From 305314d0dd52d8a59c804c758dcd3a107d7d6ef1 Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Wed, 26 Sep 2012 11:53:53 +0300
Subject: [PATCH 082/162] fmd: FMD17.2 integration

Added modifications introduced by FMD17.2 integration.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Signed-off-by: Stefan Szabo <szbs001@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       |  363 ++++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       |  938 ++++++++---------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    |  875 ++++++++--------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |  396 +++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     |  104 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |   34 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h      |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    | 1106 ++++++++++----------
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |    2 -
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |  190 ++--
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |    4 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |  101 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |  134 ++-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c   |    4 +-
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      |    5 +
 16 files changed, 2171 insertions(+), 2089 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 2fd16d9..ae26fc2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -84,7 +84,7 @@ static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
 
     intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
 
-    if (add)
+    if(add)
         p_CcNode->owners++;
     else
     {
@@ -372,7 +372,7 @@ static t_Error FmPcdCcAllocAndFillAdForContLookupManip(t_Handle h_CcNode)
 
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
-        if (!p_CcNode->h_Ad)
+        if(!p_CcNode->h_Ad)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
 
         IOMemSet32(p_CcNode->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
@@ -409,92 +409,92 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_Fm
     uint8_t             relativeSchemeId, physicalSchemeId;
     t_CcNodeInformation ccNodeInfo;
 
-     for (i = 0; i < numOfEntries; i++)
+     for(i = 0; i < numOfEntries; i++)
      {
-        if (i == 0)
+        if(i == 0)
             h_AdTmp = PTR_MOVE(h_AdTmp, i*FM_PCD_CC_AD_ENTRY_SIZE);
         else
             h_AdTmp = PTR_MOVE(h_AdTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        switch (p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.nextEngine)
+        switch(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.nextEngine)
         {
-            case (e_FM_PCD_CC):
-                if (requiredAction)
+            case(e_FM_PCD_CC):
+                if(requiredAction)
                 {
                     p_CcNode = p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
                     ASSERT_COND(p_CcNode);
-                    if (p_CcNode->shadowAction == requiredAction)
+                    if(p_CcNode->shadowAction == requiredAction)
                         break;
-                    if ((requiredAction & UPDATE_CC_WITH_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
+                    if((requiredAction & UPDATE_CC_WITH_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
                     {
 
                         ASSERT_COND(LIST_NumOfObjs(&p_CcNode->ccTreesLst) == 0);
-                        if (p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE)
+                        if(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE)
                             p_CcNode->shadowAction &= ~UPDATE_CC_WITH_DELETE_TREE;
                         memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                         ccNodeInfo.h_CcNode = h_Tree;
                         EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst, &ccNodeInfo, NULL);
                         p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_TREE;
                     }
-                    if ((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
+                    if((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
                     {
                         ASSERT_COND(LIST_NumOfObjs(&p_CcNode->ccTreesLst) == 1);
-                        if (p_CcNode->shadowAction & UPDATE_CC_WITH_TREE)
+                        if(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE)
                             p_CcNode->shadowAction &= ~UPDATE_CC_WITH_TREE;
                         DequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst, h_Tree, NULL);
                         p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_DELETE_TREE;
                     }
-                    if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
+                    if(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
                         tmp  = (uint8_t)(p_CcNode->numOfKeys + 1);
                     else
                         tmp = p_CcNode->numOfKeys;
                     err = FmPcdCcSetRequiredAction(h_FmPcd, requiredAction, p_CcNode->keyAndNextEngineParams, p_CcNode->h_AdTable, tmp, h_Tree);
-                    if (err != E_OK)
+                    if(err != E_OK)
                         return err;
                     p_CcNode->shadowAction |= requiredAction;
                 }
                 break;
 
-            case (e_FM_PCD_KG):
-                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+            case(e_FM_PCD_KG):
+                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     physicalSchemeId = FmPcdKgGetSchemeId(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme);
                     relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, physicalSchemeId);
-                    if (relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
                     if (!FmPcdKgIsSchemeValidSw(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme))
                          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
-                    if (!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
+                    if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this action scheme has to be direct."));
                     err = FmPcdKgCcGetSetParams(h_FmPcd, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme, requiredAction, 0);
-                    if (err != E_OK)
+                    if(err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
                 }
                 break;
 
-            case (e_FM_PCD_PLCR):
-                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+            case(e_FM_PCD_PLCR):
+                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
-                    if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
+                    if(!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
                         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
-                    if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
+                    if(!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
                         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
                     err =  FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd, e_FM_PCD_PLCR_SHARED, NULL, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
-                    if (err!= E_OK)
+                    if(err!= E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId, requiredAction);
-                    if (err != E_OK)
+                    if(err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
                 }
                 break;
 
-            case (e_FM_PCD_DONE):
-                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+            case(e_FM_PCD_DONE):
+                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     tmpReg32 = GET_UINT32(p_AdTmp->nia);
-                    if ((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)) != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
+                    if((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)) != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine was previously assigned not as PCD_DONE"));
                     tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
                     WRITE_UINT32(p_AdTmp->nia, tmpReg32);
@@ -559,7 +559,7 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
                                          &ccNodeInfo,
                                          p_FmPcdCcNextNode->h_Spinlock);
         }
-        if (p_AdditionalParams->h_ManipForAdd)
+        if(p_AdditionalParams->h_ManipForAdd)
         {
             p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForAdd),
                                                              p_AdditionalParams->h_CurrentNode,
@@ -635,7 +635,7 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
 
         UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
 
-        if (p_AdditionalParams->h_ManipForRmv)
+        if(p_AdditionalParams->h_ManipForRmv)
         {
              p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForRmv),
                                                              p_AdditionalParams->h_CurrentNode,
@@ -704,8 +704,7 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
            as it maybe used to retrieve keys statistics */
         intFlags = XX_LockIntrSpinlock(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_Spinlock);
 
-        if (p_AdditionalParams->numOfKeys)
-            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->numOfKeys = p_AdditionalParams->numOfKeys;
+        ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->numOfKeys = p_AdditionalParams->numOfKeys;
 
         memcpy(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
                 &p_AdditionalParams->keyAndNextEngineParams,
@@ -734,7 +733,7 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     t_FmPcdCcNode   *p_FmPcdCcNodeTmp;
 
     p_FmPcdCcNodeTmp = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
-    if (!p_FmPcdCcNodeTmp)
+    if(!p_FmPcdCcNodeTmp)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcNodeTmp"));
         return NULL;
@@ -951,9 +950,9 @@ static bool FmPcdCcIsCapwapApplSpecific(t_Handle h_Node)
 
     ASSERT_COND(h_Node);
     /* assumption that this function called only for INDEXED_FLOW_ID - so no miss*/
-    for (i = 0; i < p_CcNode->numOfKeys; i++)
+    for(i = 0; i < p_CcNode->numOfKeys; i++)
     {
-        if ( p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip &&
+        if( p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip &&
             FmPcdManipIsCapwapApplSpecific(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip))
         {
             isManipForCapwapApplSpecificBuild = TRUE;
@@ -1013,7 +1012,7 @@ static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
                 p_CcNode = p_CcKeyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
                 ASSERT_COND(p_CcNode);
 
-                if (p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
+                if(p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
                 {
                     err = FmPcdManipUpdate(h_FmPcd,
                                            NULL,
@@ -1073,23 +1072,23 @@ static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
 {
     switch (p_CcNodeParam->extractCcParams.extractNonHdr.action)
     {
-        case (e_FM_PCD_ACTION_EXACT_MATCH):
-            switch (p_CcNodeParam->extractCcParams.extractNonHdr.src)
+        case(e_FM_PCD_ACTION_EXACT_MATCH):
+            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
             {
-                case (e_FM_PCD_EXTRACT_FROM_KEY):
+                case(e_FM_PCD_EXTRACT_FROM_KEY):
                     return CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH;
-                case (e_FM_PCD_EXTRACT_FROM_HASH):
+                case(e_FM_PCD_EXTRACT_FROM_HASH):
                     return CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH;
                 default:
                     return CC_PRIVATE_INFO_NONE;
             }
 
-        case (e_FM_PCD_ACTION_INDEXED_LOOKUP):
-            switch (p_CcNodeParam->extractCcParams.extractNonHdr.src)
+        case(e_FM_PCD_ACTION_INDEXED_LOOKUP):
+            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
             {
-                case (e_FM_PCD_EXTRACT_FROM_HASH):
+                case(e_FM_PCD_EXTRACT_FROM_HASH):
                     return CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP;
-                case (e_FM_PCD_EXTRACT_FROM_FLOW_ID):
+                case(e_FM_PCD_EXTRACT_FROM_FLOW_ID):
                     return CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP;
                 default:
                   return  CC_PRIVATE_INFO_NONE;
@@ -1119,7 +1118,7 @@ void ReleaseLst(t_List *p_List)
 {
     t_CcNodeInformation   *p_CcNodeInfo = NULL;
 
-    if (!LIST_IsEmpty(p_List))
+    if(!LIST_IsEmpty(p_List))
     {
         p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
         while (p_CcNodeInfo)
@@ -1200,9 +1199,9 @@ static void DeleteNode(t_FmPcdCcNode *p_CcNode)
 
 static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
 {
-    if (p_FmPcdTree)
+    if(p_FmPcdTree)
     {
-        if (p_FmPcdTree->ccTreeBaseAddr)
+        if(p_FmPcdTree->ccTreeBaseAddr)
         {
             FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), UINT_TO_PTR(p_FmPcdTree->ccTreeBaseAddr));
             p_FmPcdTree->ccTreeBaseAddr = 0;
@@ -1216,25 +1215,25 @@ static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
 
 static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCcSize)
 {
-    if ((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
+    if((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
         *parseCodeCcSize = 1;
-    else if (parseCodeRealSize == 2)
+    else if(parseCodeRealSize == 2)
         *parseCodeCcSize = 2;
-    else if ((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
+    else if((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
         *parseCodeCcSize = 4;
-    else if ((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
+    else if((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
         *parseCodeCcSize = 8;
-    else if ((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
+    else if((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
         *parseCodeCcSize = 16;
-    else if ((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
+    else if((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
         *parseCodeCcSize = 24;
-    else if ((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
+    else if((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
         *parseCodeCcSize = 32;
-    else if ((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
+    else if((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
         *parseCodeCcSize = 40;
-    else if ((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
+    else if((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
         *parseCodeCcSize = 48;
-    else if ((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
+    else if((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
         *parseCodeCcSize = 56;
     else
         *parseCodeCcSize = 0;
@@ -1345,12 +1344,7 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             {
                 case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
                    *parseCodeRealSize = 4;
-#ifdef FM_EXP_FEATURES
-                   if ((field.ipv6 == NET_HEADER_FIELD_IPv6_TC) &&
-                     ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1)) )
-                        *parseCodeRealSize = 1;
-#endif /*FM_EXP_FEATURES*/
-                    break;
+                   break;
 
                 case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
                 case (NET_HEADER_FIELD_IPv6_HOP_LIMIT):
@@ -1372,7 +1366,7 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
         case (HEADER_TYPE_GRE):
             switch (field.gre)
             {
-                case (NET_HEADER_FIELD_GRE_TYPE):
+                case( NET_HEADER_FIELD_GRE_TYPE):
                    *parseCodeRealSize = 2;
                     break;
 
@@ -1384,7 +1378,7 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_MINENCAP):
-            switch (field.minencap)
+            switch(field.minencap)
             {
                 case (NET_HEADER_FIELD_MINENCAP_TYPE):
                    *parseCodeRealSize = 1;
@@ -1493,7 +1487,7 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("CC Node may point only to a scheme that is always direct."));
             break;
 
-        case (e_FM_PCD_PLCR):
+        case(e_FM_PCD_PLCR):
             if (p_FmPcdCcNextEngineParams->params.plcrParams.overrideParams)
             {
                 /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
@@ -1513,7 +1507,7 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
                 {
                 }
                 /* TODO - add check according to the revision of the chip.
-                if (!p_FmPcdCcNextEngineParams->params.plcrParams.newFqid ||
+                if(!p_FmPcdCcNextEngineParams->params.plcrParams.newFqid ||
                    (p_FmPcdCcNextEngineParams->params.plcrParams.newFqid & ~0x00FFFFFF))
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("newFqid  must be between 1 and 2^24-1"));
                 */
@@ -1605,27 +1599,27 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                                      t_FmPcdFields      field)
 {
 
-    switch (hdr)
-    {
-        case (HEADER_TYPE_NONE):
-            ASSERT_COND(FALSE);
-            return CC_PC_ILLEGAL;
+      switch (hdr)
+        {
+            case(HEADER_TYPE_NONE):
+                ASSERT_COND(FALSE);
+                return CC_PC_ILLEGAL;
 
-        case (HEADER_TYPE_ETH):
-            switch (field.eth)
-            {
-                case (NET_HEADER_FIELD_ETH_DA):
-                    return CC_PC_FF_MACDST;
-                case (NET_HEADER_FIELD_ETH_SA):
-                    return CC_PC_FF_MACSRC;
-                case (NET_HEADER_FIELD_ETH_TYPE):
-                    return CC_PC_FF_ETYPE;
-                default:
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                    return CC_PC_ILLEGAL;
-            }
+       case (HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_DA):
+                        return CC_PC_FF_MACDST;
+                    case(NET_HEADER_FIELD_ETH_SA):
+                         return CC_PC_FF_MACSRC;
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                         return CC_PC_FF_ETYPE;
+                    default:
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return CC_PC_ILLEGAL;
+                }
 
-        case (HEADER_TYPE_VLAN):
+         case (HEADER_TYPE_VLAN):
             switch (field.vlan)
             {
                 case (NET_HEADER_FIELD_VLAN_TCI):
@@ -1637,8 +1631,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
 
                 default:
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                    return CC_PC_ILLEGAL;
+                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                        return CC_PC_ILLEGAL;
             }
 
         case (HEADER_TYPE_MPLS):
@@ -1652,10 +1646,10 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
                     return CC_PC_ILLEGAL;
 
-                default:
+               default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-            }
+             }
 
         case (HEADER_TYPE_IPv4):
             switch (field.ipv4)
@@ -1677,9 +1671,9 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
 
                 case (NET_HEADER_FIELD_IPv4_PROTO):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4PTYPE1;
-                    if (index == e_FM_PCD_HDR_INDEX_2)
+                    if(index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
@@ -1709,14 +1703,10 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
             }
 
         case (HEADER_TYPE_IPv6):
-            switch (field.ipv6)
+             switch (field.ipv6)
             {
                 case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
                     if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
-#ifdef FM_EXP_FEATURES
-                    if (field.ipv6 == NET_HEADER_FIELD_IPv6_TC)
-                        return CC_PC_FF_IPTOS1;
-#endif /*FM_EXP_FEATURES*/
                         return CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2;
@@ -1728,7 +1718,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                         return CC_PC_FF_IPV6PTYPE1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6PTYPE2;
-                    if (index == e_FM_PCD_HDR_INDEX_LAST)
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
                         return CC_PC_FF_IPPID;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return CC_PC_ILLEGAL;
@@ -1766,7 +1756,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-            }
+           }
         case (HEADER_TYPE_MINENCAP):
             switch (field.minencap)
             {
@@ -1785,7 +1775,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-            }
+           }
 
         case (HEADER_TYPE_TCP):
             switch (field.tcp)
@@ -1832,7 +1822,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
             }
 
-        default:
+         default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
             return CC_PC_ILLEGAL;
     }
@@ -1877,15 +1867,15 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
             *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
             break;
 
-        case (HEADER_TYPE_PPPoE):
+        case(HEADER_TYPE_PPPoE):
             *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
             break;
 
         case (HEADER_TYPE_MPLS):
             if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                    *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
             else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                    *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
             else
             {
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
@@ -1906,27 +1896,27 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
             }
             break;
 
-        case (HEADER_TYPE_MINENCAP):
+        case(HEADER_TYPE_MINENCAP):
             *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
             break;
 
-        case (HEADER_TYPE_GRE):
+        case(HEADER_TYPE_GRE):
             *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
             break;
 
-        case (HEADER_TYPE_TCP):
-        case (HEADER_TYPE_UDP):
-        case (HEADER_TYPE_IPSEC_AH):
-        case (HEADER_TYPE_IPSEC_ESP):
-        case (HEADER_TYPE_DCCP):
-        case (HEADER_TYPE_SCTP):
+        case(HEADER_TYPE_TCP):
+        case(HEADER_TYPE_UDP):
+        case(HEADER_TYPE_IPSEC_AH):
+        case(HEADER_TYPE_IPSEC_ESP):
+        case(HEADER_TYPE_DCCP):
+        case(HEADER_TYPE_SCTP):
             *parseArrayOffset = CC_PC_PR_L4_OFFSET;
             break;
 
         default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header for this type of operation"));
             return CC_PC_ILLEGAL;
-    }
+     }
 
     if (offsetRelevant)
         return CC_PR_OFFSET;
@@ -1948,7 +1938,7 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
     switch (hdr)
     {
         case (HEADER_TYPE_NONE):
-            ASSERT_COND(FALSE);
+                ASSERT_COND(FALSE);
         case (HEADER_TYPE_ETH):
             switch (field.eth)
             {
@@ -2064,7 +2054,7 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
                        tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                        tmp |= p_CcNextEngineParams->params.enqueueParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                       tmp |= (p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
+                       tmp |= (p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK)<< FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                     }
                     else
@@ -2120,7 +2110,7 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
 
                     tmp |= p_CcNextEngineParams->params.plcrParams.newFqid;
 #if (DPAA_VERSION >= 11)
-                    tmp |= (p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK) << FM_PCD_AD_RESULT_VSP_SHIFT;
+                    tmp |= (p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId & FM_PCD_AD_RESULT_VSP_MASK)<< FM_PCD_AD_RESULT_VSP_SHIFT;
 #endif /* (DPAA_VERSION >= 11) */
                     WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
                 }
@@ -2179,11 +2169,11 @@ void NextStepAd(t_Handle                     h_Ad,
                 t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
                 t_FmPcd                      *p_FmPcd)
 {
-    switch (p_FmPcdCcNextEngineParams->nextEngine)
+    switch(p_FmPcdCcNextEngineParams->nextEngine)
     {
-        case (e_FM_PCD_KG):
-        case (e_FM_PCD_PLCR):
-        case (e_FM_PCD_DONE):
+        case(e_FM_PCD_KG):
+        case(e_FM_PCD_PLCR):
+        case(e_FM_PCD_DONE):
             /* if NIA is not CC, create a "result" type AD */
             FillAdOfTypeResult(h_Ad,
                                h_StatsAd,
@@ -2193,7 +2183,7 @@ void NextStepAd(t_Handle                     h_Ad,
                                p_FmPcdCcNextEngineParams);
             break;
 #if (DPAA_VERSION >= 11)
-        case (e_FM_PCD_FR):
+        case(e_FM_PCD_FR):
             if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
             {
                 FillAdOfTypeContLookup(h_Ad,
@@ -2210,7 +2200,7 @@ void NextStepAd(t_Handle                     h_Ad,
             break;
 #endif /* (DPAA_VERSION >= 11) */
 
-        case (e_FM_PCD_CC):
+        case(e_FM_PCD_CC):
             /* if NIA is not CC, create a TD to continue the CC lookup */
             FillAdOfTypeContLookup(h_Ad,
                                    h_StatsAd,
@@ -2232,11 +2222,11 @@ void NextStepAd(t_Handle                     h_Ad,
 
 static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    if (p_AdditionalInfo->p_AdTableNew)
+    if(p_AdditionalInfo->p_AdTableNew)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
                          p_AdditionalInfo->p_AdTableNew);
 
-    if (p_AdditionalInfo->p_KeysMatchTableNew)
+    if(p_AdditionalInfo->p_KeysMatchTableNew)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
                          p_AdditionalInfo->p_KeysMatchTableNew);
 }
@@ -2423,7 +2413,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     err = ValidateNextEngineParams(h_FmPcd,
                                    &p_KeyParams->ccNextEngineParams,
                                    p_CcNode->statisticsMode);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     prvLclMask = p_CcNode->lclMask;
@@ -2473,10 +2463,10 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* Check that manip is legal and what requiredAction is necessary for this manip */
-    if (p_KeyParams->ccNextEngineParams.h_Manip)
+    if(p_KeyParams->ccNextEngineParams.h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams,&requiredAction);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
@@ -2529,7 +2519,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
             /* Update mask for the received new key */
             if (p_CcNode->lclMask)
             {
-                if (p_KeyParams->p_Mask)
+                if(p_KeyParams->p_Mask)
                 {
                     Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
@@ -2696,7 +2686,7 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNod
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*update new Ad and new Key Table according to new requirement*/
-    for (i = 0, j = 0; j < p_CcNode->numOfKeys; i++, j++)
+    for (i=0, j=0; j<p_CcNode->numOfKeys; i++, j++)
     {
         if (j == keyIndex)
         {
@@ -2786,7 +2776,7 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNod
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*fill the New AdTable and New KeyTable*/
-    for (j = 0, i = 0; j < p_AdditionalInfo->numOfKeys; j++, i++)
+    for (j=0, i=0; j<p_AdditionalInfo->numOfKeys; j++, i++)
     {
         p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
         p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
@@ -2935,6 +2925,8 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (!p_AdditionalInfo->tree)
     {
         p_FmPcdCcNode1 = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
+        p_AdditionalInfo->numOfKeys =  p_FmPcdCcNode1->numOfKeys;
+
         p_Ad = p_FmPcdCcNode1->h_AdTable;
 
         if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
@@ -3034,7 +3026,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (!p_AdditionalInfo->tree)
     {
         ASSERT_COND(p_FmPcdCcNode1);
-        if (!LIST_IsEmpty(&p_FmPcdCcNode1->ccTreesLst))
+        if(!LIST_IsEmpty(&p_FmPcdCcNode1->ccTreesLst))
         {
             LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode1->ccTreesLst)
             {
@@ -3139,11 +3131,11 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
         ASSERT_COND(p_NodePtrOnCurrentMdfNode);
 
         /* Search in the previous node which exact index points on this current modified node for getting AD */
-        for (i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
+        for(i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
         {
-            if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if(p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if(p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
                 {
                     if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
                         p_AdTablePtOnCrntCurrentMdfNode = p_CrntMdfNode->h_Ad;
@@ -3187,11 +3179,11 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
         ASSERT_COND(p_TreePtrOnCurrentMdfNode);
 
         /*search in the trees which exact index points on this current modified node for getting AD */
-        for (i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
+        for(i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
         {
-            if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if(p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if(p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
                 {
                     p_AdTableTmp = UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
@@ -3247,7 +3239,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
             return NULL;
         }
 
-        if (!LIST_NumOfObjs(&p_CcNode->ccTreesLst) ||
+        if(!LIST_NumOfObjs(&p_CcNode->ccTreesLst) ||
            (LIST_NumOfObjs(&p_CcNode->ccTreesLst) != 1))
         {
             XX_Free(p_KeyAndNextEngineParams);
@@ -3259,9 +3251,9 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
                p_CcNode->keyAndNextEngineParams,
                256 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
-        if (ttlCheck)
+        if(ttlCheck)
         {
-            if ((p_CcNode->parseCode == CC_PC_FF_IPV4TTL) ||
+            if((p_CcNode->parseCode == CC_PC_FF_IPV4TTL) ||
                (p_CcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT))
             {
                 XX_Free(p_KeyAndNextEngineParams);
@@ -3270,9 +3262,9 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
             }
         }
 
-        if (hashCheck)
+        if(hashCheck)
         {
-            if (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+            if(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
                 XX_Free(p_KeyAndNextEngineParams);
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_GENERIC_IC_HASH_INDEXED can not be used for this operation"));
@@ -3291,7 +3283,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
 
     p_FmPcdModifyCcKeyAdditionalParams =
         (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
-    if (!p_FmPcdModifyCcKeyAdditionalParams)
+    if(!p_FmPcdModifyCcKeyAdditionalParams)
     {
         XX_Free(p_KeyAndNextEngineParams);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of internal data structure FAILED"));
@@ -3304,11 +3296,11 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
 
     while(i < numOfKeys)
     {
-        if ((j == keyIndex) && !wasUpdate)
+        if((j == keyIndex) && !wasUpdate)
         {
-            if (modifyState == e_MODIFY_STATE_ADD)
+            if(modifyState == e_MODIFY_STATE_ADD)
                 j++;
-            else if (modifyState == e_MODIFY_STATE_REMOVE)
+            else if(modifyState == e_MODIFY_STATE_REMOVE)
                 i++;
             wasUpdate = TRUE;
         }
@@ -3326,7 +3318,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
     {
         if (modifyState == e_MODIFY_STATE_ADD)
             j++;
-        else if (modifyState == e_MODIFY_STATE_REMOVE)
+        else if(modifyState == e_MODIFY_STATE_REMOVE)
             i++;
     }
 
@@ -3349,10 +3341,10 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode
     t_Handle                    h_NewAd;
 
     /* Building a list of all action descriptors that point to the previous node */
-    if (!LIST_IsEmpty(&p_CcNode->ccPrevNodesLst))
+    if(!LIST_IsEmpty(&p_CcNode->ccPrevNodesLst))
         UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
 
-    if (!LIST_IsEmpty(&p_CcNode->ccTreeIdLst))
+    if(!LIST_IsEmpty(&p_CcNode->ccTreeIdLst))
         UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
 
     /* This node must be found as next engine of one of its previous nodes or trees*/
@@ -3360,7 +3352,7 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode
 
     /* Building a new action descriptor that points to the modified node */
     h_NewAd = GetNewAd(p_CcNode, FALSE);
-    if (!h_NewAd)
+    if(!h_NewAd)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
     IOMemSet32(h_NewAd, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -3426,7 +3418,7 @@ static t_Error ValidateAndCalcStatsParams(e_FmPcdCcStatsMode   statisticsMode,
             *p_CountersArraySize = 2 * FM_PCD_CC_STATS_COUNTER_SIZE;
             return E_OK;
 
-#ifdef FM_EXP_FEATURES
+#if (DPAA_VERSION >= 11)
         case e_FM_PCD_CC_STATS_MODE_RMON:
             {
                 uint16_t    *p_FrameLengthRanges = p_CcNodeParam->keysParams.frameLengthRanges;
@@ -3464,7 +3456,8 @@ static t_Error ValidateAndCalcStatsParams(e_FmPcdCcStatsMode   statisticsMode,
                 *p_CountersArraySize = (*p_NumOfRanges + 1) * FM_PCD_CC_STATS_COUNTER_SIZE;
             }
             return E_OK;
-#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
+
         default:
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Statistics mode"));
     }
@@ -3498,7 +3491,7 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
@@ -3520,13 +3513,13 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
-        if (!p_KeyParams->p_Key)
+        if(!p_KeyParams->p_Key)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_Key is not initialized"));
 
         err = ValidateNextEngineParams(h_FmPcd,
                                        &p_KeyParams->ccNextEngineParams,
                                        p_CcNode->statisticsMode);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
         err = UpdateGblMask(p_CcNode,
@@ -3722,17 +3715,17 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     err = ValidateNextEngineParams(h_FmPcd,
                                    &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
                                    p_CcNode->statisticsMode);
-    if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+    if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
         RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
 
-    for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
+    for(tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
-        if (p_KeyParams->p_Mask || p_KeyParams->p_Key)
+        if(p_KeyParams->p_Mask || p_KeyParams->p_Key)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
 
-        if ((glblMask & (tmp * 16)) == (tmp * 16))
+        if((glblMask & (tmp * 16)) == (tmp * 16))
         {
             err = ValidateNextEngineParams(h_FmPcd,
                                            &p_KeyParams->ccNextEngineParams,
@@ -3765,7 +3758,7 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
             err = ValidateNextEngineParams(h_FmPcd,
                                            &p_KeyParams->ccNextEngineParams,
                                            p_CcNode->statisticsMode);
-            if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+            if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
                 RETURN_ERROR(MAJOR, err, ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
         }
     }
@@ -3940,7 +3933,7 @@ static t_Error PreAllocStatsObjs(t_FmPcdCcNode *p_CcNode)
 
     /* Allocate statistics ADs and statistics counter. An extra pair (AD + counters)
        will be allocated to support runtime modifications */
-    for (i = 0; i < p_CcNode->maxNumOfKeys + 2; i++)
+    for (i=0; i<p_CcNode->maxNumOfKeys+2; i++)
     {
         /* Allocate list object structure */
         p_StatsObj = XX_Malloc(sizeof(t_FmPcdStatsObj));
@@ -4013,9 +4006,9 @@ static t_Error MatchTableGetKeyStatistics(t_FmPcdCcNode           *p_CcNode,
 
         p_KeyStatistics->frameCount += GET_UINT32(*p_StatsCounters);
 
-#ifdef FM_EXP_FEATURES
+#if (DPAA_VERSION >= 11)
         p_KeyStatistics->frameLengthRangeCount[i-1] = GET_UINT32(*p_StatsCounters);
-#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
     }
 
     return E_OK;
@@ -4040,7 +4033,7 @@ t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info,
 
         ASSERT_COND(p_CcInformation->h_CcNode);
 
-        if (p_CcInformation->h_CcNode == h_Info)
+        if(p_CcInformation->h_CcNode == h_Info)
         {
             XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
             return p_CcInformation;
@@ -4304,7 +4297,7 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
 
     p_ModifyKeyParams->tree = TRUE;
 
-    if (p_FmPcd->p_CcShadow)
+    if(p_FmPcd->p_CcShadow)
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
             return ERROR_CODE(E_BUSY);
 
@@ -4315,7 +4308,7 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
                                        &h_OldPointersLst,
                                        &h_NewPointersLst,
                                        p_ModifyKeyParams);
-    if (err)
+    if(err)
     {
         XX_Free(p_ModifyKeyParams);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -4751,7 +4744,7 @@ t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_G
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
 
-    if (grpId >= p_FmPcdCcTree->numOfGrps)
+    if(grpId >= p_FmPcdCcTree->numOfGrps)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
 
     *p_GrpBits = p_FmPcdCcTree->fmPcdGroupParam[grpId].totalBitsMask;
@@ -4997,7 +4990,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     }
 
     p_FmPcdCcTree = (t_FmPcdCcTree*)XX_Malloc(sizeof(t_FmPcdCcTree));
-    if (!p_FmPcdCcTree)
+    if(!p_FmPcdCcTree)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("PCD tree structure"));
         return NULL;
@@ -5018,7 +5011,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         FmPcdCcIsCapwapApplSpecific(p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode))
     {
         p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip = FmPcdManipApplSpecificBuild();
-        if (!p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip)
+        if(!p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip)
         {
             DeleteTree(p_FmPcdCcTree,p_FmPcd);
             XX_Free(p_Params);
@@ -5057,7 +5050,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
         if (lastOne)
         {
-            if (p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
+            if(p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
             {
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
                 XX_Free(p_Params);
@@ -5154,7 +5147,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
     j = 0;
-    for (i = 0; i < numOfEntries; i++)
+    for(i = 0; i < numOfEntries; i++)
     {
         p_KeyAndNextEngineParams = p_Params+i;
 
@@ -5171,14 +5164,14 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
                p_KeyAndNextEngineParams,
                sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
-        if (p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
+        if(p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
             p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,
                                                         (t_Handle)p_FmPcdCcTree,
                                                         p_FmPcdCcNextNode->h_Spinlock);
 
-            if (!p_CcInformation)
+            if(!p_CcInformation)
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                 ccNodeInfo.h_CcNode = (t_Handle)p_FmPcdCcTree;
@@ -5203,13 +5196,13 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
          return NULL;
     }
 
-    for (i = 0; i < numOfEntries; i++)
+    for(i = 0; i < numOfEntries; i++)
     {
-        if (p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
+        if(p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
         {
             err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction,
                                             &p_FmPcdCcTree->keyAndNextEngineParams[i], p_CcTreeTmp,1, p_FmPcdCcTree);
-            if (err)
+            if(err)
             {
                 FmPcdLockUnlockAll(p_FmPcd);
                 FM_PCD_CcRootDelete(p_FmPcdCcTree);
@@ -5338,9 +5331,9 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     bool                glblMask = FALSE;
     t_FmPcdCcKeyParams  *p_KeyParams;
     t_Handle            h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
-#ifdef FM_EXP_FEATURES
+#if (DPAA_VERSION >= 11)
     t_Handle            h_StatsFLRs;
-#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
     bool                fullField = FALSE;
     ccPrivateInfo_t     icCode = CC_PRIVATE_INFO_NONE;
     bool                isKeyTblAlloc, fromIc = FALSE;
@@ -5629,7 +5622,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
                                                      FM_PCD_CC_AD_ENTRY_SIZE,
                                                      FM_PCD_CC_AD_TABLE_ALIGN);
-        if (!p_CcNode->h_Ad)
+        if(!p_CcNode->h_Ad)
         {
             DeleteNode(p_CcNode);
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
@@ -5642,7 +5635,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         adTableSize    = (uint32_t)(FM_PCD_CC_AD_ENTRY_SIZE * (p_CcNode->numOfKeys + 1));
     }
 
-#ifdef FM_EXP_FEATURES
+#if (DPAA_VERSION >= 11)
     /* If RMON statistics mode requested, allocate frame length ranges array */
     if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
     {
@@ -5671,7 +5664,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     }
 #else
     p_CcNode->h_StatsFLRs = NULL;
-#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
 
     /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
        identification, IPv6 hop count identification, etc. */
@@ -5818,7 +5811,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             }
             else // TODO - think about Spinlock around ++
                 p_CcInformation->index++;
-            if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+            if(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
             {
                 h_Manip = p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
                 p_CcInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
@@ -5835,9 +5828,9 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             }
             else
                 p_CcInformation->index++;
-            }
         }
     }
+    }
 
     p_AdTableTmp = p_CcNode->h_AdTable;
 
@@ -6577,14 +6570,14 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         return NULL;
     }
 
-#ifdef FM_EXP_FEATURES
+#if (DPAA_VERSION >= 11)
     if (p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
     {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE,
                      ("RMON statistics mode currently not supported for hash table"));
         return NULL;
     }
-#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
 
     p_ExactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
     if (!p_ExactMatchCcNodeParam)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index 71484e8..c74aa1c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -104,59 +104,59 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
 {
     int i;
 
-    switch (code)
+    switch(code)
     {
-        case (KG_SCH_GEN_PARSE_RESULT_N_FQID):
-        case (KG_SCH_GEN_DEFAULT):
-        case (KG_SCH_GEN_NEXTHDR):
-            for (i = 0; i < numOfSwDefaults; i++)
-                if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
+        case( KG_SCH_GEN_PARSE_RESULT_N_FQID):
+        case( KG_SCH_GEN_DEFAULT):
+        case( KG_SCH_GEN_NEXTHDR):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
                     return swDefaults[i].dfltSelect;
             ASSERT_COND(FALSE);
-        case (KG_SCH_GEN_SHIM1):
-        case (KG_SCH_GEN_SHIM2):
-        case (KG_SCH_GEN_IP_PID_NO_V):
-        case (KG_SCH_GEN_ETH_NO_V):
-        case (KG_SCH_GEN_SNAP_NO_V):
-        case (KG_SCH_GEN_VLAN1_NO_V):
-        case (KG_SCH_GEN_VLAN2_NO_V):
-        case (KG_SCH_GEN_ETH_TYPE_NO_V):
-        case (KG_SCH_GEN_PPP_NO_V):
-        case (KG_SCH_GEN_MPLS1_NO_V):
-        case (KG_SCH_GEN_MPLS_LAST_NO_V):
-        case (KG_SCH_GEN_L3_NO_V):
-        case (KG_SCH_GEN_IP2_NO_V):
-        case (KG_SCH_GEN_GRE_NO_V):
-        case (KG_SCH_GEN_L4_NO_V):
-            for (i = 0; i < numOfSwDefaults; i++)
-                if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
+        case( KG_SCH_GEN_SHIM1):
+        case( KG_SCH_GEN_SHIM2):
+        case( KG_SCH_GEN_IP_PID_NO_V):
+        case( KG_SCH_GEN_ETH_NO_V):
+        case( KG_SCH_GEN_SNAP_NO_V):
+        case( KG_SCH_GEN_VLAN1_NO_V):
+        case( KG_SCH_GEN_VLAN2_NO_V):
+        case( KG_SCH_GEN_ETH_TYPE_NO_V):
+        case( KG_SCH_GEN_PPP_NO_V):
+        case( KG_SCH_GEN_MPLS1_NO_V):
+        case( KG_SCH_GEN_MPLS_LAST_NO_V):
+        case( KG_SCH_GEN_L3_NO_V):
+        case( KG_SCH_GEN_IP2_NO_V):
+        case( KG_SCH_GEN_GRE_NO_V):
+        case( KG_SCH_GEN_L4_NO_V):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
                     return swDefaults[i].dfltSelect;
 
-        case (KG_SCH_GEN_START_OF_FRM):
-        case (KG_SCH_GEN_ETH):
-        case (KG_SCH_GEN_SNAP):
-        case (KG_SCH_GEN_VLAN1):
-        case (KG_SCH_GEN_VLAN2):
-        case (KG_SCH_GEN_ETH_TYPE):
-        case (KG_SCH_GEN_PPP):
-        case (KG_SCH_GEN_MPLS1):
-        case (KG_SCH_GEN_MPLS2):
-        case (KG_SCH_GEN_MPLS3):
-        case (KG_SCH_GEN_MPLS_LAST):
-        case (KG_SCH_GEN_IPV4):
-        case (KG_SCH_GEN_IPV6):
-        case (KG_SCH_GEN_IPV4_TUNNELED):
-        case (KG_SCH_GEN_IPV6_TUNNELED):
-        case (KG_SCH_GEN_MIN_ENCAP):
-        case (KG_SCH_GEN_GRE):
-        case (KG_SCH_GEN_TCP):
-        case (KG_SCH_GEN_UDP):
-        case (KG_SCH_GEN_IPSEC_AH):
-        case (KG_SCH_GEN_SCTP):
-        case (KG_SCH_GEN_DCCP):
-        case (KG_SCH_GEN_IPSEC_ESP):
-            for (i = 0; i < numOfSwDefaults; i++)
-                if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
+        case( KG_SCH_GEN_START_OF_FRM):
+        case( KG_SCH_GEN_ETH):
+        case( KG_SCH_GEN_SNAP):
+        case( KG_SCH_GEN_VLAN1):
+        case( KG_SCH_GEN_VLAN2):
+        case( KG_SCH_GEN_ETH_TYPE):
+        case( KG_SCH_GEN_PPP):
+        case( KG_SCH_GEN_MPLS1):
+        case( KG_SCH_GEN_MPLS2):
+        case( KG_SCH_GEN_MPLS3):
+        case( KG_SCH_GEN_MPLS_LAST):
+        case( KG_SCH_GEN_IPV4):
+        case( KG_SCH_GEN_IPV6):
+        case( KG_SCH_GEN_IPV4_TUNNELED):
+        case( KG_SCH_GEN_IPV6_TUNNELED):
+        case( KG_SCH_GEN_MIN_ENCAP):
+        case( KG_SCH_GEN_GRE):
+        case( KG_SCH_GEN_TCP):
+        case( KG_SCH_GEN_UDP):
+        case( KG_SCH_GEN_IPSEC_AH):
+        case( KG_SCH_GEN_SCTP):
+        case( KG_SCH_GEN_DCCP):
+        case( KG_SCH_GEN_IPSEC_ESP):
+            for(i=0 ; i<numOfSwDefaults ; i++)
+                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
                     return swDefaults[i].dfltSelect;
         default:
             return e_FM_PCD_KG_DFLT_ILLEGAL;
@@ -167,18 +167,18 @@ static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
 {
     *p_Offset = 0;
 
-    switch (src)
+    switch(src)
     {
-        case (e_FM_PCD_EXTRACT_FROM_FRAME_START):
+        case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
             return KG_SCH_GEN_START_OF_FRM;
-        case (e_FM_PCD_EXTRACT_FROM_DFLT_VALUE):
+        case(e_FM_PCD_EXTRACT_FROM_DFLT_VALUE):
             return KG_SCH_GEN_DEFAULT;
-        case (e_FM_PCD_EXTRACT_FROM_PARSE_RESULT):
+        case(e_FM_PCD_EXTRACT_FROM_PARSE_RESULT):
             return KG_SCH_GEN_PARSE_RESULT_N_FQID;
-        case (e_FM_PCD_EXTRACT_FROM_ENQ_FQID):
+        case(e_FM_PCD_EXTRACT_FROM_ENQ_FQID):
             *p_Offset = 32;
             return KG_SCH_GEN_PARSE_RESULT_N_FQID;
-        case (e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
+        case(e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
             return KG_SCH_GEN_NEXTHDR;
         default:
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
@@ -188,104 +188,104 @@ static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
 
 static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool ignoreProtocolValidation)
 {
-    if (!ignoreProtocolValidation)
-        switch (hdr)
+    if(!ignoreProtocolValidation)
+        switch(hdr)
         {
-            case (HEADER_TYPE_NONE):
+            case(HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-            case (HEADER_TYPE_ETH):
+            case(HEADER_TYPE_ETH):
                 return KG_SCH_GEN_ETH;
-            case (HEADER_TYPE_LLC_SNAP):
+            case(HEADER_TYPE_LLC_SNAP):
                 return KG_SCH_GEN_SNAP;
-            case (HEADER_TYPE_PPPoE):
+            case(HEADER_TYPE_PPPoE):
                 return KG_SCH_GEN_PPP;
-            case (HEADER_TYPE_MPLS):
-                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case(HEADER_TYPE_MPLS):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_MPLS1;
-                if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
                     return KG_SCH_GEN_MPLS2;
-                if (hdrIndex == e_FM_PCD_HDR_INDEX_3)
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_3)
                     return KG_SCH_GEN_MPLS3;
-                if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                     return KG_SCH_GEN_MPLS_LAST;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
                 return 0;
-            case (HEADER_TYPE_IPv4):
-                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case(HEADER_TYPE_IPv4):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_IPV4;
-                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IPV4_TUNNELED;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 header index"));
                 return 0;
-            case (HEADER_TYPE_IPv6):
-                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case(HEADER_TYPE_IPv6):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_IPV6;
-                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IPV6_TUNNELED;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 header index"));
                 return 0;
-            case (HEADER_TYPE_GRE):
+            case(HEADER_TYPE_GRE):
                 return KG_SCH_GEN_GRE;
-            case (HEADER_TYPE_TCP):
+            case(HEADER_TYPE_TCP):
                 return KG_SCH_GEN_TCP;
-            case (HEADER_TYPE_UDP):
+            case(HEADER_TYPE_UDP):
                 return KG_SCH_GEN_UDP;
-            case (HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_AH):
                 return KG_SCH_GEN_IPSEC_AH;
-            case (HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_IPSEC_ESP):
                 return KG_SCH_GEN_IPSEC_ESP;
-            case (HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_SCTP):
                 return KG_SCH_GEN_SCTP;
-            case (HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_DCCP):
                 return KG_SCH_GEN_DCCP;
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                 return 0;
         }
     else
-        switch (hdr)
+        switch(hdr)
         {
-            case (HEADER_TYPE_NONE):
+            case(HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-            case (HEADER_TYPE_ETH):
+            case(HEADER_TYPE_ETH):
                 return KG_SCH_GEN_ETH_NO_V;
-            case (HEADER_TYPE_LLC_SNAP):
+            case(HEADER_TYPE_LLC_SNAP):
                 return KG_SCH_GEN_SNAP_NO_V;
-            case (HEADER_TYPE_PPPoE):
+            case(HEADER_TYPE_PPPoE):
                 return KG_SCH_GEN_PPP_NO_V;
-            case (HEADER_TYPE_MPLS):
-                 if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_MPLS1_NO_V;
-                if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                     return KG_SCH_GEN_MPLS_LAST_NO_V;
-                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_3) )
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_3) )
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Indexed MPLS Extraction not supported"));
                 else
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
                 return 0;
-            case (HEADER_TYPE_IPv4):
-            case (HEADER_TYPE_IPv6):
-                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_L3_NO_V;
-                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IP2_NO_V;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
-            case (HEADER_TYPE_MINENCAP):
+            case(HEADER_TYPE_MINENCAP):
                 return KG_SCH_GEN_IP2_NO_V;
-            case (HEADER_TYPE_USER_DEFINED_L3):
+            case(HEADER_TYPE_USER_DEFINED_L3):
                 return KG_SCH_GEN_L3_NO_V;
-            case (HEADER_TYPE_GRE):
+            case(HEADER_TYPE_GRE):
                 return KG_SCH_GEN_GRE_NO_V;
-            case (HEADER_TYPE_TCP):
-            case (HEADER_TYPE_UDP):
-            case (HEADER_TYPE_IPSEC_AH):
-            case (HEADER_TYPE_IPSEC_ESP):
-            case (HEADER_TYPE_SCTP):
-            case (HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_DCCP):
                 return KG_SCH_GEN_L4_NO_V;
-            case (HEADER_TYPE_USER_DEFINED_SHIM1):
+            case(HEADER_TYPE_USER_DEFINED_SHIM1):
                 return KG_SCH_GEN_SHIM1;
-            case (HEADER_TYPE_USER_DEFINED_SHIM2):
+            case(HEADER_TYPE_USER_DEFINED_SHIM2):
                 return KG_SCH_GEN_SHIM2;
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
@@ -295,106 +295,106 @@ static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool
 static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field, bool ignoreProtocolValidation, e_FmPcdHdrIndex hdrIndex)
 {
     if (!ignoreProtocolValidation)
-        switch (hdr)
+        switch(hdr)
         {
-            case (HEADER_TYPE_NONE):
+            case(HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-            case (HEADER_TYPE_ETH):
-                switch (field.eth)
+            case(HEADER_TYPE_ETH):
+                switch(field.eth)
                 {
-                    case (NET_HEADER_FIELD_ETH_TYPE):
+                    case(NET_HEADER_FIELD_ETH_TYPE):
                         return KG_SCH_GEN_ETH_TYPE;
                     default:
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
-            case (HEADER_TYPE_VLAN):
-                switch (field.vlan)
+            case(HEADER_TYPE_VLAN):
+                switch(field.vlan)
                 {
-                    case (NET_HEADER_FIELD_VLAN_TCI):
-                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    case(NET_HEADER_FIELD_VLAN_TCI):
+                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                             return KG_SCH_GEN_VLAN1;
-                        if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                             return KG_SCH_GEN_VLAN2;
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                         return 0;
                 }
-            case (HEADER_TYPE_MPLS):
-            case (HEADER_TYPE_IPSEC_AH):
-            case (HEADER_TYPE_IPSEC_ESP):
-            case (HEADER_TYPE_LLC_SNAP):
-            case (HEADER_TYPE_PPPoE):
-            case (HEADER_TYPE_IPv4):
-            case (HEADER_TYPE_IPv6):
-            case (HEADER_TYPE_GRE):
-            case (HEADER_TYPE_MINENCAP):
-            case (HEADER_TYPE_USER_DEFINED_L3):
-            case (HEADER_TYPE_TCP):
-            case (HEADER_TYPE_UDP):
-            case (HEADER_TYPE_SCTP):
-            case (HEADER_TYPE_DCCP):
-            case (HEADER_TYPE_USER_DEFINED_L4):
+            case(HEADER_TYPE_MPLS):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_LLC_SNAP):
+            case(HEADER_TYPE_PPPoE):
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+            case(HEADER_TYPE_GRE):
+            case(HEADER_TYPE_MINENCAP):
+            case(HEADER_TYPE_USER_DEFINED_L3):
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_USER_DEFINED_L4):
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
                 return 0;
         }
         else
-            switch (hdr)
+            switch(hdr)
             {
-                case (HEADER_TYPE_NONE):
+                case(HEADER_TYPE_NONE):
                     ASSERT_COND(FALSE);
-                case (HEADER_TYPE_ETH):
-                switch (field.eth)
+                case(HEADER_TYPE_ETH):
+                switch(field.eth)
                 {
-                    case (NET_HEADER_FIELD_ETH_TYPE):
+                    case(NET_HEADER_FIELD_ETH_TYPE):
                         return KG_SCH_GEN_ETH_TYPE_NO_V;
                     default:
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
-                case (HEADER_TYPE_VLAN):
-                    switch (field.vlan)
+                case(HEADER_TYPE_VLAN):
+                    switch(field.vlan)
                     {
-                        case (NET_HEADER_FIELD_VLAN_TCI) :
-                            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        case(NET_HEADER_FIELD_VLAN_TCI) :
+                            if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                                 return KG_SCH_GEN_VLAN1_NO_V;
-                            if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                            if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                                 return KG_SCH_GEN_VLAN2_NO_V;
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                             return 0;
                     }
-                case (HEADER_TYPE_IPv4):
-                    switch (field.ipv4)
+                case(HEADER_TYPE_IPv4):
+                    switch(field.ipv4)
                     {
-                        case (NET_HEADER_FIELD_IPv4_PROTO):
+                        case(NET_HEADER_FIELD_IPv4_PROTO):
                             return KG_SCH_GEN_IP_PID_NO_V;
                         default:
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
-                case (HEADER_TYPE_IPv6):
-                   switch (field.ipv6)
+                case(HEADER_TYPE_IPv6):
+                   switch(field.ipv6)
                     {
-                        case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                        case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
                             return KG_SCH_GEN_IP_PID_NO_V;
                         default:
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
-                case (HEADER_TYPE_MPLS):
-                case (HEADER_TYPE_LLC_SNAP):
-                case (HEADER_TYPE_PPPoE):
-                case (HEADER_TYPE_GRE):
-                case (HEADER_TYPE_MINENCAP):
-                case (HEADER_TYPE_USER_DEFINED_L3):
-                case (HEADER_TYPE_TCP):
-                case (HEADER_TYPE_UDP):
-                case (HEADER_TYPE_IPSEC_AH):
-                case (HEADER_TYPE_IPSEC_ESP):
-                case (HEADER_TYPE_SCTP):
-                case (HEADER_TYPE_DCCP):
-                case (HEADER_TYPE_USER_DEFINED_L4):
+                case(HEADER_TYPE_MPLS):
+                case(HEADER_TYPE_LLC_SNAP):
+                case(HEADER_TYPE_PPPoE):
+                case(HEADER_TYPE_GRE):
+                case(HEADER_TYPE_MINENCAP):
+                case(HEADER_TYPE_USER_DEFINED_L3):
+                case(HEADER_TYPE_TCP):
+                case(HEADER_TYPE_UDP):
+                case(HEADER_TYPE_IPSEC_AH):
+                case(HEADER_TYPE_IPSEC_ESP):
+                case(HEADER_TYPE_SCTP):
+                case(HEADER_TYPE_DCCP):
+                case(HEADER_TYPE_USER_DEFINED_L4):
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
                 default:
@@ -407,39 +407,39 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
 {
     UNUSED(p_FmPcd);
 
-    switch (hdr)
+    switch(hdr)
     {
-        case (HEADER_TYPE_NONE):
+        case(HEADER_TYPE_NONE):
             ASSERT_COND(FALSE);
-        case (HEADER_TYPE_ETH):
-            switch (field.eth)
+        case(HEADER_TYPE_ETH):
+            switch(field.eth)
             {
-                case (NET_HEADER_FIELD_ETH_DA):
+                case(NET_HEADER_FIELD_ETH_DA):
                     return KG_SCH_KN_MACDST;
-                case (NET_HEADER_FIELD_ETH_SA):
+                case(NET_HEADER_FIELD_ETH_SA):
                     return KG_SCH_KN_MACSRC;
-                case (NET_HEADER_FIELD_ETH_TYPE):
+                case(NET_HEADER_FIELD_ETH_TYPE):
                     return KG_SCH_KN_ETYPE;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
            }
-        case (HEADER_TYPE_LLC_SNAP):
-            switch (field.llcSnap)
+        case(HEADER_TYPE_LLC_SNAP):
+            switch(field.llcSnap)
             {
-                case (NET_HEADER_FIELD_LLC_SNAP_TYPE):
+                case(NET_HEADER_FIELD_LLC_SNAP_TYPE):
                     return KG_SCH_KN_ETYPE;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
            }
-        case (HEADER_TYPE_VLAN):
-            switch (field.vlan)
+        case(HEADER_TYPE_VLAN):
+            switch(field.vlan)
             {
-                case (NET_HEADER_FIELD_VLAN_TCI):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_VLAN_TCI):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_TCI1;
-                    if (index == e_FM_PCD_HDR_INDEX_LAST)
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
                         return KG_SCH_KN_TCI2;
                     else
                     {
@@ -450,15 +450,15 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_MPLS):
-            switch (field.mpls)
+        case(HEADER_TYPE_MPLS):
+            switch(field.mpls)
             {
-                case (NET_HEADER_FIELD_MPLS_LABEL_STACK):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_MPLS1;
-                    if (index == e_FM_PCD_HDR_INDEX_2)
+                    if(index == e_FM_PCD_HDR_INDEX_2)
                         return KG_SCH_KN_MPLS2;
-                    if (index == e_FM_PCD_HDR_INDEX_LAST)
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
                         return KG_SCH_KN_MPLS_LAST;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
                     return 0;
@@ -466,34 +466,34 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_IPv4):
-            switch (field.ipv4)
+        case(HEADER_TYPE_IPv4):
+            switch(field.ipv4)
             {
-                case (NET_HEADER_FIELD_IPv4_SRC_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPSRC1;
-                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPSRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
-                case (NET_HEADER_FIELD_IPv4_DST_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_IPv4_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPDST1;
-                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPDST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
-                case (NET_HEADER_FIELD_IPv4_PROTO):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_IPv4_PROTO):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_PTYPE1;
-                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
-                case (NET_HEADER_FIELD_IPv4_TOS):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_IPv4_TOS):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPTOS_TC1;
-                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPTOS_TC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
@@ -501,29 +501,29 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_IPv6):
-             switch (field.ipv6)
+        case(HEADER_TYPE_IPv6):
+             switch(field.ipv6)
             {
-                case (NET_HEADER_FIELD_IPv6_SRC_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPSRC1;
-                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPSRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
-                case (NET_HEADER_FIELD_IPv6_DST_IP):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_IPv6_DST_IP):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPDST1;
-                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPDST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
-                case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_PTYPE1;
-                    if (index == e_FM_PCD_HDR_INDEX_2)
+                    if(index == e_FM_PCD_HDR_INDEX_2)
                         return KG_SCH_KN_PTYPE2;
-                    if (index == e_FM_PCD_HDR_INDEX_LAST)
+                    if(index == e_FM_PCD_HDR_INDEX_LAST)
 #ifdef FM_KG_NO_IPPID_SUPPORT
                     if (p_FmPcd->fmRevInfo.majorRev < 6)
                         return KG_SCH_KN_PTYPE2;
@@ -531,10 +531,10 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                         return KG_SCH_KN_IPPID;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
-                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
-                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return (KG_SCH_KN_IPV6FL1 | KG_SCH_KN_IPTOS_TC1);
-                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return (KG_SCH_KN_IPV6FL2 | KG_SCH_KN_IPTOS_TC2);
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
@@ -542,100 +542,100 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_GRE):
-            switch (field.gre)
+        case(HEADER_TYPE_GRE):
+            switch(field.gre)
             {
-                case (NET_HEADER_FIELD_GRE_TYPE):
+                case(NET_HEADER_FIELD_GRE_TYPE):
                     return KG_SCH_KN_GREPTYPE;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
            }
-        case (HEADER_TYPE_MINENCAP):
-            switch (field.minencap)
+        case(HEADER_TYPE_MINENCAP):
+            switch(field.minencap)
             {
-                case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
                     return KG_SCH_KN_IPSRC2;
-                case (NET_HEADER_FIELD_MINENCAP_DST_IP):
+                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
                     return KG_SCH_KN_IPDST2;
-                case (NET_HEADER_FIELD_MINENCAP_TYPE):
+                case(NET_HEADER_FIELD_MINENCAP_TYPE):
                     return KG_SCH_KN_PTYPE2;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
            }
-        case (HEADER_TYPE_TCP):
-            switch (field.tcp)
+        case(HEADER_TYPE_TCP):
+            switch(field.tcp)
             {
-                case (NET_HEADER_FIELD_TCP_PORT_SRC):
+                case(NET_HEADER_FIELD_TCP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case (NET_HEADER_FIELD_TCP_PORT_DST):
+                case(NET_HEADER_FIELD_TCP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
-                case (NET_HEADER_FIELD_TCP_FLAGS):
+                case(NET_HEADER_FIELD_TCP_FLAGS):
                     return KG_SCH_KN_TFLG;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_UDP):
-            switch (field.udp)
+        case(HEADER_TYPE_UDP):
+            switch(field.udp)
             {
-                case (NET_HEADER_FIELD_UDP_PORT_SRC):
+                case(NET_HEADER_FIELD_UDP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case (NET_HEADER_FIELD_UDP_PORT_DST):
+                case(NET_HEADER_FIELD_UDP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_IPSEC_AH):
-            switch (field.ipsecAh)
+        case(HEADER_TYPE_IPSEC_AH):
+            switch(field.ipsecAh)
             {
-                case (NET_HEADER_FIELD_IPSEC_AH_SPI):
+                case(NET_HEADER_FIELD_IPSEC_AH_SPI):
                     return KG_SCH_KN_IPSEC_SPI;
-                case (NET_HEADER_FIELD_IPSEC_AH_NH):
+                case(NET_HEADER_FIELD_IPSEC_AH_NH):
                     return KG_SCH_KN_IPSEC_NH;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_IPSEC_ESP):
-            switch (field.ipsecEsp)
+        case(HEADER_TYPE_IPSEC_ESP):
+            switch(field.ipsecEsp)
             {
-                case (NET_HEADER_FIELD_IPSEC_ESP_SPI):
+                case(NET_HEADER_FIELD_IPSEC_ESP_SPI):
                     return KG_SCH_KN_IPSEC_SPI;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_SCTP):
-            switch (field.sctp)
+        case(HEADER_TYPE_SCTP):
+            switch(field.sctp)
             {
-                case (NET_HEADER_FIELD_SCTP_PORT_SRC):
+                case(NET_HEADER_FIELD_SCTP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case (NET_HEADER_FIELD_SCTP_PORT_DST):
+                case(NET_HEADER_FIELD_SCTP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_DCCP):
-            switch (field.dccp)
+        case(HEADER_TYPE_DCCP):
+            switch(field.dccp)
             {
-                case (NET_HEADER_FIELD_DCCP_PORT_SRC):
+                case(NET_HEADER_FIELD_DCCP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case (NET_HEADER_FIELD_DCCP_PORT_DST):
+                case(NET_HEADER_FIELD_DCCP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case (HEADER_TYPE_PPPoE):
-            switch (field.pppoe)
+        case(HEADER_TYPE_PPPoE):
+            switch(field.pppoe)
             {
-                case (NET_HEADER_FIELD_PPPoE_PID):
+                case(NET_HEADER_FIELD_PPPoE_PID):
                     return KG_SCH_KN_PPPID;
-                case (NET_HEADER_FIELD_PPPoE_SID):
+                case(NET_HEADER_FIELD_PPPoE_SID):
                     return KG_SCH_KN_PPPSID;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
@@ -653,7 +653,7 @@ static uint8_t GetKnownFieldId(uint32_t bitMask)
     uint8_t cnt = 0;
 
     while (bitMask)
-        if (bitMask & 0x80000000)
+        if(bitMask & 0x80000000)
             break;
         else
         {
@@ -669,24 +669,24 @@ static uint8_t GetExtractedOrMask(uint8_t bitOffset, bool fqid)
     uint8_t i, mask, numOfOnesToClear, walking1Mask = 1;
 
     /* bitOffset 1-7 --> mask 0x1-0x7F */
-    if (bitOffset < 8)
+    if(bitOffset<8)
     {
         mask = 0;
-        for (i = 0; i < bitOffset; i++, walking1Mask <<= 1)
+        for(i = 0 ; i < bitOffset ; i++, walking1Mask <<= 1)
             mask |= walking1Mask;
     }
     else
     {
        mask = 0xFF;
        numOfOnesToClear = 0;
-       if (fqid && bitOffset>24)
+       if(fqid && bitOffset>24)
            /* bitOffset 25-31 --> mask 0xFE-0x80 */
            numOfOnesToClear = (uint8_t)(bitOffset-24);
        else
           /* bitOffset 9-15 --> mask 0xFE-0x80 */
-          if (!fqid && bitOffset>8)
+          if(!fqid && bitOffset>8)
                numOfOnesToClear = (uint8_t)(bitOffset-8);
-       for (i = 0; i < numOfOnesToClear; i++, walking1Mask <<= 1)
+       for(i = 0 ; i < numOfOnesToClear ; i++, walking1Mask <<= 1)
            mask &= ~walking1Mask;
        /* bitOffset 8-24 for FQID, 8 for PP --> no mask (0xFF)*/
     }
@@ -729,7 +729,7 @@ static void DecSchemeOwners(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleBindPortToSche
     p_FmPcdKg = p_FmPcd->p_FmPcdKg;
 
     /* for each scheme - update owners counters */
-    for (i = 0; i < p_BindPort->numOfSchemes; i++)
+    for(i = 0; i < p_BindPort->numOfSchemes; i++)
     {
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
         ASSERT_COND(relativeSchemeId < FM_PCD_KG_NUM_OF_SCHEMES);
@@ -750,7 +750,7 @@ static void UpateSchemePointedOwner(t_FmPcdKgScheme *p_Scheme, bool add)
    ASSERT_COND(p_Scheme);
    ASSERT_COND(p_Scheme->valid);
 
-    if (add)
+    if(add)
         p_Scheme->pointedOwners++;
     else
         p_Scheme->pointedOwners--;
@@ -773,7 +773,7 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
     /* lock a common KG reg */
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    if (err)
+    if(err)
     {
         KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         RETURN_ERROR(MINOR, err, NO_MSG);
@@ -781,7 +781,7 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
 
     tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
 
-    if (add)
+    if(add)
         tmpKgpeSp |= spReg;
     else /* clear */
         tmpKgpeSp &= ~spReg;
@@ -870,24 +870,24 @@ static void PcdKgErrorException(t_Handle h_FmPcd)
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer);
-    if (force & event)
+    if(force & event)
         WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, force & ~event);
 
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
 
-    if (event & FM_PCD_KG_DOUBLE_ECC)
+    if(event & FM_PCD_KG_DOUBLE_ECC)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
-    if (event & FM_PCD_KG_KEYSIZE_OVERFLOW)
+    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
     {
-        if (schemeIndexes)
+        if(schemeIndexes)
         {
             while(schemeIndexes)
             {
-                if (schemeIndexes & 0x1)
+                if(schemeIndexes & 0x1)
                     p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
                 schemeIndexes >>= 1;
-                index += 1;
+                index+=1;
             }
         }
         else /* this should happen only when interrupt is forced. */
@@ -922,7 +922,7 @@ static t_Error KgInitGuest(t_FmPcd *p_FmPcd)
                                  NULL,
                                  NULL)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
-    if (replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
+    if(replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
     memcpy(p_FmPcd->p_FmPcdKg->schemesIds, (uint8_t*)(reply.replyBody),p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t));
 
@@ -945,12 +945,12 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
 
     /**********************KGEEER******************/
     tmpReg = 0;
-    if (p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
     {
         FmEnableRamsEcc(p_FmPcd->h_Fm);
         tmpReg |= FM_PCD_KG_DOUBLE_ECC;
     }
-    if (p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
         tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
     WRITE_UINT32(p_Regs->kgeeer,tmpReg);
     /**********************KGEEER******************/
@@ -980,16 +980,16 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
                    p_FmPcd);
 
     /* clear binding between ports to schemes so that all ports are not bound to any schemes */
-    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
     {
         SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
 
         err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
-        if (err)
+        if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-        if (err)
+        if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -997,13 +997,13 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
     WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
 
-    if (p_FmPcd->p_FmPcdKg->numOfSchemes)
+    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
     {
         err = FmPcdKgAllocSchemes(p_FmPcd,
                                   p_FmPcd->p_FmPcdKg->numOfSchemes,
                                   p_FmPcd->guestId,
                                   p_FmPcd->p_FmPcdKg->schemesIds);
-        if (err)
+        if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -1013,7 +1013,7 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
 static void  ValidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
 {
     ASSERT_COND(!p_Scheme->valid);
-    if (p_Scheme->netEnvId != ILLEGAL_NETENV)
+    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
         FmPcdIncNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
     p_Scheme->valid = TRUE;
 }
@@ -1023,7 +1023,7 @@ static t_Error InvalidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
     if (p_Scheme->owners)
        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
 
-    if (p_Scheme->netEnvId != ILLEGAL_NETENV)
+    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
         FmPcdDecNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
     p_Scheme->valid = FALSE;
 
@@ -1037,15 +1037,15 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
     t_FmPcd                             *p_FmPcd = (t_FmPcd *)(p_Scheme->h_FmPcd);
     uint32_t                            grpBits = 0;
     uint8_t                             grpBase;
-    bool                                direct = TRUE, absolute = FALSE;
-    uint16_t                            profileId = 0, numOfProfiles = 0, relativeProfileId;
+    bool                                direct=TRUE, absolute=FALSE;
+    uint16_t                            profileId=0, numOfProfiles=0, relativeProfileId;
     t_Error                             err = E_OK;
     int                                 i = 0;
     t_NetEnvParams                      netEnvParams;
     uint32_t                            tmpReg, fqbTmp = 0, ppcTmp = 0, selectTmp, maskTmp, knownTmp, genTmp;
     t_FmPcdKgKeyExtractAndHashParams    *p_KeyAndHash = NULL;
     uint8_t                             j, curr, idx;
-    uint8_t                             id, shift = 0, code = 0, offset = 0, size = 0;
+    uint8_t                             id, shift=0, code=0, offset=0, size=0;
     t_FmPcdExtractEntry                 *p_Extract = NULL;
     t_FmPcdKgExtractedOrParams          *p_ExtractOr;
     bool                                generic = FALSE;
@@ -1064,14 +1064,14 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                      ("numOfDistinctionUnits should not exceed %d", FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS));
 
     /* by netEnv parameters, get match vector */
-    if (!p_SchemeParams->alwaysDirect)
+    if(!p_SchemeParams->alwaysDirect)
     {
         p_Scheme->netEnvId = FmPcdGetNetEnvId(p_SchemeParams->netEnvParams.h_NetEnv);
         netEnvParams.netEnvId = p_Scheme->netEnvId;
         netEnvParams.numOfDistinctionUnits = p_SchemeParams->netEnvParams.numOfDistinctionUnits;
         memcpy(netEnvParams.unitIds, p_SchemeParams->netEnvParams.unitIds, (sizeof(uint8_t))*p_SchemeParams->netEnvParams.numOfDistinctionUnits);
         err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
         p_Scheme->matchVector = netEnvParams.vector;
     }
@@ -1081,31 +1081,31 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         p_Scheme->netEnvId = ILLEGAL_NETENV;
     }
 
-    if (p_SchemeParams->nextEngine == e_FM_PCD_INVALID)
+    if(p_SchemeParams->nextEngine == e_FM_PCD_INVALID)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next Engine of the scheme is not Valid"));
 
-    if (p_SchemeParams->bypassFqidGeneration)
+    if(p_SchemeParams->bypassFqidGeneration)
     {
 #ifdef FM_KG_NO_BYPASS_FQID_GEN
         if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassFqidGeneration."));
 #endif /* FM_KG_NO_BYPASS_FQID_GEN */
-        if (p_SchemeParams->baseFqid)
+        if(p_SchemeParams->baseFqid)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid set for a scheme that does not generate an FQID"));
     }
     else
-        if (!p_SchemeParams->baseFqid)
+        if(!p_SchemeParams->baseFqid)
             DBG(WARNING, ("baseFqid is 0."));
 
-    if (p_SchemeParams->nextEngine == e_FM_PCD_PLCR)
+    if(p_SchemeParams->nextEngine == e_FM_PCD_PLCR)
     {
         direct = p_SchemeParams->kgNextEngineParams.plcrProfile.direct;
         p_Scheme->directPlcr = direct;
         absolute = (bool)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE : FALSE);
-        if (!direct && absolute)
+        if(!direct && absolute)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
 
-        if (direct)
+        if(direct)
         {
             profileId = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.directRelativeProfileId;
             numOfProfiles = 1;
@@ -1118,10 +1118,10 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         }
     }
 
-    if (p_SchemeParams->nextEngine == e_FM_PCD_CC)
+    if(p_SchemeParams->nextEngine == e_FM_PCD_CC)
     {
 #ifdef FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
-        if ((p_SchemeParams->kgNextEngineParams.cc.plcrNext) && (p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        if((p_SchemeParams->kgNextEngineParams.cc.plcrNext) && (p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
         {
             if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassPlcrProfileGeneration."));
@@ -1132,18 +1132,18 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                              p_SchemeParams->kgNextEngineParams.cc.grpId,
                              &grpBits,
                              &grpBase);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
         p_Scheme->ccUnits = grpBits;
 
-        if ((p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
+        if((p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
            (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
         {
-                if (p_SchemeParams->kgNextEngineParams.cc.plcrProfile.sharedProfile)
+                if(p_SchemeParams->kgNextEngineParams.cc.plcrProfile.sharedProfile)
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
                 absolute = FALSE;
                 direct = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.direct;
-                if (direct)
+                if(direct)
                 {
                     profileId = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
                     numOfProfiles = 1;
@@ -1158,20 +1158,20 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
     }
 
     /* if policer is used directly after KG, or after CC */
-    if ((p_SchemeParams->nextEngine == e_FM_PCD_PLCR)  ||
+    if((p_SchemeParams->nextEngine == e_FM_PCD_PLCR)  ||
        ((p_SchemeParams->nextEngine == e_FM_PCD_CC) &&
         (p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
         (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)))
     {
         /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
-        if (absolute)
+        if(absolute)
         {
             /* for absolute direct policy only, */
             relativeProfileId = profileId;
             err = FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL, relativeProfileId, &profileId);
-            if (err)
+            if(err)
                 RETURN_ERROR(MAJOR, err, ("Shared profile not valid offset"));
-            if (!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
+            if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Shared profile not valid."));
             p_Scheme->relativeProfileId = profileId;
         }
@@ -1187,10 +1187,10 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
     {
         /* if policer is NOT going to be used after KG at all than if bypassFqidGeneration
         is set, we do not need numOfUsedExtractedOrs and hashDistributionNumOfFqids */
-        if (p_SchemeParams->bypassFqidGeneration && p_SchemeParams->numOfUsedExtractedOrs)
+        if(p_SchemeParams->bypassFqidGeneration && p_SchemeParams->numOfUsedExtractedOrs)
             RETURN_ERROR(MAJOR, E_INVALID_STATE,
                     ("numOfUsedExtractedOrs is set in a scheme that does not generate FQID or policer profile ID"));
-        if (p_SchemeParams->bypassFqidGeneration &&
+        if(p_SchemeParams->bypassFqidGeneration &&
                 p_SchemeParams->useHash &&
                 p_SchemeParams->keyExtractAndHashParams.hashDistributionNumOfFqids)
             RETURN_ERROR(MAJOR, E_INVALID_STATE,
@@ -1199,24 +1199,24 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
     /* configure all 21 scheme registers */
     tmpReg =  KG_SCH_MODE_EN;
-    switch (p_SchemeParams->nextEngine)
+    switch(p_SchemeParams->nextEngine)
     {
-        case (e_FM_PCD_PLCR):
+        case(e_FM_PCD_PLCR):
             /* add to mode register - NIA */
             tmpReg |= KG_SCH_MODE_NIA_PLCR;
             tmpReg |= NIA_ENG_PLCR;
             tmpReg |= (uint32_t)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? NIA_PLCR_ABSOLUTE:0);
             /* initialize policer profile command - */
             /*  configure kgse_ppc  */
-            if (direct)
+            if(direct)
             /* use profileId as base, other fields are 0 */
                 p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
             else
             {
-                if (shift > MAX_PP_SHIFT)
+                if(shift > MAX_PP_SHIFT)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
 
-                if (!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
 
                 ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
@@ -1227,30 +1227,30 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                 p_SchemeRegs->kgse_ppc = ppcTmp;
             }
             break;
-        case (e_FM_PCD_CC):
+        case(e_FM_PCD_CC):
             /* mode reg - define NIA */
             tmpReg |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
 
             p_SchemeRegs->kgse_ccbs = grpBits;
             tmpReg |= (uint32_t)(grpBase << KG_SCH_MODE_CCOBASE_SHIFT);
 
-            if (p_SchemeParams->kgNextEngineParams.cc.plcrNext)
+            if(p_SchemeParams->kgNextEngineParams.cc.plcrNext)
             {
-                if (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
+                if(!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
                 {
                     /* find out if absolute or relative */
-                    if (absolute)
+                    if(absolute)
                          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"));
-                    if (direct)
+                    if(direct)
                     {
                         /* mask = 0, base = directProfileId */
                         p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
                     }
                     else
                     {
-                        if (shift > MAX_PP_SHIFT)
+                        if(shift > MAX_PP_SHIFT)
                             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
-                        if (!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                        if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
                             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
 
                         ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
@@ -1265,8 +1265,8 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                     ppcTmp = KG_SCH_PP_NO_GEN;
             }
             break;
-        case (e_FM_PCD_DONE):
-            if (p_SchemeParams->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
+        case(e_FM_PCD_DONE):
+            if(p_SchemeParams->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
                 tmpReg |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
             else
                 tmpReg |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
@@ -1316,7 +1316,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         p_SchemeRegs->kgse_vsp = KG_SCH_VSP_NO_KSP_EN;
 #endif /* (DPAA_VERSION >= 11) */
 
-    if (p_SchemeParams->useHash)
+    if(p_SchemeParams->useHash)
     {
         p_KeyAndHash = &p_SchemeParams->keyExtractAndHashParams;
 
@@ -1329,70 +1329,70 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         /*  configure kgse_dv1  */
         p_SchemeRegs->kgse_dv1 = p_KeyAndHash->privateDflt1;
 
-        if (!p_SchemeParams->bypassFqidGeneration)
+        if(!p_SchemeParams->bypassFqidGeneration)
         {
-            if (!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
+            if(!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
-            if ((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_SchemeParams->baseFqid)
+            if((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_SchemeParams->baseFqid)
                 DBG(WARNING, ("baseFqid unaligned. Distribution may result in less than hashDistributionNumOfFqids queues."));
         }
 
         /*  configure kgse_ekdv  */
         tmpReg = 0;
-        for (i = 0; i < p_KeyAndHash->numOfUsedDflts; i++)
+        for( i=0 ;i<p_KeyAndHash->numOfUsedDflts ; i++)
         {
-            switch (p_KeyAndHash->dflts[i].type)
+            switch(p_KeyAndHash->dflts[i].type)
             {
-                case (e_FM_PCD_KG_MAC_ADDR):
+                case(e_FM_PCD_KG_MAC_ADDR):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MAC_ADDR_SHIFT);
                     break;
-                case (e_FM_PCD_KG_TCI):
+                case(e_FM_PCD_KG_TCI):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCI_SHIFT);
                     break;
-                case (e_FM_PCD_KG_ENET_TYPE):
+                case(e_FM_PCD_KG_ENET_TYPE):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_ENET_TYPE_SHIFT);
                     break;
-                case (e_FM_PCD_KG_PPP_SESSION_ID):
+                case(e_FM_PCD_KG_PPP_SESSION_ID):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_SESSION_ID_SHIFT);
                     break;
-                case (e_FM_PCD_KG_PPP_PROTOCOL_ID):
+                case(e_FM_PCD_KG_PPP_PROTOCOL_ID):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT);
                     break;
-                case (e_FM_PCD_KG_MPLS_LABEL):
+                case(e_FM_PCD_KG_MPLS_LABEL):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MPLS_LABEL_SHIFT);
                     break;
-                case (e_FM_PCD_KG_IP_ADDR):
+                case(e_FM_PCD_KG_IP_ADDR):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_ADDR_SHIFT);
                     break;
-                case (e_FM_PCD_KG_PROTOCOL_TYPE):
+                case(e_FM_PCD_KG_PROTOCOL_TYPE):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PROTOCOL_TYPE_SHIFT);
                     break;
-                case (e_FM_PCD_KG_IP_TOS_TC):
+                case(e_FM_PCD_KG_IP_TOS_TC):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_TOS_TC_SHIFT);
                     break;
-                case (e_FM_PCD_KG_IPV6_FLOW_LABEL):
+                case(e_FM_PCD_KG_IPV6_FLOW_LABEL):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
                     break;
-                case (e_FM_PCD_KG_IPSEC_SPI):
+                case(e_FM_PCD_KG_IPSEC_SPI):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IPSEC_SPI_SHIFT);
                     break;
-                case (e_FM_PCD_KG_L4_PORT):
+                case(e_FM_PCD_KG_L4_PORT):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
                     break;
-                case (e_FM_PCD_KG_TCP_FLAG):
+                case(e_FM_PCD_KG_TCP_FLAG):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCP_FLAG_SHIFT);
                     break;
-                case (e_FM_PCD_KG_GENERIC_FROM_DATA):
+                case(e_FM_PCD_KG_GENERIC_FROM_DATA):
                     swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA;
                     swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
                     numOfSwDefaults ++;
                     break;
-                case (e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V):
+                case(e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V):
                     swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V;
                     swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
                     numOfSwDefaults ++;
                     break;
-                case (e_FM_PCD_KG_GENERIC_NOT_FROM_DATA):
+                case(e_FM_PCD_KG_GENERIC_NOT_FROM_DATA):
                     swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_NOT_FROM_DATA;
                     swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
                     numOfSwDefaults ++;
@@ -1404,29 +1404,29 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         p_SchemeRegs->kgse_ekdv = tmpReg;
 
         p_LocalExtractsArray = (t_FmPcdKgSchemesExtracts *)XX_Malloc(sizeof(t_FmPcdKgSchemesExtracts));
-        if (!p_LocalExtractsArray)
+        if(!p_LocalExtractsArray)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
 
         /*  configure kgse_ekfc and  kgse_gec */
         knownTmp = 0;
-        for (i = 0; i < p_KeyAndHash->numOfUsedExtracts; i++)
+        for( i=0 ;i<p_KeyAndHash->numOfUsedExtracts ; i++)
         {
             p_Extract = &p_KeyAndHash->extractArray[i];
-            switch (p_Extract->type)
+            switch(p_Extract->type)
             {
-                case (e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
                     knownTmp |= KG_SCH_KN_PORT_ID;
                     /* save in driver structure */
                     p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(KG_SCH_KN_PORT_ID);
                     p_LocalExtractsArray->extractsArray[i].known = TRUE;
                     break;
-                case (e_FM_PCD_EXTRACT_BY_HDR):
-                    switch (p_Extract->extractByHdr.hdr)
+                case(e_FM_PCD_EXTRACT_BY_HDR):
+                    switch(p_Extract->extractByHdr.hdr)
                     {
-                        case (HEADER_TYPE_UDP_ENCAP_ESP):
-                            switch (p_Extract->extractByHdr.type)
+                        case(HEADER_TYPE_UDP_ENCAP_ESP):
+                            switch(p_Extract->extractByHdr.type)
                             {
-                                case (e_FM_PCD_EXTRACT_FROM_HDR):
+                                case(e_FM_PCD_EXTRACT_FROM_HDR):
                                     /* case where extraction from ESP only */
                                     if (p_Extract->extractByHdr.extractByHdrType.fromHdr.offset >= UDP_HEADER_SIZE)
                                     {
@@ -1440,23 +1440,23 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                                         p_Extract->extractByHdr.ignoreProtocolValidation = FALSE;
                                     }
                                     break;
-                                case (e_FM_PCD_EXTRACT_FROM_FIELD):
-                                    switch (p_Extract->extractByHdr.extractByHdrType.fromField.field.udpEncapEsp)
+                                case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                                    switch(p_Extract->extractByHdr.extractByHdrType.fromField.field.udpEncapEsp)
                                     {
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
                                             p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
                                             break;
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
-                                            /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET; */
+                                            /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
@@ -1465,23 +1465,23 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                                             break;
                                     }
                                     break;
-                                case (e_FM_PCD_EXTRACT_FULL_FIELD):
-                                    switch (p_Extract->extractByHdr.extractByHdrType.fullField.udpEncapEsp)
+                                case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                                    switch(p_Extract->extractByHdr.extractByHdrType.fullField.udpEncapEsp)
                                     {
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
                                             p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
                                             break;
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SPI_SIZE;
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SPI_OFFSET;
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
-                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
+                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SEQ_NUM_SIZE;
@@ -1495,9 +1495,9 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                         default:
                             break;
                     }
-                    switch (p_Extract->extractByHdr.type)
+                    switch(p_Extract->extractByHdr.type)
                     {
-                        case (e_FM_PCD_EXTRACT_FROM_HDR):
+                        case(e_FM_PCD_EXTRACT_FROM_HDR):
                             generic = TRUE;
                             /* get the header code for the generic extract */
                             code = GetGenHdrCode(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex, p_Extract->extractByHdr.ignoreProtocolValidation);
@@ -1505,7 +1505,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                             offset = p_Extract->extractByHdr.extractByHdrType.fromHdr.offset;
                             size = p_Extract->extractByHdr.extractByHdrType.fromHdr.size;
                             break;
-                        case (e_FM_PCD_EXTRACT_FROM_FIELD):
+                        case(e_FM_PCD_EXTRACT_FROM_FIELD):
                             generic = TRUE;
                             /* get the field code for the generic extract */
                             code = GetGenFieldCode(p_Extract->extractByHdr.hdr,
@@ -1513,13 +1513,13 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                             offset = p_Extract->extractByHdr.extractByHdrType.fromField.offset;
                             size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                             break;
-                        case (e_FM_PCD_EXTRACT_FULL_FIELD):
-                            if (!p_Extract->extractByHdr.ignoreProtocolValidation)
+                        case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                            if(!p_Extract->extractByHdr.ignoreProtocolValidation)
                             {
                                 /* if we have a known field for it - use it, otherwise use generic */
                                 bitMask = GetKnownProtMask(p_FmPcd, p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex,
                                             p_Extract->extractByHdr.extractByHdrType.fullField);
-                                if (bitMask)
+                                if(bitMask)
                                 {
                                     knownTmp |= bitMask;
                                     /* save in driver structure */
@@ -1532,7 +1532,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                             }
                             else
                                 generic = TRUE;
-                            if (generic)
+                            if(generic)
                             {
                                 /* tmp - till we cover more headers under generic */
                                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
@@ -1542,7 +1542,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
                     }
                     break;
-                case (e_FM_PCD_EXTRACT_NON_HDR):
+                case(e_FM_PCD_EXTRACT_NON_HDR):
                     /* use generic */
                     generic = TRUE;
                     offset = 0;
@@ -1555,22 +1555,22 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                     RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             }
 
-            if (generic)
+            if(generic)
             {
                 /* set generic register fields */
-                if (currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
+                if(currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
                     RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
-                if (!code)
+                if(!code)
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
 
                 genTmp = KG_SCH_GEN_VALID;
                 genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
                 genTmp |= offset;
-                if ((size > MAX_KG_SCH_SIZE) || (size < 1))
+                if((size > MAX_KG_SCH_SIZE) || (size < 1))
                       RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
                 genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
                 swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
-                if (swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
+                if(swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
                     DBG(WARNING, ("No sw default configured"));
 
                 genTmp |= swDefault << KG_SCH_GEN_DEF_SHIFT;
@@ -1588,9 +1588,9 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         maskTmp = 0xFFFFFFFF;
         /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
 
-        if (p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+        if(p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Only %d masks supported", FM_PCD_KG_NUM_OF_EXTRACT_MASKS));
-        for (i = 0; i < p_KeyAndHash->numOfUsedMasks; i++)
+        for( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
         {
             /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
             id = p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].id;
@@ -1604,7 +1604,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
             /* Get the shift of the offset field (depending on i) - may
                be in  kgse_bmch or in kgse_fqb (depending on i) */
             GET_MASK_OFFSET_SHIFT(shift,i);
-            if (i <= 1)
+            if (i<=1)
                 selectTmp |= p_KeyAndHash->masks[i].offset << shift;
             else
                 fqbTmp |= p_KeyAndHash->masks[i].offset << shift;
@@ -1614,18 +1614,18 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
             /* pass all bits */
             maskTmp |= KG_SCH_BITMASK_MASK << shift;
             /* clear bits that need masking */
-            maskTmp &= ~(0xFF << shift);
+            maskTmp &= ~(0xFF << shift) ;
             /* set mask bits */
-            maskTmp |= (p_KeyAndHash->masks[i].mask << shift);
+            maskTmp |= (p_KeyAndHash->masks[i].mask << shift) ;
         }
         p_SchemeRegs->kgse_bmch = selectTmp;
         p_SchemeRegs->kgse_bmcl = maskTmp;
         /* kgse_fqb will be written t the end of the routine */
 
         /*  configure kgse_hc  */
-        if (p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
+        if(p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
-        if (p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
+        if(p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
 
         tmpReg = 0;
@@ -1633,9 +1633,9 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         tmpReg |= ((p_KeyAndHash->hashDistributionNumOfFqids - 1) << p_KeyAndHash->hashDistributionFqidsShift);
         tmpReg |= p_KeyAndHash->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;
 
-        if (p_KeyAndHash->symmetricHash)
+        if(p_KeyAndHash->symmetricHash)
         {
-            if ((!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACDST)) ||
+            if((!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACDST)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC1) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST1)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC2) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST2)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PDST)))
@@ -1656,11 +1656,11 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
            num_of_known - p_KeyAndHash->numOfUsedExtracts - currGenId
            first_generic_index = num_of_known */
         curr = 0;
-        for (i = 0; i < p_KeyAndHash->numOfUsedExtracts; i++)
+        for (i=0;i<p_KeyAndHash->numOfUsedExtracts ; i++)
         {
-            if (p_LocalExtractsArray->extractsArray[i].known)
+            if(p_LocalExtractsArray->extractsArray[i].known)
             {
-                ASSERT_COND(curr < (p_KeyAndHash->numOfUsedExtracts - currGenId));
+                ASSERT_COND(curr<(p_KeyAndHash->numOfUsedExtracts - currGenId));
                 j = curr;
                 /* id is the extract id (port id = 0, mac src = 1 etc.). the value in the array is the original
                 index in the user's extractions array */
@@ -1700,38 +1700,38 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         p_SchemeRegs->kgse_dv1 = 0;
     }
 
-    if (p_SchemeParams->bypassFqidGeneration)
+    if(p_SchemeParams->bypassFqidGeneration)
         p_SchemeRegs->kgse_hc |= KG_SCH_HASH_CONFIG_NO_FQID;
 
     /*  configure kgse_spc  */
-    if (p_SchemeParams->schemeCounter.update)
+    if( p_SchemeParams->schemeCounter.update)
         p_SchemeRegs->kgse_spc = p_SchemeParams->schemeCounter.value;
 
 
     /* check that are enough generic registers */
-    if (p_SchemeParams->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
+    if(p_SchemeParams->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
         RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
 
     /* extracted OR mask on Qid */
-    for (i = 0; i < p_SchemeParams->numOfUsedExtractedOrs; i++)
+    for( i=0 ;i<p_SchemeParams->numOfUsedExtractedOrs ; i++)
     {
 
         p_Scheme->extractedOrs = TRUE;
         /*  configure kgse_gec[i]  */
         p_ExtractOr = &p_SchemeParams->extractedOrs[i];
-        switch (p_ExtractOr->type)
+        switch(p_ExtractOr->type)
         {
-            case (e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+            case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
                 code = KG_SCH_GEN_PARSE_RESULT_N_FQID;
                 offset = 0;
                 break;
-            case (e_FM_PCD_EXTRACT_BY_HDR):
+            case(e_FM_PCD_EXTRACT_BY_HDR):
                 /* get the header code for the generic extract */
                 code = GetGenHdrCode(p_ExtractOr->extractByHdr.hdr, p_ExtractOr->extractByHdr.hdrIndex, p_ExtractOr->extractByHdr.ignoreProtocolValidation);
                 /* set generic register fields */
                 offset = p_ExtractOr->extractionOffset;
                 break;
-            case (e_FM_PCD_EXTRACT_NON_HDR):
+            case(e_FM_PCD_EXTRACT_NON_HDR):
                 /* get the field code for the generic extract */
                 offset = 0;
                 code = GetGenCode(p_ExtractOr->src, &offset);
@@ -1742,12 +1742,12 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         }
 
         /* set generic register fields */
-        if (!code)
+        if(!code)
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
         genTmp = KG_SCH_GEN_EXTRACT_TYPE | KG_SCH_GEN_VALID;
         genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
         genTmp |= offset;
-        if (!!p_ExtractOr->bitOffsetInFqid == !!p_ExtractOr->bitOffsetInPlcrProfile)
+        if(!!p_ExtractOr->bitOffsetInFqid == !!p_ExtractOr->bitOffsetInPlcrProfile)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" extracted byte must effect either FQID or Policer profile"));
 
         /************************************************************************************
@@ -1791,11 +1791,11 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
         ************************************************************************************/
 
-        if (p_ExtractOr->bitOffsetInFqid)
+        if(p_ExtractOr->bitOffsetInFqid)
         {
-            if (p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_FQID_BIT_OFFSET )
+            if(p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_FQID_BIT_OFFSET )
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInFqid out of range)"));
-            if (p_ExtractOr->bitOffsetInFqid < 8)
+            if(p_ExtractOr->bitOffsetInFqid<8)
                 genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid+24) << KG_SCH_GEN_SIZE_SHIFT);
             else
                 genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid-8) << KG_SCH_GEN_SIZE_SHIFT);
@@ -1803,7 +1803,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         }
         else /* effect policer profile */
         {
-            if (p_ExtractOr->bitOffsetInPlcrProfile > MAX_KG_SCH_PP_BIT_OFFSET )
+            if(p_ExtractOr->bitOffsetInPlcrProfile > MAX_KG_SCH_PP_BIT_OFFSET )
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInPlcrProfile out of range)"));
             p_Scheme->bitOffsetInPlcrProfile = p_ExtractOr->bitOffsetInPlcrProfile;
             genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInPlcrProfile+16) << KG_SCH_GEN_SIZE_SHIFT);
@@ -1812,19 +1812,19 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
         genTmp |= (uint32_t)(p_ExtractOr->extractionOffset << KG_SCH_GEN_DEF_SHIFT);
         /* clear bits that need masking */
-        genTmp &= ~KG_SCH_GEN_MASK;
+        genTmp &= ~KG_SCH_GEN_MASK ;
         /* set mask bits */
         genTmp |= (uint32_t)(p_ExtractOr->mask << KG_SCH_GEN_MASK_SHIFT);
         p_SchemeRegs->kgse_gec[currGenId++] = genTmp;
 
     }
     /* clear all unused GEC registers */
-    for (i = currGenId; i < FM_PCD_KG_NUM_OF_GENERIC_REGS; i++)
+    for( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
         p_SchemeRegs->kgse_gec[i] = 0;
 
     /* add base Qid for this scheme */
     /* add configuration for kgse_fqb */
-    if (p_SchemeParams->baseFqid & ~0x00FFFFFF)
+    if(p_SchemeParams->baseFqid & ~0x00FFFFFF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid must be between 1 and 2^24-1"));
 
     fqbTmp |= p_SchemeParams->baseFqid;
@@ -1856,7 +1856,7 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
 
     /* find a new clsPlan group */
     for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
-        if (!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
+        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
             break;
     if (i == FM_MAX_NUM_OF_PORTS)
         RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
@@ -1883,7 +1883,7 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     {
         err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
 
-        if (err)
+        if(err)
             RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
     }
     else
@@ -1923,7 +1923,7 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
 
     oredVectors = 0;
-    for (i = 0; i < p_Grp->numOfOptions; i++)
+    for(i = 0; i<p_Grp->numOfOptions; i++)
     {
         oredVectors |= p_Grp->optVectors[i];
         /* save an array of used options - the indexes represent the power of 2 index */
@@ -1932,10 +1932,10 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     /* set the classification plan relevant entries so that all bits
      * relevant to the list of options is cleared
      */
-    for (j = 0; j < p_ClsPlanGrp->sizeOfGrp; j++)
+    for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
         p_ClsPlanSet->vectors[j] = ~oredVectors;
 
-    for (i = 0; i < p_Grp->numOfOptions; i++)
+    for(i = 0; i<p_Grp->numOfOptions; i++)
     {
        /* option i got the place 2^i in the clsPlan array. all entries that
          * have bit i set, should have the vector bit cleared. So each option
@@ -1959,9 +1959,9 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
         /* now for each option (i), we set their bits in all entries (j)
          * that contain bit 2^i.
          */
-        for (j = 0; j < p_ClsPlanGrp->sizeOfGrp; j++)
+        for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
         {
-            if (j & (1<<i))
+            if(j & (1<<i))
                 p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
         }
     }
@@ -2030,7 +2030,7 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
             return;
         }
-        if ((t_Error)reply.error != E_OK)
+        if((t_Error)reply.error != E_OK)
         {
             REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Free KG clsPlan failed"));
             return;
@@ -2052,35 +2052,35 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
     /* for each scheme */
-    for (i = 0; i < p_BindPort->numOfSchemes; i++)
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
     {
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
-        if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
             RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-        if (add)
+        if(add)
         {
             p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
             if (!FmPcdKgIsSchemeValidSw(p_Scheme))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
             /* check netEnvId  of the port against the scheme netEnvId */
-            if ((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
+            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
 
             /* if next engine is private port policer profile, we need to check that it is valid */
             HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
-            if (p_Scheme->nextRelativePlcrProfile)
+            if(p_Scheme->nextRelativePlcrProfile)
             {
-                for (j = 0; j < p_Scheme->numOfProfiles; j++)
+                for(j = 0;j<p_Scheme->numOfProfiles;j++)
                 {
                     ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
-                    if (p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
+                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
-                     if (!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
+                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
                         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
                 }
             }
-            if (!p_BindPort->useClsPlan)
+            if(!p_BindPort->useClsPlan)
             {
                 /* This check may be redundant as port is a assigned to the whole NetEnv */
 
@@ -2095,10 +2095,10 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
                     tmp |= p_Scheme->ccUnits;
                     while (tmp)
                     {
-                        if (tmp & walking1Mask)
+                        if(tmp & walking1Mask)
                         {
                             tmp &= ~walking1Mask;
-                            if (!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
                                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
                         }
                         walking1Mask >>= 1;
@@ -2122,11 +2122,11 @@ t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPort
     t_Error                 err = E_OK;
 
     err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, TRUE);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     IncSchemeOwners(p_FmPcd, p_SchemeBind);
@@ -2141,11 +2141,11 @@ t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd, t_FmPcdKgInterModuleBindPor
     t_Error                 err = E_OK;
 
     err = FmPcdKgBuildBindPortToSchemes(p_FmPcd, p_SchemeBind, &spReg, FALSE);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, FALSE);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     DecSchemeOwners(p_FmPcd, p_SchemeBind);
@@ -2164,7 +2164,7 @@ bool KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-    if (p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
+    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
         return TRUE;
     else
         return FALSE;
@@ -2183,7 +2183,7 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
 
     for (j = 0, i = 0; i < FM_PCD_KG_NUM_OF_SCHEMES && j < numOfSchemes; i++)
     {
-        if (!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
+        if(!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
         {
             p_FmPcd->p_FmPcdKg->schemesMng[i].allocated = TRUE;
             p_FmPcd->p_FmPcdKg->schemesMng[i].ownerId = guestId;
@@ -2195,7 +2195,7 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
     if (j != numOfSchemes)
     {
         /* roll back */
-        for (j--; j; j--)
+        for(j--; j; j--)
         {
             p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].allocated = FALSE;
             p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].ownerId = 0;
@@ -2221,11 +2221,11 @@ t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gues
 
     for (i = 0; i < numOfSchemes; i++)
     {
-        if (!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
+        if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
         {
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
         }
-        if (p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
+        if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
         {
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
         }
@@ -2239,13 +2239,13 @@ t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gues
 t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t *p_First)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint8_t     numOfBlocks, blocksFound = 0, first = 0;
+    uint8_t     numOfBlocks, blocksFound=0, first=0;
     uint8_t     i, j;
 
     /* This routine is issued only on master core of master partition -
        either directly or through IPC, so no need for lock */
 
-    if (!numOfClsPlanEntries)
+    if(!numOfClsPlanEntries)
         return E_OK;
 
     if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
@@ -2257,7 +2257,7 @@ t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, u
     first = 0;
     for (i = 0; i < FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
     {
-        if (!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
+        if(!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
         {
             blocksFound++;
             i++;
@@ -2303,7 +2303,7 @@ UNUSED(guestId);
     ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
 
     baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
-    for (i = baseBlock; i < baseBlock + numOfBlocks; i++)
+    for(i=baseBlock;i<baseBlock+numOfBlocks;i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
         ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
@@ -2340,7 +2340,7 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
     p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
 
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    for (i = p_Set->baseEntry; i < p_Set->baseEntry + p_Set->numOfClsPlanEntries; i += 8)
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
     {
         tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
 
@@ -2350,7 +2350,7 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
             WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
         }
 
-        if (WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
+        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
         {
             REPORT_ERROR(MAJOR, E_INVALID_STATE, ("WriteKgarWait FAILED"));
             KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
@@ -2381,14 +2381,14 @@ t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
     }
     memset(p_FmPcdKg, 0, sizeof(t_FmPcdKg));
 
-    if (FmIsMaster(p_FmPcd->h_Fm))
+    if(FmIsMaster(p_FmPcd->h_Fm))
     {
         p_FmPcdKg->p_FmPcdKgRegs  = (t_FmPcdKgRegs *)UINT_TO_PTR(FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm));
         p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
     }
 
     p_FmPcdKg->numOfSchemes = p_FmPcdParams->numOfSchemes;
-    if ((p_FmPcd->guestId == NCSW_MASTER_ID) && !p_FmPcdKg->numOfSchemes)
+    if((p_FmPcd->guestId == NCSW_MASTER_ID) && !p_FmPcdKg->numOfSchemes)
     {
         p_FmPcdKg->numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
         DBG(WARNING, ("numOfSchemes was defined 0 by user, re-defined by driver to FM_PCD_KG_NUM_OF_SCHEMES"));
@@ -2412,7 +2412,7 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     else
         err =  KgInitGuest(p_FmPcd);
 
-    if (err != E_OK)
+    if(err != E_OK)
     {
         if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
             XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
@@ -2431,13 +2431,13 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
 
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR);
 
-    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
     {
         err = FmPcdKgFreeSchemes(p_FmPcd,
                                     p_FmPcd->p_FmPcdKg->numOfSchemes,
                                     p_FmPcd->guestId,
                                     p_FmPcd->p_FmPcdKg->schemesIds);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
@@ -2493,10 +2493,10 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     /* Get from the NetEnv the information of the clsPlan (can be already created,
      * or needs to build) */
     err = PcdGetClsPlanGrpParams(h_FmPcd, p_GrpParams);
-    if (err)
+    if(err)
         RETURN_ERROR(MINOR,err,NO_MSG);
 
-    if (p_GrpParams->grpExists)
+    if(p_GrpParams->grpExists)
     {
         /* this group was already updated (at least) in SW */
         *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
@@ -2536,7 +2536,7 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     /* Set caller parameters     */
 
     /* mark if this is an empty classification group */
-    if (*p_ClsPlanGrpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+    if(*p_ClsPlanGrpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
         *p_IsEmptyClsPlanGrp = TRUE;
     else
         *p_IsEmptyClsPlanGrp = FALSE;
@@ -2551,7 +2551,7 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
 
     /* bind port to the new or existing group */
     err = BindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
-    if (err)
+    if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
@@ -2643,7 +2643,7 @@ bool FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId)
 
    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
 
-    if ((p_FmPcd->p_FmPcdKg->schemes[schemeId].extractedOrs &&
+    if((p_FmPcd->p_FmPcdKg->schemes[schemeId].extractedOrs &&
         p_FmPcd->p_FmPcdKg->schemes[schemeId].bitOffsetInPlcrProfile) ||
         p_FmPcd->p_FmPcdKg->schemes[schemeId].nextRelativePlcrProfile)
         return TRUE;
@@ -2785,11 +2785,11 @@ uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint8_t     i;
 
-    for (i = 0; i < p_FmPcd->p_FmPcdKg->numOfSchemes; i++)
-        if (p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
+    for(i = 0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
             return i;
 
-    if (i == p_FmPcd->p_FmPcdKg->numOfSchemes)
+    if(i == p_FmPcd->p_FmPcdKg->numOfSchemes)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of partition range"));
 
     return FM_PCD_KG_NUM_OF_SCHEMES;
@@ -2832,10 +2832,10 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
     {
         if (requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
-            switch (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine)
+            switch(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine)
             {
-                case (e_FM_PCD_DONE):
-                    if (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction == e_FM_PCD_ENQ_FRAME)
+                case(e_FM_PCD_DONE):
+                    if(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction == e_FM_PCD_ENQ_FRAME)
                     {
                         tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
                         intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -2849,8 +2849,8 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                         KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                     }
                 break;
-                case (e_FM_PCD_PLCR):
-                    if (!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr ||
+                case(e_FM_PCD_PLCR):
+                    if(!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr ||
                        (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].extractedOrs &&
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile) ||
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile)
@@ -2858,7 +2858,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
                         }
                         err = FmPcdPlcrCcGetSetParams(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId, requiredAction);
-                        if (err)
+                        if(err)
                         {
                             RETURN_ERROR(MAJOR, err, NO_MSG);
                         }
@@ -2867,7 +2867,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,("in this situation the next engine after scheme can be or PLCR or ENQ_FRAME"));
             }
         }
-        if (requiredAction & UPDATE_KG_NIA_CC_WA)
+        if(requiredAction & UPDATE_KG_NIA_CC_WA)
         {
             if (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine == e_FM_PCD_CC)
             {
@@ -2884,7 +2884,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                 KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
            }
         }
-        if (requiredAction & UPDATE_KG_OPT_MODE)
+        if(requiredAction & UPDATE_KG_OPT_MODE)
         {
             tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
             intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -2895,7 +2895,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
             WriteKgarWait(p_FmPcd, tmpKgarReg);
             KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         }
-        if (requiredAction & UPDATE_KG_NIA)
+        if(requiredAction & UPDATE_KG_NIA)
         {
             tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
             intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -2967,14 +2967,14 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
 
         relativeSchemeId = p_SchemeParams->id.relativeSchemeId;
         /* check that schemeId is in range */
-        if (relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
+        if(relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
         {
             REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
             return NULL;
         }
 
         p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
-        if (FmPcdKgIsSchemeValidSw(p_Scheme))
+        if(FmPcdKgIsSchemeValidSw(p_Scheme))
         {
             REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
                          ("Scheme is already used"));
@@ -2993,7 +2993,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     if (err)
     {
         REPORT_ERROR(MAJOR, err, NO_MSG);
-        if (p_SchemeParams->modify)
+        if(p_SchemeParams->modify)
             KgSchemeFlagUnlock(p_Scheme);
         if (!p_SchemeParams->modify &&
             p_Scheme->p_Lock)
@@ -3007,7 +3007,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
                                  (t_Handle)p_Scheme,
                                  &schemeRegs,
                                  p_SchemeParams->schemeCounter.update);
-        if (p_SchemeParams->modify)
+        if(p_SchemeParams->modify)
             KgSchemeFlagUnlock(p_Scheme);
         if (err)
         {
@@ -3041,7 +3041,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     WRITE_UINT32(p_MemRegs->kgse_fqb,   schemeRegs.kgse_fqb);
     WRITE_UINT32(p_MemRegs->kgse_om,    schemeRegs.kgse_om);
     WRITE_UINT32(p_MemRegs->kgse_vsp,   schemeRegs.kgse_vsp);
-    for (i = 0; i < FM_PCD_KG_NUM_OF_GENERIC_REGS; i++)
+    for(i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
         WRITE_UINT32(p_MemRegs->kgse_gec[i], schemeRegs.kgse_gec[i]);
 
     /* call indirect command for scheme write */
@@ -3072,7 +3072,7 @@ t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
 
     /* check that no port is bound to this scheme */
     err = InvalidateSchemeSw(h_Scheme);
-    if (err)
+    if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     if (p_FmPcd->h_Hc)
@@ -3115,7 +3115,7 @@ uint32_t  FM_PCD_KgSchemeGetCounter(t_Handle h_Scheme)
 
     physicalSchemeId = ((t_FmPcdKgScheme *)h_Scheme)->schemeId;
 
-    if (FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
     tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
@@ -3147,7 +3147,7 @@ t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value)
 
     physicalSchemeId = ((t_FmPcdKgScheme *)h_Scheme)->schemeId;
     /* check that schemeId is in range */
-    if (FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
     /* read specified scheme into scheme registers */
@@ -3183,7 +3183,7 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, E_NULL_POINTER);
 
     p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-    if (!FmIsMaster(p_FmPcd->h_Fm))
+    if(!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetAdditionalDataAfterParsing - guest mode!"));
 
     WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
@@ -3204,10 +3204,10 @@ t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
 
     p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    if (!FmIsMaster(p_FmPcd->h_Fm))
+    if(!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetDfltValue - guest mode!"));
 
-    if (valueId == 0)
+    if(valueId == 0)
         WRITE_UINT32(p_Regs->kggdv0r,value);
     else
         WRITE_UINT32(p_Regs->kggdv1r,value);
@@ -3251,10 +3251,10 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
 
     DUMP_SUBTITLE(("\n"));
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    for (j = 0; j < FM_PCD_KG_NUM_OF_SCHEMES; j++)
+    for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
     {
         tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
-        if (WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
+        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
@@ -3282,14 +3282,14 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     }
     DUMP_SUBTITLE(("\n"));
 
-    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
     {
         SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
 
         tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
 
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if (err)
+        if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
@@ -3299,14 +3299,14 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     }
 
     DUMP_SUBTITLE(("\n"));
-    for (j = 0; j < FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP; j++)
+    for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
     {
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
 
         tmpKgarReg = ReadClsPlanBlockActionReg((uint8_t)j);
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if (err)
+        if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
         DUMP_SUBSTRUCT_ARRAY(i, 8)
             DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index 9bbac6a7..7398690 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -50,101 +50,85 @@
 #include "fm_manip.h"
 
 
-#ifdef CORE_8BIT_ACCESS_ERRATA
-#undef WRITE_UINT16
-#undef GET_UINT16
-#undef WRITE_UINT8
-#undef GET_UINT8
-
-#define WRITE_UINT16(addr, val)     \
-    do{                             \
-            if ((int)&(addr) % 4)   \
-                WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
-                        ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L)) & 0xffff0000) | (uint32_t)val));  \
-            else                    \
-                WRITE_UINT32(*(uint32_t*)&addr,                                                                         \
-                        ((GET_UINT32(*(uint32_t*)&addr) & 0x0000ffff) | (uint32_t)val<<16));                            \
-      }while(0);
-#define GET_UINT16(addr) (((uint32_t)&addr%4) ?           \
-       ((uint16_t)GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L))):  \
-       ((uint16_t)(GET_UINT32(*(uint32_t*)(uint32_t)&addr) >> 16)))
-
-#define WRITE_UINT8(addr,val) WRITE_UINT8_ERRATA(&addr,val)
-#define GET_UINT8(addr) GET_UINT8_ERRATA(&addr)
-
-
-static void WRITE_UINT8_ERRATA(uint8_t *addr, uint8_t val)
+/****************************************/
+/*       static functions               */
+/****************************************/
+static t_Handle GetManipInfo(t_FmPcdManip *p_Manip, e_ManipInfo manipInfo)
 {
-    uint32_t newAddr, newVal;
-    newAddr = (uint32_t)addr & ~0x3L;
-    switch ((uint32_t)addr%4)
+     t_FmPcdManip     *p_CurManip = p_Manip;
+
+    if(!MANIP_IS_UNIFIED(p_Manip))
+        p_CurManip = p_Manip;
+    else
     {
-    case (0):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0x00ffffff) | (((uint32_t)val)<<24);
-        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
-        break;
-    case (1):
-         newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0xff00ffff) | (((uint32_t)val)<<16);
-        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
-        break;
-    case (2):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0xffff00ff) | (((uint32_t)val)<<8);
-        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
-        break;
-    case (3):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0xffffff00) | val;
-        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
-        break;
+        /* go to first unified */
+        while(MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
+            p_CurManip = p_CurManip->h_PrevManip;
     }
-}
 
-static uint8_t GET_UINT8_ERRATA(uint8_t *addr)
+    switch(manipInfo)
+    {
+        case(e_MANIP_HMCT):
+            return p_CurManip->p_Hmct;
+        case(e_MANIP_HMTD):
+            return p_CurManip->h_Ad;
+        case(e_MANIP_HANDLER_TABLE_OWNER):
+            return (t_Handle)p_CurManip;
+        default:
+            return NULL;
+    }
+}
+static uint16_t    GetHmctSize(t_FmPcdManip *p_Manip)
 {
-    uint32_t newAddr, newVal=0;
-    newAddr = (uint32_t)addr & ~0x3L;
-    switch ((uint32_t)addr%4)
+    uint16_t         size = 0;
+    t_FmPcdManip     *p_CurManip = p_Manip;
+
+    if(!MANIP_IS_UNIFIED(p_Manip))
+        return p_Manip->tableSize;
+
+    /* accumulate sizes, starting with the first node */
+    while(MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
+        p_CurManip = p_CurManip->h_PrevManip;
+
+    while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
     {
-    case (0):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0xff000000)>>24;
-        break;
-    case (1):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0x00ff0000)>>16;
-        break;
-    case (2):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0x0000ff00)>>8;
-        break;
-    case (3):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0x000000ff);
-        break;
+        size += p_CurManip->tableSize;
+        p_CurManip = (t_FmPcdManip *)p_CurManip->h_NextManip;
     }
+    size += p_CurManip->tableSize; /* add last size */
 
-    return (uint8_t)newVal;
+    return(size);
 }
+static uint16_t    GetDataSize(t_FmPcdManip *p_Manip)
+{
+    uint16_t         size = 0;
+    t_FmPcdManip     *p_CurManip = p_Manip;
 
-#endif /* CORE_8BIT_ACCESS_ERRATA */
+    if(!MANIP_IS_UNIFIED(p_Manip))
+        return p_Manip->dataSize;
 
-/****************************************/
-/*       static functions               */
-/****************************************/
+    /* accumulate sizes, starting with the first node */
+    while(MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
+        p_CurManip = p_CurManip->h_PrevManip;
 
+    while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
+    {
+        size += p_CurManip->dataSize;
+        p_CurManip = (t_FmPcdManip *)p_CurManip->h_NextManip;
+    }
+    size += p_CurManip->dataSize; /* add last size */
 
+    return(size);
+}
 static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16_t *p_TableSize, uint8_t *p_DataSize)
 {
     uint8_t localDataSize, remain, tableSize = 0, dataSize = 0;
 
-    if (p_FmPcdManipParams->u.hdr.rmv)
+    if(p_FmPcdManipParams->u.hdr.rmv)
     {
-        switch (p_FmPcdManipParams->u.hdr.rmvParams.type){
-            case (e_FM_PCD_MANIP_RMV_GENERIC):
-            case (e_FM_PCD_MANIP_RMV_BY_HDR):
+        switch(p_FmPcdManipParams->u.hdr.rmvParams.type){
+            case(e_FM_PCD_MANIP_RMV_GENERIC):
+            case(e_FM_PCD_MANIP_RMV_BY_HDR):
                 /* As long as the only rmv command is the L2, no check on type is required */
                 tableSize +=  HMCD_BASIC_SIZE;
             break;
@@ -153,21 +137,21 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
         }
     }
 
-    if (p_FmPcdManipParams->u.hdr.insrt)
+    if(p_FmPcdManipParams->u.hdr.insrt)
     {
-        switch (p_FmPcdManipParams->u.hdr.insrtParams.type){
-            case (e_FM_PCD_MANIP_INSRT_GENERIC):
+        switch(p_FmPcdManipParams->u.hdr.insrtParams.type){
+            case(e_FM_PCD_MANIP_INSRT_GENERIC):
                 remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
-                if (remain)
+                if(remain)
                     localDataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
                 else
                     localDataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
                 tableSize += (uint8_t)(HMCD_BASIC_SIZE + localDataSize);
             break;
-            case (e_FM_PCD_MANIP_INSRT_BY_HDR):
+            case(e_FM_PCD_MANIP_INSRT_BY_HDR):
                 /* As long as the only insert command is the internal L2, no check on type is required */
                 tableSize += HMCD_BASIC_SIZE+HMCD_PTR_SIZE;
-                if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
+                if(p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
                     switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
                     {
                         case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
@@ -181,39 +165,39 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
                 RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
         }
     }
-    if (p_FmPcdManipParams->u.hdr.fieldUpdate)
+    if(p_FmPcdManipParams->u.hdr.fieldUpdate)
     {
-        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
-            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
+        switch(p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
                 tableSize += HMCD_BASIC_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
                    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                 {
                     tableSize += HMCD_PTR_SIZE;
                     dataSize += DSCP_TO_VLAN_TABLE_SIZE;
                 }
             break;
-            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
+            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
                 tableSize += HMCD_BASIC_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
                 {
                     tableSize += HMCD_PARAM_SIZE;
                     dataSize += 2;
                 }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
                     tableSize += HMCD_IPV4_ADDR_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
                     tableSize += HMCD_IPV4_ADDR_SIZE;
             break;
-            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
+            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
                 tableSize += HMCD_BASIC_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_SRC)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_SRC)
                     tableSize += HMCD_IPV6_ADDR_SIZE;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_DST)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_DST)
                     tableSize += HMCD_IPV6_ADDR_SIZE;
             break;
-            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
                     /* we implement this case with the update-checksum descriptor */
                     tableSize += HMCD_BASIC_SIZE;
                 else
@@ -225,14 +209,14 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
         }
     }
 
-    if (p_FmPcdManipParams->u.hdr.custom)
+    if(p_FmPcdManipParams->u.hdr.custom)
     {
-        switch (p_FmPcdManipParams->u.hdr.customParams.type){
-            case (e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
+        switch(p_FmPcdManipParams->u.hdr.customParams.type){
+            case(e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
             {
                 tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE + HMCD_PARAM_SIZE;
                 dataSize += p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
-                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
+                if((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
                         (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
                     dataSize += 2;
             }
@@ -266,7 +250,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset << HMCD_RMV_OFFSET_SHIFT;
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size << HMCD_RMV_SIZE_SHIFT;
         }
-        else if (p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_BY_HDR)
+        else if(p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_BY_HDR)
         {
             uint8_t     hmcdOpt;
             if (!p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.type == e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2)
@@ -275,18 +259,18 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             /* initialize HMCD */
             tmpReg = (uint32_t)(HMCD_OPCODE_L2_RMV) << HMCD_OC_SHIFT;
 
-            switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.specificL2)
+            switch(p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.specificL2)
             {
-                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET):
+                case(e_FM_PCD_MANIP_HDR_RMV_ETHERNET):
                     hmcdOpt = HMCD_RMV_L2_ETHERNET;
                     break;
-                case (e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS):
+                case(e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS):
                     hmcdOpt = HMCD_RMV_L2_STACKED_QTAGS;
                     break;
-                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS):
+                case(e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS):
                     hmcdOpt = HMCD_RMV_L2_ETHERNET_AND_MPLS;
                     break;
-                case (e_FM_PCD_MANIP_HDR_RMV_MPLS):
+                case(e_FM_PCD_MANIP_HDR_RMV_MPLS):
                     hmcdOpt = HMCD_RMV_L2_MPLS;
                     break;
                 default:
@@ -309,7 +293,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
         if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
         {
             /* initialize HMCD */
-            if (p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
+            if(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
                 tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_REPLACE) << HMCD_OC_SHIFT;
             else
                 tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_INSRT) << HMCD_OC_SHIFT;
@@ -348,7 +332,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 XX_Free(p_LocalData);
         }
 
-        else if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_BY_HDR)
+        else if(p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_BY_HDR)
         {
             uint8_t     hmcdOpt;
             if (!p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
@@ -392,13 +376,13 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
 
     if (p_FmPcdManipParams->u.hdr.fieldUpdate)
     {
-        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
-            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
+        switch(p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_VLAN_PRI_UPDATE) << HMCD_OC_SHIFT;
 
                 /* set mode & table pointer */
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
                    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                 {
                     /* set Mode */
@@ -433,7 +417,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     p_TmpData += DSCP_TO_VLAN_TABLE_SIZE;
                 }
 
-                else if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
+                else if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
                    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
                 {
                     /* set Mode */
@@ -448,7 +432,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 }
                 break;
 
-            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
+            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_IPV4_UPDATE) << HMCD_OC_SHIFT;
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_TTL)
@@ -493,19 +477,19 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 }
                 break;
 
-            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
+            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_IPV6_UPDATE) << HMCD_OC_SHIFT;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_HL)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_HL)
                     tmpReg |= HMCD_IPV6_UPDATE_HL;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_TC)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_TC)
                 {
                     tmpReg |= HMCD_IPV6_UPDATE_TC;
                     tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.trafficClass << HMCD_IPV6_UPDATE_TC_SHIFT;
                 }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
                     tmpReg |= HMCD_IPV6_UPDATE_SRC;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
                     tmpReg |= HMCD_IPV6_UPDATE_DST;
                 /* write the first 4 bytes of the descriptor */
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
@@ -513,13 +497,13 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 p_Last = p_TmpHmct;
 
                 p_TmpHmct += HMCD_BASIC_SIZE/4;
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
                     for(i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
                     {
                         WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.src[i]);
                         p_TmpHmct += HMCD_PTR_SIZE/4;
                     }
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
                     for(i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
                     {
                         WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.dst[i]);
@@ -527,8 +511,8 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     }
                 break;
 
-            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
-                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
+                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
                 {
                     /* we implement this case with the update-checksum descriptor */
                     /* set opcode */
@@ -545,9 +529,9 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     /* we implement this case with the TCP/UDP update descriptor */
                     /* set opcode */
                     tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_UPDATE) << HMCD_OC_SHIFT;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
+                    if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
                          tmpReg |= HMCD_TCP_UDP_UPDATE_DST;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
+                    if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
                          tmpReg |= HMCD_TCP_UDP_UPDATE_SRC;
                     /* write the first 4 bytes of the descriptor */
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
@@ -557,9 +541,9 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     p_TmpHmct += HMCD_BASIC_SIZE/4;
 
                     tmpReg = 0;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
+                    if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
                         tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.src) << HMCD_TCP_UDP_UPDATE_SRC_SHIFT;
-                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
+                    if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
                         tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.dst);
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
                     p_TmpHmct += HMCD_PTR_SIZE/4;
@@ -575,7 +559,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
     {
         switch (p_FmPcdManipParams->u.hdr.customParams.type)
         {
-            case (e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
+            case(e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_REPLACE_IP) << HMCD_OC_SHIFT;
 
@@ -610,7 +594,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 p_TmpHmct += HMCD_PTR_SIZE/4;
                 p_TmpData += size;
 
-                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
+                if((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
                         (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
                 {
                     WRITE_UINT16(*(uint16_t*)p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.id);
@@ -630,21 +614,8 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
     if (p_FmPcdManipParams->h_NextManip &&
         (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
     {
-        //ASSERT_COND(MANIP_IS_FIRST(p_FmPcdManipParams->h_NextManip));
-
-        if (new)
+        if(new)
         {
-        /* copy old table to new location */
-            IO2IOCpy32((uint8_t *)p_TmpHmct, MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip));
-
-            /* copy old data section to new location (perhaps can be unified with above). */
-            if (p_TmpData)
-            {
-                p_TmpData = p_TmpData - MANIP_GET_DATA_SIZE(p_Manip) - MANIP_GET_DATA_SIZE(p_FmPcdManipParams->h_NextManip);
-                IO2IOCpy32((uint8_t *)p_TmpData,
-                        MANIP_GET_DATA_PTR(p_FmPcdManipParams->h_NextManip),
-                        MANIP_GET_DATA_SIZE(p_FmPcdManipParams->h_NextManip));
-            }
         /* If this is the first time this manip is created we need to free unused memory. If it
          * is a dynamic changes case, the memory used is either the CC shadow or the existing
          * table - no allocation, no free */
@@ -653,19 +624,13 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             p_Manip->unifiedPosition = e_MANIP_UNIFIED_FIRST;
 
             /* The HMTD of the next Manip is never going to be used */
-            if (((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->muramAllocate)
+            if(((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->muramAllocate)
                 FM_MURAM_FreeMem(((t_FmPcd *)((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_FmPcd)->h_FmMuram, ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
             else
                 XX_Free(((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
             ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad = NULL;
 
 
-            /* We copied the HMCT to create a new large HMCT so we can free the old one */
-        FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip));
-
-        /* update old manip table pointer */
-            MANIP_SET_HMCT_PTR(p_FmPcdManipParams->h_NextManip, p_TmpHmct);
-            MANIP_SET_DATA_PTR(p_FmPcdManipParams->h_NextManip, p_TmpData);
         /* advance pointer */
             p_TmpHmct += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
         }
@@ -681,13 +646,15 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
 {
     t_Error     err;
     uint16_t    tmpReg;
-    uint32_t    nextSize = 0, totalSize;
+    t_FmPcdManip *p_CurManip;
+    uint8_t *p_OldHmct,*p_TmpHmctPtr, *p_TmpDataPtr;
 
+    uint32_t    nextSize = 0, totalSize;
     /* set Manip structure */
-    if (p_FmPcdManipParams->h_NextManip)
+    if(p_FmPcdManipParams->h_NextManip)
     {
-        if (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
-            nextSize =(uint32_t)(MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip) + MANIP_GET_DATA_SIZE(p_FmPcdManipParams->h_NextManip));
+        if(MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+            nextSize =(uint32_t)(GetHmctSize(p_FmPcdManipParams->h_NextManip) + GetDataSize(p_FmPcdManipParams->h_NextManip));
         else
             p_Manip->cascadedNext = TRUE;
     }
@@ -696,16 +663,16 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
     /* Allocate new table */
     /* calculate table size according to manip parameters */
     err = CalculateTableSize(p_FmPcdManipParams, &p_Manip->tableSize, &p_Manip->dataSize);
-    if (err)
+    if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
-    totalSize = p_Manip->tableSize + p_Manip->dataSize + nextSize;
+    totalSize =(uint16_t)(p_Manip->tableSize + p_Manip->dataSize + nextSize);
 
     p_Manip->p_Hmct = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, totalSize, 4);
     if (!p_Manip->p_Hmct)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
 
-    if(p_Manip->dataSize)
+    if (p_Manip->dataSize)
         p_Manip->p_Data = (uint8_t*)p_Manip->p_Hmct + p_Manip->tableSize + nextSize;
 
     /* update shadow size to allow runtime replacement of Header manipulation */
@@ -718,13 +685,45 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
        --------------------------------
      */
 
-    err = FmPcdUpdateCcShadow (p_Manip->h_FmPcd, totalSize + 16, FM_PCD_CC_AD_TABLE_ALIGN);
+    err = FmPcdUpdateCcShadow (p_Manip->h_FmPcd, (uint32_t)(totalSize + 16), (uint16_t)FM_PCD_CC_AD_TABLE_ALIGN);
     if (err != E_OK)
     {
         FM_MURAM_FreeMem(p_Manip->h_FmPcd, p_Manip->p_Hmct);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for HdrManip node shadow"));
     }
 
+
+    if (p_FmPcdManipParams->h_NextManip &&
+        (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
+    {
+        p_OldHmct = (uint8_t *)GetManipInfo(p_FmPcdManipParams->h_NextManip, e_MANIP_HMCT);
+        p_CurManip = p_FmPcdManipParams->h_NextManip;
+       /* Run till the last Manip (which is the first to configure) */
+        while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
+            p_CurManip = p_CurManip->h_NextManip;
+
+        while(p_CurManip)
+        {
+            /* If this is a unified table, point to the part of the table
+             * which is the relative offset in HMCT.
+            */
+
+            p_TmpHmctPtr = (uint8_t*)p_Manip->p_Hmct + p_Manip->tableSize + ((uint8_t*)p_CurManip->p_Hmct - p_OldHmct);
+            if(p_CurManip->p_Data)
+                p_TmpDataPtr = (uint8_t*)p_Manip->p_Hmct + p_Manip->tableSize + (p_CurManip->p_Data - p_OldHmct);
+            else
+                p_TmpDataPtr = NULL;
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, (uint32_t*)p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            /* update old manip table pointer */
+            MANIP_SET_HMCT_PTR(p_CurManip, (uint32_t*)p_TmpHmctPtr);
+            MANIP_SET_DATA_PTR(p_CurManip, p_TmpDataPtr);
+
+            p_CurManip = p_CurManip->h_PrevManip;
+       }
+        /* We copied the HMCT to create a new large HMCT so we can free the old one */
+        FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), p_OldHmct);
+    }
+
     /* Fill table */
     err = BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, TRUE);
     if (err)
@@ -757,32 +756,6 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
 
     return E_OK;
 }
-
-static t_Handle GetManipInfo(t_FmPcdManip *p_Manip, e_ManipInfo manipInfo)
-{
-     t_FmPcdManip     *p_CurManip = p_Manip;
-
-    if (!MANIP_IS_UNIFIED(p_Manip))
-        p_CurManip = p_Manip;
-    else
-    {
-        /* go to first unified */
-        while(MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
-            p_CurManip = p_CurManip->h_PrevManip;
-    }
-
-    switch (manipInfo)
-    {
-        case (e_MANIP_HMCT):
-            return p_CurManip->p_Hmct;
-        case (e_MANIP_HMTD):
-            return p_CurManip->h_Ad;
-        case (e_MANIP_HANDLER_TABLE_OWNER):
-            return (t_Handle)p_CurManip;
-        default:
-            return NULL;
-    }
-}
 static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
     uint8_t         *p_WholeHmct, newDataSize, *p_TmpDataPtr = NULL;
@@ -794,19 +767,19 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
 
 
     err = CalculateTableSize(p_FmPcdManipParams, &newSize, &newDataSize);
-    if (err)
+    if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     /* check coherency of new table parameters */
-    if (newSize > p_Manip->tableSize)
+    if(newSize > p_Manip->tableSize)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (command table)."));
-    if (newDataSize > p_Manip->dataSize)
+    if(newDataSize > p_Manip->dataSize)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (data)."));
-    if (p_FmPcdManipParams->h_NextManip)
+    if(p_FmPcdManipParams->h_NextManip)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration can not contain h_NextManip."));
-    if (MANIP_IS_UNIFIED(p_Manip) && (newSize != p_Manip->tableSize))
+    if(MANIP_IS_UNIFIED(p_Manip) && (newSize != p_Manip->tableSize))
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration in a chained manipulation requires different size than current one."));
-    if (p_Manip->dontParseAfterManip != p_FmPcdManipParams->u.hdr.dontParseAfterManip)
+    if(p_Manip->dontParseAfterManip != p_FmPcdManipParams->u.hdr.dontParseAfterManip)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration differs in dontParseAfterManip value."));
 
     p_Manip->tableSize = newSize;
@@ -814,7 +787,7 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
 
 
     /* Build the new table in the shadow */
-    if (!MANIP_IS_UNIFIED(p_Manip))
+    if(!MANIP_IS_UNIFIED(p_Manip))
     {
         p_TmpHmctPtr = (uint32_t*)((uint8_t*)p_FmPcd->p_CcShadow + 16);
         if (p_Manip->p_Data)
@@ -857,7 +830,7 @@ static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipPa
     uint32_t        *p_TmpHmctPtr;
 
     /* Build the new table in the shadow */
-    if (!MANIP_IS_UNIFIED(p_Manip))
+    if(!MANIP_IS_UNIFIED(p_Manip))
         BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, FALSE);
     else
     {
@@ -893,11 +866,11 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
     SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
 
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-           if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+           if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
             {
                 tmpReg32 = *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
                 tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
@@ -907,15 +880,15 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
             }
             else
             {
-                if (p_Manip->icOffset != icOffset)
+                if(p_Manip->icOffset != icOffset)
                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
             }
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if (p_Manip->h_Frag)
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if(p_Manip->h_Frag)
             {
-                if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+                if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
                 {
                     p_Ad     = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
                     tmpReg32 |= GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets);
@@ -926,7 +899,7 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
                 }
                 else
                 {
-                    if (p_Manip->icOffset != icOffset)
+                    if(p_Manip->icOffset != icOffset)
                             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
                 }
             }
@@ -951,9 +924,9 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
     SANITY_CHECK_RETURN_ERROR((p_Manip->opcode & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->muramAllocate, E_INVALID_STATE);
 
-    if (p_Manip->updateParams)
+    if(p_Manip->updateParams)
     {
-        if ((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
+        if((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
            (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
@@ -962,9 +935,9 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
         fmPortGetSetCcParams.setCcParams.psoSize = 16;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
         ASSERT_COND(!(fmPortGetSetCcParams.getCcParams.prOffset % 16));
@@ -972,7 +945,7 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
     }
     else if (validate)
     {
-         if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
+         if((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
            (p_Manip->updateParams & OFFSET_OF_PR))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
@@ -980,14 +953,14 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
         fmPortGetSetCcParams.setCcParams.psoSize = 16;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
 
     }
 
-   if (p_Manip->updateParams & OFFSET_OF_PR)
+   if(p_Manip->updateParams & OFFSET_OF_PR)
    {
         tmpReg32 = 0;
         tmpReg32 |= fmPortGetSetCcParams.getCcParams.prOffset;
@@ -998,7 +971,7 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
    else if (validate)
    {
         tmpReg32 = GET_UINT32(p_Ad->matchTblPtr);
-        if ((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
+        if((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"););
    }
 
@@ -1019,14 +992,14 @@ static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_
 
     p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
-    if (p_Manip->updateParams)
+    if(p_Manip->updateParams)
     {
 
-        if ((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
            ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
-        if (!p_SavedManipParams)
+        if(!p_SavedManipParams)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
         p_Manip->fragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
 
@@ -1041,9 +1014,9 @@ static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_
    {
 
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
-        if (!p_SavedManipParams)
+        if(!p_SavedManipParams)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
-        if (p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
+        if(p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
    }
 
@@ -1108,14 +1081,14 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
-        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
     }
 
-    if (p_Manip->updateParams)
+    if(p_Manip->updateParams)
     {
         tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
         tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.dataOffset<< 16);
@@ -1181,7 +1154,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
@@ -1210,7 +1183,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
@@ -1255,7 +1228,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
                                             (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
                                             4);
 
-           if (!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+           if(!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer pool table"));
 
             IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl, 0,  (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
@@ -1271,7 +1244,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
                                             (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
                                             4);
 
-            if (!p_Manip->fragParams.p_TimeOutTbl)
+            if(!p_Manip->fragParams.p_TimeOutTbl)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly timeout table"));
 
             IOMemSet32(p_Manip->fragParams.p_TimeOutTbl, 0,  (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
@@ -1412,7 +1385,7 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
     p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr =
         PTR_TO_UINT(XX_MallocSmart((uint32_t)(size * 64), p_Manip->ipReassmParams.dataMemId, 64));
 
-    if (!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
+    if(!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
 
     IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr), 0,  (uint32_t)(size * 32));
@@ -1429,7 +1402,7 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
     p_Manip->ipReassmParams.timeOutTblAddr =
         PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)(size  * 8),8));
 
-    if (!p_Manip->ipReassmParams.timeOutTblAddr)
+    if(!p_Manip->ipReassmParams.timeOutTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly timeout table"));
 
     IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr), 0,  (uint16_t)(size * 8));
@@ -1494,7 +1467,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     *p_IpReassTbl = (t_IpReassTbl *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                       FM_PCD_MANIP_IP_REASM_TABLE_SIZE,
                                                       FM_PCD_MANIP_IP_REASM_TABLE_ALIGN);
-    if (!*p_IpReassTbl)
+    if(!*p_IpReassTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly IPv4/IPv6 specific parameters table"));
     memset(*p_IpReassTbl, 0, sizeof(t_IpReassTbl));
 
@@ -1532,7 +1505,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     autoLearnHashTblSize = numOfSets * setSize;
 
     *p_AutoLearnHashTblAddr = PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize));
-    if (!*p_AutoLearnHashTblAddr)
+    if(!*p_AutoLearnHashTblAddr)
     {
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
         *p_IpReassTbl = NULL;
@@ -1551,7 +1524,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     The size of this table is (number of sets in the IP Reassembly Automatic Learning Hash table)*4 bytes.
     This table resides in external memory and its base address should be 4-byte aligned */
     *p_AutoLearnSetLockTblAddr = PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4));
-    if (!*p_AutoLearnSetLockTblAddr)
+    if(!*p_AutoLearnSetLockTblAddr)
     {
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
         *p_IpReassTbl = NULL;
@@ -1695,7 +1668,6 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
     else
     {
 #else
-#ifdef FM_EXP_FEATURES
     if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_Ptr)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1715,7 +1687,6 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
         tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv6Scheme);
         WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV6_OFFSET), tmpReg32);
     }
-#endif /* FM_EXP_FEATURES */
 #endif /* (DPAA_VERSION == 10) */
 #if (DPAA_VERSION == 10)
     }
@@ -1766,28 +1737,28 @@ static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid
 
 static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 {
-    if (p_Manip->h_Ad)
+    if(p_Manip->h_Ad)
     {
-        if (p_Manip->muramAllocate)
+        if(p_Manip->muramAllocate)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Ad);
         else
             XX_Free(p_Manip->h_Ad);
         p_Manip->h_Ad = NULL;
     }
-    if (p_Manip->p_Template)
+    if(p_Manip->p_Template)
     {
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_Template);
         p_Manip->p_Template = NULL;
     }
-    if (p_Manip->h_Frag)
+    if(p_Manip->h_Frag)
     {
-        if (p_Manip->fragParams.p_AutoLearnHashTbl)
+        if(p_Manip->fragParams.p_AutoLearnHashTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_AutoLearnHashTbl);
-        if (p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+        if(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrPoolTbl);
-        if (p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+        if(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl);
-        if (p_Manip->fragParams.p_TimeOutTbl)
+        if(p_Manip->fragParams.p_TimeOutTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_TimeOutTbl);
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Frag);
 
@@ -1839,7 +1810,7 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
             XX_FreeSmart(p_Manip->ipReassmParams.h_Ipv4Ad);
     }
 
-    if (p_Manip->p_StatsTbl)
+    if(p_Manip->p_StatsTbl)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_StatsTbl);
 }
 
@@ -1847,30 +1818,30 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
 {
 
-    if (p_ManipParams->u.hdr.rmv)
+    if(p_ManipParams->u.hdr.rmv)
     {
-        switch (p_ManipParams->u.hdr.rmvParams.type)
+        switch(p_ManipParams->u.hdr.rmvParams.type)
         {
-            case (e_FM_PCD_MANIP_RMV_BY_HDR):
-                switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+            case(e_FM_PCD_MANIP_RMV_BY_HDR):
+                switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
                 {
-                    case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
-                        if (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
+                    case(e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
+                        if(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
                         {
-                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
                             {
-                                case (HEADER_TYPE_CAPWAP_DTLS) :
+                                case(HEADER_TYPE_CAPWAP_DTLS) :
                                     p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
                                     p_Manip->muramAllocate = TRUE;
-                                    if (p_ManipParams->u.hdr.insrt)
+                                    if(p_ManipParams->u.hdr.insrt)
                                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
-                                    if (p_ManipParams->fragOrReasm)
+                                    if(p_ManipParams->fragOrReasm)
                                     {
-                                        if (!p_ManipParams->fragOrReasmParams.frag)
+                                        if(!p_ManipParams->fragOrReasmParams.frag)
                                         {
-                                            switch (p_ManipParams->fragOrReasmParams.hdr)
+                                            switch(p_ManipParams->fragOrReasmParams.hdr)
                                             {
-                                                case (HEADER_TYPE_CAPWAP):
+                                                case(HEADER_TYPE_CAPWAP):
                                                     p_Manip->opcode = HMAN_OC_CAPWAP_REASSEMBLY;
                                                     break;
                                                 default:
@@ -1887,10 +1858,10 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                         }
                         else
                         {
-                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
                             {
-                                case (HEADER_TYPE_CAPWAP_DTLS) :
-                                case (HEADER_TYPE_CAPWAP) :
+                                case(HEADER_TYPE_CAPWAP_DTLS) :
+                                case(HEADER_TYPE_CAPWAP) :
                                     if  (p_ManipParams->fragOrReasm || p_ManipParams->u.hdr.insrt)
                                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"));
                                     p_Manip->opcode = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
@@ -1910,21 +1881,21 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
         }
     }
-    else if (p_ManipParams->u.hdr.insrt)
+    else if(p_ManipParams->u.hdr.insrt)
     {
-        switch (p_ManipParams->u.hdr.insrtParams.type)
+        switch(p_ManipParams->u.hdr.insrtParams.type)
         {
-            case (e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
+            case(e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
 
                 p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
                 p_Manip->muramAllocate = FALSE;
-                if (p_ManipParams->fragOrReasm)
+                if(p_ManipParams->fragOrReasm)
                 {
-                    if (p_ManipParams->fragOrReasmParams.frag)
+                    if(p_ManipParams->fragOrReasmParams.frag)
                     {
-                           switch (p_ManipParams->fragOrReasmParams.hdr)
+                           switch(p_ManipParams->fragOrReasmParams.hdr)
                            {
-                                case (HEADER_TYPE_CAPWAP):
+                                case(HEADER_TYPE_CAPWAP):
                                     p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
                                     break;
                                 default:
@@ -1940,13 +1911,13 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
         }
     }
-    else if (p_ManipParams->fragOrReasm)
+    else if(p_ManipParams->fragOrReasm)
     {
-        if (p_ManipParams->fragOrReasmParams.frag)
+        if(p_ManipParams->fragOrReasmParams.frag)
         {
-            switch (p_ManipParams->fragOrReasmParams.hdr)
+            switch(p_ManipParams->fragOrReasmParams.hdr)
             {
-                case (HEADER_TYPE_CAPWAP):
+                case(HEADER_TYPE_CAPWAP):
                     p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
                     p_Manip->muramAllocate = FALSE;
                     break;
@@ -1958,7 +1929,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
         {
             switch (p_ManipParams->fragOrReasmParams.hdr)
             {
-                case (HEADER_TYPE_CAPWAP):
+                case(HEADER_TYPE_CAPWAP):
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
                 default:
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
@@ -1989,14 +1960,14 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("For a Header Manipulation node - no support of h_NextManip of type other than Header Manipulation."));
             }
 
-            if (p_ManipParams->u.hdr.rmv)
+            if(p_ManipParams->u.hdr.rmv)
             {
-                switch (p_ManipParams->u.hdr.rmvParams.type)
+                switch(p_ManipParams->u.hdr.rmvParams.type)
                 {
-                    case (e_FM_PCD_MANIP_RMV_BY_HDR):
-                        switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+                    case(e_FM_PCD_MANIP_RMV_BY_HDR):
+                        switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
                         {
-                            case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2) :
+                            case(e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2) :
                                 p_Manip->opcode = HMAN_OC;
                                 p_Manip->muramAllocate = TRUE;
                                 break;
@@ -2004,7 +1975,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                                  RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
                         }
                         break;
-                   case (e_FM_PCD_MANIP_RMV_GENERIC):
+                   case(e_FM_PCD_MANIP_RMV_GENERIC):
                        p_Manip->opcode = HMAN_OC;
                        p_Manip->muramAllocate = TRUE;
                        break;
@@ -2013,12 +1984,12 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 }
                 p_Manip->rmv = TRUE;
             }
-            else if (p_ManipParams->u.hdr.insrt)
+            else if(p_ManipParams->u.hdr.insrt)
             {
-                switch (p_ManipParams->u.hdr.insrtParams.type)
+                switch(p_ManipParams->u.hdr.insrtParams.type)
                 {
-                    case (e_FM_PCD_MANIP_INSRT_BY_HDR) :
-                    case (e_FM_PCD_MANIP_INSRT_GENERIC):
+                    case(e_FM_PCD_MANIP_INSRT_BY_HDR) :
+                    case(e_FM_PCD_MANIP_INSRT_GENERIC):
                         p_Manip->opcode = HMAN_OC;
                         p_Manip->muramAllocate = TRUE;
                         break;
@@ -2027,22 +1998,22 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 }
                 p_Manip->insrt = TRUE;
             }
-            else if (p_ManipParams->u.hdr.fieldUpdate)
+            else if(p_ManipParams->u.hdr.fieldUpdate)
             {
                 /* Check parameters */
-                if (p_ManipParams->u.hdr.fieldUpdateParams.type == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN)
+                if(p_ManipParams->u.hdr.fieldUpdateParams.type == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN)
                 {
-                    if ((p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
+                    if((p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
                         && (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri > 7))
                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpri should get values of 0-7 "));
-                    if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                    if(p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                     {
                         int i;
 
-                        if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal > 7)
+                        if(p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal > 7)
                             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpriDefVal should get values of 0-7 "));
                         for(i = 0 ; i < FM_PCD_MANIP_DSCP_TO_VLAN_TRANS ; i++)
-                            if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i] & 0xf0)
+                            if(p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i] & 0xf0)
                                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dscpToVpriTabl value out of range (0-15)"));
                     }
 
@@ -2052,7 +2023,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 p_Manip->muramAllocate = TRUE;
                 p_Manip->fieldUpdate = TRUE;
             }
-            else if (p_ManipParams->u.hdr.custom)
+            else if(p_ManipParams->u.hdr.custom)
             {
                 p_Manip->opcode = HMAN_OC;
                 p_Manip->muramAllocate = TRUE;
@@ -2062,12 +2033,12 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
         case e_FM_PCD_MANIP_REASSEM :
             if (p_ManipParams->h_NextManip)
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with reassembly"));
-            switch (p_ManipParams->u.reassem.hdr)
+            switch(p_ManipParams->u.reassem.hdr)
             {
-                case (HEADER_TYPE_IPv4):
+                case(HEADER_TYPE_IPv4):
                     p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv4;
                     break;
-                case (HEADER_TYPE_IPv6):
+                case(HEADER_TYPE_IPv6):
                     p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv6;
                     break;
                 default:
@@ -2078,10 +2049,10 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
         case e_FM_PCD_MANIP_FRAG :
             if (p_ManipParams->h_NextManip)
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with fragmentation"));
-            switch (p_ManipParams->u.frag.hdr)
+            switch(p_ManipParams->u.frag.hdr)
             {
-                case (HEADER_TYPE_IPv4):
-                case (HEADER_TYPE_IPv6):
+                case(HEADER_TYPE_IPv4):
+                case(HEADER_TYPE_IPv6):
                     break;
                 default:
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for fragmentation"));
@@ -2090,7 +2061,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
             p_Manip->muramAllocate = TRUE;
             break;
         case e_FM_PCD_MANIP_SPECIAL_OFFLOAD :
-            switch (p_ManipParams->u.specialOffload.type)
+            switch(p_ManipParams->u.specialOffload.type)
             {
                 case (e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC):
                     p_Manip->opcode = HMAN_OC_IPSEC_MANIP;
@@ -2123,19 +2094,19 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
     p_Ad    = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if (p_Manip->h_FmPcd != h_FmPcd)
+    if(p_Manip->h_FmPcd != h_FmPcd)
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
                      ("handler of PCD previously was initiated by different value"));
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
-    if (!p_Manip->p_StatsTbl)
+    if(!p_Manip->p_StatsTbl)
     {
 
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 = GET_UINT32(p_Ad->ccAdBase);
@@ -2144,14 +2115,14 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
             (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                         (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
                                         4);
-        if (!p_Manip->p_StatsTbl)
+        if(!p_Manip->p_StatsTbl)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation indexed statistics table"));
 
         IOMemSet32(p_Manip->p_StatsTbl, 0,  (uint32_t)(p_Manip->owner * 4));
 
         tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->p_StatsTbl) - p_FmPcd->physicalMuramBase);
 
-        if (p_Manip->cnia)
+        if(p_Manip->cnia)
             tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_CNIA;
 
         tmpReg32 |=  FM_PCD_MANIP_INDEXED_STATS_DPD;
@@ -2162,7 +2133,7 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -2188,27 +2159,27 @@ static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
     UNUSED(h_FmPcd);
     UNUSED(h_FmTree);
 
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if (!p_Manip->h_Frag)
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if(!p_Manip->h_Frag)
                 break;
-        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
             err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
             break;
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             if (p_Manip->h_Frag)
                 err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
             break;
-        case (HMAN_OC_CAPWAP_INDEXED_STATS):
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
             err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
             break;
 #endif /* FM_CAPWAP_SUPPORT */
-        case (HMAN_OC_IP_REASSEMBLY):
+        case(HMAN_OC_IP_REASSEMBLY):
             err = UpdateInitIpReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
             break;
         default:
@@ -2226,11 +2197,11 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
 
     UNUSED(level);
 
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
 
            if (p_Manip->h_Frag)
            {
@@ -2241,8 +2212,8 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
            }
            break;
 #ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if (p_Manip->h_Frag)
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if(p_Manip->h_Frag)
             {
                 err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
             }
@@ -2263,30 +2234,30 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *
     bool            byField     = p_HdrInfo->byField;
     t_FmPcdFields   field;
 
-    if (byField)
+    if(byField)
         field = p_HdrInfo->fullField;
 
-    if (byField)
+    if(byField)
     {
-        switch (hdr)
+        switch(hdr)
         {
-            case (HEADER_TYPE_ETH):
-                switch (field.eth)
+            case(HEADER_TYPE_ETH):
+                switch(field.eth)
                 {
-                    case (NET_HEADER_FIELD_ETH_TYPE):
+                    case(NET_HEADER_FIELD_ETH_TYPE):
                         *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
                         break;
                     default:
                         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type Ethernet with this field not supported"));
                 }
                 break;
-            case (HEADER_TYPE_VLAN):
-                switch (field.vlan)
+            case(HEADER_TYPE_VLAN):
+                switch(field.vlan)
                 {
-                    case (NET_HEADER_FIELD_VLAN_TCI) :
-                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    case(NET_HEADER_FIELD_VLAN_TCI) :
+                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                             *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
-                        else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                              *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
                         break;
                     default:
@@ -2299,51 +2270,51 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *
     }
     else
     {
-        switch (hdr){
-             case (HEADER_TYPE_ETH):
+        switch(hdr){
+             case(HEADER_TYPE_ETH):
                  *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
                 break;
-            case (HEADER_TYPE_USER_DEFINED_SHIM1):
+            case(HEADER_TYPE_USER_DEFINED_SHIM1):
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
                 break;
-            case (HEADER_TYPE_USER_DEFINED_SHIM2):
+            case(HEADER_TYPE_USER_DEFINED_SHIM2):
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
                 break;
-            case (HEADER_TYPE_LLC_SNAP):
+            case(HEADER_TYPE_LLC_SNAP):
                 *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
                 break;
-            case (HEADER_TYPE_PPPoE):
+            case(HEADER_TYPE_PPPoE):
                 *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
                 break;
-            case (HEADER_TYPE_MPLS):
-                 if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                         *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
-                else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                         *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
                 break;
-            case (HEADER_TYPE_IPv4):
-            case (HEADER_TYPE_IPv6):
-              if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
-              else if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
+              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
                     *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
                 break;
-            case (HEADER_TYPE_MINENCAP):
+            case(HEADER_TYPE_MINENCAP):
                 *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
                 break;
-            case (HEADER_TYPE_GRE):
+            case(HEADER_TYPE_GRE):
                 *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
                 break;
-            case (HEADER_TYPE_TCP):
-            case (HEADER_TYPE_UDP):
-            case (HEADER_TYPE_IPSEC_AH):
-            case (HEADER_TYPE_IPSEC_ESP):
-            case (HEADER_TYPE_DCCP):
-            case (HEADER_TYPE_SCTP):
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_SCTP):
                 *parseArrayOffset = CC_PC_PR_L4_OFFSET;
                 break;
-            case (HEADER_TYPE_CAPWAP):
-            case (HEADER_TYPE_CAPWAP_DTLS):
+            case(HEADER_TYPE_CAPWAP):
+            case(HEADER_TYPE_CAPWAP_DTLS):
                 *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
                 break;
             default:
@@ -2368,14 +2339,14 @@ static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_M
     if (p_Manip->rmv)
     {
         err = GetPrOffsetByHeaderOrField(&p_ManipParams->u.byHdr.u.fromStartByHdr.hdrInfo, &prsArrayOffset);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 |= (uint32_t)prsArrayOffset << 24;
         tmpReg32 |= HMAN_RMV_HDR;
     }
 
-    if (p_Manip->insrt)
+    if(p_Manip->insrt)
         tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
 
     tmpReg32 |= (uint32_t)HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
@@ -2433,7 +2404,7 @@ static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
 
 
-    if (p_Manip->h_Frag)
+    if(p_Manip->h_Frag)
     {
         p_Manip->updateParams |= INTERNAL_CONTEXT_OFFSET;
         tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
@@ -2527,7 +2498,7 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
 
     for (j=0; j<p_ManipParams->maxNumFramesInProcess*2; j++)
-        if (((j / i)  % 2)== 0)
+        if(((j / i)  % 2)== 0)
             WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->fragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
 
     tmpReg32 = 0x00008000;
@@ -2568,7 +2539,7 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                   FM_PCD_CC_AD_ENTRY_SIZE,
                                                   FM_PCD_CC_AD_TABLE_ALIGN);
-    if (!p_Manip->h_Frag)
+    if(!p_Manip->h_Frag)
          RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP fragmentation table descriptor"));
 
     IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
@@ -2578,7 +2549,7 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
 
-    if (p_ManipParams->headerOptionsCompr)
+    if(p_ManipParams->headerOptionsCompr)
         tmpReg32 |= FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
     tmpReg32 |= ((uint32_t)poolId << 8);
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
@@ -2659,7 +2630,7 @@ static t_Error SetIpv4ReassmManip(t_FmPcdManip *p_Manip)
         (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
                                  p_Manip->ipReassmParams.dataMemId,
                                  FM_PCD_CC_AD_TABLE_ALIGN);
-    if (!p_Manip->ipReassmParams.h_Ipv4Ad)
+    if(!p_Manip->ipReassmParams.h_Ipv4Ad)
     {
         ReleaseManipHandler(p_Manip, p_FmPcd);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv4 table descriptor"));
@@ -2680,7 +2651,7 @@ static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
         (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
                                  p_Manip->ipReassmParams.dataMemId,
                                  FM_PCD_CC_AD_TABLE_ALIGN);
-     if (!p_Manip->ipReassmParams.h_Ipv6Ad)
+     if(!p_Manip->ipReassmParams.h_Ipv6Ad)
      {
         ReleaseManipHandler(p_Manip, p_FmPcd);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv6 table descriptor"));
@@ -2885,7 +2856,7 @@ static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip
 
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_INDEXED_STATS;
-    if (p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
+    if(p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
         tmpReg32 |= (uint32_t)0x16 << 16;
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
@@ -2917,25 +2888,25 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_NULL_POINTER);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if (p_Manip->insrt)
+    if(p_Manip->insrt)
     {
-        if ((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
+        if((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
              (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
              RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
 
          if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
              RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
 
-         if (p_InsrtByTemplate->size > 128)
+         if(p_InsrtByTemplate->size > 128)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
 
-         if (p_InsrtByTemplate->size)
+         if(p_InsrtByTemplate->size)
          {
              p_Manip->p_Template =
                 (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                              p_InsrtByTemplate->size,
                                              FM_PCD_CC_AD_TABLE_ALIGN);
-             if (!p_Manip->p_Template)
+             if(!p_Manip->p_Template)
                  RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for manipulation header template"));
 
              tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
@@ -2947,39 +2918,39 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
         p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
 
-        if (!p_Template)
+        if(!p_Template)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of manipulation header template"));
 
         memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
 
 
-         if (p_InsrtByTemplate->modifyOuterIp)
+         if(p_InsrtByTemplate->modifyOuterIp)
          {
              ipModify = TRUE;
 
              tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
 
-             if ((tmpReg8 & 0xf0) == 0x40)
+             if((tmpReg8 & 0xf0) == 0x40)
                  tmpReg8 = 4;
-             else if ((tmpReg8 & 0xf0) == 0x60)
+             else if((tmpReg8 & 0xf0) == 0x60)
                  tmpReg8 = 6;
              else
                  tmpReg8 = 0xff;
 
-             if (tmpReg8 == 4)
+             if(tmpReg8 == 4)
              {
-                 if ((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
+                 if((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
 
-                 if (p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
+                 if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
 
                  p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
 
-                 if (p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
+                 if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
                  {
 
-                     if ((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
+                     if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
                             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
                      extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
                      blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
@@ -2989,14 +2960,14 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
                      in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
                      second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
                  }
-                 if (blockSize)
+                 if(blockSize)
                  {
                      if (!POWER_OF_2(blockSize))
                          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
                      blockSize -= 1;
                  }
 
-                 if ((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
+                 if((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
 
                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;
@@ -3012,9 +2983,9 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
 
                  /*UDP checksum has to be 0*/
-                 if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                 if(p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
                  {
-                     if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                     if((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
                          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
 
                     p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
@@ -3022,7 +2993,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
                  }
 
-                 if (p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
+                 if(p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
                      RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
 
                  tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
@@ -3055,7 +3026,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     }
 
     tmpReg32 = 0;
-    if (p_Manip->h_Frag)
+    if(p_Manip->h_Frag)
     {
         tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
         tmpReg32 |= (uint32_t)p_Manip->sizeForFragmentation << 16;
@@ -3063,7 +3034,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     else
           tmpReg32 = 0xffff0000;
 
-    if (ipModify)
+    if(ipModify)
         tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
     else
         tmpReg32 |= (uint32_t)0x0000ff00;
@@ -3112,7 +3083,7 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdM
     p_Manip->ipFragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                                              FM_PCD_CC_AD_ENTRY_SIZE,
                                                                              FM_PCD_CC_AD_TABLE_ALIGN);
-    if (!p_Manip->ipFragParams.p_Frag)
+    if(!p_Manip->ipFragParams.p_Frag)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Fragmentation table descriptor"));
     IOMemSet32( p_Manip->ipFragParams.p_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -3182,7 +3153,7 @@ static t_Error IPManip(t_FmPcdManip *p_Manip)
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
     tmpReg32 = FM_PCD_MANIP_IP_NO_FRAGMENTATION;
-    if (p_Manip->frag == TRUE)
+    if(p_Manip->frag == TRUE)
     {
         tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->ipFragParams.p_Frag) - (p_FmPcd->physicalMuramBase));
         tmpReg32  = (uint32_t)p_Manip->sizeForFragmentation << FM_PCD_MANIP_IP_MTU_SHIFT;
@@ -3251,9 +3222,9 @@ static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
 static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsParams *p_StatsParams)
 {
 
-    switch (p_StatsParams->type)
+    switch(p_StatsParams->type)
     {
-        case (e_FM_PCD_STATS_PER_FLOWID):
+        case(e_FM_PCD_STATS_PER_FLOWID):
             p_Manip->opcode = HMAN_OC_CAPWAP_INDEXED_STATS;
             p_Manip->muramAllocate = TRUE;
             break;
@@ -3311,7 +3282,7 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
             p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                         FM_PCD_CC_AD_ENTRY_SIZE,
                                                         FM_PCD_CC_AD_TABLE_ALIGN);
-             if (!p_Manip->h_Ad)
+             if(!p_Manip->h_Ad)
              {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -3324,7 +3295,7 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
         else
         {
             p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-             if (!p_Manip->h_Ad)
+             if(!p_Manip->h_Ad)
              {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -3372,10 +3343,10 @@ uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
 
     ASSERT_COND(h_Manip);
 
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             return UPDATE_NIA_ENQ_WITHOUT_DMA;
         default:
             return 0;
@@ -3391,7 +3362,7 @@ void FmPcdManipUpdateOwner(t_Handle h_Manip, bool add)
     ASSERT_COND(p_Manip);
 
     intFlags = XX_LockIntrSpinlock(p_Manip->h_Spinlock);
-    if (add)
+    if(add)
         p_Manip->owner++;
     else
     {
@@ -3410,7 +3381,6 @@ t_List *FmPcdManipGetSpinlock(t_Handle h_Manip)
     ASSERT_COND(h_Manip);
    return ((t_FmPcdManip *)h_Manip)->h_Spinlock;
 }
-
 t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, uint32_t *requiredAction)
 {
     t_FmPcdManip             *p_Manip;
@@ -3422,34 +3392,34 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
     p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
     *requiredAction = 0;
 
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
-            if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+            if(p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
                p_Manip->cnia = TRUE;
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
-        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
             p_Manip->ownerTmp++;
             break;
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) &&
                 !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
             p_Manip->ownerTmp++;
             break;
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
                 (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
             err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip, FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
-            if (err)
+            if(err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
             break;
-        case (HMAN_OC_IP_FRAGMENTATION):
+        case(HMAN_OC_IP_FRAGMENTATION):
 #if (DPAA_VERSION == 10)
             if (!(p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE))
                     RETURN_ERROR(MAJOR, E_INVALID_STATE,
@@ -3463,18 +3433,18 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
 #endif /* (DPAA_VERSION == 10) */
             p_Manip->ownerTmp++;
             break;
-        case (HMAN_OC_IP_REASSEMBLY):
-            if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+        case(HMAN_OC_IP_REASSEMBLY):
+            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
             p_Manip->ownerTmp++;
             break;
-        case (HMAN_OC_IPSEC_MANIP):
+        case(HMAN_OC_IPSEC_MANIP):
             p_Manip->ownerTmp++;
             break;
-        case (HMAN_OC):
-            if (( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE_NEXT(p_Manip))
+        case(HMAN_OC):
+            if(( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE_NEXT(p_Manip))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't have a cascaded manipulation when and Next Engine is CC"));
-            if (!MANIP_IS_FIRST(p_Manip)) //TODO Ganit - maybe change to owners
+            if(!MANIP_IS_FIRST(p_Manip)) //TODO Ganit - maybe change to owners
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_Manip is already used and may not be shared (no sharing of non-head manip nodes)"));
 
             break;
@@ -3494,19 +3464,19 @@ t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcd
     SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNode, E_INVALID_HANDLE);
 
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
             break;
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if (p_Manip->h_Frag)
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if(p_Manip->h_Frag)
             {
-                if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+                if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"));
                 err = UpdateManipIc(h_Manip, FmPcdCcGetOffset(h_FmPcdCcNode));
-                if (err)
+                if(err)
                     RETURN_ERROR(MAJOR, err, NO_MSG);
             }
             break;
@@ -3537,17 +3507,17 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
 
     /* According to "type", either build & initialize a new AD (p_AdNew) or initialize
      * p_Ad ( the AD in the match table) and set p_AdNew = NULL. */
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-        case (HMAN_OC_CAPWAP_INDEXED_STATS):
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
-        case (HMAN_OC_IPSEC_MANIP):
+        case(HMAN_OC_IPSEC_MANIP):
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
-        case (HMAN_OC_IP_FRAGMENTATION):
+        case(HMAN_OC_IP_FRAGMENTATION):
             if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_DONE) &&
                 (!p_CcNextEngineParams->params.enqueueParams.overrideFqid))
             {
@@ -3561,7 +3531,7 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
             else
                 *p_AdNewPtr = p_Manip->h_Ad;
             break;
-        case (HMAN_OC_IP_REASSEMBLY):
+        case(HMAN_OC_IP_REASSEMBLY):
             if (FmPcdManipIpReassmIsIpv6Hdr(p_Manip))
             {
                 if (!p_Manip->ipReassmParams.ipv6Assigned)
@@ -3581,14 +3551,14 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
             memcpy((uint8_t *)p_Ad, (uint8_t *)*p_AdNewPtr, sizeof(t_AdOfTypeContLookup));
             *p_AdNewPtr = NULL;
             break;
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
             *p_AdNewPtr = NULL;
             break;
-        case (HMAN_OC):
+        case(HMAN_OC):
             /* Allocate and initialize HMTD */
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
@@ -3607,9 +3577,9 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
 
     FmPcdManipUpdateOwner(h_Manip, TRUE);
 
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,   ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,  ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
@@ -3618,7 +3588,7 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
             *p_AdNewPtr = NULL;
             break;
 
-        case (HMAN_OC):
+        case(HMAN_OC):
             /* Initialize HMTD within the match table*/
             IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
             /* copy the existing HMTD */ /* ask Alla - memcpy??? */
@@ -3719,7 +3689,7 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     p_Manip->muramAllocate = FALSE;
 
     p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-     if (!p_Manip->h_Ad)
+     if(!p_Manip->h_Ad)
      {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
         XX_Free(p_Manip);
@@ -3731,7 +3701,7 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     /*treatFdStatusFieldsAsErrors = TRUE hardcoded - assumption its always come after CAAM*/
     /*Application specific = type of flowId index, move internal frame header from data to IC,
     SEC errors check*/
-    if (MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE)!= E_OK)
+    if(MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE)!= E_OK)
     {
         XX_Free(p_Manip->h_Ad);
         XX_Free(p_Manip);
@@ -3765,7 +3735,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     SANITY_CHECK_RETURN_VALUE(p_ManipParams,E_INVALID_HANDLE,NULL);
 
     p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
-    if (!p_Manip)
+    if(!p_Manip)
         return NULL;
     p_Manip->h_Spinlock = XX_InitSpinlock();
     if (!p_Manip->h_Spinlock)
@@ -3777,12 +3747,12 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     }
     INIT_LIST(&p_Manip->nodesLst);
 
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_IP_REASSEMBLY):
+        case(HMAN_OC_IP_REASSEMBLY):
             /* IpReassembly */
             err = IpReassembly(&p_ManipParams->u.reassem, p_Manip);
-            if (err)
+            if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -3790,10 +3760,10 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
             break;
-       case (HMAN_OC_IP_FRAGMENTATION):
+       case(HMAN_OC_IP_FRAGMENTATION):
             /* IpFragmentation */
             err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip);
-            if (err)
+            if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -3802,15 +3772,15 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
             }
             err = IPManip(p_Manip);
             break;
-        case (HMAN_OC_IPSEC_MANIP) :
+        case(HMAN_OC_IPSEC_MANIP) :
             err = IPSecManip(p_ManipParams, p_Manip);
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
             /* HmanType1 */
             err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->u.hdr.rmvParams, p_Manip);
             break;
-        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
             err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.u.capwapFragParams,
                                       p_Manip,
                                       p_FmPcd,
@@ -3822,36 +3792,36 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 XX_Free(p_Manip);
                 return NULL;
             }
-            if (p_Manip->insrt)
+            if(p_Manip->insrt)
                 p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
             err = InsrtHdrByTempl(&p_ManipParams->u.hdr.insrtParams, p_Manip, p_FmPcd);
             break;
-        case (HMAN_OC_CAPWAP_REASSEMBLY):
+        case(HMAN_OC_CAPWAP_REASSEMBLY):
             err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.u.capwapReasmParams,
                                    p_Manip,
                                    p_FmPcd,
                                    p_ManipParams->fragOrReasmParams.sgBpid);
-            if (err)
+            if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
                 XX_Free(p_Manip);
                 return NULL;
             }
-            if (p_Manip->rmv)
+            if(p_Manip->rmv)
                 p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             /*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
             err = CapwapRmvDtlsHdr(p_FmPcd, p_Manip);
             break;
 #endif /* FM_CAPWAP_SUPPORT */
-       case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+       case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             /*Application Specific type 1*/
             err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE);
             break;
-       case (HMAN_OC):
+       case(HMAN_OC):
            /* New Manip */
            err = CreateManipActionNew(p_Manip, p_ManipParams);
            break;
@@ -3904,9 +3874,9 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_Crnt
         /* Search in the previous node which exact index points on this current modified node for getting AD */
         for(i = 0; i < p_NodePtrOnCurrentMdfManip->numOfKeys + 1; i++)
         {
-            if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if(p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip == (t_Handle)p_CrntMdfManip)
+                if(p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip == (t_Handle)p_CrntMdfManip)
                 {
                     if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj)
                         p_AdTablePtOnCrntCurrentMdfNode =
@@ -3959,7 +3929,7 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
 
     INIT_LIST(&lstOfNodeshichPointsOnCrntMdfManip);
 
-    if ((p_ManipParams->type != e_FM_PCD_MANIP_HDR) || (p_Manip->type != e_FM_PCD_MANIP_HDR))
+    if((p_ManipParams->type != e_FM_PCD_MANIP_HDR) || (p_Manip->type != e_FM_PCD_MANIP_HDR))
         RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PCD_ManipNodeReplace Functionality supported only for Header Manipulation."));
 
     ASSERT_COND(p_Manip->opcode == HMAN_OC);
@@ -4013,7 +3983,7 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
     p_FirstManip = GetManipInfo(p_Manip, e_MANIP_HANDLER_TABLE_OWNER);//TODO GetFirstManip(p_Manip);
     ASSERT_COND(p_FirstManip);
 
-    if (!LIST_IsEmpty(&p_FirstManip->nodesLst))
+    if(!LIST_IsEmpty(&p_FirstManip->nodesLst))
         UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(p_FirstManip, &lstOfNodeshichPointsOnCrntMdfManip);
 
     p_Hmtd =(uint8_t *) GetManipInfo(p_Manip, e_MANIP_HMTD);//TODO GetHmtd(p_Manip);
@@ -4035,7 +4005,6 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
     ASSERT_COND(p_WholeHmct);
 
     /* re-build the HMCT n the origional location */
-    //memcpy(p_WholeHmct, p_ShadowHmct, GetHmctSize(p_Manip));
     err = CreateManipActionBackToOrig(p_Manip, p_ManipParams);
     if (err)
     {
@@ -4071,16 +4040,16 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
 
-    if (p_Manip->owner)
+    if(p_Manip->owner)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
 
-    if (p_Manip->h_NextManip)
+    if(p_Manip->h_NextManip)
     {
         MANIP_SET_PREV(p_Manip->h_NextManip, NULL);
         FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
     }
 
-    if (p_Manip->p_Hmct && MANIP_IS_UNIFIED_FIRST(p_Manip))
+    if(p_Manip->p_Hmct && MANIP_IS_UNIFIED_FIRST(p_Manip))
         FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_Hmct);
 
     if (p_Manip->h_Spinlock)
@@ -4103,13 +4072,13 @@ t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmP
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdManipStats, E_NULL_POINTER);
 
-    switch (p_Manip->opcode)
+    switch(p_Manip->opcode)
     {
-        case (HMAN_OC_IP_REASSEMBLY):
+        case(HMAN_OC_IP_REASSEMBLY):
             return IpReassemblyStats(p_Manip, &p_FmPcdManipStats->u.reassem.u.ipReassem);
-        case (HMAN_OC_IP_FRAGMENTATION):
+       case(HMAN_OC_IP_FRAGMENTATION):
             return IpFragmentationStats(p_Manip, &p_FmPcdManipStats->u.frag.u.ipFrag);
-        default:
+       default:
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no statistics to this type of manip"));
     }
 
@@ -4127,12 +4096,12 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsP
     SANITY_CHECK_RETURN_VALUE(p_StatsParams,E_INVALID_HANDLE,NULL);
 
     p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_StatsParams, TRUE);
-    if (!p_Manip)
+    if(!p_Manip)
         return NULL;
 
-     switch (p_Manip->opcode)
+     switch(p_Manip->opcode)
      {
-        case (HMAN_OC_CAPWAP_INDEXED_STATS):
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
             /* Indexed statistics */
             err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
             break;
@@ -4143,7 +4112,7 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsP
             return NULL;
      }
 
-     if (err)
+     if(err)
      {
          REPORT_ERROR(MAJOR, err, NO_MSG);
          ReleaseManipHandler(p_Manip, p_FmPcd);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index a051a3d..5c464f8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -117,7 +117,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
     memset(p_IpcReply, 0, (sizeof(uint8_t) * FM_PCD_MAX_REPLY_SIZE));
     *p_ReplyLength = 0;
 
-    switch (p_IpcMsg->msgId)
+    switch(p_IpcMsg->msgId)
     {
         case (FM_PCD_MASTER_IS_ALIVE):
             *(uint8_t*)(p_IpcReply->replyBody) = 1;
@@ -126,14 +126,14 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
             break;
         case (FM_PCD_MASTER_IS_ENABLED):
             /* count partitions registrations */
-            if (p_FmPcd->enabled)
+            if(p_FmPcd->enabled)
                 p_FmPcd->numOfEnabledGuestPartitionsPcds++;
             *(uint8_t*)(p_IpcReply->replyBody)  = (uint8_t)p_FmPcd->enabled;
             p_IpcReply->error = E_OK;
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
             break;
         case (FM_PCD_GUEST_DISABLE):
-            if (p_FmPcd->numOfEnabledGuestPartitionsPcds)
+            if(p_FmPcd->numOfEnabledGuestPartitionsPcds)
             {
                 p_FmPcd->numOfEnabledGuestPartitionsPcds--;
                 p_IpcReply->error = E_OK;
@@ -145,7 +145,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
             }
             *p_ReplyLength = sizeof(uint32_t);
             break;
-        case (FM_PCD_GET_COUNTER):
+        case(FM_PCD_GET_COUNTER):
         {
             e_FmPcdCounters inCounter;
             uint32_t        outCounter;
@@ -249,7 +249,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
                                   ipcAllocParams.guestId);
             break;
         }
-        case (FM_PCD_GET_SW_PRS_OFFSET):
+        case(FM_PCD_GET_SW_PRS_OFFSET):
         {
             t_FmPcdIpcSwPrsLable   ipcSwPrsLable;
             uint32_t               swPrsOffset;
@@ -263,7 +263,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
             break;
         }
-        case (FM_PCD_PRS_INC_PORT_STATS):
+        case(FM_PCD_PRS_INC_PORT_STATS):
         {
             t_FmPcdIpcPrsIncludePort   ipcPrsIncludePort;
 
@@ -381,7 +381,7 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     int     i, k, j;
 
     ASSERT_COND(p_FmPcd);
-    if (p_FmPcd->netEnvs[netEnvId].clsPlanGrpId != ILLEGAL_CLS_PLAN)
+    if(p_FmPcd->netEnvs[netEnvId].clsPlanGrpId != ILLEGAL_CLS_PLAN)
     {
         p_GrpParams->grpExists = TRUE;
         p_GrpParams->clsPlanGrpId = p_FmPcd->netEnvs[netEnvId].clsPlanGrpId;
@@ -395,16 +395,16 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
                    (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)); k++)
         {
             /* if an option exists, add it to the opts list */
-            if (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+            if(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
             {
                 /* check if this option already exists, add if it doesn't */
                 for(j = 0;j<p_GrpParams->numOfOptions;j++)
                 {
-                    if (p_GrpParams->options[j] == p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                    if(p_GrpParams->options[j] == p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
                         break;
                 }
                 p_GrpParams->optVectors[j] |= p_FmPcd->netEnvs[netEnvId].unitsVectors[i];
-                if (j == p_GrpParams->numOfOptions)
+                if(j == p_GrpParams->numOfOptions)
                 {
                     p_GrpParams->options[p_GrpParams->numOfOptions] = p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt;
                     p_GrpParams->numOfOptions++;
@@ -413,9 +413,9 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
         }
     }
 
-    if (p_GrpParams->numOfOptions == 0)
+    if(p_GrpParams->numOfOptions == 0)
     {
-        if (p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId != ILLEGAL_CLS_PLAN)
+        if(p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId != ILLEGAL_CLS_PLAN)
         {
             p_GrpParams->grpExists = TRUE;
             p_GrpParams->clsPlanGrpId = p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId;
@@ -460,7 +460,7 @@ t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
     p_Params->vector = 0;
     for(i=0; i<p_Params->numOfDistinctionUnits ;i++)
     {
-        if (p_FmPcd->netEnvs[p_Params->netEnvId].units[p_Params->unitIds[i]].hdrs[0].hdr == HEADER_TYPE_NONE)
+        if(p_FmPcd->netEnvs[p_Params->netEnvId].units[p_Params->unitIds[i]].hdrs[0].hdr == HEADER_TYPE_NONE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Requested unit was not defined for this Network Environment Characteristics module"));
         ASSERT_COND(p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]]);
         p_Params->vector |= p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]];
@@ -485,7 +485,7 @@ bool PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t uni
                   (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE));
                  k++)
                 /* check that no option exists */
-                if ((protocolOpt_t)p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                if((protocolOpt_t)p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
                     return FALSE;
             break;
         }
@@ -535,7 +535,7 @@ uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType
             for(k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS) &&
                      (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
             {
-                if ((p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr == hdr) &&
+                if((p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr == hdr) &&
                     (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt == opt))
 
                 return i;
@@ -872,10 +872,10 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     else if (p_FmPcd->guestId != NCSW_MASTER_ID)
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("No Host Command defined for a guest partition."));
 
-    if (p_FmPcdParams->kgSupport)
+    if(p_FmPcdParams->kgSupport)
     {
         p_FmPcd->p_FmPcdKg = (t_FmPcdKg *)KgConfig(p_FmPcd, p_FmPcdParams);
-        if (!p_FmPcd->p_FmPcdKg)
+        if(!p_FmPcd->p_FmPcdKg)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Keygen"));
             FM_PCD_Free(p_FmPcd);
@@ -883,10 +883,10 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         }
     }
 
-    if (p_FmPcdParams->plcrSupport)
+    if(p_FmPcdParams->plcrSupport)
     {
         p_FmPcd->p_FmPcdPlcr = (t_FmPcdPlcr *)PlcrConfig(p_FmPcd, p_FmPcdParams);
-        if (!p_FmPcd->p_FmPcdPlcr)
+        if(!p_FmPcd->p_FmPcdPlcr)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Policer"));
             FM_PCD_Free(p_FmPcd);
@@ -894,10 +894,10 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         }
     }
 
-    if (p_FmPcdParams->prsSupport)
+    if(p_FmPcdParams->prsSupport)
     {
         p_FmPcd->p_FmPcdPrs = (t_FmPcdPrs *)PrsConfig(p_FmPcd, p_FmPcdParams);
-        if (!p_FmPcd->p_FmPcdPrs)
+        if(!p_FmPcd->p_FmPcdPrs)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Parser"));
             FM_PCD_Free(p_FmPcd);
@@ -947,7 +947,7 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
 
     FM_GetRevision(p_FmPcd->h_Fm, &p_FmPcd->fmRevInfo);
 
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
     {
         memset(p_FmPcd->fmPcdIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
         if (Sprint (p_FmPcd->fmPcdIpcHandlerModuleName, "FM_PCD_%d_%d", FmGetId(p_FmPcd->h_Fm), NCSW_MASTER_ID) != 10)
@@ -993,21 +993,21 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     if (p_FmPcd->p_FmPcdKg)
     {
         err = KgInit(p_FmPcd);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if (p_FmPcd->p_FmPcdPlcr)
     {
         err = PlcrInit(p_FmPcd);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if (p_FmPcd->p_FmPcdPrs)
     {
         err = PrsInit(p_FmPcd);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1015,10 +1015,10 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     {
          /* register to inter-core messaging mechanism */
         memset(p_FmPcd->fmPcdModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-        if (Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm),NCSW_MASTER_ID) != 10)
+        if(Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm),NCSW_MASTER_ID) != 10)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
         err = XX_IpcRegisterMsgHandler(p_FmPcd->fmPcdModuleName, IpcMsgHandlerCB, p_FmPcd, FM_PCD_MAX_REPLY_SIZE);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1047,34 +1047,34 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     if (p_FmPcd->ipv6FrameIdAddr)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr));
 
-    if (p_FmPcd->enabled)
+    if(p_FmPcd->enabled)
         FM_PCD_Disable(p_FmPcd);
 
-    if (p_FmPcd->p_FmPcdDriverParam)
+    if(p_FmPcd->p_FmPcdDriverParam)
     {
         XX_Free(p_FmPcd->p_FmPcdDriverParam);
         p_FmPcd->p_FmPcdDriverParam = NULL;
     }
 
-    if (p_FmPcd->p_FmPcdKg)
+    if(p_FmPcd->p_FmPcdKg)
     {
-        if ((err = KgFree(p_FmPcd)) != E_OK)
+        if((err = KgFree(p_FmPcd)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         XX_Free(p_FmPcd->p_FmPcdKg);
         p_FmPcd->p_FmPcdKg = NULL;
     }
 
-    if (p_FmPcd->p_FmPcdPlcr)
+    if(p_FmPcd->p_FmPcdPlcr)
     {
-        if ((err = PlcrFree(p_FmPcd)) != E_OK)
+        if((err = PlcrFree(p_FmPcd)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         XX_Free(p_FmPcd->p_FmPcdPlcr);
         p_FmPcd->p_FmPcdPlcr = NULL;
     }
 
-    if (p_FmPcd->p_FmPcdPrs)
+    if(p_FmPcd->p_FmPcdPrs)
     {
-        if (p_FmPcd->guestId == NCSW_MASTER_ID)
+        if(p_FmPcd->guestId == NCSW_MASTER_ID)
             PrsFree(p_FmPcd);
         XX_Free(p_FmPcd->p_FmPcdPrs);
         p_FmPcd->p_FmPcdPrs = NULL;
@@ -1110,11 +1110,11 @@ t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bo
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigException - guest mode!"));
 
     GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
-    if (bitMask)
+    if(bitMask)
     {
         if (enable)
             p_FmPcd->exceptions |= bitMask;
@@ -1275,7 +1275,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
         if (!p_FmPcd->netEnvs[i].used)
             break;
 
-    if (i == FM_MAX_NUM_OF_PORTS)
+    if (i== FM_MAX_NUM_OF_PORTS)
     {
         REPORT_ERROR(MAJOR, E_FULL,("No more than %d netEnv's allowed.", FM_MAX_NUM_OF_PORTS));
         FmPcdUnlock(p_FmPcd, intFlags);
@@ -1324,7 +1324,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 for (j = 0; (j < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr != HEADER_TYPE_NONE); j++)
                 {
-                    if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
+                    if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
                         !p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].opt)
                     {
                         REPORT_ERROR(MINOR, E_FULL,
@@ -1445,9 +1445,9 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     for (i = 0; i < p_NetEnvParams->numOfDistinctionUnits; i++)
     {
         if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
-            switch (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
+            switch(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
             {
-                case (HEADER_TYPE_USER_DEFINED_SHIM1):
+                case(HEADER_TYPE_USER_DEFINED_SHIM1):
                     if (shim1Selected)
                     {
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header cannot be selected with UDP_IPSEC_ESP"));
@@ -1457,7 +1457,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     shim1Selected = TRUE;
                     p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000001;
                 break;
-                case (HEADER_TYPE_USER_DEFINED_SHIM2):
+                case(HEADER_TYPE_USER_DEFINED_SHIM2):
                     p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000002;
                     break;
                 default:
@@ -1467,7 +1467,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
         {
             p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x80000000 >> bitId++);
 
-            if (IS_SPECIAL_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            if(IS_SPECIAL_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
                 p_FmPcd->netEnvs[netEnvCurrId].macsecVector = p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
         }
     }
@@ -1517,7 +1517,7 @@ t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv)
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
     /* check that no port is bound to this netEnv */
-    if (p_FmPcd->netEnvs[netEnvId].owners)
+    if(p_FmPcd->netEnvs[netEnvId].owners)
     {
         RETURN_ERROR(MINOR, E_INVALID_STATE,
                 ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
@@ -1580,10 +1580,10 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
 
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PCD_KG_COUNTERS_TOTAL):
-            if (!p_FmPcd->p_FmPcdKg)
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            if(!p_FmPcd->p_FmPcdKg)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, ("KeyGen is not activated"));
                 return 0;
@@ -1598,12 +1598,12 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
             }
             break;
 
-        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
-        case (e_FM_PCD_PLCR_COUNTERS_RED):
-        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
-        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
-        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
-        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
             if (!p_FmPcd->p_FmPcdPlcr)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Policer is not activated"));
@@ -1627,24 +1627,24 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
             }
             break;
 
-        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-            if (!p_FmPcd->p_FmPcdPrs)
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if(!p_FmPcd->p_FmPcdPrs)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Parser is not activated"));
                 return 0;
@@ -1690,58 +1690,58 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
         return outCounter;
     }
 
-    switch (counter)
+    switch(counter)
     {
         /* Parser statistics */
-        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
-        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs);
-        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs);
-        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs);
-        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs);
-        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres);
-        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres);
-        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres);
-        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres);
-        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs);
-        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs);
-        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs);
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs);
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs);
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs);
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs);
-        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs);
-        case (e_FM_PCD_KG_COUNTERS_TOTAL):
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
                return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
 
         /* Policer statistics */
-        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt);
-        case (e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt);
-        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt);
-        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt);
-        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
-        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
 
         default:
@@ -1793,35 +1793,35 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetException - guest mode!"));
 
     GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
 
-    if (bitMask)
+    if(bitMask)
     {
         if (enable)
             p_FmPcd->exceptions |= bitMask;
         else
             p_FmPcd->exceptions &= ~bitMask;
 
-        switch (exception)
+        switch(exception)
         {
-            case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
-            case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
-                if (!p_FmPcd->p_FmPcdKg)
+            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+                if(!p_FmPcd->p_FmPcdKg)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
                 break;
-            case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
-            case (e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
-            case (e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
-            case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
-                if (!p_FmPcd->p_FmPcdPlcr)
+            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+                if(!p_FmPcd->p_FmPcdPlcr)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
             break;
-            case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
-            case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
-                if (!p_FmPcd->p_FmPcdPrs)
+            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+                if(!p_FmPcd->p_FmPcdPrs)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - parser is not working"));
             break;
             default:
@@ -1829,67 +1829,67 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
 
         }
 
-        switch (exception)
+        switch(exception)
         {
-            case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
-                if (enable)
+                if(enable)
                     tmpReg |= FM_PCD_KG_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_KG_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
                 break;
-            case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
-                if (enable)
+                if(enable)
                     tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
                 else
                     tmpReg &= ~FM_PCD_KG_KEYSIZE_OVERFLOW;
                 WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
                 break;
-            case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
-                if (enable)
+                if(enable)
                     tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PRS_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
                 break;
-            case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
-                if (enable)
+                if(enable)
                     tmpReg |= FM_PCD_PRS_SINGLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PRS_SINGLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever, tmpReg);
                 break;
-            case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
-                if (enable)
+                if(enable)
                     tmpReg |= FM_PCD_PLCR_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PLCR_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
                 break;
-            case (e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
-                if (enable)
+                if(enable)
                     tmpReg |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
                 else
                     tmpReg &= ~FM_PCD_PLCR_INIT_ENTRY_ERROR;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
                 break;
-            case (e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
-                if (enable)
+                if(enable)
                     tmpReg |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
                 else
                     tmpReg &= ~FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
                 break;
-            case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
-                if (enable)
+                if(enable)
                     tmpReg |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
                 else
                     tmpReg &= ~FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
@@ -1900,12 +1900,12 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
         }
         /* for ECC exceptions driver automatically enables ECC mechanism, if disabled.
            Driver may disable them automatically, depending on driver's status */
-        if (enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if(enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
             FmEnableRamsEcc(p_FmPcd->h_Fm);
-        if (!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if(!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
@@ -1924,33 +1924,33 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ForceIntr - guest mode!"));
 
-    switch (exception)
+    switch(exception)
     {
-        case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
-        case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
-            if (!p_FmPcd->p_FmPcdKg)
+        case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+            if(!p_FmPcd->p_FmPcdKg)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
             break;
-        case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
-        case (e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
-        case (e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
-        case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
-            if (!p_FmPcd->p_FmPcdPlcr)
+        case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+        case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+        case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+            if(!p_FmPcd->p_FmPcdPlcr)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
             break;
-        case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
-        case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
-           if (!p_FmPcd->p_FmPcdPrs)
+        case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+        case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+           if(!p_FmPcd->p_FmPcdPrs)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
 
     }
-    switch (exception)
+    switch(exception)
     {
         case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC))
@@ -2007,123 +2007,123 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ModifyCounter - guest mode!"));
 
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PCD_KG_COUNTERS_TOTAL):
-            if (!p_FmPcd->p_FmPcdKg)
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+            if(!p_FmPcd->p_FmPcdKg)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid counters - KeyGen is not working"));
             break;
-        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
-        case (e_FM_PCD_PLCR_COUNTERS_RED):
-        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
-        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
-        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
-        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
-            if (!p_FmPcd->p_FmPcdPlcr)
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+            if(!p_FmPcd->p_FmPcdPlcr)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid counters - Policer is not working"));
-            if (!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
-        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-            if (!p_FmPcd->p_FmPcdPrs)
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if(!p_FmPcd->p_FmPcdPrs)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
     }
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs, value);
              break;
-       case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+       case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs, value);
             break;
-        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs, value);
              break;
-        case (e_FM_PCD_KG_COUNTERS_TOTAL):
+        case(e_FM_PCD_KG_COUNTERS_TOTAL):
             WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc,value);
             break;
 
         /*Policer counters*/
-        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt, value);
             break;
-        case (e_FM_PCD_PLCR_COUNTERS_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RED):
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt, value);
             break;
-        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt, value);
             break;
-        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt, value);
             break;
-        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt, value);
             break;
-        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt, value);
             break;
         default:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 377b9f4..ac4f692 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -288,7 +288,7 @@ typedef struct {
 
 typedef struct {
     bool            allocated;
-    uint8_t         ownerId; /* guestId for KG in multi-partition only,
+    uint8_t         ownerId; /* guestId for KG in multi-partition only.
                                 portId for PLCR in any environment */
 } t_FmPcdAllocMng;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index c1e9862..928affa 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -125,10 +125,10 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
 
     switch (nextEngine)
     {
-        case e_FM_PCD_DONE:
+        case e_FM_PCD_DONE :
             switch (p_NextEngineParams->action)
             {
-                case e_FM_PCD_DROP_FRAME:
+                case e_FM_PCD_DROP_FRAME :
                     nia |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
                     break;
                 case e_FM_PCD_ENQ_FRAME:
@@ -141,19 +141,19 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
         case e_FM_PCD_KG:
             physicalSchemeId = FmPcdKgGetSchemeId(p_NextEngineParams->h_DirectScheme);
             relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
-            if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+            if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
             if (!FmPcdKgIsSchemeValidSw(p_NextEngineParams->h_DirectScheme))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
-            if (!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
+            if(!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Policer Profile may point only to a scheme that is always direct."));
             nia |= NIA_ENG_KG | NIA_KG_DIRECT | physicalSchemeId;
             break;
         case e_FM_PCD_PLCR:
             absoluteProfileId = ((t_FmPcdPlcrProfile *)p_NextEngineParams->h_Profile)->absoluteProfileId;
-            if (!IsProfileShared(p_FmPcd, absoluteProfileId))
+            if(!IsProfileShared(p_FmPcd, absoluteProfileId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next profile must be a shared profile"));
-            if (!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
+            if(!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile "));
             nia |= NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId;
             break;
@@ -254,7 +254,7 @@ static void CalcRates(t_Handle                              h_FmPcd,
      * For high rates it will never exceed the 32 bit reg (after the 16 shift), as it is
      * limited by the 10G physical port.
      */
-    if (temp != 0)
+    if(temp != 0)
     {
         /* In this case, the largest rate integer is non 0, if it does not occupy all (high) 16
          * bits of the PIR_EIR we can use this fact and enlarge it to occupy all 16 bits.
@@ -275,7 +275,7 @@ static void CalcRates(t_Handle                              h_FmPcd,
             temp = temp << 1;
             fppShift++;
         }
-        if (fppShift > 15)
+        if(fppShift > 15)
         {
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too small"));
             return;
@@ -284,7 +284,7 @@ static void CalcRates(t_Handle                              h_FmPcd,
     else
     {
         temp = (uint32_t)fraction; /* fraction will alyas be smaller than 2^16 */
-        if (!temp)
+        if(!temp)
             /* integer and fraction are 0, we set FP to its max val */
             fppShift = 31;
         else
@@ -343,13 +343,13 @@ static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
 
 /* Set G, Y, R Nia */
     err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnGreen,  &(p_ProfileParams->paramsOnGreen), &gnia);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnYellow, &(p_ProfileParams->paramsOnYellow), &ynia);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnRed,    &(p_ProfileParams->paramsOnRed), &rnia);
-   if (err)
+   if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
 /* Mode fmpl_pemode */
@@ -357,7 +357,7 @@ static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
 
     switch (p_ProfileParams->algSelection)
     {
-        case e_FM_PCD_PLCR_PASS_THROUGH:
+        case    e_FM_PCD_PLCR_PASS_THROUGH:
             p_PlcrRegs->fmpl_pecir         = 0;
             p_PlcrRegs->fmpl_pecbs         = 0;
             p_PlcrRegs->fmpl_pepepir_eir   = 0;
@@ -368,7 +368,7 @@ static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
             pemode &= ~FM_PCD_PLCR_PEMODE_ALG_MASK;
             switch (p_ProfileParams->colorMode)
             {
-                case e_FM_PCD_PLCR_COLOR_BLIND:
+                case    e_FM_PCD_PLCR_COLOR_BLIND:
                     pemode |= FM_PCD_PLCR_PEMODE_CBLND;
                     switch (p_ProfileParams->color.dfltColor)
                     {
@@ -389,7 +389,7 @@ static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
                     }
 
                     break;
-                case e_FM_PCD_PLCR_COLOR_AWARE:
+                case    e_FM_PCD_PLCR_COLOR_AWARE:
                     pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
                     break;
                 default:
@@ -397,23 +397,23 @@ static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
             }
             break;
 
-        case e_FM_PCD_PLCR_RFC_2698:
+        case    e_FM_PCD_PLCR_RFC_2698:
             /* Select algorithm MODE[ALG] = "01" */
             pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC2698;
             if (p_ProfileParams->nonPassthroughAlgParams.comittedInfoRate > p_ProfileParams->nonPassthroughAlgParams.peakOrAccessiveInfoRate)
                 RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("in RFC2698 Peak rate must be equal or larger than comittedInfoRate."));
             goto cont_rfc;
-        case e_FM_PCD_PLCR_RFC_4115:
+        case    e_FM_PCD_PLCR_RFC_4115:
             /* Select algorithm MODE[ALG] = "10" */
             pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC4115;
 cont_rfc:
             /* Select Color-Blind / Color-Aware operation (MODE[CBLND]) */
             switch (p_ProfileParams->colorMode)
             {
-                case e_FM_PCD_PLCR_COLOR_BLIND:
+                case    e_FM_PCD_PLCR_COLOR_BLIND:
                     pemode |= FM_PCD_PLCR_PEMODE_CBLND;
                     break;
-                case e_FM_PCD_PLCR_COLOR_AWARE:
+                case    e_FM_PCD_PLCR_COLOR_AWARE:
                     pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
                     /*In color aware more select override color interpretation (MODE[OVCLR]) */
                     switch (p_ProfileParams->color.override)
@@ -440,7 +440,7 @@ cont_rfc:
             /* Select Measurement Unit Mode to BYTE or PACKET (MODE[PKT]) */
             switch (p_ProfileParams->nonPassthroughAlgParams.rateMode)
             {
-                case e_FM_PCD_PLCR_BYTE_MODE:
+                case e_FM_PCD_PLCR_BYTE_MODE :
                     pemode &= ~FM_PCD_PLCR_PEMODE_PKT;
                         switch (p_ProfileParams->nonPassthroughAlgParams.byteModeParams.frameLengthSelection)
                         {
@@ -471,7 +471,7 @@ cont_rfc:
                                 RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
                         }
                     break;
-                case e_FM_PCD_PLCR_PACKET_MODE:
+                case e_FM_PCD_PLCR_PACKET_MODE :
                     pemode |= FM_PCD_PLCR_PEMODE_PKT;
                     break;
                 default:
@@ -600,15 +600,15 @@ static void EventsCB(t_Handle h_FmPcd)
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr);
-    if (force & event)
+    if(force & event)
         WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, force & ~event);
 
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr, event);
 
-    if (event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
+    if(event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
-    if (event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
+    if(event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
 }
 
@@ -627,7 +627,7 @@ static void ErrorExceptionsCB(t_Handle h_FmPcd)
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr);
-    if (force & event)
+    if(force & event)
         WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, force & ~event);
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
@@ -1186,12 +1186,12 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
     intFlags = PlcrHwLock(p_FmPcdPlcr);
     WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
 
-    if (!p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners ||
+    if(!p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners ||
        !(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction & requiredAction))
     {
-        if (requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
-            if ((p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnGreen!= e_FM_PCD_DONE) ||
+            if((p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnGreen!= e_FM_PCD_DONE) ||
                (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnYellow!= e_FM_PCD_DONE) ||
                (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnRed!= e_FM_PCD_DONE))
             {
@@ -1200,10 +1200,10 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 RETURN_ERROR (MAJOR, E_OK, ("In this case the next engine can be e_FM_PCD_DONE"));
             }
 
-            if (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnGreen.action == e_FM_PCD_ENQ_FRAME)
+            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnGreen.action == e_FM_PCD_ENQ_FRAME)
             {
                 tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia);
-                if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
                     /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
@@ -1216,10 +1216,10 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 WritePar(p_FmPcd, tmpReg32);
             }
 
-            if (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnYellow.action == e_FM_PCD_ENQ_FRAME)
+            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnYellow.action == e_FM_PCD_ENQ_FRAME)
             {
                 tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia);
-                if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
                     /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
@@ -1233,10 +1233,10 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 PlcrHwUnlock(p_FmPcdPlcr, intFlags);
             }
 
-            if (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnRed.action == e_FM_PCD_ENQ_FRAME)
+            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnRed.action == e_FM_PCD_ENQ_FRAME)
             {
                 tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia);
-                if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
                     /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
@@ -1269,7 +1269,7 @@ void FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bo
 
     ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
 
-    if (add)
+    if(add)
         p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners++;
     else
         p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners--;
@@ -1347,7 +1347,7 @@ t_Error FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle                      h_Fm
         case e_FM_PCD_PLCR_PORT_PRIVATE:
             /* get port PCD id from port handle */
             for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-                if (p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
+                if(p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
                     break;
             if (i ==  FM_MAX_NUM_OF_PORTS)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE , ("Invalid port handle."));
@@ -1406,7 +1406,7 @@ uint32_t FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId)
 bool    FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg)
 {
 
-    if (profileModeReg & FM_PCD_PLCR_PEMODE_PI)
+    if(profileModeReg & FM_PCD_PLCR_PEMODE_PI)
         return TRUE;
     else
         return FALSE;
@@ -1424,15 +1424,15 @@ uint32_t FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter)
 {
     switch(counter)
     {
-        case (e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER):
+        case(e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER):
             return FM_PCD_PLCR_PAR_PWSEL_PEGPC;
-        case (e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER):
+        case(e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER):
             return FM_PCD_PLCR_PAR_PWSEL_PEYPC;
-        case (e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER):
+        case(e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER) :
             return FM_PCD_PLCR_PAR_PWSEL_PERPC;
-        case (e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER):
+        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER) :
             return FM_PCD_PLCR_PAR_PWSEL_PERYPC;
-        case (e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER):
+        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER) :
             return FM_PCD_PLCR_PAR_PWSEL_PERRPC;
        default:
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
@@ -1445,11 +1445,11 @@ uint32_t FmPcdPlcrBuildNiaProfileReg(bool green, bool yellow, bool red)
 
     uint32_t tmpReg32 = 0;
 
-    if (green)
+    if(green)
         tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEGNIA;
-    if (yellow)
+    if(yellow)
         tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEYNIA;
-    if (red)
+    if(red)
         tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PERNIA;
 
     return tmpReg32;
@@ -1480,7 +1480,7 @@ t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
 
-    if (!FmIsMaster(p_FmPcd->h_Fm))
+    if(!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPlcrAutoRefreshMode - guest mode!"));
 
     p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
@@ -1510,11 +1510,11 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
 
-    if (!FmIsMaster(p_FmPcd->h_Fm))
+    if(!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPlcrStatistics - guest mode!"));
 
     tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
-    if (enable)
+    if(enable)
         tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
     else
         tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
@@ -1584,7 +1584,7 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
 
-    if (p_ProfileParams->modify)
+    if(p_ProfileParams->modify)
     {
         p_Profile = (t_FmPcdPlcrProfile *)p_ProfileParams->id.h_Profile;
         p_FmPcd = p_Profile->h_FmPcd;
@@ -1659,7 +1659,7 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     if (err)
     {
         REPORT_ERROR(MAJOR, err, NO_MSG);
-        if (p_ProfileParams->modify)
+        if(p_ProfileParams->modify)
             /* unlock */
             PlcrProfileFlagUnlock(p_Profile);
         if (!p_ProfileParams->modify &&
@@ -1672,9 +1672,9 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     if (p_FmPcd->h_Hc)
     {
          err = FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, (t_Handle)p_Profile, &plcrProfileReg);
-         if (p_ProfileParams->modify)
+         if(p_ProfileParams->modify)
              PlcrProfileFlagUnlock(p_Profile);
-         if (err)
+         if(err)
          {
              /* release the allocated scheme lock */
              if (!p_ProfileParams->modify &&
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index 5b401c6..f0b738f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -66,10 +66,10 @@ static void PcdPrsErrorException(t_Handle h_FmPcd)
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr, event);
 
-    DBG(TRACE, ("parser error - 0x%08x\n", event));
+    DBG(TRACE, ("parser error - 0x%08x\n",event));
 
     if(event & FM_PCD_PRS_DOUBLE_ECC)
-        p_FmPcd->f_Exception(p_FmPcd->h_App, e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
 }
 
 static void PcdPrsException(t_Handle h_FmPcd)
@@ -83,7 +83,7 @@ static void PcdPrsException(t_Handle h_FmPcd)
 
     ASSERT_COND(event & FM_PCD_PRS_SINGLE_ECC);
 
-    DBG(TRACE, ("parser event - 0x%08x\n", event));
+    DBG(TRACE, ("parser event - 0x%08x\n",event));
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr);
@@ -92,10 +92,10 @@ static void PcdPrsException(t_Handle h_FmPcd)
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr, event);
 
-    p_FmPcd->f_Exception(p_FmPcd->h_App, e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
+    p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
 }
 
-t_Handle PrsConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
+t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
 {
     t_FmPcdPrs  *p_FmPcdPrs;
     uintptr_t   baseAddr;
@@ -141,10 +141,10 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     if (p_FmPcd->guestId != NCSW_MASTER_ID)
         return E_OK;
 
-    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(sizeof(swPrsPatch), 4), 0, sizeof(uint32_t));
+    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(sizeof(swPrsPatch),4), 0, sizeof(uint32_t));
     if (!p_TmpCode)
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
-    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(sizeof(swPrsPatch), 4));
+    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(sizeof(swPrsPatch),4));
     memcpy((uint8_t *)p_TmpCode, (uint8_t *)swPrsPatch, sizeof(swPrsPatch));
 
     /**********************RPCLIM******************/
@@ -190,7 +190,7 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     /**********************PPSC******************/
 
     /* load sw parser Ip-Frag patch */
-    for (i = 0; i < DIV_CEIL(sizeof(swPrsPatch), 4); i++)
+    for (i=0; i<DIV_CEIL(sizeof(swPrsPatch),4); i++)
         WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
 
     XX_FreeSmart(p_TmpCode);
@@ -227,7 +227,7 @@ t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, boo
     uint32_t    bitMask = 0;
     uint8_t     prsPortId;
 
-    SANITY_CHECK_RETURN_ERROR((hardwarePortId >= 1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
@@ -249,7 +249,7 @@ t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_Error                     err;
 
-    SANITY_CHECK_RETURN_ERROR((hardwarePortId >= 1 && hardwarePortId <= 16), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
@@ -329,7 +329,7 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
 
     ASSERT_COND(p_FmPcd->p_FmPcdPrs->currLabel < FM_PCD_PRS_NUM_OF_LABELS);
 
-    for (i = 0; i < p_FmPcd->p_FmPcdPrs->currLabel; i++)
+    for (i=0; i<p_FmPcd->p_FmPcdPrs->currLabel; i++)
     {
         p_Label = &p_FmPcd->p_FmPcdPrs->labelsTable[i];
 
@@ -390,10 +390,10 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     if (p_FmPcd->p_FmPcdPrs->currLabel + p_SwPrs->numOfLabels > FM_PCD_PRS_NUM_OF_LABELS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceeded number of labels allowed "));
 
-    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(p_SwPrs->size, 4), 0, sizeof(uint32_t));
+    p_TmpCode = (uint32_t *)XX_MallocSmart(ROUND_UP(p_SwPrs->size,4), 0, sizeof(uint32_t));
     if (!p_TmpCode)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
-    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(p_SwPrs->size, 4));
+    memset((uint8_t *)p_TmpCode, 0, ROUND_UP(p_SwPrs->size,4));
     memcpy((uint8_t *)p_TmpCode, p_SwPrs->p_Code, p_SwPrs->size);
 
     /* save sw parser labels */
@@ -404,13 +404,13 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 
     /* load sw parser code */
     p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;
-    for (i = 0; i < DIV_CEIL(p_SwPrs->size, 4); i++)
+    for(i=0; i<DIV_CEIL(p_SwPrs->size,4); i++)
         WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
     p_FmPcd->p_FmPcdPrs->p_CurrSwPrs =
-        p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + ROUND_UP(p_SwPrs->size, 4);
+        p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + ROUND_UP(p_SwPrs->size,4);
 
     /* copy data parameters */
-    for (i = 0; i < FM_PCD_PRS_NUM_OF_HDRS; i++)
+    for (i=0;i<FM_PCD_PRS_NUM_OF_HDRS;i++)
         WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+PRS_SW_DATA/4+i), p_SwPrs->swPrsDataParams[i]);
 
     /* Clear last 4 bytes */
@@ -421,7 +421,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     return E_OK;
 }
 
-t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd, uint16_t value)
+t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
 {
     t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
index f8aa678..b4a162f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
@@ -153,7 +153,7 @@
     0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01, \
     0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03, \
     0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01, \
-    0x1B,0xFE                                          \
+    0x1B,0xFE,                                         \
 }
 #endif /* (DPAA_VERSION == 10) */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index 46a0a4d..30c57f8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -57,8 +57,8 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
     if (p_FmPort->imEn)
     {
-        if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-            if (p_FmPort->fifoDeqPipelineDepth > 2)
+        if(p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            if(p_FmPort->fifoDeqPipelineDepth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for IM 10G can't be larger than 2"));
 
         if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
@@ -69,25 +69,25 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx only                            */
         /****************************************/
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         {
             /* external buffer pools */
-            if (!p_Params->extBufPools.numOfPoolsUsed)
+            if(!p_Params->extBufPools.numOfPoolsUsed)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
 
-            if (FmSpCheckBufPoolsParams(&p_Params->extBufPools, p_Params->p_BackupBmPools, &p_Params->bufPoolDepletion)!= E_OK)
+            if(FmSpCheckBufPoolsParams(&p_Params->extBufPools, p_Params->p_BackupBmPools, &p_Params->bufPoolDepletion)!= E_OK)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
             /* Check that part of IC that needs copying is small enough to enter start margin */
-            if (p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
+            if(p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
 
-            if (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK)
+            if(p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
 
 #ifdef FM_NO_BACKUP_POOLS
     if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
-        if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+        if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("BackupBmPools"));
 #endif /* FM_NO_BACKUP_POOLS */
         }
@@ -97,19 +97,19 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         else
         {
-            if (p_Params->deqSubPortal >= FM_MAX_NUM_OF_SUB_PORTALS)
+            if(p_Params->deqSubPortal >= FM_MAX_NUM_OF_SUB_PORTALS)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", FM_MAX_NUM_OF_SUB_PORTALS));
 
             /* to protect HW internal-context from overwrite */
-            if ((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
+            if((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
 
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
                     /* in O/H DEFAULT_notSupported indicates that it is not suppported and should not be checked */
                     || (p_FmPort->fifoDeqPipelineDepth != DEFAULT_notSupported))
             {
                 /* Check that not larger than 8 */
-                if ((!p_FmPort->fifoDeqPipelineDepth) ||( p_FmPort->fifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
+                if((!p_FmPort->fifoDeqPipelineDepth) ||( p_FmPort->fifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
             }
         }
@@ -117,13 +117,13 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx Or Offline Parsing              */
         /****************************************/
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         {
 
-            if (!p_Params->dfltFqid)
+            if(!p_Params->dfltFqid)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
 #if defined(FM_CAPWAP_SUPPORT) && defined(FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004)
-            if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace % 16)
+            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace % 16)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.manipExtraSpace has to be devidable by 16"));
 #endif /* defined(FM_CAPWAP_SUPPORT) && ... */
         }
@@ -133,46 +133,46 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /* common BMI registers values */
         /* Check that Queue Id is not larger than 2^24, and is not 0 */
-        if ((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
+        if((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("errFqid must be between 1 and 2^24-1"));
-        if (p_Params->dfltFqid & ~0x00FFFFFF)
+        if(p_Params->dfltFqid & ~0x00FFFFFF)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
     }
 
     /****************************************/
     /*   Rx only                            */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* Check that divisible by 256 and not larger than 256 */
-        if (p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
+        if(p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if (!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
+        if(!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-        if (p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
+        if(p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
-        if (!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
+        if(!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
 
         /* Check that not larger than 16 */
-        if (p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
+        if(p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
 
-        if (FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
+        if(FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
         /* extra FIFO size (allowed only to Rx ports) */
-        if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
+        if(p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
 
-        if (p_Params->bufPoolDepletion.poolsGrpModeEnable &&
+        if(p_Params->bufPoolDepletion.poolsGrpModeEnable &&
            !p_Params->bufPoolDepletion.numOfPools)
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when poolsGrpModeEnable=TRUE"));
 #ifdef FM_CSI_CFED_LIMIT
         if (p_FmPort->fmRevInfo.majorRev == 4)
         {
             /* Check that not larger than 16 */
-            if (p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+            if(p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
         }
 #endif /* FM_CSI_CFED_LIMIT */
@@ -193,17 +193,17 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
         /* Check that divisible by 256 and not larger than 256 */
-        if (p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
+        if(p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if (p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
+        if(p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", BMI_MAX_FIFO_SIZE));
-        if (p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
+        if(p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if (!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
+        if(!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
 
-        if (p_FmPort->portType == e_FM_PORT_TYPE_TX)
-            if (p_FmPort->fifoDeqPipelineDepth > 2)
+        if(p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            if(p_FmPort->fifoDeqPipelineDepth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
     }
     /****************************************/
@@ -266,29 +266,29 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /****************************************/
 
     /* Check that not larger than 16 */
-    if ((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
+    if((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
 
-    if (FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
+    if(FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
     /* common BMI registers values */
-    if (p_Params->setNumOfTasks && ((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS)))
+    if(p_Params->setNumOfTasks && ((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
-    if (p_Params->setNumOfTasks && (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS))
+    if(p_Params->setNumOfTasks && (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
-    if (p_Params->setNumOfOpenDmas && ((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS)))
+    if(p_Params->setNumOfOpenDmas && ((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
-    if (p_Params->setNumOfOpenDmas && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
+    if(p_Params->setNumOfOpenDmas && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    if (p_Params->setSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
+    if(p_Params->setSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-    if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
+    if(p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_FmPort->fmRevInfo.majorRev == 4)
-        if (p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
+        if(p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
             /* this is an indication that user called config for this mode which is not supported in this integration */
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("deqPrefetchOption"));
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
@@ -338,9 +338,9 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
              !p_FmPort->imEn)
     {
 #ifdef FM_FIFO_ALLOCATION_ALG
-        if (p_FmPort->fmRevInfo.majorRev == 4)
+        if(p_FmPort->fmRevInfo.majorRev == 4)
         {
-            if (p_FmPort->rxPoolsParams.numOfPools == 1)
+            if(p_FmPort->rxPoolsParams.numOfPools == 1)
                 minFifoSizeRequired = 8*BMI_FIFO_UNITS;
             else
                 minFifoSizeRequired = (uint32_t)(DIV_CEIL(p_FmPort->rxPoolsParams.secondLargestBufSize, BMI_FIFO_UNITS) +
@@ -388,7 +388,7 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 
 static void FmPortDriverParamFree(t_FmPort *p_FmPort)
 {
-    if (p_FmPort->p_FmPortDriverParam)
+    if(p_FmPort->p_FmPortDriverParam)
     {
         XX_Free(p_FmPort->p_FmPortDriverParam);
         p_FmPort->p_FmPortDriverParam = NULL;
@@ -412,15 +412,15 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
     memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmExtPools));
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi;
             p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rmpd;
             rxPort = TRUE;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi;
             p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ompd;
             rxPort = FALSE;
@@ -432,15 +432,15 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     FmSpSetBufPoolsInAscOrderOfBufSizes(p_ExtBufPools, orderedArray, sizesArray);
 
     /* build the register value */
-    for (i = 0; i < p_ExtBufPools->numOfPoolsUsed; i++)
+    for(i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
     {
         tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
         tmpReg |= ((uint32_t)orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
         tmpReg |= sizesArray[orderedArray[i]];
         /* functionality available only for some deriviatives (limited by config) */
-        if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-            for (j = 0; j < p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools; j++)
-                if (orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
+        if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+            for(j=0;j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;j++)
+                if(orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
                 {
                     tmpReg |= BMI_EXT_BUF_POOL_BACKUP;
                     break;
@@ -468,11 +468,11 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     {
         /* calculate vector for number of pools depletion */
         vector = 0;
-        for (i = 0; i < BM_MAX_NUM_OF_POOLS; i++)
+        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
-            if (p_BufPoolDepletion->poolsToConsider[i])
+            if(p_BufPoolDepletion->poolsToConsider[i])
             {
-                for (j = 0; j < p_ExtBufPools->numOfPoolsUsed; j++)
+                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
                 {
                     if (i == orderedArray[j])
                     {
@@ -491,11 +491,11 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     {
         /* calculate vector for number of pools depletion */
         vector = 0;
-        for (i = 0; i < BM_MAX_NUM_OF_POOLS; i++)
+        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
-            if (p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
+            if(p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
             {
-                for (j = 0; j < p_ExtBufPools->numOfPoolsUsed; j++)
+                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
                 {
                     if (i == orderedArray[j])
                      {
@@ -659,7 +659,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     if (!p_FmPort->imEn)
     {
         tmpReg |= BMI_CMD_ATTR_ORDER;
-        if (p_Params->syncReq)
+        if(p_Params->syncReq)
             tmpReg |= BMI_CMD_ATTR_SYNC;
         tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
     }
@@ -680,7 +680,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     performanceContersParams.queueCompVal   = 1;
     performanceContersParams.dmaCompVal     =(uint8_t) p_FmPort->openDmas.num;
     performanceContersParams.fifoCompVal    = p_FmPort->fifoBufs.num;
-    if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams)) != E_OK)
+    if((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     WRITE_UINT32(p_Regs->fmbm_rpc, BMI_COUNTERS_EN);
@@ -752,6 +752,9 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
     {
         WRITE_UINT32(p_Regs->fmbm_tfdne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
         WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
+#if (DPAA_VERSION >= 11)
+/* TODO - what should be the TFNE for FMan v3 IM? */
+#endif /* (DPAA_VERSION >= 11) */
     }
     else
     {
@@ -832,7 +835,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
     tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
     tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
-    if (p_Params->dmaWriteOptimize)
+    if(p_Params->dmaWriteOptimize)
         tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
 
     WRITE_UINT32(p_Regs->fmbm_oda, tmpReg);
@@ -859,7 +862,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     else
         tmpReg = BMI_CMD_ATTR_ORDER | BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
 
-    if (p_Params->syncReq)
+    if(p_Params->syncReq)
         tmpReg |= BMI_CMD_ATTR_SYNC;
     tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
     WRITE_UINT32(p_Regs->fmbm_ofca, tmpReg);
@@ -871,7 +874,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         tmpReg = 0;
     WRITE_UINT32(p_Regs->fmbm_ocfg, tmpReg);
 
-    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
     {
         WRITE_UINT32(p_Regs->fmbm_ofsdm, p_Params->errorsToDiscard);
 
@@ -889,7 +892,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         {
             /* define external buffer pools */
             t_Error err = SetExtBufferPools(p_FmPort);
-            if (err)
+            if(err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 #endif /* FM_NO_OP_OBSERVED_POOLS */
@@ -930,7 +933,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
 #endif /* FM_DEQ_PIPELINE_PARAMS_FOR_OP */
 
 #ifdef FM_FRAME_END_PARAMS_FOR_OP
-    if (p_FmPort->fmRevInfo.majorRev >= 6)
+    if(p_FmPort->fmRevInfo.majorRev >= 6)
     {
         /* frame end parameters */
         tmpReg = 0;
@@ -951,7 +954,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
     p_Params = p_FmPort->p_FmPortDriverParam;
 
     /* check that port is not busy */
-    if (((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    if(((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
         (p_FmPort->portType != e_FM_PORT_TYPE_RX)) &&
        (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN))
          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
@@ -960,10 +963,10 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
     WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, QMI_PORT_CFG_EN_COUNTERS);
 
     /* The following is  done for non-Rx ports only */
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
         (p_FmPort->portType != e_FM_PORT_TYPE_RX))
     {
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+        if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
                         (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         {
             /* define dequeue NIA */
@@ -980,18 +983,18 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
 
         /* configure dequeue */
         tmpReg = 0;
-        if (p_Params->deqHighPriority)
+        if(p_Params->deqHighPriority)
             tmpReg |= QMI_DEQ_CFG_PRI;
 
-        switch (p_Params->deqType)
+        switch(p_Params->deqType)
         {
-            case (e_FM_PORT_DEQ_TYPE1):
+            case(e_FM_PORT_DEQ_TYPE1):
                 tmpReg |= QMI_DEQ_CFG_TYPE1;
                 break;
-            case (e_FM_PORT_DEQ_TYPE2):
+            case(e_FM_PORT_DEQ_TYPE2):
                 tmpReg |= QMI_DEQ_CFG_TYPE2;
                 break;
-            case (e_FM_PORT_DEQ_TYPE3):
+            case(e_FM_PORT_DEQ_TYPE3):
                 tmpReg |= QMI_DEQ_CFG_TYPE3;
                 break;
             default:
@@ -999,17 +1002,17 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
         }
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-        if (p_FmPort->fmRevInfo.majorRev != 4)
+        if(p_FmPort->fmRevInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-        switch (p_Params->deqPrefetchOption)
+        switch(p_Params->deqPrefetchOption)
         {
-            case (e_FM_PORT_DEQ_NO_PREFETCH):
+            case(e_FM_PORT_DEQ_NO_PREFETCH):
                 /* Do nothing - QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_1_FRAME = 0 */
                 break;
-            case (e_FM_PORT_DEQ_PARTIAL_PREFETCH):
+            case(e_FM_PORT_DEQ_PARTIAL_PREFETCH):
                 tmpReg |= QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
                 break;
-            case (e_FM_PORT_DEQ_FULL_PREFETCH):
+            case(e_FM_PORT_DEQ_FULL_PREFETCH):
                 tmpReg |= QMI_DEQ_CFG_PREFETCH_NO_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
                 break;
             default:
@@ -1033,26 +1036,26 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     t_FmPortRxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
 
      /* check that counters are enabled */
-    switch (counter)
-    {
-        case (e_FM_PORT_COUNTERS_CYCLE):
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
-        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+    switch(counter)
+    {
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             /* performance counters - may be read when disabled */
             break;
-        case (e_FM_PORT_COUNTERS_FRAME):
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
-        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
-            if (!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
          default:
@@ -1060,51 +1063,51 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     }
 
     /* Set counter */
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_CYCLE):
             *p_Ptr = &p_BmiRegs->fmbm_rccn;
             break;
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rtuc;
             break;
-        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rrquc;
             break;
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rduc;
             break;
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rfuc;
             break;
-        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             *p_Ptr = &p_BmiRegs->fmbm_rpac;
             break;
-        case (e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rfrc;
             break;
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rfcd;
             break;
-        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rfbc;
             break;
-        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rlfc;
             break;
-        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rffc;
             break;
-        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
             *p_Ptr = &p_BmiRegs->fmbm_rfldec;
             break;
-        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_Ptr = &p_BmiRegs->fmbm_rodc;
             break;
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_rbdc;
             break;
-        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             *p_Ptr = &p_BmiRegs->fmbm_rpec;
             break;
         default:
@@ -1119,21 +1122,21 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     t_FmPortTxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
 
      /* check that counters are enabled */
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
-        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
             /* performance counters - may be read when disabled */
             break;
-        case (e_FM_PORT_COUNTERS_FRAME):
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            if (!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -1141,36 +1144,36 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     }
 
     /* Set counter */
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_CYCLE):
            *p_Ptr = &p_BmiRegs->fmbm_tccn;
             break;
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_ttuc;
             break;
-        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_ttcquc;
             break;
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_tduc;
             break;
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_tfuc;
             break;
-        case (e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_tfrc;
             break;
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_tfdc;
             break;
-        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
            *p_Ptr = &p_BmiRegs->fmbm_tfledc;
             break;
-        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
             *p_Ptr = &p_BmiRegs->fmbm_tfufdc;
             break;
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_tbdc;
             break;
         default:
@@ -1185,29 +1188,29 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     t_FmPortOhBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
 
     /* check that counters are enabled */
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
             /* performance counters - may be read when disabled */
             break;
-        case (e_FM_PORT_COUNTERS_FRAME):
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
-        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+        case(e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
-        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
             /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
             ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
-            if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -1215,48 +1218,48 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     }
 
     /* Set counter */
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PORT_COUNTERS_CYCLE):
+        case(e_FM_PORT_COUNTERS_CYCLE):
            *p_Ptr = &p_BmiRegs->fmbm_occn;
             break;
-        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case(e_FM_PORT_COUNTERS_TASK_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_otuc;
             break;
-        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case(e_FM_PORT_COUNTERS_DMA_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_oduc;
             break;
-        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_ofuc;
             break;
-        case (e_FM_PORT_COUNTERS_FRAME):
+        case(e_FM_PORT_COUNTERS_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_ofrc;
             break;
-        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_ofdc;
             break;
-        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_offc;
             break;
-        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
           *p_Ptr = &p_BmiRegs->fmbm_ofldec;
             break;
-        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
            *p_Ptr = &p_BmiRegs->fmbm_ofwdc;
             break;
-        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
            *p_Ptr = &p_BmiRegs->fmbm_ofledc;
             break;
-        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
             *p_Ptr = &p_BmiRegs->fmbm_ofufdc;
             break;
-        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_obdc;
             break;
-        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_Ptr = &p_BmiRegs->fmbm_oodc;
             break;
-        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             *p_Ptr = &p_BmiRegs->fmbm_opec;
             break;
         default:
@@ -1272,46 +1275,46 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     u_FmPcdHdrPrsOpts           *p_prsOpts;
     uint32_t                    tmpReg = *p_SoftSeqAttachReg, tmpPrsOffset;
 
-    if (IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
+    if(IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("No additional parameters for private or special headers."));
 
-    if (p_HdrParams->errDisable)
+    if(p_HdrParams->errDisable)
         tmpReg |= PRS_HDR_ERROR_DIS;
 
     /* Set parser options */
-    if (p_HdrParams->usePrsOpts)
+    if(p_HdrParams->usePrsOpts)
     {
         p_prsOpts = &p_HdrParams->prsOpts;
-        switch (p_HdrParams->hdr)
+        switch(p_HdrParams->hdr)
         {
-            case (HEADER_TYPE_MPLS):
-                if (p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
+            case(HEADER_TYPE_MPLS):
+                if(p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
                     tmpReg |= PRS_HDR_MPLS_LBL_INTER_EN;
                 GET_PRS_HDR_NUM(hdrNum, p_prsOpts->mplsPrsOptions.nextParse);
-                if (hdrNum == ILLEGAL_HDR_NUM)
+                if(hdrNum == ILLEGAL_HDR_NUM)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
                 GET_PRS_HDR_NUM(Ipv4HdrNum, HEADER_TYPE_IPv4);
-                if (hdrNum < Ipv4HdrNum)
+                if(hdrNum < Ipv4HdrNum)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                         ("Header must be equal or higher than IPv4"));
                 tmpReg |= ((uint32_t)hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
                 break;
-            case (HEADER_TYPE_PPPoE):
+            case(HEADER_TYPE_PPPoE):
                 if (p_prsOpts->pppoePrsOptions.enableMTUCheck)
                     tmpReg |= PRS_HDR_PPPOE_MTU_CHECK_EN;
                 break;
-            case (HEADER_TYPE_IPv6):
+            case(HEADER_TYPE_IPv6):
                 if (p_prsOpts->ipv6PrsOptions.routingHdrEnable)
                     tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_EN;
                 break;
-            case (HEADER_TYPE_TCP):
+            case(HEADER_TYPE_TCP):
                 if (p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
                    tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
                 else
                    tmpReg &= ~PRS_HDR_TCP_PAD_REMOVAL;
-                break;
-            case (HEADER_TYPE_UDP):
-                if (p_prsOpts->udpPrsOptions.padIgnoreChecksum)
+               break;
+            case(HEADER_TYPE_UDP):
+                if(p_prsOpts->udpPrsOptions.padIgnoreChecksum)
                    tmpReg |= PRS_HDR_UDP_PAD_REMOVAL;
                 else
                    tmpReg &= ~PRS_HDR_UDP_PAD_REMOVAL;
@@ -1322,10 +1325,10 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     }
 
     /* set software parsing (address is devided in 2 since parser uses 2 byte access. */
-    if (p_HdrParams->swPrsEnable)
+    if(p_HdrParams->swPrsEnable)
     {
         tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
-        if (tmpPrsOffset == ILLEGAL_BASE)
+        if(tmpPrsOffset == ILLEGAL_BASE)
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
         tmpReg |= (PRS_HDR_SW_PRS_EN | tmpPrsOffset);
     }
@@ -1349,7 +1352,7 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
     {
         while (tmp)
         {
-            if (tmp & walking1Mask)
+            if(tmp & walking1Mask)
             {
                 p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = idx;
                 p_SchemeBind->numOfSchemes++;
@@ -1397,58 +1400,58 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     p_FmPort->pcdEngines = 0;
 
     /* initialize p_FmPort->pcdEngines field in port's structure */
-    switch (p_PcdParams->pcdSupport)
+    switch(p_PcdParams->pcdSupport)
     {
-        case (e_FM_PORT_PCD_SUPPORT_NONE):
+        case(e_FM_PORT_PCD_SUPPORT_NONE):
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
-        case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+        case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
+        case(e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case (e_FM_PORT_PCD_SUPPORT_CC_ONLY):
+        case(e_FM_PORT_PCD_SUPPORT_CC_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
+        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
+        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
@@ -1470,17 +1473,17 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
 
     /* get PCD registers pointers */
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[0];
             p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
@@ -1492,7 +1495,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     }
 
     /* set PCD port parameter */
-    if (p_FmPort->pcdEngines & FM_PCD_CC)
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
         err = FmPcdCcBindTree(p_FmPort->h_FmPcd,
                               p_PcdParams,
@@ -1506,9 +1509,9 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
     }
 
-    if (p_FmPort->pcdEngines & FM_PCD_KG)
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
     {
-        if (p_PcdParams->p_KgParams->numOfSchemes == 0)
+        if(p_PcdParams->p_KgParams->numOfSchemes == 0)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at least one scheme must be bound. "));
 
         err = FmPcdKgSetOrBindToClsPlanGrp(p_FmPort->h_FmPcd,
@@ -1528,7 +1531,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         schemeBind.useClsPlan = p_FmPort->useClsPlan;
 
         /* for each scheme */
-        for (i = 0; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
+        for(i=0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
         {
             ASSERT_COND(p_PcdParams->p_KgParams->h_Schemes[i]);
             physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_Schemes[i]);
@@ -1538,7 +1541,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 #if (DPAA_VERSION >= 11)
             /*because of the state that VSPE is defined per port - all PCD path should be according to this requirement
              if !VSPE - in port, for relevant scheme VSPE can not be set*/
-            if (!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
+            if(!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSPE is not at port level"));
 #endif /* (DPAA_VERSION >= 11) */
         }
@@ -1559,12 +1562,12 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
          (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
     {
-        if (!p_PcdParams->p_PlcrParams->h_Profile)
+        if(!p_PcdParams->p_PlcrParams->h_Profile)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Profile should be initialized"));
 
         absoluteProfileId = (uint16_t)FmPcdPlcrProfileGetAbsoluteId(p_PcdParams->p_PlcrParams->h_Profile);
 
-        if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+        if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Private port profile not valid."));
 
         tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
@@ -1600,34 +1603,34 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum));
         /* set after parser NIA */
         tmpReg = 0;
-        switch (p_PcdParams->pcdSupport)
+        switch(p_PcdParams->pcdSupport)
         {
-            case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
                 WRITE_UINT32(*p_BmiPrsNia, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd));
                 break;
-            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
-            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
                 tmpReg = NIA_KG_CC_EN;
-            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
-            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
-                if (p_PcdParams->p_KgParams->directScheme)
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+                if(p_PcdParams->p_KgParams->directScheme)
                 {
                     physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_DirectScheme);
                     /* check that this scheme was bound to this port */
-                    for (i = 0 ; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
-                        if (p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
+                    for(i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                        if(p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
                             break;
-                    if (i == p_PcdParams->p_KgParams->numOfSchemes)
+                    if(i == p_PcdParams->p_KgParams->numOfSchemes)
                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Direct scheme is not one of the port selected schemes."));
                     tmpReg |= (uint32_t)(NIA_KG_DIRECT | physicalSchemeId);
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
                 break;
-            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
-            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
                 WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 break;
-            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
                 break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid PCD support"));
@@ -1648,50 +1651,50 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
 
         /* set protocol options */
-        for (i = 0; p_FmPort->optArray[i]; i++)
-            switch (p_FmPort->optArray[i])
+        for(i=0;p_FmPort->optArray[i];i++)
+            switch(p_FmPort->optArray[i])
             {
-                case (ETH_BROADCAST):
+                case(ETH_BROADCAST):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
                     break;
-                case (ETH_MULTICAST):
+                case(ETH_MULTICAST):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
                     break;
-                case (VLAN_STACKED):
+                case(VLAN_STACKED):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
                     tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
                     break;
-                case (MPLS_STACKED):
+                case(MPLS_STACKED):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
                     break;
-                case (IPV4_BROADCAST_1):
+                case(IPV4_BROADCAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
                     break;
-                case (IPV4_MULTICAST_1):
+                case(IPV4_MULTICAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
                     break;
-                case (IPV4_UNICAST_2):
+                case(IPV4_UNICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
                     break;
-                case (IPV4_MULTICAST_BROADCAST_2):
+                case(IPV4_MULTICAST_BROADCAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
                     break;
-                case (IPV6_MULTICAST_1):
+                case(IPV6_MULTICAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
                     break;
-                case (IPV6_UNICAST_2):
+                case(IPV6_UNICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
                     break;
-                case (IPV6_MULTICAST_2):
+                case(IPV6_MULTICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
                     break;
@@ -1725,7 +1728,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         tmpHxs[hdrNum] |= PRS_HDR_TCP_PAD_REMOVAL;
 
         /* config additional params for specific headers */
-        for (i = 0; i < p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams; i++)
+        for (i=0; i<p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams; i++)
         {
             GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->additionalParams[i].hdr);
             if (hdrNum== ILLEGAL_HDR_NUM)
@@ -1769,12 +1772,12 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 
         /* set tpid. */
         tmpReg = PRS_TPID_DFLT;
-        if (p_PcdParams->p_PrsParams->setVlanTpid1)
+        if(p_PcdParams->p_PrsParams->setVlanTpid1)
         {
             tmpReg &= PRS_TPID2_MASK;
             tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1 << PRS_PCTPID_SHIFT;
         }
-        if (p_PcdParams->p_PrsParams->setVlanTpid2)
+        if(p_PcdParams->p_PrsParams->setVlanTpid2)
         {
             tmpReg &= PRS_TPID1_MASK;
             tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid2;
@@ -1829,18 +1832,18 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
-    if (!p_FmPort->pcdEngines)
+    if(!p_FmPort->pcdEngines)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("called for non PCD port"));
 
     /* get PCD registers pointers */
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             break;
@@ -1848,13 +1851,13 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if ((GET_UINT32(*p_BmiNia) & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+    if((GET_UINT32(*p_BmiNia) & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("port has to be detached previousely"));
 
     /* "cut" PCD out of the port's flow - go to BMI */
     /* WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)); */
 
-    if (p_FmPort->pcdEngines | FM_PCD_PRS)
+    if(p_FmPort->pcdEngines | FM_PCD_PRS)
     {
         WRITE_UINT32(*p_BmiPrsStartOffset, 0);
 
@@ -1864,7 +1867,7 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
     }
 
-    if (p_FmPort->pcdEngines & FM_PCD_KG)
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
     {
         t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
 
@@ -1872,20 +1875,20 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
 
         err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
-        if (err)
+        if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
-        if (err)
+        if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
         p_FmPort->useClsPlan = FALSE;
     }
 
-    if (p_FmPort->pcdEngines & FM_PCD_CC)
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
         /* unbind - we need to get the treeId too */
         err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd,  p_FmPort->ccTreeId);
-        if (err)
+        if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -1904,21 +1907,21 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
 pndn, pnen ... maybe were changed because of the Tree requirement*/
 
     /* get PCD registers pointers */
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
     }
 
-    if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
+    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     /* check that current NIA is BMI to BMI */
@@ -1928,29 +1931,29 @@ pndn, pnen ... maybe were changed because of the Tree requirement*/
 
     WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
 
-    if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
 
-    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
 
-    if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
-        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, p_FmPort->savedBmiFene);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
     }
-    if (p_FmPort->requiredAction & UPDATE_NIA_FPNE)
+    if(p_FmPort->requiredAction & UPDATE_NIA_FPNE)
     {
-        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne, p_FmPort->savedBmiFpne);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
     }
-    if (p_FmPort->requiredAction & UPDATE_NIA_CMNE)
+    if(p_FmPort->requiredAction & UPDATE_NIA_CMNE)
     {
-        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
@@ -1966,13 +1969,13 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     ASSERT_COND(p_FmPort);
 
     /* get PCD registers pointers */
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             break;
         default:
@@ -1982,18 +1985,18 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
 
     /* TODO - not atomic - it seems that port has to be disabled */
-    if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
     {
-        switch (p_FmPort->portType)
+        switch(p_FmPort->portType)
         {
-            case (e_FM_PORT_TYPE_TX_10G):
-            case (e_FM_PORT_TYPE_TX):
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
                 break;
-            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case (e_FM_PORT_TYPE_RX):
-            case (e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_RX):
+            case(e_FM_PORT_TYPE_RX_10G):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
                 break;
            default:
@@ -2001,16 +2004,16 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
         }
     }
 
-    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
     {
-        switch (p_FmPort->portType)
+        switch(p_FmPort->portType)
         {
-            case (e_FM_PORT_TYPE_TX_10G):
-            case (e_FM_PORT_TYPE_TX):
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
                 break;
-            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
                 break;
             default:
@@ -2018,16 +2021,16 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
         }
     }
 
-    if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
-        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
     }
 
-    if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
+    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     p_FmPort->requiredAction = 0;
@@ -2051,7 +2054,7 @@ void FmPortSetMacsecLcv(t_Handle h_FmPort)
     SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
     {
         REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Rx ports only"));
         return;
@@ -2112,7 +2115,6 @@ uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
 }
 
 #if (DPAA_VERSION >= 11)
-#ifdef FM_EXP_FEATURES
 t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **p_Value)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2128,7 +2130,7 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
     }
     else
     {
-        switch (gprFunc)
+        switch(gprFunc)
         {
             case (e_FM_PORT_GPR_MURAM_PAGE):
                 p_FmPort->p_MuramPage = FM_MURAM_AllocMem(p_FmPort->h_FmMuram,
@@ -2140,13 +2142,13 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
                 IOMemSet32(p_FmPort->p_MuramPage, 0, 256);
                 muramPageOffset = (uint32_t)(XX_VirtToPhys(p_FmPort->p_MuramPage) -
                                              p_FmPort->fmMuramPhysBaseAddr);
-                switch (p_FmPort->portType)
+                switch(p_FmPort->portType)
                 {
-                    case (e_FM_PORT_TYPE_RX_10G):
-                    case (e_FM_PORT_TYPE_RX):
+                    case(e_FM_PORT_TYPE_RX_10G):
+                    case(e_FM_PORT_TYPE_RX):
                         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr, muramPageOffset);
                         break;
-                    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ogpr, muramPageOffset);
                         break;
                     default:
@@ -2159,7 +2161,7 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
         p_FmPort->gprFunc = gprFunc;
     }
 
-    switch (p_FmPort->gprFunc)
+    switch(p_FmPort->gprFunc)
     {
         case (e_FM_PORT_GPR_MURAM_PAGE):
             *p_Value = p_FmPort->p_MuramPage;
@@ -2170,7 +2172,6 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
 
     return E_OK;
 }
-#endif /* FM_EXP_FEATURES */
 #endif /* (DPAA_VERSION >= 11) */
 
 t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcParams)
@@ -2216,7 +2217,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     if (p_CcParams->getCcParams.type & GET_NIA_FPNE)
     {
-        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne);
         else
             p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne);
@@ -2245,7 +2246,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
     {
-       if (p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
+       if(p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNEN was defined previously different"));
     }
 
@@ -2257,7 +2258,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
     {
-        if (p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
+        if(p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNDN was defined previously different"));
     }
 
@@ -2270,7 +2271,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
     {
-       if (p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
+       if(p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFENE was defined previously different"));
     }
 
@@ -2282,7 +2283,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
     {
-       if (p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
+       if(p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFPNE was defined previously different"));
     }
 
@@ -2294,7 +2295,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
     {
-       if (p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
+       if(p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xCMNE was defined previously different"));
     }
 
@@ -2302,13 +2303,13 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         !(p_FmPort->requiredAction & UPDATE_PSO))
     {
         /* get PCD registers pointers */
-         switch (p_FmPort->portType)
+         switch(p_FmPort->portType)
          {
-             case (e_FM_PORT_TYPE_RX_10G):
-             case (e_FM_PORT_TYPE_RX):
+             case(e_FM_PORT_TYPE_RX_10G):
+             case(e_FM_PORT_TYPE_RX):
                  p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
                  break;
-             case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+             case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                  p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
                  break;
              default:
@@ -2316,7 +2317,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
          }
         /* set start parsing offset */
         tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)+ p_CcParams->setCcParams.psoSize;
-        if (tmpInt>0)
+        if(tmpInt>0)
             WRITE_UINT32(*p_BmiPrsStartOffset, (uint32_t)tmpInt);
 
         p_FmPort->requiredAction |= UPDATE_PSO;
@@ -2325,7 +2326,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_PSO)
     {
-        if (p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
+        if(p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser start offset was defoned previousley different"));
     }
 
@@ -2402,7 +2403,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->maxFrameLength                                        = DEFAULT_PORT_maxFrameLength;
     /* resource distribution. */
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1)// if (p_FmPort->fmRevInfo.majorRev < 6)
+    if(1)// if(p_FmPort->fmRevInfo.majorRev < 6)
     {
         p_FmPort->fifoBufs.num                                          = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
         p_FmPort->fifoBufs.extra                                        = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
@@ -2432,16 +2433,16 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
         p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-    case (e_FM_PORT_TYPE_RX):
-    case (e_FM_PORT_TYPE_RX_10G):
+    case(e_FM_PORT_TYPE_RX):
+    case(e_FM_PORT_TYPE_RX_10G):
         /* Initialize FM port parameters for initialization phase only */
         p_FmPort->p_FmPortDriverParam->cutBytesFromEnd              = DEFAULT_PORT_cutBytesFromEnd;
         p_FmPort->p_FmPortDriverParam->enBufPoolDepletion           = FALSE;
         p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1)// if (p_FmPort->fmRevInfo.majorRev < 6)
+    if(1)// if(p_FmPort->fmRevInfo.majorRev < 6)
     {
         p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = DEFAULT_PORT_rxFifoPriElevationLevel;
         p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = DEFAULT_PORT_rxFifoThreshold;
@@ -2462,11 +2463,11 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 #endif /* (DPAA_VERSION >= 11) */
         break;
 
-    case (e_FM_PORT_TYPE_TX):
+    case(e_FM_PORT_TYPE_TX):
         p_FmPort->p_FmPortDriverParam->dontReleaseBuf               = FALSE;
-    case (e_FM_PORT_TYPE_TX_10G):
+    case(e_FM_PORT_TYPE_TX_10G):
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-        if (1)// if (p_FmPort->fmRevInfo.majorRev < 6)
+        if(1)// if(p_FmPort->fmRevInfo.majorRev < 6)
         {
             p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
             p_FmPort->fifoDeqPipelineDepth                              =
@@ -2498,20 +2499,19 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
                        DEFAULT_PORT_deqByteCnt_1G :
                        DEFAULT_PORT_deqByteCnt_10G);
         break;
-
-    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
 #if (DPAA_VERSION >= 11)
         p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
-    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
         p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
         p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
         p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
 
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1)// if (p_FmPort->fmRevInfo.majorRev < 6)
+    if(1)// if(p_FmPort->fmRevInfo.majorRev < 6)
        p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
     else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
@@ -2522,7 +2522,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     }
 
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
-        if (p_FmPort->fmRevInfo.majorRev < 6)
+        if(p_FmPort->fmRevInfo.majorRev < 6)
             p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore   = DEFAULT_notSupported;
 #endif /* !FM_FRAME_END_PARAMS_FOR_OP */
 
@@ -2540,7 +2540,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         return NULL;
     }
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if (p_FmPort->fmRevInfo.majorRev == 4)
+    if(p_FmPort->fmRevInfo.majorRev == 4)
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
@@ -2555,10 +2555,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     }
     else
     {
-        switch (p_FmPort->portType)
+        switch(p_FmPort->portType)
         {
-        case (e_FM_PORT_TYPE_RX):
-        case (e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
             /* Initialize FM port parameters for initialization phase only */
             memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
                    &p_FmPortParams->specificParams.rxParams.extBufPools,
@@ -2567,10 +2567,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
             p_FmPort->p_FmPortDriverParam->liodnOffset                  = p_FmPortParams->specificParams.rxParams.liodnOffset;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_TX):
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
             p_FmPort->p_FmPortDriverParam->deqSubPortal                 =
                 (uint8_t)(p_FmPortParams->specificParams.nonRxParams.qmChannel & QMI_DEQ_CFG_SUBPORTAL_MASK);
@@ -2585,7 +2585,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     }
 
     memset(p_FmPort->name, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-    if (Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
+    if(Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
                FmGetId(p_FmPort->h_Fm),
                ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
                  (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)) ?
@@ -2666,10 +2666,10 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
     fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
-    if (p_FmPort->fifoBufs.num)
+    if(p_FmPort->fifoBufs.num)
     {
         err = VerifySizeOfFifo(p_FmPort);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
@@ -2694,7 +2694,7 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
 
     err = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* get params for use in init */
@@ -2704,7 +2704,7 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     p_FmPort->h_FmMuram = FmGetMuramHandle(p_FmPort->h_Fm);
 
 #ifndef FM_NO_GUARANTEED_RESET_VALUES
-    if (p_FmPort->fmRevInfo.majorRev >= 6)
+    if(p_FmPort->fmRevInfo.majorRev >= 6)
     {
         p_FmPort->tasks.num = fmParams.numOfTasks;
         p_FmPort->tasks.extra = fmParams.numOfExtraTasks;
@@ -2717,24 +2717,24 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     /**********************/
     /* Init BMI Registers */
     /**********************/
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             err = BmiRxPortInit(p_FmPort);
-            if (err)
+            if(err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
             err = BmiTxPortInit(p_FmPort);
-            if (err)
+            if(err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             err = BmiOhPortInit(p_FmPort);
-            if (err)
+            if(err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
         default:
@@ -2773,7 +2773,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    if (p_FmPort->pcdEngines)
+    if(p_FmPort->pcdEngines)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
 
     if (p_FmPort->enabled)
@@ -2794,7 +2794,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     FmFreePortParams(p_FmPort->h_Fm, &fmParams);
 
 #if (DPAA_VERSION >= 11)
-    if (FmVSPFreeForPort(p_FmPort->h_Fm,
+    if(FmVSPFreeForPort(p_FmPort->h_Fm,
                         p_FmPort->portType,
                         p_FmPort->portId) != E_OK)
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSP free of port FAILED"));
@@ -2860,7 +2860,7 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->deqHighPriority = highPri;
@@ -2874,7 +2874,7 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->deqType = deqType;
@@ -2888,7 +2888,7 @@ t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOp
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
     p_FmPort->p_FmPortDriverParam->deqPrefetchOption = deqPrefetchOption;
     return E_OK;
@@ -2900,11 +2900,11 @@ t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_Backup
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->p_BackupBmPools = (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
-    if (!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+    if(!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
     memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmBackupBmPools));
 
@@ -2917,7 +2917,7 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->deqByteCnt = deqByteCnt;
@@ -2958,7 +2958,7 @@ t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->cutBytesFromEnd = cutBytesFromEnd;
@@ -2972,7 +2972,7 @@ t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_B
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
@@ -2987,7 +2987,7 @@ t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedB
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
@@ -3008,7 +3008,7 @@ t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
     memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmExtPools, sizeof(t_FmExtPools));
@@ -3022,7 +3022,7 @@ t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dontReleaseBuf = TRUE;
@@ -3048,7 +3048,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
@@ -3063,7 +3063,7 @@ t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->frmDiscardOverride = override;
@@ -3077,7 +3077,7 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
                                                             (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
@@ -3141,7 +3141,7 @@ t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
@@ -3173,7 +3173,7 @@ t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReus
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
@@ -3203,7 +3203,7 @@ t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLeve
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = minFillLevel;
@@ -3218,7 +3218,7 @@ t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelin
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Rx ports"));
 
     if (p_FmPort->imEn)
@@ -3235,7 +3235,7 @@ t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComf
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = fifoLowComfLevel;
@@ -3249,7 +3249,7 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->rxFifoThreshold = fifoThreshold;
@@ -3263,7 +3263,7 @@ t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priEle
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel = priElevationLevel;
@@ -3282,12 +3282,12 @@ t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDma
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
+    if((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
-    if (p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
+    if(p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
     err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfOpenDmas->num, (uint8_t*)&p_NumOfOpenDmas->extra, FALSE);
-    if (err)
+    if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     memcpy(&p_FmPort->openDmas, p_NumOfOpenDmas, sizeof(t_FmPortRsrc));
@@ -3306,13 +3306,13 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
     ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
 
-    if ((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
+    if((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
-    if (p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
+    if(p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
 
     err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfTasks->num, (uint8_t*)&p_NumOfTasks->extra, FALSE);
-    if (err)
+    if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     /* update driver's struct */
@@ -3335,18 +3335,18 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* extra FIFO size (allowed only to Rx ports) */
-         if (p_SizeOfFifo->extra % BMI_FIFO_UNITS)
+         if(p_SizeOfFifo->extra % BMI_FIFO_UNITS)
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-extra has to be divisible by %d", BMI_FIFO_UNITS));
     }
     else
-        if (p_SizeOfFifo->extra)
+        if(p_SizeOfFifo->extra)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No SizeOfFifo-extra for non Rx ports"));
 
     memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
 
     /* we do not change user's parameter */
     err = VerifySizeOfFifo(p_FmPort);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     err = FmSetSizeOfFifo(p_FmPort->h_Fm,
@@ -3354,7 +3354,7 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
                           &p_SizeOfFifo->num,
                           &p_SizeOfFifo->extra,
                           FALSE);
-    if (err)
+    if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
@@ -3433,21 +3433,21 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rst;
             rxPort = TRUE;
             break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
              p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
              p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tst;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ost;
             break;
@@ -3455,11 +3455,11 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
     /* check if port is already disabled */
-    if (!(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN))
+    if(!(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN))
     {
         if (!rxPort && !p_FmPort->imEn)
         {
-            if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN))
+            if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN))
                 /* port is disabled */
                 return E_OK;
             else
@@ -3522,19 +3522,19 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
             rxPort = TRUE;
             break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
              p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
             break;
         default:
@@ -3542,11 +3542,11 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
     }
 
     /* check if port is already enabled */
-    if (GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN)
+    if(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN)
     {
         if (!rxPort && !p_FmPort->imEn)
         {
-            if (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN)
+            if(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN)
                 /* port is enabled */
                 return E_OK;
             else
@@ -3583,19 +3583,19 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
                                                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
             baseGran = 16000;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
             baseGran = 10000;
@@ -3622,12 +3622,12 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 
     tmpRateLimit = (uint32_t)(p_RateLimit->rateLimit*factor/baseGran - 1);
 
-    if (!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > MAX_BURST_SIZE))
+    if(!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > MAX_BURST_SIZE))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
 
     tmpRateLimitScale = ((31 - (uint32_t)countUnitBit) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
 
-    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         tmpRateLimit |= (uint32_t)(p_RateLimit->maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
     else
     {
@@ -3635,17 +3635,17 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 
         if ((p_FmPort->fmRevInfo.majorRev == 4) || (p_FmPort->fmRevInfo.majorRev >= 6))
         {
-            switch (p_RateLimit->rateLimitDivider)
+            switch(p_RateLimit->rateLimitDivider)
             {
-                case (e_FM_PORT_DUAL_RATE_LIMITER_NONE):
+                case(e_FM_PORT_DUAL_RATE_LIMITER_NONE):
                     break;
-                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2):
+                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2):
                     tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_2;
                     break;
-                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4):
+                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4):
                     tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_4;
                     break;
-                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8):
+                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8):
                     tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_8;
                     break;
                 default:
@@ -3656,10 +3656,10 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
         else
 #endif /* ! FM_NO_ADVANCED_RATE_LIMITER */
         {
-            if (p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
+            if(p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
                     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDualRateLimitScaleDown"));
 
-            if (p_RateLimit->maxBurstSize % 1000)
+            if(p_RateLimit->maxBurstSize % 1000)
             {
                 p_RateLimit->maxBurstSize = (uint16_t)((p_RateLimit->maxBurstSize/1000)+1);
                 DBG(WARNING, ("rateLimit.maxBurstSize rounded up to %d", (p_RateLimit->maxBurstSize/1000+1)*1000));
@@ -3684,18 +3684,18 @@ t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
                                                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
            break;
@@ -3719,7 +3719,7 @@ t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     tmpReg = GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc);
-    if (enable)
+    if(enable)
         tmpReg |= QMI_PORT_CFG_EN_COUNTERS ;
     else
         tmpReg &= ~QMI_PORT_CFG_EN_COUNTERS;
@@ -3737,25 +3737,25 @@ t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpc;
             break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpc;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opc;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if (enable)
+    if(enable)
         WRITE_UINT32(*p_BmiPcReg, BMI_COUNTERS_EN);
     else
         WRITE_UINT32(*p_BmiPcReg, 0);
@@ -3771,18 +3771,18 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpcp;
             break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
             p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpcp;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opcp;
             break;
         default:
@@ -3809,26 +3809,26 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                      ("performanceCnt.fifoCompVal has to be divisible by %d",
                       BMI_FIFO_UNITS));
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             if (!p_FmPortPerformanceCnt->queueCompVal ||
                 (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                              ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d",
                               MAX_PERFORMANCE_RX_QUEUE_COMP));
             break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
             if (!p_FmPortPerformanceCnt->queueCompVal ||
                 (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                              ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d",
                               MAX_PERFORMANCE_TX_QUEUE_COMP));
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             if (p_FmPortPerformanceCnt->queueCompVal)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
             break;
@@ -3945,18 +3945,18 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rstc;
             break;
-        case (e_FM_PORT_TYPE_TX_10G):
-        case (e_FM_PORT_TYPE_TX):
+        case(e_FM_PORT_TYPE_TX_10G):
+        case(e_FM_PORT_TYPE_TX):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tstc;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ostc;
             break;
         default:
@@ -3965,7 +3965,7 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
 
     tmpReg = GET_UINT32(*p_BmiStcReg);
 
-    if (enable)
+    if(enable)
         tmpReg |= BMI_COUNTERS_EN;
     else
         tmpReg &= ~BMI_COUNTERS_EN;
@@ -3980,14 +3980,14 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t       *p_ErrQReg, *p_ErrDiscard;
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem;
             p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem;
             p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
             break;
@@ -4013,15 +4013,15 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
     SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_POOLS, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-    for (i = 0 ; i <  FM_PORT_MAX_NUM_OF_EXT_POOLS; i++)
+    for(i=0 ; i< FM_PORT_MAX_NUM_OF_EXT_POOLS ; i++)
     {
         tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if ((uint8_t)((tmpReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT) == poolId)
         {
-            if (enable)
+            if(enable)
                 tmpReg |= BMI_EXT_BUF_POOL_EN_COUNTER;
             else
                 tmpReg &= ~BMI_EXT_BUF_POOL_EN_COUNTER;
@@ -4044,19 +4044,19 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
                 return 0;
             }
             bmiCounter = FALSE;
-        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -4064,29 +4064,29 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
             break;
     }
 
-    if (bmiCounter)
+    if(bmiCounter)
     {
-        switch (p_FmPort->portType)
+        switch(p_FmPort->portType)
         {
-            case (e_FM_PORT_TYPE_RX_10G):
-            case (e_FM_PORT_TYPE_RX):
-                if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+                if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
                 break;
-            case (e_FM_PORT_TYPE_TX_10G):
-            case (e_FM_PORT_TYPE_TX):
-                if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
                 break;
-            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-                if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+                if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
@@ -4102,22 +4102,22 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     {
 
         /* check that counters are enabled */
-        if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
         {
             REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             return 0;
         }
 
         /* Set counter */
-        switch (counter)
+        switch(counter)
         {
-           case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc);
-            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc);
-            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc);
-            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc);
             default:
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
@@ -4135,15 +4135,15 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch (counter)
+    switch(counter)
     {
-        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
                         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
-        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
+        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -4151,23 +4151,23 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
             break;
     }
 
-    if (bmiCounter)
+    if(bmiCounter)
     {
-        switch (p_FmPort->portType)
+        switch(p_FmPort->portType)
         {
-            case (e_FM_PORT_TYPE_RX_10G):
-            case (e_FM_PORT_TYPE_RX):
-               if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
+               if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                 break;
-            case (e_FM_PORT_TYPE_TX_10G):
-            case (e_FM_PORT_TYPE_TX):
-               if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+               if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                 break;
-            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-               if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+               if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                  break;
             default:
@@ -4179,22 +4179,22 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     {
 
         /* check that counters are enabled */
-        if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
 
         /* Set counter */
-        switch (counter)
+        switch(counter)
         {
-           case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
+           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc, value);
                 break;
-            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc, value);
                 break;
-            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc, value);
                 break;
-            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc, value);
                 break;
             default:
@@ -4215,21 +4215,21 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
         return 0;
     }
 
-    for (i = 0; i < FM_PORT_MAX_NUM_OF_EXT_POOLS; i++)
+    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
     {
         extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
         {
             tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
-            if (tmpPool == poolId)
+            if(tmpPool == poolId)
             {
-                if (extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
                     return  GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i]);
                 else
                 {
@@ -4253,19 +4253,19 @@ t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
 
 
-    for (i = 0; i < FM_PORT_MAX_NUM_OF_EXT_POOLS; i++)
+    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
     {
         extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
         {
             tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
-            if (tmpPool == poolId)
+            if(tmpPool == poolId)
             {
-                if (extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
                 {
                     WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], value);
                     return E_OK;
@@ -4288,7 +4288,7 @@ bool FM_PORT_IsStalled(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, FALSE);
 
     err = FmIsPortStalled(p_FmPort->h_Fm, p_FmPort->hardwarePortId, &isStalled);
-    if (err != E_OK)
+    if(err != E_OK)
     {
         REPORT_ERROR(MINOR, err, NO_MSG);
         return TRUE;
@@ -4435,7 +4435,7 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
     if (numOfProfiles)
     {
         err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     /* set the port handle within the PCD policer, even if no profiles defined */
@@ -4461,7 +4461,7 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
 
     RELEASE_LOCK(p_FmPort->lock);
 
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err,NO_MSG);
 
     return E_OK;
@@ -4480,13 +4480,13 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
 
     tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC)? NIA_KG_CC_EN:0);
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             break;
         default:
@@ -4500,24 +4500,24 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     }
 
     /* if we want to change to direct scheme, we need to check that this scheme is valid */
-    if (p_FmPcdKgScheme->direct)
+    if(p_FmPcdKgScheme->direct)
     {
         physicalSchemeId = FmPcdKgGetSchemeId(p_FmPcdKgScheme->h_DirectScheme);
         /* check that this scheme is bound to this port */
-        if (!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
+        if(!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with a scheme that is not bound to this port"));
         }
 
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd, physicalSchemeId);
-        if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
         }
 
-        if (!FmPcdKgIsSchemeValidSw(p_FmPcdKgScheme->h_DirectScheme))
+        if(!FmPcdKgIsSchemeValidSw(p_FmPcdKgScheme->h_DirectScheme))
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
@@ -4546,18 +4546,18 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
 
     /* check relevance of this routine  - only when policer is used
     directly after BMI or Parser */
-    if ((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
+    if((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             tmpReg = 0;
@@ -4572,7 +4572,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
          return ERROR_CODE(E_BUSY);
     }
 
-    if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+    if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
     {
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Invalid profile"));
@@ -4580,7 +4580,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
 
     tmpReg = (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
 
-    if (p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
+    if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
     {
         /* update BMI HPNIA */
         WRITE_UINT32(*p_BmiHpnia, tmpReg);
@@ -4611,13 +4611,13 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
     /* get PCD registers pointers */
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             break;
         default:
@@ -4625,10 +4625,10 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     }
 
     /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
-    if (p_FmPort->pcdEngines & FM_PCD_CC)
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
         if (p_FmPort->h_IpReassemblyManip)
         {
@@ -4642,13 +4642,13 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
-        switch (p_FmPort->portType)
+        switch(p_FmPort->portType)
         {
-            case (e_FM_PORT_TYPE_RX_10G):
-            case (e_FM_PORT_TYPE_RX):
+            case(e_FM_PORT_TYPE_RX_10G):
+            case(e_FM_PORT_TYPE_RX):
                 p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
                 break;
-            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                 p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
                 break;
             default:
@@ -4661,7 +4661,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
              return ERROR_CODE(E_BUSY);
         }
         err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree, &ccTreePhysOffset, h_FmPort);
-        if (err)
+        if(err)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MINOR, err, NO_MSG);
@@ -4890,7 +4890,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 (p_FmPort->pcdEngines & FM_PCD_KG))
             {
                 int i;
-                for (i = 0; i < p_PcdParams->p_KgParams->numOfSchemes; i++)
+                for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
                     /* The following function must be locked */
                     FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
                                           p_PcdParams->p_KgParams->h_Schemes[i],
@@ -5017,7 +5017,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
         FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
 
     err = AttachPCD(h_FmPort);
-    if (err)
+    if(err)
     {
         DeletePcd(p_FmPort);
         if (p_FmPort->h_IpReassemblyTree)
@@ -5140,7 +5140,7 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
         (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
         (p_FmPort->fmRevInfo.majorRev < 6))
     {
-        for (i = 0; i<p_PortScheme->numOfSchemes; i++)
+        for(i=0; i<p_PortScheme->numOfSchemes; i++)
             FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PortScheme->h_Schemes[i], UPDATE_KG_NIA_CC_WA, 0);
     }
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
@@ -5198,15 +5198,15 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS , E_INVALID_STATE);
 
-    switch (p_FmPort->portType)
+    switch(p_FmPort->portType)
     {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             tmpReg = 0;
@@ -5294,12 +5294,12 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
 
     err = FmDumpPortRegs(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
-    if (err)
+    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    switch (flag)
+    switch(flag)
     {
-        case (0):
+        case(0):
 
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
@@ -5368,7 +5368,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ogpr);
         break;
-    case (1):
+    case(1):
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
@@ -5436,7 +5436,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rgpr);
         break;
-    case (2):
+    case(2):
 
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
@@ -5485,7 +5485,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnen);
     DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnetfc);
 
-    if (flag !=1)
+    if(flag !=1)
     {
         DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndn);
         DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndc);
@@ -5544,18 +5544,18 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
     memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
     memset(&priorityTmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(uint8_t));
 
-    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
     {
         tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
 
 #if (DPAA_VERSION >= 11)
-        for (j = 0; j < FM_MAX_NUM_OF_PFC_PRIORITIES; j++)
-            if (p_CongestionGrps->pfcPrioritiesEn[i][j])
+        for(j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
+            if(p_CongestionGrps->pfcPrioritiesEn[i][j])
                 priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j+1));
 #endif /* (DPAA_VERSION >= 11) */
     }
 
-    for (i = 0; i < FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
+    for (i=0; i<FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
     {
         mod = (uint8_t)(i%32);
         /* each 32 congestion groups are represented by a register */
@@ -5626,10 +5626,10 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     be out of order), we first collect all information into a 256 booleans array,
     representing each possible group. */
     memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
-    for (i = 0; i < p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
+    for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
         tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
 
-    for (i = 0; i < FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
+    for (i=0; i<FM_PORT_NUM_OF_CONGESTION_GRPS; i++)
     {
         mod = (uint8_t)(i%32);
         /* each 32 congestion groups are represented by a register */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 638bb3b..7667043 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -886,11 +886,9 @@ typedef struct {
     t_Handle                    h_IpReassemblyTree;
     uint64_t                    fmMuramPhysBaseAddr;
 #if (DPAA_VERSION >= 11)
-#ifdef FM_EXP_FEATURES
     bool                        vspe;
     e_FmPortGprFuncType         gprFunc;
     void                        *p_MuramPage;
-#endif /* FM_EXP_FEATURES */
 #endif /* (DPAA_VERSION >= 11) */
 
     t_FmPortDriverParam         *p_FmPortDriverParam;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 299227e..73728a5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -78,25 +78,25 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 {
     if (IsFmanCtrlCodeLoaded(p_Fm) && !p_Fm->p_FmDriverParam->resetOnInit)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old FMan CTRL code is loaded; FM must be reset!"));
-    if (!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
+    if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
-    if (p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
+    if(p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be divisble by %d", DMA_CAM_UNITS));
-    if (!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
+    if(!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be in the range 1 - %d", DMA_MODE_MAX_CAM_NUM_OF_ENTRIES));
-    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
-    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
-    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
+    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency must be smaller than dmaCommQThresholds.assertEmergency"));
-    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
+    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency must be smaller than dmaReadBufThresholds.assertEmergency"));
-    if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
     if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
@@ -254,15 +254,15 @@ static void    QmiErrEvent(t_Fm *p_Fm)
 
     /* clear the forced events */
     force = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif);
-    if (force & event)
+    if(force & event)
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, force & ~event);
 
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, event);
 
-    if (event & QMI_ERR_INTR_EN_DOUBLE_ECC)
+    if(event & QMI_ERR_INTR_EN_DOUBLE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DOUBLE_ECC);
-    if (event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
+    if(event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID);
 }
 
@@ -305,7 +305,7 @@ static void    DmaErrEvent(t_Fm *p_Fm)
                          tnum,
                          liodn);
     }
-    if (mask & DMA_MODE_ECC)
+    if(mask & DMA_MODE_ECC)
     {
         if (status & DMA_STATUS_FM_SPDAT_ECC)
             p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_SINGLE_PORT_ECC);
@@ -327,11 +327,11 @@ static void    FpmErrEvent(t_Fm *p_Fm)
     /* clear the all occurred events */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, event);
 
-    if ((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
+    if((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_DOUBLE_ECC);
-    if ((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
+    if((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_STALL_ON_TASKS);
-    if ((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
+    if((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_SINGLE_ECC);
 }
 
@@ -384,13 +384,13 @@ static void QmiEvent(t_Fm *p_Fm)
 
     /* clear the forced events */
     force = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_if);
-    if (force & event)
+    if(force & event)
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, force & ~event);
 
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, event);
 
-    if (event & QMI_INTR_EN_SINGLE_ECC)
+    if(event & QMI_INTR_EN_SINGLE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
 }
 
@@ -492,7 +492,7 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
         WRITE_UINT32(p_Iram->idata, p_Fm->p_FmDriverParam->firmware.p_Code[i]);
 
     compTo16 = (uint8_t)(p_Fm->p_FmDriverParam->firmware.size % 16);
-    if (compTo16)
+    if(compTo16)
         for (i=0; i < ((16-compTo16) / 4); i++)
             WRITE_UINT32(p_Iram->idata, 0xffffffff);
 
@@ -594,7 +594,7 @@ do {                                    \
         FM_G_CALL_10G_MAC_ISR(0);
     if (pending & INTR_EN_10G_MAC1)
         FM_G_CALL_10G_MAC_ISR(1);
-    if (pending & INTR_EN_TMR)
+    if(pending & INTR_EN_TMR)
         p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
 }
 
@@ -766,7 +766,7 @@ static void FreeVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOfProf
 
     for (i=base; i<numOfProfiles; i++)
     {
-        if (p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == guestId)
+        if(p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == guestId)
            p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
         else
             DBG(WARNING, ("Request for freeing storage profile window which wasn't allocated to this partition"));
@@ -802,7 +802,7 @@ static t_Error FmGuestHandleIpcMsgCB(t_Handle  h_Fm,
             t_FmIpcIsr ipcIsr;
 
             memcpy((uint8_t*)&ipcIsr, p_IpcMsg->msgBody, sizeof(t_FmIpcIsr));
-            if (ipcIsr.boolErr)
+            if(ipcIsr.boolErr)
                 GuestErrorIsr(p_Fm, ipcIsr.pendingReg);
             else
                 GuestEventIsr(p_Fm, ipcIsr.pendingReg);
@@ -921,7 +921,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             uint8_t guestId = p_IpcMsg->msgBody[0];
             /* build the FM master partition IPC address */
             memset(p_Fm->fmIpcHandlerModuleName[guestId], 0, (sizeof(char)) * MODULE_NAME_SIZE);
-            if (Sprint (p_Fm->fmIpcHandlerModuleName[guestId], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, guestId) != (guestId<10 ? 6:7))
+            if(Sprint (p_Fm->fmIpcHandlerModuleName[guestId], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, guestId) != (guestId<10 ? 6:7))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
             p_Fm->h_IpcSessions[guestId] = XX_IpcInitSession(p_Fm->fmIpcHandlerModuleName[guestId], p_Fm->fmModuleName);
             if (p_Fm->h_IpcSessions[guestId] == NULL)
@@ -1543,7 +1543,7 @@ t_Error FmVSPAllocForPort (t_Handle        h_Fm,
         {
             profilesFound++;
             i++;
-            if (profilesFound == numOfVSPs)
+            if(profilesFound == numOfVSPs)
                 break;
         }
         else
@@ -1867,7 +1867,7 @@ void  FmUnregisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
 
     ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
 
-    if (p_Fm->guestId != NCSW_MASTER_ID)
+    if(p_Fm->guestId != NCSW_MASTER_ID)
     {
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM in guest-mode"));
         return;
@@ -2029,7 +2029,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
 
     intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
-    if (p_PortParams->independentMode)
+    if(p_PortParams->independentMode)
     {
         /* set port parameters */
         p_Fm->independentMode = p_PortParams->independentMode;
@@ -2037,9 +2037,9 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_mxd, 0);
     }
 
-    if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+    if(p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
-        if (p_Fm->hcPortInitialized)
+        if(p_Fm->hcPortInitialized)
         {
             XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
@@ -2050,16 +2050,16 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] = p_PortParams->portType;
 
     err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, &p_PortParams->numOfTasks, &p_PortParams->numOfExtraTasks, TRUE);
-    if (err)
+    if(err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-    if ((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
+    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
        (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
     {
@@ -2097,7 +2097,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 #ifdef FM_LOW_END_RESTRICTION
     if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
     {
-        if (p_Fm->p_FmStateStruct->lowEndRestriction)
+        if(p_Fm->p_FmStateStruct->lowEndRestriction)
         {
             XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
@@ -2112,7 +2112,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
                           &p_PortParams->sizeOfFifo,
                           &p_PortParams->extraSizeOfFifo,
                           TRUE);
-    if (err)
+    if(err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2123,7 +2123,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
                              &p_PortParams->numOfOpenDmas,
                              &p_PortParams->numOfExtraOpenDmas,
                              TRUE);
-    if (err)
+    if(err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2134,9 +2134,9 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
         tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
-        if (p_PortParams->independentMode)
+        if(p_PortParams->independentMode)
         {
-            if ((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
+            if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
                 tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
             else
                 tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
@@ -2146,7 +2146,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
             tmpReg |= (FPM_PORT_FM_CTL2|FPM_PORT_FM_CTL1);
 
             /* order restoration */
-            if (hardwarePortId%2)
+            if(hardwarePortId%2)
                 tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
             else
                 tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
@@ -2156,7 +2156,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 
     /* set LIODN base for this port */
     tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
-    if (hardwarePortId%2)
+    if(hardwarePortId%2)
     {
         tmpReg &= ~FM_LIODN_BASE_MASK;
         tmpReg |= (uint32_t)p_PortParams->liodnBase;
@@ -2273,7 +2273,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     /* WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], 0); */
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
     if ((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
         (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
@@ -2425,7 +2425,7 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
 #ifndef FM_MAC_RESET
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
         return E_OK;
-#endif /* FM_MAC_RESET */
+#endif /*(FM_MAC_RESET >= 11)*/
 
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
@@ -2540,7 +2540,7 @@ t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_
 #if (defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS))
     if (type == e_FM_MAC_10G)
     {
-        if ((!p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId])
+        if((!p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId])
            || (p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId] &&
               (mtu <= p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId])))
                p_Fm->p_FmStateStruct->macMaxFrameLengths10G[macId] = mtu;
@@ -2552,7 +2552,7 @@ t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_
 #else
     UNUSED(type);
 #endif /* (defined(FM_MAX_NUM_OF_10G_MACS) && ... */
-    if ((!p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId])
+    if((!p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId])
        || (p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId] &&
           (mtu <= p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId])))
         p_Fm->p_FmStateStruct->macMaxFrameLengths1G[macId] = mtu;
@@ -2596,7 +2596,7 @@ uint32_t FmGetTimeStampScale(t_Handle h_Fm)
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
-        if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
+        if(replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
         memcpy((uint8_t*)&timeStamp, reply.replyBody, sizeof(uint32_t));
@@ -2810,7 +2810,7 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     {
         DBG(WARNING, ("No Ipc - can't validate FM total-fifo size."));
 
-        if (sizeOfFifo)
+        if(sizeOfFifo)
         {
             /* whether it is the first time with explicit value, or runtime "set" - write register */
             tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
@@ -2830,7 +2830,7 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
                      ("running in guest-mode without neither IPC nor mapped register!"));
 
-    if (!initialConfig || !sizeOfFifo)
+    if(!initialConfig || !sizeOfFifo)
     {
         /* !initialConfig - runtime change of existing value.
          * !numOfTasks - first configuration according to values in regs.
@@ -2847,9 +2847,9 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     {
         /* This is the first configuration and user did not specify value (!numOfTasks),
          * reset values will be used and we just save these values for resource management */
-        if (currentExtraVal)
+        if(currentExtraVal)
         {
-            if (!p_Fm->p_FmStateStruct->extraFifoPoolSize)
+            if(!p_Fm->p_FmStateStruct->extraFifoPoolSize)
                 /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
                  * must be initialized to 1 buffer per port
                  */
@@ -3056,7 +3056,7 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
     {
         DBG(WARNING, ("No Ipc - can't validate FM total-num-of-tasks."));
 
-        if (numOfTasks)
+        if(numOfTasks)
         {
             /* whether it is the first time with explicit value, or runtime "set" - write register */
             tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
@@ -3077,7 +3077,7 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
                      ("running in guest-mode without neither IPC nor mapped register!"));
 
-    if (!initialConfig || !numOfTasks)
+    if(!initialConfig || !numOfTasks)
     {
         /* !initialConfig - runtime change of existing value.
          * !numOfTasks - first configuration according to values in regs.
@@ -3095,7 +3095,7 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
          * reset values will be used and we just save these values for resource management */
          p_Fm->p_FmStateStruct->extraTasksPoolSize =
                     (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, currentExtraVal);
-         if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks + currentVal) >
+         if((p_Fm->p_FmStateStruct->accumulatedNumOfTasks + currentVal) >
                  (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
              RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
                                       ("Total ports' numOfTasks and extra tasks pool for fm%d exceed total available numOfTasks.",
@@ -3322,7 +3322,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     {
         /*DBG(WARNING, ("No Ipc - can't validate FM total-num-of-dmas."));*/
 
-        if (numOfOpenDmas)
+        if(numOfOpenDmas)
         {
             /* whether it is the first time with explicit value, or runtime "set" - write register */
             tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
@@ -3347,7 +3347,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     /* it's illegal to be in a state where this is not the first set and no value is specified */
     ASSERT_COND(initialConfig || numOfOpenDmas);
 
-    if (!initialConfig || !numOfOpenDmas)
+    if(!initialConfig || !numOfOpenDmas)
     {
         /* !initialConfig - runtime change of existing value.
          * !numOfTasks - first configuration according to values in regs.
@@ -3471,7 +3471,7 @@ t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
     p_Fm = (t_Fm*)h_Fm;
 
     err = FmVSPCheckRelativeProfile(h_Fm, portType, portId, relativeProfile);
-    if (err != E_OK)
+    if(err != E_OK)
         return err;
 
     SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
@@ -3522,14 +3522,14 @@ static t_Error InitFmDma(t_Fm *p_Fm)
             tmpReg |= DMA_MODE_ECC;
     }
 
-    if (p_FmDriverParam->dmaStopOnBusError)
+    if(p_FmDriverParam->dmaStopOnBusError)
         tmpReg |= DMA_MODE_SBER;
     tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
     if (p_FmDriverParam->dmaEnEmergency)
     {
         tmpReg |= p_FmDriverParam->dmaEmergency.emergencyBusSelect;
         tmpReg |= p_FmDriverParam->dmaEmergency.emergencyLevel << DMA_MODE_EMERGENCY_LEVEL_SHIFT;
-        if (p_FmDriverParam->dmaEnEmergencySmoother)
+        if(p_FmDriverParam->dmaEnEmergencySmoother)
             WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr, p_FmDriverParam->dmaEmergencySwitchCounter);
     }
     tmpReg |= ((p_FmDriverParam->dmaCamNumOfEntries/DMA_CAM_UNITS) - 1) << DMA_MODE_CEN_SHIFT;
@@ -3745,9 +3745,9 @@ static t_Error InitFmQmi(t_Fm *p_Fm)
      /* Clear error interrupt events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, (QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF));
     tmpReg = 0;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
         tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
-    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC)
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC)
         tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
     /* enable events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
@@ -3766,7 +3766,7 @@ static t_Error InitFmQmi(t_Fm *p_Fm)
         else
         {
             tmpReg = (uint32_t)(periodInFmClocks/64);
-            if (!tmpReg)
+            if(!tmpReg)
                 tmpReg = 1;
         }
         tmpReg <<= QMI_TAPC_TAP;
@@ -3779,7 +3779,7 @@ static t_Error InitFmQmi(t_Fm *p_Fm)
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
     {
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
-        if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
+        if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
             tmpReg |= QMI_INTR_EN_SINGLE_ECC;
         /* enable events */
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
@@ -3818,7 +3818,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
         t_FmIpcParams           ipcParams;
 
         err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmGuestHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
-        if (err)
+        if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         memset(&msg, 0, sizeof(msg));
@@ -3838,7 +3838,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
                                          p_Fm)) != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
             while(blockingFlag) ;
-            if (replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
+            if(replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
             isMasterAlive = *(uint8_t*)(reply.replyBody);
         } while (!isMasterAlive);
@@ -3856,7 +3856,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (replyLength != (sizeof(uint32_t) + sizeof(t_FmIpcParams)))
+        if(replyLength != (sizeof(uint32_t) + sizeof(t_FmIpcParams)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         memcpy((uint8_t*)&ipcParams, reply.replyBody, sizeof(t_FmIpcParams));
 
@@ -4104,7 +4104,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
     /* Chip dependent, will be configured in Init */
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+    if(1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
         p_Fm->p_FmStateStruct->totalFifoSize        = 0;
         p_Fm->p_FmStateStruct->totalNumOfTasks      = BMI_MAX_NUM_OF_TASKS;
@@ -4158,13 +4158,13 @@ t_Error FM_Init(t_Handle h_Fm)
         return InitGuestMode(p_Fm);
 
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+    if(1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
 
-    /* if user didn't configure totalFifoSize - (totalFifoSize=0) we configure default
-     * according to chip. otherwise, we use user's configuration.
-     */
-    if (p_Fm->p_FmStateStruct->totalFifoSize == 0)
-        p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev);
+        /* if user didn't configured totalFifoSize - (totalFifoSize=0) we configure default
+         * according to chip. otherwise, we use user's configuration.
+         */
+        if (p_Fm->p_FmStateStruct->totalFifoSize == 0)
+            p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev);
 #endif  /* FM_NO_GUARANTEED_RESET_VALUES */
 
     CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
@@ -4221,7 +4221,7 @@ t_Error FM_Init(t_Handle h_Fm)
 
         /* verify breakpoint debug status register */
         debug_reg = GET_UINT32(*(uint32_t *)UINT_TO_PTR(p_Fm->baseAddr + FM_DEBUG_STATUS_REGISTER_OFFSET));
-        if (!debug_reg)
+        if(!debug_reg)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Invalid debug status register value = 0"));
 
         /*************************************/
@@ -4344,7 +4344,7 @@ t_Error FM_Init(t_Handle h_Fm)
     }
 
     err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
-    if (err)
+    if(err)
     {
         FreeInitResources(p_Fm);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -4634,7 +4634,7 @@ t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if (!p_Fm->p_FmDriverParam->dmaEnEmergency)
+    if(!p_Fm->p_FmDriverParam->dmaEnEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FM_ConfigEnDmaEmergencySmoother may be called only after FM_ConfigEnDmaEmergency"));
 
     p_Fm->p_FmDriverParam->dmaEnEmergencySmoother = TRUE;
@@ -4739,7 +4739,7 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     GET_EXCEPTION_FLAG(bitMask, exception);
-    if (bitMask)
+    if(bitMask)
     {
         if (enable)
             p_Fm->p_FmDriverParam->userSetExceptions |= bitMask;
@@ -5050,7 +5050,7 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
         shift = (uint8_t)(32-4*(relativePortId+1));
 
 
-        if (weight > 1)
+        if(weight > 1)
             /* Add this port to tmpReg */
             /* (each 8 ports result in one register)*/
             tmpRegs[hardwarePortId/8] |= ((weight-1) << shift);
@@ -5177,7 +5177,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     GET_EXCEPTION_FLAG(bitMask, exception);
-    if (bitMask)
+    if(bitMask)
     {
         if (enable)
             p_Fm->p_FmStateStruct->exceptions |= bitMask;
@@ -5188,7 +5188,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
         {
              case (e_FM_EX_DMA_BUS_ERROR):
                 tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-                if (enable)
+                if(enable)
                     tmpReg |= DMA_MODE_BER;
                 else
                     tmpReg &= ~DMA_MODE_BER;
@@ -5199,7 +5199,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
              case (e_FM_EX_DMA_SYSTEM_WRITE_ECC):
              case (e_FM_EX_DMA_FM_WRITE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-                if (enable)
+                if(enable)
                     tmpReg |= DMA_MODE_ECC;
                 else
                     tmpReg &= ~DMA_MODE_ECC;
@@ -5207,7 +5207,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_FPM_STALL_ON_TASKS):
                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
-                if (enable)
+                if(enable)
                     tmpReg |= FPM_EV_MASK_STALL_EN;
                 else
                     tmpReg &= ~FPM_EV_MASK_STALL_EN;
@@ -5215,7 +5215,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_FPM_SINGLE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
-                if (enable)
+                if(enable)
                     tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
                 else
                     tmpReg &= ~FPM_EV_MASK_SINGLE_ECC_EN;
@@ -5223,7 +5223,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
             case ( e_FM_EX_FPM_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
-                if (enable)
+                if(enable)
                     tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
                 else
                     tmpReg &= ~FPM_EV_MASK_DOUBLE_ECC_EN;
@@ -5239,7 +5239,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
-                if (enable)
+                if(enable)
                     tmpReg |= QMI_INTR_EN_SINGLE_ECC;
                 else
                     tmpReg &= ~QMI_INTR_EN_SINGLE_ECC;
@@ -5254,7 +5254,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-                if (enable)
+                if(enable)
                     tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
                 else
                     tmpReg &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
@@ -5262,7 +5262,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID):
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-                if (enable)
+                if(enable)
                     tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
                 else
                     tmpReg &= ~QMI_ERR_INTR_EN_DEQ_FROM_DEF;
@@ -5270,7 +5270,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_BMI_LIST_RAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if (enable)
+                if(enable)
                     tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
@@ -5278,7 +5278,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_BMI_STORAGE_PROFILE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if (enable)
+                if(enable)
                     tmpReg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
@@ -5286,7 +5286,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_BMI_STATISTICS_RAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if (enable)
+                if(enable)
                     tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
@@ -5294,7 +5294,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_BMI_DISPATCH_RAM_ECC):
                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-               if (enable)
+               if(enable)
                {
 #ifdef FM_NO_DISPATCH_RAM_ECC
                    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
@@ -5311,7 +5311,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                break;
              case (e_FM_EX_IRAM_ECC):
                  tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
-                if (enable)
+                if(enable)
                 {
                     /* enable ECC if not enabled */
                     FmEnableRamsEcc(p_Fm);
@@ -5329,7 +5329,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 
              case (e_FM_EX_MURAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
-                if (enable)
+                if(enable)
                 {
                     /* enable ECC if not enabled */
                     FmEnableRamsEcc(p_Fm);
@@ -5466,7 +5466,7 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
         case (e_FM_COUNTERS_DEQ_1):
         case (e_FM_COUNTERS_DEQ_2):
         case (e_FM_COUNTERS_DEQ_3):
-              if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+              if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
         case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
         case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
@@ -5475,7 +5475,7 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
         case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
         case (e_FM_COUNTERS_DEQ_FROM_FD):
         case (e_FM_COUNTERS_DEQ_CONFIRM):
-            if (!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -5527,7 +5527,7 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
         case (e_FM_COUNTERS_DEQ_1):
         case (e_FM_COUNTERS_DEQ_2):
         case (e_FM_COUNTERS_DEQ_3):
-             if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+             if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
                  RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
         case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
         case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
@@ -5536,7 +5536,7 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
         case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
         case (e_FM_COUNTERS_DEQ_FROM_FD):
         case (e_FM_COUNTERS_DEQ_CONFIRM):
-            if (!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -5594,7 +5594,7 @@ void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable)
 
     bitMask = (uint32_t)((muramPort==e_FM_DMA_MURAM_PORT_WRITE) ? DMA_MODE_EMERGENCY_WRITE : DMA_MODE_EMERGENCY_READ);
 
-    if (enable)
+    if(enable)
         WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | bitMask);
     else /* disable */
         WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) & ~bitMask);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index 93f4007..6a29d6a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -777,7 +777,6 @@ uint32_t    FmPcdManipGetRequiredAction (t_Handle h_Manip);
 /*          Common API for FM-Port module                            */
 /***********************************************************************/
 #if (DPAA_VERSION >= 11)
-#ifdef FM_EXP_FEATURES
 typedef enum e_FmPortGprFuncType
 {
     e_FM_PORT_GPR_EMPTY = 0,
@@ -785,8 +784,7 @@ typedef enum e_FmPortGprFuncType
 } e_FmPortGprFuncType;
 
 t_Error     FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **p_Value);
-#endif /* FM_EXP_FEATURES */
-#endif /* (DPAA_VERSION >= 11) */
+#endif /* DPAA_VERSION >= 11) */
 t_Error     FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_FmPortGetSetCcParams);
 uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
 uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index c9cf207..53976f3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -473,24 +473,28 @@ typedef struct t_FmParams {
     uint8_t                 fmId;                   /**< Index of the FM */
     uint8_t                 guestId;                /**< FM Partition Id */
     uintptr_t               baseAddr;               /**< A pointer to base of memory mapped FM registers (virtual);
+                                                         this field is optional when the FM runs in "guest-mode"
+                                                         (i.e. guestId != NCSW_MASTER_ID); in that case, the driver will
+                                                         use the memory-map instead of calling the IPC where possible;
                                                          NOTE that this should include ALL common registers of the FM including
                                                          the PCD registers area (i.e. until the VSP pages - 880KB). */
     t_Handle                h_FmMuram;              /**< A handle of an initialized MURAM object,
                                                          to be used by the FM. */
-    uint16_t                fmClkFreq;              /**< In Mhz. */
-
-    t_FmExceptionsCallback  *f_Exception;           /**< An application callback routine to handle exceptions. */
-
-    t_FmBusErrorCallback    *f_BusError;            /**< An application callback routine to handle exceptions. */
-
+    uint16_t                fmClkFreq;              /**< In Mhz;
+                                                         Relevant when FM not runs in "guest-mode". */
+    t_FmExceptionsCallback  *f_Exception;           /**< An application callback routine to handle exceptions;
+                                                         Relevant when FM not runs in "guest-mode". */
+    t_FmBusErrorCallback    *f_BusError;            /**< An application callback routine to handle exceptions;
+                                                         Relevant when FM not runs in "guest-mode". */
     t_Handle                h_App;                  /**< A handle to an application layer object; This handle will
-                                                         be passed by the driver upon calling the above callbacks. */
-
-    int                     irq;                    /**< FM interrupt source for normal events. */
-
-    int                     errIrq;                 /**< FM interrupt source for errors. */
-
-    t_FmFirmwareParams      firmware;               /**< The firmware parameters structure. */
+                                                         be passed by the driver upon calling the above callbacks;
+                                                         Relevant when FM not runs in "guest-mode". */
+    int                     irq;                    /**< FM interrupt source for normal events;
+                                                         Relevant when FM not runs in "guest-mode". */
+    int                     errIrq;                 /**< FM interrupt source for errors;
+                                                         Relevant when FM not runs in "guest-mode". */
+    t_FmFirmwareParams      firmware;               /**< The firmware parameters structure;
+                                                         Relevant when FM not runs in "guest-mode". */
 
 #if (DPAA_VERSION >= 11)
     uintptr_t               vspBaseAddr;            /**< A pointer to base of memory mapped FM VSP registers (virtual);
@@ -690,6 +694,8 @@ typedef struct t_FmDmaThresholds {
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
 
@@ -706,6 +712,8 @@ t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
 
@@ -722,6 +730,8 @@ t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride);
 
@@ -738,6 +748,8 @@ t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverr
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
 
@@ -754,6 +766,8 @@ t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
 
@@ -770,6 +784,8 @@ t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
 
@@ -786,6 +802,8 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
 
@@ -802,6 +820,8 @@ t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode);
 
@@ -820,6 +840,8 @@ t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
                 Only if bus error is enabled.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
 
@@ -837,6 +859,8 @@ t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
 
@@ -854,6 +878,8 @@ t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
 
@@ -871,6 +897,8 @@ t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr);
 
@@ -887,6 +915,8 @@ t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophic
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm);
 
@@ -903,6 +933,8 @@ t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
 
@@ -921,6 +953,8 @@ t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
 
@@ -939,6 +973,8 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable);
 
@@ -956,6 +992,8 @@ t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
 
@@ -974,6 +1012,8 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
 
@@ -994,6 +1034,8 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
 
@@ -1012,6 +1054,8 @@ t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
 
@@ -1030,12 +1074,15 @@ t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
                     fmCtl1DispTh: [16]
                     fmCtl2DispTh: [16]
 
+
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     p_FmThresholds  A structure of threshold parameters.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
 
@@ -1051,6 +1098,8 @@ t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency);
 
@@ -1071,6 +1120,8 @@ t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergenc
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
 
@@ -1090,6 +1141,8 @@ t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDma
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
 
@@ -1110,6 +1163,8 @@ t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThr
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
 
@@ -1126,6 +1181,8 @@ t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaT
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
 
@@ -1269,6 +1326,8 @@ t_Error FM_DumpRegs(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
 
@@ -1284,6 +1343,8 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
 
@@ -1303,6 +1364,8 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_EnableRamsEcc(t_Handle h_Fm);
 
@@ -1322,6 +1385,8 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_DisableRamsEcc(t_Handle h_Fm);
 
@@ -1382,6 +1447,8 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
 
@@ -1395,6 +1462,8 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_Resume(t_Handle h_Fm);
 
@@ -1410,6 +1479,8 @@ void FM_Resume(t_Handle h_Fm);
  @Return        None.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
 
@@ -1424,6 +1495,8 @@ void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
  @Return        None.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri);
 
@@ -1563,6 +1636,8 @@ t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p
                 or is not able to create interrupt.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index ce9ac01..7c665ba 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -65,7 +65,7 @@
                 and the policer global and common registers.
                 In addition, the FM PCD SW module will initialize all required
                 key generator schemes, coarse classification flows, and policer
-                profiles. When an FM module is configured to work with one of these
+                profiles. When a FM module is configured to work with one of these
                 entities, it will register to it using the FM PORT API. The PCD
                 module will manage the PCD resources - i.e. resource management of
                 KeyGen schemes, etc.
@@ -239,17 +239,17 @@ typedef struct t_FmPcdParams {
     uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition.
                                                              this parameter is relevant if 'kgSupport'=TRUE. */
     bool                        useHostCommand;         /**< Optional for single partition, Mandatory for Multi partition */
-    t_FmPcdHcParams             hc;                     /**< Host Command parameters, relevant only if 'useHostCommand' = TRUE.
-                                                         */
+    t_FmPcdHcParams             hc;                     /**< Host Command parameters, relevant only if 'useHostCommand'=TRUE;
+                                                             Relevant when FM not runs in "guest-mode". */
 
-    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine for general PCD exceptions.
-                                                         */
+    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine for general PCD exceptions;
+                                                             Relevant when FM not runs in "guest-mode". */
     t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Callback routine for specific KeyGen scheme or
-                                                             Policer profile exceptions.
-                                                         */
+                                                             Policer profile exceptions;
+                                                             Relevant when FM not runs in "guest-mode". */
     t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
-                                                             be passed by the driver upon calling the above callbacks.
-                                                         */
+                                                             be passed by the driver upon calling the above callbacks;
+                                                             Relevant when FM not runs in "guest-mode". */
     uint8_t                     partPlcrProfilesBase;   /**< The first policer-profile-id dedicated to this partition.
                                                              this parameter is relevant if 'plcrSupport'=TRUE.
                                                              NOTE: this parameter relevant only when working with multiple partitions. */
@@ -307,13 +307,17 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd);
  @Function      FM_PCD_ConfigException
 
  @Description   Calling this routine changes the internal driver data base
-                from its default selection of all exceptions being enabled.
+                from its default selection of exceptions enabling.
+                [4].
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     exception       The exception to be selected.
  @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
 
  @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
 
@@ -360,6 +364,9 @@ t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSha
  @Param[in]     enable          TRUE to enable, FALSE to disable
 
  @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
 
@@ -375,6 +382,9 @@ t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
                                 maximum parsing time.
 
  @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
 
@@ -518,6 +528,8 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter);
 @Return         E_OK on success; Error code otherwise.
 
 @Cautions       Allowed only following FM_PCD_Init() and when PCD is disabled.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
 
@@ -532,6 +544,8 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
 @Return        E_OK on success; Error code otherwise.
 
 @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
+               This routine should NOT be called from guest-partition
+               (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd);
 
@@ -550,6 +564,8 @@ t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value);
 
@@ -565,6 +581,8 @@ t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset);
 
@@ -580,6 +598,8 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
 
@@ -595,6 +615,8 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
 
@@ -610,6 +632,8 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
 
@@ -624,6 +648,8 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
  @Return        None
 
  @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
 
@@ -653,6 +679,8 @@ void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd);
                 or is not able to create interrupt.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
 
@@ -667,6 +695,9 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
 *//***************************************************************************/
 t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd);
 
@@ -680,6 +711,9 @@ t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
 *//***************************************************************************/
 t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
 
@@ -693,6 +727,9 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
 *//***************************************************************************/
 t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
 
@@ -706,6 +743,9 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
 *//***************************************************************************/
 t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile);
 
@@ -719,6 +759,9 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID) or in a case that the registers
+                are mapped.
 *//***************************************************************************/
 t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd);
 
@@ -732,6 +775,8 @@ t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
+                NOTE: this routine may be called only for FM in master mode
+                (i.e. 'guestId'=NCSW_MASTER_ID).
 *//***************************************************************************/
 t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
 #endif /* (defined(DEBUG_ERRORS) && ... */
@@ -739,7 +784,7 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
 
 
 /**************************************************************************//**
- @Group         FM_PCD_Runtime_build_grp FM PCD Runtime Building Unit
+ KeyGen         FM_PCD_Runtime_build_grp FM PCD Runtime Building Unit
 
  @Description   Frame Manager PCD Runtime Building API
 
@@ -979,10 +1024,10 @@ typedef enum e_FmPcdPlcrColorMode {
  @Description   Enumeration type for selecting a policer profile color
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrColor {
-    e_FM_PCD_PLCR_GREEN,                /**< Green */
-    e_FM_PCD_PLCR_YELLOW,               /**< Yellow */
-    e_FM_PCD_PLCR_RED,                  /**< Red */
-    e_FM_PCD_PLCR_OVERRIDE              /**< Color override */
+    e_FM_PCD_PLCR_GREEN,                /**< Green color code */
+    e_FM_PCD_PLCR_YELLOW,               /**< Yellow color code */
+    e_FM_PCD_PLCR_RED,                  /**< Red color code */
+    e_FM_PCD_PLCR_OVERRIDE              /**< Color override code */
 } e_FmPcdPlcrColor;
 
 /**************************************************************************//**
@@ -1059,7 +1104,7 @@ typedef enum e_FmPcdManipHdrRmvType {
 } e_FmPcdManipHdrRmvType;
 
 /**************************************************************************//**
- @Description   An enum for selecting specific L2 fields removal
+ @Description   Enumeration type for selecting specific L2 fields removal
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrRmvSpecificL2 {
     e_FM_PCD_MANIP_HDR_RMV_ETHERNET,                /**< Ethernet/802.3 MAC */
@@ -1175,9 +1220,10 @@ typedef enum e_FmPcdCcStatsMode {
     e_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
     e_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
     e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
-#ifdef FM_EXP_FEATURES
-    e_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics */
-#endif /* FM_EXP_FEATURES */
+#if (DPAA_VERSION >= 11)
+    e_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics;
+                                                 This mode is supported only on B4860 device */
+#endif /* (DPAA_VERSION >= 11) */
 } e_FmPcdCcStatsMode;
 
 /**************************************************************************//**
@@ -1372,7 +1418,8 @@ typedef struct t_FmPcdDistinctionUnit {
                 by a specific PCD Network Environment Characteristics module.
 
                 Each unit represent a protocol or a group of protocols that may
-                be used later by the different PCD engines to distinguish between flows.
+                be used later by the different PCD engines to distinguish
+                between flows.
 *//***************************************************************************/
 typedef struct t_FmPcdNetEnvParams {
     uint8_t                 numOfDistinctionUnits;                      /**< Number of different units to be identified */
@@ -1642,10 +1689,10 @@ typedef struct t_FmPcdKgSchemeParams {
 /**************************************************************************//**
  @Collection    Definitions for CC statistics
 *//***************************************************************************/
-#ifdef FM_EXP_FEATURES
+#if (DPAA_VERSION >= 11)
 #define FM_PCD_CC_STATS_MAX_NUM_OF_FLR      10  /* Maximal supported number of frame length ranges */
 #define FM_PCD_CC_STATS_FLR_SIZE            2   /* Size in bytes of a frame length range limit */
-#endif /* FM_EXP_FEATURES */
+#endif /* (DPAA_VERSION >= 11) */
 #define FM_PCD_CC_STATS_COUNTER_SIZE        4   /* Size in bytes of a frame length range counter */
 /* @} */
 
@@ -1806,17 +1853,18 @@ typedef struct t_KeysParams {
     e_FmPcdCcStatsMode          statisticsMode; /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for
                                                      the requested statistics mode will be allocated according to
                                                      'maxNumOfKeys'. */
-#ifdef FM_EXP_FEATURES
+#if (DPAA_VERSION >= 11)
     uint16_t                    frameLengthRanges[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
-                                                /**< Relevant only for 'e_FM_PCD_CC_STATS_MODE_RMON' statistics mode.
-                                                     Holds a list of programmable thresholds. For each received frame,
+                                                /**< Relevant only for 'e_FM_PCD_CC_STATS_MODE_RMON' statistics
+                                                     mode (this feature is supported only on B4860 device);
+                                                     Holds a list of programmable thresholds - for each received frame,
                                                      its length in bytes is examined against these range thresholds and
-                                                     the appropriate counter is incremented by 1. For example, to belong
+                                                     the appropriate counter is incremented by 1 - for example, to belong
                                                      to range i, the following should hold:
                                                      range i-1 threshold < frame length <= range i threshold
                                                      Each range threshold must be larger then its preceding range
-                                                     threshold. Last range threshold must be 0xFFFF. */
-#endif /* FM_EXP_FEATURES */
+                                                     threshold, and last range threshold must be 0xFFFF. */
+#endif /* (DPAA_VERSION >= 11) */
     uint16_t                    numOfKeys;      /**< Number of initial keys;
                                                      Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP,
                                                      this field should be power-of-2 of the number of bits that are
@@ -1910,23 +1958,18 @@ typedef struct t_FmPcdCcTreeParams {
 *//***************************************************************************/
 typedef struct t_FmPcdCcKeyStatistics {
     uint32_t    byteCount;      /**< This counter reflects byte count of frames that
-                                     were matched this key. */
+                                     were matched by this key. */
     uint32_t    frameCount;     /**< This counter reflects count of frames that
-                                     were matched this key. */
-#ifdef FM_EXP_FEATURES
+                                     were matched by this key. */
+#if (DPAA_VERSION >= 11)
     uint32_t    frameLengthRangeCount[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
-                                /**< These counters reflect how many frames passed that
-                                     were matched this key.
-                                     For 'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FLR'
+                                /**< These counters reflect how many frames matched
+                                     this key in 'e_FM_PCD_CC_STATS_MODE_RMON'
                                      statistics mode:
                                      Each counter holds the number of frames of a
                                      specific frames length range, according to the
-                                     ranges provided at initialization.
-                                     For 'e_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME'
-                                     statistics mode:
-                                     The first counter holds the number of frames that
-                                     were matched to this key. */
-#endif /* FM_EXP_FEATURES */
+                                     ranges provided at initialization. */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmPcdCcKeyStatistics;
 
 /**************************************************************************//**
@@ -2195,7 +2238,7 @@ typedef struct t_FmPcdManipReassemIpParams {
 } t_FmPcdManipReassemIpParams;
 
 /**************************************************************************//**
- @Description   Parameters for defining IPSEC manipulation
+ @Description   structure for defining IPSEC manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipSpecialOffloadIPSecParams {
     bool        decryption;                     /**< TRUE if being used in decryption direction;
@@ -2371,6 +2414,7 @@ typedef struct t_FmPcdManipHdrInsrtSpecificL2Params {
 typedef struct t_FmPcdManipHdrInsrtByHdrParams {
     e_FmPcdManipHdrInsrtByHdrType               type;   /**< Selects manipulation type */
     union {
+
        t_FmPcdManipHdrInsrtSpecificL2Params     specificL2Params;
                                                         /**< Used when type = e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2:
                                                              Selects which L2 headers to remove */
@@ -2765,8 +2809,8 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle                   h_Profile,
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle FM_PCD_CcRootBuild(t_Handle             h_FmPcd,
-                            t_FmPcdCcTreeParams  *p_Params);
+t_Handle FM_PCD_CcRootBuild (t_Handle             h_FmPcd,
+                             t_FmPcdCcTreeParams  *p_Params);
 
 /**************************************************************************//**
  @Function      FM_PCD_CcRootDelete
@@ -2793,7 +2837,7 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree);
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcRootBuild().
+ @Cautions      Allowed only following FM_PCD_CcBuildTree().
 *//***************************************************************************/
 t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
                                       uint8_t                   grpId,
@@ -2865,7 +2909,7 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex);
 
  @Description   Add the key (including next engine parameters of this key in the
                 index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
-                may be used when the user doesn't care about the position of the
+                may be used by user that don't care about the position of the
                 key in the table - in that case, the key will be automatically
                 added by the driver in the last available entry.
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
index c53a003..08a72c9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
@@ -545,7 +545,7 @@ Status: not exported, would be nice to have
     FM_PCD_ManipGetStatistics
 
 Status: not exported
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     FM_PCD_FrmReplicSetGroup
     FM_PCD_FrmReplicDeleteGroup
     FM_PCD_FrmReplicAddMember
@@ -1498,7 +1498,7 @@ invalid_port_id:
                 if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
                     break;
 
-		compat_copy_fm_pcd_plcr_del_profile(&compat_id, &id, COMPAT_US_TO_K);
+                compat_copy_fm_pcd_plcr_del_profile(&compat_id, &id, COMPAT_US_TO_K);
             }
             else
 #endif
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index f4e7249..bbc4434 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -96,7 +96,12 @@
 #define IOC_FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of SW parser area */
 #define IOC_FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
                                                                              of the SW parser area */
+#if DPAA_VERSION >= 11
+#define IOC_FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000240          /**< Number of bytes saved for patches */
+#else
 #define IOC_FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000200          /**< Number of bytes saved for patches */
+#endif
+
 #define IOC_FM_PCD_PRS_SW_TAIL_SIZE                     4                   /**< Number of bytes that must be cleared at
                                                                              the end of the SW parser area */
 #define IOC_FM_SW_PRS_MAX_IMAGE_SIZE                    (IOC_FM_PCD_SW_PRS_SIZE-IOC_FM_PCD_PRS_SW_OFFSET-IOC_FM_PCD_PRS_SW_TAIL_SIZE-IOC_FM_PCD_PRS_SW_PATCHES_SIZE)
-- 
1.7.9.7

