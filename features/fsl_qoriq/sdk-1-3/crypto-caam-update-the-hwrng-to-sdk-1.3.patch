From da245257a575d2d2b726c5187f342a9044a74507 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Tue, 20 Nov 2012 15:01:56 +0800
Subject: [PATCH 016/162] crypto: caam: update the hwrng to sdk 1.3

These test codes are dropped in the latest FSL SDK 1.3
Since caam hwrng depends on the hardware random generator
core support, we also need select HW_RANDOM when this driver
is enabled.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/crypto/caam/Kconfig   |    8 +------
 drivers/crypto/caam/caamrng.c |   47 -----------------------------------------
 2 files changed, 1 insertion(+), 54 deletions(-)

diff --git a/drivers/crypto/caam/Kconfig b/drivers/crypto/caam/Kconfig
index 0fdb95a..4f1e914 100644
--- a/drivers/crypto/caam/Kconfig
+++ b/drivers/crypto/caam/Kconfig
@@ -91,16 +91,10 @@ config CRYPTO_DEV_FSL_CAAM_RNG_API
 	depends on CRYPTO_DEV_FSL_CAAM
 	default y
 	select CRYPTO_RNG
+	select HW_RANDOM
 	help
 	  Selecting this will register the SEC4 hardware rng to
 	  the hw_random API for suppying the kernel entropy pool.
 
 	  To compile this as a module, choose M here: the module
 	  will be called caamrng.
-
-config CRYPTO_DEV_FSL_CAAM_RNG_TEST
-	boolean "Test caam rng"
-	depends on CRYPTO_DEV_FSL_CAAM_RNG_API
-	default n
-	help
-	  Selecting this will enable self-test for caam rng.
diff --git a/drivers/crypto/caam/caamrng.c b/drivers/crypto/caam/caamrng.c
index 0f13ecf..d1939a9 100644
--- a/drivers/crypto/caam/caamrng.c
+++ b/drivers/crypto/caam/caamrng.c
@@ -245,49 +245,6 @@ static void caam_cleanup(struct hwrng *rng)
 	rng_unmap_ctx(&rng_ctx);
 }
 
-#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST
-static inline void test_len(struct hwrng *rng, size_t len, bool wait)
-{
-	u8 *buf;
-	int real_len;
-
-	buf = kzalloc(sizeof(u8) * len, GFP_KERNEL);
-	real_len = rng->read(rng, buf, len, wait);
-	if (real_len == 0 && wait)
-		pr_err("WAITING FAILED\n");
-	pr_info("wanted %d bytes, got %d\n", len, real_len);
-	print_hex_dump(KERN_INFO, "random bytes@: ", DUMP_PREFIX_ADDRESS,
-		       16, 4, buf, real_len, 1);
-	kfree(buf);
-}
-
-static inline void test_mode_once(struct hwrng *rng, bool wait)
-{
-#define TEST_CHUNK (RN_BUF_SIZE / 4)
-
-	test_len(rng, TEST_CHUNK, wait);
-	test_len(rng, RN_BUF_SIZE * 2, wait);
-	test_len(rng, RN_BUF_SIZE * 2 - TEST_CHUNK, wait);
-}
-
-static inline void test_mode(struct hwrng *rng, bool wait)
-{
-#define TEST_PASS 1
-	int i;
-
-	for (i = 0; i < TEST_PASS; i++)
-		test_mode_once(rng, wait);
-}
-
-static void self_test(struct hwrng *rng)
-{
-	pr_info("testing without waiting\n");
-	test_mode(rng, false);
-	pr_info("testing with waiting\n");
-	test_mode(rng, true);
-}
-#endif
-
 static void caam_init_buf(struct caam_rng_ctx *ctx, int buf_id)
 {
 	struct buf_data *bd = &ctx->bufs[buf_id];
@@ -343,10 +300,6 @@ static int __init caam_rng_init(void)
 
 	caam_init_rng(&rng_ctx, priv->jrdev[0]);
 
-#ifdef CONFIG_CRYPTO_DEV_FSL_CAAM_RNG_TEST
-	self_test(&caam_rng);
-#endif
-
 	dev_info(priv->jrdev[0], "registering rng-caam\n");
 	return hwrng_register(&caam_rng);
 }
-- 
1.7.9.7

