From 43fd68723de041c05c12c93cb51c65747dfd92a2 Mon Sep 17 00:00:00 2001
From: Andrei Pistirica <sorin.pistirica@freescale.com>
Date: Wed, 9 May 2012 17:50:24 +0300
Subject: [PATCH 062/162] Sync w/ FMD16 - NCSW GA4.5 release candidate 1.

Few API changed due to DPAA_VERSION support.
Update pcd module to meet NCSW.

Signed-off-by: Andrei Pistirica <sorin.pistirica@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c |   13 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c       |  200 +--
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h       |    4 +
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |    1 +
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |    1 +
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c      |   32 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h      |   12 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |   53 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.h        |    3 +-
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c    |    1 +
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h    |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h       |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       | 1145 +++++++++------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |   17 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       | 1533 ++++++++++----------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h       |  245 ++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    |  554 +++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |  163 ++-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |  595 +++++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |  292 +---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |   18 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     |  404 +++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h     |  165 +++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |   53 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h      |  172 +++
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |  684 +++++----
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |   23 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c      |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h      |    1 +
 .../dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c        |  110 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |  142 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.h    |   73 +-
 .../dpa/NetCommSw/Peripherals/FM/fm_ipc.h          |    1 +
 .../dpa/NetCommSw/Peripherals/FM/fm_muram.c        |    1 +
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |  418 +-----
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h       |    5 +-
 .../NetCommSw/Peripherals/FM/inc/fm_sp_common.h    |   24 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/error.c   |    1 +
 .../ethernet/freescale/dpa/NetCommSw/etc/list.c    |    1 +
 .../ethernet/freescale/dpa/NetCommSw/etc/memcpy.c  |    1 +
 .../net/ethernet/freescale/dpa/NetCommSw/etc/mm.c  |   17 +-
 .../net/ethernet/freescale/dpa/NetCommSw/etc/mm.h  |    7 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/sprint.c  |    1 +
 .../NetCommSw/inc/Peripherals/crc_mac_addr_ext.h   |    1 +
 .../dpa/NetCommSw/inc/Peripherals/dpaa_ext.h       |    1 +
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |   19 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h     |   27 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h   |    1 +
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |  386 +++--
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |   46 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h     |    1 +
 .../dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h     |   85 +-
 .../dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h    |    1 +
 .../freescale/dpa/NetCommSw/inc/core_ext.h         |    1 +
 .../freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h |    1 +
 .../freescale/dpa/NetCommSw/inc/cores/ppc_ext.h    |    1 +
 .../freescale/dpa/NetCommSw/inc/ctype_ext.h        |    1 +
 .../freescale/dpa/NetCommSw/inc/debug_ext.h        |    1 +
 .../freescale/dpa/NetCommSw/inc/endian_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/enet_ext.h         |    1 +
 .../freescale/dpa/NetCommSw/inc/error_ext.h        |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/list_ext.h     |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/mem_ext.h      |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h   |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/mm_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/sprint_ext.h   |    1 +
 .../inc/integrations/P1023/dpaa_integration_ext.h  |    4 +-
 .../inc/integrations/P1023/part_integration_ext.h  |    1 +
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |    2 +-
 .../freescale/dpa/NetCommSw/inc/math_ext.h         |    1 +
 .../freescale/dpa/NetCommSw/inc/ncsw_ext.h         |    1 +
 .../ethernet/freescale/dpa/NetCommSw/inc/net_ext.h |   23 +
 .../ethernet/freescale/dpa/NetCommSw/inc/std_ext.h |    1 +
 .../freescale/dpa/NetCommSw/inc/stdarg_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/stdlib_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/string_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/types_ext.h        |    9 +-
 .../NetCommSw/integrations/P1023/module_strings.c  |    1 +
 .../dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c   |    6 +-
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      |   36 +-
 81 files changed, 4528 insertions(+), 3332 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index df69aa9..376b996 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #include "std_ext.h"
 #include "error_ext.h"
 #include "sprint_ext.h"
@@ -62,11 +63,11 @@
 
 #define HC_HCOR_KG_SCHEME_COUNTER           0x00000400
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
 #define HC_HCOR_KG_SCHEME_REGS_MASK         0xFFFFF800
 #else
 #define HC_HCOR_KG_SCHEME_REGS_MASK         0xFFFFFE00
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
 #define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
 #define SIZE_OF_HC_FRAME_SCHEME_REGS        sizeof(t_HcFrame)
@@ -212,7 +213,7 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
         return NULL;
     }
 
-	err = FM_PORT_Enable(p_FmHc->h_HcPortDev);
+    err = FM_PORT_Enable(p_FmHc->h_HcPortDev);
     if (err != E_OK)
     {
         REPORT_ERROR(MAJOR, err, ("FM HC port!"));
@@ -294,7 +295,7 @@ t_Error FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemePa
 
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
-	RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
@@ -488,7 +489,7 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-	err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
+    err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
     if (err != E_OK)
     {
         REPORT_ERROR(MINOR, err, NO_MSG);
@@ -943,7 +944,7 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-	err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
+    err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
     if (err != E_OK)
     {
         REPORT_ERROR(MINOR, err, NO_MSG);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index 8f78a9b..7e67734 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          dtsec.c
 
@@ -60,17 +61,15 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId can not be greater than the number of 1G MACs"));
     if(p_Dtsec->addr == 0)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC Must have a valid MAC Address"));
-    if(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)) &&
+    if((ENET_SPEED_FROM_MODE(p_Dtsec->enetMode) >= e_ENET_SPEED_1000) &&
         p_Dtsec->p_DtsecDriverParam->halfDuplex)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in half duplex"));
     if(p_Dtsec->p_DtsecDriverParam->halfDuplex && (p_Dtsec->p_DtsecDriverParam)->loopback)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("LoopBack is not supported in halfDuplex mode"));
 #ifdef FM_RX_PREAM_4_ERRATA_DTSEC_A001
-    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev != 8 /*tmp */)
-	    if(p_Dtsec->p_DtsecDriverParam->preambleRxEn)
-	        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("preambleRxEn"));
+    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev <= 6) /* fixed for rev3 */
+        if(p_Dtsec->p_DtsecDriverParam->preambleRxEn)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("preambleRxEn"));
 #endif /* FM_RX_PREAM_4_ERRATA_DTSEC_A001 */
     if(((p_Dtsec->p_DtsecDriverParam)->preambleTxEn || (p_Dtsec->p_DtsecDriverParam)->preambleRxEn) &&( (p_Dtsec->p_DtsecDriverParam)->preambleLength != 0x7))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Preamble length should be 0x7 bytes"));
@@ -104,8 +103,8 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("uninitialized f_Event"));
 
 #ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
-	if(p_Dtsec->p_DtsecDriverParam->lengthCheckEnable)
-	   RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+    if(p_Dtsec->p_DtsecDriverParam->lengthCheckEnable)
+       RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
 #endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
 
     return E_OK;
@@ -312,74 +311,74 @@ static void DtsecErrException(t_Handle h_Dtsec)
     if(event & IMASK_XFUNEN)
     {
 #ifdef FM_TX_LOCKUP_ERRATA_DTSEC6
-	    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
-	    {
-	        uint32_t  tpkt1, tmpReg1, tpkt2, tmpReg2, i;
-	        /* a. Write 0x00E0_0C00 to DTSEC_ID */
-	        /* This is a read only regidter */
-
-	        /* b. Read and save the value of TPKT */
-	        tpkt1 = GET_UINT32(p_DtsecMemMap->tpkt);
-
-	        /* c. Read the register at dTSEC address offset 0x32C */
-	        tmpReg1 =  GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
-
-	        /* d. Compare bits [9:15] to bits [25:31] of the register at address offset 0x32C. */
-	        if((tmpReg1 & 0x007F0000) != (tmpReg1 & 0x0000007F))
-	        {
-	            /* If they are not equal, save the value of this register and wait for at least
-	             * MAXFRM*16 ns */
-	            XX_UDelay((uint32_t)(MIN(DtsecGetMaxFrameLength(p_Dtsec)*16/1000, 1)));
-	        }
-
-	        /* e. Read and save TPKT again and read the register at dTSEC address offset
-	            0x32C again*/
-	        tpkt2 = GET_UINT32(p_DtsecMemMap->tpkt);
-	        tmpReg2 = GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
-
-	        /* f. Compare the value of TPKT saved in step b to value read in step e. Also
-	            compare bits [9:15] of the register at offset 0x32C saved in step d to the value
-	            of bits [9:15] saved in step e. If the two registers values are unchanged, then
-	            the transmit portion of the dTSEC controller is locked up and the user should
-	            proceed to the recover sequence. */
-	        if((tpkt1 == tpkt2) && ((tmpReg1 & 0x007F0000) == (tmpReg2 & 0x007F0000)))
-	        {
-	            /* recover sequence */
-
-	            /* a.Write a 1 to RCTRL[GRS]*/
-
-	            WRITE_UINT32(p_DtsecMemMap->rctrl, GET_UINT32(p_DtsecMemMap->rctrl) | RCTRL_GRS);
-
-	            /* b.Wait until IEVENT[GRSC]=1, or at least 100 us has elapsed. */
-	            for(i = 0 ; i < 100 ; i++ )
-	            {
-	                if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
-	                    break;
-	                XX_UDelay(1);
-	            }
-	            if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
-	                WRITE_UINT32(p_DtsecMemMap->ievent, IMASK_GRSCEN);
-	            else
-	                DBG(INFO,("Rx lockup due to dTSEC Tx lockup"));
-
-
-	            /* c.Write a 1 to bit n of FM_RSTC (offset 0x0CC of FPM)*/
-	            FmResetMac(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId);
-
-	            /* d.Wait 4 Tx clocks (32 ns) */
-	            XX_UDelay(1);
-
-	            /* e.Write a 0 to bit n of FM_RSTC. */
-	            /* cleared by FMAN */
-	        }
-	        else
-	        {
-	            /* If either value has changed, the dTSEC controller is not locked up and the
-	               controller should be allowed to proceed normally by writing the reset value
-	               of 0x0824_0101 to DTSEC_ID. */
-	            /* Register is read only */
-	        }
-	    }
+        if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+        {
+            uint32_t  tpkt1, tmpReg1, tpkt2, tmpReg2, i;
+            /* a. Write 0x00E0_0C00 to DTSEC_ID */
+            /* This is a read only regidter */
+
+            /* b. Read and save the value of TPKT */
+            tpkt1 = GET_UINT32(p_DtsecMemMap->tpkt);
+
+            /* c. Read the register at dTSEC address offset 0x32C */
+            tmpReg1 =  GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
+
+            /* d. Compare bits [9:15] to bits [25:31] of the register at address offset 0x32C. */
+            if((tmpReg1 & 0x007F0000) != (tmpReg1 & 0x0000007F))
+            {
+                /* If they are not equal, save the value of this register and wait for at least
+                 * MAXFRM*16 ns */
+                XX_UDelay((uint32_t)(MIN(DtsecGetMaxFrameLength(p_Dtsec)*16/1000, 1)));
+            }
+
+            /* e. Read and save TPKT again and read the register at dTSEC address offset
+                0x32C again*/
+            tpkt2 = GET_UINT32(p_DtsecMemMap->tpkt);
+            tmpReg2 = GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
+
+            /* f. Compare the value of TPKT saved in step b to value read in step e. Also
+                compare bits [9:15] of the register at offset 0x32C saved in step d to the value
+                of bits [9:15] saved in step e. If the two registers values are unchanged, then
+                the transmit portion of the dTSEC controller is locked up and the user should
+                proceed to the recover sequence. */
+            if((tpkt1 == tpkt2) && ((tmpReg1 & 0x007F0000) == (tmpReg2 & 0x007F0000)))
+            {
+                /* recover sequence */
+
+                /* a.Write a 1 to RCTRL[GRS]*/
+
+                WRITE_UINT32(p_DtsecMemMap->rctrl, GET_UINT32(p_DtsecMemMap->rctrl) | RCTRL_GRS);
+
+                /* b.Wait until IEVENT[GRSC]=1, or at least 100 us has elapsed. */
+                for(i = 0 ; i < 100 ; i++ )
+                {
+                    if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
+                        break;
+                    XX_UDelay(1);
+                }
+                if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
+                    WRITE_UINT32(p_DtsecMemMap->ievent, IMASK_GRSCEN);
+                else
+                    DBG(INFO,("Rx lockup due to dTSEC Tx lockup"));
+
+
+                /* c.Write a 1 to bit n of FM_RSTC (offset 0x0CC of FPM)*/
+                FmResetMac(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId);
+
+                /* d.Wait 4 Tx clocks (32 ns) */
+                XX_UDelay(1);
+
+                /* e.Write a 0 to bit n of FM_RSTC. */
+                /* cleared by FMAN */
+            }
+            else
+            {
+                /* If either value has changed, the dTSEC controller is not locked up and the
+                   controller should be allowed to proceed normally by writing the reset value
+                   of 0x0824_0101 to DTSEC_ID. */
+                /* Register is read only */
+            }
+        }
 #endif /* FM_TX_LOCKUP_ERRATA_DTSEC6 */
 
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_FIFO_UNDRN);
@@ -1236,13 +1235,9 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
     p_DtsecMemMap = p_Dtsec->p_MemMap;
-    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
 
-    if(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)) &&
-        p_Dtsec->halfDuplex)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in half duplex"));
+    if (!fullDuplex && (speed == e_ENET_SPEED_1000))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Ethernet MAC 1G does not support half-duplex"));
 
     p_Dtsec->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode), speed);
     p_Dtsec->halfDuplex = !fullDuplex;
@@ -1281,6 +1276,21 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
 
 /* .............................................................................. */
 
+static t_Error DtsecRestartAutoneg(t_Handle h_Dtsec)
+{
+    t_Dtsec      *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint16_t     tmpReg16;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    DTSEC_MII_ReadPhyReg(p_Dtsec, p_Dtsec->p_DtsecDriverParam->tbiPhyAddr, 0, &tmpReg16);
+    tmpReg16 |= (PHY_CR_RESET_AN);
+    DTSEC_MII_WritePhyReg(p_Dtsec, p_Dtsec->p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
 static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
 {
     t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
@@ -1733,21 +1743,31 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     p_Dtsec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if(!p_Dtsec->p_MulticastAddrHash)
     {
-	FreeInitResources(p_Dtsec);
+        FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MC hash table is FAILED"));
     }
 
     p_Dtsec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if(!p_Dtsec->p_UnicastAddrHash)
     {
-	FreeInitResources(p_Dtsec);
+        FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("UC hash table is FAILED"));
     }
 
     /* register err intr handler for dtsec to FPM (err)*/
-    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_ERR, DtsecErrException , p_Dtsec);
+    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm,
+                   e_FM_MOD_1G_MAC,
+                   p_Dtsec->macId,
+                   e_FM_INTR_TYPE_ERR,
+                   DtsecErrException,
+                   p_Dtsec);
     /* register 1588 intr handler for TMR to FPM (normal)*/
-    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL, Dtsec1588Exception , p_Dtsec);
+    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm,
+                   e_FM_MOD_1G_MAC,
+                   p_Dtsec->macId,
+                   e_FM_INTR_TYPE_NORMAL,
+                   Dtsec1588Exception,
+                   p_Dtsec);
     /* register normal intr handler for dtsec to main interrupt controller. */
     if (p_Dtsec->mdioIrq != NO_IRQ)
     {
@@ -1761,7 +1781,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     err = DtsecSetStatistics(p_Dtsec, e_FM_MAC_FULL_STATISTICS);
     if(err)
     {
-	FreeInitResources(p_Dtsec);
+        FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1804,8 +1824,9 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = DtsecConfigPadAndCrc;
     p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = DtsecConfigHalfDuplex;
     p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = DtsecConfigLengthCheck;
-    p_FmMacControllerDriver->f_FM_MAC_ConfigTbiPhyAddr         	= DtsecConfigTbiPhyAddr;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigTbiPhyAddr          = DtsecConfigTbiPhyAddr;
     p_FmMacControllerDriver->f_FM_MAC_ConfigException           = DtsecConfigException;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit         = NULL;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = DtsecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = DtsecDisable;
@@ -1814,6 +1835,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = DtsecSetPromiscuous;
     p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = DtsecAdjustLink;
+    p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg            = DtsecRestartAutoneg;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = DtsecEnable1588TimeStamp;
     p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = DtsecDisable1588TimeStamp;
@@ -1885,7 +1907,7 @@ t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
 
     SetDefaultParam(p_DtsecDriverParam);
 
-    for (i=0; i < sizeof(p_FmMacParam->addr); i++)
+   for (i=0; i < sizeof(p_FmMacParam->addr); i++)
         p_Dtsec->addr |= ((uint64_t)p_FmMacParam->addr[i] << ((5-i) * 8));
 
     p_Dtsec->p_MemMap           = (t_DtsecMemMap *)UINT_TO_PTR(baseAddr);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index 51ef324..ddb606e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          dtsec.h
 
@@ -147,6 +148,8 @@ typedef  uint32_t t_ErrorDisable;
 
 #define DTSEC_TO_MII_OFFSET             0x1120  /* number of pattern match registers (entries) */
 
+
+
 #define DEFAULT_errorDisabled           0
 #define DEFAULT_pauseExtended           0x0
 #define DEFAULT_halfDulexFlowControlEn  FALSE
@@ -320,6 +323,7 @@ typedef  uint32_t t_ErrorDisable;
 #define PHY_TBIANA_SGMII    0x4001
 #define PHY_TBIANA_1000X    0x01a0
 
+
 /* CAR1/2 bits */
 #define CAR1_TR64   0x80000000
 #define CAR1_TR127  0x40000000
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
index 85614a7..8ae995c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          dtsec_mii_acc.c
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
index d43b33b..d84a0ea 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __DTSEC_MII_ACC_H
 #define __DTSEC_MII_ACC_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index 9ed7b1b..478dfd9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_mac.c
 
@@ -53,7 +54,7 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 
     SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_INVALID_HANDLE, NULL);
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     if (ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
         p_FmMacControllerDriver = (t_FmMacControllerDriver *)DTSEC_Config(p_FmMacParam);
 #if FM_MAX_NUM_OF_10G_MACS > 0
@@ -62,7 +63,7 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 #endif /* FM_MAX_NUM_OF_10G_MACS > 0 */
 #else
     p_FmMacControllerDriver = (t_FmMacControllerDriver *)MEMAC_Config(p_FmMacParam);
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
     if (!p_FmMacControllerDriver)
         return NULL;
@@ -89,13 +90,13 @@ t_Error FM_MAC_Init (t_Handle h_FmMac)
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
-#if (DPAA_VERSION == 2)
     if (p_FmMacControllerDriver->resetOnInit &&
+        !p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit &&
         (FmResetMac(p_FmMacControllerDriver->h_Fm,
-                    ((ENET_INTERFACE_FROM_MODE(p_FmMacControllerDriver->enetMode) == e_ENET_IF_XGMII) ? e_FM_MAC_10G : e_FM_MAC_1G),
-                     p_FmMacControllerDriver->macId) != E_OK))
+                    ((ENET_INTERFACE_FROM_MODE(p_FmMacControllerDriver->enetMode) == e_ENET_IF_XGMII) ?
+                        e_FM_MAC_10G : e_FM_MAC_1G),
+                    p_FmMacControllerDriver->macId) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't reset MAC!"));
-#endif /* (DPAA_VERSION == 2) */
 
     if (p_FmMacControllerDriver->f_FM_MAC_Init)
         return p_FmMacControllerDriver->f_FM_MAC_Init(h_FmMac);
@@ -124,6 +125,9 @@ t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable)
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit(h_FmMac, enable);
+
     p_FmMacControllerDriver->resetOnInit = enable;
 
     return E_OK;
@@ -536,6 +540,22 @@ t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex)
 
 /* ........................................................................... */
 
+t_Error FM_MAC_RestartAutoneg(t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg)
+        return p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+
+
+/* ........................................................................... */
+
 t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
index 52eb0f4..0afb049 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_mac.h
 
@@ -50,8 +51,6 @@
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
-
-
 #define DEFAULT_wanModeEnable               FALSE
 #define DEFAULT_promiscuousEnable           FALSE
 #define DEFAULT_rxIgnorePause               FALSE
@@ -62,13 +61,10 @@
 #define DEFAULT_lengthCheckEnable           FALSE
 #define DEFAULT_padAndCrcEnable             TRUE
 
-
-
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 #define DEFAULT_skipFman11Workaround        FALSE
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
-
 #define DEFAULT_resetOnInit                 FALSE
 
 
@@ -96,6 +92,7 @@ typedef struct {
     t_Error (*f_FM_MAC_ConfigLengthCheck) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_ConfigTbiPhyAddr) (t_Handle h_FmMac, uint8_t newVal);
     t_Error (*f_FM_MAC_ConfigException) (t_Handle h_FmMac, e_FmMacExceptions, bool enable);
+    t_Error (*f_FM_MAC_ConfigResetOnInit) (t_Handle h_FmMac, bool enable);
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
     t_Error (*f_FM_MAC_ConfigSkipFman11Workaround) (t_Handle h_FmMac);
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
@@ -125,6 +122,7 @@ typedef struct {
 
     t_Error (*f_FM_MAC_SetPromiscuous) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_AdjustLink)     (t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
+    t_Error (*f_FM_MAC_RestartAutoneg) (t_Handle h_FmMac);
 
     t_Error (*f_FM_MAC_GetId) (t_Handle h_FmMac, uint32_t *macId);
 
@@ -148,12 +146,12 @@ typedef struct {
 } t_FmMacControllerDriver;
 
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
 t_Handle    DTSEC_Config(t_FmMacParams *p_FmMacParam);
 t_Handle    TGEC_Config(t_FmMacParams *p_FmMacParams);
 #else
 t_Handle    MEMAC_Config(t_FmMacParams *p_FmMacParam);
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 uint16_t    FM_MAC_GetMaxFrameLength(t_Handle FmMac);
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index bb24210..04c497f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          tgec.c
 
@@ -67,9 +68,10 @@ static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
     if(!p_Tgec->f_Event)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("uninitialized f_Event"));
 #ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
-	if(!p_Tgec->p_TgecDriverParam->noLengthCheckEnable)
-	   RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+    if(!p_Tgec->p_TgecDriverParam->noLengthCheckEnable)
+       RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
 #endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
+
     return E_OK;
 }
 
@@ -245,7 +247,7 @@ static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
 
     p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
-    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
 
     switch (mode)
     {
@@ -263,7 +265,7 @@ static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
             break;
     }
 
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
     return E_OK;
 }
@@ -281,7 +283,7 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
 
     p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
-    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
     switch (mode)
     {
         case e_COMM_MODE_RX:
@@ -296,7 +298,7 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
     }
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
     return E_OK;
 }
@@ -315,14 +317,14 @@ static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
 
     p_TgecMemMap = p_Tgec->p_MemMap;
 
-    tmpReg32 = GET_UINT32(p_TgecMemMap->cmd_conf_ctrl);
+    tmpReg32 = GET_UINT32(p_TgecMemMap->command_config);
 
     if (newVal)
         tmpReg32 |= CMD_CFG_PROMIS_EN;
     else
         tmpReg32 &= ~CMD_CFG_PROMIS_EN;
 
-    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_TgecMemMap->command_config, tmpReg32);
 
     return E_OK;
 }
@@ -474,12 +476,12 @@ static t_Error TgecRxIgnoreMacPause(t_Handle h_Tgec, bool en)
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
 
     p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
-    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
     if (en)
         tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
     else
         tmpReg32 &= ~CMD_CFG_PAUSE_IGNORE;
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
     return E_OK;
 }
@@ -553,7 +555,7 @@ static t_Error TgecEnable1588TimeStamp(t_Handle h_Tgec)
     p_TgecMemMap = p_Tgec->p_MemMap;
     SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
 
-    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, GET_UINT32(p_TgecMemMap->cmd_conf_ctrl) | CMD_CFG_EN_TIMESTAMP);
+    WRITE_UINT32(p_TgecMemMap->command_config, GET_UINT32(p_TgecMemMap->command_config) | CMD_CFG_EN_TIMESTAMP);
 
     return E_OK;
 }
@@ -571,7 +573,7 @@ static t_Error TgecDisable1588TimeStamp(t_Handle h_Tgec)
     p_TgecMemMap = p_Tgec->p_MemMap;
     SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
 
-    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, GET_UINT32(p_TgecMemMap->cmd_conf_ctrl) & ~CMD_CFG_EN_TIMESTAMP);
+    WRITE_UINT32(p_TgecMemMap->command_config, GET_UINT32(p_TgecMemMap->command_config) & ~CMD_CFG_EN_TIMESTAMP);
 
     return E_OK;
 }
@@ -622,21 +624,21 @@ static t_Error TgecResetCounters (t_Handle h_Tgec)
 
     p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
-    cmdConfCtrl = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    cmdConfCtrl = GET_UINT32(p_MemMap->command_config);
 
     cmdConfCtrl |= CMD_CFG_STAT_CLR;
 
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+    WRITE_UINT32(p_MemMap->command_config, cmdConfCtrl);
 
     for (i=0; i<1000; i++)
     {
-        tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+        tmpReg32 = GET_UINT32(p_MemMap->command_config);
         if (!(tmpReg32 & CMD_CFG_STAT_CLR))
             break;
     }
 
     cmdConfCtrl &= ~CMD_CFG_STAT_CLR;
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+    WRITE_UINT32(p_MemMap->command_config, cmdConfCtrl);
 
     return E_OK;
 }
@@ -881,10 +883,10 @@ static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
     XX_Print("Applying 10G tx-ecc error workaround (10GMAC-A004) ...");
 #endif /* (DEBUG_ERRORS > 0) */
     /* enable and set promiscuous */
-    WRITE_UINT32(p_Tgec->p_MemMap->cmd_conf_ctrl, CMD_CFG_PROMIS_EN | CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+    WRITE_UINT32(p_Tgec->p_MemMap->command_config, CMD_CFG_PROMIS_EN | CMD_CFG_TX_EN | CMD_CFG_RX_EN);
     err = Fm10GTxEccWorkaround(p_Tgec->fmMacControllerDriver.h_Fm, p_Tgec->macId);
     /* disable */
-    WRITE_UINT32(p_Tgec->p_MemMap->cmd_conf_ctrl, 0);
+    WRITE_UINT32(p_Tgec->p_MemMap->command_config, 0);
 #if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
     if (err)
         XX_Print("FAILED!\n");
@@ -911,7 +913,7 @@ static t_Error TgecDumpRegs(t_Handle h_Tgec)
         DUMP_TITLE(p_Tgec->p_MemMap, ("10G MAC %d: ", p_Tgec->macId));
         DUMP_VAR(p_Tgec->p_MemMap, tgec_id);
         DUMP_VAR(p_Tgec->p_MemMap, scratch);
-        DUMP_VAR(p_Tgec->p_MemMap, cmd_conf_ctrl);
+        DUMP_VAR(p_Tgec->p_MemMap, command_config);
         DUMP_VAR(p_Tgec->p_MemMap, mac_addr_0);
         DUMP_VAR(p_Tgec->p_MemMap, mac_addr_1);
         DUMP_VAR(p_Tgec->p_MemMap, maxfrm);
@@ -966,7 +968,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
     FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &p_Tgec->fmMacControllerDriver.fmRevInfo);
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev != 8 /*tmp */)
+    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev <= 6 /*fixed for rev3 */)
     {
         if (!p_Tgec->p_TgecDriverParam->skipFman11Workaround &&
             ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
@@ -1028,7 +1030,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
     if (p_TgecDriverParam->txPblFwd)
         tmpReg32 |= CMD_CFG_TX_PBL_FWD;
     tmpReg32 |= 0x40;
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
     /* Max Frame Length */
     WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_TgecDriverParam->maxFrameLength);
@@ -1075,7 +1077,12 @@ static t_Error TgecInit(t_Handle h_Tgec)
     WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
     WRITE_UINT32(p_MemMap->imask, p_Tgec->exceptions);
 
-    FmRegisterIntr(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MOD_10G_MAC, p_Tgec->macId, e_FM_INTR_TYPE_ERR, TgecErrException , p_Tgec);
+    FmRegisterIntr(p_Tgec->fmMacControllerDriver.h_Fm,
+                   e_FM_MOD_10G_MAC,
+                   p_Tgec->macId,
+                   e_FM_INTR_TYPE_ERR,
+                   TgecErrException,
+                   p_Tgec);
     if ((p_Tgec->mdioIrq != 0) && (p_Tgec->mdioIrq != NO_IRQ))
     {
         XX_SetIntr(p_Tgec->mdioIrq, TgecException, p_Tgec);
@@ -1127,6 +1134,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
     p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = TgecConfigLengthCheck;
     p_FmMacControllerDriver->f_FM_MAC_ConfigException           = TgecConfigException;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit         = NULL;
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
     p_FmMacControllerDriver->f_FM_MAC_ConfigSkipFman11Workaround= TgecConfigSkipFman11Workaround;
@@ -1139,6 +1147,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = TgecSetPromiscuous;
     p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg            = NULL;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = TgecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = TgecDisable;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
index 045fb5b..64bf754 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          tgec.h
 
@@ -323,7 +324,7 @@ typedef _Packed struct {
 /* 10Ge General Control and Status */
     volatile uint32_t   tgec_id;            /* 0x000 10GEC_ID - Controller ID register */
     volatile uint32_t   scratch;            /* 0x004  */
-    volatile uint32_t   cmd_conf_ctrl;      /* 0x008 COMMAND_CONFIG - Control and configuration register */
+    volatile uint32_t   command_config;     /* 0x008 COMMAND_CONFIG - Control and configuration register */
     volatile uint32_t   mac_addr_0;         /* 0x00C MAC_ADDR_0 - Lower 32 bits of the first 48-bit MAC address */
     volatile uint32_t   mac_addr_1;         /* 0x010 MAC_ADDR_1 - Upper 16 bits of the first 48-bit MAC address */
     volatile uint32_t   maxfrm;             /* 0x014 MAXFRM - Maximum frame length register */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
index 6ab50ab..e0fafd1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
@@ -31,6 +31,7 @@
  */
 
 
+
 #include "error_ext.h"
 #include "std_ext.h"
 #include "fm_mac.h"
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
index 1de0f99..645cdde 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __TGEC_MII_ACC_H
 #define __TGEC_MII_ACC_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
index e1f6f59..8169765 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
@@ -31,7 +31,7 @@
  */
 
 
-/**************************************************************************//**
+ /**************************************************************************//**
  @File          crc64.h
 
  @Description   brief This file contains the CRC64 Table, and __inline__
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index ea7c904..f4a53e8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_cc.c
 
@@ -43,6 +44,7 @@
 #include "fm_muram_ext.h"
 
 #include "fm_common.h"
+#include "fm_pcd.h"
 #include "fm_hc.h"
 #include "fm_cc.h"
 #include "crc64.h"
@@ -52,16 +54,26 @@
 /*       static functions               */
 /****************************************/
 
-static uint32_t FmPcdCcTreeLock(t_Handle h_FmPcdCcTree)
+
+static t_Error CcRootTryLock(t_Handle h_FmPcdCcTree)
 {
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+
     ASSERT_COND(h_FmPcdCcTree);
-    return XX_LockIntrSpinlock(((t_FmPcdCcTree*)h_FmPcdCcTree)->h_Spinlock);
+
+    if (FmPcdLockTryLock(p_FmPcdCcTree->p_Lock))
+        return E_OK;
+
+    return ERROR_CODE(E_BUSY);
 }
 
-static void FmPcdCcTreeUnlock(t_Handle h_FmPcdCcTree, uint32_t intFlags)
+static void CcRootReleaseLock(t_Handle h_FmPcdCcTree)
 {
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+
     ASSERT_COND(h_FmPcdCcTree);
-    XX_UnlockIntrSpinlock(((t_FmPcdCcTree*)h_FmPcdCcTree)->h_Spinlock, intFlags);
+
+    FmPcdLockUnlock(p_FmPcdCcTree->p_Lock);
 }
 
 static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
@@ -77,10 +89,14 @@ static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
     }
 }
 
-static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_CcNode, t_Handle h_Manip, t_Handle h_FrmReplic)
+static void FillAdOfTypeContLookup(t_Handle h_Ad,
+                                   t_Handle h_FmPcd,
+                                   t_Handle p_CcNode,
+                                   t_Handle h_Manip,
+                                   t_Handle h_FrmReplic)
 {
     t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_CcNode;
-    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)p_Ad;
+    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)h_Ad;
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                tmpReg32;
     t_Handle                p_AdNewPtr = NULL;
@@ -104,19 +120,19 @@ static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_
      * AD will be written into the match table itself (case (1))*/
     p_AdNewPtr = p_AdContLookup;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if (h_Manip && h_FrmReplic)
         FmPcdManipUpdateAdContLookupForCc(h_Manip,
-                                          p_Ad,
+                                          h_Ad,
                                           &p_AdNewPtr,
                                           (uint32_t)((XX_VirtToPhys(FrmReplicGetSourceTableDescriptor(h_FrmReplic)) - p_FmPcd->physicalMuramBase)));
     else if (h_FrmReplic)
-        FrmReplicUpdateAdContLookupForCc(h_FrmReplic, p_Ad, &p_AdNewPtr);
+        FrmReplicUpdateAdContLookupForCc(h_FrmReplic, h_Ad, &p_AdNewPtr);
     else
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     if (h_Manip)
         FmPcdManipUpdateAdContLookupForCc(h_Manip,
-                                          p_Ad,
+                                          h_Ad,
                                           &p_AdNewPtr,
 
 #ifdef FM_CAPWAP_SUPPORT
@@ -128,7 +144,7 @@ static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_
                                           );
 
     /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
-    if(p_AdNewPtr)
+    if (p_AdNewPtr)
     {
         /* cases (1) & (2) */
         tmpReg32 = 0;
@@ -178,12 +194,12 @@ static t_Error FmPcdCcAllocAndFillAdForContLookupManip(t_Handle h_CcNode)
     return E_OK;
 }
 
-static t_Error FmPcdCcSetRequiredAction(t_Handle    h_FmPcd,
-                                        uint32_t    requiredAction,
-                                        t_FmPcdCcKeyAndNextEngineParams *p_CcKeyAndNextEngineParamsTmp,
-                                        t_Handle    h_AdTmp,
-                                        uint16_t    numOfEntries,
-                                        t_Handle    h_Tree)
+static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_FmPcd,
+                                        uint32_t                            requiredAction,
+                                        t_FmPcdCcKeyAndNextEngineParams     *p_CcKeyAndNextEngineParamsTmp,
+                                        t_Handle                            h_AdTmp,
+                                        uint16_t                            numOfEntries,
+                                        t_Handle                            h_Tree)
 {
     t_AdOfTypeResult    *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
     uint32_t            tmpReg32;
@@ -400,15 +416,23 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
     if (p_AdditionalParams->h_ManipForRmv)
         FmPcdManipUpdateOwner(p_AdditionalParams->h_ManipForRmv, FALSE);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
+    if (p_AdditionalParams->h_FrmReplicForAdd)
+    {
+        FrmReplicUpdateGroupOwner(p_AdditionalParams->h_FrmReplicForAdd,
+                               TRUE,  /* add */
+                               TRUE,  /* fullUpdate */
+                               p_AdditionalParams->h_CurrentNode);
+    }
+
     if (p_AdditionalParams->h_FrmReplicForRmv)
     {
         FrmReplicUpdateGroupOwner(p_AdditionalParams->h_FrmReplicForRmv,
-                               FALSE,
+                               FALSE, /* remove */
                                TRUE,  /* fullUpdate */
-                               p_AdditionalParams->h_NodeForRmv);
+                               p_AdditionalParams->h_CurrentNode);
     }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     if (!useShadowStructs)
     {
@@ -491,7 +515,7 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     {
         if (p_FmPcdCcNextEngineParams->h_Manip)
         {
-            if(FmPcdCcAllocAndFillAdForContLookupManip(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)!= E_OK)
+            if (FmPcdCcAllocAndFillAdForContLookupManip(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)!= E_OK)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                 return NULL;
@@ -504,17 +528,17 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
                                NULL);
     }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if ((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
-        (p_FmPcdCcNextEngineParams->params.h_FrmReplic))
+        (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic))
     {
         FillAdOfTypeContLookup(h_Ad,
                                p_CcNode->h_FmPcd,
                                p_FmPcdCcNodeTmp,
                                p_FmPcdCcNextEngineParams->h_Manip,
-                               p_FmPcdCcNextEngineParams->params.h_FrmReplic);
+                               p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
     }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     XX_Free(p_FmPcdCcNodeTmp);
 
@@ -850,7 +874,7 @@ static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List
     t_CcNodeInformation   *p_CcNodeInfo = NULL;
     uint32_t        intFlags;
 
-    intFlags = XX_DisableAllIntr();
+    intFlags = XX_DisableAllIntr(); //TODO - replace by lock
 
     if (!LIST_IsEmpty(p_List))
     {
@@ -880,11 +904,6 @@ void ReleaseLst(t_List *p_List)
     LIST_DelAndInit(p_List);
 }
 
-void FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree)
-{
-    RELEASE_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
-}
-
 void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
 {
     t_List              *p_Pos;
@@ -895,7 +914,7 @@ void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
         h_FmPcdCcTree = p_CcNodeInfo->h_CcNode;
-        FmPcdCcTreeReleaseLock(h_FmPcdCcTree);
+        CcRootReleaseLock(h_FmPcdCcTree);
     }
 
     ReleaseLst(p_List);
@@ -978,7 +997,9 @@ static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCc
         *parseCodeCcSize = 0;
 }
 
-static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t *parseCodeRealSize)
+static void  GetSizeHeaderField(e_NetHeaderType     hdr,
+                                t_FmPcdFields       field,
+                                uint8_t             *parseCodeRealSize)
 {
     switch(hdr)
     {
@@ -1159,7 +1180,8 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
     }
 }
 
-t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
+                                 t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
 {
     uint16_t    absoluteProfileId;
     t_Error     err = E_OK;
@@ -1176,7 +1198,7 @@ t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_
              {
                  if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid &&
                          !p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not defined fqid for control flow for BMI next engine "));
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("overrideFqid defined, but not newFqid."));
                  if (p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
                      RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
              }
@@ -1228,12 +1250,12 @@ t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("not allowed to put statisticsEn when nextEngine == e_FM_PCD_CC"));
         break;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
          case(e_FM_PCD_FR):
-             if (!p_FmPcdCcNextEngineParams->params.h_FrmReplic)
+             if (!p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
                 err = E_NOT_SUPPORTED;
              break;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
@@ -1299,7 +1321,9 @@ static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
     return CC_PC_ILLEGAL;
 }
 
-static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
+static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
+                                     e_FmPcdHdrIndex    index,
+                                     t_FmPcdFields      field)
 {
 
       switch(hdr)
@@ -1504,7 +1528,11 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
     }
 }
 
-static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset)
+static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
+                              e_FmPcdHdrIndex   hdrIndex,
+                              uint32_t          offset,
+                              bool              glblMask,
+                              uint8_t           *parseArrayOffset)
 {
     bool offsetRelevant = FALSE;
 
@@ -1649,16 +1677,17 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
         return CC_PR_WITHOUT_OFFSET;
 }
 
-void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
+void FillAdOfTypeResult(t_Handle                    h_Ad,
+                        t_FmPcd                     *p_FmPcd,
+                        t_FmPcdCcNextEngineParams   *p_CcNextEngineParams)
 {
-    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult*)p_Ad;
+    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult*)h_Ad;
     uint32_t            tmp = 0, tmpNia = 0;
     uint16_t            profileId;
     t_Handle            p_AdNewPtr = NULL;
 
-    /* there are 3 cases handled in this routine of building a "result" type AD.
+    /* There are 3 cases handled in this routine of building a "result" type AD.
      * Case 1: No Manip. The action descriptor is built within the match table.
-     *         p_AdResult = p_AdNewPtr;
      * Case 2: Manip exists. A new AD is created - p_AdNewPtr. It is initialized
      *         either in the FmPcdManipUpdateAdResultForCc routine or it was already
      *         initialized and returned here.
@@ -1672,23 +1701,28 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
      * AD will be written into the match table itself (case (1))*/
     p_AdNewPtr = p_AdResult;
 
+    /* Create Manip and return p_AdNewPtr to either a new descriptor or NULL */
     if (p_CcNextEngineParams->h_Manip)
-        /* Create Manip and return p_AdNewPtr to either a new descriptor or NULL */
-        FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip, p_Ad, &p_AdNewPtr);
+        FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip,
+                                      h_Ad,
+                                      &p_AdNewPtr);
 
     /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
     if (p_AdNewPtr)
     {
         /* case (1) and (2) */
-        switch(p_CcNextEngineParams->nextEngine)
+        switch (p_CcNextEngineParams->nextEngine)
         {
-            case(e_FM_PCD_DONE):
-                if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
+            case (e_FM_PCD_DONE):
+                if (p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
                 {
-                    if(p_CcNextEngineParams->params.enqueueParams.overrideFqid)
+                    if (p_CcNextEngineParams->params.enqueueParams.overrideFqid)
                     {
                        tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                        tmp |= p_CcNextEngineParams->params.enqueueParams.newFqid;
+#if (DPAA_VERSION >= 11)
+                       tmp |= p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId << FM_PCD_AD_RESULT_VSP_SHIFT;
+#endif /* (DPAA_VERSION >= 11) */
                     }
                     else
                     {
@@ -1697,19 +1731,23 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
                     }
                 }
 
-                if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
+                if (p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
                     tmpNia |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
                 else
                     tmpNia |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
-                if(p_CcNextEngineParams->statisticsEn)
+
+                if (p_CcNextEngineParams->statisticsEn)
                     tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                 break;
 
-            case(e_FM_PCD_KG):
-                if(p_CcNextEngineParams->params.kgParams.overrideFqid)
+            case (e_FM_PCD_KG):
+                if (p_CcNextEngineParams->params.kgParams.overrideFqid)
                 {
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                     tmp |= p_CcNextEngineParams->params.kgParams.newFqid;
+#if (DPAA_VERSION >= 11)
+                    tmp |= p_CcNextEngineParams->params.kgParams.newRelativeStorageProfileId << FM_PCD_AD_RESULT_VSP_SHIFT;
+#endif /* (DPAA_VERSION >= 11) */
                 }
                 else
                 {
@@ -1720,26 +1758,33 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
                 tmpNia |= NIA_ENG_KG;
                 tmpNia |= FmPcdKgGetSchemeId(p_CcNextEngineParams->params.kgParams.h_DirectScheme);
 
-                if(p_CcNextEngineParams->statisticsEn)
+                if (p_CcNextEngineParams->statisticsEn)
                     tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                 break;
 
             case(e_FM_PCD_PLCR):
                 tmp = 0;
-                if(p_CcNextEngineParams->params.plcrParams.overrideParams)
+                if (p_CcNextEngineParams->params.plcrParams.overrideParams)
                 {
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
 
                     /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
-                    if(p_CcNextEngineParams->params.plcrParams.sharedProfile)
+                    if (p_CcNextEngineParams->params.plcrParams.sharedProfile)
                     {
                         tmpNia |= NIA_PLCR_ABSOLUTE;
-                        FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParams->params.plcrParams.newRelativeProfileId, &profileId);
+                        FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,
+                                                              e_FM_PCD_PLCR_SHARED,
+                                                              NULL,
+                                                              p_CcNextEngineParams->params.plcrParams.newRelativeProfileId,
+                                                              &profileId);
                     }
                     else
                         profileId = p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
 
                     tmp |= p_CcNextEngineParams->params.plcrParams.newFqid;
+#if (DPAA_VERSION >= 11)
+                    tmp |= p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId << FM_PCD_AD_RESULT_VSP_SHIFT;
+#endif /* (DPAA_VERSION >= 11) */
                     WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
                 }
                 else
@@ -1747,7 +1792,7 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
 
                 tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
 
-                if(p_CcNextEngineParams->statisticsEn)
+                if (p_CcNextEngineParams->statisticsEn)
                     tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                break;
 
@@ -1766,15 +1811,18 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
             tmpNia |= FM_PCD_AD_RESULT_NADEN;
         }
 
+#if (DPAA_VERSION >= 11)
+       tmpNia |= FM_PCD_AD_RESULT_NO_OM_VSPE;
+#endif /* (DPAA_VERSION >= 11) */
         WRITE_UINT32(p_AdResult->nia, tmpNia);
     }
 }
 
-static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
-                              t_Handle                         h_PcdParams,
-                              t_Handle                         h_FmPort,
-                              t_Handle                         h_FmTree,
-                              bool                             validate)
+static t_Error CcUpdateParams(t_Handle      h_FmPcd,
+                              t_Handle      h_PcdParams,
+                              t_Handle      h_FmPort,
+                              t_Handle      h_FmTree,
+                              bool          validate)
 {
     t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
 
@@ -1790,7 +1838,9 @@ static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
                          FALSE);
 }
 
-/*static*/ void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd)
+/*static*/ void NextStepAd(t_Handle                     h_Ad,
+                           t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
+                           t_FmPcd                      *p_FmPcd)
 {
     switch(p_FmPcdCcNextEngineParams->nextEngine)
     {
@@ -1798,28 +1848,28 @@ static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
         case(e_FM_PCD_PLCR):
         case(e_FM_PCD_DONE):
             /* if NIA is not CC, create a "result" type AD */
-            FillAdOfTypeResult(p_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
+            FillAdOfTypeResult(h_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
             break;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         case(e_FM_PCD_FR):
-            if (p_FmPcdCcNextEngineParams->params.h_FrmReplic)
+            if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
             {
-                FillAdOfTypeContLookup(p_Ad,
+                FillAdOfTypeContLookup(h_Ad,
                                        p_FmPcd,
                                        p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
                                        p_FmPcdCcNextEngineParams->h_Manip,
-                                       p_FmPcdCcNextEngineParams->params.h_FrmReplic);
-                                       FrmReplicUpdateGroupOwner(p_FmPcdCcNextEngineParams->params.h_FrmReplic,
+                                       p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
+                                       FrmReplicUpdateGroupOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
                                                                  TRUE,  /* add */
                                                                  FALSE, /* fullUpdate */
                                                                  NULL);
             }
             break;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
         case(e_FM_PCD_CC):
             /* if NIA is not CC, create a TD to continue the CC lookup */
-            FillAdOfTypeContLookup(p_Ad,
+            FillAdOfTypeContLookup(h_Ad,
                                    p_FmPcd,
                                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
                                    p_FmPcdCcNextEngineParams->h_Manip,
@@ -1837,13 +1887,17 @@ static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
 static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     if(p_AdditionalInfo->p_AdTableNew)
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
+                         p_AdditionalInfo->p_AdTableNew);
 
     if(p_AdditionalInfo->p_KeysMatchTableNew)
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd), p_AdditionalInfo->p_KeysMatchTableNew);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
+                         p_AdditionalInfo->p_KeysMatchTableNew);
 }
 
-static void UpdateGblMask(t_FmPcdCcNode *p_CcNode, uint8_t keySize, uint8_t *p_Mask)
+static void UpdateGblMask(t_FmPcdCcNode *p_CcNode,
+                          uint8_t       keySize,
+                          uint8_t       *p_Mask)
 {
     if (p_Mask &&
         !p_CcNode->glblMaskUpdated &&
@@ -1910,6 +1964,11 @@ static __inline t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
            | (16 bytes) | (maximal size)  |  (maximal size)  |
            ---------------------------------------------------
          */
+        if (!p_FmPcd->p_CcShadow)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Shadow not allocated"));
+            return NULL;
+        }
 
         h_Ad = p_FmPcd->p_CcShadow;
     }
@@ -1962,6 +2021,9 @@ static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_C
            ---------------------------------------------------
          */
 
+        if (!p_FmPcd->p_CcShadow)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("CC Shadow not allocated"));
+
         p_AdditionalInfo->p_KeysMatchTableNew = PTR_MOVE(p_FmPcd->p_CcShadow, FM_PCD_CC_AD_ENTRY_SIZE);
         p_AdditionalInfo->p_AdTableNew        = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, p_CcNode->keysMatchTableMaxSize);
 
@@ -2002,8 +2064,8 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
     /* Check that new key is not require update of localMask */
     UpdateGblMask(p_CcNode,
-                        p_CcNode->ccKeySizeAccExtraction,
-                        p_KeyParams->p_Mask);
+                  p_CcNode->ccKeySizeAccExtraction,
+                  p_KeyParams->p_Mask);
 
     /* Update internal data structure with new next engine for the given index */
     memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,
@@ -2189,6 +2251,13 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForAdd = p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
 
+#if (DPAA_VERSION >= 11)
+        if ((p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_KeyParams->ccNextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForAdd = p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
+
     if (!add)
     {
         if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
@@ -2196,16 +2265,20 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
         if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
             p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
-#if DPAA_VERSION >= 3
-        if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.h_FrmReplic)
-            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.h_FrmReplic;
-#endif /* DPAA_VERSION >= 3 */
+#if (DPAA_VERSION >= 11)
+        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
     }
 
     return E_OK;
 }
 
-static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_CcNode, uint16_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNode,
+                                     uint16_t                           keyIndex,
+                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     int         i = 0, j = 0;
     t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
@@ -2249,6 +2322,13 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_CcNode, uint16_t keyIndex,
     if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
         p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
+#if (DPAA_VERSION >= 11)
+        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
+
    return E_OK;
 }
 
@@ -2416,6 +2496,12 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
             p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
         if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
             p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+#if (DPAA_VERSION >= 11)
+        if ((p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
     }
     else
     {
@@ -2426,6 +2512,12 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
             p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
         if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
             p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+#if (DPAA_VERSION >= 11)
+        if ((p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
     }
 
     if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
@@ -2471,11 +2563,22 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
                 err = FmPcdCcSetRequiredAction(p_FmPcdCcNode1->h_FmPcd,
                                                p_FmPcdCcNode1->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
                                                &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                               p_Ad, 1, p_CcNodeInformation->h_CcNode);
+                                               p_Ad,
+                                               1,
+                                               p_CcNodeInformation->h_CcNode);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-                err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd, NULL, NULL, &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],1, p_Ad, TRUE, p_CcNodeInformation->index, p_CcNodeInformation->h_CcNode, TRUE);
+                err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd,
+                                    NULL,
+                                    NULL,
+                                    &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                    1,
+                                    p_Ad,
+                                    TRUE,
+                                    p_CcNodeInformation->index,
+                                    p_CcNodeInformation->h_CcNode,
+                                    TRUE);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
             }
@@ -2494,7 +2597,15 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-        err = CcUpdateParam(h_FmPcd, NULL, NULL, &p_AdditionalInfo->keyAndNextEngineParams[keyIndex], 1, p_Ad, TRUE, 0, (t_Handle)p_FmPcdCcTree, TRUE);
+        err = CcUpdateParam(h_FmPcd,
+                            NULL,
+                            NULL,
+                            &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                            1,
+                            p_Ad,
+                            TRUE,
+                            0,
+                            (t_Handle)p_FmPcdCcTree, TRUE);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -2502,12 +2613,20 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForAdd = p_CcNextEngineParams->params.ccParams.h_CcNode;
 
+#if (DPAA_VERSION >= 11)
+        if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
+            (p_CcNextEngineParams->params.frParams.h_FrmReplic) &&
+            (!(p_CcNextEngineParams->h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForAdd = p_CcNextEngineParams->params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
+
+
     return E_OK;
 }
 
 static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode                *p_CrntMdfNode,
                                                        t_List                       *h_OldLst,
-                                                       t_FmPcdCcNextEngineParams	**p_NextEngineParams)
+                                                       t_FmPcdCcNextEngineParams    **p_NextEngineParams)
 {
     t_CcNodeInformation     *p_CcNodeInformation;
     t_FmPcdCcNode           *p_NodePtrOnCurrentMdfNode = NULL;
@@ -2549,7 +2668,7 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
     }
 }
 
-static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode				*p_CrntMdfNode,
+static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode                *p_CrntMdfNode,
                                                        t_List                       *h_OldLst,
                                                        t_FmPcdCcNextEngineParams    **p_NextEngineParams)
 {
@@ -2586,7 +2705,7 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode				*p_CrntM
         }
 
         ASSERT_COND(i == p_TreePtrOnCurrentMdfNode->numOfEntries);
-     }
+    }
 }
 
 static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle        h_FmPcdCcNodeOrTree,
@@ -2720,10 +2839,10 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
     return p_FmPcdModifyCcKeyAdditionalParams;
 }
 
-static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode *p_CcNode,
-                                                t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams,
-                                                t_List *h_OldLst,
-                                                t_List *h_NewLst)
+static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode                       *p_CcNode,
+                                                t_FmPcdModifyCcKeyAdditionalParams  *p_FmPcdModifyCcKeyAdditionalParams,
+                                                t_List                              *h_OldLst,
+                                                t_List                              *h_NewLst)
 {
     t_FmPcdCcNextEngineParams   *p_NextEngineParams = NULL;
     t_CcNodeInformation         ccNodeInfo = {0};
@@ -2756,13 +2875,11 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode *p_CcNode,
     return E_OK;
 }
 
-static void  FmPcdCcUpdateTreeOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
+static void UpdateCcRootOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
 {
-    uint32_t    intFlags = 0;
-
     ASSERT_COND(p_FmPcdCcTree);
 
-    intFlags = FmPcdCcTreeLock(p_FmPcdCcTree);
+    /* this routine must be protected by the calling routine! */
 
     if (add)
        p_FmPcdCcTree->owners++;
@@ -2771,8 +2888,6 @@ static void  FmPcdCcUpdateTreeOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
         ASSERT_COND(p_FmPcdCcTree->owners);
         p_FmPcdCcTree->owners--;
     }
-
-    FmPcdCcTreeUnlock(p_FmPcdCcTree, intFlags);
 }
 
 static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
@@ -2893,10 +3008,10 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     return E_OK;
 }
 
-static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
-                                               t_FmPcdCcNodeParams  *p_CcNodeParam,
-                                               t_FmPcdCcNode        *p_CcNode,
-                                               bool                 *isKeyTblAlloc)
+static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
+                                                t_FmPcdCcNodeParams *p_CcNodeParam,
+                                                t_FmPcdCcNode       *p_CcNode,
+                                                bool                *isKeyTblAlloc)
 {
     int                 tmp = 0;
     t_FmPcdCcKeyParams  *p_KeyParams;
@@ -2905,7 +3020,10 @@ static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
     uint32_t            requiredAction = 0;
 
     if (p_CcNode->numOfKeys != 1)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for IPV4TTL and IPV6_HOP_LIMIT has to be only 1 key - TTL = 1, otherwise it's Miss"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'numOfKeys' is 1"));
+
+    if ((p_CcNodeParam->keysParams.maxNumOfKeys) && (p_CcNodeParam->keysParams.maxNumOfKeys != 1))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"));
 
     err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
     if (err)
@@ -2918,7 +3036,9 @@ static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
-    memcpy(&p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, sizeof(t_FmPcdCcNextEngineParams));
+    memcpy(&p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams,
+           &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+           sizeof(t_FmPcdCcNextEngineParams));
 
     p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction = requiredAction;
 
@@ -2930,10 +3050,7 @@ static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
-    if (p_CcNodeParam->keysParams.maxNumOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT 'maxNumOfKeys' must be zero"));
-
-    for(tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
@@ -2959,7 +3076,9 @@ static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
         p_CcNode->keyAndNextEngineParams[tmp].mask[0] = 0xFF;
 
         /* Store NextEngine parameters */
-        memcpy(&p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams, &p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+        memcpy(&p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams,
+               &p_KeyParams->ccNextEngineParams,
+               sizeof(t_FmPcdCcNextEngineParams));
 
         if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
             && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
@@ -2994,18 +3113,18 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     while (countMask)
     {
         countOnes++;
-        countMask=(uint16_t)(countMask>>1);
+        countMask = (uint16_t)(countMask >> 1);
     }
 
-    if (p_CcNodeParam->keysParams.maxNumOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be set to 0"));
-
     if (!POWER_OF_2(p_CcNode->numOfKeys))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED numOfKeys has to be powerOfTwo"));
 
-    if (p_CcNode->numOfKeys != ((uint32_t)1<<countOnes ))
+    if (p_CcNode->numOfKeys != ((uint32_t)1 << countOnes ))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"));
 
+    if ((p_CcNodeParam->keysParams.maxNumOfKeys) && (p_CcNodeParam->keysParams.maxNumOfKeys != p_CcNode->numOfKeys))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
+
     err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
     if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
         RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
@@ -3082,7 +3201,7 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams =  ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, FALSE);
+    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -3092,13 +3211,13 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
             return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine (h_FmPcd,
-                                        p_CcNode,
-                                        keyIndex,
-                                        p_FmPcdCcNextEngineParams,
-                                        &h_OldPointersLst,
-                                        &h_NewPointersLst,
-                                        p_ModifyKeyParams);
+    err = BuildNewNodeModifyNextEngine(h_FmPcd,
+                                       p_CcNode,
+                                       keyIndex,
+                                       p_FmPcdCcNextEngineParams,
+                                       &h_OldPointersLst,
+                                       &h_NewPointersLst,
+                                       p_ModifyKeyParams);
     if (err)
     {
         XX_Free(p_ModifyKeyParams);
@@ -3134,7 +3253,7 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
     if (!p_Mask)
         memset(tmpMask, 0xFF, keySize);
 
-    for(i = 0 ; i < p_CcNode->numOfKeys; i++)
+    for (i = 0 ; i < p_CcNode->numOfKeys; i++)
     {
         /* Comparing received key */
         if (memcmp(p_Key, p_CcNode->keyAndNextEngineParams[i].key, keySize) == 0)
@@ -3160,7 +3279,7 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
         }
     }
 
-    return E_NOT_FOUND;
+    return ERROR_CODE(E_NOT_FOUND);
 }
 
 
@@ -3174,12 +3293,14 @@ t_CcNodeInformation* FmPcdCcFindNodeInfoInReleventLst(t_List *p_List, t_Handle h
     t_List              *p_Pos;
     uint32_t            intFlags;
 
-    intFlags = XX_DisableAllIntr();
+    intFlags = XX_DisableAllIntr();  //TODO - replace by lock
 
     for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
     {
         p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
+
         ASSERT_COND(p_CcInformation->h_CcNode);
+
         if(p_CcInformation->h_CcNode == h_Info)
         {
             XX_RestoreAllIntr(intFlags);
@@ -3198,7 +3319,7 @@ void FmPcdCcDequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info)
     uint32_t            intFlags;
     t_List              *p_Pos;
 
-    intFlags = XX_DisableAllIntr();
+    intFlags = XX_DisableAllIntr();  //TODO - replace by lock
 
     if (LIST_IsEmpty(p_List))
     {
@@ -3224,7 +3345,7 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
                           t_Handle  h_FmTree,
                           t_Handle  h_NetEnv,
                           t_Handle  h_IpReassemblyManip,
-                          bool      schemes)
+                          bool      createSchemes)
 {
     t_FmPcdCcTree               *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
     t_FmPcdCcNextEngineParams   nextEngineParams;
@@ -3236,6 +3357,8 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
 
     ASSERT_COND(p_FmPcdCcTree);
 
+    /* this routine must be protected by the calling routine! */
+
     if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-2))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
 
@@ -3243,34 +3366,88 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
     memset(&netEnvParams, 0, sizeof(t_NetEnvParams));
 
     h_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
+
     isIpv4Present = FmPcdManipIsIpPresent(h_FmPcd, p_FmPcdCcTree->netEnvId, FALSE);
     isIpv6Present = FmPcdManipIsIpPresent(h_FmPcd, p_FmPcdCcTree->netEnvId, TRUE);
+
     netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
     netEnvParams.numOfDistinctionUnits = 0;
+
     err = PcdGetUnitsVector(h_FmPcd, &netEnvParams);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
+
     nextEngineParams.nextEngine = e_FM_PCD_DONE;
     nextEngineParams.h_Manip = h_IpReassemblyManip;
+
+    /* Lock tree */
+    err = CcRootTryLock(p_FmPcdCcTree);
+    if (err)
+        return ERROR_CODE(E_BUSY);
+
+    if (p_FmPcdCcTree->h_IpReassemblyManip == h_IpReassemblyManip)
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        return E_OK;
+    }
+
+    if ((p_FmPcdCcTree->h_IpReassemblyManip) &&
+        (p_FmPcdCcTree->h_IpReassemblyManip != h_IpReassemblyManip))
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This tree was previously updated with different IPR"));
+    }
+
+    /* Initialize IPR for the first time for this tree */
     if (isIpv6Present)
     {
         ipv6GroupId = p_FmPcdCcTree->numOfGrps++;
         p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].totalBitsMask = netEnvParams.vector;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = p_FmPcdCcTree->numOfEntries++;
-        if (schemes)
-            FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, FALSE, ipv6GroupId);
-        NextStepAd(PTR_MOVE(h_Ad, ipv6GroupId * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
+        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = 14;
+
+        if (createSchemes)
+        {
+            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, FALSE, ipv6GroupId);
+            if (err)
+            {
+                p_FmPcdCcTree->numOfGrps--;
+                CcRootReleaseLock(p_FmPcdCcTree);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+        }
+
+        NextStepAd(PTR_MOVE(h_Ad, 14 * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
     }
+
     if (isIpv4Present)
     {
         ipv4GroupId = p_FmPcdCcTree->numOfGrps++;
         p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].totalBitsMask = netEnvParams.vector;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = p_FmPcdCcTree->numOfEntries++;
-        if (schemes)
-            FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
-        NextStepAd(PTR_MOVE(h_Ad, ipv4GroupId * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
+        p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = 15;
+
+        if (createSchemes)
+        {
+            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
+            if (err)
+            {
+                if (isIpv6Present)
+                {
+                    /* Removing both IPv4 and IPv6 groups */
+                    p_FmPcdCcTree->numOfGrps -= 2;
+                    FmPcdManipDeleteIpReassmSchemes(h_IpReassemblyManip);
+                }
+                CcRootReleaseLock(p_FmPcdCcTree);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+        }
+
+        NextStepAd(PTR_MOVE(h_Ad, 15 * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
     }
+
     p_FmPcdCcTree->h_IpReassemblyManip = h_IpReassemblyManip;
+
+    CcRootReleaseLock(p_FmPcdCcTree);
+
     return E_OK;
 }
 
@@ -3333,7 +3510,7 @@ void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo)
         memcpy(p_CcInformation, p_CcInfo, sizeof(t_CcNodeInformation));
         INIT_LIST(&p_CcInformation->node);
 
-        intFlags = XX_DisableAllIntr();
+        intFlags = XX_DisableAllIntr();  //TODO - replace by lock
         LIST_AddToTail(&p_CcInformation->node, p_List);
         XX_RestoreAllIntr(intFlags);
     }
@@ -3507,7 +3684,7 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
                        p_Key,
                        p_Mask,
                        &tmpKeyIndex);
-    if (err != E_NOT_FOUND)
+    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
         RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
                      ("The received key and mask pair was already found in the match table of the provided node"));
 
@@ -3596,13 +3773,13 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
             return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine (h_FmPcd,
-                                        p_CcNode,
-                                        keyIndex,
-                                        p_FmPcdCcNextEngineParams,
-                                        &h_OldPointersLst,
-                                        &h_NewPointersLst,
-                                        p_ModifyKeyParams);
+    err = BuildNewNodeModifyNextEngine(h_FmPcd,
+                                       p_CcNode,
+                                       keyIndex,
+                                       p_FmPcdCcNextEngineParams,
+                                       &h_OldPointersLst,
+                                       &h_NewPointersLst,
+                                       p_ModifyKeyParams);
     if (err)
     {
         XX_Free(p_ModifyKeyParams);
@@ -3658,7 +3835,7 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
                        p_FmPcdCcKeyParams->p_Key,
                        p_FmPcdCcKeyParams->p_Mask,
                        &keyIndex);
-    if (err != E_NOT_FOUND)
+    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
         RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
                      ("The received key and mask pair was already found in the match table of the provided node"));
 
@@ -3758,7 +3935,7 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
                        p_FmPcdCcKeyParams->p_Key,
                        p_FmPcdCcKeyParams->p_Mask,
                        &tmpKeyIndex);
-    if (err != E_NOT_FOUND)
+    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
         RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
                      ("The received key and mask pair was already found in the match table of the provided node"));
 
@@ -3856,67 +4033,71 @@ t_Error  FmPcdCcBindTree(t_Handle h_FmPcd,
     t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
     t_Error             err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
+
+    /* this routine must be protected by the calling routine by locking all PCD modules! */
 
-    FmPcdCcUpdateTreeOwner(p_FmPcdCcTree, TRUE);
+    err = CcUpdateParams(h_FmPcd, h_PcdParams, h_FmPort, h_FmPcdCcTree, TRUE);
+
+    if (err == E_OK)
+        UpdateCcRootOwner(p_FmPcdCcTree, TRUE);
 
     *p_Offset = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr)) -
                            p_FmPcd->physicalMuramBase);
 
-    err = CcUpdateParams(h_FmPcd, h_PcdParams, h_FmPort, h_FmPcdCcTree, TRUE);
-
     return err;
 }
 
 t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
 {
-    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+
+    /* this routine must be protected by the calling routine by locking all PCD modules! */
 
     UNUSED(h_FmPcd);
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_HANDLE);
 
-    FmPcdCcUpdateTreeOwner(p_FmPcdCcTree, FALSE);
+    UpdateCcRootOwner(p_FmPcdCcTree, FALSE);
 
     return E_OK;
 }
 
-t_Error FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree)
-{
-    if (TRY_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->h_Spinlock, &((t_FmPcdCcTree *)h_FmPcdCcTree)->lock))
-        return E_OK;
-
-    return ERROR_CODE(E_BUSY);
-}
-
 t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
 {
     t_FmPcdCcNode           *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_List                  *p_Pos;
+    t_List                  *p_Pos, *p_Tmp;
     t_CcNodeInformation     *p_CcNodeInfo, nodeInfo;
     t_Error                 err = E_OK;
 
     UNUSED(h_FmPcd);
 
-    if(LIST_IsEmpty(&p_CcNode->ccTreesLst))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+    if (LIST_IsEmpty(&p_CcNode->ccTreesLst))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"));
 
     LIST_FOR_EACH(p_Pos, &p_CcNode->ccTreesLst)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
         ASSERT_COND(p_CcNodeInfo->h_CcNode);
 
-        err = FmPcdCcTreeTryLock(p_CcNodeInfo->h_CcNode);
+        err = CcRootTryLock(p_CcNodeInfo->h_CcNode);
 
-        if(err == E_OK)
+        if (err)
         {
-            memset(&nodeInfo, 0, sizeof(t_CcNodeInformation));
-            nodeInfo.h_CcNode = p_CcNodeInfo->h_CcNode;
-            EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo);
+            LIST_FOR_EACH(p_Tmp, &p_CcNode->ccTreesLst)
+            {
+                if (p_Tmp == p_Pos)
+                    break;
+
+                CcRootReleaseLock(p_CcNodeInfo->h_CcNode);
+            }
+            break;
         }
-        else
-            FmPcdCcTreeReleaseLock(p_List);
+
+        memset(&nodeInfo, 0, sizeof(t_CcNodeInformation));
+        nodeInfo.h_CcNode = p_CcNodeInfo->h_CcNode;
+        EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo);
     }
 
     return err;
@@ -3926,6 +4107,7 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
 {
     uint32_t    intFlags;
     uint32_t    newSize = 0, newAlign = 0;
+    bool        allocFail = FALSE;
 
     ASSERT_COND(p_FmPcd);
 
@@ -3946,7 +4128,8 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
     if (align > p_FmPcd->ccShadowAlign)
         newAlign = align;
 
-    /* If a bigger shadow size or bigger shadow alignment are required, the shadow will be reallocated */
+    /* If a bigger shadow size or bigger shadow alignment are required,
+       a new shadow will be allocated */
     if ((newSize != p_FmPcd->ccShadowSize) || (newAlign != p_FmPcd->ccShadowAlign))
     {
         intFlags = FmPcdLock(p_FmPcd);
@@ -3958,11 +4141,23 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
             p_FmPcd->ccShadowAlign = 0;
         }
 
-        p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd), newSize, newAlign);
+        p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
+                                                newSize,
+                                                newAlign);
+        if (!p_FmPcd->p_CcShadow)
+        {
+            allocFail = TRUE;
+
+            /* If new shadow size allocation failed,
+               re-allocate with previous parameters */
+            p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
+                                                    p_FmPcd->ccShadowSize,
+                                                    p_FmPcd->ccShadowAlign);
+        }
 
         FmPcdUnlock(p_FmPcd, intFlags);
 
-        if (!p_FmPcd->p_CcShadow)
+        if (allocFail)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Shadow memory"));
 
         p_FmPcd->ccShadowSize  = newSize;
@@ -3972,7 +4167,7 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
     return E_OK;
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
                                               t_Handle  h_ReplicGroup,
                                               t_List    *p_AdTables,
@@ -3990,7 +4185,7 @@ void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
     for (i = 0; i < p_CurrentNode->numOfKeys + 1; i++)
     {
         if ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic == (t_Handle)h_ReplicGroup)))
+            ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic == (t_Handle)h_ReplicGroup)))
         {
             /* save the current ad table in the list */
             /* this entry uses the input replicator group */
@@ -4004,7 +4199,7 @@ void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
 
     ASSERT_COND(i != p_CurrentNode->numOfKeys);
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 /*********************** End of inter-module routines ************************/
 
 
@@ -4240,6 +4435,14 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         }
     }
 
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DeleteTree(p_FmPcdCcTree, p_FmPcd);
+        XX_Free(p_Params);
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return NULL;
+    }
+
     for(i = 0; i < numOfEntries; i++)
     {
         if(p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
@@ -4248,6 +4451,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
                                             &p_FmPcdCcTree->keyAndNextEngineParams[i], p_CcTreeTmp,1, p_FmPcdCcTree);
             if(err)
             {
+                FmPcdLockUnlockAll(p_FmPcd);
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
                 XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
@@ -4257,16 +4461,16 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         }
     }
 
-    p_FmPcdCcTree->h_Spinlock = XX_InitSpinlock();
-    if (!p_FmPcdCcTree->h_Spinlock)
+    FmPcdLockUnlockAll(p_FmPcd);
+    p_FmPcdCcTree->p_Lock = FmPcdAcquireLock(p_FmPcd);
+    if (!p_FmPcdCcTree->p_Lock)
     {
-        DeleteTree(p_FmPcdCcTree,p_FmPcd);
+        DeleteTree(p_FmPcdCcTree, p_FmPcd);
         XX_Free(p_Params);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM CC spinlock"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM CC lock"));
         return NULL;
     }
 
-
     XX_Free(p_Params);
     return p_FmPcdCcTree;
 }
@@ -4283,7 +4487,7 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
 
     FmPcdDecNetEnvOwners(p_FmPcd, p_CcTree->netEnvId);
 
-    if(p_CcTree->owners)
+    if (p_CcTree->owners)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
 
     /* Delete reassembly schemes if exist */
@@ -4313,34 +4517,33 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
         }
 #endif /* FM_CAPWAP_SUPPORT */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if ((p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic))
+            (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
         {
-             FrmReplicUpdateGroupOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic,
+             FrmReplicUpdateGroupOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
                                        FALSE,
                                        TRUE,  /* fullUpdate */
                                        p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode);
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     }
 
-    if (p_CcTree->h_Spinlock)
-        XX_FreeSpinlock(p_CcTree->h_Spinlock);
+    if (p_CcTree->p_Lock)
+        FmPcdReleaseLock(p_CcTree->h_FmPcd, p_CcTree->p_Lock);
 
     DeleteTree(p_CcTree, p_FmPcd);
 
     return E_OK;
 }
 
-t_Error FM_PCD_CcRootModifyNextEngine(t_Handle  h_CcTree,
-                                      uint8_t   grpId,
-                                      uint8_t   index,
+t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
+                                      uint8_t                   grpId,
+                                      uint8_t                   index,
                                       t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcTree   *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -4348,11 +4551,11 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle  h_CcTree,
     p_FmPcd = (t_FmPcd *)p_CcTree->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcTreeTryLock(p_CcTree);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcModifyNextEngineParamTree(p_FmPcd,
                                            p_CcTree,
@@ -4361,11 +4564,11 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle  h_CcTree,
                                            p_FmPcdCcNextEngineParams);
     if (err)
     {
-        FmPcdCcTreeReleaseLock(p_CcTree);
+        CcRootReleaseLock(p_CcTree);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    FmPcdCcTreeReleaseLock(p_CcTree);
+    FmPcdLockUnlockAll(p_FmPcd);
 
     return E_OK;
 }
@@ -4389,7 +4592,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
 
     p_CcNode = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
-    if(!p_CcNode)
+    if (!p_CcNode)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
         return NULL;
@@ -4415,7 +4618,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6 == NET_HEADER_FIELD_IPv6_HOP_LIMIT) ||
         (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4 == NET_HEADER_FIELD_IPv4_TTL)))
     {
-        err = Ipv4TtlOrIpv6HopLimiCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
+        err = Ipv4TtlOrIpv6HopLimitCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
         glblMask = FALSE;
     }
     else if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
@@ -4423,7 +4626,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
               (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
               (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
     {
-        if((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
+        if ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
             (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
         {
             REPORT_ERROR(MAJOR, E_INVALID_VALUE,
@@ -4449,14 +4652,14 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         else
         {
             err = CheckParams(h_FmPcd, p_CcNodeParam,p_CcNode, &isKeyTblAlloc);
-            if(p_CcNode->glblMaskSize)
+            if (p_CcNode->glblMaskSize)
                 glblMask = TRUE;
         }
     }
     else
     {
         err = CheckParams(h_FmPcd, p_CcNodeParam,p_CcNode, &isKeyTblAlloc);
-        if(p_CcNode->glblMaskSize)
+        if (p_CcNode->glblMaskSize)
             glblMask = TRUE;
     }
 
@@ -4469,10 +4672,10 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
     switch (p_CcNodeParam->extractCcParams.type)
     {
-        case(e_FM_PCD_EXTRACT_BY_HDR):
-            switch(p_CcNodeParam->extractCcParams.extractByHdr.type)
+        case (e_FM_PCD_EXTRACT_BY_HDR):
+            switch (p_CcNodeParam->extractCcParams.extractByHdr.type)
             {
-                case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                case (e_FM_PCD_EXTRACT_FULL_FIELD):
                     p_CcNode->parseCode =
                         GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
                                               p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
@@ -4497,7 +4700,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                     }
                     break;
 
-                case(e_FM_PCD_EXTRACT_FROM_HDR):
+                case (e_FM_PCD_EXTRACT_FROM_HDR):
                     p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
                     p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
                     p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
@@ -4508,7 +4711,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                                        &p_CcNode->prsArrayOffset);
                     break;
 
-                case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                case (e_FM_PCD_EXTRACT_FROM_FIELD):
                     p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
                     p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
                     p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
@@ -4527,7 +4730,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             }
             break;
 
-        case(e_FM_PCD_EXTRACT_NON_HDR):
+        case (e_FM_PCD_EXTRACT_NON_HDR):
             /* get the field code for the generic extract */
             p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
             p_CcNode->offset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
@@ -4602,7 +4805,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     GetCcExtractKeySize(p_CcNode->sizeOfExtraction, &p_CcNode->ccKeySizeAccExtraction);
 
     /* If local mask is used, it is stored next to each key in the keys match table */
-    if(p_CcNode->lclMask)
+    if (p_CcNode->lclMask)
         keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
     else
         keySize = p_CcNode->ccKeySizeAccExtraction;
@@ -4617,20 +4820,34 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         p_CcNode->keysMatchTableMaxSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t) * p_CcNode->maxNumOfKeys;
 
         if (p_CcNode->maskSupport)
+        {
             p_CcNode->keysMatchTableMaxSize *= 2;
 
+            /* If local mask is currently used, 'keySize' holds local mask size.
+               Otherwise, we need to allocate twice as much memory for future local mask support. */
+            if (!(p_CcNode->lclMask))
+                numOfKeysToAlloc *= 2;
+        }
+
         /* Calculate maximal shadow size of this node.
-           All shadow structures will be used for runtime modifications host command.*/
+           All shadow structures will be used for runtime modifications host command.
+           If keys table was allocated for this node, the keys table and next engines table may be
+           modified in run time (entries added or removed), so shadow tables are requires.
+           Otherwise, the only supported runtime modification is a specific next engine update and
+           this requires shadow memory of a single AD */
 
         /* Shadow size should be enough to hold the following 3 structures:
-           1 - keys match table */
-        shadowSize = p_CcNode->keysMatchTableMaxSize;
+         * 1 - an action descriptor */
+        shadowSize = FM_PCD_CC_AD_ENTRY_SIZE;
 
-        /* 2 - next action descriptors table, including one more entry for miss */
-        shadowSize += (p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE;
+        if (isKeyTblAlloc)
+        {
+            /* 2 - keys match table, if was allocated for the current node */
+            shadowSize += p_CcNode->keysMatchTableMaxSize;
 
-        /* 3 - an extra action descriptor (AD that holds keys match table and next action descriptors table) */
-        shadowSize += FM_PCD_CC_AD_ENTRY_SIZE;
+            /* 3 - next action descriptors table, including one more entry for miss */
+            shadowSize += (p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE;
+        }
 
         /* Update shadow to the calculated size */
         err = FmPcdUpdateCcShadow (p_CcNode->h_FmPcd, (uint32_t)shadowSize, FM_PCD_CC_AD_TABLE_ALIGN);
@@ -4641,9 +4858,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         }
     }
     else
-    {
         numOfKeysToAlloc = p_CcNode->numOfKeys;
-    }
 
     /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
        identification, IPv6 hop count identification, etc. */
@@ -4659,7 +4874,9 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
             return NULL;
         }
-        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable, 0, keySize * sizeof(uint8_t) * (numOfKeysToAlloc + 1));
+        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable,
+                   0,
+                   keySize * sizeof(uint8_t) * (numOfKeysToAlloc + 1));
     }
 
     /* Allocate action descriptors table */
@@ -4673,30 +4890,32 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
         return NULL;
     }
-    IOMemSet32((uint8_t *)p_CcNode->h_AdTable, 0, (uint32_t)((numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32((uint8_t *)p_CcNode->h_AdTable,
+               0,
+               (uint32_t)((numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
 
     p_KeysMatchTblTmp = p_CcNode->h_KeysMatchTable;
     p_AdTableTmp      = p_CcNode->h_AdTable;
 
     /* For each key, create the key and the next step AD */
-    for(tmp = 0 ; tmp < p_CcNode->numOfKeys; tmp++)
+    for (tmp = 0 ; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
-        if(p_KeysMatchTblTmp)
+        if (p_KeysMatchTblTmp)
         {
             /* Copy the key */
             Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_CcNode->sizeOfExtraction);
 
             /* Copy the key mask or initialize it to 0xFF..F */
-            if(p_CcNode->lclMask && p_KeyParams->p_Mask)
+            if (p_CcNode->lclMask && p_KeyParams->p_Mask)
             {
                 Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp,
                             p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
                             p_KeyParams->p_Mask,
                             p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
             }
-            else if(p_CcNode->lclMask)
+            else if (p_CcNode->lclMask)
             {
                 IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
                            p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
@@ -4706,27 +4925,27 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
             p_KeysMatchTblTmp = PTR_MOVE(p_KeysMatchTblTmp, keySize * sizeof(uint8_t));
         }
+
         /* Create the next action descriptor in the match table */
-        NextStepAd(p_AdTableTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+        NextStepAd(p_AdTableTmp, &p_KeyParams->ccNextEngineParams, p_FmPcd);
 
         p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
-
     }
 
-    NextStepAd(p_AdTableTmp,&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
+    NextStepAd(p_AdTableTmp, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
 
     /* This parameter will be used to initialize the "key length" field in the action descriptor
        that points to this node and it should be 0 for full field extraction */
-    if(fullField == TRUE)
+    if (fullField == TRUE)
         p_CcNode->sizeOfExtraction = 0;
 
-    for(tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
     {
-        if(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
 
-            if(!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+            if (!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                 ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
@@ -4743,36 +4962,40 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         }
     }
 
-    for(tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
     {
-        if(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
 
-            if(IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+            if (IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
                 UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, FALSE);
         }
     }
 
     p_AdTableTmp = p_CcNode->h_AdTable;
 
+    if (!FmPcdLockTryLockAll(h_FmPcd))
+    {
+        FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return NULL;
+    }
 
     /* Required action for each next engine */
     for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
     {
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.h_FrmReplic)
+            (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.frParams.h_FrmReplic)
             && (!(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)))
-        {
-            FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.h_FrmReplic,
+            FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.frParams.h_FrmReplic,
                                       TRUE, /* add */
                                       TRUE, /* fullUpdate */
                                       p_CcNode);
-        }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
-        if(p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
+        if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
         {
 
             err = FmPcdCcSetRequiredAction(h_FmPcd,
@@ -4783,6 +5006,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                                            NULL);
             if (err)
             {
+                FmPcdLockUnlockAll(h_FmPcd);
                 FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
                 REPORT_ERROR(MAJOR, err, NO_MSG);
                 return NULL;
@@ -4800,14 +5024,16 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                                         p_AdTableTmp,
                                         1,
                                         NULL);
-         if(err)
+         if (err)
          {
+            FmPcdLockUnlockAll(h_FmPcd);
             FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
             REPORT_ERROR(MAJOR, err, NO_MSG);
             return NULL;
         }
     }
 
+    FmPcdLockUnlockAll(h_FmPcd);
     return p_CcNode;
 }
 
@@ -4825,36 +5051,34 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID can not be removed because this node is occupied, first - unbind this node"));
 
     for (i = 0; i < p_CcNode->numOfKeys; i++)
-    {
-        if(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
-    }
 
     if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
         UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
 
     /* Handle also Miss entry */
-    for(i = 0; i < p_CcNode->numOfKeys + 1; i++)
+    for (i = 0; i < p_CcNode->numOfKeys + 1; i++)
     {
         if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
             FmPcdManipUpdateOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip, FALSE);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic))
+            (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
         {
             if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
-                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic,
+                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
                                           FALSE,
                                           FALSE, /* fullUpdate */
                                           NULL);
             else
-                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic,
+                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
                                           FALSE,
                                           TRUE,  /* fullUpdate */
                                           p_CcNode);
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     }
 
     DeleteNode(p_CcNode);
@@ -4870,7 +5094,6 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
@@ -4884,11 +5107,11 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcAddKey(p_FmPcd,
                         p_CcNode,
@@ -4896,12 +5119,20 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
                         keySize,
                         p_KeyParams);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
@@ -4909,7 +5140,6 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -4917,23 +5147,30 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcRemoveKey(p_FmPcd, p_CcNode, keyIndex);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
+
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 
     return E_OK;
 }
@@ -4957,16 +5194,16 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
     INIT_LIST(&h_List);
 
     intFlags = FmPcdLock(p_FmPcd);
     err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
     FmPcdUnlock(p_FmPcd, intFlags);
     if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    {
+        DBG(TRACE, ("Node's trees lock failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcModifyKey(p_FmPcd,
                            p_CcNode,
@@ -4977,10 +5214,18 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
 
     FmPcdCcNodeTreeReleaseLock(&h_List);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
@@ -4990,7 +5235,6 @@ t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -4999,39 +5243,41 @@ t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = ModifyNextEngineParamNode(p_FmPcd,
                                     p_CcNode,
                                     keyIndex,
                                     p_FmPcdCcNextEngineParams);
-    if(err)
+
+    FmPcdLockUnlockAll(p_FmPcd);
+
+    switch (GET_ERROR_TYPE(err))
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        case E_OK:
+            return E_OK;
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
 
-    return E_OK;
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
-t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle h_CcNode,
-                                              t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                      h_CcNode,
+                                              t_FmPcdCcNextEngineParams     *p_FmPcdCcNextEngineParams)
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -5042,25 +5288,30 @@ t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle h_CcNode,
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcModifyMissNextEngineParamNode(p_FmPcd,
                                                p_CcNode,
                                                p_FmPcdCcNextEngineParams);
-    if (err)
+
+    FmPcdLockUnlockAll(p_FmPcd);
+
+    switch (GET_ERROR_TYPE(err))
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        case E_OK:
+            return E_OK;
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
 
-    return E_OK;
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
@@ -5071,7 +5322,6 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
@@ -5080,31 +5330,34 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd,
                                         p_CcNode,
                                         keyIndex,
                                         keySize,
                                         p_KeyParams);
-    if (err)
+
+    FmPcdLockUnlockAll(p_FmPcd);
+
+    switch (GET_ERROR_TYPE(err))
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        case E_OK:
+            return E_OK;
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
 
-    return E_OK;
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 
@@ -5116,7 +5369,6 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -5128,14 +5380,14 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
-    if (err != E_OK)
+    if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(&h_List);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
@@ -5143,12 +5395,20 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
 
     err = FmPcdCcRemoveKey(p_FmPcd, p_CcNode, keyIndex);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 
@@ -5161,7 +5421,6 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -5174,14 +5433,14 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
-    if (err != E_OK)
+    if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(&h_List);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
@@ -5192,12 +5451,20 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
                                     keyIndex,
                                     p_FmPcdCcNextEngineParams);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNode,
@@ -5209,7 +5476,6 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -5222,14 +5488,14 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
-    if (err != E_OK)
+    if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(&h_List);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
@@ -5241,13 +5507,20 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
                                         keySize,
                                         p_KeyParams);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
 
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
@@ -5277,13 +5550,17 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
     err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
     FmPcdUnlock(p_FmPcd, intFlags);
     if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    {
+        DBG(TRACE, ("Node's trees lock failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
-    if (err != E_OK)
+    if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the "
+                                  "match table of the provided node"));
     }
 
     err = FmPcdCcModifyKey(p_FmPcd,
@@ -5295,10 +5572,18 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
 
     FmPcdCcNodeTreeReleaseLock(&h_List);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
@@ -5308,20 +5593,14 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
 
-    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
-    if(keyIndex > p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > numOfKeys"));
+    if (keyIndex >= p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex exceeds current number of keys"));
 
-    if(keyIndex > FM_PCD_MAX_NUM_OF_CC_NODES)
+    if (keyIndex > FM_PCD_MAX_NUM_OF_CC_NODES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex can not be larger than 255"));
 
-    if(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
-        if(keyIndex == p_CcNode->numOfKeys)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This type of node doesn't have Miss"));
-
     memcpy(p_FmPcdCcNextEngineParams,
            &p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams,
            sizeof(t_FmPcdCcNextEngineParams));
@@ -5329,6 +5608,7 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
     return E_OK;
 }
 
+
 uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
 {
     t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
@@ -5399,8 +5679,7 @@ t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
 t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
 {
     t_FmPcdCcNode           *p_CcNodeHashTbl;
-    t_FmPcdCcNodeParams     *p_indxHashCcNodeParam = NULL,
-                            *p_exactMatchCcNodeParam = NULL;
+    t_FmPcdCcNodeParams     *p_IndxHashCcNodeParam, *p_ExactMatchCcNodeParam;
     t_Handle                h_CcNode;
     t_FmPcdCcKeyParams      *p_HashKeyParams;
     uint32_t                i;
@@ -5409,23 +5688,34 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_Param, E_NULL_POINTER, NULL);
 
-    p_exactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
-    if(!p_exactMatchCcNodeParam)
+    if (p_Param->maxNumOfKeys == 0)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Max number of keys must be higher then 0"));
+        return NULL;
+    }
+
+    if (p_Param->hashResMask == 0)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_exactMatchCcNodeParam"));
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Hash result mask must differ from 0"));
         return NULL;
     }
 
-    p_indxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
-    if(!p_indxHashCcNodeParam)
+    p_ExactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    if(!p_ExactMatchCcNodeParam)
     {
-        XX_Free(p_exactMatchCcNodeParam);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_indxHashCcNodeParam"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_ExactMatchCcNodeParam"));
         return NULL;
     }
+    memset(p_ExactMatchCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
 
-    memset(p_exactMatchCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
-    memset(p_indxHashCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
+    p_IndxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    if(!p_IndxHashCcNodeParam)
+    {
+        XX_Free(p_ExactMatchCcNodeParam);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_IndxHashCcNodeParam"));
+        return NULL;
+    }
+    memset(p_IndxHashCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
 
     /* Calculate number of sets and number of ways of the hash table */
     countMask = (uint16_t)(p_Param->hashResMask >> 4);
@@ -5442,25 +5732,25 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         DBG(INFO, ("'maxNumOfKeys' is not a multiple of hash number of ways, so number of ways will be rounded up"));
 
     /* Building exact-match node params, will be used to create the hash buckets */
-    p_exactMatchCcNodeParam->extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
+    p_ExactMatchCcNodeParam->extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
 
-    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.src     = e_FM_PCD_EXTRACT_FROM_KEY;
-    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.action  = e_FM_PCD_ACTION_EXACT_MATCH;
-    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.offset  = 0;
-    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.size    = p_Param->matchKeySize;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.src     = e_FM_PCD_EXTRACT_FROM_KEY;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.action  = e_FM_PCD_ACTION_EXACT_MATCH;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.offset  = 0;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.size    = p_Param->matchKeySize;
 
-    p_exactMatchCcNodeParam->keysParams.maxNumOfKeys               = numOfWays;
-    p_exactMatchCcNodeParam->keysParams.maskSupport                = FALSE;
-    p_exactMatchCcNodeParam->keysParams.statisticsMode             = p_Param->statisticsMode;
-    p_exactMatchCcNodeParam->keysParams.numOfKeys                  = 0;
-    p_exactMatchCcNodeParam->keysParams.keySize                    = p_Param->matchKeySize;
-    p_exactMatchCcNodeParam->keysParams.ccNextEngineParamsForMiss  = p_Param->ccNextEngineParamsForMiss;
+    p_ExactMatchCcNodeParam->keysParams.maxNumOfKeys               = numOfWays;
+    p_ExactMatchCcNodeParam->keysParams.maskSupport                = FALSE;
+    p_ExactMatchCcNodeParam->keysParams.statisticsMode             = p_Param->statisticsMode;
+    p_ExactMatchCcNodeParam->keysParams.numOfKeys                  = 0;
+    p_ExactMatchCcNodeParam->keysParams.keySize                    = p_Param->matchKeySize;
+    p_ExactMatchCcNodeParam->keysParams.ccNextEngineParamsForMiss  = p_Param->ccNextEngineParamsForMiss;
 
-    p_HashKeyParams = p_indxHashCcNodeParam->keysParams.keyParams;
+    p_HashKeyParams = p_IndxHashCcNodeParam->keysParams.keyParams;
 
     for (i = 0; i < numOfSets; i++)
     {
-        h_CcNode = FM_PCD_MatchTableSet(h_FmPcd, p_exactMatchCcNodeParam);
+        h_CcNode = FM_PCD_MatchTableSet(h_FmPcd, p_ExactMatchCcNodeParam);
         if (!h_CcNode)
             break;
 
@@ -5474,31 +5764,30 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         for (i = i-1; i >=0; i--)
             FM_PCD_MatchTableDelete(p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode);
 
-        XX_Free(p_indxHashCcNodeParam);
-        XX_Free(p_exactMatchCcNodeParam);
-
         REPORT_ERROR(MAJOR, E_NULL_POINTER, NO_MSG);
+        XX_Free(p_IndxHashCcNodeParam);
+        XX_Free(p_ExactMatchCcNodeParam);
         return NULL;
     }
 
     /* Creating indexed-hash CC node */
-    p_indxHashCcNodeParam->extractCcParams.type                     = e_FM_PCD_EXTRACT_NON_HDR;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.src        = e_FM_PCD_EXTRACT_FROM_HASH;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.action     = e_FM_PCD_ACTION_INDEXED_LOOKUP;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.icIndxMask = p_Param->hashResMask;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.offset     = p_Param->hashShift;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.size       = 2;
+    p_IndxHashCcNodeParam->extractCcParams.type                     = e_FM_PCD_EXTRACT_NON_HDR;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.src        = e_FM_PCD_EXTRACT_FROM_HASH;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.action     = e_FM_PCD_ACTION_INDEXED_LOOKUP;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.icIndxMask = p_Param->hashResMask;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.offset     = p_Param->hashShift;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.size       = 2;
 
-    p_indxHashCcNodeParam->keysParams.maxNumOfKeys   = 0;
-    p_indxHashCcNodeParam->keysParams.maskSupport    = FALSE;
-    p_indxHashCcNodeParam->keysParams.statisticsMode = p_Param->statisticsMode;
-    p_indxHashCcNodeParam->keysParams.numOfKeys      = numOfSets;      /* Number of keys of this node is number of sets of the hash */
-    p_indxHashCcNodeParam->keysParams.keySize        = 2;
+    p_IndxHashCcNodeParam->keysParams.maxNumOfKeys   = numOfSets;
+    p_IndxHashCcNodeParam->keysParams.maskSupport    = FALSE;
+    p_IndxHashCcNodeParam->keysParams.statisticsMode = p_Param->statisticsMode;
+    p_IndxHashCcNodeParam->keysParams.numOfKeys      = numOfSets;      /* Number of keys of this node is number of sets of the hash */
+    p_IndxHashCcNodeParam->keysParams.keySize        = 2;
 
-    p_CcNodeHashTbl = FM_PCD_MatchTableSet(h_FmPcd, p_indxHashCcNodeParam);
+    p_CcNodeHashTbl = FM_PCD_MatchTableSet(h_FmPcd, p_IndxHashCcNodeParam);
 
-    XX_Free(p_indxHashCcNodeParam);
-    XX_Free(p_exactMatchCcNodeParam);
+    XX_Free(p_IndxHashCcNodeParam);
+    XX_Free(p_ExactMatchCcNodeParam);
 
     return p_CcNodeHashTbl;
 }
@@ -5519,16 +5808,15 @@ t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
 
     for (i = 0; i < numOfBuckets; i++)
-    {
         p_HashBuckets[i] = p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
-    }
 
     err = FM_PCD_MatchTableDelete(p_HashTbl);
 
     for (i = 0; i < numOfBuckets; i++)
-    {
-        err = FM_PCD_MatchTableDelete(p_HashBuckets[i]);
-    }
+        err |= FM_PCD_MatchTableDelete(p_HashBuckets[i]);
+
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -5651,6 +5939,7 @@ t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl
     return E_OK;
 }
 
+
 t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl,
                                           t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
 {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index 39f4952..b88df15 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_cc.h
 
@@ -129,7 +130,7 @@
 #define FM_PCD_CC_AD_TABLE_ALIGN            16
 #define FM_PCD_CC_AD_ENTRY_SIZE             16
 #define FM_PCD_CC_NUM_OF_KEYS               255
-#define FM_PCD_CC_TREE_ADDR_ALIGN			256
+#define FM_PCD_CC_TREE_ADDR_ALIGN           256
 
 #define FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE   0x00000000
 #define FM_PCD_AD_RESULT_DATA_FLOW_TYPE     0x80000000
@@ -138,7 +139,6 @@
 #define FM_PCD_AD_RESULT_NADEN              0x20000000
 #define FM_PCD_AD_RESULT_STATISTICS_EN      0x40000000
 
-
 #define FM_PCD_AD_CONT_LOOKUP_TYPE          0x40000000
 #define FM_PCD_AD_CONT_LOOKUP_LCL_MASK      0x00800000
 
@@ -146,6 +146,10 @@
 #define FM_PCD_AD_OPCODE_MASK               0x0000000f
 
 #define FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT 16
+#if (DPAA_VERSION >= 11)
+#define FM_PCD_AD_RESULT_VSP_SHIFT           24
+#define FM_PCD_AD_RESULT_NO_OM_VSPE          0x02000000
+#endif /* (DPAA_VERSION >= 11) */
 
 #define GLBL_MASK_FOR_HASH_INDEXED          0xfff00000
 #define CC_GLBL_MASK_SIZE                   4
@@ -238,9 +242,10 @@ typedef struct
     t_Handle    h_NodeForAdd;
     t_Handle    h_NodeForRmv;
     t_Handle    h_ManipForRmv;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
+    t_Handle    h_FrmReplicForAdd;
     t_Handle    h_FrmReplicForRmv;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     bool        tree;
 
     t_FmPcdCcKeyAndNextEngineParams  keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_KEYS];
@@ -275,6 +280,7 @@ typedef struct
 
     t_Handle    h_KeysMatchTable;
     t_Handle    h_AdTable;
+    t_Handle    h_StatsAds;
     t_Handle    h_Ad;
 
     t_List      ccPrevNodesLst;
@@ -314,8 +320,7 @@ typedef struct
     uint8_t             numOfGrps;
     t_FmPcdCcGroupParam fmPcdGroupParam[FM_PCD_MAX_NUM_OF_CC_GROUPS];
     t_List              fmPortsLst;
-    volatile bool       lock;
-    t_Handle            h_Spinlock;
+    t_FmPcdLock         *p_Lock;
     uint8_t             numOfEntries;
     uint8_t             owners;
     t_Handle            h_FmPcdCcSavedManipParams;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index bec6a83..57f8b17 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_kg.c
 
@@ -46,6 +47,7 @@
 #include "fm_pcd.h"
 #include "fm_hc.h"
 #include "fm_pcd_ipc.h"
+#include "fm_kg.h"
 
 
 /****************************************/
@@ -55,39 +57,37 @@
 static uint32_t KgHwLock(t_Handle h_FmPcdKg)
 {
     ASSERT_COND(h_FmPcdKg);
-    return XX_LockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_HwSpinlock);
+    return XX_LockIntrSpinlock(((t_FmPcdKg *)h_FmPcdKg)->h_HwSpinlock);
 }
 
 static void KgHwUnlock(t_Handle h_FmPcdKg, uint32_t intFlags)
 {
     ASSERT_COND(h_FmPcdKg);
-    XX_UnlockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_HwSpinlock, intFlags);
+    XX_UnlockIntrSpinlock(((t_FmPcdKg *)h_FmPcdKg)->h_HwSpinlock, intFlags);
 }
 
-static uint32_t KgSwLock(t_Handle h_FmPcdKg)
+static uint32_t KgSchemeLock(t_Handle h_Scheme)
 {
-    ASSERT_COND(h_FmPcdKg);
-    return XX_LockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_SwSpinlock);
+    ASSERT_COND(h_Scheme);
+    return FmPcdLockSpinlock(((t_FmPcdKgScheme *)h_Scheme)->p_Lock);
 }
 
-static void KgSwUnlock(t_Handle h_FmPcdKg, uint32_t intFlags)
+static void KgSchemeUnlock(t_Handle h_Scheme, uint32_t intFlags)
 {
-    ASSERT_COND(h_FmPcdKg);
-    XX_UnlockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_SwSpinlock, intFlags);
+    ASSERT_COND(h_Scheme);
+    FmPcdUnlockSpinlock(((t_FmPcdKgScheme *)h_Scheme)->p_Lock, intFlags);
 }
 
-static uint32_t KgSchemeLock(t_Handle h_Scheme)
+static bool KgSchemeFlagTryLock(t_Handle h_Scheme)
 {
     ASSERT_COND(h_Scheme);
-
-    return XX_LockIntrSpinlock(((t_FmPcdKgScheme*)h_Scheme)->h_Spinlock);
+    return FmPcdLockTryLock(((t_FmPcdKgScheme *)h_Scheme)->p_Lock);
 }
 
-static void KgSchemeUnlock(t_Handle h_Scheme, uint32_t intFlags)
+static void KgSchemeFlagUnlock(t_Handle h_Scheme)
 {
     ASSERT_COND(h_Scheme);
-
-    XX_UnlockIntrSpinlock(((t_FmPcdKgScheme*)h_Scheme)->h_Spinlock, intFlags);
+    FmPcdLockUnlock(((t_FmPcdKgScheme *)h_Scheme)->p_Lock);
 }
 
 static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
@@ -685,402 +685,616 @@ static uint8_t GetExtractedOrMask(uint8_t bitOffset, bool fqid)
     return mask;
 }
 
-
-t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
+static void IncSchemeOwners(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
-    t_FmPcdIpcKgClsPlanParams       kgAlloc;
-    t_Error                         err = E_OK;
-    uint32_t                        oredVectors = 0;
-    int                             i, j;
+    t_FmPcdKg           *p_FmPcdKg;
+    t_FmPcdKgScheme     *p_Scheme;
+    uint32_t            intFlags;
+    uint8_t             relativeSchemeId;
+    int                 i;
 
-    /* this routine is protected by the calling routine ! */
-    if (p_Grp->numOfOptions >= FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Too many classification plan basic options selected."));
+    p_FmPcdKg = p_FmPcd->p_FmPcdKg;
 
-    /* find a new clsPlan group */
-    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
-        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
-            break;
-    if(i== FM_MAX_NUM_OF_PORTS)
-        RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
+    /* for each scheme - update owners counters */
+    for (i = 0; i < p_BindPort->numOfSchemes; i++)
+    {
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        ASSERT_COND(relativeSchemeId < FM_PCD_KG_NUM_OF_SCHEMES);
 
-    p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
+        p_Scheme = &p_FmPcdKg->schemes[relativeSchemeId];
 
-    p_Grp->clsPlanGrpId = (uint8_t)i;
+        /* increment owners number */
+        intFlags = KgSchemeLock(p_Scheme);
+        p_Scheme->owners++;
+        KgSchemeUnlock(p_Scheme, intFlags);
+    }
+}
 
-    if(p_Grp->numOfOptions == 0)
-        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)i;
+static void DecSchemeOwners(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+{
+    t_FmPcdKg           *p_FmPcdKg;
+    t_FmPcdKgScheme     *p_Scheme;
+    uint32_t            intFlags;
+    uint8_t             relativeSchemeId;
+    int                 i;
 
-    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
-    p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
-    p_ClsPlanGrp->owners = 0;
-    FmPcdSetClsPlanGrpId(p_FmPcd, p_Grp->netEnvId, p_Grp->clsPlanGrpId);
-    FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
+    p_FmPcdKg = p_FmPcd->p_FmPcdKg;
 
-    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1<<p_Grp->numOfOptions);
-    /* a minimal group of 8 is required */
-    if(p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
-        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    /* for each scheme - update owners counters */
+    for(i = 0; i < p_BindPort->numOfSchemes; i++)
     {
-        err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        ASSERT_COND(relativeSchemeId < FM_PCD_KG_NUM_OF_SCHEMES);
 
-        if(err)
-            RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        p_Scheme = &p_FmPcdKg->schemes[relativeSchemeId];
+
+        /* increment owners number */
+        ASSERT_COND(p_Scheme->owners);
+        intFlags = KgSchemeLock(p_Scheme);
+        p_Scheme->owners--;
+        KgSchemeUnlock(p_Scheme, intFlags);
     }
-    else
-    {
-        t_FmPcdIpcMsg   msg;
-        uint32_t        replyLength;
-        t_FmPcdIpcReply reply;
+}
 
-        /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        memset(&kgAlloc, 0, sizeof(kgAlloc));
-        kgAlloc.guestId = p_FmPcd->guestId;
-        kgAlloc.numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
-        msg.msgId = FM_PCD_ALLOC_KG_CLSPLAN;
-        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
-        replyLength = (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry));
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(kgAlloc),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+static void UpateSchemePointedOwner(t_FmPcdKgScheme *p_Scheme, bool add)
+{
+    /* this routine is locked by the calling routine */
+   ASSERT_COND(p_Scheme);
+   ASSERT_COND(p_Scheme->valid);
 
-        if (replyLength != (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry)))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        if ((t_Error)reply.error != E_OK)
-            RETURN_ERROR(MINOR, (t_Error)reply.error, NO_MSG);
+    if(add)
+        p_Scheme->pointedOwners++;
+    else
+        p_Scheme->pointedOwners--;
+}
 
-        p_ClsPlanGrp->baseEntry = *(uint8_t*)(reply.replyBody);
-    }
+static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
+{
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0, tmpKgpeSp, intFlags;
+    t_Error                 err = E_OK;
 
-    /* build classification plan entries parameters */
-    p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
-    p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+    /* The calling routine had locked the port, so for each port only one core can access
+     * (so we don't need a lock here) */
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
 
-    oredVectors = 0;
-    for(i = 0; i<p_Grp->numOfOptions; i++)
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+
+    tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+    /* lock a common KG reg */
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if(err)
     {
-        oredVectors |= p_Grp->optVectors[i];
-        /* save an array of used options - the indexes represent the power of 2 index */
-        p_ClsPlanGrp->optArray[i] = p_Grp->options[i];
+        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
-    /* set the classification plan relevant entries so that all bits
-     * relevant to the list of options is cleared
-     */
-    for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
-        p_ClsPlanSet->vectors[j] = ~oredVectors;
 
-    for(i = 0; i<p_Grp->numOfOptions; i++)
-    {
-       /* option i got the place 2^i in the clsPlan array. all entries that
-         * have bit i set, should have the vector bit cleared. So each option
-         * has one location that it is exclusive (1,2,4,8...) and represent the
-         * presence of that option only, and other locations that represent a
-         * combination of options.
-         * e.g:
-         * If ethernet-BC is option 1 it gets entry 2 in the table. Entry 2
-         * now represents a frame with ethernet-BC header - so the bit
-         * representing ethernet-BC should be set and all other option bits
-         * should be cleared.
-         * Entries 2,3,6,7,10... also have ethernet-BC and therefore have bit
-         * vector[1] set, but they also have other bits set:
-         * 3=1+2, options 0 and 1
-         * 6=2+4, options 1 and 2
-         * 7=1+2+4, options 0,1,and 2
-         * 10=2+8, options 1 and 3
-         * etc.
-         * */
+    tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
 
-        /* now for each option (i), we set their bits in all entries (j)
-         * that contain bit 2^i.
-         */
-        for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
-        {
-            if(j & (1<<i))
-                p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
-        }
-    }
+    if(add)
+        tmpKgpeSp |= spReg;
+    else /* clear */
+        tmpKgpeSp &= ~spReg;
 
-    return E_OK;
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+
+    tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+    return err;
 }
 
-void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
+static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcKgClsPlanParams       kgAlloc;
-    t_Error                         err;
-    t_FmPcdIpcMsg                   msg;
-    uint32_t                        replyLength,intFlags ;
-    t_FmPcdIpcReply                 reply;
-
-    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg, intFlags;
+    t_Error                 err;
 
-    /* check that no port is bound to this clsPlan */
-    if(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
+    if (p_FmPcd->h_Hc)
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
-        return;
+        err = FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
+        return err;
     }
 
-    FmPcdSetClsPlanGrpId(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId, ILLEGAL_CLS_PLAN);
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
+    tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
-    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
+    return err;
+}
 
-    if(grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
-        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+static uint32_t BuildCppReg(t_FmPcd *p_FmPcd, uint8_t clsPlanGrpId)
+{
+    uint32_t    tmpKgpeCpp;
 
-    /* clear clsPlan driver structure */
-    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
+    tmpKgpeCpp = (uint32_t)(p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry / 8);
+    tmpKgpeCpp |= (uint32_t)(((p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp / 8) - 1) << FM_PCD_KG_PE_CPP_MASK_SHIFT);
 
-    /* free blocks */
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
-    {
-        KgFreeClsPlanEntries(h_FmPcd,
-                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
-                             p_FmPcd->guestId,
-                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+    return tmpKgpeCpp;
+}
 
-        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-    }
-    else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
-    {
-        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        kgAlloc.guestId = p_FmPcd->guestId;
-        kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
-        kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
-        msg.msgId = FM_PCD_FREE_KG_CLSPLAN;
-        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
-        replyLength = sizeof(uint32_t);
-        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                (uint8_t*)&msg,
-                                sizeof(msg.msgId) + sizeof(kgAlloc),
-                                (uint8_t*)&reply,
-                                &replyLength,
-                                NULL,
-                                NULL);
-        if (err != E_OK)
-        {
-            REPORT_ERROR(MINOR, err, NO_MSG);
-            return;
-        }
-        if (replyLength != sizeof(uint32_t))
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-            return;
-        }
-        if((t_Error)reply.error != E_OK)
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Free KG clsPlan failed"));
-            return;
-        }
-    }
+static t_Error BindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+{
+    uint32_t                tmpKgpeCpp = 0;
+
+    tmpKgpeCpp = BuildCppReg(p_FmPcd, clsPlanGrpId);
+    return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
 }
 
-t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+static void UnbindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                j, schemesPerPortVector = 0;
-    t_FmPcdKgScheme         *p_Scheme;
-    uint8_t                 i, relativeSchemeId;
-    uint32_t                tmp, walking1Mask;
-    uint8_t                 swPortIndex = 0;
+    KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+}
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+static uint32_t ReadClsPlanBlockActionReg(uint8_t grpId)
+{
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                      FM_PCD_KG_KGAR_READ |
+                      FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                      DUMMY_PORT_ID |
+                      ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                      FM_PCD_KG_KGAR_WSEL_MASK);
 
-    /* for each scheme */
-    for(i = 0; i<p_BindPort->numOfSchemes; i++)
-    {
-        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
-        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
-            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+    /* if we ever want to write 1 by 1, use:
+       sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));
+     */
+}
 
-        if(add)
-        {
-            p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
-            if (!FmPcdKgIsSchemeValidSw(p_Scheme))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
-            /* check netEnvId  of the port against the scheme netEnvId */
-            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
+static void PcdKgErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                event, force, schemeIndexes = 0,index = 0, mask = 0;
 
-            /* if next engine is private port policer profile, we need to check that it is valid */
-            HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
-            if(p_Scheme->nextRelativePlcrProfile)
-            {
-                for(j = 0;j<p_Scheme->numOfProfiles;j++)
-                {
-                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
-                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
-                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
-                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
-                }
-            }
-            if(!p_BindPort->useClsPlan)
-            {
-                /* This check may be redundant as port is a assigned to the whole NetEnv */
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
 
-                /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
-                cls plan options. Schemes that are used only directly, should not be checked.
-                it also may not be bound to schemes that go to CC with units that are options  - so we OR
-                the match vector and the grpBits (= ccUnits) */
-                if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
-                {
-                    walking1Mask = 0x80000000;
-                    tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
-                    tmp |= p_Scheme->ccUnits;
-                    while (tmp)
-                    {
-                        if(tmp & walking1Mask)
-                        {
-                            tmp &= ~walking1Mask;
-                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
-                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
-                        }
-                        walking1Mask >>= 1;
-                    }
-                }
+    schemeIndexes = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer);
+    schemeIndexes &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseeer);
+
+    event &= mask;
+
+    /* clear the forced events */
+    force = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer);
+    if(force & event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, force & ~event);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
+
+    if(event & FM_PCD_KG_DOUBLE_ECC)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
+    {
+        if(schemeIndexes)
+        {
+            while(schemeIndexes)
+            {
+                if(schemeIndexes & 0x1)
+                    p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
+                schemeIndexes >>= 1;
+                index+=1;
             }
         }
-        /* build vector */
-        schemesPerPortVector |= 1 << (31 - p_BindPort->schemesIds[i]);
+        else /* this should happen only when interrupt is forced. */
+            p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW);
     }
+}
 
-    *p_SpReg = schemesPerPortVector;
+static t_Error KgInitGuest(t_FmPcd *p_FmPcd)
+{
+    t_Error                     err = E_OK;
+    t_FmPcdIpcKgSchemesParams   kgAlloc;
+    uint32_t                    replyLength;
+    t_FmPcdIpcReply             reply;
+    t_FmPcdIpcMsg               msg;
 
-    return E_OK;
+    ASSERT_COND(p_FmPcd->guestId != NCSW_MASTER_ID);
+
+    /* in GUEST_PARTITION, we use the IPC  */
+    memset(&reply, 0, sizeof(reply));
+    memset(&msg, 0, sizeof(msg));
+    memset(&kgAlloc, 0, sizeof(t_FmPcdIpcKgSchemesParams));
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.guestId = p_FmPcd->guestId;
+    msg.msgId = FM_PCD_ALLOC_KG_SCHEMES;
+    memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
+    replyLength = sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t);
+    if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                 (uint8_t*)&msg,
+                                 sizeof(msg.msgId) + sizeof(kgAlloc),
+                                 (uint8_t*)&reply,
+                                 &replyLength,
+                                 NULL,
+                                 NULL)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if(replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+    memcpy(p_FmPcd->p_FmPcdKg->schemesIds, (uint8_t*)(reply.replyBody),p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t));
+
+    return (t_Error)reply.error;
 }
 
-void FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                 i;
-    t_FmPcdKgScheme     *p_Scheme;
-    uint32_t            intFlags;
+    t_Error                     err = E_OK;
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+    int                         i;
+    uint8_t                     hardwarePortId = 0;
+    uint32_t                    tmpReg;
 
-    /* for each scheme - update owners counters */
-    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+
+    /**********************KGEER******************/
+    WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
+    /**********************KGEER******************/
+
+    /**********************KGEEER******************/
+    tmpReg = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
     {
-        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+        tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+    WRITE_UINT32(p_Regs->kgeeer,tmpReg);
+    /**********************KGEEER******************/
 
-        /* increment owners number */
-        intFlags = KgSchemeLock(p_Scheme);
-        p_Scheme->owners++;
-        KgSchemeUnlock(p_Scheme, intFlags);
+    /**********************KGFDOR******************/
+    WRITE_UINT32(p_Regs->kgfdor,0);
+    /**********************KGFDOR******************/
+
+    /**********************KGGDV0R******************/
+    WRITE_UINT32(p_Regs->kggdv0r,0);
+    /**********************KGGDV0R******************/
+
+    /**********************KGGDV1R******************/
+    WRITE_UINT32(p_Regs->kggdv1r,0);
+    /**********************KGGDV1R******************/
+
+    /**********************KGGCR******************/
+    WRITE_UINT32(p_Regs->kggcr, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd));
+    /**********************KGGCR******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR, PcdKgErrorException, p_FmPcd);
+
+    /* clear binding between ports to schemes so that all ports are not bound to any schemes */
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    {
+        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
+
+        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
     }
+
+    /* enable and enable all scheme interrupts */
+    WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
+    WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
+
+
+    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
+    {
+        err = FmPcdKgAllocSchemes(p_FmPcd,
+                                  p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                  p_FmPcd->guestId,
+                                  p_FmPcd->p_FmPcdKg->schemesIds);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    return E_OK;
 }
 
-void FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+static void  ValidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                 i;
-    t_FmPcdKgScheme     *p_Scheme;
-    uint32_t            intFlags;
+    ASSERT_COND(!p_Scheme->valid);
+    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+        FmPcdIncNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
+    p_Scheme->valid = TRUE;
+}
 
-    /* for each scheme - update owners counters */
-    for(i = 0; i<p_BindPort->numOfSchemes; i++)
-    {
-        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+static t_Error  InvalidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
+{
+    if (p_Scheme->owners)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
 
-        /* increment owners number */
-        ASSERT_COND(p_Scheme->owners);
-        intFlags = KgSchemeLock(p_Scheme);
-        p_Scheme->owners--;
-        KgSchemeUnlock(p_Scheme, intFlags);
-    }
+    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+        FmPcdDecNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
+    p_Scheme->valid = FALSE;
+
+    return E_OK;
 }
 
-static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
+
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
 {
-    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg = 0, tmpKgpeSp, intFlags;
-    t_Error                 err = E_OK;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
+    t_Error                         err = E_OK;
+    uint32_t                        oredVectors = 0;
+    int                             i, j;
 
-    /* The calling routine had locked the port, so for each port only one core can access
-     * (so we don't need a lock here) */
-    if (p_FmPcd->h_Hc)
-        return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
+    /* this routine is protected by the calling routine ! */
+    if (p_Grp->numOfOptions >= FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Too many classification plan basic options selected."));
 
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    /* find a new clsPlan group */
+    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
+        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
+            break;
+    if (i == FM_MAX_NUM_OF_PORTS)
+        RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
 
-    tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
-    /* lock a common KG reg */
-    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    if(err)
+    p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
+
+    p_Grp->clsPlanGrpId = (uint8_t)i;
+
+    if (p_Grp->numOfOptions == 0)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)i;
+
+    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
+    p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
+    p_ClsPlanGrp->owners = 0;
+    FmPcdSetClsPlanGrpId(p_FmPcd, p_Grp->netEnvId, p_Grp->clsPlanGrpId);
+    FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
+
+    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1 << p_Grp->numOfOptions);
+    /* a minimal group of 8 is required */
+    if (p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
+        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
     {
-        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
+
+        if(err)
+            RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
     }
+    else
+    {
+        t_FmPcdIpcMsg   msg;
+        uint32_t        replyLength;
+        t_FmPcdIpcReply reply;
 
-    tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
+        /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        memset(&kgAlloc, 0, sizeof(kgAlloc));
+        kgAlloc.guestId = p_FmPcd->guestId;
+        kgAlloc.numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+        msg.msgId = FM_PCD_ALLOC_KG_CLSPLAN;
+        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
+        replyLength = (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry));
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(kgAlloc),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    if(add)
-        tmpKgpeSp |= spReg;
-    else /* clear */
-        tmpKgpeSp &= ~spReg;
+        if (replyLength != (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        if ((t_Error)reply.error != E_OK)
+            RETURN_ERROR(MINOR, (t_Error)reply.error, NO_MSG);
 
-    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+        p_ClsPlanGrp->baseEntry = *(uint8_t*)(reply.replyBody);
+    }
 
-    tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+    /* build classification plan entries parameters */
+    p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
+    p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
 
-    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-    return err;
+    oredVectors = 0;
+    for(i = 0; i<p_Grp->numOfOptions; i++)
+    {
+        oredVectors |= p_Grp->optVectors[i];
+        /* save an array of used options - the indexes represent the power of 2 index */
+        p_ClsPlanGrp->optArray[i] = p_Grp->options[i];
+    }
+    /* set the classification plan relevant entries so that all bits
+     * relevant to the list of options is cleared
+     */
+    for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        p_ClsPlanSet->vectors[j] = ~oredVectors;
+
+    for(i = 0; i<p_Grp->numOfOptions; i++)
+    {
+       /* option i got the place 2^i in the clsPlan array. all entries that
+         * have bit i set, should have the vector bit cleared. So each option
+         * has one location that it is exclusive (1,2,4,8...) and represent the
+         * presence of that option only, and other locations that represent a
+         * combination of options.
+         * e.g:
+         * If ethernet-BC is option 1 it gets entry 2 in the table. Entry 2
+         * now represents a frame with ethernet-BC header - so the bit
+         * representing ethernet-BC should be set and all other option bits
+         * should be cleared.
+         * Entries 2,3,6,7,10... also have ethernet-BC and therefore have bit
+         * vector[1] set, but they also have other bits set:
+         * 3=1+2, options 0 and 1
+         * 6=2+4, options 1 and 2
+         * 7=1+2+4, options 0,1,and 2
+         * 10=2+8, options 1 and 3
+         * etc.
+         * */
+
+        /* now for each option (i), we set their bits in all entries (j)
+         * that contain bit 2^i.
+         */
+        for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        {
+            if(j & (1<<i))
+                p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
+        }
+    }
+
+    return E_OK;
 }
 
-static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
+void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
 {
-    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg, intFlags;
-    t_Error                 err;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
+    t_Error                         err;
+    t_FmPcdIpcMsg                   msg;
+    uint32_t                        replyLength;
+    t_FmPcdIpcReply                 reply;
+
+    /* check that no port is bound to this clsPlan */
+    if (p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
+        return;
+    }
+
+    FmPcdSetClsPlanGrpId(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId, ILLEGAL_CLS_PLAN);
+
+    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
+
+    if (grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+
+    /* clear clsPlan driver structure */
+    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
+
+    /* free blocks */
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        KgFreeClsPlanEntries(h_FmPcd,
+                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
+                             p_FmPcd->guestId,
+                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+    }
+    else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+    {
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        kgAlloc.guestId = p_FmPcd->guestId;
+        kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
+        kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
+        msg.msgId = FM_PCD_FREE_KG_CLSPLAN;
+        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
+        replyLength = sizeof(uint32_t);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(kgAlloc),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+        {
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            return;
+        }
+        if (replyLength != sizeof(uint32_t))
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            return;
+        }
+        if((t_Error)reply.error != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Free KG clsPlan failed"));
+            return;
+        }
+    }
+}
+
+t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                j, schemesPerPortVector = 0;
+    t_FmPcdKgScheme         *p_Scheme;
+    uint8_t                 i, relativeSchemeId;
+    uint32_t                tmp, walking1Mask;
+    uint8_t                 swPortIndex = 0;
 
-    if (p_FmPcd->h_Hc)
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    /* for each scheme */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
     {
-        err = FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
-        return err;
-    }
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
-    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
-    tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
-    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+        if(add)
+        {
+            p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+            if (!FmPcdKgIsSchemeValidSw(p_Scheme))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
+            /* check netEnvId  of the port against the scheme netEnvId */
+            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
 
-    return err;
-}
+            /* if next engine is private port policer profile, we need to check that it is valid */
+            HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
+            if(p_Scheme->nextRelativePlcrProfile)
+            {
+                for(j = 0;j<p_Scheme->numOfProfiles;j++)
+                {
+                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
+                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
+                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
+                }
+            }
+            if(!p_BindPort->useClsPlan)
+            {
+                /* This check may be redundant as port is a assigned to the whole NetEnv */
 
-static void FmPcdKgUnbindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
-{
-    KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-}
+                /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
+                cls plan options. Schemes that are used only directly, should not be checked.
+                it also may not be bound to schemes that go to CC with units that are options  - so we OR
+                the match vector and the grpBits (= ccUnits) */
+                if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
+                {
+                    walking1Mask = 0x80000000;
+                    tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
+                    tmp |= p_Scheme->ccUnits;
+                    while (tmp)
+                    {
+                        if(tmp & walking1Mask)
+                        {
+                            tmp &= ~walking1Mask;
+                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
+                        }
+                        walking1Mask >>= 1;
+                    }
+                }
+            }
+        }
+        /* build vector */
+        schemesPerPortVector |= 1 << (31 - p_BindPort->schemesIds[i]);
+    }
 
-static t_Error KgBindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
-{
-    uint32_t                tmpKgpeCpp = 0;
+    *p_SpReg = schemesPerPortVector;
 
-    tmpKgpeCpp = FmPcdKgBuildCppReg(p_FmPcd, clsPlanGrpId);
-    return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
+    return E_OK;
 }
 
-
-/*****************************************************************************/
-/*              Inter-module API routines                                    */
-/*****************************************************************************/
 t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1095,18 +1309,18 @@ t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPort
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    FmPcdKgIncSchemeOwners(h_FmPcd, p_SchemeBind);
+    IncSchemeOwners(p_FmPcd, p_SchemeBind);
 
     return E_OK;
 }
 
-t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                spReg;
     t_Error                 err = E_OK;
 
-    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, FALSE);
+    err = FmPcdKgBuildBindPortToSchemes(p_FmPcd, p_SchemeBind, &spReg, FALSE);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1114,40 +1328,40 @@ t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindP
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    FmPcdKgDecSchemeOwners(h_FmPcd, p_SchemeBind);
+    DecSchemeOwners(p_FmPcd, p_SchemeBind);
 
     return E_OK;
 }
 
-bool     FmPcdKgIsSchemeValidSw(t_Handle h_Scheme)
+bool FmPcdKgIsSchemeValidSw(t_Handle h_Scheme)
 {
     t_FmPcdKgScheme     *p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
 
     return p_Scheme->valid;
 }
 
-bool     KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
+bool KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
     if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
         return TRUE;
-    else{
-	XX_Print("\n\n p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector = 0x%X \n", p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector);
-	XX_Print(" schemeId = %u \n\n", schemeId);
-	dump_stack();
-        return FALSE;}
+    else
+        return FALSE;
 }
 
 t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint8_t             i,j;
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint8_t             i, j;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    for(j=0,i=0;i<FM_PCD_KG_NUM_OF_SCHEMES && j<numOfSchemes;i++)
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
+
+    for (j = 0, i = 0; i < FM_PCD_KG_NUM_OF_SCHEMES && j < numOfSchemes; i++)
     {
         if(!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
         {
@@ -1167,6 +1381,7 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
             p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].ownerId = 0;
             p_SchemesIds[j] = 0;
         }
+
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("No schemes found"));
     }
 
@@ -1175,18 +1390,25 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
 
 t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint8_t             i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    for(i=0;i<numOfSchemes;i++)
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC */
+
+    for (i = 0; i < numOfSchemes; i++)
     {
         if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
+        {
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
+        }
         if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
+        {
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
+        }
         p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
         p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
     }
@@ -1196,12 +1418,12 @@ t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gues
 
 t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t *p_First)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint8_t     numOfBlocks, blocksFound=0, first=0;
     uint8_t     i, j;
 
-
-    /* This routine is protected by the calling routine ! */
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
 
     if(!numOfClsPlanEntries)
         return E_OK;
@@ -1213,257 +1435,109 @@ t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, u
 
     /* try to find consequent blocks */
     first = 0;
-    for(i=0;i<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
+    for (i = 0; i < FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
     {
         if(!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
         {
             blocksFound++;
-            i++;
-            if(blocksFound == numOfBlocks)
-                break;
-        }
-        else
-        {
-            blocksFound = 0;
-            /* advance i to the next aligned address */
-            first = i = (uint8_t)(first + numOfBlocks);
-        }
-    }
-
-    if(blocksFound == numOfBlocks)
-    {
-        *p_First = (uint8_t)(first*CLS_PLAN_NUM_PER_GRP);
-        for(j = first; j<first + numOfBlocks; j++)
-        {
-            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
-            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = guestId;
-        }
-
-        return E_OK;
-    }
-    else
-        RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
-}
-
-void  KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t base)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint8_t     numOfBlocks;
-    uint8_t     i, baseBlock;
-
-    UNUSED( guestId);
-
-    /* This routine is protected by the calling routine ! */
-
-    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
-    ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
-
-    baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
-    for(i=baseBlock;i<baseBlock+numOfBlocks;i++)
-    {
-        ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
-        ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
-        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
-        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
-    }
-}
-
-void KgEnable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
-}
-
-void KgDisable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
-}
-
-void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg=0;
-    uint16_t                i, j;
-
-    /* This routine is protected by the calling routine ! */
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
-
-    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
-    {
-        tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
-
-        for (j = i; j < i+8; j++)
-        {
-            ASSERT_COND(IN_RANGE(0, (j - p_Set->baseEntry), FM_PCD_MAX_NUM_OF_CLS_PLANS-1));
-            WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
-        }
-
-        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("WriteKgarWait FAILED"));
-            return;
-        }
-    }
-}
-
-static void PcdKgErrorException(t_Handle h_FmPcd)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t                event, force, schemeIndexes = 0,index = 0, mask = 0;
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
-    mask = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
-
-    schemeIndexes = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer);
-    schemeIndexes &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseeer);
-
-    event &= mask;
-
-    /* clear the forced events */
-    force = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer);
-    if(force & event)
-        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, force & ~event);
-
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
-
-    if(event & FM_PCD_KG_DOUBLE_ECC)
-        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
-    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
-    {
-        if(schemeIndexes)
-        {
-            while(schemeIndexes)
-            {
-                if(schemeIndexes & 0x1)
-                    p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
-                schemeIndexes >>= 1;
-                index+=1;
-            }
-        }
-        else /* this should happen only when interrupt is forced. */
-            p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW);
-    }
-}
-
-static t_Error KgInitGuest(t_FmPcd *p_FmPcd)
-{
-    t_Error                     err = E_OK;
-    t_FmPcdIpcKgSchemesParams   kgAlloc;
-    uint32_t                    replyLength;
-    t_FmPcdIpcReply             reply;
-    t_FmPcdIpcMsg               msg;
-
-    ASSERT_COND(p_FmPcd->guestId != NCSW_MASTER_ID);
-
-    /* in GUEST_PARTITION, we use the IPC  */
-    memset(&reply, 0, sizeof(reply));
-    memset(&msg, 0, sizeof(msg));
-    memset(&kgAlloc, 0, sizeof(t_FmPcdIpcKgSchemesParams));
-    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
-    kgAlloc.guestId = p_FmPcd->guestId;
-    msg.msgId = FM_PCD_ALLOC_KG_SCHEMES;
-    memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
-    replyLength = sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t);
-    if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId) + sizeof(kgAlloc),
-                                 (uint8_t*)&reply,
-                                 &replyLength,
-                                 NULL,
-                                 NULL)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    if(replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-    memcpy(p_FmPcd->p_FmPcdKg->schemesIds, (uint8_t*)(reply.replyBody),p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t));
+            i++;
+            if (blocksFound == numOfBlocks)
+                break;
+        }
+        else
+        {
+            blocksFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfBlocks);
+        }
+    }
 
-    return (t_Error)reply.error;
+    if (blocksFound == numOfBlocks)
+    {
+        *p_First = (uint8_t)(first * CLS_PLAN_NUM_PER_GRP);
+        for (j = first; j < (first + numOfBlocks); j++)
+        {
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = guestId;
+        }
+        return E_OK;
+    }
+    else
+        RETURN_ERROR(MINOR, E_FULL, ("No resources for clsPlan"));
 }
 
-static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
+void KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t base)
 {
-    t_Error                     err = E_OK;
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-    int                         i;
-    uint8_t                     hardwarePortId = 0;
-    uint32_t                    tmpReg;
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     numOfBlocks;
+    uint8_t     i, baseBlock;
 
-    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+#ifdef DISABLE_ASSERTIONS
+UNUSED(guestId);
+#endif /* DISABLE_ASSERTIONS */
 
-    /**********************KGEER******************/
-    WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
-    /**********************KGEER******************/
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
 
-    /**********************KGEEER******************/
-    tmpReg = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+    ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
+
+    baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
+    for(i=baseBlock;i<baseBlock+numOfBlocks;i++)
     {
-        FmEnableRamsEcc(p_FmPcd->h_Fm);
-        tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+        ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
+        ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
     }
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
-        tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
-    WRITE_UINT32(p_Regs->kgeeer,tmpReg);
-    /**********************KGEEER******************/
-
-    /**********************KGFDOR******************/
-    WRITE_UINT32(p_Regs->kgfdor,0);
-    /**********************KGFDOR******************/
-
-    /**********************KGGDV0R******************/
-    WRITE_UINT32(p_Regs->kggdv0r,0);
-    /**********************KGGDV0R******************/
+}
 
-    /**********************KGGDV1R******************/
-    WRITE_UINT32(p_Regs->kggdv1r,0);
-    /**********************KGGDV1R******************/
+void KgEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    /**********************KGGCR******************/
-    WRITE_UINT32(p_Regs->kggcr, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd));
-    /**********************KGGCR******************/
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
+}
 
-    /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR, PcdKgErrorException, p_FmPcd);
+void KgDisable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    /* clear binding between ports to schemes so that all ports are not bound to any schemes */
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-    {
-        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
+}
 
-        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0, intFlags;
+    uint16_t                i, j;
 
-        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    /* This routine is protected by the calling routine ! */
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
 
-    /* enable and enable all scheme interrupts */
-    WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
-    WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    {
+        tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
 
+        for (j = i; j < i+8; j++)
+        {
+            ASSERT_COND(IN_RANGE(0, (j - p_Set->baseEntry), FM_PCD_MAX_NUM_OF_CLS_PLANS-1));
+            WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
+        }
 
-    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
-    {
-        err = FmPcdKgAllocSchemes(p_FmPcd,
-                                  p_FmPcd->p_FmPcdKg->numOfSchemes,
-                                  p_FmPcd->guestId,
-                                  p_FmPcd->p_FmPcdKg->schemesIds);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("WriteKgarWait FAILED"));
+            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+            return;
+        }
     }
-
-    return E_OK;
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 }
 
 t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
@@ -1513,11 +1587,6 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     if (!p_FmPcd->p_FmPcdKg->h_HwSpinlock)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM KG HW spinlock"));
 
-    p_FmPcd->p_FmPcdKg->h_SwSpinlock = XX_InitSpinlock();
-    if (!p_FmPcd->p_FmPcdKg->h_SwSpinlock)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM KG SW spinlock"));
-
-
     if (p_FmPcd->guestId == NCSW_MASTER_ID)
         err =  KgInitMaster(p_FmPcd);
     else
@@ -1527,8 +1596,6 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     {
         if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
             XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
-        if (p_FmPcd->p_FmPcdKg->h_SwSpinlock)
-            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_SwSpinlock);
     }
 
     return err;
@@ -1555,9 +1622,6 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
 
         if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
             XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
-        if (p_FmPcd->p_FmPcdKg->h_SwSpinlock)
-            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_SwSpinlock);
-
 
         return E_OK;
     }
@@ -1585,8 +1649,6 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
 
     if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
         XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
-    if (p_FmPcd->p_FmPcdKg->h_SwSpinlock)
-        XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_SwSpinlock);
 
     return (t_Error)reply.error;
 }
@@ -1598,7 +1660,9 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     t_FmPcdKgClsPlanGrp                     *p_ClsPlanGrp;
     t_FmPcdKgInterModuleClsPlanSet          *p_ClsPlanSet;
     t_Error                                 err;
-    uint32_t                                intFlags;
+
+    /* This function is issued only from FM_PORT_SetPcd which locked all PCD modules,
+       so no need for lock here */
 
     memset(&grpParams, 0, sizeof(grpParams));
     grpParams.clsPlanGrpId = ILLEGAL_CLS_PLAN;
@@ -1606,8 +1670,6 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
 
     p_GrpParams->netEnvId = netEnvId;
 
-    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
-
     /* Get from the NetEnv the information of the clsPlan (can be already created,
      * or needs to build) */
     err = PcdGetClsPlanGrpParams(h_FmPcd, p_GrpParams);
@@ -1617,7 +1679,6 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     if(p_GrpParams->grpExists)
     {
         /* this group was already updated (at least) in SW */
-        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
     }
     else
@@ -1628,7 +1689,6 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
         memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
         /* Build (in SW) the clsPlan parameters, including the vectors to be written to HW */
         err = FmPcdKgBuildClsPlanGrp(h_FmPcd, p_GrpParams, p_ClsPlanSet);
-        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         if (err)
         {
             XX_Free(p_ClsPlanSet);
@@ -1636,15 +1696,12 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
         }
         *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
 
-        intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-
         if (p_FmPcd->h_Hc)
         {
             /* write clsPlan entries to memory */
             err = FmHcPcdKgSetClsPlan(p_FmPcd->h_Hc, p_ClsPlanSet);
             if (err)
             {
-                KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                 XX_Free(p_ClsPlanSet);
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
@@ -1653,8 +1710,6 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
             /* write clsPlan entries to memory */
             KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
 
-        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-
         XX_Free(p_ClsPlanSet);
     }
 
@@ -1668,18 +1723,14 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
 
     p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId];
 
-
-    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
    /* increment owners number */
     p_ClsPlanGrp->owners++;
-    KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-
 
     /* copy options array for port */
     memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId].optArray, FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)*sizeof(protocolOpt_t));
 
     /* bind port to the new or existing group */
-    err = KgBindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
+    err = BindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
     if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
@@ -1691,26 +1742,22 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
     t_FmPcdKgInterModuleClsPlanSet  *p_ClsPlanSet;
-    uint32_t                        intFlags;
     t_Error                         err;
 
-    FmPcdKgUnbindPortToClsPlanGrp(p_FmPcd, hardwarePortId);
+    /* This function is issued only from FM_PORT_DeletePcd which locked all PCD modules,
+       so no need for lock here */
+
+    UnbindPortToClsPlanGrp(p_FmPcd, hardwarePortId);
 
-    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
     /* decrement owners number */
     ASSERT_COND(p_ClsPlanGrp->owners);
     p_ClsPlanGrp->owners--;
-    KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-
 
-    if(!p_ClsPlanGrp->owners)
+    if (!p_ClsPlanGrp->owners)
     {
-        intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-
         if (p_FmPcd->h_Hc)
         {
             err = FmHcPcdKgDeleteClsPlan(p_FmPcd->h_Hc, clsPlanGrpId);
-            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
             return err;
         }
         else
@@ -1719,7 +1766,6 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
             p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
             if (!p_ClsPlanSet)
             {
-                KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
             }
             memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
@@ -1727,10 +1773,8 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
             p_ClsPlanSet->baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry;
             p_ClsPlanSet->numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp;
             KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
-            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
             XX_Free(p_ClsPlanSet);
 
-            /* protection for this routine is inside it */
             FmPcdKgDestroyClsPlanGrp(h_FmPcd, clsPlanGrpId);
        }
     }
@@ -1739,7 +1783,7 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
 
 t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs)
 {
-	t_FmPcdKgScheme 					*p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
+    t_FmPcdKgScheme                     *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
     t_FmPcd                             *p_FmPcd = (t_FmPcd *)(p_Scheme->h_FmPcd);
     uint32_t                            grpBits = 0;
     uint8_t                             grpBase;
@@ -1984,7 +2028,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemePa
 
     p_SchemeRegs->kgse_mv = p_Scheme->matchVector;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if (p_SchemeParams->overrideStorageProfile)
     {
         p_SchemeRegs->kgse_om |= KG_SCH_OM_VSPE;
@@ -2020,7 +2064,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemePa
     }
     else
         p_SchemeRegs->kgse_vsp = KG_SCH_VSP_NO_KSP_EN;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     if(p_SchemeParams->useHash)
     {
@@ -2542,31 +2586,6 @@ t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemePa
     return E_OK;
 }
 
-static void  FmPcdKgValidateSchemeSw(t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
-    uint32_t        intFlags;
-
-    ASSERT_COND(!p_Scheme->valid);
-    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
-        FmPcdIncNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
-    intFlags = KgSchemeLock(p_Scheme);
-    p_Scheme->valid = TRUE;
-    KgSchemeUnlock(p_Scheme, intFlags);
-}
-
-static void  FmPcdKgInvalidateSchemeSw(t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
-    uint32_t        intFlags;
-
-    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
-        FmPcdDecNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
-    intFlags = KgSchemeLock(p_Scheme);
-    p_Scheme->valid = FALSE;
-    KgSchemeUnlock(p_Scheme, intFlags);
-}
-
 uint32_t FmPcdKgGetRequiredAction(t_Handle h_FmPcd, uint8_t schemeId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -2603,7 +2622,6 @@ uint16_t FmPcdKgGetRelativeProfileId(t_Handle h_FmPcd, uint8_t schemeId)
     return p_FmPcd->p_FmPcdKg->schemes[schemeId].relativeProfileId;
 }
 
-
 bool FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -2618,18 +2636,6 @@ bool FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId)
         return FALSE;
 
 }
-void FmPcdKgUpatePointedOwner(t_Handle h_Scheme, bool add)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
-
-    /* this routine is locked by the calling routine */
-   ASSERT_COND(p_Scheme->valid);
-
-    if(add)
-        p_Scheme->pointedOwners++;
-    else
-        p_Scheme->pointedOwners--;
-}
 
 e_FmPcdEngine FmPcdKgGetNextEngine(t_Handle h_FmPcd, uint8_t relativeSchemeId)
 {
@@ -2653,40 +2659,13 @@ void FmPcdKgUpdateRequiredAction(t_Handle h_Scheme, uint32_t requiredAction)
 {
     t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-	/* this routine is protected by calling routine */
+    /* this routine is protected by calling routine */
 
     ASSERT_COND(p_Scheme->valid);
 
     p_Scheme->requiredAction |= requiredAction;
 }
 
-t_Error FmPcdKgCheckInvalidateSchemeSw(t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
-    uint32_t        intFlags;
-
-    intFlags = KgSchemeLock(p_Scheme);
-   /* check that no port is bound to this scheme */
-    if (p_Scheme->owners)
-       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
-    if (!p_Scheme->valid){dump_stack();
-       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete an invalid scheme"));
-    }
-    KgSchemeUnlock(p_Scheme, intFlags);
-
-    return E_OK;
-}
-
-uint32_t FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t    tmpKgpeCpp;
-
-    tmpKgpeCpp = (uint32_t)(p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry / 8);
-    tmpKgpeCpp |= (uint32_t)(((p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp / 8) - 1) << FM_PCD_KG_PE_CPP_MASK_SHIFT);
-    return tmpKgpeCpp;
-}
-
 bool FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg)
 {
     return (bool)!!(schemeModeReg & KG_SCH_MODE_EN);
@@ -2727,21 +2706,6 @@ uint32_t FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId)
      */
 }
 
-uint32_t FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId)
-{
-    return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                      FM_PCD_KG_KGAR_READ |
-                      FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
-                      DUMMY_PORT_ID |
-                      ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
-                      FM_PCD_KG_KGAR_WSEL_MASK);
-
-
-    /* if we ever want to write 1 by 1, use:
-       sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));
-     */
-}
-
 uint32_t FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId)
 {
 
@@ -2786,31 +2750,20 @@ uint16_t FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp)
     return p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrp].sizeOfGrp;
 }
 
-uint8_t FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint8_t     i;
-
-    for(i=0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
-        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeHwId)
-            return i;
-    ASSERT_COND(i!=p_FmPcd->p_FmPcdKg->numOfSchemes);
-    return FM_PCD_KG_NUM_OF_SCHEMES;
-}
 
-uint8_t	FmPcdKgGetSchemeId(t_Handle h_Scheme)
+uint8_t FmPcdKgGetSchemeId(t_Handle h_Scheme)
 {
     return ((t_FmPcdKgScheme*)h_Scheme)->schemeId;
 
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 bool FmPcdKgGetVspe(t_Handle h_Scheme)
 {
     return ((t_FmPcdKgScheme*)h_Scheme)->vspe;
 
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
 {
@@ -2833,28 +2786,23 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
     uint8_t             relativeSchemeId, physicalSchemeId;
     uint32_t            tmpKgarReg, tmpReg32 = 0, intFlags;
     t_Error             err;
-    t_FmPcdKgScheme		*p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
+    t_FmPcdKgScheme     *p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
 
-    /* if (FmPcdKgSchemeTryLock(p_FmPcd, &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]))
-        RETURN_ERROR(MAJOR, E_BUSY, ("Lock of the scheme FAILED")); */
+    /* Calling function locked all PCD modules, so no need to lock here */
+
     if (!FmPcdKgIsSchemeValidSw(h_Scheme))
         RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
 
-    intFlags = KgSchemeLock(h_Scheme);
-
     if (p_FmPcd->h_Hc)
     {
         err = FmHcPcdKgCcGetSetParams(p_FmPcd->h_Hc, h_Scheme, requiredAction, value);
 
-        FmPcdKgUpatePointedOwner(h_Scheme,TRUE);
+        UpateSchemePointedOwner(h_Scheme,TRUE);
         FmPcdKgUpdateRequiredAction(h_Scheme,requiredAction);
-
-        KgSchemeUnlock(h_Scheme, intFlags);
-        /* FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]); */
         return err;
     }
 
@@ -2867,7 +2815,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
     if (!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners ||
         !(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction & requiredAction))
     {
-        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        if (requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
             switch(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine)
             {
@@ -2892,15 +2840,11 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile) ||
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile)
                         {
-                            KgSchemeUnlock(h_Scheme, intFlags);
-                            /*FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]);*/
                             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
                         }
                         err = FmPcdPlcrCcGetSetParams(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId, requiredAction);
                         if(err)
                         {
-                            KgSchemeUnlock(h_Scheme, intFlags);
-                            /*FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]);*/
                             RETURN_ERROR(MAJOR, err, NO_MSG);
                         }
                break;
@@ -2952,31 +2896,14 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
         }
     }
 
-    FmPcdKgUpatePointedOwner(h_Scheme, TRUE);
+    UpateSchemePointedOwner(h_Scheme, TRUE);
     FmPcdKgUpdateRequiredAction(h_Scheme, requiredAction);
 
-    /* FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]); */
-    KgSchemeUnlock(h_Scheme, intFlags);
-
     return E_OK;
 }
-/*
-t_Error FmPcdKgSchemeTryLock(t_Handle h_FmPcd, t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-    if (TRY_LOCK(((t_FmPcd *)h_FmPcd)->p_FmPcdKg->h_SwSpinlock, &p_Scheme->lock))
-        return E_OK;
-    return ERROR_CODE(E_BUSY);
-}
 
-void FmPcdKgReleaseSchemeLock(t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-    RELEASE_LOCK(p_Scheme->lock);
-}
-*/
 /*********************** End of inter-module routines ************************/
 
 
@@ -2993,22 +2920,38 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     uint32_t                            tmpKgarReg;
     uint32_t                            intFlags;
     uint8_t                             physicalSchemeId, relativeSchemeId = 0;
-    t_FmPcdKgScheme						*p_Scheme;
+    t_FmPcdKgScheme                     *p_Scheme;
 
-    if(p_SchemeParams->modify)
+    if (p_SchemeParams->modify)
     {
-	p_Scheme = (t_FmPcdKgScheme *)p_SchemeParams->id.h_Scheme;
-	p_FmPcd = p_Scheme->h_FmPcd;
+        p_Scheme = (t_FmPcdKgScheme *)p_SchemeParams->id.h_Scheme;
+        p_FmPcd = p_Scheme->h_FmPcd;
 
-	SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+        SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
         SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+
+        if (!FmPcdKgIsSchemeValidSw(p_Scheme))
+        {
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
+                         ("Scheme is invalid"));
+            return NULL;
+        }
+
+        if (!KgSchemeFlagTryLock(p_Scheme))
+        {
+		DBG(TRACE, ("Scheme Try Lock - BUSY"));
+            /* Signal to caller BUSY condition */
+            p_SchemeParams->id.h_Scheme = NULL;
+            return NULL;
+        }
     }
     else
     {
-	p_FmPcd = (t_FmPcd*)h_FmPcd;
+        p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-	SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+        SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
         SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+
         relativeSchemeId = p_SchemeParams->id.relativeSchemeId;
         /* check that schemeId is in range */
         if(relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
@@ -3021,49 +2964,46 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
         if(FmPcdKgIsSchemeValidSw(p_Scheme))
         {
             REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
-                         ("Scheme %d is already used", relativeSchemeId));
+                         ("Scheme is already used"));
             return NULL;
         }
 
-	p_Scheme->schemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
-	p_Scheme->h_FmPcd = p_FmPcd;
-    }
-
-/*
-    err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
-    if (err)
-        return NULL;
-*/
+        p_Scheme->schemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
+        p_Scheme->h_FmPcd = p_FmPcd;
 
-    p_Scheme->h_Spinlock = XX_InitSpinlock();
-    if (!p_Scheme->h_Spinlock)
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM KG Scheme spinlock"));
+        p_Scheme->p_Lock = FmPcdAcquireLock(p_FmPcd);
+        if (!p_Scheme->p_Lock)
+            REPORT_ERROR(MAJOR, E_NOT_AVAILABLE, ("FM KG Scheme lock obj!"));
+    }
 
     if (p_FmPcd->h_Hc)
     {
         err = FmHcPcdKgSetScheme(p_FmPcd->h_Hc, (t_Handle)p_Scheme, p_SchemeParams);
-        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
+        if(p_SchemeParams->modify)
+            KgSchemeFlagUnlock(p_Scheme);
         if (err)
         {
-          if (p_Scheme->h_Spinlock)
-              XX_FreeSpinlock(p_Scheme->h_Spinlock);
-          return NULL;
+            if (!p_SchemeParams->modify &&
+                p_Scheme->p_Lock)
+                FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
+            return NULL;
         }
-		if (!p_SchemeParams->modify)
-			FmPcdKgValidateSchemeSw(p_Scheme);
+        if (!p_SchemeParams->modify)
+            ValidateSchemeSw(p_Scheme);
         return (t_Handle)p_Scheme;
     }
 
     physicalSchemeId = p_Scheme->schemeId;
 
-
     err = FmPcdKgBuildScheme((t_Handle)p_Scheme, p_SchemeParams, &schemeRegs);
-    if(err)
+    if (err)
     {
         REPORT_ERROR(MAJOR, err, NO_MSG);
-        /*FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]);*/
-        if (p_Scheme->h_Spinlock)
-            XX_FreeSpinlock(p_Scheme->h_Spinlock);
+        if(p_SchemeParams->modify)
+            KgSchemeFlagUnlock(p_Scheme);
+        if (!p_SchemeParams->modify &&
+            p_Scheme->p_Lock)
+            FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
         return NULL;
     }
 
@@ -3095,16 +3035,16 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
     if (!p_SchemeParams->modify)
-		FmPcdKgValidateSchemeSw(p_Scheme);
-
-    /* FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]); */
+        ValidateSchemeSw(p_Scheme);
+    else
+        KgSchemeFlagUnlock(p_Scheme);
 
     return (t_Handle)p_Scheme;
 }
 
 t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)(((t_FmPcdKgScheme *)h_Scheme)->h_FmPcd);
+    t_FmPcd             *p_FmPcd;
     uint8_t             physicalSchemeId;
     uint32_t            tmpKgarReg, intFlags;
     t_Error             err = E_OK;
@@ -3112,27 +3052,18 @@ t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
 
     SANITY_CHECK_RETURN_ERROR(h_Scheme, E_INVALID_HANDLE);
 
-    /*
-        err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
-        if (err)
-            return NULL;
-    */
+    p_FmPcd = (t_FmPcd*)(p_Scheme->h_FmPcd);
 
     /* check that no port is bound to this scheme */
-    err = FmPcdKgCheckInvalidateSchemeSw(h_Scheme);
+    err = InvalidateSchemeSw(h_Scheme);
     if(err)
-    {
-        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
         RETURN_ERROR(MINOR, err, NO_MSG);
-    }
 
     if (p_FmPcd->h_Hc)
     {
         err = FmHcPcdKgDeleteScheme(p_FmPcd->h_Hc, h_Scheme);
-        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
-        FmPcdKgInvalidateSchemeSw(h_Scheme);
-        if (p_Scheme->h_Spinlock)
-            XX_FreeSpinlock(p_Scheme->h_Spinlock);
+        if (p_Scheme->p_Lock)
+            FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
         return err;
     }
 
@@ -3148,12 +3079,8 @@ t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
     WriteKgarWait(p_FmPcd, tmpKgarReg);
     KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
-    FmPcdKgInvalidateSchemeSw(p_Scheme);
-
-    /* FmPcdKgReleaseSchemeLock(h_Scheme); */
-
-    if (p_Scheme->h_Spinlock)
-        XX_FreeSpinlock(p_Scheme->h_Spinlock);
+    if (p_Scheme->p_Lock)
+        FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
 
     return E_OK;
 }
@@ -3279,7 +3206,6 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     uint8_t             hardwarePortId = 0;
     uint32_t            tmpKgarReg, intFlags;
     t_Error             err = E_OK;
-    t_FmPcdIpcMsg       msg;
 
     DECLARE_DUMP;
 
@@ -3287,8 +3213,11 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcMsg       msg;
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_KG_DUMP_REGS;
         return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
@@ -3299,6 +3228,10 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
                                  NULL,
                                  NULL);
     }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+
     DUMP_SUBTITLE(("\n"));
     DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
 
@@ -3372,7 +3305,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
 
-        tmpKgarReg = FmPcdKgBuildReadClsPlanBlockActionReg((uint8_t)j);
+        tmpKgarReg = ReadClsPlanBlockActionReg((uint8_t)j);
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
new file mode 100644
index 0000000..6aa4dc8
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_kg.h
+
+ @Description   FM KG private header
+*//***************************************************************************/
+#ifndef __FM_KG_H
+#define __FM_KG_H
+
+#include "std_ext.h"
+
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* maskes */
+#if (DPAA_VERSION >= 11)
+#define KG_SCH_VSP_SHIFT_MASK                   0x0003f000
+#define KG_SCH_OM_VSPE                          0x00000001
+#define KG_SCH_VSP_NO_KSP_EN                    0x80000000
+
+#define MAX_SP_SHIFT                            23
+#define KG_SCH_VSP_MASK_SHIFT                   12
+#define KG_SCH_VSP_SHIFT                        24
+#endif /* (DPAA_VERSION >= 11) */
+
+#define KG_SCH_PP_SHIFT_HIGH                    0x80000000
+#define KG_SCH_PP_NO_GEN                        0x10000000
+#define KG_SCH_PP_SHIFT_LOW                     0x0000F000
+#define KG_SCH_MODE_NIA_PLCR                    0x40000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_SCH_BITMASK_MASK                     0x000000FF
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_MASK                         0x00FF0000
+#define FM_PCD_KG_KGAR_ERR                      0x20000000
+#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY       0x01000000
+#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY           0x02000000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP         0x00008000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP        0x00004000
+#define FM_PCD_KG_KGAR_WSEL_MASK                0x0000FF00
+#define KG_SCH_HASH_CONFIG_NO_FQID              0x80000000
+#define KG_SCH_HASH_CONFIG_SYM                  0x40000000
+
+#define FM_PCD_KG_KGAR_GO                       0x80000000
+#define FM_PCD_KG_KGAR_READ                     0x40000000
+#define FM_PCD_KG_KGAR_WRITE                    0x00000000
+#define FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY         0x00000000
+#define FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT   0x00008000
+
+
+typedef uint32_t t_KnownFieldsMasks;
+#define KG_SCH_KN_PORT_ID                   0x80000000
+#define KG_SCH_KN_MACDST                    0x40000000
+#define KG_SCH_KN_MACSRC                    0x20000000
+#define KG_SCH_KN_TCI1                      0x10000000
+#define KG_SCH_KN_TCI2                      0x08000000
+#define KG_SCH_KN_ETYPE                     0x04000000
+#define KG_SCH_KN_PPPSID                    0x02000000
+#define KG_SCH_KN_PPPID                     0x01000000
+#define KG_SCH_KN_MPLS1                     0x00800000
+#define KG_SCH_KN_MPLS2                     0x00400000
+#define KG_SCH_KN_MPLS_LAST                 0x00200000
+#define KG_SCH_KN_IPSRC1                    0x00100000
+#define KG_SCH_KN_IPDST1                    0x00080000
+#define KG_SCH_KN_PTYPE1                    0x00040000
+#define KG_SCH_KN_IPTOS_TC1                 0x00020000
+#define KG_SCH_KN_IPV6FL1                   0x00010000
+#define KG_SCH_KN_IPSRC2                    0x00008000
+#define KG_SCH_KN_IPDST2                    0x00004000
+#define KG_SCH_KN_PTYPE2                    0x00002000
+#define KG_SCH_KN_IPTOS_TC2                 0x00001000
+#define KG_SCH_KN_IPV6FL2                   0x00000800
+#define KG_SCH_KN_GREPTYPE                  0x00000400
+#define KG_SCH_KN_IPSEC_SPI                 0x00000200
+#define KG_SCH_KN_IPSEC_NH                  0x00000100
+#define KG_SCH_KN_L4PSRC                    0x00000004
+#define KG_SCH_KN_L4PDST                    0x00000002
+#define KG_SCH_KN_TFLG                      0x00000001
+
+typedef uint8_t t_GenericCodes;
+#define KG_SCH_GEN_SHIM1                       0x70
+#define KG_SCH_GEN_DEFAULT                     0x10
+#define KG_SCH_GEN_PARSE_RESULT_N_FQID         0x20
+#define KG_SCH_GEN_START_OF_FRM                0x40
+#define KG_SCH_GEN_SHIM2                       0x71
+#define KG_SCH_GEN_IP_PID_NO_V                 0x72
+#define KG_SCH_GEN_ETH                         0x03
+#define KG_SCH_GEN_ETH_NO_V                    0x73
+#define KG_SCH_GEN_SNAP                        0x04
+#define KG_SCH_GEN_SNAP_NO_V                   0x74
+#define KG_SCH_GEN_VLAN1                       0x05
+#define KG_SCH_GEN_VLAN1_NO_V                  0x75
+#define KG_SCH_GEN_VLAN2                       0x06
+#define KG_SCH_GEN_VLAN2_NO_V                  0x76
+#define KG_SCH_GEN_ETH_TYPE                    0x07
+#define KG_SCH_GEN_ETH_TYPE_NO_V               0x77
+#define KG_SCH_GEN_PPP                         0x08
+#define KG_SCH_GEN_PPP_NO_V                    0x78
+#define KG_SCH_GEN_MPLS1                       0x09
+#define KG_SCH_GEN_MPLS2                       0x19
+#define KG_SCH_GEN_MPLS3                       0x29
+#define KG_SCH_GEN_MPLS1_NO_V                  0x79
+#define KG_SCH_GEN_MPLS_LAST                   0x0a
+#define KG_SCH_GEN_MPLS_LAST_NO_V              0x7a
+#define KG_SCH_GEN_IPV4                        0x0b
+#define KG_SCH_GEN_IPV6                        0x1b
+#define KG_SCH_GEN_L3_NO_V                     0x7b
+#define KG_SCH_GEN_IPV4_TUNNELED               0x0c
+#define KG_SCH_GEN_IPV6_TUNNELED               0x1c
+#define KG_SCH_GEN_MIN_ENCAP                   0x2c
+#define KG_SCH_GEN_IP2_NO_V                    0x7c
+#define KG_SCH_GEN_GRE                         0x0d
+#define KG_SCH_GEN_GRE_NO_V                    0x7d
+#define KG_SCH_GEN_TCP                         0x0e
+#define KG_SCH_GEN_UDP                         0x1e
+#define KG_SCH_GEN_IPSEC_AH                    0x2e
+#define KG_SCH_GEN_SCTP                        0x3e
+#define KG_SCH_GEN_DCCP                        0x4e
+#define KG_SCH_GEN_IPSEC_ESP                   0x6e
+#define KG_SCH_GEN_L4_NO_V                     0x7e
+#define KG_SCH_GEN_NEXTHDR                     0x7f
+/* shifts */
+#define KG_SCH_PP_SHIFT_HIGH_SHIFT          27
+#define KG_SCH_PP_SHIFT_LOW_SHIFT           12
+#define KG_SCH_PP_MASK_SHIFT                16
+#define KG_SCH_MODE_CCOBASE_SHIFT           24
+#define KG_SCH_DEF_MAC_ADDR_SHIFT           30
+#define KG_SCH_DEF_TCI_SHIFT                28
+#define KG_SCH_DEF_ENET_TYPE_SHIFT          26
+#define KG_SCH_DEF_PPP_SESSION_ID_SHIFT     24
+#define KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT    22
+#define KG_SCH_DEF_MPLS_LABEL_SHIFT         20
+#define KG_SCH_DEF_IP_ADDR_SHIFT            18
+#define KG_SCH_DEF_PROTOCOL_TYPE_SHIFT      16
+#define KG_SCH_DEF_IP_TOS_TC_SHIFT          14
+#define KG_SCH_DEF_IPV6_FLOW_LABEL_SHIFT    12
+#define KG_SCH_DEF_IPSEC_SPI_SHIFT          10
+#define KG_SCH_DEF_L4_PORT_SHIFT            8
+#define KG_SCH_DEF_TCP_FLAG_SHIFT           6
+#define KG_SCH_HASH_CONFIG_SHIFT_SHIFT      24
+#define KG_SCH_GEN_MASK_SHIFT               16
+#define KG_SCH_GEN_HT_SHIFT                 8
+#define KG_SCH_GEN_SIZE_SHIFT               24
+#define KG_SCH_GEN_DEF_SHIFT                29
+#define FM_PCD_KG_KGAR_NUM_SHIFT            16
+
+/* others */
+#define NUM_OF_SW_DEFAULTS                  3
+#define MAX_PP_SHIFT                        23
+#define MAX_KG_SCH_SIZE                     16
+#define MASK_FOR_GENERIC_BASE_ID            0x20
+#define MAX_HASH_SHIFT                      40
+#define MAX_KG_SCH_FQID_BIT_OFFSET          31
+#define MAX_KG_SCH_PP_BIT_OFFSET            15
+#define MAX_DIST_FQID_SHIFT                 23
+
+#define GET_MASK_SEL_SHIFT(shift,i)             \
+switch(i) {                                     \
+    case(0):shift = 26;break;                   \
+    case(1):shift = 20;break;                   \
+    case(2):shift = 10;break;                   \
+    case(3):shift = 4;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_OFFSET_SHIFT(shift,i)          \
+switch(i) {                                     \
+    case(0):shift = 16;break;                   \
+    case(1):shift = 0;break;                    \
+    case(2):shift = 28;break;                   \
+    case(3):shift = 24;break;                   \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_SHIFT(shift,i)                 \
+switch(i) {                                     \
+    case(0):shift = 24;break;                   \
+    case(1):shift = 16;break;                   \
+    case(2):shift = 8;break;                    \
+    case(3):shift = 0;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* Masks */
+#define FM_PCD_KG_KGGCR_EN                      0x80000000
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_ERR_CAP                              0x80000000
+#define KG_ERR_TYPE_DOUBLE                      0x40000000
+#define KG_ERR_ADDR_MASK                        0x00000FFF
+#define FM_PCD_KG_DOUBLE_ECC                    0x80000000
+#define FM_PCD_KG_KEYSIZE_OVERFLOW              0x40000000
+#define KG_SCH_MODE_EN                          0x80000000
+
+/* shifts */
+#define FM_PCD_KG_PE_CPP_MASK_SHIFT             16
+#define FM_PCD_KG_KGAR_WSEL_SHIFT               8
+
+/* others */
+#define KG_DOUBLE_MEANING_REGS_OFFSET           0x100
+#define NO_VALIDATION                           0x70
+#define KG_ACTION_REG_TO                        1024
+#define KG_MAX_PROFILE                          255
+#define SCHEME_ALWAYS_DIRECT                    0xFFFFFFFF
+
+
+#endif /* __FM_KG_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index b6a199c..ba120f5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_manip.c
 
@@ -137,50 +138,74 @@ static uint8_t GET_UINT8_ERRATA(uint8_t *addr)
 
 static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
 {
-	uint8_t dataSize, remain, tableSize = 0;
-
-	if(p_FmPcdManipParams->u.hdr.rmv)
-		tableSize += HMCD_SIZE_RMV;
-
-	if(p_FmPcdManipParams->u.hdr.insrt)
-	{
-		remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
-		if(remain)
-			dataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
-		else
-			dataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
-		tableSize += (uint8_t)(HMCD_SIZE_INSRT + dataSize);
-	}
-	return tableSize;
+    uint8_t dataSize, remain, tableSize = 0;
+
+    if(p_FmPcdManipParams->u.hdr.rmv)
+    {
+        switch(p_FmPcdManipParams->u.hdr.rmvParams.type){
+            case(e_FM_PCD_MANIP_RMV_GENERIC):
+                /* As long as the only rmv command is the L2, no check on type is required */
+                tableSize +=  HMCD_BASIC_SIZE;
+            break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown rmvParams.type"));
+                return 0;
+        }
+    }
+
+    if(p_FmPcdManipParams->u.hdr.insrt)
+    {
+        switch(p_FmPcdManipParams->u.hdr.insrtParams.type){
+            case(e_FM_PCD_MANIP_INSRT_GENERIC):
+                remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
+                if(remain)
+                    dataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
+                else
+                    dataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
+                tableSize += (uint8_t)(HMCD_BASIC_SIZE + dataSize);
+            break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
+                return 0;
+        }
+    }
+
+    return tableSize;
 }
 
-static t_Error BuildHmct(t_FmPcdManipParams *p_FmPcdManipParams, uint32_t *p_HmcdTbl)
+static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-	uint32_t		*p_TmpData, *p_TmpPtr = (uint32_t *)p_HmcdTbl;
-	uint32_t		tmpReg = 0, *p_Last = NULL;
-	uint8_t			remain, i, size = 0, origSize, *p_Data = NULL;
-
-	if(p_FmPcdManipParams->u.hdr.rmv)
-	{
-	    if(p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_GENERIC)
-	    {
+    uint32_t        *p_HmcdTbl = p_Manip->p_HmcdTbl;
+    uint32_t        *p_TmpData, *p_TmpPtr = (uint32_t *)p_HmcdTbl;
+    uint32_t        tmpReg=0, *p_Last=NULL;
+    uint8_t         remain, i, size=0, origSize, *p_Data=NULL;
+
+    SANITY_CHECK_RETURN_ERROR((p_FmPcdManipParams->u.hdr.insrt ||
+                               p_FmPcdManipParams->u.hdr.rmv), E_INVALID_VALUE);
+
+    if (p_FmPcdManipParams->u.hdr.rmv)
+    {
+        if (p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_GENERIC)
+        {
             /* initialize HMCD */
             tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_RMV) << HMCD_OC_SHIFT;
             /* tmp, should be conditional */
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset << HMCD_RMV_OFFSET_SHIFT;
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size << HMCD_RMV_SIZE_SHIFT;
-	    }
-
-		WRITE_UINT32(*p_TmpPtr, tmpReg);
-		/* save a pointer to the "last" indication word */
-		p_Last = p_TmpPtr;
-		/* advance to next command */
-		p_TmpPtr += HMCD_SIZE_RMV/4;
-	}
-
-	if(p_FmPcdManipParams->u.hdr.insrt)
-	{
-        if(p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
+        }
+        else
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header remove type!"));
+
+        WRITE_UINT32(*p_TmpPtr, tmpReg);
+        /* save a pointer to the "last" indication word */
+        p_Last = p_TmpPtr;
+        /* advance to next command */
+        p_TmpPtr += HMCD_BASIC_SIZE/4;
+    }
+
+    if (p_FmPcdManipParams->u.hdr.insrt)
+    {
+        if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
         {
             /* initialize HMCD */
             if(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
@@ -193,104 +218,114 @@ static t_Error BuildHmct(t_FmPcdManipParams *p_FmPcdManipParams, uint32_t *p_Hmc
 
             size = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
             p_Data = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.p_Data;
+
+            WRITE_UINT32(*p_TmpPtr, tmpReg);
+            /* save a pointer to the "last" indication word */
+            p_Last = p_TmpPtr;
+
+            p_TmpPtr += HMCD_BASIC_SIZE/4;
+
+            /* initialize data to be inserted */
+            /* if size is not a multiple of 4, padd with 0's */
+            origSize = size;
+            remain = (uint8_t)(size % 4);
+            if (remain)
+            {
+                size += (uint8_t)(4 - remain);
+                p_TmpData = (uint32_t *)XX_Malloc(size);
+                memset((uint8_t *)p_TmpData, 0, size);
+                memcpy((uint8_t *)p_TmpData, p_Data, origSize);
+            }
+            else
+                p_TmpData = (uint32_t*)p_Data;
+
+            /* initialize data and advance pointer to next command */
+            for (i = 0; i<size/4 ; i++, p_TmpPtr++)
+                WRITE_UINT32(*p_TmpPtr, *(p_TmpData+i));
+
+            if (remain)
+                XX_Free(p_TmpData);
+
+            p_TmpPtr += HMCD_BASIC_SIZE/4;
         }
+        else
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header insert type!"));
+    }
 
-        WRITE_UINT32(*(uint32_t*)p_TmpPtr, tmpReg);
-        /* save a pointer to the "last" indication word */
-        p_Last = p_TmpPtr;
 
-        p_TmpPtr += HMCD_SIZE_INSRT/4;
-
-        /* initialize data to be inserted */
-		/* if size is not a multiple of 4, padd with 0's */
-        origSize = size;
-		remain = (uint8_t)(size % 4);
-		if(remain)
-		{
-			size += (uint8_t)(4 - remain);
-			p_TmpData = (uint32_t *)XX_Malloc(size);
-			memset((uint8_t *)p_TmpData, 0, size);
-			memcpy((uint8_t *)p_TmpData, p_Data, origSize);
-		}
-		else
-			p_TmpData = (uint32_t*)p_Data;
-
-		/* initialize data and advance pointer to next command */
-		for (i = 0; i<size/4 ; i++, p_TmpPtr++)
-			WRITE_UINT32(*p_TmpPtr, *(p_TmpData+i));
-
-		if(remain)
-			XX_Free(p_TmpData);
-	}
-	/* If this node has a nextManip, and no parsing is required after it, the old table must be copied to the new table
-	   the old table and should be freed */
-	if(p_FmPcdManipParams->h_NextManip && (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
-	{
-		/* copy old table to new location */
-		memcpy((uint8_t *)p_TmpPtr, MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip));
-		/* free old table */
-		FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip));
-		/* update old manip table pointer */
-		MANIP_SET_HMCT_PTR(p_FmPcdManipParams->h_NextManip, p_TmpPtr);
-		p_TmpPtr += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
-	}
-	else
-		/* set the "last" indication on the last command of the current table */
-		WRITE_UINT32(*p_Last, GET_UINT32(*p_Last) | HMCD_LAST);
-
-	return E_OK;
+    /* If this node has a nextManip, and no parsing is required after it, the old table must be copied to the new table
+       the old table and should be freed */
+    if (p_FmPcdManipParams->h_NextManip &&
+        (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
+    {
+        /* copy old table to new location */
+        memcpy((uint8_t *)p_TmpPtr, MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip));
+        /* free old table */
+        FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip));
+        /* update old manip table pointer */
+        MANIP_SET_HMCT_PTR(p_FmPcdManipParams->h_NextManip, p_TmpPtr);
+        p_TmpPtr += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
+    }
+    else
+        /* set the "last" indication on the last command of the current table */
+        WRITE_UINT32(*p_Last, GET_UINT32(*p_Last) | HMCD_LAST);
+
+    return E_OK;
 }
 
 static t_Error CreateManipAction(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-	t_Error		err;
-	uint16_t	tmpReg;
+    t_Error     err;
+    uint16_t    tmpReg, tmpSize;
 
-	/* set Manip structure */
-	if(p_FmPcdManipParams->h_NextManip)
+    /* set Manip structure */
+    if(p_FmPcdManipParams->h_NextManip)
     {
-	if(MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
-		p_Manip->tableSize = MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip);
-	else
-		p_Manip->cascadedNext = TRUE;
-
-		p_Manip->h_NextManip = p_FmPcdManipParams->h_NextManip;
-	/* save a "prev" pointer in h_NextManip */
-		MANIP_SET_PREV(p_FmPcdManipParams->h_NextManip, p_Manip);
-	FmPcdManipUpdateOwner(p_FmPcdManipParams->h_NextManip, TRUE);
+        if(MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+            p_Manip->tableSize = MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip);
+        else
+            p_Manip->cascadedNext = TRUE;
     }
     p_Manip->dontParseAfterManip = p_FmPcdManipParams->u.hdr.dontParseAfterManip;
 
-	/* Allocate new table */
+    /* Allocate new table */
     /* calculate table size according to manip parameters */
-    p_Manip->tableSize += CalculateTableSize(p_FmPcdManipParams);
-	p_Manip->p_HmcdTbl = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->tableSize, 4);
+    tmpSize = CalculateTableSize(p_FmPcdManipParams);
+    if(tmpSize == 0)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CalculateTableSize Failed"));
+
+    p_Manip->tableSize += tmpSize;
+    p_Manip->p_HmcdTbl = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->tableSize, 4);
+    if (!p_Manip->p_HmcdTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
 
     /* Fill table */
-	err = BuildHmct(p_FmPcdManipParams, p_Manip->p_HmcdTbl);
-	if (err)
-		RETURN_ERROR(MINOR, err, NO_MSG);
-
-	/* Build HMTD (table descriptor) */
-	tmpReg = HMTD_CFG_TYPE; /* NADEN = 0 */
-	/* add parseAfterManip */
-	if (!p_Manip->dontParseAfterManip)
-		tmpReg |= HMTD_CFG_PRS_AFTER_HM;
-	if (p_FmPcdManipParams->h_NextManip && (!MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
-	{
-		/* indicate that there's another HM table descriptor */
-		tmpReg |= HMTD_CFG_NEXT_AD_EN;
-		WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
-					 (uint16_t)((XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip)) -
-							    (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
-	}
-	WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->cfg, tmpReg);
-	WRITE_UINT32(((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
-			(uint32_t)(XX_VirtToPhys(p_Manip->p_HmcdTbl) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
-
-	WRITE_UINT8(((t_Hmtd *)p_Manip->h_Ad)->opCode, HMAN_OC);
-
-	return E_OK;
+    err = BuildHmct(p_Manip, p_FmPcdManipParams);
+    if (err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* Build HMTD (table descriptor) */
+    tmpReg = HMTD_CFG_TYPE; /* NADEN = 0 */
+    /* add parseAfterManip */
+    if (!p_Manip->dontParseAfterManip)
+        tmpReg |= HMTD_CFG_PRS_AFTER_HM;
+    if (p_FmPcdManipParams->h_NextManip &&
+        !MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+    {
+        /* indicate that there's another HM table descriptor */
+        tmpReg |= HMTD_CFG_NEXT_AD_EN;
+        WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
+                     (uint16_t)((uint32_t)(PTR_TO_UINT(XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip))) -
+                                (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
+    }
+
+    WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->cfg, tmpReg);
+    WRITE_UINT32(((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
+            (uint32_t)(XX_VirtToPhys(p_Manip->p_HmcdTbl) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+
+    WRITE_UINT8(((t_Hmtd *)p_Manip->h_Ad)->opCode, HMAN_OC);
+
+    return E_OK;
 }
 
 static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
@@ -943,9 +978,9 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     *p_AutoLearnHashTblAddr = PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize));
     if(!*p_AutoLearnHashTblAddr)
     {
-	FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
-	*p_IpReassTbl = NULL;
-	RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
+        *p_IpReassTbl = NULL;
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
     IOMemSet32(UINT_TO_PTR(*p_AutoLearnHashTblAddr), 0,  autoLearnHashTblSize);
 
@@ -962,10 +997,10 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     *p_AutoLearnSetLockTblAddr = PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4));
     if(!*p_AutoLearnSetLockTblAddr)
     {
-	FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
-	*p_IpReassTbl = NULL;
-	XX_FreeSmart(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
-	*p_AutoLearnHashTblAddr = 0;
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
+        *p_IpReassTbl = NULL;
+        XX_FreeSmart(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
+        *p_AutoLearnHashTblAddr = 0;
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
     IOMemSet32(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr), 0,  (numOfSets * 4));
@@ -1031,14 +1066,18 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
             fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_SWITCH_PORT | NIA_ENG_FM_CTL;
             fmPortGetSetCcParams.setCcParams.immediateWrite = TRUE;
             if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
+                RETURN_ERROR(MINOR, err, NO_MSG);
         }
         /* set special operational mode bits: KOMV=1(valid), OVOM=0(setting one), NENQ=1, NL=1, CWD=1.
          * set the scheme NIA to BMI */
-        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd));
-        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_OPT_MODE, 0x8000001c);
-        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd));
-        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_OPT_MODE, 0x8000001c);
+        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_OPT_MODE, 0x8000001c)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_OPT_MODE, 0x8000001c)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
     if(p_Manip->ipReassmParams.h_Ipv4Scheme)
@@ -1148,7 +1187,7 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
     return E_OK;
 }
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
 static t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
 {
     t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1184,12 +1223,9 @@ static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid
     if ((err = FmHcPcdCcIpFragScratchPollCmd(p_FmPcd->h_Hc, FALSE, &fmPcdCcFragScratchPoolCmdParams)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    if (fmPcdCcFragScratchPoolCmdParams.numOfBuffers != NUM_OF_SCRATCH_POOL_BUFFERS)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Empty scratch pool failed"));
-
     return E_OK;
 }
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
 static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 {
@@ -1223,9 +1259,9 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
     {
         if (p_Manip->ipFragParams.p_Frag)
         {
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
             FmPcdFragHcScratchPoolEmpty((t_Handle)p_FmPcd, p_Manip->ipFragParams.scratchBpid);
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
         }
@@ -1235,18 +1271,18 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
         FmPcdUnregisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
 
         if(p_Manip->ipReassmParams.timeOutTblAddr)
-		FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr));
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr));
         if(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr));
 
         if(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr));
         if(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr));
         if(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr));
         if(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr));
         if(p_Manip->ipReassmParams.p_Ipv4ReassTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv4ReassTbl);
         if(p_Manip->ipReassmParams.p_Ipv6ReassTbl)
@@ -1397,9 +1433,8 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
     return E_OK;
 }
 #else /* not FM_CAPWAP_SUPPORT */
-static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_ManipParams)
 {
-
     switch (p_ManipParams->type)
     {
         case e_FM_PCD_MANIP_HDR :
@@ -1431,6 +1466,8 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
             }
             break;
         case e_FM_PCD_MANIP_REASSEM :
+            if (p_ManipParams->h_NextManip)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with reassembly"));
             switch(p_ManipParams->u.reassem.hdr)
             {
                 case(HEADER_TYPE_IPv4):
@@ -1448,6 +1485,8 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
              }
             break;
         case e_FM_PCD_MANIP_FRAG :
+            if (p_ManipParams->h_NextManip)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with fragmentation"));
             switch(p_ManipParams->u.frag.hdr)
             {
                 case(HEADER_TYPE_IPv4):
@@ -1474,6 +1513,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("manip type"));
     }
 
+    /* TODO - Ganit */
     if (p_Manip->owner && p_Manip->h_PrevManip)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No sharing on cascaded internal nodes"));
 
@@ -1682,11 +1722,6 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *
             case(HEADER_TYPE_USER_DEFINED_SHIM2):
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
                 break;
-            /* TODO - to take care about SHIM3
-            case(HEADER_TYPE_USER_DEFINED_SHIM3):
-                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM3_OFFSET;
-                break;
-            */
             case(HEADER_TYPE_LLC_SNAP):
                 *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
                 break;
@@ -1741,9 +1776,6 @@ static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_M
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-/* TODO - reconsider this once full HM support exists */
-    SANITY_CHECK_RETURN_ERROR((p_ManipParams->type == e_FM_PCD_MANIP_RMV_BY_HDR),E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_ManipParams->u.byHdr.type == e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START),E_INVALID_HANDLE);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
     if (p_Manip->rmv)
@@ -1784,11 +1816,6 @@ static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip, bo
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
     *(uint32_t *)&p_Ad->ccAdBase = tmpReg32;
 
-    /*TODO - update offsetInBufferPrefixForIntFrameHdr when port connected to tree
-    tmpReg32 = 0;
-    tmpReg32 |= offsetInBufferPrefixForIntFrameHdr;
-    *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;*/
-
     tmpReg32 = 0;
     tmpReg32 |= HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
     tmpReg32 |= (uint32_t)0x16 << 16;
@@ -1884,7 +1911,7 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
                                     FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
 
     if (!p_Manip->fragParams.p_AutoLearnHashTbl)
-	RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
 
     IOMemSet32(p_Manip->fragParams.p_AutoLearnHashTbl, 0,  (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
 
@@ -1928,8 +1955,6 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
 
     p_Manip->fragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
     p_Manip->fragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
-    /*TODO  - to take care about this function FmGetTimeStampScale - it return t_Error
-     now we have problems with all calls to this function*/
     p_Manip->fragParams.bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
 
     tmpReg32 = 0;
@@ -2104,18 +2129,14 @@ static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
 }
 
 static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
-                            t_FmPcdManip                *p_Manip,
-                            t_FmPcd                     *p_FmPcd)
+                            t_FmPcdManip                *p_Manip)
 {
     uint32_t                    maxSetNumber = 10000;
     t_FmPcdManipReassemIpParams reassmManipParams = p_ManipReassmParams->u.ipReassem;
     t_Error                     res;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
-#ifdef DISABLE_SANITY_CHECKS
-UNUSED(p_FmPcd);
-#endif /* DISABLE_SANITY_CHECKS */
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((t_FmPcd *)p_Manip->h_FmPcd)->h_Hc, E_INVALID_HANDLE);
 
     /* Check validation of user's parameter.*/
     if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000) ||
@@ -2145,9 +2166,6 @@ UNUSED(p_FmPcd);
     p_Manip->ipReassmParams.dataMemId = reassmManipParams.dataMemId;
     p_Manip->ipReassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
     p_Manip->ipReassmParams.sgBpid = reassmManipParams.sgBpid;
-#ifdef UNDER_CONSTRUCTION_V3_IPR
-    p_Manip->ipReassmParams.h_CouplingFmPort = reassmManipParams.h_CouplingFmPort;
-#endif /* UNDER_CONSTRUCTION_V3_IPR */
     /* Creates and initializes the IP Reassembly common parameter table */
     CreateIpReassCommonTable(p_Manip);
 
@@ -2443,14 +2461,14 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
          }
 
          tmpReg32 = tmpReg16 = tmpReg8 = 0;
-         /*TODO - check it*/
-         if(p_InsrtByTemplate->modifyOuterVlan)
+
+         if (p_InsrtByTemplate->modifyOuterVlan)
          {
-             if(p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
+             if (p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
                  RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"));
 
              memcpy(&tmpReg16, &p_Template[VLAN_TAG_FIELD_OFFSET_FROM_ETH], 2*(sizeof(uint8_t)));
-             if((tmpReg16  != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
+             if ((tmpReg16  != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
                  RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "));
 
              memcpy(&tmpReg8, &p_Template[14],1*(sizeof(uint8_t)));
@@ -2507,16 +2525,18 @@ static t_Error IpFragmentationStats(t_FmPcdManip *p_Manip, t_FmPcdManipFragIpSta
     return E_OK;
 }
 
-static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdManip *p_Manip)
 {
-    uint32_t                pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
-#if (DPAA_VERSION == 2)
-    t_Error                 err = E_OK;
-#endif /* (DPAA_VERSION == 2) */
+    uint32_t    pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
+    t_FmPcd     *p_FmPcd;
+#if (DPAA_VERSION == 10)
+    t_Error     err = E_OK;
+#endif /* (DPAA_VERSION == 10) */
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_ManipParams->sizeForFragmentation != 0xFFFF, E_INVALID_VALUE);
 
+    p_FmPcd = p_Manip->h_FmPcd;
     /* Allocation of fragmentation Action Descriptor */
     p_Manip->ipFragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                                              FM_PCD_CC_AD_ENTRY_SIZE,
@@ -2536,26 +2556,26 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,t_FmPcdMa
     /* Set Scatter/Gather BPid */
     if (p_ManipParams->sgBpidEn)
     {
-	 ccAdBaseReg 	 |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
-		 pcAndOffsetsReg |= ((p_ManipParams->sgBpid << FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET) & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
+         ccAdBaseReg     |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
+         pcAndOffsetsReg |= ((p_ManipParams->sgBpid << FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET) & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
     }
 
     /* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
     gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr)) - p_FmPcd->physicalMuramBase);
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     gmaskReg |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
     /* Set all Ad registers */
     WRITE_UINT32(p_Manip->ipFragParams.p_Frag->pcAndOffsets, pcAndOffsetsReg);
-	WRITE_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase, ccAdBaseReg);
+    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase, ccAdBaseReg);
     WRITE_UINT32(p_Manip->ipFragParams.p_Frag->gmask, gmaskReg);
 
     /* Saves user's fragmentation manipulation parameters */
     p_Manip->frag = TRUE;
     p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     p_Manip->ipFragParams.scratchBpid = p_ManipParams->scratchBpid;
 
     /* scratch buffer pool initialization */
@@ -2565,19 +2585,21 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,t_FmPcdMa
         p_Manip->ipFragParams.p_Frag = NULL;
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
     return E_OK;
 }
 
-static t_Error IPManip(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IPManip(t_FmPcdManip *p_Manip)
 {
 
     t_Error                     err = E_OK;
+    t_FmPcd                     *p_FmPcd;
     t_AdOfTypeContLookup        *p_Ad;
     uint32_t                    tmpReg32 = 0, tmpRegNia = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    p_FmPcd = p_Manip->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
@@ -2600,17 +2622,18 @@ static t_Error IPManip(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
     return err;
 }
 
-static t_Error IPSecManip(t_FmPcdManipSpecialOffloadIPSecParams *p_IPSecParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
+                          t_FmPcdManip          *p_Manip)
 {
-    t_Error                     err = E_OK;
-    t_AdOfTypeContLookup        *p_Ad;
-    uint32_t                    tmpReg32 = 0;
+    t_AdOfTypeContLookup                    *p_Ad;
+    t_FmPcdManipSpecialOffloadIPSecParams   *p_IPSecParams;
+    t_Error                                 err = E_OK;
+    uint32_t                                tmpReg32 = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
-#ifdef DISABLE_SANITY_CHECKS
-UNUSED(p_FmPcd);
-#endif /* DISABLE_SANITY_CHECKS */
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_INVALID_HANDLE);
+
+    p_IPSecParams = &p_ManipParams->u.specialOffload.u.ipsec;
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
@@ -2621,7 +2644,17 @@ UNUSED(p_FmPcd);
     tmpReg32 |= (p_IPSecParams->variableIpHdrLen)?FM_PCD_MANIP_IPSEC_VIPL_EN:0;
 
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
-    WRITE_UINT32(p_Ad->pcAndOffsets, HMAN_OC_IPSEC_MANIP);
+
+    tmpReg32 = HMAN_OC_IPSEC_MANIP;
+    if (p_ManipParams->h_NextManip)
+    {
+        WRITE_UINT32(p_Ad->matchTblPtr,
+                    (uint32_t)(XX_VirtToPhys(((t_FmPcdManip *)p_ManipParams->h_NextManip)->h_Ad)-
+                               (((t_FmPcd *)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4);
+
+        tmpReg32 |= FM_PCD_MANIP_IPSEC_NADEN;
+    }
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
     return err;
 }
@@ -2682,34 +2715,34 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
     {
         /* In Case of IP reassembly manipulation the IPv4/IPv6 reassembly action descriptor will
            be defines later on */
-		if (p_Manip->muramAllocate)
-		{
-			p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-														FM_PCD_CC_AD_ENTRY_SIZE,
-														FM_PCD_CC_AD_TABLE_ALIGN);
-			 if(!p_Manip->h_Ad)
-			 {
-				REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
-				ReleaseManipHandler(p_Manip, p_FmPcd);
-				XX_Free(p_Manip);
-				return NULL;
-			 }
-
-			IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
-		}
-		else
-		{
-			p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-			 if(!p_Manip->h_Ad)
-			 {
-				REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
-				ReleaseManipHandler(p_Manip, p_FmPcd);
-				XX_Free(p_Manip);
-				return NULL;
-			 }
-
-			memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-		}
+        if (p_Manip->muramAllocate)
+        {
+            p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                        FM_PCD_CC_AD_ENTRY_SIZE,
+                                                        FM_PCD_CC_AD_TABLE_ALIGN);
+             if(!p_Manip->h_Ad)
+             {
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+             }
+
+            IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        }
+        else
+        {
+            p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+             if(!p_Manip->h_Ad)
+             {
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+             }
+
+            memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+        }
     }
 
     p_Manip->h_FmPcd = h_FmPcd;
@@ -2849,8 +2882,8 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
             p_Manip->ownerTmp++;
             break;
         case(HMAN_OC):
-			if(( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE(p_Manip))
-				RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't share this Manip node, in is cascaded and Next Engine is CC"));
+            if(( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE(p_Manip))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't share this Manip node, in is cascaded and Next Engine is CC"));
             break;
 
         default:
@@ -2954,7 +2987,7 @@ void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_
             *p_AdNewPtr = NULL;
             break;
         case(HMAN_OC):
-		/* Allocate and initialize HMTD */
+            /* Allocate and initialize HMTD */
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
         default:
@@ -2984,17 +3017,17 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
             break;
 
         case(HMAN_OC):
-		/* Initialize HMTD within the match table*/
-			IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
-		/* copy the existing HMTD */ /* ask Alla - memcpy??? */
-		memcpy((uint8_t*)p_Ad, p_Manip->h_Ad, sizeof(t_Hmtd));
-		/* update NADEN to be "1"*/
-			WRITE_UINT16(((t_Hmtd *)p_Ad)->cfg,
-			             (uint16_t)(GET_UINT16(((t_Hmtd *)p_Ad)->cfg) | HMTD_CFG_NEXT_AD_EN));
-			/* update next action descriptor */
-			WRITE_UINT16(((t_Hmtd *)p_Ad)->nextAdIdx, (uint16_t)(adTableOffset >> 4));
-			/* mark that Manip's HMTD is not used */
-			*p_AdNewPtr = NULL;
+            /* Initialize HMTD within the match table*/
+            IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+            /* copy the existing HMTD */ /* ask Alla - memcpy??? */
+            memcpy((uint8_t*)p_Ad, p_Manip->h_Ad, sizeof(t_Hmtd));
+            /* update NADEN to be "1"*/
+            WRITE_UINT16(((t_Hmtd *)p_Ad)->cfg,
+                         (uint16_t)(GET_UINT16(((t_Hmtd *)p_Ad)->cfg) | HMTD_CFG_NEXT_AD_EN));
+            /* update next action descriptor */
+            WRITE_UINT16(((t_Hmtd *)p_Ad)->nextAdIdx, (uint16_t)(adTableOffset >> 4));
+            /* mark that Manip's HMTD is not used */
+            *p_AdNewPtr = NULL;
             break;
 
         default:
@@ -3067,15 +3100,15 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     p_Manip->type = HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
     p_Manip->muramAllocate = FALSE;
 
-	p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-	 if(!p_Manip->h_Ad)
-	 {
-		REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
-		XX_Free(p_Manip);
-		return NULL;
-	 }
+    p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+     if(!p_Manip->h_Ad)
+     {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
+        XX_Free(p_Manip);
+        return NULL;
+     }
 
-	memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
 
     /*treatFdStatusFieldsAsErrors = TRUE hardcoded - assumption its always come after CAAM*/
     /*Application specific = type of flowId index, move internal frame header from data to IC,
@@ -3121,7 +3154,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     {
         case(HMAN_OC_IP_REASSEMBLY):
             /* IpReassembly */
-            err = IpReassembly(&p_ManipParams->u.reassem, p_Manip, p_FmPcd);
+            err = IpReassembly(&p_ManipParams->u.reassem, p_Manip);
             if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -3132,7 +3165,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
             break;
        case(HMAN_OC_IP_FRAGMENTATION):
             /* IpFragmentation */
-            err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip, p_FmPcd);
+            err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip);
             if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -3141,10 +3174,10 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
         case(HMAN_OC_IP_MANIP) :
-            err = IPManip(p_Manip, p_FmPcd);
+            err = IPManip(p_Manip);
             break;
         case(HMAN_OC_IPSEC_MANIP) :
-            err = IPSecManip(&p_ManipParams->u.specialOffload.u.ipsec, p_Manip, p_FmPcd);
+            err = IPSecManip(p_ManipParams, p_Manip);
             break;
 #ifdef FM_CAPWAP_SUPPORT
         case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
@@ -3211,6 +3244,14 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
         return NULL;
     }
 
+    if (p_ManipParams->h_NextManip)
+    {
+        p_Manip->h_NextManip = p_ManipParams->h_NextManip;
+        /* save a "prev" pointer in h_NextManip */
+        MANIP_SET_PREV(p_Manip->h_NextManip, p_Manip);
+        FmPcdManipUpdateOwner(p_Manip->h_NextManip, TRUE);
+    }
+
     return p_Manip;
 }
 
@@ -3223,12 +3264,15 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
     if(p_Manip->owner)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
 
-	if(p_Manip->h_NextManip)
+    if(p_Manip->h_NextManip)
     {
-		MANIP_SET_PREV(p_Manip->h_NextManip, NULL);
-	FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
+        MANIP_SET_PREV(p_Manip->h_NextManip, NULL);
+        FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
     }
 
+    if(p_Manip->p_HmcdTbl)
+        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_HmcdTbl);
+
     ReleaseManipHandler(p_Manip, p_Manip->h_FmPcd);
 
     XX_Free(h_ManipNode);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
index db16125..b07f40c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_manip.h
 
@@ -49,6 +50,8 @@
 /*          Header manipulations defines                              */
 /***********************************************************************/
 
+#define NUM_OF_SCRATCH_POOL_BUFFERS             1000 /*TODO - Change it!!*/
+
 #define HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR                      0x2e
 #define HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER              0x31
 #define HMAN_OC_CAPWAP_FRAGMENTATION                            0x33
@@ -60,7 +63,7 @@
 #define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
 #define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 /* dummy */
 #define HMAN_OC_CAPWAP_INDEXED_STATS                            0x32 /* dummy */
-#define HMAN_OC													0x35
+#define HMAN_OC                                                 0x35
 
 #define HMAN_RMV_HDR                               0x80000000
 #define HMAN_INSRT_INT_FRM_HDR                     0x40000000
@@ -112,61 +115,97 @@
 #define FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID                   24
 #define FM_PCD_MANIP_IP_FRAG_MTU_OFFSET                     16
 #define FM_PCD_MANIP_IP_FRAG_NO_FRAGMETATION                0xFFFF0000
-#define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN						0x08000000
-#define FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK					0xFF000000
-#define FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET					24
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN                     0x08000000
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK                   0xFF000000
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET                 24
 
 #define FM_PCD_MANIP_IPSEC_DEC                              0x10000000
 #define FM_PCD_MANIP_IPSEC_ECN_EN                           0x04000000
 #define FM_PCD_MANIP_IPSEC_DSCP_EN                          0x02000000
 #define FM_PCD_MANIP_IPSEC_VIPL_EN                          0x01000000
+#define FM_PCD_MANIP_IPSEC_NADEN                            0x20000000
 
 #define e_FM_MANIP_IP_INDX                                  1
 
-#define HMCD_OPCODE_GENERIC_RMV					0x01
+#define HMCD_OPCODE_GENERIC_RMV                 0x01
 #define HMCD_OPCODE_GENERIC_INSRT               0x02
 #define HMCD_OPCODE_GENERIC_REPLACE             0x05
 #define HMCD_OPCODE_L2_RMV                      0x08
 #define HMCD_OPCODE_L2_INSRT                    0x09
-
-#define HMCD_SIZE_RMV 							4
-#define HMCD_SIZE_INSRT 						4
-
-#define HMCD_LAST								0x00800000
-
-#define HMCD_OC_SHIFT							24
-
-#define HMCD_RMV_OFFSET_SHIFT					0
-#define HMCD_RMV_SIZE_SHIFT						8
-
-#define HMCD_INSRT_OFFSET_SHIFT					0
-#define HMCD_INSRT_SIZE_SHIFT					8
-
-#define	HMTD_CFG_TYPE							0x4000
-#define	HMTD_CFG_EXT_HMCT						0x0080
-#define	HMTD_CFG_PRS_AFTER_HM					0x0040
-#define	HMTD_CFG_NEXT_AD_EN						0x0020
-
-
-#define HMCD_RMV_L2_ETHERNET                   0
-#define HMCD_RMV_L2_STACKED_QTAGS              1
-#define HMCD_RMV_L2_ETHERNET_AND_MPLS          2
-#define HMCD_RMV_L2_MPLS                       3
-
-#define HMCD_INSRT_L2_MPLS                     0
-#define HMCD_INSRT_N_UPDATE_L2_MPLS            0
-
-
-#define MANIP_IS_CASCADE(h_Manip)				(((t_FmPcdManip *)h_Manip)->cascadedNext)
-#define MANIP_GET_HMCT_SIZE(h_Manip) 			(((t_FmPcdManip *)h_Manip)->tableSize)
-#define MANIP_GET_HMCT_PTR(h_Manip) 			(((t_FmPcdManip *)h_Manip)->p_HmcdTbl)
-#define MANIP_SET_HMCT_PTR(h_Manip, h_NewPtr) 	(((t_FmPcdManip *)h_Manip)->p_HmcdTbl = h_NewPtr)
-#define MANIP_GET_HMTD_PTR(h_Manip) 			(((t_FmPcdManip *)h_Manip)->h_Ad)
-#define MANIP_DONT_REPARSE(h_Manip) 			(((t_FmPcdManip *)h_Manip)->dontParseAfterManip)
-#define MANIP_SET_PREV(h_Manip, h_Prev) 		(((t_FmPcdManip *)h_Manip)->h_PrevManip = h_Prev)
-#define MANIP_GET_MURAM(h_Manip)				(((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram)
-
-
+#define HMCD_OPCODE_VLAN_PRI_UPDATE             0x0B
+#define HMCD_OPCODE_IPV4_UPDATE                 0x0C
+#define HMCD_OPCODE_IPV6_UPDATE                 0x10
+#define HMCD_OPCODE_TCP_UDP_UPDATE              0x0E
+#define HMCD_OPCODE_TCP_UDP_CHECKSUM            0x14
+#define HMCD_OPCODE_REPLACE_IP                  0x12
+
+
+#define HMCD_BASIC_SIZE                         4
+#define HMCD_PTR_SIZE                           4
+#define HMCD_PARAM_SIZE                         4
+#define HMCD_IPV4_ADDR_SIZE                     4
+#define HMCD_IPV6_ADDR_SIZE                     0x10
+
+#define HMCD_LAST                               0x00800000
+
+#define HMCD_OC_SHIFT                           24
+
+#define HMCD_RMV_OFFSET_SHIFT                   0
+#define HMCD_RMV_SIZE_SHIFT                     8
+
+#define HMCD_INSRT_OFFSET_SHIFT                 0
+#define HMCD_INSRT_SIZE_SHIFT                   8
+
+#define HMTD_CFG_TYPE                           0x4000
+#define HMTD_CFG_EXT_HMCT                       0x0080
+#define HMTD_CFG_PRS_AFTER_HM                   0x0040
+#define HMTD_CFG_NEXT_AD_EN                     0x0020
+
+#define HMCD_RMV_L2_ETHERNET                    0
+#define HMCD_RMV_L2_STACKED_QTAGS               1
+#define HMCD_RMV_L2_ETHERNET_AND_MPLS           2
+#define HMCD_RMV_L2_MPLS                        3
+
+#define HMCD_INSRT_L2_MPLS                      0
+#define HMCD_INSRT_N_UPDATE_L2_MPLS             1
+#define HMCD_INSRT_L2_SIZE_SHIFT                24
+
+#define HMCD_VLAN_PRI_REP_MODE_SHIFT            16
+#define HMCD_VLAN_PRI_UPDATE                    0
+#define HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI       1
+
+#define HMCD_IPV4_UPDATE_TTL                    0x00000001
+#define HMCD_IPV4_UPDATE_TOS                    0x00000002
+#define HMCD_IPV4_UPDATE_DST                    0x00000020
+#define HMCD_IPV4_UPDATE_SRC                    0x00000040
+#define HMCD_IPV4_UPDATE_ID                     0x00000080
+#define HMCD_IPV4_UPDATE_TOS_SHIFT              8
+
+#define HMCD_IPV6_UPDATE_HL                     0x00000001
+#define HMCD_IPV6_UPDATE_TC                     0x00000002
+#define HMCD_IPV6_UPDATE_DST                    0x00000040
+#define HMCD_IPV6_UPDATE_SRC                    0x00000080
+#define HMCD_IPV6_UPDATE_TC_SHIFT               8
+
+#define HMCD_TCP_UDP_UPDATE_DST                 0x00004000
+#define HMCD_TCP_UDP_UPDATE_SRC                 0x00008000
+#define HMCD_TCP_UDP_UPDATE_SRC_SHIFT           16
+
+#define HMCD_IP_REPLACE_REPLACE_IPV4            0x00000000
+#define HMCD_IP_REPLACE_REPLACE_IPV6            0x00010000
+#define HMCD_IP_REPLACE_TTL_HL                  0x00200000
+#define HMCD_IP_REPLACE_ID                      0x00400000
+
+#define MANIP_IS_CASCADE(h_Manip)               (((t_FmPcdManip *)h_Manip)->cascadedNext)
+#define MANIP_GET_HMCT_SIZE(h_Manip)            (((t_FmPcdManip *)h_Manip)->tableSize)
+#define MANIP_GET_HMCT_PTR(h_Manip)             (((t_FmPcdManip *)h_Manip)->p_HmcdTbl)
+#define MANIP_SET_HMCT_PTR(h_Manip, h_NewPtr)   (((t_FmPcdManip *)h_Manip)->p_HmcdTbl = h_NewPtr)
+#define MANIP_GET_HMTD_PTR(h_Manip)             (((t_FmPcdManip *)h_Manip)->h_Ad)
+#define MANIP_DONT_REPARSE(h_Manip)             (((t_FmPcdManip *)h_Manip)->dontParseAfterManip)
+#define MANIP_SET_PREV(h_Manip, h_Prev)         (((t_FmPcdManip *)h_Manip)->h_PrevManip = h_Prev)
+#define MANIP_GET_MURAM(h_Manip)                (((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram)
+
+#define DSCP_TO_VLAN_TABLE_SIZE                 32
 /***********************************************************************/
 /*          Memory map                                                 */
 /***********************************************************************/
@@ -239,14 +278,14 @@ typedef _Packed struct t_IpReassCommonTbl {
 } _PackedType t_IpReassCommonTbl;
 
 typedef _Packed struct t_Hmtd {
-    volatile uint16_t 	cfg;
-    volatile uint8_t 	eliodnOffset;
-    volatile uint8_t 	extHmcdBasePtrHi;
-    volatile uint32_t 	hmcdBasePtr;
-    volatile uint16_t 	nextAdIdx;
-    volatile uint8_t 	res1;
-    volatile uint8_t 	opCode;
-    volatile uint32_t 	res2;
+    volatile uint16_t   cfg;
+    volatile uint8_t    eliodnOffset;
+    volatile uint8_t    extHmcdBasePtrHi;
+    volatile uint32_t   hmcdBasePtr;
+    volatile uint16_t   nextAdIdx;
+    volatile uint8_t    res1;
+    volatile uint8_t    opCode;
+    volatile uint32_t   res2;
 } _PackedType t_Hmtd;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
@@ -278,9 +317,9 @@ typedef struct
 typedef struct
 {
     t_AdOfTypeContLookup    *p_Frag;
-#if (DPAA_VERSION == 2)
-    uint8_t  	            scratchBpid;
-#endif /* (DPAA_VERSION == 2) */
+#if (DPAA_VERSION == 10)
+    uint8_t                 scratchBpid;
+#endif /* (DPAA_VERSION == 10) */
 } t_IpFragParams;
 
 typedef struct t_IpReassmParams
@@ -320,15 +359,21 @@ typedef struct t_IpReassmParams
 typedef struct{
     bool                    muramAllocate;
     t_Handle                h_Ad;
-    uint32_t			    *p_HmcdTbl;
+    uint32_t                *p_HmcdTbl;
     uint32_t                type;
     bool                    rmv;
     bool                    insrt;
-    bool				    dontParseAfterManip;
+    bool                    dontParseAfterManip;
+    bool                    fieldUpdate;
+    bool                    custom;
+    uint8_t                 *p_InsertData;
+    uint8_t                 *p_UpdateData;
+    uint8_t                 *p_CustomData1;
+    uint8_t                 *p_CustomData2;
     t_Handle                h_NextManip;
     t_Handle                h_PrevManip;
-    uint16_t			    tableSize;
-    bool				    cascadedNext;
+    uint16_t                tableSize;
+    bool                    cascadedNext;
     uint8_t                 *p_Template;
     t_Handle                h_Frag;
     bool                    frag;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index a2b031c..37ffa8d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_pcd.c
 
@@ -52,6 +53,10 @@
 #include "fm_muram_ext.h"
 
 
+/****************************************/
+/*       static functions               */
+/****************************************/
+
 static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
 {
     if(!p_FmPcd->h_Fm)
@@ -79,21 +84,21 @@ static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
 }
 
 static volatile bool blockingFlag = FALSE;
-static void FmPcdIpcMsgCompletionCB(t_Handle   h_FmPcd,
-                                    uint8_t    *p_Msg,
-                                    uint8_t    *p_Reply,
-                                    uint32_t   replyLength,
-                                    t_Error    status)
+static void IpcMsgCompletionCB(t_Handle   h_FmPcd,
+                               uint8_t    *p_Msg,
+                               uint8_t    *p_Reply,
+                               uint32_t   replyLength,
+                               t_Error    status)
 {
     UNUSED(h_FmPcd);UNUSED(p_Msg);UNUSED(p_Reply);UNUSED(replyLength);UNUSED(status);
     blockingFlag = FALSE;
 }
 
-static t_Error FmPcdHandleIpcMsgCB(t_Handle  h_FmPcd,
-                                   uint8_t   *p_Msg,
-                                   uint32_t  msgLength,
-                                   uint8_t   *p_Reply,
-                                   uint32_t  *p_ReplyLength)
+static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
+                               uint8_t   *p_Msg,
+                               uint32_t  msgLength,
+                               uint8_t   *p_Reply,
+                               uint32_t  *p_ReplyLength)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_Error             err = E_OK;
@@ -306,10 +311,6 @@ static t_Error FmPcdHandleIpcMsgCB(t_Handle  h_FmPcd,
            break;
         }
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-       case(FM_PCD_DUMP_REGS):
-            if((err = FM_PCD_DumpRegs(h_FmPcd)) != E_OK)
-                REPORT_ERROR(MINOR, err, NO_MSG);
-            break;
        case(FM_PCD_KG_DUMP_REGS):
             if((err = FM_PCD_KgDumpRegs(h_FmPcd)) != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
@@ -339,6 +340,81 @@ static t_Error FmPcdHandleIpcMsgCB(t_Handle  h_FmPcd,
     return E_OK;
 }
 
+static uint32_t NetEnvLock(t_Handle h_NetEnv)
+{
+    ASSERT_COND(h_NetEnv);
+    return XX_LockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock);
+}
+
+static void NetEnvUnlock(t_Handle h_NetEnv, uint32_t intFlags)
+{
+    ASSERT_COND(h_NetEnv);
+    XX_UnlockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock, intFlags);
+}
+
+static void EnqueueLockToFreeLst(t_FmPcd *p_FmPcd, t_FmPcdLock *p_Lock)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_LockIntrSpinlock(p_FmPcd->h_Spinlock);
+    LIST_AddToTail(&p_Lock->node, &p_FmPcd->freeLocksLst);
+    XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
+}
+
+static t_FmPcdLock * DequeueLockFromFreeLst(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdLock *p_Lock = NULL;
+    uint32_t    intFlags;
+
+    intFlags = XX_LockIntrSpinlock(p_FmPcd->h_Spinlock);
+    if (!LIST_IsEmpty(&p_FmPcd->freeLocksLst))
+    {
+        p_Lock = FM_PCD_LOCK_OBJ(p_FmPcd->freeLocksLst.p_Next);
+        LIST_DelAndInit(&p_Lock->node);
+    }
+    XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
+
+    return p_Lock;
+}
+
+static void EnqueueLockToAcquiredLst(t_FmPcd *p_FmPcd, t_FmPcdLock *p_Lock)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_LockIntrSpinlock(p_FmPcd->h_Spinlock);
+    LIST_AddToTail(&p_Lock->node, &p_FmPcd->acquiredLocksLst);
+    XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
+}
+
+static t_Error FillFreeLocksLst(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdLock *p_Lock;
+    int         i;
+
+    for (i=0; i<10; i++)
+    {
+        p_Lock = (t_FmPcdLock *)XX_Malloc(sizeof(t_FmPcdLock));
+        if (!p_Lock)
+            RETURN_ERROR(MINOR, E_NO_MEMORY, ("FM-PCD lock obj!"));
+        memset(p_Lock, 0, sizeof(t_FmPcdLock));
+        INIT_LIST(&p_Lock->node);
+        p_Lock->h_Spinlock = XX_InitSpinlock();
+        if (!p_Lock->h_Spinlock)
+        {
+            XX_Free(p_Lock);
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("FM-PCD spinlock obj!"));
+        }
+        EnqueueLockToFreeLst(p_FmPcd, p_Lock);
+    }
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+
 void FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId)
 {
     ASSERT_COND(p_FmPcd);
@@ -650,18 +726,6 @@ uint8_t FmPcdGetNetEnvId(t_Handle h_NetEnv)
     return ((t_FmPcdNetEnv*)h_NetEnv)->netEnvId;
 }
 
-static uint32_t NetEnvLock(t_Handle h_NetEnv)
-{
-    ASSERT_COND(h_NetEnv);
-    return XX_LockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock);
-}
-
-static void NetEnvUnlock(t_Handle h_NetEnv, uint32_t intFlags)
-{
-    ASSERT_COND(h_NetEnv);
-    XX_UnlockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock, intFlags);
-}
-
 void FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
 {
     uint32_t    intFlags;
@@ -697,6 +761,80 @@ void FmPcdUnlock(t_Handle h_FmPcd, uint32_t intFlags)
     XX_UnlockIntrSpinlock(((t_FmPcd*)h_FmPcd)->h_Spinlock, intFlags);
 }
 
+t_FmPcdLock * FmPcdAcquireLock(t_Handle h_FmPcd)
+{
+    t_FmPcdLock *p_Lock;
+    ASSERT_COND(h_FmPcd);
+    p_Lock = DequeueLockFromFreeLst((t_FmPcd*)h_FmPcd);
+    if (!p_Lock)
+    {
+        FillFreeLocksLst(h_FmPcd);
+        p_Lock = DequeueLockFromFreeLst((t_FmPcd*)h_FmPcd);
+    }
+
+    if (p_Lock)
+        EnqueueLockToAcquiredLst((t_FmPcd*)h_FmPcd, p_Lock);
+    return p_Lock;
+}
+
+void FmPcdReleaseLock(t_Handle h_FmPcd, t_FmPcdLock *p_Lock)
+{
+    uint32_t intFlags;
+    ASSERT_COND(h_FmPcd);
+    intFlags = FmPcdLock(h_FmPcd);
+    LIST_DelAndInit(&p_Lock->node);
+    FmPcdUnlock(h_FmPcd, intFlags);
+    EnqueueLockToFreeLst((t_FmPcd*)h_FmPcd, p_Lock);
+}
+
+bool FmPcdLockTryLockAll(t_Handle h_FmPcd)
+{
+    uint32_t    intFlags;
+    t_List      *p_Pos, *p_SavedPos=NULL;
+
+    ASSERT_COND(h_FmPcd);
+    intFlags = FmPcdLock(h_FmPcd);
+    LIST_FOR_EACH(p_Pos, &((t_FmPcd*)h_FmPcd)->acquiredLocksLst)
+    {
+        t_FmPcdLock *p_Lock = FM_PCD_LOCK_OBJ(p_Pos);
+        if (!FmPcdLockTryLock(p_Lock))
+        {
+            p_SavedPos = p_Pos;
+            break;
+        }
+    }
+    if (p_SavedPos)
+    {
+        LIST_FOR_EACH(p_Pos, &((t_FmPcd*)h_FmPcd)->acquiredLocksLst)
+        {
+            t_FmPcdLock *p_Lock = FM_PCD_LOCK_OBJ(p_Pos);
+            if (p_Pos == p_SavedPos)
+                break;
+            FmPcdLockUnlock(p_Lock);
+        }
+    }
+    FmPcdUnlock(h_FmPcd, intFlags);
+
+    if (p_SavedPos)
+        return FALSE;
+    return TRUE;
+}
+
+void FmPcdLockUnlockAll(t_Handle h_FmPcd)
+{
+    uint32_t    intFlags;
+    t_List      *p_Pos;
+
+    ASSERT_COND(h_FmPcd);
+    intFlags = FmPcdLock(h_FmPcd);
+    LIST_FOR_EACH(p_Pos, &((t_FmPcd*)h_FmPcd)->acquiredLocksLst)
+    {
+        t_FmPcdLock *p_Lock = FM_PCD_LOCK_OBJ(p_Pos);
+        p_Lock->flag = FALSE;
+    }
+    FmPcdUnlock(h_FmPcd, intFlags);
+}
+
 t_Handle FmPcdGetHcHandle(t_Handle h_FmPcd)
 {
     ASSERT_COND(h_FmPcd);
@@ -709,10 +847,12 @@ bool FmPcdIsAdvancedOffloadSupported(t_Handle h_FmPcd)
     ASSERT_COND(h_FmPcd);
     return ((t_FmPcd*)h_FmPcd)->advancedOffloadSupport;
 }
+/*********************** End of inter-module routines ************************/
+
 
-/**********************************************************************************************************/
-/*              API routines                                                                              */
-/**********************************************************************************************************/
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
 
 t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
 {
@@ -807,6 +947,8 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         FM_PCD_Free(p_FmPcd);
         return NULL;
     }
+    INIT_LIST(&p_FmPcd->freeLocksLst);
+    INIT_LIST(&p_FmPcd->acquiredLocksLst);
 
     p_FmPcd->numOfEnabledGuestPartitionsPcds = 0;
 
@@ -842,10 +984,6 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
 
     if(p_FmPcd->guestId != NCSW_MASTER_ID)
     {
-        uint8_t                 isMasterAlive = 0;
-        t_FmPcdIpcReply         reply;
-        uint32_t                replyLength;
-
         memset(p_FmPcd->fmPcdIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
         if (Sprint (p_FmPcd->fmPcdIpcHandlerModuleName, "FM_PCD_%d_%d", FmGetId(p_FmPcd->h_Fm), NCSW_MASTER_ID) != 10)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
@@ -854,31 +992,35 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
 
         p_FmPcd->h_IpcSession = XX_IpcInitSession(p_FmPcd->fmPcdIpcHandlerModuleName, p_FmPcd->fmPcdModuleName);
-        if (p_FmPcd->h_IpcSession == NULL)
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("FM PCD Guest %d IPC session", p_FmPcd->guestId));
+        if (p_FmPcd->h_IpcSession)
+        {
+            t_FmPcdIpcReply         reply;
+            uint32_t                replyLength;
+            uint8_t                 isMasterAlive = 0;
 
-        memset(&msg, 0, sizeof(msg));
-        memset(&reply, 0, sizeof(reply));
-        msg.msgId = FM_PCD_MASTER_IS_ALIVE;
-        msg.msgBody[0] = p_FmPcd->guestId;
-        blockingFlag = TRUE;
+            memset(&msg, 0, sizeof(msg));
+            memset(&reply, 0, sizeof(reply));
+            msg.msgId = FM_PCD_MASTER_IS_ALIVE;
+            msg.msgBody[0] = p_FmPcd->guestId;
+            blockingFlag = TRUE;
 
-        do
-        {
-            replyLength = sizeof(uint32_t) + sizeof(isMasterAlive);
-            if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                         (uint8_t*)&msg,
-                                         sizeof(msg.msgId)+sizeof(p_FmPcd->guestId),
-                                         (uint8_t*)&reply,
-                                         &replyLength,
-                                         FmPcdIpcMsgCompletionCB,
-                                         h_FmPcd)) != E_OK)
-                REPORT_ERROR(MAJOR, err, NO_MSG);
-            while(blockingFlag) ;
-            if(replyLength != (sizeof(uint32_t) + sizeof(isMasterAlive)))
-                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-            isMasterAlive = *(uint8_t*)(reply.replyBody);
-        } while (!isMasterAlive);
+            do
+            {
+                replyLength = sizeof(uint32_t) + sizeof(isMasterAlive);
+                if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                             (uint8_t*)&msg,
+                                             sizeof(msg.msgId)+sizeof(p_FmPcd->guestId),
+                                             (uint8_t*)&reply,
+                                             &replyLength,
+                                             IpcMsgCompletionCB,
+                                             h_FmPcd)) != E_OK)
+                    REPORT_ERROR(MAJOR, err, NO_MSG);
+                while (blockingFlag) ;
+                if (replyLength != (sizeof(uint32_t) + sizeof(isMasterAlive)))
+                    REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+                isMasterAlive = *(uint8_t*)(reply.replyBody);
+            } while (!isMasterAlive);
+        }
     }
 
     CHECK_INIT_PARAMETERS(p_FmPcd, CheckFmPcdParameters);
@@ -910,7 +1052,7 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
         memset(p_FmPcd->fmPcdModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
         if(Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm),NCSW_MASTER_ID) != 10)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
-        err = XX_IpcRegisterMsgHandler(p_FmPcd->fmPcdModuleName, FmPcdHandleIpcMsgCB, p_FmPcd, FM_PCD_MAX_REPLY_SIZE);
+        err = XX_IpcRegisterMsgHandler(p_FmPcd->fmPcdModuleName, IpcMsgHandlerCB, p_FmPcd, FM_PCD_MAX_REPLY_SIZE);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
@@ -1033,28 +1175,19 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd)
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
-    {
-        if(p_FmPcd->p_FmPcdKg)
-            KgEnable(p_FmPcd);
-
-        if(p_FmPcd->p_FmPcdPlcr)
-            PlcrEnable(p_FmPcd);
-
-        if(p_FmPcd->p_FmPcdPrs)
-            PrsEnable(p_FmPcd);
+    if (p_FmPcd->enabled)
+        return E_OK;
 
-        p_FmPcd->enabled = TRUE;
-    }
-    else
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        p_FmPcd->h_IpcSession)
     {
         uint8_t         enabled;
         t_FmPcdIpcMsg   msg;
         t_FmPcdIpcReply reply;
         uint32_t        replyLength;
 
-        memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_MASTER_IS_ENABLED;
         replyLength = sizeof(uint32_t) + sizeof(enabled);
         if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
@@ -1070,7 +1203,23 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd)
         p_FmPcd->enabled = (bool)!!(*(uint8_t*)(reply.replyBody));
         if (!p_FmPcd->enabled)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM-PCD master should be enabled first!"));
+
+        return E_OK;
     }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without IPC!"));
+
+    if (p_FmPcd->p_FmPcdKg)
+        KgEnable(p_FmPcd);
+
+    if (p_FmPcd->p_FmPcdPlcr)
+        PlcrEnable(p_FmPcd);
+
+    if (p_FmPcd->p_FmPcdPrs)
+        PrsEnable(p_FmPcd);
+
+    p_FmPcd->enabled = TRUE;
 
     return E_OK;
 }
@@ -1079,47 +1228,59 @@ t_Error FM_PCD_Disable(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_Error             err = E_OK;
-    t_FmPcdIpcMsg       msg;
-    t_FmPcdIpcReply     reply;
-    uint32_t            replyLength;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    if (!p_FmPcd->enabled)
+        return E_OK;
+
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        p_FmPcd->h_IpcSession)
     {
-        if(p_FmPcd->numOfEnabledGuestPartitionsPcds != 0)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to disable a master partition PCD while guest partitions are still enabled."));
+        t_FmPcdIpcMsg       msg;
+        t_FmPcdIpcReply     reply;
+        uint32_t            replyLength;
 
-        if(p_FmPcd->p_FmPcdKg)
-             KgDisable(p_FmPcd);
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_PCD_GUEST_DISABLE;
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        if (reply.error == E_OK)
+            p_FmPcd->enabled = FALSE;
 
-        if(p_FmPcd->p_FmPcdPlcr)
-            PlcrDisable(p_FmPcd);
+        return (t_Error)(reply.error);
+    }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without IPC!"));
 
-        if(p_FmPcd->p_FmPcdPrs)
-            PrsDisable(p_FmPcd);
+    if (p_FmPcd->numOfEnabledGuestPartitionsPcds != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("Trying to disable a master partition PCD while"
+                      "guest partitions are still enabled!"));
 
-        p_FmPcd->enabled = FALSE;
+    if (p_FmPcd->p_FmPcdKg)
+         KgDisable(p_FmPcd);
 
-        return E_OK;
-    }
+    if (p_FmPcd->p_FmPcdPlcr)
+        PlcrDisable(p_FmPcd);
 
-    memset(&msg, 0, sizeof(msg));
-    msg.msgId = FM_PCD_GUEST_DISABLE;
-    memset(&reply, 0, sizeof(reply));
-    replyLength = sizeof(uint32_t);
-    if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId),
-                                 (uint8_t*)&reply,
-                                 &replyLength,
-                                 NULL,
-                                 NULL)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    if (replyLength != sizeof(uint32_t))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+    if (p_FmPcd->p_FmPcdPrs)
+        PrsDisable(p_FmPcd);
 
-    return (t_Error)(reply.error);
+    p_FmPcd->enabled = FALSE;
+
+    return E_OK;
 }
 
 t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams  *p_NetEnvParams)
@@ -1132,18 +1293,20 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     uint8_t                 ipsecAhUnit = 0,ipsecEspUnit = 0;
     bool                    ipsecAhExists = FALSE, ipsecEspExists = FALSE, shim1Selected = FALSE;
     uint8_t                 hdrNum;
+    t_FmPcdNetEnvParams     modifiedNetEnvParams;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_STATE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_NetEnvParams, E_NULL_POINTER, NULL);
 
     intFlags = FmPcdLock(p_FmPcd);
 
     /* find a new netEnv */
-    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
-        if(!p_FmPcd->netEnvs[i].used)
+    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
+        if (!p_FmPcd->netEnvs[i].used)
             break;
 
-    if(i== FM_MAX_NUM_OF_PORTS)
+    if (i== FM_MAX_NUM_OF_PORTS)
     {
         REPORT_ERROR(MAJOR, E_FULL,("No more than %d netEnv's allowed.", FM_MAX_NUM_OF_PORTS));
         FmPcdUnlock(p_FmPcd, intFlags);
@@ -1151,14 +1314,14 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     }
 
     p_FmPcd->netEnvs[i].used = TRUE;
-
-    if (!TRY_LOCK(NULL, &p_FmPcd->netEnvs[i].lock))
-    {
-        FmPcdUnlock(p_FmPcd, intFlags);
-        return NULL;
-    }
     FmPcdUnlock(p_FmPcd, intFlags);
 
+    /* As anyone doesn't have handle of this netEnv yet, no need
+       to protect it with spinlocks */
+
+    memcpy(&modifiedNetEnvParams, p_NetEnvParams, sizeof(t_FmPcdNetEnvParams));
+    p_NetEnvParams = &modifiedNetEnvParams;
+
     netEnvCurrId = (uint8_t)i;
 
     /* clear from previous use */
@@ -1169,28 +1332,27 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     p_FmPcd->netEnvs[netEnvCurrId].netEnvId = netEnvCurrId;
     p_FmPcd->netEnvs[netEnvCurrId].h_FmPcd = p_FmPcd;
 
-
     p_FmPcd->netEnvs[netEnvCurrId].clsPlanGrpId = ILLEGAL_CLS_PLAN;
 
     /* check that header with opt is not interchanged with the same header */
-    for (i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+    for (i = 0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
             && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
     {
-        for (k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
+        for (k = 0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
             && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
         {
             /* if an option exists, check that other headers are not the same header
             without option */
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt)
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt)
             {
-                for (j=0; (j < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
+                for (j = 0; (j < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr != HEADER_TYPE_NONE); j++)
                 {
                     if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
                         !p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].opt)
                     {
-                        REPORT_ERROR(MINOR, E_FULL, ("Illegal unit - header with opt may not be interchangeable with the same header without opt"));
-                        RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                        REPORT_ERROR(MINOR, E_FULL,
+                                ("Illegal unit - header with opt may not be interchangeable with the same header without opt"));
                         return NULL;
                     }
                 }
@@ -1199,23 +1361,22 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     }
 
     /* Specific headers checking  */
-    for(i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+    for (i = 0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
     {
-        for(k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
+        for (k = 0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
             && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
         {
             /* Some headers pairs may not be defined on different units as the parser
             doesn't distinguish */
             /* IPSEC_AH and IPSEC_SPI can't be 2 units,  */
             /* check that header with opt is not interchanged with the same header */
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_AH)
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_AH)
             {
                 if (ipsecEspExists && (ipsecEspUnit != i))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
-                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
-                   return NULL;
+                    return NULL;
                 }
                 else
                 {
@@ -1223,12 +1384,11 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     ipsecAhExists = TRUE;
                 }
             }
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_ESP)
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_ESP)
             {
                 if (ipsecAhExists && (ipsecAhUnit != i))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
-                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                     return NULL;
                 }
                 else
@@ -1238,7 +1398,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 }
             }
             /* ENCAP_ESP  */
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_ENCAP_ESP)
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_ENCAP_ESP)
             {
                 /* IPSec UDP encapsulation is currently set to use SHIM1 */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_UDP_ENCAP_ESP;
@@ -1247,7 +1407,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
             }
             /* IP FRAG  */
-            if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
+            if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
                 (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV4_FRAG_1))
             {
                 /* If IPv4+Frag, we need to set 2 units - SHIM 2 and IPv4. We first set SHIM2, and than check if
@@ -1267,8 +1427,8 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
                 }
             }
-            if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv6) &&
-                    (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV6_FRAG_1))
+            if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv6) &&
+                (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV6_FRAG_1))
             {
                 /* If IPv6+Frag, we need to set 2 units - SHIM 2 and IPv6. We first set SHIM2, and than check if
                  * IPv4 exists. If so we don't need to set an extra unit
@@ -1277,52 +1437,32 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv6;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV6_FRAG_1;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
 
-                for (j=0; (j < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
-                         (p_FmPcd->netEnvs[netEnvCurrId].units[j].hdrs[0].hdr != HEADER_TYPE_USER_DEFINED_SHIM2); j++) ;
-
-                if (j == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+                /* check if IPv6 header exists by itself */
+                if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
                 {
-                    p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
-                    p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
-                    /* check if IPv6 header exists by itself */
-                    if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
-                    {
-                        p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv6;
-                        p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
-                    }
-                }
-                else
-                {
-                    if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
-                    {
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = HEADER_TYPE_IPv6;
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = 0;
-                    }
-                    else
-                    {
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].hdr;
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].opt;
-                    }
+                    p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv6;
+                    p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
                 }
             }
         }
     }
 
     /* if private header (shim), check that no other headers specified */
-    for (i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+    for (i = 0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
     {
-        if(IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
+        if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
             {
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header may not be interchanged with other headers"));
-                RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                 return NULL;
             }
     }
 
-    for(i=0; i<p_NetEnvParams->numOfDistinctionUnits;i++)
+    for (i = 0; i < p_NetEnvParams->numOfDistinctionUnits; i++)
     {
         if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
             switch(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
@@ -1331,7 +1471,6 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     if (shim1Selected)
                     {
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header cannot be selected with UDP_IPSEC_ESP"));
-                        RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                         return NULL;
                     }
                     shim1Selected = TRUE;
@@ -1355,20 +1494,19 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     /* define a set of hardware parser LCV's according to the defined netenv */
 
     /* set an array of LCV's for each header in the netEnv */
-    for (i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+    for (i = 0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
     {
         /* private headers have no LCV in the hard parser */
         if (!IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
         {
-            for (k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
+            for (k = 0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                     && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
             {
                 GET_PRS_HDR_NUM(hdrNum, p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr);
                 if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
                 {
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
-                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                     return NULL;
                 }
                 p_FmPcd->netEnvs[netEnvCurrId].lcvs[hdrNum] |= p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
@@ -1376,8 +1514,6 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
         }
     }
 
-    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
-
     p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock = XX_InitSpinlock();
     if (!p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock)
     {
@@ -1389,35 +1525,34 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
 
 t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv)
 {
-    t_FmPcdNetEnv	*p_NetEnv = (t_FmPcdNetEnv*)h_NetEnv;
-    t_FmPcd     	*p_FmPcd = p_NetEnv->h_FmPcd;
-
-    uint8_t     netEnvId = p_NetEnv->netEnvId;
+    t_FmPcdNetEnv   *p_NetEnv = (t_FmPcdNetEnv*)h_NetEnv;
+    t_FmPcd         *p_FmPcd = p_NetEnv->h_FmPcd;
+    uint32_t        intFlags;
+    uint8_t         netEnvId = p_NetEnv->netEnvId;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if (!TRY_LOCK(p_FmPcd->h_Spinlock, &p_FmPcd->netEnvs[netEnvId].lock))
-        return ERROR_CODE(E_BUSY);
-
     /* check that no port is bound to this netEnv */
     if(p_FmPcd->netEnvs[netEnvId].owners)
     {
-       RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
-       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
+        RETURN_ERROR(MINOR, E_INVALID_STATE,
+                ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
     }
-    p_FmPcd->netEnvs[netEnvId].used= FALSE;
+
+    intFlags = FmPcdLock(p_FmPcd);
+
+    p_FmPcd->netEnvs[netEnvId].used = FALSE;
     p_FmPcd->netEnvs[netEnvId].clsPlanGrpId = ILLEGAL_CLS_PLAN;
 
     memset(p_FmPcd->netEnvs[netEnvId].units, 0, sizeof(t_FmPcdIntDistinctionUnit)*FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
     memset(p_FmPcd->netEnvs[netEnvId].unitsVectors, 0, sizeof(uint32_t)*FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
     memset(p_FmPcd->netEnvs[netEnvId].lcvs, 0, sizeof(uint32_t)*FM_PCD_PRS_NUM_OF_HDRS);
 
-    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
-
     if (p_FmPcd->netEnvs[netEnvId].h_Spinlock)
         XX_FreeSpinlock(p_FmPcd->netEnvs[netEnvId].h_Spinlock);
 
+    FmPcdUnlock(p_FmPcd, intFlags);
     return E_OK;
 }
 
@@ -1453,36 +1588,12 @@ t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd)
 uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                replyLength, outCounter = 0;
-    t_FmPcdIpcMsg           msg;
+    uint32_t                outCounter = 0;
     t_Error                 err;
-    t_FmPcdIpcReply         reply;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-    {
-        memset(&msg, 0, sizeof(msg));
-        memset(&reply, 0, sizeof(reply));
-        msg.msgId = FM_PCD_GET_COUNTER;
-        memcpy(msg.msgBody, (uint8_t *)&counter, sizeof(uint32_t));
-        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) +sizeof(uint32_t),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (replyLength != sizeof(uint32_t) + sizeof(uint32_t))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-
-        memcpy((uint8_t*)&outCounter, reply.replyBody, sizeof(uint32_t));
-        return outCounter;
-    }
-
     switch(counter)
     {
         case(e_FM_PCD_KG_COUNTERS_TOTAL):
@@ -1491,25 +1602,43 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
                 return 0;
             }
+            if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+                !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs &&
+                !p_FmPcd->h_IpcSession)
+            {
+                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+                return 0;
+            }
             break;
+
         case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
         case(e_FM_PCD_PLCR_COUNTERS_RED):
         case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
         case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
         case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
         case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
-            if(!p_FmPcd->p_FmPcdPlcr)
+            if (!p_FmPcd->p_FmPcdPlcr)
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
                 return 0;
             }
+            if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+                !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
+                !p_FmPcd->h_IpcSession)
+            {
+                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+                return 0;
+            }
             /* check that counters are enabled */
-            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+            if (!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
                 return 0;
             }
             break;
+
         case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
         case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
         case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
@@ -1532,11 +1661,46 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
                 return 0;
             }
+            if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+                !p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs &&
+                !p_FmPcd->h_IpcSession)
+            {
+                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+                return 0;
+            }
             break;
         default:
             REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
             return 0;
     }
+
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        t_FmPcdIpcMsg           msg;
+        t_FmPcdIpcReply         reply;
+        uint32_t                replyLength;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_PCD_GET_COUNTER;
+        memcpy(msg.msgBody, (uint8_t *)&counter, sizeof(uint32_t));
+        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) +sizeof(uint32_t),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t) + sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+
+        memcpy((uint8_t*)&outCounter, reply.replyBody, sizeof(uint32_t));
+        return outCounter;
+    }
+
     switch(counter)
     {
         case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
@@ -1600,35 +1764,24 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
 t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcMsg       msg;
+    t_Error             err = E_OK;
 
     DECLARE_DUMP;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-    {
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_DUMP_REGS;
-        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId),
-                                 NULL,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    }
     if (p_FmPcd->p_FmPcdKg)
-        return FM_PCD_KgDumpRegs(h_FmPcd);
+        err |= FM_PCD_KgDumpRegs(h_FmPcd);
     if (p_FmPcd->p_FmPcdPlcr)
-        return FM_PCD_PlcrDumpRegs(h_FmPcd);
+        err |= FM_PCD_PlcrDumpRegs(h_FmPcd);
     if (p_FmPcd->p_FmPcdPrs)
-        return FM_PCD_PrsDumpRegs(h_FmPcd);
-    return E_OK;
+        err |= FM_PCD_PrsDumpRegs(h_FmPcd);
+
+    return err;
 }
 
-t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd)
+t_Error FM_PCD_HcDumpRegs(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 712743d..918e0a1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_pcd.h
 
@@ -42,15 +43,24 @@
 #include "error_ext.h"
 #include "list_ext.h"
 #include "fm_pcd_ext.h"
-
+#include "fm_common.h"
 
 #define __ERR_MODULE__  MODULE_FM_PCD
 
 
-/**************************************************************************//**
- @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
- @{
-*//***************************************************************************/
+/****************************/
+/* Defaults                 */
+/****************************/
+#define DEFAULT_plcrAutoRefresh                 FALSE
+#define DEFAULT_prsMaxParseCycleLimit           0
+#define DEFAULT_fmPcdKgErrorExceptions          (FM_PCD_EX_KG_DOUBLE_ECC | FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+#define DEFAULT_fmPcdPlcrErrorExceptions        (FM_PCD_EX_PLCR_DOUBLE_ECC | FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+#define DEFAULT_fmPcdPlcrExceptions             0
+#define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC)
+
+#define DEFAULT_fmPcdPrsExceptions              FM_PCD_EX_PRS_SINGLE_ECC
+#define DEFAULT_numOfUsedProfilesPerWindow      16
+#define DEFAULT_numOfSharedPlcrProfiles         4
 
 /****************************/
 /* Network defines          */
@@ -107,204 +117,25 @@ switch(exception){                                                  \
 /****************************/
 /* Parser defines           */
 /****************************/
-/* masks */
-#define PRS_ERR_CAP                         0x80000000
-#define PRS_ERR_TYPE_DOUBLE                 0x40000000
-#define PRS_ERR_SINGLE_ECC_CNT_MASK         0x00FF0000
-#define PRS_ERR_ADDR_MASK                   0x000001FF
-#define FM_PCD_PRS_RPIMAC_EN                0x00000001
-#define FM_PCD_PRS_SINGLE_ECC               0x00004000
-#define FM_PCD_PRS_PORT_IDLE_STS            0xffff0000
-#define FM_PCD_PRS_DOUBLE_ECC               0x00004000
-#define FM_PCD_PRS_PPSC_ALL_PORTS           0xffff0000
-
-/* others */
-#define PRS_MAX_CYCLE_LIMIT                 8191
-#define PRS_SW_DATA                         0x00000800
-#define PRS_REGS_OFFSET                     0x00000840
-
-#define GET_FM_PCD_PRS_PORT_ID(prsPortId,hardwarePortId) \
-    prsPortId = (uint8_t)(hardwarePortId & 0x0f)
-
-#define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
-    bitMask = 0x80000000>>prsPortId
+#define FM_PCD_PRS_SINGLE_ECC                 0x00004000
+#define FM_PCD_PRS_DOUBLE_ECC                 0x00004000
+#define PRS_MAX_CYCLE_LIMIT                   8191
 
 /***********************************************************************/
 /*          Keygen defines                                             */
 /***********************************************************************/
-/* Masks */
-#define FM_PCD_KG_KGGCR_EN                      0x80000000
-#define KG_SCH_GEN_VALID                        0x80000000
-#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
-#define KG_ERR_CAP                              0x80000000
-#define KG_ERR_TYPE_DOUBLE                      0x40000000
-#define KG_ERR_ADDR_MASK                        0x00000FFF
-#define FM_PCD_KG_DOUBLE_ECC                    0x80000000
-#define FM_PCD_KG_KEYSIZE_OVERFLOW              0x40000000
-#define KG_SCH_MODE_EN                          0x80000000
-
-/* shifts */
-#define FM_PCD_KG_PE_CPP_MASK_SHIFT             16
-#define FM_PCD_KG_KGAR_WSEL_SHIFT               8
-
-/* others */
-#define KG_DOUBLE_MEANING_REGS_OFFSET           0x100
-#define NO_VALIDATION                           0x70
-#define KG_ACTION_REG_TO                        1024
-#define KG_MAX_PROFILE                          255
-#define SCHEME_ALWAYS_DIRECT                    0xFFFFFFFF
+#define FM_PCD_KG_DOUBLE_ECC                  0x80000000
+#define FM_PCD_KG_KEYSIZE_OVERFLOW            0x40000000
 
 /***********************************************************************/
 /*          Policer defines                                            */
 /***********************************************************************/
-
-/* masks */
-#define FM_PCD_PLCR_PEMODE_PI                 0x80000000
-#define FM_PCD_PLCR_PEMODE_CBLND              0x40000000
-#define FM_PCD_PLCR_PEMODE_ALG_MASK           0x30000000
-#define FM_PCD_PLCR_PEMODE_ALG_RFC2698        0x10000000
-#define FM_PCD_PLCR_PEMODE_ALG_RFC4115        0x20000000
-#define FM_PCD_PLCR_PEMODE_DEFC_MASK          0x0C000000
-#define FM_PCD_PLCR_PEMODE_DEFC_Y             0x04000000
-#define FM_PCD_PLCR_PEMODE_DEFC_R             0x08000000
-#define FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE      0x0C000000
-#define FM_PCD_PLCR_PEMODE_OVCLR_MASK         0x03000000
-#define FM_PCD_PLCR_PEMODE_OVCLR_Y            0x01000000
-#define FM_PCD_PLCR_PEMODE_OVCLR_R            0x02000000
-#define FM_PCD_PLCR_PEMODE_OVCLR_G_NC         0x03000000
-#define FM_PCD_PLCR_PEMODE_PKT                0x00800000
-#define FM_PCD_PLCR_PEMODE_FPP_MASK           0x001F0000
-#define FM_PCD_PLCR_PEMODE_FPP_SHIFT          16
-#define FM_PCD_PLCR_PEMODE_FLS_MASK           0x0000F000
-#define FM_PCD_PLCR_PEMODE_FLS_L2             0x00003000
-#define FM_PCD_PLCR_PEMODE_FLS_L3             0x0000B000
-#define FM_PCD_PLCR_PEMODE_FLS_L4             0x0000E000
-#define FM_PCD_PLCR_PEMODE_FLS_FULL           0x0000F000
-#define FM_PCD_PLCR_PEMODE_RBFLS              0x00000800
-#define FM_PCD_PLCR_PEMODE_TRA                0x00000004
-#define FM_PCD_PLCR_PEMODE_TRB                0x00000002
-#define FM_PCD_PLCR_PEMODE_TRC                0x00000001
+#define FM_PCD_PLCR_GCR_STEN                  0x40000000
 #define FM_PCD_PLCR_DOUBLE_ECC                0x80000000
 #define FM_PCD_PLCR_INIT_ENTRY_ERROR          0x40000000
 #define FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE   0x80000000
 #define FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE    0x40000000
 
-#define FM_PCD_PLCR_NIA_VALID                 0x80000000
-
-#define FM_PCD_PLCR_GCR_EN                    0x80000000
-#define FM_PCD_PLCR_GCR_STEN                  0x40000000
-#define FM_PCD_PLCR_GCR_DAR                   0x20000000
-#define FM_PCD_PLCR_GCR_DEFNIA                0x00FFFFFF
-#define FM_PCD_PLCR_NIA_ABS                   0x00000100
-
-#define FM_PCD_PLCR_GSR_BSY                   0x80000000
-#define FM_PCD_PLCR_GSR_DQS                   0x60000000
-#define FM_PCD_PLCR_GSR_RPB                   0x20000000
-#define FM_PCD_PLCR_GSR_FQS                   0x0C000000
-#define FM_PCD_PLCR_GSR_LPALG                 0x0000C000
-#define FM_PCD_PLCR_GSR_LPCA                  0x00003000
-#define FM_PCD_PLCR_GSR_LPNUM                 0x000000FF
-
-#define FM_PCD_PLCR_EVR_PSIC                  0x80000000
-#define FM_PCD_PLCR_EVR_AAC                   0x40000000
-
-#define FM_PCD_PLCR_PAR_PSI                   0x20000000
-#define FM_PCD_PLCR_PAR_PNUM                  0x00FF0000
-/* PWSEL Selctive select options */
-#define FM_PCD_PLCR_PAR_PWSEL_PEMODE          0x00008000    /* 0 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEGNIA          0x00004000    /* 1 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEYNIA          0x00002000    /* 2 */
-#define FM_PCD_PLCR_PAR_PWSEL_PERNIA          0x00001000    /* 3 */
-#define FM_PCD_PLCR_PAR_PWSEL_PECIR           0x00000800    /* 4 */
-#define FM_PCD_PLCR_PAR_PWSEL_PECBS           0x00000400    /* 5 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEPIR_EIR       0x00000200    /* 6 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEPBS_EBS       0x00000100    /* 7 */
-#define FM_PCD_PLCR_PAR_PWSEL_PELTS           0x00000080    /* 8 */
-#define FM_PCD_PLCR_PAR_PWSEL_PECTS           0x00000040    /* 9 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEPTS_ETS       0x00000020    /* 10 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEGPC           0x00000010    /* 11 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEYPC           0x00000008    /* 12 */
-#define FM_PCD_PLCR_PAR_PWSEL_PERPC           0x00000004    /* 13 */
-#define FM_PCD_PLCR_PAR_PWSEL_PERYPC          0x00000002    /* 14 */
-#define FM_PCD_PLCR_PAR_PWSEL_PERRPC          0x00000001    /* 15 */
-
-#define FM_PCD_PLCR_PAR_PMR_BRN_1TO1          0x0000   /* - Full bit replacement. {PBNUM[0:N-1]
-                                                           1-> 2^N specific locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_2TO2          0x1      /* - {PBNUM[0:N-2],PNUM[N-1]}.
-                                                           2-> 2^(N-1) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_4TO4          0x2      /* - {PBNUM[0:N-3],PNUM[N-2:N-1]}.
-                                                           4-> 2^(N-2) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_8TO8          0x3      /* - {PBNUM[0:N-4],PNUM[N-3:N-1]}.
-                                                           8->2^(N-3) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_16TO16        0x4      /* - {PBNUM[0:N-5],PNUM[N-4:N-1]}.
-                                                           16-> 2^(N-4) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_32TO32        0x5      /* {PBNUM[0:N-6],PNUM[N-5:N-1]}.
-                                                           32-> 2^(N-5) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_64TO64        0x6      /* {PBNUM[0:N-7],PNUM[N-6:N-1]}.
-                                                           64-> 2^(N-6) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_128TO128      0x7      /* {PBNUM[0:N-8],PNUM[N-7:N-1]}.
-                                                            128-> 2^(N-7) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_256TO256      0x8      /* - No bit replacement for N=8. {PNUM[N-8:N-1]}.
-                                                            When N=8 this option maps all 256 profiles by the DISPATCH bus into one group. */
-
-#define FM_PCD_PLCR_PMR_V                     0x80000000
-#define PLCR_ERR_ECC_CAP                      0x80000000
-#define PLCR_ERR_ECC_TYPE_DOUBLE              0x40000000
-#define PLCR_ERR_ECC_PNUM_MASK                0x00000FF0
-#define PLCR_ERR_ECC_OFFSET_MASK              0x0000000F
-
-#define PLCR_ERR_UNINIT_CAP                   0x80000000
-#define PLCR_ERR_UNINIT_NUM_MASK              0x000000FF
-#define PLCR_ERR_UNINIT_PID_MASK              0x003f0000
-#define PLCR_ERR_UNINIT_ABSOLUTE_MASK         0x00008000
-
-/* shifts */
-#define PLCR_ERR_ECC_PNUM_SHIFT               4
-#define PLCR_ERR_UNINIT_PID_SHIFT             16
-
-#define FM_PCD_PLCR_PMR_BRN_SHIFT             16
-
-/* others */
-#define WAIT_FOR_PLCR_EVR_AAC \
-{\
-    uint32_t count = 0; \
-    uint32_t tmpReg32; \
-    while (count < FM_PCD_PLCR_POLL) \
-    { \
-        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_evr);\
-        if (!( tmpReg32 & FM_PCD_PLCR_EVR_AAC)) break;\
-        count++;\
-    }\
-}
-
-#define WAIT_FOR_PLCR_PAR_GO \
-{\
-    uint32_t count = 0; \
-    uint32_t tmpReg32; \
-    while (count < FM_PCD_PLCR_POLL) \
-    { \
-        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_par);\
-        if (!( tmpReg32 & FM_PCD_PLCR_PAR_GO)) break;\
-        count++; \
-    }\
-}
-
-#define PLCR_PORT_WINDOW_SIZE(hardwarePortId)
-
-/****************************/
-/* Defaults                 */
-/****************************/
-#define DEFAULT_plcrAutoRefresh                 FALSE
-#define DEFAULT_prsMaxParseCycleLimit           0
-#define DEFAULT_fmPcdKgErrorExceptions          (FM_PCD_EX_KG_DOUBLE_ECC | FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
-#define DEFAULT_fmPcdPlcrErrorExceptions        (FM_PCD_EX_PLCR_DOUBLE_ECC | FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
-#define DEFAULT_fmPcdPlcrExceptions             0
-#define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC)
-
-#define DEFAULT_fmPcdPrsExceptions              FM_PCD_EX_PRS_SINGLE_ECC
-#define DEFAULT_numOfUsedProfilesPerWindow      16
-#define DEFAULT_numOfSharedPlcrProfiles         4
-
 /***********************************************************************/
 /*          Memory map                                                 */
 /***********************************************************************/
@@ -456,6 +287,12 @@ typedef struct {
 } t_NetEnvParams;
 
 typedef struct {
+    bool            allocated;
+    uint8_t         ownerId; /* guestId for KG in multi-partition only,
+                                portId for PLCR in any environment */
+} t_FmPcdAllocMng;
+
+typedef struct {
     volatile bool       lock;
     bool                used;
     uint8_t             owners;
@@ -467,10 +304,9 @@ typedef struct {
 } t_FmPcdKgClsPlanGrp;
 
 typedef struct {
-	t_Handle			h_FmPcd;
-	uint8_t				schemeId;
-	volatile bool       lock;
-    t_Handle            h_Spinlock;
+    t_Handle            h_FmPcd;
+    uint8_t             schemeId;
+    t_FmPcdLock         *p_Lock;
     bool                valid;
     uint8_t             netEnvId;
     uint8_t             owners;
@@ -487,23 +323,16 @@ typedef struct {
     bool                extractedOrs;
     uint8_t             bitOffsetInPlcrProfile;
     bool                directPlcr;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool                vspe;
 #endif
 } t_FmPcdKgScheme;
 
 typedef struct {
-    bool            allocated;
-    uint8_t         ownerId; /* guestId for KG in multi-partition only,
-                                portId for PLCR in any environment */
-} t_FmPcdAllocMng;
-
-typedef struct {
     t_FmPcdKgRegs       *p_FmPcdKgRegs;
     uint32_t            schemeExceptionsBitMask;
     uint8_t             numOfSchemes;
     t_Handle            h_HwSpinlock;
-    t_Handle            h_SwSpinlock;
     uint8_t             schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
     t_FmPcdKgScheme     schemes[FM_PCD_KG_NUM_OF_SCHEMES];
     t_FmPcdKgClsPlanGrp clsPlanGrps[FM_MAX_NUM_OF_PORTS];
@@ -519,11 +348,10 @@ typedef struct {
 } t_FmPcdPlcrMapParam;
 
 typedef struct {
-	uint16_t							absoluteProfileId;
-	t_Handle							h_FmPcd;
+    uint16_t                            absoluteProfileId;
+    t_Handle                            h_FmPcd;
     bool                                valid;
-    /*volatile bool                       lock;*/
-    t_Handle                            h_Spinlock;
+    t_FmPcdLock                         *p_Lock;
     t_FmPcdAllocMng                     profilesMng;
     uint8_t                             pointedOwners;
     uint32_t                            requiredAction;
@@ -571,9 +399,8 @@ typedef struct {
 } t_FmPcdNetEnvAliases;
 
 typedef struct {
-	uint8_t						netEnvId;
-	t_Handle					h_FmPcd;
-    volatile bool               lock;
+    uint8_t                     netEnvId;
+    t_Handle                    h_FmPcd;
     t_Handle                    h_Spinlock;
     bool                        used;
     uint8_t                     owners;
@@ -590,14 +417,18 @@ typedef struct {
     uint16_t                    prsMaxParseCycleLimit;
 } t_FmPcdDriverParam;
 
-
 typedef struct {
     t_Handle                    h_Fm;
     t_Handle                    h_FmMuram;
     t_FmRevisionInfo            fmRevInfo;
+
     uint64_t                    physicalMuramBase;
+
     volatile bool               lock;
     t_Handle                    h_Spinlock;
+    t_List                      freeLocksLst;
+    t_List                      acquiredLocksLst;
+
     t_Handle                    h_IpcSession; /* relevant for guest only */
     bool                        enabled;
     uint8_t                     guestId;            /**< Guest Partition Id */
@@ -661,6 +492,9 @@ t_Error     FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t g
 /* only for SINGLE partittion */
 t_Error     KgBindPortToSchemes(t_Handle h_FmPcd , uint8_t hardwarePortId, uint32_t spReg);
 
+t_FmPcdLock *FmPcdAcquireLock(t_Handle h_FmPcd);
+void        FmPcdReleaseLock(t_Handle h_FmPcd, t_FmPcdLock *p_Lock);
+
 t_Handle    PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     PlcrInit(t_FmPcd *p_FmPcd);
 t_Error     PlcrFree(t_FmPcd *p_FmPcd);
@@ -694,7 +528,7 @@ t_Error     FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_F
 t_Handle    FmPcdManipApplSpecificBuild(void);
 bool        FmPcdManipIsCapwapApplSpecific(t_Handle h_Manip);
 #endif /* FM_CAPWAP_SUPPORT */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 void *      FrmReplicGetSourceTableDescriptor(t_Handle h_ReplicGroup);
 void        FrmReplicUpdateGroupOwner(t_Handle h_ReplicGroup, bool add, bool fullUpdate, t_Handle h_FmPcdCcNode);
 void        FrmReplicUpdateAdContLookupForCc(t_Handle h_ReplicGroup, t_Handle p_Ad, t_Handle *h_AdNew);
@@ -703,7 +537,7 @@ void        FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle   h_Node,
                                                      t_Handle   h_ReplicGroup,
                                                      t_List     *p_AdTables,
                                                      uint32_t   *p_NumOfAdTables);
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo);
 t_CcNodeInformation* FmPcdCcFindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info);
@@ -727,5 +561,39 @@ static __inline__ uint64_t FmPcdGetMuramPhysBase(t_Handle h_FmPcd)
     return p_FmPcd->physicalMuramBase;
 }
 
+static __inline__ uint32_t FmPcdLockSpinlock(t_FmPcdLock *p_Lock)
+{
+    ASSERT_COND(p_Lock);
+    return XX_LockIntrSpinlock(p_Lock->h_Spinlock);
+}
+
+static __inline__ void FmPcdUnlockSpinlock(t_FmPcdLock *p_Lock, uint32_t flags)
+{
+    ASSERT_COND(p_Lock);
+    XX_UnlockIntrSpinlock(p_Lock->h_Spinlock, flags);
+}
+
+static __inline__ bool FmPcdLockTryLock(t_FmPcdLock *p_Lock)
+{
+    uint32_t intFlags;
+
+    ASSERT_COND(p_Lock);
+    intFlags = XX_LockIntrSpinlock(p_Lock->h_Spinlock);
+    if (p_Lock->flag)
+    {
+        XX_UnlockIntrSpinlock(p_Lock->h_Spinlock, intFlags);
+        return FALSE;
+    }
+    p_Lock->flag = TRUE;
+    XX_UnlockIntrSpinlock(p_Lock->h_Spinlock, intFlags);
+    return TRUE;
+}
+
+static __inline__ void FmPcdLockUnlock(t_FmPcdLock *p_Lock)
+{
+    ASSERT_COND(p_Lock);
+    p_Lock->flag = FALSE;
+}
+
 
 #endif /* __FM_PCD_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
index 497dc95..c0a47b6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_pcd_ipc.h
 
@@ -112,14 +113,14 @@ typedef _Packed struct t_FmPcdIpcPrsIncludePort
     bool        include;
 } _PackedType t_FmPcdIpcPrsIncludePort;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 typedef _Packed struct t_FmPcdIpcSpAllocParams
 {
     uint16_t    num;
     uint8_t     hardwarePortId;
     uint16_t    spProfilesBase;
 } _PackedType t_FmPcdIpcSpAllocParams;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 #define FM_PCD_MAX_REPLY_SIZE           16
@@ -238,15 +239,6 @@ typedef _Packed struct t_FmPcdIpcReply
 #define FM_PCD_GUEST_DISABLE                    16
 
 /**************************************************************************//**
- @Function      FM_PCD_DUMP_REGS
-
- @Description   Used by FM front-end to dump all PCD registers
-
- @Param[in]     None
-*//***************************************************************************/
-#define FM_PCD_DUMP_REGS                        17
-
-/**************************************************************************//**
  @Function      FM_PCD_KG_DUMP_REGS
 
  @Description   Used by FM front-end to dump KG registers
@@ -327,10 +319,10 @@ typedef _Packed struct t_FmPcdIpcReply
 *//***************************************************************************/
 #define FM_PCD_PRS_INC_PORT_STATS               26
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /* TODO - doc */
 #define FM_PCD_ALLOC_SP                         27
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 /** @} */ /* end of FM_PCD_IPC_grp group */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index b848615..470d86d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_plcr.c
 
@@ -46,19 +47,31 @@
 #include "fm_pcd.h"
 #include "fm_hc.h"
 #include "fm_pcd_ipc.h"
+#include "fm_plcr.h"
+
 
 static uint32_t PlcrProfileLock(t_Handle h_Profile)
 {
     ASSERT_COND(h_Profile);
-
-    return XX_LockIntrSpinlock(((t_FmPcdPlcrProfile*)h_Profile)->h_Spinlock);
+    return FmPcdLockSpinlock(((t_FmPcdPlcrProfile *)h_Profile)->p_Lock);
 }
 
 static void PlcrProfileUnlock(t_Handle h_Profile, uint32_t intFlags)
 {
     ASSERT_COND(h_Profile);
+    FmPcdUnlockSpinlock(((t_FmPcdPlcrProfile *)h_Profile)->p_Lock, intFlags);
+}
 
-    XX_UnlockIntrSpinlock(((t_FmPcdPlcrProfile*)h_Profile)->h_Spinlock, intFlags);
+static bool PlcrProfileFlagTryLock(t_Handle h_Profile)
+{
+    ASSERT_COND(h_Profile);
+    return FmPcdLockTryLock(((t_FmPcdPlcrProfile *)h_Profile)->p_Lock);
+}
+
+static void PlcrProfileFlagUnlock(t_Handle h_Profile)
+{
+    ASSERT_COND(h_Profile);
+    FmPcdLockUnlock(((t_FmPcdPlcrProfile *)h_Profile)->p_Lock);
 }
 
 static uint32_t PlcrHwLock(t_Handle h_FmPcdPlcr)
@@ -239,16 +252,16 @@ static void CalcRates(t_Handle                              h_FmPcd,
      */
     if(temp != 0)
     {
-	/* In this case, the largest rate integer is non 0, if it does not occupy all (high) 16
-	 * bits of the PIR_EIR we can use this fact and enlarge it to occupy all 16 bits.
-	 * The logic is to have as many bits for integer in the higher rates, but if we have "0"s
-	 * in the integer part of the cir/pir register, than these bits are wasted. So we want
-	 * to use these bits for the fraction. in this way we will have for fraction - the number
-	 * of "0" bits and the rest - for integer.
-	 * In other words: For each bit we shift it in PIR_EIR, we move the FP in the TS
-	 * one bit to the left - preserving the relationship and achieving more bits
-	 * for integer in the TS.
-	 */
+        /* In this case, the largest rate integer is non 0, if it does not occupy all (high) 16
+         * bits of the PIR_EIR we can use this fact and enlarge it to occupy all 16 bits.
+         * The logic is to have as many bits for integer in the higher rates, but if we have "0"s
+         * in the integer part of the cir/pir register, than these bits are wasted. So we want
+         * to use these bits for the fraction. in this way we will have for fraction - the number
+         * of "0" bits and the rest - for integer.
+         * In other words: For each bit we shift it in PIR_EIR, we move the FP in the TS
+         * one bit to the left - preserving the relationship and achieving more bits
+         * for integer in the TS.
+         */
 
         /* count zeroes left of the higher used bit (in order to shift the value such that
          * unused bits may be used for fraction).
@@ -413,9 +426,6 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     uint32_t                        tmpReg32 = 0;
     t_Error                         err = E_OK;
     t_FmPcdPlcrRegs                 *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    t_FmPcdIpcMsg                   msg;
-    uint32_t                        replyLength;
-    t_FmPcdIpcReply                 reply;
 
     p_FmPcdPlcr->h_HwSpinlock = XX_InitSpinlock();
     if (!p_FmPcdPlcr->h_HwSpinlock)
@@ -428,6 +438,9 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
         (p_FmPcdPlcr->numOfSharedProfiles))
     {
+        t_FmPcdIpcMsg                   msg;
+        uint32_t                        replyLength;
+        t_FmPcdIpcReply                 reply;
         int         i, j, index = 0;
         uint32_t    walking1Mask = 0x80000000;
         uint32_t    sharedProfilesMask[FM_PCD_PLCR_NUM_ENTRIES/32];
@@ -527,8 +540,6 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
 t_Error PlcrFree(t_FmPcd *p_FmPcd)
 {
     t_Error                             err;
-    t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
-    t_FmPcdIpcMsg                       msg;
 
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR);
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL);
@@ -537,7 +548,10 @@ t_Error PlcrFree(t_FmPcd *p_FmPcd)
     {
         if(p_FmPcd->guestId != NCSW_MASTER_ID)
         {
-            int i;
+            t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
+            t_FmPcdIpcMsg                       msg;
+            int                                 i;
+
             memset(ipcSharedPlcrParams.sharedProfilesMask, 0, sizeof(ipcSharedPlcrParams.sharedProfilesMask));
             /* Free resources using IPC messaging */
             ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
@@ -586,13 +600,15 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
     uint32_t        tmpReg32, intFlags;
     t_Error         err;
 
+    /* Calling function locked all PCD modules, so no need to lock here */
+
     if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile out of range"));
 
     if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileIndx))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile is not valid"));
 
-    intFlags = PlcrProfileLock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx]);
+    /*intFlags = PlcrProfileLock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx]);*/
 
     if (p_FmPcd->h_Hc)
     {
@@ -601,11 +617,11 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
         FmPcdPlcrUpatePointedOwner(p_FmPcd, profileIndx, TRUE);
         FmPcdPlcrUpdateRequiredAction(p_FmPcd, profileIndx, requiredAction);
 
-        PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+        /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
         return err;
     }
 
-    /* lock the HW because once we read the registers we don't them to be changed
+    /* lock the HW because once we read the registers we don't want them to be changed
      * by another access. (We can copy to a tmp location and release the lock!) */
 
     intFlags = PlcrHwLock(p_FmPcdPlcr);
@@ -621,7 +637,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnRed!= e_FM_PCD_DONE))
             {
                 PlcrHwUnlock(p_FmPcdPlcr, intFlags);
-                PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
                 RETURN_ERROR (MAJOR, E_OK, ("In this case the next engine can be e_FM_PCD_DONE"));
             }
 
@@ -631,7 +647,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
-                    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                    /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
                 }
                 tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
@@ -647,7 +663,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
-                    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                    /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
                 }
                 tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
@@ -664,7 +680,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
-                    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                    /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
                 }
                 tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
@@ -681,7 +697,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
     FmPcdPlcrUpatePointedOwner(p_FmPcd, profileIndx, TRUE);
     FmPcdPlcrUpdateRequiredAction(p_FmPcd, profileIndx, requiredAction);
 
-    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+    /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
 
     return E_OK;
 }
@@ -725,9 +741,6 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
     t_Error                     err = E_OK;
     uint16_t                    base;
     uint16_t                    swPortIndex = 0;
-    t_FmPcdIpcMsg               msg;
-    uint32_t                    replyLength;
-    t_FmPcdIpcReply             reply;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
@@ -738,6 +751,10 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
 
     if(p_FmPcd->guestId != NCSW_MASTER_ID)
     {
+        t_FmPcdIpcMsg               msg;
+        uint32_t                    replyLength;
+        t_FmPcdIpcReply             reply;
+
         /* Alloc resources using IPC messaging */
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
@@ -775,22 +792,23 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
     return E_OK;
 }
 
-t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+t_Error FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
     t_Error                     err = E_OK;
     uint16_t                    swPortIndex = 0;
-    t_FmPcdIpcMsg               msg;
-    uint32_t                    replyLength;
-    t_FmPcdIpcReply             reply;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
     {
+        t_FmPcdIpcMsg               msg;
+        uint32_t                    replyLength;
+        t_FmPcdIpcReply             reply;
+
         /* Alloc resources using IPC messaging */
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
@@ -815,8 +833,11 @@ t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
     }
     else /* master */
     {
-        err = PlcrFreeProfiles(p_FmPcd, hardwarePortId, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
-        if(err)
+        err = PlcrFreeProfiles(p_FmPcd,
+                               hardwarePortId,
+                               p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles,
+                               p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
+        if (err)
             RETURN_ERROR(MAJOR, err,NO_MSG);
     }
     p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
@@ -907,11 +928,14 @@ t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t nu
 
 t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
 {
-    uint32_t        profilesFound, intFlags;
+    uint32_t        profilesFound;
     uint16_t        i, k=0;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
+
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     if(!numOfProfiles)
         return E_OK;
@@ -920,9 +944,6 @@ t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint1
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
 
     /* Find numOfProfiles free profiles (may be spread) */
-
-    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
-
     profilesFound = 0;
     for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
     {
@@ -936,18 +957,14 @@ t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint1
         }
     }
     if(profilesFound != numOfProfiles)
-    {
-        PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
         RETURN_ERROR(MAJOR, E_INVALID_STATE,NO_MSG);
-    }
+
     for(i = 0;i<k;i++)
     {
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = TRUE;
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.ownerId = 0;
     }
 
-    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-
     return E_OK;
 }
 
@@ -983,29 +1000,27 @@ t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num
 void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
 {
     uint16_t        i;
-    uint32_t        intFlags;
 
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
 
-    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
 
     for(i=0;i<numOfProfiles; i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
     }
-    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-
 }
 
 t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_ProfileParams, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs)
 {
 
-    t_FmPcd         		*p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error         		err = E_OK;
-    uint32_t        		pemode, gnia, ynia, rnia;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                 err = E_OK;
+    uint32_t                pemode, gnia, ynia, rnia;
 
 
 /* Set G, Y, R Nia */
@@ -1219,7 +1234,7 @@ void  FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 
 uint16_t     FmPcdPlcrProfileGetAbsoluteId(t_Handle h_Profile)
 {
-	    return ((t_FmPcdPlcrProfile*)h_Profile)->absoluteProfileId;
+        return ((t_FmPcdPlcrProfile*)h_Profile)->absoluteProfileId;
 }
 
 t_Error     FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle                      h_FmPcd,
@@ -1355,25 +1370,6 @@ void FmPcdPlcrUpdateRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId,
     p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction |= requiredAction;
 }
 
-/*t_Error FmPcdPlcrProfileTryLock(t_Handle h_FmPcdPlcr, uint16_t profileId, bool intr)
-{
-    t_FmPcdPlcr         *p_FmPcdPlcr = (t_FmPcdPlcr *)h_FmPcdPlcr;
-    bool            ans;
-
-    if (intr)
-        ans = TRY_LOCK(p_FmPcdPlcr->h_SwSpinlock, &p_FmPcdPlcr->profiles[profileId].lock);
-    else
-        ans = TRY_LOCK(p_FmPcdPlcr->h_SwSpinlock, &p_FmPcdPlcr->profiles[profileId].lock);
-    if (ans)
-        return E_OK;
-    return ERROR_CODE(E_BUSY);
-}
-
-void FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcdPlcr, uint16_t profileId)
-{
-    RELEASE_LOCK(((t_FmPcdPlcr*)h_FmPcdPlcr)->profiles[profileId].lock);
-}
-*/
 
 /**************************************************/
 /*............Policer API.........................*/
@@ -1436,7 +1432,6 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     int                 i = 0;
-    t_FmPcdIpcMsg       msg;
 
     DECLARE_DUMP;
 
@@ -1444,8 +1439,11 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcMsg       msg;
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_PLCR_DUMP_REGS;
         return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
@@ -1456,39 +1454,40 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
                                  NULL,
                                  NULL);
     }
-    else
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
+
+
+    DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
+    DUMP_SUBSTRUCT_ARRAY(i, 63)
     {
-        DUMP_SUBTITLE(("\n"));
-        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
-
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
-
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
-
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
-        DUMP_SUBSTRUCT_ARRAY(i, 63)
-        {
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
-        }
-
-        return E_OK;
+        DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
     }
+
+    return E_OK;
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
@@ -1502,22 +1501,15 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     uint16_t                            absoluteProfileId;
     t_Error                             err = E_OK;
     uint32_t                            tmpReg32;
-    t_FmPcdPlcrProfile				    *p_Profile;
+    t_FmPcdPlcrProfile                  *p_Profile;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
 
-    /*
-        err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
-        if (err)
-            return NULL;
-    */
-
-
     if(p_ProfileParams->modify)
     {
-	p_Profile = (t_FmPcdPlcrProfile *)p_ProfileParams->id.h_Profile;
-	p_FmPcd = p_Profile->h_FmPcd;
-	absoluteProfileId = p_Profile->absoluteProfileId;
+        p_Profile = (t_FmPcdPlcrProfile *)p_ProfileParams->id.h_Profile;
+        p_FmPcd = p_Profile->h_FmPcd;
+        absoluteProfileId = p_Profile->absoluteProfileId;
         if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
         {
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
@@ -1526,10 +1518,18 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
 
         SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
 
-    }
+        /* Try lock profile using flag */
+         if (!PlcrProfileFlagTryLock(p_Profile))
+         {
+		 DBG(TRACE, ("Profile Try Lock - BUSY"));
+             /* Signal to caller BUSY condition */
+             p_ProfileParams->id.h_Profile = NULL;
+             return NULL;
+         }
+   }
     else
     {
-	p_FmPcd = (t_FmPcd*)h_FmPcd;
+        p_FmPcd = (t_FmPcd*)h_FmPcd;
 
         SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
 
@@ -1557,6 +1557,10 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
          p_Profile = &p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId];
          p_Profile->h_FmPcd = p_FmPcd;
          p_Profile->absoluteProfileId = absoluteProfileId;
+
+         p_Profile->p_Lock = FmPcdAcquireLock(p_FmPcd);
+         if (!p_Profile->p_Lock)
+             REPORT_ERROR(MAJOR, E_NOT_AVAILABLE, ("FM Policer Profile lock obj!"));
     }
 
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
@@ -1570,17 +1574,18 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     p_Profile->nextEngineOnRed = p_ProfileParams->nextEngineOnRed;
     memcpy(&p_Profile->paramsOnRed, &(p_ProfileParams->paramsOnRed), sizeof(u_FmPcdPlcrNextEngineParams));
 
-    p_Profile->h_Spinlock = XX_InitSpinlock();
-    if (!p_Profile->h_Spinlock)
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PLCR Profile spinlock"));
-
     if (p_FmPcd->h_Hc)
     {
          err = FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, (t_Handle)p_Profile, p_ProfileParams);
+         if(p_ProfileParams->modify)
+             PlcrProfileFlagUnlock(p_Profile);
          if(err)
          {
-             if (p_Profile->h_Spinlock)
-                 XX_FreeSpinlock(p_Profile->h_Spinlock);
+             /* release the allocated scheme lock */
+             if (!p_ProfileParams->modify &&
+                     p_Profile->p_Lock)
+                 FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
+
              return NULL;
          }
          if (!p_ProfileParams->modify)
@@ -1597,9 +1602,14 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     err =  FmPcdPlcrBuildProfile(h_FmPcd, p_ProfileParams, &plcrProfileReg);
     if(err)
     {
-        if (p_Profile->h_Spinlock)
-            XX_FreeSpinlock(p_Profile->h_Spinlock);
         REPORT_ERROR(MAJOR, err, NO_MSG);
+        if(p_ProfileParams->modify)
+            /* unlock */
+            PlcrProfileFlagUnlock(p_Profile);
+        if (!p_ProfileParams->modify &&
+                p_Profile->p_Lock)
+            /* release allocated Profile lock */
+            FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
         return NULL;
     }
 
@@ -1628,18 +1638,18 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
 
     if (!p_ProfileParams->modify)
         FmPcdPlcrValidateProfileSw(p_FmPcd,absoluteProfileId);
-
-    /*RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);*/
+    else
+        PlcrProfileFlagUnlock(p_Profile);
 
     return (t_Handle)p_Profile;
 }
 
 t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
 {
-	t_FmPcdPlcrProfile	*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
-    t_FmPcd         	*p_FmPcd;
-    uint16_t        	profileIndx;
-    uint32_t        	tmpReg32, intFlags;
+    t_FmPcdPlcrProfile  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd             *p_FmPcd;
+    uint16_t            profileIndx;
+    uint32_t            tmpReg32, intFlags;
     t_Error             err;
 
     SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
@@ -1648,19 +1658,14 @@ t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
 
     profileIndx = p_Profile->absoluteProfileId;
 
-    /*
-         err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
-         if (err)
-             return NULL;
-     */
+    FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
 
     if (p_FmPcd->h_Hc)
     {
         err = FmHcPcdPlcrDeleteProfile(p_FmPcd->h_Hc, h_Profile);
-        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
-        FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
-        if (p_Profile->h_Spinlock)
-            XX_FreeSpinlock(p_Profile->h_Spinlock);
+        if (p_Profile->p_Lock)
+            /* release allocated Profile lock */
+            FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
 
         return err;
     }
@@ -1672,12 +1677,9 @@ t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
     WritePar(p_FmPcd, tmpReg32);
     PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
-    FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
-
-    /* FmPcdKgReleaseSchemeLock(h_Scheme); */
-
-    if (p_Profile->h_Spinlock)
-        XX_FreeSpinlock(p_Profile->h_Spinlock);
+    if (p_Profile->p_Lock)
+        /* release allocated Profile lock */
+        FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
 
     return E_OK;
 }
@@ -1687,11 +1689,11 @@ t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
 /***************************************************/
 uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
 {
-	t_FmPcdPlcrProfile	*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
-    t_FmPcd         	*p_FmPcd;
-    uint16_t        	profileIndx;
-    uint32_t        	intFlags, counterVal = 0;
-    t_FmPcdPlcrRegs		*p_FmPcdPlcrRegs;
+    t_FmPcdPlcrProfile  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd             *p_FmPcd;
+    uint16_t            profileIndx;
+    uint32_t            intFlags, counterVal = 0;
+    t_FmPcdPlcrRegs     *p_FmPcdPlcrRegs;
 
     SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
     p_FmPcd = p_Profile->h_FmPcd;
@@ -1741,11 +1743,11 @@ uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCoun
 
 t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
 {
-	t_FmPcdPlcrProfile	*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
-    t_FmPcd         	*p_FmPcd;
-    uint16_t        	profileIndx;
-    uint32_t        	tmpReg32, intFlags;
-    t_FmPcdPlcrRegs		*p_FmPcdPlcrRegs;
+    t_FmPcdPlcrProfile  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd             *p_FmPcd;
+    uint16_t            profileIndx;
+    uint32_t            tmpReg32, intFlags;
+    t_FmPcdPlcrRegs     *p_FmPcdPlcrRegs;
 
     SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
 
@@ -1758,7 +1760,7 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
     p_FmPcdPlcrRegs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
     SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcrRegs, E_INVALID_HANDLE);
 
-    intFlags = FmPcdLock(p_FmPcd);
+    intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
     switch (counter)
     {
         case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
@@ -1777,6 +1779,7 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
              WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc ,value);
              break;
         default:
+		PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
     }
 
@@ -1786,7 +1789,7 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
     tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
     tmpReg32 |= FmPcdPlcrBuildCounterProfileReg(counter);
     WritePar(p_FmPcd, tmpReg32);
-    FmPcdUnlock(p_FmPcd, intFlags);
+    PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
     return E_OK;
 }
@@ -1794,12 +1797,11 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
 {
-	t_FmPcdPlcrProfile					*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
-    t_FmPcd         					*p_FmPcd;
+    t_FmPcdPlcrProfile                  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd                             *p_FmPcd;
     t_FmPcdPlcrInterModuleProfileRegs   *p_ProfilesRegs;
-    uint16_t        					profileIndx;
+    uint16_t                            profileIndx;
     uint32_t                            tmpReg, intFlags;
-    t_FmPcdIpcMsg                       msg;
 
     DECLARE_DUMP;
 
@@ -1808,10 +1810,11 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
 
-    profileIndx = p_Profile->absoluteProfileId;
-
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcMsg                       msg;
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_PLCR_PROFILE_DUMP_REGS;
         memcpy(msg.msgBody, (uint8_t *)&h_Profile, sizeof(uint32_t));
@@ -1823,38 +1826,41 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
                                  NULL,
                                  NULL);
     }
-    else
-    {
-        DUMP_SUBTITLE(("\n"));
-        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Profile Regs"));
-
-        p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
-
-        tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
-        intFlags = FmPcdLock(p_FmPcd);
-        WritePar(p_FmPcd, tmpReg);
-
-        DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
-
-        DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
-        DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pects);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
-        FmPcdUnlock(p_FmPcd, intFlags);
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
 
-        return E_OK;
-    }
+    profileIndx = p_Profile->absoluteProfileId;
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Profile Regs"));
+
+    p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
+
+    tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
+	intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
+    WritePar(p_FmPcd, tmpReg);
+
+    DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
+
+    DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
+    DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pects);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
+	PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+
+    return E_OK;
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h
new file mode 100644
index 0000000..2bb8b96
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_plcr.h
+
+ @Description   FM Policer private header
+*//***************************************************************************/
+#ifndef __FM_PLCR_H
+#define __FM_PLCR_H
+
+#include "std_ext.h"
+
+
+/***********************************************************************/
+/*          Policer defines                                            */
+/***********************************************************************/
+
+#define FM_PCD_PLCR_PAR_GO                    0x80000000
+#define FM_PCD_PLCR_PAR_PWSEL_MASK            0x0000FFFF
+#define FM_PCD_PLCR_PAR_R                     0x40000000
+
+/* shifts */
+#define FM_PCD_PLCR_PAR_PNUM_SHIFT            16
+
+/* masks */
+#define FM_PCD_PLCR_PEMODE_PI                 0x80000000
+#define FM_PCD_PLCR_PEMODE_CBLND              0x40000000
+#define FM_PCD_PLCR_PEMODE_ALG_MASK           0x30000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC2698        0x10000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC4115        0x20000000
+#define FM_PCD_PLCR_PEMODE_DEFC_MASK          0x0C000000
+#define FM_PCD_PLCR_PEMODE_DEFC_Y             0x04000000
+#define FM_PCD_PLCR_PEMODE_DEFC_R             0x08000000
+#define FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE      0x0C000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_MASK         0x03000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_Y            0x01000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_R            0x02000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_G_NC         0x03000000
+#define FM_PCD_PLCR_PEMODE_PKT                0x00800000
+#define FM_PCD_PLCR_PEMODE_FPP_MASK           0x001F0000
+#define FM_PCD_PLCR_PEMODE_FPP_SHIFT          16
+#define FM_PCD_PLCR_PEMODE_FLS_MASK           0x0000F000
+#define FM_PCD_PLCR_PEMODE_FLS_L2             0x00003000
+#define FM_PCD_PLCR_PEMODE_FLS_L3             0x0000B000
+#define FM_PCD_PLCR_PEMODE_FLS_L4             0x0000E000
+#define FM_PCD_PLCR_PEMODE_FLS_FULL           0x0000F000
+#define FM_PCD_PLCR_PEMODE_RBFLS              0x00000800
+#define FM_PCD_PLCR_PEMODE_TRA                0x00000004
+#define FM_PCD_PLCR_PEMODE_TRB                0x00000002
+#define FM_PCD_PLCR_PEMODE_TRC                0x00000001
+#define FM_PCD_PLCR_DOUBLE_ECC                0x80000000
+#define FM_PCD_PLCR_INIT_ENTRY_ERROR          0x40000000
+#define FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE   0x80000000
+#define FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE    0x40000000
+
+#define FM_PCD_PLCR_NIA_VALID                 0x80000000
+
+#define FM_PCD_PLCR_GCR_EN                    0x80000000
+#define FM_PCD_PLCR_GCR_STEN                  0x40000000
+#define FM_PCD_PLCR_GCR_DAR                   0x20000000
+#define FM_PCD_PLCR_GCR_DEFNIA                0x00FFFFFF
+#define FM_PCD_PLCR_NIA_ABS                   0x00000100
+
+#define FM_PCD_PLCR_GSR_BSY                   0x80000000
+#define FM_PCD_PLCR_GSR_DQS                   0x60000000
+#define FM_PCD_PLCR_GSR_RPB                   0x20000000
+#define FM_PCD_PLCR_GSR_FQS                   0x0C000000
+#define FM_PCD_PLCR_GSR_LPALG                 0x0000C000
+#define FM_PCD_PLCR_GSR_LPCA                  0x00003000
+#define FM_PCD_PLCR_GSR_LPNUM                 0x000000FF
+
+#define FM_PCD_PLCR_EVR_PSIC                  0x80000000
+#define FM_PCD_PLCR_EVR_AAC                   0x40000000
+
+#define FM_PCD_PLCR_PAR_PSI                   0x20000000
+#define FM_PCD_PLCR_PAR_PNUM                  0x00FF0000
+/* PWSEL Selctive select options */
+#define FM_PCD_PLCR_PAR_PWSEL_PEMODE          0x00008000    /* 0 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGNIA          0x00004000    /* 1 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYNIA          0x00002000    /* 2 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERNIA          0x00001000    /* 3 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECIR           0x00000800    /* 4 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECBS           0x00000400    /* 5 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPIR_EIR       0x00000200    /* 6 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPBS_EBS       0x00000100    /* 7 */
+#define FM_PCD_PLCR_PAR_PWSEL_PELTS           0x00000080    /* 8 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECTS           0x00000040    /* 9 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPTS_ETS       0x00000020    /* 10 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGPC           0x00000010    /* 11 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYPC           0x00000008    /* 12 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERPC           0x00000004    /* 13 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERYPC          0x00000002    /* 14 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERRPC          0x00000001    /* 15 */
+
+#define FM_PCD_PLCR_PAR_PMR_BRN_1TO1          0x0000   /* - Full bit replacement. {PBNUM[0:N-1]
+                                                           1-> 2^N specific locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_2TO2          0x1      /* - {PBNUM[0:N-2],PNUM[N-1]}.
+                                                           2-> 2^(N-1) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_4TO4          0x2      /* - {PBNUM[0:N-3],PNUM[N-2:N-1]}.
+                                                           4-> 2^(N-2) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_8TO8          0x3      /* - {PBNUM[0:N-4],PNUM[N-3:N-1]}.
+                                                           8->2^(N-3) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_16TO16        0x4      /* - {PBNUM[0:N-5],PNUM[N-4:N-1]}.
+                                                           16-> 2^(N-4) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_32TO32        0x5      /* {PBNUM[0:N-6],PNUM[N-5:N-1]}.
+                                                           32-> 2^(N-5) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_64TO64        0x6      /* {PBNUM[0:N-7],PNUM[N-6:N-1]}.
+                                                           64-> 2^(N-6) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_128TO128      0x7      /* {PBNUM[0:N-8],PNUM[N-7:N-1]}.
+                                                            128-> 2^(N-7) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_256TO256      0x8      /* - No bit replacement for N=8. {PNUM[N-8:N-1]}.
+                                                            When N=8 this option maps all 256 profiles by the DISPATCH bus into one group. */
+
+#define FM_PCD_PLCR_PMR_V                     0x80000000
+#define PLCR_ERR_ECC_CAP                      0x80000000
+#define PLCR_ERR_ECC_TYPE_DOUBLE              0x40000000
+#define PLCR_ERR_ECC_PNUM_MASK                0x00000FF0
+#define PLCR_ERR_ECC_OFFSET_MASK              0x0000000F
+
+#define PLCR_ERR_UNINIT_CAP                   0x80000000
+#define PLCR_ERR_UNINIT_NUM_MASK              0x000000FF
+#define PLCR_ERR_UNINIT_PID_MASK              0x003f0000
+#define PLCR_ERR_UNINIT_ABSOLUTE_MASK         0x00008000
+
+/* shifts */
+#define PLCR_ERR_ECC_PNUM_SHIFT               4
+#define PLCR_ERR_UNINIT_PID_SHIFT             16
+
+#define FM_PCD_PLCR_PMR_BRN_SHIFT             16
+
+#define PLCR_PORT_WINDOW_SIZE(hardwarePortId)
+
+
+#endif /* __FM_PLCR_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index ff110d7..9b8f8e9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_pcd.c
 
@@ -44,6 +45,7 @@
 #include "fm_common.h"
 #include "fm_pcd.h"
 #include "fm_pcd_ipc.h"
+#include "fm_prs.h"
 
 
 t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
@@ -259,7 +261,7 @@ t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, boo
     GET_FM_PCD_PRS_PORT_ID(prsPortId, hardwarePortId);
     GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId);
 
-    if(include)
+    if (include)
         p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics |= bitMask;
     else
         p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics &= ~bitMask;
@@ -272,16 +274,18 @@ t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, boo
 t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, bool include)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdIpcPrsIncludePort    prsIncludePortParams;
-    t_FmPcdIpcMsg               msg;
     t_Error                     err;
 
     SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcPrsIncludePort    prsIncludePortParams;
+        t_FmPcdIpcMsg               msg;
+
         prsIncludePortParams.hardwarePortId = hardwarePortId;
         prsIncludePortParams.include = include;
         memset(&msg, 0, sizeof(msg));
@@ -297,6 +301,9 @@ t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId
             RETURN_ERROR(MAJOR, err, NO_MSG);
         return E_OK;
     }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without IPC!"));
 
     return PrsIncludePortInStatistics(p_FmPcd, hardwarePortId, include);
 }
@@ -306,13 +313,14 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_Error                 err = E_OK;
     t_FmPcdIpcSwPrsLable    labelParams;
-    t_FmPcdIpcMsg           msg;
-    uint32_t                prsOffset = 0;
-    t_FmPcdIpcReply         reply;
-    uint32_t                replyLength;
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
     {
+        t_FmPcdIpcMsg           msg;
+        uint32_t                prsOffset = 0;
+        t_FmPcdIpcReply         reply;
+        uint32_t                replyLength;
+
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
         labelParams.enumHdr = (uint32_t)hdr;
@@ -328,7 +336,7 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(replyLength != sizeof(uint32_t) + sizeof(uint32_t))
+        if (replyLength != sizeof(uint32_t) + sizeof(uint32_t))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
         memcpy((uint8_t*)&prsOffset, reply.replyBody, sizeof(uint32_t));
@@ -350,7 +358,8 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPrsStatistics - guest mode!"));
         return;
     }
-    if(enable)
+
+    if (enable)
         WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, FM_PCD_PRS_PPSC_ALL_PORTS);
     else
         WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, 0);
@@ -445,7 +454,6 @@ t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
 t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcMsg       msg;
 
     DECLARE_DUMP;
 
@@ -453,18 +461,25 @@ t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcMsg       msg;
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_PRS_DUMP_REGS;
         return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                    (uint8_t*)&msg,
-                                    sizeof(msg.msgId),
-                                    NULL,
-                                    NULL,
-                                    NULL,
-                                    NULL);
+                                 (uint8_t*)&msg,
+                                 sizeof(msg.msgId),
+                                 NULL,
+                                 NULL,
+                                 NULL,
+                                 NULL);
     }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+
     DUMP_SUBTITLE(("\n"));
     DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FmPcdPrsRegs Regs"));
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
new file mode 100644
index 0000000..1c886cc
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_prs.h
+
+ @Description   FM Parser private header
+*//***************************************************************************/
+#ifndef __FM_PRS_H
+#define __FM_PRS_H
+
+#include "std_ext.h"
+
+
+/***********************************************************************/
+/*          SW parser IP_FRAG patch                                    */
+/***********************************************************************/
+
+#if (DPAA_VERSION == 10)
+/* Version: 106.5 */
+#define SW_PRS_IP_FRAG_PATCH                           \
+{                                                      \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
+    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
+    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0, \
+    0x00,0x4A,0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x28,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x31,0x52,0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x53,0x8F,0x00,0x00,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
+    0x43,0x42,0x00,0x00,0x30,0x7E,0x43,0x42,0x00,0x3C, \
+    0x1B,0x5C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
+    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x1B,0x3B,0x30,0x7E,0x53,0x72,0x00,0x2B, \
+    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
+    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
+    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00, \
+    0x9B,0x8E,0x53,0x86,0x00,0x00,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00, \
+    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
+    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
+    0x00,0x55,0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x43,0x1B,0xC0,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
+    0x43,0xB7,0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11, \
+    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F, \
+    0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
+    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
+    0x28,0x43,0x06,0x00,0x1B,0x9A,0x00,0x03,0x00,0x02, \
+    0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0,0x00,0x4A, \
+    0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE,           \
+};
+
+#else
+/* version: 106.5 */
+#define SW_PRS_IP_FRAG_PATCH                           \
+{                                                      \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
+    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x2A,0x34,0xF5, \
+    0x00,0xFB,0xFF,0xFF,0x00,0x7F,0x00,0x00,0x00,0x00, \
+    0x2A,0x9F,0x34,0xB7,0x00,0xF9,0x00,0x00,0x01,0x00, \
+    0x00,0x00,0x00,0x00,0x2B,0x97,0x00,0x03,0x00,0x02, \
+    0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0,0x00,0x4F, \
+    0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+    0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x43,0x36,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+    0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x53,0x9D,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x50, \
+    0x00,0x00,0x30,0x7E,0x43,0x50,0x00,0x3C,0x1B,0x6A, \
+    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
+    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
+    0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
+    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
+    0x1B,0x49,0x30,0x7E,0x53,0x80,0x00,0x2B,0x32,0x11, \
+    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E, \
+    0x53,0x94,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x43,0x1B,0xDC,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xC5, \
+    0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
+    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x1B,0xA8,0x34,0xF5,0x00,0xFB,0xFF,0xFF, \
+    0x00,0x7F,0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7, \
+    0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00, \
+    0x2B,0x97,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01, \
+    0x32,0xC1,0x32,0xF0,0x00,0x4A,0x00,0x80,0x1F,0xFF, \
+    0x00,0x01,0x1B,0xFE,                               \
+};
+#endif /* (DPAA_VERSION == 10) */
+
+/****************************/
+/* Parser defines           */
+/****************************/
+/* masks */
+#define PRS_ERR_CAP                         0x80000000
+#define PRS_ERR_TYPE_DOUBLE                 0x40000000
+#define PRS_ERR_SINGLE_ECC_CNT_MASK         0x00FF0000
+#define PRS_ERR_ADDR_MASK                   0x000001FF
+#define FM_PCD_PRS_RPIMAC_EN                0x00000001
+#define FM_PCD_PRS_SINGLE_ECC               0x00004000
+#define FM_PCD_PRS_PORT_IDLE_STS            0xffff0000
+#define FM_PCD_PRS_DOUBLE_ECC               0x00004000
+#define FM_PCD_PRS_PPSC_ALL_PORTS           0xffff0000
+
+/* others */
+#define PRS_MAX_CYCLE_LIMIT                 8191
+#define PRS_SW_DATA                         0x00000800
+#define PRS_REGS_OFFSET                     0x00000840
+
+#define GET_FM_PCD_PRS_PORT_ID(prsPortId,hardwarePortId) \
+    prsPortId = (uint8_t)(hardwarePortId & 0x0f)
+
+#define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
+    bitMask = 0x80000000>>prsPortId
+
+
+#endif /* __FM_PRS_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index ffd597d..62cef06 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_port.c
 
@@ -86,8 +87,8 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
 #ifdef FM_NO_BACKUP_POOLS
     if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
-	if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("BackupBmPools"));
+        if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("BackupBmPools"));
 #endif /* FM_NO_BACKUP_POOLS */
         }
 
@@ -246,18 +247,18 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
     {
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
-	if ((p_FmPort->fmRevInfo.majorRev < 6) &&
+        if ((p_FmPort->fmRevInfo.majorRev < 6) &&
             (p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore != DEFAULT_notSupported))
                  /* this is an indication that user called config for this mode which is not supported in this integration */
-		RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("cheksumLastBytesIgnore is available for Rx & Tx ports only"));
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("cheksumLastBytesIgnore is available for Rx & Tx ports only"));
 #endif /* !FM_FRAME_END_PARAMS_FOR_OP */
 
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
-	if ((!((p_FmPort->fmRevInfo.majorRev == 4) ||
+        if ((!((p_FmPort->fmRevInfo.majorRev == 4) ||
                (p_FmPort->fmRevInfo.majorRev >= 6))) &&
             (p_FmPort->fifoDeqPipelineDepth != DEFAULT_notSupported))
-		    /* this is an indication that user called config for this mode which is not supported in this integration */
-		RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
+                /* this is an indication that user called config for this mode which is not supported in this integration */
+                RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
     }
     /****************************************/
@@ -400,7 +401,6 @@ static void FmPortDriverParamFree(t_FmPort *p_FmPort)
     }
 }
 
-// TODO - ask why we save it in fmPortDriverParam and p_FmPort - Ganit
 static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 {
     t_FmExtPools                *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
@@ -514,7 +514,7 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
         tmpReg |= vector;
     }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     /* fill QbbPEV */
     if (p_BufPoolDepletion->poolsGrpModeEnable ||
         p_BufPoolDepletion->singlePoolModeEnable)
@@ -530,7 +530,7 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
         }
         tmpReg |= vector;
     }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     WRITE_UINT32(*p_BufPoolDepletionReg, tmpReg);
 
@@ -633,7 +633,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
         tmpReg = 0;
         tmpReg |= (((uint32_t)p_Params->bufMargins.startMargins) << BMI_EXT_BUF_MARG_START_SHIFT);
         tmpReg |= (((uint32_t)p_Params->bufMargins.endMargins) << BMI_EXT_BUF_MARG_END_SHIFT);
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if (p_Params->noScatherGather)
             tmpReg |= BMI_SG_DISABLE;
 #endif
@@ -997,7 +997,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
         }
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-		if(p_FmPort->fmRevInfo.majorRev != 4)
+        if(p_FmPort->fmRevInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
         switch(p_Params->deqPrefetchOption)
         {
@@ -1264,7 +1264,7 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     return E_OK;
 }
 
-static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
+static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
 {
     uint8_t                     hdrNum, Ipv4HdrNum;
     u_FmPcdHdrPrsOpts           *p_prsOpts;
@@ -1345,7 +1345,7 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
         {
             if(tmp & walking1Mask)
             {
-                p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = FmPcdKgGetSchemeSwId(p_FmPort->h_FmPcd, idx);
+                p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = idx;
                 p_SchemeBind->numOfSchemes++;
                 tmp &= ~walking1Mask;
             }
@@ -1357,9 +1357,8 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
     return tmp;
 }
 
-static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                             err = E_OK;
     uint32_t                            tmpReg;
     volatile uint32_t                   *p_BmiNia=NULL;
@@ -1376,7 +1375,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     uint32_t                            ccTreePhysOffset;
     t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    ASSERT_COND(p_FmPort);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
@@ -1488,7 +1487,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
                               p_PcdParams,
                               p_PcdParams->p_CcParams->h_CcTree,
                               &ccTreePhysOffset,
-                              h_FmPort);
+                              p_FmPort);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1525,7 +1524,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             schemeBind.schemesIds[i] = physicalSchemeId;
             /* build vector */
             p_FmPort->schemesPerPortVector |= 1 << (31 - (uint32_t)physicalSchemeId);
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
             /*because of the state that VSPE is defined per port - all PCD path should be according to this requirement
              if !VSPE - in port, for relevant scheme VSPE can not be set*/
             if(!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
@@ -1559,11 +1558,9 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
         tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
 
-        if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
-        {
+        if (p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
             /* update BMI HPNIA */
             WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
-        }
         else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
             /* update BMI NIA */
             p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PLCR);
@@ -1625,7 +1622,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         }
 
         /* set start parsing offset */
-        /* WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset); */
+         WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset);
 
         /************************************/
         /* Parser port parameters           */
@@ -1746,7 +1743,8 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         for (i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
         {
             /* For all header set LCV as taken from netEnv*/
-            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,  FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,
+                         FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
             /* set HXS register according to default+Additional params+protocol options */
             WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,  tmpHxs[i]);
         }
@@ -1768,7 +1766,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         /* enable parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
 
-        if(p_PcdParams->p_PrsParams->prsResultPrivateInfo)
+        if (p_PcdParams->p_PrsParams->prsResultPrivateInfo)
             p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
 
     } /* end parser */
@@ -1781,25 +1779,28 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     for (i=0;i<FM_PORT_PRS_RESULT_NUM_OF_WORDS;i++)
     {
         if (!i)
-            WRITE_UINT32(*(p_BmiInitPrsResult), (uint32_t)(((uint32_t)p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
-                                                            | BMI_PRS_RESULT_HIGH));
+            WRITE_UINT32(*(p_BmiInitPrsResult),
+                         (uint32_t)(((uint32_t)p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
+                                    | BMI_PRS_RESULT_HIGH));
         else
+        {
             if (i< FM_PORT_PRS_RESULT_NUM_OF_WORDS/2)
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_HIGH);
             else
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_LOW);
+        }
     }
 
     return E_OK;
 }
 
-static t_Error DeletePcd(t_Handle h_FmPort)
+static t_Error DeletePcd(t_FmPort *p_FmPort)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                             err = E_OK;
     volatile uint32_t                   *p_BmiNia=NULL;
+    volatile uint32_t                   *p_BmiPrsStartOffset = NULL;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    ASSERT_COND(p_FmPort);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
@@ -1819,9 +1820,11 @@ static t_Error DeletePcd(t_Handle h_FmPort)
         case(e_FM_PORT_TYPE_RX_10G):
         case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
@@ -1835,6 +1838,8 @@ static t_Error DeletePcd(t_Handle h_FmPort)
 
     if(p_FmPort->pcdEngines | FM_PCD_PRS)
     {
+        WRITE_UINT32(*p_BmiPrsStartOffset, 0);
+
         /* stop parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
         /* wait for parser to be in idle state */
@@ -1871,6 +1876,145 @@ static t_Error DeletePcd(t_Handle h_FmPort)
     return E_OK;
 }
 
+static t_Error AttachPCD(t_FmPort *p_FmPort)
+{
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    ASSERT_COND(p_FmPort);
+
+/*TODO - to take care about the chnges that were made in the port because of the previously assigned tree.
+pndn, pnen ... maybe were changed because of the Tree requirement*/
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    /* check that current NIA is BMI to BMI */
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("may be called only for ports in BMI-to-BMI state."));
+
+    WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, p_FmPort->savedBmiFene);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
+    }
+    if(p_FmPort->requiredAction & UPDATE_NIA_FPNE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne, p_FmPort->savedBmiFpne);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
+    }
+    if(p_FmPort->requiredAction & UPDATE_NIA_CMNE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
+    }
+
+    return E_OK;
+}
+
+static t_Error DetachPCD(t_FmPort *p_FmPort)
+{
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    ASSERT_COND(p_FmPort);
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+
+/*TODO - not atomic - it seems that port has to be disabled*/
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+                break;
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_RX):
+            case(e_FM_PORT_TYPE_RX_10G):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+                break;
+           default:
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
+        }
+    }
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
+                break;
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
+        }
+    }
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+    }
+
+    if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    return E_OK;
+}
+
 
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
@@ -1947,70 +2091,6 @@ uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
     return ((t_FmPort*)h_FmPort)->pcdEngines;
 }
 
-t_Error FmPortAttachPCD(t_Handle h_FmPort)
-{
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t                   *p_BmiNia=NULL;
-
-/*TODO - to take care about the chnges that were made in the port because of the previously assigned tree.
-pndn, pnen ... maybe were changed because of the Tree requirement*/
-
-    /* get PCD registers pointers */
-    switch(p_FmPort->portType)
-    {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
-            break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-    }
-
-    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-
-    /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
-                     ("may be called only for ports in BMI-to-BMI state."));
-
-    WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
-
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
-
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
-
-    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
-    {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, p_FmPort->savedBmiFene);
-        else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
-    }
-    if(p_FmPort->requiredAction & UPDATE_NIA_FPNE)
-    {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne, p_FmPort->savedBmiFpne);
-        else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
-    }
-    if(p_FmPort->requiredAction & UPDATE_NIA_CMNE)
-    {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
-        else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
-    }
-
-    return E_OK;
-}
-
 t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcParams)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2264,9 +2344,9 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         p_FmPort->p_FmPortDriverParam->bufMargins.endMargins        = DEFAULT_PORT_BufMargins_endMargins;
         p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
         p_FmPort->p_FmPortDriverParam->forwardReuseIntContext       = DEFAULT_PORT_forwardIntContextReuse;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
-#endif /*DPAA_VERSION*/
+#endif /* (DPAA_VERSION >= 11) */
         break;
 
     case(e_FM_PORT_TYPE_TX):
@@ -2292,9 +2372,9 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 
     case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
-#endif /*DPAA_VERSION*/
+#endif /* (DPAA_VERSION >= 11) */
     case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
         p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
@@ -2320,8 +2400,8 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         return NULL;
     }
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-	if(p_FmPort->fmRevInfo.majorRev == 4)
-	p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
+    if(p_FmPort->fmRevInfo.majorRev == 4)
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     p_FmPort->imEn = p_FmPortParams->independentModeEnable;
@@ -2549,7 +2629,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 
     FmFreePortParams(p_FmPort->h_Fm, &fmParams);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if(FmVSPFree( p_FmPort->h_Fm,
                   p_FmPort->portType,
                   p_FmPort->portId) != E_OK)
@@ -2899,7 +2979,7 @@ t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
 
     return E_OK;
 }
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2914,7 +2994,7 @@ t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather)
 
     return E_OK;
 }
-#endif /*DPAA_VERSION*/
+#endif /* (DPAA_VERSION >= 11) */
 t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -3119,10 +3199,10 @@ uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
 
-    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
-    if(p_FmPort->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
+    if (p_FmPort->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
         return NULL;
 
     return (uint8_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.pcdInfoOffset);
@@ -3135,7 +3215,7 @@ t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
-    if(p_FmPort->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
+    if (p_FmPort->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
         return NULL;
 
     return (t_FmPrsResult *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.prsResultOffset);
@@ -3148,7 +3228,7 @@ uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
-    if(p_FmPort->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
+    if (p_FmPort->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
         return NULL;
 
     return (uint64_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.timeStampOffset);
@@ -3158,10 +3238,10 @@ uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
 
-    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
-    if(p_FmPort->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
+    if (p_FmPort->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
         return NULL;
 
     return (uint8_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.hashResultOffset);
@@ -3228,7 +3308,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
         {
             WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
                          GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
-            RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+            RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable! QMI busy", p_FmPort->name));
         }
     }
 
@@ -3250,7 +3330,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
                          GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
         WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
 
-        RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+        RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable! BMI Busy", p_FmPort->name));
     }
 
     p_FmPort->enabled = 0;
@@ -4077,7 +4157,7 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
 /*       API Run-time PCD Control unit functions                             */
 /*****************************************************************************/
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
@@ -4127,7 +4207,6 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            /* TODO - for TxConf EBD should be set */
             p_BmiStorageProfileId = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid);
             p_BmiVspe = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfne);
 
@@ -4162,7 +4241,7 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
     WRITE_UINT32(*p_BmiVspe, tmpReg | BMI_SP_EN);
     return E_OK;
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
 {
@@ -4173,13 +4252,16 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
     ASSERT_COND(p_FmPort->h_FmPcd);
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
          return ERROR_CODE(E_BUSY);
+    }
 
-    if(numOfProfiles)
+    if (numOfProfiles)
     {
         err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
         if(err)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     /* set the port handle within the PCD policer, even if no profiles defined */
     FmPcdPortRegister(p_FmPort->h_FmPcd, h_FmPort, p_FmPort->hardwarePortId);
@@ -4195,7 +4277,10 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
     t_Error                     err = E_OK;
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
          return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdPlcrFreeProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
 
@@ -4234,7 +4319,11 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
     /* if we want to change to direct scheme, we need to check that this scheme is valid */
     if(p_FmPcdKgScheme->direct)
     {
@@ -4280,7 +4369,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PLCR , E_INVALID_STATE);
 
-    /* check relevancy of this routine  - only when policer is used
+    /* check relevance of this routine  - only when policer is used
     directly after BMI or Parser */
     if((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
@@ -4303,7 +4392,11 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
     if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
     {
         RELEASE_LOCK(p_FmPort->lock);
@@ -4367,6 +4460,18 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 
     if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
+        if (p_FmPort->h_IpReassemblyManip)
+        {
+            err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
+                                    h_CcTree,
+                                    NULL,
+                                    p_FmPort->h_IpReassemblyManip,
+                                    FALSE);
+            if (err != E_OK)
+            {
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+        }
         switch(p_FmPort->portType)
         {
             case(e_FM_PORT_TYPE_RX_10G):
@@ -4381,7 +4486,10 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         }
 
         if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-            return ERROR_CODE(E_BUSY);
+        {
+             DBG(TRACE, ("FM Port Try Lock - BUSY"));
+             return ERROR_CODE(E_BUSY);
+        }
         err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree, &ccTreePhysOffset, h_FmPort);
         if(err)
         {
@@ -4401,7 +4509,6 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 
 t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
 {
-
     t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error         err = E_OK;
 
@@ -4409,20 +4516,18 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
-
-    /* TODO - may add here checks for:
-        SP (or in sw: schemes)
-        CPP (or in sw clsPlan)
-        Parser enabled and configured(?)
-        Tree(?)
-        Profile - only if direct.
-        Scheme - only if direct
-    */
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
-    err = FmPortAttachPCD(h_FmPort);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
+    if (p_FmPort->h_IpReassemblyTree)
+        p_FmPort->pcdEngines |= FM_PCD_CC;
+
+    err = AttachPCD(h_FmPort);
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
@@ -4430,79 +4535,32 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
 
 t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t                   *p_BmiNia=NULL;
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
-
-    /* get PCD registers pointers */
-    switch(p_FmPort->portType)
-    {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
-            break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-    }
-
-    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
-/*TODO - not atomic - it seems that port has to be disabled*/
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-        switch(p_FmPort->portType)
-        {
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
-                break;
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_RX):
-            case(e_FM_PORT_TYPE_RX_10G):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
-                break;
-           default:
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
-        }
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
     }
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    err = DetachPCD(h_FmPort);
+    if (err != E_OK)
     {
-        switch(p_FmPort->portType)
-        {
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
-                break;
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
-                break;
-            default:
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
-        }
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
-    {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
-        else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
-    }
+    if (p_FmPort->h_IpReassemblyTree)
+        p_FmPort->pcdEngines &= ~FM_PCD_CC;
+    RELEASE_LOCK(p_FmPort->lock);
 
-    if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
     return E_OK;
 }
 
@@ -4519,7 +4577,10 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
 
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
@@ -4542,21 +4603,20 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
              !p_PcdParams->p_CcParams)
         {
             /* No user-tree, need to build internal tree */
-            t_FmPcdCcTreeParams         *p_fmPcdCcTreeParams = NULL;
+            t_FmPcdCcTreeParams         *p_FmPcdCcTreeParams;
             t_FmPortPcdCcParams         fmPortPcdCcParams;
 
-            p_fmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
-            if(!p_fmPcdCcTreeParams)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_fmPcdCcTreeParams"));
+            p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
+            if(!p_FmPcdCcTreeParams)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
+            memset(p_FmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
 
-            memset(p_fmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
             memset(&fmPortPcdCcParams, 0, sizeof(t_FmPortPcdCcParams));
 
-            p_fmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
-            p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_fmPcdCcTreeParams);
+            p_FmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
+            p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
             if (!p_FmPort->h_IpReassemblyTree)
             {
-                XX_Free(p_fmPcdCcTreeParams);
                 RELEASE_LOCK(p_FmPort->lock);
                 RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM_PCD_CcBuildTree for IPR failed"));
             }
@@ -4568,10 +4628,18 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             fmPortPcdCcParams.h_CcTree = p_FmPort->h_IpReassemblyTree;
             p_PcdParams->p_CcParams = &fmPortPcdCcParams;
 
-            XX_Free(p_fmPcdCcTreeParams);
+            XX_Free(p_FmPcdCcTreeParams);
         }
         if (!p_PcdParams->p_CcParams)
+        {
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
+            RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
+        }
         err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
                                 p_PcdParams->p_CcParams->h_CcTree,
                                 p_PcdParams->h_NetEnv,
@@ -4579,20 +4647,59 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
                                 TRUE);
         if (err != E_OK)
         {
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+            RETURN_ERROR(MINOR, err, NO_MSG);
         }
     }
+
+    if (!FmPcdLockTryLockAll(p_FmPort->h_FmPcd))
+    {
+        if (p_FmPort->h_IpReassemblyTree)
+        {
+            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+            p_FmPort->h_IpReassemblyTree = NULL;
+        }
+        RELEASE_LOCK(p_FmPort->lock);
+        DBG(TRACE, ("Try LockAll - BUSY"));
+        return ERROR_CODE(E_BUSY);
+    }
+
     err = SetPcd(h_FmPort, p_PcdParams);
-    if(err)
+    if (err)
     {
+        if (p_FmPort->h_IpReassemblyTree)
+        {
+            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+            p_FmPort->h_IpReassemblyTree = NULL;
+        }
+        FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
         RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
     if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
         (p_PcdParams->p_PrsParams->includeInPrsStatistics))
-        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+    {
+        err = FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+        if (err)
+        {
+            DeletePcd(p_FmPort);
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
+            FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+        p_FmPort->includeInPrsStatistics = TRUE;
+    }
 
     FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
@@ -4613,6 +4720,13 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER | NIA_ENG_FM_CTL);
             if ((err = FmPortGetSetCcParams(p_FmPort, &fmPortGetSetCcParams)) != E_OK)
             {
+                DeletePcd(p_FmPort);
+                if (p_FmPort->h_IpReassemblyTree)
+                {
+                    FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                    p_FmPort->h_IpReassemblyTree = NULL;
+                }
+                FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
                 RELEASE_LOCK(p_FmPort->lock);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
@@ -4630,8 +4744,10 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
         }
 
+        FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
+
         /* Set pop-to-next-step nia */
-#if DPAA_VERSION < 3
+#if (DPAA_VERSION == 10)
         if (p_FmPort->fmRevInfo.majorRev < 6)
         {
             fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
@@ -4639,48 +4755,68 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         }
         else
         {
-#endif /* DPAA_VERSION < 3 */
+#endif /* (DPAA_VERSION == 10) */
         fmPortGetSetCcParams.getCcParams.type = GET_NIA_FPNE;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_CMNE;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
-#if DPAA_VERSION < 3
+#if (DPAA_VERSION == 10)
         }
-#endif /* DPAA_VERSION < 3 */
+#endif /* (DPAA_VERSION == 10) */
         if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
         {
+            DeletePcd(p_FmPort);
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MINOR, err, NO_MSG);
         }
 
-        /* Set the ORR bit (for order-restoration) */
-#if DPAA_VERSION < 3
-        if (p_FmPort->fmRevInfo.majorRev < 6)
-        {
-            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FENE;
-            /* Set frag-check nia */
-            fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ENG_FM_CTL | NIA_ORDER_RESTOR);
-        }
-        else
-        {
-#endif /* DPAA_VERSION < 3 */
-        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FPNE;
-        fmPortGetSetCcParams.setCcParams.nia = fmPortGetSetCcParams.getCcParams.nia | NIA_ORDER_RESTOR;
-#if DPAA_VERSION < 3
-        }
-#endif /* DPAA_VERSION < 3 */
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        if (p_FmPort->h_IpReassemblyManip)
         {
-            RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
+#if (DPAA_VERSION == 10)
+            if (p_FmPort->fmRevInfo.majorRev < 6)
+            {
+                fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FENE;
+                /* Set frag-check nia */
+                fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ENG_FM_CTL | NIA_ORDER_RESTOR);
+            }
+            else
+            {
+#endif /* (DPAA_VERSION == 10) */
+            /* Set the ORR bit (for order-restoration) */
+            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FPNE;
+            fmPortGetSetCcParams.setCcParams.nia = fmPortGetSetCcParams.getCcParams.nia | NIA_ORDER_RESTOR;
+#if (DPAA_VERSION == 10)
+            }
+#endif /* (DPAA_VERSION == 10) */
+            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            {
+                DeletePcd(p_FmPort);
+                if (p_FmPort->h_IpReassemblyTree)
+                {
+                    FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                    p_FmPort->h_IpReassemblyTree = NULL;
+                }
+                RELEASE_LOCK(p_FmPort->lock);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
         }
     }
+    else
+        FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
 
-    err = FmPortAttachPCD(h_FmPort);
+    err = AttachPCD(h_FmPort);
     if(err)
     {
         DeletePcd(p_FmPort);
         if (p_FmPort->h_IpReassemblyTree)
+        {
             FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+            p_FmPort->h_IpReassemblyTree = NULL;
+        }
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
@@ -4706,10 +4842,13 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
 
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
 
-    err = FM_PORT_DetachPCD(h_FmPort);
-    if(err)
+    err = DetachPCD(h_FmPort);
+    if (err)
     {
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -4718,16 +4857,28 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
     FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
     /* we do it anyway, instead of checking if included */
-    if (FmIsMaster(p_FmPort->h_Fm) &&
-        (p_FmPort->pcdEngines & FM_PCD_PRS))
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
+        p_FmPort->includeInPrsStatistics)
+    {
         FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
+        p_FmPort->includeInPrsStatistics = FALSE;
+    }
+
+    if (!FmPcdLockTryLockAll(p_FmPort->h_FmPcd))
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        DBG(TRACE, ("Try LockAll - BUSY"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = DeletePcd(h_FmPort);
-    if(err)
+    FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
+    if (err)
     {
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
+
     if (p_FmPort->h_IpReassemblyTree)
     {
         err = FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
@@ -4736,8 +4887,8 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
+        p_FmPort->h_IpReassemblyTree = NULL;
     }
-
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
@@ -4767,7 +4918,10 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
     if (err == E_OK)
@@ -4811,7 +4965,11 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
     err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
     if (err == E_OK)
         p_FmPort->schemesPerPortVector &= ~tmpScmVec;
@@ -4855,7 +5013,11 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
     /* set the first header */
     GET_PRS_HDR_NUM(hdrNum, p_FmPcdPrsStart->firstPrsHdr);
     if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
@@ -5112,13 +5274,19 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
     int                 i;
     uint8_t             mod;
     uint32_t            tmpReg = 0;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     int                 j;
     t_Error             err;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
+
+
+
 #ifdef FM_NO_OP_OBSERVED_CGS
 
     if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
@@ -5148,7 +5316,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 
         tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         for(j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
         {
             if(p_CongestionGrps->pfcPrioritiesEn[i][j])
@@ -5156,7 +5324,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
                 priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j+1));
             }
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     }
     for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
     {
@@ -5164,7 +5332,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
         /* each 32 congestion groups are represented by a register */
         if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
             tmpReg = opPort ? GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
-                              GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32]);
+                              GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)]);
 
         /* set in the register, the bit representing the relevant congestion group. */
 
@@ -5173,11 +5341,11 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 
             tmpReg |=  (0x00000001 << (uint32_t)mod);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
             err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm,i,priorityTmpArray[i]);
             if (err)
                 return err;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
         }
 
         if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
@@ -5185,7 +5353,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
             if (opPort)
                 WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
             else
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32], tmpReg);
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)], tmpReg);
         }
     }
 
@@ -5202,6 +5370,12 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
+
+
+
 #ifdef FM_NO_OP_OBSERVED_CGS
     if ((p_FmPort->fmRevInfo.majorRev != 4) &&
         (p_FmPort->fmRevInfo.majorRev < 6))
@@ -5232,27 +5406,27 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
         /* each 32 congestion groups are represented by a register */
         if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
             tmpReg = opPort ?   GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
-                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32]);
+                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)]);
 
         /* set in the register, the bit representing the relevant congestion group. */
         if(tmpArray[i])
         {
             tmpReg &=  ~(0x00000001 << (uint32_t)mod);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
             {
                 t_Error err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm, i, 0);
                 if (err)
                     return err;
             }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
         }
         if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
         {
             if(opPort)
                 WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
             else
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32], tmpReg);
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)], tmpReg);
         }
     }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 515636e..3684bab 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_port.h
 
@@ -148,6 +149,8 @@
 #define DEFAULT_PORT_ImfwExtStructsMemId            0
 #define DEFAULT_PORT_ImfwExtStructsMemAttr          MEMORY_ATTR_CACHEABLE
 
+#define FM_PORT_CG_REG_NUM(_cgId) (((FM_PORT_NUM_OF_CONGESTION_GRPS/32)-1)-_cgId/32)
+
 /**************************************************************************//**
  @Collection    PCD Engines
 *//***************************************************************************/
@@ -423,11 +426,11 @@ typedef _Packed struct
 /**************************************************************************//**
  @Description       BMI defines
 *//***************************************************************************/
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 #define BMI_SP_ID_MASK                          0xff000000
 #define BMI_SP_ID_SHIFT                         24
 #define BMI_SP_EN                               0x01000000
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 #define BMI_PORT_CFG_EN                         0x80000000
 #define BMI_PORT_CFG_EN_MACSEC                  0x00800000
@@ -562,10 +565,10 @@ typedef _Packed struct
 
 #define BMI_EXT_BUF_POOL_ID_SHIFT               FM_SP_EXT_BUF_POOL_ID_SHIFT
 #define BMI_TX_FIFO_MIN_FILL_SHIFT              16
-#define BMI_FIFO_PIPELINE_DEPTH_SHIFT        	12
+#define BMI_FIFO_PIPELINE_DEPTH_SHIFT           12
 #define BMI_TX_LOW_COMF_SHIFT                   0
 
-#define BMI_FRAME_END_CS_IGNORE_SHIFT        	24
+#define BMI_FRAME_END_CS_IGNORE_SHIFT           24
 
 #define BMI_PERFORMANCE_TASK_COMP_SHIFT         24
 #define BMI_PERFORMANCE_PORT_COMP_SHIFT         16
@@ -626,7 +629,7 @@ typedef _Packed struct
 #define PRS_TPID_DFLT                           0x91009100
 
 #define PRS_HDR_MPLS_LBL_INTER_EN               0x00200000
-#define PRS_HDR_IPV6_ROUTE_HDR_EN              	0x00008000
+#define PRS_HDR_IPV6_ROUTE_HDR_EN               0x00008000
 #define PRS_HDR_PPPOE_MTU_CHECK_EN              0x80000000
 #define PRS_HDR_UDP_PAD_REMOVAL                 0x80000000
 #define PRS_HDR_TCP_PAD_REMOVAL                 0x80000000
@@ -782,9 +785,9 @@ typedef struct {
     t_FmBufferPrefixContent             bufferPrefixContent;
      t_FmBackupBmPools                   *p_BackupBmPools;
     bool                                dontReleaseBuf;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool                                noScatherGather;
-#endif /*DPAA_VERSION*/
+#endif /* (DPAA_VERSION >= 11) */
 
 } t_FmPortDriverParam;
 
@@ -842,6 +845,7 @@ typedef struct {
     uint32_t                    savedBmiCmne;
     uint32_t                    savedNonRxQmiRegsPndn;
     int                         savedPrsStartOffset;
+    bool                        includeInPrsStatistics;
     uint16_t                    maxFrameLength;
     t_FmFmanCtrl                orFmanCtrl;
     t_FmPortRsrc                openDmas;
@@ -851,9 +855,10 @@ typedef struct {
     bool                        explicitUserSizeOfFifo;
     t_Handle                    h_IpReassemblyManip;
     t_Handle                    h_IpReassemblyTree;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool                        vspe;
-#endif
+#endif /* (DPAA_VERSION >= 11) */
+
     t_FmPortDriverParam         *p_FmPortDriverParam;
 } t_FmPort;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index e81eb1b..f07bed9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_port_im.c
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
index 27ee116..0d03916 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_rtc.c
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
index f35dc75..4c1a422 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_rtc.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
index 706753b..7bf04b7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
@@ -48,29 +48,7 @@
 #include "fm_common.h"
 
 
-#if DPAA_VERSION >= 3
-#ifdef UNDER_CONSTRUCTION_FM_GEN
-static uint32_t fm_vsp_get_statistics(fm_pcd_storage_profile_regs   *regs,
-                                      uint16_t                      index)
-{
-    fm_pcd_storage_profile_regs *sp_regs;
-    ASSERT_COND(regs);
-
-    sp_regs = &regs[index];
-    return GET_UINT32(sp_regs->fm_sp_acnt);
-}
-
-static void fm_vsp_set_statistics(  fm_pcd_storage_profile_regs *regs,
-                                    uint16_t                index,
-                                    uint32_t                value)
-{
-    fm_pcd_storage_profile_regs *sp_regs;
-    ASSERT_COND(regs);
-
-    sp_regs = &regs[index];
-    WRITE_UINT32(sp_regs->fm_sp_acnt, value);
-}
-#endif /* UNDER_CONSTRUCTION_FM_GEN */
+#if (DPAA_VERSION >= 11)
 
 static void fm_vsp_fill_entry(fm_pcd_storage_profile_regs   *regs,
                               uint16_t                      index,
@@ -166,7 +144,7 @@ static void fm_vsp_fill_entry(fm_pcd_storage_profile_regs   *regs,
     }
     WRITE_UINT32(sp_regs->fm_sp_mpd, tmp_reg);
 
-    /* fill dma attrubutes register */
+    /* fill dma attributes register */
     tmp_reg = 0;
     tmp_reg |= (uint32_t)fm_vsp_params->dma_swap_data << FM_SP_DMA_ATTR_SWP_SHIFT;
     tmp_reg |= (uint32_t)fm_vsp_params->int_context_cache_attr << FM_SP_DMA_ATTR_IC_CACHE_SHIFT;
@@ -219,7 +197,7 @@ static t_Error CheckParams(t_FmVspEntry *p_FmVspEntry)
 
     return err;
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 /*****************************************************************************/
@@ -265,7 +243,6 @@ void FmSpSetBufPoolsInAscOrderOfBufSizes(t_FmExtPools   *p_FmExtPools,
     }
 }
 
-// TODO - ask Ganit - SetExtBufferPools called for Rx and Op but parameters check only for Rx
 t_Error FmSpCheckBufPoolsParams(t_FmExtPools            *p_FmExtPools,
                                 t_FmBackupBmPools       *p_FmBackupBmPools,
                                 t_FmBufPoolDepletion    *p_FmBufPoolDepletion)
@@ -291,7 +268,7 @@ t_Error FmSpCheckBufPoolsParams(t_FmExtPools            *p_FmExtPools,
     if(!p_FmExtPools && (p_FmBackupBmPools || p_FmBufPoolDepletion))
           RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("backupBmPools ot bufPoolDepletion can not be defined without external pools"));
 
-    /* backup BM pools indication is valid only for some chip deriviatives
+    /* backup BM pools indication is valid only for some chip derivatives
        (limited by the config routine) */
     if(p_FmBackupBmPools)
     {
@@ -308,7 +285,6 @@ t_Error FmSpCheckBufPoolsParams(t_FmExtPools            *p_FmExtPools,
                     found = TRUE;
                     break;
                 }
-
             }
             if (!found)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("All p_BackupBmPools.poolIds must be included in extBufPools.extBufPool[n].id"));
@@ -500,12 +476,12 @@ t_Error FmSpBuildBufferStructure(t_FmSpIntContextDataCopy   *p_FmSpIntContextDat
     }
 
     if (p_FmSpIntContextDataCopy->size)
-		p_FmSpBufMargins->startMargins =
-			(uint16_t)(p_FmSpIntContextDataCopy->extBufOffset +
-					   p_FmSpIntContextDataCopy->size);
+        p_FmSpBufMargins->startMargins =
+            (uint16_t)(p_FmSpIntContextDataCopy->extBufOffset +
+                       p_FmSpIntContextDataCopy->size);
     else
-	/* No Internal Context passing, STartMargin is immediately after privateInfo */
-	p_FmSpBufMargins->startMargins = p_BufferPrefixContent->privDataSize;
+        /* No Internal Context passing, STartMargin is immediately after privateInfo */
+        p_FmSpBufMargins->startMargins = p_BufferPrefixContent->privDataSize;
 
     /* save extra space for manip in both external and internal buffers */
     if (p_BufferPrefixContent->manipExtraSpace)
@@ -536,7 +512,7 @@ t_Error FmSpBuildBufferStructure(t_FmSpIntContextDataCopy   *p_FmSpIntContextDat
 /*********************** End of inter-module routines ************************/
 
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /*****************************************************************************/
 /*              API routines                                                 */
 /*****************************************************************************/
@@ -805,28 +781,66 @@ t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBm
     return E_OK;
 }
 
-#ifdef UNDER_CONSTRUCTION_FM_GEN
-uint32_t FM_VSP_GetStatistics(t_Handle h_FmVsp)
+uint32_t FM_VSP_GetBufferDataOffset(t_Handle h_FmVsp)
 {
     t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmVsp, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmSpRegsBase, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, 0);
 
-    return fm_vsp_get_statistics(p_FmVspEntry->p_FmSpRegsBase, p_FmVspEntry->absoluteSpId);
+    return p_FmVspEntry->bufferOffsets.dataOffset;
 }
-t_Error FM_VSP_ModifyCounter(t_Handle h_FmVsp, uint32_t value)
+
+uint8_t * FM_VSP_GetBufferICInfo(t_Handle h_FmVsp, char *p_Data)
 {
     t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmVsp, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmSpRegsBase, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, NULL);
 
-    fm_vsp_set_statistics(p_FmVspEntry->p_FmSpRegsBase, p_FmVspEntry->absoluteSpId, value);
+    if (p_FmVspEntry->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
+        return NULL;
 
-    return E_OK;
+    return (uint8_t *)PTR_MOVE(p_Data, p_FmVspEntry->bufferOffsets.pcdInfoOffset);
+}
+
+t_FmPrsResult * FM_VSP_GetBufferPrsResult(t_Handle h_FmVsp, char *p_Data)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, NULL);
+
+    if (p_FmVspEntry->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (t_FmPrsResult *)PTR_MOVE(p_Data, p_FmVspEntry->bufferOffsets.prsResultOffset);
+}
+
+uint64_t * FM_VSP_GetBufferTimeStamp(t_Handle h_FmVsp, char *p_Data)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, NULL);
+
+    if (p_FmVspEntry->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint64_t *)PTR_MOVE(p_Data, p_FmVspEntry->bufferOffsets.timeStampOffset);
 }
-#endif /* UNDER_CONSTRUCTION_FM_GEN */
-#endif /* DPAA_VERSION >= 3 */
+
+uint8_t * FM_VSP_GetBufferHashResult(t_Handle h_FmVsp, char *p_Data)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, NULL);
+
+    if (p_FmVspEntry->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint8_t *)PTR_MOVE(p_Data, p_FmVspEntry->bufferOffsets.hashResultOffset);
+}
+
+#endif /* (DPAA_VERSION >= 11) */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 66e8a62..042e9b9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm.c
 
@@ -113,10 +114,10 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                      ("dmaWatchdog depends on FM clock. dmaWatchdog(in microseconds) * clk (in Mhz), may not exceed 0x08x", DMA_MAX_WATCHDOG));
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if ((p_Fm->partVSPBase + p_Fm->partNumOfVSPs) > FM_VSP_MAX_NUM_OF_ENTRIES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partVSPBase+partNumOfVSPs out of range!!!"));
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     if(p_Fm->p_FmStateStruct->totalFifoSize % BMI_FIFO_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be divisible by %d", BMI_FIFO_UNITS));
@@ -647,7 +648,7 @@ t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
     return E_OK;
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error FmVSPSetWindow(t_Handle  h_Fm,
                                   uint8_t   hardwarePortId,
                                   uint8_t   baseStorageProfile,
@@ -700,13 +701,17 @@ static uint8_t FmVSPsAlloc(t_Handle  h_Fm, uint8_t base, uint8_t numOfStoragePro
     t_Fm    *p_Fm = (t_Fm *)h_Fm;
     uint8_t  profilesFound = 0;
     int     i     = 0;
+    uint32_t    intFlags;
 
     if (!numOfStorageProfiles)
         return E_OK;
-    if (numOfStorageProfiles>FM_VSP_MAX_NUM_OF_ENTRIES)
+
+    if ((numOfStorageProfiles>FM_VSP_MAX_NUM_OF_ENTRIES) ||
+        (base + numOfStorageProfiles > FM_VSP_MAX_NUM_OF_ENTRIES))
         return (uint8_t)ILLEGAL_BASE;
 
-    XX_LockSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+
     for (i = base; i < base + numOfStorageProfiles; i++)
         if (p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == (uint8_t)ILLEGAL_BASE)
             profilesFound++;
@@ -718,10 +723,10 @@ static uint8_t FmVSPsAlloc(t_Handle  h_Fm, uint8_t base, uint8_t numOfStoragePro
             p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = guestId;
     else
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         return (uint8_t)ILLEGAL_BASE;
     }
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
     return base;
 }
@@ -742,7 +747,7 @@ static void FmVSPsFree(t_Handle  h_Fm, uint8_t base, uint8_t numOfStorageProfile
             DBG(WARNING, ("Request for freeing storage profile window which wasn't allocated to this partition"));
     }
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
 
 static t_Error FmGuestHandleIpcMsgCB(t_Handle  h_Fm,
@@ -925,7 +930,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
         }
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         case (FM_VSP_ALLOC) :
         {
             t_FmIpcVspAllocParams   ipcVspAllocParams;
@@ -962,7 +967,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
                                                   FmIpcSetCongestionGroupPfcPriority.priorityBitMap);
             return err;
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
         case (FM_FREE_PORT):
         {
             t_FmInterModulePortFreeParams   portParams;
@@ -1333,7 +1338,7 @@ uintptr_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm)
     return (p_Fm->baseAddr + FM_MM_PLCR);
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 uintptr_t FmGetVSPBaseAddr(t_Handle h_Fm)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
@@ -1342,7 +1347,7 @@ uintptr_t FmGetVSPBaseAddr(t_Handle h_Fm)
 
     return p_Fm->vspBaseAddr;
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
 t_Handle FmGetMuramHandle(t_Handle h_Fm)
 {
@@ -1396,13 +1401,14 @@ void FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
     p_FmPhysAddr->high = (uint8_t)((p_Fm->fmMuramPhysBaseAddr & 0x000000ff00000000LL) >> 32);
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error FmVSPFree(  t_Handle        h_Fm,
                     e_FmPortType    portType,
                     uint8_t         portId)
 {
     t_Fm           *p_Fm = (t_Fm *)h_Fm;
     uint8_t        swPortIndex, hardwarePortId, first, numOfVSPs, i;
+    uint32_t        intFlags;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
@@ -1412,12 +1418,12 @@ t_Error FmVSPFree(  t_Handle        h_Fm,
     numOfVSPs = p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
     first = p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
 
-    XX_LockSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     for(i = first; i < first + numOfVSPs; i++)
            p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
 
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
     p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = 0;
     p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase = 0;
@@ -1432,7 +1438,7 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
 {
     t_Fm           *p_Fm = (t_Fm *)h_Fm;
     t_Error        err = E_OK;
-    uint32_t       profilesFound;
+    uint32_t       profilesFound, intFlags;
     uint8_t        first, i;
     uint8_t        log2Num;
     uint8_t        swPortIndex, hardwarePortId;
@@ -1448,30 +1454,27 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
     if (!POWER_OF_2(numOfVSPs))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
 
-    XX_LockSpinlock(p_Fm->h_Spinlock);
+    LOG2((uint64_t)numOfVSPs, log2Num);
 
-    if (p_Fm->partVSPBase == 0)
+    if ((log2Num == 0) || (p_Fm->partVSPBase == 0))
         first = 0;
-    else if (p_Fm->partVSPBase <= numOfVSPs)
-      first = numOfVSPs ;
     else
-    {
-        for (i = p_Fm->partVSPBase; i < p_Fm->partNumOfVSPs; i++)
-        {
-            if (POWER_OF_2(i))
-            {
-                first = i;
-                break;
-            }
-        }
-    }
-    if (first>= (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
-    {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        first = 1<<log2Num;
+
+    if (first > (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
-    }
+
+    if (first<p_Fm->partVSPBase)
+        while(first < p_Fm->partVSPBase)
+            first = first + numOfVSPs;
+
+    if ((first + numOfVSPs ) > (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
+
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+
     profilesFound = 0;
-    for (i=first;i<p_Fm->partNumOfVSPs;)
+    for (i=first; i < p_Fm->partVSPBase + p_Fm->partNumOfVSPs;)
     {
         if (!p_Fm->p_FmSp->profiles[i].profilesMng.allocated)
         {
@@ -1492,12 +1495,10 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
             p_Fm->p_FmSp->profiles[i].profilesMng.allocated = TRUE;
     else
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
     }
 
-    LOG2((uint64_t)numOfVSPs, log2Num);
-
     SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
@@ -1507,7 +1508,9 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
     if ((err = FmVSPSetWindow(h_Fm,hardwarePortId, first,log2Num)) != E_OK)
         for(i = first; i < first + numOfVSPs; i++)
             p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
+
     return err;
 }
 
@@ -1794,11 +1797,10 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
 {
 
     t_Fm                        *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                    tmpReg = 0;
+    uint32_t                    tmpReg = 0, intFlags;
     t_Error                     err;
     t_FmIpcPortNumOfFmanCtrls   params;
     t_FmIpcMsg                  msg;
-    unsigned long               flags;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((numOfFmanCtrls > 0) && (numOfFmanCtrls < 3)) , E_INVALID_HANDLE);
@@ -1822,7 +1824,7 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
         return E_OK;
     }
 
-    flags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
 
@@ -1832,12 +1834,10 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
         tmpReg = FPM_PORT_FM_CTL2 | FPM_PORT_FM_CTL1;
 
     /* order restoration */
-
-
     tmpReg |= (orFmanCtrl << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | orFmanCtrl;
 
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
-    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
     return E_OK;
 }
@@ -1845,7 +1845,7 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
 t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                tmpReg;
+    uint32_t                tmpReg, intFlags;
     uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
     t_FmIpcPortInInitParams portInParams;
     t_FmIpcPhysAddr         ipcPhysAddr;
@@ -1853,7 +1853,6 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     t_FmIpcMsg              msg;
     t_FmIpcReply            reply;
     uint32_t                replyLength;
-    unsigned long           flags;
 
     if(p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -1892,7 +1891,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    flags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     if(p_PortParams->independentMode)
     {
@@ -1906,7 +1905,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     {
         if(p_Fm->hcPortInitialized)
         {
-            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
         }
         else
@@ -1917,7 +1916,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfTasks, p_PortParams->numOfExtraTasks, TRUE);
     if(err)
     {
-        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1963,7 +1962,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     {
         if(p_Fm->p_FmStateStruct->lowEndRestriction)
         {
-            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
         }
         else
@@ -1978,14 +1977,14 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
                             TRUE);
     if(err)
     {
-        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     err = FmSetNumOfOpenDmas(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfOpenDmas, p_PortParams->numOfExtraOpenDmas, TRUE);
     if(err)
     {
-        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -2031,7 +2030,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         }
 
     FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
-    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
     return E_OK;
 }
@@ -2039,13 +2038,12 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                tmpReg;
+    uint32_t                tmpReg, intFlags;
     uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
     uint8_t                 numOfTasks;
     t_Error                 err;
     t_FmIpcPortFreeParams   portParams;
     t_FmIpcMsg              msg;
-    unsigned long           flags;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -2068,7 +2066,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     }
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    flags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
@@ -2140,7 +2138,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
         p_Fm->p_FmStateStruct->lowEndRestriction = FALSE;
 #endif /* FM_LOW_END_RESTRICTION */
-    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 }
 
 t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled)
@@ -2710,7 +2708,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     return E_OK;
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 
 t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
                                   e_FmPortType    portType,
@@ -2756,7 +2754,7 @@ void VspValidateProfileSw(t_Handle h_Fm, uint16_t absoluteProfileId)
     ASSERT_COND(!p_Fm->p_FmSp->profiles[absoluteProfileId].valid);
     p_Fm->p_FmSp->profiles[absoluteProfileId].valid = TRUE;
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
@@ -2953,11 +2951,11 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         memcpy(p_Fm->p_FmDriverParam->firmware.p_Code, p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
     }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     p_Fm->partVSPBase   = p_FmParam->partVSPBase;
     p_Fm->partNumOfVSPs = p_FmParam->partNumOfVSPs;
     p_Fm->vspBaseAddr = p_FmParam->vspBaseAddr;
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     return p_Fm;
 }
@@ -2983,7 +2981,7 @@ t_Error FM_Init(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     p_Fm->p_FmSp = (t_FmSp*)XX_Malloc(sizeof(t_FmSp));
     if (!p_Fm->p_FmSp)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation for internal data structure failed"));
@@ -2991,7 +2989,7 @@ t_Error FM_Init(t_Handle h_Fm)
     memset(p_Fm->p_FmSp, 0, sizeof(t_FmSp));
     for (i = 0; i < FM_VSP_MAX_NUM_OF_ENTRIES; i++)
         p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     if(p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -3073,7 +3071,7 @@ t_Error FM_Init(t_Handle h_Fm)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No baseAddr configured for guest without IPC"));
         }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if (p_Fm->h_IpcSessions[p_Fm->guestId])
         {
             t_FmIpcVspAllocParams   fmIpcVspAllocParams;
@@ -3106,7 +3104,7 @@ t_Error FM_Init(t_Handle h_Fm)
         }
         else
             DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
         XX_Free(p_Fm->p_FmDriverParam);
         p_Fm->p_FmDriverParam = NULL;
@@ -3236,11 +3234,11 @@ t_Error FM_Init(t_Handle h_Fm)
     WRITE_BLOCK(UINT_TO_PTR(p_Fm->resAddr), 0, 256);
 #endif /* FM_CAPWAP_SUPPORT */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     p_Fm->partVSPBase = FmVSPsAlloc(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
     if (p_Fm->partVSPBase == ILLEGAL_BASE)
         DBG(WARNING, ("partition VSPs allocation is FAILED"));
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     /* General FM driver initialization */
     p_Fm->fmMuramPhysBaseAddr = (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->baseAddr + FM_MM_MURAM)));
@@ -3593,7 +3591,7 @@ t_Error FM_Free(t_Handle h_Fm)
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if (p_Fm->h_IpcSessions[0])
         {
             t_FmIpcMsg          msg;
@@ -3623,7 +3621,7 @@ t_Error FM_Free(t_Handle h_Fm)
             if (err != E_OK)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
         XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
 
@@ -3663,7 +3661,7 @@ t_Error FM_Free(t_Handle h_Fm)
         }
     }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     FmVSPsFree(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
 
     if (p_Fm->p_FmSp)
@@ -3671,7 +3669,7 @@ t_Error FM_Free(t_Handle h_Fm)
         XX_Free(p_Fm->p_FmSp);
         p_Fm->p_FmSp = NULL;
     }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     if (p_Fm->h_Spinlock)
         XX_FreeSpinlock(p_Fm->h_Spinlock);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
index 9ccadcb..5854b9b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm.h
 
@@ -124,14 +125,15 @@ switch(exception){                                          \
                                             FM_EX_BMI_STORAGE_PROFILE_ECC   |\
                                             FM_EX_BMI_STATISTICS_RAM_ECC    |\
                                             FM_EX_IRAM_ECC                  |\
-                                            FM_EX_MURAM_ECC 				|\
+                                            FM_EX_MURAM_ECC                 |\
                                             FM_EX_BMI_DISPATCH_RAM_ECC      |\
                                             FM_EX_QMI_DOUBLE_ECC            |\
                                             FM_EX_QMI_SINGLE_ECC)
 
 
-#define DEFAULT_totalFifoSize(major)       ((major != 0) ?  (BMI_MAX_FIFO_SIZE*3/4):0)
-
+#define DEFAULT_totalFifoSize(major)       (((major == 2) || (major == 5))  ?   \
+                                            (100*KILOBYTE):((major == 6) ?      \
+                                            (288*KILOBYTE):((major == 4) ? (44*KILOBYTE):(122*KILOBYTE))))
 
 #define DEFAULT_eccEnable                   FALSE
 #define DEFAULT_dispLimit                   0
@@ -174,6 +176,57 @@ switch(exception){                                          \
 #define DEFAULT_mtu                         9600
 
 /**************************************************************************//**
+ @Collection   Defines used for enabling/disabling FM interrupts
+ @{
+*//***************************************************************************/
+typedef uint32_t t_FmBlockErrIntrEnable;
+
+#define ERR_INTR_EN_DMA         0x00010000
+#define ERR_INTR_EN_FPM         0x80000000
+#define ERR_INTR_EN_BMI         0x00800000
+#define ERR_INTR_EN_QMI         0x00400000
+#define ERR_INTR_EN_PRS         0x00200000
+#define ERR_INTR_EN_KG          0x00100000
+#define ERR_INTR_EN_PLCR        0x00080000
+#define ERR_INTR_EN_MURAM       0x00040000
+#define ERR_INTR_EN_IRAM        0x00020000
+#define ERR_INTR_EN_10G_MAC0    0x00008000
+#define ERR_INTR_EN_10G_MAC1    0x00000040
+#define ERR_INTR_EN_1G_MAC0     0x00004000
+#define ERR_INTR_EN_1G_MAC1     0x00002000
+#define ERR_INTR_EN_1G_MAC2     0x00001000
+#define ERR_INTR_EN_1G_MAC3     0x00000800
+#define ERR_INTR_EN_1G_MAC4     0x00000400
+#define ERR_INTR_EN_1G_MAC5     0x00000200
+#define ERR_INTR_EN_1G_MAC6     0x00000100
+#define ERR_INTR_EN_1G_MAC7     0x00000080
+#define ERR_INTR_EN_MACSEC_MAC0 0x00000001
+
+typedef uint32_t t_FmBlockIntrEnable;
+
+#define INTR_EN_QMI             0x40000000
+#define INTR_EN_PRS             0x20000000
+#define INTR_EN_PLCR            0x08000000
+#define INTR_EN_1G_MAC0         0x00080000
+#define INTR_EN_1G_MAC1         0x00040000
+#define INTR_EN_1G_MAC2         0x00020000
+#define INTR_EN_1G_MAC3         0x00010000
+#define INTR_EN_1G_MAC4         0x00000040
+#define INTR_EN_1G_MAC5         0x00000020
+#define INTR_EN_1G_MAC6         0x00000008
+#define INTR_EN_1G_MAC7         0x00000002
+#define INTR_EN_10G_MAC0        0x00200000
+#define INTR_EN_10G_MAC1        0x00100000
+#define INTR_EN_REV0            0x00008000
+#define INTR_EN_REV1            0x00004000
+#define INTR_EN_REV2            0x00002000
+#define INTR_EN_REV3            0x00001000
+#define INTR_EN_BRK             0x00000080
+#define INTR_EN_TMR             0x01000000
+#define INTR_EN_MACSEC_MAC0     0x00000001
+/* @} */
+
+/**************************************************************************//**
  @Description       Modules registers offsets
 *//***************************************************************************/
 #define FM_MM_MURAM             0x00000000
@@ -187,9 +240,9 @@ switch(exception){                                          \
 #define FM_MM_IMEM              0x000C4000
 #define FM_MM_CGP               0x000DB000
 #define FM_MM_TRB(i)            (0x000D0200 + 0x400 * (i))
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 #define FM_MM_SP                0x000dc000
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 /**************************************************************************//**
@@ -615,7 +668,7 @@ typedef _Packed struct t_FmTrbRegs
 #define TRB_TCRH_ENABLE_COUNTERS    0x84008000
 #define TRB_TCRH_DISABLE_COUNTERS   0x8400C000
 #define TRB_TCRL_RESET              0x20000000
-#define TRB_TCRL_UTIL               0x00000800
+#define TRB_TCRL_UTIL               0x00000400
 
 typedef struct {
     void        (*f_Isr) (t_Handle h_Arg, uint32_t event);
@@ -698,7 +751,7 @@ typedef struct
     uint16_t                    macMaxFrameLengths1G[FM_MAX_NUM_OF_1G_MACS];
 } t_FmStateStruct;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 typedef struct t_FmMapParam {
     uint16_t        profilesBase;
     uint16_t        numOfProfiles;
@@ -722,7 +775,7 @@ typedef struct t_FmSp {
     t_FmMapParam    portsMapping[FM_MAX_NUM_OF_PORTS];
 } t_FmSp;
 
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 typedef struct t_Fm
@@ -754,12 +807,12 @@ typedef struct t_Fm
     t_Handle                    h_Spinlock;
     bool                        recoveryMode;
     t_FmStateStruct             *p_FmStateStruct;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     t_FmSp                      *p_FmSp;
     uint8_t                     partNumOfVSPs;
     uint8_t                     partVSPBase;
     uintptr_t                   vspBaseAddr;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /* un-needed for recovery */
     t_FmDriverParam             *p_FmDriverParam;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index e63c104..6220908 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_ipc.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
index a42fa8a..a1cbe3f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          FM_muram.c
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index b273931..0694de5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_common.h
 
@@ -44,6 +45,7 @@
 #include "fm_ext.h"
 #include "fm_port_ext.h"
 
+
 #define e_FM_PORT_TYPE_OH_HOST_COMMAND      e_FM_PORT_TYPE_DUMMY
 
 #define CLS_PLAN_NUM_PER_GRP                        8
@@ -228,19 +230,16 @@ typedef uint32_t t_FmFmanCtrl;
 
 
 
-
-#define NUM_OF_SCRATCH_POOL_BUFFERS     1000 /*TODO - Change it!!*/
-
 typedef struct t_FmPcdCcFragScratchPoolCmdParams {
     uint32_t    numOfBuffers;
     uint8_t     bufferPoolId;
-}t_FmPcdCcFragScratchPoolCmdParams;
+} t_FmPcdCcFragScratchPoolCmdParams;
 
 typedef struct t_FmPcdCcIpReassmTimeoutParams {
     bool        activate;
     uint8_t     tsbs;
     uint32_t    iprcpt;
-}t_FmPcdCcIpReassmTimeoutParams;
+} t_FmPcdCcIpReassmTimeoutParams;
 
 typedef struct {
     uint8_t             baseEntry;
@@ -370,58 +369,6 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_KG_NIA                           0x04000000
 /* @} */
 
-/**************************************************************************//**
- @Collection   Defines used for enabling/disabling FM interrupts
- @{
-*//***************************************************************************/
-typedef uint32_t t_FmBlockErrIntrEnable;
-
-#define ERR_INTR_EN_DMA         0x00010000
-#define ERR_INTR_EN_FPM         0x80000000
-#define ERR_INTR_EN_BMI         0x00800000
-#define ERR_INTR_EN_QMI         0x00400000
-#define ERR_INTR_EN_PRS         0x00200000
-#define ERR_INTR_EN_KG          0x00100000
-#define ERR_INTR_EN_PLCR        0x00080000
-#define ERR_INTR_EN_MURAM       0x00040000
-#define ERR_INTR_EN_IRAM        0x00020000
-#define ERR_INTR_EN_10G_MAC0    0x00008000
-#define ERR_INTR_EN_10G_MAC1    0x00000040
-#define ERR_INTR_EN_1G_MAC0     0x00004000
-#define ERR_INTR_EN_1G_MAC1     0x00002000
-#define ERR_INTR_EN_1G_MAC2     0x00001000
-#define ERR_INTR_EN_1G_MAC3     0x00000800
-#define ERR_INTR_EN_1G_MAC4     0x00000400
-#define ERR_INTR_EN_1G_MAC5     0x00000200
-#define ERR_INTR_EN_1G_MAC6     0x00000100
-#define ERR_INTR_EN_1G_MAC7     0x00000080
-#define ERR_INTR_EN_MACSEC_MAC0 0x00000001
-
-
-typedef uint32_t t_FmBlockIntrEnable;
-
-#define INTR_EN_QMI             0x40000000
-#define INTR_EN_PRS             0x20000000
-#define INTR_EN_PLCR            0x08000000
-#define INTR_EN_1G_MAC0         0x00080000
-#define INTR_EN_1G_MAC1         0x00040000
-#define INTR_EN_1G_MAC2         0x00020000
-#define INTR_EN_1G_MAC3         0x00010000
-#define INTR_EN_1G_MAC4         0x00000040
-#define INTR_EN_1G_MAC5         0x00000020
-#define INTR_EN_1G_MAC6         0x00000008
-#define INTR_EN_1G_MAC7         0x00000002
-#define INTR_EN_10G_MAC0        0x00200000
-#define INTR_EN_10G_MAC1        0x00100000
-#define INTR_EN_REV0            0x00008000
-#define INTR_EN_REV1            0x00004000
-#define INTR_EN_REV2            0x00002000
-#define INTR_EN_REV3            0x00001000
-#define INTR_EN_BRK             0x00000080
-#define INTR_EN_TMR             0x01000000
-#define INTR_EN_MACSEC_MAC0     0x00000001
-/* @} */
-
 #define FM_MAX_NUM_OF_PORTS     (FM_MAX_NUM_OF_OH_PORTS +     \
                                  FM_MAX_NUM_OF_1G_RX_PORTS +  \
                                  FM_MAX_NUM_OF_10G_RX_PORTS + \
@@ -487,11 +434,11 @@ typedef uint32_t t_FmBlockIntrEnable;
 /**************************************************************************//**
  @Description       Port Id defines
 *//***************************************************************************/
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
 #define BASE_OH_PORTID              1
 #else
 #define BASE_OH_PORTID              2
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 #define BASE_1G_RX_PORTID           8
 #define BASE_10G_RX_PORTID          0x10
 #define BASE_1G_TX_PORTID           0x28
@@ -674,305 +621,20 @@ switch(hdr)                                                 \
 }
 
 /***********************************************************************/
-/*          SW parser IP_FRAG patch                                    */
+/*          SW parser patch flags                                      */
 /***********************************************************************/
-#if (DPAA_VERSION == 2)
-/* Version: 106.5 */
-#define SW_PRS_IP_FRAG_PATCH                           \
-{                                                      \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
-    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
-    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0, \
-    0x00,0x4A,0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x28,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x53,0x8F,0x00,0x00,0x32,0xC1,0x00,0x55, \
-    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
-    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
-    0x43,0x42,0x00,0x00,0x30,0x7E,0x43,0x42,0x00,0x3C, \
-    0x1B,0x5C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
-    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
-    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
-    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x1B,0x3B,0x30,0x7E,0x53,0x72,0x00,0x2B, \
-    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00, \
-    0x9B,0x8E,0x53,0x86,0x00,0x00,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
-    0x00,0x55,0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x43,0x1B,0xC0,0x32,0xC1,0x00,0x55, \
-    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
-    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
-    0x43,0xB7,0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F, \
-    0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x1B,0x9A,0x00,0x03,0x00,0x02, \
-    0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0,0x00,0x4A, \
-    0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE,           \
-};
+#if (DPAA_VERSION == 10)
 #define IP_FRAG_SW_PATCH_IPv4                   0x300
 #define IP_FRAG_SW_PATCH_IPv6                   0x31E
+
 #else
-/* version: 106.5 */
-#define SW_PRS_IP_FRAG_PATCH                           \
-{                                                      \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
-    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x2A,0x34,0xF5, \
-    0x00,0xFB,0xFF,0xFF,0x00,0x7F,0x00,0x00,0x00,0x00, \
-    0x2A,0x9F,0x34,0xB7,0x00,0xF9,0x00,0x00,0x01,0x00, \
-    0x00,0x00,0x00,0x00,0x2B,0x97,0x00,0x03,0x00,0x02, \
-    0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0,0x00,0x4F, \
-    0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE,0x31,0x52, \
-    0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00,0x00,0x00, \
-    0x43,0x36,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52, \
-    0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00, \
-    0x53,0x9D,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06, \
-    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x50, \
-    0x00,0x00,0x30,0x7E,0x43,0x50,0x00,0x3C,0x1B,0x6A, \
-    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
-    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
-    0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
-    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
-    0x1B,0x49,0x30,0x7E,0x53,0x80,0x00,0x2B,0x32,0x11, \
-    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
-    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E, \
-    0x53,0x94,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55, \
-    0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x43,0x1B,0xDC,0x32,0xC1,0x00,0x55,0x00,0x06, \
-    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xC5, \
-    0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
-    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
-    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
-    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x1B,0xA8,0x34,0xF5,0x00,0xFB,0xFF,0xFF, \
-    0x00,0x7F,0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7, \
-    0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00, \
-    0x2B,0x97,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01, \
-    0x32,0xC1,0x32,0xF0,0x00,0x4A,0x00,0x80,0x1F,0xFF, \
-    0x00,0x01,0x1B,0xFE,                               \
-};
 #define IP_FRAG_SW_PATCH_IPv4                   0x300
 #define IP_FRAG_SW_PATCH_IPv6                   0x32C
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
-/***********************************************************************/
-/*          Policer defines                                            */
-/***********************************************************************/
-#define FM_PCD_PLCR_PAR_GO                    0x80000000
-#define FM_PCD_PLCR_PAR_PWSEL_MASK            0x0000FFFF
-#define FM_PCD_PLCR_PAR_R                     0x40000000
-
-/* shifts */
-#define FM_PCD_PLCR_PAR_PNUM_SHIFT            16
-
-
-/***********************************************************************/
-/*          Keygen defines                                             */
-/***********************************************************************/
-/* maskes */
-#if DPAA_VERSION >= 3
-#define KG_SCH_VSP_SHIFT_MASK                   0x0003f000
-#define KG_SCH_OM_VSPE                          0x00000001
-#define KG_SCH_VSP_NO_KSP_EN                    0x80000000
-
-#define MAX_SP_SHIFT                            23
-#define KG_SCH_VSP_MASK_SHIFT                   12
-#define KG_SCH_VSP_SHIFT                        24
-#endif /* DPAA_VERSION >= 3 */
-
-#define KG_SCH_PP_SHIFT_HIGH                    0x80000000
-#define KG_SCH_PP_NO_GEN                        0x10000000
-#define KG_SCH_PP_SHIFT_LOW                     0x0000F000
-#define KG_SCH_MODE_NIA_PLCR                    0x40000000
-#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
-#define KG_SCH_BITMASK_MASK                     0x000000FF
-#define KG_SCH_GEN_VALID                        0x80000000
-#define KG_SCH_GEN_MASK                         0x00FF0000
-#define FM_PCD_KG_KGAR_ERR                      0x20000000
-#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY       0x01000000
-#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY           0x02000000
-#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP         0x00008000
-#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP        0x00004000
-#define FM_PCD_KG_KGAR_WSEL_MASK                0x0000FF00
-#define KG_SCH_HASH_CONFIG_NO_FQID              0x80000000
-#define KG_SCH_HASH_CONFIG_SYM                  0x40000000
-
-#define FM_PCD_KG_KGAR_GO                       0x80000000
-#define FM_PCD_KG_KGAR_READ                     0x40000000
-#define FM_PCD_KG_KGAR_WRITE                    0x00000000
-#define FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY         0x00000000
-#define FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT   0x00008000
-
-
-typedef uint32_t t_KnownFieldsMasks;
-
-#define KG_SCH_KN_PORT_ID                   0x80000000
-#define KG_SCH_KN_MACDST                    0x40000000
-#define KG_SCH_KN_MACSRC                    0x20000000
-#define KG_SCH_KN_TCI1                      0x10000000
-#define KG_SCH_KN_TCI2                      0x08000000
-#define KG_SCH_KN_ETYPE                     0x04000000
-#define KG_SCH_KN_PPPSID                    0x02000000
-#define KG_SCH_KN_PPPID                     0x01000000
-#define KG_SCH_KN_MPLS1                     0x00800000
-#define KG_SCH_KN_MPLS2                     0x00400000
-#define KG_SCH_KN_MPLS_LAST                 0x00200000
-#define KG_SCH_KN_IPSRC1                    0x00100000
-#define KG_SCH_KN_IPDST1                    0x00080000
-#define KG_SCH_KN_PTYPE1                    0x00040000
-#define KG_SCH_KN_IPTOS_TC1                 0x00020000
-#define KG_SCH_KN_IPV6FL1                   0x00010000
-#define KG_SCH_KN_IPSRC2                    0x00008000
-#define KG_SCH_KN_IPDST2                    0x00004000
-#define KG_SCH_KN_PTYPE2                    0x00002000
-#define KG_SCH_KN_IPTOS_TC2                 0x00001000
-#define KG_SCH_KN_IPV6FL2                   0x00000800
-#define KG_SCH_KN_GREPTYPE                  0x00000400
-#define KG_SCH_KN_IPSEC_SPI                 0x00000200
-#define KG_SCH_KN_IPSEC_NH                  0x00000100
-#define KG_SCH_KN_L4PSRC                    0x00000004
-#define KG_SCH_KN_L4PDST                    0x00000002
-#define KG_SCH_KN_TFLG                      0x00000001
-
-typedef uint8_t t_GenericCodes;
-
-#define KG_SCH_GEN_SHIM1                       0x70
-#define KG_SCH_GEN_DEFAULT                     0x10
-#define KG_SCH_GEN_PARSE_RESULT_N_FQID         0x20
-#define KG_SCH_GEN_START_OF_FRM                0x40
-#define KG_SCH_GEN_SHIM2                       0x71
-#define KG_SCH_GEN_IP_PID_NO_V                 0x72
-#define KG_SCH_GEN_ETH                         0x03
-#define KG_SCH_GEN_ETH_NO_V                    0x73
-#define KG_SCH_GEN_SNAP                        0x04
-#define KG_SCH_GEN_SNAP_NO_V                   0x74
-#define KG_SCH_GEN_VLAN1                       0x05
-#define KG_SCH_GEN_VLAN1_NO_V                  0x75
-#define KG_SCH_GEN_VLAN2                       0x06
-#define KG_SCH_GEN_VLAN2_NO_V                  0x76
-#define KG_SCH_GEN_ETH_TYPE                    0x07
-#define KG_SCH_GEN_ETH_TYPE_NO_V               0x77
-#define KG_SCH_GEN_PPP                         0x08
-#define KG_SCH_GEN_PPP_NO_V                    0x78
-#define KG_SCH_GEN_MPLS1                       0x09
-#define KG_SCH_GEN_MPLS2                       0x19
-#define KG_SCH_GEN_MPLS3                       0x29
-#define KG_SCH_GEN_MPLS1_NO_V                  0x79
-#define KG_SCH_GEN_MPLS_LAST                   0x0a
-#define KG_SCH_GEN_MPLS_LAST_NO_V              0x7a
-#define KG_SCH_GEN_IPV4                        0x0b
-#define KG_SCH_GEN_IPV6                        0x1b
-#define KG_SCH_GEN_L3_NO_V                     0x7b
-#define KG_SCH_GEN_IPV4_TUNNELED               0x0c
-#define KG_SCH_GEN_IPV6_TUNNELED               0x1c
-#define KG_SCH_GEN_MIN_ENCAP                   0x2c
-#define KG_SCH_GEN_IP2_NO_V                    0x7c
-#define KG_SCH_GEN_GRE                         0x0d
-#define KG_SCH_GEN_GRE_NO_V                    0x7d
-#define KG_SCH_GEN_TCP                         0x0e
-#define KG_SCH_GEN_UDP                         0x1e
-#define KG_SCH_GEN_IPSEC_AH                    0x2e
-#define KG_SCH_GEN_SCTP                        0x3e
-#define KG_SCH_GEN_DCCP                        0x4e
-#define KG_SCH_GEN_IPSEC_ESP                   0x6e
-#define KG_SCH_GEN_L4_NO_V                     0x7e
-#define KG_SCH_GEN_NEXTHDR                     0x7f
-
-/* shifts */
-#define KG_SCH_PP_SHIFT_HIGH_SHIFT          27
-#define KG_SCH_PP_SHIFT_LOW_SHIFT           12
-#define KG_SCH_PP_MASK_SHIFT                16
-#define KG_SCH_MODE_CCOBASE_SHIFT           24
-#define KG_SCH_DEF_MAC_ADDR_SHIFT           30
-#define KG_SCH_DEF_TCI_SHIFT                28
-#define KG_SCH_DEF_ENET_TYPE_SHIFT          26
-#define KG_SCH_DEF_PPP_SESSION_ID_SHIFT     24
-#define KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT    22
-#define KG_SCH_DEF_MPLS_LABEL_SHIFT         20
-#define KG_SCH_DEF_IP_ADDR_SHIFT            18
-#define KG_SCH_DEF_PROTOCOL_TYPE_SHIFT      16
-#define KG_SCH_DEF_IP_TOS_TC_SHIFT          14
-#define KG_SCH_DEF_IPV6_FLOW_LABEL_SHIFT    12
-#define KG_SCH_DEF_IPSEC_SPI_SHIFT          10
-#define KG_SCH_DEF_L4_PORT_SHIFT            8
-#define KG_SCH_DEF_TCP_FLAG_SHIFT           6
-#define KG_SCH_HASH_CONFIG_SHIFT_SHIFT      24
-#define KG_SCH_GEN_MASK_SHIFT               16
-#define KG_SCH_GEN_HT_SHIFT                 8
-#define KG_SCH_GEN_SIZE_SHIFT               24
-#define KG_SCH_GEN_DEF_SHIFT                29
-#define FM_PCD_KG_KGAR_NUM_SHIFT            16
-
-
-/* others */
-#define NUM_OF_SW_DEFAULTS                  3
-#define MAX_PP_SHIFT                        23
-#define MAX_KG_SCH_SIZE                     16
-#define MASK_FOR_GENERIC_BASE_ID            0x20
-#define MAX_HASH_SHIFT                      40
-#define MAX_KG_SCH_FQID_BIT_OFFSET          31
-#define MAX_KG_SCH_PP_BIT_OFFSET            15
-#define MAX_DIST_FQID_SHIFT                 23
-
-#define GET_MASK_SEL_SHIFT(shift,i)             \
-switch(i) {                                     \
-    case(0):shift = 26;break;                   \
-    case(1):shift = 20;break;                   \
-    case(2):shift = 10;break;                   \
-    case(3):shift = 4;break;                    \
-    default:                                    \
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
-}
-
-#define GET_MASK_OFFSET_SHIFT(shift,i)          \
-switch(i) {                                     \
-    case(0):shift = 16;break;                   \
-    case(1):shift = 0;break;                    \
-    case(2):shift = 28;break;                   \
-    case(3):shift = 24;break;                   \
-    default:                                    \
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
-}
-
-#define GET_MASK_SHIFT(shift,i)                 \
-switch(i) {                                     \
-    case(0):shift = 24;break;                   \
-    case(1):shift = 16;break;                   \
-    case(2):shift = 8;break;                    \
-    case(3):shift = 0;break;                    \
-    default:                                    \
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
-}
 
 #define FM_PCD_MAX_NUM_OF_OPTIONS(clsPlanEntries)   ((clsPlanEntries==256)? 8:((clsPlanEntries==128)? 7: ((clsPlanEntries==64)? 6: ((clsPlanEntries==32)? 5:0))))
 
-typedef struct {
-    uint16_t num;
-    uint8_t  hardwarePortId;
-    uint16_t plcrProfilesBase;
-} t_FmPortPcdInterModulePlcrParams;
-
 /**************************************************************************//**
  @Description   A structure for initializing a keygen classification plan group
 *//***************************************************************************/
@@ -988,18 +650,28 @@ typedef struct t_FmPcdKgInterModuleClsPlanGrpParams {
                                /* OUT in FmPcdGetSetClsPlanGrpParams IN in FmPcdKgBuildClsPlanGrp*/
 } t_FmPcdKgInterModuleClsPlanGrpParams;
 
+typedef struct t_FmPcdLock {
+    t_Handle        h_Spinlock;
+    volatile bool   flag;
+    t_List          node;
+} t_FmPcdLock;
+#define FM_PCD_LOCK_OBJ(ptr)  LIST_OBJECT(ptr, t_FmPcdLock, node)
+
 
 typedef t_Error (t_FmPortGetSetCcParamsCallback) (t_Handle                  h_FmPort,
                                                   t_FmPortGetSetCcParams    *p_FmPortGetSetCcParams);
 
 
+/***********************************************************************/
+/*          Common API for FM-PCD module                               */
+/***********************************************************************/
 t_Handle    FmPcdGetHcHandle(t_Handle h_FmPcd);
 uint32_t    FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t  indexPerHdr);
 uint32_t    FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum);
 uint32_t    FmPcdGetMacsecLcv(t_Handle h_FmPcd, uint32_t netEnvId);
 void        FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
 void        FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
-uint8_t		FmPcdGetNetEnvId(t_Handle h_NetEnv);
+uint8_t     FmPcdGetNetEnvId(t_Handle h_NetEnv);
 void        FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId);
 uint32_t    FmPcdLock(t_Handle h_FmPcd);
 void        FmPcdUnlock(t_Handle h_FmPcd, uint32_t  intFlags);
@@ -1008,37 +680,32 @@ t_Error     FmPcdFragHcScratchPoolInit(t_Handle h_FmPcd, uint8_t scratchBpid);
 t_Error     FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl);
 t_Error     FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl);
 bool        FmPcdIsAdvancedOffloadSupported(t_Handle h_FmPcd);
+bool        FmPcdLockTryLockAll(t_Handle h_FmPcd);
+void        FmPcdLockUnlockAll(t_Handle h_FmPcd);
 
+/***********************************************************************/
+/*          Common API for FM-PCD KG module                            */
+/***********************************************************************/
 uint8_t     FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp);
 uint16_t    FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp);
-t_Error 	FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
 t_Error     FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
+
+t_Error     FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
 uint8_t     FmPcdKgGetSchemeId(t_Handle h_Scheme);
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 bool        FmPcdKgGetVspe(t_Handle h_Scheme);
-#endif
+#endif /* (DPAA_VERSION >= 11) */
 uint8_t     FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
 void        FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId);
-//void        FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
-//void        FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
 t_Error     FmPcdKgCheckInvalidateSchemeSw(t_Handle h_Scheme);
 t_Error     FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPortToSchemes, uint32_t *p_SpReg, bool add);
-void        FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
-void        FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
-bool        FmPcdKgIsDriverClsPlan(t_Handle h_FmPcd);
 bool        FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg);
-uint32_t    FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
 uint32_t    FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter);
 uint32_t    FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId);
 uint32_t    FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId);
-uint32_t    FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId);
 uint32_t    FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId);
 uint32_t    FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId);
 uint32_t    FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId);
-uint8_t     FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId);
-/*t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, t_Handle h_Scheme);*/
-/*void        FmPcdKgReleaseSchemeLock(t_Handle h_Scheme);*/
-void        FmPcdKgUpatePointedOwner(t_Handle h_Scheme, bool add);
 bool        FmPcdKgIsSchemeValidSw(t_Handle h_Scheme);
 
 t_Error     FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind);
@@ -1055,10 +722,14 @@ t_Error     FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t
 t_Error     FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp);
 t_Error     FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
 
-/* FM-PCD parser API routines */
+/***********************************************************************/
+/*          Common API for FM-PCD parser module                        */
+/***********************************************************************/
 t_Error     FmPcdPrsIncludePortInStatistics(t_Handle p_FmPcd, uint8_t hardwarePortId,  bool include);
 
-/* FM-PCD policer API routines */
+/***********************************************************************/
+/*          Common API for FM-PCD policer module                       */
+/***********************************************************************/
 t_Error     FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles);
 t_Error     FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId);
 bool        FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId);
@@ -1078,8 +749,6 @@ t_Error     FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle
 void        FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 void        FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 bool        FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg);
-/*t_Error     FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId, bool intr);
-void        FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId);*/
 uint32_t    FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 uint32_t    FmPcdPlcrGetPointedOwners(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 void        FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bool add);
@@ -1099,8 +768,6 @@ t_Error     FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmP
 t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint16_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
-t_Error     FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree);
-void        FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree);
 t_Handle    FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree);
 void        FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams);
 t_Error     FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_NetEnv, t_Handle h_IpReassemblyManip, bool schemes);
@@ -1115,12 +782,11 @@ uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
 uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
 uint32_t    FmPortGetPcdEngines(t_Handle h_FmPort);
 void        FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort);
-t_Error     FmPortAttachPCD(t_Handle h_FmPort);
 
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error     FmPcdFrmReplicUpdate(t_Handle h_FmPcd, t_Handle h_FmPort, t_Handle h_FrmReplic);
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
  @Function      FmRegisterIntr
@@ -1407,7 +1073,6 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 *//***************************************************************************/
 t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls, t_FmFmanCtrl orFmanCtrl);
 
-
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 /**************************************************************************//*
  @Function      FmDumpPortRegs
@@ -1424,8 +1089,6 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
 t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
-
-
 void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
 void        FmUnregisterPcd(t_Handle h_Fm);
 t_Handle    FmGetPcdHandle(t_Handle h_Fm);
@@ -1467,7 +1130,7 @@ t_Error     FmSetCongestionGroupPFCpriority(t_Handle    h_Fm,
                                             uint32_t    congestionGroupId,
                                             uint8_t     priorityBitMap);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error     FmVSPAlloc(t_Handle         h_Fm,
                                e_FmPortType     portType,
                                uint8_t          portId,
@@ -1484,8 +1147,7 @@ t_Error     FmVSPGetAbsoluteProfileId(t_Handle      h_Fm,
                                       uint16_t      *p_AbsoluteId);
 
 uintptr_t   FmGetVSPBaseAddr(t_Handle h_Fm);
-
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 #endif /* __FM_COMMON_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
index c28760f..8f45906 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __FM_HC_H
 #define __FM_HC_H
 
@@ -55,7 +56,7 @@ t_Error     FmHcDumpRegs(t_Handle h_FmHc);
 
 void        FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd);
 
-t_Error    	FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemeParams *p_Scheme);
+t_Error     FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemeParams *p_Scheme);
 t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
 t_Error     FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams );
 t_Error     FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams);
@@ -68,7 +69,7 @@ uint32_t    FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme);
 
 t_Error     FmHcPcdCcDoDynamicChange(t_Handle h_FmHc, uint32_t oldAdAddrOffset, uint32_t newAdAddrOffset);
 
-t_Error 	FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileParams *p_ProfileParams);
+t_Error     FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileParams *p_ProfileParams);
 t_Error     FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile);
 
 t_Error     FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h
index af71d96..0675444 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h
@@ -46,6 +46,7 @@
 #include "fm_ext.h"
 #include "fm_pcd_ext.h"
 
+
 /* sizes */
 #define CAPWAP_FRAG_EXTRA_SPACE                 32
 #define OFFSET_UNITS                            16
@@ -57,18 +58,17 @@
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
-#define DEFAULT_FM_SP_bufferPrefixContent_privDataSize   0
-#define DEFAULT_FM_SP_bufferPrefixContent_passPrsResult  FALSE
-#define DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp  FALSE
-#define DEFAULT_FM_SP_bufferPrefixContent_allOtherPCDInfo    FALSE
-//#define DEFAULT_FM_SP_bufferPrefixContent_dataAlign      DATA_ALIGNMENT - // TODO should be this way
-#define DEFAULT_FM_SP_bufferPrefixContent_dataAlign      64
-#define DEFAULT_FM_SP_dmaSwapData                        e_FM_DMA_NO_SWP
-#define DEFAULT_FM_SP_dmaIntContextCacheAttr             e_FM_DMA_NO_STASH
-#define DEFAULT_FM_SP_dmaHeaderCacheAttr                 e_FM_DMA_NO_STASH
-#define DEFAULT_FM_SP_dmaScatterGatherCacheAttr          e_FM_DMA_NO_STASH
-#define DEFAULT_FM_SP_dmaWriteOptimize                   FALSE
-#define DEFAULT_FM_SP_noScatherGather                   FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_privDataSize      0
+#define DEFAULT_FM_SP_bufferPrefixContent_passPrsResult     FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp     FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_allOtherPCDInfo   FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_dataAlign         64
+#define DEFAULT_FM_SP_dmaSwapData                           e_FM_DMA_NO_SWP
+#define DEFAULT_FM_SP_dmaIntContextCacheAttr                e_FM_DMA_NO_STASH
+#define DEFAULT_FM_SP_dmaHeaderCacheAttr                    e_FM_DMA_NO_STASH
+#define DEFAULT_FM_SP_dmaScatterGatherCacheAttr             e_FM_DMA_NO_STASH
+#define DEFAULT_FM_SP_dmaWriteOptimize                      TRUE
+#define DEFAULT_FM_SP_noScatherGather                       FALSE
 
 /**************************************************************************//**
  @Description       Registers bit fields
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
index a6fcb4c..4c7a697 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /*
 
  @File          error.c
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
index 99c340a..2d044be 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          list.c
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
index e72be23..e366ee7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
@@ -31,6 +31,7 @@
  */
 
 
+
 #include "std_ext.h"
 #include "xx_ext.h"
 #include "memcpy_ext.h"
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
index 00a1d2a..7b9d201 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #include "string_ext.h"
 #include "error_ext.h"
 #include "std_ext.h"
@@ -813,7 +814,7 @@ uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
     }
 
     /* Decreasing the allocated memory size from free memory size */
-	p_MM->freeMemSize -= size;
+    p_MM->freeMemSize -= size;
 
     /* insert the new busy block into the list of busy blocks */
     AddBusy ( p_MM, p_NewBusyB );
@@ -901,7 +902,7 @@ uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, uint64_t alignment, uint64
     }
 
     /* Decreasing the allocated memory size from free memory size */
-	p_MM->freeMemSize -= size;
+    p_MM->freeMemSize -= size;
 
     /* insert the new busy block into the list of busy blocks */
     AddBusy( p_MM, p_NewBusyB );
@@ -954,7 +955,7 @@ uint64_t MM_Put(t_Handle h_MM, uint64_t base)
     size = p_BusyB->end - p_BusyB->base;
 
     /* Adding the deallocated memory size to free memory size */
-	p_MM->freeMemSize += size;
+    p_MM->freeMemSize += size;
 
     XX_Free(p_BusyB);
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
@@ -986,7 +987,7 @@ uint64_t MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size)
     }
 
     /* Adding the deallocated memory size to free memory size */
-	p_MM->freeMemSize += size;
+    p_MM->freeMemSize += size;
 
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
 
@@ -1046,7 +1047,7 @@ t_Error MM_Add(t_Handle h_MM, uint64_t base, uint64_t size)
     }
 
     /* Adding the new block size to free memory size */
-	p_MM->freeMemSize += size;
+    p_MM->freeMemSize += size;
 
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
 
@@ -1103,11 +1104,11 @@ bool MM_InRange(t_Handle h_MM, uint64_t addr)
 /*****************************************************************************/
 uint64_t MM_GetFreeMemSize(t_Handle h_MM)
 {
-	t_MM       *p_MM = (t_MM*)h_MM;
+    t_MM       *p_MM = (t_MM*)h_MM;
 
-	ASSERT_COND(p_MM);
+    ASSERT_COND(p_MM);
 
-	return p_MM->freeMemSize;
+    return p_MM->freeMemSize;
 }
 
 /*****************************************************************************/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
index ed46e9f..43b2298 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /****************************************************************
  *
  * File:  mm.h
@@ -90,14 +91,14 @@ typedef struct t_BusyBlock
 /* t_MM data structure defines parameters of the MM object */
 typedef struct t_MM
 {
-	t_Handle        h_Spinlock;
+    t_Handle        h_Spinlock;
 
-	t_MemBlock      *memBlocks;     /* List of memory blocks (Memory list) */
+    t_MemBlock      *memBlocks;     /* List of memory blocks (Memory list) */
     t_BusyBlock     *busyBlocks;    /* List of busy blocks (Busy list) */
     t_FreeBlock     *freeBlocks[MM_MAX_ALIGNMENT + 1];
                                     /* Alignment lists of free blocks (Free lists) */
 
-    uint64_t		freeMemSize;	/* Total size of free memory (in bytes) */
+    uint64_t        freeMemSize;    /* Total size of free memory (in bytes) */
 } t_MM;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
index 3dfd308..46d2956 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /*------------------------------------------------------*/
 /* File: sprint.c                                       */
 /*                                                      */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
index 4745fb1..a84d563 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /*------------------------------------------------------*/
 /*                                                      */
 /* File: crc_mac_addr_ext.h                             */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
index 03457d5..ba40f53 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          dpaa_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index d00b6da..0c279ae 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_ext.h
 
@@ -335,13 +336,14 @@ typedef struct t_FmBufferPrefixContent {
                                          get the parser-result from a buffer. */
     bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
                                          AD, hash-result, key, etc. */
-    uint16_t    dataAlign;          /**< 0 to use driver's default alignment, other value
+    uint16_t    dataAlign;          /**< 0 to use driver's default alignment
+									 [DEFAULT_PORT_bufferPrefixContent_dataAlign], other value
                                          for selecting a data alignment (must be a
-                                         power of 2) */
+                                         power of 2); if write optimization is used, must be >= 16. */
     uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size);
                                          Note that this field impacts the size of the buffer-prefix
-                                         (i.e. it pushes the data offset); in addition, in some cases
-                                         (like DPAA_VERSION>2 and it is related to Rx FM-Port) */
+                                         (i.e. it pushes the data offset);
+                                         This field is irrelevant if DPAA_VERSION==10 */
 } t_FmBufferPrefixContent;
 
 /**************************************************************************//**
@@ -394,10 +396,10 @@ typedef struct t_FmBufPoolDepletion {
     bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_POOLS];
                                                     /**< For each pool, TRUE if it should be considered for
                                                          depletion (Note - this pool must be used by this port!) */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool        pfcPrioritiesEn[FM_MAX_NUM_OF_PFC_PRIORITIES];
                                                     /**< This field is used by the MAC as the Priority Enable Vector in the PFC frame which is transmitted */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmBufPoolDepletion;
 
 /**************************************************************************//**
@@ -439,14 +441,14 @@ typedef struct t_FmParams {
     t_FmFirmwareParams      firmware;               /**< The firmware parameters structure;
                                                          Relevant when guestId = NCSW_MASTER_ID only. */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     uintptr_t               vspBaseAddr;            /**< A pointer to base of memory mapped FM VSP registers (virtual);
                                                          i.e. up to 24KB, depending on the specific chip. */
     uint8_t                 partVSPBase;            /**< The first Virtual-Storage-Profile-id dedicated to this partition.
                                                          NOTE: this parameter relevant only when working with multiple partitions. */
     uint8_t                 partNumOfVSPs;          /**< Number of VSPs dedicated to this partition.
                                                          NOTE: this parameter relevant only when working with multiple partitions. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmParams;
 
 
@@ -1601,6 +1603,7 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
 /** @} */ /* end of FM_lib_grp group */
 /** @} */ /* end of FM_grp group */
 
+
 #ifdef NCSW_BACKWARD_COMPATIBLE_API
 typedef t_FmBufferPrefixContent     t_FmPortBufferPrefixContent;
 typedef t_FmExtPoolParams           t_FmPortExtPoolParams;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index 6d341b1..d28b0bc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_mac_ext.h
 
@@ -112,7 +113,7 @@ typedef enum e_FmMacStatisticsLevel {
 } e_FmMacStatisticsLevel;
 
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Description   Priority Flow Control Parameters
 *//***************************************************************************/
@@ -125,7 +126,7 @@ typedef struct t_FmMacPfcParams {
 
 
 } t_FmMacPfcParams;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
  @Function      t_FmMacExceptionCallback
@@ -542,6 +543,7 @@ t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
                 Where applicable, the routine also enables the MIB counters
                 overflow interrupt in order to keep counters accurate
                 and account for overflows.
+                This routine is relevant only for dTSEC.
 
  @Param[in]     h_FmMac         - A handle to a FM MAC Module.
  @Param[in]     statisticsLevel - Full statistics level provides all standard counters but may
@@ -561,7 +563,7 @@ t_Error FM_MAC_SetStatistics(t_Handle h_FmMac, e_FmMacStatisticsLevel statistics
  @Description   get all statistics counters
 
  @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
- @Param[in]     p_Statistics  -  Staructure with statistics
+ @Param[in]     p_Statistics  -  Structure with statistics
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -659,6 +661,7 @@ t_Error FM_MAC_SetPromiscuous(t_Handle h_FmMac, bool enable);
  @Function      FM_MAC_AdjustLink
 
  @Description   Adjusts the Ethernet link with new speed/duplex setup.
+                This routine is relevant only for dTSEC.
 
  @Param[in]     h_FmMac     - A handle to a FM Module.
  @Param[in]     speed       - Ethernet speed.
@@ -670,6 +673,24 @@ t_Error FM_MAC_SetPromiscuous(t_Handle h_FmMac, bool enable);
 t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
 
 /**************************************************************************//**
+ @Function      FM_MAC_RestartAutoneg
+
+ @Description   Restarts the autonegotiation process.
+                When autonegegotiation process is invoked under traffic the
+                autonegotiation process between the internal TBI PHY and the
+                external PHY does not always complete succesfuly. Calling this
+                function will restart the autonegotiation process that will end
+                succesfuly. It is recomended to call this function after issuing
+                autoneg restart command to the Eth Phy.
+                This routine is relevant only for dTSEC.
+
+ @Param[in]     h_FmMac     - A handle to a FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MAC_RestartAutoneg(t_Handle h_FmMac);
+
+/**************************************************************************//**
  @Function      FM_MAC_GetId
 
  @Description   Return the MAC ID
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
index e73f516..ef62c8e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_muram_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 0556687..39055c0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -30,10 +30,11 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_pcd_ext.h
 
- @Description   FM PCD ...
+ @Description   FM PCD API definitions
 *//***************************************************************************/
 #ifndef __FM_PCD_EXT
 #define __FM_PCD_EXT
@@ -106,9 +107,9 @@
 #define FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
                                                                              insert manipulation */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 #define FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 /* @} */
 
 
@@ -292,8 +293,8 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd);
  @Function      FM_PCD_ConfigException
 
  @Description   Calling this routine changes the internal driver data base
-                from its default selection of exceptions enablement.
-                By default all exceptions are enabled.
+                from its default selection of exceptions enabling.
+                [4].
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     exception       The exception to be selected.
@@ -812,10 +813,11 @@ typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
 #define IPV6_MULTICAST_2            0x00200000  /**< Tunneled IPv6 - Multicast. */
 
 #define IPV6_FRAG_1                 0x00000004  /**< IPV6 reassembly option.
-                                                     IPV6 Reassembly manipulation requires an IPV4 network
-                                                     environment unit with IPV4_FRAG_1 option  */
+                                                     IPV6 Reassembly manipulation requires network
+                                                     environment with IPV6 header and IPV6_FRAG_1 option  */
 /* @} */
 
+
 /**************************************************************************//**
  @Description   A type used for returning the order of the key extraction.
                 each value in this array represents the index of the extraction
@@ -835,7 +837,9 @@ typedef enum e_FmPcdEngine {
     e_FM_PCD_CC,            /**< Coarse classifier */
     e_FM_PCD_PLCR,          /**< Policer */
     e_FM_PCD_PRS,           /**< Parser */
+#if (DPAA_VERSION >= 11)
     e_FM_PCD_FR,            /**< Frame-Replicator */
+#endif /* (DPAA_VERSION >= 11) */
     e_FM_PCD_HASH           /**< Hash table */
 } e_FmPcdEngine;
 
@@ -1018,8 +1022,10 @@ typedef enum e_FmPcdAction {
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrInsrtType {
     e_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
     e_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
+#endif /* defined (FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_FM_HM) */
+#ifdef FM_CAPWAP_SUPPORT
     e_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
 #endif /* FM_CAPWAP_SUPPORT */
 } e_FmPcdManipHdrInsrtType;
@@ -1029,13 +1035,13 @@ typedef enum e_FmPcdManipHdrInsrtType {
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrRmvType {
     e_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
     e_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* defined (FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_FM_HM) */
 } e_FmPcdManipHdrRmvType;
 
 
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of header removal
 *//***************************************************************************/
@@ -1044,7 +1050,7 @@ typedef enum e_FmPcdManipHdrRmvByHdrType {
     e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START            /**< Locate from data that is not the header */
 #endif /* FM_CAPWAP_SUPPORT */
 } e_FmPcdManipHdrRmvByHdrType;
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* defined (FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_FM_HM) */
 
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of timeout mode
@@ -1126,25 +1132,126 @@ typedef union u_FmPcdHdrProtocolOpt {
 } u_FmPcdHdrProtocolOpt;
 
 /**************************************************************************//**
- @Description   A union holding all known protocol fields
+ @Description   A union holding protocol fields
+
+
+				Fields supported as "full fields":
+                    HEADER_TYPE_ETH:
+						NET_HEADER_FIELD_ETH_DA
+						NET_HEADER_FIELD_ETH_SA
+						NET_HEADER_FIELD_ETH_TYPE
+
+                    HEADER_TYPE_LLC_SNAP:
+					    NET_HEADER_FIELD_LLC_SNAP_TYPE
+
+                    HEADER_TYPE_VLAN:
+						NET_HEADER_FIELD_VLAN_TCI
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_LAST)
+
+					HEADER_TYPE_MPLS:
+					    NET_HEADER_FIELD_MPLS_LABEL_STACK
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2,
+								 e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv4:
+                        NET_HEADER_FIELD_IPv4_SRC_IP
+                        NET_HEADER_FIELD_IPv4_DST_IP
+                        NET_HEADER_FIELD_IPv4_PROTO
+						NET_HEADER_FIELD_IPv4_TOS
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv6:
+                        NET_HEADER_FIELD_IPv6_SRC_IP
+                        NET_HEADER_FIELD_IPv6_DST_IP
+                        NET_HEADER_FIELD_IPv6_NEXT_HDR
+						NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC (must come together!)
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+					HEADER_TYPE_GRE:
+                        NET_HEADER_FIELD_GRE_TYPE
+
+                    HEADER_TYPE_MINENCAP
+						NET_HEADER_FIELD_MINENCAP_SRC_IP
+						NET_HEADER_FIELD_MINENCAP_DST_IP
+						NET_HEADER_FIELD_MINENCAP_TYPE
+
+					HEADER_TYPE_TCP:
+                        NET_HEADER_FIELD_TCP_PORT_SRC
+                        NET_HEADER_FIELD_TCP_PORT_DST
+						NET_HEADER_FIELD_TCP_FLAGS
+
+					HEADER_TYPE_UDP:
+                        NET_HEADER_FIELD_UDP_PORT_SRC
+                        NET_HEADER_FIELD_UDP_PORT_DST
+
+					HEADER_TYPE_IPSEC_AH:
+                        NET_HEADER_FIELD_IPSEC_AH_SPI
+                        NET_HEADER_FIELD_IPSEC_AH_NH
+
+					HEADER_TYPE_IPSEC_ESP:
+					    NET_HEADER_FIELD_IPSEC_ESP_SPI
+
+					HEADER_TYPE_SCTP:
+					    NET_HEADER_FIELD_SCTP_PORT_SRC
+						NET_HEADER_FIELD_SCTP_PORT_DST
+
+					HEADER_TYPE_DCCP:
+					    NET_HEADER_FIELD_DCCP_PORT_SRC
+						NET_HEADER_FIELD_DCCP_PORT_DST
+
+					HEADER_TYPE_PPPoE:
+                        NET_HEADER_FIELD_PPPoE_PID
+					    NET_HEADER_FIELD_PPPoE_SID
+
+		*****************************************************************
+				Fields supported as "from fields":
+                    HEADER_TYPE_ETH (with or without validation):
+						NET_HEADER_FIELD_ETH_TYPE
+
+                    HEADER_TYPE_VLAN (with or without validation):
+						NET_HEADER_FIELD_VLAN_TCI
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv4 (without validation):
+                        NET_HEADER_FIELD_IPv4_PROTO
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv6 (without validation):
+                        NET_HEADER_FIELD_IPv6_NEXT_HDR
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
 *//***************************************************************************/
 typedef union t_FmPcdFields {
-    headerFieldEth_t            eth;            /**< eth      */
-    headerFieldVlan_t           vlan;           /**< vlan     */
-    headerFieldLlcSnap_t        llcSnap;        /**< llcSnap  */
-    headerFieldPppoe_t          pppoe;          /**< pppoe    */
-    headerFieldMpls_t           mpls;           /**< mpls     */
-    headerFieldIpv4_t           ipv4;           /**< ipv4     */
-    headerFieldIpv6_t           ipv6;           /**< ipv6     */
-    headerFieldUdp_t            udp;            /**< udp      */
-    headerFieldTcp_t            tcp;            /**< tcp      */
-    headerFieldSctp_t           sctp;           /**< sctp     */
-    headerFieldDccp_t           dccp;           /**< dccp     */
-    headerFieldGre_t            gre;            /**< gre      */
-    headerFieldMinencap_t       minencap;       /**< minencap */
-    headerFieldIpsecAh_t        ipsecAh;        /**< ipsecAh  */
-    headerFieldIpsecEsp_t       ipsecEsp;       /**< ipsecEsp */
-    headerFieldUdpEncapEsp_t    udpEncapEsp;    /**< udpEncapEsp */
+    headerFieldEth_t            eth;            /**< Ethernet               */
+    headerFieldVlan_t           vlan;           /**< VLAN                   */
+    headerFieldLlcSnap_t        llcSnap;        /**< LLC SNAP               */
+    headerFieldPppoe_t          pppoe;          /**< PPPoE                  */
+    headerFieldMpls_t           mpls;           /**< MPLS                   */
+    headerFieldIpv4_t           ipv4;           /**< IPv4                   */
+    headerFieldIpv6_t           ipv6;           /**< IPv6                   */
+    headerFieldUdp_t            udp;            /**< UDP                    */
+    headerFieldTcp_t            tcp;            /**< TCP                    */
+    headerFieldSctp_t           sctp;           /**< SCTP                   */
+    headerFieldDccp_t           dccp;           /**< DCCP                   */
+    headerFieldGre_t            gre;            /**< GRE                    */
+    headerFieldMinencap_t       minencap;       /**< Minimal Encapsulation  */
+    headerFieldIpsecAh_t        ipsecAh;        /**< IPSec AH               */
+    headerFieldIpsecEsp_t       ipsecEsp;       /**< IPSec ESP              */
+    headerFieldUdpEncapEsp_t    udpEncapEsp;    /**< UDP Encapsulation ESP  */
 } t_FmPcdFields;
 
 /**************************************************************************//**
@@ -1354,7 +1461,7 @@ typedef struct t_FmPcdKgPlcrProfile {
     } profileSelect;                                /**< Direct/indirect profile selection and parameters */
 } t_FmPcdKgPlcrProfile;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Description   Parameters for configuring a storage profile for a KeyGen scheme.
 *//***************************************************************************/
@@ -1380,7 +1487,7 @@ typedef struct t_FmPcdKgStorageProfile {
         } indirectProfile;                          /**< Indirect profile parameters. */
     } profileSelect;                                /**< Direct/indirect profile selection and parameters. */
 } t_FmPcdKgStorageProfile;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
  @Description   Parameters for defining CC as the next engine after KeyGen
@@ -1435,10 +1542,10 @@ typedef struct t_FmPcdKgSchemeParams {
                                                                      for qidMask. Driver will return error if
                                                                      resource is full at initialization time. */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool                                overrideStorageProfile; /**< TRUE if KeyGen override previously decided storage profile */
     t_FmPcdKgStorageProfile             storageProfile;         /**< Used when overrideStorageProfile TRUE */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     e_FmPcdEngine                       nextEngine;             /**< may be BMI, PLCR or CC */
     union {                                                     /**< depends on nextEngine */
@@ -1457,6 +1564,15 @@ typedef struct t_FmPcdCcNextCcParams {
     t_Handle    h_CcNode;               /**< A handle of the next CC node */
 } t_FmPcdCcNextCcParams;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining Frame replicator as the next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextFrParams {
+    t_Handle    h_FrmReplic;               /**< A handle of the next frame replicator group */
+} t_FmPcdCcNextFrParams;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Parameters for defining Policer as the next engine after a CC node.
 *//***************************************************************************/
@@ -1474,12 +1590,12 @@ typedef struct t_FmPcdCcNextPlcrParams {
                                              In earlier chips  if policer next engine is KEYGEN,
                                              this parameter can be 0, because the KEYGEN
                                              always decides the enqueue FQID.*/
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     uint8_t     newRelativeStorageProfileId;
                                         /**< Indicates the relative storage profile offset within
                                              the port's storage profiles window;
                                              Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmPcdCcNextPlcrParams;
 
 /**************************************************************************//**
@@ -1487,35 +1603,36 @@ typedef struct t_FmPcdCcNextPlcrParams {
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextEnqueueParams {
     e_FmPcdDoneAction    action;        /**< Action - when next engine is BMI (done) */
-    bool                 overrideFqid;  /**< TRUE if CC override previously decided FQID (by KeyGen),
+    bool                 overrideFqid;  /**< TRUE if CC override previously decided fqid and vspid,
                                              relevant if action = e_FM_PCD_ENQ_FRAME */
     uint32_t             newFqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
                                              (otherwise FQID is taken from KeyGen),
                                              relevant if action = e_FM_PCD_ENQ_FRAME */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     uint8_t              newRelativeStorageProfileId;
-                                        /**< Indicates the relative storage profile offset within
-                                             the port's storage profiles window;
-                                             Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+                                        /**< Valid if overrideFqid=TRUE, Indicates the relative virtual
+                                             storage profile offset within the port's storage profiles
+                                             window; Relevant only if the port was configured with VSP. */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmPcdCcNextEnqueueParams;
 
 /**************************************************************************//**
  @Description   Parameters for defining KeyGen as the next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextKgParams {
-    bool        overrideFqid;           /**< TRUE if CC override previously decided FQID (by KeyGen),
+    bool        overrideFqid;           /**< TRUE if CC override previously decided fqid and vspid,
                                              Note - this parameters irrelevant for earlier chips */
     uint32_t    newFqid;                /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
                                              (otherwise FQID is taken from KeyGen),
                                              Note - this parameters irrelevant for earlier chips */
-    t_Handle    h_DirectScheme;         /**< Direct scheme handle to go to. */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     uint8_t     newRelativeStorageProfileId;
-                                        /**< Indicates the relative storage profile offset within
-                                             the port's storage profiles window;
-                                             Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+                                        /**< Valid if overrideFqid=TRUE, Indicates the relative virtual
+                                             storage profile offset within the port's storage profiles
+                                             window; Relevant only if the port was configured with VSP. */
+#endif /* (DPAA_VERSION >= 11) */
+
+    t_Handle    h_DirectScheme;         /**< Direct scheme handle to go to. */
 } t_FmPcdCcNextKgParams;
 
 /**************************************************************************//**
@@ -1529,11 +1646,10 @@ typedef struct t_FmPcdCcNextEngineParams {
         t_FmPcdCcNextPlcrParams         plcrParams;     /**< Parameters in case next engine is PLCR */
         t_FmPcdCcNextEnqueueParams      enqueueParams;  /**< Parameters in case next engine is BMI */
         t_FmPcdCcNextKgParams           kgParams;       /**< Parameters in case next engine is KG */
-#if DPAA_VERSION >= 3
-        t_Handle                        h_FrmReplic;    /**< Handle to frame replicator group;
-                                                             Relevant if next engine is e_FM_PCD_INVALID) */
-#endif /* DPAA_VERSION >= 3 */
-    } params;
+#if (DPAA_VERSION >= 11)
+        t_FmPcdCcNextFrParams           frParams;       /**< Parameters in case next engine is FR */
+#endif /* (DPAA_VERSION >= 11) */
+    } params;                                           /**< union used for all the next-engine parameters options */
 
     t_Handle                            h_Manip;        /**< Handle to Manipulation object.
                                                              Relevant if next engine is of type result
@@ -1559,7 +1675,6 @@ typedef struct t_FmPcdCcKeyParams {
 
 /**************************************************************************//**
  @Description   Parameters for defining CC keys parameters
-
                 The driver supports two methods for CC node allocation: dynamic and static.
                 Static mode was created in order to prevent runtime alloc/free
                 of FMan memory (MURAM), which may cause fragmentation; in this mode,
@@ -1567,30 +1682,37 @@ typedef struct t_FmPcdCcKeyParams {
                 'maxNumOfKeys' parameter. The driver calculates the maximal memory
                 size that may be used for this CC-Node taking into consideration
                 'maskSupport' and 'statisticsMode' parameters.
-                In dynamic mode, 'maxNumOfKeys' must be zeroed. At initialization,
+                When 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
+                parameters of this node, 'maxNumOfKeys' must be equal to 'numOfKeys'.
+                In dynamic mode, 'maxNumOfKeys' must be zero. At initialization,
                 all required structures are allocated according to 'numOfKeys'
                 parameter. During runtime modification, these structures are
                 re-allocated according to the updated number of keys.
+
+                Please note that 'action' and 'icIndxMask' mentioned in the
+                specific parameter explanations are passed in the extraction
+                parameters of the node (fields of extractCcParams.extractNonHdr).
 *//***************************************************************************/
 typedef struct t_KeysParams {
     uint16_t                    maxNumOfKeys;   /**< Maximum number of keys that will (ever) be used in this CC-Node;
                                                      A value of zero may be used for dynamic memory allocation. */
     bool                        maskSupport;    /**< This parameter is relevant only if a node is initialized with
-                                                     action = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
-                                                     Should be TRUE if the node was initialized 'empty' (no keys)
-                                                     or with keys without masks, and user wants to be able to add
-                                                     a mask to a key later on in run-time. */
-    e_FmPcdCcStatsMode          statisticsMode; /**< If enabled, the required structures for the requested statistics
-                                                     mode will be allocated according to 'maxNumOfKeys'. */
+                                                     'action' = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
+                                                     Should be TRUE to reserve table memory for key masks, even if
+                                                     initial keys do not contain masks, or if the node was initialized
+                                                     as 'empty' (without keys); this will allow user to add keys with
+                                                     masks at runtime. */
+    e_FmPcdCcStatsMode          statisticsMode; /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for
+                                                     the requested statistics mode will be allocated according to
+                                                     'maxNumOfKeys'. */
     uint16_t                    numOfKeys;      /**< Number of initial keys;
-                                                     Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP
-                                                     (but the 'src' is not e_FM_PCD_EXTRACT_FROM_HASH; in this case,
-                                                     'numOfKeys' should be zero), this field should be power-of-2
-                                                     of the number of bits that are set in 'icIndxMask'. */
-    uint8_t                     keySize;        /**< Size of key - for extraction of type FULL_FIELD, keySize has
+                                                     Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP,
+                                                     this field should be power-of-2 of the number of bits that are
+                                                     set in 'icIndxMask'. */
+    uint8_t                     keySize;        /**< Size of key - for extraction of type FULL_FIELD, 'keySize' has
                                                      to be the standard size of the selected key; For other extraction
-                                                     types, keySize has to be as size of extraction; When 'action' =
-                                                     e_FM_PCD_ACTION_INDEXED_LOOKUP, keySize has to be 2. */
+                                                     types, 'keySize' has to be as size of extraction; When 'action' =
+                                                     e_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
     t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
                                                 /**< An array with 'numOfKeys' entries, each entry specifies the
                                                      corresponding key parameters. */
@@ -1599,6 +1721,7 @@ typedef struct t_KeysParams {
                                                      Not relevant if action = e_FM_PCD_ACTION_INDEXED_LOOKUP. */
 } t_KeysParams;
 
+
 /**************************************************************************//**
  @Description   Parameters for defining a CC node
 *//***************************************************************************/
@@ -1612,8 +1735,8 @@ typedef struct t_FmPcdCcNodeParams {
 *//***************************************************************************/
 typedef struct t_FmPcdHashTableParams {
     uint16_t                    maxNumOfKeys;               /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
-    e_FmPcdCcStatsMode          statisticsMode;             /**< If enabled, the required structures for the requested statistics
-                                                                 mode will be allocated according to maxNumOfKeys. */
+    e_FmPcdCcStatsMode          statisticsMode;             /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
+                                                                 requested statistics mode will be allocated according to maxNumOfKeys. */
     uint16_t                    hashResMask;                /**< Mask that will be used on the hash-result;
                                                                  The number-of-sets for this hash will be calculated
                                                                  as (2^(number of bits set in 'hashResMask'));
@@ -1623,7 +1746,6 @@ typedef struct t_FmPcdHashTableParams {
     uint8_t                     matchKeySize;               /**< Size of the exact match keys held by the hash buckets */
 
     t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;  /**< Parameters for defining the next engine when a key is not matched */
-
 } t_FmPcdHashTableParams;
 
 /**************************************************************************//**
@@ -1825,10 +1947,12 @@ typedef struct t_FmPcdManipFragOrReasmParams {
     bool                                frag;               /**< TRUE if using the structure for fragmentation,
                                                                  otherwise this structure is used for reassembly */
     uint8_t                             sgBpid;             /**< Scatter/Gather buffer pool id;
-                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
-                                                             of this pool need to be allocated in the same memory area as the received buffers.
-                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
-                                                             mutual to all these sources. */
+                                                                 Same LIODN number is used for these buffers as for
+                                                                 the received frames buffers, so buffers of this pool
+                                                                 need to be allocated in the same memory area as the
+                                                                 received buffers. If the received buffers arrive
+                                                                 from different sources, the Scatter/Gather BP id
+                                                                 should be mutual to all these sources. */
     e_NetHeaderType                     hdr;                /**< Header selection */
     union {
         t_CapwapFragmentationParams     capwapFragParams;   /**< Structure for CAPWAP fragmentation,
@@ -1840,7 +1964,7 @@ typedef struct t_FmPcdManipFragOrReasmParams {
 
 #endif /* FM_CAPWAP_SUPPORT */
 
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
 /**************************************************************************//**
  @Description   Parameters for defining header removal by header type
 *//***************************************************************************/
@@ -1856,7 +1980,7 @@ typedef struct t_FmPcdManipHdrRmvByHdrParams {
 #endif /* FM_CAPWAP_SUPPORT */
     } u;
 } t_FmPcdManipHdrRmvByHdrParams;
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* defined(FM_CAPWAP_SUPPORT) || defined (UNDER_CONSTRUCTION_FM_HM) */
 
 /**************************************************************************//**
  @Description   Parameters for configuring IP fragmentation manipulation
@@ -1864,9 +1988,9 @@ typedef struct t_FmPcdManipHdrRmvByHdrParams {
 typedef struct t_FmPcdManipFragIpParams {
     uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
                                                              IP fragmentation will be executed.*/
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     uint8_t                     scratchBpid;            /**< Absolute buffer pool id according to BM configuration.*/
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
     bool                        sgBpidEn;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
                                                              If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
                                                              received frame's buffer. */
@@ -1894,9 +2018,6 @@ typedef struct t_FmPcdManipReassemIpParams {
                                                                  Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
                                                                  the user schemes id to ensure that the reassemblys schemes will be first match.
                                                                  Rest schemes, if defined, should have higher relative scheme ID. */
-#ifdef UNDER_CONSTRUCTION_V3_IPR
-    t_Handle                        h_CouplingFmPort;       /**< Must be given if storage profile virtualization is required */
-#endif /* UNDER_CONSTRUCTION_V3_IPR */
     uint8_t                         sgBpid;                 /**< Buffer pool id for the S/G frame created by the reassembly process */
     uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
     uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
@@ -1966,20 +2087,17 @@ typedef struct t_FmPcdManipHdrInsrtGenericParams {
 } t_FmPcdManipHdrInsrtGenericParams;
 
 
-
 /**************************************************************************//**
  @Description   Parameters for defining header insertion manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipHdrInsrtParams {
-    e_FmPcdManipHdrInsrtType                    type;   /**< Type of insertion manipulation */
+    e_FmPcdManipHdrInsrtType                    type;       /**< Type of insertion manipulation */
     union {
-        t_FmPcdManipHdrInsrtGenericParams       generic;
-                                                        /**< Parameters for defining generic header insertion manipulation,
-                                                             relevant if type = e_FM_PCD_MANIP_INSRT_GENERIC */
+        t_FmPcdManipHdrInsrtGenericParams       generic;    /**< Parameters for defining generic header insertion manipulation,
+                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_GENERIC */
 #ifdef FM_CAPWAP_SUPPORT
-        t_FmPcdManipHdrInsrtByTemplateParams    byTemplate;
-                                                        /**< Parameters for defining header insertion manipulation by template,
-                                                             relevant if type = e_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
+        t_FmPcdManipHdrInsrtByTemplateParams    byTemplate; /**< Parameters for defining header insertion manipulation by template,
+                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
 #endif /* FM_CAPWAP_SUPPORT */
     } u;
 } t_FmPcdManipHdrInsrtParams;
@@ -1990,10 +2108,10 @@ typedef struct t_FmPcdManipHdrInsrtParams {
 typedef struct t_FmPcdManipHdrRmvParams {
     e_FmPcdManipHdrRmvType                  type;       /**< Type of header removal manipulation */
     union {
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
         t_FmPcdManipHdrRmvByHdrParams       byHdr;      /**< Parameters for defining header removal manipulation by header type,
                                                              relevant if type = e_FM_PCD_MANIP_RMV_BY_HDR */
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* defined (FM_CAPWAP_SUPPORT) || defined (UNDER_CONSTRUCTION_FM_HM) */
         t_FmPcdManipHdrRmvGenericParams     generic;    /**< Parameters for defining generic header removal manipulation,
                                                              relevant if type = e_FM_PCD_MANIP_RMV_GENERIC */
     } u;
@@ -2004,10 +2122,10 @@ typedef struct t_FmPcdManipHdrRmvParams {
 *//***************************************************************************/
 typedef struct t_FmPcdManipHdrParams {
     bool                                        rmv;                /**< TRUE, to define removal manipulation */
-    t_FmPcdManipHdrRmvParams                    rmvParams;          /**< Parameters for removal manipulation, relevant if rmv = TRUE */
+    t_FmPcdManipHdrRmvParams                    rmvParams;          /**< Parameters for removal manipulation, relevant if 'rmv' = TRUE */
 
     bool                                        insrt;              /**< TRUE, to define insertion manipulation */
-    t_FmPcdManipHdrInsrtParams                  insrtParams;        /**< Parameters for insertion manipulation, relevant if insrt = TRUE */
+    t_FmPcdManipHdrInsrtParams                  insrtParams;        /**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
 
 
     bool                                        dontParseAfterManip;/**< FALSE to activate the parser a second time after
@@ -2015,7 +2133,7 @@ typedef struct t_FmPcdManipHdrParams {
 } t_FmPcdManipHdrParams;
 
 /**************************************************************************//**
- @Description   structure for defining fragmentation manipulation
+ @Description   Parameters for defining fragmentation manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipFragParams {
     e_NetHeaderType                     hdr;          /**< Header selection */
@@ -2026,7 +2144,7 @@ typedef struct t_FmPcdManipFragParams {
 } t_FmPcdManipFragParams;
 
 /**************************************************************************//**
- @Description   structure for defining reassemble manipulation
+ @Description   Parameters for defining reassembly manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipReassemParams {
     e_NetHeaderType                     hdr;          /**< Header selection */
@@ -2047,8 +2165,10 @@ typedef struct t_FmPcdManipParams {
         t_FmPcdManipFragParams              frag;               /**< Parameters for defining fragmentation manipulation node */
         t_FmPcdManipSpecialOffloadParams    specialOffload;     /**< Parameters for defining special offload manipulation node */
     } u;
-     t_Handle                               h_NextManip;        /**< Handle to another (previously defined) manipulation node;
-                                                                     Allows concatenation of manipulation actions */
+
+    t_Handle                                h_NextManip;        /**< Handle to another (previously defined) manipulation node;
+                                                                     Allows concatenation of manipulation actions;
+                                                                     This parameter is optional and may be NULL. */
 #ifdef FM_CAPWAP_SUPPORT
     bool                                    fragOrReasm;        /**< TRUE, if defined fragmentation/reassembly manipulation */
     t_FmPcdManipFragOrReasmParams           fragOrReasmParams;  /**< Parameters for fragmentation/reassembly manipulation,
@@ -2061,13 +2181,13 @@ typedef struct t_FmPcdManipParams {
 *//***************************************************************************/
 typedef struct t_FmPcdManipReassemIpStats {
     /* common counters for both IPv4 and IPv6 */
-    uint32_t    timeout;                        /**< Counts the number of TimeOut occurrences */
-    uint32_t    rfdPoolBusy;                    /**< Counts the number of failed attempts to allocate
+    uint32_t        timeout;                    /**< Counts the number of TimeOut occurrences */
+    uint32_t        rfdPoolBusy;                /**< Counts the number of failed attempts to allocate
                                                      a Reassembly Frame Descriptor */
-    uint32_t    internalBufferBusy;             /**< Counts the number of times an internal buffer busy occurred */
-    uint32_t    externalBufferBusy;             /**< Counts the number of times external buffer busy occurred */
-    uint32_t    sgFragments;                    /**< Counts the number of Scatter/Gather fragments */
-    uint32_t    dmaSemaphoreDepletion;          /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    uint32_t        internalBufferBusy;         /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t        externalBufferBusy;         /**< Counts the number of times external buffer busy occurred */
+    uint32_t        sgFragments;                /**< Counts the number of Scatter/Gather fragments */
+    uint32_t        dmaSemaphoreDepletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
     struct {
         uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
         uint32_t    validFragments;             /**< Counts the total number of valid fragments that
@@ -2102,7 +2222,7 @@ typedef struct t_FmPcdManipReassemStats {
 } t_FmPcdManipReassemStats;
 
 /**************************************************************************//**
- @Description   structure for retrieving fragmentation statistics
+ @Description   Structure for retrieving fragmentation statistics
 *//***************************************************************************/
 typedef struct t_FmPcdManipFragStats {
     union {
@@ -2111,26 +2231,37 @@ typedef struct t_FmPcdManipFragStats {
 } t_FmPcdManipFragStats;
 
 /**************************************************************************//**
- @Description   structure for defining manipulation statistics
+ @Description   Structure for selecting manipulation statistics
 *//***************************************************************************/
 typedef struct t_FmPcdManipStats {
-    union{
+    union {
         t_FmPcdManipReassemStats    reassem;    /**< Structure for reassembly statistics */
         t_FmPcdManipFragStats       frag;       /**< Structure for fragmentation statistics */
     } u;
 } t_FmPcdManipStats;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Description   Parameters for defining frame replicator group and its members
 *//***************************************************************************/
 typedef struct t_FmPcdFrmReplicGroupParams {
-    uint8_t                     maxNumOfEntries;    /**< Maximal number of members in the group  - must be at least two */
-    uint8_t                     numOfEntries;       /**< Number of members in the group - must be at least 1 */
+    uint8_t                     maxNumOfEntries;    /**< Maximal number of members in the group;
+                                                         Must be at least 2. */
+    uint8_t                     numOfEntries;       /**< Number of members in the group;
+                                                         Must be at least 1. */
     t_FmPcdCcNextEngineParams   nextEngineParams[FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
                                                     /**< Array of members' parameters */
 } t_FmPcdFrmReplicGroupParams;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   structure for defining statistics node
+*//***************************************************************************/
+typedef struct t_FmPcdStatsParams {
+    e_FmPcdStatsType    type;   /**< type of statistics node */
+} t_FmPcdStatsParams;
+#endif /* FM_CAPWAP_SUPPORT */
 
 
 /**************************************************************************//**
@@ -2207,6 +2338,9 @@ t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv);
  @Param[in,out] p_SchemeParams  A structure of parameters for defining the scheme
 
  @Return        A handle to the initialized scheme on success; NULL code otherwise.
+                When used as "modify" (rather than for setting a new scheme),
+                p_SchemeParams->id.h_Scheme will return NULL if action fails due to scheme
+                BUSY state.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
@@ -2265,7 +2399,9 @@ t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value);
                                   policer profile entry.
 
  @Return        A handle to the initialized object on success; NULL code otherwise.
-
+                When used as "modify" (rather than for setting a new profile),
+                p_Profile->id.h_Profile will return NULL if action fails due to profile
+                BUSY state.
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 t_Handle FM_PCD_PlcrProfileSet(t_Handle                  h_FmPcd,
@@ -2320,7 +2456,7 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle                   h_Profile,
                                      uint32_t                   value);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcRoot
+ @Function      FM_PCD_CcRootBuild
 
  @Description   This routine must be called to define a complete coarse
                 classification tree. This is the way to define coarse
@@ -2358,7 +2494,7 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree);
  @Param[in]     h_CcTree                    A handle to the tree
  @Param[in]     grpId                       A Group index in the tree
  @Param[in]     index                       Entry index in the group defined by grpId
- @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+ @Param[in]     p_FmPcdCcNextEngineParams   Pointer to new next engine parameters
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -2370,7 +2506,7 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
                                       t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_EmSetNode
+ @Function      FM_PCD_MatchTableSet
 
  @Description   This routine should be called for each CC (coarse classification)
                 node. The whole CC tree should be built bottom up so that each
@@ -2383,7 +2519,7 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle   FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams  *p_Param);
+t_Handle   FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_Param);
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableDelete
@@ -2496,7 +2632,7 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle            h_CcNode,
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableModifyKey
 
- @Description   Modify the key  in the index defined by the keyIndex.
+ @Description   Modify the key in the index defined by the keyIndex.
 
  @Param[in]     h_CcNode                    A handle to the node
  @Param[in]     keyIndex                    Key index for adding
@@ -2861,7 +2997,7 @@ t_Error  FM_PCD_ManipNodeDelete(t_Handle h_ManipNode);
 *//***************************************************************************/
 t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmPcdManipStats);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Function      FM_PCD_FrmReplicSetGroup
 
@@ -2921,17 +3057,10 @@ t_Error FM_PCD_FrmReplicAddMember(t_Handle                   h_FrmReplicGroup,
 *//***************************************************************************/
 t_Error FM_PCD_FrmReplicRemoveMember(t_Handle h_FrmReplicGroup,
                                      uint16_t memberIndex);
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 #ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
- @Description   structure for defining statistics node
-*//***************************************************************************/
-typedef struct t_FmPcdStatsParams {
-    e_FmPcdStatsType    type;   /**< type of statistics node */
-} t_FmPcdStatsParams;
-
-/**************************************************************************//**
  @Function      FM_PCD_StatisticsSetNode
 
  @Description   This routine should be called for defining a statistics node.
@@ -2952,8 +3081,11 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcds
 /** @} */ /* end of FM_grp group */
 
 
-#define NCSW_BACKWARD_COMPATIBLE_API
 #ifdef NCSW_BACKWARD_COMPATIBLE_API
+#define FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS   FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
+#define e_FM_PCD_MANIP_ONE_WAYS_HASH            e_FM_PCD_MANIP_ONE_WAY_HASH
+#define e_FM_PCD_MANIP_TOW_WAYS_HASH            e_FM_PCD_MANIP_TWO_WAYS_HASH
+
 #define FM_PCD_SetNetEnvCharacteristics(_pcd, _params)  \
     FM_PCD_NetEnvCharacteristicsSet(_pcd, _params)
 #define FM_PCD_KgSetScheme(_pcd, _params)       FM_PCD_KgSchemeSet(_pcd, _params)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 2aed870..64dc103 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_port_ext.h
 
@@ -280,7 +281,7 @@ typedef struct t_FmPortParams {
     u_FmPortSpecificParams      specificParams;     /**< Additional parameters depending on port
                                                          type. */
 
-    t_FmPortExceptionCallback   *f_Exception;       /**< Callback routine to be called of PCD exception */
+    t_FmPortExceptionCallback   *f_Exception;       /**< Relevant for IM only Callback routine to be called on BUSY exception */
     t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
                                                          be passed by the driver upon calling the above callbacks */
 } t_FmPortParams;
@@ -829,9 +830,17 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
 
  @Description   Calling this routine changes the write optimization
                 parameter in the internal driver data base
-                from its default configuration:  optimize = [DEFAULT_FM_SP_dmaWriteOptimize]
+                from its default configuration:  By default optimize = [DEFAULT_FM_SP_dmaWriteOptimize].
+                Note:
+
+                1. For head optimization, data alignment must be >= 16 (supported by default).
+
+                3. For tail optimization, note that the optimization is performed by extending the write transaction
+				of the frame payload at the tail as needed to achieve optimal bus transfers, so that the last write
+				is extended to be on 16/64 bytes aligned block (chip dependent).
+
 
-                May be used for non-Tx port types
+                Relevant for non-Tx port types
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
@@ -1148,6 +1157,23 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 *//***************************************************************************/
 t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigInternalBuffOffset
+
+ @Description   TODO
+                May be used for Rx and OP ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     val                 New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigInternalBuffOffset(t_Handle h_FmPort, uint8_t val);
+#endif /* (DPAA_VERSION >= 11) */
+
 /** @} */ /* end of FM_PORT_advanced_init_grp group */
 /** @} */ /* end of FM_PORT_init_grp group */
 
@@ -1202,12 +1228,12 @@ typedef struct t_FmPortCongestionGrps {
                                                         /**< An array of CG indexes;
                                                              Note that the size of the array should be
                                                              'numOfCongestionGrpsToConsider'. */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool        pfcPrioritiesEn[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
                                                         /**< a matrix that represents the map between the CG ids
                                                              defined in 'congestionGrpsToConsider' to the priorties
                                                              mapping array. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmPortCongestionGrps;
 
 
@@ -1852,7 +1878,7 @@ typedef struct t_FmPcdPrsStart {
                                              'parsingOffset' */
 } t_FmPcdPrsStart;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Description   struct for defining external buffer margins
 *//***************************************************************************/
@@ -1861,9 +1887,9 @@ typedef struct t_FmPortVSPAllocParams {
     uint8_t     dfltRelativeId;         /**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
                                              The same default Virtual-Storage-Profile-id will be for coupled Tx port
                                              if relevant function called for Rx port */
-    t_Handle    h_FmTxPort;             /**< Handle to coupled Tx Port */
+    t_Handle    h_FmTxPort;             /**< Handle to coupled Tx Port; not relevant for OP port. */
 } t_FmPortVSPAllocParams;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 /**************************************************************************//**
@@ -1970,7 +1996,7 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
 *//***************************************************************************/
 t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Function      FM_PORT_VSPAlloc
 
@@ -1987,7 +2013,7 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
                 and also before FM_PORT_Enable() (i.e. the port should be disabled).
 *//***************************************************************************/
 t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_Params);
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
  @Function      FM_PORT_PcdKgModifyInitialScheme
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
index 8436944..c8fa262 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_rtc_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h
index 311357e..f9aed03 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h
@@ -308,7 +308,7 @@ t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBm
 /** @} */ /* end of FM_VSP_adv_config_grp group */
 /** @} */ /* end of FM_VSP_init_grp group */
 
-#ifdef UNDER_CONSTRUCTION_FM_GEN
+
 /**************************************************************************//**
  @Group         FM_VSP_control_grp FM VSP Control Unit
 
@@ -318,35 +318,92 @@ t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBm
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Function      FM_VSP_GetStatistics
+ @Function      FM_VSP_GetBufferDataOffset
 
- @Description   Reads FM VSP counter.
+ @Description   Relevant for Rx ports.
+                Returns the data offset from the beginning of the data buffer
 
- @Param[in]     h_FmVsp             A handle to a FM VSP module.
+ @Param[in]     h_FmVsp - FM PORT module descriptor
 
- @Return        Counter's current value.
+ @Return        data offset.
 
  @Cautions      Allowed only following FM_VSP_Init().
-                Note that counters in summary of BM pools defined for this VSP
 *//***************************************************************************/
-uint32_t FM_VSP_GetStatistics(t_Handle h_FmVsp);
+uint32_t FM_VSP_GetBufferDataOffset(t_Handle h_FmVsp);
 
 /**************************************************************************//**
- @Function      FM_VSP_ModifyCounter
+ @Function      FM_VSP_GetBufferICInfo
 
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+ @Description   Returns the Internal Context offset from the beginning of the data buffer
 
- @Param[in]     h_FmVsp             A handle to a FM VSP module.
- @Param[in]     value               The requested value to be written into the counter.
+ @Param[in]     h_FmVsp - FM PORT module descriptor
+ @Param[in]     p_Data   - A pointer to the data buffer.
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        Internal context info pointer on success, NULL if 'allOtherInfo' was not
+                configured for this port.
 
  @Cautions      Allowed only following FM_VSP_Init().
 *//***************************************************************************/
-t_Error FM_VSP_ModifyCounter(t_Handle h_FmVsp, uint32_t value);
+uint8_t * FM_VSP_GetBufferICInfo(t_Handle h_FmVsp, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where parse result should be
+                initialized - if so configured.
+                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmVsp    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Parse result pointer on success, NULL if parse result was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+t_FmPrsResult * FM_VSP_GetBufferPrsResult(t_Handle h_FmVsp, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferTimeStamp
+
+ @Description   Returns the time stamp in the data buffer.
+                Relevant for Rx ports for getting the buffer time stamp.
+                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmVsp    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+uint64_t * FM_VSP_GetBufferTimeStamp(t_Handle h_FmVsp, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferHashResult
+
+ @Description   Given a data buffer, on the condition that hash result was defined
+                as a part of the buffer content (see FM_VSP_ConfigBufferPrefixContent)
+                this routine will return the pointer to the hash result location in the
+                buffer prefix.
+
+ @Param[in]     h_FmVsp    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+uint8_t * FM_VSP_GetBufferHashResult(t_Handle h_FmVsp, char *p_Data);
+
 
 /** @} */ /* end of FM_VSP_control_grp group */
-#endif /* UNDER_CONSTRUCTION_FM_GEN */
 /** @} */ /* end of FM_VSP_grp group */
 /** @} */ /* end of FM_grp group */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
index 5b38fdb..f635d3c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
@@ -31,6 +31,7 @@
  */
 
 
+
 #ifndef __MII_ACC_EXT_H
 #define __MII_ACC_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
index 4b0c1e5..42174cf 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          core_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
index 1beb5a6..099c7b9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          e500v2_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
index 57c2889..9344b3a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          ppc_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
index 706f35a..e3d5d8d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __CTYPE_EXT_H
 #define __CTYPE_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
index 1d915ea..0b15dda 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          debug_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
index 99b08e8..5cdec66 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          endian_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
index ae4b267..79d2e78 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          enet_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
index 5917edd..25ceb02 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**
  @File          error_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
index 822b2bc..bb5496b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          list_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
index e12f382..5284959 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          mem_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
index 6157bdc..59351fa 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          memcpy_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
index 740a4fd..085b95c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
  /**************************************************************************//**
 
  @File          mm_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
index ad5c412..4e34234 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
 
  @File          sprint_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
index edddfe1..3c6bbc6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**
 
  @File          dpaa_integration_ext.h
@@ -42,7 +43,7 @@
 #include "std_ext.h"
 
 
-#define DPAA_VERSION    2
+#define DPAA_VERSION    10
 
 typedef enum e_DpaaSwPortal {
     e_DPAA_SWPORTAL0 = 0,
@@ -212,7 +213,6 @@ typedef enum e_FmMacsecInterModuleEvent {
 
 #define FM_DEBUG_TRACE_FMAN_A004                        /* No implementation, Out of LLD scope */
 #define FM_INT_BUF_LEAK_FMAN_A005                       /* No implementation, Out of LLD scope. App must avoid S/G */
-//TODO: #define FM___ERRATA_FMAN_A006
 
 /* #define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
index 3253782..ac7a33a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**
 
  @File          part_integration_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index 389572d..270b61e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -42,7 +42,7 @@
 #include "std_ext.h"
 
 
-#define DPAA_VERSION    2
+#define DPAA_VERSION    10
 
 /**************************************************************************//**
  @Description   DPAA SW Portals Enumeration.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
index a622fc5..bff428d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __MATH_EXT_H
 #define __MATH_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
index a89b604..29df6f4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
  /**************************************************************************//**
  @File          ncsw_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
index 1c8aa58..c684647 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          net_ext.h
 
@@ -82,6 +83,7 @@ typedef uint8_t headerFieldEth_t;
 #define NET_HEADER_FIELD_ETH_PADDING                    (NET_HEADER_FIELD_ETH_DA << 5)
 #define NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((NET_HEADER_FIELD_ETH_DA << 6) - 1)
 
+#define NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
 
 typedef uint16_t headerFieldIpv4_t;
 
@@ -102,6 +104,9 @@ typedef uint16_t headerFieldIpv4_t;
 #define NET_HEADER_FIELD_IPv4_OPTS_COUNT                (NET_HEADER_FIELD_IPv4_VER << 14)
 #define NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((NET_HEADER_FIELD_IPv4_VER << 15) - 1)
 
+#define NET_HEADER_FIELD_IPv4_ADDR_SIZE                 4
+#define NET_HEADER_FIELD_IPv4_PROTO_SIZE                1
+
 
 typedef uint8_t headerFieldIpv6_t;
 
@@ -114,6 +119,9 @@ typedef uint8_t headerFieldIpv6_t;
 #define NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (NET_HEADER_FIELD_IPv6_VER << 6)
 #define NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((NET_HEADER_FIELD_IPv6_VER << 7) - 1)
 
+#define NET_HEADER_FIELD_IPv6_ADDR_SIZE                 16
+#define NET_HEADER_FIELD_IPv6_NEXT_HDR_SIZE             1
+
 #define NET_HEADER_FIELD_ICMP_TYPE                      (1)
 #define NET_HEADER_FIELD_ICMP_CODE                      (NET_HEADER_FIELD_ICMP_TYPE << 1)
 #define NET_HEADER_FIELD_ICMP_CKSUM                     (NET_HEADER_FIELD_ICMP_TYPE << 2)
@@ -121,6 +129,9 @@ typedef uint8_t headerFieldIpv6_t;
 #define NET_HEADER_FIELD_ICMP_SQ_NUM                    (NET_HEADER_FIELD_ICMP_TYPE << 4)
 #define NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
 
+#define NET_HEADER_FIELD_ICMP_CODE_SIZE                 1
+#define NET_HEADER_FIELD_ICMP_TYPE_SIZE                 1
+
 #define NET_HEADER_FIELD_IGMP_VERSION                   (1)
 #define NET_HEADER_FIELD_IGMP_TYPE                      (NET_HEADER_FIELD_IGMP_VERSION << 1)
 #define NET_HEADER_FIELD_IGMP_CKSUM                     (NET_HEADER_FIELD_IGMP_VERSION << 2)
@@ -143,6 +154,8 @@ typedef uint16_t headerFieldTcp_t;
 #define NET_HEADER_FIELD_TCP_OPTS_COUNT                 (NET_HEADER_FIELD_TCP_PORT_SRC << 10)
 #define NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
 
+#define NET_HEADER_FIELD_TCP_PORT_SIZE                  2
+
 
 typedef uint8_t headerFieldSctp_t;
 
@@ -152,6 +165,7 @@ typedef uint8_t headerFieldSctp_t;
 #define NET_HEADER_FIELD_SCTP_CKSUM                     (NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
 #define NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
 
+#define NET_HEADER_FIELD_SCTP_PORT_SIZE                 2
 
 typedef uint8_t headerFieldDccp_t;
 
@@ -159,6 +173,8 @@ typedef uint8_t headerFieldDccp_t;
 #define NET_HEADER_FIELD_DCCP_PORT_DST                  (NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
 #define NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
 
+#define NET_HEADER_FIELD_DCCP_PORT_SIZE                 2
+
 
 typedef uint8_t headerFieldUdp_t;
 
@@ -168,6 +184,8 @@ typedef uint8_t headerFieldUdp_t;
 #define NET_HEADER_FIELD_UDP_CKSUM                      (NET_HEADER_FIELD_UDP_PORT_SRC << 3)
 #define NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
 
+#define NET_HEADER_FIELD_UDP_PORT_SIZE                  2
+
 typedef uint8_t headerFieldUdpEncapEsp_t;
 
 #define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
@@ -178,6 +196,9 @@ typedef uint8_t headerFieldUdpEncapEsp_t;
 #define NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
 #define NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
 
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SIZE        2
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI_SIZE         4
+
 #define NET_HEADER_FIELD_IPHC_CID                       (1)
 #define NET_HEADER_FIELD_IPHC_CID_TYPE                  (NET_HEADER_FIELD_IPHC_CID << 1)
 #define NET_HEADER_FIELD_IPHC_HCINDEX                   (NET_HEADER_FIELD_IPHC_CID << 2)
@@ -326,6 +347,8 @@ typedef uint8_t headerFieldIpsecEsp_t;
 #define NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM         (NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
 #define NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
 
+#define NET_HEADER_FIELD_IPSEC_ESP_SPI_SIZE             4
+
 
 typedef uint8_t headerFieldMpls_t;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
index 95e452d..9bb18f4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
  /**************************************************************************//**
 
  @File          std_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
index 8037f7646..3c8bb0a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __STDARG_EXT_H
 #define __STDARG_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
index b3a8b57..a47860c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
@@ -31,6 +31,7 @@
  */
 
 
+
 #ifndef __STDLIB_EXT_H
 #define __STDLIB_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
index 298fdb8..a5c6c7e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __STRING_EXT_H
 #define __STRING_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
index 40e6bf9..29ab09c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
  /**************************************************************************//**
  @File          types_ext.h
 
@@ -63,21 +64,19 @@ static __inline__ void TypesChecker(void)
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
      _Packed struct strct {
         __volatile__ int vi;
     } _PackedType;
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
     size_t          size = 0;
     bool            tr = TRUE, fls = FALSE;
-    struct strct    *p_Strct = NULL;
+    struct strct    *p_Struct = NULL;
     physAddress_t   addr = 0x100;
 
-    tr      = fls;
-    p_Strct = p_Strct;
+    tr          = fls;
+    p_Struct    = p_Struct;
     size++;
     if (tr) size++;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
index 0721079..3a4ed69 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
@@ -31,6 +31,7 @@
  */
 
 
+
 /* Module names for debug messages */
 const char *moduleStrings[] =
 {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
index 2b3c6de..e45ea14 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
@@ -140,7 +140,7 @@
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
 #if CMP_IOC_DEFINE(FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES)
 #error Error: please synchronize IOC_ defines!
 #endif
@@ -358,7 +358,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_extracted_or_params_t) == sizeof(t_FmPcdKgExtractedOrParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_scheme_counter_t) == sizeof(t_FmPcdKgSchemeCounter));
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_plcr_profile_t) == sizeof(t_FmPcdKgPlcrProfile));
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_storage_profile_t) == sizeof(t_FmPcdKgStorageProfile));
 #endif
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_cc_t) == sizeof(t_FmPcdKgCc));
@@ -415,7 +415,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_stats_t) == sizeof(t_FmPcdManipReassemStats));
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_stats_t) == sizeof(t_FmPcdManipFragStats));
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_stats_t) == sizeof(t_FmPcdManipStats));
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     ASSERT_COND(sizeof(ioc_fm_pcd_frm_replic_group_params_t) == sizeof(t_FmPcdFrmReplicGroupParams));
 #endif
 
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index d48fd98..935b0c0 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -103,9 +103,9 @@
 #define IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
                                                                              insert manipulation */
 
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
 #define IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 /* @} */
 
@@ -972,7 +972,7 @@ typedef struct ioc_fm_pcd_kg_plcr_profile_t {
     } profile_select;
 } ioc_fm_pcd_kg_plcr_profile_t;
 
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
 /**************************************************************************//**
  @Description   Parameters for configuring a storage profile for a KeyGen scheme.
 *//***************************************************************************/
@@ -998,7 +998,7 @@ typedef struct ioc_fm_pcd_kg_storage_profile_t {
         } indirect_profile;                          /**< Indirect profile parameters. */
     } profile_select;                                /**< Direct/indirect profile selection and parameters. */
 } ioc_fm_pcd_kg_storage_profile_t;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 /**************************************************************************//**
  @Description   A structure for CC parameters if CC is the next engine after KG
@@ -1055,10 +1055,10 @@ typedef struct ioc_fm_pcd_kg_scheme_params_t {
                                                               actions; Normally only some will be used
                                                               for qidMask. Driver will return error if
                                                               resource is full at initialization time. */
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     bool                                override_storage_profile; /**< TRUE if KeyGen override previously decided storage profile */
     ioc_fm_pcd_kg_storage_profile       storage_profile;        /**< Used when overrideStorageProfile TRUE */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
     ioc_fm_pcd_engine                   next_engine;     /**< may be BMI, PLCR or CC */
     union{                                               /**< depends on nextEngine */
@@ -1098,12 +1098,12 @@ typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
                                                 In earlier chips  if policer next engine is KEYGEN,
                                                 this parameter can be 0, because the KEYGEN always decides
                                                 the enqueue FQID.*/
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     uint8_t     new_relative_storage_profileId;
                                         /**< Indicates the relative storage profile offset within
                                              the port's storage profiles window;
                                              Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 } ioc_fm_pcd_cc_next_plcr_params_t;
 
@@ -1118,12 +1118,12 @@ typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
     uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
                                                  (otherwise FQID is taken from keygen),
                                                  relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     uint8_t              new_relative_storage_profile_id;
                                         /**< Indicates the relative storage profile offset within
                                              the port's storage profiles window;
                                              Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 } ioc_fm_pcd_cc_next_enqueue_params_t;
 
@@ -1138,12 +1138,12 @@ typedef struct ioc_fm_pcd_cc_next_kg_params_t {
                                          (otherwise FQID is taken from keygen),
                                           Note - this parameters unrelevant for earlier chips*/
     void       *p_direct_scheme;        /**< Direct scheme handle to go to. */
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     uint8_t              new_relative_storage_profile_id;
                                         /**< Indicates the relative storage profile offset within
                                              the port's storage profiles window;
                                              Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 } ioc_fm_pcd_cc_next_kg_params_t;
 
 /**************************************************************************//**
@@ -1159,10 +1159,10 @@ typedef struct ioc_fm_pcd_cc_next_engine_params_t {
             ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
             ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
     } params;
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     void                                        *p_frm_replic_id; /**< Handle to frame replicator group;
                                                                        Relevant if next engine is e_FM_PCD_INVALID) */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
     void                                        *manip_id;      /**< Handle to Manipulation object.
                                                                      Relevant if next engine is of type result
@@ -1455,9 +1455,9 @@ typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
 typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
     uint16_t                    size_for_fragmentation;   /**< If length of the frame is greater than this value,
                                                              IP fragmentation will be executed.*/
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     uint8_t                     scratch_bpid;            /**< Absolute buffer pool id according to BM configuration.*/
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
     bool                        sg_bpid_en;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
                                                              If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
                                                              received frame's buffer. */
@@ -1702,7 +1702,7 @@ typedef struct ioc_fm_pcd_manip_stats_t {
     } u;
 } ioc_fm_pcd_manip_stats_t;
 
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
 /**************************************************************************//**
  @Description   Parameters for defining frame replicator group and its members
 *//***************************************************************************/
@@ -1712,7 +1712,7 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
     ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
                                                     /**< Array of members' parameters */
 } ioc_fm_pcd_frm_replic_group_params_t;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 /**************************************************************************//**
  @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
-- 
1.7.9.7

