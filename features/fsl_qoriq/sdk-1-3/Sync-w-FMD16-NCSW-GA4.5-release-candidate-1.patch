From 43fd68723de041c05c12c93cb51c65747dfd92a2 Mon Sep 17 00:00:00 2001
From: Andrei Pistirica <sorin.pistirica@freescale.com>
Date: Wed, 9 May 2012 17:50:24 +0300
Subject: [PATCH 062/162] Sync w/ FMD16 - NCSW GA4.5 release candidate 1.

Few API changed due to DPAA_VERSION support.
Update pcd module to meet NCSW.

Signed-off-by: Andrei Pistirica <sorin.pistirica@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c |   13 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c       |  200 +--
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h       |    4 +
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |    1 +
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |    1 +
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c      |   32 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h      |   12 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |   53 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.h        |    3 +-
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c    |    1 +
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h    |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h       |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       | 1145 +++++++++------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |   17 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       | 1533 ++++++++++----------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h       |  245 ++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    |  554 +++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |  163 ++-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |  595 +++++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |  292 +---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |   18 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     |  404 +++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h     |  165 +++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |   53 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h      |  172 +++
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |  684 +++++----
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |   23 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c      |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h      |    1 +
 .../dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c        |  110 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |  142 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.h    |   73 +-
 .../dpa/NetCommSw/Peripherals/FM/fm_ipc.h          |    1 +
 .../dpa/NetCommSw/Peripherals/FM/fm_muram.c        |    1 +
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |  418 +-----
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h       |    5 +-
 .../NetCommSw/Peripherals/FM/inc/fm_sp_common.h    |   24 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/error.c   |    1 +
 .../ethernet/freescale/dpa/NetCommSw/etc/list.c    |    1 +
 .../ethernet/freescale/dpa/NetCommSw/etc/memcpy.c  |    1 +
 .../net/ethernet/freescale/dpa/NetCommSw/etc/mm.c  |   17 +-
 .../net/ethernet/freescale/dpa/NetCommSw/etc/mm.h  |    7 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/sprint.c  |    1 +
 .../NetCommSw/inc/Peripherals/crc_mac_addr_ext.h   |    1 +
 .../dpa/NetCommSw/inc/Peripherals/dpaa_ext.h       |    1 +
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |   19 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h     |   27 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h   |    1 +
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |  386 +++--
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |   46 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h     |    1 +
 .../dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h     |   85 +-
 .../dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h    |    1 +
 .../freescale/dpa/NetCommSw/inc/core_ext.h         |    1 +
 .../freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h |    1 +
 .../freescale/dpa/NetCommSw/inc/cores/ppc_ext.h    |    1 +
 .../freescale/dpa/NetCommSw/inc/ctype_ext.h        |    1 +
 .../freescale/dpa/NetCommSw/inc/debug_ext.h        |    1 +
 .../freescale/dpa/NetCommSw/inc/endian_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/enet_ext.h         |    1 +
 .../freescale/dpa/NetCommSw/inc/error_ext.h        |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/list_ext.h     |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/mem_ext.h      |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h   |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/mm_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/sprint_ext.h   |    1 +
 .../inc/integrations/P1023/dpaa_integration_ext.h  |    4 +-
 .../inc/integrations/P1023/part_integration_ext.h  |    1 +
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |    2 +-
 .../freescale/dpa/NetCommSw/inc/math_ext.h         |    1 +
 .../freescale/dpa/NetCommSw/inc/ncsw_ext.h         |    1 +
 .../ethernet/freescale/dpa/NetCommSw/inc/net_ext.h |   23 +
 .../ethernet/freescale/dpa/NetCommSw/inc/std_ext.h |    1 +
 .../freescale/dpa/NetCommSw/inc/stdarg_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/stdlib_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/string_ext.h       |    1 +
 .../freescale/dpa/NetCommSw/inc/types_ext.h        |    9 +-
 .../NetCommSw/integrations/P1023/module_strings.c  |    1 +
 .../dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c   |    6 +-
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      |   36 +-
 81 files changed, 4528 insertions(+), 3332 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index df69aa9..376b996 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #include "std_ext.h"
 #include "error_ext.h"
 #include "sprint_ext.h"
@@ -62,11 +63,11 @@
 
 #define HC_HCOR_KG_SCHEME_COUNTER           0x00000400
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
 #define HC_HCOR_KG_SCHEME_REGS_MASK         0xFFFFF800
 #else
 #define HC_HCOR_KG_SCHEME_REGS_MASK         0xFFFFFE00
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
 #define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
 #define SIZE_OF_HC_FRAME_SCHEME_REGS        sizeof(t_HcFrame)
@@ -212,7 +213,7 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
         return NULL;
     }
 
-	err = FM_PORT_Enable(p_FmHc->h_HcPortDev);
+    err = FM_PORT_Enable(p_FmHc->h_HcPortDev);
     if (err != E_OK)
     {
         REPORT_ERROR(MAJOR, err, ("FM HC port!"));
@@ -294,7 +295,7 @@ t_Error FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemePa
 
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
-	RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
@@ -488,7 +489,7 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-	err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
+    err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
     if (err != E_OK)
     {
         REPORT_ERROR(MINOR, err, NO_MSG);
@@ -943,7 +944,7 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-	err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
+    err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
     if (err != E_OK)
     {
         REPORT_ERROR(MINOR, err, NO_MSG);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index 8f78a9b..7e67734 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          dtsec.c
 
@@ -60,17 +61,15 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId can not be greater than the number of 1G MACs"));
     if(p_Dtsec->addr == 0)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC Must have a valid MAC Address"));
-    if(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)) &&
+    if((ENET_SPEED_FROM_MODE(p_Dtsec->enetMode) >= e_ENET_SPEED_1000) &&
         p_Dtsec->p_DtsecDriverParam->halfDuplex)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in half duplex"));
     if(p_Dtsec->p_DtsecDriverParam->halfDuplex && (p_Dtsec->p_DtsecDriverParam)->loopback)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("LoopBack is not supported in halfDuplex mode"));
 #ifdef FM_RX_PREAM_4_ERRATA_DTSEC_A001
-    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev != 8 /*tmp */)
-	    if(p_Dtsec->p_DtsecDriverParam->preambleRxEn)
-	        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("preambleRxEn"));
+    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev <= 6) /* fixed for rev3 */
+        if(p_Dtsec->p_DtsecDriverParam->preambleRxEn)
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("preambleRxEn"));
 #endif /* FM_RX_PREAM_4_ERRATA_DTSEC_A001 */
     if(((p_Dtsec->p_DtsecDriverParam)->preambleTxEn || (p_Dtsec->p_DtsecDriverParam)->preambleRxEn) &&( (p_Dtsec->p_DtsecDriverParam)->preambleLength != 0x7))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Preamble length should be 0x7 bytes"));
@@ -104,8 +103,8 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("uninitialized f_Event"));
 
 #ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
-	if(p_Dtsec->p_DtsecDriverParam->lengthCheckEnable)
-	   RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+    if(p_Dtsec->p_DtsecDriverParam->lengthCheckEnable)
+       RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
 #endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
 
     return E_OK;
@@ -312,74 +311,74 @@ static void DtsecErrException(t_Handle h_Dtsec)
     if(event & IMASK_XFUNEN)
     {
 #ifdef FM_TX_LOCKUP_ERRATA_DTSEC6
-	    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
-	    {
-	        uint32_t  tpkt1, tmpReg1, tpkt2, tmpReg2, i;
-	        /* a. Write 0x00E0_0C00 to DTSEC_ID */
-	        /* This is a read only regidter */
-
-	        /* b. Read and save the value of TPKT */
-	        tpkt1 = GET_UINT32(p_DtsecMemMap->tpkt);
-
-	        /* c. Read the register at dTSEC address offset 0x32C */
-	        tmpReg1 =  GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
-
-	        /* d. Compare bits [9:15] to bits [25:31] of the register at address offset 0x32C. */
-	        if((tmpReg1 & 0x007F0000) != (tmpReg1 & 0x0000007F))
-	        {
-	            /* If they are not equal, save the value of this register and wait for at least
-	             * MAXFRM*16 ns */
-	            XX_UDelay((uint32_t)(MIN(DtsecGetMaxFrameLength(p_Dtsec)*16/1000, 1)));
-	        }
-
-	        /* e. Read and save TPKT again and read the register at dTSEC address offset
-	            0x32C again*/
-	        tpkt2 = GET_UINT32(p_DtsecMemMap->tpkt);
-	        tmpReg2 = GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
-
-	        /* f. Compare the value of TPKT saved in step b to value read in step e. Also
-	            compare bits [9:15] of the register at offset 0x32C saved in step d to the value
-	            of bits [9:15] saved in step e. If the two registers values are unchanged, then
-	            the transmit portion of the dTSEC controller is locked up and the user should
-	            proceed to the recover sequence. */
-	        if((tpkt1 == tpkt2) && ((tmpReg1 & 0x007F0000) == (tmpReg2 & 0x007F0000)))
-	        {
-	            /* recover sequence */
-
-	            /* a.Write a 1 to RCTRL[GRS]*/
-
-	            WRITE_UINT32(p_DtsecMemMap->rctrl, GET_UINT32(p_DtsecMemMap->rctrl) | RCTRL_GRS);
-
-	            /* b.Wait until IEVENT[GRSC]=1, or at least 100 us has elapsed. */
-	            for(i = 0 ; i < 100 ; i++ )
-	            {
-	                if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
-	                    break;
-	                XX_UDelay(1);
-	            }
-	            if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
-	                WRITE_UINT32(p_DtsecMemMap->ievent, IMASK_GRSCEN);
-	            else
-	                DBG(INFO,("Rx lockup due to dTSEC Tx lockup"));
-
-
-	            /* c.Write a 1 to bit n of FM_RSTC (offset 0x0CC of FPM)*/
-	            FmResetMac(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId);
-
-	            /* d.Wait 4 Tx clocks (32 ns) */
-	            XX_UDelay(1);
-
-	            /* e.Write a 0 to bit n of FM_RSTC. */
-	            /* cleared by FMAN */
-	        }
-	        else
-	        {
-	            /* If either value has changed, the dTSEC controller is not locked up and the
-	               controller should be allowed to proceed normally by writing the reset value
-	               of 0x0824_0101 to DTSEC_ID. */
-	            /* Register is read only */
-	        }
-	    }
+        if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+        {
+            uint32_t  tpkt1, tmpReg1, tpkt2, tmpReg2, i;
+            /* a. Write 0x00E0_0C00 to DTSEC_ID */
+            /* This is a read only regidter */
+
+            /* b. Read and save the value of TPKT */
+            tpkt1 = GET_UINT32(p_DtsecMemMap->tpkt);
+
+            /* c. Read the register at dTSEC address offset 0x32C */
+            tmpReg1 =  GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
+
+            /* d. Compare bits [9:15] to bits [25:31] of the register at address offset 0x32C. */
+            if((tmpReg1 & 0x007F0000) != (tmpReg1 & 0x0000007F))
+            {
+                /* If they are not equal, save the value of this register and wait for at least
+                 * MAXFRM*16 ns */
+                XX_UDelay((uint32_t)(MIN(DtsecGetMaxFrameLength(p_Dtsec)*16/1000, 1)));
+            }
+
+            /* e. Read and save TPKT again and read the register at dTSEC address offset
+                0x32C again*/
+            tpkt2 = GET_UINT32(p_DtsecMemMap->tpkt);
+            tmpReg2 = GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
+
+            /* f. Compare the value of TPKT saved in step b to value read in step e. Also
+                compare bits [9:15] of the register at offset 0x32C saved in step d to the value
+                of bits [9:15] saved in step e. If the two registers values are unchanged, then
+                the transmit portion of the dTSEC controller is locked up and the user should
+                proceed to the recover sequence. */
+            if((tpkt1 == tpkt2) && ((tmpReg1 & 0x007F0000) == (tmpReg2 & 0x007F0000)))
+            {
+                /* recover sequence */
+
+                /* a.Write a 1 to RCTRL[GRS]*/
+
+                WRITE_UINT32(p_DtsecMemMap->rctrl, GET_UINT32(p_DtsecMemMap->rctrl) | RCTRL_GRS);
+
+                /* b.Wait until IEVENT[GRSC]=1, or at least 100 us has elapsed. */
+                for(i = 0 ; i < 100 ; i++ )
+                {
+                    if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
+                        break;
+                    XX_UDelay(1);
+                }
+                if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
+                    WRITE_UINT32(p_DtsecMemMap->ievent, IMASK_GRSCEN);
+                else
+                    DBG(INFO,("Rx lockup due to dTSEC Tx lockup"));
+
+
+                /* c.Write a 1 to bit n of FM_RSTC (offset 0x0CC of FPM)*/
+                FmResetMac(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId);
+
+                /* d.Wait 4 Tx clocks (32 ns) */
+                XX_UDelay(1);
+
+                /* e.Write a 0 to bit n of FM_RSTC. */
+                /* cleared by FMAN */
+            }
+            else
+            {
+                /* If either value has changed, the dTSEC controller is not locked up and the
+                   controller should be allowed to proceed normally by writing the reset value
+                   of 0x0824_0101 to DTSEC_ID. */
+                /* Register is read only */
+            }
+        }
 #endif /* FM_TX_LOCKUP_ERRATA_DTSEC6 */
 
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_FIFO_UNDRN);
@@ -1236,13 +1235,9 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
     p_DtsecMemMap = p_Dtsec->p_MemMap;
-    SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
 
-    if(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)) &&
-        p_Dtsec->halfDuplex)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in half duplex"));
+    if (!fullDuplex && (speed == e_ENET_SPEED_1000))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Ethernet MAC 1G does not support half-duplex"));
 
     p_Dtsec->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode), speed);
     p_Dtsec->halfDuplex = !fullDuplex;
@@ -1281,6 +1276,21 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
 
 /* .............................................................................. */
 
+static t_Error DtsecRestartAutoneg(t_Handle h_Dtsec)
+{
+    t_Dtsec      *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint16_t     tmpReg16;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    DTSEC_MII_ReadPhyReg(p_Dtsec, p_Dtsec->p_DtsecDriverParam->tbiPhyAddr, 0, &tmpReg16);
+    tmpReg16 |= (PHY_CR_RESET_AN);
+    DTSEC_MII_WritePhyReg(p_Dtsec, p_Dtsec->p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
 static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
 {
     t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
@@ -1733,21 +1743,31 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     p_Dtsec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if(!p_Dtsec->p_MulticastAddrHash)
     {
-	FreeInitResources(p_Dtsec);
+        FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MC hash table is FAILED"));
     }
 
     p_Dtsec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if(!p_Dtsec->p_UnicastAddrHash)
     {
-	FreeInitResources(p_Dtsec);
+        FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("UC hash table is FAILED"));
     }
 
     /* register err intr handler for dtsec to FPM (err)*/
-    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_ERR, DtsecErrException , p_Dtsec);
+    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm,
+                   e_FM_MOD_1G_MAC,
+                   p_Dtsec->macId,
+                   e_FM_INTR_TYPE_ERR,
+                   DtsecErrException,
+                   p_Dtsec);
     /* register 1588 intr handler for TMR to FPM (normal)*/
-    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL, Dtsec1588Exception , p_Dtsec);
+    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm,
+                   e_FM_MOD_1G_MAC,
+                   p_Dtsec->macId,
+                   e_FM_INTR_TYPE_NORMAL,
+                   Dtsec1588Exception,
+                   p_Dtsec);
     /* register normal intr handler for dtsec to main interrupt controller. */
     if (p_Dtsec->mdioIrq != NO_IRQ)
     {
@@ -1761,7 +1781,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     err = DtsecSetStatistics(p_Dtsec, e_FM_MAC_FULL_STATISTICS);
     if(err)
     {
-	FreeInitResources(p_Dtsec);
+        FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1804,8 +1824,9 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = DtsecConfigPadAndCrc;
     p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = DtsecConfigHalfDuplex;
     p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = DtsecConfigLengthCheck;
-    p_FmMacControllerDriver->f_FM_MAC_ConfigTbiPhyAddr         	= DtsecConfigTbiPhyAddr;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigTbiPhyAddr          = DtsecConfigTbiPhyAddr;
     p_FmMacControllerDriver->f_FM_MAC_ConfigException           = DtsecConfigException;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit         = NULL;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = DtsecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = DtsecDisable;
@@ -1814,6 +1835,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = DtsecSetPromiscuous;
     p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = DtsecAdjustLink;
+    p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg            = DtsecRestartAutoneg;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = DtsecEnable1588TimeStamp;
     p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = DtsecDisable1588TimeStamp;
@@ -1885,7 +1907,7 @@ t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
 
     SetDefaultParam(p_DtsecDriverParam);
 
-    for (i=0; i < sizeof(p_FmMacParam->addr); i++)
+   for (i=0; i < sizeof(p_FmMacParam->addr); i++)
         p_Dtsec->addr |= ((uint64_t)p_FmMacParam->addr[i] << ((5-i) * 8));
 
     p_Dtsec->p_MemMap           = (t_DtsecMemMap *)UINT_TO_PTR(baseAddr);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index 51ef324..ddb606e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          dtsec.h
 
@@ -147,6 +148,8 @@ typedef  uint32_t t_ErrorDisable;
 
 #define DTSEC_TO_MII_OFFSET             0x1120  /* number of pattern match registers (entries) */
 
+
+
 #define DEFAULT_errorDisabled           0
 #define DEFAULT_pauseExtended           0x0
 #define DEFAULT_halfDulexFlowControlEn  FALSE
@@ -320,6 +323,7 @@ typedef  uint32_t t_ErrorDisable;
 #define PHY_TBIANA_SGMII    0x4001
 #define PHY_TBIANA_1000X    0x01a0
 
+
 /* CAR1/2 bits */
 #define CAR1_TR64   0x80000000
 #define CAR1_TR127  0x40000000
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
index 85614a7..8ae995c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          dtsec_mii_acc.c
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
index d43b33b..d84a0ea 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __DTSEC_MII_ACC_H
 #define __DTSEC_MII_ACC_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index 9ed7b1b..478dfd9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_mac.c
 
@@ -53,7 +54,7 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 
     SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_INVALID_HANDLE, NULL);
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     if (ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
         p_FmMacControllerDriver = (t_FmMacControllerDriver *)DTSEC_Config(p_FmMacParam);
 #if FM_MAX_NUM_OF_10G_MACS > 0
@@ -62,7 +63,7 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 #endif /* FM_MAX_NUM_OF_10G_MACS > 0 */
 #else
     p_FmMacControllerDriver = (t_FmMacControllerDriver *)MEMAC_Config(p_FmMacParam);
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
     if (!p_FmMacControllerDriver)
         return NULL;
@@ -89,13 +90,13 @@ t_Error FM_MAC_Init (t_Handle h_FmMac)
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
-#if (DPAA_VERSION == 2)
     if (p_FmMacControllerDriver->resetOnInit &&
+        !p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit &&
         (FmResetMac(p_FmMacControllerDriver->h_Fm,
-                    ((ENET_INTERFACE_FROM_MODE(p_FmMacControllerDriver->enetMode) == e_ENET_IF_XGMII) ? e_FM_MAC_10G : e_FM_MAC_1G),
-                     p_FmMacControllerDriver->macId) != E_OK))
+                    ((ENET_INTERFACE_FROM_MODE(p_FmMacControllerDriver->enetMode) == e_ENET_IF_XGMII) ?
+                        e_FM_MAC_10G : e_FM_MAC_1G),
+                    p_FmMacControllerDriver->macId) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't reset MAC!"));
-#endif /* (DPAA_VERSION == 2) */
 
     if (p_FmMacControllerDriver->f_FM_MAC_Init)
         return p_FmMacControllerDriver->f_FM_MAC_Init(h_FmMac);
@@ -124,6 +125,9 @@ t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable)
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit(h_FmMac, enable);
+
     p_FmMacControllerDriver->resetOnInit = enable;
 
     return E_OK;
@@ -536,6 +540,22 @@ t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex)
 
 /* ........................................................................... */
 
+t_Error FM_MAC_RestartAutoneg(t_Handle h_FmMac)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg)
+        return p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg(h_FmMac);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+
+
+/* ........................................................................... */
+
 t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
index 52eb0f4..0afb049 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_mac.h
 
@@ -50,8 +51,6 @@
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
-
-
 #define DEFAULT_wanModeEnable               FALSE
 #define DEFAULT_promiscuousEnable           FALSE
 #define DEFAULT_rxIgnorePause               FALSE
@@ -62,13 +61,10 @@
 #define DEFAULT_lengthCheckEnable           FALSE
 #define DEFAULT_padAndCrcEnable             TRUE
 
-
-
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 #define DEFAULT_skipFman11Workaround        FALSE
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
-
 #define DEFAULT_resetOnInit                 FALSE
 
 
@@ -96,6 +92,7 @@ typedef struct {
     t_Error (*f_FM_MAC_ConfigLengthCheck) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_ConfigTbiPhyAddr) (t_Handle h_FmMac, uint8_t newVal);
     t_Error (*f_FM_MAC_ConfigException) (t_Handle h_FmMac, e_FmMacExceptions, bool enable);
+    t_Error (*f_FM_MAC_ConfigResetOnInit) (t_Handle h_FmMac, bool enable);
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
     t_Error (*f_FM_MAC_ConfigSkipFman11Workaround) (t_Handle h_FmMac);
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
@@ -125,6 +122,7 @@ typedef struct {
 
     t_Error (*f_FM_MAC_SetPromiscuous) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_AdjustLink)     (t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
+    t_Error (*f_FM_MAC_RestartAutoneg) (t_Handle h_FmMac);
 
     t_Error (*f_FM_MAC_GetId) (t_Handle h_FmMac, uint32_t *macId);
 
@@ -148,12 +146,12 @@ typedef struct {
 } t_FmMacControllerDriver;
 
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
 t_Handle    DTSEC_Config(t_FmMacParams *p_FmMacParam);
 t_Handle    TGEC_Config(t_FmMacParams *p_FmMacParams);
 #else
 t_Handle    MEMAC_Config(t_FmMacParams *p_FmMacParam);
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 uint16_t    FM_MAC_GetMaxFrameLength(t_Handle FmMac);
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index bb24210..04c497f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          tgec.c
 
@@ -67,9 +68,10 @@ static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
     if(!p_Tgec->f_Event)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("uninitialized f_Event"));
 #ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
-	if(!p_Tgec->p_TgecDriverParam->noLengthCheckEnable)
-	   RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+    if(!p_Tgec->p_TgecDriverParam->noLengthCheckEnable)
+       RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
 #endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
+
     return E_OK;
 }
 
@@ -245,7 +247,7 @@ static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
 
     p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
-    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
 
     switch (mode)
     {
@@ -263,7 +265,7 @@ static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
             break;
     }
 
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
     return E_OK;
 }
@@ -281,7 +283,7 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
 
     p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
-    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
     switch (mode)
     {
         case e_COMM_MODE_RX:
@@ -296,7 +298,7 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
     }
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
     return E_OK;
 }
@@ -315,14 +317,14 @@ static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
 
     p_TgecMemMap = p_Tgec->p_MemMap;
 
-    tmpReg32 = GET_UINT32(p_TgecMemMap->cmd_conf_ctrl);
+    tmpReg32 = GET_UINT32(p_TgecMemMap->command_config);
 
     if (newVal)
         tmpReg32 |= CMD_CFG_PROMIS_EN;
     else
         tmpReg32 &= ~CMD_CFG_PROMIS_EN;
 
-    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_TgecMemMap->command_config, tmpReg32);
 
     return E_OK;
 }
@@ -474,12 +476,12 @@ static t_Error TgecRxIgnoreMacPause(t_Handle h_Tgec, bool en)
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
 
     p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
-    tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
     if (en)
         tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
     else
         tmpReg32 &= ~CMD_CFG_PAUSE_IGNORE;
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
     return E_OK;
 }
@@ -553,7 +555,7 @@ static t_Error TgecEnable1588TimeStamp(t_Handle h_Tgec)
     p_TgecMemMap = p_Tgec->p_MemMap;
     SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
 
-    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, GET_UINT32(p_TgecMemMap->cmd_conf_ctrl) | CMD_CFG_EN_TIMESTAMP);
+    WRITE_UINT32(p_TgecMemMap->command_config, GET_UINT32(p_TgecMemMap->command_config) | CMD_CFG_EN_TIMESTAMP);
 
     return E_OK;
 }
@@ -571,7 +573,7 @@ static t_Error TgecDisable1588TimeStamp(t_Handle h_Tgec)
     p_TgecMemMap = p_Tgec->p_MemMap;
     SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
 
-    WRITE_UINT32(p_TgecMemMap->cmd_conf_ctrl, GET_UINT32(p_TgecMemMap->cmd_conf_ctrl) & ~CMD_CFG_EN_TIMESTAMP);
+    WRITE_UINT32(p_TgecMemMap->command_config, GET_UINT32(p_TgecMemMap->command_config) & ~CMD_CFG_EN_TIMESTAMP);
 
     return E_OK;
 }
@@ -622,21 +624,21 @@ static t_Error TgecResetCounters (t_Handle h_Tgec)
 
     p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
-    cmdConfCtrl = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+    cmdConfCtrl = GET_UINT32(p_MemMap->command_config);
 
     cmdConfCtrl |= CMD_CFG_STAT_CLR;
 
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+    WRITE_UINT32(p_MemMap->command_config, cmdConfCtrl);
 
     for (i=0; i<1000; i++)
     {
-        tmpReg32 = GET_UINT32(p_MemMap->cmd_conf_ctrl);
+        tmpReg32 = GET_UINT32(p_MemMap->command_config);
         if (!(tmpReg32 & CMD_CFG_STAT_CLR))
             break;
     }
 
     cmdConfCtrl &= ~CMD_CFG_STAT_CLR;
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, cmdConfCtrl);
+    WRITE_UINT32(p_MemMap->command_config, cmdConfCtrl);
 
     return E_OK;
 }
@@ -881,10 +883,10 @@ static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
     XX_Print("Applying 10G tx-ecc error workaround (10GMAC-A004) ...");
 #endif /* (DEBUG_ERRORS > 0) */
     /* enable and set promiscuous */
-    WRITE_UINT32(p_Tgec->p_MemMap->cmd_conf_ctrl, CMD_CFG_PROMIS_EN | CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+    WRITE_UINT32(p_Tgec->p_MemMap->command_config, CMD_CFG_PROMIS_EN | CMD_CFG_TX_EN | CMD_CFG_RX_EN);
     err = Fm10GTxEccWorkaround(p_Tgec->fmMacControllerDriver.h_Fm, p_Tgec->macId);
     /* disable */
-    WRITE_UINT32(p_Tgec->p_MemMap->cmd_conf_ctrl, 0);
+    WRITE_UINT32(p_Tgec->p_MemMap->command_config, 0);
 #if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
     if (err)
         XX_Print("FAILED!\n");
@@ -911,7 +913,7 @@ static t_Error TgecDumpRegs(t_Handle h_Tgec)
         DUMP_TITLE(p_Tgec->p_MemMap, ("10G MAC %d: ", p_Tgec->macId));
         DUMP_VAR(p_Tgec->p_MemMap, tgec_id);
         DUMP_VAR(p_Tgec->p_MemMap, scratch);
-        DUMP_VAR(p_Tgec->p_MemMap, cmd_conf_ctrl);
+        DUMP_VAR(p_Tgec->p_MemMap, command_config);
         DUMP_VAR(p_Tgec->p_MemMap, mac_addr_0);
         DUMP_VAR(p_Tgec->p_MemMap, mac_addr_1);
         DUMP_VAR(p_Tgec->p_MemMap, maxfrm);
@@ -966,7 +968,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
     FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &p_Tgec->fmMacControllerDriver.fmRevInfo);
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev != 8 /*tmp */)
+    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev <= 6 /*fixed for rev3 */)
     {
         if (!p_Tgec->p_TgecDriverParam->skipFman11Workaround &&
             ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
@@ -1028,7 +1030,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
     if (p_TgecDriverParam->txPblFwd)
         tmpReg32 |= CMD_CFG_TX_PBL_FWD;
     tmpReg32 |= 0x40;
-    WRITE_UINT32(p_MemMap->cmd_conf_ctrl, tmpReg32);
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
 
     /* Max Frame Length */
     WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_TgecDriverParam->maxFrameLength);
@@ -1075,7 +1077,12 @@ static t_Error TgecInit(t_Handle h_Tgec)
     WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
     WRITE_UINT32(p_MemMap->imask, p_Tgec->exceptions);
 
-    FmRegisterIntr(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MOD_10G_MAC, p_Tgec->macId, e_FM_INTR_TYPE_ERR, TgecErrException , p_Tgec);
+    FmRegisterIntr(p_Tgec->fmMacControllerDriver.h_Fm,
+                   e_FM_MOD_10G_MAC,
+                   p_Tgec->macId,
+                   e_FM_INTR_TYPE_ERR,
+                   TgecErrException,
+                   p_Tgec);
     if ((p_Tgec->mdioIrq != 0) && (p_Tgec->mdioIrq != NO_IRQ))
     {
         XX_SetIntr(p_Tgec->mdioIrq, TgecException, p_Tgec);
@@ -1127,6 +1134,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
     p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = TgecConfigLengthCheck;
     p_FmMacControllerDriver->f_FM_MAC_ConfigException           = TgecConfigException;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit         = NULL;
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
     p_FmMacControllerDriver->f_FM_MAC_ConfigSkipFman11Workaround= TgecConfigSkipFman11Workaround;
@@ -1139,6 +1147,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = TgecSetPromiscuous;
     p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg            = NULL;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = TgecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = TgecDisable;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
index 045fb5b..64bf754 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          tgec.h
 
@@ -323,7 +324,7 @@ typedef _Packed struct {
 /* 10Ge General Control and Status */
     volatile uint32_t   tgec_id;            /* 0x000 10GEC_ID - Controller ID register */
     volatile uint32_t   scratch;            /* 0x004  */
-    volatile uint32_t   cmd_conf_ctrl;      /* 0x008 COMMAND_CONFIG - Control and configuration register */
+    volatile uint32_t   command_config;     /* 0x008 COMMAND_CONFIG - Control and configuration register */
     volatile uint32_t   mac_addr_0;         /* 0x00C MAC_ADDR_0 - Lower 32 bits of the first 48-bit MAC address */
     volatile uint32_t   mac_addr_1;         /* 0x010 MAC_ADDR_1 - Upper 16 bits of the first 48-bit MAC address */
     volatile uint32_t   maxfrm;             /* 0x014 MAXFRM - Maximum frame length register */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
index 6ab50ab..e0fafd1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
@@ -31,6 +31,7 @@
  */
 
 
+
 #include "error_ext.h"
 #include "std_ext.h"
 #include "fm_mac.h"
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
index 1de0f99..645cdde 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __TGEC_MII_ACC_H
 #define __TGEC_MII_ACC_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
index e1f6f59..8169765 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
@@ -31,7 +31,7 @@
  */
 
 
-/**************************************************************************//**
+ /**************************************************************************//**
  @File          crc64.h
 
  @Description   brief This file contains the CRC64 Table, and __inline__
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index ea7c904..f4a53e8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_cc.c
 
@@ -43,6 +44,7 @@
 #include "fm_muram_ext.h"
 
 #include "fm_common.h"
+#include "fm_pcd.h"
 #include "fm_hc.h"
 #include "fm_cc.h"
 #include "crc64.h"
@@ -52,16 +54,26 @@
 /*       static functions               */
 /****************************************/
 
-static uint32_t FmPcdCcTreeLock(t_Handle h_FmPcdCcTree)
+
+static t_Error CcRootTryLock(t_Handle h_FmPcdCcTree)
 {
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+
     ASSERT_COND(h_FmPcdCcTree);
-    return XX_LockIntrSpinlock(((t_FmPcdCcTree*)h_FmPcdCcTree)->h_Spinlock);
+
+    if (FmPcdLockTryLock(p_FmPcdCcTree->p_Lock))
+        return E_OK;
+
+    return ERROR_CODE(E_BUSY);
 }
 
-static void FmPcdCcTreeUnlock(t_Handle h_FmPcdCcTree, uint32_t intFlags)
+static void CcRootReleaseLock(t_Handle h_FmPcdCcTree)
 {
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+
     ASSERT_COND(h_FmPcdCcTree);
-    XX_UnlockIntrSpinlock(((t_FmPcdCcTree*)h_FmPcdCcTree)->h_Spinlock, intFlags);
+
+    FmPcdLockUnlock(p_FmPcdCcTree->p_Lock);
 }
 
 static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
@@ -77,10 +89,14 @@ static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
     }
 }
 
-static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_CcNode, t_Handle h_Manip, t_Handle h_FrmReplic)
+static void FillAdOfTypeContLookup(t_Handle h_Ad,
+                                   t_Handle h_FmPcd,
+                                   t_Handle p_CcNode,
+                                   t_Handle h_Manip,
+                                   t_Handle h_FrmReplic)
 {
     t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_CcNode;
-    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)p_Ad;
+    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)h_Ad;
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                tmpReg32;
     t_Handle                p_AdNewPtr = NULL;
@@ -104,19 +120,19 @@ static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_
      * AD will be written into the match table itself (case (1))*/
     p_AdNewPtr = p_AdContLookup;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if (h_Manip && h_FrmReplic)
         FmPcdManipUpdateAdContLookupForCc(h_Manip,
-                                          p_Ad,
+                                          h_Ad,
                                           &p_AdNewPtr,
                                           (uint32_t)((XX_VirtToPhys(FrmReplicGetSourceTableDescriptor(h_FrmReplic)) - p_FmPcd->physicalMuramBase)));
     else if (h_FrmReplic)
-        FrmReplicUpdateAdContLookupForCc(h_FrmReplic, p_Ad, &p_AdNewPtr);
+        FrmReplicUpdateAdContLookupForCc(h_FrmReplic, h_Ad, &p_AdNewPtr);
     else
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     if (h_Manip)
         FmPcdManipUpdateAdContLookupForCc(h_Manip,
-                                          p_Ad,
+                                          h_Ad,
                                           &p_AdNewPtr,
 
 #ifdef FM_CAPWAP_SUPPORT
@@ -128,7 +144,7 @@ static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_
                                           );
 
     /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
-    if(p_AdNewPtr)
+    if (p_AdNewPtr)
     {
         /* cases (1) & (2) */
         tmpReg32 = 0;
@@ -178,12 +194,12 @@ static t_Error FmPcdCcAllocAndFillAdForContLookupManip(t_Handle h_CcNode)
     return E_OK;
 }
 
-static t_Error FmPcdCcSetRequiredAction(t_Handle    h_FmPcd,
-                                        uint32_t    requiredAction,
-                                        t_FmPcdCcKeyAndNextEngineParams *p_CcKeyAndNextEngineParamsTmp,
-                                        t_Handle    h_AdTmp,
-                                        uint16_t    numOfEntries,
-                                        t_Handle    h_Tree)
+static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_FmPcd,
+                                        uint32_t                            requiredAction,
+                                        t_FmPcdCcKeyAndNextEngineParams     *p_CcKeyAndNextEngineParamsTmp,
+                                        t_Handle                            h_AdTmp,
+                                        uint16_t                            numOfEntries,
+                                        t_Handle                            h_Tree)
 {
     t_AdOfTypeResult    *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
     uint32_t            tmpReg32;
@@ -400,15 +416,23 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
     if (p_AdditionalParams->h_ManipForRmv)
         FmPcdManipUpdateOwner(p_AdditionalParams->h_ManipForRmv, FALSE);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
+    if (p_AdditionalParams->h_FrmReplicForAdd)
+    {
+        FrmReplicUpdateGroupOwner(p_AdditionalParams->h_FrmReplicForAdd,
+                               TRUE,  /* add */
+                               TRUE,  /* fullUpdate */
+                               p_AdditionalParams->h_CurrentNode);
+    }
+
     if (p_AdditionalParams->h_FrmReplicForRmv)
     {
         FrmReplicUpdateGroupOwner(p_AdditionalParams->h_FrmReplicForRmv,
-                               FALSE,
+                               FALSE, /* remove */
                                TRUE,  /* fullUpdate */
-                               p_AdditionalParams->h_NodeForRmv);
+                               p_AdditionalParams->h_CurrentNode);
     }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     if (!useShadowStructs)
     {
@@ -491,7 +515,7 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     {
         if (p_FmPcdCcNextEngineParams->h_Manip)
         {
-            if(FmPcdCcAllocAndFillAdForContLookupManip(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)!= E_OK)
+            if (FmPcdCcAllocAndFillAdForContLookupManip(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)!= E_OK)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                 return NULL;
@@ -504,17 +528,17 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
                                NULL);
     }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if ((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
-        (p_FmPcdCcNextEngineParams->params.h_FrmReplic))
+        (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic))
     {
         FillAdOfTypeContLookup(h_Ad,
                                p_CcNode->h_FmPcd,
                                p_FmPcdCcNodeTmp,
                                p_FmPcdCcNextEngineParams->h_Manip,
-                               p_FmPcdCcNextEngineParams->params.h_FrmReplic);
+                               p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
     }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     XX_Free(p_FmPcdCcNodeTmp);
 
@@ -850,7 +874,7 @@ static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List
     t_CcNodeInformation   *p_CcNodeInfo = NULL;
     uint32_t        intFlags;
 
-    intFlags = XX_DisableAllIntr();
+    intFlags = XX_DisableAllIntr(); //TODO - replace by lock
 
     if (!LIST_IsEmpty(p_List))
     {
@@ -880,11 +904,6 @@ void ReleaseLst(t_List *p_List)
     LIST_DelAndInit(p_List);
 }
 
-void FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree)
-{
-    RELEASE_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
-}
-
 void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
 {
     t_List              *p_Pos;
@@ -895,7 +914,7 @@ void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
         h_FmPcdCcTree = p_CcNodeInfo->h_CcNode;
-        FmPcdCcTreeReleaseLock(h_FmPcdCcTree);
+        CcRootReleaseLock(h_FmPcdCcTree);
     }
 
     ReleaseLst(p_List);
@@ -978,7 +997,9 @@ static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCc
         *parseCodeCcSize = 0;
 }
 
-static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t *parseCodeRealSize)
+static void  GetSizeHeaderField(e_NetHeaderType     hdr,
+                                t_FmPcdFields       field,
+                                uint8_t             *parseCodeRealSize)
 {
     switch(hdr)
     {
@@ -1159,7 +1180,8 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
     }
 }
 
-t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
+                                 t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
 {
     uint16_t    absoluteProfileId;
     t_Error     err = E_OK;
@@ -1176,7 +1198,7 @@ t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_
              {
                  if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid &&
                          !p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not defined fqid for control flow for BMI next engine "));
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("overrideFqid defined, but not newFqid."));
                  if (p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
                      RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
              }
@@ -1228,12 +1250,12 @@ t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("not allowed to put statisticsEn when nextEngine == e_FM_PCD_CC"));
         break;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
          case(e_FM_PCD_FR):
-             if (!p_FmPcdCcNextEngineParams->params.h_FrmReplic)
+             if (!p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
                 err = E_NOT_SUPPORTED;
              break;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
@@ -1299,7 +1321,9 @@ static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
     return CC_PC_ILLEGAL;
 }
 
-static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
+static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
+                                     e_FmPcdHdrIndex    index,
+                                     t_FmPcdFields      field)
 {
 
       switch(hdr)
@@ -1504,7 +1528,11 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
     }
 }
 
-static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset)
+static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
+                              e_FmPcdHdrIndex   hdrIndex,
+                              uint32_t          offset,
+                              bool              glblMask,
+                              uint8_t           *parseArrayOffset)
 {
     bool offsetRelevant = FALSE;
 
@@ -1649,16 +1677,17 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
         return CC_PR_WITHOUT_OFFSET;
 }
 
-void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
+void FillAdOfTypeResult(t_Handle                    h_Ad,
+                        t_FmPcd                     *p_FmPcd,
+                        t_FmPcdCcNextEngineParams   *p_CcNextEngineParams)
 {
-    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult*)p_Ad;
+    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult*)h_Ad;
     uint32_t            tmp = 0, tmpNia = 0;
     uint16_t            profileId;
     t_Handle            p_AdNewPtr = NULL;
 
-    /* there are 3 cases handled in this routine of building a "result" type AD.
+    /* There are 3 cases handled in this routine of building a "result" type AD.
      * Case 1: No Manip. The action descriptor is built within the match table.
-     *         p_AdResult = p_AdNewPtr;
      * Case 2: Manip exists. A new AD is created - p_AdNewPtr. It is initialized
      *         either in the FmPcdManipUpdateAdResultForCc routine or it was already
      *         initialized and returned here.
@@ -1672,23 +1701,28 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
      * AD will be written into the match table itself (case (1))*/
     p_AdNewPtr = p_AdResult;
 
+    /* Create Manip and return p_AdNewPtr to either a new descriptor or NULL */
     if (p_CcNextEngineParams->h_Manip)
-        /* Create Manip and return p_AdNewPtr to either a new descriptor or NULL */
-        FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip, p_Ad, &p_AdNewPtr);
+        FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip,
+                                      h_Ad,
+                                      &p_AdNewPtr);
 
     /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
     if (p_AdNewPtr)
     {
         /* case (1) and (2) */
-        switch(p_CcNextEngineParams->nextEngine)
+        switch (p_CcNextEngineParams->nextEngine)
         {
-            case(e_FM_PCD_DONE):
-                if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
+            case (e_FM_PCD_DONE):
+                if (p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
                 {
-                    if(p_CcNextEngineParams->params.enqueueParams.overrideFqid)
+                    if (p_CcNextEngineParams->params.enqueueParams.overrideFqid)
                     {
                        tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                        tmp |= p_CcNextEngineParams->params.enqueueParams.newFqid;
+#if (DPAA_VERSION >= 11)
+                       tmp |= p_CcNextEngineParams->params.enqueueParams.newRelativeStorageProfileId << FM_PCD_AD_RESULT_VSP_SHIFT;
+#endif /* (DPAA_VERSION >= 11) */
                     }
                     else
                     {
@@ -1697,19 +1731,23 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
                     }
                 }
 
-                if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
+                if (p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
                     tmpNia |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
                 else
                     tmpNia |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
-                if(p_CcNextEngineParams->statisticsEn)
+
+                if (p_CcNextEngineParams->statisticsEn)
                     tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                 break;
 
-            case(e_FM_PCD_KG):
-                if(p_CcNextEngineParams->params.kgParams.overrideFqid)
+            case (e_FM_PCD_KG):
+                if (p_CcNextEngineParams->params.kgParams.overrideFqid)
                 {
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
                     tmp |= p_CcNextEngineParams->params.kgParams.newFqid;
+#if (DPAA_VERSION >= 11)
+                    tmp |= p_CcNextEngineParams->params.kgParams.newRelativeStorageProfileId << FM_PCD_AD_RESULT_VSP_SHIFT;
+#endif /* (DPAA_VERSION >= 11) */
                 }
                 else
                 {
@@ -1720,26 +1758,33 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
                 tmpNia |= NIA_ENG_KG;
                 tmpNia |= FmPcdKgGetSchemeId(p_CcNextEngineParams->params.kgParams.h_DirectScheme);
 
-                if(p_CcNextEngineParams->statisticsEn)
+                if (p_CcNextEngineParams->statisticsEn)
                     tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                 break;
 
             case(e_FM_PCD_PLCR):
                 tmp = 0;
-                if(p_CcNextEngineParams->params.plcrParams.overrideParams)
+                if (p_CcNextEngineParams->params.plcrParams.overrideParams)
                 {
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
 
                     /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
-                    if(p_CcNextEngineParams->params.plcrParams.sharedProfile)
+                    if (p_CcNextEngineParams->params.plcrParams.sharedProfile)
                     {
                         tmpNia |= NIA_PLCR_ABSOLUTE;
-                        FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParams->params.plcrParams.newRelativeProfileId, &profileId);
+                        FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,
+                                                              e_FM_PCD_PLCR_SHARED,
+                                                              NULL,
+                                                              p_CcNextEngineParams->params.plcrParams.newRelativeProfileId,
+                                                              &profileId);
                     }
                     else
                         profileId = p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
 
                     tmp |= p_CcNextEngineParams->params.plcrParams.newFqid;
+#if (DPAA_VERSION >= 11)
+                    tmp |= p_CcNextEngineParams->params.plcrParams.newRelativeStorageProfileId << FM_PCD_AD_RESULT_VSP_SHIFT;
+#endif /* (DPAA_VERSION >= 11) */
                     WRITE_UINT32(p_AdResult->plcrProfile,(uint32_t)((uint32_t)profileId << FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT));
                 }
                 else
@@ -1747,7 +1792,7 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
 
                 tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
 
-                if(p_CcNextEngineParams->statisticsEn)
+                if (p_CcNextEngineParams->statisticsEn)
                     tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                break;
 
@@ -1766,15 +1811,18 @@ void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEnginePara
             tmpNia |= FM_PCD_AD_RESULT_NADEN;
         }
 
+#if (DPAA_VERSION >= 11)
+       tmpNia |= FM_PCD_AD_RESULT_NO_OM_VSPE;
+#endif /* (DPAA_VERSION >= 11) */
         WRITE_UINT32(p_AdResult->nia, tmpNia);
     }
 }
 
-static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
-                              t_Handle                         h_PcdParams,
-                              t_Handle                         h_FmPort,
-                              t_Handle                         h_FmTree,
-                              bool                             validate)
+static t_Error CcUpdateParams(t_Handle      h_FmPcd,
+                              t_Handle      h_PcdParams,
+                              t_Handle      h_FmPort,
+                              t_Handle      h_FmTree,
+                              bool          validate)
 {
     t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
 
@@ -1790,7 +1838,9 @@ static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
                          FALSE);
 }
 
-/*static*/ void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd)
+/*static*/ void NextStepAd(t_Handle                     h_Ad,
+                           t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
+                           t_FmPcd                      *p_FmPcd)
 {
     switch(p_FmPcdCcNextEngineParams->nextEngine)
     {
@@ -1798,28 +1848,28 @@ static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
         case(e_FM_PCD_PLCR):
         case(e_FM_PCD_DONE):
             /* if NIA is not CC, create a "result" type AD */
-            FillAdOfTypeResult(p_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
+            FillAdOfTypeResult(h_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
             break;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         case(e_FM_PCD_FR):
-            if (p_FmPcdCcNextEngineParams->params.h_FrmReplic)
+            if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
             {
-                FillAdOfTypeContLookup(p_Ad,
+                FillAdOfTypeContLookup(h_Ad,
                                        p_FmPcd,
                                        p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
                                        p_FmPcdCcNextEngineParams->h_Manip,
-                                       p_FmPcdCcNextEngineParams->params.h_FrmReplic);
-                                       FrmReplicUpdateGroupOwner(p_FmPcdCcNextEngineParams->params.h_FrmReplic,
+                                       p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
+                                       FrmReplicUpdateGroupOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
                                                                  TRUE,  /* add */
                                                                  FALSE, /* fullUpdate */
                                                                  NULL);
             }
             break;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
         case(e_FM_PCD_CC):
             /* if NIA is not CC, create a TD to continue the CC lookup */
-            FillAdOfTypeContLookup(p_Ad,
+            FillAdOfTypeContLookup(h_Ad,
                                    p_FmPcd,
                                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
                                    p_FmPcdCcNextEngineParams->h_Manip,
@@ -1837,13 +1887,17 @@ static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
 static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     if(p_AdditionalInfo->p_AdTableNew)
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
+                         p_AdditionalInfo->p_AdTableNew);
 
     if(p_AdditionalInfo->p_KeysMatchTableNew)
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd), p_AdditionalInfo->p_KeysMatchTableNew);
+        FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
+                         p_AdditionalInfo->p_KeysMatchTableNew);
 }
 
-static void UpdateGblMask(t_FmPcdCcNode *p_CcNode, uint8_t keySize, uint8_t *p_Mask)
+static void UpdateGblMask(t_FmPcdCcNode *p_CcNode,
+                          uint8_t       keySize,
+                          uint8_t       *p_Mask)
 {
     if (p_Mask &&
         !p_CcNode->glblMaskUpdated &&
@@ -1910,6 +1964,11 @@ static __inline t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
            | (16 bytes) | (maximal size)  |  (maximal size)  |
            ---------------------------------------------------
          */
+        if (!p_FmPcd->p_CcShadow)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Shadow not allocated"));
+            return NULL;
+        }
 
         h_Ad = p_FmPcd->p_CcShadow;
     }
@@ -1962,6 +2021,9 @@ static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_C
            ---------------------------------------------------
          */
 
+        if (!p_FmPcd->p_CcShadow)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("CC Shadow not allocated"));
+
         p_AdditionalInfo->p_KeysMatchTableNew = PTR_MOVE(p_FmPcd->p_CcShadow, FM_PCD_CC_AD_ENTRY_SIZE);
         p_AdditionalInfo->p_AdTableNew        = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, p_CcNode->keysMatchTableMaxSize);
 
@@ -2002,8 +2064,8 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
     /* Check that new key is not require update of localMask */
     UpdateGblMask(p_CcNode,
-                        p_CcNode->ccKeySizeAccExtraction,
-                        p_KeyParams->p_Mask);
+                  p_CcNode->ccKeySizeAccExtraction,
+                  p_KeyParams->p_Mask);
 
     /* Update internal data structure with new next engine for the given index */
     memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,
@@ -2189,6 +2251,13 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForAdd = p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
 
+#if (DPAA_VERSION >= 11)
+        if ((p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_KeyParams->ccNextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForAdd = p_KeyParams->ccNextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
+
     if (!add)
     {
         if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
@@ -2196,16 +2265,20 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
         if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
             p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
-#if DPAA_VERSION >= 3
-        if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.h_FrmReplic)
-            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.h_FrmReplic;
-#endif /* DPAA_VERSION >= 3 */
+#if (DPAA_VERSION >= 11)
+        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
     }
 
     return E_OK;
 }
 
-static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_CcNode, uint16_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNode,
+                                     uint16_t                           keyIndex,
+                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     int         i = 0, j = 0;
     t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
@@ -2249,6 +2322,13 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_CcNode, uint16_t keyIndex,
     if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
         p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
+#if (DPAA_VERSION >= 11)
+        if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
+
    return E_OK;
 }
 
@@ -2416,6 +2496,12 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
             p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
         if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
             p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+#if (DPAA_VERSION >= 11)
+        if ((p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
     }
     else
     {
@@ -2426,6 +2512,12 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
             p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
         if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
             p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+#if (DPAA_VERSION >= 11)
+        if ((p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic) &&
+            (!(p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
     }
 
     if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
@@ -2471,11 +2563,22 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
                 err = FmPcdCcSetRequiredAction(p_FmPcdCcNode1->h_FmPcd,
                                                p_FmPcdCcNode1->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
                                                &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                               p_Ad, 1, p_CcNodeInformation->h_CcNode);
+                                               p_Ad,
+                                               1,
+                                               p_CcNodeInformation->h_CcNode);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-                err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd, NULL, NULL, &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],1, p_Ad, TRUE, p_CcNodeInformation->index, p_CcNodeInformation->h_CcNode, TRUE);
+                err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd,
+                                    NULL,
+                                    NULL,
+                                    &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                    1,
+                                    p_Ad,
+                                    TRUE,
+                                    p_CcNodeInformation->index,
+                                    p_CcNodeInformation->h_CcNode,
+                                    TRUE);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
             }
@@ -2494,7 +2597,15 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-        err = CcUpdateParam(h_FmPcd, NULL, NULL, &p_AdditionalInfo->keyAndNextEngineParams[keyIndex], 1, p_Ad, TRUE, 0, (t_Handle)p_FmPcdCcTree, TRUE);
+        err = CcUpdateParam(h_FmPcd,
+                            NULL,
+                            NULL,
+                            &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                            1,
+                            p_Ad,
+                            TRUE,
+                            0,
+                            (t_Handle)p_FmPcdCcTree, TRUE);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -2502,12 +2613,20 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForAdd = p_CcNextEngineParams->params.ccParams.h_CcNode;
 
+#if (DPAA_VERSION >= 11)
+        if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
+            (p_CcNextEngineParams->params.frParams.h_FrmReplic) &&
+            (!(p_CcNextEngineParams->h_Manip)))
+            p_AdditionalInfo->h_FrmReplicForAdd = p_CcNextEngineParams->params.frParams.h_FrmReplic;
+#endif /* (DPAA_VERSION >= 11) */
+
+
     return E_OK;
 }
 
 static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode                *p_CrntMdfNode,
                                                        t_List                       *h_OldLst,
-                                                       t_FmPcdCcNextEngineParams	**p_NextEngineParams)
+                                                       t_FmPcdCcNextEngineParams    **p_NextEngineParams)
 {
     t_CcNodeInformation     *p_CcNodeInformation;
     t_FmPcdCcNode           *p_NodePtrOnCurrentMdfNode = NULL;
@@ -2549,7 +2668,7 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
     }
 }
 
-static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode				*p_CrntMdfNode,
+static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode                *p_CrntMdfNode,
                                                        t_List                       *h_OldLst,
                                                        t_FmPcdCcNextEngineParams    **p_NextEngineParams)
 {
@@ -2586,7 +2705,7 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode				*p_CrntM
         }
 
         ASSERT_COND(i == p_TreePtrOnCurrentMdfNode->numOfEntries);
-     }
+    }
 }
 
 static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle        h_FmPcdCcNodeOrTree,
@@ -2720,10 +2839,10 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
     return p_FmPcdModifyCcKeyAdditionalParams;
 }
 
-static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode *p_CcNode,
-                                                t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams,
-                                                t_List *h_OldLst,
-                                                t_List *h_NewLst)
+static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode                       *p_CcNode,
+                                                t_FmPcdModifyCcKeyAdditionalParams  *p_FmPcdModifyCcKeyAdditionalParams,
+                                                t_List                              *h_OldLst,
+                                                t_List                              *h_NewLst)
 {
     t_FmPcdCcNextEngineParams   *p_NextEngineParams = NULL;
     t_CcNodeInformation         ccNodeInfo = {0};
@@ -2756,13 +2875,11 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode *p_CcNode,
     return E_OK;
 }
 
-static void  FmPcdCcUpdateTreeOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
+static void UpdateCcRootOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
 {
-    uint32_t    intFlags = 0;
-
     ASSERT_COND(p_FmPcdCcTree);
 
-    intFlags = FmPcdCcTreeLock(p_FmPcdCcTree);
+    /* this routine must be protected by the calling routine! */
 
     if (add)
        p_FmPcdCcTree->owners++;
@@ -2771,8 +2888,6 @@ static void  FmPcdCcUpdateTreeOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
         ASSERT_COND(p_FmPcdCcTree->owners);
         p_FmPcdCcTree->owners--;
     }
-
-    FmPcdCcTreeUnlock(p_FmPcdCcTree, intFlags);
 }
 
 static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
@@ -2893,10 +3008,10 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     return E_OK;
 }
 
-static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
-                                               t_FmPcdCcNodeParams  *p_CcNodeParam,
-                                               t_FmPcdCcNode        *p_CcNode,
-                                               bool                 *isKeyTblAlloc)
+static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
+                                                t_FmPcdCcNodeParams *p_CcNodeParam,
+                                                t_FmPcdCcNode       *p_CcNode,
+                                                bool                *isKeyTblAlloc)
 {
     int                 tmp = 0;
     t_FmPcdCcKeyParams  *p_KeyParams;
@@ -2905,7 +3020,10 @@ static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
     uint32_t            requiredAction = 0;
 
     if (p_CcNode->numOfKeys != 1)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for IPV4TTL and IPV6_HOP_LIMIT has to be only 1 key - TTL = 1, otherwise it's Miss"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'numOfKeys' is 1"));
+
+    if ((p_CcNodeParam->keysParams.maxNumOfKeys) && (p_CcNodeParam->keysParams.maxNumOfKeys != 1))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"));
 
     err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
     if (err)
@@ -2918,7 +3036,9 @@ static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
-    memcpy(&p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, sizeof(t_FmPcdCcNextEngineParams));
+    memcpy(&p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams,
+           &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+           sizeof(t_FmPcdCcNextEngineParams));
 
     p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction = requiredAction;
 
@@ -2930,10 +3050,7 @@ static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
-    if (p_CcNodeParam->keysParams.maxNumOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT 'maxNumOfKeys' must be zero"));
-
-    for(tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
@@ -2959,7 +3076,9 @@ static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
         p_CcNode->keyAndNextEngineParams[tmp].mask[0] = 0xFF;
 
         /* Store NextEngine parameters */
-        memcpy(&p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams, &p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+        memcpy(&p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams,
+               &p_KeyParams->ccNextEngineParams,
+               sizeof(t_FmPcdCcNextEngineParams));
 
         if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
             && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
@@ -2994,18 +3113,18 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     while (countMask)
     {
         countOnes++;
-        countMask=(uint16_t)(countMask>>1);
+        countMask = (uint16_t)(countMask >> 1);
     }
 
-    if (p_CcNodeParam->keysParams.maxNumOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be set to 0"));
-
     if (!POWER_OF_2(p_CcNode->numOfKeys))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED numOfKeys has to be powerOfTwo"));
 
-    if (p_CcNode->numOfKeys != ((uint32_t)1<<countOnes ))
+    if (p_CcNode->numOfKeys != ((uint32_t)1 << countOnes ))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"));
 
+    if ((p_CcNodeParam->keysParams.maxNumOfKeys) && (p_CcNodeParam->keysParams.maxNumOfKeys != p_CcNode->numOfKeys))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
+
     err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
     if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
         RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
@@ -3082,7 +3201,7 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams =  ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, FALSE);
+    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -3092,13 +3211,13 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
             return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine (h_FmPcd,
-                                        p_CcNode,
-                                        keyIndex,
-                                        p_FmPcdCcNextEngineParams,
-                                        &h_OldPointersLst,
-                                        &h_NewPointersLst,
-                                        p_ModifyKeyParams);
+    err = BuildNewNodeModifyNextEngine(h_FmPcd,
+                                       p_CcNode,
+                                       keyIndex,
+                                       p_FmPcdCcNextEngineParams,
+                                       &h_OldPointersLst,
+                                       &h_NewPointersLst,
+                                       p_ModifyKeyParams);
     if (err)
     {
         XX_Free(p_ModifyKeyParams);
@@ -3134,7 +3253,7 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
     if (!p_Mask)
         memset(tmpMask, 0xFF, keySize);
 
-    for(i = 0 ; i < p_CcNode->numOfKeys; i++)
+    for (i = 0 ; i < p_CcNode->numOfKeys; i++)
     {
         /* Comparing received key */
         if (memcmp(p_Key, p_CcNode->keyAndNextEngineParams[i].key, keySize) == 0)
@@ -3160,7 +3279,7 @@ static t_Error FindKeyIndex(t_Handle    h_CcNode,
         }
     }
 
-    return E_NOT_FOUND;
+    return ERROR_CODE(E_NOT_FOUND);
 }
 
 
@@ -3174,12 +3293,14 @@ t_CcNodeInformation* FmPcdCcFindNodeInfoInReleventLst(t_List *p_List, t_Handle h
     t_List              *p_Pos;
     uint32_t            intFlags;
 
-    intFlags = XX_DisableAllIntr();
+    intFlags = XX_DisableAllIntr();  //TODO - replace by lock
 
     for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
     {
         p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
+
         ASSERT_COND(p_CcInformation->h_CcNode);
+
         if(p_CcInformation->h_CcNode == h_Info)
         {
             XX_RestoreAllIntr(intFlags);
@@ -3198,7 +3319,7 @@ void FmPcdCcDequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info)
     uint32_t            intFlags;
     t_List              *p_Pos;
 
-    intFlags = XX_DisableAllIntr();
+    intFlags = XX_DisableAllIntr();  //TODO - replace by lock
 
     if (LIST_IsEmpty(p_List))
     {
@@ -3224,7 +3345,7 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
                           t_Handle  h_FmTree,
                           t_Handle  h_NetEnv,
                           t_Handle  h_IpReassemblyManip,
-                          bool      schemes)
+                          bool      createSchemes)
 {
     t_FmPcdCcTree               *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
     t_FmPcdCcNextEngineParams   nextEngineParams;
@@ -3236,6 +3357,8 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
 
     ASSERT_COND(p_FmPcdCcTree);
 
+    /* this routine must be protected by the calling routine! */
+
     if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-2))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
 
@@ -3243,34 +3366,88 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
     memset(&netEnvParams, 0, sizeof(t_NetEnvParams));
 
     h_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
+
     isIpv4Present = FmPcdManipIsIpPresent(h_FmPcd, p_FmPcdCcTree->netEnvId, FALSE);
     isIpv6Present = FmPcdManipIsIpPresent(h_FmPcd, p_FmPcdCcTree->netEnvId, TRUE);
+
     netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
     netEnvParams.numOfDistinctionUnits = 0;
+
     err = PcdGetUnitsVector(h_FmPcd, &netEnvParams);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
+
     nextEngineParams.nextEngine = e_FM_PCD_DONE;
     nextEngineParams.h_Manip = h_IpReassemblyManip;
+
+    /* Lock tree */
+    err = CcRootTryLock(p_FmPcdCcTree);
+    if (err)
+        return ERROR_CODE(E_BUSY);
+
+    if (p_FmPcdCcTree->h_IpReassemblyManip == h_IpReassemblyManip)
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        return E_OK;
+    }
+
+    if ((p_FmPcdCcTree->h_IpReassemblyManip) &&
+        (p_FmPcdCcTree->h_IpReassemblyManip != h_IpReassemblyManip))
+    {
+        CcRootReleaseLock(p_FmPcdCcTree);
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This tree was previously updated with different IPR"));
+    }
+
+    /* Initialize IPR for the first time for this tree */
     if (isIpv6Present)
     {
         ipv6GroupId = p_FmPcdCcTree->numOfGrps++;
         p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].totalBitsMask = netEnvParams.vector;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = p_FmPcdCcTree->numOfEntries++;
-        if (schemes)
-            FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, FALSE, ipv6GroupId);
-        NextStepAd(PTR_MOVE(h_Ad, ipv6GroupId * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
+        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = 14;
+
+        if (createSchemes)
+        {
+            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, FALSE, ipv6GroupId);
+            if (err)
+            {
+                p_FmPcdCcTree->numOfGrps--;
+                CcRootReleaseLock(p_FmPcdCcTree);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+        }
+
+        NextStepAd(PTR_MOVE(h_Ad, 14 * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
     }
+
     if (isIpv4Present)
     {
         ipv4GroupId = p_FmPcdCcTree->numOfGrps++;
         p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].totalBitsMask = netEnvParams.vector;
-        p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = p_FmPcdCcTree->numOfEntries++;
-        if (schemes)
-            FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
-        NextStepAd(PTR_MOVE(h_Ad, ipv4GroupId * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
+        p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = 15;
+
+        if (createSchemes)
+        {
+            err = FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
+            if (err)
+            {
+                if (isIpv6Present)
+                {
+                    /* Removing both IPv4 and IPv6 groups */
+                    p_FmPcdCcTree->numOfGrps -= 2;
+                    FmPcdManipDeleteIpReassmSchemes(h_IpReassemblyManip);
+                }
+                CcRootReleaseLock(p_FmPcdCcTree);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+        }
+
+        NextStepAd(PTR_MOVE(h_Ad, 15 * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
     }
+
     p_FmPcdCcTree->h_IpReassemblyManip = h_IpReassemblyManip;
+
+    CcRootReleaseLock(p_FmPcdCcTree);
+
     return E_OK;
 }
 
@@ -3333,7 +3510,7 @@ void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo)
         memcpy(p_CcInformation, p_CcInfo, sizeof(t_CcNodeInformation));
         INIT_LIST(&p_CcInformation->node);
 
-        intFlags = XX_DisableAllIntr();
+        intFlags = XX_DisableAllIntr();  //TODO - replace by lock
         LIST_AddToTail(&p_CcInformation->node, p_List);
         XX_RestoreAllIntr(intFlags);
     }
@@ -3507,7 +3684,7 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
                        p_Key,
                        p_Mask,
                        &tmpKeyIndex);
-    if (err != E_NOT_FOUND)
+    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
         RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
                      ("The received key and mask pair was already found in the match table of the provided node"));
 
@@ -3596,13 +3773,13 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
             return ERROR_CODE(E_BUSY);
     }
 
-    err = BuildNewNodeModifyNextEngine (h_FmPcd,
-                                        p_CcNode,
-                                        keyIndex,
-                                        p_FmPcdCcNextEngineParams,
-                                        &h_OldPointersLst,
-                                        &h_NewPointersLst,
-                                        p_ModifyKeyParams);
+    err = BuildNewNodeModifyNextEngine(h_FmPcd,
+                                       p_CcNode,
+                                       keyIndex,
+                                       p_FmPcdCcNextEngineParams,
+                                       &h_OldPointersLst,
+                                       &h_NewPointersLst,
+                                       p_ModifyKeyParams);
     if (err)
     {
         XX_Free(p_ModifyKeyParams);
@@ -3658,7 +3835,7 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
                        p_FmPcdCcKeyParams->p_Key,
                        p_FmPcdCcKeyParams->p_Mask,
                        &keyIndex);
-    if (err != E_NOT_FOUND)
+    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
         RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
                      ("The received key and mask pair was already found in the match table of the provided node"));
 
@@ -3758,7 +3935,7 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
                        p_FmPcdCcKeyParams->p_Key,
                        p_FmPcdCcKeyParams->p_Mask,
                        &tmpKeyIndex);
-    if (err != E_NOT_FOUND)
+    if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
         RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
                      ("The received key and mask pair was already found in the match table of the provided node"));
 
@@ -3856,67 +4033,71 @@ t_Error  FmPcdCcBindTree(t_Handle h_FmPcd,
     t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
     t_Error             err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
+
+    /* this routine must be protected by the calling routine by locking all PCD modules! */
 
-    FmPcdCcUpdateTreeOwner(p_FmPcdCcTree, TRUE);
+    err = CcUpdateParams(h_FmPcd, h_PcdParams, h_FmPort, h_FmPcdCcTree, TRUE);
+
+    if (err == E_OK)
+        UpdateCcRootOwner(p_FmPcdCcTree, TRUE);
 
     *p_Offset = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr)) -
                            p_FmPcd->physicalMuramBase);
 
-    err = CcUpdateParams(h_FmPcd, h_PcdParams, h_FmPort, h_FmPcdCcTree, TRUE);
-
     return err;
 }
 
 t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
 {
-    t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcTree   *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+
+    /* this routine must be protected by the calling routine by locking all PCD modules! */
 
     UNUSED(h_FmPcd);
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcTree,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_HANDLE);
 
-    FmPcdCcUpdateTreeOwner(p_FmPcdCcTree, FALSE);
+    UpdateCcRootOwner(p_FmPcdCcTree, FALSE);
 
     return E_OK;
 }
 
-t_Error FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree)
-{
-    if (TRY_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->h_Spinlock, &((t_FmPcdCcTree *)h_FmPcdCcTree)->lock))
-        return E_OK;
-
-    return ERROR_CODE(E_BUSY);
-}
-
 t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
 {
     t_FmPcdCcNode           *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_List                  *p_Pos;
+    t_List                  *p_Pos, *p_Tmp;
     t_CcNodeInformation     *p_CcNodeInfo, nodeInfo;
     t_Error                 err = E_OK;
 
     UNUSED(h_FmPcd);
 
-    if(LIST_IsEmpty(&p_CcNode->ccTreesLst))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
+    if (LIST_IsEmpty(&p_CcNode->ccTreesLst))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"));
 
     LIST_FOR_EACH(p_Pos, &p_CcNode->ccTreesLst)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
         ASSERT_COND(p_CcNodeInfo->h_CcNode);
 
-        err = FmPcdCcTreeTryLock(p_CcNodeInfo->h_CcNode);
+        err = CcRootTryLock(p_CcNodeInfo->h_CcNode);
 
-        if(err == E_OK)
+        if (err)
         {
-            memset(&nodeInfo, 0, sizeof(t_CcNodeInformation));
-            nodeInfo.h_CcNode = p_CcNodeInfo->h_CcNode;
-            EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo);
+            LIST_FOR_EACH(p_Tmp, &p_CcNode->ccTreesLst)
+            {
+                if (p_Tmp == p_Pos)
+                    break;
+
+                CcRootReleaseLock(p_CcNodeInfo->h_CcNode);
+            }
+            break;
         }
-        else
-            FmPcdCcTreeReleaseLock(p_List);
+
+        memset(&nodeInfo, 0, sizeof(t_CcNodeInformation));
+        nodeInfo.h_CcNode = p_CcNodeInfo->h_CcNode;
+        EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo);
     }
 
     return err;
@@ -3926,6 +4107,7 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
 {
     uint32_t    intFlags;
     uint32_t    newSize = 0, newAlign = 0;
+    bool        allocFail = FALSE;
 
     ASSERT_COND(p_FmPcd);
 
@@ -3946,7 +4128,8 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
     if (align > p_FmPcd->ccShadowAlign)
         newAlign = align;
 
-    /* If a bigger shadow size or bigger shadow alignment are required, the shadow will be reallocated */
+    /* If a bigger shadow size or bigger shadow alignment are required,
+       a new shadow will be allocated */
     if ((newSize != p_FmPcd->ccShadowSize) || (newAlign != p_FmPcd->ccShadowAlign))
     {
         intFlags = FmPcdLock(p_FmPcd);
@@ -3958,11 +4141,23 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
             p_FmPcd->ccShadowAlign = 0;
         }
 
-        p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd), newSize, newAlign);
+        p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
+                                                newSize,
+                                                newAlign);
+        if (!p_FmPcd->p_CcShadow)
+        {
+            allocFail = TRUE;
+
+            /* If new shadow size allocation failed,
+               re-allocate with previous parameters */
+            p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
+                                                    p_FmPcd->ccShadowSize,
+                                                    p_FmPcd->ccShadowAlign);
+        }
 
         FmPcdUnlock(p_FmPcd, intFlags);
 
-        if (!p_FmPcd->p_CcShadow)
+        if (allocFail)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Shadow memory"));
 
         p_FmPcd->ccShadowSize  = newSize;
@@ -3972,7 +4167,7 @@ t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
     return E_OK;
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
                                               t_Handle  h_ReplicGroup,
                                               t_List    *p_AdTables,
@@ -3990,7 +4185,7 @@ void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
     for (i = 0; i < p_CurrentNode->numOfKeys + 1; i++)
     {
         if ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic == (t_Handle)h_ReplicGroup)))
+            ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic == (t_Handle)h_ReplicGroup)))
         {
             /* save the current ad table in the list */
             /* this entry uses the input replicator group */
@@ -4004,7 +4199,7 @@ void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
 
     ASSERT_COND(i != p_CurrentNode->numOfKeys);
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 /*********************** End of inter-module routines ************************/
 
 
@@ -4240,6 +4435,14 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         }
     }
 
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DeleteTree(p_FmPcdCcTree, p_FmPcd);
+        XX_Free(p_Params);
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return NULL;
+    }
+
     for(i = 0; i < numOfEntries; i++)
     {
         if(p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
@@ -4248,6 +4451,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
                                             &p_FmPcdCcTree->keyAndNextEngineParams[i], p_CcTreeTmp,1, p_FmPcdCcTree);
             if(err)
             {
+                FmPcdLockUnlockAll(p_FmPcd);
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
                 XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
@@ -4257,16 +4461,16 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         }
     }
 
-    p_FmPcdCcTree->h_Spinlock = XX_InitSpinlock();
-    if (!p_FmPcdCcTree->h_Spinlock)
+    FmPcdLockUnlockAll(p_FmPcd);
+    p_FmPcdCcTree->p_Lock = FmPcdAcquireLock(p_FmPcd);
+    if (!p_FmPcdCcTree->p_Lock)
     {
-        DeleteTree(p_FmPcdCcTree,p_FmPcd);
+        DeleteTree(p_FmPcdCcTree, p_FmPcd);
         XX_Free(p_Params);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM CC spinlock"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM CC lock"));
         return NULL;
     }
 
-
     XX_Free(p_Params);
     return p_FmPcdCcTree;
 }
@@ -4283,7 +4487,7 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
 
     FmPcdDecNetEnvOwners(p_FmPcd, p_CcTree->netEnvId);
 
-    if(p_CcTree->owners)
+    if (p_CcTree->owners)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
 
     /* Delete reassembly schemes if exist */
@@ -4313,34 +4517,33 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
         }
 #endif /* FM_CAPWAP_SUPPORT */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if ((p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic))
+            (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
         {
-             FrmReplicUpdateGroupOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic,
+             FrmReplicUpdateGroupOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
                                        FALSE,
                                        TRUE,  /* fullUpdate */
                                        p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode);
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     }
 
-    if (p_CcTree->h_Spinlock)
-        XX_FreeSpinlock(p_CcTree->h_Spinlock);
+    if (p_CcTree->p_Lock)
+        FmPcdReleaseLock(p_CcTree->h_FmPcd, p_CcTree->p_Lock);
 
     DeleteTree(p_CcTree, p_FmPcd);
 
     return E_OK;
 }
 
-t_Error FM_PCD_CcRootModifyNextEngine(t_Handle  h_CcTree,
-                                      uint8_t   grpId,
-                                      uint8_t   index,
+t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
+                                      uint8_t                   grpId,
+                                      uint8_t                   index,
                                       t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcTree   *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -4348,11 +4551,11 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle  h_CcTree,
     p_FmPcd = (t_FmPcd *)p_CcTree->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcTreeTryLock(p_CcTree);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcModifyNextEngineParamTree(p_FmPcd,
                                            p_CcTree,
@@ -4361,11 +4564,11 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle  h_CcTree,
                                            p_FmPcdCcNextEngineParams);
     if (err)
     {
-        FmPcdCcTreeReleaseLock(p_CcTree);
+        CcRootReleaseLock(p_CcTree);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    FmPcdCcTreeReleaseLock(p_CcTree);
+    FmPcdLockUnlockAll(p_FmPcd);
 
     return E_OK;
 }
@@ -4389,7 +4592,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
 
     p_CcNode = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
-    if(!p_CcNode)
+    if (!p_CcNode)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
         return NULL;
@@ -4415,7 +4618,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6 == NET_HEADER_FIELD_IPv6_HOP_LIMIT) ||
         (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4 == NET_HEADER_FIELD_IPv4_TTL)))
     {
-        err = Ipv4TtlOrIpv6HopLimiCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
+        err = Ipv4TtlOrIpv6HopLimitCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
         glblMask = FALSE;
     }
     else if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
@@ -4423,7 +4626,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
               (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
               (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
     {
-        if((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
+        if ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
             (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
         {
             REPORT_ERROR(MAJOR, E_INVALID_VALUE,
@@ -4449,14 +4652,14 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         else
         {
             err = CheckParams(h_FmPcd, p_CcNodeParam,p_CcNode, &isKeyTblAlloc);
-            if(p_CcNode->glblMaskSize)
+            if (p_CcNode->glblMaskSize)
                 glblMask = TRUE;
         }
     }
     else
     {
         err = CheckParams(h_FmPcd, p_CcNodeParam,p_CcNode, &isKeyTblAlloc);
-        if(p_CcNode->glblMaskSize)
+        if (p_CcNode->glblMaskSize)
             glblMask = TRUE;
     }
 
@@ -4469,10 +4672,10 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
     switch (p_CcNodeParam->extractCcParams.type)
     {
-        case(e_FM_PCD_EXTRACT_BY_HDR):
-            switch(p_CcNodeParam->extractCcParams.extractByHdr.type)
+        case (e_FM_PCD_EXTRACT_BY_HDR):
+            switch (p_CcNodeParam->extractCcParams.extractByHdr.type)
             {
-                case(e_FM_PCD_EXTRACT_FULL_FIELD):
+                case (e_FM_PCD_EXTRACT_FULL_FIELD):
                     p_CcNode->parseCode =
                         GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
                                               p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
@@ -4497,7 +4700,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                     }
                     break;
 
-                case(e_FM_PCD_EXTRACT_FROM_HDR):
+                case (e_FM_PCD_EXTRACT_FROM_HDR):
                     p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
                     p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
                     p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
@@ -4508,7 +4711,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                                        &p_CcNode->prsArrayOffset);
                     break;
 
-                case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                case (e_FM_PCD_EXTRACT_FROM_FIELD):
                     p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
                     p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
                     p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
@@ -4527,7 +4730,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             }
             break;
 
-        case(e_FM_PCD_EXTRACT_NON_HDR):
+        case (e_FM_PCD_EXTRACT_NON_HDR):
             /* get the field code for the generic extract */
             p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
             p_CcNode->offset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
@@ -4602,7 +4805,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     GetCcExtractKeySize(p_CcNode->sizeOfExtraction, &p_CcNode->ccKeySizeAccExtraction);
 
     /* If local mask is used, it is stored next to each key in the keys match table */
-    if(p_CcNode->lclMask)
+    if (p_CcNode->lclMask)
         keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
     else
         keySize = p_CcNode->ccKeySizeAccExtraction;
@@ -4617,20 +4820,34 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         p_CcNode->keysMatchTableMaxSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t) * p_CcNode->maxNumOfKeys;
 
         if (p_CcNode->maskSupport)
+        {
             p_CcNode->keysMatchTableMaxSize *= 2;
 
+            /* If local mask is currently used, 'keySize' holds local mask size.
+               Otherwise, we need to allocate twice as much memory for future local mask support. */
+            if (!(p_CcNode->lclMask))
+                numOfKeysToAlloc *= 2;
+        }
+
         /* Calculate maximal shadow size of this node.
-           All shadow structures will be used for runtime modifications host command.*/
+           All shadow structures will be used for runtime modifications host command.
+           If keys table was allocated for this node, the keys table and next engines table may be
+           modified in run time (entries added or removed), so shadow tables are requires.
+           Otherwise, the only supported runtime modification is a specific next engine update and
+           this requires shadow memory of a single AD */
 
         /* Shadow size should be enough to hold the following 3 structures:
-           1 - keys match table */
-        shadowSize = p_CcNode->keysMatchTableMaxSize;
+         * 1 - an action descriptor */
+        shadowSize = FM_PCD_CC_AD_ENTRY_SIZE;
 
-        /* 2 - next action descriptors table, including one more entry for miss */
-        shadowSize += (p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE;
+        if (isKeyTblAlloc)
+        {
+            /* 2 - keys match table, if was allocated for the current node */
+            shadowSize += p_CcNode->keysMatchTableMaxSize;
 
-        /* 3 - an extra action descriptor (AD that holds keys match table and next action descriptors table) */
-        shadowSize += FM_PCD_CC_AD_ENTRY_SIZE;
+            /* 3 - next action descriptors table, including one more entry for miss */
+            shadowSize += (p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE;
+        }
 
         /* Update shadow to the calculated size */
         err = FmPcdUpdateCcShadow (p_CcNode->h_FmPcd, (uint32_t)shadowSize, FM_PCD_CC_AD_TABLE_ALIGN);
@@ -4641,9 +4858,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         }
     }
     else
-    {
         numOfKeysToAlloc = p_CcNode->numOfKeys;
-    }
 
     /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
        identification, IPv6 hop count identification, etc. */
@@ -4659,7 +4874,9 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
             return NULL;
         }
-        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable, 0, keySize * sizeof(uint8_t) * (numOfKeysToAlloc + 1));
+        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable,
+                   0,
+                   keySize * sizeof(uint8_t) * (numOfKeysToAlloc + 1));
     }
 
     /* Allocate action descriptors table */
@@ -4673,30 +4890,32 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
         return NULL;
     }
-    IOMemSet32((uint8_t *)p_CcNode->h_AdTable, 0, (uint32_t)((numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32((uint8_t *)p_CcNode->h_AdTable,
+               0,
+               (uint32_t)((numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
 
     p_KeysMatchTblTmp = p_CcNode->h_KeysMatchTable;
     p_AdTableTmp      = p_CcNode->h_AdTable;
 
     /* For each key, create the key and the next step AD */
-    for(tmp = 0 ; tmp < p_CcNode->numOfKeys; tmp++)
+    for (tmp = 0 ; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
-        if(p_KeysMatchTblTmp)
+        if (p_KeysMatchTblTmp)
         {
             /* Copy the key */
             Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_CcNode->sizeOfExtraction);
 
             /* Copy the key mask or initialize it to 0xFF..F */
-            if(p_CcNode->lclMask && p_KeyParams->p_Mask)
+            if (p_CcNode->lclMask && p_KeyParams->p_Mask)
             {
                 Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp,
                             p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
                             p_KeyParams->p_Mask,
                             p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
             }
-            else if(p_CcNode->lclMask)
+            else if (p_CcNode->lclMask)
             {
                 IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
                            p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
@@ -4706,27 +4925,27 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
             p_KeysMatchTblTmp = PTR_MOVE(p_KeysMatchTblTmp, keySize * sizeof(uint8_t));
         }
+
         /* Create the next action descriptor in the match table */
-        NextStepAd(p_AdTableTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
+        NextStepAd(p_AdTableTmp, &p_KeyParams->ccNextEngineParams, p_FmPcd);
 
         p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
-
     }
 
-    NextStepAd(p_AdTableTmp,&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
+    NextStepAd(p_AdTableTmp, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
 
     /* This parameter will be used to initialize the "key length" field in the action descriptor
        that points to this node and it should be 0 for full field extraction */
-    if(fullField == TRUE)
+    if (fullField == TRUE)
         p_CcNode->sizeOfExtraction = 0;
 
-    for(tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
     {
-        if(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
 
-            if(!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+            if (!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                 ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
@@ -4743,36 +4962,40 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         }
     }
 
-    for(tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
     {
-        if(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
 
-            if(IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
+            if (IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
                 UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, FALSE);
         }
     }
 
     p_AdTableTmp = p_CcNode->h_AdTable;
 
+    if (!FmPcdLockTryLockAll(h_FmPcd))
+    {
+        FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return NULL;
+    }
 
     /* Required action for each next engine */
     for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
     {
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.h_FrmReplic)
+            (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.frParams.h_FrmReplic)
             && (!(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)))
-        {
-            FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.h_FrmReplic,
+            FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.frParams.h_FrmReplic,
                                       TRUE, /* add */
                                       TRUE, /* fullUpdate */
                                       p_CcNode);
-        }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
-        if(p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
+        if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
         {
 
             err = FmPcdCcSetRequiredAction(h_FmPcd,
@@ -4783,6 +5006,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                                            NULL);
             if (err)
             {
+                FmPcdLockUnlockAll(h_FmPcd);
                 FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
                 REPORT_ERROR(MAJOR, err, NO_MSG);
                 return NULL;
@@ -4800,14 +5024,16 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                                         p_AdTableTmp,
                                         1,
                                         NULL);
-         if(err)
+         if (err)
          {
+            FmPcdLockUnlockAll(h_FmPcd);
             FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
             REPORT_ERROR(MAJOR, err, NO_MSG);
             return NULL;
         }
     }
 
+    FmPcdLockUnlockAll(h_FmPcd);
     return p_CcNode;
 }
 
@@ -4825,36 +5051,34 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID can not be removed because this node is occupied, first - unbind this node"));
 
     for (i = 0; i < p_CcNode->numOfKeys; i++)
-    {
-        if(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
-    }
 
     if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
         UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
 
     /* Handle also Miss entry */
-    for(i = 0; i < p_CcNode->numOfKeys + 1; i++)
+    for (i = 0; i < p_CcNode->numOfKeys + 1; i++)
     {
         if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
             FmPcdManipUpdateOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip, FALSE);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
-            (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic))
+            (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic))
         {
             if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
-                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic,
+                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
                                           FALSE,
                                           FALSE, /* fullUpdate */
                                           NULL);
             else
-                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic,
+                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.frParams.h_FrmReplic,
                                           FALSE,
                                           TRUE,  /* fullUpdate */
                                           p_CcNode);
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     }
 
     DeleteNode(p_CcNode);
@@ -4870,7 +5094,6 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
@@ -4884,11 +5107,11 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcAddKey(p_FmPcd,
                         p_CcNode,
@@ -4896,12 +5119,20 @@ t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
                         keySize,
                         p_KeyParams);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
@@ -4909,7 +5140,6 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
@@ -4917,23 +5147,30 @@ t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcRemoveKey(p_FmPcd, p_CcNode, keyIndex);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
+
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 
     return E_OK;
 }
@@ -4957,16 +5194,16 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
     INIT_LIST(&h_List);
 
     intFlags = FmPcdLock(p_FmPcd);
     err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
     FmPcdUnlock(p_FmPcd, intFlags);
     if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    {
+        DBG(TRACE, ("Node's trees lock failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcModifyKey(p_FmPcd,
                            p_CcNode,
@@ -4977,10 +5214,18 @@ t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
 
     FmPcdCcNodeTreeReleaseLock(&h_List);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
@@ -4990,7 +5235,6 @@ t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -4999,39 +5243,41 @@ t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = ModifyNextEngineParamNode(p_FmPcd,
                                     p_CcNode,
                                     keyIndex,
                                     p_FmPcdCcNextEngineParams);
-    if(err)
+
+    FmPcdLockUnlockAll(p_FmPcd);
+
+    switch (GET_ERROR_TYPE(err))
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        case E_OK:
+            return E_OK;
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
 
-    return E_OK;
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
-t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle h_CcNode,
-                                              t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                      h_CcNode,
+                                              t_FmPcdCcNextEngineParams     *p_FmPcdCcNextEngineParams)
 {
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
@@ -5042,25 +5288,30 @@ t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle h_CcNode,
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcModifyMissNextEngineParamNode(p_FmPcd,
                                                p_CcNode,
                                                p_FmPcdCcNextEngineParams);
-    if (err)
+
+    FmPcdLockUnlockAll(p_FmPcd);
+
+    switch (GET_ERROR_TYPE(err))
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        case E_OK:
+            return E_OK;
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
 
-    return E_OK;
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
@@ -5071,7 +5322,6 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
@@ -5080,31 +5330,34 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd,
                                         p_CcNode,
                                         keyIndex,
                                         keySize,
                                         p_KeyParams);
-    if (err)
+
+    FmPcdLockUnlockAll(p_FmPcd);
+
+    switch (GET_ERROR_TYPE(err))
     {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+        case E_OK:
+            return E_OK;
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
 
-    return E_OK;
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 
@@ -5116,7 +5369,6 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -5128,14 +5380,14 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
-    if (err != E_OK)
+    if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(&h_List);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
@@ -5143,12 +5395,20 @@ t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
 
     err = FmPcdCcRemoveKey(p_FmPcd, p_CcNode, keyIndex);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 
@@ -5161,7 +5421,6 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -5174,14 +5433,14 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
-    if (err != E_OK)
+    if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(&h_List);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
@@ -5192,12 +5451,20 @@ t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNod
                                     keyIndex,
                                     p_FmPcdCcNextEngineParams);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNode,
@@ -5209,7 +5476,6 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
     t_FmPcd         *p_FmPcd;
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_List          h_List;
-    uint32_t        intFlags;
     uint16_t        keyIndex;
     t_Error         err;
 
@@ -5222,14 +5488,14 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
 
     INIT_LIST(&h_List);
 
-    intFlags = FmPcdLock(p_FmPcd);
-    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
-    FmPcdUnlock(p_FmPcd, intFlags);
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
-    if (err != E_OK)
+    if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(&h_List);
         RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
@@ -5241,13 +5507,20 @@ t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNod
                                         keySize,
                                         p_KeyParams);
 
-    FmPcdCcNodeTreeReleaseLock(&h_List);
+    FmPcdLockUnlockAll(p_FmPcd);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
 
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
@@ -5277,13 +5550,17 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
     err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
     FmPcdUnlock(p_FmPcd, intFlags);
     if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    {
+        DBG(TRACE, ("Node's trees lock failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
-    if (err != E_OK)
+    if (GET_ERROR_TYPE(err) != E_OK)
     {
         FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the "
+                                  "match table of the provided node"));
     }
 
     err = FmPcdCcModifyKey(p_FmPcd,
@@ -5295,10 +5572,18 @@ t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
 
     FmPcdCcNodeTreeReleaseLock(&h_List);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
 
-    return E_OK;
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
@@ -5308,20 +5593,14 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
     t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
 
-    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_CcNode->numOfKeys;
-
-    if(keyIndex > p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > numOfKeys"));
+    if (keyIndex >= p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex exceeds current number of keys"));
 
-    if(keyIndex > FM_PCD_MAX_NUM_OF_CC_NODES)
+    if (keyIndex > FM_PCD_MAX_NUM_OF_CC_NODES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex can not be larger than 255"));
 
-    if(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
-        if(keyIndex == p_CcNode->numOfKeys)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This type of node doesn't have Miss"));
-
     memcpy(p_FmPcdCcNextEngineParams,
            &p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams,
            sizeof(t_FmPcdCcNextEngineParams));
@@ -5329,6 +5608,7 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
     return E_OK;
 }
 
+
 uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
 {
     t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
@@ -5399,8 +5679,7 @@ t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
 t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
 {
     t_FmPcdCcNode           *p_CcNodeHashTbl;
-    t_FmPcdCcNodeParams     *p_indxHashCcNodeParam = NULL,
-                            *p_exactMatchCcNodeParam = NULL;
+    t_FmPcdCcNodeParams     *p_IndxHashCcNodeParam, *p_ExactMatchCcNodeParam;
     t_Handle                h_CcNode;
     t_FmPcdCcKeyParams      *p_HashKeyParams;
     uint32_t                i;
@@ -5409,23 +5688,34 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_Param, E_NULL_POINTER, NULL);
 
-    p_exactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
-    if(!p_exactMatchCcNodeParam)
+    if (p_Param->maxNumOfKeys == 0)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Max number of keys must be higher then 0"));
+        return NULL;
+    }
+
+    if (p_Param->hashResMask == 0)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_exactMatchCcNodeParam"));
+        REPORT_ERROR(MINOR, E_INVALID_VALUE, ("Hash result mask must differ from 0"));
         return NULL;
     }
 
-    p_indxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
-    if(!p_indxHashCcNodeParam)
+    p_ExactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    if(!p_ExactMatchCcNodeParam)
     {
-        XX_Free(p_exactMatchCcNodeParam);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_indxHashCcNodeParam"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_ExactMatchCcNodeParam"));
         return NULL;
     }
+    memset(p_ExactMatchCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
 
-    memset(p_exactMatchCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
-    memset(p_indxHashCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
+    p_IndxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    if(!p_IndxHashCcNodeParam)
+    {
+        XX_Free(p_ExactMatchCcNodeParam);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_IndxHashCcNodeParam"));
+        return NULL;
+    }
+    memset(p_IndxHashCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
 
     /* Calculate number of sets and number of ways of the hash table */
     countMask = (uint16_t)(p_Param->hashResMask >> 4);
@@ -5442,25 +5732,25 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         DBG(INFO, ("'maxNumOfKeys' is not a multiple of hash number of ways, so number of ways will be rounded up"));
 
     /* Building exact-match node params, will be used to create the hash buckets */
-    p_exactMatchCcNodeParam->extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
+    p_ExactMatchCcNodeParam->extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
 
-    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.src     = e_FM_PCD_EXTRACT_FROM_KEY;
-    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.action  = e_FM_PCD_ACTION_EXACT_MATCH;
-    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.offset  = 0;
-    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.size    = p_Param->matchKeySize;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.src     = e_FM_PCD_EXTRACT_FROM_KEY;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.action  = e_FM_PCD_ACTION_EXACT_MATCH;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.offset  = 0;
+    p_ExactMatchCcNodeParam->extractCcParams.extractNonHdr.size    = p_Param->matchKeySize;
 
-    p_exactMatchCcNodeParam->keysParams.maxNumOfKeys               = numOfWays;
-    p_exactMatchCcNodeParam->keysParams.maskSupport                = FALSE;
-    p_exactMatchCcNodeParam->keysParams.statisticsMode             = p_Param->statisticsMode;
-    p_exactMatchCcNodeParam->keysParams.numOfKeys                  = 0;
-    p_exactMatchCcNodeParam->keysParams.keySize                    = p_Param->matchKeySize;
-    p_exactMatchCcNodeParam->keysParams.ccNextEngineParamsForMiss  = p_Param->ccNextEngineParamsForMiss;
+    p_ExactMatchCcNodeParam->keysParams.maxNumOfKeys               = numOfWays;
+    p_ExactMatchCcNodeParam->keysParams.maskSupport                = FALSE;
+    p_ExactMatchCcNodeParam->keysParams.statisticsMode             = p_Param->statisticsMode;
+    p_ExactMatchCcNodeParam->keysParams.numOfKeys                  = 0;
+    p_ExactMatchCcNodeParam->keysParams.keySize                    = p_Param->matchKeySize;
+    p_ExactMatchCcNodeParam->keysParams.ccNextEngineParamsForMiss  = p_Param->ccNextEngineParamsForMiss;
 
-    p_HashKeyParams = p_indxHashCcNodeParam->keysParams.keyParams;
+    p_HashKeyParams = p_IndxHashCcNodeParam->keysParams.keyParams;
 
     for (i = 0; i < numOfSets; i++)
     {
-        h_CcNode = FM_PCD_MatchTableSet(h_FmPcd, p_exactMatchCcNodeParam);
+        h_CcNode = FM_PCD_MatchTableSet(h_FmPcd, p_ExactMatchCcNodeParam);
         if (!h_CcNode)
             break;
 
@@ -5474,31 +5764,30 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         for (i = i-1; i >=0; i--)
             FM_PCD_MatchTableDelete(p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode);
 
-        XX_Free(p_indxHashCcNodeParam);
-        XX_Free(p_exactMatchCcNodeParam);
-
         REPORT_ERROR(MAJOR, E_NULL_POINTER, NO_MSG);
+        XX_Free(p_IndxHashCcNodeParam);
+        XX_Free(p_ExactMatchCcNodeParam);
         return NULL;
     }
 
     /* Creating indexed-hash CC node */
-    p_indxHashCcNodeParam->extractCcParams.type                     = e_FM_PCD_EXTRACT_NON_HDR;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.src        = e_FM_PCD_EXTRACT_FROM_HASH;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.action     = e_FM_PCD_ACTION_INDEXED_LOOKUP;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.icIndxMask = p_Param->hashResMask;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.offset     = p_Param->hashShift;
-    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.size       = 2;
+    p_IndxHashCcNodeParam->extractCcParams.type                     = e_FM_PCD_EXTRACT_NON_HDR;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.src        = e_FM_PCD_EXTRACT_FROM_HASH;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.action     = e_FM_PCD_ACTION_INDEXED_LOOKUP;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.icIndxMask = p_Param->hashResMask;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.offset     = p_Param->hashShift;
+    p_IndxHashCcNodeParam->extractCcParams.extractNonHdr.size       = 2;
 
-    p_indxHashCcNodeParam->keysParams.maxNumOfKeys   = 0;
-    p_indxHashCcNodeParam->keysParams.maskSupport    = FALSE;
-    p_indxHashCcNodeParam->keysParams.statisticsMode = p_Param->statisticsMode;
-    p_indxHashCcNodeParam->keysParams.numOfKeys      = numOfSets;      /* Number of keys of this node is number of sets of the hash */
-    p_indxHashCcNodeParam->keysParams.keySize        = 2;
+    p_IndxHashCcNodeParam->keysParams.maxNumOfKeys   = numOfSets;
+    p_IndxHashCcNodeParam->keysParams.maskSupport    = FALSE;
+    p_IndxHashCcNodeParam->keysParams.statisticsMode = p_Param->statisticsMode;
+    p_IndxHashCcNodeParam->keysParams.numOfKeys      = numOfSets;      /* Number of keys of this node is number of sets of the hash */
+    p_IndxHashCcNodeParam->keysParams.keySize        = 2;
 
-    p_CcNodeHashTbl = FM_PCD_MatchTableSet(h_FmPcd, p_indxHashCcNodeParam);
+    p_CcNodeHashTbl = FM_PCD_MatchTableSet(h_FmPcd, p_IndxHashCcNodeParam);
 
-    XX_Free(p_indxHashCcNodeParam);
-    XX_Free(p_exactMatchCcNodeParam);
+    XX_Free(p_IndxHashCcNodeParam);
+    XX_Free(p_ExactMatchCcNodeParam);
 
     return p_CcNodeHashTbl;
 }
@@ -5519,16 +5808,15 @@ t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
 
     for (i = 0; i < numOfBuckets; i++)
-    {
         p_HashBuckets[i] = p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
-    }
 
     err = FM_PCD_MatchTableDelete(p_HashTbl);
 
     for (i = 0; i < numOfBuckets; i++)
-    {
-        err = FM_PCD_MatchTableDelete(p_HashBuckets[i]);
-    }
+        err |= FM_PCD_MatchTableDelete(p_HashBuckets[i]);
+
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -5651,6 +5939,7 @@ t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl
     return E_OK;
 }
 
+
 t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl,
                                           t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
 {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index 39f4952..b88df15 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_cc.h
 
@@ -129,7 +130,7 @@
 #define FM_PCD_CC_AD_TABLE_ALIGN            16
 #define FM_PCD_CC_AD_ENTRY_SIZE             16
 #define FM_PCD_CC_NUM_OF_KEYS               255
-#define FM_PCD_CC_TREE_ADDR_ALIGN			256
+#define FM_PCD_CC_TREE_ADDR_ALIGN           256
 
 #define FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE   0x00000000
 #define FM_PCD_AD_RESULT_DATA_FLOW_TYPE     0x80000000
@@ -138,7 +139,6 @@
 #define FM_PCD_AD_RESULT_NADEN              0x20000000
 #define FM_PCD_AD_RESULT_STATISTICS_EN      0x40000000
 
-
 #define FM_PCD_AD_CONT_LOOKUP_TYPE          0x40000000
 #define FM_PCD_AD_CONT_LOOKUP_LCL_MASK      0x00800000
 
@@ -146,6 +146,10 @@
 #define FM_PCD_AD_OPCODE_MASK               0x0000000f
 
 #define FM_PCD_AD_PROFILEID_FOR_CNTRL_SHIFT 16
+#if (DPAA_VERSION >= 11)
+#define FM_PCD_AD_RESULT_VSP_SHIFT           24
+#define FM_PCD_AD_RESULT_NO_OM_VSPE          0x02000000
+#endif /* (DPAA_VERSION >= 11) */
 
 #define GLBL_MASK_FOR_HASH_INDEXED          0xfff00000
 #define CC_GLBL_MASK_SIZE                   4
@@ -238,9 +242,10 @@ typedef struct
     t_Handle    h_NodeForAdd;
     t_Handle    h_NodeForRmv;
     t_Handle    h_ManipForRmv;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
+    t_Handle    h_FrmReplicForAdd;
     t_Handle    h_FrmReplicForRmv;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     bool        tree;
 
     t_FmPcdCcKeyAndNextEngineParams  keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_KEYS];
@@ -275,6 +280,7 @@ typedef struct
 
     t_Handle    h_KeysMatchTable;
     t_Handle    h_AdTable;
+    t_Handle    h_StatsAds;
     t_Handle    h_Ad;
 
     t_List      ccPrevNodesLst;
@@ -314,8 +320,7 @@ typedef struct
     uint8_t             numOfGrps;
     t_FmPcdCcGroupParam fmPcdGroupParam[FM_PCD_MAX_NUM_OF_CC_GROUPS];
     t_List              fmPortsLst;
-    volatile bool       lock;
-    t_Handle            h_Spinlock;
+    t_FmPcdLock         *p_Lock;
     uint8_t             numOfEntries;
     uint8_t             owners;
     t_Handle            h_FmPcdCcSavedManipParams;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index bec6a83..57f8b17 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_kg.c
 
@@ -46,6 +47,7 @@
 #include "fm_pcd.h"
 #include "fm_hc.h"
 #include "fm_pcd_ipc.h"
+#include "fm_kg.h"
 
 
 /****************************************/
@@ -55,39 +57,37 @@
 static uint32_t KgHwLock(t_Handle h_FmPcdKg)
 {
     ASSERT_COND(h_FmPcdKg);
-    return XX_LockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_HwSpinlock);
+    return XX_LockIntrSpinlock(((t_FmPcdKg *)h_FmPcdKg)->h_HwSpinlock);
 }
 
 static void KgHwUnlock(t_Handle h_FmPcdKg, uint32_t intFlags)
 {
     ASSERT_COND(h_FmPcdKg);
-    XX_UnlockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_HwSpinlock, intFlags);
+    XX_UnlockIntrSpinlock(((t_FmPcdKg *)h_FmPcdKg)->h_HwSpinlock, intFlags);
 }
 
-static uint32_t KgSwLock(t_Handle h_FmPcdKg)
+static uint32_t KgSchemeLock(t_Handle h_Scheme)
 {
-    ASSERT_COND(h_FmPcdKg);
-    return XX_LockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_SwSpinlock);
+    ASSERT_COND(h_Scheme);
+    return FmPcdLockSpinlock(((t_FmPcdKgScheme *)h_Scheme)->p_Lock);
 }
 
-static void KgSwUnlock(t_Handle h_FmPcdKg, uint32_t intFlags)
+static void KgSchemeUnlock(t_Handle h_Scheme, uint32_t intFlags)
 {
-    ASSERT_COND(h_FmPcdKg);
-    XX_UnlockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_SwSpinlock, intFlags);
+    ASSERT_COND(h_Scheme);
+    FmPcdUnlockSpinlock(((t_FmPcdKgScheme *)h_Scheme)->p_Lock, intFlags);
 }
 
-static uint32_t KgSchemeLock(t_Handle h_Scheme)
+static bool KgSchemeFlagTryLock(t_Handle h_Scheme)
 {
     ASSERT_COND(h_Scheme);
-
-    return XX_LockIntrSpinlock(((t_FmPcdKgScheme*)h_Scheme)->h_Spinlock);
+    return FmPcdLockTryLock(((t_FmPcdKgScheme *)h_Scheme)->p_Lock);
 }
 
-static void KgSchemeUnlock(t_Handle h_Scheme, uint32_t intFlags)
+static void KgSchemeFlagUnlock(t_Handle h_Scheme)
 {
     ASSERT_COND(h_Scheme);
-
-    XX_UnlockIntrSpinlock(((t_FmPcdKgScheme*)h_Scheme)->h_Spinlock, intFlags);
+    FmPcdLockUnlock(((t_FmPcdKgScheme *)h_Scheme)->p_Lock);
 }
 
 static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
@@ -685,402 +685,616 @@ static uint8_t GetExtractedOrMask(uint8_t bitOffset, bool fqid)
     return mask;
 }
 
-
-t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
+static void IncSchemeOwners(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
-    t_FmPcdIpcKgClsPlanParams       kgAlloc;
-    t_Error                         err = E_OK;
-    uint32_t                        oredVectors = 0;
-    int                             i, j;
+    t_FmPcdKg           *p_FmPcdKg;
+    t_FmPcdKgScheme     *p_Scheme;
+    uint32_t            intFlags;
+    uint8_t             relativeSchemeId;
+    int                 i;
 
-    /* this routine is protected by the calling routine ! */
-    if (p_Grp->numOfOptions >= FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Too many classification plan basic options selected."));
+    p_FmPcdKg = p_FmPcd->p_FmPcdKg;
 
-    /* find a new clsPlan group */
-    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
-        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
-            break;
-    if(i== FM_MAX_NUM_OF_PORTS)
-        RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
+    /* for each scheme - update owners counters */
+    for (i = 0; i < p_BindPort->numOfSchemes; i++)
+    {
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        ASSERT_COND(relativeSchemeId < FM_PCD_KG_NUM_OF_SCHEMES);
 
-    p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
+        p_Scheme = &p_FmPcdKg->schemes[relativeSchemeId];
 
-    p_Grp->clsPlanGrpId = (uint8_t)i;
+        /* increment owners number */
+        intFlags = KgSchemeLock(p_Scheme);
+        p_Scheme->owners++;
+        KgSchemeUnlock(p_Scheme, intFlags);
+    }
+}
 
-    if(p_Grp->numOfOptions == 0)
-        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)i;
+static void DecSchemeOwners(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+{
+    t_FmPcdKg           *p_FmPcdKg;
+    t_FmPcdKgScheme     *p_Scheme;
+    uint32_t            intFlags;
+    uint8_t             relativeSchemeId;
+    int                 i;
 
-    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
-    p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
-    p_ClsPlanGrp->owners = 0;
-    FmPcdSetClsPlanGrpId(p_FmPcd, p_Grp->netEnvId, p_Grp->clsPlanGrpId);
-    FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
+    p_FmPcdKg = p_FmPcd->p_FmPcdKg;
 
-    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1<<p_Grp->numOfOptions);
-    /* a minimal group of 8 is required */
-    if(p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
-        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    /* for each scheme - update owners counters */
+    for(i = 0; i < p_BindPort->numOfSchemes; i++)
     {
-        err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        ASSERT_COND(relativeSchemeId < FM_PCD_KG_NUM_OF_SCHEMES);
 
-        if(err)
-            RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        p_Scheme = &p_FmPcdKg->schemes[relativeSchemeId];
+
+        /* increment owners number */
+        ASSERT_COND(p_Scheme->owners);
+        intFlags = KgSchemeLock(p_Scheme);
+        p_Scheme->owners--;
+        KgSchemeUnlock(p_Scheme, intFlags);
     }
-    else
-    {
-        t_FmPcdIpcMsg   msg;
-        uint32_t        replyLength;
-        t_FmPcdIpcReply reply;
+}
 
-        /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        memset(&kgAlloc, 0, sizeof(kgAlloc));
-        kgAlloc.guestId = p_FmPcd->guestId;
-        kgAlloc.numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
-        msg.msgId = FM_PCD_ALLOC_KG_CLSPLAN;
-        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
-        replyLength = (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry));
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(kgAlloc),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+static void UpateSchemePointedOwner(t_FmPcdKgScheme *p_Scheme, bool add)
+{
+    /* this routine is locked by the calling routine */
+   ASSERT_COND(p_Scheme);
+   ASSERT_COND(p_Scheme->valid);
 
-        if (replyLength != (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry)))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        if ((t_Error)reply.error != E_OK)
-            RETURN_ERROR(MINOR, (t_Error)reply.error, NO_MSG);
+    if(add)
+        p_Scheme->pointedOwners++;
+    else
+        p_Scheme->pointedOwners--;
+}
 
-        p_ClsPlanGrp->baseEntry = *(uint8_t*)(reply.replyBody);
-    }
+static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
+{
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0, tmpKgpeSp, intFlags;
+    t_Error                 err = E_OK;
 
-    /* build classification plan entries parameters */
-    p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
-    p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+    /* The calling routine had locked the port, so for each port only one core can access
+     * (so we don't need a lock here) */
+    if (p_FmPcd->h_Hc)
+        return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
 
-    oredVectors = 0;
-    for(i = 0; i<p_Grp->numOfOptions; i++)
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+
+    tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+    /* lock a common KG reg */
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    if(err)
     {
-        oredVectors |= p_Grp->optVectors[i];
-        /* save an array of used options - the indexes represent the power of 2 index */
-        p_ClsPlanGrp->optArray[i] = p_Grp->options[i];
+        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
-    /* set the classification plan relevant entries so that all bits
-     * relevant to the list of options is cleared
-     */
-    for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
-        p_ClsPlanSet->vectors[j] = ~oredVectors;
 
-    for(i = 0; i<p_Grp->numOfOptions; i++)
-    {
-       /* option i got the place 2^i in the clsPlan array. all entries that
-         * have bit i set, should have the vector bit cleared. So each option
-         * has one location that it is exclusive (1,2,4,8...) and represent the
-         * presence of that option only, and other locations that represent a
-         * combination of options.
-         * e.g:
-         * If ethernet-BC is option 1 it gets entry 2 in the table. Entry 2
-         * now represents a frame with ethernet-BC header - so the bit
-         * representing ethernet-BC should be set and all other option bits
-         * should be cleared.
-         * Entries 2,3,6,7,10... also have ethernet-BC and therefore have bit
-         * vector[1] set, but they also have other bits set:
-         * 3=1+2, options 0 and 1
-         * 6=2+4, options 1 and 2
-         * 7=1+2+4, options 0,1,and 2
-         * 10=2+8, options 1 and 3
-         * etc.
-         * */
+    tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
 
-        /* now for each option (i), we set their bits in all entries (j)
-         * that contain bit 2^i.
-         */
-        for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
-        {
-            if(j & (1<<i))
-                p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
-        }
-    }
+    if(add)
+        tmpKgpeSp |= spReg;
+    else /* clear */
+        tmpKgpeSp &= ~spReg;
 
-    return E_OK;
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+
+    tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+    return err;
 }
 
-void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
+static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcKgClsPlanParams       kgAlloc;
-    t_Error                         err;
-    t_FmPcdIpcMsg                   msg;
-    uint32_t                        replyLength,intFlags ;
-    t_FmPcdIpcReply                 reply;
-
-    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
+    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg, intFlags;
+    t_Error                 err;
 
-    /* check that no port is bound to this clsPlan */
-    if(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
+    if (p_FmPcd->h_Hc)
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
-        return;
+        err = FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
+        return err;
     }
 
-    FmPcdSetClsPlanGrpId(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId, ILLEGAL_CLS_PLAN);
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
+    tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
+    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
-    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
+    return err;
+}
 
-    if(grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
-        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+static uint32_t BuildCppReg(t_FmPcd *p_FmPcd, uint8_t clsPlanGrpId)
+{
+    uint32_t    tmpKgpeCpp;
 
-    /* clear clsPlan driver structure */
-    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
+    tmpKgpeCpp = (uint32_t)(p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry / 8);
+    tmpKgpeCpp |= (uint32_t)(((p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp / 8) - 1) << FM_PCD_KG_PE_CPP_MASK_SHIFT);
 
-    /* free blocks */
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
-    {
-        KgFreeClsPlanEntries(h_FmPcd,
-                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
-                             p_FmPcd->guestId,
-                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+    return tmpKgpeCpp;
+}
 
-        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-    }
-    else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
-    {
-        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        kgAlloc.guestId = p_FmPcd->guestId;
-        kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
-        kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
-        msg.msgId = FM_PCD_FREE_KG_CLSPLAN;
-        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
-        replyLength = sizeof(uint32_t);
-        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                (uint8_t*)&msg,
-                                sizeof(msg.msgId) + sizeof(kgAlloc),
-                                (uint8_t*)&reply,
-                                &replyLength,
-                                NULL,
-                                NULL);
-        if (err != E_OK)
-        {
-            REPORT_ERROR(MINOR, err, NO_MSG);
-            return;
-        }
-        if (replyLength != sizeof(uint32_t))
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-            return;
-        }
-        if((t_Error)reply.error != E_OK)
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Free KG clsPlan failed"));
-            return;
-        }
-    }
+static t_Error BindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
+{
+    uint32_t                tmpKgpeCpp = 0;
+
+    tmpKgpeCpp = BuildCppReg(p_FmPcd, clsPlanGrpId);
+    return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
 }
 
-t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+static void UnbindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
 {
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                j, schemesPerPortVector = 0;
-    t_FmPcdKgScheme         *p_Scheme;
-    uint8_t                 i, relativeSchemeId;
-    uint32_t                tmp, walking1Mask;
-    uint8_t                 swPortIndex = 0;
+    KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+}
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+static uint32_t ReadClsPlanBlockActionReg(uint8_t grpId)
+{
+    return (uint32_t)(FM_PCD_KG_KGAR_GO |
+                      FM_PCD_KG_KGAR_READ |
+                      FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                      DUMMY_PORT_ID |
+                      ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                      FM_PCD_KG_KGAR_WSEL_MASK);
 
-    /* for each scheme */
-    for(i = 0; i<p_BindPort->numOfSchemes; i++)
-    {
-        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
-        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
-            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+    /* if we ever want to write 1 by 1, use:
+       sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));
+     */
+}
 
-        if(add)
-        {
-            p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
-            if (!FmPcdKgIsSchemeValidSw(p_Scheme))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
-            /* check netEnvId  of the port against the scheme netEnvId */
-            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
+static void PcdKgErrorException(t_Handle h_FmPcd)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                event, force, schemeIndexes = 0,index = 0, mask = 0;
 
-            /* if next engine is private port policer profile, we need to check that it is valid */
-            HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
-            if(p_Scheme->nextRelativePlcrProfile)
-            {
-                for(j = 0;j<p_Scheme->numOfProfiles;j++)
-                {
-                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
-                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
-                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
-                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
-                }
-            }
-            if(!p_BindPort->useClsPlan)
-            {
-                /* This check may be redundant as port is a assigned to the whole NetEnv */
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
+    mask = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
 
-                /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
-                cls plan options. Schemes that are used only directly, should not be checked.
-                it also may not be bound to schemes that go to CC with units that are options  - so we OR
-                the match vector and the grpBits (= ccUnits) */
-                if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
-                {
-                    walking1Mask = 0x80000000;
-                    tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
-                    tmp |= p_Scheme->ccUnits;
-                    while (tmp)
-                    {
-                        if(tmp & walking1Mask)
-                        {
-                            tmp &= ~walking1Mask;
-                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
-                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
-                        }
-                        walking1Mask >>= 1;
-                    }
-                }
+    schemeIndexes = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer);
+    schemeIndexes &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseeer);
+
+    event &= mask;
+
+    /* clear the forced events */
+    force = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer);
+    if(force & event)
+        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, force & ~event);
+
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
+    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
+
+    if(event & FM_PCD_KG_DOUBLE_ECC)
+        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
+    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
+    {
+        if(schemeIndexes)
+        {
+            while(schemeIndexes)
+            {
+                if(schemeIndexes & 0x1)
+                    p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
+                schemeIndexes >>= 1;
+                index+=1;
             }
         }
-        /* build vector */
-        schemesPerPortVector |= 1 << (31 - p_BindPort->schemesIds[i]);
+        else /* this should happen only when interrupt is forced. */
+            p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW);
     }
+}
 
-    *p_SpReg = schemesPerPortVector;
+static t_Error KgInitGuest(t_FmPcd *p_FmPcd)
+{
+    t_Error                     err = E_OK;
+    t_FmPcdIpcKgSchemesParams   kgAlloc;
+    uint32_t                    replyLength;
+    t_FmPcdIpcReply             reply;
+    t_FmPcdIpcMsg               msg;
 
-    return E_OK;
+    ASSERT_COND(p_FmPcd->guestId != NCSW_MASTER_ID);
+
+    /* in GUEST_PARTITION, we use the IPC  */
+    memset(&reply, 0, sizeof(reply));
+    memset(&msg, 0, sizeof(msg));
+    memset(&kgAlloc, 0, sizeof(t_FmPcdIpcKgSchemesParams));
+    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
+    kgAlloc.guestId = p_FmPcd->guestId;
+    msg.msgId = FM_PCD_ALLOC_KG_SCHEMES;
+    memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
+    replyLength = sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t);
+    if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                 (uint8_t*)&msg,
+                                 sizeof(msg.msgId) + sizeof(kgAlloc),
+                                 (uint8_t*)&reply,
+                                 &replyLength,
+                                 NULL,
+                                 NULL)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if(replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+    memcpy(p_FmPcd->p_FmPcdKg->schemesIds, (uint8_t*)(reply.replyBody),p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t));
+
+    return (t_Error)reply.error;
 }
 
-void FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                 i;
-    t_FmPcdKgScheme     *p_Scheme;
-    uint32_t            intFlags;
+    t_Error                     err = E_OK;
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+    int                         i;
+    uint8_t                     hardwarePortId = 0;
+    uint32_t                    tmpReg;
 
-    /* for each scheme - update owners counters */
-    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+
+    /**********************KGEER******************/
+    WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
+    /**********************KGEER******************/
+
+    /**********************KGEEER******************/
+    tmpReg = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
     {
-        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+    }
+    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+        tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
+    WRITE_UINT32(p_Regs->kgeeer,tmpReg);
+    /**********************KGEEER******************/
 
-        /* increment owners number */
-        intFlags = KgSchemeLock(p_Scheme);
-        p_Scheme->owners++;
-        KgSchemeUnlock(p_Scheme, intFlags);
+    /**********************KGFDOR******************/
+    WRITE_UINT32(p_Regs->kgfdor,0);
+    /**********************KGFDOR******************/
+
+    /**********************KGGDV0R******************/
+    WRITE_UINT32(p_Regs->kggdv0r,0);
+    /**********************KGGDV0R******************/
+
+    /**********************KGGDV1R******************/
+    WRITE_UINT32(p_Regs->kggdv1r,0);
+    /**********************KGGDV1R******************/
+
+    /**********************KGGCR******************/
+    WRITE_UINT32(p_Regs->kggcr, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd));
+    /**********************KGGCR******************/
+
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR, PcdKgErrorException, p_FmPcd);
+
+    /* clear binding between ports to schemes so that all ports are not bound to any schemes */
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    {
+        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
+
+        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
     }
+
+    /* enable and enable all scheme interrupts */
+    WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
+    WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
+
+
+    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
+    {
+        err = FmPcdKgAllocSchemes(p_FmPcd,
+                                  p_FmPcd->p_FmPcdKg->numOfSchemes,
+                                  p_FmPcd->guestId,
+                                  p_FmPcd->p_FmPcdKg->schemesIds);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    return E_OK;
 }
 
-void FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
+static void  ValidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                 i;
-    t_FmPcdKgScheme     *p_Scheme;
-    uint32_t            intFlags;
+    ASSERT_COND(!p_Scheme->valid);
+    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+        FmPcdIncNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
+    p_Scheme->valid = TRUE;
+}
 
-    /* for each scheme - update owners counters */
-    for(i = 0; i<p_BindPort->numOfSchemes; i++)
-    {
-        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
+static t_Error  InvalidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
+{
+    if (p_Scheme->owners)
+       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
 
-        /* increment owners number */
-        ASSERT_COND(p_Scheme->owners);
-        intFlags = KgSchemeLock(p_Scheme);
-        p_Scheme->owners--;
-        KgSchemeUnlock(p_Scheme, intFlags);
-    }
+    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+        FmPcdDecNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
+    p_Scheme->valid = FALSE;
+
+    return E_OK;
 }
 
-static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spReg, bool add)
+
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet)
 {
-    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg = 0, tmpKgpeSp, intFlags;
-    t_Error                 err = E_OK;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
+    t_Error                         err = E_OK;
+    uint32_t                        oredVectors = 0;
+    int                             i, j;
 
-    /* The calling routine had locked the port, so for each port only one core can access
-     * (so we don't need a lock here) */
-    if (p_FmPcd->h_Hc)
-        return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
+    /* this routine is protected by the calling routine ! */
+    if (p_Grp->numOfOptions >= FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Too many classification plan basic options selected."));
 
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
+    /* find a new clsPlan group */
+    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
+        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
+            break;
+    if (i == FM_MAX_NUM_OF_PORTS)
+        RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
 
-    tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
-    /* lock a common KG reg */
-    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    if(err)
+    p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
+
+    p_Grp->clsPlanGrpId = (uint8_t)i;
+
+    if (p_Grp->numOfOptions == 0)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)i;
+
+    p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
+    p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
+    p_ClsPlanGrp->owners = 0;
+    FmPcdSetClsPlanGrpId(p_FmPcd, p_Grp->netEnvId, p_Grp->clsPlanGrpId);
+    FmPcdIncNetEnvOwners(p_FmPcd, p_Grp->netEnvId);
+
+    p_ClsPlanGrp->sizeOfGrp = (uint16_t)(1 << p_Grp->numOfOptions);
+    /* a minimal group of 8 is required */
+    if (p_ClsPlanGrp->sizeOfGrp < CLS_PLAN_NUM_PER_GRP)
+        p_ClsPlanGrp->sizeOfGrp = CLS_PLAN_NUM_PER_GRP;
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
     {
-        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
+
+        if(err)
+            RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
     }
+    else
+    {
+        t_FmPcdIpcMsg   msg;
+        uint32_t        replyLength;
+        t_FmPcdIpcReply reply;
 
-    tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
+        /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        memset(&kgAlloc, 0, sizeof(kgAlloc));
+        kgAlloc.guestId = p_FmPcd->guestId;
+        kgAlloc.numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
+        msg.msgId = FM_PCD_ALLOC_KG_CLSPLAN;
+        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
+        replyLength = (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry));
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) + sizeof(kgAlloc),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    if(add)
-        tmpKgpeSp |= spReg;
-    else /* clear */
-        tmpKgpeSp &= ~spReg;
+        if (replyLength != (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        if ((t_Error)reply.error != E_OK)
+            RETURN_ERROR(MINOR, (t_Error)reply.error, NO_MSG);
 
-    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_sp, tmpKgpeSp);
+        p_ClsPlanGrp->baseEntry = *(uint8_t*)(reply.replyBody);
+    }
 
-    tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
+    /* build classification plan entries parameters */
+    p_ClsPlanSet->baseEntry = p_ClsPlanGrp->baseEntry;
+    p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
 
-    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-    return err;
+    oredVectors = 0;
+    for(i = 0; i<p_Grp->numOfOptions; i++)
+    {
+        oredVectors |= p_Grp->optVectors[i];
+        /* save an array of used options - the indexes represent the power of 2 index */
+        p_ClsPlanGrp->optArray[i] = p_Grp->options[i];
+    }
+    /* set the classification plan relevant entries so that all bits
+     * relevant to the list of options is cleared
+     */
+    for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        p_ClsPlanSet->vectors[j] = ~oredVectors;
+
+    for(i = 0; i<p_Grp->numOfOptions; i++)
+    {
+       /* option i got the place 2^i in the clsPlan array. all entries that
+         * have bit i set, should have the vector bit cleared. So each option
+         * has one location that it is exclusive (1,2,4,8...) and represent the
+         * presence of that option only, and other locations that represent a
+         * combination of options.
+         * e.g:
+         * If ethernet-BC is option 1 it gets entry 2 in the table. Entry 2
+         * now represents a frame with ethernet-BC header - so the bit
+         * representing ethernet-BC should be set and all other option bits
+         * should be cleared.
+         * Entries 2,3,6,7,10... also have ethernet-BC and therefore have bit
+         * vector[1] set, but they also have other bits set:
+         * 3=1+2, options 0 and 1
+         * 6=2+4, options 1 and 2
+         * 7=1+2+4, options 0,1,and 2
+         * 10=2+8, options 1 and 3
+         * etc.
+         * */
+
+        /* now for each option (i), we set their bits in all entries (j)
+         * that contain bit 2^i.
+         */
+        for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        {
+            if(j & (1<<i))
+                p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
+        }
+    }
+
+    return E_OK;
 }
 
-static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cppReg)
+void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
 {
-    t_FmPcdKgPortConfigRegs *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg, intFlags;
-    t_Error                 err;
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdIpcKgClsPlanParams       kgAlloc;
+    t_Error                         err;
+    t_FmPcdIpcMsg                   msg;
+    uint32_t                        replyLength;
+    t_FmPcdIpcReply                 reply;
+
+    /* check that no port is bound to this clsPlan */
+    if (p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
+    {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a clsPlan grp that has ports bound to"));
+        return;
+    }
+
+    FmPcdSetClsPlanGrpId(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId, ILLEGAL_CLS_PLAN);
+
+    FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
+
+    if (grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+
+    /* clear clsPlan driver structure */
+    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
+
+    /* free blocks */
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        KgFreeClsPlanEntries(h_FmPcd,
+                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
+                             p_FmPcd->guestId,
+                             p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+    }
+    else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
+    {
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        kgAlloc.guestId = p_FmPcd->guestId;
+        kgAlloc.numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp;
+        kgAlloc.clsPlanBase = p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry;
+        msg.msgId = FM_PCD_FREE_KG_CLSPLAN;
+        memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
+        replyLength = sizeof(uint32_t);
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(kgAlloc),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+        {
+            REPORT_ERROR(MINOR, err, NO_MSG);
+            return;
+        }
+        if (replyLength != sizeof(uint32_t))
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            return;
+        }
+        if((t_Error)reply.error != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Free KG clsPlan failed"));
+            return;
+        }
+    }
+}
+
+t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                j, schemesPerPortVector = 0;
+    t_FmPcdKgScheme         *p_Scheme;
+    uint8_t                 i, relativeSchemeId;
+    uint32_t                tmp, walking1Mask;
+    uint8_t                 swPortIndex = 0;
 
-    if (p_FmPcd->h_Hc)
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    /* for each scheme */
+    for(i = 0; i<p_BindPort->numOfSchemes; i++)
     {
-        err = FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
-        return err;
-    }
+        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
+        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+            RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
-    WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
-    tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
-    err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+        if(add)
+        {
+            p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+            if (!FmPcdKgIsSchemeValidSw(p_Scheme))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
+            /* check netEnvId  of the port against the scheme netEnvId */
+            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
 
-    return err;
-}
+            /* if next engine is private port policer profile, we need to check that it is valid */
+            HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
+            if(p_Scheme->nextRelativePlcrProfile)
+            {
+                for(j = 0;j<p_Scheme->numOfProfiles;j++)
+                {
+                    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
+                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
+                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
+                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
+                }
+            }
+            if(!p_BindPort->useClsPlan)
+            {
+                /* This check may be redundant as port is a assigned to the whole NetEnv */
 
-static void FmPcdKgUnbindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
-{
-    KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-}
+                /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
+                cls plan options. Schemes that are used only directly, should not be checked.
+                it also may not be bound to schemes that go to CC with units that are options  - so we OR
+                the match vector and the grpBits (= ccUnits) */
+                if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
+                {
+                    walking1Mask = 0x80000000;
+                    tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
+                    tmp |= p_Scheme->ccUnits;
+                    while (tmp)
+                    {
+                        if(tmp & walking1Mask)
+                        {
+                            tmp &= ~walking1Mask;
+                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
+                        }
+                        walking1Mask >>= 1;
+                    }
+                }
+            }
+        }
+        /* build vector */
+        schemesPerPortVector |= 1 << (31 - p_BindPort->schemesIds[i]);
+    }
 
-static t_Error KgBindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId)
-{
-    uint32_t                tmpKgpeCpp = 0;
+    *p_SpReg = schemesPerPortVector;
 
-    tmpKgpeCpp = FmPcdKgBuildCppReg(p_FmPcd, clsPlanGrpId);
-    return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
+    return E_OK;
 }
 
-
-/*****************************************************************************/
-/*              Inter-module API routines                                    */
-/*****************************************************************************/
 t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1095,18 +1309,18 @@ t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPort
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    FmPcdKgIncSchemeOwners(h_FmPcd, p_SchemeBind);
+    IncSchemeOwners(p_FmPcd, p_SchemeBind);
 
     return E_OK;
 }
 
-t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
+t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                spReg;
     t_Error                 err = E_OK;
 
-    err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, FALSE);
+    err = FmPcdKgBuildBindPortToSchemes(p_FmPcd, p_SchemeBind, &spReg, FALSE);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1114,40 +1328,40 @@ t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindP
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    FmPcdKgDecSchemeOwners(h_FmPcd, p_SchemeBind);
+    DecSchemeOwners(p_FmPcd, p_SchemeBind);
 
     return E_OK;
 }
 
-bool     FmPcdKgIsSchemeValidSw(t_Handle h_Scheme)
+bool FmPcdKgIsSchemeValidSw(t_Handle h_Scheme)
 {
     t_FmPcdKgScheme     *p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
 
     return p_Scheme->valid;
 }
 
-bool     KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
+bool KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
     if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
         return TRUE;
-    else{
-	XX_Print("\n\n p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector = 0x%X \n", p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector);
-	XX_Print(" schemeId = %u \n\n", schemeId);
-	dump_stack();
-        return FALSE;}
+    else
+        return FALSE;
 }
 
 t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint8_t             i,j;
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint8_t             i, j;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    for(j=0,i=0;i<FM_PCD_KG_NUM_OF_SCHEMES && j<numOfSchemes;i++)
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
+
+    for (j = 0, i = 0; i < FM_PCD_KG_NUM_OF_SCHEMES && j < numOfSchemes; i++)
     {
         if(!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
         {
@@ -1167,6 +1381,7 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
             p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].ownerId = 0;
             p_SchemesIds[j] = 0;
         }
+
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("No schemes found"));
     }
 
@@ -1175,18 +1390,25 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
 
 t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint8_t             i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    for(i=0;i<numOfSchemes;i++)
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC */
+
+    for (i = 0; i < numOfSchemes; i++)
     {
         if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
+        {
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
+        }
         if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
+        {
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
+        }
         p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
         p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
     }
@@ -1196,12 +1418,12 @@ t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gues
 
 t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t *p_First)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint8_t     numOfBlocks, blocksFound=0, first=0;
     uint8_t     i, j;
 
-
-    /* This routine is protected by the calling routine ! */
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
 
     if(!numOfClsPlanEntries)
         return E_OK;
@@ -1213,257 +1435,109 @@ t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, u
 
     /* try to find consequent blocks */
     first = 0;
-    for(i=0;i<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
+    for (i = 0; i < FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
     {
         if(!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
         {
             blocksFound++;
-            i++;
-            if(blocksFound == numOfBlocks)
-                break;
-        }
-        else
-        {
-            blocksFound = 0;
-            /* advance i to the next aligned address */
-            first = i = (uint8_t)(first + numOfBlocks);
-        }
-    }
-
-    if(blocksFound == numOfBlocks)
-    {
-        *p_First = (uint8_t)(first*CLS_PLAN_NUM_PER_GRP);
-        for(j = first; j<first + numOfBlocks; j++)
-        {
-            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
-            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = guestId;
-        }
-
-        return E_OK;
-    }
-    else
-        RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
-}
-
-void  KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t base)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint8_t     numOfBlocks;
-    uint8_t     i, baseBlock;
-
-    UNUSED( guestId);
-
-    /* This routine is protected by the calling routine ! */
-
-    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
-    ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
-
-    baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
-    for(i=baseBlock;i<baseBlock+numOfBlocks;i++)
-    {
-        ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
-        ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
-        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
-        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
-    }
-}
-
-void KgEnable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
-}
-
-void KgDisable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
-}
-
-void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg=0;
-    uint16_t                i, j;
-
-    /* This routine is protected by the calling routine ! */
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
-
-    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
-    {
-        tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
-
-        for (j = i; j < i+8; j++)
-        {
-            ASSERT_COND(IN_RANGE(0, (j - p_Set->baseEntry), FM_PCD_MAX_NUM_OF_CLS_PLANS-1));
-            WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
-        }
-
-        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("WriteKgarWait FAILED"));
-            return;
-        }
-    }
-}
-
-static void PcdKgErrorException(t_Handle h_FmPcd)
-{
-    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    uint32_t                event, force, schemeIndexes = 0,index = 0, mask = 0;
-
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    event = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer);
-    mask = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
-
-    schemeIndexes = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer);
-    schemeIndexes &= GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseeer);
-
-    event &= mask;
-
-    /* clear the forced events */
-    force = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer);
-    if(force & event)
-        WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, force & ~event);
-
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
-    WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
-
-    if(event & FM_PCD_KG_DOUBLE_ECC)
-        p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
-    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
-    {
-        if(schemeIndexes)
-        {
-            while(schemeIndexes)
-            {
-                if(schemeIndexes & 0x1)
-                    p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
-                schemeIndexes >>= 1;
-                index+=1;
-            }
-        }
-        else /* this should happen only when interrupt is forced. */
-            p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW);
-    }
-}
-
-static t_Error KgInitGuest(t_FmPcd *p_FmPcd)
-{
-    t_Error                     err = E_OK;
-    t_FmPcdIpcKgSchemesParams   kgAlloc;
-    uint32_t                    replyLength;
-    t_FmPcdIpcReply             reply;
-    t_FmPcdIpcMsg               msg;
-
-    ASSERT_COND(p_FmPcd->guestId != NCSW_MASTER_ID);
-
-    /* in GUEST_PARTITION, we use the IPC  */
-    memset(&reply, 0, sizeof(reply));
-    memset(&msg, 0, sizeof(msg));
-    memset(&kgAlloc, 0, sizeof(t_FmPcdIpcKgSchemesParams));
-    kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
-    kgAlloc.guestId = p_FmPcd->guestId;
-    msg.msgId = FM_PCD_ALLOC_KG_SCHEMES;
-    memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
-    replyLength = sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t);
-    if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId) + sizeof(kgAlloc),
-                                 (uint8_t*)&reply,
-                                 &replyLength,
-                                 NULL,
-                                 NULL)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    if(replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-    memcpy(p_FmPcd->p_FmPcdKg->schemesIds, (uint8_t*)(reply.replyBody),p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t));
+            i++;
+            if (blocksFound == numOfBlocks)
+                break;
+        }
+        else
+        {
+            blocksFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfBlocks);
+        }
+    }
 
-    return (t_Error)reply.error;
+    if (blocksFound == numOfBlocks)
+    {
+        *p_First = (uint8_t)(first * CLS_PLAN_NUM_PER_GRP);
+        for (j = first; j < (first + numOfBlocks); j++)
+        {
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
+            p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = guestId;
+        }
+        return E_OK;
+    }
+    else
+        RETURN_ERROR(MINOR, E_FULL, ("No resources for clsPlan"));
 }
 
-static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
+void KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t base)
 {
-    t_Error                     err = E_OK;
-    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-    int                         i;
-    uint8_t                     hardwarePortId = 0;
-    uint32_t                    tmpReg;
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint8_t     numOfBlocks;
+    uint8_t     i, baseBlock;
 
-    ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
+#ifdef DISABLE_ASSERTIONS
+UNUSED(guestId);
+#endif /* DISABLE_ASSERTIONS */
 
-    /**********************KGEER******************/
-    WRITE_UINT32(p_Regs->kgeer, (FM_PCD_KG_DOUBLE_ECC | FM_PCD_KG_KEYSIZE_OVERFLOW));
-    /**********************KGEER******************/
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
 
-    /**********************KGEEER******************/
-    tmpReg = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+    numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
+    ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
+
+    baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
+    for(i=baseBlock;i<baseBlock+numOfBlocks;i++)
     {
-        FmEnableRamsEcc(p_FmPcd->h_Fm);
-        tmpReg |= FM_PCD_KG_DOUBLE_ECC;
+        ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
+        ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
+        p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
     }
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
-        tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
-    WRITE_UINT32(p_Regs->kgeeer,tmpReg);
-    /**********************KGEEER******************/
-
-    /**********************KGFDOR******************/
-    WRITE_UINT32(p_Regs->kgfdor,0);
-    /**********************KGFDOR******************/
-
-    /**********************KGGDV0R******************/
-    WRITE_UINT32(p_Regs->kggdv0r,0);
-    /**********************KGGDV0R******************/
+}
 
-    /**********************KGGDV1R******************/
-    WRITE_UINT32(p_Regs->kggdv1r,0);
-    /**********************KGGDV1R******************/
+void KgEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    /**********************KGGCR******************/
-    WRITE_UINT32(p_Regs->kggcr, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd));
-    /**********************KGGCR******************/
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
+}
 
-    /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR, PcdKgErrorException, p_FmPcd);
+void KgDisable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    /* clear binding between ports to schemes so that all ports are not bound to any schemes */
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-    {
-        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
+}
 
-        err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
+    uint32_t                tmpKgarReg = 0, intFlags;
+    uint16_t                i, j;
 
-        err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    /* This routine is protected by the calling routine ! */
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
 
-    /* enable and enable all scheme interrupts */
-    WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
-    WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    {
+        tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
 
+        for (j = i; j < i+8; j++)
+        {
+            ASSERT_COND(IN_RANGE(0, (j - p_Set->baseEntry), FM_PCD_MAX_NUM_OF_CLS_PLANS-1));
+            WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
+        }
 
-    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
-    {
-        err = FmPcdKgAllocSchemes(p_FmPcd,
-                                  p_FmPcd->p_FmPcdKg->numOfSchemes,
-                                  p_FmPcd->guestId,
-                                  p_FmPcd->p_FmPcdKg->schemesIds);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("WriteKgarWait FAILED"));
+            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+            return;
+        }
     }
-
-    return E_OK;
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 }
 
 t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
@@ -1513,11 +1587,6 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     if (!p_FmPcd->p_FmPcdKg->h_HwSpinlock)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM KG HW spinlock"));
 
-    p_FmPcd->p_FmPcdKg->h_SwSpinlock = XX_InitSpinlock();
-    if (!p_FmPcd->p_FmPcdKg->h_SwSpinlock)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM KG SW spinlock"));
-
-
     if (p_FmPcd->guestId == NCSW_MASTER_ID)
         err =  KgInitMaster(p_FmPcd);
     else
@@ -1527,8 +1596,6 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     {
         if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
             XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
-        if (p_FmPcd->p_FmPcdKg->h_SwSpinlock)
-            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_SwSpinlock);
     }
 
     return err;
@@ -1555,9 +1622,6 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
 
         if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
             XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
-        if (p_FmPcd->p_FmPcdKg->h_SwSpinlock)
-            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_SwSpinlock);
-
 
         return E_OK;
     }
@@ -1585,8 +1649,6 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
 
     if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
         XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
-    if (p_FmPcd->p_FmPcdKg->h_SwSpinlock)
-        XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_SwSpinlock);
 
     return (t_Error)reply.error;
 }
@@ -1598,7 +1660,9 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     t_FmPcdKgClsPlanGrp                     *p_ClsPlanGrp;
     t_FmPcdKgInterModuleClsPlanSet          *p_ClsPlanSet;
     t_Error                                 err;
-    uint32_t                                intFlags;
+
+    /* This function is issued only from FM_PORT_SetPcd which locked all PCD modules,
+       so no need for lock here */
 
     memset(&grpParams, 0, sizeof(grpParams));
     grpParams.clsPlanGrpId = ILLEGAL_CLS_PLAN;
@@ -1606,8 +1670,6 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
 
     p_GrpParams->netEnvId = netEnvId;
 
-    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
-
     /* Get from the NetEnv the information of the clsPlan (can be already created,
      * or needs to build) */
     err = PcdGetClsPlanGrpParams(h_FmPcd, p_GrpParams);
@@ -1617,7 +1679,6 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     if(p_GrpParams->grpExists)
     {
         /* this group was already updated (at least) in SW */
-        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
     }
     else
@@ -1628,7 +1689,6 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
         memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
         /* Build (in SW) the clsPlan parameters, including the vectors to be written to HW */
         err = FmPcdKgBuildClsPlanGrp(h_FmPcd, p_GrpParams, p_ClsPlanSet);
-        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         if (err)
         {
             XX_Free(p_ClsPlanSet);
@@ -1636,15 +1696,12 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
         }
         *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
 
-        intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-
         if (p_FmPcd->h_Hc)
         {
             /* write clsPlan entries to memory */
             err = FmHcPcdKgSetClsPlan(p_FmPcd->h_Hc, p_ClsPlanSet);
             if (err)
             {
-                KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                 XX_Free(p_ClsPlanSet);
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
@@ -1653,8 +1710,6 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
             /* write clsPlan entries to memory */
             KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
 
-        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-
         XX_Free(p_ClsPlanSet);
     }
 
@@ -1668,18 +1723,14 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
 
     p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId];
 
-
-    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
    /* increment owners number */
     p_ClsPlanGrp->owners++;
-    KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-
 
     /* copy options array for port */
     memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId].optArray, FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)*sizeof(protocolOpt_t));
 
     /* bind port to the new or existing group */
-    err = KgBindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
+    err = BindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
     if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
@@ -1691,26 +1742,22 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
     t_FmPcdKgInterModuleClsPlanSet  *p_ClsPlanSet;
-    uint32_t                        intFlags;
     t_Error                         err;
 
-    FmPcdKgUnbindPortToClsPlanGrp(p_FmPcd, hardwarePortId);
+    /* This function is issued only from FM_PORT_DeletePcd which locked all PCD modules,
+       so no need for lock here */
+
+    UnbindPortToClsPlanGrp(p_FmPcd, hardwarePortId);
 
-    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
     /* decrement owners number */
     ASSERT_COND(p_ClsPlanGrp->owners);
     p_ClsPlanGrp->owners--;
-    KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
-
 
-    if(!p_ClsPlanGrp->owners)
+    if (!p_ClsPlanGrp->owners)
     {
-        intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-
         if (p_FmPcd->h_Hc)
         {
             err = FmHcPcdKgDeleteClsPlan(p_FmPcd->h_Hc, clsPlanGrpId);
-            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
             return err;
         }
         else
@@ -1719,7 +1766,6 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
             p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
             if (!p_ClsPlanSet)
             {
-                KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
             }
             memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
@@ -1727,10 +1773,8 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
             p_ClsPlanSet->baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry;
             p_ClsPlanSet->numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp;
             KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
-            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
             XX_Free(p_ClsPlanSet);
 
-            /* protection for this routine is inside it */
             FmPcdKgDestroyClsPlanGrp(h_FmPcd, clsPlanGrpId);
        }
     }
@@ -1739,7 +1783,7 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
 
 t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs)
 {
-	t_FmPcdKgScheme 					*p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
+    t_FmPcdKgScheme                     *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
     t_FmPcd                             *p_FmPcd = (t_FmPcd *)(p_Scheme->h_FmPcd);
     uint32_t                            grpBits = 0;
     uint8_t                             grpBase;
@@ -1984,7 +2028,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemePa
 
     p_SchemeRegs->kgse_mv = p_Scheme->matchVector;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if (p_SchemeParams->overrideStorageProfile)
     {
         p_SchemeRegs->kgse_om |= KG_SCH_OM_VSPE;
@@ -2020,7 +2064,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemePa
     }
     else
         p_SchemeRegs->kgse_vsp = KG_SCH_VSP_NO_KSP_EN;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     if(p_SchemeParams->useHash)
     {
@@ -2542,31 +2586,6 @@ t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemePa
     return E_OK;
 }
 
-static void  FmPcdKgValidateSchemeSw(t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
-    uint32_t        intFlags;
-
-    ASSERT_COND(!p_Scheme->valid);
-    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
-        FmPcdIncNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
-    intFlags = KgSchemeLock(p_Scheme);
-    p_Scheme->valid = TRUE;
-    KgSchemeUnlock(p_Scheme, intFlags);
-}
-
-static void  FmPcdKgInvalidateSchemeSw(t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
-    uint32_t        intFlags;
-
-    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
-        FmPcdDecNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
-    intFlags = KgSchemeLock(p_Scheme);
-    p_Scheme->valid = FALSE;
-    KgSchemeUnlock(p_Scheme, intFlags);
-}
-
 uint32_t FmPcdKgGetRequiredAction(t_Handle h_FmPcd, uint8_t schemeId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -2603,7 +2622,6 @@ uint16_t FmPcdKgGetRelativeProfileId(t_Handle h_FmPcd, uint8_t schemeId)
     return p_FmPcd->p_FmPcdKg->schemes[schemeId].relativeProfileId;
 }
 
-
 bool FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -2618,18 +2636,6 @@ bool FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId)
         return FALSE;
 
 }
-void FmPcdKgUpatePointedOwner(t_Handle h_Scheme, bool add)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
-
-    /* this routine is locked by the calling routine */
-   ASSERT_COND(p_Scheme->valid);
-
-    if(add)
-        p_Scheme->pointedOwners++;
-    else
-        p_Scheme->pointedOwners--;
-}
 
 e_FmPcdEngine FmPcdKgGetNextEngine(t_Handle h_FmPcd, uint8_t relativeSchemeId)
 {
@@ -2653,40 +2659,13 @@ void FmPcdKgUpdateRequiredAction(t_Handle h_Scheme, uint32_t requiredAction)
 {
     t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-	/* this routine is protected by calling routine */
+    /* this routine is protected by calling routine */
 
     ASSERT_COND(p_Scheme->valid);
 
     p_Scheme->requiredAction |= requiredAction;
 }
 
-t_Error FmPcdKgCheckInvalidateSchemeSw(t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
-    uint32_t        intFlags;
-
-    intFlags = KgSchemeLock(p_Scheme);
-   /* check that no port is bound to this scheme */
-    if (p_Scheme->owners)
-       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
-    if (!p_Scheme->valid){dump_stack();
-       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete an invalid scheme"));
-    }
-    KgSchemeUnlock(p_Scheme, intFlags);
-
-    return E_OK;
-}
-
-uint32_t FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t    tmpKgpeCpp;
-
-    tmpKgpeCpp = (uint32_t)(p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry / 8);
-    tmpKgpeCpp |= (uint32_t)(((p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp / 8) - 1) << FM_PCD_KG_PE_CPP_MASK_SHIFT);
-    return tmpKgpeCpp;
-}
-
 bool FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg)
 {
     return (bool)!!(schemeModeReg & KG_SCH_MODE_EN);
@@ -2727,21 +2706,6 @@ uint32_t FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId)
      */
 }
 
-uint32_t FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId)
-{
-    return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                      FM_PCD_KG_KGAR_READ |
-                      FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
-                      DUMMY_PORT_ID |
-                      ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
-                      FM_PCD_KG_KGAR_WSEL_MASK);
-
-
-    /* if we ever want to write 1 by 1, use:
-       sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));
-     */
-}
-
 uint32_t FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId)
 {
 
@@ -2786,31 +2750,20 @@ uint16_t FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp)
     return p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrp].sizeOfGrp;
 }
 
-uint8_t FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint8_t     i;
-
-    for(i=0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
-        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeHwId)
-            return i;
-    ASSERT_COND(i!=p_FmPcd->p_FmPcdKg->numOfSchemes);
-    return FM_PCD_KG_NUM_OF_SCHEMES;
-}
 
-uint8_t	FmPcdKgGetSchemeId(t_Handle h_Scheme)
+uint8_t FmPcdKgGetSchemeId(t_Handle h_Scheme)
 {
     return ((t_FmPcdKgScheme*)h_Scheme)->schemeId;
 
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 bool FmPcdKgGetVspe(t_Handle h_Scheme)
 {
     return ((t_FmPcdKgScheme*)h_Scheme)->vspe;
 
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
 {
@@ -2833,28 +2786,23 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
     uint8_t             relativeSchemeId, physicalSchemeId;
     uint32_t            tmpKgarReg, tmpReg32 = 0, intFlags;
     t_Error             err;
-    t_FmPcdKgScheme		*p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
+    t_FmPcdKgScheme     *p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
 
-    /* if (FmPcdKgSchemeTryLock(p_FmPcd, &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]))
-        RETURN_ERROR(MAJOR, E_BUSY, ("Lock of the scheme FAILED")); */
+    /* Calling function locked all PCD modules, so no need to lock here */
+
     if (!FmPcdKgIsSchemeValidSw(h_Scheme))
         RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
 
-    intFlags = KgSchemeLock(h_Scheme);
-
     if (p_FmPcd->h_Hc)
     {
         err = FmHcPcdKgCcGetSetParams(p_FmPcd->h_Hc, h_Scheme, requiredAction, value);
 
-        FmPcdKgUpatePointedOwner(h_Scheme,TRUE);
+        UpateSchemePointedOwner(h_Scheme,TRUE);
         FmPcdKgUpdateRequiredAction(h_Scheme,requiredAction);
-
-        KgSchemeUnlock(h_Scheme, intFlags);
-        /* FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]); */
         return err;
     }
 
@@ -2867,7 +2815,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
     if (!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners ||
         !(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction & requiredAction))
     {
-        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        if (requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
             switch(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine)
             {
@@ -2892,15 +2840,11 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile) ||
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile)
                         {
-                            KgSchemeUnlock(h_Scheme, intFlags);
-                            /*FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]);*/
                             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
                         }
                         err = FmPcdPlcrCcGetSetParams(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId, requiredAction);
                         if(err)
                         {
-                            KgSchemeUnlock(h_Scheme, intFlags);
-                            /*FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]);*/
                             RETURN_ERROR(MAJOR, err, NO_MSG);
                         }
                break;
@@ -2952,31 +2896,14 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
         }
     }
 
-    FmPcdKgUpatePointedOwner(h_Scheme, TRUE);
+    UpateSchemePointedOwner(h_Scheme, TRUE);
     FmPcdKgUpdateRequiredAction(h_Scheme, requiredAction);
 
-    /* FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]); */
-    KgSchemeUnlock(h_Scheme, intFlags);
-
     return E_OK;
 }
-/*
-t_Error FmPcdKgSchemeTryLock(t_Handle h_FmPcd, t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-    if (TRY_LOCK(((t_FmPcd *)h_FmPcd)->p_FmPcdKg->h_SwSpinlock, &p_Scheme->lock))
-        return E_OK;
-    return ERROR_CODE(E_BUSY);
-}
 
-void FmPcdKgReleaseSchemeLock(t_Handle h_Scheme)
-{
-    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-    RELEASE_LOCK(p_Scheme->lock);
-}
-*/
 /*********************** End of inter-module routines ************************/
 
 
@@ -2993,22 +2920,38 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     uint32_t                            tmpKgarReg;
     uint32_t                            intFlags;
     uint8_t                             physicalSchemeId, relativeSchemeId = 0;
-    t_FmPcdKgScheme						*p_Scheme;
+    t_FmPcdKgScheme                     *p_Scheme;
 
-    if(p_SchemeParams->modify)
+    if (p_SchemeParams->modify)
     {
-	p_Scheme = (t_FmPcdKgScheme *)p_SchemeParams->id.h_Scheme;
-	p_FmPcd = p_Scheme->h_FmPcd;
+        p_Scheme = (t_FmPcdKgScheme *)p_SchemeParams->id.h_Scheme;
+        p_FmPcd = p_Scheme->h_FmPcd;
 
-	SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+        SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
         SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+
+        if (!FmPcdKgIsSchemeValidSw(p_Scheme))
+        {
+            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
+                         ("Scheme is invalid"));
+            return NULL;
+        }
+
+        if (!KgSchemeFlagTryLock(p_Scheme))
+        {
+		DBG(TRACE, ("Scheme Try Lock - BUSY"));
+            /* Signal to caller BUSY condition */
+            p_SchemeParams->id.h_Scheme = NULL;
+            return NULL;
+        }
     }
     else
     {
-	p_FmPcd = (t_FmPcd*)h_FmPcd;
+        p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-	SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+        SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
         SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+
         relativeSchemeId = p_SchemeParams->id.relativeSchemeId;
         /* check that schemeId is in range */
         if(relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
@@ -3021,49 +2964,46 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
         if(FmPcdKgIsSchemeValidSw(p_Scheme))
         {
             REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
-                         ("Scheme %d is already used", relativeSchemeId));
+                         ("Scheme is already used"));
             return NULL;
         }
 
-	p_Scheme->schemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
-	p_Scheme->h_FmPcd = p_FmPcd;
-    }
-
-/*
-    err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
-    if (err)
-        return NULL;
-*/
+        p_Scheme->schemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
+        p_Scheme->h_FmPcd = p_FmPcd;
 
-    p_Scheme->h_Spinlock = XX_InitSpinlock();
-    if (!p_Scheme->h_Spinlock)
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM KG Scheme spinlock"));
+        p_Scheme->p_Lock = FmPcdAcquireLock(p_FmPcd);
+        if (!p_Scheme->p_Lock)
+            REPORT_ERROR(MAJOR, E_NOT_AVAILABLE, ("FM KG Scheme lock obj!"));
+    }
 
     if (p_FmPcd->h_Hc)
     {
         err = FmHcPcdKgSetScheme(p_FmPcd->h_Hc, (t_Handle)p_Scheme, p_SchemeParams);
-        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
+        if(p_SchemeParams->modify)
+            KgSchemeFlagUnlock(p_Scheme);
         if (err)
         {
-          if (p_Scheme->h_Spinlock)
-              XX_FreeSpinlock(p_Scheme->h_Spinlock);
-          return NULL;
+            if (!p_SchemeParams->modify &&
+                p_Scheme->p_Lock)
+                FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
+            return NULL;
         }
-		if (!p_SchemeParams->modify)
-			FmPcdKgValidateSchemeSw(p_Scheme);
+        if (!p_SchemeParams->modify)
+            ValidateSchemeSw(p_Scheme);
         return (t_Handle)p_Scheme;
     }
 
     physicalSchemeId = p_Scheme->schemeId;
 
-
     err = FmPcdKgBuildScheme((t_Handle)p_Scheme, p_SchemeParams, &schemeRegs);
-    if(err)
+    if (err)
     {
         REPORT_ERROR(MAJOR, err, NO_MSG);
-        /*FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]);*/
-        if (p_Scheme->h_Spinlock)
-            XX_FreeSpinlock(p_Scheme->h_Spinlock);
+        if(p_SchemeParams->modify)
+            KgSchemeFlagUnlock(p_Scheme);
+        if (!p_SchemeParams->modify &&
+            p_Scheme->p_Lock)
+            FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
         return NULL;
     }
 
@@ -3095,16 +3035,16 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
     if (!p_SchemeParams->modify)
-		FmPcdKgValidateSchemeSw(p_Scheme);
-
-    /* FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]); */
+        ValidateSchemeSw(p_Scheme);
+    else
+        KgSchemeFlagUnlock(p_Scheme);
 
     return (t_Handle)p_Scheme;
 }
 
 t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)(((t_FmPcdKgScheme *)h_Scheme)->h_FmPcd);
+    t_FmPcd             *p_FmPcd;
     uint8_t             physicalSchemeId;
     uint32_t            tmpKgarReg, intFlags;
     t_Error             err = E_OK;
@@ -3112,27 +3052,18 @@ t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
 
     SANITY_CHECK_RETURN_ERROR(h_Scheme, E_INVALID_HANDLE);
 
-    /*
-        err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
-        if (err)
-            return NULL;
-    */
+    p_FmPcd = (t_FmPcd*)(p_Scheme->h_FmPcd);
 
     /* check that no port is bound to this scheme */
-    err = FmPcdKgCheckInvalidateSchemeSw(h_Scheme);
+    err = InvalidateSchemeSw(h_Scheme);
     if(err)
-    {
-        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
         RETURN_ERROR(MINOR, err, NO_MSG);
-    }
 
     if (p_FmPcd->h_Hc)
     {
         err = FmHcPcdKgDeleteScheme(p_FmPcd->h_Hc, h_Scheme);
-        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
-        FmPcdKgInvalidateSchemeSw(h_Scheme);
-        if (p_Scheme->h_Spinlock)
-            XX_FreeSpinlock(p_Scheme->h_Spinlock);
+        if (p_Scheme->p_Lock)
+            FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
         return err;
     }
 
@@ -3148,12 +3079,8 @@ t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
     WriteKgarWait(p_FmPcd, tmpKgarReg);
     KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
-    FmPcdKgInvalidateSchemeSw(p_Scheme);
-
-    /* FmPcdKgReleaseSchemeLock(h_Scheme); */
-
-    if (p_Scheme->h_Spinlock)
-        XX_FreeSpinlock(p_Scheme->h_Spinlock);
+    if (p_Scheme->p_Lock)
+        FmPcdReleaseLock(p_FmPcd, p_Scheme->p_Lock);
 
     return E_OK;
 }
@@ -3279,7 +3206,6 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     uint8_t             hardwarePortId = 0;
     uint32_t            tmpKgarReg, intFlags;
     t_Error             err = E_OK;
-    t_FmPcdIpcMsg       msg;
 
     DECLARE_DUMP;
 
@@ -3287,8 +3213,11 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcMsg       msg;
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_KG_DUMP_REGS;
         return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
@@ -3299,6 +3228,10 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
                                  NULL,
                                  NULL);
     }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+
     DUMP_SUBTITLE(("\n"));
     DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
 
@@ -3372,7 +3305,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
 
-        tmpKgarReg = FmPcdKgBuildReadClsPlanBlockActionReg((uint8_t)j);
+        tmpKgarReg = ReadClsPlanBlockActionReg((uint8_t)j);
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
new file mode 100644
index 0000000..6aa4dc8
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
@@ -0,0 +1,245 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_kg.h
+
+ @Description   FM KG private header
+*//***************************************************************************/
+#ifndef __FM_KG_H
+#define __FM_KG_H
+
+#include "std_ext.h"
+
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* maskes */
+#if (DPAA_VERSION >= 11)
+#define KG_SCH_VSP_SHIFT_MASK                   0x0003f000
+#define KG_SCH_OM_VSPE                          0x00000001
+#define KG_SCH_VSP_NO_KSP_EN                    0x80000000
+
+#define MAX_SP_SHIFT                            23
+#define KG_SCH_VSP_MASK_SHIFT                   12
+#define KG_SCH_VSP_SHIFT                        24
+#endif /* (DPAA_VERSION >= 11) */
+
+#define KG_SCH_PP_SHIFT_HIGH                    0x80000000
+#define KG_SCH_PP_NO_GEN                        0x10000000
+#define KG_SCH_PP_SHIFT_LOW                     0x0000F000
+#define KG_SCH_MODE_NIA_PLCR                    0x40000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_SCH_BITMASK_MASK                     0x000000FF
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_MASK                         0x00FF0000
+#define FM_PCD_KG_KGAR_ERR                      0x20000000
+#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY       0x01000000
+#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY           0x02000000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP         0x00008000
+#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP        0x00004000
+#define FM_PCD_KG_KGAR_WSEL_MASK                0x0000FF00
+#define KG_SCH_HASH_CONFIG_NO_FQID              0x80000000
+#define KG_SCH_HASH_CONFIG_SYM                  0x40000000
+
+#define FM_PCD_KG_KGAR_GO                       0x80000000
+#define FM_PCD_KG_KGAR_READ                     0x40000000
+#define FM_PCD_KG_KGAR_WRITE                    0x00000000
+#define FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY         0x00000000
+#define FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT   0x00008000
+
+
+typedef uint32_t t_KnownFieldsMasks;
+#define KG_SCH_KN_PORT_ID                   0x80000000
+#define KG_SCH_KN_MACDST                    0x40000000
+#define KG_SCH_KN_MACSRC                    0x20000000
+#define KG_SCH_KN_TCI1                      0x10000000
+#define KG_SCH_KN_TCI2                      0x08000000
+#define KG_SCH_KN_ETYPE                     0x04000000
+#define KG_SCH_KN_PPPSID                    0x02000000
+#define KG_SCH_KN_PPPID                     0x01000000
+#define KG_SCH_KN_MPLS1                     0x00800000
+#define KG_SCH_KN_MPLS2                     0x00400000
+#define KG_SCH_KN_MPLS_LAST                 0x00200000
+#define KG_SCH_KN_IPSRC1                    0x00100000
+#define KG_SCH_KN_IPDST1                    0x00080000
+#define KG_SCH_KN_PTYPE1                    0x00040000
+#define KG_SCH_KN_IPTOS_TC1                 0x00020000
+#define KG_SCH_KN_IPV6FL1                   0x00010000
+#define KG_SCH_KN_IPSRC2                    0x00008000
+#define KG_SCH_KN_IPDST2                    0x00004000
+#define KG_SCH_KN_PTYPE2                    0x00002000
+#define KG_SCH_KN_IPTOS_TC2                 0x00001000
+#define KG_SCH_KN_IPV6FL2                   0x00000800
+#define KG_SCH_KN_GREPTYPE                  0x00000400
+#define KG_SCH_KN_IPSEC_SPI                 0x00000200
+#define KG_SCH_KN_IPSEC_NH                  0x00000100
+#define KG_SCH_KN_L4PSRC                    0x00000004
+#define KG_SCH_KN_L4PDST                    0x00000002
+#define KG_SCH_KN_TFLG                      0x00000001
+
+typedef uint8_t t_GenericCodes;
+#define KG_SCH_GEN_SHIM1                       0x70
+#define KG_SCH_GEN_DEFAULT                     0x10
+#define KG_SCH_GEN_PARSE_RESULT_N_FQID         0x20
+#define KG_SCH_GEN_START_OF_FRM                0x40
+#define KG_SCH_GEN_SHIM2                       0x71
+#define KG_SCH_GEN_IP_PID_NO_V                 0x72
+#define KG_SCH_GEN_ETH                         0x03
+#define KG_SCH_GEN_ETH_NO_V                    0x73
+#define KG_SCH_GEN_SNAP                        0x04
+#define KG_SCH_GEN_SNAP_NO_V                   0x74
+#define KG_SCH_GEN_VLAN1                       0x05
+#define KG_SCH_GEN_VLAN1_NO_V                  0x75
+#define KG_SCH_GEN_VLAN2                       0x06
+#define KG_SCH_GEN_VLAN2_NO_V                  0x76
+#define KG_SCH_GEN_ETH_TYPE                    0x07
+#define KG_SCH_GEN_ETH_TYPE_NO_V               0x77
+#define KG_SCH_GEN_PPP                         0x08
+#define KG_SCH_GEN_PPP_NO_V                    0x78
+#define KG_SCH_GEN_MPLS1                       0x09
+#define KG_SCH_GEN_MPLS2                       0x19
+#define KG_SCH_GEN_MPLS3                       0x29
+#define KG_SCH_GEN_MPLS1_NO_V                  0x79
+#define KG_SCH_GEN_MPLS_LAST                   0x0a
+#define KG_SCH_GEN_MPLS_LAST_NO_V              0x7a
+#define KG_SCH_GEN_IPV4                        0x0b
+#define KG_SCH_GEN_IPV6                        0x1b
+#define KG_SCH_GEN_L3_NO_V                     0x7b
+#define KG_SCH_GEN_IPV4_TUNNELED               0x0c
+#define KG_SCH_GEN_IPV6_TUNNELED               0x1c
+#define KG_SCH_GEN_MIN_ENCAP                   0x2c
+#define KG_SCH_GEN_IP2_NO_V                    0x7c
+#define KG_SCH_GEN_GRE                         0x0d
+#define KG_SCH_GEN_GRE_NO_V                    0x7d
+#define KG_SCH_GEN_TCP                         0x0e
+#define KG_SCH_GEN_UDP                         0x1e
+#define KG_SCH_GEN_IPSEC_AH                    0x2e
+#define KG_SCH_GEN_SCTP                        0x3e
+#define KG_SCH_GEN_DCCP                        0x4e
+#define KG_SCH_GEN_IPSEC_ESP                   0x6e
+#define KG_SCH_GEN_L4_NO_V                     0x7e
+#define KG_SCH_GEN_NEXTHDR                     0x7f
+/* shifts */
+#define KG_SCH_PP_SHIFT_HIGH_SHIFT          27
+#define KG_SCH_PP_SHIFT_LOW_SHIFT           12
+#define KG_SCH_PP_MASK_SHIFT                16
+#define KG_SCH_MODE_CCOBASE_SHIFT           24
+#define KG_SCH_DEF_MAC_ADDR_SHIFT           30
+#define KG_SCH_DEF_TCI_SHIFT                28
+#define KG_SCH_DEF_ENET_TYPE_SHIFT          26
+#define KG_SCH_DEF_PPP_SESSION_ID_SHIFT     24
+#define KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT    22
+#define KG_SCH_DEF_MPLS_LABEL_SHIFT         20
+#define KG_SCH_DEF_IP_ADDR_SHIFT            18
+#define KG_SCH_DEF_PROTOCOL_TYPE_SHIFT      16
+#define KG_SCH_DEF_IP_TOS_TC_SHIFT          14
+#define KG_SCH_DEF_IPV6_FLOW_LABEL_SHIFT    12
+#define KG_SCH_DEF_IPSEC_SPI_SHIFT          10
+#define KG_SCH_DEF_L4_PORT_SHIFT            8
+#define KG_SCH_DEF_TCP_FLAG_SHIFT           6
+#define KG_SCH_HASH_CONFIG_SHIFT_SHIFT      24
+#define KG_SCH_GEN_MASK_SHIFT               16
+#define KG_SCH_GEN_HT_SHIFT                 8
+#define KG_SCH_GEN_SIZE_SHIFT               24
+#define KG_SCH_GEN_DEF_SHIFT                29
+#define FM_PCD_KG_KGAR_NUM_SHIFT            16
+
+/* others */
+#define NUM_OF_SW_DEFAULTS                  3
+#define MAX_PP_SHIFT                        23
+#define MAX_KG_SCH_SIZE                     16
+#define MASK_FOR_GENERIC_BASE_ID            0x20
+#define MAX_HASH_SHIFT                      40
+#define MAX_KG_SCH_FQID_BIT_OFFSET          31
+#define MAX_KG_SCH_PP_BIT_OFFSET            15
+#define MAX_DIST_FQID_SHIFT                 23
+
+#define GET_MASK_SEL_SHIFT(shift,i)             \
+switch(i) {                                     \
+    case(0):shift = 26;break;                   \
+    case(1):shift = 20;break;                   \
+    case(2):shift = 10;break;                   \
+    case(3):shift = 4;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_OFFSET_SHIFT(shift,i)          \
+switch(i) {                                     \
+    case(0):shift = 16;break;                   \
+    case(1):shift = 0;break;                    \
+    case(2):shift = 28;break;                   \
+    case(3):shift = 24;break;                   \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+#define GET_MASK_SHIFT(shift,i)                 \
+switch(i) {                                     \
+    case(0):shift = 24;break;                   \
+    case(1):shift = 16;break;                   \
+    case(2):shift = 8;break;                    \
+    case(3):shift = 0;break;                    \
+    default:                                    \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+}
+
+/***********************************************************************/
+/*          Keygen defines                                             */
+/***********************************************************************/
+/* Masks */
+#define FM_PCD_KG_KGGCR_EN                      0x80000000
+#define KG_SCH_GEN_VALID                        0x80000000
+#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
+#define KG_ERR_CAP                              0x80000000
+#define KG_ERR_TYPE_DOUBLE                      0x40000000
+#define KG_ERR_ADDR_MASK                        0x00000FFF
+#define FM_PCD_KG_DOUBLE_ECC                    0x80000000
+#define FM_PCD_KG_KEYSIZE_OVERFLOW              0x40000000
+#define KG_SCH_MODE_EN                          0x80000000
+
+/* shifts */
+#define FM_PCD_KG_PE_CPP_MASK_SHIFT             16
+#define FM_PCD_KG_KGAR_WSEL_SHIFT               8
+
+/* others */
+#define KG_DOUBLE_MEANING_REGS_OFFSET           0x100
+#define NO_VALIDATION                           0x70
+#define KG_ACTION_REG_TO                        1024
+#define KG_MAX_PROFILE                          255
+#define SCHEME_ALWAYS_DIRECT                    0xFFFFFFFF
+
+
+#endif /* __FM_KG_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index b6a199c..ba120f5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_manip.c
 
@@ -137,50 +138,74 @@ static uint8_t GET_UINT8_ERRATA(uint8_t *addr)
 
 static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
 {
-	uint8_t dataSize, remain, tableSize = 0;
-
-	if(p_FmPcdManipParams->u.hdr.rmv)
-		tableSize += HMCD_SIZE_RMV;
-
-	if(p_FmPcdManipParams->u.hdr.insrt)
-	{
-		remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
-		if(remain)
-			dataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
-		else
-			dataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
-		tableSize += (uint8_t)(HMCD_SIZE_INSRT + dataSize);
-	}
-	return tableSize;
+    uint8_t dataSize, remain, tableSize = 0;
+
+    if(p_FmPcdManipParams->u.hdr.rmv)
+    {
+        switch(p_FmPcdManipParams->u.hdr.rmvParams.type){
+            case(e_FM_PCD_MANIP_RMV_GENERIC):
+                /* As long as the only rmv command is the L2, no check on type is required */
+                tableSize +=  HMCD_BASIC_SIZE;
+            break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown rmvParams.type"));
+                return 0;
+        }
+    }
+
+    if(p_FmPcdManipParams->u.hdr.insrt)
+    {
+        switch(p_FmPcdManipParams->u.hdr.insrtParams.type){
+            case(e_FM_PCD_MANIP_INSRT_GENERIC):
+                remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
+                if(remain)
+                    dataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
+                else
+                    dataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
+                tableSize += (uint8_t)(HMCD_BASIC_SIZE + dataSize);
+            break;
+            default:
+                REPORT_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
+                return 0;
+        }
+    }
+
+    return tableSize;
 }
 
-static t_Error BuildHmct(t_FmPcdManipParams *p_FmPcdManipParams, uint32_t *p_HmcdTbl)
+static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-	uint32_t		*p_TmpData, *p_TmpPtr = (uint32_t *)p_HmcdTbl;
-	uint32_t		tmpReg = 0, *p_Last = NULL;
-	uint8_t			remain, i, size = 0, origSize, *p_Data = NULL;
-
-	if(p_FmPcdManipParams->u.hdr.rmv)
-	{
-	    if(p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_GENERIC)
-	    {
+    uint32_t        *p_HmcdTbl = p_Manip->p_HmcdTbl;
+    uint32_t        *p_TmpData, *p_TmpPtr = (uint32_t *)p_HmcdTbl;
+    uint32_t        tmpReg=0, *p_Last=NULL;
+    uint8_t         remain, i, size=0, origSize, *p_Data=NULL;
+
+    SANITY_CHECK_RETURN_ERROR((p_FmPcdManipParams->u.hdr.insrt ||
+                               p_FmPcdManipParams->u.hdr.rmv), E_INVALID_VALUE);
+
+    if (p_FmPcdManipParams->u.hdr.rmv)
+    {
+        if (p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_GENERIC)
+        {
             /* initialize HMCD */
             tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_RMV) << HMCD_OC_SHIFT;
             /* tmp, should be conditional */
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset << HMCD_RMV_OFFSET_SHIFT;
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size << HMCD_RMV_SIZE_SHIFT;
-	    }
-
-		WRITE_UINT32(*p_TmpPtr, tmpReg);
-		/* save a pointer to the "last" indication word */
-		p_Last = p_TmpPtr;
-		/* advance to next command */
-		p_TmpPtr += HMCD_SIZE_RMV/4;
-	}
-
-	if(p_FmPcdManipParams->u.hdr.insrt)
-	{
-        if(p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
+        }
+        else
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header remove type!"));
+
+        WRITE_UINT32(*p_TmpPtr, tmpReg);
+        /* save a pointer to the "last" indication word */
+        p_Last = p_TmpPtr;
+        /* advance to next command */
+        p_TmpPtr += HMCD_BASIC_SIZE/4;
+    }
+
+    if (p_FmPcdManipParams->u.hdr.insrt)
+    {
+        if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
         {
             /* initialize HMCD */
             if(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
@@ -193,104 +218,114 @@ static t_Error BuildHmct(t_FmPcdManipParams *p_FmPcdManipParams, uint32_t *p_Hmc
 
             size = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
             p_Data = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.p_Data;
+
+            WRITE_UINT32(*p_TmpPtr, tmpReg);
+            /* save a pointer to the "last" indication word */
+            p_Last = p_TmpPtr;
+
+            p_TmpPtr += HMCD_BASIC_SIZE/4;
+
+            /* initialize data to be inserted */
+            /* if size is not a multiple of 4, padd with 0's */
+            origSize = size;
+            remain = (uint8_t)(size % 4);
+            if (remain)
+            {
+                size += (uint8_t)(4 - remain);
+                p_TmpData = (uint32_t *)XX_Malloc(size);
+                memset((uint8_t *)p_TmpData, 0, size);
+                memcpy((uint8_t *)p_TmpData, p_Data, origSize);
+            }
+            else
+                p_TmpData = (uint32_t*)p_Data;
+
+            /* initialize data and advance pointer to next command */
+            for (i = 0; i<size/4 ; i++, p_TmpPtr++)
+                WRITE_UINT32(*p_TmpPtr, *(p_TmpData+i));
+
+            if (remain)
+                XX_Free(p_TmpData);
+
+            p_TmpPtr += HMCD_BASIC_SIZE/4;
         }
+        else
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("manip header insert type!"));
+    }
 
-        WRITE_UINT32(*(uint32_t*)p_TmpPtr, tmpReg);
-        /* save a pointer to the "last" indication word */
-        p_Last = p_TmpPtr;
 
-        p_TmpPtr += HMCD_SIZE_INSRT/4;
-
-        /* initialize data to be inserted */
-		/* if size is not a multiple of 4, padd with 0's */
-        origSize = size;
-		remain = (uint8_t)(size % 4);
-		if(remain)
-		{
-			size += (uint8_t)(4 - remain);
-			p_TmpData = (uint32_t *)XX_Malloc(size);
-			memset((uint8_t *)p_TmpData, 0, size);
-			memcpy((uint8_t *)p_TmpData, p_Data, origSize);
-		}
-		else
-			p_TmpData = (uint32_t*)p_Data;
-
-		/* initialize data and advance pointer to next command */
-		for (i = 0; i<size/4 ; i++, p_TmpPtr++)
-			WRITE_UINT32(*p_TmpPtr, *(p_TmpData+i));
-
-		if(remain)
-			XX_Free(p_TmpData);
-	}
-	/* If this node has a nextManip, and no parsing is required after it, the old table must be copied to the new table
-	   the old table and should be freed */
-	if(p_FmPcdManipParams->h_NextManip && (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
-	{
-		/* copy old table to new location */
-		memcpy((uint8_t *)p_TmpPtr, MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip));
-		/* free old table */
-		FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip));
-		/* update old manip table pointer */
-		MANIP_SET_HMCT_PTR(p_FmPcdManipParams->h_NextManip, p_TmpPtr);
-		p_TmpPtr += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
-	}
-	else
-		/* set the "last" indication on the last command of the current table */
-		WRITE_UINT32(*p_Last, GET_UINT32(*p_Last) | HMCD_LAST);
-
-	return E_OK;
+    /* If this node has a nextManip, and no parsing is required after it, the old table must be copied to the new table
+       the old table and should be freed */
+    if (p_FmPcdManipParams->h_NextManip &&
+        (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
+    {
+        /* copy old table to new location */
+        memcpy((uint8_t *)p_TmpPtr, MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip));
+        /* free old table */
+        FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip));
+        /* update old manip table pointer */
+        MANIP_SET_HMCT_PTR(p_FmPcdManipParams->h_NextManip, p_TmpPtr);
+        p_TmpPtr += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
+    }
+    else
+        /* set the "last" indication on the last command of the current table */
+        WRITE_UINT32(*p_Last, GET_UINT32(*p_Last) | HMCD_LAST);
+
+    return E_OK;
 }
 
 static t_Error CreateManipAction(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-	t_Error		err;
-	uint16_t	tmpReg;
+    t_Error     err;
+    uint16_t    tmpReg, tmpSize;
 
-	/* set Manip structure */
-	if(p_FmPcdManipParams->h_NextManip)
+    /* set Manip structure */
+    if(p_FmPcdManipParams->h_NextManip)
     {
-	if(MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
-		p_Manip->tableSize = MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip);
-	else
-		p_Manip->cascadedNext = TRUE;
-
-		p_Manip->h_NextManip = p_FmPcdManipParams->h_NextManip;
-	/* save a "prev" pointer in h_NextManip */
-		MANIP_SET_PREV(p_FmPcdManipParams->h_NextManip, p_Manip);
-	FmPcdManipUpdateOwner(p_FmPcdManipParams->h_NextManip, TRUE);
+        if(MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+            p_Manip->tableSize = MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip);
+        else
+            p_Manip->cascadedNext = TRUE;
     }
     p_Manip->dontParseAfterManip = p_FmPcdManipParams->u.hdr.dontParseAfterManip;
 
-	/* Allocate new table */
+    /* Allocate new table */
     /* calculate table size according to manip parameters */
-    p_Manip->tableSize += CalculateTableSize(p_FmPcdManipParams);
-	p_Manip->p_HmcdTbl = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->tableSize, 4);
+    tmpSize = CalculateTableSize(p_FmPcdManipParams);
+    if(tmpSize == 0)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CalculateTableSize Failed"));
+
+    p_Manip->tableSize += tmpSize;
+    p_Manip->p_HmcdTbl = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->tableSize, 4);
+    if (!p_Manip->p_HmcdTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
 
     /* Fill table */
-	err = BuildHmct(p_FmPcdManipParams, p_Manip->p_HmcdTbl);
-	if (err)
-		RETURN_ERROR(MINOR, err, NO_MSG);
-
-	/* Build HMTD (table descriptor) */
-	tmpReg = HMTD_CFG_TYPE; /* NADEN = 0 */
-	/* add parseAfterManip */
-	if (!p_Manip->dontParseAfterManip)
-		tmpReg |= HMTD_CFG_PRS_AFTER_HM;
-	if (p_FmPcdManipParams->h_NextManip && (!MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
-	{
-		/* indicate that there's another HM table descriptor */
-		tmpReg |= HMTD_CFG_NEXT_AD_EN;
-		WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
-					 (uint16_t)((XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip)) -
-							    (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
-	}
-	WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->cfg, tmpReg);
-	WRITE_UINT32(((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
-			(uint32_t)(XX_VirtToPhys(p_Manip->p_HmcdTbl) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
-
-	WRITE_UINT8(((t_Hmtd *)p_Manip->h_Ad)->opCode, HMAN_OC);
-
-	return E_OK;
+    err = BuildHmct(p_Manip, p_FmPcdManipParams);
+    if (err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* Build HMTD (table descriptor) */
+    tmpReg = HMTD_CFG_TYPE; /* NADEN = 0 */
+    /* add parseAfterManip */
+    if (!p_Manip->dontParseAfterManip)
+        tmpReg |= HMTD_CFG_PRS_AFTER_HM;
+    if (p_FmPcdManipParams->h_NextManip &&
+        !MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+    {
+        /* indicate that there's another HM table descriptor */
+        tmpReg |= HMTD_CFG_NEXT_AD_EN;
+        WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
+                     (uint16_t)((uint32_t)(PTR_TO_UINT(XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip))) -
+                                (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
+    }
+
+    WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->cfg, tmpReg);
+    WRITE_UINT32(((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
+            (uint32_t)(XX_VirtToPhys(p_Manip->p_HmcdTbl) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+
+    WRITE_UINT8(((t_Hmtd *)p_Manip->h_Ad)->opCode, HMAN_OC);
+
+    return E_OK;
 }
 
 static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
@@ -943,9 +978,9 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     *p_AutoLearnHashTblAddr = PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize));
     if(!*p_AutoLearnHashTblAddr)
     {
-	FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
-	*p_IpReassTbl = NULL;
-	RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
+        *p_IpReassTbl = NULL;
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
     IOMemSet32(UINT_TO_PTR(*p_AutoLearnHashTblAddr), 0,  autoLearnHashTblSize);
 
@@ -962,10 +997,10 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     *p_AutoLearnSetLockTblAddr = PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4));
     if(!*p_AutoLearnSetLockTblAddr)
     {
-	FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
-	*p_IpReassTbl = NULL;
-	XX_FreeSmart(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
-	*p_AutoLearnHashTblAddr = 0;
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
+        *p_IpReassTbl = NULL;
+        XX_FreeSmart(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
+        *p_AutoLearnHashTblAddr = 0;
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
     IOMemSet32(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr), 0,  (numOfSets * 4));
@@ -1031,14 +1066,18 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
             fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_SWITCH_PORT | NIA_ENG_FM_CTL;
             fmPortGetSetCcParams.setCcParams.immediateWrite = TRUE;
             if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
+                RETURN_ERROR(MINOR, err, NO_MSG);
         }
         /* set special operational mode bits: KOMV=1(valid), OVOM=0(setting one), NENQ=1, NL=1, CWD=1.
          * set the scheme NIA to BMI */
-        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd));
-        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_OPT_MODE, 0x8000001c);
-        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd));
-        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_OPT_MODE, 0x8000001c);
+        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_OPT_MODE, 0x8000001c)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        if ((err = FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_OPT_MODE, 0x8000001c)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
     if(p_Manip->ipReassmParams.h_Ipv4Scheme)
@@ -1148,7 +1187,7 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
     return E_OK;
 }
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
 static t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
 {
     t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1184,12 +1223,9 @@ static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid
     if ((err = FmHcPcdCcIpFragScratchPollCmd(p_FmPcd->h_Hc, FALSE, &fmPcdCcFragScratchPoolCmdParams)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    if (fmPcdCcFragScratchPoolCmdParams.numOfBuffers != NUM_OF_SCRATCH_POOL_BUFFERS)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Empty scratch pool failed"));
-
     return E_OK;
 }
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
 static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 {
@@ -1223,9 +1259,9 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
     {
         if (p_Manip->ipFragParams.p_Frag)
         {
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
             FmPcdFragHcScratchPoolEmpty((t_Handle)p_FmPcd, p_Manip->ipFragParams.scratchBpid);
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
         }
@@ -1235,18 +1271,18 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
         FmPcdUnregisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
 
         if(p_Manip->ipReassmParams.timeOutTblAddr)
-		FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr));
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr));
         if(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr));
 
         if(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr));
         if(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr));
         if(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr));
         if(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr)
-		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr));
+            XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr));
         if(p_Manip->ipReassmParams.p_Ipv4ReassTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv4ReassTbl);
         if(p_Manip->ipReassmParams.p_Ipv6ReassTbl)
@@ -1397,9 +1433,8 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
     return E_OK;
 }
 #else /* not FM_CAPWAP_SUPPORT */
-static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_ManipParams)
 {
-
     switch (p_ManipParams->type)
     {
         case e_FM_PCD_MANIP_HDR :
@@ -1431,6 +1466,8 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
             }
             break;
         case e_FM_PCD_MANIP_REASSEM :
+            if (p_ManipParams->h_NextManip)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with reassembly"));
             switch(p_ManipParams->u.reassem.hdr)
             {
                 case(HEADER_TYPE_IPv4):
@@ -1448,6 +1485,8 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
              }
             break;
         case e_FM_PCD_MANIP_FRAG :
+            if (p_ManipParams->h_NextManip)
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with fragmentation"));
             switch(p_ManipParams->u.frag.hdr)
             {
                 case(HEADER_TYPE_IPv4):
@@ -1474,6 +1513,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("manip type"));
     }
 
+    /* TODO - Ganit */
     if (p_Manip->owner && p_Manip->h_PrevManip)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No sharing on cascaded internal nodes"));
 
@@ -1682,11 +1722,6 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *
             case(HEADER_TYPE_USER_DEFINED_SHIM2):
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
                 break;
-            /* TODO - to take care about SHIM3
-            case(HEADER_TYPE_USER_DEFINED_SHIM3):
-                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM3_OFFSET;
-                break;
-            */
             case(HEADER_TYPE_LLC_SNAP):
                 *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
                 break;
@@ -1741,9 +1776,6 @@ static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_M
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-/* TODO - reconsider this once full HM support exists */
-    SANITY_CHECK_RETURN_ERROR((p_ManipParams->type == e_FM_PCD_MANIP_RMV_BY_HDR),E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_ManipParams->u.byHdr.type == e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START),E_INVALID_HANDLE);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
     if (p_Manip->rmv)
@@ -1784,11 +1816,6 @@ static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip, bo
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
     *(uint32_t *)&p_Ad->ccAdBase = tmpReg32;
 
-    /*TODO - update offsetInBufferPrefixForIntFrameHdr when port connected to tree
-    tmpReg32 = 0;
-    tmpReg32 |= offsetInBufferPrefixForIntFrameHdr;
-    *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;*/
-
     tmpReg32 = 0;
     tmpReg32 |= HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
     tmpReg32 |= (uint32_t)0x16 << 16;
@@ -1884,7 +1911,7 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
                                     FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
 
     if (!p_Manip->fragParams.p_AutoLearnHashTbl)
-	RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
 
     IOMemSet32(p_Manip->fragParams.p_AutoLearnHashTbl, 0,  (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
 
@@ -1928,8 +1955,6 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
 
     p_Manip->fragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
     p_Manip->fragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
-    /*TODO  - to take care about this function FmGetTimeStampScale - it return t_Error
-     now we have problems with all calls to this function*/
     p_Manip->fragParams.bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
 
     tmpReg32 = 0;
@@ -2104,18 +2129,14 @@ static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
 }
 
 static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
-                            t_FmPcdManip                *p_Manip,
-                            t_FmPcd                     *p_FmPcd)
+                            t_FmPcdManip                *p_Manip)
 {
     uint32_t                    maxSetNumber = 10000;
     t_FmPcdManipReassemIpParams reassmManipParams = p_ManipReassmParams->u.ipReassem;
     t_Error                     res;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
-#ifdef DISABLE_SANITY_CHECKS
-UNUSED(p_FmPcd);
-#endif /* DISABLE_SANITY_CHECKS */
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((t_FmPcd *)p_Manip->h_FmPcd)->h_Hc, E_INVALID_HANDLE);
 
     /* Check validation of user's parameter.*/
     if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000) ||
@@ -2145,9 +2166,6 @@ UNUSED(p_FmPcd);
     p_Manip->ipReassmParams.dataMemId = reassmManipParams.dataMemId;
     p_Manip->ipReassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
     p_Manip->ipReassmParams.sgBpid = reassmManipParams.sgBpid;
-#ifdef UNDER_CONSTRUCTION_V3_IPR
-    p_Manip->ipReassmParams.h_CouplingFmPort = reassmManipParams.h_CouplingFmPort;
-#endif /* UNDER_CONSTRUCTION_V3_IPR */
     /* Creates and initializes the IP Reassembly common parameter table */
     CreateIpReassCommonTable(p_Manip);
 
@@ -2443,14 +2461,14 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
          }
 
          tmpReg32 = tmpReg16 = tmpReg8 = 0;
-         /*TODO - check it*/
-         if(p_InsrtByTemplate->modifyOuterVlan)
+
+         if (p_InsrtByTemplate->modifyOuterVlan)
          {
-             if(p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
+             if (p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
                  RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"));
 
              memcpy(&tmpReg16, &p_Template[VLAN_TAG_FIELD_OFFSET_FROM_ETH], 2*(sizeof(uint8_t)));
-             if((tmpReg16  != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
+             if ((tmpReg16  != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
                  RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "));
 
              memcpy(&tmpReg8, &p_Template[14],1*(sizeof(uint8_t)));
@@ -2507,16 +2525,18 @@ static t_Error IpFragmentationStats(t_FmPcdManip *p_Manip, t_FmPcdManipFragIpSta
     return E_OK;
 }
 
-static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdManip *p_Manip)
 {
-    uint32_t                pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
-#if (DPAA_VERSION == 2)
-    t_Error                 err = E_OK;
-#endif /* (DPAA_VERSION == 2) */
+    uint32_t    pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
+    t_FmPcd     *p_FmPcd;
+#if (DPAA_VERSION == 10)
+    t_Error     err = E_OK;
+#endif /* (DPAA_VERSION == 10) */
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_ManipParams->sizeForFragmentation != 0xFFFF, E_INVALID_VALUE);
 
+    p_FmPcd = p_Manip->h_FmPcd;
     /* Allocation of fragmentation Action Descriptor */
     p_Manip->ipFragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                                              FM_PCD_CC_AD_ENTRY_SIZE,
@@ -2536,26 +2556,26 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,t_FmPcdMa
     /* Set Scatter/Gather BPid */
     if (p_ManipParams->sgBpidEn)
     {
-	 ccAdBaseReg 	 |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
-		 pcAndOffsetsReg |= ((p_ManipParams->sgBpid << FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET) & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
+         ccAdBaseReg     |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
+         pcAndOffsetsReg |= ((p_ManipParams->sgBpid << FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET) & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
     }
 
     /* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
     gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr)) - p_FmPcd->physicalMuramBase);
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     gmaskReg |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
     /* Set all Ad registers */
     WRITE_UINT32(p_Manip->ipFragParams.p_Frag->pcAndOffsets, pcAndOffsetsReg);
-	WRITE_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase, ccAdBaseReg);
+    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase, ccAdBaseReg);
     WRITE_UINT32(p_Manip->ipFragParams.p_Frag->gmask, gmaskReg);
 
     /* Saves user's fragmentation manipulation parameters */
     p_Manip->frag = TRUE;
     p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
 
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     p_Manip->ipFragParams.scratchBpid = p_ManipParams->scratchBpid;
 
     /* scratch buffer pool initialization */
@@ -2565,19 +2585,21 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,t_FmPcdMa
         p_Manip->ipFragParams.p_Frag = NULL;
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
     return E_OK;
 }
 
-static t_Error IPManip(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IPManip(t_FmPcdManip *p_Manip)
 {
 
     t_Error                     err = E_OK;
+    t_FmPcd                     *p_FmPcd;
     t_AdOfTypeContLookup        *p_Ad;
     uint32_t                    tmpReg32 = 0, tmpRegNia = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    p_FmPcd = p_Manip->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
@@ -2600,17 +2622,18 @@ static t_Error IPManip(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
     return err;
 }
 
-static t_Error IPSecManip(t_FmPcdManipSpecialOffloadIPSecParams *p_IPSecParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
+                          t_FmPcdManip          *p_Manip)
 {
-    t_Error                     err = E_OK;
-    t_AdOfTypeContLookup        *p_Ad;
-    uint32_t                    tmpReg32 = 0;
+    t_AdOfTypeContLookup                    *p_Ad;
+    t_FmPcdManipSpecialOffloadIPSecParams   *p_IPSecParams;
+    t_Error                                 err = E_OK;
+    uint32_t                                tmpReg32 = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
-#ifdef DISABLE_SANITY_CHECKS
-UNUSED(p_FmPcd);
-#endif /* DISABLE_SANITY_CHECKS */
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_INVALID_HANDLE);
+
+    p_IPSecParams = &p_ManipParams->u.specialOffload.u.ipsec;
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
@@ -2621,7 +2644,17 @@ UNUSED(p_FmPcd);
     tmpReg32 |= (p_IPSecParams->variableIpHdrLen)?FM_PCD_MANIP_IPSEC_VIPL_EN:0;
 
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
-    WRITE_UINT32(p_Ad->pcAndOffsets, HMAN_OC_IPSEC_MANIP);
+
+    tmpReg32 = HMAN_OC_IPSEC_MANIP;
+    if (p_ManipParams->h_NextManip)
+    {
+        WRITE_UINT32(p_Ad->matchTblPtr,
+                    (uint32_t)(XX_VirtToPhys(((t_FmPcdManip *)p_ManipParams->h_NextManip)->h_Ad)-
+                               (((t_FmPcd *)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4);
+
+        tmpReg32 |= FM_PCD_MANIP_IPSEC_NADEN;
+    }
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
     return err;
 }
@@ -2682,34 +2715,34 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
     {
         /* In Case of IP reassembly manipulation the IPv4/IPv6 reassembly action descriptor will
            be defines later on */
-		if (p_Manip->muramAllocate)
-		{
-			p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-														FM_PCD_CC_AD_ENTRY_SIZE,
-														FM_PCD_CC_AD_TABLE_ALIGN);
-			 if(!p_Manip->h_Ad)
-			 {
-				REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
-				ReleaseManipHandler(p_Manip, p_FmPcd);
-				XX_Free(p_Manip);
-				return NULL;
-			 }
-
-			IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
-		}
-		else
-		{
-			p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-			 if(!p_Manip->h_Ad)
-			 {
-				REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
-				ReleaseManipHandler(p_Manip, p_FmPcd);
-				XX_Free(p_Manip);
-				return NULL;
-			 }
-
-			memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-		}
+        if (p_Manip->muramAllocate)
+        {
+            p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                        FM_PCD_CC_AD_ENTRY_SIZE,
+                                                        FM_PCD_CC_AD_TABLE_ALIGN);
+             if(!p_Manip->h_Ad)
+             {
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+             }
+
+            IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        }
+        else
+        {
+            p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+             if(!p_Manip->h_Ad)
+             {
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+             }
+
+            memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+        }
     }
 
     p_Manip->h_FmPcd = h_FmPcd;
@@ -2849,8 +2882,8 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
             p_Manip->ownerTmp++;
             break;
         case(HMAN_OC):
-			if(( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE(p_Manip))
-				RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't share this Manip node, in is cascaded and Next Engine is CC"));
+            if(( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE(p_Manip))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't share this Manip node, in is cascaded and Next Engine is CC"));
             break;
 
         default:
@@ -2954,7 +2987,7 @@ void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_
             *p_AdNewPtr = NULL;
             break;
         case(HMAN_OC):
-		/* Allocate and initialize HMTD */
+            /* Allocate and initialize HMTD */
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
         default:
@@ -2984,17 +3017,17 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
             break;
 
         case(HMAN_OC):
-		/* Initialize HMTD within the match table*/
-			IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
-		/* copy the existing HMTD */ /* ask Alla - memcpy??? */
-		memcpy((uint8_t*)p_Ad, p_Manip->h_Ad, sizeof(t_Hmtd));
-		/* update NADEN to be "1"*/
-			WRITE_UINT16(((t_Hmtd *)p_Ad)->cfg,
-			             (uint16_t)(GET_UINT16(((t_Hmtd *)p_Ad)->cfg) | HMTD_CFG_NEXT_AD_EN));
-			/* update next action descriptor */
-			WRITE_UINT16(((t_Hmtd *)p_Ad)->nextAdIdx, (uint16_t)(adTableOffset >> 4));
-			/* mark that Manip's HMTD is not used */
-			*p_AdNewPtr = NULL;
+            /* Initialize HMTD within the match table*/
+            IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+            /* copy the existing HMTD */ /* ask Alla - memcpy??? */
+            memcpy((uint8_t*)p_Ad, p_Manip->h_Ad, sizeof(t_Hmtd));
+            /* update NADEN to be "1"*/
+            WRITE_UINT16(((t_Hmtd *)p_Ad)->cfg,
+                         (uint16_t)(GET_UINT16(((t_Hmtd *)p_Ad)->cfg) | HMTD_CFG_NEXT_AD_EN));
+            /* update next action descriptor */
+            WRITE_UINT16(((t_Hmtd *)p_Ad)->nextAdIdx, (uint16_t)(adTableOffset >> 4));
+            /* mark that Manip's HMTD is not used */
+            *p_AdNewPtr = NULL;
             break;
 
         default:
@@ -3067,15 +3100,15 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     p_Manip->type = HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
     p_Manip->muramAllocate = FALSE;
 
-	p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-	 if(!p_Manip->h_Ad)
-	 {
-		REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
-		XX_Free(p_Manip);
-		return NULL;
-	 }
+    p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+     if(!p_Manip->h_Ad)
+     {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
+        XX_Free(p_Manip);
+        return NULL;
+     }
 
-	memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
 
     /*treatFdStatusFieldsAsErrors = TRUE hardcoded - assumption its always come after CAAM*/
     /*Application specific = type of flowId index, move internal frame header from data to IC,
@@ -3121,7 +3154,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     {
         case(HMAN_OC_IP_REASSEMBLY):
             /* IpReassembly */
-            err = IpReassembly(&p_ManipParams->u.reassem, p_Manip, p_FmPcd);
+            err = IpReassembly(&p_ManipParams->u.reassem, p_Manip);
             if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -3132,7 +3165,7 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
             break;
        case(HMAN_OC_IP_FRAGMENTATION):
             /* IpFragmentation */
-            err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip, p_FmPcd);
+            err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip);
             if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -3141,10 +3174,10 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
         case(HMAN_OC_IP_MANIP) :
-            err = IPManip(p_Manip, p_FmPcd);
+            err = IPManip(p_Manip);
             break;
         case(HMAN_OC_IPSEC_MANIP) :
-            err = IPSecManip(&p_ManipParams->u.specialOffload.u.ipsec, p_Manip, p_FmPcd);
+            err = IPSecManip(p_ManipParams, p_Manip);
             break;
 #ifdef FM_CAPWAP_SUPPORT
         case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
@@ -3211,6 +3244,14 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
         return NULL;
     }
 
+    if (p_ManipParams->h_NextManip)
+    {
+        p_Manip->h_NextManip = p_ManipParams->h_NextManip;
+        /* save a "prev" pointer in h_NextManip */
+        MANIP_SET_PREV(p_Manip->h_NextManip, p_Manip);
+        FmPcdManipUpdateOwner(p_Manip->h_NextManip, TRUE);
+    }
+
     return p_Manip;
 }
 
@@ -3223,12 +3264,15 @@ t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
     if(p_Manip->owner)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
 
-	if(p_Manip->h_NextManip)
+    if(p_Manip->h_NextManip)
     {
-		MANIP_SET_PREV(p_Manip->h_NextManip, NULL);
-	FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
+        MANIP_SET_PREV(p_Manip->h_NextManip, NULL);
+        FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
     }
 
+    if(p_Manip->p_HmcdTbl)
+        FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_HmcdTbl);
+
     ReleaseManipHandler(p_Manip, p_Manip->h_FmPcd);
 
     XX_Free(h_ManipNode);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
index db16125..b07f40c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_manip.h
 
@@ -49,6 +50,8 @@
 /*          Header manipulations defines                              */
 /***********************************************************************/
 
+#define NUM_OF_SCRATCH_POOL_BUFFERS             1000 /*TODO - Change it!!*/
+
 #define HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR                      0x2e
 #define HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER              0x31
 #define HMAN_OC_CAPWAP_FRAGMENTATION                            0x33
@@ -60,7 +63,7 @@
 #define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
 #define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 /* dummy */
 #define HMAN_OC_CAPWAP_INDEXED_STATS                            0x32 /* dummy */
-#define HMAN_OC													0x35
+#define HMAN_OC                                                 0x35
 
 #define HMAN_RMV_HDR                               0x80000000
 #define HMAN_INSRT_INT_FRM_HDR                     0x40000000
@@ -112,61 +115,97 @@
 #define FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID                   24
 #define FM_PCD_MANIP_IP_FRAG_MTU_OFFSET                     16
 #define FM_PCD_MANIP_IP_FRAG_NO_FRAGMETATION                0xFFFF0000
-#define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN						0x08000000
-#define FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK					0xFF000000
-#define FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET					24
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN                     0x08000000
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK                   0xFF000000
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET                 24
 
 #define FM_PCD_MANIP_IPSEC_DEC                              0x10000000
 #define FM_PCD_MANIP_IPSEC_ECN_EN                           0x04000000
 #define FM_PCD_MANIP_IPSEC_DSCP_EN                          0x02000000
 #define FM_PCD_MANIP_IPSEC_VIPL_EN                          0x01000000
+#define FM_PCD_MANIP_IPSEC_NADEN                            0x20000000
 
 #define e_FM_MANIP_IP_INDX                                  1
 
-#define HMCD_OPCODE_GENERIC_RMV					0x01
+#define HMCD_OPCODE_GENERIC_RMV                 0x01
 #define HMCD_OPCODE_GENERIC_INSRT               0x02
 #define HMCD_OPCODE_GENERIC_REPLACE             0x05
 #define HMCD_OPCODE_L2_RMV                      0x08
 #define HMCD_OPCODE_L2_INSRT                    0x09
-
-#define HMCD_SIZE_RMV 							4
-#define HMCD_SIZE_INSRT 						4
-
-#define HMCD_LAST								0x00800000
-
-#define HMCD_OC_SHIFT							24
-
-#define HMCD_RMV_OFFSET_SHIFT					0
-#define HMCD_RMV_SIZE_SHIFT						8
-
-#define HMCD_INSRT_OFFSET_SHIFT					0
-#define HMCD_INSRT_SIZE_SHIFT					8
-
-#define	HMTD_CFG_TYPE							0x4000
-#define	HMTD_CFG_EXT_HMCT						0x0080
-#define	HMTD_CFG_PRS_AFTER_HM					0x0040
-#define	HMTD_CFG_NEXT_AD_EN						0x0020
-
-
-#define HMCD_RMV_L2_ETHERNET                   0
-#define HMCD_RMV_L2_STACKED_QTAGS              1
-#define HMCD_RMV_L2_ETHERNET_AND_MPLS          2
-#define HMCD_RMV_L2_MPLS                       3
-
-#define HMCD_INSRT_L2_MPLS                     0
-#define HMCD_INSRT_N_UPDATE_L2_MPLS            0
-
-
-#define MANIP_IS_CASCADE(h_Manip)				(((t_FmPcdManip *)h_Manip)->cascadedNext)
-#define MANIP_GET_HMCT_SIZE(h_Manip) 			(((t_FmPcdManip *)h_Manip)->tableSize)
-#define MANIP_GET_HMCT_PTR(h_Manip) 			(((t_FmPcdManip *)h_Manip)->p_HmcdTbl)
-#define MANIP_SET_HMCT_PTR(h_Manip, h_NewPtr) 	(((t_FmPcdManip *)h_Manip)->p_HmcdTbl = h_NewPtr)
-#define MANIP_GET_HMTD_PTR(h_Manip) 			(((t_FmPcdManip *)h_Manip)->h_Ad)
-#define MANIP_DONT_REPARSE(h_Manip) 			(((t_FmPcdManip *)h_Manip)->dontParseAfterManip)
-#define MANIP_SET_PREV(h_Manip, h_Prev) 		(((t_FmPcdManip *)h_Manip)->h_PrevManip = h_Prev)
-#define MANIP_GET_MURAM(h_Manip)				(((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram)
-
-
+#define HMCD_OPCODE_VLAN_PRI_UPDATE             0x0B
+#define HMCD_OPCODE_IPV4_UPDATE                 0x0C
+#define HMCD_OPCODE_IPV6_UPDATE                 0x10
+#define HMCD_OPCODE_TCP_UDP_UPDATE              0x0E
+#define HMCD_OPCODE_TCP_UDP_CHECKSUM            0x14
+#define HMCD_OPCODE_REPLACE_IP                  0x12
+
+
+#define HMCD_BASIC_SIZE                         4
+#define HMCD_PTR_SIZE                           4
+#define HMCD_PARAM_SIZE                         4
+#define HMCD_IPV4_ADDR_SIZE                     4
+#define HMCD_IPV6_ADDR_SIZE                     0x10
+
+#define HMCD_LAST                               0x00800000
+
+#define HMCD_OC_SHIFT                           24
+
+#define HMCD_RMV_OFFSET_SHIFT                   0
+#define HMCD_RMV_SIZE_SHIFT                     8
+
+#define HMCD_INSRT_OFFSET_SHIFT                 0
+#define HMCD_INSRT_SIZE_SHIFT                   8
+
+#define HMTD_CFG_TYPE                           0x4000
+#define HMTD_CFG_EXT_HMCT                       0x0080
+#define HMTD_CFG_PRS_AFTER_HM                   0x0040
+#define HMTD_CFG_NEXT_AD_EN                     0x0020
+
+#define HMCD_RMV_L2_ETHERNET                    0
+#define HMCD_RMV_L2_STACKED_QTAGS               1
+#define HMCD_RMV_L2_ETHERNET_AND_MPLS           2
+#define HMCD_RMV_L2_MPLS                        3
+
+#define HMCD_INSRT_L2_MPLS                      0
+#define HMCD_INSRT_N_UPDATE_L2_MPLS             1
+#define HMCD_INSRT_L2_SIZE_SHIFT                24
+
+#define HMCD_VLAN_PRI_REP_MODE_SHIFT            16
+#define HMCD_VLAN_PRI_UPDATE                    0
+#define HMCD_VLAN_PRI_UPDATE_DSCP_TO_VPRI       1
+
+#define HMCD_IPV4_UPDATE_TTL                    0x00000001
+#define HMCD_IPV4_UPDATE_TOS                    0x00000002
+#define HMCD_IPV4_UPDATE_DST                    0x00000020
+#define HMCD_IPV4_UPDATE_SRC                    0x00000040
+#define HMCD_IPV4_UPDATE_ID                     0x00000080
+#define HMCD_IPV4_UPDATE_TOS_SHIFT              8
+
+#define HMCD_IPV6_UPDATE_HL                     0x00000001
+#define HMCD_IPV6_UPDATE_TC                     0x00000002
+#define HMCD_IPV6_UPDATE_DST                    0x00000040
+#define HMCD_IPV6_UPDATE_SRC                    0x00000080
+#define HMCD_IPV6_UPDATE_TC_SHIFT               8
+
+#define HMCD_TCP_UDP_UPDATE_DST                 0x00004000
+#define HMCD_TCP_UDP_UPDATE_SRC                 0x00008000
+#define HMCD_TCP_UDP_UPDATE_SRC_SHIFT           16
+
+#define HMCD_IP_REPLACE_REPLACE_IPV4            0x00000000
+#define HMCD_IP_REPLACE_REPLACE_IPV6            0x00010000
+#define HMCD_IP_REPLACE_TTL_HL                  0x00200000
+#define HMCD_IP_REPLACE_ID                      0x00400000
+
+#define MANIP_IS_CASCADE(h_Manip)               (((t_FmPcdManip *)h_Manip)->cascadedNext)
+#define MANIP_GET_HMCT_SIZE(h_Manip)            (((t_FmPcdManip *)h_Manip)->tableSize)
+#define MANIP_GET_HMCT_PTR(h_Manip)             (((t_FmPcdManip *)h_Manip)->p_HmcdTbl)
+#define MANIP_SET_HMCT_PTR(h_Manip, h_NewPtr)   (((t_FmPcdManip *)h_Manip)->p_HmcdTbl = h_NewPtr)
+#define MANIP_GET_HMTD_PTR(h_Manip)             (((t_FmPcdManip *)h_Manip)->h_Ad)
+#define MANIP_DONT_REPARSE(h_Manip)             (((t_FmPcdManip *)h_Manip)->dontParseAfterManip)
+#define MANIP_SET_PREV(h_Manip, h_Prev)         (((t_FmPcdManip *)h_Manip)->h_PrevManip = h_Prev)
+#define MANIP_GET_MURAM(h_Manip)                (((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram)
+
+#define DSCP_TO_VLAN_TABLE_SIZE                 32
 /***********************************************************************/
 /*          Memory map                                                 */
 /***********************************************************************/
@@ -239,14 +278,14 @@ typedef _Packed struct t_IpReassCommonTbl {
 } _PackedType t_IpReassCommonTbl;
 
 typedef _Packed struct t_Hmtd {
-    volatile uint16_t 	cfg;
-    volatile uint8_t 	eliodnOffset;
-    volatile uint8_t 	extHmcdBasePtrHi;
-    volatile uint32_t 	hmcdBasePtr;
-    volatile uint16_t 	nextAdIdx;
-    volatile uint8_t 	res1;
-    volatile uint8_t 	opCode;
-    volatile uint32_t 	res2;
+    volatile uint16_t   cfg;
+    volatile uint8_t    eliodnOffset;
+    volatile uint8_t    extHmcdBasePtrHi;
+    volatile uint32_t   hmcdBasePtr;
+    volatile uint16_t   nextAdIdx;
+    volatile uint8_t    res1;
+    volatile uint8_t    opCode;
+    volatile uint32_t   res2;
 } _PackedType t_Hmtd;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
@@ -278,9 +317,9 @@ typedef struct
 typedef struct
 {
     t_AdOfTypeContLookup    *p_Frag;
-#if (DPAA_VERSION == 2)
-    uint8_t  	            scratchBpid;
-#endif /* (DPAA_VERSION == 2) */
+#if (DPAA_VERSION == 10)
+    uint8_t                 scratchBpid;
+#endif /* (DPAA_VERSION == 10) */
 } t_IpFragParams;
 
 typedef struct t_IpReassmParams
@@ -320,15 +359,21 @@ typedef struct t_IpReassmParams
 typedef struct{
     bool                    muramAllocate;
     t_Handle                h_Ad;
-    uint32_t			    *p_HmcdTbl;
+    uint32_t                *p_HmcdTbl;
     uint32_t                type;
     bool                    rmv;
     bool                    insrt;
-    bool				    dontParseAfterManip;
+    bool                    dontParseAfterManip;
+    bool                    fieldUpdate;
+    bool                    custom;
+    uint8_t                 *p_InsertData;
+    uint8_t                 *p_UpdateData;
+    uint8_t                 *p_CustomData1;
+    uint8_t                 *p_CustomData2;
     t_Handle                h_NextManip;
     t_Handle                h_PrevManip;
-    uint16_t			    tableSize;
-    bool				    cascadedNext;
+    uint16_t                tableSize;
+    bool                    cascadedNext;
     uint8_t                 *p_Template;
     t_Handle                h_Frag;
     bool                    frag;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index a2b031c..37ffa8d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_pcd.c
 
@@ -52,6 +53,10 @@
 #include "fm_muram_ext.h"
 
 
+/****************************************/
+/*       static functions               */
+/****************************************/
+
 static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
 {
     if(!p_FmPcd->h_Fm)
@@ -79,21 +84,21 @@ static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
 }
 
 static volatile bool blockingFlag = FALSE;
-static void FmPcdIpcMsgCompletionCB(t_Handle   h_FmPcd,
-                                    uint8_t    *p_Msg,
-                                    uint8_t    *p_Reply,
-                                    uint32_t   replyLength,
-                                    t_Error    status)
+static void IpcMsgCompletionCB(t_Handle   h_FmPcd,
+                               uint8_t    *p_Msg,
+                               uint8_t    *p_Reply,
+                               uint32_t   replyLength,
+                               t_Error    status)
 {
     UNUSED(h_FmPcd);UNUSED(p_Msg);UNUSED(p_Reply);UNUSED(replyLength);UNUSED(status);
     blockingFlag = FALSE;
 }
 
-static t_Error FmPcdHandleIpcMsgCB(t_Handle  h_FmPcd,
-                                   uint8_t   *p_Msg,
-                                   uint32_t  msgLength,
-                                   uint8_t   *p_Reply,
-                                   uint32_t  *p_ReplyLength)
+static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
+                               uint8_t   *p_Msg,
+                               uint32_t  msgLength,
+                               uint8_t   *p_Reply,
+                               uint32_t  *p_ReplyLength)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_Error             err = E_OK;
@@ -306,10 +311,6 @@ static t_Error FmPcdHandleIpcMsgCB(t_Handle  h_FmPcd,
            break;
         }
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-       case(FM_PCD_DUMP_REGS):
-            if((err = FM_PCD_DumpRegs(h_FmPcd)) != E_OK)
-                REPORT_ERROR(MINOR, err, NO_MSG);
-            break;
        case(FM_PCD_KG_DUMP_REGS):
             if((err = FM_PCD_KgDumpRegs(h_FmPcd)) != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
@@ -339,6 +340,81 @@ static t_Error FmPcdHandleIpcMsgCB(t_Handle  h_FmPcd,
     return E_OK;
 }
 
+static uint32_t NetEnvLock(t_Handle h_NetEnv)
+{
+    ASSERT_COND(h_NetEnv);
+    return XX_LockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock);
+}
+
+static void NetEnvUnlock(t_Handle h_NetEnv, uint32_t intFlags)
+{
+    ASSERT_COND(h_NetEnv);
+    XX_UnlockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock, intFlags);
+}
+
+static void EnqueueLockToFreeLst(t_FmPcd *p_FmPcd, t_FmPcdLock *p_Lock)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_LockIntrSpinlock(p_FmPcd->h_Spinlock);
+    LIST_AddToTail(&p_Lock->node, &p_FmPcd->freeLocksLst);
+    XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
+}
+
+static t_FmPcdLock * DequeueLockFromFreeLst(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdLock *p_Lock = NULL;
+    uint32_t    intFlags;
+
+    intFlags = XX_LockIntrSpinlock(p_FmPcd->h_Spinlock);
+    if (!LIST_IsEmpty(&p_FmPcd->freeLocksLst))
+    {
+        p_Lock = FM_PCD_LOCK_OBJ(p_FmPcd->freeLocksLst.p_Next);
+        LIST_DelAndInit(&p_Lock->node);
+    }
+    XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
+
+    return p_Lock;
+}
+
+static void EnqueueLockToAcquiredLst(t_FmPcd *p_FmPcd, t_FmPcdLock *p_Lock)
+{
+    uint32_t   intFlags;
+
+    intFlags = XX_LockIntrSpinlock(p_FmPcd->h_Spinlock);
+    LIST_AddToTail(&p_Lock->node, &p_FmPcd->acquiredLocksLst);
+    XX_UnlockIntrSpinlock(p_FmPcd->h_Spinlock, intFlags);
+}
+
+static t_Error FillFreeLocksLst(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdLock *p_Lock;
+    int         i;
+
+    for (i=0; i<10; i++)
+    {
+        p_Lock = (t_FmPcdLock *)XX_Malloc(sizeof(t_FmPcdLock));
+        if (!p_Lock)
+            RETURN_ERROR(MINOR, E_NO_MEMORY, ("FM-PCD lock obj!"));
+        memset(p_Lock, 0, sizeof(t_FmPcdLock));
+        INIT_LIST(&p_Lock->node);
+        p_Lock->h_Spinlock = XX_InitSpinlock();
+        if (!p_Lock->h_Spinlock)
+        {
+            XX_Free(p_Lock);
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("FM-PCD spinlock obj!"));
+        }
+        EnqueueLockToFreeLst(p_FmPcd, p_Lock);
+    }
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+
 void FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId)
 {
     ASSERT_COND(p_FmPcd);
@@ -650,18 +726,6 @@ uint8_t FmPcdGetNetEnvId(t_Handle h_NetEnv)
     return ((t_FmPcdNetEnv*)h_NetEnv)->netEnvId;
 }
 
-static uint32_t NetEnvLock(t_Handle h_NetEnv)
-{
-    ASSERT_COND(h_NetEnv);
-    return XX_LockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock);
-}
-
-static void NetEnvUnlock(t_Handle h_NetEnv, uint32_t intFlags)
-{
-    ASSERT_COND(h_NetEnv);
-    XX_UnlockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock, intFlags);
-}
-
 void FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
 {
     uint32_t    intFlags;
@@ -697,6 +761,80 @@ void FmPcdUnlock(t_Handle h_FmPcd, uint32_t intFlags)
     XX_UnlockIntrSpinlock(((t_FmPcd*)h_FmPcd)->h_Spinlock, intFlags);
 }
 
+t_FmPcdLock * FmPcdAcquireLock(t_Handle h_FmPcd)
+{
+    t_FmPcdLock *p_Lock;
+    ASSERT_COND(h_FmPcd);
+    p_Lock = DequeueLockFromFreeLst((t_FmPcd*)h_FmPcd);
+    if (!p_Lock)
+    {
+        FillFreeLocksLst(h_FmPcd);
+        p_Lock = DequeueLockFromFreeLst((t_FmPcd*)h_FmPcd);
+    }
+
+    if (p_Lock)
+        EnqueueLockToAcquiredLst((t_FmPcd*)h_FmPcd, p_Lock);
+    return p_Lock;
+}
+
+void FmPcdReleaseLock(t_Handle h_FmPcd, t_FmPcdLock *p_Lock)
+{
+    uint32_t intFlags;
+    ASSERT_COND(h_FmPcd);
+    intFlags = FmPcdLock(h_FmPcd);
+    LIST_DelAndInit(&p_Lock->node);
+    FmPcdUnlock(h_FmPcd, intFlags);
+    EnqueueLockToFreeLst((t_FmPcd*)h_FmPcd, p_Lock);
+}
+
+bool FmPcdLockTryLockAll(t_Handle h_FmPcd)
+{
+    uint32_t    intFlags;
+    t_List      *p_Pos, *p_SavedPos=NULL;
+
+    ASSERT_COND(h_FmPcd);
+    intFlags = FmPcdLock(h_FmPcd);
+    LIST_FOR_EACH(p_Pos, &((t_FmPcd*)h_FmPcd)->acquiredLocksLst)
+    {
+        t_FmPcdLock *p_Lock = FM_PCD_LOCK_OBJ(p_Pos);
+        if (!FmPcdLockTryLock(p_Lock))
+        {
+            p_SavedPos = p_Pos;
+            break;
+        }
+    }
+    if (p_SavedPos)
+    {
+        LIST_FOR_EACH(p_Pos, &((t_FmPcd*)h_FmPcd)->acquiredLocksLst)
+        {
+            t_FmPcdLock *p_Lock = FM_PCD_LOCK_OBJ(p_Pos);
+            if (p_Pos == p_SavedPos)
+                break;
+            FmPcdLockUnlock(p_Lock);
+        }
+    }
+    FmPcdUnlock(h_FmPcd, intFlags);
+
+    if (p_SavedPos)
+        return FALSE;
+    return TRUE;
+}
+
+void FmPcdLockUnlockAll(t_Handle h_FmPcd)
+{
+    uint32_t    intFlags;
+    t_List      *p_Pos;
+
+    ASSERT_COND(h_FmPcd);
+    intFlags = FmPcdLock(h_FmPcd);
+    LIST_FOR_EACH(p_Pos, &((t_FmPcd*)h_FmPcd)->acquiredLocksLst)
+    {
+        t_FmPcdLock *p_Lock = FM_PCD_LOCK_OBJ(p_Pos);
+        p_Lock->flag = FALSE;
+    }
+    FmPcdUnlock(h_FmPcd, intFlags);
+}
+
 t_Handle FmPcdGetHcHandle(t_Handle h_FmPcd)
 {
     ASSERT_COND(h_FmPcd);
@@ -709,10 +847,12 @@ bool FmPcdIsAdvancedOffloadSupported(t_Handle h_FmPcd)
     ASSERT_COND(h_FmPcd);
     return ((t_FmPcd*)h_FmPcd)->advancedOffloadSupport;
 }
+/*********************** End of inter-module routines ************************/
+
 
-/**********************************************************************************************************/
-/*              API routines                                                                              */
-/**********************************************************************************************************/
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
 
 t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
 {
@@ -807,6 +947,8 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         FM_PCD_Free(p_FmPcd);
         return NULL;
     }
+    INIT_LIST(&p_FmPcd->freeLocksLst);
+    INIT_LIST(&p_FmPcd->acquiredLocksLst);
 
     p_FmPcd->numOfEnabledGuestPartitionsPcds = 0;
 
@@ -842,10 +984,6 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
 
     if(p_FmPcd->guestId != NCSW_MASTER_ID)
     {
-        uint8_t                 isMasterAlive = 0;
-        t_FmPcdIpcReply         reply;
-        uint32_t                replyLength;
-
         memset(p_FmPcd->fmPcdIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
         if (Sprint (p_FmPcd->fmPcdIpcHandlerModuleName, "FM_PCD_%d_%d", FmGetId(p_FmPcd->h_Fm), NCSW_MASTER_ID) != 10)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
@@ -854,31 +992,35 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
 
         p_FmPcd->h_IpcSession = XX_IpcInitSession(p_FmPcd->fmPcdIpcHandlerModuleName, p_FmPcd->fmPcdModuleName);
-        if (p_FmPcd->h_IpcSession == NULL)
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("FM PCD Guest %d IPC session", p_FmPcd->guestId));
+        if (p_FmPcd->h_IpcSession)
+        {
+            t_FmPcdIpcReply         reply;
+            uint32_t                replyLength;
+            uint8_t                 isMasterAlive = 0;
 
-        memset(&msg, 0, sizeof(msg));
-        memset(&reply, 0, sizeof(reply));
-        msg.msgId = FM_PCD_MASTER_IS_ALIVE;
-        msg.msgBody[0] = p_FmPcd->guestId;
-        blockingFlag = TRUE;
+            memset(&msg, 0, sizeof(msg));
+            memset(&reply, 0, sizeof(reply));
+            msg.msgId = FM_PCD_MASTER_IS_ALIVE;
+            msg.msgBody[0] = p_FmPcd->guestId;
+            blockingFlag = TRUE;
 
-        do
-        {
-            replyLength = sizeof(uint32_t) + sizeof(isMasterAlive);
-            if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                         (uint8_t*)&msg,
-                                         sizeof(msg.msgId)+sizeof(p_FmPcd->guestId),
-                                         (uint8_t*)&reply,
-                                         &replyLength,
-                                         FmPcdIpcMsgCompletionCB,
-                                         h_FmPcd)) != E_OK)
-                REPORT_ERROR(MAJOR, err, NO_MSG);
-            while(blockingFlag) ;
-            if(replyLength != (sizeof(uint32_t) + sizeof(isMasterAlive)))
-                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-            isMasterAlive = *(uint8_t*)(reply.replyBody);
-        } while (!isMasterAlive);
+            do
+            {
+                replyLength = sizeof(uint32_t) + sizeof(isMasterAlive);
+                if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                             (uint8_t*)&msg,
+                                             sizeof(msg.msgId)+sizeof(p_FmPcd->guestId),
+                                             (uint8_t*)&reply,
+                                             &replyLength,
+                                             IpcMsgCompletionCB,
+                                             h_FmPcd)) != E_OK)
+                    REPORT_ERROR(MAJOR, err, NO_MSG);
+                while (blockingFlag) ;
+                if (replyLength != (sizeof(uint32_t) + sizeof(isMasterAlive)))
+                    REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+                isMasterAlive = *(uint8_t*)(reply.replyBody);
+            } while (!isMasterAlive);
+        }
     }
 
     CHECK_INIT_PARAMETERS(p_FmPcd, CheckFmPcdParameters);
@@ -910,7 +1052,7 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
         memset(p_FmPcd->fmPcdModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
         if(Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm),NCSW_MASTER_ID) != 10)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
-        err = XX_IpcRegisterMsgHandler(p_FmPcd->fmPcdModuleName, FmPcdHandleIpcMsgCB, p_FmPcd, FM_PCD_MAX_REPLY_SIZE);
+        err = XX_IpcRegisterMsgHandler(p_FmPcd->fmPcdModuleName, IpcMsgHandlerCB, p_FmPcd, FM_PCD_MAX_REPLY_SIZE);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
@@ -1033,28 +1175,19 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd)
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
-    {
-        if(p_FmPcd->p_FmPcdKg)
-            KgEnable(p_FmPcd);
-
-        if(p_FmPcd->p_FmPcdPlcr)
-            PlcrEnable(p_FmPcd);
-
-        if(p_FmPcd->p_FmPcdPrs)
-            PrsEnable(p_FmPcd);
+    if (p_FmPcd->enabled)
+        return E_OK;
 
-        p_FmPcd->enabled = TRUE;
-    }
-    else
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        p_FmPcd->h_IpcSession)
     {
         uint8_t         enabled;
         t_FmPcdIpcMsg   msg;
         t_FmPcdIpcReply reply;
         uint32_t        replyLength;
 
-        memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_MASTER_IS_ENABLED;
         replyLength = sizeof(uint32_t) + sizeof(enabled);
         if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
@@ -1070,7 +1203,23 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd)
         p_FmPcd->enabled = (bool)!!(*(uint8_t*)(reply.replyBody));
         if (!p_FmPcd->enabled)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM-PCD master should be enabled first!"));
+
+        return E_OK;
     }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without IPC!"));
+
+    if (p_FmPcd->p_FmPcdKg)
+        KgEnable(p_FmPcd);
+
+    if (p_FmPcd->p_FmPcdPlcr)
+        PlcrEnable(p_FmPcd);
+
+    if (p_FmPcd->p_FmPcdPrs)
+        PrsEnable(p_FmPcd);
+
+    p_FmPcd->enabled = TRUE;
 
     return E_OK;
 }
@@ -1079,47 +1228,59 @@ t_Error FM_PCD_Disable(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_Error             err = E_OK;
-    t_FmPcdIpcMsg       msg;
-    t_FmPcdIpcReply     reply;
-    uint32_t            replyLength;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    if (!p_FmPcd->enabled)
+        return E_OK;
+
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        p_FmPcd->h_IpcSession)
     {
-        if(p_FmPcd->numOfEnabledGuestPartitionsPcds != 0)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to disable a master partition PCD while guest partitions are still enabled."));
+        t_FmPcdIpcMsg       msg;
+        t_FmPcdIpcReply     reply;
+        uint32_t            replyLength;
 
-        if(p_FmPcd->p_FmPcdKg)
-             KgDisable(p_FmPcd);
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_PCD_GUEST_DISABLE;
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        if (reply.error == E_OK)
+            p_FmPcd->enabled = FALSE;
 
-        if(p_FmPcd->p_FmPcdPlcr)
-            PlcrDisable(p_FmPcd);
+        return (t_Error)(reply.error);
+    }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without IPC!"));
 
-        if(p_FmPcd->p_FmPcdPrs)
-            PrsDisable(p_FmPcd);
+    if (p_FmPcd->numOfEnabledGuestPartitionsPcds != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("Trying to disable a master partition PCD while"
+                      "guest partitions are still enabled!"));
 
-        p_FmPcd->enabled = FALSE;
+    if (p_FmPcd->p_FmPcdKg)
+         KgDisable(p_FmPcd);
 
-        return E_OK;
-    }
+    if (p_FmPcd->p_FmPcdPlcr)
+        PlcrDisable(p_FmPcd);
 
-    memset(&msg, 0, sizeof(msg));
-    msg.msgId = FM_PCD_GUEST_DISABLE;
-    memset(&reply, 0, sizeof(reply));
-    replyLength = sizeof(uint32_t);
-    if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId),
-                                 (uint8_t*)&reply,
-                                 &replyLength,
-                                 NULL,
-                                 NULL)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    if (replyLength != sizeof(uint32_t))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+    if (p_FmPcd->p_FmPcdPrs)
+        PrsDisable(p_FmPcd);
 
-    return (t_Error)(reply.error);
+    p_FmPcd->enabled = FALSE;
+
+    return E_OK;
 }
 
 t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams  *p_NetEnvParams)
@@ -1132,18 +1293,20 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     uint8_t                 ipsecAhUnit = 0,ipsecEspUnit = 0;
     bool                    ipsecAhExists = FALSE, ipsecEspExists = FALSE, shim1Selected = FALSE;
     uint8_t                 hdrNum;
+    t_FmPcdNetEnvParams     modifiedNetEnvParams;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_STATE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_NetEnvParams, E_NULL_POINTER, NULL);
 
     intFlags = FmPcdLock(p_FmPcd);
 
     /* find a new netEnv */
-    for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
-        if(!p_FmPcd->netEnvs[i].used)
+    for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
+        if (!p_FmPcd->netEnvs[i].used)
             break;
 
-    if(i== FM_MAX_NUM_OF_PORTS)
+    if (i== FM_MAX_NUM_OF_PORTS)
     {
         REPORT_ERROR(MAJOR, E_FULL,("No more than %d netEnv's allowed.", FM_MAX_NUM_OF_PORTS));
         FmPcdUnlock(p_FmPcd, intFlags);
@@ -1151,14 +1314,14 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     }
 
     p_FmPcd->netEnvs[i].used = TRUE;
-
-    if (!TRY_LOCK(NULL, &p_FmPcd->netEnvs[i].lock))
-    {
-        FmPcdUnlock(p_FmPcd, intFlags);
-        return NULL;
-    }
     FmPcdUnlock(p_FmPcd, intFlags);
 
+    /* As anyone doesn't have handle of this netEnv yet, no need
+       to protect it with spinlocks */
+
+    memcpy(&modifiedNetEnvParams, p_NetEnvParams, sizeof(t_FmPcdNetEnvParams));
+    p_NetEnvParams = &modifiedNetEnvParams;
+
     netEnvCurrId = (uint8_t)i;
 
     /* clear from previous use */
@@ -1169,28 +1332,27 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     p_FmPcd->netEnvs[netEnvCurrId].netEnvId = netEnvCurrId;
     p_FmPcd->netEnvs[netEnvCurrId].h_FmPcd = p_FmPcd;
 
-
     p_FmPcd->netEnvs[netEnvCurrId].clsPlanGrpId = ILLEGAL_CLS_PLAN;
 
     /* check that header with opt is not interchanged with the same header */
-    for (i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+    for (i = 0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
             && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
     {
-        for (k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
+        for (k = 0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
             && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
         {
             /* if an option exists, check that other headers are not the same header
             without option */
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt)
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt)
             {
-                for (j=0; (j < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
+                for (j = 0; (j < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr != HEADER_TYPE_NONE); j++)
                 {
                     if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
                         !p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].opt)
                     {
-                        REPORT_ERROR(MINOR, E_FULL, ("Illegal unit - header with opt may not be interchangeable with the same header without opt"));
-                        RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
+                        REPORT_ERROR(MINOR, E_FULL,
+                                ("Illegal unit - header with opt may not be interchangeable with the same header without opt"));
                         return NULL;
                     }
                 }
@@ -1199,23 +1361,22 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     }
 
     /* Specific headers checking  */
-    for(i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+    for (i = 0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
     {
-        for(k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
+        for (k = 0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
             && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
         {
             /* Some headers pairs may not be defined on different units as the parser
             doesn't distinguish */
             /* IPSEC_AH and IPSEC_SPI can't be 2 units,  */
             /* check that header with opt is not interchanged with the same header */
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_AH)
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_AH)
             {
                 if (ipsecEspExists && (ipsecEspUnit != i))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
-                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
-                   return NULL;
+                    return NULL;
                 }
                 else
                 {
@@ -1223,12 +1384,11 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     ipsecAhExists = TRUE;
                 }
             }
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_ESP)
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_ESP)
             {
                 if (ipsecAhExists && (ipsecAhUnit != i))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
-                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                     return NULL;
                 }
                 else
@@ -1238,7 +1398,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 }
             }
             /* ENCAP_ESP  */
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_ENCAP_ESP)
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_ENCAP_ESP)
             {
                 /* IPSec UDP encapsulation is currently set to use SHIM1 */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_UDP_ENCAP_ESP;
@@ -1247,7 +1407,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
             }
             /* IP FRAG  */
-            if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
+            if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
                 (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV4_FRAG_1))
             {
                 /* If IPv4+Frag, we need to set 2 units - SHIM 2 and IPv4. We first set SHIM2, and than check if
@@ -1267,8 +1427,8 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
                 }
             }
-            if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv6) &&
-                    (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV6_FRAG_1))
+            if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv6) &&
+                (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV6_FRAG_1))
             {
                 /* If IPv6+Frag, we need to set 2 units - SHIM 2 and IPv6. We first set SHIM2, and than check if
                  * IPv4 exists. If so we don't need to set an extra unit
@@ -1277,52 +1437,32 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv6;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV6_FRAG_1;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
 
-                for (j=0; (j < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
-                         (p_FmPcd->netEnvs[netEnvCurrId].units[j].hdrs[0].hdr != HEADER_TYPE_USER_DEFINED_SHIM2); j++) ;
-
-                if (j == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+                /* check if IPv6 header exists by itself */
+                if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
                 {
-                    p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
-                    p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
-                    /* check if IPv6 header exists by itself */
-                    if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
-                    {
-                        p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv6;
-                        p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
-                    }
-                }
-                else
-                {
-                    if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
-                    {
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = HEADER_TYPE_IPv6;
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = 0;
-                    }
-                    else
-                    {
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].hdr;
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].opt;
-                    }
+                    p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv6;
+                    p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
                 }
             }
         }
     }
 
     /* if private header (shim), check that no other headers specified */
-    for (i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+    for (i = 0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
     {
-        if(IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
-            if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
+        if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
             {
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header may not be interchanged with other headers"));
-                RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                 return NULL;
             }
     }
 
-    for(i=0; i<p_NetEnvParams->numOfDistinctionUnits;i++)
+    for (i = 0; i < p_NetEnvParams->numOfDistinctionUnits; i++)
     {
         if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
             switch(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
@@ -1331,7 +1471,6 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     if (shim1Selected)
                     {
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header cannot be selected with UDP_IPSEC_ESP"));
-                        RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                         return NULL;
                     }
                     shim1Selected = TRUE;
@@ -1355,20 +1494,19 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     /* define a set of hardware parser LCV's according to the defined netenv */
 
     /* set an array of LCV's for each header in the netEnv */
-    for (i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+    for (i = 0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
     {
         /* private headers have no LCV in the hard parser */
         if (!IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
         {
-            for (k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
+            for (k = 0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                     && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
             {
                 GET_PRS_HDR_NUM(hdrNum, p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr);
                 if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
                 {
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
-                    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                     return NULL;
                 }
                 p_FmPcd->netEnvs[netEnvCurrId].lcvs[hdrNum] |= p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
@@ -1376,8 +1514,6 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
         }
     }
 
-    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
-
     p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock = XX_InitSpinlock();
     if (!p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock)
     {
@@ -1389,35 +1525,34 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
 
 t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv)
 {
-    t_FmPcdNetEnv	*p_NetEnv = (t_FmPcdNetEnv*)h_NetEnv;
-    t_FmPcd     	*p_FmPcd = p_NetEnv->h_FmPcd;
-
-    uint8_t     netEnvId = p_NetEnv->netEnvId;
+    t_FmPcdNetEnv   *p_NetEnv = (t_FmPcdNetEnv*)h_NetEnv;
+    t_FmPcd         *p_FmPcd = p_NetEnv->h_FmPcd;
+    uint32_t        intFlags;
+    uint8_t         netEnvId = p_NetEnv->netEnvId;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if (!TRY_LOCK(p_FmPcd->h_Spinlock, &p_FmPcd->netEnvs[netEnvId].lock))
-        return ERROR_CODE(E_BUSY);
-
     /* check that no port is bound to this netEnv */
     if(p_FmPcd->netEnvs[netEnvId].owners)
     {
-       RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
-       RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
+        RETURN_ERROR(MINOR, E_INVALID_STATE,
+                ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
     }
-    p_FmPcd->netEnvs[netEnvId].used= FALSE;
+
+    intFlags = FmPcdLock(p_FmPcd);
+
+    p_FmPcd->netEnvs[netEnvId].used = FALSE;
     p_FmPcd->netEnvs[netEnvId].clsPlanGrpId = ILLEGAL_CLS_PLAN;
 
     memset(p_FmPcd->netEnvs[netEnvId].units, 0, sizeof(t_FmPcdIntDistinctionUnit)*FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
     memset(p_FmPcd->netEnvs[netEnvId].unitsVectors, 0, sizeof(uint32_t)*FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
     memset(p_FmPcd->netEnvs[netEnvId].lcvs, 0, sizeof(uint32_t)*FM_PCD_PRS_NUM_OF_HDRS);
 
-    RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
-
     if (p_FmPcd->netEnvs[netEnvId].h_Spinlock)
         XX_FreeSpinlock(p_FmPcd->netEnvs[netEnvId].h_Spinlock);
 
+    FmPcdUnlock(p_FmPcd, intFlags);
     return E_OK;
 }
 
@@ -1453,36 +1588,12 @@ t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd)
 uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                replyLength, outCounter = 0;
-    t_FmPcdIpcMsg           msg;
+    uint32_t                outCounter = 0;
     t_Error                 err;
-    t_FmPcdIpcReply         reply;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-    {
-        memset(&msg, 0, sizeof(msg));
-        memset(&reply, 0, sizeof(reply));
-        msg.msgId = FM_PCD_GET_COUNTER;
-        memcpy(msg.msgBody, (uint8_t *)&counter, sizeof(uint32_t));
-        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) +sizeof(uint32_t),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        if (replyLength != sizeof(uint32_t) + sizeof(uint32_t))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-
-        memcpy((uint8_t*)&outCounter, reply.replyBody, sizeof(uint32_t));
-        return outCounter;
-    }
-
     switch(counter)
     {
         case(e_FM_PCD_KG_COUNTERS_TOTAL):
@@ -1491,25 +1602,43 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
                 return 0;
             }
+            if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+                !p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs &&
+                !p_FmPcd->h_IpcSession)
+            {
+                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+                return 0;
+            }
             break;
+
         case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
         case(e_FM_PCD_PLCR_COUNTERS_RED):
         case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
         case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
         case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
         case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
-            if(!p_FmPcd->p_FmPcdPlcr)
+            if (!p_FmPcd->p_FmPcdPlcr)
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
                 return 0;
             }
+            if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+                !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
+                !p_FmPcd->h_IpcSession)
+            {
+                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+                return 0;
+            }
             /* check that counters are enabled */
-            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+            if (!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
                 return 0;
             }
             break;
+
         case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
         case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
         case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
@@ -1532,11 +1661,46 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this counters"));
                 return 0;
             }
+            if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+                !p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs &&
+                !p_FmPcd->h_IpcSession)
+            {
+                REPORT_ERROR(MINOR, E_NOT_SUPPORTED,
+                             ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+                return 0;
+            }
             break;
         default:
             REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
             return 0;
     }
+
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        t_FmPcdIpcMsg           msg;
+        t_FmPcdIpcReply         reply;
+        uint32_t                replyLength;
+
+        memset(&msg, 0, sizeof(msg));
+        memset(&reply, 0, sizeof(reply));
+        msg.msgId = FM_PCD_GET_COUNTER;
+        memcpy(msg.msgBody, (uint8_t *)&counter, sizeof(uint32_t));
+        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) +sizeof(uint32_t),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (replyLength != sizeof(uint32_t) + sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+
+        memcpy((uint8_t*)&outCounter, reply.replyBody, sizeof(uint32_t));
+        return outCounter;
+    }
+
     switch(counter)
     {
         case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
@@ -1600,35 +1764,24 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
 t_Error FM_PCD_DumpRegs(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcMsg       msg;
+    t_Error             err = E_OK;
 
     DECLARE_DUMP;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-    {
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_DUMP_REGS;
-        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId),
-                                 NULL,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    }
     if (p_FmPcd->p_FmPcdKg)
-        return FM_PCD_KgDumpRegs(h_FmPcd);
+        err |= FM_PCD_KgDumpRegs(h_FmPcd);
     if (p_FmPcd->p_FmPcdPlcr)
-        return FM_PCD_PlcrDumpRegs(h_FmPcd);
+        err |= FM_PCD_PlcrDumpRegs(h_FmPcd);
     if (p_FmPcd->p_FmPcdPrs)
-        return FM_PCD_PrsDumpRegs(h_FmPcd);
-    return E_OK;
+        err |= FM_PCD_PrsDumpRegs(h_FmPcd);
+
+    return err;
 }
 
-t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd)
+t_Error FM_PCD_HcDumpRegs(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 712743d..918e0a1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_pcd.h
 
@@ -42,15 +43,24 @@
 #include "error_ext.h"
 #include "list_ext.h"
 #include "fm_pcd_ext.h"
-
+#include "fm_common.h"
 
 #define __ERR_MODULE__  MODULE_FM_PCD
 
 
-/**************************************************************************//**
- @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
- @{
-*//***************************************************************************/
+/****************************/
+/* Defaults                 */
+/****************************/
+#define DEFAULT_plcrAutoRefresh                 FALSE
+#define DEFAULT_prsMaxParseCycleLimit           0
+#define DEFAULT_fmPcdKgErrorExceptions          (FM_PCD_EX_KG_DOUBLE_ECC | FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+#define DEFAULT_fmPcdPlcrErrorExceptions        (FM_PCD_EX_PLCR_DOUBLE_ECC | FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+#define DEFAULT_fmPcdPlcrExceptions             0
+#define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC)
+
+#define DEFAULT_fmPcdPrsExceptions              FM_PCD_EX_PRS_SINGLE_ECC
+#define DEFAULT_numOfUsedProfilesPerWindow      16
+#define DEFAULT_numOfSharedPlcrProfiles         4
 
 /****************************/
 /* Network defines          */
@@ -107,204 +117,25 @@ switch(exception){                                                  \
 /****************************/
 /* Parser defines           */
 /****************************/
-/* masks */
-#define PRS_ERR_CAP                         0x80000000
-#define PRS_ERR_TYPE_DOUBLE                 0x40000000
-#define PRS_ERR_SINGLE_ECC_CNT_MASK         0x00FF0000
-#define PRS_ERR_ADDR_MASK                   0x000001FF
-#define FM_PCD_PRS_RPIMAC_EN                0x00000001
-#define FM_PCD_PRS_SINGLE_ECC               0x00004000
-#define FM_PCD_PRS_PORT_IDLE_STS            0xffff0000
-#define FM_PCD_PRS_DOUBLE_ECC               0x00004000
-#define FM_PCD_PRS_PPSC_ALL_PORTS           0xffff0000
-
-/* others */
-#define PRS_MAX_CYCLE_LIMIT                 8191
-#define PRS_SW_DATA                         0x00000800
-#define PRS_REGS_OFFSET                     0x00000840
-
-#define GET_FM_PCD_PRS_PORT_ID(prsPortId,hardwarePortId) \
-    prsPortId = (uint8_t)(hardwarePortId & 0x0f)
-
-#define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
-    bitMask = 0x80000000>>prsPortId
+#define FM_PCD_PRS_SINGLE_ECC                 0x00004000
+#define FM_PCD_PRS_DOUBLE_ECC                 0x00004000
+#define PRS_MAX_CYCLE_LIMIT                   8191
 
 /***********************************************************************/
 /*          Keygen defines                                             */
 /***********************************************************************/
-/* Masks */
-#define FM_PCD_KG_KGGCR_EN                      0x80000000
-#define KG_SCH_GEN_VALID                        0x80000000
-#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
-#define KG_ERR_CAP                              0x80000000
-#define KG_ERR_TYPE_DOUBLE                      0x40000000
-#define KG_ERR_ADDR_MASK                        0x00000FFF
-#define FM_PCD_KG_DOUBLE_ECC                    0x80000000
-#define FM_PCD_KG_KEYSIZE_OVERFLOW              0x40000000
-#define KG_SCH_MODE_EN                          0x80000000
-
-/* shifts */
-#define FM_PCD_KG_PE_CPP_MASK_SHIFT             16
-#define FM_PCD_KG_KGAR_WSEL_SHIFT               8
-
-/* others */
-#define KG_DOUBLE_MEANING_REGS_OFFSET           0x100
-#define NO_VALIDATION                           0x70
-#define KG_ACTION_REG_TO                        1024
-#define KG_MAX_PROFILE                          255
-#define SCHEME_ALWAYS_DIRECT                    0xFFFFFFFF
+#define FM_PCD_KG_DOUBLE_ECC                  0x80000000
+#define FM_PCD_KG_KEYSIZE_OVERFLOW            0x40000000
 
 /***********************************************************************/
 /*          Policer defines                                            */
 /***********************************************************************/
-
-/* masks */
-#define FM_PCD_PLCR_PEMODE_PI                 0x80000000
-#define FM_PCD_PLCR_PEMODE_CBLND              0x40000000
-#define FM_PCD_PLCR_PEMODE_ALG_MASK           0x30000000
-#define FM_PCD_PLCR_PEMODE_ALG_RFC2698        0x10000000
-#define FM_PCD_PLCR_PEMODE_ALG_RFC4115        0x20000000
-#define FM_PCD_PLCR_PEMODE_DEFC_MASK          0x0C000000
-#define FM_PCD_PLCR_PEMODE_DEFC_Y             0x04000000
-#define FM_PCD_PLCR_PEMODE_DEFC_R             0x08000000
-#define FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE      0x0C000000
-#define FM_PCD_PLCR_PEMODE_OVCLR_MASK         0x03000000
-#define FM_PCD_PLCR_PEMODE_OVCLR_Y            0x01000000
-#define FM_PCD_PLCR_PEMODE_OVCLR_R            0x02000000
-#define FM_PCD_PLCR_PEMODE_OVCLR_G_NC         0x03000000
-#define FM_PCD_PLCR_PEMODE_PKT                0x00800000
-#define FM_PCD_PLCR_PEMODE_FPP_MASK           0x001F0000
-#define FM_PCD_PLCR_PEMODE_FPP_SHIFT          16
-#define FM_PCD_PLCR_PEMODE_FLS_MASK           0x0000F000
-#define FM_PCD_PLCR_PEMODE_FLS_L2             0x00003000
-#define FM_PCD_PLCR_PEMODE_FLS_L3             0x0000B000
-#define FM_PCD_PLCR_PEMODE_FLS_L4             0x0000E000
-#define FM_PCD_PLCR_PEMODE_FLS_FULL           0x0000F000
-#define FM_PCD_PLCR_PEMODE_RBFLS              0x00000800
-#define FM_PCD_PLCR_PEMODE_TRA                0x00000004
-#define FM_PCD_PLCR_PEMODE_TRB                0x00000002
-#define FM_PCD_PLCR_PEMODE_TRC                0x00000001
+#define FM_PCD_PLCR_GCR_STEN                  0x40000000
 #define FM_PCD_PLCR_DOUBLE_ECC                0x80000000
 #define FM_PCD_PLCR_INIT_ENTRY_ERROR          0x40000000
 #define FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE   0x80000000
 #define FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE    0x40000000
 
-#define FM_PCD_PLCR_NIA_VALID                 0x80000000
-
-#define FM_PCD_PLCR_GCR_EN                    0x80000000
-#define FM_PCD_PLCR_GCR_STEN                  0x40000000
-#define FM_PCD_PLCR_GCR_DAR                   0x20000000
-#define FM_PCD_PLCR_GCR_DEFNIA                0x00FFFFFF
-#define FM_PCD_PLCR_NIA_ABS                   0x00000100
-
-#define FM_PCD_PLCR_GSR_BSY                   0x80000000
-#define FM_PCD_PLCR_GSR_DQS                   0x60000000
-#define FM_PCD_PLCR_GSR_RPB                   0x20000000
-#define FM_PCD_PLCR_GSR_FQS                   0x0C000000
-#define FM_PCD_PLCR_GSR_LPALG                 0x0000C000
-#define FM_PCD_PLCR_GSR_LPCA                  0x00003000
-#define FM_PCD_PLCR_GSR_LPNUM                 0x000000FF
-
-#define FM_PCD_PLCR_EVR_PSIC                  0x80000000
-#define FM_PCD_PLCR_EVR_AAC                   0x40000000
-
-#define FM_PCD_PLCR_PAR_PSI                   0x20000000
-#define FM_PCD_PLCR_PAR_PNUM                  0x00FF0000
-/* PWSEL Selctive select options */
-#define FM_PCD_PLCR_PAR_PWSEL_PEMODE          0x00008000    /* 0 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEGNIA          0x00004000    /* 1 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEYNIA          0x00002000    /* 2 */
-#define FM_PCD_PLCR_PAR_PWSEL_PERNIA          0x00001000    /* 3 */
-#define FM_PCD_PLCR_PAR_PWSEL_PECIR           0x00000800    /* 4 */
-#define FM_PCD_PLCR_PAR_PWSEL_PECBS           0x00000400    /* 5 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEPIR_EIR       0x00000200    /* 6 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEPBS_EBS       0x00000100    /* 7 */
-#define FM_PCD_PLCR_PAR_PWSEL_PELTS           0x00000080    /* 8 */
-#define FM_PCD_PLCR_PAR_PWSEL_PECTS           0x00000040    /* 9 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEPTS_ETS       0x00000020    /* 10 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEGPC           0x00000010    /* 11 */
-#define FM_PCD_PLCR_PAR_PWSEL_PEYPC           0x00000008    /* 12 */
-#define FM_PCD_PLCR_PAR_PWSEL_PERPC           0x00000004    /* 13 */
-#define FM_PCD_PLCR_PAR_PWSEL_PERYPC          0x00000002    /* 14 */
-#define FM_PCD_PLCR_PAR_PWSEL_PERRPC          0x00000001    /* 15 */
-
-#define FM_PCD_PLCR_PAR_PMR_BRN_1TO1          0x0000   /* - Full bit replacement. {PBNUM[0:N-1]
-                                                           1-> 2^N specific locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_2TO2          0x1      /* - {PBNUM[0:N-2],PNUM[N-1]}.
-                                                           2-> 2^(N-1) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_4TO4          0x2      /* - {PBNUM[0:N-3],PNUM[N-2:N-1]}.
-                                                           4-> 2^(N-2) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_8TO8          0x3      /* - {PBNUM[0:N-4],PNUM[N-3:N-1]}.
-                                                           8->2^(N-3) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_16TO16        0x4      /* - {PBNUM[0:N-5],PNUM[N-4:N-1]}.
-                                                           16-> 2^(N-4) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_32TO32        0x5      /* {PBNUM[0:N-6],PNUM[N-5:N-1]}.
-                                                           32-> 2^(N-5) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_64TO64        0x6      /* {PBNUM[0:N-7],PNUM[N-6:N-1]}.
-                                                           64-> 2^(N-6) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_128TO128      0x7      /* {PBNUM[0:N-8],PNUM[N-7:N-1]}.
-                                                            128-> 2^(N-7) base locations. */
-#define FM_PCD_PLCR_PAR_PMR_BRN_256TO256      0x8      /* - No bit replacement for N=8. {PNUM[N-8:N-1]}.
-                                                            When N=8 this option maps all 256 profiles by the DISPATCH bus into one group. */
-
-#define FM_PCD_PLCR_PMR_V                     0x80000000
-#define PLCR_ERR_ECC_CAP                      0x80000000
-#define PLCR_ERR_ECC_TYPE_DOUBLE              0x40000000
-#define PLCR_ERR_ECC_PNUM_MASK                0x00000FF0
-#define PLCR_ERR_ECC_OFFSET_MASK              0x0000000F
-
-#define PLCR_ERR_UNINIT_CAP                   0x80000000
-#define PLCR_ERR_UNINIT_NUM_MASK              0x000000FF
-#define PLCR_ERR_UNINIT_PID_MASK              0x003f0000
-#define PLCR_ERR_UNINIT_ABSOLUTE_MASK         0x00008000
-
-/* shifts */
-#define PLCR_ERR_ECC_PNUM_SHIFT               4
-#define PLCR_ERR_UNINIT_PID_SHIFT             16
-
-#define FM_PCD_PLCR_PMR_BRN_SHIFT             16
-
-/* others */
-#define WAIT_FOR_PLCR_EVR_AAC \
-{\
-    uint32_t count = 0; \
-    uint32_t tmpReg32; \
-    while (count < FM_PCD_PLCR_POLL) \
-    { \
-        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_evr);\
-        if (!( tmpReg32 & FM_PCD_PLCR_EVR_AAC)) break;\
-        count++;\
-    }\
-}
-
-#define WAIT_FOR_PLCR_PAR_GO \
-{\
-    uint32_t count = 0; \
-    uint32_t tmpReg32; \
-    while (count < FM_PCD_PLCR_POLL) \
-    { \
-        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->fmpl_par);\
-        if (!( tmpReg32 & FM_PCD_PLCR_PAR_GO)) break;\
-        count++; \
-    }\
-}
-
-#define PLCR_PORT_WINDOW_SIZE(hardwarePortId)
-
-/****************************/
-/* Defaults                 */
-/****************************/
-#define DEFAULT_plcrAutoRefresh                 FALSE
-#define DEFAULT_prsMaxParseCycleLimit           0
-#define DEFAULT_fmPcdKgErrorExceptions          (FM_PCD_EX_KG_DOUBLE_ECC | FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
-#define DEFAULT_fmPcdPlcrErrorExceptions        (FM_PCD_EX_PLCR_DOUBLE_ECC | FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
-#define DEFAULT_fmPcdPlcrExceptions             0
-#define DEFAULT_fmPcdPrsErrorExceptions         (FM_PCD_EX_PRS_DOUBLE_ECC)
-
-#define DEFAULT_fmPcdPrsExceptions              FM_PCD_EX_PRS_SINGLE_ECC
-#define DEFAULT_numOfUsedProfilesPerWindow      16
-#define DEFAULT_numOfSharedPlcrProfiles         4
-
 /***********************************************************************/
 /*          Memory map                                                 */
 /***********************************************************************/
@@ -456,6 +287,12 @@ typedef struct {
 } t_NetEnvParams;
 
 typedef struct {
+    bool            allocated;
+    uint8_t         ownerId; /* guestId for KG in multi-partition only,
+                                portId for PLCR in any environment */
+} t_FmPcdAllocMng;
+
+typedef struct {
     volatile bool       lock;
     bool                used;
     uint8_t             owners;
@@ -467,10 +304,9 @@ typedef struct {
 } t_FmPcdKgClsPlanGrp;
 
 typedef struct {
-	t_Handle			h_FmPcd;
-	uint8_t				schemeId;
-	volatile bool       lock;
-    t_Handle            h_Spinlock;
+    t_Handle            h_FmPcd;
+    uint8_t             schemeId;
+    t_FmPcdLock         *p_Lock;
     bool                valid;
     uint8_t             netEnvId;
     uint8_t             owners;
@@ -487,23 +323,16 @@ typedef struct {
     bool                extractedOrs;
     uint8_t             bitOffsetInPlcrProfile;
     bool                directPlcr;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool                vspe;
 #endif
 } t_FmPcdKgScheme;
 
 typedef struct {
-    bool            allocated;
-    uint8_t         ownerId; /* guestId for KG in multi-partition only,
-                                portId for PLCR in any environment */
-} t_FmPcdAllocMng;
-
-typedef struct {
     t_FmPcdKgRegs       *p_FmPcdKgRegs;
     uint32_t            schemeExceptionsBitMask;
     uint8_t             numOfSchemes;
     t_Handle            h_HwSpinlock;
-    t_Handle            h_SwSpinlock;
     uint8_t             schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
     t_FmPcdKgScheme     schemes[FM_PCD_KG_NUM_OF_SCHEMES];
     t_FmPcdKgClsPlanGrp clsPlanGrps[FM_MAX_NUM_OF_PORTS];
@@ -519,11 +348,10 @@ typedef struct {
 } t_FmPcdPlcrMapParam;
 
 typedef struct {
-	uint16_t							absoluteProfileId;
-	t_Handle							h_FmPcd;
+    uint16_t                            absoluteProfileId;
+    t_Handle                            h_FmPcd;
     bool                                valid;
-    /*volatile bool                       lock;*/
-    t_Handle                            h_Spinlock;
+    t_FmPcdLock                         *p_Lock;
     t_FmPcdAllocMng                     profilesMng;
     uint8_t                             pointedOwners;
     uint32_t                            requiredAction;
@@ -571,9 +399,8 @@ typedef struct {
 } t_FmPcdNetEnvAliases;
 
 typedef struct {
-	uint8_t						netEnvId;
-	t_Handle					h_FmPcd;
-    volatile bool               lock;
+    uint8_t                     netEnvId;
+    t_Handle                    h_FmPcd;
     t_Handle                    h_Spinlock;
     bool                        used;
     uint8_t                     owners;
@@ -590,14 +417,18 @@ typedef struct {
     uint16_t                    prsMaxParseCycleLimit;
 } t_FmPcdDriverParam;
 
-
 typedef struct {
     t_Handle                    h_Fm;
     t_Handle                    h_FmMuram;
     t_FmRevisionInfo            fmRevInfo;
+
     uint64_t                    physicalMuramBase;
+
     volatile bool               lock;
     t_Handle                    h_Spinlock;
+    t_List                      freeLocksLst;
+    t_List                      acquiredLocksLst;
+
     t_Handle                    h_IpcSession; /* relevant for guest only */
     bool                        enabled;
     uint8_t                     guestId;            /**< Guest Partition Id */
@@ -661,6 +492,9 @@ t_Error     FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t g
 /* only for SINGLE partittion */
 t_Error     KgBindPortToSchemes(t_Handle h_FmPcd , uint8_t hardwarePortId, uint32_t spReg);
 
+t_FmPcdLock *FmPcdAcquireLock(t_Handle h_FmPcd);
+void        FmPcdReleaseLock(t_Handle h_FmPcd, t_FmPcdLock *p_Lock);
+
 t_Handle    PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     PlcrInit(t_FmPcd *p_FmPcd);
 t_Error     PlcrFree(t_FmPcd *p_FmPcd);
@@ -694,7 +528,7 @@ t_Error     FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_F
 t_Handle    FmPcdManipApplSpecificBuild(void);
 bool        FmPcdManipIsCapwapApplSpecific(t_Handle h_Manip);
 #endif /* FM_CAPWAP_SUPPORT */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 void *      FrmReplicGetSourceTableDescriptor(t_Handle h_ReplicGroup);
 void        FrmReplicUpdateGroupOwner(t_Handle h_ReplicGroup, bool add, bool fullUpdate, t_Handle h_FmPcdCcNode);
 void        FrmReplicUpdateAdContLookupForCc(t_Handle h_ReplicGroup, t_Handle p_Ad, t_Handle *h_AdNew);
@@ -703,7 +537,7 @@ void        FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle   h_Node,
                                                      t_Handle   h_ReplicGroup,
                                                      t_List     *p_AdTables,
                                                      uint32_t   *p_NumOfAdTables);
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo);
 t_CcNodeInformation* FmPcdCcFindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info);
@@ -727,5 +561,39 @@ static __inline__ uint64_t FmPcdGetMuramPhysBase(t_Handle h_FmPcd)
     return p_FmPcd->physicalMuramBase;
 }
 
+static __inline__ uint32_t FmPcdLockSpinlock(t_FmPcdLock *p_Lock)
+{
+    ASSERT_COND(p_Lock);
+    return XX_LockIntrSpinlock(p_Lock->h_Spinlock);
+}
+
+static __inline__ void FmPcdUnlockSpinlock(t_FmPcdLock *p_Lock, uint32_t flags)
+{
+    ASSERT_COND(p_Lock);
+    XX_UnlockIntrSpinlock(p_Lock->h_Spinlock, flags);
+}
+
+static __inline__ bool FmPcdLockTryLock(t_FmPcdLock *p_Lock)
+{
+    uint32_t intFlags;
+
+    ASSERT_COND(p_Lock);
+    intFlags = XX_LockIntrSpinlock(p_Lock->h_Spinlock);
+    if (p_Lock->flag)
+    {
+        XX_UnlockIntrSpinlock(p_Lock->h_Spinlock, intFlags);
+        return FALSE;
+    }
+    p_Lock->flag = TRUE;
+    XX_UnlockIntrSpinlock(p_Lock->h_Spinlock, intFlags);
+    return TRUE;
+}
+
+static __inline__ void FmPcdLockUnlock(t_FmPcdLock *p_Lock)
+{
+    ASSERT_COND(p_Lock);
+    p_Lock->flag = FALSE;
+}
+
 
 #endif /* __FM_PCD_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
index 497dc95..c0a47b6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_pcd_ipc.h
 
@@ -112,14 +113,14 @@ typedef _Packed struct t_FmPcdIpcPrsIncludePort
     bool        include;
 } _PackedType t_FmPcdIpcPrsIncludePort;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 typedef _Packed struct t_FmPcdIpcSpAllocParams
 {
     uint16_t    num;
     uint8_t     hardwarePortId;
     uint16_t    spProfilesBase;
 } _PackedType t_FmPcdIpcSpAllocParams;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 #define FM_PCD_MAX_REPLY_SIZE           16
@@ -238,15 +239,6 @@ typedef _Packed struct t_FmPcdIpcReply
 #define FM_PCD_GUEST_DISABLE                    16
 
 /**************************************************************************//**
- @Function      FM_PCD_DUMP_REGS
-
- @Description   Used by FM front-end to dump all PCD registers
-
- @Param[in]     None
-*//***************************************************************************/
-#define FM_PCD_DUMP_REGS                        17
-
-/**************************************************************************//**
  @Function      FM_PCD_KG_DUMP_REGS
 
  @Description   Used by FM front-end to dump KG registers
@@ -327,10 +319,10 @@ typedef _Packed struct t_FmPcdIpcReply
 *//***************************************************************************/
 #define FM_PCD_PRS_INC_PORT_STATS               26
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /* TODO - doc */
 #define FM_PCD_ALLOC_SP                         27
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 /** @} */ /* end of FM_PCD_IPC_grp group */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index b848615..470d86d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_plcr.c
 
@@ -46,19 +47,31 @@
 #include "fm_pcd.h"
 #include "fm_hc.h"
 #include "fm_pcd_ipc.h"
+#include "fm_plcr.h"
+
 
 static uint32_t PlcrProfileLock(t_Handle h_Profile)
 {
     ASSERT_COND(h_Profile);
-
-    return XX_LockIntrSpinlock(((t_FmPcdPlcrProfile*)h_Profile)->h_Spinlock);
+    return FmPcdLockSpinlock(((t_FmPcdPlcrProfile *)h_Profile)->p_Lock);
 }
 
 static void PlcrProfileUnlock(t_Handle h_Profile, uint32_t intFlags)
 {
     ASSERT_COND(h_Profile);
+    FmPcdUnlockSpinlock(((t_FmPcdPlcrProfile *)h_Profile)->p_Lock, intFlags);
+}
 
-    XX_UnlockIntrSpinlock(((t_FmPcdPlcrProfile*)h_Profile)->h_Spinlock, intFlags);
+static bool PlcrProfileFlagTryLock(t_Handle h_Profile)
+{
+    ASSERT_COND(h_Profile);
+    return FmPcdLockTryLock(((t_FmPcdPlcrProfile *)h_Profile)->p_Lock);
+}
+
+static void PlcrProfileFlagUnlock(t_Handle h_Profile)
+{
+    ASSERT_COND(h_Profile);
+    FmPcdLockUnlock(((t_FmPcdPlcrProfile *)h_Profile)->p_Lock);
 }
 
 static uint32_t PlcrHwLock(t_Handle h_FmPcdPlcr)
@@ -239,16 +252,16 @@ static void CalcRates(t_Handle                              h_FmPcd,
      */
     if(temp != 0)
     {
-	/* In this case, the largest rate integer is non 0, if it does not occupy all (high) 16
-	 * bits of the PIR_EIR we can use this fact and enlarge it to occupy all 16 bits.
-	 * The logic is to have as many bits for integer in the higher rates, but if we have "0"s
-	 * in the integer part of the cir/pir register, than these bits are wasted. So we want
-	 * to use these bits for the fraction. in this way we will have for fraction - the number
-	 * of "0" bits and the rest - for integer.
-	 * In other words: For each bit we shift it in PIR_EIR, we move the FP in the TS
-	 * one bit to the left - preserving the relationship and achieving more bits
-	 * for integer in the TS.
-	 */
+        /* In this case, the largest rate integer is non 0, if it does not occupy all (high) 16
+         * bits of the PIR_EIR we can use this fact and enlarge it to occupy all 16 bits.
+         * The logic is to have as many bits for integer in the higher rates, but if we have "0"s
+         * in the integer part of the cir/pir register, than these bits are wasted. So we want
+         * to use these bits for the fraction. in this way we will have for fraction - the number
+         * of "0" bits and the rest - for integer.
+         * In other words: For each bit we shift it in PIR_EIR, we move the FP in the TS
+         * one bit to the left - preserving the relationship and achieving more bits
+         * for integer in the TS.
+         */
 
         /* count zeroes left of the higher used bit (in order to shift the value such that
          * unused bits may be used for fraction).
@@ -413,9 +426,6 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     uint32_t                        tmpReg32 = 0;
     t_Error                         err = E_OK;
     t_FmPcdPlcrRegs                 *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    t_FmPcdIpcMsg                   msg;
-    uint32_t                        replyLength;
-    t_FmPcdIpcReply                 reply;
 
     p_FmPcdPlcr->h_HwSpinlock = XX_InitSpinlock();
     if (!p_FmPcdPlcr->h_HwSpinlock)
@@ -428,6 +438,9 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
     if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
         (p_FmPcdPlcr->numOfSharedProfiles))
     {
+        t_FmPcdIpcMsg                   msg;
+        uint32_t                        replyLength;
+        t_FmPcdIpcReply                 reply;
         int         i, j, index = 0;
         uint32_t    walking1Mask = 0x80000000;
         uint32_t    sharedProfilesMask[FM_PCD_PLCR_NUM_ENTRIES/32];
@@ -527,8 +540,6 @@ t_Error PlcrInit(t_FmPcd *p_FmPcd)
 t_Error PlcrFree(t_FmPcd *p_FmPcd)
 {
     t_Error                             err;
-    t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
-    t_FmPcdIpcMsg                       msg;
 
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR);
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL);
@@ -537,7 +548,10 @@ t_Error PlcrFree(t_FmPcd *p_FmPcd)
     {
         if(p_FmPcd->guestId != NCSW_MASTER_ID)
         {
-            int i;
+            t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
+            t_FmPcdIpcMsg                       msg;
+            int                                 i;
+
             memset(ipcSharedPlcrParams.sharedProfilesMask, 0, sizeof(ipcSharedPlcrParams.sharedProfilesMask));
             /* Free resources using IPC messaging */
             ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
@@ -586,13 +600,15 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
     uint32_t        tmpReg32, intFlags;
     t_Error         err;
 
+    /* Calling function locked all PCD modules, so no need to lock here */
+
     if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile out of range"));
 
     if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileIndx))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile is not valid"));
 
-    intFlags = PlcrProfileLock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx]);
+    /*intFlags = PlcrProfileLock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx]);*/
 
     if (p_FmPcd->h_Hc)
     {
@@ -601,11 +617,11 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
         FmPcdPlcrUpatePointedOwner(p_FmPcd, profileIndx, TRUE);
         FmPcdPlcrUpdateRequiredAction(p_FmPcd, profileIndx, requiredAction);
 
-        PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+        /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
         return err;
     }
 
-    /* lock the HW because once we read the registers we don't them to be changed
+    /* lock the HW because once we read the registers we don't want them to be changed
      * by another access. (We can copy to a tmp location and release the lock!) */
 
     intFlags = PlcrHwLock(p_FmPcdPlcr);
@@ -621,7 +637,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnRed!= e_FM_PCD_DONE))
             {
                 PlcrHwUnlock(p_FmPcdPlcr, intFlags);
-                PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
                 RETURN_ERROR (MAJOR, E_OK, ("In this case the next engine can be e_FM_PCD_DONE"));
             }
 
@@ -631,7 +647,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
-                    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                    /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
                 }
                 tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
@@ -647,7 +663,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
-                    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                    /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
                 }
                 tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
@@ -664,7 +680,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
-                    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                    /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
                 }
                 tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
@@ -681,7 +697,7 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
     FmPcdPlcrUpatePointedOwner(p_FmPcd, profileIndx, TRUE);
     FmPcdPlcrUpdateRequiredAction(p_FmPcd, profileIndx, requiredAction);
 
-    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+    /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
 
     return E_OK;
 }
@@ -725,9 +741,6 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
     t_Error                     err = E_OK;
     uint16_t                    base;
     uint16_t                    swPortIndex = 0;
-    t_FmPcdIpcMsg               msg;
-    uint32_t                    replyLength;
-    t_FmPcdIpcReply             reply;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
@@ -738,6 +751,10 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
 
     if(p_FmPcd->guestId != NCSW_MASTER_ID)
     {
+        t_FmPcdIpcMsg               msg;
+        uint32_t                    replyLength;
+        t_FmPcdIpcReply             reply;
+
         /* Alloc resources using IPC messaging */
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
@@ -775,22 +792,23 @@ t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16
     return E_OK;
 }
 
-t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+t_Error FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
     t_Error                     err = E_OK;
     uint16_t                    swPortIndex = 0;
-    t_FmPcdIpcMsg               msg;
-    uint32_t                    replyLength;
-    t_FmPcdIpcReply             reply;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
     {
+        t_FmPcdIpcMsg               msg;
+        uint32_t                    replyLength;
+        t_FmPcdIpcReply             reply;
+
         /* Alloc resources using IPC messaging */
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
@@ -815,8 +833,11 @@ t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
     }
     else /* master */
     {
-        err = PlcrFreeProfiles(p_FmPcd, hardwarePortId, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
-        if(err)
+        err = PlcrFreeProfiles(p_FmPcd,
+                               hardwarePortId,
+                               p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles,
+                               p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
+        if (err)
             RETURN_ERROR(MAJOR, err,NO_MSG);
     }
     p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
@@ -907,11 +928,14 @@ t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t nu
 
 t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
 {
-    uint32_t        profilesFound, intFlags;
+    uint32_t        profilesFound;
     uint16_t        i, k=0;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
+
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     if(!numOfProfiles)
         return E_OK;
@@ -920,9 +944,6 @@ t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint1
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
 
     /* Find numOfProfiles free profiles (may be spread) */
-
-    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
-
     profilesFound = 0;
     for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
     {
@@ -936,18 +957,14 @@ t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint1
         }
     }
     if(profilesFound != numOfProfiles)
-    {
-        PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
         RETURN_ERROR(MAJOR, E_INVALID_STATE,NO_MSG);
-    }
+
     for(i = 0;i<k;i++)
     {
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = TRUE;
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.ownerId = 0;
     }
 
-    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-
     return E_OK;
 }
 
@@ -983,29 +1000,27 @@ t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num
 void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
 {
     uint16_t        i;
-    uint32_t        intFlags;
 
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
 
-    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
+    /* This routine is issued only on master core of master partition -
+       either directly or through IPC, so no need for lock */
 
     for(i=0;i<numOfProfiles; i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
     }
-    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
-
 }
 
 t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_ProfileParams, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs)
 {
 
-    t_FmPcd         		*p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_Error         		err = E_OK;
-    uint32_t        		pemode, gnia, ynia, rnia;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error                 err = E_OK;
+    uint32_t                pemode, gnia, ynia, rnia;
 
 
 /* Set G, Y, R Nia */
@@ -1219,7 +1234,7 @@ void  FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 
 uint16_t     FmPcdPlcrProfileGetAbsoluteId(t_Handle h_Profile)
 {
-	    return ((t_FmPcdPlcrProfile*)h_Profile)->absoluteProfileId;
+        return ((t_FmPcdPlcrProfile*)h_Profile)->absoluteProfileId;
 }
 
 t_Error     FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle                      h_FmPcd,
@@ -1355,25 +1370,6 @@ void FmPcdPlcrUpdateRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId,
     p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction |= requiredAction;
 }
 
-/*t_Error FmPcdPlcrProfileTryLock(t_Handle h_FmPcdPlcr, uint16_t profileId, bool intr)
-{
-    t_FmPcdPlcr         *p_FmPcdPlcr = (t_FmPcdPlcr *)h_FmPcdPlcr;
-    bool            ans;
-
-    if (intr)
-        ans = TRY_LOCK(p_FmPcdPlcr->h_SwSpinlock, &p_FmPcdPlcr->profiles[profileId].lock);
-    else
-        ans = TRY_LOCK(p_FmPcdPlcr->h_SwSpinlock, &p_FmPcdPlcr->profiles[profileId].lock);
-    if (ans)
-        return E_OK;
-    return ERROR_CODE(E_BUSY);
-}
-
-void FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcdPlcr, uint16_t profileId)
-{
-    RELEASE_LOCK(((t_FmPcdPlcr*)h_FmPcdPlcr)->profiles[profileId].lock);
-}
-*/
 
 /**************************************************/
 /*............Policer API.........................*/
@@ -1436,7 +1432,6 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     int                 i = 0;
-    t_FmPcdIpcMsg       msg;
 
     DECLARE_DUMP;
 
@@ -1444,8 +1439,11 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcMsg       msg;
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_PLCR_DUMP_REGS;
         return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
@@ -1456,39 +1454,40 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
                                  NULL,
                                  NULL);
     }
-    else
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
+
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
+
+
+    DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
+    DUMP_SUBSTRUCT_ARRAY(i, 63)
     {
-        DUMP_SUBTITLE(("\n"));
-        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
-
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
-
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
-
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
-        DUMP_SUBSTRUCT_ARRAY(i, 63)
-        {
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
-        }
-
-        return E_OK;
+        DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
     }
+
+    return E_OK;
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
@@ -1502,22 +1501,15 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     uint16_t                            absoluteProfileId;
     t_Error                             err = E_OK;
     uint32_t                            tmpReg32;
-    t_FmPcdPlcrProfile				    *p_Profile;
+    t_FmPcdPlcrProfile                  *p_Profile;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
 
-    /*
-        err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
-        if (err)
-            return NULL;
-    */
-
-
     if(p_ProfileParams->modify)
     {
-	p_Profile = (t_FmPcdPlcrProfile *)p_ProfileParams->id.h_Profile;
-	p_FmPcd = p_Profile->h_FmPcd;
-	absoluteProfileId = p_Profile->absoluteProfileId;
+        p_Profile = (t_FmPcdPlcrProfile *)p_ProfileParams->id.h_Profile;
+        p_FmPcd = p_Profile->h_FmPcd;
+        absoluteProfileId = p_Profile->absoluteProfileId;
         if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
         {
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
@@ -1526,10 +1518,18 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
 
         SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
 
-    }
+        /* Try lock profile using flag */
+         if (!PlcrProfileFlagTryLock(p_Profile))
+         {
+		 DBG(TRACE, ("Profile Try Lock - BUSY"));
+             /* Signal to caller BUSY condition */
+             p_ProfileParams->id.h_Profile = NULL;
+             return NULL;
+         }
+   }
     else
     {
-	p_FmPcd = (t_FmPcd*)h_FmPcd;
+        p_FmPcd = (t_FmPcd*)h_FmPcd;
 
         SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
 
@@ -1557,6 +1557,10 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
          p_Profile = &p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId];
          p_Profile->h_FmPcd = p_FmPcd;
          p_Profile->absoluteProfileId = absoluteProfileId;
+
+         p_Profile->p_Lock = FmPcdAcquireLock(p_FmPcd);
+         if (!p_Profile->p_Lock)
+             REPORT_ERROR(MAJOR, E_NOT_AVAILABLE, ("FM Policer Profile lock obj!"));
     }
 
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
@@ -1570,17 +1574,18 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     p_Profile->nextEngineOnRed = p_ProfileParams->nextEngineOnRed;
     memcpy(&p_Profile->paramsOnRed, &(p_ProfileParams->paramsOnRed), sizeof(u_FmPcdPlcrNextEngineParams));
 
-    p_Profile->h_Spinlock = XX_InitSpinlock();
-    if (!p_Profile->h_Spinlock)
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PLCR Profile spinlock"));
-
     if (p_FmPcd->h_Hc)
     {
          err = FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, (t_Handle)p_Profile, p_ProfileParams);
+         if(p_ProfileParams->modify)
+             PlcrProfileFlagUnlock(p_Profile);
          if(err)
          {
-             if (p_Profile->h_Spinlock)
-                 XX_FreeSpinlock(p_Profile->h_Spinlock);
+             /* release the allocated scheme lock */
+             if (!p_ProfileParams->modify &&
+                     p_Profile->p_Lock)
+                 FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
+
              return NULL;
          }
          if (!p_ProfileParams->modify)
@@ -1597,9 +1602,14 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     err =  FmPcdPlcrBuildProfile(h_FmPcd, p_ProfileParams, &plcrProfileReg);
     if(err)
     {
-        if (p_Profile->h_Spinlock)
-            XX_FreeSpinlock(p_Profile->h_Spinlock);
         REPORT_ERROR(MAJOR, err, NO_MSG);
+        if(p_ProfileParams->modify)
+            /* unlock */
+            PlcrProfileFlagUnlock(p_Profile);
+        if (!p_ProfileParams->modify &&
+                p_Profile->p_Lock)
+            /* release allocated Profile lock */
+            FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
         return NULL;
     }
 
@@ -1628,18 +1638,18 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
 
     if (!p_ProfileParams->modify)
         FmPcdPlcrValidateProfileSw(p_FmPcd,absoluteProfileId);
-
-    /*RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);*/
+    else
+        PlcrProfileFlagUnlock(p_Profile);
 
     return (t_Handle)p_Profile;
 }
 
 t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
 {
-	t_FmPcdPlcrProfile	*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
-    t_FmPcd         	*p_FmPcd;
-    uint16_t        	profileIndx;
-    uint32_t        	tmpReg32, intFlags;
+    t_FmPcdPlcrProfile  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd             *p_FmPcd;
+    uint16_t            profileIndx;
+    uint32_t            tmpReg32, intFlags;
     t_Error             err;
 
     SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
@@ -1648,19 +1658,14 @@ t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
 
     profileIndx = p_Profile->absoluteProfileId;
 
-    /*
-         err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
-         if (err)
-             return NULL;
-     */
+    FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
 
     if (p_FmPcd->h_Hc)
     {
         err = FmHcPcdPlcrDeleteProfile(p_FmPcd->h_Hc, h_Profile);
-        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
-        FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
-        if (p_Profile->h_Spinlock)
-            XX_FreeSpinlock(p_Profile->h_Spinlock);
+        if (p_Profile->p_Lock)
+            /* release allocated Profile lock */
+            FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
 
         return err;
     }
@@ -1672,12 +1677,9 @@ t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
     WritePar(p_FmPcd, tmpReg32);
     PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
-    FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
-
-    /* FmPcdKgReleaseSchemeLock(h_Scheme); */
-
-    if (p_Profile->h_Spinlock)
-        XX_FreeSpinlock(p_Profile->h_Spinlock);
+    if (p_Profile->p_Lock)
+        /* release allocated Profile lock */
+        FmPcdReleaseLock(p_FmPcd, p_Profile->p_Lock);
 
     return E_OK;
 }
@@ -1687,11 +1689,11 @@ t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
 /***************************************************/
 uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
 {
-	t_FmPcdPlcrProfile	*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
-    t_FmPcd         	*p_FmPcd;
-    uint16_t        	profileIndx;
-    uint32_t        	intFlags, counterVal = 0;
-    t_FmPcdPlcrRegs		*p_FmPcdPlcrRegs;
+    t_FmPcdPlcrProfile  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd             *p_FmPcd;
+    uint16_t            profileIndx;
+    uint32_t            intFlags, counterVal = 0;
+    t_FmPcdPlcrRegs     *p_FmPcdPlcrRegs;
 
     SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
     p_FmPcd = p_Profile->h_FmPcd;
@@ -1741,11 +1743,11 @@ uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCoun
 
 t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
 {
-	t_FmPcdPlcrProfile	*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
-    t_FmPcd         	*p_FmPcd;
-    uint16_t        	profileIndx;
-    uint32_t        	tmpReg32, intFlags;
-    t_FmPcdPlcrRegs		*p_FmPcdPlcrRegs;
+    t_FmPcdPlcrProfile  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd             *p_FmPcd;
+    uint16_t            profileIndx;
+    uint32_t            tmpReg32, intFlags;
+    t_FmPcdPlcrRegs     *p_FmPcdPlcrRegs;
 
     SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
 
@@ -1758,7 +1760,7 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
     p_FmPcdPlcrRegs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
     SANITY_CHECK_RETURN_ERROR(p_FmPcdPlcrRegs, E_INVALID_HANDLE);
 
-    intFlags = FmPcdLock(p_FmPcd);
+    intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
     switch (counter)
     {
         case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
@@ -1777,6 +1779,7 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
              WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_perrpc ,value);
              break;
         default:
+		PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
     }
 
@@ -1786,7 +1789,7 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
     tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
     tmpReg32 |= FmPcdPlcrBuildCounterProfileReg(counter);
     WritePar(p_FmPcd, tmpReg32);
-    FmPcdUnlock(p_FmPcd, intFlags);
+    PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
     return E_OK;
 }
@@ -1794,12 +1797,11 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCount
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
 {
-	t_FmPcdPlcrProfile					*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
-    t_FmPcd         					*p_FmPcd;
+    t_FmPcdPlcrProfile                  *p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd                             *p_FmPcd;
     t_FmPcdPlcrInterModuleProfileRegs   *p_ProfilesRegs;
-    uint16_t        					profileIndx;
+    uint16_t                            profileIndx;
     uint32_t                            tmpReg, intFlags;
-    t_FmPcdIpcMsg                       msg;
 
     DECLARE_DUMP;
 
@@ -1808,10 +1810,11 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
 
-    profileIndx = p_Profile->absoluteProfileId;
-
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcMsg                       msg;
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_PLCR_PROFILE_DUMP_REGS;
         memcpy(msg.msgBody, (uint8_t *)&h_Profile, sizeof(uint32_t));
@@ -1823,38 +1826,41 @@ t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
                                  NULL,
                                  NULL);
     }
-    else
-    {
-        DUMP_SUBTITLE(("\n"));
-        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Profile Regs"));
-
-        p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
-
-        tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
-        intFlags = FmPcdLock(p_FmPcd);
-        WritePar(p_FmPcd, tmpReg);
-
-        DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
-
-        DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
-        DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pects);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
-        DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
-        DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
-        FmPcdUnlock(p_FmPcd, intFlags);
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
 
-        return E_OK;
-    }
+    profileIndx = p_Profile->absoluteProfileId;
+
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Profile Regs"));
+
+    p_ProfilesRegs = &p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs;
+
+    tmpReg = FmPcdPlcrBuildReadPlcrActionReg((uint16_t)profileIndx);
+	intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
+    WritePar(p_FmPcd, tmpReg);
+
+    DUMP_TITLE(p_ProfilesRegs, ("Profile %d regs", profileIndx));
+
+    DUMP_VAR(p_ProfilesRegs, fmpl_pemode);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pegnia);
+    DUMP_VAR(p_ProfilesRegs, fmpl_peynia);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pernia);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pecir);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pecbs);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pepepir_eir);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pepbs_ebs);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pelts);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pects);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pepts_ets);
+    DUMP_VAR(p_ProfilesRegs, fmpl_pegpc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_peypc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_perpc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_perypc);
+    DUMP_VAR(p_ProfilesRegs, fmpl_perrpc);
+	PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+
+    return E_OK;
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h
new file mode 100644
index 0000000..2bb8b96
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_plcr.h
+
+ @Description   FM Policer private header
+*//***************************************************************************/
+#ifndef __FM_PLCR_H
+#define __FM_PLCR_H
+
+#include "std_ext.h"
+
+
+/***********************************************************************/
+/*          Policer defines                                            */
+/***********************************************************************/
+
+#define FM_PCD_PLCR_PAR_GO                    0x80000000
+#define FM_PCD_PLCR_PAR_PWSEL_MASK            0x0000FFFF
+#define FM_PCD_PLCR_PAR_R                     0x40000000
+
+/* shifts */
+#define FM_PCD_PLCR_PAR_PNUM_SHIFT            16
+
+/* masks */
+#define FM_PCD_PLCR_PEMODE_PI                 0x80000000
+#define FM_PCD_PLCR_PEMODE_CBLND              0x40000000
+#define FM_PCD_PLCR_PEMODE_ALG_MASK           0x30000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC2698        0x10000000
+#define FM_PCD_PLCR_PEMODE_ALG_RFC4115        0x20000000
+#define FM_PCD_PLCR_PEMODE_DEFC_MASK          0x0C000000
+#define FM_PCD_PLCR_PEMODE_DEFC_Y             0x04000000
+#define FM_PCD_PLCR_PEMODE_DEFC_R             0x08000000
+#define FM_PCD_PLCR_PEMODE_DEFC_OVERRIDE      0x0C000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_MASK         0x03000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_Y            0x01000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_R            0x02000000
+#define FM_PCD_PLCR_PEMODE_OVCLR_G_NC         0x03000000
+#define FM_PCD_PLCR_PEMODE_PKT                0x00800000
+#define FM_PCD_PLCR_PEMODE_FPP_MASK           0x001F0000
+#define FM_PCD_PLCR_PEMODE_FPP_SHIFT          16
+#define FM_PCD_PLCR_PEMODE_FLS_MASK           0x0000F000
+#define FM_PCD_PLCR_PEMODE_FLS_L2             0x00003000
+#define FM_PCD_PLCR_PEMODE_FLS_L3             0x0000B000
+#define FM_PCD_PLCR_PEMODE_FLS_L4             0x0000E000
+#define FM_PCD_PLCR_PEMODE_FLS_FULL           0x0000F000
+#define FM_PCD_PLCR_PEMODE_RBFLS              0x00000800
+#define FM_PCD_PLCR_PEMODE_TRA                0x00000004
+#define FM_PCD_PLCR_PEMODE_TRB                0x00000002
+#define FM_PCD_PLCR_PEMODE_TRC                0x00000001
+#define FM_PCD_PLCR_DOUBLE_ECC                0x80000000
+#define FM_PCD_PLCR_INIT_ENTRY_ERROR          0x40000000
+#define FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE   0x80000000
+#define FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE    0x40000000
+
+#define FM_PCD_PLCR_NIA_VALID                 0x80000000
+
+#define FM_PCD_PLCR_GCR_EN                    0x80000000
+#define FM_PCD_PLCR_GCR_STEN                  0x40000000
+#define FM_PCD_PLCR_GCR_DAR                   0x20000000
+#define FM_PCD_PLCR_GCR_DEFNIA                0x00FFFFFF
+#define FM_PCD_PLCR_NIA_ABS                   0x00000100
+
+#define FM_PCD_PLCR_GSR_BSY                   0x80000000
+#define FM_PCD_PLCR_GSR_DQS                   0x60000000
+#define FM_PCD_PLCR_GSR_RPB                   0x20000000
+#define FM_PCD_PLCR_GSR_FQS                   0x0C000000
+#define FM_PCD_PLCR_GSR_LPALG                 0x0000C000
+#define FM_PCD_PLCR_GSR_LPCA                  0x00003000
+#define FM_PCD_PLCR_GSR_LPNUM                 0x000000FF
+
+#define FM_PCD_PLCR_EVR_PSIC                  0x80000000
+#define FM_PCD_PLCR_EVR_AAC                   0x40000000
+
+#define FM_PCD_PLCR_PAR_PSI                   0x20000000
+#define FM_PCD_PLCR_PAR_PNUM                  0x00FF0000
+/* PWSEL Selctive select options */
+#define FM_PCD_PLCR_PAR_PWSEL_PEMODE          0x00008000    /* 0 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGNIA          0x00004000    /* 1 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYNIA          0x00002000    /* 2 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERNIA          0x00001000    /* 3 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECIR           0x00000800    /* 4 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECBS           0x00000400    /* 5 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPIR_EIR       0x00000200    /* 6 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPBS_EBS       0x00000100    /* 7 */
+#define FM_PCD_PLCR_PAR_PWSEL_PELTS           0x00000080    /* 8 */
+#define FM_PCD_PLCR_PAR_PWSEL_PECTS           0x00000040    /* 9 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEPTS_ETS       0x00000020    /* 10 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEGPC           0x00000010    /* 11 */
+#define FM_PCD_PLCR_PAR_PWSEL_PEYPC           0x00000008    /* 12 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERPC           0x00000004    /* 13 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERYPC          0x00000002    /* 14 */
+#define FM_PCD_PLCR_PAR_PWSEL_PERRPC          0x00000001    /* 15 */
+
+#define FM_PCD_PLCR_PAR_PMR_BRN_1TO1          0x0000   /* - Full bit replacement. {PBNUM[0:N-1]
+                                                           1-> 2^N specific locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_2TO2          0x1      /* - {PBNUM[0:N-2],PNUM[N-1]}.
+                                                           2-> 2^(N-1) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_4TO4          0x2      /* - {PBNUM[0:N-3],PNUM[N-2:N-1]}.
+                                                           4-> 2^(N-2) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_8TO8          0x3      /* - {PBNUM[0:N-4],PNUM[N-3:N-1]}.
+                                                           8->2^(N-3) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_16TO16        0x4      /* - {PBNUM[0:N-5],PNUM[N-4:N-1]}.
+                                                           16-> 2^(N-4) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_32TO32        0x5      /* {PBNUM[0:N-6],PNUM[N-5:N-1]}.
+                                                           32-> 2^(N-5) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_64TO64        0x6      /* {PBNUM[0:N-7],PNUM[N-6:N-1]}.
+                                                           64-> 2^(N-6) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_128TO128      0x7      /* {PBNUM[0:N-8],PNUM[N-7:N-1]}.
+                                                            128-> 2^(N-7) base locations. */
+#define FM_PCD_PLCR_PAR_PMR_BRN_256TO256      0x8      /* - No bit replacement for N=8. {PNUM[N-8:N-1]}.
+                                                            When N=8 this option maps all 256 profiles by the DISPATCH bus into one group. */
+
+#define FM_PCD_PLCR_PMR_V                     0x80000000
+#define PLCR_ERR_ECC_CAP                      0x80000000
+#define PLCR_ERR_ECC_TYPE_DOUBLE              0x40000000
+#define PLCR_ERR_ECC_PNUM_MASK                0x00000FF0
+#define PLCR_ERR_ECC_OFFSET_MASK              0x0000000F
+
+#define PLCR_ERR_UNINIT_CAP                   0x80000000
+#define PLCR_ERR_UNINIT_NUM_MASK              0x000000FF
+#define PLCR_ERR_UNINIT_PID_MASK              0x003f0000
+#define PLCR_ERR_UNINIT_ABSOLUTE_MASK         0x00008000
+
+/* shifts */
+#define PLCR_ERR_ECC_PNUM_SHIFT               4
+#define PLCR_ERR_UNINIT_PID_SHIFT             16
+
+#define FM_PCD_PLCR_PMR_BRN_SHIFT             16
+
+#define PLCR_PORT_WINDOW_SIZE(hardwarePortId)
+
+
+#endif /* __FM_PLCR_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index ff110d7..9b8f8e9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_pcd.c
 
@@ -44,6 +45,7 @@
 #include "fm_common.h"
 #include "fm_pcd.h"
 #include "fm_pcd_ipc.h"
+#include "fm_prs.h"
 
 
 t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
@@ -259,7 +261,7 @@ t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, boo
     GET_FM_PCD_PRS_PORT_ID(prsPortId, hardwarePortId);
     GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId);
 
-    if(include)
+    if (include)
         p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics |= bitMask;
     else
         p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics &= ~bitMask;
@@ -272,16 +274,18 @@ t_Error PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, boo
 t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId, bool include)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdIpcPrsIncludePort    prsIncludePortParams;
-    t_FmPcdIpcMsg               msg;
     t_Error                     err;
 
     SANITY_CHECK_RETURN_ERROR((hardwarePortId >=1 && hardwarePortId <= 16), E_INVALID_VALUE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcPrsIncludePort    prsIncludePortParams;
+        t_FmPcdIpcMsg               msg;
+
         prsIncludePortParams.hardwarePortId = hardwarePortId;
         prsIncludePortParams.include = include;
         memset(&msg, 0, sizeof(msg));
@@ -297,6 +301,9 @@ t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId
             RETURN_ERROR(MAJOR, err, NO_MSG);
         return E_OK;
     }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without IPC!"));
 
     return PrsIncludePortInStatistics(p_FmPcd, hardwarePortId, include);
 }
@@ -306,13 +313,14 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_Error                 err = E_OK;
     t_FmPcdIpcSwPrsLable    labelParams;
-    t_FmPcdIpcMsg           msg;
-    uint32_t                prsOffset = 0;
-    t_FmPcdIpcReply         reply;
-    uint32_t                replyLength;
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
     {
+        t_FmPcdIpcMsg           msg;
+        uint32_t                prsOffset = 0;
+        t_FmPcdIpcReply         reply;
+        uint32_t                replyLength;
+
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
         labelParams.enumHdr = (uint32_t)hdr;
@@ -328,7 +336,7 @@ uint32_t FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t inde
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(replyLength != sizeof(uint32_t) + sizeof(uint32_t))
+        if (replyLength != sizeof(uint32_t) + sizeof(uint32_t))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
         memcpy((uint8_t*)&prsOffset, reply.replyBody, sizeof(uint32_t));
@@ -350,7 +358,8 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPrsStatistics - guest mode!"));
         return;
     }
-    if(enable)
+
+    if (enable)
         WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, FM_PCD_PRS_PPSC_ALL_PORTS);
     else
         WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, 0);
@@ -445,7 +454,6 @@ t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
 t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcMsg       msg;
 
     DECLARE_DUMP;
 
@@ -453,18 +461,25 @@ t_Error FM_PCD_PrsDumpRegs(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        !p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs &&
+        p_FmPcd->h_IpcSession)
     {
+        t_FmPcdIpcMsg       msg;
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_PCD_PRS_DUMP_REGS;
         return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                    (uint8_t*)&msg,
-                                    sizeof(msg.msgId),
-                                    NULL,
-                                    NULL,
-                                    NULL,
-                                    NULL);
+                                 (uint8_t*)&msg,
+                                 sizeof(msg.msgId),
+                                 NULL,
+                                 NULL,
+                                 NULL,
+                                 NULL);
     }
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("running in \"guest-mode\" without neither IPC nor mapped register!"));
+
     DUMP_SUBTITLE(("\n"));
     DUMP_TITLE(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs, ("FmPcdPrsRegs Regs"));
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
new file mode 100644
index 0000000..1c886cc
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_prs.h
+
+ @Description   FM Parser private header
+*//***************************************************************************/
+#ifndef __FM_PRS_H
+#define __FM_PRS_H
+
+#include "std_ext.h"
+
+
+/***********************************************************************/
+/*          SW parser IP_FRAG patch                                    */
+/***********************************************************************/
+
+#if (DPAA_VERSION == 10)
+/* Version: 106.5 */
+#define SW_PRS_IP_FRAG_PATCH                           \
+{                                                      \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
+    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
+    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0, \
+    0x00,0x4A,0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x28,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x31,0x52,0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x53,0x8F,0x00,0x00,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
+    0x43,0x42,0x00,0x00,0x30,0x7E,0x43,0x42,0x00,0x3C, \
+    0x1B,0x5C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
+    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x1B,0x3B,0x30,0x7E,0x53,0x72,0x00,0x2B, \
+    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
+    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
+    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00, \
+    0x9B,0x8E,0x53,0x86,0x00,0x00,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00, \
+    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
+    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
+    0x00,0x55,0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x43,0x1B,0xC0,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
+    0x43,0xB7,0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11, \
+    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F, \
+    0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
+    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
+    0x28,0x43,0x06,0x00,0x1B,0x9A,0x00,0x03,0x00,0x02, \
+    0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0,0x00,0x4A, \
+    0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE,           \
+};
+
+#else
+/* version: 106.5 */
+#define SW_PRS_IP_FRAG_PATCH                           \
+{                                                      \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
+    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x2A,0x34,0xF5, \
+    0x00,0xFB,0xFF,0xFF,0x00,0x7F,0x00,0x00,0x00,0x00, \
+    0x2A,0x9F,0x34,0xB7,0x00,0xF9,0x00,0x00,0x01,0x00, \
+    0x00,0x00,0x00,0x00,0x2B,0x97,0x00,0x03,0x00,0x02, \
+    0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0,0x00,0x4F, \
+    0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+    0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x43,0x36,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+    0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x53,0x9D,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x50, \
+    0x00,0x00,0x30,0x7E,0x43,0x50,0x00,0x3C,0x1B,0x6A, \
+    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
+    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
+    0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
+    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
+    0x1B,0x49,0x30,0x7E,0x53,0x80,0x00,0x2B,0x32,0x11, \
+    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E, \
+    0x53,0x94,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x43,0x1B,0xDC,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xC5, \
+    0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
+    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x1B,0xA8,0x34,0xF5,0x00,0xFB,0xFF,0xFF, \
+    0x00,0x7F,0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7, \
+    0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00, \
+    0x2B,0x97,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01, \
+    0x32,0xC1,0x32,0xF0,0x00,0x4A,0x00,0x80,0x1F,0xFF, \
+    0x00,0x01,0x1B,0xFE,                               \
+};
+#endif /* (DPAA_VERSION == 10) */
+
+/****************************/
+/* Parser defines           */
+/****************************/
+/* masks */
+#define PRS_ERR_CAP                         0x80000000
+#define PRS_ERR_TYPE_DOUBLE                 0x40000000
+#define PRS_ERR_SINGLE_ECC_CNT_MASK         0x00FF0000
+#define PRS_ERR_ADDR_MASK                   0x000001FF
+#define FM_PCD_PRS_RPIMAC_EN                0x00000001
+#define FM_PCD_PRS_SINGLE_ECC               0x00004000
+#define FM_PCD_PRS_PORT_IDLE_STS            0xffff0000
+#define FM_PCD_PRS_DOUBLE_ECC               0x00004000
+#define FM_PCD_PRS_PPSC_ALL_PORTS           0xffff0000
+
+/* others */
+#define PRS_MAX_CYCLE_LIMIT                 8191
+#define PRS_SW_DATA                         0x00000800
+#define PRS_REGS_OFFSET                     0x00000840
+
+#define GET_FM_PCD_PRS_PORT_ID(prsPortId,hardwarePortId) \
+    prsPortId = (uint8_t)(hardwarePortId & 0x0f)
+
+#define GET_FM_PCD_INDEX_FLAG(bitMask, prsPortId)    \
+    bitMask = 0x80000000>>prsPortId
+
+
+#endif /* __FM_PRS_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index ffd597d..62cef06 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_port.c
 
@@ -86,8 +87,8 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
 #ifdef FM_NO_BACKUP_POOLS
     if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
-	if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("BackupBmPools"));
+        if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("BackupBmPools"));
 #endif /* FM_NO_BACKUP_POOLS */
         }
 
@@ -246,18 +247,18 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
     {
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
-	if ((p_FmPort->fmRevInfo.majorRev < 6) &&
+        if ((p_FmPort->fmRevInfo.majorRev < 6) &&
             (p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore != DEFAULT_notSupported))
                  /* this is an indication that user called config for this mode which is not supported in this integration */
-		RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("cheksumLastBytesIgnore is available for Rx & Tx ports only"));
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("cheksumLastBytesIgnore is available for Rx & Tx ports only"));
 #endif /* !FM_FRAME_END_PARAMS_FOR_OP */
 
 #ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
-	if ((!((p_FmPort->fmRevInfo.majorRev == 4) ||
+        if ((!((p_FmPort->fmRevInfo.majorRev == 4) ||
                (p_FmPort->fmRevInfo.majorRev >= 6))) &&
             (p_FmPort->fifoDeqPipelineDepth != DEFAULT_notSupported))
-		    /* this is an indication that user called config for this mode which is not supported in this integration */
-		RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
+                /* this is an indication that user called config for this mode which is not supported in this integration */
+                RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
     }
     /****************************************/
@@ -400,7 +401,6 @@ static void FmPortDriverParamFree(t_FmPort *p_FmPort)
     }
 }
 
-// TODO - ask why we save it in fmPortDriverParam and p_FmPort - Ganit
 static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 {
     t_FmExtPools                *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
@@ -514,7 +514,7 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
         tmpReg |= vector;
     }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     /* fill QbbPEV */
     if (p_BufPoolDepletion->poolsGrpModeEnable ||
         p_BufPoolDepletion->singlePoolModeEnable)
@@ -530,7 +530,7 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
         }
         tmpReg |= vector;
     }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     WRITE_UINT32(*p_BufPoolDepletionReg, tmpReg);
 
@@ -633,7 +633,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
         tmpReg = 0;
         tmpReg |= (((uint32_t)p_Params->bufMargins.startMargins) << BMI_EXT_BUF_MARG_START_SHIFT);
         tmpReg |= (((uint32_t)p_Params->bufMargins.endMargins) << BMI_EXT_BUF_MARG_END_SHIFT);
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if (p_Params->noScatherGather)
             tmpReg |= BMI_SG_DISABLE;
 #endif
@@ -997,7 +997,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
         }
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-		if(p_FmPort->fmRevInfo.majorRev != 4)
+        if(p_FmPort->fmRevInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
         switch(p_Params->deqPrefetchOption)
         {
@@ -1264,7 +1264,7 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     return E_OK;
 }
 
-static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
+static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrParams *p_HdrParams, uint32_t *p_SoftSeqAttachReg)
 {
     uint8_t                     hdrNum, Ipv4HdrNum;
     u_FmPcdHdrPrsOpts           *p_prsOpts;
@@ -1345,7 +1345,7 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
         {
             if(tmp & walking1Mask)
             {
-                p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = FmPcdKgGetSchemeSwId(p_FmPort->h_FmPcd, idx);
+                p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = idx;
                 p_SchemeBind->numOfSchemes++;
                 tmp &= ~walking1Mask;
             }
@@ -1357,9 +1357,8 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
     return tmp;
 }
 
-static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
+static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                             err = E_OK;
     uint32_t                            tmpReg;
     volatile uint32_t                   *p_BmiNia=NULL;
@@ -1376,7 +1375,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     uint32_t                            ccTreePhysOffset;
     t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    ASSERT_COND(p_FmPort);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
@@ -1488,7 +1487,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
                               p_PcdParams,
                               p_PcdParams->p_CcParams->h_CcTree,
                               &ccTreePhysOffset,
-                              h_FmPort);
+                              p_FmPort);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1525,7 +1524,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             schemeBind.schemesIds[i] = physicalSchemeId;
             /* build vector */
             p_FmPort->schemesPerPortVector |= 1 << (31 - (uint32_t)physicalSchemeId);
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
             /*because of the state that VSPE is defined per port - all PCD path should be according to this requirement
              if !VSPE - in port, for relevant scheme VSPE can not be set*/
             if(!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
@@ -1559,11 +1558,9 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
         tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
 
-        if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
-        {
+        if (p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
             /* update BMI HPNIA */
             WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_PLCR | tmpReg));
-        }
         else /* e_FM_PCD_SUPPORT_PLCR_ONLY */
             /* update BMI NIA */
             p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PLCR);
@@ -1625,7 +1622,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         }
 
         /* set start parsing offset */
-        /* WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset); */
+         WRITE_UINT32(*p_BmiPrsStartOffset, p_PcdParams->p_PrsParams->parsingOffset);
 
         /************************************/
         /* Parser port parameters           */
@@ -1746,7 +1743,8 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         for (i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
         {
             /* For all header set LCV as taken from netEnv*/
-            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,  FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
+            WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,
+                         FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
             /* set HXS register according to default+Additional params+protocol options */
             WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].softSeqAttach,  tmpHxs[i]);
         }
@@ -1768,7 +1766,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         /* enable parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, 0);
 
-        if(p_PcdParams->p_PrsParams->prsResultPrivateInfo)
+        if (p_PcdParams->p_PrsParams->prsResultPrivateInfo)
             p_FmPort->privateInfo = p_PcdParams->p_PrsParams->prsResultPrivateInfo;
 
     } /* end parser */
@@ -1781,25 +1779,28 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     for (i=0;i<FM_PORT_PRS_RESULT_NUM_OF_WORDS;i++)
     {
         if (!i)
-            WRITE_UINT32(*(p_BmiInitPrsResult), (uint32_t)(((uint32_t)p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
-                                                            | BMI_PRS_RESULT_HIGH));
+            WRITE_UINT32(*(p_BmiInitPrsResult),
+                         (uint32_t)(((uint32_t)p_FmPort->privateInfo << BMI_PR_PORTID_SHIFT)
+                                    | BMI_PRS_RESULT_HIGH));
         else
+        {
             if (i< FM_PORT_PRS_RESULT_NUM_OF_WORDS/2)
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_HIGH);
             else
                 WRITE_UINT32(*(p_BmiInitPrsResult+i), BMI_PRS_RESULT_LOW);
+        }
     }
 
     return E_OK;
 }
 
-static t_Error DeletePcd(t_Handle h_FmPort)
+static t_Error DeletePcd(t_FmPort *p_FmPort)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                             err = E_OK;
     volatile uint32_t                   *p_BmiNia=NULL;
+    volatile uint32_t                   *p_BmiPrsStartOffset = NULL;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+    ASSERT_COND(p_FmPort);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
@@ -1819,9 +1820,11 @@ static t_Error DeletePcd(t_Handle h_FmPort)
         case(e_FM_PORT_TYPE_RX_10G):
         case(e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
@@ -1835,6 +1838,8 @@ static t_Error DeletePcd(t_Handle h_FmPort)
 
     if(p_FmPort->pcdEngines | FM_PCD_PRS)
     {
+        WRITE_UINT32(*p_BmiPrsStartOffset, 0);
+
         /* stop parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
         /* wait for parser to be in idle state */
@@ -1871,6 +1876,145 @@ static t_Error DeletePcd(t_Handle h_FmPort)
     return E_OK;
 }
 
+static t_Error AttachPCD(t_FmPort *p_FmPort)
+{
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    ASSERT_COND(p_FmPort);
+
+/*TODO - to take care about the chnges that were made in the port because of the previously assigned tree.
+pndn, pnen ... maybe were changed because of the Tree requirement*/
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    /* check that current NIA is BMI to BMI */
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("may be called only for ports in BMI-to-BMI state."));
+
+    WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, p_FmPort->savedBmiFene);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
+    }
+    if(p_FmPort->requiredAction & UPDATE_NIA_FPNE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne, p_FmPort->savedBmiFpne);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
+    }
+    if(p_FmPort->requiredAction & UPDATE_NIA_CMNE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
+    }
+
+    return E_OK;
+}
+
+static t_Error DetachPCD(t_FmPort *p_FmPort)
+{
+    volatile uint32_t                   *p_BmiNia=NULL;
+
+    ASSERT_COND(p_FmPort);
+
+    /* get PCD registers pointers */
+    switch(p_FmPort->portType)
+    {
+        case(e_FM_PORT_TYPE_RX_10G):
+        case(e_FM_PORT_TYPE_RX):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
+            break;
+        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+            break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+
+/*TODO - not atomic - it seems that port has to be disabled*/
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
+                break;
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case(e_FM_PORT_TYPE_RX):
+            case(e_FM_PORT_TYPE_RX_10G):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+                break;
+           default:
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
+        }
+    }
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    {
+        switch(p_FmPort->portType)
+        {
+            case(e_FM_PORT_TYPE_TX_10G):
+            case(e_FM_PORT_TYPE_TX):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
+                break;
+            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
+        }
+    }
+
+    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+    }
+
+    if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    return E_OK;
+}
+
 
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
@@ -1947,70 +2091,6 @@ uint32_t FmPortGetPcdEngines(t_Handle h_FmPort)
     return ((t_FmPort*)h_FmPort)->pcdEngines;
 }
 
-t_Error FmPortAttachPCD(t_Handle h_FmPort)
-{
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t                   *p_BmiNia=NULL;
-
-/*TODO - to take care about the chnges that were made in the port because of the previously assigned tree.
-pndn, pnen ... maybe were changed because of the Tree requirement*/
-
-    /* get PCD registers pointers */
-    switch(p_FmPort->portType)
-    {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
-            break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-    }
-
-    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-
-    /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
-                     ("may be called only for ports in BMI-to-BMI state."));
-
-    WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
-
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
-
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
-
-    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
-    {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, p_FmPort->savedBmiFene);
-        else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
-    }
-    if(p_FmPort->requiredAction & UPDATE_NIA_FPNE)
-    {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne, p_FmPort->savedBmiFpne);
-        else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
-    }
-    if(p_FmPort->requiredAction & UPDATE_NIA_CMNE)
-    {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
-        else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
-    }
-
-    return E_OK;
-}
-
 t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcParams)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2264,9 +2344,9 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         p_FmPort->p_FmPortDriverParam->bufMargins.endMargins        = DEFAULT_PORT_BufMargins_endMargins;
         p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
         p_FmPort->p_FmPortDriverParam->forwardReuseIntContext       = DEFAULT_PORT_forwardIntContextReuse;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
-#endif /*DPAA_VERSION*/
+#endif /* (DPAA_VERSION >= 11) */
         break;
 
     case(e_FM_PORT_TYPE_TX):
@@ -2292,9 +2372,9 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 
     case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
-#endif /*DPAA_VERSION*/
+#endif /* (DPAA_VERSION >= 11) */
     case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
         p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
@@ -2320,8 +2400,8 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         return NULL;
     }
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-	if(p_FmPort->fmRevInfo.majorRev == 4)
-	p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
+    if(p_FmPort->fmRevInfo.majorRev == 4)
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     p_FmPort->imEn = p_FmPortParams->independentModeEnable;
@@ -2549,7 +2629,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 
     FmFreePortParams(p_FmPort->h_Fm, &fmParams);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if(FmVSPFree( p_FmPort->h_Fm,
                   p_FmPort->portType,
                   p_FmPort->portId) != E_OK)
@@ -2899,7 +2979,7 @@ t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
 
     return E_OK;
 }
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2914,7 +2994,7 @@ t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather)
 
     return E_OK;
 }
-#endif /*DPAA_VERSION*/
+#endif /* (DPAA_VERSION >= 11) */
 t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -3119,10 +3199,10 @@ uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
 
-    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
-    if(p_FmPort->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
+    if (p_FmPort->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
         return NULL;
 
     return (uint8_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.pcdInfoOffset);
@@ -3135,7 +3215,7 @@ t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
-    if(p_FmPort->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
+    if (p_FmPort->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
         return NULL;
 
     return (t_FmPrsResult *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.prsResultOffset);
@@ -3148,7 +3228,7 @@ uint64_t * FM_PORT_GetBufferTimeStamp(t_Handle h_FmPort, char *p_Data)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
-    if(p_FmPort->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
+    if (p_FmPort->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
         return NULL;
 
     return (uint64_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.timeStampOffset);
@@ -3158,10 +3238,10 @@ uint8_t * FM_PORT_GetBufferHashResult(t_Handle h_FmPort, char *p_Data)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
 
-    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, NULL);
 
-    if(p_FmPort->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
+    if (p_FmPort->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
         return NULL;
 
     return (uint8_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.hashResultOffset);
@@ -3228,7 +3308,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
         {
             WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
                          GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
-            RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+            RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable! QMI busy", p_FmPort->name));
         }
     }
 
@@ -3250,7 +3330,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
                          GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
         WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
 
-        RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+        RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable! BMI Busy", p_FmPort->name));
     }
 
     p_FmPort->enabled = 0;
@@ -4077,7 +4157,7 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
 /*       API Run-time PCD Control unit functions                             */
 /*****************************************************************************/
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
@@ -4127,7 +4207,6 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
     {
         case (e_FM_PORT_TYPE_RX_10G):
         case (e_FM_PORT_TYPE_RX):
-            /* TODO - for TxConf EBD should be set */
             p_BmiStorageProfileId = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid);
             p_BmiVspe = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfne);
 
@@ -4162,7 +4241,7 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
     WRITE_UINT32(*p_BmiVspe, tmpReg | BMI_SP_EN);
     return E_OK;
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
 {
@@ -4173,13 +4252,16 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
     ASSERT_COND(p_FmPort->h_FmPcd);
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
          return ERROR_CODE(E_BUSY);
+    }
 
-    if(numOfProfiles)
+    if (numOfProfiles)
     {
         err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
         if(err)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     /* set the port handle within the PCD policer, even if no profiles defined */
     FmPcdPortRegister(p_FmPort->h_FmPcd, h_FmPort, p_FmPort->hardwarePortId);
@@ -4195,7 +4277,10 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
     t_Error                     err = E_OK;
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
          return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdPlcrFreeProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
 
@@ -4234,7 +4319,11 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
     /* if we want to change to direct scheme, we need to check that this scheme is valid */
     if(p_FmPcdKgScheme->direct)
     {
@@ -4280,7 +4369,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PLCR , E_INVALID_STATE);
 
-    /* check relevancy of this routine  - only when policer is used
+    /* check relevance of this routine  - only when policer is used
     directly after BMI or Parser */
     if((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
@@ -4303,7 +4392,11 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
     if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
     {
         RELEASE_LOCK(p_FmPort->lock);
@@ -4367,6 +4460,18 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 
     if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
+        if (p_FmPort->h_IpReassemblyManip)
+        {
+            err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
+                                    h_CcTree,
+                                    NULL,
+                                    p_FmPort->h_IpReassemblyManip,
+                                    FALSE);
+            if (err != E_OK)
+            {
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+        }
         switch(p_FmPort->portType)
         {
             case(e_FM_PORT_TYPE_RX_10G):
@@ -4381,7 +4486,10 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         }
 
         if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-            return ERROR_CODE(E_BUSY);
+        {
+             DBG(TRACE, ("FM Port Try Lock - BUSY"));
+             return ERROR_CODE(E_BUSY);
+        }
         err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree, &ccTreePhysOffset, h_FmPort);
         if(err)
         {
@@ -4401,7 +4509,6 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 
 t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
 {
-
     t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error         err = E_OK;
 
@@ -4409,20 +4516,18 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
-
-    /* TODO - may add here checks for:
-        SP (or in sw: schemes)
-        CPP (or in sw clsPlan)
-        Parser enabled and configured(?)
-        Tree(?)
-        Profile - only if direct.
-        Scheme - only if direct
-    */
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
-    err = FmPortAttachPCD(h_FmPort);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
+    if (p_FmPort->h_IpReassemblyTree)
+        p_FmPort->pcdEngines |= FM_PCD_CC;
+
+    err = AttachPCD(h_FmPort);
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
@@ -4430,79 +4535,32 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
 
 t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
 {
-    t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
-    volatile uint32_t                   *p_BmiNia=NULL;
+    t_FmPort        *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error         err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
-
-    /* get PCD registers pointers */
-    switch(p_FmPort->portType)
-    {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
-            break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-    }
-
-    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
-/*TODO - not atomic - it seems that port has to be disabled*/
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
-        switch(p_FmPort->portType)
-        {
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
-                break;
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_RX):
-            case(e_FM_PORT_TYPE_RX_10G):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
-                break;
-           default:
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
-        }
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
     }
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    err = DetachPCD(h_FmPort);
+    if (err != E_OK)
     {
-        switch(p_FmPort->portType)
-        {
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
-                break;
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
-                break;
-            default:
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
-        }
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
-    {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
-        else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
-    }
+    if (p_FmPort->h_IpReassemblyTree)
+        p_FmPort->pcdEngines &= ~FM_PCD_CC;
+    RELEASE_LOCK(p_FmPort->lock);
 
-    if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
     return E_OK;
 }
 
@@ -4519,7 +4577,10 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
 
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
@@ -4542,21 +4603,20 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
              !p_PcdParams->p_CcParams)
         {
             /* No user-tree, need to build internal tree */
-            t_FmPcdCcTreeParams         *p_fmPcdCcTreeParams = NULL;
+            t_FmPcdCcTreeParams         *p_FmPcdCcTreeParams;
             t_FmPortPcdCcParams         fmPortPcdCcParams;
 
-            p_fmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
-            if(!p_fmPcdCcTreeParams)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_fmPcdCcTreeParams"));
+            p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
+            if(!p_FmPcdCcTreeParams)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
+            memset(p_FmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
 
-            memset(p_fmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
             memset(&fmPortPcdCcParams, 0, sizeof(t_FmPortPcdCcParams));
 
-            p_fmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
-            p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_fmPcdCcTreeParams);
+            p_FmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
+            p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
             if (!p_FmPort->h_IpReassemblyTree)
             {
-                XX_Free(p_fmPcdCcTreeParams);
                 RELEASE_LOCK(p_FmPort->lock);
                 RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM_PCD_CcBuildTree for IPR failed"));
             }
@@ -4568,10 +4628,18 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             fmPortPcdCcParams.h_CcTree = p_FmPort->h_IpReassemblyTree;
             p_PcdParams->p_CcParams = &fmPortPcdCcParams;
 
-            XX_Free(p_fmPcdCcTreeParams);
+            XX_Free(p_FmPcdCcTreeParams);
         }
         if (!p_PcdParams->p_CcParams)
+        {
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
+            RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
+        }
         err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
                                 p_PcdParams->p_CcParams->h_CcTree,
                                 p_PcdParams->h_NetEnv,
@@ -4579,20 +4647,59 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
                                 TRUE);
         if (err != E_OK)
         {
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+            RETURN_ERROR(MINOR, err, NO_MSG);
         }
     }
+
+    if (!FmPcdLockTryLockAll(p_FmPort->h_FmPcd))
+    {
+        if (p_FmPort->h_IpReassemblyTree)
+        {
+            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+            p_FmPort->h_IpReassemblyTree = NULL;
+        }
+        RELEASE_LOCK(p_FmPort->lock);
+        DBG(TRACE, ("Try LockAll - BUSY"));
+        return ERROR_CODE(E_BUSY);
+    }
+
     err = SetPcd(h_FmPort, p_PcdParams);
-    if(err)
+    if (err)
     {
+        if (p_FmPort->h_IpReassemblyTree)
+        {
+            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+            p_FmPort->h_IpReassemblyTree = NULL;
+        }
+        FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
         RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
     if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
         (p_PcdParams->p_PrsParams->includeInPrsStatistics))
-        FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+    {
+        err = FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
+        if (err)
+        {
+            DeletePcd(p_FmPort);
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
+            FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+        p_FmPort->includeInPrsStatistics = TRUE;
+    }
 
     FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
@@ -4613,6 +4720,13 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER | NIA_ENG_FM_CTL);
             if ((err = FmPortGetSetCcParams(p_FmPort, &fmPortGetSetCcParams)) != E_OK)
             {
+                DeletePcd(p_FmPort);
+                if (p_FmPort->h_IpReassemblyTree)
+                {
+                    FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                    p_FmPort->h_IpReassemblyTree = NULL;
+                }
+                FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
                 RELEASE_LOCK(p_FmPort->lock);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
@@ -4630,8 +4744,10 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
         }
 
+        FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
+
         /* Set pop-to-next-step nia */
-#if DPAA_VERSION < 3
+#if (DPAA_VERSION == 10)
         if (p_FmPort->fmRevInfo.majorRev < 6)
         {
             fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
@@ -4639,48 +4755,68 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         }
         else
         {
-#endif /* DPAA_VERSION < 3 */
+#endif /* (DPAA_VERSION == 10) */
         fmPortGetSetCcParams.getCcParams.type = GET_NIA_FPNE;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_CMNE;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
-#if DPAA_VERSION < 3
+#if (DPAA_VERSION == 10)
         }
-#endif /* DPAA_VERSION < 3 */
+#endif /* (DPAA_VERSION == 10) */
         if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
         {
+            DeletePcd(p_FmPort);
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MINOR, err, NO_MSG);
         }
 
-        /* Set the ORR bit (for order-restoration) */
-#if DPAA_VERSION < 3
-        if (p_FmPort->fmRevInfo.majorRev < 6)
-        {
-            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FENE;
-            /* Set frag-check nia */
-            fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ENG_FM_CTL | NIA_ORDER_RESTOR);
-        }
-        else
-        {
-#endif /* DPAA_VERSION < 3 */
-        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FPNE;
-        fmPortGetSetCcParams.setCcParams.nia = fmPortGetSetCcParams.getCcParams.nia | NIA_ORDER_RESTOR;
-#if DPAA_VERSION < 3
-        }
-#endif /* DPAA_VERSION < 3 */
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        if (p_FmPort->h_IpReassemblyManip)
         {
-            RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
+#if (DPAA_VERSION == 10)
+            if (p_FmPort->fmRevInfo.majorRev < 6)
+            {
+                fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FENE;
+                /* Set frag-check nia */
+                fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ENG_FM_CTL | NIA_ORDER_RESTOR);
+            }
+            else
+            {
+#endif /* (DPAA_VERSION == 10) */
+            /* Set the ORR bit (for order-restoration) */
+            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FPNE;
+            fmPortGetSetCcParams.setCcParams.nia = fmPortGetSetCcParams.getCcParams.nia | NIA_ORDER_RESTOR;
+#if (DPAA_VERSION == 10)
+            }
+#endif /* (DPAA_VERSION == 10) */
+            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            {
+                DeletePcd(p_FmPort);
+                if (p_FmPort->h_IpReassemblyTree)
+                {
+                    FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                    p_FmPort->h_IpReassemblyTree = NULL;
+                }
+                RELEASE_LOCK(p_FmPort->lock);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
         }
     }
+    else
+        FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
 
-    err = FmPortAttachPCD(h_FmPort);
+    err = AttachPCD(h_FmPort);
     if(err)
     {
         DeletePcd(p_FmPort);
         if (p_FmPort->h_IpReassemblyTree)
+        {
             FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+            p_FmPort->h_IpReassemblyTree = NULL;
+        }
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
@@ -4706,10 +4842,13 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
 
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
 
-    err = FM_PORT_DetachPCD(h_FmPort);
-    if(err)
+    err = DetachPCD(h_FmPort);
+    if (err)
     {
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -4718,16 +4857,28 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
     FmPcdDecNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
     /* we do it anyway, instead of checking if included */
-    if (FmIsMaster(p_FmPort->h_Fm) &&
-        (p_FmPort->pcdEngines & FM_PCD_PRS))
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
+        p_FmPort->includeInPrsStatistics)
+    {
         FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
+        p_FmPort->includeInPrsStatistics = FALSE;
+    }
+
+    if (!FmPcdLockTryLockAll(p_FmPort->h_FmPcd))
+    {
+        RELEASE_LOCK(p_FmPort->lock);
+        DBG(TRACE, ("Try LockAll - BUSY"));
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = DeletePcd(h_FmPort);
-    if(err)
+    FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
+    if (err)
     {
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
+
     if (p_FmPort->h_IpReassemblyTree)
     {
         err = FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
@@ -4736,8 +4887,8 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
+        p_FmPort->h_IpReassemblyTree = NULL;
     }
-
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
@@ -4767,7 +4918,10 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
 
     err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
     if (err == E_OK)
@@ -4811,7 +4965,11 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
     err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
     if (err == E_OK)
         p_FmPort->schemesPerPortVector &= ~tmpScmVec;
@@ -4855,7 +5013,11 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
-        return ERROR_CODE(E_BUSY);
+    {
+         DBG(TRACE, ("FM Port Try Lock - BUSY"));
+         return ERROR_CODE(E_BUSY);
+    }
+
     /* set the first header */
     GET_PRS_HDR_NUM(hdrNum, p_FmPcdPrsStart->firstPrsHdr);
     if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
@@ -5112,13 +5274,19 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
     int                 i;
     uint8_t             mod;
     uint32_t            tmpReg = 0;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     int                 j;
     t_Error             err;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
+
+
+
 #ifdef FM_NO_OP_OBSERVED_CGS
 
     if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
@@ -5148,7 +5316,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 
         tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         for(j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
         {
             if(p_CongestionGrps->pfcPrioritiesEn[i][j])
@@ -5156,7 +5324,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
                 priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j+1));
             }
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
     }
     for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
     {
@@ -5164,7 +5332,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
         /* each 32 congestion groups are represented by a register */
         if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
             tmpReg = opPort ? GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
-                              GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32]);
+                              GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)]);
 
         /* set in the register, the bit representing the relevant congestion group. */
 
@@ -5173,11 +5341,11 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 
             tmpReg |=  (0x00000001 << (uint32_t)mod);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
             err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm,i,priorityTmpArray[i]);
             if (err)
                 return err;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
         }
 
         if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
@@ -5185,7 +5353,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
             if (opPort)
                 WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
             else
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32], tmpReg);
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)], tmpReg);
         }
     }
 
@@ -5202,6 +5370,12 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
+    for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+        if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
+
+
+
 #ifdef FM_NO_OP_OBSERVED_CGS
     if ((p_FmPort->fmRevInfo.majorRev != 4) &&
         (p_FmPort->fmRevInfo.majorRev < 6))
@@ -5232,27 +5406,27 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
         /* each 32 congestion groups are represented by a register */
         if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
             tmpReg = opPort ?   GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
-                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32]);
+                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)]);
 
         /* set in the register, the bit representing the relevant congestion group. */
         if(tmpArray[i])
         {
             tmpReg &=  ~(0x00000001 << (uint32_t)mod);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
             {
                 t_Error err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm, i, 0);
                 if (err)
                     return err;
             }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
         }
         if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
         {
             if(opPort)
                 WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
             else
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32], tmpReg);
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[FM_PORT_CG_REG_NUM(i)], tmpReg);
         }
     }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 515636e..3684bab 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_port.h
 
@@ -148,6 +149,8 @@
 #define DEFAULT_PORT_ImfwExtStructsMemId            0
 #define DEFAULT_PORT_ImfwExtStructsMemAttr          MEMORY_ATTR_CACHEABLE
 
+#define FM_PORT_CG_REG_NUM(_cgId) (((FM_PORT_NUM_OF_CONGESTION_GRPS/32)-1)-_cgId/32)
+
 /**************************************************************************//**
  @Collection    PCD Engines
 *//***************************************************************************/
@@ -423,11 +426,11 @@ typedef _Packed struct
 /**************************************************************************//**
  @Description       BMI defines
 *//***************************************************************************/
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 #define BMI_SP_ID_MASK                          0xff000000
 #define BMI_SP_ID_SHIFT                         24
 #define BMI_SP_EN                               0x01000000
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 #define BMI_PORT_CFG_EN                         0x80000000
 #define BMI_PORT_CFG_EN_MACSEC                  0x00800000
@@ -562,10 +565,10 @@ typedef _Packed struct
 
 #define BMI_EXT_BUF_POOL_ID_SHIFT               FM_SP_EXT_BUF_POOL_ID_SHIFT
 #define BMI_TX_FIFO_MIN_FILL_SHIFT              16
-#define BMI_FIFO_PIPELINE_DEPTH_SHIFT        	12
+#define BMI_FIFO_PIPELINE_DEPTH_SHIFT           12
 #define BMI_TX_LOW_COMF_SHIFT                   0
 
-#define BMI_FRAME_END_CS_IGNORE_SHIFT        	24
+#define BMI_FRAME_END_CS_IGNORE_SHIFT           24
 
 #define BMI_PERFORMANCE_TASK_COMP_SHIFT         24
 #define BMI_PERFORMANCE_PORT_COMP_SHIFT         16
@@ -626,7 +629,7 @@ typedef _Packed struct
 #define PRS_TPID_DFLT                           0x91009100
 
 #define PRS_HDR_MPLS_LBL_INTER_EN               0x00200000
-#define PRS_HDR_IPV6_ROUTE_HDR_EN              	0x00008000
+#define PRS_HDR_IPV6_ROUTE_HDR_EN               0x00008000
 #define PRS_HDR_PPPOE_MTU_CHECK_EN              0x80000000
 #define PRS_HDR_UDP_PAD_REMOVAL                 0x80000000
 #define PRS_HDR_TCP_PAD_REMOVAL                 0x80000000
@@ -782,9 +785,9 @@ typedef struct {
     t_FmBufferPrefixContent             bufferPrefixContent;
      t_FmBackupBmPools                   *p_BackupBmPools;
     bool                                dontReleaseBuf;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool                                noScatherGather;
-#endif /*DPAA_VERSION*/
+#endif /* (DPAA_VERSION >= 11) */
 
 } t_FmPortDriverParam;
 
@@ -842,6 +845,7 @@ typedef struct {
     uint32_t                    savedBmiCmne;
     uint32_t                    savedNonRxQmiRegsPndn;
     int                         savedPrsStartOffset;
+    bool                        includeInPrsStatistics;
     uint16_t                    maxFrameLength;
     t_FmFmanCtrl                orFmanCtrl;
     t_FmPortRsrc                openDmas;
@@ -851,9 +855,10 @@ typedef struct {
     bool                        explicitUserSizeOfFifo;
     t_Handle                    h_IpReassemblyManip;
     t_Handle                    h_IpReassemblyTree;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool                        vspe;
-#endif
+#endif /* (DPAA_VERSION >= 11) */
+
     t_FmPortDriverParam         *p_FmPortDriverParam;
 } t_FmPort;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index e81eb1b..f07bed9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_port_im.c
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
index 27ee116..0d03916 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_rtc.c
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
index f35dc75..4c1a422 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_rtc.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
index 706753b..7bf04b7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
@@ -48,29 +48,7 @@
 #include "fm_common.h"
 
 
-#if DPAA_VERSION >= 3
-#ifdef UNDER_CONSTRUCTION_FM_GEN
-static uint32_t fm_vsp_get_statistics(fm_pcd_storage_profile_regs   *regs,
-                                      uint16_t                      index)
-{
-    fm_pcd_storage_profile_regs *sp_regs;
-    ASSERT_COND(regs);
-
-    sp_regs = &regs[index];
-    return GET_UINT32(sp_regs->fm_sp_acnt);
-}
-
-static void fm_vsp_set_statistics(  fm_pcd_storage_profile_regs *regs,
-                                    uint16_t                index,
-                                    uint32_t                value)
-{
-    fm_pcd_storage_profile_regs *sp_regs;
-    ASSERT_COND(regs);
-
-    sp_regs = &regs[index];
-    WRITE_UINT32(sp_regs->fm_sp_acnt, value);
-}
-#endif /* UNDER_CONSTRUCTION_FM_GEN */
+#if (DPAA_VERSION >= 11)
 
 static void fm_vsp_fill_entry(fm_pcd_storage_profile_regs   *regs,
                               uint16_t                      index,
@@ -166,7 +144,7 @@ static void fm_vsp_fill_entry(fm_pcd_storage_profile_regs   *regs,
     }
     WRITE_UINT32(sp_regs->fm_sp_mpd, tmp_reg);
 
-    /* fill dma attrubutes register */
+    /* fill dma attributes register */
     tmp_reg = 0;
     tmp_reg |= (uint32_t)fm_vsp_params->dma_swap_data << FM_SP_DMA_ATTR_SWP_SHIFT;
     tmp_reg |= (uint32_t)fm_vsp_params->int_context_cache_attr << FM_SP_DMA_ATTR_IC_CACHE_SHIFT;
@@ -219,7 +197,7 @@ static t_Error CheckParams(t_FmVspEntry *p_FmVspEntry)
 
     return err;
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 /*****************************************************************************/
@@ -265,7 +243,6 @@ void FmSpSetBufPoolsInAscOrderOfBufSizes(t_FmExtPools   *p_FmExtPools,
     }
 }
 
-// TODO - ask Ganit - SetExtBufferPools called for Rx and Op but parameters check only for Rx
 t_Error FmSpCheckBufPoolsParams(t_FmExtPools            *p_FmExtPools,
                                 t_FmBackupBmPools       *p_FmBackupBmPools,
                                 t_FmBufPoolDepletion    *p_FmBufPoolDepletion)
@@ -291,7 +268,7 @@ t_Error FmSpCheckBufPoolsParams(t_FmExtPools            *p_FmExtPools,
     if(!p_FmExtPools && (p_FmBackupBmPools || p_FmBufPoolDepletion))
           RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("backupBmPools ot bufPoolDepletion can not be defined without external pools"));
 
-    /* backup BM pools indication is valid only for some chip deriviatives
+    /* backup BM pools indication is valid only for some chip derivatives
        (limited by the config routine) */
     if(p_FmBackupBmPools)
     {
@@ -308,7 +285,6 @@ t_Error FmSpCheckBufPoolsParams(t_FmExtPools            *p_FmExtPools,
                     found = TRUE;
                     break;
                 }
-
             }
             if (!found)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("All p_BackupBmPools.poolIds must be included in extBufPools.extBufPool[n].id"));
@@ -500,12 +476,12 @@ t_Error FmSpBuildBufferStructure(t_FmSpIntContextDataCopy   *p_FmSpIntContextDat
     }
 
     if (p_FmSpIntContextDataCopy->size)
-		p_FmSpBufMargins->startMargins =
-			(uint16_t)(p_FmSpIntContextDataCopy->extBufOffset +
-					   p_FmSpIntContextDataCopy->size);
+        p_FmSpBufMargins->startMargins =
+            (uint16_t)(p_FmSpIntContextDataCopy->extBufOffset +
+                       p_FmSpIntContextDataCopy->size);
     else
-	/* No Internal Context passing, STartMargin is immediately after privateInfo */
-	p_FmSpBufMargins->startMargins = p_BufferPrefixContent->privDataSize;
+        /* No Internal Context passing, STartMargin is immediately after privateInfo */
+        p_FmSpBufMargins->startMargins = p_BufferPrefixContent->privDataSize;
 
     /* save extra space for manip in both external and internal buffers */
     if (p_BufferPrefixContent->manipExtraSpace)
@@ -536,7 +512,7 @@ t_Error FmSpBuildBufferStructure(t_FmSpIntContextDataCopy   *p_FmSpIntContextDat
 /*********************** End of inter-module routines ************************/
 
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /*****************************************************************************/
 /*              API routines                                                 */
 /*****************************************************************************/
@@ -805,28 +781,66 @@ t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBm
     return E_OK;
 }
 
-#ifdef UNDER_CONSTRUCTION_FM_GEN
-uint32_t FM_VSP_GetStatistics(t_Handle h_FmVsp)
+uint32_t FM_VSP_GetBufferDataOffset(t_Handle h_FmVsp)
 {
     t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmVsp, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmSpRegsBase, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, 0);
 
-    return fm_vsp_get_statistics(p_FmVspEntry->p_FmSpRegsBase, p_FmVspEntry->absoluteSpId);
+    return p_FmVspEntry->bufferOffsets.dataOffset;
 }
-t_Error FM_VSP_ModifyCounter(t_Handle h_FmVsp, uint32_t value)
+
+uint8_t * FM_VSP_GetBufferICInfo(t_Handle h_FmVsp, char *p_Data)
 {
     t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmVsp, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmSpRegsBase, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, NULL);
 
-    fm_vsp_set_statistics(p_FmVspEntry->p_FmSpRegsBase, p_FmVspEntry->absoluteSpId, value);
+    if (p_FmVspEntry->bufferOffsets.pcdInfoOffset == ILLEGAL_BASE)
+        return NULL;
 
-    return E_OK;
+    return (uint8_t *)PTR_MOVE(p_Data, p_FmVspEntry->bufferOffsets.pcdInfoOffset);
+}
+
+t_FmPrsResult * FM_VSP_GetBufferPrsResult(t_Handle h_FmVsp, char *p_Data)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, NULL);
+
+    if (p_FmVspEntry->bufferOffsets.prsResultOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (t_FmPrsResult *)PTR_MOVE(p_Data, p_FmVspEntry->bufferOffsets.prsResultOffset);
+}
+
+uint64_t * FM_VSP_GetBufferTimeStamp(t_Handle h_FmVsp, char *p_Data)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, NULL);
+
+    if (p_FmVspEntry->bufferOffsets.timeStampOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint64_t *)PTR_MOVE(p_Data, p_FmVspEntry->bufferOffsets.timeStampOffset);
 }
-#endif /* UNDER_CONSTRUCTION_FM_GEN */
-#endif /* DPAA_VERSION >= 3 */
+
+uint8_t * FM_VSP_GetBufferHashResult(t_Handle h_FmVsp, char *p_Data)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmVspEntry, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_STATE, NULL);
+
+    if (p_FmVspEntry->bufferOffsets.hashResultOffset == ILLEGAL_BASE)
+        return NULL;
+
+    return (uint8_t *)PTR_MOVE(p_Data, p_FmVspEntry->bufferOffsets.hashResultOffset);
+}
+
+#endif /* (DPAA_VERSION >= 11) */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 66e8a62..042e9b9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm.c
 
@@ -113,10 +114,10 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                      ("dmaWatchdog depends on FM clock. dmaWatchdog(in microseconds) * clk (in Mhz), may not exceed 0x08x", DMA_MAX_WATCHDOG));
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     if ((p_Fm->partVSPBase + p_Fm->partNumOfVSPs) > FM_VSP_MAX_NUM_OF_ENTRIES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partVSPBase+partNumOfVSPs out of range!!!"));
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     if(p_Fm->p_FmStateStruct->totalFifoSize % BMI_FIFO_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be divisible by %d", BMI_FIFO_UNITS));
@@ -647,7 +648,7 @@ t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
     return E_OK;
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error FmVSPSetWindow(t_Handle  h_Fm,
                                   uint8_t   hardwarePortId,
                                   uint8_t   baseStorageProfile,
@@ -700,13 +701,17 @@ static uint8_t FmVSPsAlloc(t_Handle  h_Fm, uint8_t base, uint8_t numOfStoragePro
     t_Fm    *p_Fm = (t_Fm *)h_Fm;
     uint8_t  profilesFound = 0;
     int     i     = 0;
+    uint32_t    intFlags;
 
     if (!numOfStorageProfiles)
         return E_OK;
-    if (numOfStorageProfiles>FM_VSP_MAX_NUM_OF_ENTRIES)
+
+    if ((numOfStorageProfiles>FM_VSP_MAX_NUM_OF_ENTRIES) ||
+        (base + numOfStorageProfiles > FM_VSP_MAX_NUM_OF_ENTRIES))
         return (uint8_t)ILLEGAL_BASE;
 
-    XX_LockSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+
     for (i = base; i < base + numOfStorageProfiles; i++)
         if (p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == (uint8_t)ILLEGAL_BASE)
             profilesFound++;
@@ -718,10 +723,10 @@ static uint8_t FmVSPsAlloc(t_Handle  h_Fm, uint8_t base, uint8_t numOfStoragePro
             p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = guestId;
     else
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         return (uint8_t)ILLEGAL_BASE;
     }
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
     return base;
 }
@@ -742,7 +747,7 @@ static void FmVSPsFree(t_Handle  h_Fm, uint8_t base, uint8_t numOfStorageProfile
             DBG(WARNING, ("Request for freeing storage profile window which wasn't allocated to this partition"));
     }
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
 
 static t_Error FmGuestHandleIpcMsgCB(t_Handle  h_Fm,
@@ -925,7 +930,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
         }
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         case (FM_VSP_ALLOC) :
         {
             t_FmIpcVspAllocParams   ipcVspAllocParams;
@@ -962,7 +967,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
                                                   FmIpcSetCongestionGroupPfcPriority.priorityBitMap);
             return err;
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
         case (FM_FREE_PORT):
         {
             t_FmInterModulePortFreeParams   portParams;
@@ -1333,7 +1338,7 @@ uintptr_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm)
     return (p_Fm->baseAddr + FM_MM_PLCR);
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 uintptr_t FmGetVSPBaseAddr(t_Handle h_Fm)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
@@ -1342,7 +1347,7 @@ uintptr_t FmGetVSPBaseAddr(t_Handle h_Fm)
 
     return p_Fm->vspBaseAddr;
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
 t_Handle FmGetMuramHandle(t_Handle h_Fm)
 {
@@ -1396,13 +1401,14 @@ void FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
     p_FmPhysAddr->high = (uint8_t)((p_Fm->fmMuramPhysBaseAddr & 0x000000ff00000000LL) >> 32);
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error FmVSPFree(  t_Handle        h_Fm,
                     e_FmPortType    portType,
                     uint8_t         portId)
 {
     t_Fm           *p_Fm = (t_Fm *)h_Fm;
     uint8_t        swPortIndex, hardwarePortId, first, numOfVSPs, i;
+    uint32_t        intFlags;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
@@ -1412,12 +1418,12 @@ t_Error FmVSPFree(  t_Handle        h_Fm,
     numOfVSPs = p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
     first = p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
 
-    XX_LockSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     for(i = first; i < first + numOfVSPs; i++)
            p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
 
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
     p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = 0;
     p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase = 0;
@@ -1432,7 +1438,7 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
 {
     t_Fm           *p_Fm = (t_Fm *)h_Fm;
     t_Error        err = E_OK;
-    uint32_t       profilesFound;
+    uint32_t       profilesFound, intFlags;
     uint8_t        first, i;
     uint8_t        log2Num;
     uint8_t        swPortIndex, hardwarePortId;
@@ -1448,30 +1454,27 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
     if (!POWER_OF_2(numOfVSPs))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
 
-    XX_LockSpinlock(p_Fm->h_Spinlock);
+    LOG2((uint64_t)numOfVSPs, log2Num);
 
-    if (p_Fm->partVSPBase == 0)
+    if ((log2Num == 0) || (p_Fm->partVSPBase == 0))
         first = 0;
-    else if (p_Fm->partVSPBase <= numOfVSPs)
-      first = numOfVSPs ;
     else
-    {
-        for (i = p_Fm->partVSPBase; i < p_Fm->partNumOfVSPs; i++)
-        {
-            if (POWER_OF_2(i))
-            {
-                first = i;
-                break;
-            }
-        }
-    }
-    if (first>= (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
-    {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        first = 1<<log2Num;
+
+    if (first > (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
-    }
+
+    if (first<p_Fm->partVSPBase)
+        while(first < p_Fm->partVSPBase)
+            first = first + numOfVSPs;
+
+    if ((first + numOfVSPs ) > (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
+
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+
     profilesFound = 0;
-    for (i=first;i<p_Fm->partNumOfVSPs;)
+    for (i=first; i < p_Fm->partVSPBase + p_Fm->partNumOfVSPs;)
     {
         if (!p_Fm->p_FmSp->profiles[i].profilesMng.allocated)
         {
@@ -1492,12 +1495,10 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
             p_Fm->p_FmSp->profiles[i].profilesMng.allocated = TRUE;
     else
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
     }
 
-    LOG2((uint64_t)numOfVSPs, log2Num);
-
     SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
@@ -1507,7 +1508,9 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
     if ((err = FmVSPSetWindow(h_Fm,hardwarePortId, first,log2Num)) != E_OK)
         for(i = first; i < first + numOfVSPs; i++)
             p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
+
     return err;
 }
 
@@ -1794,11 +1797,10 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
 {
 
     t_Fm                        *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                    tmpReg = 0;
+    uint32_t                    tmpReg = 0, intFlags;
     t_Error                     err;
     t_FmIpcPortNumOfFmanCtrls   params;
     t_FmIpcMsg                  msg;
-    unsigned long               flags;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((numOfFmanCtrls > 0) && (numOfFmanCtrls < 3)) , E_INVALID_HANDLE);
@@ -1822,7 +1824,7 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
         return E_OK;
     }
 
-    flags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
 
@@ -1832,12 +1834,10 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
         tmpReg = FPM_PORT_FM_CTL2 | FPM_PORT_FM_CTL1;
 
     /* order restoration */
-
-
     tmpReg |= (orFmanCtrl << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | orFmanCtrl;
 
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
-    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
     return E_OK;
 }
@@ -1845,7 +1845,7 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
 t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortParams)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                tmpReg;
+    uint32_t                tmpReg, intFlags;
     uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
     t_FmIpcPortInInitParams portInParams;
     t_FmIpcPhysAddr         ipcPhysAddr;
@@ -1853,7 +1853,6 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     t_FmIpcMsg              msg;
     t_FmIpcReply            reply;
     uint32_t                replyLength;
-    unsigned long           flags;
 
     if(p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -1892,7 +1891,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    flags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     if(p_PortParams->independentMode)
     {
@@ -1906,7 +1905,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     {
         if(p_Fm->hcPortInitialized)
         {
-            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
         }
         else
@@ -1917,7 +1916,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfTasks, p_PortParams->numOfExtraTasks, TRUE);
     if(err)
     {
-        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1963,7 +1962,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     {
         if(p_Fm->p_FmStateStruct->lowEndRestriction)
         {
-            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
         }
         else
@@ -1978,14 +1977,14 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
                             TRUE);
     if(err)
     {
-        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     err = FmSetNumOfOpenDmas(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfOpenDmas, p_PortParams->numOfExtraOpenDmas, TRUE);
     if(err)
     {
-        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -2031,7 +2030,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         }
 
     FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
-    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
     return E_OK;
 }
@@ -2039,13 +2038,12 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                tmpReg;
+    uint32_t                tmpReg, intFlags;
     uint8_t                 hardwarePortId = p_PortParams->hardwarePortId;
     uint8_t                 numOfTasks;
     t_Error                 err;
     t_FmIpcPortFreeParams   portParams;
     t_FmIpcMsg              msg;
-    unsigned long           flags;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -2068,7 +2066,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     }
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    flags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
+    intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
@@ -2140,7 +2138,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
         p_Fm->p_FmStateStruct->lowEndRestriction = FALSE;
 #endif /* FM_LOW_END_RESTRICTION */
-    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 }
 
 t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled)
@@ -2710,7 +2708,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     return E_OK;
 }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 
 t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
                                   e_FmPortType    portType,
@@ -2756,7 +2754,7 @@ void VspValidateProfileSw(t_Handle h_Fm, uint16_t absoluteProfileId)
     ASSERT_COND(!p_Fm->p_FmSp->profiles[absoluteProfileId].valid);
     p_Fm->p_FmSp->profiles[absoluteProfileId].valid = TRUE;
 }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
@@ -2953,11 +2951,11 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         memcpy(p_Fm->p_FmDriverParam->firmware.p_Code, p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
     }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     p_Fm->partVSPBase   = p_FmParam->partVSPBase;
     p_Fm->partNumOfVSPs = p_FmParam->partNumOfVSPs;
     p_Fm->vspBaseAddr = p_FmParam->vspBaseAddr;
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     return p_Fm;
 }
@@ -2983,7 +2981,7 @@ t_Error FM_Init(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     p_Fm->p_FmSp = (t_FmSp*)XX_Malloc(sizeof(t_FmSp));
     if (!p_Fm->p_FmSp)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation for internal data structure failed"));
@@ -2991,7 +2989,7 @@ t_Error FM_Init(t_Handle h_Fm)
     memset(p_Fm->p_FmSp, 0, sizeof(t_FmSp));
     for (i = 0; i < FM_VSP_MAX_NUM_OF_ENTRIES; i++)
         p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     if(p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -3073,7 +3071,7 @@ t_Error FM_Init(t_Handle h_Fm)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No baseAddr configured for guest without IPC"));
         }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if (p_Fm->h_IpcSessions[p_Fm->guestId])
         {
             t_FmIpcVspAllocParams   fmIpcVspAllocParams;
@@ -3106,7 +3104,7 @@ t_Error FM_Init(t_Handle h_Fm)
         }
         else
             DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
         XX_Free(p_Fm->p_FmDriverParam);
         p_Fm->p_FmDriverParam = NULL;
@@ -3236,11 +3234,11 @@ t_Error FM_Init(t_Handle h_Fm)
     WRITE_BLOCK(UINT_TO_PTR(p_Fm->resAddr), 0, 256);
 #endif /* FM_CAPWAP_SUPPORT */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     p_Fm->partVSPBase = FmVSPsAlloc(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
     if (p_Fm->partVSPBase == ILLEGAL_BASE)
         DBG(WARNING, ("partition VSPs allocation is FAILED"));
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     /* General FM driver initialization */
     p_Fm->fmMuramPhysBaseAddr = (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->baseAddr + FM_MM_MURAM)));
@@ -3593,7 +3591,7 @@ t_Error FM_Free(t_Handle h_Fm)
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
         if (p_Fm->h_IpcSessions[0])
         {
             t_FmIpcMsg          msg;
@@ -3623,7 +3621,7 @@ t_Error FM_Free(t_Handle h_Fm)
             if (err != E_OK)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
         }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
         XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
 
@@ -3663,7 +3661,7 @@ t_Error FM_Free(t_Handle h_Fm)
         }
     }
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     FmVSPsFree(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
 
     if (p_Fm->p_FmSp)
@@ -3671,7 +3669,7 @@ t_Error FM_Free(t_Handle h_Fm)
         XX_Free(p_Fm->p_FmSp);
         p_Fm->p_FmSp = NULL;
     }
-#endif /* DPAA_VERSION >= 3 */
+#endif /*(DPAA_VERSION >= 11)*/
 
     if (p_Fm->h_Spinlock)
         XX_FreeSpinlock(p_Fm->h_Spinlock);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
index 9ccadcb..5854b9b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm.h
 
@@ -124,14 +125,15 @@ switch(exception){                                          \
                                             FM_EX_BMI_STORAGE_PROFILE_ECC   |\
                                             FM_EX_BMI_STATISTICS_RAM_ECC    |\
                                             FM_EX_IRAM_ECC                  |\
-                                            FM_EX_MURAM_ECC 				|\
+                                            FM_EX_MURAM_ECC                 |\
                                             FM_EX_BMI_DISPATCH_RAM_ECC      |\
                                             FM_EX_QMI_DOUBLE_ECC            |\
                                             FM_EX_QMI_SINGLE_ECC)
 
 
-#define DEFAULT_totalFifoSize(major)       ((major != 0) ?  (BMI_MAX_FIFO_SIZE*3/4):0)
-
+#define DEFAULT_totalFifoSize(major)       (((major == 2) || (major == 5))  ?   \
+                                            (100*KILOBYTE):((major == 6) ?      \
+                                            (288*KILOBYTE):((major == 4) ? (44*KILOBYTE):(122*KILOBYTE))))
 
 #define DEFAULT_eccEnable                   FALSE
 #define DEFAULT_dispLimit                   0
@@ -174,6 +176,57 @@ switch(exception){                                          \
 #define DEFAULT_mtu                         9600
 
 /**************************************************************************//**
+ @Collection   Defines used for enabling/disabling FM interrupts
+ @{
+*//***************************************************************************/
+typedef uint32_t t_FmBlockErrIntrEnable;
+
+#define ERR_INTR_EN_DMA         0x00010000
+#define ERR_INTR_EN_FPM         0x80000000
+#define ERR_INTR_EN_BMI         0x00800000
+#define ERR_INTR_EN_QMI         0x00400000
+#define ERR_INTR_EN_PRS         0x00200000
+#define ERR_INTR_EN_KG          0x00100000
+#define ERR_INTR_EN_PLCR        0x00080000
+#define ERR_INTR_EN_MURAM       0x00040000
+#define ERR_INTR_EN_IRAM        0x00020000
+#define ERR_INTR_EN_10G_MAC0    0x00008000
+#define ERR_INTR_EN_10G_MAC1    0x00000040
+#define ERR_INTR_EN_1G_MAC0     0x00004000
+#define ERR_INTR_EN_1G_MAC1     0x00002000
+#define ERR_INTR_EN_1G_MAC2     0x00001000
+#define ERR_INTR_EN_1G_MAC3     0x00000800
+#define ERR_INTR_EN_1G_MAC4     0x00000400
+#define ERR_INTR_EN_1G_MAC5     0x00000200
+#define ERR_INTR_EN_1G_MAC6     0x00000100
+#define ERR_INTR_EN_1G_MAC7     0x00000080
+#define ERR_INTR_EN_MACSEC_MAC0 0x00000001
+
+typedef uint32_t t_FmBlockIntrEnable;
+
+#define INTR_EN_QMI             0x40000000
+#define INTR_EN_PRS             0x20000000
+#define INTR_EN_PLCR            0x08000000
+#define INTR_EN_1G_MAC0         0x00080000
+#define INTR_EN_1G_MAC1         0x00040000
+#define INTR_EN_1G_MAC2         0x00020000
+#define INTR_EN_1G_MAC3         0x00010000
+#define INTR_EN_1G_MAC4         0x00000040
+#define INTR_EN_1G_MAC5         0x00000020
+#define INTR_EN_1G_MAC6         0x00000008
+#define INTR_EN_1G_MAC7         0x00000002
+#define INTR_EN_10G_MAC0        0x00200000
+#define INTR_EN_10G_MAC1        0x00100000
+#define INTR_EN_REV0            0x00008000
+#define INTR_EN_REV1            0x00004000
+#define INTR_EN_REV2            0x00002000
+#define INTR_EN_REV3            0x00001000
+#define INTR_EN_BRK             0x00000080
+#define INTR_EN_TMR             0x01000000
+#define INTR_EN_MACSEC_MAC0     0x00000001
+/* @} */
+
+/**************************************************************************//**
  @Description       Modules registers offsets
 *//***************************************************************************/
 #define FM_MM_MURAM             0x00000000
@@ -187,9 +240,9 @@ switch(exception){                                          \
 #define FM_MM_IMEM              0x000C4000
 #define FM_MM_CGP               0x000DB000
 #define FM_MM_TRB(i)            (0x000D0200 + 0x400 * (i))
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 #define FM_MM_SP                0x000dc000
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 /**************************************************************************//**
@@ -615,7 +668,7 @@ typedef _Packed struct t_FmTrbRegs
 #define TRB_TCRH_ENABLE_COUNTERS    0x84008000
 #define TRB_TCRH_DISABLE_COUNTERS   0x8400C000
 #define TRB_TCRL_RESET              0x20000000
-#define TRB_TCRL_UTIL               0x00000800
+#define TRB_TCRL_UTIL               0x00000400
 
 typedef struct {
     void        (*f_Isr) (t_Handle h_Arg, uint32_t event);
@@ -698,7 +751,7 @@ typedef struct
     uint16_t                    macMaxFrameLengths1G[FM_MAX_NUM_OF_1G_MACS];
 } t_FmStateStruct;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 typedef struct t_FmMapParam {
     uint16_t        profilesBase;
     uint16_t        numOfProfiles;
@@ -722,7 +775,7 @@ typedef struct t_FmSp {
     t_FmMapParam    portsMapping[FM_MAX_NUM_OF_PORTS];
 } t_FmSp;
 
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 typedef struct t_Fm
@@ -754,12 +807,12 @@ typedef struct t_Fm
     t_Handle                    h_Spinlock;
     bool                        recoveryMode;
     t_FmStateStruct             *p_FmStateStruct;
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     t_FmSp                      *p_FmSp;
     uint8_t                     partNumOfVSPs;
     uint8_t                     partVSPBase;
     uintptr_t                   vspBaseAddr;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /* un-needed for recovery */
     t_FmDriverParam             *p_FmDriverParam;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index e63c104..6220908 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_ipc.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
index a42fa8a..a1cbe3f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          FM_muram.c
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index b273931..0694de5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          fm_common.h
 
@@ -44,6 +45,7 @@
 #include "fm_ext.h"
 #include "fm_port_ext.h"
 
+
 #define e_FM_PORT_TYPE_OH_HOST_COMMAND      e_FM_PORT_TYPE_DUMMY
 
 #define CLS_PLAN_NUM_PER_GRP                        8
@@ -228,19 +230,16 @@ typedef uint32_t t_FmFmanCtrl;
 
 
 
-
-#define NUM_OF_SCRATCH_POOL_BUFFERS     1000 /*TODO - Change it!!*/
-
 typedef struct t_FmPcdCcFragScratchPoolCmdParams {
     uint32_t    numOfBuffers;
     uint8_t     bufferPoolId;
-}t_FmPcdCcFragScratchPoolCmdParams;
+} t_FmPcdCcFragScratchPoolCmdParams;
 
 typedef struct t_FmPcdCcIpReassmTimeoutParams {
     bool        activate;
     uint8_t     tsbs;
     uint32_t    iprcpt;
-}t_FmPcdCcIpReassmTimeoutParams;
+} t_FmPcdCcIpReassmTimeoutParams;
 
 typedef struct {
     uint8_t             baseEntry;
@@ -370,58 +369,6 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_KG_NIA                           0x04000000
 /* @} */
 
-/**************************************************************************//**
- @Collection   Defines used for enabling/disabling FM interrupts
- @{
-*//***************************************************************************/
-typedef uint32_t t_FmBlockErrIntrEnable;
-
-#define ERR_INTR_EN_DMA         0x00010000
-#define ERR_INTR_EN_FPM         0x80000000
-#define ERR_INTR_EN_BMI         0x00800000
-#define ERR_INTR_EN_QMI         0x00400000
-#define ERR_INTR_EN_PRS         0x00200000
-#define ERR_INTR_EN_KG          0x00100000
-#define ERR_INTR_EN_PLCR        0x00080000
-#define ERR_INTR_EN_MURAM       0x00040000
-#define ERR_INTR_EN_IRAM        0x00020000
-#define ERR_INTR_EN_10G_MAC0    0x00008000
-#define ERR_INTR_EN_10G_MAC1    0x00000040
-#define ERR_INTR_EN_1G_MAC0     0x00004000
-#define ERR_INTR_EN_1G_MAC1     0x00002000
-#define ERR_INTR_EN_1G_MAC2     0x00001000
-#define ERR_INTR_EN_1G_MAC3     0x00000800
-#define ERR_INTR_EN_1G_MAC4     0x00000400
-#define ERR_INTR_EN_1G_MAC5     0x00000200
-#define ERR_INTR_EN_1G_MAC6     0x00000100
-#define ERR_INTR_EN_1G_MAC7     0x00000080
-#define ERR_INTR_EN_MACSEC_MAC0 0x00000001
-
-
-typedef uint32_t t_FmBlockIntrEnable;
-
-#define INTR_EN_QMI             0x40000000
-#define INTR_EN_PRS             0x20000000
-#define INTR_EN_PLCR            0x08000000
-#define INTR_EN_1G_MAC0         0x00080000
-#define INTR_EN_1G_MAC1         0x00040000
-#define INTR_EN_1G_MAC2         0x00020000
-#define INTR_EN_1G_MAC3         0x00010000
-#define INTR_EN_1G_MAC4         0x00000040
-#define INTR_EN_1G_MAC5         0x00000020
-#define INTR_EN_1G_MAC6         0x00000008
-#define INTR_EN_1G_MAC7         0x00000002
-#define INTR_EN_10G_MAC0        0x00200000
-#define INTR_EN_10G_MAC1        0x00100000
-#define INTR_EN_REV0            0x00008000
-#define INTR_EN_REV1            0x00004000
-#define INTR_EN_REV2            0x00002000
-#define INTR_EN_REV3            0x00001000
-#define INTR_EN_BRK             0x00000080
-#define INTR_EN_TMR             0x01000000
-#define INTR_EN_MACSEC_MAC0     0x00000001
-/* @} */
-
 #define FM_MAX_NUM_OF_PORTS     (FM_MAX_NUM_OF_OH_PORTS +     \
                                  FM_MAX_NUM_OF_1G_RX_PORTS +  \
                                  FM_MAX_NUM_OF_10G_RX_PORTS + \
@@ -487,11 +434,11 @@ typedef uint32_t t_FmBlockIntrEnable;
 /**************************************************************************//**
  @Description       Port Id defines
 *//***************************************************************************/
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
 #define BASE_OH_PORTID              1
 #else
 #define BASE_OH_PORTID              2
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 #define BASE_1G_RX_PORTID           8
 #define BASE_10G_RX_PORTID          0x10
 #define BASE_1G_TX_PORTID           0x28
@@ -674,305 +621,20 @@ switch(hdr)                                                 \
 }
 
 /***********************************************************************/
-/*          SW parser IP_FRAG patch                                    */
+/*          SW parser patch flags                                      */
 /***********************************************************************/
-#if (DPAA_VERSION == 2)
-/* Version: 106.5 */
-#define SW_PRS_IP_FRAG_PATCH                           \
-{                                                      \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
-    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
-    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0, \
-    0x00,0x4A,0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x28,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x53,0x8F,0x00,0x00,0x32,0xC1,0x00,0x55, \
-    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
-    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
-    0x43,0x42,0x00,0x00,0x30,0x7E,0x43,0x42,0x00,0x3C, \
-    0x1B,0x5C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
-    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
-    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
-    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x1B,0x3B,0x30,0x7E,0x53,0x72,0x00,0x2B, \
-    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00, \
-    0x9B,0x8E,0x53,0x86,0x00,0x00,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
-    0x00,0x55,0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x43,0x1B,0xC0,0x32,0xC1,0x00,0x55, \
-    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
-    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
-    0x43,0xB7,0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F, \
-    0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
-    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
-    0x28,0x43,0x06,0x00,0x1B,0x9A,0x00,0x03,0x00,0x02, \
-    0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0,0x00,0x4A, \
-    0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE,           \
-};
+#if (DPAA_VERSION == 10)
 #define IP_FRAG_SW_PATCH_IPv4                   0x300
 #define IP_FRAG_SW_PATCH_IPv6                   0x31E
+
 #else
-/* version: 106.5 */
-#define SW_PRS_IP_FRAG_PATCH                           \
-{                                                      \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
-    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x2A,0x34,0xF5, \
-    0x00,0xFB,0xFF,0xFF,0x00,0x7F,0x00,0x00,0x00,0x00, \
-    0x2A,0x9F,0x34,0xB7,0x00,0xF9,0x00,0x00,0x01,0x00, \
-    0x00,0x00,0x00,0x00,0x2B,0x97,0x00,0x03,0x00,0x02, \
-    0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0,0x00,0x4F, \
-    0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE,0x31,0x52, \
-    0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00,0x00,0x00, \
-    0x43,0x36,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52, \
-    0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00, \
-    0x53,0x9D,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06, \
-    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x50, \
-    0x00,0x00,0x30,0x7E,0x43,0x50,0x00,0x3C,0x1B,0x6A, \
-    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
-    0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
-    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
-    0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
-    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
-    0x1B,0x49,0x30,0x7E,0x53,0x80,0x00,0x2B,0x32,0x11, \
-    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
-    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E, \
-    0x53,0x94,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55, \
-    0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x43,0x1B,0xDC,0x32,0xC1,0x00,0x55,0x00,0x06, \
-    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
-    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xC5, \
-    0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
-    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
-    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
-    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
-    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
-    0x06,0x00,0x1B,0xA8,0x34,0xF5,0x00,0xFB,0xFF,0xFF, \
-    0x00,0x7F,0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7, \
-    0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00, \
-    0x2B,0x97,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01, \
-    0x32,0xC1,0x32,0xF0,0x00,0x4A,0x00,0x80,0x1F,0xFF, \
-    0x00,0x01,0x1B,0xFE,                               \
-};
 #define IP_FRAG_SW_PATCH_IPv4                   0x300
 #define IP_FRAG_SW_PATCH_IPv6                   0x32C
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
 
-/***********************************************************************/
-/*          Policer defines                                            */
-/***********************************************************************/
-#define FM_PCD_PLCR_PAR_GO                    0x80000000
-#define FM_PCD_PLCR_PAR_PWSEL_MASK            0x0000FFFF
-#define FM_PCD_PLCR_PAR_R                     0x40000000
-
-/* shifts */
-#define FM_PCD_PLCR_PAR_PNUM_SHIFT            16
-
-
-/***********************************************************************/
-/*          Keygen defines                                             */
-/***********************************************************************/
-/* maskes */
-#if DPAA_VERSION >= 3
-#define KG_SCH_VSP_SHIFT_MASK                   0x0003f000
-#define KG_SCH_OM_VSPE                          0x00000001
-#define KG_SCH_VSP_NO_KSP_EN                    0x80000000
-
-#define MAX_SP_SHIFT                            23
-#define KG_SCH_VSP_MASK_SHIFT                   12
-#define KG_SCH_VSP_SHIFT                        24
-#endif /* DPAA_VERSION >= 3 */
-
-#define KG_SCH_PP_SHIFT_HIGH                    0x80000000
-#define KG_SCH_PP_NO_GEN                        0x10000000
-#define KG_SCH_PP_SHIFT_LOW                     0x0000F000
-#define KG_SCH_MODE_NIA_PLCR                    0x40000000
-#define KG_SCH_GEN_EXTRACT_TYPE                 0x00008000
-#define KG_SCH_BITMASK_MASK                     0x000000FF
-#define KG_SCH_GEN_VALID                        0x80000000
-#define KG_SCH_GEN_MASK                         0x00FF0000
-#define FM_PCD_KG_KGAR_ERR                      0x20000000
-#define FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY       0x01000000
-#define FM_PCD_KG_KGAR_SEL_PORT_ENTRY           0x02000000
-#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP         0x00008000
-#define FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP        0x00004000
-#define FM_PCD_KG_KGAR_WSEL_MASK                0x0000FF00
-#define KG_SCH_HASH_CONFIG_NO_FQID              0x80000000
-#define KG_SCH_HASH_CONFIG_SYM                  0x40000000
-
-#define FM_PCD_KG_KGAR_GO                       0x80000000
-#define FM_PCD_KG_KGAR_READ                     0x40000000
-#define FM_PCD_KG_KGAR_WRITE                    0x00000000
-#define FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY         0x00000000
-#define FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT   0x00008000
-
-
-typedef uint32_t t_KnownFieldsMasks;
-
-#define KG_SCH_KN_PORT_ID                   0x80000000
-#define KG_SCH_KN_MACDST                    0x40000000
-#define KG_SCH_KN_MACSRC                    0x20000000
-#define KG_SCH_KN_TCI1                      0x10000000
-#define KG_SCH_KN_TCI2                      0x08000000
-#define KG_SCH_KN_ETYPE                     0x04000000
-#define KG_SCH_KN_PPPSID                    0x02000000
-#define KG_SCH_KN_PPPID                     0x01000000
-#define KG_SCH_KN_MPLS1                     0x00800000
-#define KG_SCH_KN_MPLS2                     0x00400000
-#define KG_SCH_KN_MPLS_LAST                 0x00200000
-#define KG_SCH_KN_IPSRC1                    0x00100000
-#define KG_SCH_KN_IPDST1                    0x00080000
-#define KG_SCH_KN_PTYPE1                    0x00040000
-#define KG_SCH_KN_IPTOS_TC1                 0x00020000
-#define KG_SCH_KN_IPV6FL1                   0x00010000
-#define KG_SCH_KN_IPSRC2                    0x00008000
-#define KG_SCH_KN_IPDST2                    0x00004000
-#define KG_SCH_KN_PTYPE2                    0x00002000
-#define KG_SCH_KN_IPTOS_TC2                 0x00001000
-#define KG_SCH_KN_IPV6FL2                   0x00000800
-#define KG_SCH_KN_GREPTYPE                  0x00000400
-#define KG_SCH_KN_IPSEC_SPI                 0x00000200
-#define KG_SCH_KN_IPSEC_NH                  0x00000100
-#define KG_SCH_KN_L4PSRC                    0x00000004
-#define KG_SCH_KN_L4PDST                    0x00000002
-#define KG_SCH_KN_TFLG                      0x00000001
-
-typedef uint8_t t_GenericCodes;
-
-#define KG_SCH_GEN_SHIM1                       0x70
-#define KG_SCH_GEN_DEFAULT                     0x10
-#define KG_SCH_GEN_PARSE_RESULT_N_FQID         0x20
-#define KG_SCH_GEN_START_OF_FRM                0x40
-#define KG_SCH_GEN_SHIM2                       0x71
-#define KG_SCH_GEN_IP_PID_NO_V                 0x72
-#define KG_SCH_GEN_ETH                         0x03
-#define KG_SCH_GEN_ETH_NO_V                    0x73
-#define KG_SCH_GEN_SNAP                        0x04
-#define KG_SCH_GEN_SNAP_NO_V                   0x74
-#define KG_SCH_GEN_VLAN1                       0x05
-#define KG_SCH_GEN_VLAN1_NO_V                  0x75
-#define KG_SCH_GEN_VLAN2                       0x06
-#define KG_SCH_GEN_VLAN2_NO_V                  0x76
-#define KG_SCH_GEN_ETH_TYPE                    0x07
-#define KG_SCH_GEN_ETH_TYPE_NO_V               0x77
-#define KG_SCH_GEN_PPP                         0x08
-#define KG_SCH_GEN_PPP_NO_V                    0x78
-#define KG_SCH_GEN_MPLS1                       0x09
-#define KG_SCH_GEN_MPLS2                       0x19
-#define KG_SCH_GEN_MPLS3                       0x29
-#define KG_SCH_GEN_MPLS1_NO_V                  0x79
-#define KG_SCH_GEN_MPLS_LAST                   0x0a
-#define KG_SCH_GEN_MPLS_LAST_NO_V              0x7a
-#define KG_SCH_GEN_IPV4                        0x0b
-#define KG_SCH_GEN_IPV6                        0x1b
-#define KG_SCH_GEN_L3_NO_V                     0x7b
-#define KG_SCH_GEN_IPV4_TUNNELED               0x0c
-#define KG_SCH_GEN_IPV6_TUNNELED               0x1c
-#define KG_SCH_GEN_MIN_ENCAP                   0x2c
-#define KG_SCH_GEN_IP2_NO_V                    0x7c
-#define KG_SCH_GEN_GRE                         0x0d
-#define KG_SCH_GEN_GRE_NO_V                    0x7d
-#define KG_SCH_GEN_TCP                         0x0e
-#define KG_SCH_GEN_UDP                         0x1e
-#define KG_SCH_GEN_IPSEC_AH                    0x2e
-#define KG_SCH_GEN_SCTP                        0x3e
-#define KG_SCH_GEN_DCCP                        0x4e
-#define KG_SCH_GEN_IPSEC_ESP                   0x6e
-#define KG_SCH_GEN_L4_NO_V                     0x7e
-#define KG_SCH_GEN_NEXTHDR                     0x7f
-
-/* shifts */
-#define KG_SCH_PP_SHIFT_HIGH_SHIFT          27
-#define KG_SCH_PP_SHIFT_LOW_SHIFT           12
-#define KG_SCH_PP_MASK_SHIFT                16
-#define KG_SCH_MODE_CCOBASE_SHIFT           24
-#define KG_SCH_DEF_MAC_ADDR_SHIFT           30
-#define KG_SCH_DEF_TCI_SHIFT                28
-#define KG_SCH_DEF_ENET_TYPE_SHIFT          26
-#define KG_SCH_DEF_PPP_SESSION_ID_SHIFT     24
-#define KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT    22
-#define KG_SCH_DEF_MPLS_LABEL_SHIFT         20
-#define KG_SCH_DEF_IP_ADDR_SHIFT            18
-#define KG_SCH_DEF_PROTOCOL_TYPE_SHIFT      16
-#define KG_SCH_DEF_IP_TOS_TC_SHIFT          14
-#define KG_SCH_DEF_IPV6_FLOW_LABEL_SHIFT    12
-#define KG_SCH_DEF_IPSEC_SPI_SHIFT          10
-#define KG_SCH_DEF_L4_PORT_SHIFT            8
-#define KG_SCH_DEF_TCP_FLAG_SHIFT           6
-#define KG_SCH_HASH_CONFIG_SHIFT_SHIFT      24
-#define KG_SCH_GEN_MASK_SHIFT               16
-#define KG_SCH_GEN_HT_SHIFT                 8
-#define KG_SCH_GEN_SIZE_SHIFT               24
-#define KG_SCH_GEN_DEF_SHIFT                29
-#define FM_PCD_KG_KGAR_NUM_SHIFT            16
-
-
-/* others */
-#define NUM_OF_SW_DEFAULTS                  3
-#define MAX_PP_SHIFT                        23
-#define MAX_KG_SCH_SIZE                     16
-#define MASK_FOR_GENERIC_BASE_ID            0x20
-#define MAX_HASH_SHIFT                      40
-#define MAX_KG_SCH_FQID_BIT_OFFSET          31
-#define MAX_KG_SCH_PP_BIT_OFFSET            15
-#define MAX_DIST_FQID_SHIFT                 23
-
-#define GET_MASK_SEL_SHIFT(shift,i)             \
-switch(i) {                                     \
-    case(0):shift = 26;break;                   \
-    case(1):shift = 20;break;                   \
-    case(2):shift = 10;break;                   \
-    case(3):shift = 4;break;                    \
-    default:                                    \
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
-}
-
-#define GET_MASK_OFFSET_SHIFT(shift,i)          \
-switch(i) {                                     \
-    case(0):shift = 16;break;                   \
-    case(1):shift = 0;break;                    \
-    case(2):shift = 28;break;                   \
-    case(3):shift = 24;break;                   \
-    default:                                    \
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
-}
-
-#define GET_MASK_SHIFT(shift,i)                 \
-switch(i) {                                     \
-    case(0):shift = 24;break;                   \
-    case(1):shift = 16;break;                   \
-    case(2):shift = 8;break;                    \
-    case(3):shift = 0;break;                    \
-    default:                                    \
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
-}
 
 #define FM_PCD_MAX_NUM_OF_OPTIONS(clsPlanEntries)   ((clsPlanEntries==256)? 8:((clsPlanEntries==128)? 7: ((clsPlanEntries==64)? 6: ((clsPlanEntries==32)? 5:0))))
 
-typedef struct {
-    uint16_t num;
-    uint8_t  hardwarePortId;
-    uint16_t plcrProfilesBase;
-} t_FmPortPcdInterModulePlcrParams;
-
 /**************************************************************************//**
  @Description   A structure for initializing a keygen classification plan group
 *//***************************************************************************/
@@ -988,18 +650,28 @@ typedef struct t_FmPcdKgInterModuleClsPlanGrpParams {
                                /* OUT in FmPcdGetSetClsPlanGrpParams IN in FmPcdKgBuildClsPlanGrp*/
 } t_FmPcdKgInterModuleClsPlanGrpParams;
 
+typedef struct t_FmPcdLock {
+    t_Handle        h_Spinlock;
+    volatile bool   flag;
+    t_List          node;
+} t_FmPcdLock;
+#define FM_PCD_LOCK_OBJ(ptr)  LIST_OBJECT(ptr, t_FmPcdLock, node)
+
 
 typedef t_Error (t_FmPortGetSetCcParamsCallback) (t_Handle                  h_FmPort,
                                                   t_FmPortGetSetCcParams    *p_FmPortGetSetCcParams);
 
 
+/***********************************************************************/
+/*          Common API for FM-PCD module                               */
+/***********************************************************************/
 t_Handle    FmPcdGetHcHandle(t_Handle h_FmPcd);
 uint32_t    FmPcdGetSwPrsOffset(t_Handle h_FmPcd, e_NetHeaderType hdr, uint8_t  indexPerHdr);
 uint32_t    FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum);
 uint32_t    FmPcdGetMacsecLcv(t_Handle h_FmPcd, uint32_t netEnvId);
 void        FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
 void        FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
-uint8_t		FmPcdGetNetEnvId(t_Handle h_NetEnv);
+uint8_t     FmPcdGetNetEnvId(t_Handle h_NetEnv);
 void        FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId);
 uint32_t    FmPcdLock(t_Handle h_FmPcd);
 void        FmPcdUnlock(t_Handle h_FmPcd, uint32_t  intFlags);
@@ -1008,37 +680,32 @@ t_Error     FmPcdFragHcScratchPoolInit(t_Handle h_FmPcd, uint8_t scratchBpid);
 t_Error     FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl);
 t_Error     FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl);
 bool        FmPcdIsAdvancedOffloadSupported(t_Handle h_FmPcd);
+bool        FmPcdLockTryLockAll(t_Handle h_FmPcd);
+void        FmPcdLockUnlockAll(t_Handle h_FmPcd);
 
+/***********************************************************************/
+/*          Common API for FM-PCD KG module                            */
+/***********************************************************************/
 uint8_t     FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp);
 uint16_t    FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp);
-t_Error 	FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
 t_Error     FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
+
+t_Error     FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
 uint8_t     FmPcdKgGetSchemeId(t_Handle h_Scheme);
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 bool        FmPcdKgGetVspe(t_Handle h_Scheme);
-#endif
+#endif /* (DPAA_VERSION >= 11) */
 uint8_t     FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
 void        FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId);
-//void        FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
-//void        FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
 t_Error     FmPcdKgCheckInvalidateSchemeSw(t_Handle h_Scheme);
 t_Error     FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPortToSchemes, uint32_t *p_SpReg, bool add);
-void        FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
-void        FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
-bool        FmPcdKgIsDriverClsPlan(t_Handle h_FmPcd);
 bool        FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg);
-uint32_t    FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId);
 uint32_t    FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter);
 uint32_t    FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId);
 uint32_t    FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId);
-uint32_t    FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId);
 uint32_t    FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId);
 uint32_t    FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId);
 uint32_t    FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId);
-uint8_t     FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId);
-/*t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, t_Handle h_Scheme);*/
-/*void        FmPcdKgReleaseSchemeLock(t_Handle h_Scheme);*/
-void        FmPcdKgUpatePointedOwner(t_Handle h_Scheme, bool add);
 bool        FmPcdKgIsSchemeValidSw(t_Handle h_Scheme);
 
 t_Error     FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind);
@@ -1055,10 +722,14 @@ t_Error     FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t
 t_Error     FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp);
 t_Error     FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
 
-/* FM-PCD parser API routines */
+/***********************************************************************/
+/*          Common API for FM-PCD parser module                        */
+/***********************************************************************/
 t_Error     FmPcdPrsIncludePortInStatistics(t_Handle p_FmPcd, uint8_t hardwarePortId,  bool include);
 
-/* FM-PCD policer API routines */
+/***********************************************************************/
+/*          Common API for FM-PCD policer module                       */
+/***********************************************************************/
 t_Error     FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles);
 t_Error     FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId);
 bool        FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId);
@@ -1078,8 +749,6 @@ t_Error     FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle
 void        FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 void        FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 bool        FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg);
-/*t_Error     FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId, bool intr);
-void        FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId);*/
 uint32_t    FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 uint32_t    FmPcdPlcrGetPointedOwners(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 void        FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bool add);
@@ -1099,8 +768,6 @@ t_Error     FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmP
 t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint16_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
-t_Error     FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree);
-void        FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree);
 t_Handle    FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree);
 void        FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams);
 t_Error     FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_NetEnv, t_Handle h_IpReassemblyManip, bool schemes);
@@ -1115,12 +782,11 @@ uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
 uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
 uint32_t    FmPortGetPcdEngines(t_Handle h_FmPort);
 void        FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort);
-t_Error     FmPortAttachPCD(t_Handle h_FmPort);
 
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error     FmPcdFrmReplicUpdate(t_Handle h_FmPcd, t_Handle h_FmPort, t_Handle h_FrmReplic);
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
  @Function      FmRegisterIntr
@@ -1407,7 +1073,6 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 *//***************************************************************************/
 t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls, t_FmFmanCtrl orFmanCtrl);
 
-
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 /**************************************************************************//*
  @Function      FmDumpPortRegs
@@ -1424,8 +1089,6 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
 t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
-
-
 void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
 void        FmUnregisterPcd(t_Handle h_Fm);
 t_Handle    FmGetPcdHandle(t_Handle h_Fm);
@@ -1467,7 +1130,7 @@ t_Error     FmSetCongestionGroupPFCpriority(t_Handle    h_Fm,
                                             uint32_t    congestionGroupId,
                                             uint8_t     priorityBitMap);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 t_Error     FmVSPAlloc(t_Handle         h_Fm,
                                e_FmPortType     portType,
                                uint8_t          portId,
@@ -1484,8 +1147,7 @@ t_Error     FmVSPGetAbsoluteProfileId(t_Handle      h_Fm,
                                       uint16_t      *p_AbsoluteId);
 
 uintptr_t   FmGetVSPBaseAddr(t_Handle h_Fm);
-
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 #endif /* __FM_COMMON_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
index c28760f..8f45906 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __FM_HC_H
 #define __FM_HC_H
 
@@ -55,7 +56,7 @@ t_Error     FmHcDumpRegs(t_Handle h_FmHc);
 
 void        FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd);
 
-t_Error    	FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemeParams *p_Scheme);
+t_Error     FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemeParams *p_Scheme);
 t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
 t_Error     FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams );
 t_Error     FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams);
@@ -68,7 +69,7 @@ uint32_t    FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme);
 
 t_Error     FmHcPcdCcDoDynamicChange(t_Handle h_FmHc, uint32_t oldAdAddrOffset, uint32_t newAdAddrOffset);
 
-t_Error 	FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileParams *p_ProfileParams);
+t_Error     FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileParams *p_ProfileParams);
 t_Error     FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile);
 
 t_Error     FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h
index af71d96..0675444 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h
@@ -46,6 +46,7 @@
 #include "fm_ext.h"
 #include "fm_pcd_ext.h"
 
+
 /* sizes */
 #define CAPWAP_FRAG_EXTRA_SPACE                 32
 #define OFFSET_UNITS                            16
@@ -57,18 +58,17 @@
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
-#define DEFAULT_FM_SP_bufferPrefixContent_privDataSize   0
-#define DEFAULT_FM_SP_bufferPrefixContent_passPrsResult  FALSE
-#define DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp  FALSE
-#define DEFAULT_FM_SP_bufferPrefixContent_allOtherPCDInfo    FALSE
-//#define DEFAULT_FM_SP_bufferPrefixContent_dataAlign      DATA_ALIGNMENT - // TODO should be this way
-#define DEFAULT_FM_SP_bufferPrefixContent_dataAlign      64
-#define DEFAULT_FM_SP_dmaSwapData                        e_FM_DMA_NO_SWP
-#define DEFAULT_FM_SP_dmaIntContextCacheAttr             e_FM_DMA_NO_STASH
-#define DEFAULT_FM_SP_dmaHeaderCacheAttr                 e_FM_DMA_NO_STASH
-#define DEFAULT_FM_SP_dmaScatterGatherCacheAttr          e_FM_DMA_NO_STASH
-#define DEFAULT_FM_SP_dmaWriteOptimize                   FALSE
-#define DEFAULT_FM_SP_noScatherGather                   FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_privDataSize      0
+#define DEFAULT_FM_SP_bufferPrefixContent_passPrsResult     FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp     FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_allOtherPCDInfo   FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_dataAlign         64
+#define DEFAULT_FM_SP_dmaSwapData                           e_FM_DMA_NO_SWP
+#define DEFAULT_FM_SP_dmaIntContextCacheAttr                e_FM_DMA_NO_STASH
+#define DEFAULT_FM_SP_dmaHeaderCacheAttr                    e_FM_DMA_NO_STASH
+#define DEFAULT_FM_SP_dmaScatterGatherCacheAttr             e_FM_DMA_NO_STASH
+#define DEFAULT_FM_SP_dmaWriteOptimize                      TRUE
+#define DEFAULT_FM_SP_noScatherGather                       FALSE
 
 /**************************************************************************//**
  @Description       Registers bit fields
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
index a6fcb4c..4c7a697 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /*
 
  @File          error.c
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
index 99c340a..2d044be 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          list.c
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
index e72be23..e366ee7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
@@ -31,6 +31,7 @@
  */
 
 
+
 #include "std_ext.h"
 #include "xx_ext.h"
 #include "memcpy_ext.h"
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
index 00a1d2a..7b9d201 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #include "string_ext.h"
 #include "error_ext.h"
 #include "std_ext.h"
@@ -813,7 +814,7 @@ uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
     }
 
     /* Decreasing the allocated memory size from free memory size */
-	p_MM->freeMemSize -= size;
+    p_MM->freeMemSize -= size;
 
     /* insert the new busy block into the list of busy blocks */
     AddBusy ( p_MM, p_NewBusyB );
@@ -901,7 +902,7 @@ uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, uint64_t alignment, uint64
     }
 
     /* Decreasing the allocated memory size from free memory size */
-	p_MM->freeMemSize -= size;
+    p_MM->freeMemSize -= size;
 
     /* insert the new busy block into the list of busy blocks */
     AddBusy( p_MM, p_NewBusyB );
@@ -954,7 +955,7 @@ uint64_t MM_Put(t_Handle h_MM, uint64_t base)
     size = p_BusyB->end - p_BusyB->base;
 
     /* Adding the deallocated memory size to free memory size */
-	p_MM->freeMemSize += size;
+    p_MM->freeMemSize += size;
 
     XX_Free(p_BusyB);
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
@@ -986,7 +987,7 @@ uint64_t MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size)
     }
 
     /* Adding the deallocated memory size to free memory size */
-	p_MM->freeMemSize += size;
+    p_MM->freeMemSize += size;
 
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
 
@@ -1046,7 +1047,7 @@ t_Error MM_Add(t_Handle h_MM, uint64_t base, uint64_t size)
     }
 
     /* Adding the new block size to free memory size */
-	p_MM->freeMemSize += size;
+    p_MM->freeMemSize += size;
 
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
 
@@ -1103,11 +1104,11 @@ bool MM_InRange(t_Handle h_MM, uint64_t addr)
 /*****************************************************************************/
 uint64_t MM_GetFreeMemSize(t_Handle h_MM)
 {
-	t_MM       *p_MM = (t_MM*)h_MM;
+    t_MM       *p_MM = (t_MM*)h_MM;
 
-	ASSERT_COND(p_MM);
+    ASSERT_COND(p_MM);
 
-	return p_MM->freeMemSize;
+    return p_MM->freeMemSize;
 }
 
 /*****************************************************************************/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
index ed46e9f..43b2298 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /****************************************************************
  *
  * File:  mm.h
@@ -90,14 +91,14 @@ typedef struct t_BusyBlock
 /* t_MM data structure defines parameters of the MM object */
 typedef struct t_MM
 {
-	t_Handle        h_Spinlock;
+    t_Handle        h_Spinlock;
 
-	t_MemBlock      *memBlocks;     /* List of memory blocks (Memory list) */
+    t_MemBlock      *memBlocks;     /* List of memory blocks (Memory list) */
     t_BusyBlock     *busyBlocks;    /* List of busy blocks (Busy list) */
     t_FreeBlock     *freeBlocks[MM_MAX_ALIGNMENT + 1];
                                     /* Alignment lists of free blocks (Free lists) */
 
-    uint64_t		freeMemSize;	/* Total size of free memory (in bytes) */
+    uint64_t        freeMemSize;    /* Total size of free memory (in bytes) */
 } t_MM;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
index 3dfd308..46d2956 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /*------------------------------------------------------*/
 /* File: sprint.c                                       */
 /*                                                      */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
index 4745fb1..a84d563 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /*------------------------------------------------------*/
 /*                                                      */
 /* File: crc_mac_addr_ext.h                             */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
index 03457d5..ba40f53 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
  @File          dpaa_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index d00b6da..0c279ae 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_ext.h
 
@@ -335,13 +336,14 @@ typedef struct t_FmBufferPrefixContent {
                                          get the parser-result from a buffer. */
     bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
                                          AD, hash-result, key, etc. */
-    uint16_t    dataAlign;          /**< 0 to use driver's default alignment, other value
+    uint16_t    dataAlign;          /**< 0 to use driver's default alignment
+									 [DEFAULT_PORT_bufferPrefixContent_dataAlign], other value
                                          for selecting a data alignment (must be a
-                                         power of 2) */
+                                         power of 2); if write optimization is used, must be >= 16. */
     uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size);
                                          Note that this field impacts the size of the buffer-prefix
-                                         (i.e. it pushes the data offset); in addition, in some cases
-                                         (like DPAA_VERSION>2 and it is related to Rx FM-Port) */
+                                         (i.e. it pushes the data offset);
+                                         This field is irrelevant if DPAA_VERSION==10 */
 } t_FmBufferPrefixContent;
 
 /**************************************************************************//**
@@ -394,10 +396,10 @@ typedef struct t_FmBufPoolDepletion {
     bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_POOLS];
                                                     /**< For each pool, TRUE if it should be considered for
                                                          depletion (Note - this pool must be used by this port!) */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool        pfcPrioritiesEn[FM_MAX_NUM_OF_PFC_PRIORITIES];
                                                     /**< This field is used by the MAC as the Priority Enable Vector in the PFC frame which is transmitted */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmBufPoolDepletion;
 
 /**************************************************************************//**
@@ -439,14 +441,14 @@ typedef struct t_FmParams {
     t_FmFirmwareParams      firmware;               /**< The firmware parameters structure;
                                                          Relevant when guestId = NCSW_MASTER_ID only. */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     uintptr_t               vspBaseAddr;            /**< A pointer to base of memory mapped FM VSP registers (virtual);
                                                          i.e. up to 24KB, depending on the specific chip. */
     uint8_t                 partVSPBase;            /**< The first Virtual-Storage-Profile-id dedicated to this partition.
                                                          NOTE: this parameter relevant only when working with multiple partitions. */
     uint8_t                 partNumOfVSPs;          /**< Number of VSPs dedicated to this partition.
                                                          NOTE: this parameter relevant only when working with multiple partitions. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmParams;
 
 
@@ -1601,6 +1603,7 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
 /** @} */ /* end of FM_lib_grp group */
 /** @} */ /* end of FM_grp group */
 
+
 #ifdef NCSW_BACKWARD_COMPATIBLE_API
 typedef t_FmBufferPrefixContent     t_FmPortBufferPrefixContent;
 typedef t_FmExtPoolParams           t_FmPortExtPoolParams;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index 6d341b1..d28b0bc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_mac_ext.h
 
@@ -112,7 +113,7 @@ typedef enum e_FmMacStatisticsLevel {
 } e_FmMacStatisticsLevel;
 
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Description   Priority Flow Control Parameters
 *//***************************************************************************/
@@ -125,7 +126,7 @@ typedef struct t_FmMacPfcParams {
 
 
 } t_FmMacPfcParams;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
  @Function      t_FmMacExceptionCallback
@@ -542,6 +543,7 @@ t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
                 Where applicable, the routine also enables the MIB counters
                 overflow interrupt in order to keep counters accurate
                 and account for overflows.
+                This routine is relevant only for dTSEC.
 
  @Param[in]     h_FmMac         - A handle to a FM MAC Module.
  @Param[in]     statisticsLevel - Full statistics level provides all standard counters but may
@@ -561,7 +563,7 @@ t_Error FM_MAC_SetStatistics(t_Handle h_FmMac, e_FmMacStatisticsLevel statistics
  @Description   get all statistics counters
 
  @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
- @Param[in]     p_Statistics  -  Staructure with statistics
+ @Param[in]     p_Statistics  -  Structure with statistics
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -659,6 +661,7 @@ t_Error FM_MAC_SetPromiscuous(t_Handle h_FmMac, bool enable);
  @Function      FM_MAC_AdjustLink
 
  @Description   Adjusts the Ethernet link with new speed/duplex setup.
+                This routine is relevant only for dTSEC.
 
  @Param[in]     h_FmMac     - A handle to a FM Module.
  @Param[in]     speed       - Ethernet speed.
@@ -670,6 +673,24 @@ t_Error FM_MAC_SetPromiscuous(t_Handle h_FmMac, bool enable);
 t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
 
 /**************************************************************************//**
+ @Function      FM_MAC_RestartAutoneg
+
+ @Description   Restarts the autonegotiation process.
+                When autonegegotiation process is invoked under traffic the
+                autonegotiation process between the internal TBI PHY and the
+                external PHY does not always complete succesfuly. Calling this
+                function will restart the autonegotiation process that will end
+                succesfuly. It is recomended to call this function after issuing
+                autoneg restart command to the Eth Phy.
+                This routine is relevant only for dTSEC.
+
+ @Param[in]     h_FmMac     - A handle to a FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MAC_RestartAutoneg(t_Handle h_FmMac);
+
+/**************************************************************************//**
  @Function      FM_MAC_GetId
 
  @Description   Return the MAC ID
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
index e73f516..ef62c8e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_muram_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 0556687..39055c0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -30,10 +30,11 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_pcd_ext.h
 
- @Description   FM PCD ...
+ @Description   FM PCD API definitions
 *//***************************************************************************/
 #ifndef __FM_PCD_EXT
 #define __FM_PCD_EXT
@@ -106,9 +107,9 @@
 #define FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
                                                                              insert manipulation */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 #define FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 /* @} */
 
 
@@ -292,8 +293,8 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd);
  @Function      FM_PCD_ConfigException
 
  @Description   Calling this routine changes the internal driver data base
-                from its default selection of exceptions enablement.
-                By default all exceptions are enabled.
+                from its default selection of exceptions enabling.
+                [4].
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     exception       The exception to be selected.
@@ -812,10 +813,11 @@ typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
 #define IPV6_MULTICAST_2            0x00200000  /**< Tunneled IPv6 - Multicast. */
 
 #define IPV6_FRAG_1                 0x00000004  /**< IPV6 reassembly option.
-                                                     IPV6 Reassembly manipulation requires an IPV4 network
-                                                     environment unit with IPV4_FRAG_1 option  */
+                                                     IPV6 Reassembly manipulation requires network
+                                                     environment with IPV6 header and IPV6_FRAG_1 option  */
 /* @} */
 
+
 /**************************************************************************//**
  @Description   A type used for returning the order of the key extraction.
                 each value in this array represents the index of the extraction
@@ -835,7 +837,9 @@ typedef enum e_FmPcdEngine {
     e_FM_PCD_CC,            /**< Coarse classifier */
     e_FM_PCD_PLCR,          /**< Policer */
     e_FM_PCD_PRS,           /**< Parser */
+#if (DPAA_VERSION >= 11)
     e_FM_PCD_FR,            /**< Frame-Replicator */
+#endif /* (DPAA_VERSION >= 11) */
     e_FM_PCD_HASH           /**< Hash table */
 } e_FmPcdEngine;
 
@@ -1018,8 +1022,10 @@ typedef enum e_FmPcdAction {
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrInsrtType {
     e_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
     e_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
+#endif /* defined (FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_FM_HM) */
+#ifdef FM_CAPWAP_SUPPORT
     e_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
 #endif /* FM_CAPWAP_SUPPORT */
 } e_FmPcdManipHdrInsrtType;
@@ -1029,13 +1035,13 @@ typedef enum e_FmPcdManipHdrInsrtType {
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrRmvType {
     e_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
     e_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* defined (FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_FM_HM) */
 } e_FmPcdManipHdrRmvType;
 
 
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of header removal
 *//***************************************************************************/
@@ -1044,7 +1050,7 @@ typedef enum e_FmPcdManipHdrRmvByHdrType {
     e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START            /**< Locate from data that is not the header */
 #endif /* FM_CAPWAP_SUPPORT */
 } e_FmPcdManipHdrRmvByHdrType;
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* defined (FM_CAPWAP_SUPPORT) || defined(UNDER_CONSTRUCTION_FM_HM) */
 
 /**************************************************************************//**
  @Description   Enumeration type for selecting type of timeout mode
@@ -1126,25 +1132,126 @@ typedef union u_FmPcdHdrProtocolOpt {
 } u_FmPcdHdrProtocolOpt;
 
 /**************************************************************************//**
- @Description   A union holding all known protocol fields
+ @Description   A union holding protocol fields
+
+
+				Fields supported as "full fields":
+                    HEADER_TYPE_ETH:
+						NET_HEADER_FIELD_ETH_DA
+						NET_HEADER_FIELD_ETH_SA
+						NET_HEADER_FIELD_ETH_TYPE
+
+                    HEADER_TYPE_LLC_SNAP:
+					    NET_HEADER_FIELD_LLC_SNAP_TYPE
+
+                    HEADER_TYPE_VLAN:
+						NET_HEADER_FIELD_VLAN_TCI
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_LAST)
+
+					HEADER_TYPE_MPLS:
+					    NET_HEADER_FIELD_MPLS_LABEL_STACK
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2,
+								 e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv4:
+                        NET_HEADER_FIELD_IPv4_SRC_IP
+                        NET_HEADER_FIELD_IPv4_DST_IP
+                        NET_HEADER_FIELD_IPv4_PROTO
+						NET_HEADER_FIELD_IPv4_TOS
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv6:
+                        NET_HEADER_FIELD_IPv6_SRC_IP
+                        NET_HEADER_FIELD_IPv6_DST_IP
+                        NET_HEADER_FIELD_IPv6_NEXT_HDR
+						NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC (must come together!)
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+					HEADER_TYPE_GRE:
+                        NET_HEADER_FIELD_GRE_TYPE
+
+                    HEADER_TYPE_MINENCAP
+						NET_HEADER_FIELD_MINENCAP_SRC_IP
+						NET_HEADER_FIELD_MINENCAP_DST_IP
+						NET_HEADER_FIELD_MINENCAP_TYPE
+
+					HEADER_TYPE_TCP:
+                        NET_HEADER_FIELD_TCP_PORT_SRC
+                        NET_HEADER_FIELD_TCP_PORT_DST
+						NET_HEADER_FIELD_TCP_FLAGS
+
+					HEADER_TYPE_UDP:
+                        NET_HEADER_FIELD_UDP_PORT_SRC
+                        NET_HEADER_FIELD_UDP_PORT_DST
+
+					HEADER_TYPE_IPSEC_AH:
+                        NET_HEADER_FIELD_IPSEC_AH_SPI
+                        NET_HEADER_FIELD_IPSEC_AH_NH
+
+					HEADER_TYPE_IPSEC_ESP:
+					    NET_HEADER_FIELD_IPSEC_ESP_SPI
+
+					HEADER_TYPE_SCTP:
+					    NET_HEADER_FIELD_SCTP_PORT_SRC
+						NET_HEADER_FIELD_SCTP_PORT_DST
+
+					HEADER_TYPE_DCCP:
+					    NET_HEADER_FIELD_DCCP_PORT_SRC
+						NET_HEADER_FIELD_DCCP_PORT_DST
+
+					HEADER_TYPE_PPPoE:
+                        NET_HEADER_FIELD_PPPoE_PID
+					    NET_HEADER_FIELD_PPPoE_SID
+
+		*****************************************************************
+				Fields supported as "from fields":
+                    HEADER_TYPE_ETH (with or without validation):
+						NET_HEADER_FIELD_ETH_TYPE
+
+                    HEADER_TYPE_VLAN (with or without validation):
+						NET_HEADER_FIELD_VLAN_TCI
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv4 (without validation):
+                        NET_HEADER_FIELD_IPv4_PROTO
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
+                    HEADER_TYPE_IPv6 (without validation):
+                        NET_HEADER_FIELD_IPv6_NEXT_HDR
+						        (index may apply:
+								 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1,
+					             e_FM_PCD_HDR_INDEX_2/e_FM_PCD_HDR_INDEX_LAST)
+
 *//***************************************************************************/
 typedef union t_FmPcdFields {
-    headerFieldEth_t            eth;            /**< eth      */
-    headerFieldVlan_t           vlan;           /**< vlan     */
-    headerFieldLlcSnap_t        llcSnap;        /**< llcSnap  */
-    headerFieldPppoe_t          pppoe;          /**< pppoe    */
-    headerFieldMpls_t           mpls;           /**< mpls     */
-    headerFieldIpv4_t           ipv4;           /**< ipv4     */
-    headerFieldIpv6_t           ipv6;           /**< ipv6     */
-    headerFieldUdp_t            udp;            /**< udp      */
-    headerFieldTcp_t            tcp;            /**< tcp      */
-    headerFieldSctp_t           sctp;           /**< sctp     */
-    headerFieldDccp_t           dccp;           /**< dccp     */
-    headerFieldGre_t            gre;            /**< gre      */
-    headerFieldMinencap_t       minencap;       /**< minencap */
-    headerFieldIpsecAh_t        ipsecAh;        /**< ipsecAh  */
-    headerFieldIpsecEsp_t       ipsecEsp;       /**< ipsecEsp */
-    headerFieldUdpEncapEsp_t    udpEncapEsp;    /**< udpEncapEsp */
+    headerFieldEth_t            eth;            /**< Ethernet               */
+    headerFieldVlan_t           vlan;           /**< VLAN                   */
+    headerFieldLlcSnap_t        llcSnap;        /**< LLC SNAP               */
+    headerFieldPppoe_t          pppoe;          /**< PPPoE                  */
+    headerFieldMpls_t           mpls;           /**< MPLS                   */
+    headerFieldIpv4_t           ipv4;           /**< IPv4                   */
+    headerFieldIpv6_t           ipv6;           /**< IPv6                   */
+    headerFieldUdp_t            udp;            /**< UDP                    */
+    headerFieldTcp_t            tcp;            /**< TCP                    */
+    headerFieldSctp_t           sctp;           /**< SCTP                   */
+    headerFieldDccp_t           dccp;           /**< DCCP                   */
+    headerFieldGre_t            gre;            /**< GRE                    */
+    headerFieldMinencap_t       minencap;       /**< Minimal Encapsulation  */
+    headerFieldIpsecAh_t        ipsecAh;        /**< IPSec AH               */
+    headerFieldIpsecEsp_t       ipsecEsp;       /**< IPSec ESP              */
+    headerFieldUdpEncapEsp_t    udpEncapEsp;    /**< UDP Encapsulation ESP  */
 } t_FmPcdFields;
 
 /**************************************************************************//**
@@ -1354,7 +1461,7 @@ typedef struct t_FmPcdKgPlcrProfile {
     } profileSelect;                                /**< Direct/indirect profile selection and parameters */
 } t_FmPcdKgPlcrProfile;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Description   Parameters for configuring a storage profile for a KeyGen scheme.
 *//***************************************************************************/
@@ -1380,7 +1487,7 @@ typedef struct t_FmPcdKgStorageProfile {
         } indirectProfile;                          /**< Indirect profile parameters. */
     } profileSelect;                                /**< Direct/indirect profile selection and parameters. */
 } t_FmPcdKgStorageProfile;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
  @Description   Parameters for defining CC as the next engine after KeyGen
@@ -1435,10 +1542,10 @@ typedef struct t_FmPcdKgSchemeParams {
                                                                      for qidMask. Driver will return error if
                                                                      resource is full at initialization time. */
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool                                overrideStorageProfile; /**< TRUE if KeyGen override previously decided storage profile */
     t_FmPcdKgStorageProfile             storageProfile;         /**< Used when overrideStorageProfile TRUE */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
     e_FmPcdEngine                       nextEngine;             /**< may be BMI, PLCR or CC */
     union {                                                     /**< depends on nextEngine */
@@ -1457,6 +1564,15 @@ typedef struct t_FmPcdCcNextCcParams {
     t_Handle    h_CcNode;               /**< A handle of the next CC node */
 } t_FmPcdCcNextCcParams;
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Description   Parameters for defining Frame replicator as the next engine after a CC node.
+*//***************************************************************************/
+typedef struct t_FmPcdCcNextFrParams {
+    t_Handle    h_FrmReplic;               /**< A handle of the next frame replicator group */
+} t_FmPcdCcNextFrParams;
+#endif /* (DPAA_VERSION >= 11) */
+
 /**************************************************************************//**
  @Description   Parameters for defining Policer as the next engine after a CC node.
 *//***************************************************************************/
@@ -1474,12 +1590,12 @@ typedef struct t_FmPcdCcNextPlcrParams {
                                              In earlier chips  if policer next engine is KEYGEN,
                                              this parameter can be 0, because the KEYGEN
                                              always decides the enqueue FQID.*/
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     uint8_t     newRelativeStorageProfileId;
                                         /**< Indicates the relative storage profile offset within
                                              the port's storage profiles window;
                                              Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmPcdCcNextPlcrParams;
 
 /**************************************************************************//**
@@ -1487,35 +1603,36 @@ typedef struct t_FmPcdCcNextPlcrParams {
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextEnqueueParams {
     e_FmPcdDoneAction    action;        /**< Action - when next engine is BMI (done) */
-    bool                 overrideFqid;  /**< TRUE if CC override previously decided FQID (by KeyGen),
+    bool                 overrideFqid;  /**< TRUE if CC override previously decided fqid and vspid,
                                              relevant if action = e_FM_PCD_ENQ_FRAME */
     uint32_t             newFqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
                                              (otherwise FQID is taken from KeyGen),
                                              relevant if action = e_FM_PCD_ENQ_FRAME */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     uint8_t              newRelativeStorageProfileId;
-                                        /**< Indicates the relative storage profile offset within
-                                             the port's storage profiles window;
-                                             Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+                                        /**< Valid if overrideFqid=TRUE, Indicates the relative virtual
+                                             storage profile offset within the port's storage profiles
+                                             window; Relevant only if the port was configured with VSP. */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmPcdCcNextEnqueueParams;
 
 /**************************************************************************//**
  @Description   Parameters for defining KeyGen as the next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextKgParams {
-    bool        overrideFqid;           /**< TRUE if CC override previously decided FQID (by KeyGen),
+    bool        overrideFqid;           /**< TRUE if CC override previously decided fqid and vspid,
                                              Note - this parameters irrelevant for earlier chips */
     uint32_t    newFqid;                /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
                                              (otherwise FQID is taken from KeyGen),
                                              Note - this parameters irrelevant for earlier chips */
-    t_Handle    h_DirectScheme;         /**< Direct scheme handle to go to. */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     uint8_t     newRelativeStorageProfileId;
-                                        /**< Indicates the relative storage profile offset within
-                                             the port's storage profiles window;
-                                             Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+                                        /**< Valid if overrideFqid=TRUE, Indicates the relative virtual
+                                             storage profile offset within the port's storage profiles
+                                             window; Relevant only if the port was configured with VSP. */
+#endif /* (DPAA_VERSION >= 11) */
+
+    t_Handle    h_DirectScheme;         /**< Direct scheme handle to go to. */
 } t_FmPcdCcNextKgParams;
 
 /**************************************************************************//**
@@ -1529,11 +1646,10 @@ typedef struct t_FmPcdCcNextEngineParams {
         t_FmPcdCcNextPlcrParams         plcrParams;     /**< Parameters in case next engine is PLCR */
         t_FmPcdCcNextEnqueueParams      enqueueParams;  /**< Parameters in case next engine is BMI */
         t_FmPcdCcNextKgParams           kgParams;       /**< Parameters in case next engine is KG */
-#if DPAA_VERSION >= 3
-        t_Handle                        h_FrmReplic;    /**< Handle to frame replicator group;
-                                                             Relevant if next engine is e_FM_PCD_INVALID) */
-#endif /* DPAA_VERSION >= 3 */
-    } params;
+#if (DPAA_VERSION >= 11)
+        t_FmPcdCcNextFrParams           frParams;       /**< Parameters in case next engine is FR */
+#endif /* (DPAA_VERSION >= 11) */
+    } params;                                           /**< union used for all the next-engine parameters options */
 
     t_Handle                            h_Manip;        /**< Handle to Manipulation object.
                                                              Relevant if next engine is of type result
@@ -1559,7 +1675,6 @@ typedef struct t_FmPcdCcKeyParams {
 
 /**************************************************************************//**
  @Description   Parameters for defining CC keys parameters
-
                 The driver supports two methods for CC node allocation: dynamic and static.
                 Static mode was created in order to prevent runtime alloc/free
                 of FMan memory (MURAM), which may cause fragmentation; in this mode,
@@ -1567,30 +1682,37 @@ typedef struct t_FmPcdCcKeyParams {
                 'maxNumOfKeys' parameter. The driver calculates the maximal memory
                 size that may be used for this CC-Node taking into consideration
                 'maskSupport' and 'statisticsMode' parameters.
-                In dynamic mode, 'maxNumOfKeys' must be zeroed. At initialization,
+                When 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP in the extraction
+                parameters of this node, 'maxNumOfKeys' must be equal to 'numOfKeys'.
+                In dynamic mode, 'maxNumOfKeys' must be zero. At initialization,
                 all required structures are allocated according to 'numOfKeys'
                 parameter. During runtime modification, these structures are
                 re-allocated according to the updated number of keys.
+
+                Please note that 'action' and 'icIndxMask' mentioned in the
+                specific parameter explanations are passed in the extraction
+                parameters of the node (fields of extractCcParams.extractNonHdr).
 *//***************************************************************************/
 typedef struct t_KeysParams {
     uint16_t                    maxNumOfKeys;   /**< Maximum number of keys that will (ever) be used in this CC-Node;
                                                      A value of zero may be used for dynamic memory allocation. */
     bool                        maskSupport;    /**< This parameter is relevant only if a node is initialized with
-                                                     action = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
-                                                     Should be TRUE if the node was initialized 'empty' (no keys)
-                                                     or with keys without masks, and user wants to be able to add
-                                                     a mask to a key later on in run-time. */
-    e_FmPcdCcStatsMode          statisticsMode; /**< If enabled, the required structures for the requested statistics
-                                                     mode will be allocated according to 'maxNumOfKeys'. */
+                                                     'action' = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
+                                                     Should be TRUE to reserve table memory for key masks, even if
+                                                     initial keys do not contain masks, or if the node was initialized
+                                                     as 'empty' (without keys); this will allow user to add keys with
+                                                     masks at runtime. */
+    e_FmPcdCcStatsMode          statisticsMode; /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for
+                                                     the requested statistics mode will be allocated according to
+                                                     'maxNumOfKeys'. */
     uint16_t                    numOfKeys;      /**< Number of initial keys;
-                                                     Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP
-                                                     (but the 'src' is not e_FM_PCD_EXTRACT_FROM_HASH; in this case,
-                                                     'numOfKeys' should be zero), this field should be power-of-2
-                                                     of the number of bits that are set in 'icIndxMask'. */
-    uint8_t                     keySize;        /**< Size of key - for extraction of type FULL_FIELD, keySize has
+                                                     Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP,
+                                                     this field should be power-of-2 of the number of bits that are
+                                                     set in 'icIndxMask'. */
+    uint8_t                     keySize;        /**< Size of key - for extraction of type FULL_FIELD, 'keySize' has
                                                      to be the standard size of the selected key; For other extraction
-                                                     types, keySize has to be as size of extraction; When 'action' =
-                                                     e_FM_PCD_ACTION_INDEXED_LOOKUP, keySize has to be 2. */
+                                                     types, 'keySize' has to be as size of extraction; When 'action' =
+                                                     e_FM_PCD_ACTION_INDEXED_LOOKUP, 'keySize' must be 2. */
     t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
                                                 /**< An array with 'numOfKeys' entries, each entry specifies the
                                                      corresponding key parameters. */
@@ -1599,6 +1721,7 @@ typedef struct t_KeysParams {
                                                      Not relevant if action = e_FM_PCD_ACTION_INDEXED_LOOKUP. */
 } t_KeysParams;
 
+
 /**************************************************************************//**
  @Description   Parameters for defining a CC node
 *//***************************************************************************/
@@ -1612,8 +1735,8 @@ typedef struct t_FmPcdCcNodeParams {
 *//***************************************************************************/
 typedef struct t_FmPcdHashTableParams {
     uint16_t                    maxNumOfKeys;               /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
-    e_FmPcdCcStatsMode          statisticsMode;             /**< If enabled, the required structures for the requested statistics
-                                                                 mode will be allocated according to maxNumOfKeys. */
+    e_FmPcdCcStatsMode          statisticsMode;             /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
+                                                                 requested statistics mode will be allocated according to maxNumOfKeys. */
     uint16_t                    hashResMask;                /**< Mask that will be used on the hash-result;
                                                                  The number-of-sets for this hash will be calculated
                                                                  as (2^(number of bits set in 'hashResMask'));
@@ -1623,7 +1746,6 @@ typedef struct t_FmPcdHashTableParams {
     uint8_t                     matchKeySize;               /**< Size of the exact match keys held by the hash buckets */
 
     t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;  /**< Parameters for defining the next engine when a key is not matched */
-
 } t_FmPcdHashTableParams;
 
 /**************************************************************************//**
@@ -1825,10 +1947,12 @@ typedef struct t_FmPcdManipFragOrReasmParams {
     bool                                frag;               /**< TRUE if using the structure for fragmentation,
                                                                  otherwise this structure is used for reassembly */
     uint8_t                             sgBpid;             /**< Scatter/Gather buffer pool id;
-                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
-                                                             of this pool need to be allocated in the same memory area as the received buffers.
-                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
-                                                             mutual to all these sources. */
+                                                                 Same LIODN number is used for these buffers as for
+                                                                 the received frames buffers, so buffers of this pool
+                                                                 need to be allocated in the same memory area as the
+                                                                 received buffers. If the received buffers arrive
+                                                                 from different sources, the Scatter/Gather BP id
+                                                                 should be mutual to all these sources. */
     e_NetHeaderType                     hdr;                /**< Header selection */
     union {
         t_CapwapFragmentationParams     capwapFragParams;   /**< Structure for CAPWAP fragmentation,
@@ -1840,7 +1964,7 @@ typedef struct t_FmPcdManipFragOrReasmParams {
 
 #endif /* FM_CAPWAP_SUPPORT */
 
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
 /**************************************************************************//**
  @Description   Parameters for defining header removal by header type
 *//***************************************************************************/
@@ -1856,7 +1980,7 @@ typedef struct t_FmPcdManipHdrRmvByHdrParams {
 #endif /* FM_CAPWAP_SUPPORT */
     } u;
 } t_FmPcdManipHdrRmvByHdrParams;
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* defined(FM_CAPWAP_SUPPORT) || defined (UNDER_CONSTRUCTION_FM_HM) */
 
 /**************************************************************************//**
  @Description   Parameters for configuring IP fragmentation manipulation
@@ -1864,9 +1988,9 @@ typedef struct t_FmPcdManipHdrRmvByHdrParams {
 typedef struct t_FmPcdManipFragIpParams {
     uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
                                                              IP fragmentation will be executed.*/
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     uint8_t                     scratchBpid;            /**< Absolute buffer pool id according to BM configuration.*/
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
     bool                        sgBpidEn;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
                                                              If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
                                                              received frame's buffer. */
@@ -1894,9 +2018,6 @@ typedef struct t_FmPcdManipReassemIpParams {
                                                                  Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
                                                                  the user schemes id to ensure that the reassemblys schemes will be first match.
                                                                  Rest schemes, if defined, should have higher relative scheme ID. */
-#ifdef UNDER_CONSTRUCTION_V3_IPR
-    t_Handle                        h_CouplingFmPort;       /**< Must be given if storage profile virtualization is required */
-#endif /* UNDER_CONSTRUCTION_V3_IPR */
     uint8_t                         sgBpid;                 /**< Buffer pool id for the S/G frame created by the reassembly process */
     uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
     uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
@@ -1966,20 +2087,17 @@ typedef struct t_FmPcdManipHdrInsrtGenericParams {
 } t_FmPcdManipHdrInsrtGenericParams;
 
 
-
 /**************************************************************************//**
  @Description   Parameters for defining header insertion manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipHdrInsrtParams {
-    e_FmPcdManipHdrInsrtType                    type;   /**< Type of insertion manipulation */
+    e_FmPcdManipHdrInsrtType                    type;       /**< Type of insertion manipulation */
     union {
-        t_FmPcdManipHdrInsrtGenericParams       generic;
-                                                        /**< Parameters for defining generic header insertion manipulation,
-                                                             relevant if type = e_FM_PCD_MANIP_INSRT_GENERIC */
+        t_FmPcdManipHdrInsrtGenericParams       generic;    /**< Parameters for defining generic header insertion manipulation,
+                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_GENERIC */
 #ifdef FM_CAPWAP_SUPPORT
-        t_FmPcdManipHdrInsrtByTemplateParams    byTemplate;
-                                                        /**< Parameters for defining header insertion manipulation by template,
-                                                             relevant if type = e_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
+        t_FmPcdManipHdrInsrtByTemplateParams    byTemplate; /**< Parameters for defining header insertion manipulation by template,
+                                                                 relevant if 'type' = e_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
 #endif /* FM_CAPWAP_SUPPORT */
     } u;
 } t_FmPcdManipHdrInsrtParams;
@@ -1990,10 +2108,10 @@ typedef struct t_FmPcdManipHdrInsrtParams {
 typedef struct t_FmPcdManipHdrRmvParams {
     e_FmPcdManipHdrRmvType                  type;       /**< Type of header removal manipulation */
     union {
-#ifdef FM_CAPWAP_SUPPORT
+#if defined(FM_CAPWAP_SUPPORT)
         t_FmPcdManipHdrRmvByHdrParams       byHdr;      /**< Parameters for defining header removal manipulation by header type,
                                                              relevant if type = e_FM_PCD_MANIP_RMV_BY_HDR */
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* defined (FM_CAPWAP_SUPPORT) || defined (UNDER_CONSTRUCTION_FM_HM) */
         t_FmPcdManipHdrRmvGenericParams     generic;    /**< Parameters for defining generic header removal manipulation,
                                                              relevant if type = e_FM_PCD_MANIP_RMV_GENERIC */
     } u;
@@ -2004,10 +2122,10 @@ typedef struct t_FmPcdManipHdrRmvParams {
 *//***************************************************************************/
 typedef struct t_FmPcdManipHdrParams {
     bool                                        rmv;                /**< TRUE, to define removal manipulation */
-    t_FmPcdManipHdrRmvParams                    rmvParams;          /**< Parameters for removal manipulation, relevant if rmv = TRUE */
+    t_FmPcdManipHdrRmvParams                    rmvParams;          /**< Parameters for removal manipulation, relevant if 'rmv' = TRUE */
 
     bool                                        insrt;              /**< TRUE, to define insertion manipulation */
-    t_FmPcdManipHdrInsrtParams                  insrtParams;        /**< Parameters for insertion manipulation, relevant if insrt = TRUE */
+    t_FmPcdManipHdrInsrtParams                  insrtParams;        /**< Parameters for insertion manipulation, relevant if 'insrt' = TRUE */
 
 
     bool                                        dontParseAfterManip;/**< FALSE to activate the parser a second time after
@@ -2015,7 +2133,7 @@ typedef struct t_FmPcdManipHdrParams {
 } t_FmPcdManipHdrParams;
 
 /**************************************************************************//**
- @Description   structure for defining fragmentation manipulation
+ @Description   Parameters for defining fragmentation manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipFragParams {
     e_NetHeaderType                     hdr;          /**< Header selection */
@@ -2026,7 +2144,7 @@ typedef struct t_FmPcdManipFragParams {
 } t_FmPcdManipFragParams;
 
 /**************************************************************************//**
- @Description   structure for defining reassemble manipulation
+ @Description   Parameters for defining reassembly manipulation
 *//***************************************************************************/
 typedef struct t_FmPcdManipReassemParams {
     e_NetHeaderType                     hdr;          /**< Header selection */
@@ -2047,8 +2165,10 @@ typedef struct t_FmPcdManipParams {
         t_FmPcdManipFragParams              frag;               /**< Parameters for defining fragmentation manipulation node */
         t_FmPcdManipSpecialOffloadParams    specialOffload;     /**< Parameters for defining special offload manipulation node */
     } u;
-     t_Handle                               h_NextManip;        /**< Handle to another (previously defined) manipulation node;
-                                                                     Allows concatenation of manipulation actions */
+
+    t_Handle                                h_NextManip;        /**< Handle to another (previously defined) manipulation node;
+                                                                     Allows concatenation of manipulation actions;
+                                                                     This parameter is optional and may be NULL. */
 #ifdef FM_CAPWAP_SUPPORT
     bool                                    fragOrReasm;        /**< TRUE, if defined fragmentation/reassembly manipulation */
     t_FmPcdManipFragOrReasmParams           fragOrReasmParams;  /**< Parameters for fragmentation/reassembly manipulation,
@@ -2061,13 +2181,13 @@ typedef struct t_FmPcdManipParams {
 *//***************************************************************************/
 typedef struct t_FmPcdManipReassemIpStats {
     /* common counters for both IPv4 and IPv6 */
-    uint32_t    timeout;                        /**< Counts the number of TimeOut occurrences */
-    uint32_t    rfdPoolBusy;                    /**< Counts the number of failed attempts to allocate
+    uint32_t        timeout;                    /**< Counts the number of TimeOut occurrences */
+    uint32_t        rfdPoolBusy;                /**< Counts the number of failed attempts to allocate
                                                      a Reassembly Frame Descriptor */
-    uint32_t    internalBufferBusy;             /**< Counts the number of times an internal buffer busy occurred */
-    uint32_t    externalBufferBusy;             /**< Counts the number of times external buffer busy occurred */
-    uint32_t    sgFragments;                    /**< Counts the number of Scatter/Gather fragments */
-    uint32_t    dmaSemaphoreDepletion;          /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    uint32_t        internalBufferBusy;         /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t        externalBufferBusy;         /**< Counts the number of times external buffer busy occurred */
+    uint32_t        sgFragments;                /**< Counts the number of Scatter/Gather fragments */
+    uint32_t        dmaSemaphoreDepletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
     struct {
         uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
         uint32_t    validFragments;             /**< Counts the total number of valid fragments that
@@ -2102,7 +2222,7 @@ typedef struct t_FmPcdManipReassemStats {
 } t_FmPcdManipReassemStats;
 
 /**************************************************************************//**
- @Description   structure for retrieving fragmentation statistics
+ @Description   Structure for retrieving fragmentation statistics
 *//***************************************************************************/
 typedef struct t_FmPcdManipFragStats {
     union {
@@ -2111,26 +2231,37 @@ typedef struct t_FmPcdManipFragStats {
 } t_FmPcdManipFragStats;
 
 /**************************************************************************//**
- @Description   structure for defining manipulation statistics
+ @Description   Structure for selecting manipulation statistics
 *//***************************************************************************/
 typedef struct t_FmPcdManipStats {
-    union{
+    union {
         t_FmPcdManipReassemStats    reassem;    /**< Structure for reassembly statistics */
         t_FmPcdManipFragStats       frag;       /**< Structure for fragmentation statistics */
     } u;
 } t_FmPcdManipStats;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Description   Parameters for defining frame replicator group and its members
 *//***************************************************************************/
 typedef struct t_FmPcdFrmReplicGroupParams {
-    uint8_t                     maxNumOfEntries;    /**< Maximal number of members in the group  - must be at least two */
-    uint8_t                     numOfEntries;       /**< Number of members in the group - must be at least 1 */
+    uint8_t                     maxNumOfEntries;    /**< Maximal number of members in the group;
+                                                         Must be at least 2. */
+    uint8_t                     numOfEntries;       /**< Number of members in the group;
+                                                         Must be at least 1. */
     t_FmPcdCcNextEngineParams   nextEngineParams[FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
                                                     /**< Array of members' parameters */
 } t_FmPcdFrmReplicGroupParams;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   structure for defining statistics node
+*//***************************************************************************/
+typedef struct t_FmPcdStatsParams {
+    e_FmPcdStatsType    type;   /**< type of statistics node */
+} t_FmPcdStatsParams;
+#endif /* FM_CAPWAP_SUPPORT */
 
 
 /**************************************************************************//**
@@ -2207,6 +2338,9 @@ t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv);
  @Param[in,out] p_SchemeParams  A structure of parameters for defining the scheme
 
  @Return        A handle to the initialized scheme on success; NULL code otherwise.
+                When used as "modify" (rather than for setting a new scheme),
+                p_SchemeParams->id.h_Scheme will return NULL if action fails due to scheme
+                BUSY state.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
@@ -2265,7 +2399,9 @@ t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value);
                                   policer profile entry.
 
  @Return        A handle to the initialized object on success; NULL code otherwise.
-
+                When used as "modify" (rather than for setting a new profile),
+                p_Profile->id.h_Profile will return NULL if action fails due to profile
+                BUSY state.
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 t_Handle FM_PCD_PlcrProfileSet(t_Handle                  h_FmPcd,
@@ -2320,7 +2456,7 @@ t_Error FM_PCD_PlcrProfileSetCounter(t_Handle                   h_Profile,
                                      uint32_t                   value);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcRoot
+ @Function      FM_PCD_CcRootBuild
 
  @Description   This routine must be called to define a complete coarse
                 classification tree. This is the way to define coarse
@@ -2358,7 +2494,7 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree);
  @Param[in]     h_CcTree                    A handle to the tree
  @Param[in]     grpId                       A Group index in the tree
  @Param[in]     index                       Entry index in the group defined by grpId
- @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+ @Param[in]     p_FmPcdCcNextEngineParams   Pointer to new next engine parameters
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -2370,7 +2506,7 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
                                       t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_EmSetNode
+ @Function      FM_PCD_MatchTableSet
 
  @Description   This routine should be called for each CC (coarse classification)
                 node. The whole CC tree should be built bottom up so that each
@@ -2383,7 +2519,7 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle   FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams  *p_Param);
+t_Handle   FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_Param);
 
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableDelete
@@ -2496,7 +2632,7 @@ t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle            h_CcNode,
 /**************************************************************************//**
  @Function      FM_PCD_MatchTableModifyKey
 
- @Description   Modify the key  in the index defined by the keyIndex.
+ @Description   Modify the key in the index defined by the keyIndex.
 
  @Param[in]     h_CcNode                    A handle to the node
  @Param[in]     keyIndex                    Key index for adding
@@ -2861,7 +2997,7 @@ t_Error  FM_PCD_ManipNodeDelete(t_Handle h_ManipNode);
 *//***************************************************************************/
 t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmPcdManipStats);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Function      FM_PCD_FrmReplicSetGroup
 
@@ -2921,17 +3057,10 @@ t_Error FM_PCD_FrmReplicAddMember(t_Handle                   h_FrmReplicGroup,
 *//***************************************************************************/
 t_Error FM_PCD_FrmReplicRemoveMember(t_Handle h_FrmReplicGroup,
                                      uint16_t memberIndex);
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 #ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
- @Description   structure for defining statistics node
-*//***************************************************************************/
-typedef struct t_FmPcdStatsParams {
-    e_FmPcdStatsType    type;   /**< type of statistics node */
-} t_FmPcdStatsParams;
-
-/**************************************************************************//**
  @Function      FM_PCD_StatisticsSetNode
 
  @Description   This routine should be called for defining a statistics node.
@@ -2952,8 +3081,11 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcds
 /** @} */ /* end of FM_grp group */
 
 
-#define NCSW_BACKWARD_COMPATIBLE_API
 #ifdef NCSW_BACKWARD_COMPATIBLE_API
+#define FM_PCD_MAX_NUM_OF_INTERCHANGABLE_HDRS   FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS
+#define e_FM_PCD_MANIP_ONE_WAYS_HASH            e_FM_PCD_MANIP_ONE_WAY_HASH
+#define e_FM_PCD_MANIP_TOW_WAYS_HASH            e_FM_PCD_MANIP_TWO_WAYS_HASH
+
 #define FM_PCD_SetNetEnvCharacteristics(_pcd, _params)  \
     FM_PCD_NetEnvCharacteristicsSet(_pcd, _params)
 #define FM_PCD_KgSetScheme(_pcd, _params)       FM_PCD_KgSchemeSet(_pcd, _params)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 2aed870..64dc103 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_port_ext.h
 
@@ -280,7 +281,7 @@ typedef struct t_FmPortParams {
     u_FmPortSpecificParams      specificParams;     /**< Additional parameters depending on port
                                                          type. */
 
-    t_FmPortExceptionCallback   *f_Exception;       /**< Callback routine to be called of PCD exception */
+    t_FmPortExceptionCallback   *f_Exception;       /**< Relevant for IM only Callback routine to be called on BUSY exception */
     t_Handle                    h_App;              /**< A handle to an application layer object; This handle will
                                                          be passed by the driver upon calling the above callbacks */
 } t_FmPortParams;
@@ -829,9 +830,17 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
 
  @Description   Calling this routine changes the write optimization
                 parameter in the internal driver data base
-                from its default configuration:  optimize = [DEFAULT_FM_SP_dmaWriteOptimize]
+                from its default configuration:  By default optimize = [DEFAULT_FM_SP_dmaWriteOptimize].
+                Note:
+
+                1. For head optimization, data alignment must be >= 16 (supported by default).
+
+                3. For tail optimization, note that the optimization is performed by extending the write transaction
+				of the frame payload at the tail as needed to achieve optimal bus transfers, so that the last write
+				is extended to be on 16/64 bytes aligned block (chip dependent).
+
 
-                May be used for non-Tx port types
+                Relevant for non-Tx port types
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
@@ -1148,6 +1157,23 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 *//***************************************************************************/
 t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigInternalBuffOffset
+
+ @Description   TODO
+                May be used for Rx and OP ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     val                 New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigInternalBuffOffset(t_Handle h_FmPort, uint8_t val);
+#endif /* (DPAA_VERSION >= 11) */
+
 /** @} */ /* end of FM_PORT_advanced_init_grp group */
 /** @} */ /* end of FM_PORT_init_grp group */
 
@@ -1202,12 +1228,12 @@ typedef struct t_FmPortCongestionGrps {
                                                         /**< An array of CG indexes;
                                                              Note that the size of the array should be
                                                              'numOfCongestionGrpsToConsider'. */
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     bool        pfcPrioritiesEn[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
                                                         /**< a matrix that represents the map between the CG ids
                                                              defined in 'congestionGrpsToConsider' to the priorties
                                                              mapping array. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 } t_FmPortCongestionGrps;
 
 
@@ -1852,7 +1878,7 @@ typedef struct t_FmPcdPrsStart {
                                              'parsingOffset' */
 } t_FmPcdPrsStart;
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Description   struct for defining external buffer margins
 *//***************************************************************************/
@@ -1861,9 +1887,9 @@ typedef struct t_FmPortVSPAllocParams {
     uint8_t     dfltRelativeId;         /**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
                                              The same default Virtual-Storage-Profile-id will be for coupled Tx port
                                              if relevant function called for Rx port */
-    t_Handle    h_FmTxPort;             /**< Handle to coupled Tx Port */
+    t_Handle    h_FmTxPort;             /**< Handle to coupled Tx Port; not relevant for OP port. */
 } t_FmPortVSPAllocParams;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 
 /**************************************************************************//**
@@ -1970,7 +1996,7 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
 *//***************************************************************************/
 t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
 
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
 /**************************************************************************//**
  @Function      FM_PORT_VSPAlloc
 
@@ -1987,7 +2013,7 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
                 and also before FM_PORT_Enable() (i.e. the port should be disabled).
 *//***************************************************************************/
 t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_Params);
-#endif /* DPAA_VERSION >= 3 */
+#endif /* (DPAA_VERSION >= 11) */
 
 /**************************************************************************//**
  @Function      FM_PORT_PcdKgModifyInitialScheme
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
index 8436944..c8fa262 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          fm_rtc_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h
index 311357e..f9aed03 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h
@@ -308,7 +308,7 @@ t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBm
 /** @} */ /* end of FM_VSP_adv_config_grp group */
 /** @} */ /* end of FM_VSP_init_grp group */
 
-#ifdef UNDER_CONSTRUCTION_FM_GEN
+
 /**************************************************************************//**
  @Group         FM_VSP_control_grp FM VSP Control Unit
 
@@ -318,35 +318,92 @@ t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBm
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Function      FM_VSP_GetStatistics
+ @Function      FM_VSP_GetBufferDataOffset
 
- @Description   Reads FM VSP counter.
+ @Description   Relevant for Rx ports.
+                Returns the data offset from the beginning of the data buffer
 
- @Param[in]     h_FmVsp             A handle to a FM VSP module.
+ @Param[in]     h_FmVsp - FM PORT module descriptor
 
- @Return        Counter's current value.
+ @Return        data offset.
 
  @Cautions      Allowed only following FM_VSP_Init().
-                Note that counters in summary of BM pools defined for this VSP
 *//***************************************************************************/
-uint32_t FM_VSP_GetStatistics(t_Handle h_FmVsp);
+uint32_t FM_VSP_GetBufferDataOffset(t_Handle h_FmVsp);
 
 /**************************************************************************//**
- @Function      FM_VSP_ModifyCounter
+ @Function      FM_VSP_GetBufferICInfo
 
- @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+ @Description   Returns the Internal Context offset from the beginning of the data buffer
 
- @Param[in]     h_FmVsp             A handle to a FM VSP module.
- @Param[in]     value               The requested value to be written into the counter.
+ @Param[in]     h_FmVsp - FM PORT module descriptor
+ @Param[in]     p_Data   - A pointer to the data buffer.
 
- @Return        E_OK on success; Error code otherwise.
+ @Return        Internal context info pointer on success, NULL if 'allOtherInfo' was not
+                configured for this port.
 
  @Cautions      Allowed only following FM_VSP_Init().
 *//***************************************************************************/
-t_Error FM_VSP_ModifyCounter(t_Handle h_FmVsp, uint32_t value);
+uint8_t * FM_VSP_GetBufferICInfo(t_Handle h_FmVsp, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferPrsResult
+
+ @Description   Returns the pointer to the parse result in the data buffer.
+                In Rx ports this is relevant after reception, if parse
+                result is configured to be part of the data passed to the
+                application. For non Rx ports it may be used to get the pointer
+                of the area in the buffer where parse result should be
+                initialized - if so configured.
+                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmVsp    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        Parse result pointer on success, NULL if parse result was not
+                configured for this port.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+t_FmPrsResult * FM_VSP_GetBufferPrsResult(t_Handle h_FmVsp, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferTimeStamp
+
+ @Description   Returns the time stamp in the data buffer.
+                Relevant for Rx ports for getting the buffer time stamp.
+                See FM_VSP_ConfigBufferPrefixContent for data buffer prefix
+                configuration.
+
+ @Param[in]     h_FmVsp    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+uint64_t * FM_VSP_GetBufferTimeStamp(t_Handle h_FmVsp, char *p_Data);
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetBufferHashResult
+
+ @Description   Given a data buffer, on the condition that hash result was defined
+                as a part of the buffer content (see FM_VSP_ConfigBufferPrefixContent)
+                this routine will return the pointer to the hash result location in the
+                buffer prefix.
+
+ @Param[in]     h_FmVsp    - FM PORT module descriptor
+ @Param[in]     p_Data      - A pointer to the data buffer.
+
+ @Return        A pointer to the hash result on success, NULL otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+uint8_t * FM_VSP_GetBufferHashResult(t_Handle h_FmVsp, char *p_Data);
+
 
 /** @} */ /* end of FM_VSP_control_grp group */
-#endif /* UNDER_CONSTRUCTION_FM_GEN */
 /** @} */ /* end of FM_VSP_grp group */
 /** @} */ /* end of FM_grp group */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
index 5b38fdb..f635d3c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
@@ -31,6 +31,7 @@
  */
 
 
+
 #ifndef __MII_ACC_EXT_H
 #define __MII_ACC_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
index 4b0c1e5..42174cf 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          core_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
index 1beb5a6..099c7b9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          e500v2_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
index 57c2889..9344b3a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          ppc_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
index 706f35a..e3d5d8d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __CTYPE_EXT_H
 #define __CTYPE_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
index 1d915ea..0b15dda 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          debug_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
index 99b08e8..5cdec66 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          endian_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
index ae4b267..79d2e78 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          enet_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
index 5917edd..25ceb02 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**
  @File          error_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
index 822b2bc..bb5496b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          list_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
index e12f382..5284959 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          mem_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
index 6157bdc..59351fa 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          memcpy_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
index 740a4fd..085b95c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
  /**************************************************************************//**
 
  @File          mm_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
index ad5c412..4e34234 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /******************************************************************************
 
  @File          sprint_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
index edddfe1..3c6bbc6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**
 
  @File          dpaa_integration_ext.h
@@ -42,7 +43,7 @@
 #include "std_ext.h"
 
 
-#define DPAA_VERSION    2
+#define DPAA_VERSION    10
 
 typedef enum e_DpaaSwPortal {
     e_DPAA_SWPORTAL0 = 0,
@@ -212,7 +213,6 @@ typedef enum e_FmMacsecInterModuleEvent {
 
 #define FM_DEBUG_TRACE_FMAN_A004                        /* No implementation, Out of LLD scope */
 #define FM_INT_BUF_LEAK_FMAN_A005                       /* No implementation, Out of LLD scope. App must avoid S/G */
-//TODO: #define FM___ERRATA_FMAN_A006
 
 /* #define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
index 3253782..ac7a33a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**
 
  @File          part_integration_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index 389572d..270b61e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -42,7 +42,7 @@
 #include "std_ext.h"
 
 
-#define DPAA_VERSION    2
+#define DPAA_VERSION    10
 
 /**************************************************************************//**
  @Description   DPAA SW Portals Enumeration.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
index a622fc5..bff428d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __MATH_EXT_H
 #define __MATH_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
index a89b604..29df6f4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
  /**************************************************************************//**
  @File          ncsw_ext.h
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
index 1c8aa58..c684647 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          net_ext.h
 
@@ -82,6 +83,7 @@ typedef uint8_t headerFieldEth_t;
 #define NET_HEADER_FIELD_ETH_PADDING                    (NET_HEADER_FIELD_ETH_DA << 5)
 #define NET_HEADER_FIELD_ETH_ALL_FIELDS                 ((NET_HEADER_FIELD_ETH_DA << 6) - 1)
 
+#define NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
 
 typedef uint16_t headerFieldIpv4_t;
 
@@ -102,6 +104,9 @@ typedef uint16_t headerFieldIpv4_t;
 #define NET_HEADER_FIELD_IPv4_OPTS_COUNT                (NET_HEADER_FIELD_IPv4_VER << 14)
 #define NET_HEADER_FIELD_IPv4_ALL_FIELDS                ((NET_HEADER_FIELD_IPv4_VER << 15) - 1)
 
+#define NET_HEADER_FIELD_IPv4_ADDR_SIZE                 4
+#define NET_HEADER_FIELD_IPv4_PROTO_SIZE                1
+
 
 typedef uint8_t headerFieldIpv6_t;
 
@@ -114,6 +119,9 @@ typedef uint8_t headerFieldIpv6_t;
 #define NET_HEADER_FIELD_IPv6_HOP_LIMIT                 (NET_HEADER_FIELD_IPv6_VER << 6)
 #define NET_HEADER_FIELD_IPv6_ALL_FIELDS                ((NET_HEADER_FIELD_IPv6_VER << 7) - 1)
 
+#define NET_HEADER_FIELD_IPv6_ADDR_SIZE                 16
+#define NET_HEADER_FIELD_IPv6_NEXT_HDR_SIZE             1
+
 #define NET_HEADER_FIELD_ICMP_TYPE                      (1)
 #define NET_HEADER_FIELD_ICMP_CODE                      (NET_HEADER_FIELD_ICMP_TYPE << 1)
 #define NET_HEADER_FIELD_ICMP_CKSUM                     (NET_HEADER_FIELD_ICMP_TYPE << 2)
@@ -121,6 +129,9 @@ typedef uint8_t headerFieldIpv6_t;
 #define NET_HEADER_FIELD_ICMP_SQ_NUM                    (NET_HEADER_FIELD_ICMP_TYPE << 4)
 #define NET_HEADER_FIELD_ICMP_ALL_FIELDS                ((NET_HEADER_FIELD_ICMP_TYPE << 5) - 1)
 
+#define NET_HEADER_FIELD_ICMP_CODE_SIZE                 1
+#define NET_HEADER_FIELD_ICMP_TYPE_SIZE                 1
+
 #define NET_HEADER_FIELD_IGMP_VERSION                   (1)
 #define NET_HEADER_FIELD_IGMP_TYPE                      (NET_HEADER_FIELD_IGMP_VERSION << 1)
 #define NET_HEADER_FIELD_IGMP_CKSUM                     (NET_HEADER_FIELD_IGMP_VERSION << 2)
@@ -143,6 +154,8 @@ typedef uint16_t headerFieldTcp_t;
 #define NET_HEADER_FIELD_TCP_OPTS_COUNT                 (NET_HEADER_FIELD_TCP_PORT_SRC << 10)
 #define NET_HEADER_FIELD_TCP_ALL_FIELDS                 ((NET_HEADER_FIELD_TCP_PORT_SRC << 11) - 1)
 
+#define NET_HEADER_FIELD_TCP_PORT_SIZE                  2
+
 
 typedef uint8_t headerFieldSctp_t;
 
@@ -152,6 +165,7 @@ typedef uint8_t headerFieldSctp_t;
 #define NET_HEADER_FIELD_SCTP_CKSUM                     (NET_HEADER_FIELD_SCTP_PORT_SRC << 3)
 #define NET_HEADER_FIELD_SCTP_ALL_FIELDS                ((NET_HEADER_FIELD_SCTP_PORT_SRC << 4) - 1)
 
+#define NET_HEADER_FIELD_SCTP_PORT_SIZE                 2
 
 typedef uint8_t headerFieldDccp_t;
 
@@ -159,6 +173,8 @@ typedef uint8_t headerFieldDccp_t;
 #define NET_HEADER_FIELD_DCCP_PORT_DST                  (NET_HEADER_FIELD_DCCP_PORT_SRC << 1)
 #define NET_HEADER_FIELD_DCCP_ALL_FIELDS                ((NET_HEADER_FIELD_DCCP_PORT_SRC << 2) - 1)
 
+#define NET_HEADER_FIELD_DCCP_PORT_SIZE                 2
+
 
 typedef uint8_t headerFieldUdp_t;
 
@@ -168,6 +184,8 @@ typedef uint8_t headerFieldUdp_t;
 #define NET_HEADER_FIELD_UDP_CKSUM                      (NET_HEADER_FIELD_UDP_PORT_SRC << 3)
 #define NET_HEADER_FIELD_UDP_ALL_FIELDS                 ((NET_HEADER_FIELD_UDP_PORT_SRC << 4) - 1)
 
+#define NET_HEADER_FIELD_UDP_PORT_SIZE                  2
+
 typedef uint8_t headerFieldUdpEncapEsp_t;
 
 #define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC         (1)
@@ -178,6 +196,9 @@ typedef uint8_t headerFieldUdpEncapEsp_t;
 #define NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM     (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 5)
 #define NET_HEADER_FIELD_UDP_ENCAP_ESP_ALL_FIELDS       ((NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC << 6) - 1)
 
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SIZE        2
+#define NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI_SIZE         4
+
 #define NET_HEADER_FIELD_IPHC_CID                       (1)
 #define NET_HEADER_FIELD_IPHC_CID_TYPE                  (NET_HEADER_FIELD_IPHC_CID << 1)
 #define NET_HEADER_FIELD_IPHC_HCINDEX                   (NET_HEADER_FIELD_IPHC_CID << 2)
@@ -326,6 +347,8 @@ typedef uint8_t headerFieldIpsecEsp_t;
 #define NET_HEADER_FIELD_IPSEC_ESP_SEQUENCE_NUM         (NET_HEADER_FIELD_IPSEC_ESP_SPI << 1)
 #define NET_HEADER_FIELD_IPSEC_ESP_ALL_FIELDS           ((NET_HEADER_FIELD_IPSEC_ESP_SPI << 2) - 1)
 
+#define NET_HEADER_FIELD_IPSEC_ESP_SPI_SIZE             4
+
 
 typedef uint8_t headerFieldMpls_t;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
index 95e452d..9bb18f4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
  /**************************************************************************//**
 
  @File          std_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
index 8037f7646..3c8bb0a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __STDARG_EXT_H
 #define __STDARG_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
index b3a8b57..a47860c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
@@ -31,6 +31,7 @@
  */
 
 
+
 #ifndef __STDLIB_EXT_H
 #define __STDLIB_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
index 298fdb8..a5c6c7e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 #ifndef __STRING_EXT_H
 #define __STRING_EXT_H
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
index 40e6bf9..29ab09c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
  /**************************************************************************//**
  @File          types_ext.h
 
@@ -63,21 +64,19 @@ static __inline__ void TypesChecker(void)
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
      _Packed struct strct {
         __volatile__ int vi;
     } _PackedType;
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
     size_t          size = 0;
     bool            tr = TRUE, fls = FALSE;
-    struct strct    *p_Strct = NULL;
+    struct strct    *p_Struct = NULL;
     physAddress_t   addr = 0x100;
 
-    tr      = fls;
-    p_Strct = p_Strct;
+    tr          = fls;
+    p_Struct    = p_Struct;
     size++;
     if (tr) size++;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
index 0721079..3a4ed69 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
@@ -31,6 +31,7 @@
  */
 
 
+
 /* Module names for debug messages */
 const char *moduleStrings[] =
 {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
index 2b3c6de..e45ea14 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
@@ -140,7 +140,7 @@
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
 #if CMP_IOC_DEFINE(FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES)
 #error Error: please synchronize IOC_ defines!
 #endif
@@ -358,7 +358,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_extracted_or_params_t) == sizeof(t_FmPcdKgExtractedOrParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_scheme_counter_t) == sizeof(t_FmPcdKgSchemeCounter));
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_plcr_profile_t) == sizeof(t_FmPcdKgPlcrProfile));
-#if DPAA_VERSION >= 3
+#if (DPAA_VERSION >= 11)
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_storage_profile_t) == sizeof(t_FmPcdKgStorageProfile));
 #endif
     ASSERT_COND(sizeof(ioc_fm_pcd_kg_cc_t) == sizeof(t_FmPcdKgCc));
@@ -415,7 +415,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_stats_t) == sizeof(t_FmPcdManipReassemStats));
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_stats_t) == sizeof(t_FmPcdManipFragStats));
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_stats_t) == sizeof(t_FmPcdManipStats));
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     ASSERT_COND(sizeof(ioc_fm_pcd_frm_replic_group_params_t) == sizeof(t_FmPcdFrmReplicGroupParams));
 #endif
 
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index d48fd98..935b0c0 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -103,9 +103,9 @@
 #define IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
                                                                              insert manipulation */
 
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
 #define IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 /* @} */
 
@@ -972,7 +972,7 @@ typedef struct ioc_fm_pcd_kg_plcr_profile_t {
     } profile_select;
 } ioc_fm_pcd_kg_plcr_profile_t;
 
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
 /**************************************************************************//**
  @Description   Parameters for configuring a storage profile for a KeyGen scheme.
 *//***************************************************************************/
@@ -998,7 +998,7 @@ typedef struct ioc_fm_pcd_kg_storage_profile_t {
         } indirect_profile;                          /**< Indirect profile parameters. */
     } profile_select;                                /**< Direct/indirect profile selection and parameters. */
 } ioc_fm_pcd_kg_storage_profile_t;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 /**************************************************************************//**
  @Description   A structure for CC parameters if CC is the next engine after KG
@@ -1055,10 +1055,10 @@ typedef struct ioc_fm_pcd_kg_scheme_params_t {
                                                               actions; Normally only some will be used
                                                               for qidMask. Driver will return error if
                                                               resource is full at initialization time. */
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     bool                                override_storage_profile; /**< TRUE if KeyGen override previously decided storage profile */
     ioc_fm_pcd_kg_storage_profile       storage_profile;        /**< Used when overrideStorageProfile TRUE */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
     ioc_fm_pcd_engine                   next_engine;     /**< may be BMI, PLCR or CC */
     union{                                               /**< depends on nextEngine */
@@ -1098,12 +1098,12 @@ typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
                                                 In earlier chips  if policer next engine is KEYGEN,
                                                 this parameter can be 0, because the KEYGEN always decides
                                                 the enqueue FQID.*/
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     uint8_t     new_relative_storage_profileId;
                                         /**< Indicates the relative storage profile offset within
                                              the port's storage profiles window;
                                              Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 } ioc_fm_pcd_cc_next_plcr_params_t;
 
@@ -1118,12 +1118,12 @@ typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
     uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
                                                  (otherwise FQID is taken from keygen),
                                                  relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     uint8_t              new_relative_storage_profile_id;
                                         /**< Indicates the relative storage profile offset within
                                              the port's storage profiles window;
                                              Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 } ioc_fm_pcd_cc_next_enqueue_params_t;
 
@@ -1138,12 +1138,12 @@ typedef struct ioc_fm_pcd_cc_next_kg_params_t {
                                          (otherwise FQID is taken from keygen),
                                           Note - this parameters unrelevant for earlier chips*/
     void       *p_direct_scheme;        /**< Direct scheme handle to go to. */
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     uint8_t              new_relative_storage_profile_id;
                                         /**< Indicates the relative storage profile offset within
                                              the port's storage profiles window;
                                              Relevant only if the port was configured with VSP. */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 } ioc_fm_pcd_cc_next_kg_params_t;
 
 /**************************************************************************//**
@@ -1159,10 +1159,10 @@ typedef struct ioc_fm_pcd_cc_next_engine_params_t {
             ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
             ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
     } params;
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
     void                                        *p_frm_replic_id; /**< Handle to frame replicator group;
                                                                        Relevant if next engine is e_FM_PCD_INVALID) */
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
     void                                        *manip_id;      /**< Handle to Manipulation object.
                                                                      Relevant if next engine is of type result
@@ -1455,9 +1455,9 @@ typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
 typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
     uint16_t                    size_for_fragmentation;   /**< If length of the frame is greater than this value,
                                                              IP fragmentation will be executed.*/
-#if (DPAA_VERSION == 2)
+#if (DPAA_VERSION == 10)
     uint8_t                     scratch_bpid;            /**< Absolute buffer pool id according to BM configuration.*/
-#endif /* (DPAA_VERSION == 2) */
+#endif /* (DPAA_VERSION == 10) */
     bool                        sg_bpid_en;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
                                                              If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
                                                              received frame's buffer. */
@@ -1702,7 +1702,7 @@ typedef struct ioc_fm_pcd_manip_stats_t {
     } u;
 } ioc_fm_pcd_manip_stats_t;
 
-#if DPAA_VERSION >= 3
+#if DPAA_VERSION >= 11
 /**************************************************************************//**
  @Description   Parameters for defining frame replicator group and its members
 *//***************************************************************************/
@@ -1712,7 +1712,7 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
     ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
                                                     /**< Array of members' parameters */
 } ioc_fm_pcd_frm_replic_group_params_t;
-#endif /* DPAA_VERSION >= 3 */
+#endif /* DPAA_VERSION >= 11 */
 
 /**************************************************************************//**
  @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
-- 
1.7.9.7

