From d20e002c3e18edff355f1fc266ef2e5b866c8530 Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Thu, 9 Aug 2012 22:27:29 +0000
Subject: [PATCH 034/162] dpaa_eth: add S/G support for MAC-less/Shared MAC Rx

Add Scatter/Gather support for the MAC-less and Shared MAC
reception path.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c    |  130 +++++++++++++++++++---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h    |   10 ++
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c |    1 -
 3 files changed, 127 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 05e2f37..5dc13e8 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -623,6 +623,63 @@ dpa_fq_free(struct device *dev, struct list_head *list)
 	return _errno;
 }
 
+static void
+dpa_fd_release_unmapped(const struct net_device *net_dev,
+			const struct qm_fd *fd)
+{
+	int				 i, j;
+	const struct dpa_priv_s		*priv;
+	struct qm_sg_entry		*sgt;
+	struct dpa_bp			*_dpa_bp, *dpa_bp;
+	struct bm_buffer		 _bmb, bmb[8];
+
+	priv = netdev_priv(net_dev);
+
+	_bmb.hi	= fd->addr_hi;
+	_bmb.lo	= fd->addr_lo;
+
+	_dpa_bp = dpa_bpid2pool(fd->bpid);
+
+	if (fd->format == qm_fd_sg) {
+		sgt = kmalloc(DPA_SGT_MAX_ENTRIES * sizeof(*sgt), GFP_ATOMIC);
+		if (sgt == NULL) {
+			if (netif_msg_tx_err(priv) && net_ratelimit())
+				cpu_netdev_err(net_dev,
+					"Memory allocation failed\n");
+			return;
+		}
+
+		copy_from_unmapped_area(sgt, bm_buf_addr(&_bmb) +
+						dpa_fd_offset(fd),
+					min(DPA_SGT_MAX_ENTRIES * sizeof(*sgt),
+						_dpa_bp->size));
+
+		i = 0;
+		do {
+			dpa_bp = dpa_bpid2pool(sgt[i].bpid);
+			BUG_ON(IS_ERR(dpa_bp));
+
+			j = 0;
+			do {
+				BUG_ON(sgt[i].extension);
+
+				bmb[j].hi	= sgt[i].addr_hi;
+				bmb[j].lo	= sgt[i].addr_lo;
+
+				j++; i++;
+			} while (j < ARRAY_SIZE(bmb) &&
+					!sgt[i-1].final &&
+					sgt[i-1].bpid == sgt[i].bpid);
+
+			while (bman_release(dpa_bp->pool, bmb, j, 0))
+				cpu_relax();
+		} while (!sgt[i-1].final);
+		kfree(sgt);
+	}
+
+	while (bman_release(_dpa_bp->pool, &_bmb, 1, 0))
+		cpu_relax();
+}
 
 void __attribute__((nonnull))
 dpa_fd_release(const struct net_device *net_dev, const struct qm_fd *fd)
@@ -1715,12 +1772,17 @@ shared_rx_dqrr(struct qman_portal *portal, struct qman_fq *fq,
 	const struct qm_fd *fd = &dq->fd;
 	struct dpa_bp *dpa_bp;
 	struct sk_buff *skb;
+	struct qm_sg_entry *sgt;
+	int i;
 
 	net_dev = ((struct dpa_fq *)fq)->net_dev;
 	priv = netdev_priv(net_dev);
 
 	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
 
+	dpa_bp = dpa_bpid2pool(fd->bpid);
+	BUG_ON(IS_ERR(dpa_bp));
+
 	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
 		if (netif_msg_hw(priv) && net_ratelimit())
 			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
@@ -1731,18 +1793,6 @@ shared_rx_dqrr(struct qman_portal *portal, struct qman_fq *fq,
 		goto out;
 	}
 
-	dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(IS_ERR(dpa_bp));
-
-	if (fd->format == qm_fd_sg) {
-		percpu_priv->stats.rx_dropped++;
-		if (netif_msg_rx_status(priv) && net_ratelimit())
-			cpu_netdev_warn(net_dev,
-				"%s:%hu:%s(): Dropping a SG frame\n",
-				__file__, __LINE__, __func__);
-		goto out;
-	}
-
 	skb = __netdev_alloc_skb(net_dev,
 				 DPA_BP_HEAD + dpa_fd_length(fd),
 				 GFP_ATOMIC);
@@ -1757,6 +1807,56 @@ shared_rx_dqrr(struct qman_portal *portal, struct qman_fq *fq,
 
 	skb_reserve(skb, DPA_BP_HEAD);
 
+	if (fd->format == qm_fd_sg) {
+		if (dpa_bp->vaddr) {
+			sgt = dpa_phys2virt(dpa_bp,
+					    qm_fd_addr(fd)) + dpa_fd_offset(fd);
+
+			for (i = 0; i < DPA_SGT_MAX_ENTRIES; i++) {
+				BUG_ON(sgt[i].extension);
+
+				/* copy from sgt[i] */
+				memcpy(skb_put(skb, sgt[i].length),
+					dpa_phys2virt(dpa_bp,
+							qm_sg_addr(&sgt[i]) +
+							sgt[i].offset),
+					sgt[i].length);
+				if (sgt[i].final)
+					break;
+			}
+		} else {
+			sgt = kmalloc(DPA_SGT_MAX_ENTRIES * sizeof(*sgt),
+					GFP_ATOMIC);
+			if (unlikely(sgt == NULL)) {
+				if (netif_msg_tx_err(priv) && net_ratelimit())
+					cpu_netdev_err(net_dev,
+						"Memory allocation failed\n");
+				return -ENOMEM;
+			}
+
+			copy_from_unmapped_area(sgt,
+					qm_fd_addr(fd) + dpa_fd_offset(fd),
+					min(DPA_SGT_MAX_ENTRIES * sizeof(*sgt),
+							dpa_bp->size));
+
+			for (i = 0; i < DPA_SGT_MAX_ENTRIES; i++) {
+				BUG_ON(sgt[i].extension);
+
+				copy_from_unmapped_area(
+					skb_put(skb, sgt[i].length),
+					qm_sg_addr(&sgt[i]) + sgt[i].offset,
+					sgt[i].length);
+
+				if (sgt[i].final)
+					break;
+			}
+
+			kfree(sgt);
+		}
+		goto skb_copied;
+	}
+
+	/* otherwise fd->format == qm_fd_contig */
 	if (dpa_bp->vaddr) {
 		/* Fill the SKB */
 		memcpy(skb_put(skb, dpa_fd_length(fd)),
@@ -1768,6 +1868,7 @@ shared_rx_dqrr(struct qman_portal *portal, struct qman_fq *fq,
 					dpa_fd_length(fd));
 	}
 
+skb_copied:
 	skb->protocol = eth_type_trans(skb, net_dev);
 
 	if (unlikely(dpa_check_rx_mtu(skb, net_dev->mtu))) {
@@ -1786,7 +1887,10 @@ shared_rx_dqrr(struct qman_portal *portal, struct qman_fq *fq,
 	net_dev->last_rx = jiffies;
 
 out:
-	dpa_fd_release(net_dev, fd);
+	if ((fd->format == qm_fd_sg) && (!dpa_bp->vaddr))
+		dpa_fd_release_unmapped(net_dev, fd);
+	else
+		dpa_fd_release(net_dev, fd);
 
 	return qman_cb_dqrr_consume;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 0ed99d7..6d48c8d 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -139,6 +139,8 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 			DPA_HASH_RESULTS_SIZE)
 #define DPA_BP_SIZE(s)	(DPA_BP_HEAD + dpa_get_rx_extra_headroom() + (s))
 
+#define DPA_SGT_MAX_ENTRIES 16 /* maximum number of entries in SG Table */
+
 #ifdef CONFIG_DPAA_ETH_SG_SUPPORT
 #define DEFAULT_SKB_COUNT 64 /* maximum number of SKBs in each percpu list */
 /*
@@ -224,7 +226,15 @@ struct dpa_bp {
 	};
 	size_t				size;
 	bool				seed_pool;
+	/*
+	 * physical address of the contiguous memory used by the pool to store
+	 * the buffers
+	 */
 	dma_addr_t			paddr;
+	/*
+	 * virtual address of the contiguous memory used by the pool to store
+	 * the buffers
+	 */
 	void				*vaddr;
 	int kernel_pool;
 	/* current number of buffers in the bpool alloted to this CPU */
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 8f27b19..2e02878 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -40,7 +40,6 @@
 #ifdef CONFIG_DPAA_ETH_SG_SUPPORT
 
 #define DPA_COPIED_HEADERS_SIZE 128 /* TODO: determine the required value */
-#define DPA_SGT_MAX_ENTRIES 16 /* maximum number of entries in SG Table */
 
 /*
  * It does not return a page as you get the page from the fd,
-- 
1.7.9.7

