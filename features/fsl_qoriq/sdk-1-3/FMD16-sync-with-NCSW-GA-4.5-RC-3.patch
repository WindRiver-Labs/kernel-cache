From f60f314bafd642edbef91c4a022e5fa7d63d66d4 Mon Sep 17 00:00:00 2001
From: Andrei Pistirica <sorin.pistirica@freescale.com>
Date: Tue, 22 May 2012 13:20:37 +0300
Subject: [PATCH 067/162] FMD16 sync with NCSW GA 4.5 RC 3.

Update to Soft-Parser code to fix IP tunneling case.
Some cosmetic changes and few fixes.

Signed-off-by: Andrei Pistirica
Signed-off-by: Stefan Szabo <szbs001@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c       |   19 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c      |   28 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h      |    8 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |   19 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h       |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       |   62 +--
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       |    5 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h      |    8 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |   20 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |  397 ++++++++++----------
 .../dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h     |   49 ++-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.c          |   37 +-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.h          |    8 +-
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      |    2 +-
 14 files changed, 362 insertions(+), 302 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index 7e67734..79c5a53 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -710,10 +710,10 @@ static t_Error DtsecDisable (t_Handle h_Dtsec, e_CommMode mode)
 
 /* .............................................................................. */
 
-static t_Error DtsecTxMacPause(t_Handle h_Dtsec,
-                               uint8_t  priority,
-                               uint16_t pauseTime,
-                               uint16_t threshTime)
+static t_Error DtsecSetTxPauseFrames(t_Handle h_Dtsec,
+                                     uint8_t  priority,
+                                     uint16_t pauseTime,
+                                     uint16_t threshTime)
 {
     t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
     uint32_t        ptv = 0;
@@ -754,6 +754,14 @@ UNUSED(priority);UNUSED(threshTime);
 
 /* .............................................................................. */
 
+static t_Error DtsecSetTxAutoPauseFrames(t_Handle h_Dtsec,
+                                         uint16_t pauseTime)
+{
+    return DtsecSetTxPauseFrames(h_Dtsec, 0, pauseTime, 0);
+}
+
+/* .............................................................................. */
+
 static t_Error DtsecRxIgnoreMacPause(t_Handle h_Dtsec, bool en)
 {
     t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
@@ -1840,7 +1848,8 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = DtsecEnable1588TimeStamp;
     p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = DtsecDisable1588TimeStamp;
 
-    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = DtsecTxMacPause;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = DtsecSetTxAutoPauseFrames;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames          = DtsecSetTxPauseFrames;
     p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = DtsecRxIgnoreMacPause;
 
     p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = DtsecResetCounters;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index 478dfd9..b252456 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -324,9 +324,7 @@ t_Error FM_MAC_Disable1588TimeStamp (t_Handle h_FmMac)
 /* ........................................................................... */
 
 t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
-                                    uint8_t  priority,
-                                    uint16_t pauseTime,
-                                    uint16_t threshTime)
+                                    uint16_t pauseTime)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
 
@@ -334,9 +332,27 @@ t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
 
     if (p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames)
         return p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames(h_FmMac,
-                                                                      priority,
-                                                                      pauseTime,
-                                                                      threshTime);
+                                                                      pauseTime);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
+t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac,
+                                uint8_t  priority,
+                                uint16_t pauseTime,
+                                uint16_t threshTime)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames)
+        return p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames(h_FmMac,
+                                                                  priority,
+                                                                  pauseTime,
+                                                                  threshTime);
 
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
index 0afb049..5abc1b9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -106,9 +106,11 @@ typedef struct {
     t_Error (*f_FM_MAC_Reset)   (t_Handle h_FmMac, bool wait);
 
     t_Error (*f_FM_MAC_SetTxAutoPauseFrames) (t_Handle h_FmMac,
-                                              uint8_t  priority,
-                                              uint16_t pauseTime,
-                                              uint16_t threshTime);
+                                              uint16_t pauseTime);
+    t_Error (*f_FM_MAC_SetTxPauseFrames) (t_Handle h_FmMac,
+                                          uint8_t  priority,
+                                          uint16_t pauseTime,
+                                          uint16_t threshTime);
     t_Error (*f_FM_MAC_SetRxIgnorePauseFrames) (t_Handle h_FmMac, bool en);
 
     t_Error (*f_FM_MAC_ResetCounters) (t_Handle h_FmMac);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index 04c497f..72c6d52 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -439,10 +439,10 @@ static t_Error TgecConfigSkipFman11Workaround(t_Handle h_Tgec)
 
 /* .............................................................................. */
 
-static t_Error TgecTxMacPause(t_Handle h_Tgec,
-                              uint8_t  priority,
-                              uint16_t pauseTime,
-                              uint16_t threshTime)
+static t_Error TgecSetTxPauseFrames(t_Handle h_Tgec,
+                                    uint8_t  priority,
+                                    uint16_t pauseTime,
+                                    uint16_t threshTime)
 {
     t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
     uint32_t        ptv = 0;
@@ -465,6 +465,14 @@ UNUSED(priority);UNUSED(threshTime);
 
 /* .............................................................................. */
 
+static t_Error TgecSetTxAutoPauseFrames(t_Handle h_Tgec,
+                                        uint16_t pauseTime)
+{
+    return TgecSetTxPauseFrames(h_Tgec, 0, pauseTime, 0);
+}
+
+/* .............................................................................. */
+
 static t_Error TgecRxIgnoreMacPause(t_Handle h_Tgec, bool en)
 {
     t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
@@ -1152,7 +1160,8 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = TgecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = TgecDisable;
 
-    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = TgecTxMacPause;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = TgecSetTxAutoPauseFrames;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames          = TgecSetTxPauseFrames;
     p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = TgecRxIgnoreMacPause;
 
     p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = TgecResetCounters;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
index aa320a3..335ee68 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
@@ -58,7 +58,7 @@
  */
 struct crc64_t {
     uint64_t initial;                       /**< Initial seed */
-    uint64_t table[CRC64_TABLE_ENTRIES];    /**< crc table entries*/
+    uint64_t table[CRC64_TABLE_ENTRIES];    /**< CRC table entries */
 };
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 28a21ed..4ac056f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -234,8 +234,6 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_Fm
         else
             h_AdTmp = PTR_MOVE(h_AdTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        if(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & requiredAction)
-            continue;
         switch(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.nextEngine)
         {
             case(e_FM_PCD_CC):
@@ -353,6 +351,7 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
     SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdOldPointersLst)),E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((1 == LIST_NumOfObjs(h_FmPcdNewPointersLst)),E_INVALID_STATE);
 
+
     /* We don't update subtree of the new node with new tree because it was done in the previous stage */
     if (p_AdditionalParams->h_NodeForAdd)
     {
@@ -463,11 +462,17 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
         h_Muram = FmPcdGetMuramHandle(h_FmPcd);
         ASSERT_COND(h_Muram);
 
-        /* We release new AD which was allocated and updated for copy from to actual AD */
-        p_Pos = LIST_FIRST(h_FmPcdNewPointersLst);
-        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        ASSERT_COND(p_CcNodeInformation->h_CcNode);
-        FM_MURAM_FreeMem(h_Muram, p_CcNodeInformation->h_CcNode);
+        if ((p_AdditionalParams->tree &&
+             !((t_FmPcd *)h_FmPcd)->p_CcShadow) ||
+            (!p_AdditionalParams->tree &&
+             !((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->maxNumOfKeys))
+        {
+            /* We release new AD which was allocated and updated for copy from to actual AD */
+            p_Pos = LIST_FIRST(h_FmPcdNewPointersLst);
+            p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+            ASSERT_COND(p_CcNodeInformation->h_CcNode);
+            FM_MURAM_FreeMem(h_Muram, p_CcNodeInformation->h_CcNode);
+        }
 
         /* Free Old data structure if it has to be freed - new data structure was allocated*/
         if (p_AdditionalParams->p_AdTableOld)
@@ -1946,25 +1951,18 @@ static void UpdateGblMask(t_FmPcdCcNode *p_CcNode,
 
 static __inline t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
 {
-    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
     t_FmPcd         *p_FmPcd;
     t_Handle        h_Ad;
 
-    if ((isTree) || (p_CcNode->maxNumOfKeys == 0))
-    {
-        h_Ad = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
-                                           FM_PCD_CC_AD_ENTRY_SIZE,
-                                           FM_PCD_CC_AD_TABLE_ALIGN);
-        if (!h_Ad)
-        {
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptor"));
-            return NULL;
-        }
-    }
+
+    if(isTree)
+        p_FmPcd = (t_FmPcd *)(((t_FmPcdCcTree *)h_FmPcdCcNodeOrTree)->h_FmPcd);
     else
-    {
-        p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+        p_FmPcd = (t_FmPcd *)(((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_FmPcd);
 
+
+    if((isTree && p_FmPcd->p_CcShadow) || (!isTree && ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->maxNumOfKeys))
+    {
         /* The allocated shadow is divided as follows:
            0 . . .       16 . . .
            ---------------------------------------------------
@@ -1981,6 +1979,17 @@ static __inline t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
 
         h_Ad = p_FmPcd->p_CcShadow;
     }
+    else
+    {
+        h_Ad = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
+                                           FM_PCD_CC_AD_ENTRY_SIZE,
+                                           FM_PCD_CC_AD_TABLE_ALIGN);
+        if (!h_Ad)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptor"));
+            return NULL;
+        }
+    }
 
     return h_Ad;
 }
@@ -3568,6 +3577,10 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
 
     p_ModifyKeyParams->tree = TRUE;
 
+    if(p_FmPcd->p_CcShadow)
+        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+            return ERROR_CODE(E_BUSY);
+
     err = BuildNewNodeModifyNextEngine(p_FmPcd,
                                        p_FmPcdCcTree,
                                        keyIndex,
@@ -3581,7 +3594,12 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    return DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+
+    if (p_FmPcd->p_CcShadow)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+
+    return err;
 
 }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index 05cc279..5845a6c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -1172,9 +1172,6 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
     if (grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
         p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
 
-    /* clear clsPlan driver structure */
-    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
-
     /* free blocks */
     if (p_FmPcd->guestId == NCSW_MASTER_ID)
     {
@@ -1216,6 +1213,8 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
             return;
         }
     }
+    /* clear clsPlan driver structure */
+    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
 }
 
 t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
index 1c886cc..b0240e7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
@@ -47,18 +47,18 @@
 /***********************************************************************/
 
 #if (DPAA_VERSION == 10)
-/* Version: 106.5 */
+/* Version: 106.1.6 */
 #define SW_PRS_IP_FRAG_PATCH                           \
 {                                                      \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x31,0x52,0x00,0xDA,0x0A,0x00,0x00,0x00,0x00,0x00, \
     0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
     0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
     0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
     0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0, \
     0x00,0x4A,0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x31,0x52,0x00,0xDA,0x06,0x00,0x00,0x00,0x00,0x00, \
     0x00,0x00,0x43,0x28,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00, \
+    0x31,0x52,0x00,0xDA,0x00,0x40,0x00,0x00,0x00,0x00, \
     0x00,0x00,0x53,0x8F,0x00,0x00,0x32,0xC1,0x00,0x55, \
     0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
     0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index f8d49eb..a31ef75 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -3188,7 +3188,9 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
 
     p_FmPort->explicitUserSizeOfFifo = TRUE;
     /* we do not change user's parameter */
-    VerifySizeOfFifo(p_FmPort);
+    err = VerifySizeOfFifo(p_FmPort);
+    if(err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     err = FmSetSizeOfFifo(p_FmPort->h_Fm, p_FmPort->hardwarePortId, p_SizeOfFifo->num, p_SizeOfFifo->extra, FALSE);
     if(err)
@@ -4578,9 +4580,12 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
 
 t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 {
-    t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-    t_Error             err = E_OK;
-    t_FmPortPcdParams   modifiedPcdParams, *p_PcdParams;
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                 err = E_OK;
+    t_FmPortPcdParams       modifiedPcdParams, *p_PcdParams;
+    t_FmPcdCcTreeParams     *p_FmPcdCcTreeParams;
+    t_FmPortPcdCcParams     fmPortPcdCcParams;
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -4612,10 +4617,6 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
         p_FmPort->h_IpReassemblyManip = p_PcdParams->h_IpReassemblyManip;
         if (!p_PcdParams->p_CcParams)
         {
-            /* No user-tree, need to build internal tree */
-            t_FmPcdCcTreeParams         *p_FmPcdCcTreeParams;
-            t_FmPortPcdCcParams         fmPortPcdCcParams;
-
             if (!((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG) ||
                   (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR)))
             {
@@ -4623,6 +4624,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
             }
 
+            /* No user-tree, need to build internal tree */
             p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
             if(!p_FmPcdCcTreeParams)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
@@ -4713,8 +4715,6 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
     if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd))
     {
-        t_FmPortGetSetCcParams      fmPortGetSetCcParams;
-
         memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 18d2274..5c45d07 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -145,7 +145,7 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 
 #ifdef FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) && (p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError))
-	RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
 #endif /* not FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
 #ifdef FM_NO_TNUM_AGING
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
@@ -157,19 +157,19 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 #ifdef FM_NO_DISPATCH_RAM_ECC
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
         if(p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
-		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_BMI_DISPATCH_RAM_ECC!"));
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_BMI_DISPATCH_RAM_ECC!"));
 #endif /* FM_NO_DISPATCH_RAM_ECC */
 
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
     if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
         if(p_Fm->p_FmDriverParam->userSetExceptions & (FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC))
-		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC/e_FM_EX_QMI_DOUBLE_ECC!"));
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC/e_FM_EX_QMI_DOUBLE_ECC!"));
 #endif /* FM_QMI_NO_ECC_EXCEPTIONS */
 
 #ifdef FM_QMI_NO_SINGLE_ECC_EXCEPTION
     if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
         if(p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_QMI_SINGLE_ECC)
-		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC!"));
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC!"));
 #endif /* FM_QMI_NO_SINGLE_ECC_EXCEPTION */
 
     return E_OK;
@@ -190,7 +190,7 @@ static void SendIpcIsr(t_Fm *p_Fm, uint32_t macEvent, uint32_t pendingReg)
         fmIpcIsr.pendingReg = pendingReg;
         fmIpcIsr.boolErr = FALSE;
         memcpy(msg.msgBody, &fmIpcIsr, sizeof(fmIpcIsr));
-		err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->intrMng[macEvent].guestId],
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->intrMng[macEvent].guestId],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId) + sizeof(fmIpcIsr),
                                      NULL,
@@ -354,7 +354,7 @@ static void IramErrIntr(t_Fm *p_Fm)
 
     /* clear the acknowledged events (do not clear IRAM event) */
     /* Prior to V3 this event bit clearing does not work ! ) */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC);
+   WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC);
 
     ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC_EN);
 
@@ -495,7 +495,7 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
         while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
         for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
         {
-			tmp = GET_UINT32(p_Iram->idata);
+            tmp = GET_UINT32(p_Iram->idata);
             if (tmp != p_Fm->p_FmDriverParam->firmware.p_Code[i])
                 RETURN_ERROR(MAJOR, E_WRITE_FAILED,
                              ("UCode write error : write 0x%x, read 0x%x",
@@ -701,9 +701,9 @@ t_Error FmVSPSetWindow(t_Handle  h_Fm,
 
 static uint8_t FmVSPsAlloc(t_Handle  h_Fm, uint8_t base, uint8_t numOfStorageProfiles, uint8_t guestId)
 {
-    t_Fm    *p_Fm = (t_Fm *)h_Fm;
-    uint8_t  profilesFound = 0;
-    int     i     = 0;
+    t_Fm        *p_Fm = (t_Fm *)h_Fm;
+    uint8_t     profilesFound = 0;
+    int         i     = 0;
     uint32_t    intFlags;
 
     if (!numOfStorageProfiles)
@@ -925,9 +925,9 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             t_FmIpcMacMaxFrameParams    ipcMacMaxFrameParams;
 
             memcpy((uint8_t*)&ipcMacMaxFrameParams, p_IpcMsg->msgBody, sizeof(t_FmIpcMacMaxFrameParams));
-			err = FmSetMacMaxFrame(p_Fm,
-                                        (e_FmMacType)(ipcMacMaxFrameParams.macParams.enumType),
-                                        ipcMacMaxFrameParams.macParams.id,
+            err = FmSetMacMaxFrame(p_Fm,
+                                  (e_FmMacType)(ipcMacMaxFrameParams.macParams.enumType),
+                                  ipcMacMaxFrameParams.macParams.id,
                                   ipcMacMaxFrameParams.maxFrameLength);
             if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
@@ -994,14 +994,14 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
         case (FM_DUMP_REGS):
         {
-		err = FM_DumpRegs(h_Fm);
+            err = FM_DumpRegs(h_Fm);
             if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
         }
         case (FM_DUMP_PORT_REGS):
         {
-		err = FmDumpPortRegs(h_Fm, p_IpcMsg->msgBody[0]);
+            err = FmDumpPortRegs(h_Fm, p_IpcMsg->msgBody[0]);
             if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
@@ -1116,7 +1116,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
                 ((err = FM_SetException(h_Fm, e_FM_EX_IRAM_ECC, TRUE)) != E_OK) ||
                 ((err = FM_SetException(h_Fm, e_FM_EX_MURAM_ECC, TRUE)) != E_OK))
 #if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
-				UNUSED(err);
+                UNUSED(err);
 #else
                 REPORT_ERROR(MINOR, err, NO_MSG);
 #endif /* (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0)) */
@@ -1129,7 +1129,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
                 ((err = FM_SetException(h_Fm, e_FM_EX_MURAM_ECC, FALSE)) != E_OK) ||
                 ((err = FM_DisableRamsEcc(h_Fm)) != E_OK))
 #if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
-				UNUSED(err);
+                UNUSED(err);
 #else
                 REPORT_ERROR(MINOR, err, NO_MSG);
 #endif /* (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0)) */
@@ -1141,8 +1141,8 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 
             memcpy((uint8_t*)&ipcPortNumOfFmanCtrls, p_IpcMsg->msgBody, sizeof(t_FmIpcPortNumOfFmanCtrls));
             err = FmSetNumOfRiscsPerPort(h_Fm,
-                                              ipcPortNumOfFmanCtrls.hardwarePortId,
-                                              ipcPortNumOfFmanCtrls.numOfFmanCtrls,
+                                         ipcPortNumOfFmanCtrls.hardwarePortId,
+                                         ipcPortNumOfFmanCtrls.numOfFmanCtrls,
                                          ipcPortNumOfFmanCtrls.orFmanCtrl);
             if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
@@ -1254,7 +1254,7 @@ t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
     uint32_t        replyLength;
     uint8_t         rxHardwarePortId, txHardwarePortId;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
@@ -1370,18 +1370,18 @@ void FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
     uint32_t        replyLength;
     t_FmIpcPhysAddr ipcPhysAddr;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_GET_PHYS_MURAM_BASE;
         replyLength = sizeof(uint32_t) + sizeof(t_FmPhysAddr);
         err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
                                 NULL);
         if (err != E_OK)
         {
@@ -1409,8 +1409,8 @@ t_Error FmVSPFree(  t_Handle        h_Fm,
                     e_FmPortType    portType,
                     uint8_t         portId)
 {
-    t_Fm           *p_Fm = (t_Fm *)h_Fm;
-    uint8_t        swPortIndex, hardwarePortId, first, numOfVSPs, i;
+    t_Fm            *p_Fm = (t_Fm *)h_Fm;
+    uint8_t         swPortIndex, hardwarePortId, first, numOfVSPs, i;
     uint32_t        intFlags;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
@@ -1465,7 +1465,7 @@ t_Error FmVSPAlloc          (t_Handle  h_Fm,
         first = 1<<log2Num;
 
     if (first > (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
+         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
 
     if (first<p_Fm->partVSPBase)
         while(first < p_Fm->partVSPBase)
@@ -1578,11 +1578,11 @@ void FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId)
         msg.msgId = FM_FREE_FMAN_CTRL_EVENT_REG;
         msg.msgBody[0] = eventId;
         err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId)+sizeof(eventId),
-                                     NULL,
-                                     NULL,
-                                     NULL,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId)+sizeof(eventId),
+                                NULL,
+                                NULL,
+                                NULL,
                                 NULL);
         if (err != E_OK)
             REPORT_ERROR(MINOR, err, NO_MSG);
@@ -1592,12 +1592,12 @@ void FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId)
     ((t_Fm*)h_Fm)->usedEventRegs[eventId] = FALSE;
 }
 
-void FmRegisterIntr(t_Handle h_Fm,
-                        e_FmEventModules        module,
-                        uint8_t                 modId,
-                        e_FmIntrType            intrType,
-                        void (*f_Isr) (t_Handle h_Arg),
-                        t_Handle    h_Arg)
+void FmRegisterIntr(t_Handle                h_Fm,
+                    e_FmEventModules        module,
+                    uint8_t                 modId,
+                    e_FmIntrType            intrType,
+                    void                    (*f_Isr) (t_Handle h_Arg),
+                    t_Handle                h_Arg)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
     t_FmIpcRegisterIntr fmIpcRegisterIntr;
@@ -1607,7 +1607,7 @@ void FmRegisterIntr(t_Handle h_Fm,
 
     ASSERT_COND(h_Fm);
 
-    GET_FM_MODULE_EVENT(module, modId,intrType, event);
+    GET_FM_MODULE_EVENT(module, modId, intrType, event);
     ASSERT_COND(event < e_FM_EV_DUMMY_LAST);
 
     /* register in local FM structure */
@@ -1625,11 +1625,11 @@ void FmRegisterIntr(t_Handle h_Fm,
             msg.msgId = FM_REGISTER_INTR;
             memcpy(msg.msgBody, &fmIpcRegisterIntr, sizeof(fmIpcRegisterIntr));
             err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                         (uint8_t*)&msg,
-                                         sizeof(msg.msgId) + sizeof(fmIpcRegisterIntr),
-                                         NULL,
-                                         NULL,
-                                         NULL,
+                                    (uint8_t*)&msg,
+                                    sizeof(msg.msgId) + sizeof(fmIpcRegisterIntr),
+                                    NULL,
+                                    NULL,
+                                    NULL,
                                     NULL);
             if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
@@ -1640,12 +1640,12 @@ void FmRegisterIntr(t_Handle h_Fm,
 
 }
 
-void FmUnregisterIntr(t_Handle h_Fm,
+void FmUnregisterIntr(t_Handle                  h_Fm,
                         e_FmEventModules        module,
                         uint8_t                 modId,
                         e_FmIntrType            intrType)
 {
-    t_Fm       *p_Fm = (t_Fm*)h_Fm;
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
     int         event = 0;
 
     ASSERT_COND(h_Fm);
@@ -1672,11 +1672,11 @@ void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId, uint32_t enableEvent
         msg.msgId = FM_SET_FMAN_CTRL_EVENTS_ENABLE;
         memcpy(msg.msgBody, &fmanCtrl, sizeof(fmanCtrl));
         err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId)+sizeof(fmanCtrl),
-                                     NULL,
-                                     NULL,
-                                     NULL,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId)+sizeof(fmanCtrl),
+                                NULL,
+                                NULL,
+                                NULL,
                                 NULL);
         if (err != E_OK)
             REPORT_ERROR(MINOR, err, NO_MSG);
@@ -1703,11 +1703,11 @@ uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
         msg.msgBody[0] = eventRegId;
         replyLength = sizeof(uint32_t) + sizeof(uint32_t);
         err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId)+sizeof(eventRegId),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId)+sizeof(eventRegId),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
                                 NULL);
         if (err != E_OK)
         {
@@ -1924,7 +1924,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-	if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
     if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
@@ -1995,42 +1995,42 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 
     if(p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
-    tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
-    if(p_PortParams->independentMode)
-    {
-        if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
-            tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
+        tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
+        if(p_PortParams->independentMode)
+        {
+            if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
+                tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
+            else
+                tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
+        }
         else
-            tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
-    }
-    else
-    {
-        tmpReg |= (FPM_PORT_FM_CTL2|FPM_PORT_FM_CTL1);
+        {
+            tmpReg |= (FPM_PORT_FM_CTL2|FPM_PORT_FM_CTL1);
 
-        /* order restoration */
-        if(hardwarePortId%2)
-            tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
-        else
-            tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
-    }
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+            /* order restoration */
+            if(hardwarePortId%2)
+                tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+            else
+                tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
+        }
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
     }
 
     {
-            /* set LIODN base for this port */
-            tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
-            if(hardwarePortId%2)
-            {
-                tmpReg &= ~FM_LIODN_BASE_MASK;
-                tmpReg |= (uint32_t)p_PortParams->liodnBase;
-            }
-            else
-            {
-                tmpReg &= ~(FM_LIODN_BASE_MASK<< DMA_LIODN_SHIFT);
-                tmpReg |= (uint32_t)p_PortParams->liodnBase << DMA_LIODN_SHIFT;
-            }
-            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], tmpReg);
+        /* set LIODN base for this port */
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
+        if(hardwarePortId%2)
+        {
+            tmpReg &= ~FM_LIODN_BASE_MASK;
+            tmpReg |= (uint32_t)p_PortParams->liodnBase;
         }
+        else
+        {
+            tmpReg &= ~(FM_LIODN_BASE_MASK<< DMA_LIODN_SHIFT);
+            tmpReg |= (uint32_t)p_PortParams->liodnBase << DMA_LIODN_SHIFT;
+        }
+        WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], tmpReg);
+    }
 
     FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
     XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
@@ -2057,11 +2057,11 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
         msg.msgId = FM_FREE_PORT;
         memcpy(msg.msgBody, &portParams, sizeof(portParams));
         err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId)+sizeof(portParams),
-                                     NULL,
-                                     NULL,
-                                     NULL,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId)+sizeof(portParams),
+                                NULL,
+                                NULL,
+                                NULL,
                                 NULL);
         if (err != E_OK)
             REPORT_ERROR(MINOR, err, NO_MSG);
@@ -2071,6 +2071,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
     intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
+
     if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
         ASSERT_COND(p_Fm->hcPortInitialized);
@@ -2109,7 +2110,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     /* WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], 0); */
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-	if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
     if ((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
         (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
@@ -2669,7 +2670,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     if(numOfExtraOpenDmas > oldVal)
         p_Fm->p_FmStateStruct->extraOpenDmasPoolSize = (uint8_t)MAX(p_Fm->p_FmStateStruct->extraOpenDmasPoolSize, numOfExtraOpenDmas);
 
-    if(!initialConfig)
+    if (!initialConfig)
         /* read into oldVal the current num of tasks */
         oldVal = (uint8_t)(((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
 
@@ -2678,10 +2679,10 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
 #ifndef FM_NO_TOTAL_DMAS
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) &&
         (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas >
-		p_Fm->p_FmStateStruct->maxNumOfOpenDmas))
-        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                     ("Requested numOfOpenDmas for fm%d exceeds total numOfOpenDmas.",
-                      p_Fm->p_FmStateStruct->fmId));
+            p_Fm->p_FmStateStruct->maxNumOfOpenDmas))
+            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                         ("Requested numOfOpenDmas for fm%d exceeds total numOfOpenDmas.",
+                         p_Fm->p_FmStateStruct->fmId));
 #else /* FM_NO_TOTAL_DMAS */
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev >= 6) &&
         (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas > DMA_THRESH_MAX_COMMQ+1))
@@ -2768,7 +2769,7 @@ t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
 
     DECLARE_DUMP;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_DUMP_PORT_REGS;
@@ -2805,9 +2806,9 @@ t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
 /*****************************************************************************/
 t_Handle FM_Config(t_FmParams *p_FmParam)
 {
-    t_Fm        *p_Fm;
-    uint8_t     i;
-    uintptr_t   baseAddr;
+    t_Fm                *p_Fm;
+    uint8_t             i;
+    uintptr_t           baseAddr;
 
     SANITY_CHECK_RETURN_VALUE(p_FmParam, E_NULL_POINTER, NULL);
     SANITY_CHECK_RETURN_VALUE(((p_FmParam->firmware.p_Code && p_FmParam->firmware.size) ||
@@ -2853,26 +2854,26 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     memset(p_Fm->p_FmDriverParam, 0, sizeof(t_FmDriverParam));
 
     /* Initialize FM parameters which will be kept by the driver */
-    p_Fm->p_FmStateStruct->fmId              = p_FmParam->fmId;
-    p_Fm->h_FmMuram         = p_FmParam->h_FmMuram;
-    p_Fm->h_App             = p_FmParam->h_App;
-    p_Fm->p_FmStateStruct->fmClkFreq         = p_FmParam->fmClkFreq;
-    p_Fm->f_Exception       = p_FmParam->f_Exception;
-    p_Fm->f_BusError        = p_FmParam->f_BusError;
-    p_Fm->p_FmFpmRegs       = (t_FmFpmRegs *)UINT_TO_PTR(baseAddr + FM_MM_FPM);
-    p_Fm->p_FmBmiRegs       = (t_FmBmiRegs *)UINT_TO_PTR(baseAddr + FM_MM_BMI);
-    p_Fm->p_FmQmiRegs       = (t_FmQmiRegs *)UINT_TO_PTR(baseAddr + FM_MM_QMI);
-    p_Fm->p_FmDmaRegs       = (t_FmDmaRegs *)UINT_TO_PTR(baseAddr + FM_MM_DMA);
-    p_Fm->baseAddr          = baseAddr;
-    p_Fm->p_FmStateStruct->irq               = p_FmParam->irq;
-    p_Fm->p_FmStateStruct->errIrq            = p_FmParam->errIrq;
-    p_Fm->hcPortInitialized = FALSE;
-    p_Fm->independentMode   = FALSE;
-    p_Fm->p_FmStateStruct->ramsEccEnable     = FALSE;
-    p_Fm->p_FmStateStruct->totalNumOfTasks   = BMI_MAX_NUM_OF_TASKS;
-    p_Fm->p_FmStateStruct->maxNumOfOpenDmas  = BMI_MAX_NUM_OF_DMAS;
+    p_Fm->p_FmStateStruct->fmId                 = p_FmParam->fmId;
+    p_Fm->h_FmMuram                             = p_FmParam->h_FmMuram;
+    p_Fm->h_App                                 = p_FmParam->h_App;
+    p_Fm->p_FmStateStruct->fmClkFreq            = p_FmParam->fmClkFreq;
+    p_Fm->f_Exception                           = p_FmParam->f_Exception;
+    p_Fm->f_BusError                            = p_FmParam->f_BusError;
+    p_Fm->p_FmFpmRegs                           = (t_FmFpmRegs *)UINT_TO_PTR(baseAddr + FM_MM_FPM);
+    p_Fm->p_FmBmiRegs                           = (t_FmBmiRegs *)UINT_TO_PTR(baseAddr + FM_MM_BMI);
+    p_Fm->p_FmQmiRegs                           = (t_FmQmiRegs *)UINT_TO_PTR(baseAddr + FM_MM_QMI);
+    p_Fm->p_FmDmaRegs                           = (t_FmDmaRegs *)UINT_TO_PTR(baseAddr + FM_MM_DMA);
+    p_Fm->baseAddr                              = baseAddr;
+    p_Fm->p_FmStateStruct->irq                  = p_FmParam->irq;
+    p_Fm->p_FmStateStruct->errIrq               = p_FmParam->errIrq;
+    p_Fm->hcPortInitialized                     = FALSE;
+    p_Fm->independentMode                       = FALSE;
+    p_Fm->p_FmStateStruct->ramsEccEnable        = FALSE;
+    p_Fm->p_FmStateStruct->totalNumOfTasks      = BMI_MAX_NUM_OF_TASKS;
+    p_Fm->p_FmStateStruct->maxNumOfOpenDmas     = BMI_MAX_NUM_OF_DMAS;
     p_Fm->p_FmStateStruct->extraFifoPoolSize    = 0;
-    p_Fm->p_FmStateStruct->exceptions        = DEFAULT_exceptions;
+    p_Fm->p_FmStateStruct->exceptions           = DEFAULT_exceptions;
     /* Chip dependent, will be configured in Init */
     p_Fm->p_FmStateStruct->totalFifoSize        = 0;
 
@@ -2893,7 +2894,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         return NULL;
     }
 
-    /*p_Fm->p_FmDriverParam->numOfPartitions                      = p_FmParam->numOfPartitions;    */
+    /*p_Fm->p_FmDriverParam->numOfPartitions                    = p_FmParam->numOfPartitions;    */
     p_Fm->p_FmDriverParam->enCounters                           = FALSE;
     p_Fm->p_FmDriverParam->tnumAgingPeriod                      = 0;
     p_Fm->p_FmDriverParam->resetOnInit                          = DEFAULT_resetOnInit;
@@ -2994,7 +2995,7 @@ t_Error FM_Init(t_Handle h_Fm)
         p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
 #endif /*(DPAA_VERSION >= 11)*/
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
         uint8_t             isMasterAlive;
         t_FmIpcMsg          msg;
@@ -3068,9 +3069,9 @@ t_Error FM_Init(t_Handle h_Fm)
         else
         {
             DBG(WARNING, ("FM Guest mode - without IPC"));
-            if(!p_Fm->p_FmStateStruct->fmClkFreq )
+            if (!p_Fm->p_FmStateStruct->fmClkFreq )
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No fmClkFreq configured for guest without IPC"));
-            if(!p_Fm->baseAddr)
+            if (!p_Fm->baseAddr)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No baseAddr configured for guest without IPC"));
         }
 
@@ -3149,7 +3150,7 @@ t_Error FM_Init(t_Handle h_Fm)
 
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
     if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
-        p_Fm->p_FmStateStruct->exceptions  &= ~(FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC);
+        p_Fm->p_FmStateStruct->exceptions &= ~(FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC);
 #endif /* FM_QMI_NO_ECC_EXCEPTIONS */
 
 #ifdef FM_QMI_NO_SINGLE_ECC_EXCEPTION
@@ -3274,8 +3275,8 @@ t_Error FM_Init(t_Handle h_Fm)
     }
     else
     {
-    if ((p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_FM_WRITE_ECC))
-        tmpReg |= DMA_MODE_ECC;
+        if ((p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_FM_WRITE_ECC))
+            tmpReg |= DMA_MODE_ECC;
     }
     if(p_FmDriverParam->dmaStopOnBusError)
         tmpReg |= DMA_MODE_SBER;
@@ -3321,7 +3322,7 @@ t_Error FM_Init(t_Handle h_Fm)
     p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
                                                       (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY),
                                                       DMA_CAM_ALIGN));
-    if (!p_Fm->camBaseAddr )
+    if (!p_Fm->camBaseAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
 
     WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
@@ -3329,38 +3330,38 @@ t_Error FM_Init(t_Handle h_Fm)
                 (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
 
     if (p_Fm->p_FmStateStruct->revInfo.majorRev == 2)
-        {
-            FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
+    {
+        FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
 
-            p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
-                                                              (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128),
-                                                              64));
-            if (!p_Fm->camBaseAddr)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
+        p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                          (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128),
+                                                          64));
+        if (!p_Fm->camBaseAddr)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
 
         WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
                    0,
                    (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128));
 
-            switch(p_FmDriverParam->dmaCamNumOfEntries)
-            {
-                case(8):
+        switch(p_FmDriverParam->dmaCamNumOfEntries)
+        {
+            case(8):
                 WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xff000000);
-                    break;
-                case(16):
+                break;
+            case(16):
                 WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffff0000);
-                    break;
-                case(24):
+                break;
+            case(24):
                 WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffffff00);
-                    break;
-                case(32):
+                break;
+            case(32):
                 WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffffffff);
-                    break;
-                default:
-		FreeInitResources(p_Fm);
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("wrong dmaCamNumOfEntries"));
-            }
+                break;
+            default:
+                FreeInitResources(p_Fm);
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("wrong dmaCamNumOfEntries"));
         }
+    }
 
     /* VirtToPhys */
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
@@ -3449,7 +3450,7 @@ t_Error FM_Init(t_Handle h_Fm)
                                                        BMI_FIFO_ALIGN));
     if (!p_Fm->fifoBaseAddr)
     {
-	FreeInitResources(p_Fm);
+        FreeInitResources(p_Fm);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for BMI FIFO failed"));
     }
 
@@ -3514,11 +3515,11 @@ t_Error FM_Init(t_Handle h_Fm)
     /* Clear interrupt events */
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
     {
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
-        tmpReg |= QMI_INTR_EN_SINGLE_ECC;
-    /* enable events */
-    WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
+        if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
+            tmpReg |= QMI_INTR_EN_SINGLE_ECC;
+        /* enable events */
+        WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
     }
 
     /* clear & enable global counters  - calculate reg and save for later,
@@ -3526,8 +3527,8 @@ t_Error FM_Init(t_Handle h_Fm)
     if(p_Fm->p_FmDriverParam->enCounters)
         cfgReg = QMI_CFG_EN_COUNTERS;
 #ifndef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-	if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
-    cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) |  (uint32_t)QMI_DEF_TNUMS_THRESH);
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+        cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) |  (uint32_t)QMI_DEF_TNUMS_THRESH);
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     if (p_Fm->p_FmStateStruct->irq != NO_IRQ)
@@ -3545,14 +3546,14 @@ t_Error FM_Init(t_Handle h_Fm)
     /* build the FM master partition IPC address */
     if (Sprint (p_Fm->fmModuleName, "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, NCSW_MASTER_ID) != 6)
     {
-	FreeInitResources(p_Fm);
+        FreeInitResources(p_Fm);
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
     }
 
     err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
     if(err)
     {
-	FreeInitResources(p_Fm);
+        FreeInitResources(p_Fm);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -3588,7 +3589,7 @@ t_Error FM_Init(t_Handle h_Fm)
 *//***************************************************************************/
 t_Error FM_Free(t_Handle h_Fm)
 {
-    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    t_Fm    *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
@@ -3628,7 +3629,7 @@ t_Error FM_Free(t_Handle h_Fm)
 
         XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
 
-        if(!p_Fm->recoveryMode)
+        if (!p_Fm->recoveryMode)
             XX_Free(p_Fm->p_FmStateStruct);
 
         XX_Free(p_Fm);
@@ -3894,7 +3895,7 @@ t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE );
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
     if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
@@ -4066,7 +4067,7 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
 
     switch(exception)
-{
+    {
         case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
             if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID))
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
@@ -4409,9 +4410,9 @@ t_Error FM_DisableRamsEcc(t_Handle h_Fm)
 
 t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 {
-    t_Fm        *p_Fm = (t_Fm*)h_Fm;
-    uint32_t    bitMask = 0;
-    uint32_t    tmpReg;
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    uint32_t            bitMask = 0;
+    uint32_t            tmpReg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
@@ -4472,10 +4473,10 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
             case( e_FM_EX_QMI_SINGLE_ECC):
 #if defined(FM_QMI_NO_ECC_EXCEPTIONS) || defined(FM_QMI_NO_SINGLE_ECC_EXCEPTION)
                if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 4) || (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
-                    {
-                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_SINGLE_ECC"));
-                       return E_OK;
-                    }
+                {
+                   REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_SINGLE_ECC"));
+                   return E_OK;
+                }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
                 if(enable)
@@ -4487,10 +4488,10 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
              case(e_FM_EX_QMI_DOUBLE_ECC):
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
                 if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
-                    {
-                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_DOUBLE_ECC"));
-                       return E_OK;
-                    }
+                {
+                   REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_DOUBLE_ECC"));
+                   return E_OK;
+                }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
                 if(enable)
@@ -4596,7 +4597,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 
 t_Error FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
 {
-    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     p_FmRevisionInfo->majorRev = p_Fm->p_FmStateStruct->revInfo.majorRev;
     p_FmRevisionInfo->minorRev = p_Fm->p_FmStateStruct->revInfo.minorRev;
@@ -4608,9 +4609,9 @@ t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_Re
 {
     t_Fm                            *p_Fm = (t_Fm*)h_Fm;
     t_FMIramRegs                    *p_Iram;
-    t_Error             err;
-    t_FmIpcMsg          msg;
-    t_FmIpcReply        reply;
+    t_Error                         err;
+    t_FmIpcMsg                      msg;
+    t_FmIpcReply                    reply;
     uint32_t                        replyLength, revInfo;
     t_FmIpcFmanCtrlCodeRevisionInfo ipcRevInfo;
 
@@ -4858,11 +4859,11 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
         msg.msgId = FM_DMA_STAT;
         replyLength = sizeof(uint32_t) + sizeof(t_FmIpcDmaStatus);
         err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
                                 NULL);
         if (err != E_OK)
         {
@@ -4893,9 +4894,9 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
         p_FmDmaStatus->singlePortEccError = (bool)(tmpReg & DMA_STATUS_FM_SPDAT_ECC);
     else
     {
-    p_FmDmaStatus->readBufEccError = (bool)(tmpReg & DMA_STATUS_READ_ECC);
-    p_FmDmaStatus->writeBufEccSysError = (bool)(tmpReg & DMA_STATUS_SYSTEM_WRITE_ECC);
-    p_FmDmaStatus->writeBufEccFmError = (bool)(tmpReg & DMA_STATUS_FM_WRITE_ECC);
+        p_FmDmaStatus->readBufEccError = (bool)(tmpReg & DMA_STATUS_READ_ECC);
+        p_FmDmaStatus->writeBufEccSysError = (bool)(tmpReg & DMA_STATUS_SYSTEM_WRITE_ECC);
+        p_FmDmaStatus->writeBufEccFmError = (bool)(tmpReg & DMA_STATUS_FM_WRITE_ECC);
     }
 
     return;
@@ -4903,7 +4904,7 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
 
 void FM_Resume(t_Handle h_Fm)
 {
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
+    t_Fm            *p_Fm = (t_Fm*)h_Fm;
     uint32_t        tmpReg;
 
     SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
@@ -4947,24 +4948,24 @@ t_Error FM_GetSpecialOperationCoding(t_Handle h_Fm,
             case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP):
             case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
                     *p_SpOperCoding = 5;
-            break;
+                    break;
             case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP):
             case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
                     *p_SpOperCoding = 6;
-            break;
+                    break;
             case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_RPD):
                     *p_SpOperCoding = 3;
-            break;
+                    break;
             case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN):
                     *p_SpOperCoding = 1;
-            break;
+                    break;
             case (FM_SP_OP_IPSEC|FM_SP_OP_RPD):
                     *p_SpOperCoding = 4;
-            break;
+                    break;
             case (FM_SP_OP_IPSEC):
                     *p_SpOperCoding = 2;
-            break;
-        default:
+                    break;
+            default:
                 RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
         }
     }
@@ -5006,7 +5007,7 @@ t_Error FM_CtrlMonStart(t_Handle h_Fm)
 
 t_Error FM_CtrlMonStop(t_Handle h_Fm)
 {
-    t_Fm            *p_Fm = (t_Fm*)h_Fm;
+    t_Fm            *p_Fm = (t_Fm *)h_Fm;
     t_FmTrbRegs     *p_MonRegs;
     uint8_t         fmCtrlNum, i;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index d28b0bc..62459c0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -60,7 +60,7 @@
  @{
 *//***************************************************************************/
 
-#define FM_MAC_NO_PFC   0xffff
+#define FM_MAC_NO_PFC   0xff
 
 
 /**************************************************************************//**
@@ -204,7 +204,7 @@ typedef struct t_FmMacStatistics {
 typedef struct t_FmMacParams {
     uintptr_t                   baseAddr;           /**< Base of memory mapped FM MAC registers */
     t_EnetAddr                  addr;               /**< MAC address of device; First octet is sent first */
-    uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G 0>         */
+    uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G-MAC 0>      */
     e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed) */
     t_Handle                    h_Fm;               /**< A handle to the FM object this port related to */
     int                         mdioIrq;            /**< MDIO exceptions interrupt source - not valid for all
@@ -314,7 +314,7 @@ t_Error FM_MAC_ConfigMaxFrameLength(t_Handle h_FmMac, uint16_t newVal);
 /**************************************************************************//**
  @Function      FM_MAC_ConfigWan
 
- @Description   ENABLE WAN mode in 10G MAC
+ @Description   ENABLE WAN mode in 10G-MAC
 
  @Param[in]     h_FmMac    A handle to a FM MAC Module.
  @Param[in]     enable     TRUE to enable or FALSE to disable.
@@ -469,7 +469,28 @@ t_Error FM_MAC_Disable1588TimeStamp(t_Handle h_Fm);
  @Function      FM_MAC_SetTxAutoPauseFrames
 
  @Description   Enable/Disable transmission of Pause-Frames.
-                The routine will ct changes the default configuration [0xf000].
+                The routine changes the default configuration [0xf000].
+
+ @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
+ @Param[in]     pauseTime     -  Pause quanta value used with transmitted pause frames.
+                                 Each quanta represents a 512 bit-times; Note that '0'
+                                 as an input here will be used as disabling the
+                                 transmission of the pause-frames.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
+                                    uint16_t pauseTime);
+
+ /**************************************************************************//**
+ @Function      FM_MAC_SetTxPauseFrames
+
+ @Description   Enable/Disable transmission of Pause-Frames.
+                The routine changes the default configuration:
+                pause-time - [0xf000]
+                threshold-time - [0]
 
  @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
  @Param[in]     priority      -  the PFC class of service; use 'FM_MAC_NO_PFC'
@@ -486,11 +507,14 @@ t_Error FM_MAC_Disable1588TimeStamp(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Init().
+                PFC is supported only on new mEMAC; i.e. in MACs that don't have
+                PFC support (10G-MAC and dTSEC), user should use 'FM_MAC_NO_PFC'
+                in the 'priority' field.
 *//***************************************************************************/
-t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
-                                    uint8_t  priority,
-                                    uint16_t pauseTime,
-                                    uint16_t threshTime);
+t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac,
+                                uint8_t  priority,
+                                uint16_t pauseTime,
+                                uint16_t threshTime);
 
 /**************************************************************************//**
  @Function      FM_MAC_SetRxIgnorePauseFrames
@@ -765,6 +789,10 @@ t_Error FM_MAC_MII_ReadPhyReg(t_Handle h_FmMac,  uint8_t phyAddr, uint8_t reg, u
 t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
+/** @} */ /* end of FM_mac_runtime_control_grp group */
+/** @} */ /* end of FM_mac_grp group */
+/** @} */ /* end of FM_grp group */
+
 /**************************************************************************//**
  @Function      DtsecRestartTbiAN
 
@@ -774,9 +802,4 @@ t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
 *//***************************************************************************/
 void DtsecRestartTbiAN(t_Handle h_Dtsec);
 
-/** @} */ /* end of FM_mac_runtime_control_grp group */
-/** @} */ /* end of FM_mac_grp group */
-/** @} */ /* end of FM_grp group */
-
-
 #endif /* __FM_MAC_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
index 0b8f414..f0c8022 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -79,6 +79,8 @@ static void hex_dump(void * p_addr, unsigned int size)
 #endif
 
 /* maping kernel pointers w/ UserSpace id's { */
+/*TODO: per FMan module: Parser:FM_PARSER_NODE,
+ * Kg:FM_KG_NODE, Policer:FM_POLICER_NODE */
 const unsigned char map_node_name[][ID_MAP_NAME_SIZE] = {
     "FM_NODE", /* 0 */
     "FM_PORT_NODE", /* 1 */
@@ -94,7 +96,7 @@ struct map_node {
 	const unsigned char *name;
 };
 
-static struct map_node compat_ptr2id_array[COMPAT_PTR2ID_ARRAY_MAX];
+static struct map_node compat_ptr2id_array[COMPAT_PTR2ID_ARRAY_MAX] = {{0},{0}};
 
 void compat_del_ptr2id(void *p, const unsigned char *name)
 {
@@ -940,37 +942,22 @@ void compat_fm_pcd_manip_set_node(
         ioc_fm_pcd_manip_params_t *param,
         uint8_t compat)
 {
-#warning TODO compat manip node not implemented
-#if 0
     if (compat == COMPAT_US_TO_K) {
-	param->rmv = compat_param->rmv;
-	memcpy(&param->rmv_params, &compat_param->rmv_params, sizeof(ioc_fm_pcd_manip_rmv_params_t));
+        param->type = compat_param->type;
+        memcpy(&param->u, &compat_param->u, sizeof(param->u));
 
-	param->insrt = compat_param->insrt;
-	memcpy(&param->insrt_params, &compat_param->insrt_params, sizeof(ioc_fm_pcd_manip_insrt_params_t));
-
-	param->frag_or_reasm = compat_param->frag_or_reasm;
-	memcpy(&param->frag_or_reasm_params, &compat_param->frag_or_reasm_params, sizeof(ioc_fm_pcd_manip_frag_or_reasm_params_t));
-
-	param->treat_fd_status_fields_as_errors = compat_param->treat_fd_status_fields_as_errors;
-
-	param->id = compat_get_id2ptr(compat_param->id);
+        if (compat_param->p_next_manip)
+            param->p_next_manip = compat_get_id2ptr(compat_param->id, PCD_NODE);
     }
     else {
-	compat_param->rmv = param->rmv;
-	memcpy(&compat_param->rmv_params, &param->rmv_params, sizeof(ioc_fm_pcd_manip_rmv_params_t));
-
-	compat_param->insrt = param->insrt;
-	memcpy(&compat_param->insrt_params, &param->insrt_params, sizeof(ioc_fm_pcd_manip_insrt_params_t));
+        compat_param->type = param->type;
+        memcpy(&compat_param->u, &param->u, sizeof(compat_param->u));
 
-	compat_param->frag_or_reasm = param->frag_or_reasm;
-	memcpy(&compat_param->frag_or_reasm_params, &param->frag_or_reasm_params, sizeof(ioc_fm_pcd_manip_frag_or_reasm_params_t));
+        if (param->p_next_manip)
+            compat_param->p_next_manip = compat_get_ptr2id(param->id, PCD_NODE);
 
-	compat_param->treat_fd_status_fields_as_errors = param->treat_fd_status_fields_as_errors;
-
-    compat_param->id = compat_add_ptr2id(param->id, PCD_NODE);
+        compat_param->id = compat_add_ptr2id(param->id, PCD_NODE);
     }
-#endif
 }
 
 void compat_copy_fm_pcd_manip_delete_node(
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
index e0a1761..16f5cfc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -66,11 +66,7 @@
 #define _fm_cpt_wrn(format, arg...) _fm_cpt_prk(KERN_WARNING, format, ##arg)
 #define _fm_cpt_err(format, arg...) _fm_cpt_prk(KERN_ERR, format, ##arg)
 
-/* there are two macros for debugging: for runtime and generic.
- * Helps when the runtime functions are not targeted for debugging,
- * thus all the unnecessary information will be skipped.
- */
-/* used for generic debugging */
+/* used for compat IOCTL debugging */
 #if defined(FM_COMPAT_DBG)
 	#define _fm_cpt_dbg(from, format, arg...) \
 		do{ \
@@ -374,7 +370,7 @@ typedef struct ioc_compat_fm_pcd_manip_params_t {
      compat_uptr_t                                p_next_manip;        /**< Handle to another (previously defined) manipulation node;
                                                                             Allows concatenation of manipulation actions */
 #ifdef FM_CAPWAP_SUPPORT
-TODO:
+#warning "feature not supported!"
 #endif
     compat_uptr_t                                 id;
 } ioc_compat_fm_pcd_manip_params_t;
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index d87b543..174e83e 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -1633,7 +1633,7 @@ typedef struct ioc_fm_pcd_manip_params_t {
      void*                                        p_next_manip;        /**< Handle to another (previously defined) manipulation node;
                                                                             Allows concatenation of manipulation actions */
 #ifdef FM_CAPWAP_SUPPORT
-TODO:
+#warning "feature not supported!"
 #endif
 	void                                      *id;
 } ioc_fm_pcd_manip_params_t;
-- 
1.7.9.7

