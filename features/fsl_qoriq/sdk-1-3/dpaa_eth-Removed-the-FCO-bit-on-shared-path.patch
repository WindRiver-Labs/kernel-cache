From c424ff580371bc6ceb7136cbebf15e54ddbe043a Mon Sep 17 00:00:00 2001
From: Cristian Sovaiala <cristian.sovaiala@freescale.com>
Date: Wed, 3 Oct 2012 20:44:39 +0000
Subject: [PATCH 050/162] dpaa_eth: Removed the FCO bit on shared path

In scenarios such as MAC-less linked to Offline Port the FCO bit
in FD status has to be unset because OP does not support FCO.
Removed the FCO bit on shared TX path and added TX confirmation
callbacks, inside which, buffers are released to BMan.

Signed-off-by: Cristian Sovaiala <cristian.sovaiala@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   86 +++++++++++++++++++++++--
 1 file changed, 82 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 2877b9a..2ba18967 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -1439,7 +1439,6 @@ static int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
 	fd.bpid = dpa_bp->bpid;
 
 	fd.length20 = skb_headlen(skb);
-	fd.cmd = FM_FD_CMD_FCO;
 	fd.addr_hi = bmb.hi;
 	fd.addr_lo = bmb.lo;
 	fd.offset = DPA_BP_HEAD;
@@ -2045,6 +2044,76 @@ ingress_tx_default_dqrr(struct qman_portal		*portal,
 	return qman_cb_dqrr_consume;
 }
 
+static enum qman_cb_dqrr_result
+shared_tx_error_dqrr(struct qman_portal                *portal,
+		     struct qman_fq                    *fq,
+		     const struct qm_dqrr_entry        *dq)
+{
+	struct net_device               *net_dev;
+	struct dpa_priv_s               *priv;
+	struct dpa_percpu_priv_s        *percpu_priv;
+	struct dpa_bp			*dpa_bp;
+	const struct qm_fd		*fd = &dq->fd;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	dpa_bp = dpa_bpid2pool(fd->bpid);
+	BUG_ON(IS_ERR(dpa_bp));
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (netif_msg_hw(priv) && net_ratelimit())
+		netdev_warn(net_dev, "FD status = 0x%08x\n",
+				fd->status & FM_FD_STAT_ERRORS);
+
+	if ((fd->format == qm_fd_sg) && (!dpa_bp->vaddr))
+		dpa_fd_release_sg(net_dev, fd);
+	else
+		dpa_fd_release(net_dev, fd);
+
+	percpu_priv->stats.tx_errors++;
+
+	return qman_cb_dqrr_consume;
+}
+
+static enum qman_cb_dqrr_result __hot
+shared_tx_default_dqrr(struct qman_portal              *portal,
+		       struct qman_fq                  *fq,
+		       const struct qm_dqrr_entry      *dq)
+{
+	struct net_device               *net_dev;
+	struct dpa_priv_s               *priv;
+	struct dpa_percpu_priv_s        *percpu_priv;
+	struct dpa_bp			*dpa_bp;
+	const struct qm_fd		*fd = &dq->fd;
+
+	net_dev = ((struct dpa_fq *)fq)->net_dev;
+	priv = netdev_priv(net_dev);
+
+	dpa_bp = dpa_bpid2pool(fd->bpid);
+	BUG_ON(IS_ERR(dpa_bp));
+
+	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+
+	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
+		if (netif_msg_hw(priv) && net_ratelimit())
+			netdev_warn(net_dev, "FD status = 0x%08x\n",
+					fd->status & FM_FD_STAT_ERRORS);
+
+		percpu_priv->stats.tx_errors++;
+	}
+
+	if ((fd->format == qm_fd_sg) && (!dpa_bp->vaddr))
+		dpa_fd_release_sg(net_dev, fd);
+	else
+		dpa_fd_release(net_dev, fd);
+
+	percpu_priv->tx_confirm++;
+
+	return qman_cb_dqrr_consume;
+}
+
 static void count_ern(struct dpa_percpu_priv_s *percpu_priv,
 		      const struct qm_mr_entry *msg)
 {
@@ -2143,7 +2212,12 @@ static const struct qman_fq tx_private_defq __devinitconst = {
 static const struct qman_fq tx_private_errq __devinitconst = {
 	.cb = { .dqrr = ingress_tx_error_dqrr }
 };
-static const struct qman_fq dummyq __devinitconst = { };
+static const struct qman_fq tx_shared_defq __devinitconst = {
+	.cb = { .dqrr = shared_tx_default_dqrr }
+};
+static const struct qman_fq tx_shared_errq __devinitconst = {
+	.cb = { .dqrr = shared_tx_error_dqrr }
+};
 static const struct qman_fq private_egress_fq __devinitconst = {
 	.cb = { .ern = egress_ern }
 };
@@ -3217,8 +3291,8 @@ static void dpa_tx_fq_init(struct dpa_priv_s *priv, struct list_head *head,
 
 	/* The shared driver doesn't use tx confirmation */
 	if (priv->shared) {
-		dpa_setup_ingress(priv, defq, &dummyq);
-		dpa_setup_ingress(priv, errq, &dummyq);
+		dpa_setup_ingress(priv, defq, &tx_shared_defq);
+		dpa_setup_ingress(priv, errq, &tx_shared_errq);
 	} else {
 		dpa_setup_ingress(priv, defq, &tx_private_defq);
 		dpa_setup_ingress(priv, errq, &tx_private_errq);
@@ -3403,6 +3477,10 @@ static ssize_t dpaa_eth_show_fqids(struct device *dev,
 			str = "TX confirmation";
 		else if (dqrr == ingress_tx_error_dqrr)
 			str = "TX error";
+		else if (dqrr == shared_tx_default_dqrr)
+			str = "Shared TX confirmation";
+		else if (dqrr == shared_tx_error_dqrr)
+			str = "Shared TX error";
 		else if (dqrr == NULL)
 			str = "TX";
 		else
-- 
1.7.9.7

