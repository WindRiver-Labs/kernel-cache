From a515576f2ceae5348a86bebc3729a07acbf04052 Mon Sep 17 00:00:00 2001
From: Andrei Pistirica <sorin.pistirica@freescale.com>
Date: Wed, 9 May 2012 15:23:49 +0300
Subject: [PATCH 061/162] FMD 16 release.

Supported platforms: p4080 only
No 64bit support and no mix evironment support.
PCD API changes: pcd handler removed from several functions.
Added API for Match Table manipulation.
Added Storage profile suport (not tested and not exported through
IOCTL).

Signed-off-by: Andrei Pistirica
Signed-off-by: Stefan Szabo <szbs001@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.3-SOURCE-20121114-yocto.iso tarball. Just adjust
the drivers directory in some Makefile.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c | 1013 +---
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c       |  240 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h       |  100 +-
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |    4 +-
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |    6 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c      |   39 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h      |   26 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |  124 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.h        |  117 +-
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c    |    4 +-
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h    |    6 +-
 .../dpa/NetCommSw/Peripherals/FM/Makefile          |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h       |    4 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       | 5030 ++++++++++++++------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |  131 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       | 1402 +++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    | 2203 +++++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |  236 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |  332 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |  135 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |   52 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     | 1674 ++++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |   85 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    | 1696 ++++---
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |  291 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |   19 +-
 .../dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c      |   10 +-
 .../dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h      |    6 +-
 .../dpa/NetCommSw/Peripherals/FM/SP/Makefile       |   15 +
 .../dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c        |  832 ++++
 .../dpa/NetCommSw/Peripherals/FM/SP/fm_sp.h        |  131 +
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    | 1647 +++++--
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.h    |  275 +-
 .../dpa/NetCommSw/Peripherals/FM/fm_ipc.h          |   65 +-
 .../dpa/NetCommSw/Peripherals/FM/fm_muram.c        |   16 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |  482 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h       |   24 +-
 .../NetCommSw/Peripherals/FM/inc/fm_sp_common.h    |  154 +
 .../ethernet/freescale/dpa/NetCommSw/etc/error.c   |   32 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/list.c    |    4 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/memcpy.c  |    4 +-
 .../net/ethernet/freescale/dpa/NetCommSw/etc/mm.c  |   60 +-
 .../net/ethernet/freescale/dpa/NetCommSw/etc/mm.h  |   17 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/sprint.c  |    4 +-
 .../NetCommSw/inc/Peripherals/crc_mac_addr_ext.h   |    4 +-
 .../dpa/NetCommSw/inc/Peripherals/dpaa_ext.h       |    6 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |  945 ++--
 .../dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h     |  160 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h   |   19 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     | 2174 ++++++---
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |  591 +--
 .../dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h     |   10 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h     |  354 ++
 .../dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h    |    4 +-
 .../freescale/dpa/NetCommSw/inc/core_ext.h         |   10 +-
 .../freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h |   70 +-
 .../freescale/dpa/NetCommSw/inc/cores/ppc_ext.h    |   18 +-
 .../freescale/dpa/NetCommSw/inc/ctype_ext.h        |    4 +-
 .../freescale/dpa/NetCommSw/inc/debug_ext.h        |    4 +-
 .../freescale/dpa/NetCommSw/inc/endian_ext.h       |    4 +-
 .../freescale/dpa/NetCommSw/inc/enet_ext.h         |   15 +-
 .../freescale/dpa/NetCommSw/inc/error_ext.h        |   51 +-
 .../freescale/dpa/NetCommSw/inc/etc/list_ext.h     |    6 +-
 .../freescale/dpa/NetCommSw/inc/etc/mem_ext.h      |    4 +-
 .../freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h   |    4 +-
 .../freescale/dpa/NetCommSw/inc/etc/mm_ext.h       |   20 +-
 .../freescale/dpa/NetCommSw/inc/etc/sprint_ext.h   |   11 +-
 .../inc/integrations/P1023/dpaa_integration_ext.h  |  136 +-
 .../NetCommSw/inc/integrations/P1023/part_ext.h    |    4 +-
 .../inc/integrations/P1023/part_integration_ext.h  |   29 +-
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |  150 +-
 .../inc/integrations/P3040_P4080_P5020/part_ext.h  |    4 +-
 .../P3040_P4080_P5020/part_integration_ext.h       |   15 +-
 .../freescale/dpa/NetCommSw/inc/math_ext.h         |    4 +-
 .../freescale/dpa/NetCommSw/inc/ncsw_ext.h         |    5 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/net_ext.h |    4 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/std_ext.h |    4 +-
 .../freescale/dpa/NetCommSw/inc/stdarg_ext.h       |    4 +-
 .../freescale/dpa/NetCommSw/inc/stdlib_ext.h       |    4 +-
 .../freescale/dpa/NetCommSw/inc/string_ext.h       |    4 +-
 .../freescale/dpa/NetCommSw/inc/types_ext.h        |    8 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h  |   96 +-
 .../NetCommSw/integrations/P1023/module_strings.c  |    5 +-
 .../P3040_P4080_P5020/module_strings.c             |    4 +-
 .../freescale/dpa/NetCommSw/p1023_dflags.h         |    4 +-
 .../dpa/NetCommSw/p3040_4080_5020_dflags.h         |    4 +-
 .../dpa/NetCommSw/src/inc/system/sys_ext.h         |    4 +-
 .../dpa/NetCommSw/src/inc/system/sys_io_ext.h      |    4 +-
 .../freescale/dpa/NetCommSw/src/inc/types_linux.h  |    4 +-
 .../dpa/NetCommSw/src/inc/wrapper/fsl_fman.h       |    6 +-
 .../dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h  |    4 +-
 .../dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h  |    4 +-
 .../freescale/dpa/NetCommSw/src/inc/xx/xx.h        |    4 +-
 .../freescale/dpa/NetCommSw/src/system/sys_io.c    |    4 +-
 .../freescale/dpa/NetCommSw/src/wrapper/Makefile   |    1 +
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.c          |   25 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.h          |   10 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c     |   86 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c   |  489 +-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.c          |    6 +-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.h          |    6 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.c   |    6 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.h   |    6 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c       |    6 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h       |    6 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c    |    6 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h    |    6 +-
 .../NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c   |   16 +-
 .../NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h   |    6 +-
 .../freescale/dpa/NetCommSw/src/xx/stdlib.c        |    4 +-
 .../freescale/dpa/NetCommSw/src/xx/udivdi3.c       |    4 +-
 .../freescale/dpa/NetCommSw/src/xx/xx_linux.c      |   10 +-
 include/linux/fmd/Peripherals/fm_ioctls.h          |   65 +-
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      |  763 ++-
 include/linux/fmd/Peripherals/fm_port_ioctls.h     |   38 +-
 .../linux/fmd/integrations/integration_ioctls.h    |    9 +
 116 files changed, 15901 insertions(+), 9431 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/Makefile
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index 6c91ac3..df69aa9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -39,12 +39,16 @@
 #include "fm_hc.h"
 
 
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+#define DEFAULT_dataMemId                                       0
+
 #define HC_HCOR_OPCODE_PLCR_PRFL                                0x0
 #define HC_HCOR_OPCODE_KG_SCM                                   0x1
 #define HC_HCOR_OPCODE_SYNC                                     0x2
 #define HC_HCOR_OPCODE_CC                                       0x3
 #define HC_HCOR_OPCODE_CC_CAPWAP_REASSM_TIMEOUT                 0x5
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
 #define HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT                     0x10
 #define HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION                0x11
 #define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT       24
@@ -53,10 +57,17 @@
 #define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK           0xF
 #define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_CMD_SHIFT       24
 #define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_BPID            16
-#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
 
 #define HC_HCOR_GBL                         0x20000000
 
+#define HC_HCOR_KG_SCHEME_COUNTER           0x00000400
+
+#if (DPAA_VERSION == 2)
+#define HC_HCOR_KG_SCHEME_REGS_MASK         0xFFFFF800
+#else
+#define HC_HCOR_KG_SCHEME_REGS_MASK         0xFFFFFE00
+#endif /* (DPAA_VERSION == 2) */
+
 #define SIZE_OF_HC_FRAME_PORT_REGS          (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdKgPortRegs))
 #define SIZE_OF_HC_FRAME_SCHEME_REGS        sizeof(t_HcFrame)
 #define SIZE_OF_HC_FRAME_PROFILES_REGS      (sizeof(t_HcFrame)-sizeof(t_FmPcdKgInterModuleSchemeRegs)+sizeof(t_FmPcdPlcrInterModuleProfileRegs))
@@ -66,7 +77,7 @@
 #define BUILD_FD(len)                     \
 do {                                      \
     memset(&fmFd, 0, sizeof(t_DpaaFD));   \
-    DPAA_FD_SET_ADDR(&fmFd, p_HcFrame);    \
+    DPAA_FD_SET_ADDR(&fmFd, p_HcFrame);   \
     DPAA_FD_SET_OFFSET(&fmFd, 0);         \
     DPAA_FD_SET_LENGTH(&fmFd, len);       \
 } while (0)
@@ -75,27 +86,6 @@ do {                                      \
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
-
-/**************************************************************************//**
- @Description   PCD KG scheme registers
-*//***************************************************************************/
-typedef _Packed struct t_FmPcdKgSchemeRegsWithoutCounter {
-    volatile uint32_t kgse_mode;    /**< MODE */
-    volatile uint32_t kgse_ekfc;    /**< Extract Known Fields Command */
-    volatile uint32_t kgse_ekdv;    /**< Extract Known Default Value */
-    volatile uint32_t kgse_bmch;    /**< Bit Mask Command High */
-    volatile uint32_t kgse_bmcl;    /**< Bit Mask Command Low */
-    volatile uint32_t kgse_fqb;     /**< Frame Queue Base */
-    volatile uint32_t kgse_hc;      /**< Hash Command */
-    volatile uint32_t kgse_ppc;     /**< Policer Profile Command */
-    volatile uint32_t kgse_gec[FM_PCD_KG_NUM_OF_GENERIC_REGS];
-                                    /**< Generic Extract Command */
-    volatile uint32_t kgse_dv0;     /**< KeyGen Scheme Entry Default Value 0 */
-    volatile uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
-    volatile uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
-    volatile uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
-} _PackedType t_FmPcdKgSchemeRegsWithoutCounter;
 
 typedef _Packed struct t_FmPcdKgPortRegs {
     volatile uint32_t                       spReg;
@@ -115,13 +105,10 @@ typedef _Packed struct t_HcFrame {
         t_FmPcdKgPortRegs                       portRegsForRead;
         volatile uint32_t                       clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
         t_FmPcdCcCapwapReassmTimeoutParams      ccCapwapReassmTimeout;
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
         t_FmPcdCcIpReassmTimeoutParams          ccIpReassmTimeout;
-#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
     } hcSpecificData;
 } _PackedType t_HcFrame;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -133,6 +120,7 @@ typedef struct t_FmHc {
     t_FmPcdQmEnqueueCallback    *f_QmEnqueue;     /**< A callback for enqueuing frames to the QM */
     t_Handle                    h_QmArg;          /**< A handle to the QM module */
     uint8_t                     padTill16;
+    uint8_t                     dataMemId;        /**< Memory partition ID for data buffers */
 
     uint32_t                    seqNum;
     volatile bool               wait[32];
@@ -153,10 +141,12 @@ static __inline__ t_Error EnQFrm(t_FmHc *p_FmHc, t_DpaaFD *p_FmFd, volatile uint
     ASSERT_COND(!p_FmHc->wait[savedSeqNum]);
     p_FmHc->wait[savedSeqNum] = TRUE;
     FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-    DBG(TRACE, ("Send Hc, SeqNum %d, FD@0x%x, fd offset 0x%x",
-                savedSeqNum,DPAA_FD_GET_ADDR(p_FmFd),DPAA_FD_GET_OFFSET(p_FmFd)));
+    DBG(TRACE, ("Send Hc, SeqNum %d, buff@0x%x, fd offset 0x%x",
+                savedSeqNum,
+                DPAA_FD_GET_ADDR(p_FmFd),
+                DPAA_FD_GET_OFFSET(p_FmFd)));
     err = p_FmHc->f_QmEnqueue(p_FmHc->h_QmArg, (void *)p_FmFd);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, ("HC enqueue failed"));
 
     while (p_FmHc->wait[savedSeqNum] && --timeout)
@@ -168,86 +158,12 @@ static __inline__ t_Error EnQFrm(t_FmHc *p_FmHc, t_DpaaFD *p_FmFd, volatile uint
     return err;
 }
 
-static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, t_Handle p_OldPointer, t_Handle p_NewPointer)
-{
-    t_HcFrame               *p_HcFrame;
-    t_DpaaFD                fmFd;
-    t_Error                 err = E_OK;
-
-    ASSERT_COND(p_FmHc);
-
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
-    if (!p_HcFrame)
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
-
-    memset(p_HcFrame, 0, sizeof(t_HcFrame));
-    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC);
-    p_HcFrame->actionReg  = FmPcdCcGetNodeAddrOffsetFromNodeInfo(p_FmHc->h_FmPcd, p_NewPointer);
-    if(p_HcFrame->actionReg == (uint32_t)ILLEGAL_BASE)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
-    }
-
-    p_HcFrame->actionReg  |=  0xc0000000;
-        p_HcFrame->extraReg   = FmPcdCcGetNodeAddrOffsetFromNodeInfo(p_FmHc->h_FmPcd, p_OldPointer);
-    if(p_HcFrame->extraReg == (uint32_t)ILLEGAL_BASE)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Something wrong with base address"));
-    }
-
-    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
-
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
-
-    XX_FreeSmart(p_HcFrame);
-
-    return E_OK;
-}
-
-static t_Error HcDynamicChange(t_FmHc *p_FmHc,t_List *h_OldPointersLst, t_List *h_NewPointersLst, t_Handle *h_Params)
-{
-
-    t_List      *p_PosOld, *p_PosNew;
-    uint16_t    i = 0;
-    t_Error     err = E_OK;
-    uint8_t     numOfModifiedPtr;
-
-    SANITY_CHECK_RETURN_ERROR((LIST_NumOfObjs(h_NewPointersLst) == LIST_NumOfObjs(h_OldPointersLst)),E_INVALID_STATE);
-
-    numOfModifiedPtr = (uint8_t)LIST_NumOfObjs(h_NewPointersLst);
-    p_PosNew = LIST_FIRST(h_NewPointersLst);
-    p_PosOld = LIST_FIRST(h_OldPointersLst);
-    for(i = 0; i < numOfModifiedPtr; i++)
-    {
-        err = CcHcDoDynamicChange(p_FmHc, p_PosOld, p_PosNew);
-        if(err)
-        {
-            FmPcdCcReleaseModifiedDataStructure(p_FmHc->h_FmPcd, h_OldPointersLst, h_NewPointersLst, i, h_Params);
-            RETURN_ERROR(MAJOR, err, ("For part of nodes changes are done - situation is danger"));
-        }
-        p_PosNew = LIST_NEXT(p_PosNew);
-        p_PosOld = LIST_NEXT(p_PosOld);
-    }
-
-    err = FmPcdCcReleaseModifiedDataStructure(p_FmHc->h_FmPcd, h_OldPointersLst, h_NewPointersLst, i, h_Params);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    return E_OK;
-}
-
 
 t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
 {
     t_FmHc          *p_FmHc;
     t_FmPortParams  fmPortParam;
-    t_Error         err = E_OK;
+    t_Error         err;
 
     p_FmHc = (t_FmHc *)XX_Malloc(sizeof(t_FmHc));
     if (!p_FmHc)
@@ -260,14 +176,11 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     p_FmHc->h_FmPcd             = p_FmHcParams->h_FmPcd;
     p_FmHc->f_QmEnqueue         = p_FmHcParams->params.f_QmEnqueue;
     p_FmHc->h_QmArg             = p_FmHcParams->params.h_QmArg;
+    p_FmHc->dataMemId           = DEFAULT_dataMemId;
 
     if (!FmIsMaster(p_FmHcParams->h_Fm))
         return (t_Handle)p_FmHc;
 
-/*
-TKT056919 - axi12axi0 can hang if read request follows the single byte write on the very next cycle
-TKT038900 - FM dma lockup occur due to AXI slave protocol violation
-*/
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
     p_FmHc->padTill16 = 16 - (sizeof(t_FmHc) % 16);
 #endif /* FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004 */
@@ -291,14 +204,16 @@ TKT038900 - FM dma lockup occur due to AXI slave protocol violation
     }
 
     /* final init */
-    if ((err = FM_PORT_Init(p_FmHc->h_HcPortDev)) != E_OK)
+    err = FM_PORT_Init(p_FmHc->h_HcPortDev);
+    if (err != E_OK)
     {
         REPORT_ERROR(MAJOR, err, ("FM HC port!"));
         FmHcFree(p_FmHc);
         return NULL;
     }
 
-    if ((err = FM_PORT_Enable(p_FmHc->h_HcPortDev)) != E_OK)
+	err = FM_PORT_Enable(p_FmHc->h_HcPortDev);
+    if (err != E_OK)
     {
         REPORT_ERROR(MAJOR, err, ("FM HC port!"));
         FmHcFree(p_FmHc);
@@ -321,6 +236,19 @@ void FmHcFree(t_Handle h_FmHc)
     XX_Free(p_FmHc);
 }
 
+/*****************************************************************************/
+t_Error FmHcSetFramesDataMemory(t_Handle h_FmHc,
+                                uint8_t  memId)
+{
+    t_FmHc  *p_FmHc = (t_FmHc*)h_FmHc;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmHc, E_INVALID_HANDLE);
+
+    p_FmHc->dataMemId            = memId;
+
+    return E_OK;
+}
+
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FmHcDumpRegs(t_Handle h_FmHc)
 {
@@ -355,103 +283,35 @@ void FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd)
     FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 }
 
-t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
+t_Error FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemeParams *p_SchemeParams)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error                             err = E_OK;
     t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
-    uint32_t                            intFlags;
     uint8_t                             physicalSchemeId, relativeSchemeId;
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
-    {
-        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
-        return NULL;
-    }
-
-    if(!p_Scheme->modify)
-    {
-        /* check that schemeId is in range */
-        if(p_Scheme->id.relativeSchemeId >= FmPcdKgGetNumOfPartitionSchemes(p_FmHc->h_FmPcd))
-        {
-            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
-            XX_FreeSmart(p_HcFrame);
-            return NULL;
-        }
-
-        relativeSchemeId = p_Scheme->id.relativeSchemeId;
-
-        if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE))
-        {
-            XX_FreeSmart(p_HcFrame);
-            return NULL;
-        }
-
-        physicalSchemeId = FmPcdKgGetPhysicalSchemeId(p_FmHc->h_FmPcd, relativeSchemeId);
-
-        memset(p_HcFrame, 0, sizeof(t_HcFrame));
-        p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
-        p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-        p_HcFrame->extraReg = 0xFFFFF800;
-
-        BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
-
-        if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-        {
-            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-            REPORT_ERROR(MINOR, err, NO_MSG);
-            XX_FreeSmart(p_HcFrame);
-            return NULL;
-        }
+	RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
-        /* check if this scheme is already used */
-        if (FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
-        {
-            FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
-            XX_FreeSmart(p_HcFrame);
-            return NULL;
-        }
-    }
-    else
-    {
-        intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-        physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_Scheme->id.h_Scheme)-1);
-        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
-        if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
-        {
-            FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-            XX_FreeSmart(p_HcFrame);
-            return NULL;
-        }
-        err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, TRUE);
-        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-        if (err)
-        {
-            XX_FreeSmart(p_HcFrame);
-            return NULL;
-        }
-    }
+    physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
+    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
 
-    err = FmPcdKgBuildScheme(p_FmHc->h_FmPcd, p_Scheme, &schemeRegs);
+    err = FmPcdKgBuildScheme(h_Scheme, p_SchemeParams, &schemeRegs);
     if(err)
     {
-        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-        REPORT_ERROR(MAJOR, err, NO_MSG);
         XX_FreeSmart(p_HcFrame);
-        return NULL;
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
-    p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
-    p_HcFrame->extraReg = 0xFFFFF800;
+    p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_SchemeParams->schemeCounter.update);
+    p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
     memcpy(&p_HcFrame->hcSpecificData.schemeRegs, &schemeRegs, sizeof(t_FmPcdKgInterModuleSchemeRegs));
-    if(!p_Scheme->schemeCounter.update)
+    if(!p_SchemeParams->schemeCounter.update)
     {
         p_HcFrame->hcSpecificData.schemeRegs.kgse_dv0   = schemeRegs.kgse_dv0;
         p_HcFrame->hcSpecificData.schemeRegs.kgse_dv1   = schemeRegs.kgse_dv1;
@@ -463,19 +323,13 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
 
     if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
     {
-        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-        REPORT_ERROR(MINOR, err, NO_MSG);
         XX_FreeSmart(p_HcFrame);
-        return NULL;
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    FmPcdKgValidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
-
-    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-
     XX_FreeSmart(p_HcFrame);
 
-    return (t_Handle)(UINT_TO_PTR(physicalSchemeId + 1));
+    return E_OK;
 }
 
 t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
@@ -484,215 +338,134 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
     t_Error     err = E_OK;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
-    uint8_t     relativeSchemeId;
-    uint8_t     physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
-
-    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
-
-    if ((err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
-    {
-        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-    }
+    uint8_t     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
 
-    err = FmPcdKgCheckInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
-    if (err)
-    {
-        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
-    {
-        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
-    }
+
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
-    p_HcFrame->extraReg = 0xFFFFF800;
+    p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
     memset(&p_HcFrame->hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
 
     BUILD_FD(sizeof(t_HcFrame));
 
     if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
     {
-        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
         XX_FreeSmart(p_HcFrame);
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    FmPcdKgInvalidateSchemeSw(p_FmHc->h_FmPcd, relativeSchemeId);
-
-    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-
     XX_FreeSmart(p_HcFrame);
 
     return E_OK;
 }
 
-t_Error FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t requiredAction)
+t_Error FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t requiredAction, uint32_t value)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error     err = E_OK;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
     uint8_t     relativeSchemeId;
-    uint8_t     physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+    uint8_t     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
     uint32_t    tmpReg32 = 0;
 
+    /* Scheme is locked by calling routine */
+    /* WARNING - this lock will not be efficient if other HC routine will attempt to change
+     * "kgse_mode" or "kgse_om" without locking scheme !
+     */
+
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
     if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-    if (FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Lock of the scheme FAILED"));
-
     if(!FmPcdKgGetPointedOwners(p_FmHc->h_FmPcd, relativeSchemeId) ||
        !(FmPcdKgGetRequiredAction(p_FmHc->h_FmPcd, relativeSchemeId) & requiredAction))
     {
-
-        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
-        {
-            if((FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_DONE) && (FmPcdKgGetDoneAction(p_FmHc->h_FmPcd, relativeSchemeId) ==  e_FM_PCD_ENQ_FRAME))
-
-            {
-                p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
-                if (!p_HcFrame)
-                {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
-                }
-                memset(p_HcFrame, 0, sizeof(t_HcFrame));
-                p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
-                p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-                p_HcFrame->extraReg = 0xFFFFF800;
-                BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
-                if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-                {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-                    XX_FreeSmart(p_HcFrame);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
-                }
-
-                /* check if this scheme is already used */
-                if (!FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
-                {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-                    XX_FreeSmart(p_HcFrame);
-                    RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
-                }
-                tmpReg32 = p_HcFrame->hcSpecificData.schemeRegs.kgse_mode;
-
-                ASSERT_COND(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
-
-                p_HcFrame->hcSpecificData.schemeRegs.kgse_mode =  tmpReg32 | NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
-
-                p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
-                p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
-                p_HcFrame->extraReg = 0x80000000;
-
-                BUILD_FD(sizeof(t_HcFrame));
-
-                if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-                {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-                    XX_FreeSmart(p_HcFrame);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
-                }
-
-                XX_FreeSmart(p_HcFrame);
-            }
-            else if (FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_PLCR)
+        if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) &&
+            (FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_PLCR))
             {
-
                 if((FmPcdKgIsDirectPlcr(p_FmHc->h_FmPcd, relativeSchemeId) == FALSE) ||
                     (FmPcdKgIsDistrOnPlcrProfile(p_FmHc->h_FmPcd, relativeSchemeId) == TRUE))
-                 {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
-                 }
                 err = FmPcdPlcrCcGetSetParams(p_FmHc->h_FmPcd, FmPcdKgGetRelativeProfileId(p_FmHc->h_FmPcd, relativeSchemeId), requiredAction);
                 if(err)
-                {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
                     RETURN_ERROR(MAJOR, err, NO_MSG);
-                }
             }
-        }
-        if(requiredAction & UPDATE_KG_NIA_CC_WA)
+        else /* From here we deal with KG-Schemes only */
         {
-            if (FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_CC)
+            /* Pre change general code */
+            p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+            if (!p_HcFrame)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
+            memset(p_HcFrame, 0, sizeof(t_HcFrame));
+            p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+            p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+            p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
+            BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
             {
-                p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
-                if (!p_HcFrame)
-                {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
-                }
-                memset(p_HcFrame, 0, sizeof(t_HcFrame));
-                p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
-                p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-                p_HcFrame->extraReg = 0xFFFFF800;
-                BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
-                if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-                {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-                    XX_FreeSmart(p_HcFrame);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
-                }
-
-                /* check if this scheme is already used */
-                if (!FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
+                XX_FreeSmart(p_HcFrame);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+            /* specific change */
+            if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) &&
+                ((FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_DONE) &&
+                 (FmPcdKgGetDoneAction(p_FmHc->h_FmPcd, relativeSchemeId) ==  e_FM_PCD_ENQ_FRAME)))
                 {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-                    XX_FreeSmart(p_HcFrame);
-                    RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
+                    tmpReg32 = p_HcFrame->hcSpecificData.schemeRegs.kgse_mode;
+                    ASSERT_COND(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+                    p_HcFrame->hcSpecificData.schemeRegs.kgse_mode =  tmpReg32 | NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
                 }
+            if ((requiredAction & UPDATE_KG_NIA_CC_WA) &&
+                (FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_CC))
+            {
                 tmpReg32 = p_HcFrame->hcSpecificData.schemeRegs.kgse_mode;
-
                 ASSERT_COND(tmpReg32 & (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 tmpReg32 &= ~NIA_FM_CTL_AC_CC;
                 p_HcFrame->hcSpecificData.schemeRegs.kgse_mode =  tmpReg32 | NIA_FM_CTL_AC_PRE_CC;
+            }
+            if(requiredAction & UPDATE_KG_OPT_MODE)
+            {
+                p_HcFrame->hcSpecificData.schemeRegs.kgse_om = value;
+            }
+            if(requiredAction & UPDATE_KG_NIA)
+            {
+                tmpReg32 = p_HcFrame->hcSpecificData.schemeRegs.kgse_mode;
+                tmpReg32 &= ~(NIA_ENG_MASK | NIA_AC_MASK);
+                tmpReg32 |= value;
+                p_HcFrame->hcSpecificData.schemeRegs.kgse_mode = tmpReg32;
+            }
+            /* Post change general code */
+            p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+            p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+            p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
 
-                p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
-                p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
-                p_HcFrame->extraReg = 0x80000000;
-
-                BUILD_FD(sizeof(t_HcFrame));
-
-                if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-                {
-                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-                    XX_FreeSmart(p_HcFrame);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
-                }
-
+            BUILD_FD(sizeof(t_HcFrame));
+            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            {
                 XX_FreeSmart(p_HcFrame);
-           }
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+            XX_FreeSmart(p_HcFrame);
         }
     }
 
-    FmPcdKgUpatePointedOwner(p_FmHc->h_FmPcd, relativeSchemeId,TRUE);
-    FmPcdKgUpdateRequiredAction(p_FmHc->h_FmPcd, relativeSchemeId,requiredAction);
-    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-
     return E_OK;
 }
 
 uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error     err = E_OK;
+    t_Error     err;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
     uint32_t    retVal;
     uint8_t     relativeSchemeId;
-    uint8_t     physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+    uint8_t     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
 
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
     if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
@@ -701,14 +474,8 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
         return 0;
     }
 
-    if ((err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE)) != E_OK)
-    {
-        REPORT_ERROR(MAJOR, err, ("Scheme lock"));
-        return 0;
-    }
-
     /* first read scheme and check that it is valid */
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
     {
         REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
@@ -717,13 +484,13 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-    p_HcFrame->extraReg = 0xFFFFF800;
+    p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+	err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
+    if (err != E_OK)
     {
-        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
         REPORT_ERROR(MINOR, err, NO_MSG);
         XX_FreeSmart(p_HcFrame);
         return 0;
@@ -738,8 +505,6 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
 
     retVal = p_HcFrame->hcSpecificData.schemeRegs.kgse_spc;
 
-    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-
     XX_FreeSmart(p_HcFrame);
 
     return retVal;
@@ -751,53 +516,27 @@ t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t
     t_Error     err = E_OK;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
-    uint8_t     relativeSchemeId, physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+    uint8_t     relativeSchemeId, physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
 
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
     if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-    if ((err = FmPcdKgSchemeTryLock(p_FmHc->h_FmPcd, relativeSchemeId, FALSE)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
     /* first read scheme and check that it is valid */
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
-    p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-    p_HcFrame->extraReg = 0xFFFFF800;
-
-    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
-
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
-
-    /* check that scheme is valid */
-    if (!FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
-    {
-        FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is invalid"));
-    }
-
-    /* Write scheme back, with modified counter */
-    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
-    p_HcFrame->extraReg = 0xFFFFF800;
+    p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_COUNTER;
     /* write counter */
-    p_HcFrame->hcSpecificData.schemeRegs.kgse_spc = value;
+    p_HcFrame->hcSpecificData.singleRegForWrite = value;
 
     BUILD_FD(sizeof(t_HcFrame));
 
     err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
 
-    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
     XX_FreeSmart(p_HcFrame);
 
     return err;
@@ -813,16 +552,16 @@ t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_S
 
     ASSERT_COND(p_FmHc);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
-    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    for (i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
     {
         memset(p_HcFrame, 0, sizeof(t_HcFrame));
         p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
         p_HcFrame->actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
-        p_HcFrame->extraReg = 0xFFFFF800;
+        p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
         memcpy((void*)&p_HcFrame->hcSpecificData.clsPlanEntries, (void *)&p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
 
         BUILD_FD(sizeof(t_HcFrame));
@@ -866,16 +605,15 @@ t_Error FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeo
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame                           *p_HcFrame;
-    uint32_t                            intFlags;
     t_DpaaFD                            fmFd;
     t_Error                             err;
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
-    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
+
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_CAPWAP_REASSM_TIMEOUT);
     memcpy(&p_HcFrame->hcSpecificData.ccCapwapReassmTimeout, p_CcCapwapReassmTimeoutParams, sizeof(t_FmPcdCcCapwapReassmTimeoutParams));
@@ -884,11 +622,10 @@ t_Error FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeo
     err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
 
     XX_FreeSmart(p_HcFrame);
-    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+
     return err;
 }
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
 t_Error FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
@@ -898,14 +635,14 @@ t_Error FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragS
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
 
     p_HcFrame->opcode     = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION);
-    p_HcFrame->actionReg  = ((fill == TRUE) ? 0 : 1) << HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_CMD_SHIFT;
+    p_HcFrame->actionReg  = (uint32_t)(((fill == TRUE) ? 0 : 1) << HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_CMD_SHIFT);
     p_HcFrame->actionReg |= p_FmPcdCcFragScratchPoolCmdParams->bufferPoolId << HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_BPID;
     if (fill == TRUE)
     {
@@ -935,13 +672,13 @@ t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT);
-    p_HcFrame->actionReg = (p_CcIpReassmTimeoutParams->activate ? 0 : 1) << HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT;
+    p_HcFrame->actionReg = (uint32_t)((p_CcIpReassmTimeoutParams->activate ? 0 : 1) << HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT);
     p_HcFrame->extraReg = (p_CcIpReassmTimeoutParams->tsbs << HC_HCOR_EXTRA_REG_IP_REASSM_TIMEOUT_TSBS_SHIFT) | p_CcIpReassmTimeoutParams->iprcpt;
     p_HcFrame->commandSequence = 0;
 
@@ -952,12 +689,12 @@ t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    *p_Result = (p_HcFrame->actionReg >> HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_SHIFT) & HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK;
+    *p_Result = (uint8_t)
+        ((p_HcFrame->actionReg >> HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_SHIFT) & HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK);
     XX_FreeSmart(p_HcFrame);
 
    return E_OK;
 }
-#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
 
 t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, uint32_t requiredAction)
 {
@@ -970,12 +707,10 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
-    if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile out of range"));
-
-    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
-        return ERROR_CODE(E_BUSY);
-
+    /* Profile is locked by calling routine */
+    /* WARNING - this lock will not be efficient if other HC routine will attempt to change
+     * "fmpl_pegnia" "fmpl_peynia" or "fmpl_pernia" without locking Profile !
+     */
 
     requiredActionTmp = FmPcdPlcrGetRequiredAction(p_FmHc->h_FmPcd, absoluteProfileId);
     pointedOwnersTmp = FmPcdPlcrGetPointedOwners(p_FmHc->h_FmPcd, absoluteProfileId);
@@ -986,7 +721,7 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
         if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
 
-            p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+            p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
             if (!p_HcFrame)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
             /* first read scheme and check that it is valid */
@@ -999,19 +734,10 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
 
             if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
             {
-                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
                 XX_FreeSmart(p_HcFrame);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
 
-            /* check that profile is valid */
-            if (!FmPcdPlcrHwProfileIsValid(p_HcFrame->hcSpecificData.profileRegs.fmpl_pemode))
-            {
-                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
-                XX_FreeSmart(p_HcFrame);
-                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
-            }
-
             tmpReg32 = p_HcFrame->hcSpecificData.profileRegs.fmpl_pegnia;
             if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
             {
@@ -1030,7 +756,6 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
 
             if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
             {
-                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
                 XX_FreeSmart(p_HcFrame);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
@@ -1053,7 +778,6 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
 
             if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
             {
-                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
                 XX_FreeSmart(p_HcFrame);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
@@ -1076,7 +800,6 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
 
             if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
             {
-                FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
                 XX_FreeSmart(p_HcFrame);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
@@ -1084,91 +807,32 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
         }
     }
 
-    FmPcdPlcrUpatePointedOwner(p_FmHc->h_FmPcd, absoluteProfileId, TRUE);
-    FmPcdPlcrUpdateRequiredAction(p_FmHc->h_FmPcd, absoluteProfileId, requiredAction);
-
-    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
-
     return E_OK;
 }
 
-t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile)
+t_Error FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileParams *p_ProfileParams)
 {
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_FmPcdPlcrInterModuleProfileRegs   profileRegs;
     t_Error                             err = E_OK;
-    uint32_t                            intFlags;
     uint16_t                            profileIndx;
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
 
-    if (p_Profile->modify)
-    {
-        profileIndx = (uint16_t)(PTR_TO_UINT(p_Profile->id.h_Profile)-1);
-        if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx, FALSE))
-            return NULL;
-    }
-    else
-    {
-        intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-        err = FmPcdPlcrGetAbsoluteProfileId(p_FmHc->h_FmPcd,
-                                            p_Profile->id.newParams.profileType,
-                                            p_Profile->id.newParams.h_FmPort,
-                                            p_Profile->id.newParams.relativeProfileId,
-                                            &profileIndx);
-        if (err)
-        {
-            REPORT_ERROR(MAJOR, err, NO_MSG);
-            return NULL;
-        }
-        err = FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, profileIndx, TRUE);
-        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-        if (err)
-            return NULL;
-    }
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
-    {
-        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
-        return NULL;
-    }
-
-    if(!p_Profile->modify)
-    {
-        memset(p_HcFrame, 0, sizeof(t_HcFrame));
-        p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
-        p_HcFrame->actionReg  = FmPcdPlcrBuildReadPlcrActionReg(profileIndx);
-        p_HcFrame->extraReg = 0x00008000;
-
-        BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
-
-        if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-        {
-            FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
-            REPORT_ERROR(MINOR, err, NO_MSG);
-            XX_FreeSmart(p_HcFrame);
-            return NULL;
-        }
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
-        /* check if this scheme is already used */
-        if (FmPcdPlcrHwProfileIsValid(p_HcFrame->hcSpecificData.profileRegs.fmpl_pemode))
-        {
-            FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
-            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
-            XX_FreeSmart(p_HcFrame);
-            return NULL;
-        }
-    }
+    profileIndx = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
 
     memset(&profileRegs, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
-    err = FmPcdPlcrBuildProfile(p_FmHc->h_FmPcd, p_Profile, &profileRegs);
+
+    err = FmPcdPlcrBuildProfile(p_FmHc->h_FmPcd, p_ProfileParams, &profileRegs);
     if(err)
     {
-        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
-        REPORT_ERROR(MAJOR, err, NO_MSG);
         XX_FreeSmart(p_HcFrame);
-        return NULL;
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -1181,35 +845,24 @@ t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profi
 
     if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
     {
-        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
-        REPORT_ERROR(MINOR, err, NO_MSG);
         XX_FreeSmart(p_HcFrame);
-        return NULL;
+        RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    FmPcdPlcrValidateProfileSw(p_FmHc->h_FmPcd, profileIndx);
-
-    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, profileIndx);
-
     XX_FreeSmart(p_HcFrame);
 
-    return UINT_TO_PTR((uint64_t)profileIndx+1);
+    return E_OK;
 }
 
 t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    uint16_t    absoluteProfileId = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    uint16_t    absoluteProfileId = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
     t_Error     err = E_OK;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
 
-    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
-        return ERROR_CODE(E_BUSY);
-
-    FmPcdPlcrInvalidateProfileSw(p_FmHc->h_FmPcd, absoluteProfileId);
-
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -1223,13 +876,10 @@ t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
 
     if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
     {
-        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
         XX_FreeSmart(p_HcFrame);
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
-
     XX_FreeSmart(p_HcFrame);
 
     return E_OK;
@@ -1239,41 +889,17 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 {
 
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    uint16_t    absoluteProfileId = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    uint16_t    absoluteProfileId = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
     t_Error     err = E_OK;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
 
-    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
-        return ERROR_CODE(E_BUSY);
-
     /* first read scheme and check that it is valid */
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
-    p_HcFrame->actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
-    p_HcFrame->extraReg = 0x00008000;
-
-    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
-
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
-
-    /* check that profile is valid */
-    if (!FmPcdPlcrHwProfileIsValid(p_HcFrame->hcSpecificData.profileRegs.fmpl_pemode))
-    {
-        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer is already used"));
-    }
-
-    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
     p_HcFrame->actionReg |= FmPcdPlcrBuildCounterProfileReg(counter);
     p_HcFrame->extraReg = 0x00008000;
@@ -1283,13 +909,10 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 
     if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
     {
-        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
         XX_FreeSmart(p_HcFrame);
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
-
     XX_FreeSmart(p_HcFrame);
 
     return E_OK;
@@ -1298,19 +921,16 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    uint16_t    absoluteProfileId = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
-    t_Error     err = E_OK;
+    uint16_t    absoluteProfileId = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
+    t_Error     err;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
     uint32_t    retVal = 0;
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
-    if (FmPcdPlcrProfileTryLock(p_FmHc->h_FmPcd, absoluteProfileId, FALSE))
-        return 0;
-
     /* first read scheme and check that it is valid */
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
     {
         REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
@@ -1323,23 +943,14 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+	err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
+    if (err != E_OK)
     {
-        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
         REPORT_ERROR(MINOR, err, NO_MSG);
         XX_FreeSmart(p_HcFrame);
         return 0;
     }
 
-    /* check that profile is valid */
-    if (!FmPcdPlcrHwProfileIsValid(p_HcFrame->hcSpecificData.profileRegs.fmpl_pemode))
-    {
-        FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
-        XX_FreeSmart(p_HcFrame);
-        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("invalid Policer profile"));
-        return 0;
-    }
-
     switch (counter)
     {
         case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
@@ -1361,282 +972,11 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
     }
 
-    FmPcdPlcrReleaseProfileLock(p_FmHc->h_FmPcd, absoluteProfileId);
-
     XX_FreeSmart(p_HcFrame);
 
     return retVal;
 }
 
-t_Error FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
-{
-    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error     err = E_OK;
-    uint32_t    intFlags;
-    t_List      h_OldPointersLst, h_NewPointersLst;
-    t_Handle    h_Params;
-
-    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-    err = FmPcdCcTreeTryLock(h_CcTree);
-    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-    if (err)
-        return err;
-
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
-
-    err = FmPcdCcModifyNextEngineParamTree(p_FmHc->h_FmPcd, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams,
-            &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-    if(err)
-    {
-        FmPcdCcTreeReleaseLock(h_CcTree);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-
-    FmPcdCcTreeReleaseLock(h_CcTree);
-
-    return err;
-}
-
-
-t_Error FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
-{
-    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Handle    h_Params;
-    t_List      h_OldPointersLst, h_NewPointersLst;
-    t_Error     err = E_OK;
-    t_List      h_List;
-    uint32_t    intFlags;
-
-    INIT_LIST(&h_List);
-
-    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-
-    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
-    {
-        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-        return err;
-    }
-
-    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
-
-    err = FmPcdCcModifyMissNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, p_FmPcdCcNextEngineParams, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-    if(err)
-    {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-
-    FmPcdCcNodeTreeReleaseLock(&h_List);
-
-
-    return E_OK;
-}
-
-t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex)
-{
-    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Handle    h_Params;
-    t_List      h_OldPointersLst, h_NewPointersLst;
-    t_Error     err = E_OK;
-    t_List      h_List;
-    uint32_t    intFlags;
-
-    INIT_LIST(&h_List);
-
-    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-
-    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
-    {
-        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-        return err;
-    }
-
-    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
-
-
-    err = FmPcdCcRemoveKey(p_FmHc->h_FmPcd,h_CcNode,keyIndex, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-    if(err)
-    {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-
-    FmPcdCcNodeTreeReleaseLock(&h_List);
-
-    return err;
-
-}
-
-t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
-{
-    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Handle    h_Params;
-    t_List      h_OldPointersLst, h_NewPointersLst;
-    t_Error     err = E_OK;
-    t_List      h_List;
-    uint32_t    intFlags;
-
-    INIT_LIST(&h_List);
-
-    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-
-    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
-    {
-        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-        return err;
-    }
-
-    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
-
-
-    err = FmPcdCcAddKey(p_FmHc->h_FmPcd,h_CcNode,keyIndex,keySize, p_KeyParams, &h_OldPointersLst,&h_NewPointersLst, &h_Params);
-    if(err)
-    {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-
-    FmPcdCcNodeTreeReleaseLock(&h_List);
-
-    return err;
-}
-
-
-t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
-{
-    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    t_List      h_OldPointersLst, h_NewPointersLst;
-    t_Error     err = E_OK;
-    t_List      h_List;
-    uint32_t    intFlags;
-    t_Handle    h_Params;
-
-    UNUSED(keySize);
-
-    INIT_LIST(&h_List);
-
-    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-
-    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
-    {
-        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-        return err;
-    }
-
-    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
-
-    err = FmPcdCcModifyKey(p_FmHc->h_FmPcd, h_CcNode, keyIndex, keySize, p_Key, p_Mask, &h_OldPointersLst,&h_NewPointersLst,  &h_Params);
-    if(err)
-    {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-
-    FmPcdCcNodeTreeReleaseLock(&h_List);
-
-    return err;
-}
-
-t_Error FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
-{
-    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    t_Error     err = E_OK;
-    t_List      h_OldPointersLst, h_NewPointersLst;
-    t_List      h_List;
-    uint32_t    intFlags;
-    t_Handle    h_Params;
-
-    INIT_LIST(&h_List);
-
-    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-
-    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
-    {
-        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-        return err;
-    }
-
-    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
-
-    err = FmPcdCcModiyNextEngineParamNode(p_FmHc->h_FmPcd, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-    if(err)
-    {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-    FmPcdCcNodeTreeReleaseLock(&h_List);
-    return err;
-}
-
-
-t_Error FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
-{
-    t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
-    t_List      h_OldPointersLst, h_NewPointersLst;
-    t_Error     err = E_OK;
-    t_List      h_List;
-    uint32_t    intFlags;
-    t_Handle    h_Params;
-
-    INIT_LIST(&h_OldPointersLst);
-    INIT_LIST(&h_NewPointersLst);
-    INIT_LIST(&h_List);
-
-    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-
-    if ((err = FmPcdCcNodeTreeTryLock(p_FmHc->h_FmPcd, h_CcNode, &h_List)) != E_OK)
-    {
-        FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-        return err;
-    }
-
-    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
-
-
-    err = FmPcdCcModifyKeyAndNextEngine(p_FmHc->h_FmPcd,h_CcNode,keyIndex,keySize, p_KeyParams, &h_OldPointersLst,&h_NewPointersLst, &h_Params);
-    if(err)
-    {
-        FmPcdCcNodeTreeReleaseLock(&h_List);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-    err =  HcDynamicChange(p_FmHc, &h_OldPointersLst, &h_NewPointersLst, &h_Params);
-
-    FmPcdCcNodeTreeReleaseLock(&h_List);
-
-
-    return err;
-}
-
-
 t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add)
 {
     t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
@@ -1646,14 +986,14 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
 
     ASSERT_COND(p_FmHc);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     /* first read SP register */
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
-    p_HcFrame->extraReg = 0xFFFFF800;
+    p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
 
     BUILD_FD(SIZE_OF_HC_FRAME_PORT_REGS);
 
@@ -1693,14 +1033,14 @@ t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
 
     ASSERT_COND(p_FmHc);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     /* first read SP register */
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
-    p_HcFrame->extraReg = 0xFFFFF800;
+    p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
     p_HcFrame->hcSpecificData.singleRegForWrite = cppReg;
 
     BUILD_FD(sizeof(t_HcFrame));
@@ -1716,3 +1056,34 @@ t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
     return E_OK;
 }
 
+t_Error FmHcPcdCcDoDynamicChange(t_Handle h_FmHc, uint32_t oldAdAddrOffset, uint32_t newAdAddrOffset)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    t_Error                 err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmHc, E_INVALID_HANDLE);
+
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+
+    p_HcFrame->opcode     = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC);
+    p_HcFrame->actionReg  = newAdAddrOffset;
+    p_HcFrame->actionReg |= 0xc0000000;
+    p_HcFrame->extraReg   = oldAdAddrOffset;
+
+    BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_FreeSmart(p_HcFrame);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    XX_FreeSmart(p_HcFrame);
+
+    return E_OK;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index e26d147..8f78a9b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -68,8 +68,9 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
     if(p_Dtsec->p_DtsecDriverParam->halfDuplex && (p_Dtsec->p_DtsecDriverParam)->loopback)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("LoopBack is not supported in halfDuplex mode"));
 #ifdef FM_RX_PREAM_4_ERRATA_DTSEC_A001
-    if(p_Dtsec->p_DtsecDriverParam->preambleRxEn)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("preambleRxEn"));
+    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev != 8 /*tmp */)
+	    if(p_Dtsec->p_DtsecDriverParam->preambleRxEn)
+	        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("preambleRxEn"));
 #endif /* FM_RX_PREAM_4_ERRATA_DTSEC_A001 */
     if(((p_Dtsec->p_DtsecDriverParam)->preambleTxEn || (p_Dtsec->p_DtsecDriverParam)->preambleRxEn) &&( (p_Dtsec->p_DtsecDriverParam)->preambleLength != 0x7))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Preamble length should be 0x7 bytes"));
@@ -102,6 +103,11 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
     if (!p_Dtsec->f_Event)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("uninitialized f_Event"));
 
+#ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
+	if(p_Dtsec->p_DtsecDriverParam->lengthCheckEnable)
+	   RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+#endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
+
     return E_OK;
 }
 
@@ -306,71 +312,74 @@ static void DtsecErrException(t_Handle h_Dtsec)
     if(event & IMASK_XFUNEN)
     {
 #ifdef FM_TX_LOCKUP_ERRATA_DTSEC6
-        uint32_t  tpkt1, tmpReg1, tpkt2, tmpReg2, i;
-        /* a. Write 0x00E0_0C00 to DTSEC_ID */
-        /* This is a read only regidter */
-
-        /* b. Read and save the value of TPKT */
-        tpkt1 = GET_UINT32(p_DtsecMemMap->tpkt);
-
-        /* c. Read the register at dTSEC address offset 0x32C */
-        tmpReg1 =  GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
-
-        /* d. Compare bits [9:15] to bits [25:31] of the register at address offset 0x32C. */
-        if((tmpReg1 & 0x007F0000) != (tmpReg1 & 0x0000007F))
-        {
-            /* If they are not equal, save the value of this register and wait for at least
-             * MAXFRM*16 ns */
-            XX_UDelay((uint32_t)(MIN(DtsecGetMaxFrameLength(p_Dtsec)*16/1000, 1)));
-        }
-
-        /* e. Read and save TPKT again and read the register at dTSEC address offset
-            0x32C again*/
-        tpkt2 = GET_UINT32(p_DtsecMemMap->tpkt);
-        tmpReg2 = GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
-
-        /* f. Compare the value of TPKT saved in step b to value read in step e. Also
-            compare bits [9:15] of the register at offset 0x32C saved in step d to the value
-            of bits [9:15] saved in step e. If the two registers values are unchanged, then
-            the transmit portion of the dTSEC controller is locked up and the user should
-            proceed to the recover sequence. */
-        if((tpkt1 == tpkt2) && ((tmpReg1 & 0x007F0000) == (tmpReg2 & 0x007F0000)))
-        {
-            /* recover sequence */
-
-            /* a.Write a 1 to RCTRL[GRS]*/
-
-            WRITE_UINT32(p_DtsecMemMap->rctrl, GET_UINT32(p_DtsecMemMap->rctrl) | RCTRL_GRS);
-
-            /* b.Wait until IEVENT[GRSC]=1, or at least 100 us has elapsed. */
-            for(i = 0 ; i < 100 ; i++ )
-            {
-                if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
-                    break;
-                XX_UDelay(1);
-            }
-            if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
-                WRITE_UINT32(p_DtsecMemMap->ievent, IMASK_GRSCEN);
-            else
-                DBG(INFO,("Rx lockup due to dTSEC Tx lockup"));
-
-
-            /* c.Write a 1 to bit n of FM_RSTC (offset 0x0CC of FPM)*/
-            FmResetMac(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId);
-
-            /* d.Wait 4 Tx clocks (32 ns) */
-            XX_UDelay(1);
-
-            /* e.Write a 0 to bit n of FM_RSTC. */
-            /* cleared by FMAN */
-        }
-        else
-        {
-            /* If either value has changed, the dTSEC controller is not locked up and the
-               controller should be allowed to proceed normally by writing the reset value
-               of 0x0824_0101 to DTSEC_ID. */
-            /* Register is read only */
-        }
+	    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+	    {
+	        uint32_t  tpkt1, tmpReg1, tpkt2, tmpReg2, i;
+	        /* a. Write 0x00E0_0C00 to DTSEC_ID */
+	        /* This is a read only regidter */
+
+	        /* b. Read and save the value of TPKT */
+	        tpkt1 = GET_UINT32(p_DtsecMemMap->tpkt);
+
+	        /* c. Read the register at dTSEC address offset 0x32C */
+	        tmpReg1 =  GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
+
+	        /* d. Compare bits [9:15] to bits [25:31] of the register at address offset 0x32C. */
+	        if((tmpReg1 & 0x007F0000) != (tmpReg1 & 0x0000007F))
+	        {
+	            /* If they are not equal, save the value of this register and wait for at least
+	             * MAXFRM*16 ns */
+	            XX_UDelay((uint32_t)(MIN(DtsecGetMaxFrameLength(p_Dtsec)*16/1000, 1)));
+	        }
+
+	        /* e. Read and save TPKT again and read the register at dTSEC address offset
+	            0x32C again*/
+	        tpkt2 = GET_UINT32(p_DtsecMemMap->tpkt);
+	        tmpReg2 = GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
+
+	        /* f. Compare the value of TPKT saved in step b to value read in step e. Also
+	            compare bits [9:15] of the register at offset 0x32C saved in step d to the value
+	            of bits [9:15] saved in step e. If the two registers values are unchanged, then
+	            the transmit portion of the dTSEC controller is locked up and the user should
+	            proceed to the recover sequence. */
+	        if((tpkt1 == tpkt2) && ((tmpReg1 & 0x007F0000) == (tmpReg2 & 0x007F0000)))
+	        {
+	            /* recover sequence */
+
+	            /* a.Write a 1 to RCTRL[GRS]*/
+
+	            WRITE_UINT32(p_DtsecMemMap->rctrl, GET_UINT32(p_DtsecMemMap->rctrl) | RCTRL_GRS);
+
+	            /* b.Wait until IEVENT[GRSC]=1, or at least 100 us has elapsed. */
+	            for(i = 0 ; i < 100 ; i++ )
+	            {
+	                if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
+	                    break;
+	                XX_UDelay(1);
+	            }
+	            if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
+	                WRITE_UINT32(p_DtsecMemMap->ievent, IMASK_GRSCEN);
+	            else
+	                DBG(INFO,("Rx lockup due to dTSEC Tx lockup"));
+
+
+	            /* c.Write a 1 to bit n of FM_RSTC (offset 0x0CC of FPM)*/
+	            FmResetMac(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId);
+
+	            /* d.Wait 4 Tx clocks (32 ns) */
+	            XX_UDelay(1);
+
+	            /* e.Write a 0 to bit n of FM_RSTC. */
+	            /* cleared by FMAN */
+	        }
+	        else
+	        {
+	            /* If either value has changed, the dTSEC controller is not locked up and the
+	               controller should be allowed to proceed normally by writing the reset value
+	               of 0x0824_0101 to DTSEC_ID. */
+	            /* Register is read only */
+	        }
+	    }
 #endif /* FM_TX_LOCKUP_ERRATA_DTSEC6 */
 
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_FIFO_UNDRN);
@@ -418,10 +427,9 @@ static void FreeInitResources(t_Dtsec *p_Dtsec)
         XX_DisableIntr(p_Dtsec->mdioIrq);
         XX_FreeIntr(p_Dtsec->mdioIrq);
     }
-    else if (p_Dtsec->mdioIrq == 0)
-        FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL);
+
     FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_ERR);
-    FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC_TMR, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL);
+    FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL);
 
     /* release the driver's group hash table */
     FreeHashTable(p_Dtsec->p_MulticastAddrHash);
@@ -474,15 +482,22 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
                      GET_UINT32(p_MemMap->rctrl) | RCTRL_GRS);
 
 #ifdef FM_GRS_ERRATA_DTSEC_A002
-    XX_UDelay(100);
+    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+        XX_UDelay(100);
 #endif /* FM_GRS_ERRATA_DTSEC_A002 */
 
-#if defined(FM_GTS_ERRATA_DTSEC_A004) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012) || defined(FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014)
-    DBG(INFO, ("GTS not supported due to DTSEC_A004 errata."));
-#else  /* not defined(FM_GTS_ERRATA_DTSEC_A004) ||... */
     if (mode & e_COMM_MODE_TX)
+#if defined(FM_GTS_ERRATA_DTSEC_A004) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012)
+    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+        DBG(INFO, ("GTS not supported due to DTSEC_A004 errata."));
+#else  /* not defined(FM_GTS_ERRATA_DTSEC_A004) ||... */
+#ifdef FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014
+    if((p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2) || (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 5))
+        DBG(INFO, ("GTS not supported due to DTSEC_A0014 errata."));
+#else  /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
         WRITE_UINT32(p_MemMap->tctrl,
                      GET_UINT32(p_MemMap->tctrl) | TCTRL_GTS);
+#endif
 #endif /* defined(FM_GTS_ERRATA_DTSEC_A004) ||...  */
 
     return E_OK;
@@ -576,13 +591,22 @@ static t_Error DtsecConfigHalfDuplex(t_Handle h_Dtsec, bool newVal)
 
 /* .............................................................................. */
 
-static t_Error DtsecConfigLengthCheck(t_Handle h_Dtsec, bool newVal)
+static t_Error DtsecConfigTbiPhyAddr(t_Handle h_Dtsec, uint8_t newVal)
 {
-#ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
-UNUSED(h_Dtsec);
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+    t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    p_Dtsec->p_DtsecDriverParam->tbiPhyAddr = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
 
-#else
+static t_Error DtsecConfigLengthCheck(t_Handle h_Dtsec, bool newVal)
+{
     t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
@@ -591,7 +615,6 @@ UNUSED(h_Dtsec);
     p_Dtsec->p_DtsecDriverParam->lengthCheckEnable = newVal;
 
     return E_OK;
-#endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
 }
 
 static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exception, bool enable)
@@ -688,12 +711,17 @@ static t_Error DtsecDisable (t_Handle h_Dtsec, e_CommMode mode)
 
 /* .............................................................................. */
 
-static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime)
+static t_Error DtsecTxMacPause(t_Handle h_Dtsec,
+                               uint8_t  priority,
+                               uint16_t pauseTime,
+                               uint16_t threshTime)
 {
     t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
     uint32_t        ptv = 0;
     t_DtsecMemMap   *p_MemMap;
 
+UNUSED(priority);UNUSED(threshTime);
+
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
@@ -703,12 +731,11 @@ static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime)
     if (pauseTime)
     {
 #ifdef FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
-        {
+        if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
             if (pauseTime <= 320)
                 RETURN_ERROR(MINOR, E_INVALID_VALUE,
                              ("This pause-time value of %d is illegal due to errata dTSEC-A003!"
                               " value should be greater than 320."));
-        }
 #endif /* FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003 */
 
         ptv = GET_UINT32(p_MemMap->ptv);
@@ -720,10 +747,8 @@ static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime)
                      GET_UINT32(p_MemMap->maccfg1) | MACCFG1_TX_FLOW);
     }
     else
-    {
         WRITE_UINT32(p_MemMap->maccfg1,
                      GET_UINT32(p_MemMap->maccfg1) & ~MACCFG1_TX_FLOW);
-    }
 
     return E_OK;
 }
@@ -761,10 +786,6 @@ static t_Error DtsecEnable1588TimeStamp(t_Handle h_Dtsec)
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
-#ifdef FM_10_100_SGMII_NO_TS_ERRATA_DTSEC3
-    if((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) || (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("1588TimeStamp in 10/100 SGMII"));
-#endif /* FM_10_100_SGMII_NO_TS_ERRATA_DTSEC3 */
     p_Dtsec->ptpTsuEnabled = TRUE;
     WRITE_UINT32(p_Dtsec->p_MemMap->rctrl, GET_UINT32(p_Dtsec->p_MemMap->rctrl) | RCTRL_RTSE);
     WRITE_UINT32(p_Dtsec->p_MemMap->tctrl, GET_UINT32(p_Dtsec->p_MemMap->tctrl) | TCTRL_TTSE);
@@ -1217,10 +1238,11 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
     p_DtsecMemMap = p_Dtsec->p_MemMap;
     SANITY_CHECK_RETURN_ERROR(p_DtsecMemMap, E_INVALID_HANDLE);
 
-    if (!fullDuplex &&
-        ((speed >= e_ENET_SPEED_1000) ||
-         (ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)))
-        RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
+    if(((p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
+        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)) &&
+        p_Dtsec->halfDuplex)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in half duplex"));
 
     p_Dtsec->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode), speed);
     p_Dtsec->halfDuplex = !fullDuplex;
@@ -1326,7 +1348,9 @@ static t_Error DtsecSetException(t_Handle h_Dtsec, e_FmMacExceptions exception,
         if((exception == e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL) &&
             !enable &&
             (p_Dtsec->statisticsLevel != e_FM_MAC_NONE_STATISTICS))
-            DBG(INFO, ("Disabled MIB counters overflow exceptions. Counters value may be inaccurate due to unregistered overflow"));
+            DBG(INFO, ("Disabled MIB counters overflow exceptions."
+                          " Counters value may be inaccurate due to unregistered overflow"));
+
     }
     else
     {
@@ -1441,9 +1465,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
              RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for reduced interface in current DTSEC version"));
         }
 
-    if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
+    if ((ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)||
         (p_Dtsec->enetMode == e_ENET_MODE_MII_10)    ||
         (p_Dtsec->enetMode == e_ENET_MODE_MII_100))
         if(tmpReg32 & ID2_INT_NORMAL_OFF)
@@ -1463,9 +1485,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
         (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
         tmpReg32 |= ECNTRL_GMIIM;
-    if ((p_Dtsec->enetMode == e_ENET_MODE_SGMII_10)   ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100)  ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000))
+    if (ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)
         tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM);
     if (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)
         tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM | ECNTRL_QSGMIIM);
@@ -1534,15 +1554,17 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     /* conflict with the external PHYs Physical address   */
     WRITE_UINT32(p_DtsecMemMap->tbipa, p_DtsecDriverParam->tbiPhyAddr);
 
-    if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
+    if(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)
     {
         uint16_t            tmpReg16;
 
         /* Configure the TBI PHY Control Register */
         tmpReg16 = PHY_TBICON_CLK_SEL | PHY_TBICON_SRESET;
+
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
 
         tmpReg16 = PHY_TBICON_CLK_SEL;
+
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
 
         tmpReg16 = (PHY_CR_PHY_RESET | PHY_CR_ANE | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
@@ -1552,7 +1574,8 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         tmpReg16 = PHY_TBIANA_SGMII;
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 4, tmpReg16);
 
-        tmpReg16 = PHY_CR_ANE | PHY_CR_RESET_AN | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1;
+        tmpReg16 = (PHY_CR_ANE | PHY_CR_RESET_AN | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
+
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
     }
 
@@ -1710,21 +1733,21 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     p_Dtsec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if(!p_Dtsec->p_MulticastAddrHash)
     {
-        FreeInitResources(p_Dtsec);
+	FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MC hash table is FAILED"));
     }
 
     p_Dtsec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if(!p_Dtsec->p_UnicastAddrHash)
     {
-        FreeInitResources(p_Dtsec);
+	FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("UC hash table is FAILED"));
     }
 
     /* register err intr handler for dtsec to FPM (err)*/
     FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_ERR, DtsecErrException , p_Dtsec);
     /* register 1588 intr handler for TMR to FPM (normal)*/
-    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC_TMR, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL, Dtsec1588Exception , p_Dtsec);
+    FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL, Dtsec1588Exception , p_Dtsec);
     /* register normal intr handler for dtsec to main interrupt controller. */
     if (p_Dtsec->mdioIrq != NO_IRQ)
     {
@@ -1738,7 +1761,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     err = DtsecSetStatistics(p_Dtsec, e_FM_MAC_FULL_STATISTICS);
     if(err)
     {
-        FreeInitResources(p_Dtsec);
+	FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1781,6 +1804,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = DtsecConfigPadAndCrc;
     p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = DtsecConfigHalfDuplex;
     p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = DtsecConfigLengthCheck;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigTbiPhyAddr         	= DtsecConfigTbiPhyAddr;
     p_FmMacControllerDriver->f_FM_MAC_ConfigException           = DtsecConfigException;
 
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = DtsecEnable;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index 54c44b2..51ef324 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -293,17 +293,17 @@ typedef  uint32_t t_ErrorDisable;
 #define DEBUG_GET_FIFO_READ_INDEX       0x007f0000
 #define DEBUG_GET_FIFO_WRITE_INDEX      0x0000007f
 /* Pause Time Value Register  */
-#define PTV_PTE_SHIFT    16
+#define PTV_PTE_SHIFT       16
 
-#define     MASK22BIT   0x003FFFFF
-#define     MASK16BIT   0x0000FFFF
-#define     MASK12BIT   0x00000FFF
-#define     MASK8BIT    0x000000FF
+#define MASK22BIT           0x003FFFFF
+#define MASK16BIT           0x0000FFFF
+#define MASK12BIT           0x00000FFF
+#define MASK8BIT            0x000000FF
 
-#define     VAL32BIT    0x100000000LL
-#define     VAL22BIT    0x00400000
-#define     VAL16BIT    0x00010000
-#define     VAL12BIT    0x00001000
+#define VAL32BIT            0x100000000LL
+#define VAL22BIT            0x00400000
+#define VAL16BIT            0x00010000
+#define VAL12BIT            0x00001000
 
 /* PHY Control Register */
 #define PHY_CR_PHY_RESET    0x8000
@@ -365,51 +365,17 @@ typedef  uint32_t t_ErrorDisable;
 
 #define CAM2_ERRORS_ONLY (CAR2_TFCS | CAR2_TXPF | CAR2_TDRP)
 
-typedef struct t_InternalStatistics
-{
-    uint64_t    tr64;
-    uint64_t    tr127;
-    uint64_t    tr255;
-    uint64_t    tr511;
-    uint64_t    tr1k;
-    uint64_t    trmax;
-    uint64_t    trmgv;
-    uint64_t    rfrg;
-    uint64_t    rjbr;
-    uint64_t    rdrp;
-    uint64_t    raln;
-    uint64_t    rund;
-    uint64_t    rovr;
-    uint64_t    rxpf;
-    uint64_t    txpf;
-    uint64_t    rbyt;
-    uint64_t    rpkt;
-    uint64_t    rmca;
-    uint64_t    rbca;
-    uint64_t    rflr;
-    uint64_t    rcde;
-    uint64_t    rcse;
-    uint64_t    tbyt;
-    uint64_t    tpkt;
-    uint64_t    tmca;
-    uint64_t    tbca;
-    uint64_t    tdrp;
-    uint64_t    tfcs;
-} t_InternalStatistics;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
-typedef _Packed struct
-{
-    uint32_t exact_match1; /* octets 1-4 */
-    uint32_t exact_match2; /* octets 5-6 */
-} _PackedType macRegs;
+typedef struct {
+    volatile uint32_t exact_match1; /* octets 1-4 */
+    volatile uint32_t exact_match2; /* octets 5-6 */
+} macRegs;
 
-typedef _Packed struct
-{
+typedef struct {
     volatile uint32_t tsec_id1;             /* 0x000 ETSEC_ID register */
     volatile uint32_t tsec_id2;             /* 0x004 ETSEC_ID2 register */
     volatile uint32_t ievent;               /* 0x008 Interrupt event register */
@@ -523,15 +489,45 @@ typedef _Packed struct
     volatile uint32_t tx_threshold;     /* 0x340 Transmit threshold; Number of entries (4 bytes units) before starting to transmit to the MAC */
     volatile uint32_t tx_watermark_high;/* 0x344 Transmit watermark high; Number of entries (4 byte units) before de-asserting Ready to packet Interface */
     volatile uint32_t rx_watermark_low; /* 0x348 Receive watermark low; Number of entries (4 byte units) before unloading to packet Interface */
-} _PackedType t_DtsecMemMap;
+} t_DtsecMemMap;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
 
 
 typedef struct {
+    uint64_t    tr64;
+    uint64_t    tr127;
+    uint64_t    tr255;
+    uint64_t    tr511;
+    uint64_t    tr1k;
+    uint64_t    trmax;
+    uint64_t    trmgv;
+    uint64_t    rfrg;
+    uint64_t    rjbr;
+    uint64_t    rdrp;
+    uint64_t    raln;
+    uint64_t    rund;
+    uint64_t    rovr;
+    uint64_t    rxpf;
+    uint64_t    txpf;
+    uint64_t    rbyt;
+    uint64_t    rpkt;
+    uint64_t    rmca;
+    uint64_t    rbca;
+    uint64_t    rflr;
+    uint64_t    rcde;
+    uint64_t    rcse;
+    uint64_t    tbyt;
+    uint64_t    tpkt;
+    uint64_t    tmca;
+    uint64_t    tbca;
+    uint64_t    tdrp;
+    uint64_t    tfcs;
+} t_InternalStatistics;
+
+typedef struct {
     uint32_t    errorDisabled;
     bool        halfDuplex;
     uint16_t    pauseTime;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
index 14b53ea..85614a7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
index 6c0c449..d43b33b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -54,7 +54,6 @@
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 /*----------------------------------------------------*/
 /* MII Configuration Control Memory Map Registers     */
@@ -69,7 +68,6 @@ typedef _Packed struct t_MiiAccessMemMap
     volatile uint32_t miimind;    /* MII Mgmt:indicators    */
 } _PackedType t_MiiAccessMemMap ;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index 74dfaf5..9ed7b1b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -53,10 +53,16 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 
     SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_INVALID_HANDLE, NULL);
 
-    if(ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
+#if (DPAA_VERSION == 2)
+    if (ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
         p_FmMacControllerDriver = (t_FmMacControllerDriver *)DTSEC_Config(p_FmMacParam);
+#if FM_MAX_NUM_OF_10G_MACS > 0
     else
        p_FmMacControllerDriver = (t_FmMacControllerDriver *)TGEC_Config(p_FmMacParam);
+#endif /* FM_MAX_NUM_OF_10G_MACS > 0 */
+#else
+    p_FmMacControllerDriver = (t_FmMacControllerDriver *)MEMAC_Config(p_FmMacParam);
+#endif /* (DPAA_VERSION == 2) */
 
     if (!p_FmMacControllerDriver)
         return NULL;
@@ -83,11 +89,13 @@ t_Error FM_MAC_Init (t_Handle h_FmMac)
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
+#if (DPAA_VERSION == 2)
     if (p_FmMacControllerDriver->resetOnInit &&
         (FmResetMac(p_FmMacControllerDriver->h_Fm,
                     ((ENET_INTERFACE_FROM_MODE(p_FmMacControllerDriver->enetMode) == e_ENET_IF_XGMII) ? e_FM_MAC_10G : e_FM_MAC_1G),
                      p_FmMacControllerDriver->macId) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't reset MAC!"));
+#endif /* (DPAA_VERSION == 2) */
 
     if (p_FmMacControllerDriver->f_FM_MAC_Init)
         return p_FmMacControllerDriver->f_FM_MAC_Init(h_FmMac);
@@ -192,6 +200,20 @@ t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool newVal)
 
 /* ........................................................................... */
 
+t_Error FM_MAC_ConfigTbiPhyAddr (t_Handle h_FmMac, uint8_t newVal)
+{
+    t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacControllerDriver->f_FM_MAC_ConfigTbiPhyAddr)
+        return p_FmMacControllerDriver->f_FM_MAC_ConfigTbiPhyAddr(h_FmMac,newVal);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+/* ........................................................................... */
+
 t_Error FM_MAC_ConfigLengthCheck (t_Handle h_FmMac, bool newVal)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
@@ -297,14 +319,20 @@ t_Error FM_MAC_Disable1588TimeStamp (t_Handle h_FmMac)
 
 /* ........................................................................... */
 
-t_Error FM_MAC_SetTxAutoPauseFrames (t_Handle h_FmMac, uint16_t pauseTime)
+t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
+                                    uint8_t  priority,
+                                    uint16_t pauseTime,
+                                    uint16_t threshTime)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver = (t_FmMacControllerDriver *)h_FmMac;
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
     if (p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames)
-        return p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames(h_FmMac, pauseTime);
+        return p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames(h_FmMac,
+                                                                      priority,
+                                                                      pauseTime,
+                                                                      threshTime);
 
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
@@ -361,6 +389,7 @@ t_Error FM_MAC_SetStatistics (t_Handle h_FmMac, e_FmMacStatisticsLevel statistic
 
     if (p_FmMacControllerDriver->f_FM_MAC_SetStatistics)
         return p_FmMacControllerDriver->f_FM_MAC_SetStatistics(h_FmMac, statisticsLevel);
+
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
index 3dfa6cd..52eb0f4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -42,6 +42,7 @@
 #include "error_ext.h"
 #include "list_ext.h"
 #include "fm_mac_ext.h"
+#include "fm_common.h"
 
 
 #define __ERR_MODULE__  MODULE_FM_MAC
@@ -93,6 +94,7 @@ typedef struct {
     t_Error (*f_FM_MAC_ConfigPadAndCrc) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_ConfigHalfDuplex) (t_Handle h_FmMac, bool newVal);
     t_Error (*f_FM_MAC_ConfigLengthCheck) (t_Handle h_FmMac, bool newVal);
+    t_Error (*f_FM_MAC_ConfigTbiPhyAddr) (t_Handle h_FmMac, uint8_t newVal);
     t_Error (*f_FM_MAC_ConfigException) (t_Handle h_FmMac, e_FmMacExceptions, bool enable);
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
     t_Error (*f_FM_MAC_ConfigSkipFman11Workaround) (t_Handle h_FmMac);
@@ -106,7 +108,10 @@ typedef struct {
     t_Error (*f_FM_MAC_Disable1588TimeStamp) (t_Handle h_FmMac);
     t_Error (*f_FM_MAC_Reset)   (t_Handle h_FmMac, bool wait);
 
-    t_Error (*f_FM_MAC_SetTxAutoPauseFrames)   (t_Handle h_FmMac, uint16_t pauseTime);
+    t_Error (*f_FM_MAC_SetTxAutoPauseFrames) (t_Handle h_FmMac,
+                                              uint8_t  priority,
+                                              uint16_t pauseTime,
+                                              uint16_t threshTime);
     t_Error (*f_FM_MAC_SetRxIgnorePauseFrames) (t_Handle h_FmMac, bool en);
 
     t_Error (*f_FM_MAC_ResetCounters) (t_Handle h_FmMac);
@@ -134,16 +139,21 @@ typedef struct {
     t_Error (*f_FM_MAC_DumpRegs) (t_Handle h_FmMac);
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
-    t_Handle        h_Fm;
-    e_EnetMode      enetMode;
-    uint8_t         macId;
-    bool            resetOnInit;
-    uint16_t        clkFreq;
+    t_Handle            h_Fm;
+    t_FmRevisionInfo    fmRevInfo;
+    e_EnetMode          enetMode;
+    uint8_t             macId;
+    bool                resetOnInit;
+    uint16_t            clkFreq;
 } t_FmMacControllerDriver;
 
 
+#if (DPAA_VERSION == 2)
 t_Handle    DTSEC_Config(t_FmMacParams *p_FmMacParam);
 t_Handle    TGEC_Config(t_FmMacParams *p_FmMacParams);
+#else
+t_Handle    MEMAC_Config(t_FmMacParams *p_FmMacParam);
+#endif /* (DPAA_VERSION == 2) */
 uint16_t    FM_MAC_GetMaxFrameLength(t_Handle FmMac);
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index 0de017d..bb24210 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -66,6 +66,10 @@ static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("uninitialized f_Exception"));
     if(!p_Tgec->f_Event)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("uninitialized f_Event"));
+#ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
+	if(!p_Tgec->p_TgecDriverParam->noLengthCheckEnable)
+	   RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+#endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
     return E_OK;
 }
 
@@ -337,15 +341,6 @@ static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-#ifdef FM_NO_TGEC_LOOPBACK
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("no loopback in this chip rev!"));
-    }
-#endif /* FM_NO_TGEC_LOOPBACK */
-
     p_Tgec->p_TgecDriverParam->loopbackEnable = newVal;
 
     return E_OK;
@@ -383,11 +378,6 @@ static t_Error TgecConfigMaxFrameLength(t_Handle h_Tgec, uint16_t newVal)
 
 static t_Error TgecConfigLengthCheck(t_Handle h_Tgec, bool newVal)
 {
-#if defined(FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010) || defined(FM_LEN_CHECK_ERRATA_FMAN_SW002)
-UNUSED(h_Tgec);
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
-
-#else
     t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
 
     UNUSED(newVal);
@@ -398,7 +388,6 @@ UNUSED(h_Tgec);
     p_Tgec->p_TgecDriverParam->noLengthCheckEnable = !newVal;
 
     return E_OK;
-#endif /* FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010 */
 }
 
 /* .............................................................................. */
@@ -448,12 +437,17 @@ static t_Error TgecConfigSkipFman11Workaround(t_Handle h_Tgec)
 
 /* .............................................................................. */
 
-static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime)
+static t_Error TgecTxMacPause(t_Handle h_Tgec,
+                              uint8_t  priority,
+                              uint16_t pauseTime,
+                              uint16_t threshTime)
 {
     t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
     uint32_t        ptv = 0;
     t_TgecMemMap    *p_MemMap;
 
+UNUSED(priority);UNUSED(threshTime);
+
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
@@ -504,44 +498,44 @@ static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistic
 
     p_TgecMemMap = p_Tgec->p_MemMap;
 
-    p_Statistics->eStatPkts64           = GET_UINT64(p_TgecMemMap->R64);
-    p_Statistics->eStatPkts65to127      = GET_UINT64(p_TgecMemMap->R127);
-    p_Statistics->eStatPkts128to255     = GET_UINT64(p_TgecMemMap->R255);
-    p_Statistics->eStatPkts256to511     = GET_UINT64(p_TgecMemMap->R511);
-    p_Statistics->eStatPkts512to1023    = GET_UINT64(p_TgecMemMap->R1023);
-    p_Statistics->eStatPkts1024to1518   = GET_UINT64(p_TgecMemMap->R1518);
-    p_Statistics->eStatPkts1519to1522   = GET_UINT64(p_TgecMemMap->R1519X);
+    p_Statistics->eStatPkts64           = (((uint64_t)GET_UINT32(p_TgecMemMap->r64_u)<<32)|GET_UINT32(p_TgecMemMap->r64_l));
+    p_Statistics->eStatPkts65to127      = (((uint64_t)GET_UINT32(p_TgecMemMap->r127_u)<<32)|GET_UINT32(p_TgecMemMap->r127_l));
+    p_Statistics->eStatPkts128to255     = (((uint64_t)GET_UINT32(p_TgecMemMap->r255_u)<<32)|GET_UINT32(p_TgecMemMap->r255_l));
+    p_Statistics->eStatPkts256to511     = (((uint64_t)GET_UINT32(p_TgecMemMap->r511_u)<<32)|GET_UINT32(p_TgecMemMap->r511_l));
+    p_Statistics->eStatPkts512to1023    = (((uint64_t)GET_UINT32(p_TgecMemMap->r1023_u)<<32)|GET_UINT32(p_TgecMemMap->r1023_l));
+    p_Statistics->eStatPkts1024to1518   = (((uint64_t)GET_UINT32(p_TgecMemMap->r1518_u)<<32)|GET_UINT32(p_TgecMemMap->r1518_l));
+    p_Statistics->eStatPkts1519to1522   = (((uint64_t)GET_UINT32(p_TgecMemMap->r1519x_u)<<32)|GET_UINT32(p_TgecMemMap->r1519x_l));
 /* */
-    p_Statistics->eStatFragments        = GET_UINT64(p_TgecMemMap->TRFRG);
-    p_Statistics->eStatJabbers          = GET_UINT64(p_TgecMemMap->TRJBR);
+    p_Statistics->eStatFragments        = (((uint64_t)GET_UINT32(p_TgecMemMap->trfrg_u)<<32)|GET_UINT32(p_TgecMemMap->trfrg_l));
+    p_Statistics->eStatJabbers          = (((uint64_t)GET_UINT32(p_TgecMemMap->trjbr_u)<<32)|GET_UINT32(p_TgecMemMap->trjbr_l));
 
-    p_Statistics->eStatsDropEvents      = GET_UINT64(p_TgecMemMap->RDRP);
-    p_Statistics->eStatCRCAlignErrors   = GET_UINT64(p_TgecMemMap->RALN);
+    p_Statistics->eStatsDropEvents      = (((uint64_t)GET_UINT32(p_TgecMemMap->rdrp_u)<<32)|GET_UINT32(p_TgecMemMap->rdrp_l));
+    p_Statistics->eStatCRCAlignErrors   = (((uint64_t)GET_UINT32(p_TgecMemMap->raln_u)<<32)|GET_UINT32(p_TgecMemMap->raln_l));
 
-    p_Statistics->eStatUndersizePkts    = GET_UINT64(p_TgecMemMap->TRUND);
-    p_Statistics->eStatOversizePkts     = GET_UINT64(p_TgecMemMap->TROVR);
+    p_Statistics->eStatUndersizePkts    = (((uint64_t)GET_UINT32(p_TgecMemMap->trund_u)<<32)|GET_UINT32(p_TgecMemMap->trund_l));
+    p_Statistics->eStatOversizePkts     = (((uint64_t)GET_UINT32(p_TgecMemMap->trovr_u)<<32)|GET_UINT32(p_TgecMemMap->trovr_l));
 /* Pause */
-    p_Statistics->reStatPause           = GET_UINT64(p_TgecMemMap->RXPF);
-    p_Statistics->teStatPause           = GET_UINT64(p_TgecMemMap->TXPF);
+    p_Statistics->reStatPause           = (((uint64_t)GET_UINT32(p_TgecMemMap->rxpf_u)<<32)|GET_UINT32(p_TgecMemMap->rxpf_l));
+    p_Statistics->teStatPause           = (((uint64_t)GET_UINT32(p_TgecMemMap->txpf_u)<<32)|GET_UINT32(p_TgecMemMap->txpf_l));
 
 /* MIB II */
-    p_Statistics->ifInOctets            = GET_UINT64(p_TgecMemMap->ROCT);
-    p_Statistics->ifInMcastPkts         = GET_UINT64(p_TgecMemMap->RMCA);
-    p_Statistics->ifInBcastPkts         = GET_UINT64(p_TgecMemMap->RBCA);
-    p_Statistics->ifInPkts              = GET_UINT64(p_TgecMemMap->RUCA)
+    p_Statistics->ifInOctets            = (((uint64_t)GET_UINT32(p_TgecMemMap->roct_u)<<32)|GET_UINT32(p_TgecMemMap->roct_l));
+    p_Statistics->ifInMcastPkts         = (((uint64_t)GET_UINT32(p_TgecMemMap->rmca_u)<<32)|GET_UINT32(p_TgecMemMap->rmca_l));
+    p_Statistics->ifInBcastPkts         = (((uint64_t)GET_UINT32(p_TgecMemMap->rbca_u)<<32)|GET_UINT32(p_TgecMemMap->rbca_l));
+    p_Statistics->ifInPkts              = (((uint64_t)GET_UINT32(p_TgecMemMap->ruca_u)<<32)|GET_UINT32(p_TgecMemMap->ruca_l))
                                         + p_Statistics->ifInMcastPkts
                                         + p_Statistics->ifInBcastPkts;
     p_Statistics->ifInDiscards          = 0;
-    p_Statistics->ifInErrors            = GET_UINT64(p_TgecMemMap->RERR);
+    p_Statistics->ifInErrors            = (((uint64_t)GET_UINT32(p_TgecMemMap->rerr_u)<<32)|GET_UINT32(p_TgecMemMap->rerr_l));
 
-    p_Statistics->ifOutOctets           = GET_UINT64(p_TgecMemMap->TOCT);
-    p_Statistics->ifOutMcastPkts        = GET_UINT64(p_TgecMemMap->TMCA);
-    p_Statistics->ifOutBcastPkts        = GET_UINT64(p_TgecMemMap->TBCA);
-    p_Statistics->ifOutPkts             = GET_UINT64(p_TgecMemMap->TUCA)
+    p_Statistics->ifOutOctets           = (((uint64_t)GET_UINT32(p_TgecMemMap->toct_u)<<32)|GET_UINT32(p_TgecMemMap->toct_l));
+    p_Statistics->ifOutMcastPkts        = (((uint64_t)GET_UINT32(p_TgecMemMap->tmca_u)<<32)|GET_UINT32(p_TgecMemMap->tmca_l));
+    p_Statistics->ifOutBcastPkts        = (((uint64_t)GET_UINT32(p_TgecMemMap->tbca_u)<<32)|GET_UINT32(p_TgecMemMap->tbca_l));
+    p_Statistics->ifOutPkts             = (((uint64_t)GET_UINT32(p_TgecMemMap->tuca_u)<<32)|GET_UINT32(p_TgecMemMap->tuca_l))
                                             + p_Statistics->ifOutMcastPkts
                                             + p_Statistics->ifOutBcastPkts;
     p_Statistics->ifOutDiscards         = 0;
-    p_Statistics->ifOutErrors           = GET_UINT64(p_TgecMemMap->TERR);
+    p_Statistics->ifOutErrors           = (((uint64_t)GET_UINT32(p_TgecMemMap->terr_u)<<32)|GET_UINT32(p_TgecMemMap->terr_l));
 
     return E_OK;
 }
@@ -665,19 +659,12 @@ static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
 
     /* Make sure no PADDR contains this address */
     for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
-    {
         if (p_Tgec->indAddrRegUsed[paddrNum])
-        {
             if (p_Tgec->paddr[paddrNum] == ethAddr)
-            {
                 RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
-            }
-        }
-    }
 
     /* Find first unused PADDR */
     for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
-    {
         if (!(p_Tgec->indAddrRegUsed[paddrNum]))
         {
             /* mark this PADDR as used */
@@ -691,7 +678,6 @@ static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
 
             return E_OK;
         }
-    }
 
     /* No free PADDR */
     RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
@@ -977,12 +963,17 @@ static t_Error TgecInit(t_Handle h_Tgec)
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
 
+    FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &p_Tgec->fmMacControllerDriver.fmRevInfo);
+
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    if (!p_Tgec->p_TgecDriverParam->skipFman11Workaround &&
-        ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
+    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev != 8 /*tmp */)
     {
-        FreeInitResources(p_Tgec);
-        RETURN_ERROR(MAJOR, err, ("TgecTxEccWorkaround FAILED"));
+        if (!p_Tgec->p_TgecDriverParam->skipFman11Workaround &&
+            ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
+        {
+            FreeInitResources(p_Tgec);
+            RETURN_ERROR(MAJOR, err, ("TgecTxEccWorkaround FAILED"));
+        }
     }
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
@@ -1041,8 +1032,11 @@ static t_Error TgecInit(t_Handle h_Tgec)
 
     /* Max Frame Length */
     WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_TgecDriverParam->maxFrameLength);
-    err = FmSetMacMaxFrame(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MAC_10G, p_Tgec->fmMacControllerDriver.macId, p_TgecDriverParam->maxFrameLength);
-    if(err)
+    err = FmSetMacMaxFrame(p_Tgec->fmMacControllerDriver.h_Fm,
+                           e_FM_MAC_10G,
+                           p_Tgec->fmMacControllerDriver.macId,
+                           p_TgecDriverParam->maxFrameLength);
+    if (err)
     {
         FreeInitResources(p_Tgec);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -1052,8 +1046,11 @@ static t_Error TgecInit(t_Handle h_Tgec)
     WRITE_UINT32(p_MemMap->pause_quant, p_TgecDriverParam->pauseTime);
 
 #ifdef FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
-    WRITE_UINT32(p_Tgec->p_MemMap->tx_ipg_len,
-        (GET_UINT32(p_Tgec->p_MemMap->tx_ipg_len) & ~TX_IPG_LENGTH_MASK) | DEFAULT_txIpgLength);
+    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+    {
+        WRITE_UINT32(p_Tgec->p_MemMap->tx_ipg_len,
+            (GET_UINT32(p_Tgec->p_MemMap->tx_ipg_len) & ~TX_IPG_LENGTH_MASK) | DEFAULT_txIpgLength);
+    }
 #endif /* FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007 */
 
     p_Tgec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
@@ -1072,12 +1069,8 @@ static t_Error TgecInit(t_Handle h_Tgec)
 
     /* interrupts */
 #ifdef FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
-        if (revInfo.majorRev <=2)
-            p_Tgec->exceptions &= ~(IMASK_REM_FAULT | IMASK_LOC_FAULT);
-    }
+    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev <=2)
+        p_Tgec->exceptions &= ~(IMASK_REM_FAULT | IMASK_LOC_FAULT);
 #endif /* FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005 */
     WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
     WRITE_UINT32(p_MemMap->imask, p_Tgec->exceptions);
@@ -1124,6 +1117,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_Init                      = TgecInit;
     p_FmMacControllerDriver->f_FM_MAC_Free                      = TgecFree;
 
+    p_FmMacControllerDriver->f_FM_MAC_SetStatistics             = NULL;
     p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = TgecConfigLoopback;
     p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = TgecConfigMaxFrameLength;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
index 68d490c..045fb5b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -207,7 +207,6 @@
 #define MAX_RETRANSMISSION          0x0f
 #define MAX_COLLISION_WINDOW        0x03ff
 
-
 #define TGEC_NUM_OF_PADDRS          1                   /* number of pattern match registers (entries) */
 
 #define GROUP_ADDRESS               0x0000010000000000LL /* Group address bit indication */
@@ -313,11 +312,9 @@
 #define TX_IPG_LENGTH_MASK          0x000003ff
 
 
-
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 /*
  * 10G memory map
@@ -352,46 +349,80 @@ typedef _Packed struct {
     volatile uint32_t   ievent;             /* 0x064 IEVENT - Interrupt event register */
     volatile uint32_t   udp_port;           /* 0x068 Defines a UDP Port number. When an UDP/IP frame is received with a matching UDP destination port, the receive status indication pin ff_rx_ts_frm will be asserted.*/
     volatile uint32_t   type_1588v2;        /* 0x06c Type field for 1588v2 layer 2 frames. IEEE1588 defines the type 0x88f7 for 1588 frames. */
-    volatile uint32_t   TENGEC_RESERVED4[4];
-/*10Ge Statistics Counter */
-    volatile uint64_t   TFRM;        /* 80 aFramesTransmittedOK */
-    volatile uint64_t   RFRM;        /* 88 aFramesReceivedOK */
-    volatile uint64_t   RFCS;        /* 90 aFrameCheckSequenceErrors */
-    volatile uint64_t   RALN;        /* 98 aAlignmentErrors */
-    volatile uint64_t   TXPF;        /* A0 aPAUSEMACCtrlFramesTransmitted */
-    volatile uint64_t   RXPF;        /* A8 aPAUSEMACCtrlFramesReceived */
-    volatile uint64_t   RLONG;       /* B0 aFrameTooLongErrors */
-    volatile uint64_t   RFLR;        /* B8 aInRangeLengthErrors */
-    volatile uint64_t   TVLAN;       /* C0 VLANTransmittedOK */
-    volatile uint64_t   RVLAN;       /* C8 VLANReceivedOK */
-    volatile uint64_t   TOCT;        /* D0 ifOutOctets */
-    volatile uint64_t   ROCT;        /* D8 ifInOctets */
-    volatile uint64_t   RUCA;        /* E0 ifInUcastPkts */
-    volatile uint64_t   RMCA;        /* E8 ifInMulticastPkts */
-    volatile uint64_t   RBCA;        /* F0 ifInBroadcastPkts */
-    volatile uint64_t   TERR;        /* F8 ifOutErrors */
-    volatile uint32_t   TENGEC_RESERVED6[2];
-    volatile uint64_t   TUCA;        /* 108 ifOutUcastPkts */
-    volatile uint64_t   TMCA;        /* 110 ifOutMulticastPkts */
-    volatile uint64_t   TBCA;        /* 118 ifOutBroadcastPkts */
-    volatile uint64_t   RDRP;        /* 120 etherStatsDropEvents */
-    volatile uint64_t   REOCT;       /* 128 etherStatsOctets */
-    volatile uint64_t   RPKT;        /* 130 etherStatsPkts */
-    volatile uint64_t   TRUND;       /* 138 etherStatsUndersizePkts */
-    volatile uint64_t   R64;         /* 140 etherStatsPkts64Octets */
-    volatile uint64_t   R127;        /* 148 etherStatsPkts65to127Octets */
-    volatile uint64_t   R255;        /* 150 etherStatsPkts128to255Octets */
-    volatile uint64_t   R511;        /* 158 etherStatsPkts256to511Octets */
-    volatile uint64_t   R1023;       /* 160 etherStatsPkts512to1023Octets */
-    volatile uint64_t   R1518;       /* 168 etherStatsPkts1024to1518Octets */
-    volatile uint64_t   R1519X;      /* 170 etherStatsPkts1519toX */
-    volatile uint64_t   TROVR;       /* 178 etherStatsOversizePkts */
-    volatile uint64_t   TRJBR;       /* 180 etherStatsJabbers */
-    volatile uint64_t   TRFRG;       /* 188 etherStatsFragments */
-    volatile uint64_t   RERR;        /* 190 ifInErrors */
+    volatile uint32_t   reserved1[4];       /* */
+
+    /*10Ge Statistics Counter */
+    volatile uint32_t   tfrm_u;      /* 80 aFramesTransmittedOK */
+    volatile uint32_t   tfrm_l;      /* 84 aFramesTransmittedOK */
+    volatile uint32_t   rfrm_u;      /* 88 aFramesReceivedOK */
+    volatile uint32_t   rfrm_l;      /* 8c aFramesReceivedOK */
+    volatile uint32_t   rfcs_u;      /* 90 aFrameCheckSequenceErrors */
+    volatile uint32_t   rfcs_l;      /* 94 aFrameCheckSequenceErrors */
+    volatile uint32_t   raln_u;      /* 98 aAlignmentErrors */
+    volatile uint32_t   raln_l;      /* 9c aAlignmentErrors */
+    volatile uint32_t   txpf_u;      /* A0 aPAUSEMACCtrlFramesTransmitted */
+    volatile uint32_t   txpf_l;      /* A4 aPAUSEMACCtrlFramesTransmitted */
+    volatile uint32_t   rxpf_u;      /* A8 aPAUSEMACCtrlFramesReceived */
+    volatile uint32_t   rxpf_l;      /* Ac aPAUSEMACCtrlFramesReceived */
+    volatile uint32_t   rlong_u;     /* B0 aFrameTooLongErrors */
+    volatile uint32_t   rlong_l;     /* B4 aFrameTooLongErrors */
+    volatile uint32_t   rflr_u;      /* B8 aInRangeLengthErrors */
+    volatile uint32_t   rflr_l;      /* Bc aInRangeLengthErrors */
+    volatile uint32_t   tvlan_u;     /* C0 VLANTransmittedOK */
+    volatile uint32_t   tvlan_l;     /* C4 VLANTransmittedOK */
+    volatile uint32_t   rvlan_u;     /* C8 VLANReceivedOK */
+    volatile uint32_t   rvlan_l;     /* Cc VLANReceivedOK */
+    volatile uint32_t   toct_u;      /* D0 ifOutOctets */
+    volatile uint32_t   toct_l;      /* D4 ifOutOctets */
+    volatile uint32_t   roct_u;      /* D8 ifInOctets */
+    volatile uint32_t   roct_l;      /* Dc ifInOctets */
+    volatile uint32_t   ruca_u;      /* E0 ifInUcastPkts */
+    volatile uint32_t   ruca_l;      /* E4 ifInUcastPkts */
+    volatile uint32_t   rmca_u;      /* E8 ifInMulticastPkts */
+    volatile uint32_t   rmca_l;      /* Ec ifInMulticastPkts */
+    volatile uint32_t   rbca_u;      /* F0 ifInBroadcastPkts */
+    volatile uint32_t   rbca_l;      /* F4 ifInBroadcastPkts */
+    volatile uint32_t   terr_u;      /* F8 ifOutErrors */
+    volatile uint32_t   terr_l;      /* Fc ifOutErrors */
+    volatile uint32_t   reserved2[2];/* 100-108*/
+    volatile uint32_t   tuca_u;      /* 108 ifOutUcastPkts */
+    volatile uint32_t   tuca_l;      /* 10c ifOutUcastPkts */
+    volatile uint32_t   tmca_u;      /* 110 ifOutMulticastPkts */
+    volatile uint32_t   tmca_l;      /* 114 ifOutMulticastPkts */
+    volatile uint32_t   tbca_u;      /* 118 ifOutBroadcastPkts */
+    volatile uint32_t   tbca_l;      /* 11c ifOutBroadcastPkts */
+    volatile uint32_t   rdrp_u;      /* 120 etherStatsDropEvents */
+    volatile uint32_t   rdrp_l;      /* 124 etherStatsDropEvents */
+    volatile uint32_t   reoct_u;     /* 128 etherStatsOctets */
+    volatile uint32_t   reoct_l;     /* 12c etherStatsOctets */
+    volatile uint32_t   rpkt_u;      /* 130 etherStatsPkts */
+    volatile uint32_t   rpkt_l;      /* 134 etherStatsPkts */
+    volatile uint32_t   trund_u;     /* 138 etherStatsUndersizePkts */
+    volatile uint32_t   trund_l;     /* 13c etherStatsUndersizePkts */
+    volatile uint32_t   r64_u;       /* 140 etherStatsPkts64Octets */
+    volatile uint32_t   r64_l;       /* 144 etherStatsPkts64Octets */
+    volatile uint32_t   r127_u;      /* 148 etherStatsPkts65to127Octets */
+    volatile uint32_t   r127_l;      /* 14c etherStatsPkts65to127Octets */
+    volatile uint32_t   r255_u;      /* 150 etherStatsPkts128to255Octets */
+    volatile uint32_t   r255_l;      /* 154 etherStatsPkts128to255Octets */
+    volatile uint32_t   r511_u;      /* 158 etherStatsPkts256to511Octets */
+    volatile uint32_t   r511_l;      /* 15c etherStatsPkts256to511Octets */
+    volatile uint32_t   r1023_u;     /* 160 etherStatsPkts512to1023Octets */
+    volatile uint32_t   r1023_l;     /* 164 etherStatsPkts512to1023Octets */
+    volatile uint32_t   r1518_u;     /* 168 etherStatsPkts1024to1518Octets */
+    volatile uint32_t   r1518_l;     /* 16c etherStatsPkts1024to1518Octets */
+    volatile uint32_t   r1519x_u;    /* 170 etherStatsPkts1519toX */
+    volatile uint32_t   r1519x_l;    /* 174 etherStatsPkts1519toX */
+    volatile uint32_t   trovr_u;     /* 178 etherStatsOversizePkts */
+    volatile uint32_t   trovr_l;     /* 17c etherStatsOversizePkts */
+    volatile uint32_t   trjbr_u;     /* 180 etherStatsJabbers */
+    volatile uint32_t   trjbr_l;     /* 184 etherStatsJabbers */
+    volatile uint32_t   trfrg_u;     /* 188 etherStatsFragments */
+    volatile uint32_t   trfrg_l;     /* 18C etherStatsFragments */
+    volatile uint32_t   rerr_u;      /* 190 ifInErrors */
+    volatile uint32_t   rerr_l;      /* 194 ifInErrors */
 } _PackedType t_TgecMemMap;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
index 229048f..6ab50ab 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
index dfa2e6f..1de0f99 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -59,7 +59,6 @@
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 /*----------------------------------------------------*/
 /* MII Configuration Control Memory Map Registers     */
@@ -72,7 +71,6 @@ typedef _Packed struct t_TgecMiiAccessMemMap
     volatile uint32_t   mdio_regaddr;       /* 0x03c  */
 } _PackedType t_TgecMiiAccessMemMap ;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Makefile
index 49e9d1c..4dd81ad 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Makefile
@@ -16,6 +16,7 @@ fsl-ncsw-PFM1-objs	:=   fm.o fm_muram.o
 
 obj-y		+= MAC/
 obj-y		+= Pcd/
+obj-y           += SP/
 obj-y		+= Port/
 obj-y		+= HC/
 obj-y		+= Rtc/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
index f24a53c..e1f6f59 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index c9cf60a..ea7c904 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -33,7 +33,7 @@
 /******************************************************************************
  @File          fm_cc.c
 
- @Description   FM CC ...
+ @Description   FM Coarse Classifier implementation
 *//***************************************************************************/
 #include "std_ext.h"
 #include "error_ext.h"
@@ -48,127 +48,147 @@
 #include "crc64.h"
 
 
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
-#define FM_PCD_CC_MANIP
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+/****************************************/
+/*       static functions               */
+/****************************************/
 
-
-t_Handle   FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree, uint8_t manipIndx)
-{
-    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
-
-    ASSERT_COND(p_FmPcdCcTree);
-
-    return p_FmPcdCcTree->fmPcdCcSavedManipParams[manipIndx];
-}
-
-void   FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams, uint8_t   manipIndx)
+static uint32_t FmPcdCcTreeLock(t_Handle h_FmPcdCcTree)
 {
-    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
-
-    ASSERT_COND(p_FmPcdCcTree);
-
-    p_FmPcdCcTree->fmPcdCcSavedManipParams[manipIndx] = h_SavedManipParams;
+    ASSERT_COND(h_FmPcdCcTree);
+    return XX_LockIntrSpinlock(((t_FmPcdCcTree*)h_FmPcdCcTree)->h_Spinlock);
 }
 
-uint8_t FmPcdCcGetParseCode(t_Handle h_CcNode)
+static void FmPcdCcTreeUnlock(t_Handle h_FmPcdCcTree, uint32_t intFlags)
 {
-    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
-
-    ASSERT_COND(p_FmPcdCcNode);
-    return p_FmPcdCcNode->parseCode;
+    ASSERT_COND(h_FmPcdCcTree);
+    XX_UnlockIntrSpinlock(((t_FmPcdCcTree*)h_FmPcdCcTree)->h_Spinlock, intFlags);
 }
 
-uint8_t FmPcdCcGetOffset(t_Handle h_CcNode)
+static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
 {
-    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+    ASSERT_COND(p_CcNode);
 
-    ASSERT_COND(p_FmPcdCcNode);
-    return p_FmPcdCcNode->offset;
+    if(add)
+        p_CcNode->owners++;
+    else
+    {
+        ASSERT_COND(p_CcNode->owners);
+        p_CcNode->owners--;
+    }
 }
 
-uint16_t FmPcdCcGetNumOfKeys(t_Handle h_CcNode)
-{
-    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
-
-    ASSERT_COND(p_FmPcdCcNode);
-    return p_FmPcdCcNode->numOfKeys;
-}
-static void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo)
+static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_CcNode, t_Handle h_Manip, t_Handle h_FrmReplic)
 {
-    t_CcNodeInformation *p_CcInformation;
-    uint32_t            intFlags;
+    t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_CcNode;
+    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)p_Ad;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t                tmpReg32;
+    t_Handle                p_AdNewPtr = NULL;
 
-    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(sizeof(t_CcNodeInformation));
-    if (p_CcInformation)
-    {
-        memset(p_CcInformation, 0, sizeof(t_CcNodeInformation));
-        memcpy(p_CcInformation, p_CcInfo, sizeof(t_CcNodeInformation));
-        INIT_LIST(&p_CcInformation->node);
+    UNUSED(h_Manip);
+    UNUSED(h_FrmReplic);
+
+    /* there are 3 cases handled in this routine of building a "Continue lookup" type AD.
+     * Case 1: No Manip. The action descriptor is built within the match table.
+     *         p_AdResult = p_AdNewPtr;
+     * Case 2: Manip exists. A new AD is created - p_AdNewPtr. It is initialized
+     *         either in the FmPcdManipUpdateAdResultForCc routine or it was already
+     *         initialized and returned here.
+     *         p_AdResult (within the match table) will be initialized after
+     *         this routine returns and point to the existing AD.
+     * Case 3: Manip exists. The action descriptor is built within the match table.
+     *         FmPcdManipUpdateAdContLookupForCc returns a NULL p_AdNewPtr.
+     */
+
+    /* As default, the "new" ptr is the current one. i.e. the content of the result
+     * AD will be written into the match table itself (case (1))*/
+    p_AdNewPtr = p_AdContLookup;
 
-        intFlags = XX_DisableAllIntr();
-        LIST_AddToTail(&p_CcInformation->node, p_List);
-        XX_RestoreAllIntr(intFlags);
-    }
+#if DPAA_VERSION >= 3
+    if (h_Manip && h_FrmReplic)
+        FmPcdManipUpdateAdContLookupForCc(h_Manip,
+                                          p_Ad,
+                                          &p_AdNewPtr,
+                                          (uint32_t)((XX_VirtToPhys(FrmReplicGetSourceTableDescriptor(h_FrmReplic)) - p_FmPcd->physicalMuramBase)));
+    else if (h_FrmReplic)
+        FrmReplicUpdateAdContLookupForCc(h_FrmReplic, p_Ad, &p_AdNewPtr);
     else
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Node Information"));
-}
+#endif /* DPAA_VERSION >= 3 */
+    if (h_Manip)
+        FmPcdManipUpdateAdContLookupForCc(h_Manip,
+                                          p_Ad,
+                                          &p_AdNewPtr,
+
+#ifdef FM_CAPWAP_SUPPORT
+                                          /*no check for opcode of manip - this step can be reached only with capwap_applic_specific*/
+                                          (uint32_t)((XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase))
+#else  /* not FM_CAPWAP_SUPPORT */
+                                          (uint32_t)((XX_VirtToPhys(p_Node->h_Ad) - p_FmPcd->physicalMuramBase))
+#endif /* not FM_CAPWAP_SUPPORT */
+                                          );
+
+    /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
+    if(p_AdNewPtr)
+    {
+        /* cases (1) & (2) */
+        tmpReg32 = 0;
+        tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+        tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase);
+        WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
 
+        tmpReg32 = 0;
+        tmpReg32 |= p_Node->numOfKeys << 24;
+        tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
+        tmpReg32 |= p_Node->h_KeysMatchTable ?
+                        (uint32_t)(XX_VirtToPhys(p_Node->h_KeysMatchTable) - p_FmPcd->physicalMuramBase) : 0;
+        WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
 
-static t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info)
-{
-    t_CcNodeInformation *p_CcInformation;
-    t_List *p_Pos;
-    uint32_t            intFlags;
+        tmpReg32 = 0;
+        tmpReg32 |= p_Node->prsArrayOffset << 24;
+        tmpReg32 |= p_Node->offset << 16;
+        tmpReg32 |= p_Node->parseCode;
+        WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
 
-    intFlags = XX_DisableAllIntr();
-    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
-    {
-        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
-        ASSERT_COND(p_CcInformation->h_CcNode);
-        if(p_CcInformation->h_CcNode == h_Info)
-        {
-            XX_RestoreAllIntr(intFlags);
-            return p_CcInformation;
-        }
+        Mem2IOCpy32((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask, CC_GLBL_MASK_SIZE);
     }
-    XX_RestoreAllIntr(intFlags);
-    return NULL;
 }
 
-static void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info)
+static t_Error FmPcdCcAllocAndFillAdForContLookupManip(t_Handle h_CcNode)
 {
-    t_CcNodeInformation *p_CcInformation = NULL;
-    uint32_t            intFlags;
-    t_List              *p_Pos;
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
 
-    intFlags = XX_DisableAllIntr();
-    if (LIST_IsEmpty(p_List))
-    {
-        XX_RestoreAllIntr(intFlags);
-        return;
-    }
+    ASSERT_COND(p_CcNode);
 
-    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    if(!p_CcNode->h_Ad)
     {
-        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
-        ASSERT_COND(p_CcInformation->h_CcNode);
-        if (p_CcInformation->h_CcNode == h_Info)
-            break;
+        p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram,
+                                           FM_PCD_CC_AD_ENTRY_SIZE,
+                                           FM_PCD_CC_AD_TABLE_ALIGN);
+        if(!p_CcNode->h_Ad)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
+
+        IOMemSet32(p_CcNode->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        FillAdOfTypeContLookup(p_CcNode->h_Ad,
+                               p_CcNode->h_FmPcd,
+                               p_CcNode,
+                               NULL,
+                               NULL);
     }
-    if (p_CcInformation)
-        LIST_DelAndInit(&p_CcInformation->node);
-    XX_RestoreAllIntr(intFlags);
+    return E_OK;
 }
 
-static t_Error FmPcdCcSetRequiredAction(t_Handle h_FmPcd, uint32_t requiredAction, t_FmPcdCcNextEngineAndRequiredActionParams *p_CcNextEngineParamsTmp,
-                                        t_Handle h_AdTmp, uint16_t numOfEntries, t_Handle h_Tree)
+static t_Error FmPcdCcSetRequiredAction(t_Handle    h_FmPcd,
+                                        uint32_t    requiredAction,
+                                        t_FmPcdCcKeyAndNextEngineParams *p_CcKeyAndNextEngineParamsTmp,
+                                        t_Handle    h_AdTmp,
+                                        uint16_t    numOfEntries,
+                                        t_Handle    h_Tree)
 {
-
     t_AdOfTypeResult    *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
     uint32_t            tmpReg32;
     t_Error             err;
-    t_FmPcdCcNode       *p_FmPcdCcNode;
+    t_FmPcdCcNode       *p_CcNode;
     int                 i = 0;
     uint16_t            tmp = 0;
     uint16_t            profileId;
@@ -182,89 +202,91 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle h_FmPcd, uint32_t requiredActio
         else
             h_AdTmp = PTR_MOVE(h_AdTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        switch(p_CcNextEngineParamsTmp[i].nextEngineParams.nextEngine)
+        if(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & requiredAction)
+            continue;
+        switch(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.nextEngine)
         {
             case(e_FM_PCD_CC):
                 if(requiredAction)
                 {
-                    p_FmPcdCcNode = p_CcNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
-                    ASSERT_COND(p_FmPcdCcNode);
-                    if(p_FmPcdCcNode->shadowAction == requiredAction)
+                    p_CcNode = p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
+                    ASSERT_COND(p_CcNode);
+                    if(p_CcNode->shadowAction == requiredAction)
                         break;
-                    if((requiredAction & UPDATE_CC_WITH_TREE) && !(p_FmPcdCcNode->shadowAction & UPDATE_CC_WITH_TREE))
+                    if((requiredAction & UPDATE_CC_WITH_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
                     {
 
-                        ASSERT_COND(LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) == 0);
-                        if(p_FmPcdCcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE)
-                            p_FmPcdCcNode->shadowAction &= ~UPDATE_CC_WITH_DELETE_TREE;
+                        ASSERT_COND(LIST_NumOfObjs(&p_CcNode->ccTreesLst) == 0);
+                        if(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE)
+                            p_CcNode->shadowAction &= ~UPDATE_CC_WITH_DELETE_TREE;
                         memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                         ccNodeInfo.h_CcNode = h_Tree;
-                        EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNode->ccTreesLst, &ccNodeInfo);
-                        p_CcNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_TREE;
+                        EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst, &ccNodeInfo);
+                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_TREE;
                     }
-                    if((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_FmPcdCcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
+                    if((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
                     {
-                        ASSERT_COND(LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) == 1);
-                        if(p_FmPcdCcNode->shadowAction & UPDATE_CC_WITH_TREE)
-                            p_FmPcdCcNode->shadowAction &= ~UPDATE_CC_WITH_TREE;
-                        DequeueNodeInfoFromRelevantLst(&p_FmPcdCcNode->ccTreesLst, h_Tree);
-                        p_CcNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_DELETE_TREE;
+                        ASSERT_COND(LIST_NumOfObjs(&p_CcNode->ccTreesLst) == 1);
+                        if(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE)
+                            p_CcNode->shadowAction &= ~UPDATE_CC_WITH_TREE;
+                        FmPcdCcDequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst, h_Tree);
+                        p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_DELETE_TREE;
                     }
-                    if(p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
-                        tmp  = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
+                    if(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
+                        tmp  = (uint8_t)(p_CcNode->numOfKeys + 1);
                     else
-                        tmp = p_FmPcdCcNode->numOfKeys;
-                    err = FmPcdCcSetRequiredAction(h_FmPcd, requiredAction, p_FmPcdCcNode->nextEngineAndRequiredAction, p_FmPcdCcNode->h_AdTable, tmp, h_Tree);
+                        tmp = p_CcNode->numOfKeys;
+                    err = FmPcdCcSetRequiredAction(h_FmPcd, requiredAction, p_CcNode->keyAndNextEngineParams, p_CcNode->h_AdTable, tmp, h_Tree);
                     if(err != E_OK)
                         return err;
-                    p_FmPcdCcNode->shadowAction |= requiredAction;
+                    p_CcNode->shadowAction |= requiredAction;
                 }
                 break;
 
             case(e_FM_PCD_KG):
-                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
-                    physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_CcNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme)-1);
+                    physicalSchemeId = FmPcdKgGetSchemeId(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme);
                     relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, physicalSchemeId);
                     if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-                    if (!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+                    if (!FmPcdKgIsSchemeValidSw(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme))
                          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
                     if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this action scheme has to be direct."));
-                    err = FmPcdKgCcGetSetParams(h_FmPcd, p_CcNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme, requiredAction);
+                    err = FmPcdKgCcGetSetParams(h_FmPcd, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme, requiredAction, 0);
                     if(err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
-                    p_CcNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
                 }
                 break;
 
             case(e_FM_PCD_PLCR):
-                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
-                    if(!p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
-                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this intialization only overrideFqid can be intiizliaes"));
-                    if(!p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
-                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this intialization only overrideFqid can be intiizliaes"));
-                    err =  FmPcdPlcrGetAbsoluteProfileId(h_FmPcd, e_FM_PCD_PLCR_SHARED, NULL, p_CcNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
+                    if(!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
+                    if(!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
+                    err =  FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd, e_FM_PCD_PLCR_SHARED, NULL, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
                     if(err!= E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId, requiredAction);
                     if(err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
-                    p_CcNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
                 }
                 break;
 
             case(e_FM_PCD_DONE):
-                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     tmpReg32 = GET_UINT32(p_AdTmp->nia);
-                    if((tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine was previosely assigned not as PCD_DONE"));
+                    if((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)) != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine was previously assigned not as PCD_DONE"));
                     tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
                     WRITE_UINT32(p_AdTmp->nia, tmpReg32);
-                    p_CcNextEngineParamsTmp[i].shadowAction |= requiredAction;
+                    p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
                 }
                 break;
 
@@ -276,164 +298,590 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle h_FmPcd, uint32_t requiredActio
      return E_OK;
 }
 
-static t_Error CcUpdateParam(t_Handle                                   h_FmPcd,
-                             t_Handle                                   h_PcdParams,
-                             t_Handle                                   h_FmPort,
-                             t_FmPcdCcNextEngineAndRequiredActionParams *p_CcNextEngineParams,
-                             uint16_t                                   numOfEntries,
-                             t_Handle                                   h_Ad,
-                             bool                                       validate,
-                             uint16_t                                   level,
-                             t_Handle                                   h_FmTree,
-                             bool                                       modify)
+static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle                            h_FmPcd,
+                                                   t_List                              *h_FmPcdOldPointersLst,
+                                                   t_List                              *h_FmPcdNewPointersLst,
+                                                   uint16_t                            numOfGoodChanges,
+                                                   t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalParams,
+                                                   bool                                useShadowStructs)
 {
-    t_FmPcdCcNode       *p_FmPcdCcNode;
-    t_Error             err;
-    uint16_t            tmp = 0;
-    int                 i = 0;
-#ifdef FM_PCD_CC_MANIP
-    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
-#endif /* FM_PCD_CC_MANIP */
+    t_List                          *p_Pos;
+    t_Error                         err = E_OK;
+    t_CcNodeInformation             ccNodeInfo, *p_CcNodeInformation;
+    t_Handle                        h_Muram;
+    t_FmPcdCcNode                   *p_FmPcdCcNextNode;
+    t_List                          *p_UpdateLst;
 
-    level++;
+    UNUSED(numOfGoodChanges);
 
-#ifdef FM_PCD_CC_MANIP
-    if(p_CcTree->h_IpReassemblyManip)
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_AdditionalParams->h_CurrentNode,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointersLst,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdOldPointersLst)),E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((1 == LIST_NumOfObjs(h_FmPcdNewPointersLst)),E_INVALID_STATE);
+
+    /* We don't update subtree of the new node with new tree because it was done in the previous stage */
+    if (p_AdditionalParams->h_NodeForAdd)
     {
-        err = FmPcdManipUpdate(h_FmPcd, h_PcdParams, h_FmPort, p_CcTree->h_IpReassemblyManip, h_Ad, validate, level, h_FmTree, modify);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_AdditionalParams->h_NodeForAdd;
+
+        if (!p_AdditionalParams->tree)
+            p_UpdateLst = &p_FmPcdCcNextNode->ccPrevNodesLst;
+        else
+            p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
+
+        p_CcNodeInformation = FmPcdCcFindNodeInfoInReleventLst(p_UpdateLst, p_AdditionalParams->h_CurrentNode);
+
+        if (p_CcNodeInformation)
+            p_CcNodeInformation->index++;
+        else
+        {
+            memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+            ccNodeInfo.h_CcNode = (t_Handle)p_AdditionalParams->h_CurrentNode;
+            ccNodeInfo.index = 1;
+            EnqueueNodeInfoToRelevantLst(p_UpdateLst, &ccNodeInfo);
+        }
     }
-#endif /* FM_PCD_CC_MANIP */
 
-    if(numOfEntries)
+    if (p_AdditionalParams->h_NodeForRmv)
     {
-        for(i = 0; i < numOfEntries; i++)
+        p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_AdditionalParams->h_NodeForRmv;
+
+        if (!p_AdditionalParams->tree)
         {
-            if(i == 0)
-                h_Ad = PTR_MOVE(h_Ad, i*FM_PCD_CC_AD_ENTRY_SIZE);
-            else
-                h_Ad = PTR_MOVE(h_Ad, FM_PCD_CC_AD_ENTRY_SIZE);
+            p_UpdateLst = &p_FmPcdCcNextNode->ccPrevNodesLst;
 
-            if(p_CcNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            while (!LIST_IsEmpty(&p_FmPcdCcNextNode->ccTreesLst))
             {
-                p_FmPcdCcNode = p_CcNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
-                ASSERT_COND(p_FmPcdCcNode);
-#ifdef FM_PCD_CC_MANIP
-                if(p_CcNextEngineParams[i].nextEngineParams.h_Manip)
-                {
-                    err = FmPcdManipUpdate(h_FmPcd, NULL, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate, level, h_FmTree, modify);
-                    if(err)
-                        RETURN_ERROR(MAJOR, err, NO_MSG);
-                }
-#endif /* FM_PCD_CC_MANIP */
+                p_Pos = LIST_NEXT(&p_FmPcdCcNextNode->ccTreesLst);
+                p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
 
-                if(p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
-                    tmp  = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
-                else
-                    tmp = p_FmPcdCcNode->numOfKeys;
+                ASSERT_COND(p_CcNodeInformation->h_CcNode);
 
-                err = CcUpdateParam(h_FmPcd, h_PcdParams, h_FmPort, p_FmPcdCcNode->nextEngineAndRequiredAction, tmp, p_FmPcdCcNode->h_AdTable, validate, level, h_FmTree, modify);
-                if(err)
-                    RETURN_ERROR(MAJOR, err, NO_MSG);
-            }
-#ifdef FM_PCD_CC_MANIP
-            else
-            {
-                if(p_CcNextEngineParams[i].nextEngineParams.h_Manip)
-                {
-                    err = FmPcdManipUpdate(h_FmPcd, NULL, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate, level, h_FmTree, modify);
-                    if(err)
-                        RETURN_ERROR(MAJOR, err, NO_MSG);
-                }
+                err = FmPcdCcSetRequiredAction(h_FmPcd,
+                                               UPDATE_CC_WITH_DELETE_TREE,
+                                               &((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
+                                               PTR_MOVE(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable, p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                               1,
+                                               p_CcNodeInformation->h_CcNode);
             }
-#endif /* FM_PCD_CC_MANIP */
-          }
-    }
+        }
+        else
+        {
+            p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
 
-    return E_OK;
-}
-static bool IsNodeInModifiedState(t_Handle h_CcNode)
-{
-    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+            err = FmPcdCcSetRequiredAction(h_FmPcd,
+                                           UPDATE_CC_WITH_DELETE_TREE,
+                                           &((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
+                                           UINT_TO_PTR(((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->ccTreeBaseAddr + p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                           1,
+                                           p_AdditionalParams->h_CurrentNode);
+        }
+        if (err)
+            return err;
 
-    ASSERT_COND(p_CcNode);
+        /* We remove from the subtree of the removed node tree because it wasn't done in the previous stage
+           Update ccPrevNodesLst or ccTreeIdLst of the removed node
+           Update of the node owner */
+        p_CcNodeInformation = FmPcdCcFindNodeInfoInReleventLst(p_UpdateLst, p_AdditionalParams->h_CurrentNode);
 
-    return p_CcNode->modifiedState;
-}
+        ASSERT_COND(p_CcNodeInformation);
+        ASSERT_COND(p_CcNodeInformation->index);
 
-static void UpdateNodeWithModifiedState(t_Handle h_CcNode, bool modifiedState)
-{
-    t_FmPcdCcNode *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+        p_CcNodeInformation->index--;
 
-    ASSERT_COND(p_FmPcdCcNode);
+        if (p_CcNodeInformation->index == 0)
+           FmPcdCcDequeueNodeInfoFromRelevantLst(p_UpdateLst,p_AdditionalParams->h_CurrentNode);
 
-    p_FmPcdCcNode->modifiedState = modifiedState;
-}
+        UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
+    }
 
-static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
-{
-    switch (p_CcNodeParam->extractCcParams.extractNonHdr.action)
+    if (p_AdditionalParams->h_ManipForRmv)
+        FmPcdManipUpdateOwner(p_AdditionalParams->h_ManipForRmv, FALSE);
+
+#if DPAA_VERSION >= 3
+    if (p_AdditionalParams->h_FrmReplicForRmv)
     {
-        case(e_FM_PCD_ACTION_EXACT_MATCH):
-            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
-            {
-                case(e_FM_PCD_EXTRACT_FROM_KEY):
-                    return CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH;
-                case(e_FM_PCD_EXTRACT_FROM_HASH):
-                    return CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH;
-                default:
-                    return CC_PRIVATE_INFO_NONE;
-            }
-        case(e_FM_PCD_ACTION_INDEXED_LOOKUP):
-            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
-            {
-                case(e_FM_PCD_EXTRACT_FROM_HASH):
-                    return CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP;
-                case(e_FM_PCD_EXTRACT_FROM_FLOW_ID):
-                    return CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP;
-                default:
-                  return  CC_PRIVATE_INFO_NONE;
-            }
-       default:
-           break;
+        FrmReplicUpdateGroupOwner(p_AdditionalParams->h_FrmReplicForRmv,
+                               FALSE,
+                               TRUE,  /* fullUpdate */
+                               p_AdditionalParams->h_NodeForRmv);
     }
-    return CC_PRIVATE_INFO_NONE;
-}
+#endif /* DPAA_VERSION >= 3 */
 
-static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List)
-{
-    t_CcNodeInformation   *p_CcNodeInfo = NULL;
-    uint32_t        intFlags;
+    if (!useShadowStructs)
+    {
+        h_Muram = FmPcdGetMuramHandle(h_FmPcd);
+        ASSERT_COND(h_Muram);
 
-    intFlags = XX_DisableAllIntr();
-    if (!LIST_IsEmpty(p_List))
+        /* We release new AD which was allocated and updated for copy from to actual AD */
+        p_Pos = LIST_FIRST(h_FmPcdNewPointersLst);
+        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcNodeInformation->h_CcNode);
+        FM_MURAM_FreeMem(h_Muram, p_CcNodeInformation->h_CcNode);
+
+        /* Free Old data structure if it has to be freed - new data structure was allocated*/
+        if (p_AdditionalParams->p_AdTableOld)
+            FM_MURAM_FreeMem(h_Muram,p_AdditionalParams->p_AdTableOld);
+
+        if (p_AdditionalParams->p_KeysMatchTableOld)
+            FM_MURAM_FreeMem(h_Muram,p_AdditionalParams->p_KeysMatchTableOld);
+    }
+
+    /* Update current modified node with changed fields if it's required*/
+    if (!p_AdditionalParams->tree)
     {
-        p_CcNodeInfo = CC_NODE_F_OBJECT(p_List->p_Next);
-        LIST_DelAndInit(&p_CcNodeInfo->node);
+        if (p_AdditionalParams->p_AdTableNew)
+            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable = p_AdditionalParams->p_AdTableNew;
+
+        if (p_AdditionalParams->numOfKeys)
+            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->numOfKeys = p_AdditionalParams->numOfKeys;
+
+        if (p_AdditionalParams->p_KeysMatchTableNew)
+            ((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_KeysMatchTable = p_AdditionalParams->p_KeysMatchTableNew;
+
+        memcpy(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
+                &p_AdditionalParams->keyAndNextEngineParams,
+                sizeof(t_FmPcdCcKeyAndNextEngineParams) * (FM_PCD_MAX_NUM_OF_KEYS));
     }
-    XX_RestoreAllIntr(intFlags);
-    return p_CcNodeInfo;
+    else
+        memcpy(&((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams,
+               &p_AdditionalParams->keyAndNextEngineParams,
+               sizeof(t_FmPcdCcKeyAndNextEngineParams) * (((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->numOfEntries));
+
+    ReleaseLst(h_FmPcdOldPointersLst);
+    ReleaseLst(h_FmPcdNewPointersLst);
+
+    XX_Free(p_AdditionalParams);
+
+    return E_OK;
 }
 
-static void ReleaseLst(t_List *p_List)
+static t_Handle BuildNewAd(t_Handle                             h_Ad,
+                           t_FmPcdModifyCcKeyAdditionalParams   *p_FmPcdModifyCcKeyAdditionalParams,
+                           t_FmPcdCcNode                        *p_CcNode,
+                           t_FmPcdCcNextEngineParams            *p_FmPcdCcNextEngineParams)
 {
-    t_CcNodeInformation   *p_CcNodeInfo = NULL;
+    t_FmPcdCcNode   *p_FmPcdCcNodeTmp;
 
-    if(!LIST_IsEmpty(p_List))
+    p_FmPcdCcNodeTmp = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
+    if(!p_FmPcdCcNodeTmp)
     {
-        p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
-        while (p_CcNodeInfo)
-        {
-            XX_Free(p_CcNodeInfo);
-            p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
-        }
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcNodeTmp"));
+        return NULL;
     }
-    LIST_DelAndInit(p_List);
-}
+    memset(p_FmPcdCcNodeTmp, 0, sizeof(t_FmPcdCcNode));
 
-void FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree)
-{
+    p_FmPcdCcNodeTmp->numOfKeys        = p_FmPcdModifyCcKeyAdditionalParams->numOfKeys;
+    p_FmPcdCcNodeTmp->h_KeysMatchTable = p_FmPcdModifyCcKeyAdditionalParams->p_KeysMatchTableNew;
+    p_FmPcdCcNodeTmp->h_AdTable        = p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
+
+    p_FmPcdCcNodeTmp->lclMask                = p_CcNode->lclMask;
+    p_FmPcdCcNodeTmp->parseCode              = p_CcNode->parseCode;
+    p_FmPcdCcNodeTmp->offset                 = p_CcNode->offset;
+    p_FmPcdCcNodeTmp->prsArrayOffset         = p_CcNode->prsArrayOffset;
+    p_FmPcdCcNodeTmp->ctrlFlow               = p_CcNode->ctrlFlow;
+    p_FmPcdCcNodeTmp->ccKeySizeAccExtraction = p_CcNode->ccKeySizeAccExtraction;
+    p_FmPcdCcNodeTmp->sizeOfExtraction       = p_CcNode->sizeOfExtraction;
+    p_FmPcdCcNodeTmp->glblMaskSize           = p_CcNode->glblMaskSize;
+    p_FmPcdCcNodeTmp->p_GlblMask             = p_CcNode->p_GlblMask;
+
+    if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC)
+    {
+        if (p_FmPcdCcNextEngineParams->h_Manip)
+        {
+            if(FmPcdCcAllocAndFillAdForContLookupManip(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)!= E_OK)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+                return NULL;
+            }
+        }
+        FillAdOfTypeContLookup(h_Ad,
+                               p_CcNode->h_FmPcd,
+                               p_FmPcdCcNodeTmp,
+                               p_FmPcdCcNextEngineParams->h_Manip,
+                               NULL);
+    }
+
+#if DPAA_VERSION >= 3
+    if ((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_FR) &&
+        (p_FmPcdCcNextEngineParams->params.h_FrmReplic))
+    {
+        FillAdOfTypeContLookup(h_Ad,
+                               p_CcNode->h_FmPcd,
+                               p_FmPcdCcNodeTmp,
+                               p_FmPcdCcNextEngineParams->h_Manip,
+                               p_FmPcdCcNextEngineParams->params.h_FrmReplic);
+    }
+#endif /* DPAA_VERSION >= 3 */
+
+    XX_Free(p_FmPcdCcNodeTmp);
+
+    return E_OK;
+}
+
+static t_Error DynamicChangeHc(t_Handle                             h_FmPcd,
+                               t_List                               *h_OldPointersLst,
+                               t_List                               *h_NewPointersLst,
+                               t_FmPcdModifyCcKeyAdditionalParams   *p_AdditionalParams,
+                               bool                                 useShadowStructs)
+{
+    t_List      *p_PosOld, *p_PosNew;
+    uint32_t    oldAdAddrOffset, newAdAddrOffset;
+    uint16_t    i = 0;
+    t_Error     err = E_OK;
+    uint8_t     numOfModifiedPtr;
+
+    ASSERT_COND(h_FmPcd);
+    ASSERT_COND(h_OldPointersLst);
+    ASSERT_COND(h_NewPointersLst);
+
+    numOfModifiedPtr = (uint8_t)LIST_NumOfObjs(h_OldPointersLst);
+
+    p_PosNew = LIST_FIRST(h_NewPointersLst);
+    p_PosOld = LIST_FIRST(h_OldPointersLst);
+
+    /* Retrieve address of new AD */
+    newAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd, p_PosNew);
+    if (newAdAddrOffset == (uint32_t)ILLEGAL_BASE)
+    {
+        FmPcdCcReleaseModifiedDataStructure(h_FmPcd,
+                                            h_OldPointersLst,
+                                            h_NewPointersLst,
+                                            0,
+                                            p_AdditionalParams,
+                                            useShadowStructs);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("New AD address"));
+    }
+
+    for (i = 0; i < numOfModifiedPtr; i++)
+    {
+        /* Retrieve address of current AD */
+        oldAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd, p_PosOld);
+        if (oldAdAddrOffset == (uint32_t)ILLEGAL_BASE)
+        {
+            FmPcdCcReleaseModifiedDataStructure(h_FmPcd,
+                                                h_OldPointersLst,
+                                                h_NewPointersLst,
+                                                i,
+                                                p_AdditionalParams,
+                                                useShadowStructs);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old AD address"));
+        }
+
+        /* Invoke host command to copy from new AD to old AD */
+        err = FmHcPcdCcDoDynamicChange(((t_FmPcd *)h_FmPcd)->h_Hc, oldAdAddrOffset, newAdAddrOffset);
+        if (err)
+        {
+            FmPcdCcReleaseModifiedDataStructure(h_FmPcd,
+                                                h_OldPointersLst,
+                                                h_NewPointersLst,
+                                                i,
+                                                p_AdditionalParams,
+                                                useShadowStructs);
+            RETURN_ERROR(MAJOR, err, ("For part of nodes changes are done - situation is danger"));
+        }
+
+        p_PosOld = LIST_NEXT(p_PosOld);
+    }
+
+    return E_OK;
+}
+
+static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
+                               t_List                               *h_OldPointersLst,
+                               t_List                               *h_NewPointersLst,
+                               t_FmPcdModifyCcKeyAdditionalParams   *p_AdditionalParams,
+                               bool                                 useShadowStructs)
+{
+    t_FmPcdCcNode               *p_CcNode = (t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode);
+    t_List                      *p_PosNew;
+    t_CcNodeInformation         *p_CcNodeInfo;
+    t_FmPcdCcNextEngineParams   nextEngineParams;
+    t_Handle                    h_Ad;
+    uint32_t                    keySize;
+
+    t_Error     err = E_OK;
+    uint8_t     numOfModifiedPtr;
+
+    ASSERT_COND(h_FmPcd);
+
+    SANITY_CHECK_RETURN_ERROR((LIST_NumOfObjs(h_OldPointersLst) >= 1),E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR((LIST_NumOfObjs(h_NewPointersLst) == 1),E_INVALID_STATE);
+
+    numOfModifiedPtr = (uint8_t)LIST_NumOfObjs(h_OldPointersLst);
+
+    p_PosNew = LIST_FIRST(h_NewPointersLst);
+
+    /* Invoke host-command to copy from the new Ad to existing Ads */
+    err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst, p_AdditionalParams, useShadowStructs);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if (useShadowStructs)
+    {
+        /* When the host-command above has ended, the old structures are 'free'and we can update
+           them by copying from the new shadow structures. */
+        if(p_CcNode->lclMask)
+            keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
+        else
+            keySize = p_CcNode->ccKeySizeAccExtraction;
+
+        IO2IOCpy32(p_AdditionalParams->p_KeysMatchTableOld,
+                   p_AdditionalParams->p_KeysMatchTableNew,
+                   p_CcNode->maxNumOfKeys * keySize * sizeof (uint8_t));
+
+        IO2IOCpy32(p_AdditionalParams->p_AdTableOld,
+                   p_AdditionalParams->p_AdTableNew,
+                   (uint32_t)((p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
+
+        /* Retrieve the address of the allocated Ad */
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_PosNew);
+        h_Ad = p_CcNodeInfo->h_CcNode;
+
+        /* Build a new Ad that holds the old (now updated) structures */
+        p_AdditionalParams->p_KeysMatchTableNew = p_AdditionalParams->p_KeysMatchTableOld;
+        p_AdditionalParams->p_AdTableNew        = p_AdditionalParams->p_AdTableOld;
+
+        nextEngineParams.nextEngine = e_FM_PCD_CC;
+        nextEngineParams.params.ccParams.h_CcNode = (t_Handle)p_CcNode;
+
+        BuildNewAd(h_Ad, p_AdditionalParams, p_CcNode, &nextEngineParams);
+
+        /* HC to copy from the new Ad (old updated structures) to current Ad (uses shadow structures) */
+        err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst, p_AdditionalParams, useShadowStructs);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = FmPcdCcReleaseModifiedDataStructure(h_FmPcd,
+                                              h_OldPointersLst,
+                                              h_NewPointersLst,
+                                              numOfModifiedPtr,
+                                              p_AdditionalParams,
+                                              useShadowStructs);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
+}
+
+#ifdef FM_CAPWAP_SUPPORT
+static bool FmPcdCcIsCapwapApplSpecific(t_Handle h_Node)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_Node;
+    bool    isManipForCapwapApplSpecificBuild = FALSE;
+    int i = 0;
+
+    ASSERT_COND(h_Node);
+    /* assumption that this function called only for INDEXED_FLOW_ID - so no miss*/
+    for(i = 0; i < p_CcNode->numOfKeys; i++)
+    {
+        if( p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip &&
+            FmPcdManipIsCapwapApplSpecific(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip))
+        {
+            isManipForCapwapApplSpecificBuild = TRUE;
+            break;
+        }
+    }
+    return isManipForCapwapApplSpecificBuild;
+
+}
+#endif /* FM_CAPWAP_SUPPORT */
+
+static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
+                             t_Handle                           h_PcdParams,
+                             t_Handle                           h_FmPort,
+                             t_FmPcdCcKeyAndNextEngineParams    *p_CcKeyAndNextEngineParams,
+                             uint16_t                           numOfEntries,
+                             t_Handle                           h_Ad,
+                             bool                               validate,
+                             uint16_t                           level,
+                             t_Handle                           h_FmTree,
+                             bool                               modify)
+{
+    t_FmPcdCcNode       *p_CcNode;
+    t_Error             err;
+    uint16_t            tmp = 0;
+    int                 i = 0;
+    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
+
+    level++;
+
+    if (p_CcTree->h_IpReassemblyManip)
+    {
+        err = FmPcdManipUpdate(h_FmPcd,
+                               h_PcdParams,
+                               h_FmPort,
+                               p_CcTree->h_IpReassemblyManip,
+                               h_Ad,
+                               validate,
+                               level,
+                               h_FmTree,
+                               modify);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    if (numOfEntries)
+    {
+        for (i = 0; i < numOfEntries; i++)
+        {
+            if (i == 0)
+                h_Ad = PTR_MOVE(h_Ad, i*FM_PCD_CC_AD_ENTRY_SIZE);
+            else
+                h_Ad = PTR_MOVE(h_Ad, FM_PCD_CC_AD_ENTRY_SIZE);
+
+            if (p_CcKeyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            {
+                p_CcNode = p_CcKeyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+                ASSERT_COND(p_CcNode);
+
+                if(p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
+                {
+                    err = FmPcdManipUpdate(h_FmPcd,
+                                           NULL,
+                                           h_FmPort,
+                                           p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                                           h_Ad,
+                                           validate,
+                                           level,
+                                           h_FmTree,
+                                           modify);
+                    if (err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+
+                if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
+                    tmp  = (uint8_t)(p_CcNode->numOfKeys + 1);
+                else
+                    tmp = p_CcNode->numOfKeys;
+
+                err = CcUpdateParam(h_FmPcd,
+                                    h_PcdParams,
+                                    h_FmPort,
+                                    p_CcNode->keyAndNextEngineParams,
+                                    tmp,
+                                    p_CcNode->h_AdTable,
+                                    validate,
+                                    level,
+                                    h_FmTree,
+                                    modify);
+                if (err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+            else
+            {
+                if (p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
+                {
+                    err = FmPcdManipUpdate(h_FmPcd,
+                                           NULL,
+                                           h_FmPort,
+                                           p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                                           h_Ad,
+                                           validate,
+                                           level,
+                                           h_FmTree,
+                                           modify);
+                    if (err)
+                        RETURN_ERROR(MAJOR, err, NO_MSG);
+                }
+            }
+        }
+    }
+
+    return E_OK;
+}
+
+static bool IsNodeInModifiedState(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_CcNode);
+
+    return p_CcNode->modifiedState;
+}
+
+static void UpdateNodeWithModifiedState(t_Handle h_CcNode, bool modifiedState)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_CcNode);
+
+    p_CcNode->modifiedState = modifiedState;
+}
+
+static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
+{
+    switch (p_CcNodeParam->extractCcParams.extractNonHdr.action)
+    {
+        case(e_FM_PCD_ACTION_EXACT_MATCH):
+            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+            {
+                case(e_FM_PCD_EXTRACT_FROM_KEY):
+                    return CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH;
+                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                    return CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH;
+                default:
+                    return CC_PRIVATE_INFO_NONE;
+            }
+
+        case(e_FM_PCD_ACTION_INDEXED_LOOKUP):
+            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+            {
+                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                    return CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP;
+                case(e_FM_PCD_EXTRACT_FROM_FLOW_ID):
+                    return CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP;
+                default:
+                  return  CC_PRIVATE_INFO_NONE;
+            }
+
+       default:
+           break;
+    }
+
+    return CC_PRIVATE_INFO_NONE;
+}
+
+static t_CcNodeInformation * DequeueAdditionalInfoFromRelevantLst(t_List *p_List)
+{
+    t_CcNodeInformation   *p_CcNodeInfo = NULL;
+    uint32_t        intFlags;
+
+    intFlags = XX_DisableAllIntr();
+
+    if (!LIST_IsEmpty(p_List))
+    {
+        p_CcNodeInfo = CC_NODE_F_OBJECT(p_List->p_Next);
+        LIST_DelAndInit(&p_CcNodeInfo->node);
+    }
+
+    XX_RestoreAllIntr(intFlags);
+
+    return p_CcNodeInfo;
+}
+
+void ReleaseLst(t_List *p_List)
+{
+    t_CcNodeInformation   *p_CcNodeInfo = NULL;
+
+    if(!LIST_IsEmpty(p_List))
+    {
+        p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
+        while (p_CcNodeInfo)
+        {
+            XX_Free(p_CcNodeInfo);
+            p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
+        }
+    }
+
+    LIST_DelAndInit(p_List);
+}
+
+void FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree)
+{
     RELEASE_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->lock);
 }
 
@@ -449,34 +897,42 @@ void FmPcdCcNodeTreeReleaseLock(t_List *p_List)
         h_FmPcdCcTree = p_CcNodeInfo->h_CcNode;
         FmPcdCcTreeReleaseLock(h_FmPcdCcTree);
     }
+
     ReleaseLst(p_List);
 }
 
-static void DeleteNode(t_FmPcdCcNode *p_FmPcdCcNode)
+static void DeleteNode(t_FmPcdCcNode *p_CcNode)
 {
-    if(p_FmPcdCcNode)
+    if(p_CcNode)
     {
-        if(p_FmPcdCcNode->p_GlblMask)
+        if(p_CcNode->p_GlblMask)
         {
-            XX_Free(p_FmPcdCcNode->p_GlblMask);
-            p_FmPcdCcNode->p_GlblMask = NULL;
+            XX_Free(p_CcNode->p_GlblMask);
+            p_CcNode->p_GlblMask = NULL;
         }
-        if(p_FmPcdCcNode->h_KeysMatchTable)
+
+        if(p_CcNode->h_KeysMatchTable)
         {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd), p_FmPcdCcNode->h_KeysMatchTable);
-            p_FmPcdCcNode->h_KeysMatchTable = NULL;
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_KeysMatchTable);
+            p_CcNode->h_KeysMatchTable = NULL;
         }
-        if(p_FmPcdCcNode->h_AdTable)
+
+        if(p_CcNode->h_AdTable)
         {
-            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd), p_FmPcdCcNode->h_AdTable);
-            p_FmPcdCcNode->h_AdTable = NULL;
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_AdTable);
+            p_CcNode->h_AdTable = NULL;
         }
 
-        ReleaseLst(&p_FmPcdCcNode->ccPrevNodesLst);
-        ReleaseLst(&p_FmPcdCcNode->ccTreeIdLst);
-        ReleaseLst(&p_FmPcdCcNode->ccTreesLst);
+        if(p_CcNode->h_Ad)
+        {
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_Ad);
+            p_CcNode->h_Ad = NULL;
+        }
+        ReleaseLst(&p_CcNode->ccPrevNodesLst);
+        ReleaseLst(&p_CcNode->ccTreeIdLst);
+        ReleaseLst(&p_CcNode->ccTreesLst);
 
-        XX_Free(p_FmPcdCcNode);
+        XX_Free(p_CcNode);
     }
 }
 
@@ -496,19 +952,6 @@ static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
     }
 }
 
-static void  UpdateNodeOwner(t_FmPcdCcNode *p_FmPcdCcNode, bool add)
-{
-    ASSERT_COND(p_FmPcdCcNode);
-
-    if(add)
-        p_FmPcdCcNode->owners++;
-    else
-    {
-        ASSERT_COND(p_FmPcdCcNode->owners);
-        p_FmPcdCcNode->owners--;
-    }
-}
-
 static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCcSize)
 {
     if((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
@@ -557,6 +1000,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
         case(HEADER_TYPE_PPPoE):
             switch(field.pppoe)
             {
@@ -569,6 +1013,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
         case (HEADER_TYPE_VLAN):
             switch(field.vlan)
             {
@@ -581,6 +1026,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
         case (HEADER_TYPE_MPLS):
             switch(field.mpls)
             {
@@ -593,6 +1039,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
         case (HEADER_TYPE_IPv4):
             switch(field.ipv4)
             {
@@ -616,6 +1063,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
         case (HEADER_TYPE_IPv6):
             switch(field.ipv6)
             {
@@ -636,6 +1084,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
         case (HEADER_TYPE_GRE):
             switch(field.gre)
             {
@@ -648,6 +1097,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
         case (HEADER_TYPE_MINENCAP):
             switch(field.minencap)
             {
@@ -667,6 +1117,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
         case (HEADER_TYPE_TCP):
             switch(field.tcp)
             {
@@ -683,6 +1134,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
         case (HEADER_TYPE_UDP):
             switch(field.udp)
             {
@@ -699,6 +1151,7 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
                     break;
             }
             break;
+
        default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported10"));
             *parseCodeRealSize = CC_SIZE_ILLEGAL;
@@ -706,44 +1159,52 @@ static void  GetSizeHeaderField(e_NetHeaderType hdr,t_FmPcdFields field,uint8_t
     }
 }
 
-static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    uint16_t                    absoluteProfileId;
-    t_Error                     err = E_OK;
-    uint8_t                     relativeSchemeId;
+    uint16_t    absoluteProfileId;
+    t_Error     err = E_OK;
+    uint8_t     relativeSchemeId;
 
     switch(p_FmPcdCcNextEngineParams->nextEngine)
     {
          case(e_FM_PCD_INVALID):
              err = E_NOT_SUPPORTED;
              break;
+
          case(e_FM_PCD_DONE):
-             if(p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
+             if (p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME)
              {
-                 if(p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid &&
+                 if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid &&
                          !p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not defined fqid for control flow for BMI next engine "));
-                 if(p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
+                 if (p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
                      RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
              }
             break;
+
         case(e_FM_PCD_KG):
-            relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, (uint8_t)(PTR_TO_UINT(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme)-1));
-            if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+            relativeSchemeId =
+                    FmPcdKgGetRelativeSchemeId(h_FmPcd, FmPcdKgGetSchemeId(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme));
+            if (relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-            if(!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
+            if (!FmPcdKgIsSchemeValidSw(p_FmPcdCcNextEngineParams->params.kgParams.h_DirectScheme))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("not valid schemeIndex in KG next engine param"));
-            if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
+            if (!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("CC Node may point only to a scheme that is always direct."));
             break;
+
         case(e_FM_PCD_PLCR):
             if(p_FmPcdCcNextEngineParams->params.plcrParams.overrideParams)
             {
-                /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+                /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
                 if(p_FmPcdCcNextEngineParams->params.plcrParams.sharedProfile)
                 {
-                    err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId, &absoluteProfileId);
+                    err = FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd,
+                                                        e_FM_PCD_PLCR_SHARED,
+                                                        NULL,
+                                                        p_FmPcdCcNextEngineParams->params.plcrParams.newRelativeProfileId,
+                                                        &absoluteProfileId);
                     if(err)
                         RETURN_ERROR(MAJOR, err, ("Shared profile offset is out of range"));
                     if(!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
@@ -759,21 +1220,38 @@ static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEnginePar
                 */
             }
             break;
+
         case(e_FM_PCD_CC):
             if(!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
                 RETURN_ERROR(MAJOR, E_NULL_POINTER, ("handler to next Node is NULL"));
-            break;
+            if(p_FmPcdCcNextEngineParams->statisticsEn)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("not allowed to put statisticsEn when nextEngine == e_FM_PCD_CC"));
+        break;
+
+#if DPAA_VERSION >= 3
+         case(e_FM_PCD_FR):
+             if (!p_FmPcdCcNextEngineParams->params.h_FrmReplic)
+                err = E_NOT_SUPPORTED;
+             break;
+#endif /* DPAA_VERSION >= 3 */
+
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
     }
+
     return err;
 }
 
-static uint8_t GetGenParseCode(t_Handle h_FmPcd, e_FmPcdExtractFrom src, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset, bool fromIc, ccPrivateInfo_t icCode)
+static uint8_t GetGenParseCode(t_Handle             h_FmPcd,
+                               e_FmPcdExtractFrom   src,
+                               uint32_t             offset,
+                               bool                 glblMask,
+                               uint8_t              *parseArrayOffset,
+                               bool                 fromIc,
+                               ccPrivateInfo_t      icCode)
 {
-#ifndef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
     UNUSED(h_FmPcd);
-#endif /* !FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
+
     if(!fromIc)
     {
         switch(src)
@@ -783,12 +1261,14 @@ static uint8_t GetGenParseCode(t_Handle h_FmPcd, e_FmPcdExtractFrom src, uint32_
                     return CC_PC_GENERIC_WITH_MASK ;
                 else
                   return CC_PC_GENERIC_WITHOUT_MASK;
+
             case(e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
                 *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
                 if(offset)
                     return CC_PR_OFFSET;
                 else
                     return CC_PR_WITHOUT_OFFSET;
+
             default:
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
                 return CC_PC_ILLEGAL;
@@ -815,6 +1295,7 @@ static uint8_t GetGenParseCode(t_Handle h_FmPcd, e_FmPcdExtractFrom src, uint32_
                 break;
         }
     }
+
     return CC_PC_ILLEGAL;
 }
 
@@ -1030,82 +1511,96 @@ static uint8_t GetPrParseCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, uin
     if(offset)
         offsetRelevant = TRUE;
 
-    switch(hdr){
+    switch(hdr)
+    {
         case(HEADER_TYPE_NONE):
             ASSERT_COND(FALSE);
             return CC_PC_ILLEGAL;
+
         case(HEADER_TYPE_ETH):
             *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
             break;
+
         case(HEADER_TYPE_USER_DEFINED_SHIM1):
             if(offset || glblMask)
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
             else
                 return CC_PC_PR_SHIM1;
             break;
+
         case(HEADER_TYPE_USER_DEFINED_SHIM2):
             if(offset || glblMask)
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
             else
                 return CC_PC_PR_SHIM2;
             break;
-      case(HEADER_TYPE_LLC_SNAP):
+
+        case(HEADER_TYPE_LLC_SNAP):
             *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
             break;
+
         case(HEADER_TYPE_PPPoE):
             *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
             break;
-            case(HEADER_TYPE_MPLS):
-                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                        *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
-                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
-                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
-                else
-                {
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
-                    return CC_PC_ILLEGAL;
-                }
-                break;
-            case(HEADER_TYPE_IPv4):
-            case(HEADER_TYPE_IPv6):
-              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
-                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
-              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
-                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
-              else
-              {
+
+        case(HEADER_TYPE_MPLS):
+            if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+            else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                    *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+            else
+            {
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
+                return CC_PC_ILLEGAL;
+            }
+            break;
+
+        case(HEADER_TYPE_IPv4):
+        case(HEADER_TYPE_IPv6):
+            if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
+            else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+            else
+            {
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
                 return CC_PC_ILLEGAL;
+            }
+            break;
 
-              }
-                break;
-            case(HEADER_TYPE_MINENCAP):
-                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
-                break;
-            case(HEADER_TYPE_GRE):
-                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
-                break;
-            case(HEADER_TYPE_TCP):
-            case(HEADER_TYPE_UDP):
-            case(HEADER_TYPE_IPSEC_AH):
-            case(HEADER_TYPE_IPSEC_ESP):
-            case(HEADER_TYPE_DCCP):
-            case(HEADER_TYPE_SCTP):
-                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
-                break;
+        case(HEADER_TYPE_MINENCAP):
+            *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
+            break;
 
-            default:
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header for this type of operation"));
-                return CC_PC_ILLEGAL;
+        case(HEADER_TYPE_GRE):
+            *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
+            break;
+
+        case(HEADER_TYPE_TCP):
+        case(HEADER_TYPE_UDP):
+        case(HEADER_TYPE_IPSEC_AH):
+        case(HEADER_TYPE_IPSEC_ESP):
+        case(HEADER_TYPE_DCCP):
+        case(HEADER_TYPE_SCTP):
+            *parseArrayOffset = CC_PC_PR_L4_OFFSET;
+            break;
+
+        default:
+            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header for this type of operation"));
+            return CC_PC_ILLEGAL;
      }
 
-        if(offsetRelevant)
-            return CC_PR_OFFSET;
-        else
-            return CC_PR_WITHOUT_OFFSET;
+    if(offsetRelevant)
+        return CC_PR_OFFSET;
+    else
+        return CC_PR_WITHOUT_OFFSET;
 }
 
-static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field, uint32_t offset, uint8_t *parseArrayOffset, e_FmPcdHdrIndex hdrIndex)
+static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
+                                 t_FmPcdFields      field,
+                                 uint32_t           offset,
+                                 uint8_t            *parseArrayOffset,
+                                 e_FmPcdHdrIndex    hdrIndex)
 {
     bool offsetRelevant = FALSE;
 
@@ -1127,6 +1622,7 @@ static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field, uint3
                     return CC_PC_ILLEGAL;
             }
             break;
+
         case(HEADER_TYPE_VLAN):
             switch(field.vlan)
             {
@@ -1140,33 +1636,50 @@ static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field, uint3
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
             }
-        break;
+            break;
+
         default:
             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal header "));
             return CC_PC_ILLEGAL;
     }
+
     if(offsetRelevant)
         return CC_PR_OFFSET;
     else
         return CC_PR_WITHOUT_OFFSET;
 }
 
-static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
+void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams)
 {
-    t_AdOfTypeResult                *p_AdResult = (t_AdOfTypeResult*)p_Ad;
-    uint32_t                        tmp = 0, tmpNia = 0;
-    uint16_t                        profileId;
-    t_Handle                        p_AdNewPtr = NULL;
-
+    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult*)p_Ad;
+    uint32_t            tmp = 0, tmpNia = 0;
+    uint16_t            profileId;
+    t_Handle            p_AdNewPtr = NULL;
+
+    /* there are 3 cases handled in this routine of building a "result" type AD.
+     * Case 1: No Manip. The action descriptor is built within the match table.
+     *         p_AdResult = p_AdNewPtr;
+     * Case 2: Manip exists. A new AD is created - p_AdNewPtr. It is initialized
+     *         either in the FmPcdManipUpdateAdResultForCc routine or it was already
+     *         initialized and returned here.
+     *         p_AdResult (within the match table) will be initialized after
+     *         this routine returns and point to the existing AD.
+     * Case 3: Manip exists. The action descriptor is built within the match table.
+     *         FmPcdManipUpdateAdResultForCc returns a NULL p_AdNewPtr.
+     */
+
+    /* As default, the "new" ptr is the current one. i.e. the content of the result
+     * AD will be written into the match table itself (case (1))*/
     p_AdNewPtr = p_AdResult;
 
-#ifdef FM_PCD_CC_MANIP
     if (p_CcNextEngineParams->h_Manip)
+        /* Create Manip and return p_AdNewPtr to either a new descriptor or NULL */
         FmPcdManipUpdateAdResultForCc(p_CcNextEngineParams->h_Manip, p_Ad, &p_AdNewPtr);
-#endif /* FM_PCD_CC_MANIP */
 
-    if(p_AdNewPtr)
+    /* if (p_AdNewPtr = NULL) --> Done. (case (3)) */
+    if (p_AdNewPtr)
     {
+        /* case (1) and (2) */
         switch(p_CcNextEngineParams->nextEngine)
         {
             case(e_FM_PCD_DONE):
@@ -1183,13 +1696,15 @@ static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEng
                        tmp |= FM_PCD_AD_RESULT_PLCR_DIS;
                     }
                 }
-            if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
-                tmpNia |= (NIA_ENG_BMI |NIA_BMI_AC_DISCARD);
-            else
-                tmpNia |= (NIA_ENG_BMI |NIA_BMI_AC_ENQ_FRAME);
-            if(p_CcNextEngineParams->params.enqueueParams.statisticsEn)
-                tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
+
+                if(p_CcNextEngineParams->params.enqueueParams.action == e_FM_PCD_DROP_FRAME)
+                    tmpNia |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
+                else
+                    tmpNia |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
+                if(p_CcNextEngineParams->statisticsEn)
+                    tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                 break;
+
             case(e_FM_PCD_KG):
                 if(p_CcNextEngineParams->params.kgParams.overrideFqid)
                 {
@@ -1203,21 +1718,23 @@ static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEng
                 }
                 tmpNia = NIA_KG_DIRECT;
                 tmpNia |= NIA_ENG_KG;
-                tmpNia |= (uint8_t)(PTR_TO_UINT(p_CcNextEngineParams->params.kgParams.h_DirectScheme)-1);
-            if(p_CcNextEngineParams->params.kgParams.statisticsEn)
-                tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
-            break;
+                tmpNia |= FmPcdKgGetSchemeId(p_CcNextEngineParams->params.kgParams.h_DirectScheme);
+
+                if(p_CcNextEngineParams->statisticsEn)
+                    tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
+                break;
+
             case(e_FM_PCD_PLCR):
                 tmp = 0;
                 if(p_CcNextEngineParams->params.plcrParams.overrideParams)
                 {
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
 
-                    /* if private policer profile, it may be uninitialized yet, therefor no checks are done at this stage */
+                    /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
                     if(p_CcNextEngineParams->params.plcrParams.sharedProfile)
                     {
                         tmpNia |= NIA_PLCR_ABSOLUTE;
-                        FmPcdPlcrGetAbsoluteProfileId((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParams->params.plcrParams.newRelativeProfileId, &profileId);
+                        FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL,p_CcNextEngineParams->params.plcrParams.newRelativeProfileId, &profileId);
                     }
                     else
                         profileId = p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
@@ -1227,17 +1744,19 @@ static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEng
                 }
                 else
                    tmp = FM_PCD_AD_RESULT_DATA_FLOW_TYPE;
+
                 tmpNia |= NIA_ENG_PLCR | p_CcNextEngineParams->params.plcrParams.newRelativeProfileId;
-            if(p_CcNextEngineParams->params.kgParams.statisticsEn)
-                tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
+
+                if(p_CcNextEngineParams->statisticsEn)
+                    tmpNia |=  FM_PCD_AD_RESULT_EXTENDED_MODE |  FM_PCD_AD_RESULT_STATISTICS_EN;
                break;
+
             default:
                 return;
         }
         WRITE_UINT32(p_AdResult->fqid, tmp);
 
-#ifdef FM_PCD_CC_MANIP
-        if(p_CcNextEngineParams->h_Manip)
+        if (p_CcNextEngineParams->h_Manip)
         {
             tmp = GET_UINT32(p_AdResult->plcrProfile);
             tmp |= (uint32_t)(XX_VirtToPhys(p_AdNewPtr) - (p_FmPcd->physicalMuramBase)) >> 4;
@@ -1246,76 +1765,69 @@ static void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEng
             tmpNia |= FM_PCD_AD_RESULT_EXTENDED_MODE;
             tmpNia |= FM_PCD_AD_RESULT_NADEN;
         }
-#endif /* FM_PCD_CC_MANIP */
 
         WRITE_UINT32(p_AdResult->nia, tmpNia);
     }
 }
 
-static void FillAdOfTypeContLookup(t_Handle p_Ad,  t_Handle h_FmPcd, t_Handle p_FmPcdCcNode, t_Handle h_Manip)
+static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
+                              t_Handle                         h_PcdParams,
+                              t_Handle                         h_FmPort,
+                              t_Handle                         h_FmTree,
+                              bool                             validate)
 {
-    t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_FmPcdCcNode;
-    t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)p_Ad;
-    t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                tmpReg32;
-    t_Handle                p_AdNewPtr = NULL;
-
-    p_AdNewPtr = p_AdContLookup;
-
-#ifdef FM_PCD_CC_MANIP
-    if (h_Manip)
-        FmPcdManipUpdateAdContLookupForCc(h_Manip, p_Ad, &p_AdNewPtr, (uint32_t)((XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase)));
-#else
-    UNUSED(h_Manip);
-#endif /* FM_PCD_CC_MANIP */
-
-    if(p_AdNewPtr)
-    {
-        tmpReg32 = 0;
-        tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-        tmpReg32 |= p_Node->sizeOfExtraction ? ((p_Node->sizeOfExtraction - 1) << 24) : 0;
-        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Node->h_AdTable) - p_FmPcd->physicalMuramBase);
-        WRITE_UINT32(p_AdContLookup->ccAdBase, tmpReg32);
-
-        tmpReg32 = 0;
-        tmpReg32 |= p_Node->numOfKeys << 24;
-        tmpReg32 |= (p_Node->lclMask ? FM_PCD_AD_CONT_LOOKUP_LCL_MASK : 0);
-        tmpReg32 |= p_Node->h_KeysMatchTable ?
-                        (uint32_t)(XX_VirtToPhys(p_Node->h_KeysMatchTable) - p_FmPcd->physicalMuramBase) : 0;
-        WRITE_UINT32(p_AdContLookup->matchTblPtr, tmpReg32);
-
-        tmpReg32 = 0;
-        tmpReg32 |= p_Node->prsArrayOffset << 24;
-        tmpReg32 |= p_Node->offset << 16;
-        tmpReg32 |= p_Node->parseCode;
-        WRITE_UINT32(p_AdContLookup->pcAndOffsets, tmpReg32);
+    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
 
-        Mem2IOCpy32((void*)&p_AdContLookup->gmask, p_Node->p_GlblMask, CC_GLBL_MASK_SIZE);
-    }
+    return CcUpdateParam(h_FmPcd,
+                         h_PcdParams,
+                         h_FmPort,
+                         p_CcTree->keyAndNextEngineParams,
+                         p_CcTree->numOfEntries,
+                         UINT_TO_PTR(p_CcTree->ccTreeBaseAddr),
+                         validate,
+                         0,
+                         h_FmTree,
+                         FALSE);
 }
 
-static void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd)
+/*static*/ void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd)
 {
     switch(p_FmPcdCcNextEngineParams->nextEngine)
     {
         case(e_FM_PCD_KG):
         case(e_FM_PCD_PLCR):
         case(e_FM_PCD_DONE):
+            /* if NIA is not CC, create a "result" type AD */
             FillAdOfTypeResult(p_Ad, p_FmPcd, p_FmPcdCcNextEngineParams);
             break;
+#if DPAA_VERSION >= 3
+        case(e_FM_PCD_FR):
+            if (p_FmPcdCcNextEngineParams->params.h_FrmReplic)
+            {
+                FillAdOfTypeContLookup(p_Ad,
+                                       p_FmPcd,
+                                       p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                                       p_FmPcdCcNextEngineParams->h_Manip,
+                                       p_FmPcdCcNextEngineParams->params.h_FrmReplic);
+                                       FrmReplicUpdateGroupOwner(p_FmPcdCcNextEngineParams->params.h_FrmReplic,
+                                                                 TRUE,  /* add */
+                                                                 FALSE, /* fullUpdate */
+                                                                 NULL);
+            }
+            break;
+#endif /* DPAA_VERSION >= 3 */
+
         case(e_FM_PCD_CC):
+            /* if NIA is not CC, create a TD to continue the CC lookup */
             FillAdOfTypeContLookup(p_Ad,
                                    p_FmPcd,
                                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-#ifdef FM_PCD_CC_MANIP
-                                   p_FmPcdCcNextEngineParams->h_Manip
-#else
-                                   NULL
-#endif /* FM_PCD_CC_MANIP */
-                                   );
-            UpdateNodeOwner (p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-                            TRUE);
+                                   p_FmPcdCcNextEngineParams->h_Manip,
+                                   NULL);
+
+            UpdateNodeOwner(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode, TRUE);
             break;
+
          default:
              return;
     }
@@ -1326,86 +1838,149 @@ static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_Addit
 {
     if(p_AdditionalInfo->p_AdTableNew)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
+
     if(p_AdditionalInfo->p_KeysMatchTableNew)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd), p_AdditionalInfo->p_KeysMatchTableNew);
 }
 
-static t_Error UpdateGblMask(t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keySize, uint8_t *p_Mask)
+static void UpdateGblMask(t_FmPcdCcNode *p_CcNode, uint8_t keySize, uint8_t *p_Mask)
 {
     if (p_Mask &&
-        !p_FmPcdCcNode->glblMaskUpdated &&
+        !p_CcNode->glblMaskUpdated &&
         (keySize <= 4) &&
-        !p_FmPcdCcNode->lclMask )
+        !p_CcNode->lclMask )
     {
-        memcpy(p_FmPcdCcNode->p_GlblMask, p_Mask, (sizeof(uint8_t))*keySize);
-        p_FmPcdCcNode->glblMaskUpdated = TRUE;
-        p_FmPcdCcNode->glblMaskSize = 4;
+        memcpy(p_CcNode->p_GlblMask, p_Mask, (sizeof(uint8_t))*keySize);
+        p_CcNode->glblMaskUpdated = TRUE;
+        p_CcNode->glblMaskSize = 4;
     }
     else if (p_Mask &&
              (keySize <= 4) &&
-             !p_FmPcdCcNode->lclMask)
+             !p_CcNode->lclMask)
     {
-        if (memcmp(p_FmPcdCcNode->p_GlblMask, p_Mask, keySize) != 0)
+        if (memcmp(p_CcNode->p_GlblMask, p_Mask, keySize) != 0)
         {
-            p_FmPcdCcNode->lclMask = TRUE;
-            p_FmPcdCcNode->glblMaskSize = 0;
+            p_CcNode->lclMask = TRUE;
+            p_CcNode->glblMaskSize = 0;
         }
     }
-    else if (!p_Mask && (p_FmPcdCcNode->glblMaskUpdated) && (keySize <= 4))
+    else if (!p_Mask && (p_CcNode->glblMaskUpdated) && (keySize <= 4))
     {
         uint32_t tmpMask = 0xffffffff;
-        if (memcmp(p_FmPcdCcNode->p_GlblMask, &tmpMask, 4) != 0)
+        if (memcmp(p_CcNode->p_GlblMask, &tmpMask, 4) != 0)
         {
-            p_FmPcdCcNode->lclMask = TRUE;
-            p_FmPcdCcNode->glblMaskSize = 0;
+            p_CcNode->lclMask = TRUE;
+            p_CcNode->glblMaskSize = 0;
         }
     }
     else if (p_Mask)
     {
-        p_FmPcdCcNode->lclMask = TRUE;
-        p_FmPcdCcNode->glblMaskSize = 0;
+        p_CcNode->lclMask = TRUE;
+        p_CcNode->glblMaskSize = 0;
     }
 
-    return E_OK;
 }
 
-static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_FmPcdCcNode,
+static __inline t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
+{
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
+    t_FmPcd         *p_FmPcd;
+    t_Handle        h_Ad;
+
+    if ((isTree) || (p_CcNode->maxNumOfKeys == 0))
+    {
+        h_Ad = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                                           FM_PCD_CC_AD_ENTRY_SIZE,
+                                           FM_PCD_CC_AD_TABLE_ALIGN);
+        if (!h_Ad)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptor"));
+            return NULL;
+        }
+    }
+    else
+    {
+        p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+
+        /* The allocated shadow is divided as follows:
+           0 . . .       16 . . .
+           ---------------------------------------------------
+           |   Shadow   |   Shadow Keys   |   Shadow Next    |
+           |     Ad     |   Match Table   |   Engine Table   |
+           | (16 bytes) | (maximal size)  |  (maximal size)  |
+           ---------------------------------------------------
+         */
+
+        h_Ad = p_FmPcd->p_CcShadow;
+    }
+
+    return h_Ad;
+}
+
+static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_CcNode,
                                       int                                   *size,
                                       t_FmPcdModifyCcKeyAdditionalParams    *p_AdditionalInfo)
 {
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
-    p_AdditionalInfo->p_AdTableNew = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd),
-                                     (uint32_t)( (p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
-                                     FM_PCD_CC_AD_TABLE_ALIGN);
-    if(!p_AdditionalInfo->p_AdTableNew)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for AD table "));
+    if(p_CcNode->lclMask)
+        *size = 2 * p_CcNode->ccKeySizeAccExtraction;
+    else
+        *size = p_CcNode->ccKeySizeAccExtraction;
 
-    IOMemSet32((uint8_t*)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+    if (p_CcNode->maxNumOfKeys == 0)
+    {
+        p_AdditionalInfo->p_AdTableNew =
+            (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
+                                        (uint32_t)( (p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
+                                        FM_PCD_CC_AD_TABLE_ALIGN);
+        if (!p_AdditionalInfo->p_AdTableNew)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
+
+        p_AdditionalInfo->p_KeysMatchTableNew =
+            (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd),
+                                        (uint32_t)(*size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1)),
+                                        FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
+        if (!p_AdditionalInfo->p_KeysMatchTableNew)
+        {
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
+            p_AdditionalInfo->p_AdTableNew = NULL;
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
+        }
 
-    if(p_FmPcdCcNode->lclMask)
-        *size = 2 * p_FmPcdCcNode->ccKeySizeAccExtraction;
+        IOMemSet32((uint8_t*)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_AdditionalInfo->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0, *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
+    }
     else
-        *size = p_FmPcdCcNode->ccKeySizeAccExtraction;
-
-    p_AdditionalInfo->p_KeysMatchTableNew =
-        (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd),
-                                    (uint32_t)(*size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1)),
-                                    FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
-    if(!p_AdditionalInfo->p_KeysMatchTableNew)
     {
-        FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd), p_AdditionalInfo->p_AdTableNew);
-        p_AdditionalInfo->p_AdTableNew = NULL;
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
+        /* The allocated shadow is divided as follows:
+           0 . . .       16 . . .
+           ---------------------------------------------------
+           |   Shadow   |   Shadow Keys   |   Shadow Next    |
+           |     Ad     |   Match Table   |   Engine Table   |
+           | (16 bytes) | (maximal size)  |  (maximal size)  |
+           ---------------------------------------------------
+         */
+
+        p_AdditionalInfo->p_KeysMatchTableNew = PTR_MOVE(p_FmPcd->p_CcShadow, FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdditionalInfo->p_AdTableNew        = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, p_CcNode->keysMatchTableMaxSize);
+
+        IOMemSet32((uint8_t*)p_AdditionalInfo->p_AdTableNew, 0, (uint32_t)((p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
+        IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0, (*size) * sizeof(uint8_t) * (p_CcNode->maxNumOfKeys));
     }
-    IOMemSet32((uint8_t*)p_AdditionalInfo->p_KeysMatchTableNew, 0, *size * sizeof(uint8_t) * (p_AdditionalInfo->numOfKeys + 1));
 
-    p_AdditionalInfo->p_AdTableOld          = p_FmPcdCcNode->h_AdTable;
-    p_AdditionalInfo->p_KeysMatchTableOld   = p_FmPcdCcNode->h_KeysMatchTable;
+    p_AdditionalInfo->p_AdTableOld          = p_CcNode->h_AdTable;
+    p_AdditionalInfo->p_KeysMatchTableOld   = p_CcNode->h_KeysMatchTable;
 
     return E_OK;
 }
 
-static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo, bool add)
+static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle                           h_FmPcd,
+                                                     t_FmPcdCcNode                      *p_CcNode,
+                                                     uint16_t                           keyIndex,
+                                                     t_FmPcdCcKeyParams                 *p_KeyParams,
+                                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo,
+                                                     bool                               add)
 {
     t_Error                 err = E_OK;
     t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
@@ -1418,35 +1993,56 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCc
     t_CcNodeInformation     *p_CcNodeInformation;
     t_List                  *p_Pos;
 
-    /*check that new NIA is legal*/
+    /* Check that new NIA is legal */
     err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    prvLclMask = p_FmPcdCcNode->lclMask;
+    prvLclMask = p_CcNode->lclMask;
 
-    /*check that new key is not require update of localMask*/
-    err = UpdateGblMask(p_FmPcdCcNode,
-                        p_FmPcdCcNode->ccKeySizeAccExtraction,
+    /* Check that new key is not require update of localMask */
+    UpdateGblMask(p_CcNode,
+                        p_CcNode->ccKeySizeAccExtraction,
                         p_KeyParams->p_Mask);
-    if (err != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    /*update internal data structure for next engine per index (index - key)*/
-    memcpy(&p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].nextEngineParams,&p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+    /* Update internal data structure with new next engine for the given index */
+    memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,
+           &p_KeyParams->ccNextEngineParams,
+           sizeof(t_FmPcdCcNextEngineParams));
 
-    /*update numOfKeys*/
-    if(add)
-        p_AdditionalInfo->numOfKeys = (uint8_t)(p_FmPcdCcNode->numOfKeys + 1);
+    memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key,
+            p_KeyParams->p_Key,
+            p_CcNode->userSizeOfExtraction);
+
+    if ((p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        && p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
+    {
+        err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode);
+        if (err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
+
+    if (p_KeyParams->p_Mask)
+        memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
+               p_KeyParams->p_Mask,
+               p_CcNode->userSizeOfExtraction);
     else
-        p_AdditionalInfo->numOfKeys = (uint8_t)p_FmPcdCcNode->numOfKeys;
-    /*function which build in the memory new KeyTbl, AdTbl*/
-    err = BuildNewNodeCommonPart(p_FmPcdCcNode, &size, p_AdditionalInfo);
-    if(err)
+        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
+               0xFF,
+               p_CcNode->userSizeOfExtraction);
+
+    /* Update numOfKeys */
+    if (add)
+        p_AdditionalInfo->numOfKeys = (uint8_t)(p_CcNode->numOfKeys + 1);
+    else
+        p_AdditionalInfo->numOfKeys = (uint8_t)p_CcNode->numOfKeys;
+
+    /* Allocate new tables in MURAM: keys match table and action descriptors table */
+    err = BuildNewNodeCommonPart(p_CcNode, &size, p_AdditionalInfo);
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-#ifdef FM_PCD_CC_MANIP
-    /*check that manip is legal and what requiredAction is necessary for this manip*/
+    /* Check that manip is legal and what requiredAction is necessary for this manip */
     if(p_KeyParams->ccNextEngineParams.h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams,&requiredAction);
@@ -1454,121 +2050,162 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCc
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
     }
-#endif /* FM_PCD_CC_MANIP */
 
-    p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction = requiredAction;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction = requiredAction;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
 
-    p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
-
-
-    /*update new Ad and new Key Table according to new requirement*/
+    /* Update new Ad and new Key Table according to new requirement */
     i = 0;
-    for(j = 0; j < p_AdditionalInfo->numOfKeys; j++)
+    for (j = 0; j < p_AdditionalInfo->numOfKeys; j++)
     {
         p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
-        if(j == keyIndex)
-         {
-            NextStepAd(p_AdTableNewTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
-            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
-            Mem2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_FmPcdCcNode->userSizeOfExtraction);
-            if(p_FmPcdCcNode->lclMask)
+
+        if (j == keyIndex)
+        {
+            /* Building action descriptor for the received new key */
+            NextStepAd(p_AdTableNewTmp, &p_KeyParams->ccNextEngineParams, p_FmPcd);
+
+            /* Copy the received new key into keys match table */
+            p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size*sizeof(uint8_t));
+
+            Mem2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeyParams->p_Key, p_CcNode->userSizeOfExtraction);
+
+            /* Update mask for the received new key */
+            if (p_CcNode->lclMask)
             {
                 if(p_KeyParams->p_Mask)
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->userSizeOfExtraction);
-                else if (p_FmPcdCcNode->ccKeySizeAccExtraction > 4)
-                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->userSizeOfExtraction);
+                {
+                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                p_KeyParams->p_Mask,
+                                p_CcNode->userSizeOfExtraction);
+                }
+                else if (p_CcNode->ccKeySizeAccExtraction > 4)
+                {
+                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                               p_CcNode->ccKeySizeAccExtraction),
+                               0xff,
+                               p_CcNode->userSizeOfExtraction);
+                }
                 else
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->p_GlblMask, p_FmPcdCcNode->userSizeOfExtraction);
+                {
+                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                p_CcNode->p_GlblMask,
+                                p_CcNode->userSizeOfExtraction);
+                }
             }
-            if(!add)
+
+            /* If key modification requested, the old entry is omitted and replaced by the new parameters */
+            if (!add)
                 i++;
          }
          else
          {
-            p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
-            IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
-            p_KeysMatchTableNewTmp  = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
-            p_KeysMatchTableOldTmp  = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, i*size * sizeof(uint8_t));
+             /* Copy existing action descriptors to the newly allocated Ad table */
+             p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+             IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
 
-            if(p_FmPcdCcNode->lclMask)
-            {
-                if(prvLclMask)
-                    IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),
-                               PTR_MOVE(p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),
-                               p_FmPcdCcNode->ccKeySizeAccExtraction);
-                else
-                {
-                    p_KeysMatchTableOldTmp  = PTR_MOVE(p_FmPcdCcNode->h_KeysMatchTable, i*p_FmPcdCcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+             /* Copy existing keys and their masks to the newly allocated keys match table */
+             p_KeysMatchTableNewTmp  = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
+             p_KeysMatchTableOldTmp  = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, i*size * sizeof(uint8_t));
 
-                    if (p_FmPcdCcNode->ccKeySizeAccExtraction > 4)
-                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->userSizeOfExtraction);
-                    else
-                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_FmPcdCcNode->p_GlblMask, p_FmPcdCcNode->userSizeOfExtraction);
-                }
-            }
-            IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
-           i++;
-         }
+             if (p_CcNode->lclMask)
+             {
+                 if (prvLclMask)
+                 {
+                     IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
+                                PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
+                                p_CcNode->ccKeySizeAccExtraction);
+                 }
+                 else
+                 {
+                     p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable,
+                                                       i*p_CcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+
+                     if (p_CcNode->ccKeySizeAccExtraction > 4)
+                     {
+                         IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                    p_CcNode->ccKeySizeAccExtraction),
+                                    0xff,
+                                    p_CcNode->userSizeOfExtraction);
+                     }
+                     else
+                     {
+                         IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                    p_CcNode->ccKeySizeAccExtraction),
+                                    p_CcNode->p_GlblMask,
+                                    p_CcNode->userSizeOfExtraction);
+                     }
+                 }
+             }
+
+             IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction);
+
+             i++;
+        }
     }
 
+    /* Miss action descriptor */
     p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
     p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-
-    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccTreesLst))
+    if (!LIST_IsEmpty(&p_CcNode->ccTreesLst))
     {
-        LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreesLst)
+        LIST_FOR_EACH(p_Pos, &p_CcNode->ccTreesLst)
         {
             p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
             ASSERT_COND(p_CcNodeInformation->h_CcNode);
             /*update the manipulation which has to be updated from parameters of the port*/
             /*it's has to be updated with restrictions defined in the function*/
-                err = FmPcdCcSetRequiredAction(p_FmPcdCcNode->h_FmPcd,
-                                               p_FmPcdCcNode->shadowAction | p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction,
-                                               &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],
-                                               PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                               1,
-                                               p_CcNodeInformation->h_CcNode);
-                if (err)
-                    RETURN_ERROR(MAJOR, err, (NO_MSG));
+            err = FmPcdCcSetRequiredAction(p_CcNode->h_FmPcd,
+                                           p_CcNode->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                                           &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                           PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                           1,
+                                           p_CcNodeInformation->h_CcNode);
+            if (err)
+                RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-                err = CcUpdateParam(p_FmPcdCcNode->h_FmPcd,
-                                    NULL,
-                                    NULL,
-                                    &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],
-                                    1,
-                                    PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                    TRUE,
-                                    p_CcNodeInformation->index,
-                                    p_CcNodeInformation->h_CcNode,
-                                    TRUE);
-                if (err)
-                    RETURN_ERROR(MAJOR, err, (NO_MSG));
+            err = CcUpdateParam(p_CcNode->h_FmPcd,
+                                NULL,
+                                NULL,
+                                &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                1,
+                                PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                TRUE,
+                                p_CcNodeInformation->index,
+                                p_CcNodeInformation->h_CcNode,
+                                TRUE);
+            if (err)
+                RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
-   }
-
-    if(p_FmPcdCcNode->lclMask)
-        memset(p_FmPcdCcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+    }
 
+    if (p_CcNode->lclMask)
+        memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
-    if(p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC)
+    if (p_KeyParams->ccNextEngineParams.nextEngine == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForAdd = p_KeyParams->ccNextEngineParams.params.ccParams.h_CcNode;
 
-    if(!add)
+    if (!add)
     {
-        if(p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
-#ifdef FM_PCD_CC_MANIP
-        if(p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip)
-            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip;
-#endif /* FM_PCD_CC_MANIP */
+        if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+
+        if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
+            p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+#if DPAA_VERSION >= 3
+        if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.h_FrmReplic)
+            p_AdditionalInfo->h_FrmReplicForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.h_FrmReplic;
+#endif /* DPAA_VERSION >= 3 */
     }
 
     return E_OK;
 }
 
-static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_CcNode, uint16_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     int         i = 0, j = 0;
     t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
@@ -1577,22 +2214,22 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyI
     t_Error     err = E_OK;
 
     /*save new numOfKeys*/
-    p_AdditionalInfo->numOfKeys = (uint16_t)(p_FmPcdCcNode->numOfKeys - 1);
+    p_AdditionalInfo->numOfKeys = (uint16_t)(p_CcNode->numOfKeys - 1);
 
     /*function which allocates in the memory new KeyTbl, AdTbl*/
-    err = BuildNewNodeCommonPart(p_FmPcdCcNode, &size, p_AdditionalInfo);
+    err = BuildNewNodeCommonPart(p_CcNode, &size, p_AdditionalInfo);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*update new Ad and new Key Table according to new requirement*/
-    for(i = 0, j = 0; j < p_FmPcdCcNode->numOfKeys; i++, j++)
+    for(i = 0, j = 0; j < p_CcNode->numOfKeys; i++, j++)
     {
         if(j == keyIndex)
         {
             p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j*FM_PCD_CC_AD_ENTRY_SIZE);
             j++;
         }
-        if(j == p_FmPcdCcNode->numOfKeys)
+        if(j == p_CcNode->numOfKeys)
             break;
          p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i*FM_PCD_CC_AD_ENTRY_SIZE);
          p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j*FM_PCD_CC_AD_ENTRY_SIZE);
@@ -1606,17 +2243,20 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyI
     p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j*FM_PCD_CC_AD_ENTRY_SIZE);
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
 
-    if(p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
-#ifdef FM_PCD_CC_MANIP
-    if(p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip)
-        p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip;
-#endif /* FM_PCD_CC_MANIP */
+    if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        p_AdditionalInfo->h_NodeForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+
+    if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
+        p_AdditionalInfo->h_ManipForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
 
    return E_OK;
 }
 
-static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyIndex, uint8_t  *p_Key, uint8_t *p_Mask,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode                      *p_CcNode,
+                                     uint16_t                           keyIndex,
+                                     uint8_t                            *p_Key,
+                                     uint8_t                            *p_Mask,
+                                     t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     t_Error                 err = E_OK;
     t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
@@ -1625,19 +2265,31 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyI
     int                     i = 0, j = 0;
     bool                    prvLclMask;
 
-    p_AdditionalInfo->numOfKeys =  p_FmPcdCcNode->numOfKeys;
+    p_AdditionalInfo->numOfKeys =  p_CcNode->numOfKeys;
 
-    prvLclMask = p_FmPcdCcNode->lclMask;
+    prvLclMask = p_CcNode->lclMask;
 
     /*check that new key is not require update of localMask*/
-    err = UpdateGblMask(p_FmPcdCcNode,
-                        p_FmPcdCcNode->sizeOfExtraction,
+    UpdateGblMask(p_CcNode,
+                        p_CcNode->ccKeySizeAccExtraction,
                         p_Mask);
-    if(err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /* Update internal data structure with new next engine for the given index */
+    memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].key,
+           p_Key,
+           p_CcNode->userSizeOfExtraction);
+
+    if (p_Mask)
+        memcpy(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
+               p_Mask,
+               p_CcNode->userSizeOfExtraction);
+    else
+        memset(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].mask,
+               0xFF,
+               p_CcNode->userSizeOfExtraction);
 
     /*function which build in the memory new KeyTbl, AdTbl*/
-    err = BuildNewNodeCommonPart(p_FmPcdCcNode, &size,  p_AdditionalInfo);
+    err = BuildNewNodeCommonPart(p_CcNode, &size,  p_AdditionalInfo);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1646,55 +2298,88 @@ static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyI
     {
         p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
         p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, i*FM_PCD_CC_AD_ENTRY_SIZE);
+
         IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
+
         if(j == keyIndex)
         {
             p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
-            Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key, p_FmPcdCcNode->userSizeOfExtraction);
-            if(p_FmPcdCcNode->lclMask)
+
+            Mem2IOCpy32(p_KeysMatchTableNewTmp, p_Key, p_CcNode->userSizeOfExtraction);
+
+            if(p_CcNode->lclMask)
             {
-                if(p_Mask)
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_Mask, p_FmPcdCcNode->userSizeOfExtraction);
-                else if (p_FmPcdCcNode->ccKeySizeAccExtraction > 4)
-                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->userSizeOfExtraction);
+                if (p_Mask)
+                {
+                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                p_Mask,
+                                p_CcNode->userSizeOfExtraction);
+                }
+                else if (p_CcNode->ccKeySizeAccExtraction > 4)
+                {
+                    IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                               p_CcNode->ccKeySizeAccExtraction),
+                               0xff,
+                               p_CcNode->userSizeOfExtraction);
+                }
                 else
-                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),p_FmPcdCcNode->p_GlblMask, p_FmPcdCcNode->userSizeOfExtraction);
+                {
+                    Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                p_CcNode->ccKeySizeAccExtraction),
+                                p_CcNode->p_GlblMask,
+                                p_CcNode->userSizeOfExtraction);
+                }
             }
         }
         else
         {
             p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size * sizeof(uint8_t));
-            p_KeysMatchTableOldTmp = PTR_MOVE(p_FmPcdCcNode->h_KeysMatchTable, i*size * sizeof(uint8_t));
-            if (p_FmPcdCcNode->lclMask)
+            p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i*size * sizeof(uint8_t));
+
+            if (p_CcNode->lclMask)
             {
                 if(prvLclMask)
-                    IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),
-                               PTR_MOVE(p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction),
-                               p_FmPcdCcNode->userSizeOfExtraction);
+                {
+                    IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
+                               PTR_MOVE(p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction),
+                               p_CcNode->userSizeOfExtraction);
+                }
                 else
                 {
-                    p_KeysMatchTableOldTmp = PTR_MOVE(p_FmPcdCcNode->h_KeysMatchTable, i*p_FmPcdCcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
+                    p_KeysMatchTableOldTmp = PTR_MOVE(p_CcNode->h_KeysMatchTable, i*p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
 
-                    if (p_FmPcdCcNode->ccKeySizeAccExtraction > 4)
-                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->userSizeOfExtraction);
+                    if (p_CcNode->ccKeySizeAccExtraction > 4)
+                        IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
+                                   p_CcNode->ccKeySizeAccExtraction),
+                                   0xff,
+                                   p_CcNode->userSizeOfExtraction);
                     else
-                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_FmPcdCcNode->p_GlblMask, p_FmPcdCcNode->userSizeOfExtraction);
+                        IO2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp, p_CcNode->ccKeySizeAccExtraction),
+                                   p_CcNode->p_GlblMask,
+                                   p_CcNode->userSizeOfExtraction);
                 }
             }
-            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_FmPcdCcNode->ccKeySizeAccExtraction);
+            IO2IOCpy32((void*)p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, p_CcNode->ccKeySizeAccExtraction);
         }
     }
 
     p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, j*FM_PCD_CC_AD_ENTRY_SIZE);
-    p_AdTableOldTmp = PTR_MOVE(p_FmPcdCcNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdTableOldTmp = PTR_MOVE(p_CcNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+
     IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     return E_OK;
 }
 
-static t_Error BuildNewNodeModifyNextEngine(t_Handle h_FmPcd ,t_Handle h_FmPcdCcNodeOrTree, uint16_t keyIndex,t_FmPcdCcNextEngineParams   *p_CcNextEngineParams, t_List *h_OldLst, t_List *h_NewLst,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeModifyNextEngine(t_Handle                            h_FmPcd,
+                                            t_Handle                            h_FmPcdCcNodeOrTree,
+                                            uint16_t                            keyIndex,
+                                            t_FmPcdCcNextEngineParams           *p_CcNextEngineParams,
+                                            t_List                              *h_OldLst,
+                                            t_List                              *h_NewLst,
+                                            t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalInfo)
 {
-
     t_Error      err = E_OK;
     uint32_t     requiredAction = 0;
     t_List       *p_Pos;
@@ -1704,71 +2389,73 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle h_FmPcd ,t_Handle h_FmPcdCc
     t_FmPcdCcTree *p_FmPcdCcTree = NULL;
 
     ASSERT_COND(p_CcNextEngineParams);
+
     /*check that new NIA is legal*/
     err = ValidateNextEngineParams(h_FmPcd, p_CcNextEngineParams);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /*update internal data structure for next engine per index (index - key)*/
-    memcpy(&p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].nextEngineParams,p_CcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+    memcpy(&p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams,p_CcNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
 
-#ifdef FM_PCD_CC_MANIP
     /*check that manip is legal and what requiredAction is necessary for this manip*/
-    if(p_CcNextEngineParams->h_Manip)
+    if (p_CcNextEngineParams->h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(p_CcNextEngineParams,&requiredAction);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
     }
-#endif /* FM_PCD_CC_MANIP */
 
-    if(!p_AdditionalInfo->tree)
+    if (!p_AdditionalInfo->tree)
     {
         p_FmPcdCcNode1 = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
         p_Ad = p_FmPcdCcNode1->h_AdTable;
-        if(p_FmPcdCcNode1->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode1->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
-#ifdef FM_PCD_CC_MANIP
-        if(p_FmPcdCcNode1->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip)
-            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode1->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip;
-#endif /* FM_PCD_CC_MANIP */
+
+        if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+        if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
+            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
     }
     else
     {
         p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
         p_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
-        if(p_FmPcdCcTree->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcTree->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
-#ifdef FM_PCD_CC_MANIP
-        if(p_FmPcdCcTree->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip)
-            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcTree->nextEngineAndRequiredAction[keyIndex].nextEngineParams.h_Manip;
-#endif /* FM_PCD_CC_MANIP */
+
+        if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            p_AdditionalInfo->h_NodeForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode;
+        if (p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
+            p_AdditionalInfo->h_ManipForRmv = p_FmPcdCcTree->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip;
+    }
+
+    if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
+        && p_CcNextEngineParams->h_Manip)
+    {
+        err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNextEngineParams->params.ccParams.h_CcNode);
+        if (err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
+
     ASSERT_COND(p_Ad);
     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
     ccNodeInfo.h_CcNode = PTR_MOVE(p_Ad, keyIndex * FM_PCD_CC_AD_ENTRY_SIZE);
     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo);
 
     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-    p_Ad = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
-                                         FM_PCD_CC_AD_ENTRY_SIZE,
-                                         FM_PCD_CC_AD_TABLE_ALIGN);
-
-    if(!p_Ad)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
-
+    p_Ad = GetNewAd(h_FmPcdCcNodeOrTree, p_AdditionalInfo->tree);
+    if (!p_Ad)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptor"));
     IOMemSet32((uint8_t *)p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
-    if(p_CcNextEngineParams)
+
+    if (p_CcNextEngineParams)
         NextStepAd(p_Ad,p_CcNextEngineParams, h_FmPcd);
     ccNodeInfo.h_CcNode = p_Ad;
     EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo);
 
-    p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction = requiredAction;
-
-    p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction = requiredAction;
+    p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction |= UPDATE_CC_WITH_TREE;
 
-    if(!p_AdditionalInfo->tree)
+    if (!p_AdditionalInfo->tree)
     {
         ASSERT_COND(p_FmPcdCcNode1);
         if(!LIST_IsEmpty(&p_FmPcdCcNode1->ccTreesLst))
@@ -1776,136 +2463,101 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle h_FmPcd ,t_Handle h_FmPcdCc
             LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode1->ccTreesLst)
             {
                 p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+
                 ASSERT_COND(p_CcNodeInformation->h_CcNode);
-                /*update the manipulation which has to be updated from parameters of the port*/
-                /*it's has to be updated with restrictions defined in the function*/
-                    err = FmPcdCcSetRequiredAction(p_FmPcdCcNode1->h_FmPcd, p_FmPcdCcNode1->shadowAction | p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],
-                                                   p_Ad, 1, p_CcNodeInformation->h_CcNode);
-                    if(err)
-                        RETURN_ERROR(MAJOR, err, (NO_MSG));
-                     err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd, NULL, NULL, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],1, p_Ad, TRUE, p_CcNodeInformation->index, p_CcNodeInformation->h_CcNode, TRUE);
-                    if(err)
-                        RETURN_ERROR(MAJOR, err, (NO_MSG));
+                /* Update the manipulation which has to be updated from parameters of the port
+                   it's has to be updated with restrictions defined in the function */
+
+                err = FmPcdCcSetRequiredAction(p_FmPcdCcNode1->h_FmPcd,
+                                               p_FmPcdCcNode1->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                                               &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                               p_Ad, 1, p_CcNodeInformation->h_CcNode);
+                if (err)
+                    RETURN_ERROR(MAJOR, err, (NO_MSG));
+
+                err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd, NULL, NULL, &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],1, p_Ad, TRUE, p_CcNodeInformation->index, p_CcNodeInformation->h_CcNode, TRUE);
+                if (err)
+                    RETURN_ERROR(MAJOR, err, (NO_MSG));
             }
         }
     }
     else
     {
        ASSERT_COND(p_FmPcdCcTree);
-       err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcTree->requiredAction | p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex].requiredAction, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],
-                                       p_Ad, 1, (t_Handle)p_FmPcdCcTree);
-        if(err)
+
+       err = FmPcdCcSetRequiredAction(h_FmPcd,
+                                      p_FmPcdCcTree->requiredAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                                      &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                      p_Ad,
+                                      1,
+                                      (t_Handle)p_FmPcdCcTree);
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
-         err = CcUpdateParam(h_FmPcd, NULL, NULL, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],1, p_Ad, TRUE, 0, (t_Handle)p_FmPcdCcTree, TRUE);
-        if(err)
+
+        err = CcUpdateParam(h_FmPcd, NULL, NULL, &p_AdditionalInfo->keyAndNextEngineParams[keyIndex], 1, p_Ad, TRUE, 0, (t_Handle)p_FmPcdCcTree, TRUE);
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
-    if(p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
+    if (p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
         p_AdditionalInfo->h_NodeForAdd = p_CcNextEngineParams->params.ccParams.h_CcNode;
+
     return E_OK;
 }
 
-static t_Handle BuildNewAd(t_FmPcdModifyCcKeyAdditionalParams   *p_FmPcdModifyCcKeyAdditionalParams,
-                           t_FmPcdCcNode                        *p_FmPcdCcNode,
-                           t_FmPcdCcNextEngineParams            *p_FmPcdCcNextEngineParams)
+static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode                *p_CrntMdfNode,
+                                                       t_List                       *h_OldLst,
+                                                       t_FmPcdCcNextEngineParams	**p_NextEngineParams)
 {
+    t_CcNodeInformation     *p_CcNodeInformation;
+    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfNode = NULL;
+    t_List                  *p_Pos;
+    int                     i = 0;
+    t_Handle                p_AdTablePtOnCrntCurrentMdfNode/*, p_AdTableNewModified*/;
+    t_CcNodeInformation     ccNodeInfo;
 
-    t_Handle        p_Ad;
-    t_FmPcdCcNode   *p_FmPcdCcNodeTmp;
-
-    p_Ad = (t_Handle)FM_MURAM_AllocMem(((t_FmPcd *)(p_FmPcdCcNode->h_FmPcd))->h_FmMuram,
-                                         FM_PCD_CC_AD_ENTRY_SIZE,
-                                         FM_PCD_CC_AD_TABLE_ALIGN);
-    if(!p_Ad)
+    LIST_FOR_EACH(p_Pos, &p_CrntMdfNode->ccPrevNodesLst)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM for AD"));
-        return NULL;
-    }
-    IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
+        p_NodePtrOnCurrentMdfNode = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
 
-    p_FmPcdCcNodeTmp = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
-    if(!p_FmPcdCcNodeTmp)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcNodeTmp"));
-        return NULL;
-    }
-    memset(p_FmPcdCcNodeTmp, 0, sizeof(t_FmPcdCcNode));
-
-    p_FmPcdCcNodeTmp->numOfKeys = p_FmPcdModifyCcKeyAdditionalParams->numOfKeys;
-    p_FmPcdCcNodeTmp->h_KeysMatchTable = p_FmPcdModifyCcKeyAdditionalParams->p_KeysMatchTableNew;
-    p_FmPcdCcNodeTmp->h_AdTable = p_FmPcdModifyCcKeyAdditionalParams->p_AdTableNew;
-
-    p_FmPcdCcNodeTmp->lclMask = p_FmPcdCcNode->lclMask;
-    p_FmPcdCcNodeTmp->parseCode = p_FmPcdCcNode->parseCode;
-    p_FmPcdCcNodeTmp->offset = p_FmPcdCcNode->offset;
-    p_FmPcdCcNodeTmp->prsArrayOffset = p_FmPcdCcNode->prsArrayOffset;
-    p_FmPcdCcNodeTmp->ctrlFlow = p_FmPcdCcNode->ctrlFlow;
-    p_FmPcdCcNodeTmp->ccKeySizeAccExtraction = p_FmPcdCcNode->ccKeySizeAccExtraction;
-    p_FmPcdCcNodeTmp->sizeOfExtraction = p_FmPcdCcNode->sizeOfExtraction;
-    p_FmPcdCcNodeTmp->glblMaskSize = p_FmPcdCcNode->glblMaskSize;
-    p_FmPcdCcNodeTmp->p_GlblMask = p_FmPcdCcNode->p_GlblMask;
-
-    if (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC)
-        FillAdOfTypeContLookup(p_Ad,
-                               p_FmPcdCcNode->h_FmPcd,
-                               p_FmPcdCcNodeTmp,
-#ifdef FM_PCD_CC_MANIP
-                               p_FmPcdCcNextEngineParams->h_Manip
-#else
-                               NULL
-#endif /* FM_PCD_CC_MANIP */
-                               );
-
-    XX_Free(p_FmPcdCcNodeTmp);
-
-    return p_Ad;
-}
-
-static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode *p_CrntMdfNode ,t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams, t_List  *h_OldLst, t_List  *h_NewLst)
-{
-    t_CcNodeInformation     *p_CcNodeInformation;
-    t_FmPcdCcNode           *p_NodePtrOnCurrentMdfNode = NULL;
-    t_List                  *p_Pos;
-    int                     i = 0;
-    t_Handle                p_AdTablePtOnCrntCurrentMdfNode, p_AdTableNewModified;
-    t_CcNodeInformation     ccNodeInfo;
-
-    LIST_FOR_EACH(p_Pos, &p_CrntMdfNode->ccPrevNodesLst)
-    {
-        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        p_NodePtrOnCurrentMdfNode = (t_FmPcdCcNode *)p_CcNodeInformation->h_CcNode;
         ASSERT_COND(p_NodePtrOnCurrentMdfNode);
-        /*search in the prev node which exact index points on this current modified node for getting AD */
+
+        /* Search in the previous node which exact index points on this current modified node for getting AD */
         for(i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
         {
-            if(p_NodePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if(p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if(p_NodePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if(p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
                 {
-                    p_AdTablePtOnCrntCurrentMdfNode = PTR_MOVE(p_NodePtrOnCurrentMdfNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+                    if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
+                        p_AdTablePtOnCrntCurrentMdfNode = p_CrntMdfNode->h_Ad;
+                    else
+                        p_AdTablePtOnCrntCurrentMdfNode = PTR_MOVE(p_NodePtrOnCurrentMdfNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
                     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo);
 
-                    p_AdTableNewModified = BuildNewAd(p_FmPcdModifyCcKeyAdditionalParams, p_CrntMdfNode, &p_NodePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams);
-                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                    ccNodeInfo.h_CcNode = p_AdTableNewModified;
-                    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo);
+                    if (!(*p_NextEngineParams))
+                        *p_NextEngineParams = &p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
                 }
             }
         }
+
         ASSERT_COND(i != p_NodePtrOnCurrentMdfNode->numOfKeys);
     }
 }
 
-static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode *p_CrntMdfNode ,t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams, t_List  *h_OldLst, t_List  *h_NewLst)
+static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode				*p_CrntMdfNode,
+                                                       t_List                       *h_OldLst,
+                                                       t_FmPcdCcNextEngineParams    **p_NextEngineParams)
 {
     t_CcNodeInformation     *p_CcNodeInformation;
     t_FmPcdCcTree           *p_TreePtrOnCurrentMdfNode = NULL;
     t_List                  *p_Pos;
     int                     i = 0;
-    t_Handle                p_AdTableTmp, p_AdTableTmp1;
+    t_Handle                p_AdTableTmp;
     t_CcNodeInformation     ccNodeInfo;
 
     LIST_FOR_EACH(p_Pos, &p_CrntMdfNode->ccTreeIdLst)
@@ -1914,75 +2566,98 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode *p_CrntMdfN
         p_TreePtrOnCurrentMdfNode = (t_FmPcdCcTree *)p_CcNodeInformation->h_CcNode;
 
         ASSERT_COND(p_TreePtrOnCurrentMdfNode);
-        /*search in the trees which exact index points on this current modified node for getting AD
-        */
+
+        /*search in the trees which exact index points on this current modified node for getting AD */
         for(i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
         {
-            if(p_TreePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if(p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if(p_TreePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if(p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
                 {
                     p_AdTableTmp = UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTableTmp;
                     EnqueueNodeInfoToRelevantLst(h_OldLst, &ccNodeInfo);
 
-                    p_AdTableTmp1 = BuildNewAd(p_FmPcdModifyCcKeyAdditionalParams, p_CrntMdfNode, &p_TreePtrOnCurrentMdfNode->nextEngineAndRequiredAction[i].nextEngineParams);
-                    memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                    ccNodeInfo.h_CcNode = p_AdTableTmp1;
-                    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo);
+                    if (!(*p_NextEngineParams))
+                        *p_NextEngineParams = &p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams;
                 }
+            }
         }
-    }
+
         ASSERT_COND(i == p_TreePtrOnCurrentMdfNode->numOfEntries);
      }
 }
 
-static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyIndex, t_Handle *h_Params, e_ModifyState modifyState, bool check, bool tree)
+static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle        h_FmPcdCcNodeOrTree,
+                                                                uint16_t        keyIndex,
+                                                                e_ModifyState   modifyState,
+                                                                bool            ttlCheck,
+                                                                bool            hashCheck,
+                                                                bool            tree)
 {
-    t_FmPcdModifyCcKeyAdditionalParams          *p_FmPcdModifyCcKeyAdditionalParams;
-    int                                         i = 0, j = 0;
-    bool                                        wasUpdate = FALSE;
-    t_FmPcdCcNode                               *p_FmPcdCcNode = NULL;
-    t_FmPcdCcTree                               *p_FmPcdCcTree;
-    uint16_t                                    numOfKeys;
-    t_FmPcdCcNextEngineAndRequiredActionParams  *p_NextEngineAndRequiredAction;
-
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNodeOrTree,E_INVALID_HANDLE);
-
-    p_NextEngineAndRequiredAction = (t_FmPcdCcNextEngineAndRequiredActionParams  *)XX_Malloc(sizeof(t_FmPcdCcNextEngineAndRequiredActionParams)*256);
-    memset(p_NextEngineAndRequiredAction, 0, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams) * 256);
+    t_FmPcdModifyCcKeyAdditionalParams  *p_FmPcdModifyCcKeyAdditionalParams;
+    int                                 i = 0, j = 0;
+    bool                                wasUpdate = FALSE;
+    t_FmPcdCcNode                       *p_CcNode = NULL;
+    t_FmPcdCcTree                       *p_FmPcdCcTree;
+    uint16_t                            numOfKeys;
+    t_FmPcdCcKeyAndNextEngineParams     *p_KeyAndNextEngineParams;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcdCcNodeOrTree, E_INVALID_HANDLE, NULL);
+
+    p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*256);
+    if (!p_KeyAndNextEngineParams)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Next engine and required action structure"));
+        return NULL;
+    }
+    memset(p_KeyAndNextEngineParams, 0, sizeof(t_FmPcdCcKeyAndNextEngineParams)*256);
 
-    if(!tree)
+    if (!tree)
     {
-        p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
-        numOfKeys = p_FmPcdCcNode->numOfKeys;
+        p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
+        numOfKeys = p_CcNode->numOfKeys;
 
-        /*node has to be pointed by another node or tree*/
-        if (!LIST_NumOfObjs(&p_FmPcdCcNode->ccPrevNodesLst) &&
-            !LIST_NumOfObjs(&p_FmPcdCcNode->ccTreeIdLst))
+        /* node has to be pointed by another node or tree */
+        if (!LIST_NumOfObjs(&p_CcNode->ccPrevNodesLst) &&
+            !LIST_NumOfObjs(&p_CcNode->ccTreeIdLst))
         {
-            XX_Free(p_NextEngineAndRequiredAction);
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be pointed by node or tree"));
+            XX_Free(p_KeyAndNextEngineParams);
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be pointed by node or tree"));
+            return NULL;
+        }
+
+        if(!LIST_NumOfObjs(&p_CcNode->ccTreesLst) ||
+           (LIST_NumOfObjs(&p_CcNode->ccTreesLst) != 1))
+        {
+            XX_Free(p_KeyAndNextEngineParams);
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be belonging to some tree and only to one tree"));
+            return NULL;
         }
-        if(!LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) ||
-            (LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) != 1))
+
+        memcpy(p_KeyAndNextEngineParams,
+               p_CcNode->keyAndNextEngineParams,
+               256 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+
+        if(ttlCheck)
         {
-            XX_Free(p_NextEngineAndRequiredAction);
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be belonging to some tree and only to one tree"));
+            if((p_CcNode->parseCode == CC_PC_FF_IPV4TTL) ||
+               (p_CcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT))
+            {
+                XX_Free(p_KeyAndNextEngineParams);
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for this operation"));
+                return NULL;
+            }
         }
-        memcpy(p_NextEngineAndRequiredAction,
-               p_FmPcdCcNode->nextEngineAndRequiredAction,
-               256 * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
 
-        if(check)
+        if(hashCheck)
         {
-            if((p_FmPcdCcNode->parseCode == CC_PC_FF_IPV4TTL) ||
-               (p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT) ||
-               (p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
+            if(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
-                XX_Free(p_NextEngineAndRequiredAction);
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for addKey, removeKey, modifyKey"));
+                XX_Free(p_KeyAndNextEngineParams);
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_GENERIC_IC_HASH_INDEXED can not be used for this operation"));
+                return NULL;
             }
         }
     }
@@ -1990,22 +2665,23 @@ static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyI
     {
         p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
         numOfKeys = p_FmPcdCcTree->numOfEntries;
-        memcpy(p_NextEngineAndRequiredAction,
-               p_FmPcdCcTree->nextEngineAndRequiredAction,
-               256 * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+        memcpy(p_KeyAndNextEngineParams,
+               p_FmPcdCcTree->keyAndNextEngineParams,
+               256 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
     }
 
     p_FmPcdModifyCcKeyAdditionalParams =
         (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
     if(!p_FmPcdModifyCcKeyAdditionalParams)
     {
-        XX_Free(p_NextEngineAndRequiredAction);
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of internal data structure FAILED"));
+        XX_Free(p_KeyAndNextEngineParams);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of internal data structure FAILED"));
+        return NULL;
     }
     memset(p_FmPcdModifyCcKeyAdditionalParams, 0, sizeof(t_FmPcdModifyCcKeyAdditionalParams));
 
     p_FmPcdModifyCcKeyAdditionalParams->h_CurrentNode = h_FmPcdCcNodeOrTree;
-    p_FmPcdModifyCcKeyAdditionalParams->keyIndex = keyIndex;
+    p_FmPcdModifyCcKeyAdditionalParams->savedKeyIndex = keyIndex;
 
     while(i < numOfKeys)
     {
@@ -2019,7 +2695,9 @@ static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyI
         }
         else
         {
-            memcpy(&p_FmPcdModifyCcKeyAdditionalParams->nextEngineAndRequiredAction[j],p_NextEngineAndRequiredAction+i, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+            memcpy(&p_FmPcdModifyCcKeyAdditionalParams->keyAndNextEngineParams[j],
+                   p_KeyAndNextEngineParams + i,
+                   sizeof(t_FmPcdCcKeyAndNextEngineParams));
             i++;
             j++;
         }
@@ -2033,49 +2711,81 @@ static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyI
             i++;
     }
 
-    memcpy(&p_FmPcdModifyCcKeyAdditionalParams->nextEngineAndRequiredAction[j],p_NextEngineAndRequiredAction+numOfKeys, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+    memcpy(&p_FmPcdModifyCcKeyAdditionalParams->keyAndNextEngineParams[j],
+           p_KeyAndNextEngineParams + numOfKeys,
+           sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
-    *h_Params = p_FmPcdModifyCcKeyAdditionalParams;
+    XX_Free(p_KeyAndNextEngineParams);
 
-    XX_Free(p_NextEngineAndRequiredAction);
-    return E_OK;
+    return p_FmPcdModifyCcKeyAdditionalParams;
 }
 
-static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode *p_FmPcdCcNode, t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams ,t_List *h_OldLst, t_List *h_NewLst)
+static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode *p_CcNode,
+                                                t_FmPcdModifyCcKeyAdditionalParams *p_FmPcdModifyCcKeyAdditionalParams,
+                                                t_List *h_OldLst,
+                                                t_List *h_NewLst)
 {
-    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccPrevNodesLst))
-        UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewLst);
+    t_FmPcdCcNextEngineParams   *p_NextEngineParams = NULL;
+    t_CcNodeInformation         ccNodeInfo = {0};
+    t_Handle                    h_NewAd;
+
+    /* Building a list of all action descriptors that point to the previous node */
+    if(!LIST_IsEmpty(&p_CcNode->ccPrevNodesLst))
+        UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
+
+    if(!LIST_IsEmpty(&p_CcNode->ccTreeIdLst))
+        UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
+
+    /* This node must be found as next engine of one of its previous nodes or trees*/
+    ASSERT_COND(p_NextEngineParams);
 
-    if(!LIST_IsEmpty(&p_FmPcdCcNode->ccTreeIdLst))
-        UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_FmPcdCcNode, p_FmPcdModifyCcKeyAdditionalParams, h_OldLst, h_NewLst);
+    /* Building a new action descriptor that points to the modified node */
+    h_NewAd = GetNewAd(p_CcNode, FALSE);
+    if(!h_NewAd)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+    IOMemSet32(h_NewAd, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    BuildNewAd(h_NewAd,
+               p_FmPcdModifyCcKeyAdditionalParams,
+               p_CcNode,
+               p_NextEngineParams);
+
+    ccNodeInfo.h_CcNode = h_NewAd;
+    EnqueueNodeInfoToRelevantLst(h_NewLst, &ccNodeInfo);
 
     return E_OK;
 }
 
 static void  FmPcdCcUpdateTreeOwner(t_FmPcdCcTree *p_FmPcdCcTree, bool add)
 {
+    uint32_t    intFlags = 0;
+
     ASSERT_COND(p_FmPcdCcTree);
 
-    if(add)
-        p_FmPcdCcTree->owners++;
+    intFlags = FmPcdCcTreeLock(p_FmPcdCcTree);
+
+    if (add)
+       p_FmPcdCcTree->owners++;
     else
     {
         ASSERT_COND(p_FmPcdCcTree->owners);
         p_FmPcdCcTree->owners--;
     }
+
+    FmPcdCcTreeUnlock(p_FmPcdCcTree, intFlags);
 }
 
-#ifdef FM_PCD_CC_MANIP
-static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_FmPcdCcNode)
+static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
 {
     t_Error err = E_OK;
     int     i = 0;
 
-    for(i = 0; i < p_FmPcdCcNode->numOfKeys; i++)
+    for(i = 0; i < p_CcNode->numOfKeys; i++)
     {
-        if(p_FmPcdCcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip)
+        if(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
         {
-            err = FmPcdManipCheckParamsWithCcNodeParams(p_FmPcdCcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip, (t_Handle)p_FmPcdCcNode);
+            err = FmPcdManipCheckParamsWithCcNodeParams(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip,
+                                                        (t_Handle)p_CcNode);
             if(err)
                 return err;
         }
@@ -2083,31 +2793,10 @@ static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_FmPcdCcNo
 
     return err;
 }
-#endif /* FM_PCD_CC_MANIP */
-
-static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
-                              t_Handle                         h_PcdParams,
-                              t_Handle                         h_FmPort,
-                              t_Handle                         h_FmTree,
-                              bool                             validate)
-{
-    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
-
-    return CcUpdateParam(h_FmPcd,
-                         h_PcdParams,
-                         h_FmPort,
-                         p_CcTree->nextEngineAndRequiredAction,
-                         p_CcTree->numOfEntries,
-                         UINT_TO_PTR(p_CcTree->ccTreeBaseAddr),
-                         validate,
-                         0,
-                         h_FmTree,
-                         FALSE);
-}
 
 static t_Error CheckParams(t_Handle             h_FmPcd,
                            t_FmPcdCcNodeParams  *p_CcNodeParam,
-                           t_FmPcdCcNode        *p_FmPcdCcNode,
+                           t_FmPcdCcNode        *p_CcNode,
                            bool                 *isKeyTblAlloc)
 {
     int                     tmp = 0;
@@ -2116,57 +2805,98 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     uint32_t                requiredAction = 0;
 
     err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
 
-#ifdef FM_PCD_CC_MANIP
-    if(p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
+    if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
         if(err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
-#endif /* FM_PCD_CC_MANIP */
 
-    memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams,&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, sizeof(t_FmPcdCcNextEngineParams));
-    p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].requiredAction = requiredAction;
+    memcpy(&p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams,
+           &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
+           sizeof(t_FmPcdCcNextEngineParams));
+
+    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction = requiredAction;
+
+    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
+    {
+        err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
+        if (err)
+            RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
 
-    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
         if(!p_KeyParams->p_Key)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_Key is not initialized"));
 
-
-       err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
+        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
         if(err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
-        err = UpdateGblMask(p_FmPcdCcNode,
-                            p_CcNodeParam->keysParams.keySize,
-                            p_KeyParams->p_Mask);
+        UpdateGblMask(p_CcNode,
+                      p_CcNodeParam->keysParams.keySize,
+                      p_KeyParams->p_Mask);
 
-#ifdef FM_PCD_CC_MANIP
-        if(p_KeyParams->ccNextEngineParams.h_Manip)
+        if (p_KeyParams->ccNextEngineParams.h_Manip)
         {
             err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
-            if(err)
+            if (err)
+                RETURN_ERROR(MAJOR, err, (NO_MSG));
+        }
+
+        /* Store 'key' parameters - key, mask (if passed by the user) */
+        memcpy(p_CcNode->keyAndNextEngineParams[tmp].key, p_KeyParams->p_Key, p_CcNodeParam->keysParams.keySize);
+
+        if (p_KeyParams->p_Mask)
+            memcpy(p_CcNode->keyAndNextEngineParams[tmp].mask,
+                   p_KeyParams->p_Mask,
+                   p_CcNodeParam->keysParams.keySize);
+        else
+            memset((void *)(p_CcNode->keyAndNextEngineParams[tmp].mask),
+                   0xFF,
+                   p_CcNodeParam->keysParams.keySize);
+
+        /* Store next engine parameters */
+        memcpy(&p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams,
+               &p_KeyParams->ccNextEngineParams,
+               sizeof(t_FmPcdCcNextEngineParams));
+
+        p_CcNode->keyAndNextEngineParams[tmp].requiredAction = requiredAction;
+
+        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+        {
+            err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+            if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
-#endif /* FM_PCD_CC_MANIP */
+    }
+
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if (p_CcNode->maxNumOfKeys < p_CcNode->numOfKeys)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Number of keys exceed the provided maximal number of keys"));
 
-        memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp],&p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
-        p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction = requiredAction;
+        if ((!p_CcNode->maskSupport) && (p_CcNode->glblMaskUpdated || p_CcNode->lclMask))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Mask support should be enabled, as it was required by the received keys parameters"));
     }
 
     *isKeyTblAlloc = TRUE;
+
     return E_OK;
 }
 
-static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(  t_Handle h_FmPcd,
-                                                    t_FmPcdCcNodeParams *p_CcNodeParam, t_FmPcdCcNode *p_FmPcdCcNode,
-                                                    bool *isKeyTblAlloc)
+static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(t_Handle             h_FmPcd,
+                                               t_FmPcdCcNodeParams  *p_CcNodeParam,
+                                               t_FmPcdCcNode        *p_CcNode,
+                                               bool                 *isKeyTblAlloc)
 {
     int                 tmp = 0;
     t_FmPcdCcKeyParams  *p_KeyParams;
@@ -2174,68 +2904,89 @@ static t_Error Ipv4TtlOrIpv6HopLimiCheckParams(  t_Handle h_FmPcd,
     uint8_t             key = 0x01;
     uint32_t            requiredAction = 0;
 
-    if(p_FmPcdCcNode->numOfKeys != 1 )
+    if (p_CcNode->numOfKeys != 1)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for IPV4TTL and IPV6_HOP_LIMIT has to be only 1 key - TTL = 1, otherwise it's Miss"));
 
     err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, ("For this node MissNextEngineParams are not valid"));
 
-#ifdef FM_PCD_CC_MANIP
-    if(p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
+    if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
-#endif /* FM_PCD_CC_MANIP */
 
-    memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].nextEngineParams, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, sizeof(t_FmPcdCcNextEngineParams));
-    p_FmPcdCcNode->nextEngineAndRequiredAction[p_FmPcdCcNode->numOfKeys].requiredAction = requiredAction;
+    memcpy(&p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, sizeof(t_FmPcdCcNextEngineParams));
+
+    p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].requiredAction = requiredAction;
 
-    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
     {
-        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
-        if(p_KeyParams->p_Mask)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("If node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Mask can not be initialized"));
-        if(memcmp(p_KeyParams->p_Key, &key, 1) != 0)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("If node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"));
-        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
-        if(err)
+        err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
+    }
 
-#ifdef FM_PCD_CC_MANIP
-    if(p_KeyParams->ccNextEngineParams.h_Manip)
+    if (p_CcNodeParam->keysParams.maxNumOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT 'maxNumOfKeys' must be zero"));
+
+    for(tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
-        err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
-        if(err)
+        p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+
+        if (p_KeyParams->p_Mask)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Mask can not be initialized"));
+
+        if (memcmp(p_KeyParams->p_Key, &key, 1) != 0)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT p_Key has to be 1"));
+
+        err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
-    }
-#endif /* FM_PCD_CC_MANIP */
 
-        memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams, &p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
-        p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction = requiredAction;
+        if (p_KeyParams->ccNextEngineParams.h_Manip)
+        {
+            err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
+            if (err)
+                RETURN_ERROR(MAJOR, err, (NO_MSG));
+        }
+
+        /* Store 'key' parameters - key (fixed to 0x01), key size of 1 byte and full mask */
+        p_CcNode->keyAndNextEngineParams[tmp].key[0]  = key;
+        p_CcNode->keyAndNextEngineParams[tmp].mask[0] = 0xFF;
+
+        /* Store NextEngine parameters */
+        memcpy(&p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams, &p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+
+        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+        {
+            err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+            if (err)
+                RETURN_ERROR(MAJOR, err, (NO_MSG));
+        }
+        p_CcNode->keyAndNextEngineParams[tmp].requiredAction = requiredAction;
     }
 
     *isKeyTblAlloc = FALSE;
+
     return E_OK;
 }
 
-static t_Error IcHashIndexedCheckParams(t_Handle h_FmPcd,
-                                            t_FmPcdCcNodeParams *p_CcNodeParam,
-                                            t_FmPcdCcNode *p_FmPcdCcNode,
-                                            /*uint16_t *ccInfo,*/
-                                            /*t_List *ccNextDifferentNodesLst,*/
-                                            bool *isKeyTblAlloc)
+static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
+                                        t_FmPcdCcNodeParams *p_CcNodeParam,
+                                        t_FmPcdCcNode       *p_CcNode,
+                                        bool                *isKeyTblAlloc)
 {
     int                 tmp = 0, countOnes = 0;
     t_FmPcdCcKeyParams  *p_KeyParams;
     t_Error             err;
     uint16_t            glblMask = p_CcNodeParam->extractCcParams.extractNonHdr.icIndxMask;
     uint16_t            countMask = (uint16_t)(glblMask >> 4);
-#ifdef FM_PCD_CC_MANIP
-    uint32_t            requiredAction;
-#endif /* FM_PCD_CC_MANIP */
+    uint32_t            requiredAction = 0;
 
     if (glblMask & 0x000f)
        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("icIndxMask has to be with last nibble 0"));
@@ -2246,38 +2997,51 @@ static t_Error IcHashIndexedCheckParams(t_Handle h_FmPcd,
         countMask=(uint16_t)(countMask>>1);
     }
 
-    if (!POWER_OF_2(p_FmPcdCcNode->numOfKeys))
+    if (p_CcNodeParam->keysParams.maxNumOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be set to 0"));
+
+    if (!POWER_OF_2(p_CcNode->numOfKeys))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED numOfKeys has to be powerOfTwo"));
-    if (p_FmPcdCcNode->numOfKeys != ((uint32_t)1<<countOnes ))
+
+    if (p_CcNode->numOfKeys != ((uint32_t)1<<countOnes ))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED numOfKeys has to be powerOfTwo"));
 
     err = ValidateNextEngineParams(h_FmPcd, &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss);
     if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
         RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
 
-    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    for(tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
+
         if(p_KeyParams->p_Mask || p_KeyParams->p_Key)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
 
         if((glblMask & (tmp * 16)) == (tmp * 16))
         {
             err = ValidateNextEngineParams(h_FmPcd, &p_KeyParams->ccNextEngineParams);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, ("This index has to be initialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask "));
 
-#ifdef FM_PCD_CC_MANIP
-            if(p_KeyParams->ccNextEngineParams.h_Manip)
+            if (p_KeyParams->ccNextEngineParams.h_Manip)
             {
                 err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
-                if(err)
+                if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
-                p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction = requiredAction;
+                p_CcNode->keyAndNextEngineParams[tmp].requiredAction = requiredAction;
             }
-#endif /* FM_PCD_CC_MANIP */
 
-            memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams,&p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
+            memcpy(&p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams,
+                   &p_KeyParams->ccNextEngineParams,
+                   sizeof(t_FmPcdCcNextEngineParams));
+
+            if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+                && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+            {
+                err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+                if (err)
+                    RETURN_ERROR(MAJOR, err, (NO_MSG));
+            }
         }
         else
         {
@@ -2286,396 +3050,773 @@ static t_Error IcHashIndexedCheckParams(t_Handle h_FmPcd,
                 RETURN_ERROR(MAJOR, err, ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
         }
     }
+
     *isKeyTblAlloc = FALSE;
-    memcpy(PTR_MOVE(p_FmPcdCcNode->p_GlblMask, 2), &glblMask, 2);
+    memcpy(PTR_MOVE(p_CcNode->p_GlblMask, 2), &glblMask, 2);
 
     return E_OK;
 }
 
-t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
+                                         t_Handle                    h_FmPcdCcNode,
+                                         uint16_t                    keyIndex,
+                                         t_FmPcdCcNextEngineParams   *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdCcTree                       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                             *p_FmPcd;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
     t_Error                             err = E_OK;
-    uint16_t                            keyIndex;
-    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
 
-    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode,E_INVALID_HANDLE);
 
-    if(grpId >= p_FmPcdCcTree->numOfGrps)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+    if (keyIndex >= p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
 
-    if(index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
+    if ((p_CcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
 
-    keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
-    err =  ModifyKeyCommonPart1(h_FmPcdCcTree, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, TRUE, TRUE);
-    if(err)
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    p_ModifyKeyParams =  ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, FALSE);
+    if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
-    p_ModifyKeyParams->tree = TRUE;
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+            return ERROR_CODE(E_BUSY);
+    }
 
-    err = BuildNewNodeModifyNextEngine (h_FmPcd, h_FmPcdCcTree, keyIndex,p_FmPcdCcNextEngineParams, h_OldLst, h_NewLst, p_ModifyKeyParams);
-    if(err)
+    err = BuildNewNodeModifyNextEngine (h_FmPcd,
+                                        p_CcNode,
+                                        keyIndex,
+                                        p_FmPcdCcNextEngineParams,
+                                        &h_OldPointersLst,
+                                        &h_NewPointersLst,
+                                        p_ModifyKeyParams);
+    if (err)
     {
         XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
-    return E_OK;
 
-}
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
 
-t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
-{
+    if (p_CcNode->maxNumOfKeys)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
 
-    t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
-    t_Error                             err = E_OK;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    return err;
+}
 
-    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("impossible to remove key when numOfKeys <= keyIndex"));
+static t_Error FindKeyIndex(t_Handle    h_CcNode,
+                            uint8_t     keySize,
+                            uint8_t     *p_Key,
+                            uint8_t     *p_Mask,
+                            uint16_t    *p_KeyIndex)
+{
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint8_t         tmpMask[FM_PCD_MAX_SIZE_OF_KEY];
+    uint16_t        i;
 
-    if(!p_FmPcdCcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
+    ASSERT_COND(p_KeyIndex);
 
-    if(p_FmPcdCcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is diferent from one which was assigned to the node in the Init time"));
+    if (keySize != p_CcNode->userSizeOfExtraction)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Key size doesn't match the extraction size of the node"));
 
-    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_REMOVE, TRUE, FALSE);
-    if(err)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    /* If a user didn't passed a mask for this key, we'll look for full extraction mask */
+    if (!p_Mask)
+        memset(tmpMask, 0xFF, keySize);
 
-    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
-    err = BuildNewNodeRemoveKey (p_FmPcdCcNode, keyIndex, p_ModifyKeyParams);
-    if(err)
+    for(i = 0 ; i < p_CcNode->numOfKeys; i++)
     {
-        XX_Free(p_ModifyKeyParams);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        /* Comparing received key */
+        if (memcmp(p_Key, p_CcNode->keyAndNextEngineParams[i].key, keySize) == 0)
+        {
+            if (p_Mask)
+            {
+                /* If a user passed a mask for this key, it must match to the existing key's mask for a correct match */
+                if (memcmp(p_Mask, p_CcNode->keyAndNextEngineParams[i].mask, keySize) == 0)
+                {
+                    *p_KeyIndex = i;
+                    return E_OK;
+                }
+            }
+            else
+            {
+                /* If a user didn't passed a mask for this key, checking if the existing key's mask is full extraction */
+                if (memcmp(tmpMask, p_CcNode->keyAndNextEngineParams[i].mask, keySize) == 0)
+                {
+                    *p_KeyIndex = i;
+                    return E_OK;
+                }
+            }
+        }
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_FmPcdCcNode, p_ModifyKeyParams, h_OldLst, h_NewLst);
-    if(err)
-    {
-        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
-        XX_Free(p_ModifyKeyParams);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+    return E_NOT_FOUND;
+}
 
-    return E_OK;
 
-}
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
 
-t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst, t_List *h_NewLst,t_Handle *h_AdditionalParams)
+t_CcNodeInformation* FmPcdCcFindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info)
 {
-    t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_Error                             err = E_OK;
-    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    t_CcNodeInformation *p_CcInformation;
+    t_List              *p_Pos;
+    uint32_t            intFlags;
 
-    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+    intFlags = XX_DisableAllIntr();
 
-    if((p_FmPcdCcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
+    {
+        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcInformation->h_CcNode);
+        if(p_CcInformation->h_CcNode == h_Info)
+        {
+            XX_RestoreAllIntr(intFlags);
+            return p_CcInformation;
+        }
+    }
 
-    if(keySize != p_FmPcdCcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size for ModifyKey has to be the same as defined in SetNode"));
+    XX_RestoreAllIntr(intFlags);
 
-    if(p_FmPcdCcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is diferent from one which was assigned to the node in the Init time"));
+    return NULL;
+}
 
-    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, TRUE, FALSE);
-    if(err)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+void FmPcdCcDequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info)
+{
+    t_CcNodeInformation *p_CcInformation = NULL;
+    uint32_t            intFlags;
+    t_List              *p_Pos;
 
-    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+    intFlags = XX_DisableAllIntr();
 
-    err = BuildNewNodeModifyKey (p_FmPcdCcNode, keyIndex, p_Key, p_Mask, p_ModifyKeyParams);
-    if(err)
+    if (LIST_IsEmpty(p_List))
     {
-        XX_Free(p_ModifyKeyParams);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        XX_RestoreAllIntr(intFlags);
+        return;
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_FmPcdCcNode, p_ModifyKeyParams, h_OldLst, h_NewLst);
-    if(err)
+    for (p_Pos = LIST_FIRST(p_List); p_Pos != (p_List); p_Pos = LIST_NEXT(p_Pos))
     {
-        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
-        XX_Free(p_ModifyKeyParams);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        p_CcInformation = CC_NODE_F_OBJECT(p_Pos);
+        ASSERT_COND(p_CcInformation->h_CcNode);
+        if (p_CcInformation->h_CcNode == h_Info)
+            break;
     }
-    return E_OK;
-}
-
 
-t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint16_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams)
-{
-    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_Error                         err = E_OK;
-    t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    if (p_CcInformation)
+        LIST_DelAndInit(&p_CcInformation->node);
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_HANDLE);
+    XX_RestoreAllIntr(intFlags);
+}
 
-    if(keyIndex >= p_FmPcdCcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
+                          t_Handle  h_FmTree,
+                          t_Handle  h_NetEnv,
+                          t_Handle  h_IpReassemblyManip,
+                          bool      schemes)
+{
+    t_FmPcdCcTree               *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+    t_FmPcdCcNextEngineParams   nextEngineParams;
+    t_NetEnvParams              netEnvParams;
+    t_Handle                    h_Ad;
+    bool                        isIpv6Present, isIpv4Present;
+    uint8_t                     ipv4GroupId, ipv6GroupId;
+    t_Error                     err;
 
-    if((p_FmPcdCcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+    ASSERT_COND(p_FmPcdCcTree);
 
-    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, FALSE, FALSE);
-    if(err)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    if (p_FmPcdCcTree->numOfEntries > (FM_PCD_MAX_NUM_OF_CC_GROUPS-2))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("need two free entries for IPR"));
 
-    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+    memset(&nextEngineParams, 0, sizeof(t_FmPcdCcNextEngineParams));
+    memset(&netEnvParams, 0, sizeof(t_NetEnvParams));
 
-    err = BuildNewNodeModifyNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex,p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer, p_ModifyKeyParams);
+    h_Ad = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
+    isIpv4Present = FmPcdManipIsIpPresent(h_FmPcd, p_FmPcdCcTree->netEnvId, FALSE);
+    isIpv6Present = FmPcdManipIsIpPresent(h_FmPcd, p_FmPcdCcTree->netEnvId, TRUE);
+    netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
+    netEnvParams.numOfDistinctionUnits = 0;
+    err = PcdGetUnitsVector(h_FmPcd, &netEnvParams);
     if(err)
-    {
-        XX_Free(p_ModifyKeyParams);
         RETURN_ERROR(MAJOR, err, NO_MSG);
+    nextEngineParams.nextEngine = e_FM_PCD_DONE;
+    nextEngineParams.h_Manip = h_IpReassemblyManip;
+    if (isIpv6Present)
+    {
+        ipv6GroupId = p_FmPcdCcTree->numOfGrps++;
+        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].totalBitsMask = netEnvParams.vector;
+        p_FmPcdCcTree->fmPcdGroupParam[ipv6GroupId].baseGroupEntry = p_FmPcdCcTree->numOfEntries++;
+        if (schemes)
+            FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, FALSE, ipv6GroupId);
+        NextStepAd(PTR_MOVE(h_Ad, ipv6GroupId * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
+    }
+    if (isIpv4Present)
+    {
+        ipv4GroupId = p_FmPcdCcTree->numOfGrps++;
+        p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].totalBitsMask = netEnvParams.vector;
+        p_FmPcdCcTree->fmPcdGroupParam[ipv4GroupId].baseGroupEntry = p_FmPcdCcTree->numOfEntries++;
+        if (schemes)
+            FmPcdManipBuildIpReassmScheme(h_FmPcd, h_NetEnv, p_FmPcdCcTree, h_IpReassemblyManip, TRUE, ipv4GroupId);
+        NextStepAd(PTR_MOVE(h_Ad, ipv4GroupId * FM_PCD_CC_AD_ENTRY_SIZE), &nextEngineParams, h_FmPcd);
     }
+    p_FmPcdCcTree->h_IpReassemblyManip = h_IpReassemblyManip;
     return E_OK;
 }
 
-t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams)
+
+t_Handle FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree)
 {
-    t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_Error                         err = E_OK;
-    uint16_t                         keyIndex;
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+
+    ASSERT_COND(p_FmPcdCcTree);
+
+    return p_FmPcdCcTree->h_FmPcdCcSavedManipParams;
+}
+
+void   FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams)
+{
+    t_FmPcdCcTree *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmTree;
+
+    ASSERT_COND(p_FmPcdCcTree);
+
+    p_FmPcdCcTree->h_FmPcdCcSavedManipParams = h_SavedManipParams;
+}
+
+uint8_t FmPcdCcGetParseCode(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_CcNode);
+
+    return p_CcNode->parseCode;
+}
+
+uint8_t FmPcdCcGetOffset(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_CcNode);
+
+    return p_CcNode->offset;
+}
+
+uint16_t FmPcdCcGetNumOfKeys(t_Handle h_CcNode)
+{
+    t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    ASSERT_COND(p_CcNode);
+
+    return p_CcNode->numOfKeys;
+}
+
+void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo)
+{
+    t_CcNodeInformation *p_CcInformation;
+    uint32_t            intFlags;
+
+    p_CcInformation = (t_CcNodeInformation *)XX_Malloc(sizeof(t_CcNodeInformation));
+
+    if (p_CcInformation)
+    {
+        memset(p_CcInformation, 0, sizeof(t_CcNodeInformation));
+        memcpy(p_CcInformation, p_CcInfo, sizeof(t_CcNodeInformation));
+        INIT_LIST(&p_CcInformation->node);
+
+        intFlags = XX_DisableAllIntr();
+        LIST_AddToTail(&p_CcInformation->node, p_List);
+        XX_RestoreAllIntr(intFlags);
+    }
+    else
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("CC Node Information"));
+}
+
+t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
+                                         t_Handle                   h_FmPcdCcTree,
+                                         uint8_t                    grpId,
+                                         uint8_t                    index,
+                                         t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcdCcTree                       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
+    t_FmPcd                             *p_FmPcd;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    uint16_t                            keyIndex;
     t_FmPcdModifyCcKeyAdditionalParams *p_ModifyKeyParams;
+    t_Error                             err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode,E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((grpId <= 7),E_INVALID_VALUE);
 
-    keyIndex = p_FmPcdCcNode->numOfKeys;
+    if (grpId >= p_FmPcdCcTree->numOfGrps)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
 
-    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, TRUE, FALSE);
-    if(err)
+    if (index >= p_FmPcdCcTree->fmPcdGroupParam[grpId].numOfEntriesInGroup)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("index > numOfEntriesInGroup"));
+
+    p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index);
+
+    p_ModifyKeyParams = ModifyKeyCommonPart1(p_FmPcdCcTree, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, TRUE);
+    if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+    p_ModifyKeyParams->tree = TRUE;
 
-    err = BuildNewNodeModifyNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex,p_FmPcdCcNextEngineParams, h_OldPointer, h_NewPointer, p_ModifyKeyParams);
+    err = BuildNewNodeModifyNextEngine(p_FmPcd,
+                                       p_FmPcdCcTree,
+                                       keyIndex,
+                                       p_FmPcdCcNextEngineParams,
+                                       &h_OldPointersLst,
+                                       &h_NewPointersLst,
+                                       p_ModifyKeyParams);
     if(err)
     {
         XX_Free(p_ModifyKeyParams);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    return E_OK;
+    return DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+
 }
 
-t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
+                         t_Handle   h_FmPcdCcNode,
+                         uint16_t   keyIndex)
 {
-    t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
+    t_FmPcd                             *p_FmPcd;
     t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    bool                                useShadowStructs = FALSE;
     t_Error                             err = E_OK;
 
-    if(keyIndex > p_FmPcdCcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+    if (keyIndex >= p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("impossible to remove key when numOfKeys <= keyIndex"));
 
-    if((p_FmPcdCcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
+    if (!p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
 
-    if(keySize != p_FmPcdCcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step."));
+    if (p_CcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    if(p_FmPcdCcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is diferent from one which was assigned to the node in the Init time"));
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
-    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_ADD, TRUE, FALSE);
-    if(err)
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_REMOVE, TRUE, TRUE, FALSE);
+    if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
-    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_ModifyKeyParams, TRUE);
-    if(err)
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+            return ERROR_CODE(E_BUSY);
+
+        useShadowStructs = TRUE;
+    }
+
+    err = BuildNewNodeRemoveKey(p_CcNode, keyIndex, p_ModifyKeyParams);
+    if (err)
     {
         XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_FmPcdCcNode, p_ModifyKeyParams, h_OldLst, h_NewLst);
-                if(err)
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
+                                           p_ModifyKeyParams,
+                                           &h_OldPointersLst,
+                                           &h_NewPointersLst);
+    if (err)
     {
         ReleaseNewNodeCommonPart(p_ModifyKeyParams);
         XX_Free(p_ModifyKeyParams);
-                    RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    return E_OK;
+    err = DoDynamicChange(p_FmPcd,
+                          &h_OldPointersLst,
+                          &h_NewPointersLst,
+                          p_ModifyKeyParams,
+                          useShadowStructs);
+
+    if (p_CcNode->maxNumOfKeys)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+
+    return err;
 }
 
-t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
+                         t_Handle   h_FmPcdCcNode,
+                         uint16_t   keyIndex,
+                         uint8_t    keySize,
+                         uint8_t    *p_Key,
+                         uint8_t    *p_Mask)
 {
-    t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                             *p_FmPcd;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
     t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    uint16_t                            tmpKeyIndex;
+    bool                                useShadowStructs = FALSE;
     t_Error                             err = E_OK;
 
-    if(keyIndex > p_FmPcdCcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previousely cleared last index + 1"));
+    if (keyIndex >= p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
 
-    if((p_FmPcdCcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
+    if ((p_CcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfKeys with new key can not be larger than 255"));
 
-    if(keySize != p_FmPcdCcNode->userSizeOfExtraction)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
+    if (keySize != p_CcNode->userSizeOfExtraction)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size for ModifyKey has to be the same as defined in SetNode"));
 
-    if(p_FmPcdCcNode->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is diferent from one which was assigned to the node in the Init time"));
+    if (p_CcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    err =  ModifyKeyCommonPart1(p_FmPcdCcNode, keyIndex, h_AdditionalParams, e_MODIFY_STATE_CHANGE, TRUE, FALSE);
-    if(err)
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if ((p_CcNode->numOfKeys + 1) > p_CcNode->maxNumOfKeys)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
+
+        if ((!p_CcNode->maskSupport) && (p_Mask))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("mask support was not enabled for this node initialization time"));
+    }
+
+    err = FindKeyIndex(h_FmPcdCcNode,
+                       keySize,
+                       p_Key,
+                       p_Mask,
+                       &tmpKeyIndex);
+    if (err != E_NOT_FOUND)
+        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
+                     ("The received key and mask pair was already found in the match table of the provided node"));
+
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
+    if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    p_ModifyKeyParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_AdditionalParams;
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+            return ERROR_CODE(E_BUSY);
+
+        useShadowStructs = TRUE;
+    }
 
-    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd, p_FmPcdCcNode, keyIndex, p_FmPcdCcKeyParams, p_ModifyKeyParams, FALSE);
-    if(err)
+    err = BuildNewNodeModifyKey(p_CcNode,
+                                keyIndex,
+                                p_Key,
+                                p_Mask,
+                                p_ModifyKeyParams);
+    if (err)
     {
-        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
         XX_Free(p_ModifyKeyParams);
-                        RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = UpdatePtrWhichPointOnCrntMdfNode(p_FmPcdCcNode, p_ModifyKeyParams, h_OldLst, h_NewLst);
-    if(err)
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
+                                           p_ModifyKeyParams,
+                                           &h_OldPointersLst,
+                                           &h_NewPointersLst);
+    if (err)
     {
         ReleaseNewNodeCommonPart(p_ModifyKeyParams);
         XX_Free(p_ModifyKeyParams);
-                        RETURN_ERROR(MAJOR, err, NO_MSG);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    return E_OK;
+    err = DoDynamicChange(p_FmPcd,
+                          &h_OldPointersLst,
+                          &h_NewPointersLst,
+                          p_ModifyKeyParams,
+                          useShadowStructs);
+
+    if (p_CcNode->maxNumOfKeys)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+
+    return err;
 }
 
-t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_List *h_FmPcdNewPointersLst, uint16_t numOfGoodChanges, t_Handle *h_Params)
+t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
+                                             t_Handle                   h_FmPcdCcNode,
+                                             t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcdModifyCcKeyAdditionalParams *p_CcNewModifyAdditionalParams = (t_FmPcdModifyCcKeyAdditionalParams *)*h_Params;
-    t_List                          *p_Pos;
-    t_Error                         err = E_OK;
-    t_CcNodeInformation             ccNodeInfo, *p_CcNodeInformation;
-    t_Handle                        h_Muram;
-    t_FmPcdCcNode                   *p_FmPcdCcNextNode;
-    t_List                          *p_UpdateLst;
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                             *p_FmPcd;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    uint16_t                            keyIndex;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    t_Error                             err = E_OK;
 
-    UNUSED(numOfGoodChanges);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode,E_INVALID_VALUE);
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_CcNewModifyAdditionalParams->h_CurrentNode,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdOldPointersLst,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_FmPcdNewPointersLst,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdOldPointersLst)),E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR((numOfGoodChanges == LIST_NumOfObjs(h_FmPcdNewPointersLst)),E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR((LIST_NumOfObjs(h_FmPcdOldPointersLst) == LIST_NumOfObjs(h_FmPcdNewPointersLst)),E_INVALID_STATE);
+    keyIndex = p_CcNode->numOfKeys;
+
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
-    /*we don't update subtree of the new node with new tree because it was done in the previose stage*/
-    if(p_CcNewModifyAdditionalParams->h_NodeForAdd)
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    p_ModifyKeyParams =  ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, TRUE, FALSE);
+    if (!p_ModifyKeyParams)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    if (p_CcNode->maxNumOfKeys)
     {
-        p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNewModifyAdditionalParams->h_NodeForAdd;
-        if(!p_CcNewModifyAdditionalParams->tree)
-            p_UpdateLst = &p_FmPcdCcNextNode->ccPrevNodesLst;
-        else
-            p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
-        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst, p_CcNewModifyAdditionalParams->h_CurrentNode);
-        if(p_CcNodeInformation)
-            p_CcNodeInformation->index++;
-        else
-        {
-            memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-            ccNodeInfo.h_CcNode = (t_Handle)p_CcNewModifyAdditionalParams->h_CurrentNode;
-            ccNodeInfo.index = 1;
-            EnqueueNodeInfoToRelevantLst(p_UpdateLst, &ccNodeInfo);
-        }
+        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+            return ERROR_CODE(E_BUSY);
     }
 
-     if(p_CcNewModifyAdditionalParams->h_NodeForRmv)
+    err = BuildNewNodeModifyNextEngine (h_FmPcd,
+                                        p_CcNode,
+                                        keyIndex,
+                                        p_FmPcdCcNextEngineParams,
+                                        &h_OldPointersLst,
+                                        &h_NewPointersLst,
+                                        p_ModifyKeyParams);
+    if (err)
     {
-        p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNewModifyAdditionalParams->h_NodeForRmv;
-        if(!p_CcNewModifyAdditionalParams->tree)
-        {
-            p_UpdateLst = &p_FmPcdCcNextNode->ccPrevNodesLst;
-            while (!LIST_IsEmpty(&p_FmPcdCcNextNode->ccTreesLst))
-            {
-                p_Pos = LIST_NEXT(&p_FmPcdCcNextNode->ccTreesLst);
-                p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-                ASSERT_COND(p_CcNodeInformation->h_CcNode);
-                err = FmPcdCcSetRequiredAction(h_FmPcd,
-                                               UPDATE_CC_WITH_DELETE_TREE,
-                                               &((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction[p_CcNewModifyAdditionalParams->keyIndex],
-                                               PTR_MOVE(((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->h_AdTable, p_CcNewModifyAdditionalParams->keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                               1,
-                                               p_CcNodeInformation->h_CcNode);
-            }
-        }
-        else
-        {
-            p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
-            err =  FmPcdCcSetRequiredAction(h_FmPcd,
-                                            UPDATE_CC_WITH_DELETE_TREE,
-                                            &((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction[p_CcNewModifyAdditionalParams->keyIndex],
-                                            UINT_TO_PTR(((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->ccTreeBaseAddr + p_CcNewModifyAdditionalParams->keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                            1,
-                                            p_CcNewModifyAdditionalParams->h_CurrentNode);
-        }
-        if(err)
-            return err;
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 
-        /*we remove from the subtree of the removed node tree because it wasn't done in the previous stage*/
-        /*update ccPrevNodesLst or ccTreeIdLst of the removed node*/
-        /*update of the nodeOwner*/
-        p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst, p_CcNewModifyAdditionalParams->h_CurrentNode);
-        ASSERT_COND(p_CcNodeInformation);
-        ASSERT_COND(p_CcNodeInformation->index);
-        p_CcNodeInformation->index--;
-        if(p_CcNodeInformation->index == 0)
-           DequeueNodeInfoFromRelevantLst(p_UpdateLst,p_CcNewModifyAdditionalParams->h_CurrentNode);
-        UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
+    err = DoDynamicChange(p_FmPcd, &h_OldPointersLst, &h_NewPointersLst, p_ModifyKeyParams, FALSE);
+
+    if (p_CcNode->maxNumOfKeys)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+
+    return err;
+}
+
+t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
+                      t_Handle              h_FmPcdCcNode,
+                      uint16_t              keyIndex,
+                      uint8_t               keySize,
+                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+{
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                             *p_FmPcd;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    bool                                useShadowStructs = FALSE;
+    t_Error                             err = E_OK;
+
+    if (keyIndex > p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+
+    if ((p_CcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys can not be larger than 255"));
+
+    if (keySize != p_CcNode->userSizeOfExtraction)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step."));
+
+    if (p_CcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
+
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if ((p_CcNode->numOfKeys + 1) > p_CcNode->maxNumOfKeys)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
+
+        if ((!p_CcNode->maskSupport) && (p_FmPcdCcKeyParams->p_Mask))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("mask support was not enabled for this node initialization time"));
+    }
+
+    err = FindKeyIndex(h_FmPcdCcNode,
+                       keySize,
+                       p_FmPcdCcKeyParams->p_Key,
+                       p_FmPcdCcKeyParams->p_Mask,
+                       &keyIndex);
+    if (err != E_NOT_FOUND)
+        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
+                     ("The received key and mask pair was already found in the match table of the provided node"));
+
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode,
+                                             keyIndex,
+                                             e_MODIFY_STATE_ADD,
+                                             TRUE,
+                                             TRUE,
+                                             FALSE);
+    if (!p_ModifyKeyParams)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    if (p_CcNode->maxNumOfKeys)
+    {
+        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+            return ERROR_CODE(E_BUSY);
+
+        useShadowStructs = TRUE;
+    }
+
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
+                                                 p_CcNode,
+                                                 keyIndex,
+                                                 p_FmPcdCcKeyParams,
+                                                 p_ModifyKeyParams,
+                                                 TRUE);
+    if (err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
+                                           p_ModifyKeyParams,
+                                           &h_OldPointersLst,
+                                           &h_NewPointersLst);
+    if (err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-#ifdef FM_PCD_CC_MANIP
-    if(p_CcNewModifyAdditionalParams->h_ManipForRmv)
-        FmPcdManipUpdateOwner(p_CcNewModifyAdditionalParams->h_ManipForRmv, FALSE);
-#endif /* FM_PCD_CC_MANIP */
+    err = DoDynamicChange(p_FmPcd,
+                          &h_OldPointersLst,
+                          &h_NewPointersLst,
+                          p_ModifyKeyParams,
+                          useShadowStructs);
+
+    if (p_CcNode->maxNumOfKeys)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+
+    return err;
+}
+
+t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
+                                      t_Handle              h_FmPcdCcNode,
+                                      uint16_t              keyIndex,
+                                      uint8_t               keySize,
+                                      t_FmPcdCcKeyParams    *p_FmPcdCcKeyParams)
+{
+    t_FmPcdCcNode                       *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_FmPcd                             *p_FmPcd;
+    t_List                              h_OldPointersLst, h_NewPointersLst;
+    t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
+    uint16_t                            tmpKeyIndex;
+    bool                                useShadowStructs = FALSE;
+    t_Error                             err = E_OK;
+
+    if (keyIndex > p_CcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+
+    if (keySize != p_CcNode->userSizeOfExtraction)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
 
-    h_Muram = FmPcdGetMuramHandle(h_FmPcd);
-    ASSERT_COND(h_Muram);
+    if (p_CcNode->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
-    /*we release new AD which was allocated and updated for copy from to actual AD*/
-    LIST_FOR_EACH(p_Pos, h_FmPcdNewPointersLst)
+    if (p_CcNode->maxNumOfKeys)
     {
-        p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
-        ASSERT_COND(p_CcNodeInformation->h_CcNode);
-        FM_MURAM_FreeMem(h_Muram, p_CcNodeInformation->h_CcNode);
+        if ((!p_CcNode->maskSupport) && (p_FmPcdCcKeyParams->p_Mask))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("mask support was not enabled for this node initialization time"));
+    }
 
-     }
+    err = FindKeyIndex(h_FmPcdCcNode,
+                       keySize,
+                       p_FmPcdCcKeyParams->p_Key,
+                       p_FmPcdCcKeyParams->p_Mask,
+                       &tmpKeyIndex);
+    if (err != E_NOT_FOUND)
+        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
+                     ("The received key and mask pair was already found in the match table of the provided node"));
+
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
 
-    /*free Old data structure if it has to be freed - new data structure was allocated*/
-    if(p_CcNewModifyAdditionalParams->p_AdTableOld)
-        FM_MURAM_FreeMem(h_Muram,p_CcNewModifyAdditionalParams->p_AdTableOld);
-    if(p_CcNewModifyAdditionalParams->p_KeysMatchTableOld)
-        FM_MURAM_FreeMem(h_Muram,p_CcNewModifyAdditionalParams->p_KeysMatchTableOld);
+    INIT_LIST(&h_OldPointersLst);
+    INIT_LIST(&h_NewPointersLst);
+
+    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
+    if (!p_ModifyKeyParams)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    /*update current modified node with changed fields if it's required*/
-    if(!p_CcNewModifyAdditionalParams->tree)
+    if (p_CcNode->maxNumOfKeys)
     {
-        if(p_CcNewModifyAdditionalParams->p_AdTableNew)
-            ((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->h_AdTable    = p_CcNewModifyAdditionalParams->p_AdTableNew;
-        if(p_CcNewModifyAdditionalParams->numOfKeys)
-            ((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->numOfKeys    = p_CcNewModifyAdditionalParams->numOfKeys;
-        if(p_CcNewModifyAdditionalParams->p_KeysMatchTableNew)
-            ((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->h_KeysMatchTable    = p_CcNewModifyAdditionalParams->p_KeysMatchTableNew;
-        memcpy(((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction, &p_CcNewModifyAdditionalParams->nextEngineAndRequiredAction, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams) * (256));
+        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+            return ERROR_CODE(E_BUSY);
+
+        useShadowStructs = TRUE;
     }
-    else
-        memcpy(&((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction, &p_CcNewModifyAdditionalParams->nextEngineAndRequiredAction, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams) * (((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->numOfEntries));
 
-    ReleaseLst(h_FmPcdOldPointersLst);
-    ReleaseLst(h_FmPcdNewPointersLst);
-    XX_Free(p_CcNewModifyAdditionalParams);
+    err = BuildNewNodeAddOrMdfyKeyAndNextEngine (h_FmPcd,
+                                                 p_CcNode,
+                                                 keyIndex,
+                                                 p_FmPcdCcKeyParams,
+                                                 p_ModifyKeyParams,
+                                                 FALSE);
+    if (err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 
-    return E_OK;
+    err = UpdatePtrWhichPointOnCrntMdfNode(p_CcNode,
+                                           p_ModifyKeyParams,
+                                           &h_OldPointersLst,
+                                           &h_NewPointersLst);
+    if (err)
+    {
+        ReleaseNewNodeCommonPart(p_ModifyKeyParams);
+        XX_Free(p_ModifyKeyParams);
+        if (p_CcNode->maxNumOfKeys)
+            RELEASE_LOCK(p_FmPcd->shadowLock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    err = DoDynamicChange(p_FmPcd,
+                          &h_OldPointersLst,
+                          &h_NewPointersLst,
+                          p_ModifyKeyParams,
+                          useShadowStructs);
+
+    if (p_CcNode->maxNumOfKeys)
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+
+    return err;
 }
 
 uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer)
@@ -2686,6 +3827,7 @@ uint32_t FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Point
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, (uint32_t)ILLEGAL_BASE);
 
     p_CcNodeInfo = CC_NODE_F_OBJECT(h_Pointer);
+
     return (uint32_t)(XX_VirtToPhys(p_CcNodeInfo->h_CcNode) - p_FmPcd->physicalMuramBase);
 }
 
@@ -2697,12 +3839,18 @@ t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_G
 
     if(grpId >= p_FmPcdCcTree->numOfGrps)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
+
     *p_GrpBits = p_FmPcdCcTree->fmPcdGroupParam[grpId].totalBitsMask;
     *p_GrpBase = p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry;
+
     return E_OK;
 }
 
-t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle  h_FmPcdCcTree,  uint32_t  *p_Offset, t_Handle h_FmPort)
+t_Error  FmPcdCcBindTree(t_Handle h_FmPcd,
+                         t_Handle h_PcdParams,
+                         t_Handle h_FmPcdCcTree,
+                         uint32_t *p_Offset,
+                         t_Handle h_FmPort)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
@@ -2736,27 +3884,31 @@ t_Error FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree)
 
 t_Error FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree)
 {
-    if (TRY_LOCK(NULL, &((t_FmPcdCcTree *)h_FmPcdCcTree)->lock))
+    if (TRY_LOCK(((t_FmPcdCcTree *)h_FmPcdCcTree)->h_Spinlock, &((t_FmPcdCcTree *)h_FmPcdCcTree)->lock))
         return E_OK;
+
     return ERROR_CODE(E_BUSY);
 }
 
 t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List)
 {
-    t_FmPcdCcNode   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
-    t_List          *p_Pos;
-    t_CcNodeInformation    *p_CcNodeInfo, nodeInfo;
-    t_Error         err = E_OK;
+    t_FmPcdCcNode           *p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
+    t_List                  *p_Pos;
+    t_CcNodeInformation     *p_CcNodeInfo, nodeInfo;
+    t_Error                 err = E_OK;
 
     UNUSED(h_FmPcd);
 
-    if(LIST_IsEmpty(&p_FmPcdCcNode->ccTreesLst))
+    if(LIST_IsEmpty(&p_CcNode->ccTreesLst))
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("asked for more nodes in CC than MAX"))  ;
-    LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode->ccTreesLst)
+
+    LIST_FOR_EACH(p_Pos, &p_CcNode->ccTreesLst)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
         ASSERT_COND(p_CcNodeInfo->h_CcNode);
+
         err = FmPcdCcTreeTryLock(p_CcNodeInfo->h_CcNode);
+
         if(err == E_OK)
         {
             memset(&nodeInfo, 0, sizeof(t_CcNodeInformation));
@@ -2764,13 +3916,103 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *
             EnqueueNodeInfoToRelevantLst(p_List, &nodeInfo);
         }
         else
-            FmPcdCcNodeTreeReleaseLock(p_List);
+            FmPcdCcTreeReleaseLock(p_List);
     }
 
     return err;
 }
 
-t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam)
+t_Error FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align)
+{
+    uint32_t    intFlags;
+    uint32_t    newSize = 0, newAlign = 0;
+
+    ASSERT_COND(p_FmPcd);
+
+    if (!size)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("size must be larger then 0"));
+
+    if (!POWER_OF_2(align))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("alignment must be power of 2"));
+
+    newSize  = p_FmPcd->ccShadowSize;
+    newAlign = p_FmPcd->ccShadowAlign;
+
+    /* Check if current shadow is large enough to hold the requested size */
+    if (size > p_FmPcd->ccShadowSize)
+        newSize = size;
+
+    /* Check if current shadow matches the requested alignment */
+    if (align > p_FmPcd->ccShadowAlign)
+        newAlign = align;
+
+    /* If a bigger shadow size or bigger shadow alignment are required, the shadow will be reallocated */
+    if ((newSize != p_FmPcd->ccShadowSize) || (newAlign != p_FmPcd->ccShadowAlign))
+    {
+        intFlags = FmPcdLock(p_FmPcd);
+
+        if (p_FmPcd->p_CcShadow)
+        {
+            FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), p_FmPcd->p_CcShadow);
+            p_FmPcd->ccShadowSize  = 0;
+            p_FmPcd->ccShadowAlign = 0;
+        }
+
+        p_FmPcd->p_CcShadow = FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcd), newSize, newAlign);
+
+        FmPcdUnlock(p_FmPcd, intFlags);
+
+        if (!p_FmPcd->p_CcShadow)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Shadow memory"));
+
+        p_FmPcd->ccShadowSize  = newSize;
+        p_FmPcd->ccShadowAlign = newAlign;
+    }
+
+    return E_OK;
+}
+
+#if DPAA_VERSION >= 3
+void FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle  h_Node,
+                                              t_Handle  h_ReplicGroup,
+                                              t_List    *p_AdTables,
+                                              uint32_t  *p_NumOfAdTables)
+{
+    t_FmPcdCcNode           *p_CurrentNode = (t_FmPcdCcNode *)h_Node;
+    int                     i = 0;
+    void *                  p_AdTable;
+    t_CcNodeInformation     ccNodeInfo;
+
+    ASSERT_COND(h_Node);
+    *p_NumOfAdTables = 0;
+
+    /* search in the current node which exact index points on this current replicator group for getting AD */
+    for (i = 0; i < p_CurrentNode->numOfKeys + 1; i++)
+    {
+        if ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            ((p_CurrentNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic == (t_Handle)h_ReplicGroup)))
+        {
+            /* save the current ad table in the list */
+            /* this entry uses the input replicator group */
+            p_AdTable = PTR_MOVE(p_CurrentNode->h_AdTable, i*FM_PCD_CC_AD_ENTRY_SIZE);
+            memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
+            ccNodeInfo.h_CcNode = p_AdTable;
+            EnqueueNodeInfoToRelevantLst(p_AdTables, &ccNodeInfo);
+            (*p_NumOfAdTables)++;
+        }
+    }
+
+    ASSERT_COND(i != p_CurrentNode->numOfKeys);
+}
+#endif /* DPAA_VERSION >= 3 */
+/*********************** End of inter-module routines ************************/
+
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+
+t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_Error                     err = E_OK;
@@ -2779,16 +4021,12 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     uint8_t                     numOfEntries;
     t_Handle                    p_CcTreeTmp;
     t_FmPcdCcGrpParams          *p_FmPcdCcGroupParams;
-    t_FmPcdCcNextEngineAndRequiredActionParams   *p_Params, *p_NextEngineAndRequiredActionParams;
+    t_FmPcdCcKeyAndNextEngineParams   *p_Params, *p_KeyAndNextEngineParams;
     t_NetEnvParams              netEnvParams;
     uint8_t                     lastOne = 0;
     uint32_t                    requiredAction = 0;
     t_FmPcdCcNode               *p_FmPcdCcNextNode;
     t_CcNodeInformation         ccNodeInfo, *p_CcInformation;
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    bool                        isIpv4Present = FALSE, isIpv6Present = FALSE;
-    uint8_t                     ipv4ReassmGrpNum = 0xFF, ipv6ReassmGrpNum = 0xFF;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam,E_INVALID_HANDLE, NULL);
@@ -2805,60 +4043,36 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("PCD tree structure"));
         return NULL;
     }
-    memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree)) ;
-    p_Params = (t_FmPcdCcNextEngineAndRequiredActionParams*)XX_Malloc(16 * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
-    memset(p_Params, 0, 16 * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+    memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree));
+    p_FmPcdCcTree->h_FmPcd = h_FmPcd;
+
+    p_Params = (t_FmPcdCcKeyAndNextEngineParams*)XX_Malloc(16 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+    memset(p_Params, 0, 16 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
     INIT_LIST(&p_FmPcdCcTree->fmPortsLst);
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    if(p_PcdGroupsParam->h_IpReassemblyManip)
+#ifdef FM_CAPWAP_SUPPORT
+    if ((p_PcdGroupsParam->numOfGrps == 1) &&
+        (p_PcdGroupsParam->ccGrpParams[0].numOfDistinctionUnits == 0) &&
+        (p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].nextEngine == e_FM_PCD_CC) &&
+        p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode &&
+        FmPcdCcIsCapwapApplSpecific(p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode))
     {
-        /* Check if the tree has IPv4 or IPv6 reassembly manipulation */
-        p_FmPcdCcTree->h_IpReassemblyManip = p_PcdGroupsParam->h_IpReassemblyManip;
-        isIpv4Present = FmPcdManipIsIpv4Present(h_FmPcd, (uint8_t)(PTR_TO_UINT(p_PcdGroupsParam->h_NetEnv)-1));
-        isIpv6Present = FmPcdManipIsIpv6Present(h_FmPcd, (uint8_t)(PTR_TO_UINT(p_PcdGroupsParam->h_NetEnv)-1));
-
-        if(isIpv6Present)
+        p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip = FmPcdManipApplSpecificBuild();
+        if(!p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip)
         {
-            if((p_PcdGroupsParam->numOfGrps + 1) > FM_PCD_MAX_NUM_OF_CC_GROUPS)
-            {
-                DeleteTree(p_FmPcdCcTree,p_FmPcd);
-                XX_Free(p_Params);
-                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfGrps can not be greater than 16"));
-                return NULL;
-            }
-            /* Sets IPv6 reassembly manipulation group parameters */
-            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].nextEnginePerEntriesInGrp[0].nextEngine = e_FM_PCD_DONE;
-            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].nextEnginePerEntriesInGrp[0].h_Manip = p_PcdGroupsParam->h_IpReassemblyManip;
-            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].numOfDistinctionUnits = 0;
-            ipv6ReassmGrpNum = p_PcdGroupsParam->numOfGrps;
-            /* Save and increases groups number*/
-            p_PcdGroupsParam->numOfGrps++;
-        }
-        if(isIpv4Present)
-        {
-            if((p_PcdGroupsParam->numOfGrps + 1) > FM_PCD_MAX_NUM_OF_CC_GROUPS)
-            {
-                DeleteTree(p_FmPcdCcTree,p_FmPcd);
-                XX_Free(p_Params);
-                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfGrps can not be greater than 16"));
-                return NULL;
-            }
-            /* Sets IPv4 reassembly manipulation group parameters */
-            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].nextEnginePerEntriesInGrp[0].nextEngine = e_FM_PCD_DONE;
-            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].nextEnginePerEntriesInGrp[0].h_Manip = p_PcdGroupsParam->h_IpReassemblyManip;
-            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].numOfDistinctionUnits = 0;
-            /* Save and increases groups number*/
-            ipv4ReassmGrpNum = p_PcdGroupsParam->numOfGrps;
-            p_PcdGroupsParam->numOfGrps++;
+            DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            XX_Free(p_Params);
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+            return NULL;
         }
     }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+#endif /* FM_CAPWAP_SUPPORT */
 
     numOfEntries = 0;
-    p_FmPcdCcTree->netEnvId = (uint8_t)(PTR_TO_UINT(p_PcdGroupsParam->h_NetEnv)-1);
-    for(i = 0; i < p_PcdGroupsParam->numOfGrps; i++)
+    p_FmPcdCcTree->netEnvId = FmPcdGetNetEnvId(p_PcdGroupsParam->h_NetEnv);
+
+    for (i = 0; i < p_PcdGroupsParam->numOfGrps; i++)
     {
         p_FmPcdCcGroupParams = &p_PcdGroupsParam->ccGrpParams[i];
 
@@ -2874,14 +4088,15 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         p_FmPcdCcTree->fmPcdGroupParam[i].baseGroupEntry = numOfEntries;
         p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup =(uint8_t)( 0x01 << p_FmPcdCcGroupParams->numOfDistinctionUnits);
         numOfEntries += p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup;
-        if(numOfEntries > 16)
+        if (numOfEntries > 16)
         {
             DeleteTree(p_FmPcdCcTree,p_FmPcd);
             XX_Free(p_Params);
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("numOfEntries can not be larger than 16"));
             return NULL;
         }
-        if(lastOne)
+
+        if (lastOne)
         {
             if(p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
             {
@@ -2896,9 +4111,13 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
         netEnvParams.netEnvId = p_FmPcdCcTree->netEnvId;
         netEnvParams.numOfDistinctionUnits = p_FmPcdCcGroupParams->numOfDistinctionUnits;
-        memcpy(netEnvParams.unitIds, &p_FmPcdCcGroupParams->unitIds, (sizeof(uint8_t)) * p_FmPcdCcGroupParams->numOfDistinctionUnits);
+
+        memcpy(netEnvParams.unitIds,
+               &p_FmPcdCcGroupParams->unitIds,
+               (sizeof(uint8_t)) * p_FmPcdCcGroupParams->numOfDistinctionUnits);
+
         err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
-        if(err)
+        if (err)
         {
             DeleteTree(p_FmPcdCcTree,p_FmPcd);
             XX_Free(p_Params);
@@ -2907,10 +4126,10 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         }
 
         p_FmPcdCcTree->fmPcdGroupParam[i].totalBitsMask = netEnvParams.vector;
-        for(j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup; j++)
+        for (j = 0; j < p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup; j++)
         {
             err = ValidateNextEngineParams(h_FmPcd,&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j]);
-            if(err)
+            if (err)
             {
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
                 XX_Free(p_Params);
@@ -2918,55 +4137,78 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
                 return NULL;
             }
 
-#ifdef FM_PCD_CC_MANIP
-            if(p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j].h_Manip)
+            if (p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j].h_Manip)
             {
                 err = FmPcdManipCheckParamsForCcNextEgine(&p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], &requiredAction);
-                if(err)
+                if (err)
                 {
                     DeleteTree(p_FmPcdCcTree,p_FmPcd);
                     XX_Free(p_Params);
                     REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                     return NULL;
                 }
-           }
-#endif /* FM_PCD_CC_MANIP */
-           p_NextEngineAndRequiredActionParams = p_Params+k;
-           memcpy(&p_NextEngineAndRequiredActionParams->nextEngineParams, &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], sizeof(t_FmPcdCcNextEngineParams));
-           requiredAction |= UPDATE_CC_WITH_TREE;
-           p_NextEngineAndRequiredActionParams->requiredAction = requiredAction;
-           k++;
+            }
+            p_KeyAndNextEngineParams = p_Params+k;
+
+            memcpy(&p_KeyAndNextEngineParams->nextEngineParams,
+                   &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j],
+                   sizeof(t_FmPcdCcNextEngineParams));
+
+            if ((p_KeyAndNextEngineParams->nextEngineParams.nextEngine == e_FM_PCD_CC)
+                && p_KeyAndNextEngineParams->nextEngineParams.h_Manip)
+            {
+                err = FmPcdCcAllocAndFillAdForContLookupManip(p_KeyAndNextEngineParams->nextEngineParams.params.ccParams.h_CcNode);
+                if (err)
+                {
+                    DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                    XX_Free(p_Params);
+                    REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Tree"));
+                    return NULL;
+                }
+            }
+
+            requiredAction |= UPDATE_CC_WITH_TREE;
+            p_KeyAndNextEngineParams->requiredAction = requiredAction;
+
+            k++;
         }
     }
 
     p_FmPcdCcTree->numOfEntries = (uint8_t)k;
     p_FmPcdCcTree->numOfGrps = p_PcdGroupsParam->numOfGrps;
+
     p_FmPcdCcTree->ccTreeBaseAddr =
         PTR_TO_UINT(FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
-                                      (uint32_t)( k * FM_PCD_CC_AD_ENTRY_SIZE),
+                                      (uint32_t)( FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE),
                                       FM_PCD_CC_TREE_ADDR_ALIGN));
-
-    if(!p_FmPcdCcTree->ccTreeBaseAddr)
+    if (!p_FmPcdCcTree->ccTreeBaseAddr)
     {
         DeleteTree(p_FmPcdCcTree,p_FmPcd);
         XX_Free(p_Params);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC Tree"));
         return NULL;
     }
-    IOMemSet32(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr), 0, (uint32_t)(k * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr), 0, (uint32_t)(FM_PCD_MAX_NUM_OF_CC_GROUPS * FM_PCD_CC_AD_ENTRY_SIZE));
 
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
     j = 0;
     for(i = 0; i < numOfEntries; i++)
     {
-        p_NextEngineAndRequiredActionParams = p_Params+i;
-        NextStepAd(p_CcTreeTmp,&p_NextEngineAndRequiredActionParams->nextEngineParams,p_FmPcd);
+        p_KeyAndNextEngineParams = p_Params+i;
+
+        NextStepAd(p_CcTreeTmp,&p_KeyAndNextEngineParams->nextEngineParams,p_FmPcd);
+
         p_CcTreeTmp = PTR_MOVE(p_CcTreeTmp, FM_PCD_CC_AD_ENTRY_SIZE);
-        memcpy(&p_FmPcdCcTree->nextEngineAndRequiredAction[i], p_NextEngineAndRequiredActionParams, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
-        if(p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
+
+        memcpy(&p_FmPcdCcTree->keyAndNextEngineParams[i],
+               p_KeyAndNextEngineParams,
+               sizeof(t_FmPcdCcKeyAndNextEngineParams));
+
+        if(p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
         {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode;
+            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+
             if(!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
@@ -2977,7 +4219,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
             }
             else
             {
-                p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,(t_Handle)p_FmPcdCcTree);
+                p_CcInformation = FmPcdCcFindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,(t_Handle)p_FmPcdCcTree);
                 ASSERT_COND(p_CcInformation);
                 p_CcInformation->index++;
             }
@@ -2989,9 +4231,9 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
     for(i = 0; i < p_FmPcdCcTree->numOfEntries ; i++)
     {
-        if(p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if(p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
         {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode;
+            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
 
             if(IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
                 UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, FALSE);
@@ -3000,9 +4242,10 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
     for(i = 0; i < numOfEntries; i++)
     {
-        if(p_FmPcdCcTree->nextEngineAndRequiredAction[i].requiredAction)
+        if(p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
         {
-            err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcTree->nextEngineAndRequiredAction[i].requiredAction, &p_FmPcdCcTree->nextEngineAndRequiredAction[i], p_CcTreeTmp,1, p_FmPcdCcTree);
+            err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction,
+                                            &p_FmPcdCcTree->keyAndNextEngineParams[i], p_CcTreeTmp,1, p_FmPcdCcTree);
             if(err)
             {
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
@@ -3014,62 +4257,125 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         }
     }
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    /* Sets reassembly schemes if required */
-    if (isIpv4Present)
-        FmPcdManipBuildIpReassmScheme(p_FmPcd, p_PcdGroupsParam, p_FmPcdCcTree, p_FmPcdCcTree->h_IpReassemblyManip, TRUE, ipv4ReassmGrpNum);
-    if (isIpv6Present)
-        FmPcdManipBuildIpReassmScheme(p_FmPcd, p_PcdGroupsParam, p_FmPcdCcTree, p_FmPcdCcTree->h_IpReassemblyManip, FALSE, ipv6ReassmGrpNum);
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+    p_FmPcdCcTree->h_Spinlock = XX_InitSpinlock();
+    if (!p_FmPcdCcTree->h_Spinlock)
+    {
+        DeleteTree(p_FmPcdCcTree,p_FmPcd);
+        XX_Free(p_Params);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM CC spinlock"));
+        return NULL;
+    }
+
 
     XX_Free(p_Params);
     return p_FmPcdCcTree;
 }
 
-t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree)
+t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
 {
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdCcTree               *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
-    int                         i= 0;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcTree   *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
+    int             i= 0;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
+    p_FmPcd = (t_FmPcd *)p_CcTree->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    FmPcdDecNetEnvOwners(h_FmPcd, p_CcTree->netEnvId);
+    FmPcdDecNetEnvOwners(p_FmPcd, p_CcTree->netEnvId);
 
     if(p_CcTree->owners)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
     /* Delete reassembly schemes if exist */
     if (p_CcTree->h_IpReassemblyManip)
-        FmPcdManipDeleteIpReassmSchemes(p_FmPcd, p_CcTree->h_IpReassemblyManip);
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-
-    for(i = 0; i <p_CcTree->numOfEntries; i++)
     {
-        if(p_CcTree->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            UpdateNodeOwner(p_CcTree->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+        FmPcdManipDeleteIpReassmSchemes(p_CcTree->h_IpReassemblyManip);
+        FmPcdManipUpdateOwner(p_CcTree->h_IpReassemblyManip, FALSE);
     }
 
-#ifdef FM_PCD_CC_MANIP
-    for(i = 0; i < p_CcTree->numOfEntries; i++)
+    for (i = 0; i <p_CcTree->numOfEntries; i++)
     {
-        if(p_CcTree->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip)
-            FmPcdManipUpdateOwner(p_CcTree->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip, FALSE);
+        if (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            UpdateNodeOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+
+        if (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
+            FmPcdManipUpdateOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.h_Manip, FALSE);
+
+#ifdef FM_CAPWAP_SUPPORT
+        if ((p_CcTree->numOfGrps == 1) &&
+            (p_CcTree->fmPcdGroupParam[0].numOfEntriesInGroup == 1) &&
+            (p_CcTree->keyAndNextEngineParams[0].nextEngineParams.nextEngine == e_FM_PCD_CC) &&
+            p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode &&
+            FmPcdCcIsCapwapApplSpecific(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode))
+        {
+            if (FM_PCD_ManipNodeDelete(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.h_Manip) != E_OK)
+                return E_INVALID_STATE;
+        }
+#endif /* FM_CAPWAP_SUPPORT */
+
+#if DPAA_VERSION >= 3
+        if ((p_CcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic))
+        {
+             FrmReplicUpdateGroupOwner(p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic,
+                                       FALSE,
+                                       TRUE,  /* fullUpdate */
+                                       p_CcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode);
+        }
+#endif /* DPAA_VERSION >= 3 */
     }
-#endif /* FM_PCD_CC_MANIP */
+
+    if (p_CcTree->h_Spinlock)
+        XX_FreeSpinlock(p_CcTree->h_Spinlock);
 
     DeleteTree(p_CcTree, p_FmPcd);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_CcRootModifyNextEngine(t_Handle  h_CcTree,
+                                      uint8_t   grpId,
+                                      uint8_t   index,
+                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcTree   *p_CcTree = (t_FmPcdCcTree *)h_CcTree;
+    uint32_t        intFlags;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcTree,E_INVALID_STATE);
+    p_FmPcd = (t_FmPcd *)p_CcTree->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcTreeTryLock(p_CcTree);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FmPcdCcModifyNextEngineParamTree(p_FmPcd,
+                                           p_CcTree,
+                                           grpId,
+                                           index,
+                                           p_FmPcdCcNextEngineParams);
+    if (err)
+    {
+        FmPcdCcTreeReleaseLock(p_CcTree);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    FmPcdCcTreeReleaseLock(p_CcTree);
+
     return E_OK;
 }
 
-t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
+t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd *) h_FmPcd;
-    t_FmPcdCcNode       *p_FmPcdCcNode, *p_FmPcdCcNextNode;
+    t_FmPcdCcNode       *p_CcNode, *p_FmPcdCcNextNode;
     t_Error             err = E_OK;
-    int                 tmp, size;
+    uint32_t            tmp, keySize, shadowSize;
     bool                glblMask = FALSE;
     t_FmPcdCcKeyParams  *p_KeyParams;
     t_Handle            p_KeysMatchTblTmp;
@@ -3077,552 +4383,1288 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
     bool                fullField = FALSE;
     ccPrivateInfo_t     icCode = CC_PRIVATE_INFO_NONE;
     bool                isKeyTblAlloc, fromIc = FALSE;
+    uint16_t            numOfKeysToAlloc;
     t_CcNodeInformation ccNodeInfo, *p_CcInformation;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
 
-    /*
-    if (!p_CcNodeParam->keysParams.keySize ||
-        !p_CcNodeParam->keysParams.numOfKeys)
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("At least one key of keySize > 0 must be defined."));
-        return NULL;
-    }
-    */
-    p_FmPcdCcNode = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
-    if(!p_FmPcdCcNode)
+    p_CcNode = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
+    if(!p_CcNode)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
         return NULL;
     }
-    memset(p_FmPcdCcNode, 0, sizeof(t_FmPcdCcNode));
+    memset(p_CcNode, 0, sizeof(t_FmPcdCcNode));
 
-    p_FmPcdCcNode->p_GlblMask = (t_Handle)XX_Malloc(CC_GLBL_MASK_SIZE * sizeof(uint8_t));
-    memset(p_FmPcdCcNode->p_GlblMask, 0, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+    p_CcNode->p_GlblMask = (t_Handle)XX_Malloc(CC_GLBL_MASK_SIZE * sizeof(uint8_t));
+    memset(p_CcNode->p_GlblMask, 0, CC_GLBL_MASK_SIZE * sizeof(uint8_t));
 
-    p_FmPcdCcNode->numOfKeys = p_CcNodeParam->keysParams.numOfKeys;
+    p_CcNode->h_FmPcd      = h_FmPcd;
+    p_CcNode->numOfKeys    = p_CcNodeParam->keysParams.numOfKeys;
+    p_CcNode->maxNumOfKeys = p_CcNodeParam->keysParams.maxNumOfKeys;
+    p_CcNode->maskSupport  = p_CcNodeParam->keysParams.maskSupport;
 
-    p_FmPcdCcNode->h_FmPcd = h_FmPcd;
+    INIT_LIST(&p_CcNode->ccPrevNodesLst);
+    INIT_LIST(&p_CcNode->ccTreeIdLst);
+    INIT_LIST(&p_CcNode->ccTreesLst);
 
-    INIT_LIST(&p_FmPcdCcNode->ccPrevNodesLst);
-    INIT_LIST(&p_FmPcdCcNode->ccTreeIdLst);
-    INIT_LIST(&p_FmPcdCcNode->ccTreesLst);
-
-    if((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR) &&
+    if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_BY_HDR) &&
         ((p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv4) ||
         (p_CcNodeParam->extractCcParams.extractByHdr.hdr == HEADER_TYPE_IPv6)) &&
         (p_CcNodeParam->extractCcParams.extractByHdr.type == e_FM_PCD_EXTRACT_FULL_FIELD) &&
         ((p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv6 == NET_HEADER_FIELD_IPv6_HOP_LIMIT) ||
         (p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField.ipv4 == NET_HEADER_FIELD_IPv4_TTL)))
     {
-            err = Ipv4TtlOrIpv6HopLimiCheckParams(h_FmPcd, p_CcNodeParam, p_FmPcdCcNode, &isKeyTblAlloc);
-            glblMask = FALSE;
-
+        err = Ipv4TtlOrIpv6HopLimiCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
+        glblMask = FALSE;
     }
-    else if((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
-        ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_KEY) ||
-           (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
-           (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
+    else if ((p_CcNodeParam->extractCcParams.type == e_FM_PCD_EXTRACT_NON_HDR) &&
+             ((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_KEY) ||
+              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_HASH) ||
+              (p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID)))
     {
         if((p_CcNodeParam->extractCcParams.extractNonHdr.src == e_FM_PCD_EXTRACT_FROM_FLOW_ID) &&
             (p_CcNodeParam->extractCcParams.extractNonHdr.offset != 0))
         {
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("In the case of the extraction from e_FM_PCD_EXTRACT_FROM_FLOW_ID offset has to be 0"));
             return NULL;
         }
 
         icCode = IcDefineCode(p_CcNodeParam);
         fromIc = TRUE;
-        if(icCode == CC_PRIVATE_INFO_NONE)
+        if (icCode == CC_PRIVATE_INFO_NONE)
         {
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
+            REPORT_ERROR(MAJOR, E_INVALID_STATE,
+                         ("user asked extraction from IC and field in internal context or action wasn't initialized in the right way"));
             return NULL;
         }
 
-        if((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP) || (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
+        if ((icCode == CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP) ||
+            (icCode == CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP))
         {
-            err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_FmPcdCcNode, &isKeyTblAlloc);
-
+            err = IcHashIndexedCheckParams(h_FmPcd, p_CcNodeParam, p_CcNode, &isKeyTblAlloc);
             glblMask = TRUE;
         }
         else
         {
-            err = CheckParams(h_FmPcd, p_CcNodeParam,p_FmPcdCcNode, &isKeyTblAlloc);
-            if(p_FmPcdCcNode->glblMaskSize)
+            err = CheckParams(h_FmPcd, p_CcNodeParam,p_CcNode, &isKeyTblAlloc);
+            if(p_CcNode->glblMaskSize)
                 glblMask = TRUE;
         }
     }
     else
     {
-        err = CheckParams(h_FmPcd, p_CcNodeParam,p_FmPcdCcNode, &isKeyTblAlloc);
-        if(p_FmPcdCcNode->glblMaskSize)
+        err = CheckParams(h_FmPcd, p_CcNodeParam,p_CcNode, &isKeyTblAlloc);
+        if(p_CcNode->glblMaskSize)
             glblMask = TRUE;
     }
 
-    if(err)
+    if (err)
     {
-        DeleteNode(p_FmPcdCcNode);
+        DeleteNode(p_CcNode);
         REPORT_ERROR(MAJOR, err, NO_MSG);
         return NULL;
     }
 
-    switch(p_CcNodeParam->extractCcParams.type)
+    switch (p_CcNodeParam->extractCcParams.type)
     {
         case(e_FM_PCD_EXTRACT_BY_HDR):
             switch(p_CcNodeParam->extractCcParams.extractByHdr.type)
             {
                 case(e_FM_PCD_EXTRACT_FULL_FIELD):
-                    p_FmPcdCcNode->parseCode = GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                                                    p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
-                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField, &p_FmPcdCcNode->sizeOfExtraction);
+                    p_CcNode->parseCode =
+                        GetFullFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                              p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                              p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
+                    GetSizeHeaderField(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                       p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField,
+                                       &p_CcNode->sizeOfExtraction);
                     fullField = TRUE;
-                    if((p_FmPcdCcNode->parseCode != CC_PC_FF_TCI1) && (p_FmPcdCcNode->parseCode != CC_PC_FF_TCI2) &&
-                       (p_FmPcdCcNode->parseCode != CC_PC_FF_MPLS1) && (p_FmPcdCcNode->parseCode != CC_PC_FF_MPLS1) &&
-                       (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&  (p_FmPcdCcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
-                       (p_FmPcdCcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&  (p_FmPcdCcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
-                       glblMask)
+                    if ((p_CcNode->parseCode != CC_PC_FF_TCI1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_TCI2) &&
+                        (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_MPLS1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
+                        glblMask)
                     {
                         glblMask = FALSE;
-                        p_FmPcdCcNode->glblMaskSize = 4;
-                        p_FmPcdCcNode->lclMask = TRUE;
+                        p_CcNode->glblMaskSize = 4;
+                        p_CcNode->lclMask = TRUE;
                     }
                     break;
+
                 case(e_FM_PCD_EXTRACT_FROM_HDR):
-                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
-                        p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
-                        p_FmPcdCcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
-                        p_FmPcdCcNode->parseCode = GetPrParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
-                                                                p_FmPcdCcNode->offset,glblMask, &p_FmPcdCcNode->prsArrayOffset);
-                        break;
+                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
+                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                    p_CcNode->parseCode =
+                        GetPrParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                       p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
+                                       p_CcNode->offset,glblMask,
+                                       &p_CcNode->prsArrayOffset);
+                    break;
+
                 case(e_FM_PCD_EXTRACT_FROM_FIELD):
-                        p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
-                        p_FmPcdCcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
-                        p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
-                        p_FmPcdCcNode->parseCode = GetFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
-                                                    p_FmPcdCcNode->offset,&p_FmPcdCcNode->prsArrayOffset,
-                                                    p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
-                        break;
+                    p_CcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                    p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                    p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
+                    p_CcNode->parseCode =
+                        GetFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr,
+                                          p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
+                                          p_CcNode->offset,
+                                          &p_CcNode->prsArrayOffset,
+                                          p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex);
+                    break;
+
                 default:
-                    DeleteNode(p_FmPcdCcNode);
+                    DeleteNode(p_CcNode);
                     REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
                     return NULL;
             }
             break;
+
         case(e_FM_PCD_EXTRACT_NON_HDR):
             /* get the field code for the generic extract */
-            p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
-            p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
-            p_FmPcdCcNode->userOffset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
-            p_FmPcdCcNode->parseCode = GetGenParseCode(h_FmPcd, p_CcNodeParam->extractCcParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset, fromIc,icCode);
-
-            if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+            p_CcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
+            p_CcNode->offset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_CcNode->userOffset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_CcNode->parseCode =
+                GetGenParseCode(h_FmPcd,
+                                p_CcNodeParam->extractCcParams.extractNonHdr.src,
+                                p_CcNode->offset,
+                                glblMask,
+                                &p_CcNode->prsArrayOffset,
+                                fromIc,icCode);
+
+            if (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
-                if((p_FmPcdCcNode->offset + p_FmPcdCcNode->sizeOfExtraction) > 8)
+                if ((p_CcNode->offset + p_CcNode->sizeOfExtraction) > 8)
                 {
-                     DeleteNode(p_FmPcdCcNode);
+                     DeleteNode(p_CcNode);
                      REPORT_ERROR(MAJOR, E_INVALID_SELECTION,("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
                      return NULL;
                 }
             }
-            if((p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_GMASK) || (p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
+            if ((p_CcNode->parseCode == CC_PC_GENERIC_IC_GMASK) ||
+                (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
             {
-                p_FmPcdCcNode->offset +=  p_FmPcdCcNode->prsArrayOffset;
-                p_FmPcdCcNode->prsArrayOffset = 0;
+                p_CcNode->offset +=  p_CcNode->prsArrayOffset;
+                p_CcNode->prsArrayOffset = 0;
             }
-                break;
+            break;
 
        default:
-            DeleteNode(p_FmPcdCcNode);
+            DeleteNode(p_CcNode);
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             return NULL;
     }
 
-    if(p_FmPcdCcNode->parseCode == CC_PC_ILLEGAL)
+    if (p_CcNode->parseCode == CC_PC_ILLEGAL)
     {
-        DeleteNode(p_FmPcdCcNode);
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("illeagl extraction type"));
+        DeleteNode(p_CcNode);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("illegal extraction type"));
         return NULL;
     }
 
-    if((p_FmPcdCcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY) || !p_FmPcdCcNode->sizeOfExtraction)
+    if ((p_CcNode->sizeOfExtraction > FM_PCD_MAX_SIZE_OF_KEY) ||
+        !p_CcNode->sizeOfExtraction)
     {
-        DeleteNode(p_FmPcdCcNode);
+        DeleteNode(p_CcNode);
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("sizeOfExatrction can not be greater than 56 and not 0"));
         return NULL;
     }
 
-    if(p_CcNodeParam->keysParams.keySize != p_FmPcdCcNode->sizeOfExtraction)
+    if (p_CcNodeParam->keysParams.keySize != p_CcNode->sizeOfExtraction)
     {
-        DeleteNode(p_FmPcdCcNode);
+        DeleteNode(p_CcNode);
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
         return NULL;
     }
 
+    p_CcNode->userSizeOfExtraction = p_CcNode->sizeOfExtraction;
 
-    p_FmPcdCcNode->userSizeOfExtraction = p_FmPcdCcNode->sizeOfExtraction;
+    if (!glblMask)
+        memset(p_CcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE  * sizeof(uint8_t));
 
-    if(!glblMask)
-        memset(p_FmPcdCcNode->p_GlblMask, 0xff, CC_GLBL_MASK_SIZE  * sizeof(uint8_t));
-
-#ifdef FM_PCD_CC_MANIP
-    err = CheckAndSetManipParamsWithCcNodeParams(p_FmPcdCcNode);
-    if(err != E_OK)
+    err = CheckAndSetManipParamsWithCcNodeParams(p_CcNode);
+    if (err != E_OK)
     {
-        DeleteNode(p_FmPcdCcNode);
+        DeleteNode(p_CcNode);
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be equal to sizeOfExtraction"));
         return NULL;
     }
-#endif /* FM_PCD_CC_MANIP */
 
-    GetCcExtractKeySize(p_FmPcdCcNode->sizeOfExtraction, &p_FmPcdCcNode->ccKeySizeAccExtraction);
+    /* Calculating matching table entry size by rounding up the user-defined size of extraction to valid entry size */
+    GetCcExtractKeySize(p_CcNode->sizeOfExtraction, &p_CcNode->ccKeySizeAccExtraction);
+
+    /* If local mask is used, it is stored next to each key in the keys match table */
+    if(p_CcNode->lclMask)
+        keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
+    else
+        keySize = p_CcNode->ccKeySizeAccExtraction;
+
+    /* Update CC shadow with maximal size required by this node */
+    if (p_CcNode->maxNumOfKeys)
+    {
+        numOfKeysToAlloc = p_CcNode->maxNumOfKeys;
+
+        /* Calculate keys table maximal size - each entry consists of a key and a mask,
+           (if local mask support is requested) */
+        p_CcNode->keysMatchTableMaxSize = p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t) * p_CcNode->maxNumOfKeys;
+
+        if (p_CcNode->maskSupport)
+            p_CcNode->keysMatchTableMaxSize *= 2;
+
+        /* Calculate maximal shadow size of this node.
+           All shadow structures will be used for runtime modifications host command.*/
 
-    if(p_FmPcdCcNode->lclMask)
-        size = 2 * p_FmPcdCcNode->ccKeySizeAccExtraction;
+        /* Shadow size should be enough to hold the following 3 structures:
+           1 - keys match table */
+        shadowSize = p_CcNode->keysMatchTableMaxSize;
+
+        /* 2 - next action descriptors table, including one more entry for miss */
+        shadowSize += (p_CcNode->maxNumOfKeys + 1) * FM_PCD_CC_AD_ENTRY_SIZE;
+
+        /* 3 - an extra action descriptor (AD that holds keys match table and next action descriptors table) */
+        shadowSize += FM_PCD_CC_AD_ENTRY_SIZE;
+
+        /* Update shadow to the calculated size */
+        err = FmPcdUpdateCcShadow (p_CcNode->h_FmPcd, (uint32_t)shadowSize, FM_PCD_CC_AD_TABLE_ALIGN);
+        if (err != E_OK)
+        {
+            DeleteNode(p_CcNode);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node shadow"));
+        }
+    }
     else
-        size = p_FmPcdCcNode->ccKeySizeAccExtraction;
+    {
+        numOfKeysToAlloc = p_CcNode->numOfKeys;
+    }
 
-    if(isKeyTblAlloc)
+    /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
+       identification, IPv6 hop count identification, etc. */
+    if (isKeyTblAlloc)
     {
-        p_FmPcdCcNode->h_KeysMatchTable =(t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd),
-                                         (uint32_t)(size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1)),
+        p_CcNode->h_KeysMatchTable =
+            (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                                        (uint32_t)(keySize * sizeof(uint8_t) * (numOfKeysToAlloc + 1)),
                                          FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN);
-        if(!p_FmPcdCcNode->h_KeysMatchTable)
+        if (!p_CcNode->h_KeysMatchTable)
         {
-            DeleteNode(p_FmPcdCcNode);
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for KEY MATCH table"));
+            DeleteNode(p_CcNode);
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node key match table"));
             return NULL;
         }
-        IOMemSet32((uint8_t *)p_FmPcdCcNode->h_KeysMatchTable, 0, size * sizeof(uint8_t) * (p_FmPcdCcNode->numOfKeys + 1));
+        IOMemSet32((uint8_t *)p_CcNode->h_KeysMatchTable, 0, keySize * sizeof(uint8_t) * (numOfKeysToAlloc + 1));
     }
 
-    p_FmPcdCcNode->h_AdTable = (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_FmPcdCcNode->h_FmPcd),
-                                     (uint32_t)( (p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE),
-                                     FM_PCD_CC_AD_TABLE_ALIGN);
-    if(!p_FmPcdCcNode->h_AdTable)
+    /* Allocate action descriptors table */
+    p_CcNode->h_AdTable =
+        (t_Handle)FM_MURAM_AllocMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd),
+                                    (uint32_t)( (numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE),
+                                    FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_CcNode->h_AdTable)
     {
-        DeleteNode(p_FmPcdCcNode);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory in MURAM for AD table "));
+        DeleteNode(p_CcNode);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node action descriptors table"));
         return NULL;
     }
-    IOMemSet32((uint8_t *)p_FmPcdCcNode->h_AdTable, 0, (uint32_t)((p_FmPcdCcNode->numOfKeys+1) * FM_PCD_CC_AD_ENTRY_SIZE));
+    IOMemSet32((uint8_t *)p_CcNode->h_AdTable, 0, (uint32_t)((numOfKeysToAlloc + 1) * FM_PCD_CC_AD_ENTRY_SIZE));
 
-    p_KeysMatchTblTmp    = p_FmPcdCcNode->h_KeysMatchTable;
-    p_AdTableTmp         = p_FmPcdCcNode->h_AdTable;
-    for(tmp = 0 ; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    p_KeysMatchTblTmp = p_CcNode->h_KeysMatchTable;
+    p_AdTableTmp      = p_CcNode->h_AdTable;
+
+    /* For each key, create the key and the next step AD */
+    for(tmp = 0 ; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
         if(p_KeysMatchTblTmp)
         {
-            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_FmPcdCcNode->sizeOfExtraction);
+            /* Copy the key */
+            Mem2IOCpy32((void*)p_KeysMatchTblTmp, p_KeyParams->p_Key, p_CcNode->sizeOfExtraction);
 
-            if(p_FmPcdCcNode->lclMask && p_KeyParams->p_Mask)
-                Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), p_KeyParams->p_Mask, p_FmPcdCcNode->sizeOfExtraction);
-            else if(p_FmPcdCcNode->lclMask)
-                IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp, p_FmPcdCcNode->ccKeySizeAccExtraction), 0xff, p_FmPcdCcNode->sizeOfExtraction);
-            p_KeysMatchTblTmp = PTR_MOVE(p_KeysMatchTblTmp, size * sizeof(uint8_t));
+            /* Copy the key mask or initialize it to 0xFF..F */
+            if(p_CcNode->lclMask && p_KeyParams->p_Mask)
+            {
+                Mem2IOCpy32(PTR_MOVE(p_KeysMatchTblTmp,
+                            p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
+                            p_KeyParams->p_Mask,
+                            p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
+            }
+            else if(p_CcNode->lclMask)
+            {
+                IOMemSet32(PTR_MOVE(p_KeysMatchTblTmp,
+                           p_CcNode->ccKeySizeAccExtraction),     /* User's size of extraction rounded up to a valid matching table entry size */
+                           0xff,
+                           p_CcNode->sizeOfExtraction);           /* Exact size of extraction as received from the user */
+            }
+
+            p_KeysMatchTblTmp = PTR_MOVE(p_KeysMatchTblTmp, keySize * sizeof(uint8_t));
         }
+        /* Create the next action descriptor in the match table */
         NextStepAd(p_AdTableTmp,&p_KeyParams->ccNextEngineParams, p_FmPcd);
 
         p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
     }
+
     NextStepAd(p_AdTableTmp,&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, p_FmPcd);
 
+    /* This parameter will be used to initialize the "key length" field in the action descriptor
+       that points to this node and it should be 0 for full field extraction */
     if(fullField == TRUE)
-        p_FmPcdCcNode->sizeOfExtraction = 0;
+        p_CcNode->sizeOfExtraction = 0;
 
-
-    for(tmp = 0; tmp < p_FmPcdCcNode->numOfKeys + 1; tmp++)
+    for(tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
     {
-        if(p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
         {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams.params.ccParams.h_CcNode;
+            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
 
             if(!IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
-                ccNodeInfo.h_CcNode = (t_Handle)p_FmPcdCcNode;
+                ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
                 ccNodeInfo.index = 1;
                 EnqueueNodeInfoToRelevantLst(&p_FmPcdCcNextNode->ccPrevNodesLst, &ccNodeInfo);
                 UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, TRUE);
             }
             else
             {
-                p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccPrevNodesLst,(t_Handle)p_FmPcdCcNode);
+                p_CcInformation = FmPcdCcFindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccPrevNodesLst,(t_Handle)p_CcNode);
                 ASSERT_COND(p_CcInformation);
                 p_CcInformation->index++;
             }
         }
-
     }
 
-    for(tmp = 0; tmp < p_FmPcdCcNode->numOfKeys + 1; tmp++)
+    for(tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
     {
-        if(p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        if(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
         {
-            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams.params.ccParams.h_CcNode;
+            p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode;
 
             if(IsNodeInModifiedState((t_Handle)p_FmPcdCcNextNode))
                 UpdateNodeWithModifiedState((t_Handle)p_FmPcdCcNextNode, FALSE);
         }
     }
 
-    p_AdTableTmp   = p_FmPcdCcNode->h_AdTable;
-    for(tmp = 0; tmp < p_FmPcdCcNode->numOfKeys; tmp++)
+    p_AdTableTmp = p_CcNode->h_AdTable;
+
+
+    /* Required action for each next engine */
+    for (tmp = 0; tmp < p_CcNode->numOfKeys + 1; tmp++)
     {
-        if(p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction)
+#if DPAA_VERSION >= 3
+        if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.h_FrmReplic)
+            && (!(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)))
         {
+            FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.h_FrmReplic,
+                                      TRUE, /* add */
+                                      TRUE, /* fullUpdate */
+                                      p_CcNode);
+        }
+#endif /* DPAA_VERSION >= 3 */
 
-            err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction, &p_FmPcdCcNode->nextEngineAndRequiredAction[tmp], p_AdTableTmp,1, NULL);
-            if(err)
+        if(p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
+        {
+
+            err = FmPcdCcSetRequiredAction(h_FmPcd,
+                                           p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
+                                           &p_CcNode->keyAndNextEngineParams[tmp],
+                                           p_AdTableTmp,
+                                           1,
+                                           NULL);
+            if (err)
             {
-                FM_PCD_CcDeleteNode(h_FmPcd, (t_Handle)p_FmPcdCcNode);
+                FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
                 REPORT_ERROR(MAJOR, err, NO_MSG);
                 return NULL;
             }
             p_AdTableTmp = PTR_MOVE(p_AdTableTmp, FM_PCD_CC_AD_ENTRY_SIZE);
         }
     }
-    if(p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction)
+
+    /* Current node required action on 'miss' */
+    if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
     {
-         err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction, &p_FmPcdCcNode->nextEngineAndRequiredAction[tmp], p_AdTableTmp,1, NULL);
+         err = FmPcdCcSetRequiredAction(h_FmPcd,
+                                        p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
+                                        &p_CcNode->keyAndNextEngineParams[tmp],
+                                        p_AdTableTmp,
+                                        1,
+                                        NULL);
          if(err)
-        {
-            FM_PCD_CcDeleteNode(h_FmPcd, (t_Handle)p_FmPcdCcNode);
+         {
+            FM_PCD_MatchTableDelete((t_Handle)p_CcNode);
             REPORT_ERROR(MAJOR, err, NO_MSG);
             return NULL;
         }
-
     }
 
-
-    return p_FmPcdCcNode;
+    return p_CcNode;
 }
 
-t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode)
+t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
 {
-    t_FmPcdCcNode               *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
-    int i = 0;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    int             i = 0;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-
-    UNUSED(h_FmPcd);
-    if(!p_CcNode)
-        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID is not initialized"));
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    if(p_CcNode->owners)
+    if (p_CcNode->owners)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the node with this ID can not be removed because this node is occupied, first - unbind this node"));
 
-   for(i = 0; i < p_CcNode->numOfKeys; i++)
-   {
-        if(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-            UpdateNodeOwner(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
-
+    for (i = 0; i < p_CcNode->numOfKeys; i++)
+    {
+        if(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
     }
-    if(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
-        UpdateNodeOwner(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
 
-#ifdef FM_PCD_CC_MANIP
-    for(i = 0; i < p_CcNode->numOfKeys; i++)
+    if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+        UpdateNodeOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode, FALSE);
+
+    /* Handle also Miss entry */
+    for(i = 0; i < p_CcNode->numOfKeys + 1; i++)
     {
-        if(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip)
-            FmPcdManipUpdateOwner(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip, FALSE);
+        if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
+            FmPcdManipUpdateOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip, FALSE);
+
+#if DPAA_VERSION >= 3
+        if ((p_CcNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
+            (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic))
+        {
+            if (p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
+                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic,
+                                          FALSE,
+                                          FALSE, /* fullUpdate */
+                                          NULL);
+            else
+                FrmReplicUpdateGroupOwner(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.params.h_FrmReplic,
+                                          FALSE,
+                                          TRUE,  /* fullUpdate */
+                                          p_CcNode);
+        }
+#endif /* DPAA_VERSION >= 3 */
     }
-    if(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip)
-        FmPcdManipUpdateOwner(p_CcNode->nextEngineAndRequiredAction[i].nextEngineParams.h_Manip, FALSE);
-#endif /* FM_PCD_CC_MANIP */
 
-   DeleteNode(p_CcNode);
+    DeleteNode(p_CcNode);
 
     return E_OK;
 }
 
-t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
+                                uint16_t            keyIndex,
+                                uint8_t             keySize,
+                                t_FmPcdCcKeyParams  *p_KeyParams)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    t_Error         err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = ((t_FmPcdCcNode *)h_CcNode)->numOfKeys;
-    return FmHcPcdCcAddKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
+    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = p_CcNode->numOfKeys;
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FmPcdCcAddKey(p_FmPcd,
+                        p_CcNode,
+                        keyIndex,
+                        keySize,
+                        p_KeyParams);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
 }
 
-t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex)
+t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    t_Error         err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
 
-    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = ((t_FmPcdCcNode *)h_CcNode)->numOfKeys;
+    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = p_CcNode->numOfKeys;
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FmPcdCcRemoveKey(p_FmPcd, p_CcNode, keyIndex);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FmHcPcdCcRemoveKey(p_FmPcd->h_Hc, h_CcNode, keyIndex);
+    return E_OK;
 }
 
-t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
+t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
+                                   uint16_t keyIndex,
+                                   uint8_t  keySize,
+                                   uint8_t  *p_Key,
+                                   uint8_t  *p_Mask)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    t_Error         err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Mask, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
 
-    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = ((t_FmPcdCcNode *)h_CcNode)->numOfKeys;
+    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = p_CcNode->numOfKeys;
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FmPcdCcModifyKey(p_FmPcd,
+                           p_CcNode,
+                           keyIndex,
+                           keySize,
+                           p_Key,
+                           p_Mask);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
 
-    return FmHcPcdCcModifyKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_Key, p_Mask);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
 }
 
-t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle h_CcNode,
+                                          uint16_t keyIndex,
+                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    t_Error         err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
 
-    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = ((t_FmPcdCcNode *)h_CcNode)->numOfKeys;
+    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = p_CcNode->numOfKeys;
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    return FmHcPcdCcModifyNodeNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams);
+    err = ModifyNextEngineParamNode(p_FmPcd,
+                                    p_CcNode,
+                                    keyIndex,
+                                    p_FmPcdCcNextEngineParams);
+    if(err)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    return E_OK;
 }
 
-t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle h_CcNode,
+                                              t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    t_Error         err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    return FmHcPcdCcModifyNodeMissNextEngine(p_FmPcd->h_Hc, h_CcNode, p_FmPcdCcNextEngineParams);
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+
+    err = FmPcdCcModifyMissNextEngineParamNode(p_FmPcd,
+                                               p_CcNode,
+                                               p_FmPcdCcNextEngineParams);
+    if (err)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    return E_OK;
 }
 
-t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle    h_CcNode,
+                                                uint16_t    keyIndex,
+                                                uint8_t     keySize,
+                                                t_FmPcdCcKeyParams  *p_KeyParams)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    t_Error         err = E_OK;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    return FmHcPcdCcModifyTreeNextEngine(p_FmPcd->h_Hc, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams);
+    if (keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = p_CcNode->numOfKeys;
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd,
+                                        p_CcNode,
+                                        keyIndex,
+                                        keySize,
+                                        p_KeyParams);
+    if (err)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    return E_OK;
 }
 
-t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+
+t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
+                                        uint8_t  keySize,
+                                        uint8_t  *p_Key,
+                                        uint8_t  *p_Mask)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    uint16_t        keyIndex;
+    t_Error         err;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    return FmHcPcdCcModifyKeyAndNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
+    if (err != E_OK)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+    }
+
+    err = FmPcdCcRemoveKey(p_FmPcd, p_CcNode, keyIndex);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
 }
 
-t_Error FM_PCD_CcNodeGetNextEngine(t_Handle                     h_FmPcd,
-                                   t_Handle                     h_CcNode,
-                                   uint16_t                     keyIndex,
-                                   t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
+
+t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNode,
+                                               uint8_t                   keySize,
+                                               uint8_t                   *p_Key,
+                                               uint8_t                   *p_Mask,
+                                               t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
-    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdCcNode                   *p_FmPcdCcNode  = (t_FmPcdCcNode *)h_CcNode;
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    uint16_t        keyIndex;
+    t_Error         err;
 
-#ifdef DISABLE_SANITY_CHECKS
-    UNUSED(p_FmPcd);
-#endif /* DISABLE_SANITY_CHECKS */
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
+    if (err != E_OK)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+    }
+
+    err = ModifyNextEngineParamNode(p_FmPcd,
+                                    p_CcNode,
+                                    keyIndex,
+                                    p_FmPcdCcNextEngineParams);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNode,
+                                                     uint8_t             keySize,
+                                                     uint8_t             *p_Key,
+                                                     uint8_t             *p_Mask,
+                                                     t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    uint16_t        keyIndex;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
+    if (err != E_OK)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+    }
+
+    err = FmPcdCcModifyKeyAndNextEngine(p_FmPcd,
+                                        h_CcNode,
+                                        keyIndex,
+                                        keySize,
+                                        p_KeyParams);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
+
+}
+
+t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
+                                        uint8_t  keySize,
+                                        uint8_t  *p_Key,
+                                        uint8_t  *p_Mask,
+                                        uint8_t  *p_NewKey,
+                                        uint8_t  *p_NewMask)
+{
+    t_FmPcd         *p_FmPcd;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_List          h_List;
+    uint32_t        intFlags;
+    uint16_t        keyIndex;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_NewKey, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
+    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    INIT_LIST(&h_List);
+
+    intFlags = FmPcdLock(p_FmPcd);
+    err = FmPcdCcNodeTreeTryLock(p_FmPcd, p_CcNode, &h_List);
+    FmPcdUnlock(p_FmPcd, intFlags);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FindKeyIndex(p_CcNode, keySize, p_Key, p_Mask, &keyIndex);
+    if (err != E_OK)
+    {
+        FmPcdCcNodeTreeReleaseLock(&h_List);
+        RETURN_ERROR(MAJOR, err, ("The received key and mask pair was not found in the match table of the provided node"));
+    }
+
+    err = FmPcdCcModifyKey(p_FmPcd,
+                           p_CcNode,
+                           keyIndex,
+                           keySize,
+                           p_NewKey,
+                           p_NewMask);
+
+    FmPcdCcNodeTreeReleaseLock(&h_List);
+
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
+                                       uint16_t                     keyIndex,
+                                       t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+
+    SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
 
     if(keyIndex == FM_PCD_LAST_KEY_INDEX)
-        keyIndex = p_FmPcdCcNode->numOfKeys;
-    if(keyIndex > p_FmPcdCcNode->numOfKeys)
+        keyIndex = p_CcNode->numOfKeys;
+
+    if(keyIndex > p_CcNode->numOfKeys)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > numOfKeys"));
+
     if(keyIndex > FM_PCD_MAX_NUM_OF_CC_NODES)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex can not be larger than 255"));
-    if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
-        if(keyIndex == p_FmPcdCcNode->numOfKeys)
+
+    if(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+        if(keyIndex == p_CcNode->numOfKeys)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This type of node doesn't have Miss"));
 
-    memcpy(p_FmPcdCcNextEngineParams, &p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex],sizeof(t_FmPcdCcNextEngineParams));
+    memcpy(p_FmPcdCcNextEngineParams,
+           &p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams,
+           sizeof(t_FmPcdCcNextEngineParams));
 
     return E_OK;
 }
 
-uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex)
+uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex)
 {
-    t_FmPcdCcNode       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+    t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     t_AdOfTypeResult    *p_AdResult = NULL;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_VALUE(h_CcNode, E_INVALID_HANDLE, 0);
-#ifdef DISABLE_SANITY_CHECKS
-UNUSED(h_FmPcd);
-#endif /* DISABLE_SANITY_CHECKS */
+    SANITY_CHECK_RETURN_VALUE(p_CcNode, E_INVALID_HANDLE, 0);
 
-    if (keyIndex >= p_FmPcdCcNode->numOfKeys)
+    if (keyIndex >= p_CcNode->numOfKeys)
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE,
-                     ("keyIndex > numOfKeys defined for this node"));
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("keyIndex > numOfKeys defined for this node"));
         return 0;
     }
 
-    p_AdResult = PTR_MOVE(p_FmPcdCcNode->h_AdTable, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE);
+    p_AdResult = PTR_MOVE(p_CcNode->h_AdTable, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE);
     ASSERT_COND(p_AdResult);
 
-    if (p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
+    if (p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE,
-                     ("statistics updated only for entries where next engine not CC"));
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("statistics updated only for entries where next engine not CC"));
         return 0;
     }
 
-    if(((p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_DONE) &&
-        !p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.enqueueParams.statisticsEn) ||
-        ((p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_KG) &&
-        !p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.kgParams.statisticsEn) ||
-        ((p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_PLCR) &&
-        !p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex].nextEngineParams.params.plcrParams.statisticsEn))
-    {
-        REPORT_ERROR(MINOR, E_INVALID_STATE,
-                     ("statistics wasn't enable"));
+    if(!p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.statisticsEn)
+     {
+        REPORT_ERROR(MINOR, E_INVALID_STATE, ("statistics wasn't enable"));
         return 0;
     }
 
     return  GET_UINT32(p_AdResult->res);
 }
 
-t_Error FM_PCD_CcIndexedHashNodeGetBucket(t_Handle    h_FmPcd,
-                                          t_Handle    h_CcNode,
-                                          uint8_t     keySize,
-                                          uint8_t     *p_Key,
-                                          uint8_t     hashShift,
-                                          t_Handle    *p_CcNodeBucketHandle,
-                                          uint8_t     *p_BucketIndex,
-                                          uint16_t    *p_LastIndex)
+t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
+                                              uint8_t     keySize,
+                                              uint8_t     *p_Key,
+                                              uint8_t     hashShift,
+                                              t_Handle    *p_CcNodeBucketHandle,
+                                              uint8_t     *p_BucketIndex,
+                                              uint16_t    *p_LastIndex)
 {
-    t_FmPcdCcNode       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
-    uint16_t            glblMask;
-    uint64_t            crc64 = 0;
+    t_FmPcdCcNode   *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t        glblMask;
+    uint64_t        crc64 = 0;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_CcNodeBucketHandle, E_NULL_POINTER);
 
-    UNUSED(h_FmPcd);
+    memcpy(&glblMask, PTR_MOVE(p_CcNode->p_GlblMask, 2), 2);
 
-    memcpy(&glblMask, PTR_MOVE(p_FmPcdCcNode->p_GlblMask, 2), 2);
     crc64 = crc64_init();
     crc64 = crc64_compute(p_Key, keySize, crc64);
     crc64 >>= hashShift;
-    *p_BucketIndex = (uint8_t)(((crc64 >> (8 * (6 - p_FmPcdCcNode->userOffset))) & glblMask) >> 4);
-    *p_CcNodeBucketHandle = p_FmPcdCcNode->nextEngineAndRequiredAction[*p_BucketIndex].nextEngineParams.params.ccParams.h_CcNode;
+
+    *p_BucketIndex = (uint8_t)(((crc64 >> (8 * (6 - p_CcNode->userOffset))) & glblMask) >> 4);
+    if (*p_BucketIndex >= p_CcNode->numOfKeys)
+        RETURN_ERROR(MINOR, E_NOT_IN_RANGE, ("bucket index!"));
+
+    *p_CcNodeBucketHandle = p_CcNode->keyAndNextEngineParams[*p_BucketIndex].nextEngineParams.params.ccParams.h_CcNode;
+    if (!*p_CcNodeBucketHandle)
+        RETURN_ERROR(MINOR, E_NOT_FOUND, ("bucket!"));
+
     *p_LastIndex = ((t_FmPcdCcNode *)*p_CcNodeBucketHandle)->numOfKeys;
 
     return E_OK;
 }
+
+t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
+{
+    t_FmPcdCcNode           *p_CcNodeHashTbl;
+    t_FmPcdCcNodeParams     *p_indxHashCcNodeParam = NULL,
+                            *p_exactMatchCcNodeParam = NULL;
+    t_Handle                h_CcNode;
+    t_FmPcdCcKeyParams      *p_HashKeyParams;
+    uint32_t                i;
+    uint16_t                numOfSets, numOfWays, countMask, onesCount = 0;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_Param, E_NULL_POINTER, NULL);
+
+    p_exactMatchCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    if(!p_exactMatchCcNodeParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_exactMatchCcNodeParam"));
+        return NULL;
+    }
+
+    p_indxHashCcNodeParam = (t_FmPcdCcNodeParams*)XX_Malloc(sizeof(t_FmPcdCcNodeParams));
+    if(!p_indxHashCcNodeParam)
+    {
+        XX_Free(p_exactMatchCcNodeParam);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_indxHashCcNodeParam"));
+        return NULL;
+    }
+
+    memset(p_exactMatchCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
+    memset(p_indxHashCcNodeParam, 0, sizeof(t_FmPcdCcNodeParams));
+
+    /* Calculate number of sets and number of ways of the hash table */
+    countMask = (uint16_t)(p_Param->hashResMask >> 4);
+    while (countMask)
+    {
+        onesCount++;
+        countMask = (uint16_t)(countMask >> 1);
+    }
+
+    numOfSets = (uint16_t)(1 << onesCount);
+    numOfWays = (uint16_t)DIV_CEIL(p_Param->maxNumOfKeys, numOfSets);
+
+    if (p_Param->maxNumOfKeys % numOfSets)
+        DBG(INFO, ("'maxNumOfKeys' is not a multiple of hash number of ways, so number of ways will be rounded up"));
+
+    /* Building exact-match node params, will be used to create the hash buckets */
+    p_exactMatchCcNodeParam->extractCcParams.type = e_FM_PCD_EXTRACT_NON_HDR;
+
+    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.src     = e_FM_PCD_EXTRACT_FROM_KEY;
+    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.action  = e_FM_PCD_ACTION_EXACT_MATCH;
+    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.offset  = 0;
+    p_exactMatchCcNodeParam->extractCcParams.extractNonHdr.size    = p_Param->matchKeySize;
+
+    p_exactMatchCcNodeParam->keysParams.maxNumOfKeys               = numOfWays;
+    p_exactMatchCcNodeParam->keysParams.maskSupport                = FALSE;
+    p_exactMatchCcNodeParam->keysParams.statisticsMode             = p_Param->statisticsMode;
+    p_exactMatchCcNodeParam->keysParams.numOfKeys                  = 0;
+    p_exactMatchCcNodeParam->keysParams.keySize                    = p_Param->matchKeySize;
+    p_exactMatchCcNodeParam->keysParams.ccNextEngineParamsForMiss  = p_Param->ccNextEngineParamsForMiss;
+
+    p_HashKeyParams = p_indxHashCcNodeParam->keysParams.keyParams;
+
+    for (i = 0; i < numOfSets; i++)
+    {
+        h_CcNode = FM_PCD_MatchTableSet(h_FmPcd, p_exactMatchCcNodeParam);
+        if (!h_CcNode)
+            break;
+
+        p_HashKeyParams[i].ccNextEngineParams.nextEngine               = e_FM_PCD_CC;
+        p_HashKeyParams[i].ccNextEngineParams.statisticsEn             = FALSE;
+        p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode = h_CcNode;
+    }
+
+    if (i < numOfSets)
+    {
+        for (i = i-1; i >=0; i--)
+            FM_PCD_MatchTableDelete(p_HashKeyParams[i].ccNextEngineParams.params.ccParams.h_CcNode);
+
+        XX_Free(p_indxHashCcNodeParam);
+        XX_Free(p_exactMatchCcNodeParam);
+
+        REPORT_ERROR(MAJOR, E_NULL_POINTER, NO_MSG);
+        return NULL;
+    }
+
+    /* Creating indexed-hash CC node */
+    p_indxHashCcNodeParam->extractCcParams.type                     = e_FM_PCD_EXTRACT_NON_HDR;
+    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.src        = e_FM_PCD_EXTRACT_FROM_HASH;
+    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.action     = e_FM_PCD_ACTION_INDEXED_LOOKUP;
+    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.icIndxMask = p_Param->hashResMask;
+    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.offset     = p_Param->hashShift;
+    p_indxHashCcNodeParam->extractCcParams.extractNonHdr.size       = 2;
+
+    p_indxHashCcNodeParam->keysParams.maxNumOfKeys   = 0;
+    p_indxHashCcNodeParam->keysParams.maskSupport    = FALSE;
+    p_indxHashCcNodeParam->keysParams.statisticsMode = p_Param->statisticsMode;
+    p_indxHashCcNodeParam->keysParams.numOfKeys      = numOfSets;      /* Number of keys of this node is number of sets of the hash */
+    p_indxHashCcNodeParam->keysParams.keySize        = 2;
+
+    p_CcNodeHashTbl = FM_PCD_MatchTableSet(h_FmPcd, p_indxHashCcNodeParam);
+
+    XX_Free(p_indxHashCcNodeParam);
+    XX_Free(p_exactMatchCcNodeParam);
+
+    return p_CcNodeHashTbl;
+}
+
+t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
+{
+    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle        *p_HashBuckets;
+    uint16_t        i, numOfBuckets;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
+
+    numOfBuckets = p_HashTbl->numOfKeys;
+
+    p_HashBuckets = (t_Handle *)XX_Malloc(numOfBuckets * sizeof(t_Handle));
+    if (!p_HashBuckets)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+
+    for (i = 0; i < numOfBuckets; i++)
+    {
+        p_HashBuckets[i] = p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+    }
+
+    err = FM_PCD_MatchTableDelete(p_HashTbl);
+
+    for (i = 0; i < numOfBuckets; i++)
+    {
+        err = FM_PCD_MatchTableDelete(p_HashBuckets[i]);
+    }
+
+    return E_OK;
+}
+
+t_Error FM_PCD_HashTableAddKey(t_Handle            h_HashTbl,
+                               uint8_t             keySize,
+                               t_FmPcdCcKeyParams  *p_KeyParams)
+{
+    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle        h_HashBucket;
+    uint8_t         bucketIndex;
+    uint16_t        lastIndex;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_KeyParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_KeyParams->p_Key, E_NULL_POINTER);
+
+    if (p_KeyParams->p_Mask)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Keys masks not supported for hash table"));
+
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
+                                                keySize,
+                                                p_KeyParams->p_Key,
+                                                p_HashTbl->userOffset,
+                                                &h_HashBucket,
+                                                &bucketIndex,
+                                                &lastIndex);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return FM_PCD_MatchTableAddKey(h_HashBucket,
+                                   FM_PCD_LAST_KEY_INDEX,
+                                   keySize,
+                                   p_KeyParams);
+}
+
+t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
+                                  uint8_t  keySize,
+                                  uint8_t  *p_Key)
+{
+    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle        h_HashBucket;
+    uint8_t         bucketIndex;
+    uint16_t        lastIndex;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
+                                                keySize,
+                                                p_Key,
+                                                p_HashTbl->userOffset,
+                                                &h_HashBucket,
+                                                &bucketIndex,
+                                                &lastIndex);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return FM_PCD_MatchTableFindNRemoveKey(h_HashBucket,
+                                           keySize,
+                                           p_Key,
+                                           NULL);
+}
+
+t_Error FM_PCD_HashTableModifyNextEngine(t_Handle                  h_HashTbl,
+                                         uint8_t                   keySize,
+                                         uint8_t                   *p_Key,
+                                         t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle        h_HashBucket;
+    uint8_t         bucketIndex;
+    uint16_t        lastIndex;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
+
+    err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
+                                                keySize,
+                                                p_Key,
+                                                p_HashTbl->userOffset,
+                                                &h_HashBucket,
+                                                &bucketIndex,
+                                                &lastIndex);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    return FM_PCD_MatchTableFindNModifyNextEngine(h_HashBucket,
+                                                  keySize,
+                                                  p_Key,
+                                                  NULL,
+                                                  p_FmPcdCcNextEngineParams);
+}
+
+t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl,
+                                             t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_Handle        h_HashBucket;
+    uint8_t         i;
+    t_Error         err;
+
+    SANITY_CHECK_RETURN_ERROR(h_HashTbl, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
+
+    for (i = 0; i < p_HashTbl->numOfKeys; i++)
+    {
+        h_HashBucket = p_HashTbl->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
+
+        err = FM_PCD_MatchTableModifyMissNextEngine(h_HashBucket,
+                                                    p_FmPcdCcNextEngineParams);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
+    return E_OK;
+}
+
+t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl,
+                                          t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcdCcNode   *p_HashTbl = (t_FmPcdCcNode *)h_HashTbl;
+    t_FmPcdCcNode   *p_HashBucket;
+
+    SANITY_CHECK_RETURN_ERROR(p_HashTbl, E_INVALID_HANDLE);
+
+    /* Miss next engine of each bucket was initialized with the next engine of the hash table */
+    p_HashBucket = p_HashTbl->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode;
+
+    memcpy(p_FmPcdCcNextEngineParams,
+           &p_HashBucket->keyAndNextEngineParams[p_HashBucket->numOfKeys].nextEngineParams,
+           sizeof(t_FmPcdCcNextEngineParams));
+
+    return E_OK;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index 59416e1..39f4952 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -129,7 +129,7 @@
 #define FM_PCD_CC_AD_TABLE_ALIGN            16
 #define FM_PCD_CC_AD_ENTRY_SIZE             16
 #define FM_PCD_CC_NUM_OF_KEYS               255
-#define FM_PCD_CC_TREE_ADDR_ALIGN           256
+#define FM_PCD_CC_TREE_ADDR_ALIGN			256
 
 #define FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE   0x00000000
 #define FM_PCD_AD_RESULT_DATA_FLOW_TYPE     0x80000000
@@ -164,84 +164,102 @@ typedef uint32_t ccPrivateInfo_t; /**< private info of CC: */
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
-typedef _Packed struct {
+typedef _Packed struct
+{
     volatile uint32_t fqid;
     volatile uint32_t plcrProfile;
     volatile uint32_t nia;
     volatile uint32_t res;
 } _PackedType t_AdOfTypeResult;
 
-typedef _Packed struct {
+typedef _Packed struct
+{
     volatile uint32_t ccAdBase;
     volatile uint32_t matchTblPtr;
     volatile uint32_t pcAndOffsets;
     volatile uint32_t gmask;
 } _PackedType t_AdOfTypeContLookup;
 
-typedef _Packed union {
+typedef _Packed union
+{
     volatile t_AdOfTypeResult        adResult;
     volatile t_AdOfTypeContLookup    adContLookup;
 } _PackedType t_Ad;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
 
 
 /***********************************************************************/
-/*  Driver's internal structures                                        */
+/*  Driver's internal structures                                       */
 /***********************************************************************/
 
-typedef enum e_ModifyState {
+typedef enum e_ModifyState
+{
     e_MODIFY_STATE_ADD = 0,
     e_MODIFY_STATE_REMOVE,
     e_MODIFY_STATE_CHANGE
 } e_ModifyState;
 
-typedef struct {
+typedef struct
+{
+    uint8_t                     key[FM_PCD_MAX_SIZE_OF_KEY];
+    uint8_t                     mask[FM_PCD_MAX_SIZE_OF_KEY];
+
     t_FmPcdCcNextEngineParams   nextEngineParams;
     uint32_t                    requiredAction;
     uint32_t                    shadowAction;
-} t_FmPcdCcNextEngineAndRequiredActionParams;
-
-typedef struct {
-    t_Handle         p_Ad;
-    e_FmPcdEngine    fmPcdEngine;
-    bool             adAllocated;
-    bool             isTree;
-
-    uint32_t    myInfo;
-    t_List      *h_CcNextNodesLst;
-    t_Handle    h_AdditionalInfo;
-    t_Handle    h_Node;
+} t_FmPcdCcKeyAndNextEngineParams;
+
+typedef struct
+{
+    t_Handle        p_Ad;
+    e_FmPcdEngine   fmPcdEngine;
+    bool            adAllocated;
+    bool            isTree;
+
+    uint32_t        myInfo;
+    t_List          *h_CcNextNodesLst;
+    t_Handle        h_AdditionalInfo;
+    t_Handle        h_Node;
 } t_FmPcdModifyCcAdditionalParams;
 
-typedef struct {
-    t_Handle p_AdTableNew;
-    t_Handle p_KeysMatchTableNew;
-    t_Handle p_AdTableOld;
-    t_Handle p_KeysMatchTableOld;
-    uint16_t numOfKeys;
-    t_Handle h_CurrentNode;
-    uint16_t keyIndex;
-    t_Handle h_NodeForAdd;
-    t_Handle h_NodeForRmv;
-    t_Handle h_ManipForRmv;
-    bool     tree;
-
-    t_FmPcdCcNextEngineAndRequiredActionParams nextEngineAndRequiredAction[256];
+typedef struct
+{
+    t_Handle    p_AdTableNew;
+    t_Handle    p_KeysMatchTableNew;
+    t_Handle    p_AdTableOld;
+    t_Handle    p_KeysMatchTableOld;
+    uint16_t    numOfKeys;
+    t_Handle    h_CurrentNode;
+    uint16_t    savedKeyIndex;
+    t_Handle    h_NodeForAdd;
+    t_Handle    h_NodeForRmv;
+    t_Handle    h_ManipForRmv;
+#if DPAA_VERSION >= 3
+    t_Handle    h_FrmReplicForRmv;
+#endif /* DPAA_VERSION >= 3 */
+    bool        tree;
+
+    t_FmPcdCcKeyAndNextEngineParams  keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_KEYS];
 } t_FmPcdModifyCcKeyAdditionalParams;
 
-typedef struct {
-    t_Handle h_Manip;
-    t_Handle h_CcNode;
+typedef struct
+{
+    t_Handle    h_Manip;
+    t_Handle    h_CcNode;
 } t_CcNextEngineInfo;
 
-typedef struct {
+typedef struct
+{
     uint16_t    numOfKeys;
+    uint16_t    maxNumOfKeys;
+
+    bool        maskSupport;
+    uint32_t    keysMatchTableMaxSize;
+
     bool        glblMaskUpdated;
     t_Handle    p_GlblMask;
     bool        lclMask;
@@ -257,6 +275,7 @@ typedef struct {
 
     t_Handle    h_KeysMatchTable;
     t_Handle    h_AdTable;
+    t_Handle    h_Ad;
 
     t_List      ccPrevNodesLst;
 
@@ -269,47 +288,49 @@ typedef struct {
     uint8_t     userSizeOfExtraction;
     uint8_t     userOffset;
 
-    t_FmPcdCcNextEngineAndRequiredActionParams nextEngineAndRequiredAction[256];
+    t_FmPcdCcKeyAndNextEngineParams keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_KEYS];
 } t_FmPcdCcNode;
 
-typedef struct {
+typedef struct
+{
     t_FmPcdCcNode       *p_FmPcdCcNode;
     bool                occupied;
     uint8_t             owners;
     volatile bool       lock;
 } t_FmPcdCcNodeArray;
 
-typedef struct {
+typedef struct
+{
     uint8_t             numOfEntriesInGroup;
     uint32_t            totalBitsMask;
     uint8_t             baseGroupEntry;
 } t_FmPcdCcGroupParam;
 
-typedef struct {
+typedef struct
+{
+    t_Handle            h_FmPcd;
     uint8_t             netEnvId;
     uintptr_t           ccTreeBaseAddr;
     uint8_t             numOfGrps;
     t_FmPcdCcGroupParam fmPcdGroupParam[FM_PCD_MAX_NUM_OF_CC_GROUPS];
     t_List              fmPortsLst;
     volatile bool       lock;
+    t_Handle            h_Spinlock;
     uint8_t             numOfEntries;
     uint8_t             owners;
-    t_Handle            *fmPcdCcSavedManipParams[256];
+    t_Handle            h_FmPcdCcSavedManipParams;
     bool                modifiedState;
     uint32_t            requiredAction;
-    t_FmPcdCcNextEngineAndRequiredActionParams nextEngineAndRequiredAction[FM_PCD_MAX_NUM_OF_KEYS];
     t_Handle            h_IpReassemblyManip;
-} t_FmPcdCcTree;
 
-typedef struct {
-    t_FmPcdCcTree       *p_FmPcdCcTree;
-    bool                occupied;
-    uint8_t             owners;
-    volatile bool       lock;
-} t_FmPcdCcTreeArray;
+    t_FmPcdCcKeyAndNextEngineParams keyAndNextEngineParams[FM_PCD_MAX_NUM_OF_KEYS];
+} t_FmPcdCcTree;
 
 
-bool FmPcdManipIsManipNode(t_Handle h_Ad);
+bool        FmPcdManipIsManipNode(t_Handle h_Ad);
+t_Error     FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List);
+void        FmPcdCcNodeTreeReleaseLock(t_List *p_List);
+t_Error     FmPcdUpdateCcShadow (t_FmPcd *p_FmPcd, uint32_t size, uint32_t align);
 
 
 #endif /* __FM_CC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index 6015d4c..bec6a83 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -45,10 +45,51 @@
 #include "fm_common.h"
 #include "fm_pcd.h"
 #include "fm_hc.h"
-
 #include "fm_pcd_ipc.h"
 
 
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+static uint32_t KgHwLock(t_Handle h_FmPcdKg)
+{
+    ASSERT_COND(h_FmPcdKg);
+    return XX_LockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_HwSpinlock);
+}
+
+static void KgHwUnlock(t_Handle h_FmPcdKg, uint32_t intFlags)
+{
+    ASSERT_COND(h_FmPcdKg);
+    XX_UnlockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_HwSpinlock, intFlags);
+}
+
+static uint32_t KgSwLock(t_Handle h_FmPcdKg)
+{
+    ASSERT_COND(h_FmPcdKg);
+    return XX_LockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_SwSpinlock);
+}
+
+static void KgSwUnlock(t_Handle h_FmPcdKg, uint32_t intFlags)
+{
+    ASSERT_COND(h_FmPcdKg);
+    XX_UnlockIntrSpinlock(((t_FmPcdKg*)h_FmPcdKg)->h_SwSpinlock, intFlags);
+}
+
+static uint32_t KgSchemeLock(t_Handle h_Scheme)
+{
+    ASSERT_COND(h_Scheme);
+
+    return XX_LockIntrSpinlock(((t_FmPcdKgScheme*)h_Scheme)->h_Spinlock);
+}
+
+static void KgSchemeUnlock(t_Handle h_Scheme, uint32_t intFlags)
+{
+    ASSERT_COND(h_Scheme);
+
+    XX_UnlockIntrSpinlock(((t_FmPcdKgScheme*)h_Scheme)->h_Spinlock, intFlags);
+}
+
 static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
 {
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
@@ -652,36 +693,26 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     t_FmPcdIpcKgClsPlanParams       kgAlloc;
     t_Error                         err = E_OK;
     uint32_t                        oredVectors = 0;
-    uint32_t                        intFlags;
     int                             i, j;
 
+    /* this routine is protected by the calling routine ! */
     if (p_Grp->numOfOptions >= FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Too many classification plan basic options selected."));
 
-    intFlags = FmPcdLock(p_FmPcd);
-
     /* find a new clsPlan group */
     for(i = 0;i<FM_MAX_NUM_OF_PORTS;i++)
         if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
             break;
     if(i== FM_MAX_NUM_OF_PORTS)
-    {
-        FmPcdUnlock(p_FmPcd, intFlags);
         RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
-    }
+
     p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used = TRUE;
+
     p_Grp->clsPlanGrpId = (uint8_t)i;
 
     if(p_Grp->numOfOptions == 0)
         p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = (uint8_t)i;
 
-    if (!TRY_LOCK(NULL, &p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock))
-    {
-        FmPcdUnlock(p_FmPcd, intFlags);
-        return ERROR_CODE(E_BUSY);
-    }
-    FmPcdUnlock(p_FmPcd, intFlags);
-
     p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[i];
     p_ClsPlanGrp->netEnvId = p_Grp->netEnvId;
     p_ClsPlanGrp->owners = 0;
@@ -697,11 +728,7 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
         err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
 
         if(err)
-        {
-            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
             RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
-        }
-
     }
     else
     {
@@ -725,21 +752,12 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
                                      &replyLength,
                                      NULL,
                                      NULL)) != E_OK)
-        {
-            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        }
 
         if (replyLength != (sizeof(uint32_t) + sizeof(p_ClsPlanGrp->baseEntry)))
-        {
-            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        }
         if ((t_Error)reply.error != E_OK)
-        {
-            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
             RETURN_ERROR(MINOR, (t_Error)reply.error, NO_MSG);
-        }
 
         p_ClsPlanGrp->baseEntry = *(uint8_t*)(reply.replyBody);
     }
@@ -792,8 +810,6 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
         }
     }
 
-    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->clsPlanGrps[p_Grp->clsPlanGrpId].lock);
-
     return E_OK;
 }
 
@@ -803,9 +819,11 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
     t_FmPcdIpcKgClsPlanParams       kgAlloc;
     t_Error                         err;
     t_FmPcdIpcMsg                   msg;
-    uint32_t                        replyLength;
+    uint32_t                        replyLength,intFlags ;
     t_FmPcdIpcReply                 reply;
 
+    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
+
     /* check that no port is bound to this clsPlan */
     if(p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].owners)
     {
@@ -813,8 +831,16 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
         return;
     }
 
+    FmPcdSetClsPlanGrpId(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId, ILLEGAL_CLS_PLAN);
+
     FmPcdDecNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].netEnvId);
 
+    if(grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
+
+    /* clear clsPlan driver structure */
+    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
+
     /* free blocks */
     if(p_FmPcd->guestId == NCSW_MASTER_ID)
     {
@@ -822,9 +848,12 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
                              p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].sizeOfGrp,
                              p_FmPcd->guestId,
                              p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId].baseEntry);
+
+        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
     }
     else    /* in GUEST_PARTITION, we use the IPC, to also set a private driver group if required */
     {
+        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
         kgAlloc.guestId = p_FmPcd->guestId;
@@ -833,13 +862,14 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
         msg.msgId = FM_PCD_FREE_KG_CLSPLAN;
         memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
         replyLength = sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(kgAlloc),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
+        err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId) + sizeof(kgAlloc),
+                                (uint8_t*)&reply,
+                                &replyLength,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
         {
             REPORT_ERROR(MINOR, err, NO_MSG);
             return;
@@ -855,11 +885,6 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
             return;
         }
     }
-
-    if(grpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
-        p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId = ILLEGAL_CLS_PLAN;
-    /* clear clsPlan driver structure */
-    memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
 }
 
 t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
@@ -884,10 +909,9 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
 
         if(add)
         {
-            if (!FmPcdKgIsSchemeValidSw(h_FmPcd, relativeSchemeId))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
-
             p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+            if (!FmPcdKgIsSchemeValidSw(p_Scheme))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
             /* check netEnvId  of the port against the scheme netEnvId */
             if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
@@ -907,6 +931,8 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
             }
             if(!p_BindPort->useClsPlan)
             {
+                /* This check may be redundant as port is a assigned to the whole NetEnv */
+
                 /* if this port does not use clsPlan, it may not be bound to schemes with units that contain
                 cls plan options. Schemes that are used only directly, should not be checked.
                 it also may not be bound to schemes that go to CC with units that are options  - so we OR
@@ -941,8 +967,9 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
 void FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int             i;
-    t_FmPcdKgScheme *p_Scheme;
+    int                 i;
+    t_FmPcdKgScheme     *p_Scheme;
+    uint32_t            intFlags;
 
     /* for each scheme - update owners counters */
     for(i = 0; i<p_BindPort->numOfSchemes; i++)
@@ -950,15 +977,18 @@ void FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSch
         p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[p_BindPort->schemesIds[i]];
 
         /* increment owners number */
+        intFlags = KgSchemeLock(p_Scheme);
         p_Scheme->owners++;
+        KgSchemeUnlock(p_Scheme, intFlags);
     }
 }
 
 void FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int             i;
-    t_FmPcdKgScheme *p_Scheme;
+    int                 i;
+    t_FmPcdKgScheme     *p_Scheme;
+    uint32_t            intFlags;
 
     /* for each scheme - update owners counters */
     for(i = 0; i<p_BindPort->numOfSchemes; i++)
@@ -967,7 +997,9 @@ void FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSch
 
         /* increment owners number */
         ASSERT_COND(p_Scheme->owners);
+        intFlags = KgSchemeLock(p_Scheme);
         p_Scheme->owners--;
+        KgSchemeUnlock(p_Scheme, intFlags);
     }
 }
 
@@ -977,17 +1009,20 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
     uint32_t                tmpKgarReg = 0, tmpKgpeSp, intFlags;
     t_Error                 err = E_OK;
 
+    /* The calling routine had locked the port, so for each port only one core can access
+     * (so we don't need a lock here) */
     if (p_FmPcd->h_Hc)
         return FmHcKgWriteSp(p_FmPcd->h_Hc, hardwarePortId, spReg, add);
 
     p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
 
     tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
-    intFlags = FmPcdLock(p_FmPcd);
+    /* lock a common KG reg */
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     err = WriteKgarWait(p_FmPcd, tmpKgarReg);
     if(err)
     {
-        FmPcdUnlock(p_FmPcd, intFlags);
+        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -1003,7 +1038,7 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
     tmpKgarReg = FmPcdKgBuildWritePortSchemeBindActionReg(hardwarePortId);
 
     err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    FmPcdUnlock(p_FmPcd, intFlags);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
     return err;
 }
 
@@ -1014,15 +1049,17 @@ static t_Error KgWriteCpp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t cpp
     t_Error                 err;
 
     if (p_FmPcd->h_Hc)
-        return FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
+    {
+        err = FmHcKgWriteCpp(p_FmPcd->h_Hc, hardwarePortId, cppReg);
+        return err;
+    }
 
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs;
-    intFlags = FmPcdLock(p_FmPcd);
     WRITE_UINT32(p_FmPcdKgPortRegs->kgoe_cpp, cppReg);
-
     tmpKgarReg = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
     err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    FmPcdUnlock(p_FmPcd, intFlags);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
     return err;
 }
@@ -1040,6 +1077,10 @@ static t_Error KgBindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId,
     return KgWriteCpp(p_FmPcd, hardwarePortId, tmpKgpeCpp);
 }
 
+
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
 t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1078,11 +1119,11 @@ t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd ,  t_FmPcdKgInterModuleBindP
     return E_OK;
 }
 
-bool     FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId)
+bool     FmPcdKgIsSchemeValidSw(t_Handle h_Scheme)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgScheme     *p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
 
-    return p_FmPcd->p_FmPcdKg->schemes[schemeId].valid;
+    return p_Scheme->valid;
 }
 
 bool     KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
@@ -1091,20 +1132,21 @@ bool     KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
 
     if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
         return TRUE;
-    else
-        return FALSE;
+    else{
+	XX_Print("\n\n p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector = 0x%X \n", p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector);
+	XX_Print(" schemeId = %u \n\n", schemeId);
+	dump_stack();
+        return FALSE;}
 }
 
 t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t            intFlags;
     uint8_t             i,j;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    intFlags = FmPcdLock(p_FmPcd);
     for(j=0,i=0;i<FM_PCD_KG_NUM_OF_SCHEMES && j<numOfSchemes;i++)
     {
         if(!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
@@ -1125,10 +1167,8 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
             p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].ownerId = 0;
             p_SchemesIds[j] = 0;
         }
-        FmPcdUnlock(p_FmPcd, intFlags);
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("No schemes found"));
     }
-    FmPcdUnlock(p_FmPcd, intFlags);
 
     return E_OK;
 }
@@ -1136,54 +1176,38 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
 t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t guestId, uint8_t *p_SchemesIds)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t            intFlags;
     uint8_t             i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
 
-    intFlags = FmPcdLock(p_FmPcd);
-
     for(i=0;i<numOfSchemes;i++)
     {
         if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
-        {
-            FmPcdUnlock(p_FmPcd, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
-        }
         if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
-        {
-            FmPcdUnlock(p_FmPcd, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
-        }
         p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated = FALSE;
         p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId = 0;
     }
 
-    FmPcdUnlock(p_FmPcd, intFlags);
     return E_OK;
 }
 
 t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t *p_First)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t    intFlags;
     uint8_t     numOfBlocks, blocksFound=0, first=0;
     uint8_t     i, j;
 
-    intFlags = FmPcdLock(p_FmPcd);
+
+    /* This routine is protected by the calling routine ! */
 
     if(!numOfClsPlanEntries)
-    {
-        FmPcdUnlock(p_FmPcd, intFlags);
         return E_OK;
-    }
 
     if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
-    {
-        FmPcdUnlock(p_FmPcd, intFlags);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfClsPlanEntries must be a power of 2 and divisible by 8"));
-    }
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfClsPlanEntries must be a power of 2 and divisible by 8"));
 
     numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
 
@@ -1214,27 +1238,22 @@ t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, u
             p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].allocated = TRUE;
             p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[j].ownerId = guestId;
         }
-        FmPcdUnlock(p_FmPcd, intFlags);
 
         return E_OK;
     }
     else
-    {
-        FmPcdUnlock(p_FmPcd, intFlags);
         RETURN_ERROR(MINOR, E_FULL, ("No recources for clsPlan"));
-    }
 }
 
 void  KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8_t guestId, uint8_t base)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t    intFlags;
     uint8_t     numOfBlocks;
     uint8_t     i, baseBlock;
 
     UNUSED( guestId);
 
-    intFlags = FmPcdLock(p_FmPcd);
+    /* This routine is protected by the calling routine ! */
 
     numOfBlocks =  (uint8_t)(numOfClsPlanEntries/CLS_PLAN_NUM_PER_GRP);
     ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
@@ -1247,7 +1266,6 @@ void  KgFreeClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, uint8
         p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated = FALSE;
         p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId = 0;
     }
-    FmPcdUnlock(p_FmPcd, intFlags);
 }
 
 void KgEnable(t_FmPcd *p_FmPcd)
@@ -1270,16 +1288,14 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdKgClsPlanRegs    *p_FmPcdKgPortRegs;
-    uint32_t                tmpKgarReg=0, intFlags;
+    uint32_t                tmpKgarReg=0;
     uint16_t                i, j;
 
-    SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    /* This routine is protected by the calling routine ! */
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
 
-    intFlags = FmPcdLock(p_FmPcd);
     for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
     {
         tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
@@ -1296,7 +1312,6 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
             return;
         }
     }
-    FmPcdUnlock(p_FmPcd, intFlags);
 }
 
 static void PcdKgErrorException(t_Handle h_FmPcd)
@@ -1413,7 +1428,7 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
     /**********************KGGDV1R******************/
 
     /**********************KGGCR******************/
-    WRITE_UINT32(p_Regs->kggcr, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+    WRITE_UINT32(p_Regs->kggcr, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd));
     /**********************KGGCR******************/
 
     /* register even if no interrupts enabled, to allow future enablement */
@@ -1437,6 +1452,7 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
     WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
 
+
     if(p_FmPcd->p_FmPcdKg->numOfSchemes)
     {
         err = FmPcdKgAllocSchemes(p_FmPcd,
@@ -1450,171 +1466,6 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
     return E_OK;
 }
 
-
-/****************************************/
-/*  API routines                        */
-/****************************************/
-t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
-{
-   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
-   t_FmPcdKgRegs        *p_Regs;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, E_NULL_POINTER);
-
-    p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-    if(!FmIsMaster(p_FmPcd->h_Fm))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetAdditionalDataAfterParsing - guest mode!"));
-
-/* not needed
-    if(payloadOffset > 256)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("data exatraction offset from parseing end can not be more than 256"));
-*/
-
-    WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
-
-    return E_OK;
-}
-
-t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
-{
-   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
-   t_FmPcdKgRegs        *p_Regs;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(((valueId == 0) || (valueId == 1)), E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, E_NULL_POINTER);
-
-    p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-
-    if(!FmIsMaster(p_FmPcd->h_Fm))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetDfltValue - guest mode!"));
-
-    if(valueId == 0)
-        WRITE_UINT32(p_Regs->kggdv0r,value);
-    else
-        WRITE_UINT32(p_Regs->kggdv1r,value);
-    return E_OK;
-}
-
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                 i = 0, j = 0;
-    uint8_t             hardwarePortId = 0;
-    uint32_t            tmpKgarReg, intFlags;
-    t_Error             err = E_OK;
-    t_FmPcdIpcMsg       msg;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-    {
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_KG_DUMP_REGS;
-        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId),
-                                 NULL,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    }
-    DUMP_SUBTITLE(("\n"));
-    DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
-
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggcr);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggsr);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgtpc);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgserc);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfdor);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv0r);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv1r);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfeer);
-    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgar);
-
-    DUMP_SUBTITLE(("\n"));
-    intFlags = FmPcdLock(p_FmPcd);
-    for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
-    {
-        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
-        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
-
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mode);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekfc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekdv);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmch);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmcl);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_fqb);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_hc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ppc);
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec, ("kgse_gec"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PCD_KG_NUM_OF_GENERIC_REGS)
-        {
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec[i], sizeof(uint32_t));
-        }
-
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_spc);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv0);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv1);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ccbs);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mv);
-    }
-    DUMP_SUBTITLE(("\n"));
-
-    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-    {
-        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
-
-        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
-
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
-
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_sp);
-        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_cpp);
-    }
-
-    DUMP_SUBTITLE(("\n"));
-    for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
-    {
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
-        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
-
-        tmpKgarReg = FmPcdKgBuildReadClsPlanBlockActionReg((uint8_t)j);
-        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-        DUMP_SUBSTRUCT_ARRAY(i, 8)
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
-    }
-    FmPcdUnlock(p_FmPcd, intFlags);
-
-    return E_OK;
-}
-#endif /* (defined(DEBUG_ERRORS) && ... */
-
 t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
 {
     t_FmPcdKg   *p_FmPcdKg;
@@ -1656,11 +1507,32 @@ t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
 
 t_Error KgInit(t_FmPcd *p_FmPcd)
 {
-    if (p_FmPcd->guestId == NCSW_MASTER_ID)
-        return KgInitMaster(p_FmPcd);
-    else
-        return KgInitGuest(p_FmPcd);
-}
+    t_Error err = E_OK;
+
+    p_FmPcd->p_FmPcdKg->h_HwSpinlock = XX_InitSpinlock();
+    if (!p_FmPcd->p_FmPcdKg->h_HwSpinlock)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM KG HW spinlock"));
+
+    p_FmPcd->p_FmPcdKg->h_SwSpinlock = XX_InitSpinlock();
+    if (!p_FmPcd->p_FmPcdKg->h_SwSpinlock)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM KG SW spinlock"));
+
+
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
+        err =  KgInitMaster(p_FmPcd);
+    else
+        err =  KgInitGuest(p_FmPcd);
+
+    if(err != E_OK)
+    {
+        if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
+            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
+        if (p_FmPcd->p_FmPcdKg->h_SwSpinlock)
+            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_SwSpinlock);
+    }
+
+    return err;
+}
 
 t_Error KgFree(t_FmPcd *p_FmPcd)
 {
@@ -1673,10 +1545,22 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR);
 
     if(p_FmPcd->guestId == NCSW_MASTER_ID)
-        return FmPcdKgFreeSchemes(p_FmPcd,
+    {
+        err = FmPcdKgFreeSchemes(p_FmPcd,
                                     p_FmPcd->p_FmPcdKg->numOfSchemes,
                                     p_FmPcd->guestId,
                                     p_FmPcd->p_FmPcdKg->schemesIds);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
+            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
+        if (p_FmPcd->p_FmPcdKg->h_SwSpinlock)
+            XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_SwSpinlock);
+
+
+        return E_OK;
+    }
 
     /* guest */
     memset(&reply, 0, sizeof(reply));
@@ -1684,7 +1568,7 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
     kgAlloc.numOfSchemes = p_FmPcd->p_FmPcdKg->numOfSchemes;
     kgAlloc.guestId = p_FmPcd->guestId;
     ASSERT_COND(kgAlloc.numOfSchemes < FM_PCD_KG_NUM_OF_SCHEMES);
-    memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds , (sizeof(uint8_t))*kgAlloc.numOfSchemes);
+    memcpy(kgAlloc.schemesIds, p_FmPcd->p_FmPcdKg->schemesIds, (sizeof(uint8_t))*kgAlloc.numOfSchemes);
     msg.msgId = FM_PCD_FREE_KG_SCHEMES;
     memcpy(msg.msgBody, &kgAlloc, sizeof(kgAlloc));
     replyLength = sizeof(uint32_t);
@@ -1699,6 +1583,11 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
     if (replyLength != sizeof(uint32_t))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
+    if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
+        XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
+    if (p_FmPcd->p_FmPcdKg->h_SwSpinlock)
+        XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_SwSpinlock);
+
     return (t_Error)reply.error;
 }
 
@@ -1709,24 +1598,37 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     t_FmPcdKgClsPlanGrp                     *p_ClsPlanGrp;
     t_FmPcdKgInterModuleClsPlanSet          *p_ClsPlanSet;
     t_Error                                 err;
+    uint32_t                                intFlags;
 
     memset(&grpParams, 0, sizeof(grpParams));
     grpParams.clsPlanGrpId = ILLEGAL_CLS_PLAN;
     p_GrpParams = &grpParams;
 
     p_GrpParams->netEnvId = netEnvId;
+
+    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
+
+    /* Get from the NetEnv the information of the clsPlan (can be already created,
+     * or needs to build) */
     err = PcdGetClsPlanGrpParams(h_FmPcd, p_GrpParams);
     if(err)
         RETURN_ERROR(MINOR,err,NO_MSG);
+
     if(p_GrpParams->grpExists)
+    {
+        /* this group was already updated (at least) in SW */
+        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
+    }
     else
     {
         p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
         if (!p_ClsPlanSet)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
         memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
+        /* Build (in SW) the clsPlan parameters, including the vectors to be written to HW */
         err = FmPcdKgBuildClsPlanGrp(h_FmPcd, p_GrpParams, p_ClsPlanSet);
+        KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         if (err)
         {
             XX_Free(p_ClsPlanSet);
@@ -1734,12 +1636,15 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
         }
         *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
 
+        intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+
         if (p_FmPcd->h_Hc)
         {
             /* write clsPlan entries to memory */
             err = FmHcPcdKgSetClsPlan(p_FmPcd->h_Hc, p_ClsPlanSet);
             if (err)
             {
+                KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                 XX_Free(p_ClsPlanSet);
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
@@ -1748,9 +1653,13 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
             /* write clsPlan entries to memory */
             KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
 
+        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+
         XX_Free(p_ClsPlanSet);
     }
 
+    /* Set caller parameters     */
+
     /* mark if this is an empty classification group */
     if(*p_ClsPlanGrpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
         *p_IsEmptyClsPlanGrp = TRUE;
@@ -1759,8 +1668,12 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
 
     p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId];
 
-    /* increment owners number */
+
+    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
+   /* increment owners number */
     p_ClsPlanGrp->owners++;
+    KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+
 
     /* copy options array for port */
     memcpy(p_OptArray, &p_FmPcd->p_FmPcdKg->clsPlanGrps[*p_ClsPlanGrpId].optArray, FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS)*sizeof(protocolOpt_t));
@@ -1778,38 +1691,56 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_FmPcdKgClsPlanGrp             *p_ClsPlanGrp = &p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId];
     t_FmPcdKgInterModuleClsPlanSet  *p_ClsPlanSet;
+    uint32_t                        intFlags;
+    t_Error                         err;
 
     FmPcdKgUnbindPortToClsPlanGrp(p_FmPcd, hardwarePortId);
 
+    intFlags = KgSwLock(p_FmPcd->p_FmPcdKg);
     /* decrement owners number */
     ASSERT_COND(p_ClsPlanGrp->owners);
     p_ClsPlanGrp->owners--;
+    KgSwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+
 
     if(!p_ClsPlanGrp->owners)
     {
+        intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+
         if (p_FmPcd->h_Hc)
-            return FmHcPcdKgDeleteClsPlan(p_FmPcd->h_Hc, clsPlanGrpId);
+        {
+            err = FmHcPcdKgDeleteClsPlan(p_FmPcd->h_Hc, clsPlanGrpId);
+            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+            return err;
+        }
         else
         {
             /* clear clsPlan entries in memory */
             p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
             if (!p_ClsPlanSet)
+            {
+                KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
+            }
             memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
 
             p_ClsPlanSet->baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry;
             p_ClsPlanSet->numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp;
             KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
+            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
             XX_Free(p_ClsPlanSet);
+
+            /* protection for this routine is inside it */
             FmPcdKgDestroyClsPlanGrp(h_FmPcd, clsPlanGrpId);
-        }
+       }
     }
     return E_OK;
 }
 
-t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs)
+t_Error FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs)
 {
-    t_FmPcd                             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+	t_FmPcdKgScheme 					*p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
+    t_FmPcd                             *p_FmPcd = (t_FmPcd *)(p_Scheme->h_FmPcd);
     uint32_t                            grpBits = 0;
     uint8_t                             grpBase;
     bool                                direct=TRUE, absolute=FALSE;
@@ -1829,173 +1760,158 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
     t_FmPcdKgSchemesExtracts            *p_LocalExtractsArray;
     uint8_t                             numOfSwDefaults = 0;
     t_FmPcdKgExtractDflt                swDefaults[NUM_OF_SW_DEFAULTS];
-    uint8_t                             currGenId = 0, relativeSchemeId;
+    uint8_t                             currGenId = 0;
 
-    if(!p_Scheme->modify)
-        relativeSchemeId = p_Scheme->id.relativeSchemeId;
-    else
-        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, (uint8_t)(PTR_TO_UINT(p_Scheme->id.h_Scheme)-1));
-
-    memset(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId], 0, sizeof(t_FmPcdKgScheme));
     memset(swDefaults, 0, NUM_OF_SW_DEFAULTS*sizeof(t_FmPcdKgExtractDflt));
     memset(p_SchemeRegs, 0, sizeof(t_FmPcdKgInterModuleSchemeRegs));
 
-    if (p_Scheme->netEnvParams.numOfDistinctionUnits > FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+    if (p_SchemeParams->netEnvParams.numOfDistinctionUnits > FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                      ("numOfDistinctionUnits should not exceed %d", FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS));
 
     /* by netEnv parameters, get match vector */
-    if(!p_Scheme->alwaysDirect)
+    if(!p_SchemeParams->alwaysDirect)
     {
-        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId =
-            (uint8_t)(PTR_TO_UINT(p_Scheme->netEnvParams.h_NetEnv)-1);
-        netEnvParams.netEnvId = p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId;
-        netEnvParams.numOfDistinctionUnits = p_Scheme->netEnvParams.numOfDistinctionUnits;
-        memcpy(netEnvParams.unitIds, p_Scheme->netEnvParams.unitIds, (sizeof(uint8_t))*p_Scheme->netEnvParams.numOfDistinctionUnits);
+        p_Scheme->netEnvId = FmPcdGetNetEnvId(p_SchemeParams->netEnvParams.h_NetEnv);
+        netEnvParams.netEnvId = p_Scheme->netEnvId;
+        netEnvParams.numOfDistinctionUnits = p_SchemeParams->netEnvParams.numOfDistinctionUnits;
+        memcpy(netEnvParams.unitIds, p_SchemeParams->netEnvParams.unitIds, (sizeof(uint8_t))*p_SchemeParams->netEnvParams.numOfDistinctionUnits);
         err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
         if(err)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector = netEnvParams.vector;
+        p_Scheme->matchVector = netEnvParams.vector;
     }
     else
     {
-        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector = SCHEME_ALWAYS_DIRECT;
-        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId = ILLEGAL_NETENV;
+        p_Scheme->matchVector = SCHEME_ALWAYS_DIRECT;
+        p_Scheme->netEnvId = ILLEGAL_NETENV;
     }
 
-    if(p_Scheme->nextEngine == e_FM_PCD_INVALID)
+    if(p_SchemeParams->nextEngine == e_FM_PCD_INVALID)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next Engine of the scheme is not Valid"));
 
-    if(p_Scheme->bypassFqidGeneration)
+    if(p_SchemeParams->bypassFqidGeneration)
     {
 #ifdef FM_KG_NO_BYPASS_FQID_GEN
-        {
-            t_FmRevisionInfo    revInfo;
-
-            FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
-            if (revInfo.majorRev != 4)
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassFqidGeneration."));
-        }
+        if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassFqidGeneration."));
 #endif /* FM_KG_NO_BYPASS_FQID_GEN */
-        if(p_Scheme->baseFqid)
+        if(p_SchemeParams->baseFqid)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid set for a scheme that does not generate an FQID"));
     }
     else
-        if(!p_Scheme->baseFqid)
+        if(!p_SchemeParams->baseFqid)
             DBG(WARNING, ("baseFqid is 0."));
 
-    if(p_Scheme->nextEngine == e_FM_PCD_PLCR)
+    if(p_SchemeParams->nextEngine == e_FM_PCD_PLCR)
     {
-        direct = p_Scheme->kgNextEngineParams.plcrProfile.direct;
-        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr = direct;
-        absolute = (bool)(p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE : FALSE);
+        direct = p_SchemeParams->kgNextEngineParams.plcrProfile.direct;
+        p_Scheme->directPlcr = direct;
+        absolute = (bool)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE : FALSE);
         if(!direct && absolute)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
 
         if(direct)
         {
-            profileId = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.directRelativeProfileId;
+            profileId = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.directRelativeProfileId;
             numOfProfiles = 1;
         }
         else
         {
-            profileId = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
-            shift = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
-            numOfProfiles = p_Scheme->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+            profileId = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+            shift = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+            numOfProfiles = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
         }
     }
 
-    if(p_Scheme->nextEngine == e_FM_PCD_CC)
+    if(p_SchemeParams->nextEngine == e_FM_PCD_CC)
     {
 #ifdef FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
-        if((p_Scheme->kgNextEngineParams.cc.plcrNext) && (p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        if((p_SchemeParams->kgNextEngineParams.cc.plcrNext) && (p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
         {
-            t_FmRevisionInfo    revInfo;
-
-            FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
-            if (revInfo.majorRev != 4)
+            if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassPlcrProfileGeneration."));
         }
 #endif /* FM_KG_NO_BYPASS_PLCR_PROFILE_GEN */
 
-        err = FmPcdCcGetGrpParams(p_Scheme->kgNextEngineParams.cc.h_CcTree,
-                             p_Scheme->kgNextEngineParams.cc.grpId,
+        err = FmPcdCcGetGrpParams(p_SchemeParams->kgNextEngineParams.cc.h_CcTree,
+                             p_SchemeParams->kgNextEngineParams.cc.grpId,
                              &grpBits,
                              &grpBase);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].ccUnits = grpBits;
+        p_Scheme->ccUnits = grpBits;
 
-        if((p_Scheme->kgNextEngineParams.cc.plcrNext) &&
-           (!p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        if((p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
+           (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
         {
-                if(p_Scheme->kgNextEngineParams.cc.plcrProfile.sharedProfile)
+                if(p_SchemeParams->kgNextEngineParams.cc.plcrProfile.sharedProfile)
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
                 absolute = FALSE;
-                direct = p_Scheme->kgNextEngineParams.cc.plcrProfile.direct;
+                direct = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.direct;
                 if(direct)
                 {
-                    profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
+                    profileId = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
                     numOfProfiles = 1;
                 }
                 else
                 {
-                    profileId = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
-                    shift = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
-                    numOfProfiles = p_Scheme->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
+                    profileId = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+                    shift = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.fqidOffsetShift;
+                    numOfProfiles = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.indirectProfile.numOfProfiles;
                 }
         }
     }
 
     /* if policer is used directly after KG, or after CC */
-    if((p_Scheme->nextEngine == e_FM_PCD_PLCR)  ||
-       ((p_Scheme->nextEngine == e_FM_PCD_CC) &&
-        (p_Scheme->kgNextEngineParams.cc.plcrNext) &&
-        (!p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration)))
+    if((p_SchemeParams->nextEngine == e_FM_PCD_PLCR)  ||
+       ((p_SchemeParams->nextEngine == e_FM_PCD_CC) &&
+        (p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
+        (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)))
     {
         /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
         if(absolute)
         {
             /* for absolute direct policy only, */
             relativeProfileId = profileId;
-            err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,e_FM_PCD_PLCR_SHARED,NULL, relativeProfileId, &profileId);
+            err = FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL, relativeProfileId, &profileId);
             if(err)
                 RETURN_ERROR(MAJOR, err, ("Shared profile not valid offset"));
             if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Shared profile not valid."));
-            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId = profileId;
+            p_Scheme->relativeProfileId = profileId;
         }
         else
         {
             /* save relative profile id's for later check */
-            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile = TRUE;
-            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId = profileId;
-            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].numOfProfiles = numOfProfiles;
+            p_Scheme->nextRelativePlcrProfile = TRUE;
+            p_Scheme->relativeProfileId = profileId;
+            p_Scheme->numOfProfiles = numOfProfiles;
         }
     }
     else
     {
         /* if policer is NOT going to be used after KG at all than if bypassFqidGeneration
         is set, we do not need numOfUsedExtractedOrs and hashDistributionNumOfFqids */
-        if(p_Scheme->bypassFqidGeneration && p_Scheme->numOfUsedExtractedOrs)
+        if(p_SchemeParams->bypassFqidGeneration && p_SchemeParams->numOfUsedExtractedOrs)
             RETURN_ERROR(MAJOR, E_INVALID_STATE,
                     ("numOfUsedExtractedOrs is set in a scheme that does not generate FQID or policer profile ID"));
-        if(p_Scheme->bypassFqidGeneration &&
-                p_Scheme->useHash &&
-                p_Scheme->keyExtractAndHashParams.hashDistributionNumOfFqids)
+        if(p_SchemeParams->bypassFqidGeneration &&
+                p_SchemeParams->useHash &&
+                p_SchemeParams->keyExtractAndHashParams.hashDistributionNumOfFqids)
             RETURN_ERROR(MAJOR, E_INVALID_STATE,
                     ("hashDistributionNumOfFqids is set in a scheme that does not generate FQID or policer profile ID"));
     }
 
     /* configure all 21 scheme registers */
     tmpReg =  KG_SCH_MODE_EN;
-    switch(p_Scheme->nextEngine)
+    switch(p_SchemeParams->nextEngine)
     {
         case(e_FM_PCD_PLCR):
             /* add to mode register - NIA */
             tmpReg |= KG_SCH_MODE_NIA_PLCR;
             tmpReg |= NIA_ENG_PLCR;
-            tmpReg |= (uint32_t)(p_Scheme->kgNextEngineParams.plcrProfile.sharedProfile ? NIA_PLCR_ABSOLUTE:0);
+            tmpReg |= (uint32_t)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? NIA_PLCR_ABSOLUTE:0);
             /* initialize policer profile command - */
             /*  configure kgse_ppc  */
             if(direct)
@@ -2024,9 +1940,9 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
             p_SchemeRegs->kgse_ccbs = grpBits;
             tmpReg |= (uint32_t)(grpBase << KG_SCH_MODE_CCOBASE_SHIFT);
 
-            if(p_Scheme->kgNextEngineParams.cc.plcrNext)
+            if(p_SchemeParams->kgNextEngineParams.cc.plcrNext)
             {
-                if(!p_Scheme->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
+                if(!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
                 {
                     /* find out if absolute or relative */
                     if(absolute)
@@ -2056,21 +1972,59 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
             }
             break;
         case(e_FM_PCD_DONE):
-            if(p_Scheme->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
-                tmpReg |= (NIA_ENG_BMI | NIA_BMI_AC_DISCARD);
+            if(p_SchemeParams->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
+                tmpReg |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
             else
-                tmpReg |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+                tmpReg |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
             break;
         default:
              RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Next engine not supported"));
     }
     p_SchemeRegs->kgse_mode = tmpReg;
 
-    p_SchemeRegs->kgse_mv = p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].matchVector;
+    p_SchemeRegs->kgse_mv = p_Scheme->matchVector;
 
-    if(p_Scheme->useHash)
+#if DPAA_VERSION >= 3
+    if (p_SchemeParams->overrideStorageProfile)
     {
-        p_KeyAndHash = &p_Scheme->keyExtractAndHashParams;
+        p_SchemeRegs->kgse_om |= KG_SCH_OM_VSPE;
+
+        tmpReg = 0;
+        if (p_SchemeParams->storageProfile.direct)
+        {
+            profileId = p_SchemeParams->storageProfile.profileSelect.directRelativeProfileId;
+            shift = 0;
+            numOfProfiles = 1;
+        }
+        else
+        {
+            profileId = p_SchemeParams->storageProfile.profileSelect.indirectProfile.fqidOffsetRelativeProfileIdBase;
+            shift = p_SchemeParams->storageProfile.profileSelect.indirectProfile.fqidOffsetShift;
+            numOfProfiles = p_SchemeParams->storageProfile.profileSelect.indirectProfile.numOfProfiles;
+        }
+        if (shift > MAX_SP_SHIFT)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_SP_SHIFT));
+
+        if (!numOfProfiles || !POWER_OF_2(numOfProfiles))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
+
+        tmpReg = (uint32_t)shift << KG_SCH_VSP_SHIFT;
+        tmpReg |= ((uint32_t)(numOfProfiles-1) << KG_SCH_VSP_MASK_SHIFT);
+        tmpReg |= (uint32_t)profileId;
+
+
+        p_SchemeRegs->kgse_vsp = tmpReg;
+
+        p_Scheme->vspe = TRUE;
+
+    }
+    else
+        p_SchemeRegs->kgse_vsp = KG_SCH_VSP_NO_KSP_EN;
+#endif /* DPAA_VERSION >= 3 */
+
+    if(p_SchemeParams->useHash)
+    {
+        p_KeyAndHash = &p_SchemeParams->keyExtractAndHashParams;
 
         if (p_KeyAndHash->numOfUsedExtracts >= FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfUsedExtracts out of range"));
@@ -2081,11 +2035,11 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
         /*  configure kgse_dv1  */
         p_SchemeRegs->kgse_dv1 = p_KeyAndHash->privateDflt1;
 
-        if(!p_Scheme->bypassFqidGeneration)
+        if(!p_SchemeParams->bypassFqidGeneration)
         {
             if(!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
-            if((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_Scheme->baseFqid)
+            if((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_SchemeParams->baseFqid)
                 DBG(WARNING, ("baseFqid unaligned. Distribution may result in less than hashDistributionNumOfFqids queues."));
         }
 
@@ -2182,7 +2136,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                                     /* case where extraction from ESP only */
                                     if (p_Extract->extractByHdr.extractByHdrType.fromHdr.offset >= UDP_HEADER_SIZE)
                                     {
-                                        p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                        p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                         p_Extract->extractByHdr.extractByHdrType.fromHdr.offset -= UDP_HEADER_SIZE;
                                         p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                     }
@@ -2203,14 +2157,14 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                                             break;
                                         case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                                             /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
                                         case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                                             p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SEQ_NUM_OFFSET;
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
@@ -2228,14 +2182,14 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                                             break;
                                         case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SPI_SIZE;
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SPI_OFFSET;
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
                                         case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
+                                            p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SEQ_NUM_SIZE;
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SEQ_NUM_OFFSET;
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
@@ -2419,13 +2373,13 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                 /* we compare the id of the current extract with the id of the extract in the orderedArray[j-1]
                 location */
                 while((j > 0) && (p_LocalExtractsArray->extractsArray[i].id <
-                      p_LocalExtractsArray->extractsArray[p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j-1]].id))
+                      p_LocalExtractsArray->extractsArray[p_Scheme->orderedArray[j-1]].id))
                 {
-                    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j] =
-                        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j-1];
+                    p_Scheme->orderedArray[j] =
+                        p_Scheme->orderedArray[j-1];
                     j--;
                 }
-                p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[j] = (uint8_t)i;
+                p_Scheme->orderedArray[j] = (uint8_t)i;
                 curr++;
             }
             else
@@ -2433,7 +2387,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
                 /* index is first_generic_index + generic index (id) */
                 idx = (uint8_t)(p_KeyAndHash->numOfUsedExtracts - currGenId + p_LocalExtractsArray->extractsArray[i].id);
                 ASSERT_COND(idx < FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY);
-                p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].orderedArray[idx]= (uint8_t)i;
+                p_Scheme->orderedArray[idx]= (uint8_t)i;
             }
         }
         XX_Free(p_LocalExtractsArray);
@@ -2452,25 +2406,25 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
         p_SchemeRegs->kgse_dv1 = 0;
     }
 
-    if(p_Scheme->bypassFqidGeneration)
+    if(p_SchemeParams->bypassFqidGeneration)
         p_SchemeRegs->kgse_hc |= KG_SCH_HASH_CONFIG_NO_FQID;
 
     /*  configure kgse_spc  */
-    if( p_Scheme->schemeCounter.update)
-        p_SchemeRegs->kgse_spc = p_Scheme->schemeCounter.value;
+    if( p_SchemeParams->schemeCounter.update)
+        p_SchemeRegs->kgse_spc = p_SchemeParams->schemeCounter.value;
 
 
     /* check that are enough generic registers */
-    if(p_Scheme->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
+    if(p_SchemeParams->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
         RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
 
     /* extracted OR mask on Qid */
-    for( i=0 ;i<p_Scheme->numOfUsedExtractedOrs ; i++)
+    for( i=0 ;i<p_SchemeParams->numOfUsedExtractedOrs ; i++)
     {
 
-        p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].extractedOrs = TRUE;
+        p_Scheme->extractedOrs = TRUE;
         /*  configure kgse_gec[i]  */
-        p_ExtractOr = &p_Scheme->extractedOrs[i];
+        p_ExtractOr = &p_SchemeParams->extractedOrs[i];
         switch(p_ExtractOr->type)
         {
             case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
@@ -2557,7 +2511,7 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
         {
             if(p_ExtractOr->bitOffsetInPlcrProfile > MAX_KG_SCH_PP_BIT_OFFSET )
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInPlcrProfile out of range)"));
-            p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile = p_ExtractOr->bitOffsetInPlcrProfile;
+            p_Scheme->bitOffsetInPlcrProfile = p_ExtractOr->bitOffsetInPlcrProfile;
             genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInPlcrProfile+16) << KG_SCH_GEN_SIZE_SHIFT);
             p_ExtractOr->mask &= GetExtractedOrMask(p_ExtractOr->bitOffsetInPlcrProfile, FALSE);
         }
@@ -2576,36 +2530,41 @@ t_Error FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t
 
     /* add base Qid for this scheme */
     /* add configuration for kgse_fqb */
-    if(p_Scheme->baseFqid & ~0x00FFFFFF)
+    if(p_SchemeParams->baseFqid & ~0x00FFFFFF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid must be between 1 and 2^24-1"));
 
-    fqbTmp |= p_Scheme->baseFqid;
+    fqbTmp |= p_SchemeParams->baseFqid;
     p_SchemeRegs->kgse_fqb = fqbTmp;
 
-    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine = p_Scheme->nextEngine;
-    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction = p_Scheme->kgNextEngineParams.doneAction;
+    p_Scheme->nextEngine = p_SchemeParams->nextEngine;
+    p_Scheme->doneAction = p_SchemeParams->kgNextEngineParams.doneAction;
+
     return E_OK;
 }
 
-void  FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+static void  FmPcdKgValidateSchemeSw(t_Handle h_Scheme)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    ASSERT_COND(!p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
+    uint32_t        intFlags;
 
-    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId != ILLEGAL_NETENV)
-        FmPcdIncNetEnvOwners(p_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
-    p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = TRUE;
+    ASSERT_COND(!p_Scheme->valid);
+    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+        FmPcdIncNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
+    intFlags = KgSchemeLock(p_Scheme);
+    p_Scheme->valid = TRUE;
+    KgSchemeUnlock(p_Scheme, intFlags);
 }
 
-void  FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+static void  FmPcdKgInvalidateSchemeSw(t_Handle h_Scheme)
 {
+    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
+    uint32_t        intFlags;
 
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId != ILLEGAL_NETENV)
-        FmPcdDecNetEnvOwners(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[schemeId].netEnvId);
-    p_FmPcd->p_FmPcdKg->schemes[schemeId].valid = FALSE;
+    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+        FmPcdDecNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
+    intFlags = KgSchemeLock(p_Scheme);
+    p_Scheme->valid = FALSE;
+    KgSchemeUnlock(p_Scheme, intFlags);
 }
 
 uint32_t FmPcdKgGetRequiredAction(t_Handle h_FmPcd, uint8_t schemeId)
@@ -2659,25 +2618,26 @@ bool FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId)
         return FALSE;
 
 }
-void FmPcdKgUpatePointedOwner(t_Handle h_FmPcd, uint8_t schemeId, bool add)
+void FmPcdKgUpatePointedOwner(t_Handle h_Scheme, bool add)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-   ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+    /* this routine is locked by the calling routine */
+   ASSERT_COND(p_Scheme->valid);
 
     if(add)
-        p_FmPcd->p_FmPcdKg->schemes[schemeId].pointedOwners++;
+        p_Scheme->pointedOwners++;
     else
-        p_FmPcd->p_FmPcdKg->schemes[schemeId].pointedOwners--;
+        p_Scheme->pointedOwners--;
 }
 
-e_FmPcdEngine FmPcdKgGetNextEngine(t_Handle h_FmPcd, uint8_t schemeId)
+e_FmPcdEngine FmPcdKgGetNextEngine(t_Handle h_FmPcd, uint8_t relativeSchemeId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].valid);
 
-    return p_FmPcd->p_FmPcdKg->schemes[schemeId].nextEngine;
+    return p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine;
 }
 
 e_FmPcdDoneAction FmPcdKgGetDoneAction(t_Handle h_FmPcd, uint8_t schemeId)
@@ -2689,27 +2649,31 @@ e_FmPcdDoneAction FmPcdKgGetDoneAction(t_Handle h_FmPcd, uint8_t schemeId)
     return p_FmPcd->p_FmPcdKg->schemes[schemeId].doneAction;
 }
 
-void FmPcdKgUpdateRequiredAction(t_Handle h_FmPcd, uint8_t schemeId, uint32_t requiredAction)
+void FmPcdKgUpdateRequiredAction(t_Handle h_Scheme, uint32_t requiredAction)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
+	/* this routine is protected by calling routine */
+
+    ASSERT_COND(p_Scheme->valid);
 
-    p_FmPcd->p_FmPcdKg->schemes[schemeId].requiredAction = requiredAction;
+    p_Scheme->requiredAction |= requiredAction;
 }
 
-t_Error FmPcdKgCheckInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId)
+t_Error FmPcdKgCheckInvalidateSchemeSw(t_Handle h_Scheme)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    if(schemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
-        REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
+    uint32_t        intFlags;
 
+    intFlags = KgSchemeLock(p_Scheme);
    /* check that no port is bound to this scheme */
-    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].owners)
+    if (p_Scheme->owners)
        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
-    if(!p_FmPcd->p_FmPcdKg->schemes[schemeId].valid)
+    if (!p_Scheme->valid){dump_stack();
        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete an invalid scheme"));
+    }
+    KgSchemeUnlock(p_Scheme, intFlags);
+
     return E_OK;
 }
 
@@ -2723,93 +2687,89 @@ uint32_t FmPcdKgBuildCppReg(t_Handle h_FmPcd, uint8_t clsPlanGrpId)
     return tmpKgpeCpp;
 }
 
-bool    FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg)
+bool FmPcdKgHwSchemeIsValid(uint32_t schemeModeReg)
 {
-
-    if(schemeModeReg & KG_SCH_MODE_EN)
-        return TRUE;
-    else
-        return FALSE;
+    return (bool)!!(schemeModeReg & KG_SCH_MODE_EN);
 }
 
-uint32_t    FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter)
+uint32_t FmPcdKgBuildWriteSchemeActionReg(uint8_t schemeId, bool updateCounter)
 {
-    return     (uint32_t)(((uint32_t)schemeId << FM_PCD_KG_KGAR_NUM_SHIFT)|
-                            FM_PCD_KG_KGAR_GO |
-                            FM_PCD_KG_KGAR_WRITE |
-                            FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
-                            DUMMY_PORT_ID |
-                            (updateCounter ? FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT:0));
-
+    return (uint32_t)(((uint32_t)schemeId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                      FM_PCD_KG_KGAR_GO |
+                      FM_PCD_KG_KGAR_WRITE |
+                      FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                      DUMMY_PORT_ID |
+                      (updateCounter ? FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT:0));
 }
 
-uint32_t    FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId)
+uint32_t FmPcdKgBuildReadSchemeActionReg(uint8_t schemeId)
 {
-    return     (uint32_t)(((uint32_t)schemeId << FM_PCD_KG_KGAR_NUM_SHIFT)|
-                            FM_PCD_KG_KGAR_GO |
-                            FM_PCD_KG_KGAR_READ |
-                            FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
-                            DUMMY_PORT_ID |
-                            FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT);
+    return (uint32_t)(((uint32_t)schemeId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                      FM_PCD_KG_KGAR_GO |
+                      FM_PCD_KG_KGAR_READ |
+                      FM_PCD_KG_KGAR_SEL_SCHEME_ENTRY |
+                      DUMMY_PORT_ID |
+                      FM_PCD_KG_KGAR_SCHEME_WSEL_UPDATE_CNT);
 
 }
 
-
-uint32_t    FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId)
+uint32_t FmPcdKgBuildWriteClsPlanBlockActionReg(uint8_t grpId)
 {
     return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                        FM_PCD_KG_KGAR_WRITE |
-                        FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
-                        DUMMY_PORT_ID |
-                        ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
-                        FM_PCD_KG_KGAR_WSEL_MASK);
-
-
-        /* if we ever want to write 1 by 1, use:
-        sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));*/
+                      FM_PCD_KG_KGAR_WRITE |
+                      FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                      DUMMY_PORT_ID |
+                      ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                      FM_PCD_KG_KGAR_WSEL_MASK);
+
+    /* if we ever want to write 1 by 1, use:
+       sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));
+     */
 }
 
-uint32_t    FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId)
+uint32_t FmPcdKgBuildReadClsPlanBlockActionReg(uint8_t grpId)
 {
     return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                        FM_PCD_KG_KGAR_READ |
-                        FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
-                        DUMMY_PORT_ID |
-                        ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
-                        FM_PCD_KG_KGAR_WSEL_MASK);
+                      FM_PCD_KG_KGAR_READ |
+                      FM_PCD_KG_KGAR_SEL_CLS_PLAN_ENTRY |
+                      DUMMY_PORT_ID |
+                      ((uint32_t)grpId << FM_PCD_KG_KGAR_NUM_SHIFT) |
+                      FM_PCD_KG_KGAR_WSEL_MASK);
 
 
-        /* if we ever want to write 1 by 1, use:
-        sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));*/
+    /* if we ever want to write 1 by 1, use:
+       sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));
+     */
 }
 
-uint32_t        FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId)
+uint32_t FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId)
 {
 
     return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                        FM_PCD_KG_KGAR_WRITE |
-                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
-                        hardwarePortId |
-                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
+                      FM_PCD_KG_KGAR_WRITE |
+                      FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                      hardwarePortId |
+                      FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
 }
 
-uint32_t        FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId)
+uint32_t FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId)
 {
 
     return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                        FM_PCD_KG_KGAR_READ |
-                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
-                        hardwarePortId |
-                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
+                      FM_PCD_KG_KGAR_READ |
+                      FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                      hardwarePortId |
+                      FM_PCD_KG_KGAR_SEL_PORT_WSEL_SP);
 }
-uint32_t        FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId)
+
+uint32_t FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId)
 {
 
     return (uint32_t)(FM_PCD_KG_KGAR_GO |
-                        FM_PCD_KG_KGAR_WRITE |
-                        FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
-                        hardwarePortId |
-                        FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP);
+                      FM_PCD_KG_KGAR_WRITE |
+                      FM_PCD_KG_KGAR_SEL_PORT_ENTRY |
+                      hardwarePortId |
+                      FM_PCD_KG_KGAR_SEL_PORT_WSEL_CPP);
 }
 
 uint8_t FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp)
@@ -2838,15 +2798,19 @@ uint8_t FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId)
     return FM_PCD_KG_NUM_OF_SCHEMES;
 }
 
-uint8_t FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd)
+uint8_t	FmPcdKgGetSchemeId(t_Handle h_Scheme)
 {
-    return ((t_FmPcd*)h_FmPcd)->p_FmPcdKg->numOfSchemes;
+    return ((t_FmPcdKgScheme*)h_Scheme)->schemeId;
+
 }
 
-uint8_t FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t relativeSchemeId)
+#if DPAA_VERSION >= 3
+bool FmPcdKgGetVspe(t_Handle h_Scheme)
 {
-    return ((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemesIds[relativeSchemeId];
+    return ((t_FmPcdKgScheme*)h_Scheme)->vspe;
+
 }
+#endif /* DPAA_VERSION >= 3 */
 
 uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
 {
@@ -2863,31 +2827,45 @@ uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
     return FM_PCD_KG_NUM_OF_SCHEMES;
 }
 
-t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t requiredAction)
+t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requiredAction, uint32_t value)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint8_t             relativeSchemeId, physicalSchemeId;
     uint32_t            tmpKgarReg, tmpReg32 = 0, intFlags;
     t_Error             err;
+    t_FmPcdKgScheme		*p_Scheme = (t_FmPcdKgScheme*)h_Scheme;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
 
+    /* if (FmPcdKgSchemeTryLock(p_FmPcd, &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]))
+        RETURN_ERROR(MAJOR, E_BUSY, ("Lock of the scheme FAILED")); */
+    if (!FmPcdKgIsSchemeValidSw(h_Scheme))
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+
+    intFlags = KgSchemeLock(h_Scheme);
+
     if (p_FmPcd->h_Hc)
-        return FmHcPcdKgCcGetSetParams(p_FmPcd->h_Hc,  h_Scheme,  requiredAction);
+    {
+        err = FmHcPcdKgCcGetSetParams(p_FmPcd->h_Hc, h_Scheme, requiredAction, value);
+
+        FmPcdKgUpatePointedOwner(h_Scheme,TRUE);
+        FmPcdKgUpdateRequiredAction(h_Scheme,requiredAction);
+
+        KgSchemeUnlock(h_Scheme, intFlags);
+        /* FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]); */
+        return err;
+    }
 
-    physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+    physicalSchemeId = p_Scheme->schemeId;
 
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
-    if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+    if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-    if (FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, FALSE))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Lock of the scheme FAILED"));
-
-    if(!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners ||
-       !(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction & requiredAction))
+    if (!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners ||
+        !(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction & requiredAction))
     {
         if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
@@ -2897,21 +2875,15 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t req
                     if(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction == e_FM_PCD_ENQ_FRAME)
                     {
                         tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-                        intFlags = FmPcdLock(p_FmPcd);
+                        intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
                         WriteKgarWait(p_FmPcd, tmpKgarReg);
-                        if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
-                        {
-                            FmPcdUnlock(p_FmPcd, intFlags);
-                            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
-                            RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
-                        }
                         tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
                         ASSERT_COND(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
                         WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, tmpReg32 | NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA);
                         /* call indirect command for scheme write */
                         tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
                         WriteKgarWait(p_FmPcd, tmpKgarReg);
-                        FmPcdUnlock(p_FmPcd, intFlags);
+                        KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                     }
                 break;
                 case(e_FM_PCD_PLCR):
@@ -2920,13 +2892,15 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t req
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile) ||
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile)
                         {
-                            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+                            KgSchemeUnlock(h_Scheme, intFlags);
+                            /*FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]);*/
                             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
                         }
                         err = FmPcdPlcrCcGetSetParams(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId, requiredAction);
                         if(err)
                         {
-                            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+                            KgSchemeUnlock(h_Scheme, intFlags);
+                            /*FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]);*/
                             RETURN_ERROR(MAJOR, err, NO_MSG);
                         }
                break;
@@ -2939,14 +2913,8 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t req
             if (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine == e_FM_PCD_CC)
             {
                 tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-                intFlags = FmPcdLock(p_FmPcd);
+                intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
                 WriteKgarWait(p_FmPcd, tmpKgarReg);
-                if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
-                {
-                    FmPcdUnlock(p_FmPcd, intFlags);
-                    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
-                    RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
-                }
                 tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
                 ASSERT_COND(tmpReg32 & (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 tmpReg32 &= ~NIA_FM_CTL_AC_CC;
@@ -2954,179 +2922,223 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t req
                 /* call indirect command for scheme write */
                 tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
                 WriteKgarWait(p_FmPcd, tmpKgarReg);
-                FmPcdUnlock(p_FmPcd, intFlags);
+                KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
            }
         }
+        if(requiredAction & UPDATE_KG_OPT_MODE)
+        {
+            tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+            intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+            WriteKgarWait(p_FmPcd, tmpKgarReg);
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_om, value);
+            /* call indirect command for scheme write */
+            tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+            WriteKgarWait(p_FmPcd, tmpKgarReg);
+            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+        }
+        if(requiredAction & UPDATE_KG_NIA)
+        {
+            tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+            intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+            WriteKgarWait(p_FmPcd, tmpKgarReg);
+            tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+            tmpReg32 &= ~(NIA_ENG_MASK | NIA_AC_MASK);
+            tmpReg32 |= value;
+            WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, tmpReg32);
+            /* call indirect command for scheme write */
+            tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+            WriteKgarWait(p_FmPcd, tmpKgarReg);
+            KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+        }
     }
-    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners += 1;
-    p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction |= requiredAction;
 
-    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+    FmPcdKgUpatePointedOwner(h_Scheme, TRUE);
+    FmPcdKgUpdateRequiredAction(h_Scheme, requiredAction);
+
+    /* FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]); */
+    KgSchemeUnlock(h_Scheme, intFlags);
+
     return E_OK;
 }
-
-t_Error FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId, bool intr)
+/*
+t_Error FmPcdKgSchemeTryLock(t_Handle h_FmPcd, t_Handle h_Scheme)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    bool        ans;
+    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-    if (intr)
-        ans = TRY_LOCK(NULL, &p_FmPcd->p_FmPcdKg->schemes[schemeId].lock);
-    else
-        ans = TRY_LOCK(p_FmPcd->h_Spinlock, &p_FmPcd->p_FmPcdKg->schemes[schemeId].lock);
-    if (ans)
+    if (TRY_LOCK(((t_FmPcd *)h_FmPcd)->p_FmPcdKg->h_SwSpinlock, &p_Scheme->lock))
         return E_OK;
     return ERROR_CODE(E_BUSY);
 }
 
-void FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId)
+void FmPcdKgReleaseSchemeLock(t_Handle h_Scheme)
 {
-    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdKg->schemes[schemeId].lock);
+    t_FmPcdKgScheme *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
+
+    RELEASE_LOCK(p_Scheme->lock);
 }
+*/
+/*********************** End of inter-module routines ************************/
+
 
-t_Handle FM_PCD_KgSetScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme)
+/****************************************/
+/*  API routines                        */
+/****************************************/
+t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemeParams)
 {
-    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                            tmpReg;
+    t_FmPcd                             *p_FmPcd;
     t_FmPcdKgInterModuleSchemeRegs      schemeRegs;
     t_FmPcdKgInterModuleSchemeRegs      *p_MemRegs;
     uint8_t                             i;
     t_Error                             err = E_OK;
     uint32_t                            tmpKgarReg;
     uint32_t                            intFlags;
-    uint8_t                             physicalSchemeId, relativeSchemeId;
+    uint8_t                             physicalSchemeId, relativeSchemeId = 0;
+    t_FmPcdKgScheme						*p_Scheme;
 
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
-
-    if (p_FmPcd->h_Hc)
-        return FmHcPcdKgSetScheme(p_FmPcd->h_Hc, p_Scheme);
+    if(p_SchemeParams->modify)
+    {
+	p_Scheme = (t_FmPcdKgScheme *)p_SchemeParams->id.h_Scheme;
+	p_FmPcd = p_Scheme->h_FmPcd;
 
-    /* if not called for modification, check first that this scheme is unused */
-    if(!p_Scheme->modify)
+	SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+        SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+    }
+    else
     {
+	p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+	SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
+        SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, NULL);
+        relativeSchemeId = p_SchemeParams->id.relativeSchemeId;
         /* check that schemeId is in range */
-        if(p_Scheme->id.relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
+        if(relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
         {
             REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
             return NULL;
         }
-        relativeSchemeId = p_Scheme->id.relativeSchemeId;
-
-        if (FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, FALSE))
-            return NULL;
 
-        physicalSchemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
-
-        /* read specified scheme into scheme registers */
-        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-        intFlags = FmPcdLock(p_FmPcd);
-        WriteKgarWait(p_FmPcd, tmpKgarReg);
-        tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
-        FmPcdUnlock(p_FmPcd, intFlags);
-
-        if (tmpReg & KG_SCH_MODE_EN)
+        p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
+        if(FmPcdKgIsSchemeValidSw(p_Scheme))
         {
             REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
-                         ("Scheme %d(phys %d) is already used", relativeSchemeId, physicalSchemeId));
-            RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+                         ("Scheme %d is already used", relativeSchemeId));
             return NULL;
         }
+
+	p_Scheme->schemeId = p_FmPcd->p_FmPcdKg->schemesIds[relativeSchemeId];
+	p_Scheme->h_FmPcd = p_FmPcd;
     }
-    else
-    {
-        SANITY_CHECK_RETURN_VALUE(p_Scheme->id.h_Scheme, E_INVALID_HANDLE, NULL);
 
-        intFlags = FmPcdLock(p_FmPcd);
-        physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_Scheme->id.h_Scheme)-1);
-        relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+/*
+    err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
+    if (err)
+        return NULL;
+*/
 
-        /* check that schemeId is in range */
-        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
-        {
-            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-            FmPcdUnlock(p_FmPcd, intFlags);
-            return NULL;
-        }
+    p_Scheme->h_Spinlock = XX_InitSpinlock();
+    if (!p_Scheme->h_Spinlock)
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM KG Scheme spinlock"));
 
-        err = FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, TRUE);
-        FmPcdUnlock(p_FmPcd, intFlags);
+    if (p_FmPcd->h_Hc)
+    {
+        err = FmHcPcdKgSetScheme(p_FmPcd->h_Hc, (t_Handle)p_Scheme, p_SchemeParams);
+        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
         if (err)
-            return NULL;
+        {
+          if (p_Scheme->h_Spinlock)
+              XX_FreeSpinlock(p_Scheme->h_Spinlock);
+          return NULL;
+        }
+		if (!p_SchemeParams->modify)
+			FmPcdKgValidateSchemeSw(p_Scheme);
+        return (t_Handle)p_Scheme;
     }
 
-    err = FmPcdKgBuildScheme(h_FmPcd, p_Scheme, &schemeRegs);
+    physicalSchemeId = p_Scheme->schemeId;
+
+
+    err = FmPcdKgBuildScheme((t_Handle)p_Scheme, p_SchemeParams, &schemeRegs);
     if(err)
     {
         REPORT_ERROR(MAJOR, err, NO_MSG);
-        FmPcdKgInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
-        RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+        /*FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]);*/
+        if (p_Scheme->h_Spinlock)
+            XX_FreeSpinlock(p_Scheme->h_Spinlock);
         return NULL;
     }
 
     /* configure all 21 scheme registers */
     p_MemRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs;
-    intFlags = FmPcdLock(p_FmPcd);
-    WRITE_UINT32(p_MemRegs->kgse_ppc, schemeRegs.kgse_ppc);
-    WRITE_UINT32(p_MemRegs->kgse_ccbs, schemeRegs.kgse_ccbs);
-    WRITE_UINT32(p_MemRegs->kgse_mode, schemeRegs.kgse_mode);
-    WRITE_UINT32(p_MemRegs->kgse_mv, schemeRegs.kgse_mv);
-    WRITE_UINT32(p_MemRegs->kgse_dv0, schemeRegs.kgse_dv0);
-    WRITE_UINT32(p_MemRegs->kgse_dv1, schemeRegs.kgse_dv1);
-    WRITE_UINT32(p_MemRegs->kgse_ekdv, schemeRegs.kgse_ekdv);
-    WRITE_UINT32(p_MemRegs->kgse_ekfc, schemeRegs.kgse_ekfc);
-    WRITE_UINT32(p_MemRegs->kgse_bmch, schemeRegs.kgse_bmch);
-    WRITE_UINT32(p_MemRegs->kgse_bmcl, schemeRegs.kgse_bmcl);
-    WRITE_UINT32(p_MemRegs->kgse_hc, schemeRegs.kgse_hc);
-    WRITE_UINT32(p_MemRegs->kgse_spc, schemeRegs.kgse_spc);
-    WRITE_UINT32(p_MemRegs->kgse_fqb, schemeRegs.kgse_fqb);
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+    WRITE_UINT32(p_MemRegs->kgse_ppc,   schemeRegs.kgse_ppc);
+    WRITE_UINT32(p_MemRegs->kgse_ccbs,  schemeRegs.kgse_ccbs);
+    WRITE_UINT32(p_MemRegs->kgse_mode,  schemeRegs.kgse_mode);
+    WRITE_UINT32(p_MemRegs->kgse_mv,    schemeRegs.kgse_mv);
+    WRITE_UINT32(p_MemRegs->kgse_dv0,   schemeRegs.kgse_dv0);
+    WRITE_UINT32(p_MemRegs->kgse_dv1,   schemeRegs.kgse_dv1);
+    WRITE_UINT32(p_MemRegs->kgse_ekdv,  schemeRegs.kgse_ekdv);
+    WRITE_UINT32(p_MemRegs->kgse_ekfc,  schemeRegs.kgse_ekfc);
+    WRITE_UINT32(p_MemRegs->kgse_bmch,  schemeRegs.kgse_bmch);
+    WRITE_UINT32(p_MemRegs->kgse_bmcl,  schemeRegs.kgse_bmcl);
+    WRITE_UINT32(p_MemRegs->kgse_hc,    schemeRegs.kgse_hc);
+    WRITE_UINT32(p_MemRegs->kgse_spc,   schemeRegs.kgse_spc);
+    WRITE_UINT32(p_MemRegs->kgse_fqb,   schemeRegs.kgse_fqb);
+    WRITE_UINT32(p_MemRegs->kgse_om,    schemeRegs.kgse_om);
+    WRITE_UINT32(p_MemRegs->kgse_vsp,   schemeRegs.kgse_vsp);
     for(i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
         WRITE_UINT32(p_MemRegs->kgse_gec[i], schemeRegs.kgse_gec[i]);
 
     /* call indirect command for scheme write */
-    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_Scheme->schemeCounter.update);
+    tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, p_SchemeParams->schemeCounter.update);
 
     WriteKgarWait(p_FmPcd, tmpKgarReg);
-    FmPcdUnlock(p_FmPcd, intFlags);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
-    FmPcdKgValidateSchemeSw(h_FmPcd, relativeSchemeId);
+    if (!p_SchemeParams->modify)
+		FmPcdKgValidateSchemeSw(p_Scheme);
 
-    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+    /* FmPcdKgReleaseSchemeLock(&p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId]); */
 
-    return UINT_TO_PTR((uint64_t)physicalSchemeId+1);
+    return (t_Handle)p_Scheme;
 }
 
-t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
+t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)(((t_FmPcdKgScheme *)h_Scheme)->h_FmPcd);
     uint8_t             physicalSchemeId;
     uint32_t            tmpKgarReg, intFlags;
     t_Error             err = E_OK;
-    uint8_t             relativeSchemeId;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    if (p_FmPcd->h_Hc)
-        return FmHcPcdKgDeleteScheme(p_FmPcd->h_Hc, h_Scheme);
-
-    physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
-    relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+    t_FmPcdKgScheme     *p_Scheme = (t_FmPcdKgScheme *)h_Scheme;
 
-    if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
-        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
+    SANITY_CHECK_RETURN_ERROR(h_Scheme, E_INVALID_HANDLE);
 
-    if ((err = FmPcdKgSchemeTryLock(p_FmPcd, relativeSchemeId, FALSE)) != E_OK)
-       RETURN_ERROR(MINOR, err, NO_MSG);
+    /*
+        err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
+        if (err)
+            return NULL;
+    */
 
     /* check that no port is bound to this scheme */
-    err = FmPcdKgCheckInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+    err = FmPcdKgCheckInvalidateSchemeSw(h_Scheme);
     if(err)
-       RETURN_ERROR(MINOR, err, NO_MSG);
+    {
+        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    if (p_FmPcd->h_Hc)
+    {
+        err = FmHcPcdKgDeleteScheme(p_FmPcd->h_Hc, h_Scheme);
+        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
+        FmPcdKgInvalidateSchemeSw(h_Scheme);
+        if (p_Scheme->h_Spinlock)
+            XX_FreeSpinlock(p_Scheme->h_Spinlock);
+        return err;
+    }
 
-    intFlags = FmPcdLock(p_FmPcd);
+    physicalSchemeId = ((t_FmPcdKgScheme *)h_Scheme)->schemeId;
+
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     /* clear mode register, including enable bit */
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, 0);
 
@@ -3134,69 +3146,74 @@ t_Error  FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme)
     tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
 
     WriteKgarWait(p_FmPcd, tmpKgarReg);
-    FmPcdUnlock(p_FmPcd, intFlags);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+
+    FmPcdKgInvalidateSchemeSw(p_Scheme);
 
-    FmPcdKgInvalidateSchemeSw(h_FmPcd, relativeSchemeId);
+    /* FmPcdKgReleaseSchemeLock(h_Scheme); */
 
-    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+    if (p_Scheme->h_Spinlock)
+        XX_FreeSpinlock(p_Scheme->h_Spinlock);
 
     return E_OK;
 }
 
-uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme)
+uint32_t  FM_PCD_KgSchemeGetCounter(t_Handle h_Scheme)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcd             *p_FmPcd;
     uint32_t            tmpKgarReg, spc, intFlags;
     uint8_t             physicalSchemeId;
 
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(h_Scheme, E_INVALID_HANDLE, 0);
 
+    p_FmPcd = (t_FmPcd*)(((t_FmPcdKgScheme *)h_Scheme)->h_FmPcd);
     if (p_FmPcd->h_Hc)
         return FmHcPcdKgGetSchemeCounter(p_FmPcd->h_Hc, h_Scheme);
 
-    physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+    physicalSchemeId = ((t_FmPcdKgScheme *)h_Scheme)->schemeId;
 
     if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
     tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-    intFlags = FmPcdLock(p_FmPcd);
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     WriteKgarWait(p_FmPcd, tmpKgarReg);
     if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
        REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
     spc = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_spc);
-    FmPcdUnlock(p_FmPcd, intFlags);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
 
     return spc;
 }
 
-t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t value)
+t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcd             *p_FmPcd;
     uint32_t            tmpKgarReg, intFlags;
     uint8_t             physicalSchemeId;
 
-    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
+    SANITY_CHECK_RETURN_VALUE(h_Scheme, E_INVALID_HANDLE, 0);
+
+    p_FmPcd = (t_FmPcd*)(((t_FmPcdKgScheme *)h_Scheme)->h_FmPcd);
+
+    if (!FmPcdKgIsSchemeValidSw(h_Scheme))
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdKgSetSchemeCounter(p_FmPcd->h_Hc, h_Scheme, value);
 
-    physicalSchemeId = (uint8_t)(PTR_TO_UINT(h_Scheme)-1);
+    physicalSchemeId = ((t_FmPcdKgScheme *)h_Scheme)->schemeId;
     /* check that schemeId is in range */
     if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
     /* read specified scheme into scheme registers */
     tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
-    intFlags = FmPcdLock(p_FmPcd);
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     WriteKgarWait(p_FmPcd, tmpKgarReg);
     if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
     {
-       FmPcdUnlock(p_FmPcd, intFlags);
+       KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
     }
 
@@ -3207,8 +3224,163 @@ t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t
     tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
 
     WriteKgarWait(p_FmPcd, tmpKgarReg);
-    FmPcdUnlock(p_FmPcd, intFlags);
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset)
+{
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, E_NULL_POINTER);
+
+    p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetAdditionalDataAfterParsing - guest mode!"));
+
+    WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
 
     return E_OK;
 }
 
+t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
+{
+   t_FmPcd              *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   t_FmPcdKgRegs        *p_Regs;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((valueId == 0) || (valueId == 1)), E_INVALID_VALUE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, E_NULL_POINTER);
+
+    p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetDfltValue - guest mode!"));
+
+    if(valueId == 0)
+        WRITE_UINT32(p_Regs->kggdv0r,value);
+    else
+        WRITE_UINT32(p_Regs->kggdv1r,value);
+    return E_OK;
+}
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                 i = 0, j = 0;
+    uint8_t             hardwarePortId = 0;
+    uint32_t            tmpKgarReg, intFlags;
+    t_Error             err = E_OK;
+    t_FmPcdIpcMsg       msg;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_PCD_KG_DUMP_REGS;
+        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                 (uint8_t*)&msg,
+                                 sizeof(msg.msgId),
+                                 NULL,
+                                 NULL,
+                                 NULL,
+                                 NULL);
+    }
+    DUMP_SUBTITLE(("\n"));
+    DUMP_TITLE(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, ("FmPcdKgRegs Regs"));
+
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggcr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgeeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgseeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggsr);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgtpc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgserc);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfdor);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv0r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kggdv1r);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgfeer);
+    DUMP_VAR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs,kgar);
+
+    DUMP_SUBTITLE(("\n"));
+    intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
+    for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
+    {
+        tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
+        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mode);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekfc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ekdv);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmch);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_bmcl);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_fqb);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_hc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ppc);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec, ("kgse_gec"));
+        DUMP_SUBSTRUCT_ARRAY(i, FM_PCD_KG_NUM_OF_GENERIC_REGS)
+        {
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_gec[i], sizeof(uint32_t));
+        }
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_spc);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv0);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_dv1);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_ccbs);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs,kgse_mv);
+    }
+    DUMP_SUBTITLE(("\n"));
+
+    for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
+    {
+        SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
+
+        tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
+
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
+
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_sp);
+        DUMP_VAR(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, kgoe_cpp);
+    }
+
+    DUMP_SUBTITLE(("\n"));
+    for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
+    {
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
+        DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
+
+        tmpKgarReg = FmPcdKgBuildReadClsPlanBlockActionReg((uint8_t)j);
+        err = WriteKgarWait(p_FmPcd, tmpKgarReg);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        DUMP_SUBSTRUCT_ARRAY(i, 8)
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
+    }
+    KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
+
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index 4d88f7e..b6a199c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -55,7 +55,7 @@
 #undef WRITE_UINT8
 #undef GET_UINT8
 
-#define WRITE_UINT16(addr, val)  \
+#define WRITE_UINT16(addr, val)     \
     do{                             \
             if((int)&(addr) % 4)    \
                 WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
@@ -130,14 +130,167 @@ static uint8_t GET_UINT8_ERRATA(uint8_t *addr)
 
 #endif /* CORE_8BIT_ACCESS_ERRATA */
 
-static t_Error GetPrOffsetByNonHeader(uint8_t *parseArrayOffset)
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+
+static uint8_t CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    /*For now - the only field in the Parse Array from the NON_BY_TYPE can be e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE*/
-    /*Maybe extended in the future*/
+	uint8_t dataSize, remain, tableSize = 0;
+
+	if(p_FmPcdManipParams->u.hdr.rmv)
+		tableSize += HMCD_SIZE_RMV;
+
+	if(p_FmPcdManipParams->u.hdr.insrt)
+	{
+		remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
+		if(remain)
+			dataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
+		else
+			dataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
+		tableSize += (uint8_t)(HMCD_SIZE_INSRT + dataSize);
+	}
+	return tableSize;
+}
 
-    *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+static t_Error BuildHmct(t_FmPcdManipParams *p_FmPcdManipParams, uint32_t *p_HmcdTbl)
+{
+	uint32_t		*p_TmpData, *p_TmpPtr = (uint32_t *)p_HmcdTbl;
+	uint32_t		tmpReg = 0, *p_Last = NULL;
+	uint8_t			remain, i, size = 0, origSize, *p_Data = NULL;
+
+	if(p_FmPcdManipParams->u.hdr.rmv)
+	{
+	    if(p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_GENERIC)
+	    {
+            /* initialize HMCD */
+            tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_RMV) << HMCD_OC_SHIFT;
+            /* tmp, should be conditional */
+            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset << HMCD_RMV_OFFSET_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size << HMCD_RMV_SIZE_SHIFT;
+	    }
+
+		WRITE_UINT32(*p_TmpPtr, tmpReg);
+		/* save a pointer to the "last" indication word */
+		p_Last = p_TmpPtr;
+		/* advance to next command */
+		p_TmpPtr += HMCD_SIZE_RMV/4;
+	}
+
+	if(p_FmPcdManipParams->u.hdr.insrt)
+	{
+        if(p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
+        {
+            /* initialize HMCD */
+            if(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
+                tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_INSRT) << HMCD_OC_SHIFT;
+            else
+                tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_INSRT) << HMCD_OC_SHIFT;
 
-    return E_OK;
+            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.offset << HMCD_INSRT_OFFSET_SHIFT;
+            tmpReg |= p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size << HMCD_INSRT_SIZE_SHIFT;
+
+            size = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
+            p_Data = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.p_Data;
+        }
+
+        WRITE_UINT32(*(uint32_t*)p_TmpPtr, tmpReg);
+        /* save a pointer to the "last" indication word */
+        p_Last = p_TmpPtr;
+
+        p_TmpPtr += HMCD_SIZE_INSRT/4;
+
+        /* initialize data to be inserted */
+		/* if size is not a multiple of 4, padd with 0's */
+        origSize = size;
+		remain = (uint8_t)(size % 4);
+		if(remain)
+		{
+			size += (uint8_t)(4 - remain);
+			p_TmpData = (uint32_t *)XX_Malloc(size);
+			memset((uint8_t *)p_TmpData, 0, size);
+			memcpy((uint8_t *)p_TmpData, p_Data, origSize);
+		}
+		else
+			p_TmpData = (uint32_t*)p_Data;
+
+		/* initialize data and advance pointer to next command */
+		for (i = 0; i<size/4 ; i++, p_TmpPtr++)
+			WRITE_UINT32(*p_TmpPtr, *(p_TmpData+i));
+
+		if(remain)
+			XX_Free(p_TmpData);
+	}
+	/* If this node has a nextManip, and no parsing is required after it, the old table must be copied to the new table
+	   the old table and should be freed */
+	if(p_FmPcdManipParams->h_NextManip && (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
+	{
+		/* copy old table to new location */
+		memcpy((uint8_t *)p_TmpPtr, MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip));
+		/* free old table */
+		FM_MURAM_FreeMem(MANIP_GET_MURAM(p_FmPcdManipParams->h_NextManip), MANIP_GET_HMCT_PTR(p_FmPcdManipParams->h_NextManip));
+		/* update old manip table pointer */
+		MANIP_SET_HMCT_PTR(p_FmPcdManipParams->h_NextManip, p_TmpPtr);
+		p_TmpPtr += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)/4;
+	}
+	else
+		/* set the "last" indication on the last command of the current table */
+		WRITE_UINT32(*p_Last, GET_UINT32(*p_Last) | HMCD_LAST);
+
+	return E_OK;
+}
+
+static t_Error CreateManipAction(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
+{
+	t_Error		err;
+	uint16_t	tmpReg;
+
+	/* set Manip structure */
+	if(p_FmPcdManipParams->h_NextManip)
+    {
+	if(MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+		p_Manip->tableSize = MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip);
+	else
+		p_Manip->cascadedNext = TRUE;
+
+		p_Manip->h_NextManip = p_FmPcdManipParams->h_NextManip;
+	/* save a "prev" pointer in h_NextManip */
+		MANIP_SET_PREV(p_FmPcdManipParams->h_NextManip, p_Manip);
+	FmPcdManipUpdateOwner(p_FmPcdManipParams->h_NextManip, TRUE);
+    }
+    p_Manip->dontParseAfterManip = p_FmPcdManipParams->u.hdr.dontParseAfterManip;
+
+	/* Allocate new table */
+    /* calculate table size according to manip parameters */
+    p_Manip->tableSize += CalculateTableSize(p_FmPcdManipParams);
+	p_Manip->p_HmcdTbl = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->tableSize, 4);
+
+    /* Fill table */
+	err = BuildHmct(p_FmPcdManipParams, p_Manip->p_HmcdTbl);
+	if (err)
+		RETURN_ERROR(MINOR, err, NO_MSG);
+
+	/* Build HMTD (table descriptor) */
+	tmpReg = HMTD_CFG_TYPE; /* NADEN = 0 */
+	/* add parseAfterManip */
+	if (!p_Manip->dontParseAfterManip)
+		tmpReg |= HMTD_CFG_PRS_AFTER_HM;
+	if (p_FmPcdManipParams->h_NextManip && (!MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
+	{
+		/* indicate that there's another HM table descriptor */
+		tmpReg |= HMTD_CFG_NEXT_AD_EN;
+		WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->nextAdIdx,
+					 (uint16_t)((XX_VirtToPhys(MANIP_GET_HMTD_PTR(p_FmPcdManipParams->h_NextManip)) -
+							    (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)) >> 4));
+	}
+	WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->cfg, tmpReg);
+	WRITE_UINT32(((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
+			(uint32_t)(XX_VirtToPhys(p_Manip->p_HmcdTbl) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+
+	WRITE_UINT8(((t_Hmtd *)p_Manip->h_Ad)->opCode, HMAN_OC);
+
+	return E_OK;
 }
 
 static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
@@ -277,40 +430,39 @@ static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_
     if(p_Manip->updateParams)
     {
 
-        if((!(p_Manip->updateParams & OFFSET_OF_DATA) &&
-           !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
-           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)))
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
+           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
-        p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree, e_FM_MANIP_CAPWAP_INDX);
+        p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
         if(!p_SavedManipParams)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
-        p_Manip->fragParams.poolId = p_SavedManipParams->capwapParams.poolId;
         p_Manip->fragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
 
         tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
-        tmpReg32 |= ((uint32_t)p_Manip->fragParams.poolId << 8);
         tmpReg32 |= ((uint32_t)p_Manip->fragParams.dataOffset<< 16);
         WRITE_UINT32(p_Ad->pcAndOffsets,tmpReg32);
 
         p_Manip->updateParams &= ~OFFSET_OF_DATA;
-        p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
-        p_Manip->shadowUpdateParams |= (OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP);
+        p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
     }
    else if (validate)
    {
 
-        p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree, e_FM_MANIP_CAPWAP_INDX);
+        p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
         if(!p_SavedManipParams)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
-        if((p_Manip->fragParams.poolId != p_SavedManipParams->capwapParams.poolId) ||
-           (p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset))
+        if(p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
    }
 
     return E_OK;
 }
 
-static t_Error UpdateInitCapwapFragmentation(t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate, t_Handle h_FmTree)
+static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
+                                             t_FmPcdManip   *p_Manip,
+                                             t_Handle       h_Ad,
+                                             bool           validate,
+                                             t_Handle       h_FmTree)
 {
     t_AdOfTypeContLookup        *p_Ad;
     t_FmPortGetSetCcParams      fmPortGetSetCcParams;
@@ -323,51 +475,44 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle h_FmPort, t_FmPcdManip *p_
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(((p_Manip->type == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->type == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(((p_Manip->type == HMAN_OC_CAPWAP_FRAGMENTATION) ||
+                               (p_Manip->type == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
 
     p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
-        if((!(p_Manip->updateParams & OFFSET_OF_DATA) &&
-           !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
-           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)))
+        if ((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
+            ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
-        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
-        /*for CAPWAP Rassembly used FMAN_CTRL2 hardcoded - so for fragmentation its better to use FMAN_CTRL1*/
+        /* For CAPWAP Rassembly used FMAN_CTRL2 hardcoded - so for fragmentation its better to use FMAN_CTRL1 */
         fmPortGetSetCcParams.setCcParams.orFmanCtrl = FPM_PORT_FM_CTL1;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool doe header manipulation wasn't configured previousely"));
 
         p_SavedManipParams = (t_FmPcdCcSavedManipParams *)XX_Malloc(sizeof(t_FmPcdCcSavedManipParams));
         p_SavedManipParams->capwapParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
-        p_SavedManipParams->capwapParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
 
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
         ASSERT_COND(!(p_SavedManipParams->capwapParams.dataOffset % 16));
-#endif
+#endif /* FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004 */
 
-        FmPcdCcTreeSetSavedManipParams(h_FmTree, (t_Handle)p_SavedManipParams, e_FM_MANIP_CAPWAP_INDX);
+        FmPcdCcTreeSetSavedManipParams(h_FmTree, (t_Handle)p_SavedManipParams);
     }
     else if (validate)
     {
-        if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
-            !(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
-            ((p_Manip->updateParams & OFFSET_OF_DATA) ||
-            (p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)))
+        if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) ||
+            ((p_Manip->updateParams & OFFSET_OF_DATA)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
-        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
@@ -376,47 +521,41 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle h_FmPort, t_FmPcdManip *p_
 
         if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool doe header manipulation wasn't configured previousely"));
     }
 
     if(p_Manip->updateParams)
     {
         tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
-        tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.poolIdForManip << 8);
         tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.dataOffset<< 16);
         WRITE_UINT32(p_Ad->pcAndOffsets,tmpReg32);
 
         p_Manip->updateParams &= ~OFFSET_OF_DATA;
-        p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
-        p_Manip->shadowUpdateParams |= (OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP);
-        p_Manip->fragParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
+        p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
         p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
     }
     else if (validate)
     {
-        if((p_Manip->fragParams.poolId != fmPortGetSetCcParams.getCcParams.poolIdForManip) ||
-           (p_Manip->fragParams.dataOffset != fmPortGetSetCcParams.getCcParams.dataOffset))
+        if (p_Manip->fragParams.dataOffset != fmPortGetSetCcParams.getCcParams.dataOffset)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
     }
 
     return E_OK;
 }
 
-static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
-                                     t_Handle                       h_FmPort,
-                                     t_FmPcdManip                   *p_Manip,
-                                     t_Handle                       h_Ad,
-                                     bool                           validate)
+static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
+                                     t_Handle      h_FmPort,
+                                     t_FmPcdManip  *p_Manip,
+                                     t_Handle      h_Ad,
+                                     bool          validate)
 {
-    t_CapwapReasmPram  *p_ReassmTbl;
-    t_Error             err;
-    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
-    uint8_t             i = 0;
-    uint16_t            size;
-    uint32_t            tmpReg32;
-    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdCcCapwapReassmTimeoutParams ccCapwapReassmTimeoutParams;
+    t_CapwapReasmPram                   *p_ReassmTbl;
+    t_Error                             err;
+    t_FmPortGetSetCcParams              fmPortGetSetCcParams;
+    uint8_t                             i = 0;
+    uint16_t                            size;
+    uint32_t                            tmpReg32;
+    t_FmPcd                             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcCapwapReassmTimeoutParams  ccCapwapReassmTimeoutParams;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
@@ -425,88 +564,89 @@ static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
     SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
 
-    if(p_Manip->h_FmPcd != h_FmPcd)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("handler of PCD previously was initiated by different value"));
+    if (p_Manip->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("handler of PCD previously was initiated by different value"));
 
     UNUSED(h_Ad);
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
     p_ReassmTbl  = (t_CapwapReasmPram *)p_Manip->h_Frag;
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
-        if((!(p_Manip->updateParams & NUM_OF_TASKS) && !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP) &&
-        !(p_Manip->updateParams & OFFSET_OF_DATA) && !(p_Manip->updateParams & OFFSET_OF_PR) &&
-        !(p_Manip->updateParams & HW_PORT_ID)) ||
-           ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) ||
-           (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR)
-           ||(p_Manip->shadowUpdateParams & HW_PORT_ID)))
+        if ((!(p_Manip->updateParams & NUM_OF_TASKS) &&
+             !(p_Manip->updateParams & OFFSET_OF_DATA) &&
+             !(p_Manip->updateParams & OFFSET_OF_PR) &&
+             !(p_Manip->updateParams & HW_PORT_ID)) ||
+            ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) ||
+             (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR) ||
+             (p_Manip->shadowUpdateParams & HW_PORT_ID)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
-        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+
+        if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("buffser pool id  wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+        if (fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
         ASSERT_COND((fmPortGetSetCcParams.getCcParams.dataOffset % 16) == 0);
-#endif
+#endif /* FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004 */
     }
     else if (validate)
     {
-         if((!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) && (!(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)) &&
-         (!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) && (!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) &&
-         (!(p_Manip->shadowUpdateParams & HW_PORT_ID))) &&
-           ((p_Manip->updateParams & NUM_OF_TASKS) ||
-           (p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP) ||
-           (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR)||
-            (p_Manip->updateParams & HW_PORT_ID)))
-
+         if ((!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
+              !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
+              !(p_Manip->shadowUpdateParams & OFFSET_OF_PR) &&
+              !(p_Manip->shadowUpdateParams & HW_PORT_ID)) &&
+             ((p_Manip->updateParams & NUM_OF_TASKS) ||
+              (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR) ||
+              (p_Manip->updateParams & HW_PORT_ID)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
-        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool for header manipulation wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+
+        if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previously"));
+        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previously"));
+        if (fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
     }
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
-        if(p_Manip->updateParams & NUM_OF_TASKS)
+        if (p_Manip->updateParams & NUM_OF_TASKS)
         {
             /*recommendation of Microcode team - (maxNumFramesInProcess * 2) */
             size = (uint16_t)(p_Manip->fragParams.maxNumFramesInProcess*2 + fmPortGetSetCcParams.getCcParams.numOfTasks);
-            if(size  > 255)
+            if (size  > 255)
                 RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"));
 
             p_Manip->fragParams.numOfTasks = fmPortGetSetCcParams.getCcParams.numOfTasks;
 
             /*p_ReassmFrmDescrIndxPoolTbl*/
-            p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                              (uint32_t)(size + 1),
-                                              4);
-            if(!p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl =
+                (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                            (uint32_t)(size + 1),
+                                            4);
+            if (!p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer index pool table"));
 
             IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size + 1));
 
@@ -518,12 +658,13 @@ static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
             WRITE_UINT32(p_ReassmTbl->reasmFrmDescIndexPoolTblPtr, tmpReg32);
 
             /*p_ReassmFrmDescrPoolTbl*/
-            p_Manip->fragParams.p_ReassmFrmDescrPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                              (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
-                                              4);
+            p_Manip->fragParams.p_ReassmFrmDescrPoolTbl =
+                (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                            (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
+                                            4);
 
            if(!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer pool table"));
 
             IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl, 0,  (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
 
@@ -533,37 +674,24 @@ static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
 
             /*p_TimeOutTbl*/
 
-            p_Manip->fragParams.p_TimeOutTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                              (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
-                                              4);
+            p_Manip->fragParams.p_TimeOutTbl =
+                (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                            (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
+                                            4);
 
             if(!p_Manip->fragParams.p_TimeOutTbl)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly timeout table"));
 
             IOMemSet32(p_Manip->fragParams.p_TimeOutTbl, 0,  (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
 
             tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_TimeOutTbl) - p_FmPcd->physicalMuramBase);
             WRITE_UINT32(p_ReassmTbl->timeOutTblPtr, tmpReg32);
 
-
             p_Manip->updateParams &= ~NUM_OF_TASKS;
             p_Manip->shadowUpdateParams |= NUM_OF_TASKS;
-       }
-
-       if(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)
-       {
-
-            p_Manip->fragParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
-
-            tmpReg32 = GET_UINT32(p_ReassmTbl->bufferPoolIdAndRisc1SetIndexes);
-            tmpReg32 |= (uint32_t)p_Manip->fragParams.poolId << 16;
-            WRITE_UINT32(p_ReassmTbl->bufferPoolIdAndRisc1SetIndexes, tmpReg32);
-
-            p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
-            p_Manip->shadowUpdateParams |= BUFFER_POOL_ID_FOR_MANIP;
-       }
+        }
 
-        if(p_Manip->updateParams & OFFSET_OF_DATA)
+        if (p_Manip->updateParams & OFFSET_OF_DATA)
         {
             p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
             tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
@@ -572,7 +700,8 @@ static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
             p_Manip->updateParams &= ~OFFSET_OF_DATA;
             p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
         }
-        if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+
+        if (!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
         {
             p_Manip->fragParams.prOffset = fmPortGetSetCcParams.getCcParams.prOffset;
 
@@ -591,12 +720,11 @@ static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
            p_Manip->fragParams.prOffset = 0xff;
            p_Manip->updateParams &= ~OFFSET_OF_PR;
            p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
-
        }
 
-        p_Manip->fragParams.hwPortId = fmPortGetSetCcParams.getCcParams.hardwarePortId;
-        p_Manip->updateParams &= ~HW_PORT_ID;
-        p_Manip->shadowUpdateParams |= HW_PORT_ID;
+       p_Manip->fragParams.hwPortId = fmPortGetSetCcParams.getCcParams.hardwarePortId;
+       p_Manip->updateParams &= ~HW_PORT_ID;
+       p_Manip->shadowUpdateParams |= HW_PORT_ID;
 
         /*timeout hc */
        ccCapwapReassmTimeoutParams.fqidForTimeOutFrames = p_Manip->fragParams.fqidForTimeOutFrames;
@@ -604,29 +732,27 @@ static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
        ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl |= (uint32_t)((XX_VirtToPhys(p_ReassmTbl) - p_FmPcd->physicalMuramBase));
        ccCapwapReassmTimeoutParams.timeoutRequestTime = (((uint32_t)1<<p_Manip->fragParams.bitFor1Micro) * p_Manip->fragParams.timeoutRoutineRequestTime)/2;
        return FmHcPcdCcCapwapTimeoutReassm(p_FmPcd->h_Hc,&ccCapwapReassmTimeoutParams);
-
     }
-    else if(validate)
+
+    else if (validate)
     {
-        if(fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)
+        if (fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
-        if(fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
+        if (fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
 
-        if(fmPortGetSetCcParams.getCcParams.poolIdForManip != p_Manip->fragParams.poolId)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("poolId for this manipulation previously was defined by another value "));
 
-        if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+        if (!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
         {
-            if(p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
+            if (p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
         }
         else
         {
-            if(p_Manip->fragParams.prOffset != 0xff)
+            if (p_Manip->fragParams.prOffset != 0xff)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
         }
-        if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
+        if (fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));
     }
 
@@ -634,117 +760,114 @@ static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
 }
 #endif /* FM_CAPWAP_SUPPORT */
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-static t_Error CreateIpReassCommonParamTable(t_FmPcdManip *p_Manip,
-                                             t_FmPcd *p_FmPcd ,
-                                             t_IpReasmCommonTbl *p_IpReasmCommonPramTbl)
+static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
 {
     uint32_t    tmpReg32 = 0, i;
     uint64_t    tmpReg64, size;
+    bool        couplingPort;
+    t_FmPcd     *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
     t_Error     err = E_OK;
 
     /* Allocation of the IP Reassembly Common Parameters table. This table is located in the
     MURAM. Its size is 64 bytes and its base address should be 8-byte aligned.
     It contains parameters that are common to both the IPv4 reassembly function and IPv6
     reassembly function.*/
-    p_Manip->ipReassmParams.h_IpReassCommonParamsTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                       FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE,
-                                                       FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN);
+    p_Manip->ipReassmParams.p_IpReassCommonTbl =
+        (t_IpReassCommonTbl *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE,
+                                                FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN);
 
-    if(!p_Manip->ipReassmParams.h_IpReassCommonParamsTbl)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+    if (!p_Manip->ipReassmParams.p_IpReassCommonTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly common parameters table"));
 
-    p_IpReasmCommonPramTbl = (t_IpReasmCommonTbl *)(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
-
-    IOMemSet32(p_IpReasmCommonPramTbl, 0,  FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE);
+    IOMemSet32(p_Manip->ipReassmParams.p_IpReassCommonTbl, 0,  FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE);
 
+    couplingPort = (bool)(p_Manip->ipReassmParams.h_CouplingFmPort ? TRUE : FALSE);
     /* Setting the TimeOut Mode.*/
     tmpReg32 = 0;
-    if(p_Manip->ipReassmParams.timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
+    if (p_Manip->ipReassmParams.timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
         tmpReg32 |= FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES;
 
     /* Setting TimeOut FQID - Frames that time out are enqueued to this FQID.
     In order to cause TimeOut frames to be discarded, this queue should be configured accordingly*/
     tmpReg32 |= p_Manip->ipReassmParams.fqidForTimeOutFrames;
-    WRITE_UINT32(p_IpReasmCommonPramTbl->timeoutModeAndFqid, tmpReg32);
+    if (couplingPort)
+        tmpReg32 |= FM_PCD_MANIP_IP_REASM_COUPLING_ENABLE;
+    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->timeoutModeAndFqid, tmpReg32);
 
     /* Calculation the size of IP Reassembly Frame Descriptor - number of frames that are allowed to be reassembled simultaneously + 128.*/
     size = p_Manip->ipReassmParams.maxNumFramesInProcess + 128;
 
     /*Allocation of IP Reassembly Frame Descriptor Indexes Pool - This pool resides in the MURAM */
-    p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                      (uint32_t)(size * 2),
-                                      256);
-    if(!p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+    p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr =
+         PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                       (uint32_t)(size * 2),
+                                       256));
+    if (!p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly frame descriptor indexes pool"));
 
-    IOMemSet32(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size * 2));
+    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr), 0,  (uint32_t)(size * 2));
 
     /* The entries in IP Reassembly Frame Descriptor Indexes Pool contains indexes starting with 1 up to
     the maximum number of frames that are allowed to be reassembled simultaneously + 128.
     The last entry in this pool must contain the index zero*/
-    for( i = 0; i < size - 1; i++)
-        WRITE_UINT16(*(uint16_t *)PTR_MOVE_16(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl, i), (uint16_t)(i+1));
+    for (i=0; i<(size-1); i++)
+        WRITE_UINT16(*(uint16_t *)PTR_MOVE(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr), (i<<1)),
+                     (uint16_t)(i+1));
 
     /* Sets the IP Reassembly Frame Descriptor Indexes Pool offset from MURAM */
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
-    WRITE_UINT32(p_IpReasmCommonPramTbl->reassFrmDescIndexPoolTblPtr, tmpReg32);
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)) - p_FmPcd->physicalMuramBase);
+    if (couplingPort)
+        tmpReg32 |= ((FmPortGetHardwarePortId(p_Manip->ipReassmParams.h_CouplingFmPort) << FM_PCD_MANIP_IP_REASM_COUPLING_SHIFT) & FM_PCD_MANIP_IP_REASM_COUPLING_MASK);
+    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->reassFrmDescIndexPoolTblPtr, tmpReg32);
 
     /* Allocation of the Reassembly Frame Descriptors Pool - This pool resides in external memory.
     The number of entries in this pool should be equal to the number of entries in IP Reassembly Frame Descriptor Indexes Pool.*/
-    p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl = (t_Handle)XX_MallocSmart((uint32_t)(size * 64), p_Manip->ipReassmParams.dataMemId, 64);
+    p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr =
+        PTR_TO_UINT(XX_MallocSmart((uint32_t)(size * 64), p_Manip->ipReassmParams.dataMemId, 64));
 
-    if(!p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl)
+    if(!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
 
-    IOMemSet32(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl, 0,  (uint32_t)(size * 32));
+    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr), 0,  (uint32_t)(size * 32));
 
     /* Sets the Reassembly Frame Descriptors Pool and liodn offset*/
-    tmpReg64 = (uint64_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl));
+    tmpReg64 = (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)));
     tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
     tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
-    WRITE_UINT32(p_IpReasmCommonPramTbl->liodnAndReassFrmDescPoolPtrHi, (uint32_t)(tmpReg64 >> 32));
-    WRITE_UINT32(p_IpReasmCommonPramTbl->reassFrmDescPoolPtrLow, (uint32_t)tmpReg64);
+    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->liodnAndReassFrmDescPoolPtrHi, (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->reassFrmDescPoolPtrLow, (uint32_t)tmpReg64);
 
     /*Allocation of the TimeOut table - This table resides in the MURAM.
     The number of entries in this table is identical to the number of entries in the Reassembly Frame Descriptors Pool*/
-    p_Manip->ipReassmParams.h_TimeOutTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                           (uint32_t)(size  * 8),8);
+    p_Manip->ipReassmParams.timeOutTblAddr =
+        PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)(size  * 8),8));
 
-    if(!p_Manip->ipReassmParams.h_TimeOutTbl)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+    if(!p_Manip->ipReassmParams.timeOutTblAddr)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly timeout table"));
 
-    IOMemSet32(p_Manip->ipReassmParams.h_TimeOutTbl, 0,  (uint16_t)(size * 8));
+    IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr), 0,  (uint16_t)(size * 8));
 
     /* Sets the TimeOut table offset from MURAM*/
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_TimeOutTbl) - p_FmPcd->physicalMuramBase);
-    WRITE_UINT32(p_IpReasmCommonPramTbl->timeOutTblPtr, tmpReg32);
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr)) - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->timeOutTblPtr, tmpReg32);
 
     /* Sets the Expiration Delay */
     tmpReg32 = 0;
     tmpReg32 |= p_Manip->ipReassmParams.timeoutThresholdForReassmProcess * 256;
-    WRITE_UINT32(p_IpReasmCommonPramTbl->expirationDelay, tmpReg32);
-
-    /* Counts the number of TimeOut occurrences - Must be initialized to zero.*/
-    WRITE_UINT32(p_IpReasmCommonPramTbl->totalTimeOutCounter, 0);
-    /* Counts the number of failed attempts to allocate a Reassembly Frame Descriptor - Must be initialized to zero.*/
-    WRITE_UINT32(p_IpReasmCommonPramTbl->totalRfdPoolBusyCounter, 0);
-    /* Counts the number of times an internal buffer busy occured.*/
-    WRITE_UINT32(p_IpReasmCommonPramTbl->totalInternalBufferBusy, 0);
-    /* Counts the number of times external buffer busy occured. */
-    WRITE_UINT32(p_IpReasmCommonPramTbl->totalExternalBufferBusy, 0);
-
-    err = FmPcdRegisterReassmPort(p_FmPcd, p_IpReasmCommonPramTbl);
+    WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->expirationDelay, tmpReg32);
+
+    err = FmPcdRegisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
     if (err != E_OK)
     {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_IpReasmCommonPramTbl);
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_IpReassCommonTbl);
         RETURN_ERROR(MAJOR, err, ("port registration"));
     }
 
     return err;
 }
 
-static t_Handle CreateIpReassParamTable(t_FmPcdManip *p_Manip,  bool ipv4)
+static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
 {
     t_FmPcd                 *p_FmPcd = p_Manip->h_FmPcd;
     uint32_t                tmpReg32, autoLearnHashTblSize;
@@ -752,29 +875,41 @@ static t_Handle CreateIpReassParamTable(t_FmPcdManip *p_Manip,  bool ipv4)
     uint32_t                waySize, numOfSets, tmpNumOfSets, numOfEntries;
     uint64_t                tmpReg64;
     uint16_t                minFragSize;
-    t_Handle                *h_AutoLearnHashTbl, *h_AutoLearnSetLockTblPtr, h_IpReassParamsTblPtr;
-    t_IpReasmPram           *p_IpReassParamsTblPtr;
+    uintptr_t               *p_AutoLearnHashTblAddr, *p_AutoLearnSetLockTblAddr;
+    t_IpReassTbl            **p_IpReassTbl;
 
-    /* Allocates the IP Reassembly Parameters Table - This table is located in the MURAM.*/
-    h_IpReassParamsTblPtr = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                        FM_PCD_MANIP_IP_REASM_TABLE_SIZE,
-                                                        FM_PCD_MANIP_IP_REASM_TABLE_ALIGN);
-
-    if(!h_IpReassParamsTblPtr)
+    if (ipv4)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
-        return NULL;
+        p_IpReassTbl = &p_Manip->ipReassmParams.p_Ipv4ReassTbl;
+        p_AutoLearnHashTblAddr = &p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr;
+        p_AutoLearnSetLockTblAddr = &p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr;
+        minFragSize = p_Manip->ipReassmParams.minFragSize[0];
+        numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry[0];
+        waySize = ROUND_UP(((4 + 4 + 1 + 2)),8);
+    }
+    else
+    {
+        p_IpReassTbl = &p_Manip->ipReassmParams.p_Ipv6ReassTbl;
+        p_AutoLearnHashTblAddr = &p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr;
+        p_AutoLearnSetLockTblAddr = &p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr;
+        minFragSize = p_Manip->ipReassmParams.minFragSize[1];
+        numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry[1];
+        waySize = ROUND_UP(((16 + 16 + 4) /* * numOfWays*/),8);
+        if (numOfWays > e_FM_PCD_MANIP_SIX_WAYS_HASH)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("num of ways"));
     }
 
-    p_IpReassParamsTblPtr = (t_IpReasmPram *)h_IpReassParamsTblPtr;
-    memset(p_IpReassParamsTblPtr, 0, sizeof(t_IpReasmPram));
+    /* Allocates the IP Reassembly Parameters Table - This table is located in the MURAM.*/
+    *p_IpReassTbl = (t_IpReassTbl *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                      FM_PCD_MANIP_IP_REASM_TABLE_SIZE,
+                                                      FM_PCD_MANIP_IP_REASM_TABLE_ALIGN);
+    if(!*p_IpReassTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly IPv4/IPv6 specific parameters table"));
+    memset(*p_IpReassTbl, 0, sizeof(t_IpReassTbl));
 
     /* Sets the IP Reassembly common Parameters table offset from MURAM in the IP Reassembly Table descriptor*/
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl) - p_FmPcd->physicalMuramBase);
-    WRITE_UINT32(p_IpReassParamsTblPtr->ipReassCommonPrmTblPtr, tmpReg32);
-
-    /* Get user's requested number of ways */
-    numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry;
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_IpReassCommonTbl) - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32((*p_IpReassTbl)->ipReassCommonPrmTblPtr, tmpReg32);
 
     /*It is recommended that the total number of entries in this table
     (number of sets * number of ways) will be twice the number of frames that
@@ -784,21 +919,6 @@ static t_Handle CreateIpReassParamTable(t_FmPcdManip *p_Manip,  bool ipv4)
     /* sets number calculation - number of entries = number of sets * number of ways */
     numOfSets = numOfEntries / numOfWays;
 
-    /* Calculates way size */
-    switch(p_Manip->ipReassmParams.hdr)
-    {
-        case(HEADER_TYPE_IPv6):
-            /* WaySize is rounded-up to next multiple of 8 */
-            waySize = ROUND_UP(((16 + 16 + 4) /* * numOfWays*/),8);
-            break;
-        case(HEADER_TYPE_IPv4):
-            waySize = ROUND_UP(((4 + 4 + 1 + 2)),8);
-            break;
-        default:
-            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
-            return NULL;
-    }
-
     /* Calculate set size (set size is rounded-up to next power of 2) */
     LOG2(numOfWays * waySize, tmpSetSize);
     setSize =  (uint32_t)(1 << (tmpSetSize + (POWER_OF_2(numOfWays * waySize) ? 0 : 1)));
@@ -807,12 +927,12 @@ static t_Handle CreateIpReassParamTable(t_FmPcdManip *p_Manip,  bool ipv4)
     LOG2(setSize, setSizeCode);
 
     /* Sets ways number and set size code */
-    WRITE_UINT16(p_IpReassParamsTblPtr->waysNumAndSetSize, (uint16_t)((numOfWays << 8) | setSizeCode));
+    WRITE_UINT16((*p_IpReassTbl)->waysNumAndSetSize, (uint16_t)((numOfWays << 8) | setSizeCode));
 
     /* Sets AutoLearnHashKeyMask*/
     LOG2(numOfSets, tmpNumOfSets);
     numOfSets = (uint32_t)(1 << (tmpNumOfSets + (POWER_OF_2(numOfSets) ? 0 : 1)));
-    WRITE_UINT16(p_IpReassParamsTblPtr->autoLearnHashKeyMask, (uint16_t)(numOfSets - 1));
+    WRITE_UINT16((*p_IpReassTbl)->autoLearnHashKeyMask, (uint16_t)(numOfSets - 1));
 
     /* Allocation of IP Reassembly Automatic Learning Hash Table - This table resides in external memory.
     The size of this table is determined by the number of sets and the set size.
@@ -820,67 +940,47 @@ static t_Handle CreateIpReassParamTable(t_FmPcdManip *p_Manip,  bool ipv4)
     This tables base address should be aligned to SetSize.*/
     autoLearnHashTblSize = numOfSets * setSize;
 
-    if (ipv4)
-        h_AutoLearnHashTbl = &p_Manip->ipReassmParams.h_Ipv4AutoLearnHashTbl;
-    else
-        h_AutoLearnHashTbl = &p_Manip->ipReassmParams.h_Ipv6AutoLearnHashTbl;
-
-    *h_AutoLearnHashTbl = (t_Handle)XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize);
-
-    if(!*h_AutoLearnHashTbl)
+    *p_AutoLearnHashTblAddr = PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize));
+    if(!*p_AutoLearnHashTblAddr)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
-        return NULL;
+	FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
+	*p_IpReassTbl = NULL;
+	RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
-    IOMemSet32(*h_AutoLearnHashTbl, 0,  autoLearnHashTblSize);
+    IOMemSet32(UINT_TO_PTR(*p_AutoLearnHashTblAddr), 0,  autoLearnHashTblSize);
 
     /* Sets the IP Reassembly Automatic Learning Hash Table and liodn offset */
     tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
     tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
-    tmpReg64 |= XX_VirtToPhys(*h_AutoLearnHashTbl);
-    WRITE_UINT32(p_IpReassParamsTblPtr->liodnAlAndAutoLearnHashTblPtrHi, (uint32_t)(tmpReg64 >> 32));
-    WRITE_UINT32(p_IpReassParamsTblPtr->autoLearnHashTblPtrLow, (uint32_t)tmpReg64);
+    tmpReg64 |= XX_VirtToPhys(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
+    WRITE_UINT32((*p_IpReassTbl)->liodnAlAndAutoLearnHashTblPtrHi, (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32((*p_IpReassTbl)->autoLearnHashTblPtrLow, (uint32_t)tmpReg64);
 
     /* Allocation of the Set Lock table - This table resides in external memory
     The size of this table is (number of sets in the IP Reassembly Automatic Learning Hash table)*4 bytes.
     This table resides in external memory and its base address should be 4-byte aligned */
-    if (ipv4)
-        h_AutoLearnSetLockTblPtr = &p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr;
-    else
-        h_AutoLearnSetLockTblPtr = &p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr;
-
-    *h_AutoLearnSetLockTblPtr = (t_Handle)XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4);
-
-    if(!*h_AutoLearnSetLockTblPtr)
+    *p_AutoLearnSetLockTblAddr = PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4));
+    if(!*p_AutoLearnSetLockTblAddr)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
-        return NULL;
+	FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
+	*p_IpReassTbl = NULL;
+	XX_FreeSmart(UINT_TO_PTR(*p_AutoLearnHashTblAddr));
+	*p_AutoLearnHashTblAddr = 0;
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
     }
-
-    IOMemSet32(*h_AutoLearnSetLockTblPtr, 0,  (numOfSets * 4));
+    IOMemSet32(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr), 0,  (numOfSets * 4));
 
     /* sets Set Lock table pointer and liodn offset*/
     tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
     tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
-    tmpReg64 |= XX_VirtToPhys(*h_AutoLearnSetLockTblPtr);
-    WRITE_UINT32(p_IpReassParamsTblPtr->liodnSlAndAutoLearnSetLockTblPtrHi, (uint32_t)(tmpReg64 >> 32));
-    WRITE_UINT32(p_IpReassParamsTblPtr->autoLearnSetLockTblPtrLow, (uint32_t)tmpReg64);
+    tmpReg64 |= XX_VirtToPhys(UINT_TO_PTR(*p_AutoLearnSetLockTblAddr));
+    WRITE_UINT32((*p_IpReassTbl)->liodnSlAndAutoLearnSetLockTblPtrHi, (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32((*p_IpReassTbl)->autoLearnSetLockTblPtrLow, (uint32_t)tmpReg64);
 
     /* Sets user's requested minimum fragment size (in Bytes) for First/Middle fragment */
-    minFragSize = ipv4 ? p_Manip->ipReassmParams.minFragSize[0] : p_Manip->ipReassmParams.minFragSize[1];
-    WRITE_UINT16(p_IpReassParamsTblPtr->minFragSize, minFragSize);
-
-    /* Zeroes all counters */
-    WRITE_UINT32(p_IpReassParamsTblPtr->totalSuccessfullyReasmFramesCounter, 0);
-    WRITE_UINT32(p_IpReassParamsTblPtr->totalValidFragmentCounter, 0);
-    WRITE_UINT32(p_IpReassParamsTblPtr->totalProcessedFragCounter, 0);
-    WRITE_UINT32(p_IpReassParamsTblPtr->totalMalformdFragCounter, 0);
-    WRITE_UINT32(p_IpReassParamsTblPtr->totalSetBusyCounter, 0);
-    WRITE_UINT32(p_IpReassParamsTblPtr->totalDiscardedFragsCounter, 0);
-    WRITE_UINT32(p_IpReassParamsTblPtr->totalMoreThan16FramesCounter, 0);
-
-    /* Return the pointer to the IP Reassembly table */
-    return h_IpReassParamsTblPtr;
+    WRITE_UINT16((*p_IpReassTbl)->minFragSize, minFragSize);
+
+    return E_OK;
 }
 
 static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
@@ -904,6 +1004,9 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
 
     UNUSED(h_Ad);
 
+    if (!p_Manip->updateParams)
+        return E_OK;
+
     if( p_Manip->ipReassmParams.h_Ipv4Ad != NULL)
          p_Ipv4Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv4Ad;
     if( p_Manip->ipReassmParams.h_Ipv6Ad != NULL)
@@ -914,72 +1017,66 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
+    fmPortGetSetCcParams.setCcParams.type = 0;
+    fmPortGetSetCcParams.getCcParams.type = FM_REV;
+    if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev >= 6)
+    {
+        if (p_Manip->ipReassmParams.h_CouplingFmPort)
+        {
+            fmPortGetSetCcParams.getCcParams.type = 0;
+            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FNE;
+            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_SWITCH_PORT | NIA_ENG_FM_CTL;
+            fmPortGetSetCcParams.setCcParams.immediateWrite = TRUE;
+            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        /* set special operational mode bits: KOMV=1(valid), OVOM=0(setting one), NENQ=1, NL=1, CWD=1.
+         * set the scheme NIA to BMI */
+        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd));
+        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme, UPDATE_KG_OPT_MODE, 0x8000001c);
+        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_NIA, GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd));
+        FmPcdKgCcGetSetParams(h_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme, UPDATE_KG_OPT_MODE, 0x8000001c);
+    }
+
+    if(p_Manip->ipReassmParams.h_Ipv4Scheme)
+    {
+        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv4Scheme;
+        p_PcdParams->p_KgParams->numOfSchemes++;
+    }
+    if(p_Manip->ipReassmParams.h_Ipv6Scheme)
+    {
+        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv6Scheme;
+        p_PcdParams->p_KgParams->numOfSchemes++;
+    }
 
     if(p_Manip->updateParams)
     {
-        if((!(p_Manip->updateParams & OFFSET_OF_DATA) && !(p_Manip->updateParams & HW_PORT_ID)) ||
-           ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) ||
-           (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) ||(p_Manip->shadowUpdateParams & HW_PORT_ID)))
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
+           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
-        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
-        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
-        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        fmPortGetSetCcParams.setCcParams.type = 0;
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
-        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
-        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_RFENE;
-        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ORDER_RESTOR);
-        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previously"));
         if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previously"));
-        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
-
-        if(p_Manip->ipReassmParams.h_Ipv4Scheme)
-        {
-            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv4Scheme;
-            p_PcdParams->p_KgParams->numOfSchemes++;
-        }
-        if(p_Manip->ipReassmParams.h_Ipv6Scheme)
-        {
-            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv6Scheme;
-            p_PcdParams->p_KgParams->numOfSchemes++;
-        }
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
     }
     else if (validate)
     {
-         if((!(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) &&
-         (!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) &&
-         (!(p_Manip->shadowUpdateParams & HW_PORT_ID))) &&
-           ((p_Manip->updateParams & NUM_OF_TASKS) ||
-           (p_Manip->updateParams & OFFSET_OF_DATA) ||
-            (p_Manip->updateParams & HW_PORT_ID)))
+        if((!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) ||
+           ((p_Manip->updateParams & OFFSET_OF_DATA)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
 
-        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
-        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
-        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
-        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
-        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_RFENE;
-        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ORDER_RESTOR);
-        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
-        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+         fmPortGetSetCcParams.setCcParams.type = 0;
+         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+         if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+             RETURN_ERROR(MAJOR, err, NO_MSG);
+         if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data wasn't configured previously"));
     }
 
     if(p_Manip->updateParams)
@@ -999,85 +1096,60 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
                 tmpReg32 |= (p_Manip->ipReassmParams.dataOffset << 16);
                 WRITE_UINT32(p_Ipv6Ad->matchTblPtr, tmpReg32);
             }
-
             p_Manip->updateParams &= ~OFFSET_OF_DATA;
             p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
         }
-        if(p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))
+        if (p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))
         {
-            t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
-            t_IpReasmCommonTbl  *p_IpReasmCommonPramTbl;
-            uint8_t             *p_Ptr, i, totalNumOfTnums;
-            uint32_t            tmpReg32;
+            t_FmPcd     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+            uint8_t     *p_Ptr, i, totalNumOfTnums;
+            uint32_t    tmpReg32;
 
-            totalNumOfTnums = (fmPortGetSetCcParams.getCcParams.numOfTasks +
-                               fmPortGetSetCcParams.getCcParams.numOfExtraTasks);
+            totalNumOfTnums = (uint8_t)(fmPortGetSetCcParams.getCcParams.numOfTasks +
+                                        fmPortGetSetCcParams.getCcParams.numOfExtraTasks);
 
             p_Manip->ipReassmParams.internalBufferPoolAddr =
                     PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  totalNumOfTnums * BMI_FIFO_UNITS,
+                                                  (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS),
                                                   BMI_FIFO_UNITS));
             if (!p_Manip->ipReassmParams.internalBufferPoolAddr)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly internal buffers pool"));
             IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr),
                        0,
-                       totalNumOfTnums * BMI_FIFO_UNITS);
+                       (uint32_t)(totalNumOfTnums * BMI_FIFO_UNITS));
 
             p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr =
                     PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                  5 + totalNumOfTnums,
+                                                  (uint32_t)(5 + totalNumOfTnums),
                                                   4));
             if (!p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly internal buffers management"));
 
             p_Ptr = (uint8_t*)UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr);
-            WRITE_UINT32(*(uint32_t*)p_Ptr, (uint32_t)XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr)) - p_FmPcd->physicalMuramBase);
-            for (i=0,p_Ptr+=4;i<totalNumOfTnums;i++,p_Ptr++)
+            WRITE_UINT32(*(uint32_t*)p_Ptr, (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr)) - p_FmPcd->physicalMuramBase));
+            for (i=0, p_Ptr += 4; i < totalNumOfTnums; i++, p_Ptr++)
                 WRITE_UINT8(*p_Ptr, i);
             WRITE_UINT8(*p_Ptr, 0xFF);
 
             tmpReg32 = (4 << FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_SHIFT) |
-                       ((uint32_t)XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)) - p_FmPcd->physicalMuramBase);
-            p_IpReasmCommonPramTbl = (t_IpReasmCommonTbl *)(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
-            WRITE_UINT32(p_IpReasmCommonPramTbl->internalBufferManagement, tmpReg32);
+                       ((uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)) - p_FmPcd->physicalMuramBase));
+            WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->internalBufferManagement, tmpReg32);
 
             p_Manip->updateParams &= ~(NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
             p_Manip->shadowUpdateParams |= (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
         }
     }
-    else
+    else if(validate)
     {
-        if(validate)
-        {
-            /* TODO - Handle validate..*/
-            /*if(fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
-            if(fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
-
-            if(fmPortGetSetCcParams.getCcParams.poolIdForManip != p_Manip->fragParams.poolId)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("poolId for this manipulation previously was defined by another value "));
-
-            if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
-            {
-                if(p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
-            }
-            else
-            {
-                if(p_Manip->fragParams.prOffset != 0xff)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
-            }
-            if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));*/
-
-        }
+        if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->ipReassmParams.dataOffset)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value"));
     }
 
     return E_OK;
 }
 
-t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
+#if (DPAA_VERSION == 2)
+static t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
 {
     t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdCcFragScratchPoolCmdParams   fmPcdCcFragScratchPoolCmdParams;
@@ -1098,7 +1170,7 @@ t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
     return E_OK;
 }
 
-t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid)
+static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid)
 {
     t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdCcFragScratchPoolCmdParams   fmPcdCcFragScratchPoolCmdParams;
@@ -1117,7 +1189,7 @@ t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid)
 
     return E_OK;
 }
-#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
+#endif /* (DPAA_VERSION == 2) */
 
 static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 {
@@ -1147,123 +1219,127 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Frag);
 
     }
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
     if (p_Manip->frag)
     {
         if (p_Manip->ipFragParams.p_Frag)
         {
+#if (DPAA_VERSION == 2)
             FmPcdFragHcScratchPoolEmpty((t_Handle)p_FmPcd, p_Manip->ipFragParams.scratchBpid);
+#endif /* (DPAA_VERSION == 2) */
+
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
         }
     }
     else if (p_Manip->reassm)
     {
-        FmPcdUnregisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
-
-        if(p_Manip->ipReassmParams.h_Ipv4AutoLearnHashTbl)
-            XX_Free(p_Manip->ipReassmParams.h_Ipv4AutoLearnHashTbl);
-        if(p_Manip->ipReassmParams.h_Ipv6AutoLearnHashTbl)
-            XX_Free(p_Manip->ipReassmParams.h_Ipv6AutoLearnHashTbl);
-        if(p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr)
-            XX_Free(p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr);
-        if(p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr)
-            XX_Free(p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr);
-        if(p_Manip->ipReassmParams.h_TimeOutTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_TimeOutTbl);
-        if(p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr);
-        if(p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr);
-        if(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
-        if(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl)
-            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl);
-        if(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl)
-            XX_Free(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl);
+        FmPcdUnregisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
+
+        if(p_Manip->ipReassmParams.timeOutTblAddr)
+		FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr));
+        if(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
+		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr));
+
+        if(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr)
+		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnHashTblAddr));
+        if(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr)
+		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnHashTblAddr));
+        if(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr)
+		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv4AutoLearnSetLockTblAddr));
+        if(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr)
+		XX_FreeSmart(UINT_TO_PTR(p_Manip->ipReassmParams.ipv6AutoLearnSetLockTblAddr));
+        if(p_Manip->ipReassmParams.p_Ipv4ReassTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv4ReassTbl);
+        if(p_Manip->ipReassmParams.p_Ipv6ReassTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_Ipv6ReassTbl);
+        if(p_Manip->ipReassmParams.p_IpReassCommonTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.p_IpReassCommonTbl);
+        if(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrIndxPoolTblAddr));
         if(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr));
         if(p_Manip->ipReassmParams.internalBufferPoolAddr)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr));
     }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
     if(p_Manip->p_StatsTbl)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_StatsTbl);
 }
 
+#ifdef FM_CAPWAP_SUPPORT
 static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
 {
 
-    if(p_ManipParams->rmv)
+    if(p_ManipParams->u.hdr.rmv)
     {
-        switch(p_ManipParams->rmvParams.type)
+        switch(p_ManipParams->u.hdr.rmvParams.type)
         {
-            case(e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION):
-                switch(p_ManipParams->rmvParams.rmvSpecificLocationParams.type)
+            case(e_FM_PCD_MANIP_RMV_BY_HDR):
+                switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
                 {
-                    case(e_FM_PCD_MANIP_LOC_BY_HDR) :
-                        switch(p_ManipParams->rmvParams.rmvSpecificLocationParams.manipByHdr.hdr)
+                    case(e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
+                        if(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
                         {
-                            case(HEADER_TYPE_CAPWAP_DTLS) :
-
-                                p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
-                                p_Manip->muramAllocate = TRUE;
-
-                                if(p_ManipParams->insrt)
-                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
-
-                                if(p_ManipParams->fragOrReasm)
-                                {
-                                    if(!p_ManipParams->fragOrReasmParams.frag)
+                            switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            {
+                                case(HEADER_TYPE_CAPWAP_DTLS) :
+                                    p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+                                    p_Manip->muramAllocate = TRUE;
+                                    if(p_ManipParams->u.hdr.insrt)
+                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
+                                    if(p_ManipParams->fragOrReasm)
                                     {
-                                        switch(p_ManipParams->fragOrReasmParams.hdr)
+                                        if(!p_ManipParams->fragOrReasmParams.frag)
                                         {
-                                            case(HEADER_TYPE_CAPWAP):
-                                                p_Manip->type = HMAN_OC_CAPWAP_REASSEMBLY;
-                                                break;
-                                            default:
-                                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
+                                            switch(p_ManipParams->fragOrReasmParams.hdr)
+                                            {
+                                                case(HEADER_TYPE_CAPWAP):
+                                                    p_Manip->type = HMAN_OC_CAPWAP_REASSEMBLY;
+                                                    break;
+                                                default:
+                                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
+                                            }
                                         }
+                                        else
+                                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for this type of manipulation frag can not be TRUE"));
                                     }
-                                    else
-                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for this type of manipulation frag can not be TRUE"));
-                                }
-                            break;
-                            default:
-                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid net header of remove location"));
-
+                                break;
+                                default:
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid net header of remove location"));
+                            }
+                        }
+                        else
+                        {
+                            switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            {
+                                case(HEADER_TYPE_CAPWAP_DTLS) :
+                                case(HEADER_TYPE_CAPWAP) :
+                                    if  (p_ManipParams->fragOrReasm || p_ManipParams->u.hdr.insrt)
+                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"));
+                                    p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                                    p_Manip->muramAllocate = TRUE;
+                                    p_ManipParams->u.hdr.insrt = TRUE; //internal frame header
+                                    break;
+                                default :
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+                            }
                         }
                         break;
-                        default:
-                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid type of remove location"));
-
-                }
-            break;
-            case(e_FM_PCD_MANIP_RMV_INT_FRAME_HDR) :
-                if(p_ManipParams->insrt || p_ManipParams->fragOrReasm)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For the type of remove e_FM_PCD_MANIP_RMV_INT_FRAME_HDR the only valid option rmv = TRUE, insrt = FALSE, fragOrReasm = FALSE"));
-                p_Manip->type = HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
-                p_Manip->muramAllocate = FALSE;
-            break;
-            case(e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION) :
-                if  (p_ManipParams->fragOrReasm ||
-                    ((p_ManipParams->insrt) && p_ManipParams->insrtParams.type != e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION the only allowed insertion type is e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR"));
-                p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
-                p_Manip->muramAllocate = TRUE;
-           break;
+                    default :
+                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+               }
+               break;
            default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
         }
     }
-    else if(p_ManipParams->insrt)
+    else if(p_ManipParams->u.hdr.insrt)
     {
-        switch(p_ManipParams->insrtParams.type)
+        switch(p_ManipParams->u.hdr.insrtParams.type)
         {
-            case(e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE) :
+            case(e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
 
                 p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
                 p_Manip->muramAllocate = FALSE;
-
                 if(p_ManipParams->fragOrReasm)
                 {
                     if(p_ManipParams->fragOrReasmParams.frag)
@@ -1273,7 +1349,6 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                                 case(HEADER_TYPE_CAPWAP):
                                     p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
                                     break;
-                                break;
                                 default:
                                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header for fragmentation"));
                            }
@@ -1281,13 +1356,8 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                     else
                         RETURN_ERROR(MAJOR, E_INVALID_STATE,("can not reach this point"));
                 }
-            break;
-            case(e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR) :
-                if(p_ManipParams->fragOrReasm)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of insert can not be fragOrReasm = TRUE"));
-                p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
-                p_Manip->muramAllocate = TRUE;
-            break;
+                break;
+
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
         }
@@ -1297,20 +1367,13 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
         if(p_ManipParams->fragOrReasmParams.frag)
         {
             switch(p_ManipParams->fragOrReasmParams.hdr)
-             {
-                 case(HEADER_TYPE_CAPWAP):
-                     p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
-                     p_Manip->muramAllocate = FALSE;
-                 break;
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-                 case(HEADER_TYPE_IPv4):
-                 case(HEADER_TYPE_IPv6):
-                     p_Manip->type = HMAN_OC_IP_FRAGMENTATION;
-                     p_Manip->muramAllocate = TRUE;
-                 break;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-                 default:
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for fragmentation"));
+            {
+                case(HEADER_TYPE_CAPWAP):
+                    p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
+                    p_Manip->muramAllocate = FALSE;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for fragmentation"));
              }
         }
         else
@@ -1319,7 +1382,57 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
             {
                 case(HEADER_TYPE_CAPWAP):
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+                default:
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
+            }
+        }
+
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("User didn't ask for any manipulation"));
+
+    p_Manip->insrt = p_ManipParams->u.hdr.insrt;
+    p_Manip->rmv   = p_ManipParams->u.hdr.rmv;
+
+    return E_OK;
+}
+#else /* not FM_CAPWAP_SUPPORT */
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
+{
+
+    switch (p_ManipParams->type)
+    {
+        case e_FM_PCD_MANIP_HDR :
+            if(p_ManipParams->u.hdr.rmv)
+            {
+                switch(p_ManipParams->u.hdr.rmvParams.type)
+                {
+                   case(e_FM_PCD_MANIP_RMV_GENERIC):
+                       p_Manip->type = HMAN_OC;
+                       p_Manip->muramAllocate = TRUE;
+                       break;
+                   default:
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+                }
+                p_Manip->rmv = TRUE;
+            }
+            else if(p_ManipParams->u.hdr.insrt)
+            {
+                switch(p_ManipParams->u.hdr.insrtParams.type)
+                {
+                    case(e_FM_PCD_MANIP_INSRT_GENERIC):
+                        p_Manip->type = HMAN_OC;
+                        p_Manip->muramAllocate = TRUE;
+                        break;
+                    default:
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
+                }
+                p_Manip->insrt = TRUE;
+            }
+            break;
+        case e_FM_PCD_MANIP_REASSEM :
+            switch(p_ManipParams->u.reassem.hdr)
+            {
                 case(HEADER_TYPE_IPv4):
                     p_Manip->type = HMAN_OC_IP_REASSEMBLY;
                     p_Manip->muramAllocate = TRUE;
@@ -1330,25 +1443,48 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                     p_Manip->muramAllocate = TRUE;
                     p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv6;
                     break;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
                 default:
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
-
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for reassembly"));
+             }
+            break;
+        case e_FM_PCD_MANIP_FRAG :
+            switch(p_ManipParams->u.frag.hdr)
+            {
+                case(HEADER_TYPE_IPv4):
+                case(HEADER_TYPE_IPv6):
+                    p_Manip->type = HMAN_OC_IP_FRAGMENTATION;
+                    p_Manip->muramAllocate = TRUE;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for fragmentation"));
+             }
+            break;
+        case e_FM_PCD_MANIP_SPECIAL_OFFLOAD :
+            switch(p_ManipParams->u.specialOffload.type)
+            {
+                case (e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC):
+                    p_Manip->type = HMAN_OC_IPSEC_MANIP;
+                    p_Manip->muramAllocate = TRUE;
+                    break;
+                default:
+                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("special offload type"));
             }
-        }
-
+            break;
+        default :
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("manip type"));
     }
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("User didn't ask for any manipulation"));
 
-    p_Manip->insrt = p_ManipParams->insrt;
-    p_Manip->rmv   = p_ManipParams->rmv;
+    if (p_Manip->owner && p_Manip->h_PrevManip)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No sharing on cascaded internal nodes"));
 
     return E_OK;
 }
-static t_Error UpdateIndxStats(  t_Handle                       h_FmPcd,
-                                 t_Handle                       h_FmPort,
-                                 t_FmPcdManip                   *p_Manip)
+#endif /* not FM_CAPWAP_SUPPORT */
+
+#ifdef FM_CAPWAP_SUPPORT
+static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
+                               t_Handle     h_FmPort,
+                               t_FmPcdManip *p_Manip)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t                tmpReg32 = 0;
@@ -1377,11 +1513,12 @@ static t_Error UpdateIndxStats(  t_Handle                       h_FmPcd,
 
         tmpReg32 = GET_UINT32(p_Ad->ccAdBase);
 
-        p_Manip->p_StatsTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                          (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
-                                          4);
+        p_Manip->p_StatsTbl =
+            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                        (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
+                                        4);
         if(!p_Manip->p_StatsTbl)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation indexed statistics table"));
 
         IOMemSet32(p_Manip->p_StatsTbl, 0,  (uint32_t)(p_Manip->owner * 4));
 
@@ -1392,7 +1529,6 @@ static t_Error UpdateIndxStats(  t_Handle                       h_FmPcd,
 
         tmpReg32 |=  FM_PCD_MANIP_INDEXED_STATS_DPD;
         WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
-
     }
     else
     {
@@ -1402,51 +1538,56 @@ static t_Error UpdateIndxStats(  t_Handle                       h_FmPcd,
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
+
     return E_OK;
 }
+#endif /* FM_CAPWAP_SUPPORT */
 
-static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree)
+static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
+                                    t_Handle h_PcdParams,
+                                    t_Handle h_FmPort,
+                                    t_Handle h_Manip,
+                                    t_Handle h_Ad,
+                                    bool     validate,
+                                    int      level,
+                                    t_Handle h_FmTree)
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
     t_Error      err = E_OK;
+
     SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+
     UNUSED(level);
     UNUSED(h_FmPcd);
     UNUSED(h_FmTree);
-#ifndef FM_IP_FRAG_N_REASSEM_SUPPORT
-    UNUSED(h_PcdParams);
-#endif /* not FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     switch(p_Manip->type)
     {
         case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-        err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
-        break;
+            err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
+            break;
 #ifdef FM_CAPWAP_SUPPORT
         case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             if(!p_Manip->h_Frag)
                 break;
         case(HMAN_OC_CAPWAP_FRAGMENTATION):
             err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
-        break;
+            break;
         case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if(p_Manip->h_Frag)
-            {
+            if (p_Manip->h_Frag)
                 err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
-            }
+            break;
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
             break;
 #endif /* FM_CAPWAP_SUPPORT */
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
         case(HMAN_OC_IP_REASSEMBLY):
             err = UpdateInitIpReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
             break;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
-            err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
-            break;
         default:
             return E_OK;
     }
+
     return err;
 }
 
@@ -1455,18 +1596,21 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
 
     t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
     t_Error         err = E_OK;
+
     UNUSED(level);
+
     switch(p_Manip->type)
     {
         case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
         case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
 
-           if(p_Manip->h_Frag)
+           if (p_Manip->h_Frag)
            {
-               if(!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) && !(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) &&
-               !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) && !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation requires manipulation be updated previousely in SetPcd function"));
+               if (!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
+                   !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
+                   !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation requires manipulation be updated previously in SetPcd function"));
            }
            break;
 #ifdef FM_CAPWAP_SUPPORT
@@ -1479,21 +1623,21 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
 #endif /* FM_CAPWAP_SUPPORT */
         default:
             return E_OK;
-
     }
-    return err;
 
+    return err;
 }
 
-static t_Error GetPrOffsetByHeaderOrField(t_FmPcdManipLocationParams *p_ManipParams, uint8_t *parseArrayOffset)
+#ifdef FM_CAPWAP_SUPPORT
+static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *parseArrayOffset)
 {
-    e_NetHeaderType hdr         = p_ManipParams->manipByHdr.hdr;
-    e_FmPcdHdrIndex hdrIndex    = p_ManipParams->manipByHdr.hdrIndex;
-    bool            byField     = p_ManipParams->manipByHdr.byField;
+    e_NetHeaderType hdr         = p_HdrInfo->hdr;
+    e_FmPcdHdrIndex hdrIndex    = p_HdrInfo->hdrIndex;
+    bool            byField     = p_HdrInfo->byField;
     t_FmPcdFields   field;
 
     if(byField)
-        field = p_ManipParams->manipByHdr.fullField;
+        field = p_HdrInfo->fullField;
 
     if(byField)
     {
@@ -1576,6 +1720,10 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmPcdManipLocationParams *p_ManipPar
             case(HEADER_TYPE_SCTP):
                 *parseArrayOffset = CC_PC_PR_L4_OFFSET;
                 break;
+            case(HEADER_TYPE_CAPWAP):
+            case(HEADER_TYPE_CAPWAP_DTLS):
+                *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+                break;
             default:
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header is not supported"));
      }
@@ -1583,7 +1731,7 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmPcdManipLocationParams *p_ManipPar
     return E_OK;
 }
 
-static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipRmvParams  *p_ManipParams, t_FmPcdManip *p_Manip)
+static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_ManipParams, t_FmPcdManip *p_Manip)
 {
     t_AdOfTypeContLookup    *p_Ad;
     uint32_t                tmpReg32 = 0;
@@ -1593,21 +1741,14 @@ static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipRmvParams  *p_Mani
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+/* TODO - reconsider this once full HM support exists */
+    SANITY_CHECK_RETURN_ERROR((p_ManipParams->type == e_FM_PCD_MANIP_RMV_BY_HDR),E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_ManipParams->u.byHdr.type == e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START),E_INVALID_HANDLE);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if(p_Manip->rmv)
+    if (p_Manip->rmv)
     {
-        switch(p_ManipParams->rmvSpecificLocationParams.type)
-        {
-            case(e_FM_PCD_MANIP_LOC_BY_HDR) :
-                err = GetPrOffsetByHeaderOrField(&p_ManipParams->rmvSpecificLocationParams, &prsArrayOffset);
-                break;
-            case(e_FM_PCD_MANIP_LOC_NON_HDR) :
-                err = GetPrOffsetByNonHeader(&prsArrayOffset);
-                break;
-            default :
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid type of location header manipulation of type Remove"));
-        }
+        err = GetPrOffsetByHeaderOrField(&p_ManipParams->u.byHdr.u.fromStartByHdr.hdrInfo, &prsArrayOffset);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -1628,6 +1769,7 @@ static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipRmvParams  *p_Mani
 
     return E_OK;
 }
+#endif /* FM_CAPWAP_SUPPORT */
 
 static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip, bool caamUsed)
 {
@@ -1688,7 +1830,10 @@ static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
     return err;
 }
 
-static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd, uint8_t poolIndex)
+static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
+                                t_FmPcdManip                *p_Manip,
+                                t_FmPcd                     *p_FmPcd,
+                                uint8_t                     poolId)
 {
     t_Handle    p_Table;
     uint32_t    tmpReg32 = 0;
@@ -1697,45 +1842,49 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,t_FmPcdM
     uint8_t     numOfSets;
     uint32_t    j = 0;
 
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
-    if(!p_FmPcd->h_Hc)
+    if (!p_FmPcd->h_Hc)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("hc port has to be initialized in this mode"));
     if (!POWER_OF_2(p_ManipParams->timeoutRoutineRequestTime))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeoutRoutineRequestTime has to be power of 2"));
-    if(!POWER_OF_2(p_ManipParams->maxNumFramesInProcess))
+    if (!POWER_OF_2(p_ManipParams->maxNumFramesInProcess))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("maxNumFramesInProcess has to be power of 2"));
-    if(!p_ManipParams->timeoutRoutineRequestTime && p_ManipParams->timeoutThresholdForReassmProcess)
+    if (!p_ManipParams->timeoutRoutineRequestTime && p_ManipParams->timeoutThresholdForReassmProcess)
         DBG(WARNING, ("if timeoutRoutineRequestTime 0,  timeoutThresholdForReassmProcess is uselessly"));
-    if(p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH)
+    if (p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH)
     {
-        if((p_ManipParams->maxNumFramesInProcess < 4) ||
+        if ((p_ManipParams->maxNumFramesInProcess < 4) ||
             (p_ManipParams->maxNumFramesInProcess > 512))
             RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"));
     }
     else
     {
-        if((p_ManipParams->maxNumFramesInProcess < 8) ||
+        if ((p_ManipParams->maxNumFramesInProcess < 8) ||
             (p_ManipParams->maxNumFramesInProcess > 2048))
             RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"));
     }
 
-    p_Manip->updateParams |= (NUM_OF_TASKS | BUFFER_POOL_ID_FOR_MANIP | OFFSET_OF_PR | OFFSET_OF_DATA | HW_PORT_ID);
+    p_Manip->updateParams |= (NUM_OF_TASKS | OFFSET_OF_PR | OFFSET_OF_DATA | HW_PORT_ID);
 
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
-                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
-    if(!p_Manip->h_Frag)
-         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+                                                  FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
+                                                  FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+    if (!p_Manip->h_Frag)
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc CAPWAP reassembly parameters table"));
 
     IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
 
-    p_Table         = (t_CapwapReasmPram *)p_Manip->h_Frag;
+    p_Table = (t_CapwapReasmPram *)p_Manip->h_Frag;
+
+    p_Manip->fragParams.p_AutoLearnHashTbl =
+        (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                    (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE),
+                                    FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
 
-    p_Manip->fragParams.p_AutoLearnHashTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                          (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE),
-                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+    if (!p_Manip->fragParams.p_AutoLearnHashTbl)
+	RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
 
     IOMemSet32(p_Manip->fragParams.p_AutoLearnHashTbl, 0,  (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
 
@@ -1745,11 +1894,11 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,t_FmPcdM
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->autoLearnHashTblPtr, tmpReg32);
 
     tmpReg32 = 0;
-    if(p_ManipParams->timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
+    if (p_ManipParams->timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
         tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES;
-    if(p_ManipParams->haltOnDuplicationFrag)
+    if (p_ManipParams->haltOnDuplicationFrag)
         tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
-    if(p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH)
+    if (p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH)
     {
         i = 8;
         tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS;
@@ -1763,26 +1912,24 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,t_FmPcdM
 
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
 
-    for(j = 0; j < p_ManipParams->maxNumFramesInProcess * 2; j++)
-    {
+    for (j=0; j<p_ManipParams->maxNumFramesInProcess*2; j++)
         if(((j / i)  % 2)== 0)
-        {
             WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->fragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
-        }
-    }
 
-    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->bufferPoolIdAndRisc1SetIndexes, 0x00008000);
+    tmpReg32 = 0x00008000;
+    tmpReg32 |= (uint32_t)poolId << 16;
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->bufferPoolIdAndRisc1SetIndexes, tmpReg32);
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc23SetIndexes, 0x80008000);
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc4SetIndexesAndExtendedStatsTblPtr, 0x80000000);
 
     p_Manip->fragParams.maxNumFramesInProcess = p_ManipParams->maxNumFramesInProcess;
 
-    p_Manip->fragParams.poolIndx =  poolIndex;
+    p_Manip->fragParams.sgBpid =  poolId;
 
     p_Manip->fragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
     p_Manip->fragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
     /*TODO  - to take care about this function FmGetTimeStampScale - it return t_Error
-     now we have problems with all calls to this fucntion*/
+     now we have problems with all calls to this function*/
     p_Manip->fragParams.bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
 
     tmpReg32 = 0;
@@ -1790,144 +1937,80 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,t_FmPcdM
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->expirationDelay, tmpReg32);
 
     return E_OK;
-
 }
 
-static t_Error CapwapFragmentation(t_CapwapFragmentationParams *p_ManipParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd, uint8_t poolIndex)
+static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
+                                   t_FmPcdManip                 *p_Manip,
+                                   t_FmPcd                      *p_FmPcd,
+                                   uint8_t                      poolId)
 {
     t_AdOfTypeContLookup    *p_Ad;
     uint32_t                tmpReg32 = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
-    p_Manip->updateParams |= OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP;
+    p_Manip->updateParams |= OFFSET_OF_DATA;
 
     p_Manip->frag = TRUE;
 
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                          FM_PCD_CC_AD_ENTRY_SIZE,
-                                          FM_PCD_CC_AD_TABLE_ALIGN);
+                                                  FM_PCD_CC_AD_ENTRY_SIZE,
+                                                  FM_PCD_CC_AD_TABLE_ALIGN);
     if(!p_Manip->h_Frag)
-         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP fragmentation table descriptor"));
 
     IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
-    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
 
     if(p_ManipParams->headerOptionsCompr)
-        tmpReg32 = FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
+    tmpReg32 |= ((uint32_t)poolId << 8);
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
     tmpReg32 = 0;
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
-
     p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
-    p_Manip->fragParams.poolIndx = poolIndex;
+    p_Manip->fragParams.sgBpid = poolId;
 
     return E_OK;
 }
 #endif /* FM_CAPWAP_SUPPORT */
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-static t_Error IpFragmentation(t_IpFragmentationParams *p_ManipParams,t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
-{
-    t_AdOfTypeContLookup    *p_Ad;
-    uint32_t                tmpReg32 = 0;
-    t_Error                 err = E_OK;
-
-    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
-
-    /* Host Command module must be initialized when using IP Fragmentation manipulation */
-    if (!p_FmPcd->h_Hc)
-        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("hc port has to be initialized in this mode"));
-
-    /* Allocation of fragmentation Action Descriptor */
-    p_Manip->ipFragParams.p_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                               FM_PCD_CC_AD_ENTRY_SIZE,
-                                                               FM_PCD_CC_AD_TABLE_ALIGN);
-
-    if(!p_Manip->ipFragParams.p_Frag)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
-
-    IOMemSet32( p_Manip->ipFragParams.p_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
-
-    p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipFragParams.p_Frag;
-
-    /* Sets the third Ad register (pcAndOffsets)- OperationCode */
-    tmpReg32 = 0;
-    tmpReg32 |= (uint32_t)HMAN_OC_IP_FRAGMENTATION;
-    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
-
-    /* Sets the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
-    tmpReg32 = 0;
-    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
-    tmpReg32 |= (p_ManipParams->dontFragAction << FM_PCD_MANIP_IP_FRAG_DF_OFFSET);
-    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
-
-    /* Saves user's fragmentation manipulation parameters */
-    p_Manip->ipFragParams.scratchBpid = p_ManipParams->scratchBpid;
-    p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
-    p_Manip->frag = TRUE;
-
-    /* Sets the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
-    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_FmPcd->h_FragIdPtr) - p_FmPcd->physicalMuramBase);
-    tmpReg32 |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
-    WRITE_UINT32(p_Ad->gmask, tmpReg32);
-
-    /* scratch buffer pool initialization */
-    if ((err = FmPcdFragHcScratchPoolFill((t_Handle)p_FmPcd, p_ManipParams->scratchBpid)) != E_OK)
-    {
-        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
-        p_Manip->ipFragParams.p_Frag = NULL;
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-    return E_OK;
-}
-
-static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, t_Handle h_Ad, bool ipv4)
+static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, bool ipv4)
 {
     t_AdOfTypeContLookup *p_Ad;
     t_FmPcd              *p_FmPcd   = (t_FmPcd *)p_Manip->h_FmPcd;
     uint32_t             tmpReg32;
     t_Error              err = E_OK;
-    t_Handle             h_IpReassParamsTblPtr;
 
-    /* Gets the required Action descriptor table pointer */
-    if (ipv4)
-        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv4Ad;
-    else
-        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv6Ad;
+    /* Creates the IP Reassembly Parameters table. It contains parameters that are specific to either the IPv4 reassembly
+     function or to the IPv6 reassembly function. If both IPv4 reassembly and IPv6 reassembly are required, then
+     two separate IP Reassembly Parameter tables are required.*/
+    if ((err = CreateIpReassTable(p_Manip, ipv4)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* Sets the first Ad register (ccAdBase) - Action Descriptor Type and Pointer to the IP Reassembly Parameters Table offset from MURAM*/
     tmpReg32 = 0;
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
 
-    /* Creates the IP Reassembly Parameters table. It contains parameters that are specific to either the IPv4 reassembly
-     function or to the IPv6 reassembly function. If both IPv4 reassembly and IPv6 reassembly are required, then
-     two separate IP Reassembly Parameter tables are required.*/
+    /* Gets the required Action descriptor table pointer */
     if (ipv4)
     {
-        p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr = CreateIpReassParamTable(p_Manip, ipv4);;
-        h_IpReassParamsTblPtr = p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr;
+        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv4Ad;
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_Ipv4ReassTbl) - (p_FmPcd->physicalMuramBase));
     }
     else
     {
-        p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr = CreateIpReassParamTable(p_Manip, ipv4);
-        h_IpReassParamsTblPtr = p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr;
+        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv6Ad;
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.p_Ipv6ReassTbl) - (p_FmPcd->physicalMuramBase));
     }
 
-    /* Gets the IP Reassemly parameter table offset from MURAM */
-    if (h_IpReassParamsTblPtr != NULL)
-        tmpReg32 |= (uint32_t)(XX_VirtToPhys(h_IpReassParamsTblPtr) - (p_FmPcd->physicalMuramBase));
-    else
-        return err;
-
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
 
     /* Sets the second Ad register (matchTblPtr) - Buffer pool ID (BPID) and Scatter/Gather table offset*/
@@ -1937,7 +2020,7 @@ static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, t_Handle h_Ad, bool
     tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.sgBpid << 8);
     WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
 
-    /* Sets the third Ad register (pcAndOffsets)- liodn offset and IP Reassembly Operation Code*/
+    /* Sets the third Ad register (pcAndOffsets)- IP Reassemble Operation Code*/
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
@@ -1954,33 +2037,35 @@ static t_Error SetIpv4ReassmManip(t_FmPcdManip *p_Manip)
     /* Allocation if IPv4 Action descriptor */
     if(p_Manip->muramAllocate)
     {
-        p_Manip->ipReassmParams.h_Ipv4Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                             FM_PCD_CC_AD_ENTRY_SIZE,
-                                             FM_PCD_CC_AD_TABLE_ALIGN);
+        p_Manip->ipReassmParams.h_Ipv4Ad =
+            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                        FM_PCD_CC_AD_ENTRY_SIZE,
+                                        FM_PCD_CC_AD_TABLE_ALIGN);
         if(!p_Manip->ipReassmParams.h_Ipv4Ad)
         {
            ReleaseManipHandler(p_Manip, p_FmPcd);
-           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for IPv4 table descriptor"));
         }
 
         IOMemSet32(p_Manip->ipReassmParams.h_Ipv4Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
     }
     else
     {
-        p_Manip->ipReassmParams.h_Ipv4Ad = (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t), p_Manip->ipReassmParams.dataMemId, 0);
+        p_Manip->ipReassmParams.h_Ipv4Ad =
+            (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t),
+                                     p_Manip->ipReassmParams.dataMemId,
+                                     0);
         if(!p_Manip->ipReassmParams.h_Ipv4Ad)
         {
             ReleaseManipHandler(p_Manip, p_FmPcd);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv4 table descriptor"));
         }
 
         memset(p_Manip->ipReassmParams.h_Ipv4Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
     }
 
     /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
-    FillReassmManipParams(p_Manip, p_Manip->ipReassmParams.h_Ipv4Ad, TRUE);
-
-    return E_OK;
+    return FillReassmManipParams(p_Manip, TRUE);
 }
 
 static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
@@ -1990,13 +2075,14 @@ static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
     /* Allocation if IPv6 Action descriptor */
     if(p_Manip->muramAllocate)
     {
-        p_Manip->ipReassmParams.h_Ipv6Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                             FM_PCD_CC_AD_ENTRY_SIZE,
-                                             FM_PCD_CC_AD_TABLE_ALIGN);
+        p_Manip->ipReassmParams.h_Ipv6Ad =
+            (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                        FM_PCD_CC_AD_ENTRY_SIZE,
+                                        FM_PCD_CC_AD_TABLE_ALIGN);
         if(!p_Manip->ipReassmParams.h_Ipv6Ad)
         {
            ReleaseManipHandler(p_Manip, p_FmPcd);
-           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for IPv6 table descriptor"));
         }
 
         IOMemSet32(p_Manip->ipReassmParams.h_Ipv6Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
@@ -2007,56 +2093,63 @@ static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
          if(!p_Manip->ipReassmParams.h_Ipv6Ad)
          {
             ReleaseManipHandler(p_Manip, p_FmPcd);
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv6 table descriptor"));
          }
 
         memset(p_Manip->ipReassmParams.h_Ipv6Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
     }
 
     /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
-    FillReassmManipParams(p_Manip, p_Manip->ipReassmParams.h_Ipv6Ad, FALSE);
-
-    return E_OK;
+    return FillReassmManipParams(p_Manip, FALSE);
 }
 
-
-static t_Error IpReassembly(t_FmPcdManipFragOrReasmParams *p_ManipParams,t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
+                            t_FmPcdManip                *p_Manip,
+                            t_FmPcd                     *p_FmPcd)
 {
     uint32_t                    maxSetNumber = 10000;
-    t_IpReasmCommonTbl          *p_IpReasmCommonPramTbl = NULL;
-    t_IpReassemblyParams        reassmManipParams = p_ManipParams->ipReasmParams;
+    t_FmPcdManipReassemIpParams reassmManipParams = p_ManipReassmParams->u.ipReassem;
     t_Error                     res;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+#ifdef DISABLE_SANITY_CHECKS
+UNUSED(p_FmPcd);
+#endif /* DISABLE_SANITY_CHECKS */
 
     /* Check validation of user's parameter.*/
-    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000) || (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
+    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000) ||
+        (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,("timeoutThresholdForReassmProcess should be 1msec - 8sec"));
     /* It is recommended that the total number of entries in this table (number of sets * number of ways)
        will be twice the number of frames that are expected to be reassembled simultaneously.*/
-    if (reassmManipParams.maxNumFramesInProcess > (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
+    if (reassmManipParams.maxNumFramesInProcess >
+        (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"));
 
-    if ((p_ManipParams->hdr == HEADER_TYPE_IPv6) &&
+    if ((p_ManipReassmParams->hdr == HEADER_TYPE_IPv6) &&
         (reassmManipParams.minFragSize[1] < 256))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("minFragSize[1] must be >= 256"));
 
     /* Saves user's reassembly manipulation parameters */
-    p_Manip->ipReassmParams.relativeSchemeId[0] = p_ManipParams->ipReasmParams.relativeSchemeId[0];
-    p_Manip->ipReassmParams.relativeSchemeId[1] = p_ManipParams->ipReasmParams.relativeSchemeId[1];
+    p_Manip->ipReassmParams.relativeSchemeId[0] = reassmManipParams.relativeSchemeId[0];
+    p_Manip->ipReassmParams.relativeSchemeId[1] = reassmManipParams.relativeSchemeId[1];
+    p_Manip->ipReassmParams.numOfFramesPerHashEntry[0] = reassmManipParams.numOfFramesPerHashEntry[0];
+    p_Manip->ipReassmParams.numOfFramesPerHashEntry[1] = reassmManipParams.numOfFramesPerHashEntry[1];
+    p_Manip->ipReassmParams.minFragSize[0] = reassmManipParams.minFragSize[0];
+    p_Manip->ipReassmParams.minFragSize[1] = reassmManipParams.minFragSize[1];
     p_Manip->ipReassmParams.maxNumFramesInProcess = reassmManipParams.maxNumFramesInProcess;
     p_Manip->ipReassmParams.timeOutMode = reassmManipParams.timeOutMode;
     p_Manip->ipReassmParams.fqidForTimeOutFrames = reassmManipParams.fqidForTimeOutFrames;
-    p_Manip->ipReassmParams.numOfFramesPerHashEntry = reassmManipParams.numOfFramesPerHashEntry;
     p_Manip->ipReassmParams.timeoutThresholdForReassmProcess = reassmManipParams.timeoutThresholdForReassmProcess;
-    p_Manip->ipReassmParams.minFragSize[0] = reassmManipParams.minFragSize[0];
-    p_Manip->ipReassmParams.minFragSize[1] = reassmManipParams.minFragSize[1];
     p_Manip->ipReassmParams.dataMemId = reassmManipParams.dataMemId;
     p_Manip->ipReassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
     p_Manip->ipReassmParams.sgBpid = reassmManipParams.sgBpid;
-
+#ifdef UNDER_CONSTRUCTION_V3_IPR
+    p_Manip->ipReassmParams.h_CouplingFmPort = reassmManipParams.h_CouplingFmPort;
+#endif /* UNDER_CONSTRUCTION_V3_IPR */
     /* Creates and initializes the IP Reassembly common parameter table */
-    CreateIpReassCommonParamTable(p_Manip, p_FmPcd, p_IpReasmCommonPramTbl);
+    CreateIpReassCommonTable(p_Manip);
 
     /* Creation of IPv4 reassembly manipulation */
     if ((p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6) || (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4))
@@ -2077,34 +2170,119 @@ static t_Error IpReassembly(t_FmPcdManipFragOrReasmParams *p_ManipParams,t_FmPcd
     return E_OK;
 }
 
-bool FmPcdManipIsIpv4Present(t_FmPcd *p_FmPcd, uint8_t netEnvId)
+static void setReassmSchemeParams(t_FmPcd* p_FmPcd, t_FmPcdKgSchemeParams *p_Scheme, t_Handle h_CcTree, bool ipv4, uint8_t groupId)
 {
-    uint8_t         res;
-
-    ASSERT_COND(p_FmPcd);
+    uint32_t    j;
+    uint8_t     res;
 
-    res = FmPcdNetEnvGetUnitId(p_FmPcd, netEnvId, HEADER_TYPE_IPv4, FALSE, IPV4_FRAG_1);
-    if (res == HEADER_TYPE_USER_DEFINED_SHIM2)
-        return TRUE;
+    /* Configures scheme's network environment parameters */
+    p_Scheme->netEnvParams.numOfDistinctionUnits = 2;
+    if (ipv4)
+        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv4, FALSE, 0);
     else
-        return FALSE;
-}
+        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv6, FALSE, 0);
+    ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    p_Scheme->netEnvParams.unitIds[0] = res;
 
-bool FmPcdManipIsIpv6Present(t_FmPcd *p_FmPcd, uint8_t netEnvId)
-{
-    uint8_t         res;
+    res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0);
+    ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    p_Scheme->netEnvParams.unitIds[1] = res;
 
-    ASSERT_COND(p_FmPcd);
+    /* Configures scheme's next engine parameters*/
+    p_Scheme->nextEngine = e_FM_PCD_CC;
+    p_Scheme->kgNextEngineParams.cc.h_CcTree = h_CcTree;
+    p_Scheme->kgNextEngineParams.cc.grpId = groupId;
+    p_Scheme->useHash = TRUE;
 
-    res = FmPcdNetEnvGetUnitId(p_FmPcd, netEnvId, HEADER_TYPE_IPv6, FALSE, IPV6_FRAG_1);
-    if (res == HEADER_TYPE_USER_DEFINED_SHIM2)
-        return TRUE;
-    else
-        return FALSE;
+    /* Configures scheme's key*/
+    if (ipv4 == TRUE)
+    {
+        p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 4;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv4 ;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.hdr = HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.ignoreProtocolValidation = FALSE;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.size = 2;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.offset = 4;
+    }
+    else /* IPv6 */
+    {
+        p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 3;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv6 ;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_DST_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv6;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_SRC_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.size  = 4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.offset = 4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.ignoreProtocolValidation = TRUE;
+    }
+
+    p_Scheme->keyExtractAndHashParams.privateDflt0 = 0x01020304;
+    p_Scheme->keyExtractAndHashParams.privateDflt1 = 0x11121314;
+    p_Scheme->keyExtractAndHashParams.numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+    for(j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
+    {
+        p_Scheme->keyExtractAndHashParams.dflts[j].type = (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
+        p_Scheme->keyExtractAndHashParams.dflts[j].dfltSelect = e_FM_PCD_KG_DFLT_GBL_0;
+    }
 }
 
-#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
+static t_Error IpReassemblyStats(t_FmPcdManip *p_Manip, t_FmPcdManipReassemIpStats *p_Stats)
+{
+    ASSERT_COND(p_Manip);
+    ASSERT_COND(p_Stats);
+    ASSERT_COND(p_Manip->ipReassmParams.p_IpReassCommonTbl);
+
+    p_Stats->timeout                = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalTimeOutCounter);
+    p_Stats->rfdPoolBusy            = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalRfdPoolBusyCounter);
+    p_Stats->internalBufferBusy     = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalInternalBufferBusy);
+    p_Stats->externalBufferBusy     = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalExternalBufferBusy);
+    p_Stats->sgFragments            = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalSgFragmentCounter);
+    p_Stats->dmaSemaphoreDepletion  = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalDmaSemaphoreDepletionCounter);
+
+    if (p_Manip->ipReassmParams.p_Ipv4ReassTbl)
+    {
+        p_Stats->specificHdrStatistics[0].successfullyReassembled = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalSuccessfullyReasmFramesCounter);
+        p_Stats->specificHdrStatistics[0].validFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalValidFragmentCounter);
+        p_Stats->specificHdrStatistics[0].processedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalProcessedFragCounter);
+        p_Stats->specificHdrStatistics[0].malformedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalMalformdFragCounter);
+        p_Stats->specificHdrStatistics[0].autoLearnBusy = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalSetBusyCounter);
+        p_Stats->specificHdrStatistics[0].discardedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalDiscardedFragsCounter);
+        p_Stats->specificHdrStatistics[0].moreThan16Fragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv4ReassTbl->totalMoreThan16FramesCounter);
+    }
+    if (p_Manip->ipReassmParams.p_Ipv6ReassTbl)
+    {
+        p_Stats->specificHdrStatistics[1].successfullyReassembled = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalSuccessfullyReasmFramesCounter);
+        p_Stats->specificHdrStatistics[1].validFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalValidFragmentCounter);
+        p_Stats->specificHdrStatistics[1].processedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalProcessedFragCounter);
+        p_Stats->specificHdrStatistics[1].malformedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalMalformdFragCounter);
+        p_Stats->specificHdrStatistics[1].autoLearnBusy = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalSetBusyCounter);
+        p_Stats->specificHdrStatistics[1].discardedFragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalDiscardedFragsCounter);
+        p_Stats->specificHdrStatistics[1].moreThan16Fragments = GET_UINT32(p_Manip->ipReassmParams.p_Ipv6ReassTbl->totalMoreThan16FramesCounter);
+    }
+    return E_OK;
+}
 
+#ifdef FM_CAPWAP_SUPPORT
 static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd)
 {
     t_AdOfTypeContLookup    *p_Ad;
@@ -2129,18 +2307,20 @@ static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip
     return E_OK;
 }
 
-#ifdef FM_CAPWAP_SUPPORT
-static t_Error InsrtHdrByTempl(t_FmPcdManipInsrtParams  *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
+                               t_FmPcdManip                 *p_Manip,
+                               t_FmPcd                      *p_FmPcd)
 {
-    t_FmPcdManipInsrtByTemplateParams   *p_InsrtByTemplate = &p_ManipParams->insrtByTemplateParams;
-    uint8_t                             tmpReg8 = 0xff;
-    t_AdOfTypeContLookup                *p_Ad;
-    bool                                ipModify = FALSE;
-    uint32_t                            tmpReg32 = 0, tmpRegNia = 0;
-    uint16_t                            tmpReg16 = 0;
-    t_Error                             err = E_OK;
-    uint8_t                             extraAddedBytes = 0, blockSize = 0, extraAddedBytesAlignedToBlockSize = 0;
-    uint8_t                             *p_Template = NULL;
+    t_FmPcdManipHdrInsrtByTemplateParams    *p_InsrtByTemplate = &p_ManipParams->u.byTemplate;
+    uint8_t                                 tmpReg8 = 0xff;
+    t_AdOfTypeContLookup                    *p_Ad;
+    bool                                    ipModify = FALSE;
+    uint32_t                                tmpReg32 = 0, tmpRegNia = 0;
+    uint16_t                                tmpReg16 = 0;
+    t_Error                                 err = E_OK;
+    uint8_t                                 extraAddedBytes = 0, blockSize = 0;
+    uint8_t                                 extraAddedBytesAlignedToBlockSize = 0;
+    uint8_t                                 *p_Template = NULL;
 
     SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
@@ -2162,11 +2342,12 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipInsrtParams  *p_ManipParams, t_FmPcdM
 
          if(p_InsrtByTemplate->size)
          {
-             p_Manip->p_Template = (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                                p_InsrtByTemplate->size,
-                                                FM_PCD_CC_AD_TABLE_ALIGN);
+             p_Manip->p_Template =
+                (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                             p_InsrtByTemplate->size,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
              if(!p_Manip->p_Template)
-                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for manipulation header template"));
 
              tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
              tmpReg32 |= (uint32_t)p_InsrtByTemplate->size << 24;
@@ -2178,7 +2359,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipInsrtParams  *p_ManipParams, t_FmPcdM
         p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
 
         if(!p_Template)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of manipulation header template"));
 
         memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
 
@@ -2308,8 +2489,88 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipInsrtParams  *p_ManipParams, t_FmPcdM
 }
 #endif /* FM_CAPWAP_SUPPORT */
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-static t_Error IPManip(t_FmPcdManipParams *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+static t_Error IpFragmentationStats(t_FmPcdManip *p_Manip, t_FmPcdManipFragIpStats *p_Stats)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+
+    ASSERT_COND(p_Manip);
+    ASSERT_COND(p_Stats);
+    ASSERT_COND(p_Manip->h_Ad);
+    ASSERT_COND(p_Manip->ipFragParams.p_Frag);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    p_Stats->totalFrames = GET_UINT32(p_Ad->gmask);
+    p_Stats->fragmentedFrames = GET_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase) & 0x00ffffff;
+    p_Stats->generatedFragments = GET_UINT32(p_Manip->ipFragParams.p_Frag->matchTblPtr);
+
+    return E_OK;
+}
+
+static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams,t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    uint32_t                pcAndOffsetsReg = 0, ccAdBaseReg = 0, gmaskReg = 0;
+#if (DPAA_VERSION == 2)
+    t_Error                 err = E_OK;
+#endif /* (DPAA_VERSION == 2) */
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams->sizeForFragmentation != 0xFFFF, E_INVALID_VALUE);
+
+    /* Allocation of fragmentation Action Descriptor */
+    p_Manip->ipFragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                                                             FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_Manip->ipFragParams.p_Frag)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Fragmentation table descriptor"));
+
+    IOMemSet32( p_Manip->ipFragParams.p_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    /* Prepare the third Ad register (pcAndOffsets)- OperationCode */
+    pcAndOffsetsReg = (uint32_t)HMAN_OC_IP_FRAGMENTATION;
+
+    /* Prepare the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
+    ccAdBaseReg = FM_PCD_AD_CONT_LOOKUP_TYPE;
+    ccAdBaseReg |= (p_ManipParams->dontFragAction << FM_PCD_MANIP_IP_FRAG_DF_OFFSET);
+
+    /* Set Scatter/Gather BPid */
+    if (p_ManipParams->sgBpidEn)
+    {
+	 ccAdBaseReg 	 |= FM_PCD_MANIP_IP_FRAG_SG_BDID_EN;
+		 pcAndOffsetsReg |= ((p_ManipParams->sgBpid << FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET) & FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK);
+    }
+
+    /* Prepare the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
+    gmaskReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr)) - p_FmPcd->physicalMuramBase);
+#if (DPAA_VERSION == 2)
+    gmaskReg |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
+#endif /* (DPAA_VERSION == 2) */
+
+    /* Set all Ad registers */
+    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->pcAndOffsets, pcAndOffsetsReg);
+	WRITE_UINT32(p_Manip->ipFragParams.p_Frag->ccAdBase, ccAdBaseReg);
+    WRITE_UINT32(p_Manip->ipFragParams.p_Frag->gmask, gmaskReg);
+
+    /* Saves user's fragmentation manipulation parameters */
+    p_Manip->frag = TRUE;
+    p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
+
+#if (DPAA_VERSION == 2)
+    p_Manip->ipFragParams.scratchBpid = p_ManipParams->scratchBpid;
+
+    /* scratch buffer pool initialization */
+    if ((err = FmPcdFragHcScratchPoolFill((t_Handle)p_FmPcd, p_ManipParams->scratchBpid)) != E_OK)
+    {
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
+        p_Manip->ipFragParams.p_Frag = NULL;
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+#endif /* (DPAA_VERSION == 2) */
+
+    return E_OK;
+}
+
+static t_Error IPManip(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 {
 
     t_Error                     err = E_OK;
@@ -2327,7 +2588,7 @@ static t_Error IPManip(t_FmPcdManipParams *p_ManipParams, t_FmPcdManip *p_Manip,
         tmpReg32  = (uint32_t)p_Manip->sizeForFragmentation << FM_PCD_MANIP_IP_FRAG_MTU_OFFSET;
     }
     else
-          tmpReg32 = FM_PCD_MANIP_IP_FRAG_NO_FRAGMETATION;
+        tmpReg32 = FM_PCD_MANIP_IP_FRAG_NO_FRAGMETATION;
 
     tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
     tmpReg32  |= HMAN_OC_IP_MANIP;
@@ -2336,17 +2597,36 @@ static t_Error IPManip(t_FmPcdManipParams *p_ManipParams, t_FmPcdManip *p_Manip,
     WRITE_UINT32(p_Ad->ccAdBase, tmpRegNia);
     WRITE_UINT32(p_Ad->gmask, 0); /* Total frame counter - MUST be initialized to zero.*/
 
-/*
-    TODO - Fill the following:
-         - Over write OuterTos
-         - SaveInnerTos
-         - support in CNIA
-*/
+    return err;
+}
+
+static t_Error IPSecManip(t_FmPcdManipSpecialOffloadIPSecParams *p_IPSecParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    t_Error                     err = E_OK;
+    t_AdOfTypeContLookup        *p_Ad;
+    uint32_t                    tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+#ifdef DISABLE_SANITY_CHECKS
+UNUSED(p_FmPcd);
+#endif /* DISABLE_SANITY_CHECKS */
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32 |= (p_IPSecParams->decryption)?FM_PCD_MANIP_IPSEC_DEC:0;
+    tmpReg32 |= (p_IPSecParams->ecnCopy)?FM_PCD_MANIP_IPSEC_ECN_EN:0;
+    tmpReg32 |= (p_IPSecParams->dscpCopy)?FM_PCD_MANIP_IPSEC_DSCP_EN:0;
+    tmpReg32 |= (p_IPSecParams->variableIpHdrLen)?FM_PCD_MANIP_IPSEC_VIPL_EN:0;
+
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+    WRITE_UINT32(p_Ad->pcAndOffsets, HMAN_OC_IPSEC_MANIP);
 
     return err;
 }
-#endif /* (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || ... */
 
+#ifdef FM_CAPWAP_SUPPORT
 static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsParams *p_StatsParams)
 {
 
@@ -2355,13 +2635,14 @@ static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsPa
         case(e_FM_PCD_STATS_PER_FLOWID):
             p_Manip->type = HMAN_OC_CAPWAP_INDEXED_STATS;
             p_Manip->muramAllocate = TRUE;
-        break;
+            break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported statistics type"));
     }
 
     return E_OK;
 }
+#endif /* FM_CAPWAP_SUPPORT */
 
 static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool stats)
 {
@@ -2370,23 +2651,26 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     p_Manip = (t_FmPcdManip*)XX_Malloc(sizeof(t_FmPcdManip));
-    if(!p_Manip)
+    if (!p_Manip)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
         return NULL;
     }
     memset(p_Manip, 0, sizeof(t_FmPcdManip));
 
-    if(!stats)
-    {
+    if (!stats)
         err = CheckManipParamsAndSetType(p_Manip, (t_FmPcdManipParams *)p_Params);
-    }
+#ifdef FM_CAPWAP_SUPPORT
     else
-    {
         err = CheckStatsParamsAndSetType(p_Manip, (t_FmPcdStatsParams *)p_Params);
+#else
+    else
+    {
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Statistics node!"));
+        return NULL;
     }
-
-    if(err)
+#endif /* FM_CAPWAP_SUPPORT */
+    if (err)
     {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("INVALID HEADER MANIPULATION TYPE"));
         ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -2394,61 +2678,83 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
         return NULL;
     }
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    if(p_Manip->type != HMAN_OC_IP_REASSEMBLY)
+    if (p_Manip->type != HMAN_OC_IP_REASSEMBLY)
     {
         /* In Case of IP reassembly manipulation the IPv4/IPv6 reassembly action descriptor will
            be defines later on */
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-    if(p_Manip->muramAllocate)
-    {
-        p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
-                                             FM_PCD_CC_AD_ENTRY_SIZE,
-                                             FM_PCD_CC_AD_TABLE_ALIGN);
-         if(!p_Manip->h_Ad)
-         {
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
-            ReleaseManipHandler(p_Manip, p_FmPcd);
-            XX_Free(p_Manip);
-            return NULL;
-         }
-
-        IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+		if (p_Manip->muramAllocate)
+		{
+			p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+														FM_PCD_CC_AD_ENTRY_SIZE,
+														FM_PCD_CC_AD_TABLE_ALIGN);
+			 if(!p_Manip->h_Ad)
+			 {
+				REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
+				ReleaseManipHandler(p_Manip, p_FmPcd);
+				XX_Free(p_Manip);
+				return NULL;
+			 }
+
+			IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+		}
+		else
+		{
+			p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+			 if(!p_Manip->h_Ad)
+			 {
+				REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
+				ReleaseManipHandler(p_Manip, p_FmPcd);
+				XX_Free(p_Manip);
+				return NULL;
+			 }
+
+			memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+		}
     }
-    else
-    {
-        p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-         if(!p_Manip->h_Ad)
-         {
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
-            ReleaseManipHandler(p_Manip, p_FmPcd);
-            XX_Free(p_Manip);
-            return NULL;
-         }
 
-        memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-    }
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
     p_Manip->h_FmPcd = h_FmPcd;
 
     return p_Manip;
 }
 
 
-t_Error FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree, bool modify)
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+
+bool FmPcdManipIsIpPresent(t_FmPcd *p_FmPcd, uint8_t netEnvId, bool ipv6)
+{
+    uint8_t         res;
+
+    ASSERT_COND(p_FmPcd);
+
+    if (ipv6)
+        res = FmPcdNetEnvGetUnitId(p_FmPcd, netEnvId, HEADER_TYPE_IPv6, FALSE, IPV6_FRAG_1);
+    else
+        res = FmPcdNetEnvGetUnitId(p_FmPcd, netEnvId, HEADER_TYPE_IPv4, FALSE, IPV4_FRAG_1);
+    if (res == HEADER_TYPE_USER_DEFINED_SHIM2)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+t_Error FmPcdManipUpdate(t_Handle h_FmPcd,
+                         t_Handle h_PcdParams,
+                         t_Handle h_FmPort,
+                         t_Handle h_Manip,
+                         t_Handle h_Ad,
+                         bool     validate,
+                         int      level,
+                         t_Handle h_FmTree,
+                         bool    modify)
 {
     t_Error err;
 
-    if(!modify)
-    {
+    if (!modify)
         err = FmPcdManipInitUpdate(h_FmPcd, h_PcdParams, h_FmPort, h_Manip, h_Ad, validate, level, h_FmTree);
-    }
     else
-    {
         err = FmPcdManipModifyUpdate(h_Manip, h_Ad, validate, level, h_FmTree);
-    }
+
     return err;
 }
 
@@ -2485,12 +2791,12 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
     t_FmPcdManip             *p_Manip;
     t_Error                   err;
 
-
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip, E_NULL_POINTER);
 
     p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
     *requiredAction = 0;
+
     switch(p_Manip->type)
     {
         case(HMAN_OC_CAPWAP_INDEXED_STATS):
@@ -2502,12 +2808,12 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
             *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
         case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
             p_Manip->ownerTmp++;
-        break;
+            break;
         case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) && !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
             p_Manip->ownerTmp++;
-        break;
+            break;
         case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
                (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
@@ -2516,8 +2822,7 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
             if(err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
-        break;
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+            break;
         case(HMAN_OC_IP_MANIP):
 
             if((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE) &&
@@ -2534,13 +2839,20 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
             if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
             p_Manip->ownerTmp++;
-        break;
+            break;
         case(HMAN_OC_IP_REASSEMBLY):
             if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
             p_Manip->ownerTmp++;
-        break;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+            break;
+        case(HMAN_OC_IPSEC_MANIP):
+            p_Manip->ownerTmp++;
+            break;
+        case(HMAN_OC):
+			if(( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE(p_Manip))
+				RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't share this Manip node, in is cascaded and Next Engine is CC"));
+            break;
+
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE,("invalid type of header manipulation for this state"));
     }
@@ -2561,7 +2873,7 @@ t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcd
         case(HMAN_OC_CAPWAP_INDEXED_STATS):
             if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
-        break;
+            break;
         case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             if(p_Manip->h_Frag)
             {
@@ -2575,72 +2887,87 @@ t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcd
         default:
             break;
     }
+
     return err;
 }
 
-void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew)
+void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNewPtr)
 {
-    t_FmPcdManip             *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
+
+
+    /* This routine creates a Manip AD and can return in "p_AdNewPtr"
+     * either the new descriptor or NULL if it writes the Manip AD into p_AD (into the match table) */
 
     ASSERT_COND(p_Manip);
 
     FmPcdManipUpdateOwner(h_Manip, TRUE);
 
+    /* According to "type", either build & initialize a new AD (p_AdNew) or initialize
+     * p_Ad ( the AD in the match table) and set p_AdNew = NULL. */
     switch(p_Manip->type)
     {
         case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
         case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
         case(HMAN_OC_CAPWAP_INDEXED_STATS):
-            *p_AdNew = p_Manip->h_Ad;
+            *p_AdNewPtr = p_Manip->h_Ad;
+            break;
+        case(HMAN_OC_IPSEC_MANIP):
+            *p_AdNewPtr = p_Manip->h_Ad;
             break;
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
         case(HMAN_OC_IP_FRAGMENTATION):
-            *p_AdNew = p_Manip->h_Ad;
+            *p_AdNewPtr = p_Manip->h_Ad;
             break;
         case(HMAN_OC_IP_REASSEMBLY):
             if (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4)
             {
-                *p_AdNew = p_Manip->ipReassmParams.h_Ipv4Ad;
+                *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv4Ad;
             }
             if (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6)
             {
                 if (!p_Manip->ipReassmParams.ipv6Assigned)
                 {
-                    *p_AdNew = p_Manip->ipReassmParams.h_Ipv6Ad;
+                    *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv6Ad;
                     p_Manip->ipReassmParams.ipv6Assigned = TRUE;
+                    FmPcdManipUpdateOwner(h_Manip, FALSE);
                 }
                 else
-                    *p_AdNew = p_Manip->ipReassmParams.h_Ipv4Ad;
+                    *p_AdNewPtr = p_Manip->ipReassmParams.h_Ipv4Ad;
             }
             break;
         case(HMAN_OC_IP_MANIP):
             if (p_Manip->cnia)
-                *p_AdNew = p_Manip->h_Ad;
+                *p_AdNewPtr = p_Manip->h_Ad;
             else
             {
                 WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
                 WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
                 WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
-                *p_AdNew = NULL;
+                *p_AdNewPtr = NULL;
             }
             break;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
         case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
         case(HMAN_OC_CAPWAP_FRAGMENTATION):
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
-            *p_AdNew = NULL;
+            *p_AdNewPtr = NULL;
+            break;
+        case(HMAN_OC):
+		/* Allocate and initialize HMTD */
+            *p_AdNewPtr = p_Manip->h_Ad;
             break;
         default:
             break;
     }
 }
 
-void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew, uint32_t adTableOffset)
+void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNewPtr, uint32_t adTableOffset)
 {
-    t_FmPcdManip             *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
 
+    /* This routine creates a Manip AD and can return in "p_AdNewPtr"
+     * either the new descriptor or NULL if it writes the Manip AD into p_AD (into the match table) */
     ASSERT_COND(p_Manip);
 
     FmPcdManipUpdateOwner(h_Manip, TRUE);
@@ -2653,144 +2980,131 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,  ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->gmask,         ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->gmask);
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      (GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) | adTableOffset));
-            *p_AdNew = NULL;
-            break;
-        default:
+            *p_AdNewPtr = NULL;
             break;
-    }
-}
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-void setReassmSchemeParams(t_FmPcd* p_FmPcd, t_FmPcdKgSchemeParams *p_Scheme, t_Handle h_CcTree, bool ipv4, uint32_t groupId)
-{
-    uint32_t    j;
-    uint8_t     res;
-
-    /* Configures scheme's network environment parameters */
-    p_Scheme->netEnvParams.numOfDistinctionUnits = 2;
-    if (ipv4)
-        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_FmPcd, p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv4, FALSE, 0);
-    else
-        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_FmPcd, p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv6, FALSE, 0);
-    ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
-    p_Scheme->netEnvParams.unitIds[0] = res;
-
-    res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_FmPcd, p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0);
-    ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
-    p_Scheme->netEnvParams.unitIds[1] = res;
 
-    /* Configures scheme's next engine parameters*/
-    p_Scheme->nextEngine = e_FM_PCD_CC;
-    p_Scheme->kgNextEngineParams.cc.h_CcTree = h_CcTree;
-    p_Scheme->kgNextEngineParams.cc.grpId = groupId;
-    p_Scheme->useHash = TRUE;
-
-    /* Configures scheme's key*/
-    if (ipv4 == TRUE)
-    {
-        p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 4;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv4 ;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv4;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_IPv4;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.hdr = HEADER_TYPE_IPv4;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.ignoreProtocolValidation = FALSE;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.size = 2;
-        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.offset = 4;
-    }
-    else /* IPv6 */
-    {
-        p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 3;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv6 ;
-        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_DST_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv6;
-        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_SRC_IP;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.size  = 4;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.offset = 4;
-        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.ignoreProtocolValidation = TRUE;
-    }
+        case(HMAN_OC):
+		/* Initialize HMTD within the match table*/
+			IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+		/* copy the existing HMTD */ /* ask Alla - memcpy??? */
+		memcpy((uint8_t*)p_Ad, p_Manip->h_Ad, sizeof(t_Hmtd));
+		/* update NADEN to be "1"*/
+			WRITE_UINT16(((t_Hmtd *)p_Ad)->cfg,
+			             (uint16_t)(GET_UINT16(((t_Hmtd *)p_Ad)->cfg) | HMTD_CFG_NEXT_AD_EN));
+			/* update next action descriptor */
+			WRITE_UINT16(((t_Hmtd *)p_Ad)->nextAdIdx, (uint16_t)(adTableOffset >> 4));
+			/* mark that Manip's HMTD is not used */
+			*p_AdNewPtr = NULL;
+            break;
 
-    p_Scheme->keyExtractAndHashParams.privateDflt0 = 0x01020304;
-    p_Scheme->keyExtractAndHashParams.privateDflt1 = 0x11121314;
-    p_Scheme->keyExtractAndHashParams.numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
-    for(j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
-    {
-        p_Scheme->keyExtractAndHashParams.dflts[j].type = (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
-        p_Scheme->keyExtractAndHashParams.dflts[j].dfltSelect = e_FM_PCD_KG_DFLT_GBL_0;
+        default:
+            break;
     }
-
-    return;
 }
 
-t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint32_t groupId)
+t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint8_t groupId)
 {
     t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_FmPcdKgSchemeParams   *p_scheme = NULL;
+    t_FmPcdKgSchemeParams   *p_SchemeParams = NULL;
 
     ASSERT_COND(p_FmPcd);
-    ASSERT_COND(p_PcdGroupsParam);
+    ASSERT_COND(h_NetEnv);
     ASSERT_COND(p_Manip);
 
-    p_scheme = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
-
-    if(!p_scheme)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+    p_SchemeParams = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
+    if (!p_SchemeParams)
+       RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation failed for scheme"));
 
     /* Configures the IPv4 or IPv6 scheme*/
-    memset(p_scheme, 0, sizeof(*p_scheme));
-    p_scheme->netEnvParams.h_NetEnv = p_PcdGroupsParam->h_NetEnv;
-    p_scheme->id.relativeSchemeId = (isIpv4 == TRUE) ?  p_Manip->ipReassmParams.relativeSchemeId[0] : p_Manip->ipReassmParams.relativeSchemeId[1];
-    p_scheme->schemeCounter.update = TRUE;
-    p_scheme->baseFqid = 0xFFFFFF; /*TODO- baseFqid*/
-    p_scheme->keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+    memset(p_SchemeParams, 0, sizeof(t_FmPcdKgSchemeParams));
+    p_SchemeParams->netEnvParams.h_NetEnv = h_NetEnv;
+    p_SchemeParams->id.relativeSchemeId = (uint8_t)((isIpv4 == TRUE) ?  p_Manip->ipReassmParams.relativeSchemeId[0] : p_Manip->ipReassmParams.relativeSchemeId[1]);
+    p_SchemeParams->schemeCounter.update = TRUE;
+    p_SchemeParams->baseFqid = 0xFFFFFF; /*TODO- baseFqid*/
+    p_SchemeParams->keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
 
-    setReassmSchemeParams(p_FmPcd, p_scheme, h_CcTree, isIpv4, groupId);
+    setReassmSchemeParams(p_FmPcd, p_SchemeParams, h_CcTree, isIpv4, groupId);
 
     /* Sets the new scheme */
     if (isIpv4)
-        p_Manip->ipReassmParams.h_Ipv4Scheme = FM_PCD_KgSetScheme(p_FmPcd, p_scheme);
+        p_Manip->ipReassmParams.h_Ipv4Scheme = FM_PCD_KgSchemeSet(p_FmPcd, p_SchemeParams);
     else
-        p_Manip->ipReassmParams.h_Ipv6Scheme = FM_PCD_KgSetScheme(p_FmPcd, p_scheme);
+        p_Manip->ipReassmParams.h_Ipv6Scheme = FM_PCD_KgSchemeSet(p_FmPcd, p_SchemeParams);
 
-    XX_Free(p_scheme);
+    XX_Free(p_SchemeParams);
 
     return E_OK;
 }
 
-t_Error FmPcdManipDeleteIpReassmSchemes(t_FmPcd *p_FmPcd, t_Handle h_Manip)
+t_Error FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip)
 {
     t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
 
-    ASSERT_COND(p_FmPcd);
     ASSERT_COND(p_Manip);
 
     if (p_Manip->ipReassmParams.h_Ipv4Scheme)
-        FM_PCD_KgDeleteScheme(p_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme);
+        FM_PCD_KgSchemeDelete(p_Manip->ipReassmParams.h_Ipv4Scheme);
 
     if (p_Manip->ipReassmParams.h_Ipv6Scheme)
-        FM_PCD_KgDeleteScheme(p_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme);
+        FM_PCD_KgSchemeDelete(p_Manip->ipReassmParams.h_Ipv6Scheme);
 
     return E_OK;
 }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
-t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams)
+#ifdef FM_CAPWAP_SUPPORT
+t_Handle FmPcdManipApplSpecificBuild(void)
+{
+    t_FmPcdManip *p_Manip;
+
+    p_Manip = (t_FmPcdManip*)XX_Malloc(sizeof(t_FmPcdManip));
+    if (!p_Manip)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_Manip, 0, sizeof(t_FmPcdManip));
+
+    p_Manip->type = HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
+    p_Manip->muramAllocate = FALSE;
+
+	p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+	 if(!p_Manip->h_Ad)
+	 {
+		REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
+		XX_Free(p_Manip);
+		return NULL;
+	 }
+
+	memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+
+    /*treatFdStatusFieldsAsErrors = TRUE hardcoded - assumption its always come after CAAM*/
+    /*Application specific = type of flowId index, move internal frame header from data to IC,
+    SEC errors check*/
+    if(MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE)!= E_OK)
+    {
+        XX_Free(p_Manip->h_Ad);
+        XX_Free(p_Manip);
+        return NULL;
+    }
+    return p_Manip;
+}
+
+bool FmPcdManipIsCapwapApplSpecific(t_Handle h_Manip)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    ASSERT_COND(h_Manip);
+
+    return (bool)((p_Manip->type == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST) ? TRUE : FALSE);
+}
+#endif /* FM_CAPWAP_SUPPORT */
+/*********************** End of inter-module routines ************************/
+
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+
+t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_FmPcdManip                *p_Manip;
@@ -2805,14 +3119,9 @@ t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
 
     switch(p_Manip->type)
     {
-        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
-            /* HmanType1 */
-            err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->rmvParams, p_Manip);
-            break;
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
         case(HMAN_OC_IP_REASSEMBLY):
             /* IpReassembly */
-            err = IpReassembly(&p_ManipParams->fragOrReasmParams, p_Manip, p_FmPcd);
+            err = IpReassembly(&p_ManipParams->u.reassem, p_Manip, p_FmPcd);
             if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -2823,7 +3132,7 @@ t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
             break;
        case(HMAN_OC_IP_FRAGMENTATION):
             /* IpFragmentation */
-            err = IpFragmentation(&p_ManipParams->fragOrReasmParams.ipFragParams ,p_Manip, p_FmPcd);
+            err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip, p_FmPcd);
             if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -2831,17 +3140,23 @@ t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 XX_Free(p_Manip);
                 return NULL;
             }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
         case(HMAN_OC_IP_MANIP) :
-            err = IPManip(p_ManipParams, p_Manip, p_FmPcd);
+            err = IPManip(p_Manip, p_FmPcd);
+            break;
+        case(HMAN_OC_IPSEC_MANIP) :
+            err = IPSecManip(&p_ManipParams->u.specialOffload.u.ipsec, p_Manip, p_FmPcd);
             break;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 #ifdef FM_CAPWAP_SUPPORT
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+            /* HmanType1 */
+            err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->u.hdr.rmvParams, p_Manip);
+            break;
         case(HMAN_OC_CAPWAP_FRAGMENTATION):
-            /* CapwapFragmentation */
-            err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.capwapFragParams ,p_Manip, p_FmPcd, p_ManipParams->fragOrReasmParams.extBufPoolIndx);
-            if(err)
+            err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.u.capwapFragParams,
+                                      p_Manip,
+                                      p_FmPcd,
+                                      p_ManipParams->fragOrReasmParams.sgBpid);
+            if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -2852,11 +3167,13 @@ t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
         case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
-            err = InsrtHdrByTempl(&p_ManipParams->insrtParams, p_Manip, p_FmPcd);
+            err = InsrtHdrByTempl(&p_ManipParams->u.hdr.insrtParams, p_Manip, p_FmPcd);
             break;
-        case(HMAN_OC_CAPWAP_REASSEMBLY) :
-            /*CAPWAP Reassembly*/
-            err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.capwapReasmParams,p_Manip, p_FmPcd, p_ManipParams->fragOrReasmParams.extBufPoolIndx);
+        case(HMAN_OC_CAPWAP_REASSEMBLY):
+            err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.u.capwapReasmParams,
+                                   p_Manip,
+                                   p_FmPcd,
+                                   p_ManipParams->fragOrReasmParams.sgBpid);
             if(err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
@@ -2873,43 +3190,73 @@ t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
 #endif /* FM_CAPWAP_SUPPORT */
        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             /*Application Specific type 1*/
-            err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, (bool)(p_ManipParams->treatFdStatusFieldsAsErrors ? TRUE : FALSE));
+            err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE);
             break;
+       case(HMAN_OC):
+           /* New Manip */
+           err = CreateManipAction(p_Manip, p_ManipParams);
+           break;
        default:
-                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
-                ReleaseManipHandler(p_Manip, p_FmPcd);
-                XX_Free(p_Manip);
-                return NULL;
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            XX_Free(p_Manip);
+            return NULL;
     }
-    if(err)
-     {
-         REPORT_ERROR(MAJOR, err, NO_MSG);
-         ReleaseManipHandler(p_Manip, p_FmPcd);
-         XX_Free(p_Manip);
-         return NULL;
-     }
-     return p_Manip;
+
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        XX_Free(p_Manip);
+        return NULL;
+    }
+
+    return p_Manip;
 }
 
-t_Error FM_PCD_ManipDeleteNode(t_Handle h_FmPcd, t_Handle h_ManipNode)
+t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
 {
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
     t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_ManipNode;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
 
     if(p_Manip->owner)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
 
-    ReleaseManipHandler(p_Manip,p_FmPcd);
+	if(p_Manip->h_NextManip)
+    {
+		MANIP_SET_PREV(p_Manip->h_NextManip, NULL);
+	FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
+    }
+
+    ReleaseManipHandler(p_Manip, p_Manip->h_FmPcd);
 
     XX_Free(h_ManipNode);
 
     return E_OK;
 }
 
+t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmPcdManipStats)
+{
+    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_ManipNode;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdManipStats, E_NULL_POINTER);
 
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_IP_REASSEMBLY):
+            return IpReassemblyStats(p_Manip, &p_FmPcdManipStats->u.reassem.u.ipReassem);
+       case(HMAN_OC_IP_FRAGMENTATION):
+            return IpFragmentationStats(p_Manip, &p_FmPcdManipStats->u.frag.u.ipFrag);
+       default:
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no statistics to this type of manip"));
+    }
+
+    return E_OK;
+}
+
+#ifdef FM_CAPWAP_SUPPORT
 t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsParams)
 {
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
@@ -2924,18 +3271,18 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsP
         return NULL;
 
      switch(p_Manip->type)
-    {
+     {
         case(HMAN_OC_CAPWAP_INDEXED_STATS):
             /* Indexed statistics */
             err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
             break;
-       default:
-                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED Statistics type"));
-                ReleaseManipHandler(p_Manip, p_FmPcd);
-                XX_Free(p_Manip);
-                return NULL;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED Statistics type"));
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            XX_Free(p_Manip);
+            return NULL;
+     }
 
-    }
      if(err)
      {
          REPORT_ERROR(MAJOR, err, NO_MSG);
@@ -2943,5 +3290,7 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsP
          XX_Free(p_Manip);
          return NULL;
      }
+
      return p_Manip;
 }
+#endif /* FM_CAPWAP_SUPPORT */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
index 18e8882..db16125 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -55,10 +55,12 @@
 #define HMAN_OC_IP_MANIP                                        0x34
 #define HMAN_OC_IP_FRAGMENTATION                                0x74
 #define HMAN_OC_IP_REASSEMBLY                                   0xB4
+#define HMAN_OC_IPSEC_MANIP                                     0xF4
 #define HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX     0x2f
 #define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
 #define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 /* dummy */
 #define HMAN_OC_CAPWAP_INDEXED_STATS                            0x32 /* dummy */
+#define HMAN_OC													0x35
 
 #define HMAN_RMV_HDR                               0x80000000
 #define HMAN_INSRT_INT_FRM_HDR                     0x40000000
@@ -90,17 +92,19 @@
 #define FM_PCD_MANIP_INDEXED_STATS_CNIA                     0x20000000
 #define FM_PCD_MANIP_INDEXED_STATS_DPD                      0x10000000
 
-#define FM_PCD_MANIP_IPSEC_CALC_UDP_LENGTH                  0x01000000
-#define FM_PCD_MANIP_IPSEC_CNIA                             0x20000000
-
-#define e_FM_MANIP_CAPWAP_INDX                              0
-
 #define FM_PCD_MANIP_IP_REASM_TABLE_SIZE                    0x40
 #define FM_PCD_MANIP_IP_REASM_TABLE_ALIGN                   8
 
 #define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE       64
 #define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN      8
-#define FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES              0x80000000
+#define FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES       0x80000000
+#define FM_PCD_MANIP_IP_REASM_COUPLING_ENABLE               0x40000000
+#define FM_PCD_MANIP_IP_REASM_COUPLING_MASK                 0xFF000000
+#define FM_PCD_MANIP_IP_REASM_COUPLING_SHIFT                24
+#define FM_PCD_MANIP_IP_REASM_LIODN_MASK                    0x0000003F
+#define FM_PCD_MANIP_IP_REASM_LIODN_SHIFT                   56
+#define FM_PCD_MANIP_IP_REASM_ELIODN_MASK                   0x000003c0
+#define FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT                  38
 #define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_MASK    0x000000FF
 #define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_SHIFT   24
 
@@ -108,12 +112,60 @@
 #define FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID                   24
 #define FM_PCD_MANIP_IP_FRAG_MTU_OFFSET                     16
 #define FM_PCD_MANIP_IP_FRAG_NO_FRAGMETATION                0xFFFF0000
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN						0x08000000
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK					0xFF000000
+#define FM_PCD_MANIP_IP_FRAG_SG_BDID_OFFSET					24
+
+#define FM_PCD_MANIP_IPSEC_DEC                              0x10000000
+#define FM_PCD_MANIP_IPSEC_ECN_EN                           0x04000000
+#define FM_PCD_MANIP_IPSEC_DSCP_EN                          0x02000000
+#define FM_PCD_MANIP_IPSEC_VIPL_EN                          0x01000000
 
 #define e_FM_MANIP_IP_INDX                                  1
-#define FM_PCD_MANIP_IP_REASM_LIODN_MASK                    0x0000003F
-#define FM_PCD_MANIP_IP_REASM_LIODN_SHIFT                   56
-#define FM_PCD_MANIP_IP_REASM_ELIODN_MASK                   0x000003c0
-#define FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT                  38
+
+#define HMCD_OPCODE_GENERIC_RMV					0x01
+#define HMCD_OPCODE_GENERIC_INSRT               0x02
+#define HMCD_OPCODE_GENERIC_REPLACE             0x05
+#define HMCD_OPCODE_L2_RMV                      0x08
+#define HMCD_OPCODE_L2_INSRT                    0x09
+
+#define HMCD_SIZE_RMV 							4
+#define HMCD_SIZE_INSRT 						4
+
+#define HMCD_LAST								0x00800000
+
+#define HMCD_OC_SHIFT							24
+
+#define HMCD_RMV_OFFSET_SHIFT					0
+#define HMCD_RMV_SIZE_SHIFT						8
+
+#define HMCD_INSRT_OFFSET_SHIFT					0
+#define HMCD_INSRT_SIZE_SHIFT					8
+
+#define	HMTD_CFG_TYPE							0x4000
+#define	HMTD_CFG_EXT_HMCT						0x0080
+#define	HMTD_CFG_PRS_AFTER_HM					0x0040
+#define	HMTD_CFG_NEXT_AD_EN						0x0020
+
+
+#define HMCD_RMV_L2_ETHERNET                   0
+#define HMCD_RMV_L2_STACKED_QTAGS              1
+#define HMCD_RMV_L2_ETHERNET_AND_MPLS          2
+#define HMCD_RMV_L2_MPLS                       3
+
+#define HMCD_INSRT_L2_MPLS                     0
+#define HMCD_INSRT_N_UPDATE_L2_MPLS            0
+
+
+#define MANIP_IS_CASCADE(h_Manip)				(((t_FmPcdManip *)h_Manip)->cascadedNext)
+#define MANIP_GET_HMCT_SIZE(h_Manip) 			(((t_FmPcdManip *)h_Manip)->tableSize)
+#define MANIP_GET_HMCT_PTR(h_Manip) 			(((t_FmPcdManip *)h_Manip)->p_HmcdTbl)
+#define MANIP_SET_HMCT_PTR(h_Manip, h_NewPtr) 	(((t_FmPcdManip *)h_Manip)->p_HmcdTbl = h_NewPtr)
+#define MANIP_GET_HMTD_PTR(h_Manip) 			(((t_FmPcdManip *)h_Manip)->h_Ad)
+#define MANIP_DONT_REPARSE(h_Manip) 			(((t_FmPcdManip *)h_Manip)->dontParseAfterManip)
+#define MANIP_SET_PREV(h_Manip, h_Prev) 		(((t_FmPcdManip *)h_Manip)->h_PrevManip = h_Prev)
+#define MANIP_GET_MURAM(h_Manip)				(((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram)
+
 
 /***********************************************************************/
 /*          Memory map                                                 */
@@ -122,7 +174,7 @@
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-typedef _Packed struct {
+typedef _Packed struct t_CapwapReasmPram {
     volatile uint32_t mode;
     volatile uint32_t autoLearnHashTblPtr;
     volatile uint32_t intStatsTblPtr;
@@ -145,10 +197,10 @@ typedef _Packed struct {
     volatile uint32_t totalMoreThan16FramesCounter;
     volatile uint32_t internalBufferBusy;
     volatile uint32_t externalBufferBusy;
-    volatile uint8_t res[16];
+    volatile uint32_t reserved1[4];
 } _PackedType t_CapwapReasmPram;
 
-typedef _Packed struct t_IpReasmPram{
+typedef _Packed struct t_IpReassTbl {
     volatile uint16_t waysNumAndSetSize;
     volatile uint16_t autoLearnHashKeyMask;
     volatile uint32_t ipReassCommonPrmTblPtr;
@@ -166,9 +218,9 @@ typedef _Packed struct t_IpReasmPram{
     volatile uint32_t totalDiscardedFragsCounter;
     volatile uint32_t totalMoreThan16FramesCounter;
     volatile uint32_t reserved2[2];
-} _PackedType t_IpReasmPram;
+} _PackedType t_IpReassTbl;
 
-typedef _Packed struct t_IpReasmCommonTbl{
+typedef _Packed struct t_IpReassCommonTbl {
     volatile uint32_t timeoutModeAndFqid;
     volatile uint32_t reassFrmDescIndexPoolTblPtr;
     volatile uint32_t liodnAndReassFrmDescPoolPtrHi;
@@ -176,15 +228,27 @@ typedef _Packed struct t_IpReasmCommonTbl{
     volatile uint32_t timeOutTblPtr;
     volatile uint32_t expirationDelay;
     volatile uint32_t internalBufferManagement;
-    volatile uint32_t reseervd1;
+    volatile uint32_t reserved2;
     volatile uint32_t totalTimeOutCounter;
     volatile uint32_t totalRfdPoolBusyCounter;
     volatile uint32_t totalInternalBufferBusy;
     volatile uint32_t totalExternalBufferBusy;
-    volatile uint32_t reserved3[4];
-} _PackedType t_IpReasmCommonTbl;
+    volatile uint32_t totalSgFragmentCounter;
+    volatile uint32_t totalDmaSemaphoreDepletionCounter;
+    volatile uint32_t reserved3[2];
+} _PackedType t_IpReassCommonTbl;
+
+typedef _Packed struct t_Hmtd {
+    volatile uint16_t 	cfg;
+    volatile uint8_t 	eliodnOffset;
+    volatile uint8_t 	extHmcdBasePtrHi;
+    volatile uint32_t 	hmcdBasePtr;
+    volatile uint16_t 	nextAdIdx;
+    volatile uint8_t 	res1;
+    volatile uint8_t 	opCode;
+    volatile uint32_t 	res2;
+} _PackedType t_Hmtd;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -193,19 +257,18 @@ typedef _Packed struct t_IpReasmCommonTbl{
 /***********************************************************************/
 /*  Driver's internal structures                                       */
 /***********************************************************************/
-
 typedef struct
 {
     t_Handle p_AutoLearnHashTbl;
     t_Handle p_ReassmFrmDescrPoolTbl;
     t_Handle p_ReassmFrmDescrIndxPoolTbl;
     t_Handle p_TimeOutTbl;
-    uint16_t  maxNumFramesInProcess;
+    uint16_t maxNumFramesInProcess;
     uint8_t  numOfTasks;
-    uint8_t  poolId;
+    //uint8_t  poolId;
     uint8_t  prOffset;
     uint16_t dataOffset;
-    uint8_t  poolIndx;
+    uint8_t  sgBpid;
     uint8_t  hwPortId;
     uint32_t fqidForTimeOutFrames;
     uint32_t timeoutRoutineRequestTime;
@@ -214,79 +277,76 @@ typedef struct
 
 typedef struct
 {
-    void     *p_Frag;
-    uint8_t  poolId;
-    uint16_t dataOffset;
-    uint8_t  poolIndx;
-    uint8_t  scratchBpid;
-}t_IpFragParams;
+    t_AdOfTypeContLookup    *p_Frag;
+#if (DPAA_VERSION == 2)
+    uint8_t  	            scratchBpid;
+#endif /* (DPAA_VERSION == 2) */
+} t_IpFragParams;
 
 typedef struct t_IpReassmParams
 {
-    t_Handle            h_Ipv4Ad;
-    t_Handle            h_Ipv6Ad;
-    bool                ipv6Assigned;
-    e_NetHeaderType     hdr;                /**< Header selection */
-    uint32_t            fqidForTimeOutFrames;
-    uint16_t            dataOffset;
-    t_Handle            h_IpReassCommonParamsTbl;
-    t_Handle            h_Ipv4ReassParamsTblPtr;
-    t_Handle            h_Ipv6ReassParamsTblPtr;
-    t_Handle            h_Ipv4AutoLearnHashTbl;
-    t_Handle            h_Ipv6AutoLearnHashTbl;
-    t_Handle            h_Ipv4AutoLearnSetLockTblPtr;
-    t_Handle            h_Ipv6AutoLearnSetLockTblPtr;
-    t_Handle            h_ReassmFrmDescrIndxPoolTbl;
-    t_Handle            h_ReassmFrmDescrPoolTbl;
-    t_Handle            h_TimeOutTbl;
-    uintptr_t           internalBufferPoolManagementIndexAddr;
-    uintptr_t           internalBufferPoolAddr;
-    uint32_t            maxNumFramesInProcess;
-    uint32_t            dataLiodnOffset;
-    uint32_t            minFragSize[2];
-    uint8_t             dataMemId;              /**< Memory partition ID for data buffers */
-    uint32_t            sgBpid;
+    t_Handle                        h_Ipv4Ad;
+    t_Handle                        h_Ipv6Ad;
+    bool                            ipv6Assigned;
+    e_NetHeaderType                 hdr; /* Header selection */
+    uint16_t                        dataOffset;
+    t_IpReassCommonTbl              *p_IpReassCommonTbl;
+    t_IpReassTbl                    *p_Ipv4ReassTbl;
+    t_IpReassTbl                    *p_Ipv6ReassTbl;
+    uintptr_t                       ipv4AutoLearnHashTblAddr;
+    uintptr_t                       ipv6AutoLearnHashTblAddr;
+    uintptr_t                       ipv4AutoLearnSetLockTblAddr;
+    uintptr_t                       ipv6AutoLearnSetLockTblAddr;
+    uintptr_t                       reassFrmDescrIndxPoolTblAddr;
+    uintptr_t                       reassFrmDescrPoolTblAddr;
+    uintptr_t                       timeOutTblAddr;
+    uintptr_t                       internalBufferPoolManagementIndexAddr;
+    uintptr_t                       internalBufferPoolAddr;
+    uint32_t                        maxNumFramesInProcess;
+    t_Handle                        h_CouplingFmPort;
+    uint8_t                         sgBpid;
+    uint8_t                         dataMemId;
+    uint16_t                        dataLiodnOffset;
+    uint32_t                        fqidForTimeOutFrames;
     e_FmPcdManipReassemTimeOutMode  timeOutMode;
-    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
     uint32_t                        timeoutThresholdForReassmProcess;
-    uint8_t              relativeSchemeId[2];
-    t_Handle             h_Ipv4Scheme;
-    t_Handle             h_Ipv6Scheme;
-}t_IpReassmParams;
-
-typedef struct t_IpCommonReassmParams
-{
-    uint8_t             numOfTasks;
-    uint32_t            bitFor1Micro;
-    t_Handle            h_ReassmFrmDescrPoolTbl;
-    t_Handle            h_ReassmFrmDescrIndxPoolTbl;
-    t_Handle            h_TimeOutTbl;
-}t_IpCommonReassmParams;
+    uint16_t                        minFragSize[2];
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
+    uint8_t                         relativeSchemeId[2];
+    t_Handle                        h_Ipv4Scheme;
+    t_Handle                        h_Ipv6Scheme;
+} t_IpReassmParams;
 
 typedef struct{
-    bool                muramAllocate;
-    t_Handle            h_Ad;
-    uint32_t            type;
-    bool                rmv;
-    bool                insrt;
-    uint8_t             *p_Template;
-    t_Handle            h_Frag;
-    bool                frag;
-    bool                reassm;
-    uint16_t            sizeForFragmentation;
-    uint8_t             owner;
-    uint32_t            updateParams;
-    uint32_t            shadowUpdateParams;
-    t_FragParams        fragParams;
+    bool                    muramAllocate;
+    t_Handle                h_Ad;
+    uint32_t			    *p_HmcdTbl;
+    uint32_t                type;
+    bool                    rmv;
+    bool                    insrt;
+    bool				    dontParseAfterManip;
+    t_Handle                h_NextManip;
+    t_Handle                h_PrevManip;
+    uint16_t			    tableSize;
+    bool				    cascadedNext;
+    uint8_t                 *p_Template;
+    t_Handle                h_Frag;
+    bool                    frag;
+    bool                    reassm;
+    uint16_t                sizeForFragmentation;
+    uint8_t                 owner;
+    uint32_t                updateParams;
+    uint32_t                shadowUpdateParams;
+    t_FragParams            fragParams;
     union {
         t_IpReassmParams    ipReassmParams;
         t_IpFragParams      ipFragParams;
     };
-    uint8_t             icOffset;
-    uint16_t            ownerTmp;
-    bool                cnia;
-    t_Handle            p_StatsTbl;
-    t_Handle            h_FmPcd;
+    uint8_t                 icOffset;
+    uint16_t                ownerTmp;
+    bool                    cnia;
+    t_Handle                p_StatsTbl;
+    t_Handle                h_FmPcd;
 } t_FmPcdManip;
 
 typedef struct t_FmPcdCcSavedManipParams
@@ -296,7 +356,7 @@ typedef struct t_FmPcdCcSavedManipParams
         struct
         {
             uint16_t    dataOffset;
-            uint8_t     poolId;
+            //uint8_t     poolId;
         }capwapParams;
         struct
         {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 0bb46d0..a2b031c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -51,6 +51,7 @@
 #include "fm_hc.h"
 #include "fm_muram_ext.h"
 
+
 static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
 {
     if(!p_FmPcd->h_Fm)
@@ -321,7 +322,7 @@ static t_Error FmPcdHandleIpcMsgCB(t_Handle  h_FmPcd,
        {
             t_Handle h_Profile;
             memcpy((uint8_t*)&h_Profile, p_IpcMsg->msgBody, sizeof(t_Handle));
-            if((err = FM_PCD_PlcrProfileDumpRegs(h_FmPcd, h_Profile)) != E_OK)
+            if((err = FM_PCD_PlcrProfileDumpRegs(h_Profile)) != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
 
@@ -340,6 +341,7 @@ static t_Error FmPcdHandleIpcMsgCB(t_Handle  h_FmPcd,
 
 void FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId)
 {
+    ASSERT_COND(p_FmPcd);
     p_FmPcd->netEnvs[netEnvId].clsPlanGrpId = clsPlanGrpId;
 }
 
@@ -348,6 +350,7 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     uint8_t netEnvId = p_GrpParams->netEnvId;
     int     i, k, j;
 
+    ASSERT_COND(p_FmPcd);
     if(p_FmPcd->netEnvs[netEnvId].clsPlanGrpId != ILLEGAL_CLS_PLAN)
     {
         p_GrpParams->grpExists = TRUE;
@@ -399,6 +402,7 @@ t_Error PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt
 
     *p_Vector = 0;
 
+    ASSERT_COND(p_FmPcd);
     for (j=0; ((j < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
               (p_FmPcd->netEnvs[netEnvId].units[j].hdrs[0].hdr != HEADER_TYPE_NONE)); j++)
     {
@@ -416,16 +420,11 @@ t_Error PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt
         return E_OK;
 }
 
-uint8_t FmPcdGetNetEnvId(t_FmPcd *p_FmPcd, t_Handle h_NetEnv)
-{
-    UNUSED(p_FmPcd);
-    return (uint8_t)(PTR_TO_UINT(h_NetEnv)-1);
-}
-
 t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
 {
     int                     i;
 
+    ASSERT_COND(p_FmPcd);
     p_Params->vector = 0;
     for(i=0; i<p_Params->numOfDistinctionUnits ;i++)
     {
@@ -441,6 +440,8 @@ t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
 bool PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t unitVector)
 {
     int     i=0, k;
+
+    ASSERT_COND(p_FmPcd);
     /* check whether a given unit may be used by non-clsPlan users. */
     /* first, recognize the unit by its vector */
     while (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE)
@@ -488,10 +489,9 @@ bool  FmPcdNetEnvIsHdrExist(t_Handle h_FmPcd, uint8_t netEnvId, e_NetHeaderType
     return FALSE;
 }
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-uint8_t  FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr, bool interchangable, protocolOpt_t opt)
+uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr, bool interchangable, protocolOpt_t opt)
 {
-    int         i, k;
+    uint8_t     i, k;
 
     ASSERT_COND(p_FmPcd);
 
@@ -529,14 +529,6 @@ uint8_t  FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderTyp
     return FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS;
 }
 
-bool  FmPcdIsIpFrag(t_Handle h_FmPcd, uint8_t netEnvId)
-{
-    if(FmPcdNetEnvGetUnitId(h_FmPcd, netEnvId, HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
-        return FALSE;
-    else
-        return TRUE;
-}
-
 t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -550,10 +542,10 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
 
     bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
     tsbs = 31 - bitFor1Micro + 1;
-    tsbs = 17;//(for TimeOut check will be triggered every 1/8ms)
+    tsbs = 17; /* for TimeOut check will be triggered every 1/8ms */
 
-    ccIpReassmTimeoutParams.iprcpt      = (XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
-    ccIpReassmTimeoutParams.tsbs        = tsbs;
+    ccIpReassmTimeoutParams.iprcpt      = (uint32_t)(XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccIpReassmTimeoutParams.tsbs        = (uint8_t)tsbs;
     ccIpReassmTimeoutParams.activate    = TRUE;
     if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -567,7 +559,7 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
         case (2):
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer"));
         case (3):
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("\"Disable Timeout Task\" with invalid IPRCPT"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Disable Timeout Task with invalid IPRCPT"));
         case (4):
             RETURN_ERROR(MAJOR, E_FULL, ("too many timeout tasks"));
         case (5):
@@ -588,7 +580,7 @@ t_Error FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPram
     ASSERT_COND(p_FmPcd);
     ASSERT_COND(h_IpReasmCommonPramTbl);
 
-    ccIpReassmTimeoutParams.iprcpt   = (XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccIpReassmTimeoutParams.iprcpt   = (uint32_t)(XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
     ccIpReassmTimeoutParams.activate = FALSE; /*Disable Timeout Task*/
 
     if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
@@ -610,7 +602,6 @@ t_Error FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPram
 
     return E_OK;
 }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
 e_NetHeaderType FmPcdGetAliasHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr)
 {
@@ -633,8 +624,8 @@ void   FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePo
     t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint16_t        swPortIndex = 0;
 
+    ASSERT_COND(h_FmPcd);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
-
     p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort = h_FmPort;
 }
 
@@ -642,6 +633,7 @@ uint32_t FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
+    ASSERT_COND(h_FmPcd);
     return p_FmPcd->netEnvs[netEnvId].lcvs[hdrNum];
 }
 
@@ -649,27 +641,59 @@ uint32_t FmPcdGetMacsecLcv(t_Handle h_FmPcd, uint32_t netEnvId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
+    ASSERT_COND(h_FmPcd);
     return p_FmPcd->netEnvs[netEnvId].macsecVector;
 }
 
+uint8_t FmPcdGetNetEnvId(t_Handle h_NetEnv)
+{
+    return ((t_FmPcdNetEnv*)h_NetEnv)->netEnvId;
+}
+
+static uint32_t NetEnvLock(t_Handle h_NetEnv)
+{
+    ASSERT_COND(h_NetEnv);
+    return XX_LockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock);
+}
+
+static void NetEnvUnlock(t_Handle h_NetEnv, uint32_t intFlags)
+{
+    ASSERT_COND(h_NetEnv);
+    XX_UnlockIntrSpinlock(((t_FmPcdNetEnv*)h_NetEnv)->h_Spinlock, intFlags);
+}
+
 void FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
 {
+    uint32_t    intFlags;
+
+    ASSERT_COND(h_FmPcd);
+
+    intFlags = NetEnvLock(&((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId]);
     ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners++;
+    NetEnvUnlock(&((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId], intFlags);
 }
 
 void FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId)
 {
+    uint32_t    intFlags;
+
+    ASSERT_COND(h_FmPcd);
     ASSERT_COND(((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners);
+
+    intFlags = NetEnvLock(&((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId]);
     ((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId].owners--;
+    NetEnvUnlock(&((t_FmPcd*)h_FmPcd)->netEnvs[netEnvId], intFlags);
 }
 
 uint32_t FmPcdLock(t_Handle h_FmPcd)
 {
+    ASSERT_COND(h_FmPcd);
     return XX_LockIntrSpinlock(((t_FmPcd*)h_FmPcd)->h_Spinlock);
 }
 
 void FmPcdUnlock(t_Handle h_FmPcd, uint32_t intFlags)
 {
+    ASSERT_COND(h_FmPcd);
     XX_UnlockIntrSpinlock(((t_FmPcd*)h_FmPcd)->h_Spinlock, intFlags);
 }
 
@@ -680,8 +704,14 @@ t_Handle FmPcdGetHcHandle(t_Handle h_FmPcd)
     return ((t_FmPcd*)h_FmPcd)->h_Hc;
 }
 
+bool FmPcdIsAdvancedOffloadSupported(t_Handle h_FmPcd)
+{
+    ASSERT_COND(h_FmPcd);
+    return ((t_FmPcd*)h_FmPcd)->advancedOffloadSupport;
+}
+
 /**********************************************************************************************************/
-/*              API                                                                                       */
+/*              API routines                                                                              */
 /**********************************************************************************************************/
 
 t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
@@ -734,7 +764,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
             return NULL;
         }
     }
-    else if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    else if (p_FmPcd->guestId != NCSW_MASTER_ID)
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("No Host Command defined for a guest partition."));
 
     if(p_FmPcdParams->kgSupport)
@@ -784,17 +814,18 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     p_FmPcd->f_FmPcdIndexedException    = p_FmPcdParams->f_ExceptionId;
     p_FmPcd->h_App                      = p_FmPcdParams->h_App;
 
-    /*p_ReassmFrmDescrPoolTbl*/
-    p_FmPcd->h_FragIdPtr = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)4, (uint32_t)4);
-    if(!p_FmPcd->h_FragIdPtr)
+    p_FmPcd->p_CcShadow                 = NULL;
+    p_FmPcd->ccShadowSize               = 0;
+    p_FmPcd->ccShadowAlign              = 0;
+
+    p_FmPcd->h_ShadowSpinlock = XX_InitSpinlock();
+    if (!p_FmPcd->h_ShadowSpinlock)
     {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd shadow spinlock"));
         FM_PCD_Free(p_FmPcd);
         return NULL;
     }
 
-    IOMemSet32(p_FmPcd->h_FragIdPtr, 0,  4);
-
     return p_FmPcd;
 }
 
@@ -807,6 +838,8 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
 
+    FM_GetRevision(p_FmPcd->h_Fm, &p_FmPcd->fmRevInfo);
+
     if(p_FmPcd->guestId != NCSW_MASTER_ID)
     {
         uint8_t                 isMasterAlive = 0;
@@ -814,10 +847,10 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
         uint32_t                replyLength;
 
         memset(p_FmPcd->fmPcdIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-        if(Sprint (p_FmPcd->fmPcdIpcHandlerModuleName, "FM_PCD_%d_%d", FmGetId(p_FmPcd->h_Fm), NCSW_MASTER_ID) != 10)
+        if (Sprint (p_FmPcd->fmPcdIpcHandlerModuleName, "FM_PCD_%d_%d", FmGetId(p_FmPcd->h_Fm), NCSW_MASTER_ID) != 10)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
         memset(p_FmPcd->fmPcdModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-        if(Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm), p_FmPcd->guestId) != (p_FmPcd->guestId<10 ? 10:11))
+        if (Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm), p_FmPcd->guestId) != (p_FmPcd->guestId<10 ? 10:11))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
 
         p_FmPcd->h_IpcSession = XX_IpcInitSession(p_FmPcd->fmPcdIpcHandlerModuleName, p_FmPcd->fmPcdModuleName);
@@ -850,28 +883,28 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
 
     CHECK_INIT_PARAMETERS(p_FmPcd, CheckFmPcdParameters);
 
-    if(p_FmPcd->p_FmPcdKg)
+    if (p_FmPcd->p_FmPcdKg)
     {
         err = KgInit(p_FmPcd);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if(p_FmPcd->p_FmPcdPlcr)
+    if (p_FmPcd->p_FmPcdPlcr)
     {
         err = PlcrInit(p_FmPcd);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if(p_FmPcd->p_FmPcdPrs)
+    if (p_FmPcd->p_FmPcdPrs)
     {
         err = PrsInit(p_FmPcd);
         if(err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
     {
          /* register to inter-core messaging mechanism */
         memset(p_FmPcd->fmPcdModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
@@ -887,6 +920,16 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
 
     FmRegisterPcd(p_FmPcd->h_Fm, p_FmPcd);
 
+    /* IPv6 Frame-Id used for fragmentation */
+    p_FmPcd->ipv6FrameIdAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, 4, 4));
+    if (!p_FmPcd->ipv6FrameIdAddr)
+    {
+        FM_PCD_Free(p_FmPcd);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for IPv6 Frame-Id"));
+    }
+
+    IOMemSet32(UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr), 0,  4);
+
     return E_OK;
 }
 
@@ -895,6 +938,9 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     t_FmPcd                             *p_FmPcd =(t_FmPcd *)h_FmPcd;
     t_Error                             err = E_OK;
 
+    if (p_FmPcd->ipv6FrameIdAddr)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr));
+
     if(p_FmPcd->enabled)
         FM_PCD_Disable(p_FmPcd);
 
@@ -903,6 +949,7 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
         XX_Free(p_FmPcd->p_FmPcdDriverParam);
         p_FmPcd->p_FmPcdDriverParam = NULL;
     }
+
     if(p_FmPcd->p_FmPcdKg)
     {
         if((err = KgFree(p_FmPcd)) != E_OK)
@@ -941,9 +988,44 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     FmUnregisterPcd(p_FmPcd->h_Fm);
 
     XX_Free(p_FmPcd);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t        bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigException - guest mode!"));
+
+    GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
+    if(bitMask)
+    {
+        if (enable)
+            p_FmPcd->exceptions |= bitMask;
+        else
+            p_FmPcd->exceptions &= ~bitMask;
+   }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
     return E_OK;
 }
 
+t_Error FM_PCD_ConfigHcFramesDataMemory(t_Handle h_FmPcd, uint8_t memId)
+{
+    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+
+    return FmHcSetFramesDataMemory(p_FmPcd->h_Hc, memId);
+}
+
 t_Error FM_PCD_Enable(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1040,7 +1122,7 @@ t_Error FM_PCD_Disable(t_Handle h_FmPcd)
     return (t_Error)(reply.error);
 }
 
-t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams  *p_NetEnvParams)
+t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams  *p_NetEnvParams)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                intFlags, specialUnits = 0;
@@ -1083,6 +1165,11 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     memset(&p_FmPcd->netEnvs[netEnvCurrId].units, 0, FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS * sizeof(t_FmPcdIntDistinctionUnit));
     memset(&p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs, 0, FM_PCD_MAX_NUM_OF_ALIAS_HDRS * sizeof(t_FmPcdNetEnvAliases));
     memcpy(&p_FmPcd->netEnvs[netEnvCurrId].units, p_NetEnvParams->units, p_NetEnvParams->numOfDistinctionUnits*sizeof(t_FmPcdIntDistinctionUnit));
+
+    p_FmPcd->netEnvs[netEnvCurrId].netEnvId = netEnvCurrId;
+    p_FmPcd->netEnvs[netEnvCurrId].h_FmPcd = p_FmPcd;
+
+
     p_FmPcd->netEnvs[netEnvCurrId].clsPlanGrpId = ILLEGAL_CLS_PLAN;
 
     /* check that header with opt is not interchanged with the same header */
@@ -1153,74 +1240,72 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             /* ENCAP_ESP  */
             if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_ENCAP_ESP)
             {
-                /* TODO - general coding. choose the free shim header */
+                /* IPSec UDP encapsulation is currently set to use SHIM1 */
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_UDP_ENCAP_ESP;
                 p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM1;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM1;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
             }
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
             /* IP FRAG  */
-            if(k==0)
-                if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
-                    (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV4_FRAG_1))
+            if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
+                (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV4_FRAG_1))
+            {
+                /* If IPv4+Frag, we need to set 2 units - SHIM 2 and IPv4. We first set SHIM2, and than check if
+                 * IPv4 exists. If so we don't need to set an extra unit
+                 * We consider as "having IPv4" any IPv4 without interchangable headers
+                 * but including any options.  */
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv4;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV4_FRAG_1;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
+
+                /* check if IPv4 header exists by itself */
+                if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv4, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+                {
+                    p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv4;
+                    p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
+                }
+            }
+            if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv6) &&
+                    (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV6_FRAG_1))
+            {
+                /* If IPv6+Frag, we need to set 2 units - SHIM 2 and IPv6. We first set SHIM2, and than check if
+                 * IPv4 exists. If so we don't need to set an extra unit
+                 * We consider as "having IPv6" any IPv6 without interchangable headers
+                 * but including any options.  */
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv6;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV6_FRAG_1;
+                p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+
+                for (j=0; (j < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
+                         (p_FmPcd->netEnvs[netEnvCurrId].units[j].hdrs[0].hdr != HEADER_TYPE_USER_DEFINED_SHIM2); j++) ;
+
+                if (j == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
                 {
-                    /* If IPv4+Frag, we need to set 2 units - SHIM 2 and IPv4. We first set SHIM2, and than check if
-                     * IPv4 exists. If so we don't need to set an extra unit
-                     * We consider as "having IPv4" any IPv4 without interchangable headers
-                     * but including any options.  */
-                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv4;
-                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV4_FRAG_1;
-                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
                     p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
                     p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
-
-                    /* check if IPv4 header exists by itself */
-                    if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv4, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+                    /* check if IPv6 header exists by itself */
+                    if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
                     {
-                        p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv4;
+                        p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv6;
                         p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
                     }
                 }
-                if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv6) &&
-                        (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV6_FRAG_1))
+                else
                 {
-                    /* If IPv6+Frag, we need to set 2 units - SHIM 2 and IPv6. We first set SHIM2, and than check if
-                     * IPv4 exists. If so we don't need to set an extra unit
-                     * We consider as "having IPv6" any IPv6 without interchangable headers
-                     * but including any options.  */
-                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv6;
-                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV6_FRAG_1;
-                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
-
-                    for(j=0; (j < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
-                             (p_FmPcd->netEnvs[netEnvCurrId].units[j].hdrs[0].hdr != HEADER_TYPE_USER_DEFINED_SHIM2); j++);
-                    if (j == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+                    if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
                     {
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
-                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
-                        /* check if IPv6 header exists by itself */
-                        if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
-                        {
-                            p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv6;
-                            p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
-                        }
+                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = HEADER_TYPE_IPv6;
+                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = 0;
                     }
                     else
                     {
-                        if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
-                        {
-                            p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = HEADER_TYPE_IPv6;
-                            p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = 0;
-                        }
-                        else
-                        {
-                            p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].hdr;
-                            p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].opt;
-                        }
+                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].hdr;
+                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].opt;
                     }
                 }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+            }
         }
     }
 
@@ -1293,19 +1378,28 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
 
     RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
 
-    return UINT_TO_PTR((uint64_t)netEnvCurrId+1);
+    p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock = XX_InitSpinlock();
+    if (!p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Pcd NetEnv spinlock"));
+        return NULL;
+    }
+    return &p_FmPcd->netEnvs[netEnvCurrId];
 }
 
-t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv)
+t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint8_t     netEnvId = (uint8_t)(PTR_TO_UINT(h_NetEnv)-1);
+    t_FmPcdNetEnv	*p_NetEnv = (t_FmPcdNetEnv*)h_NetEnv;
+    t_FmPcd     	*p_FmPcd = p_NetEnv->h_FmPcd;
 
-    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_STATE);
+    uint8_t     netEnvId = p_NetEnv->netEnvId;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
     if (!TRY_LOCK(p_FmPcd->h_Spinlock, &p_FmPcd->netEnvs[netEnvId].lock))
         return ERROR_CODE(E_BUSY);
+
     /* check that no port is bound to this netEnv */
     if(p_FmPcd->netEnvs[netEnvId].owners)
     {
@@ -1321,6 +1415,9 @@ t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv)
 
     RELEASE_LOCK(p_FmPcd->netEnvs[netEnvId].lock);
 
+    if (p_FmPcd->netEnvs[netEnvId].h_Spinlock)
+        XX_FreeSpinlock(p_FmPcd->netEnvs[netEnvId].h_Spinlock);
+
     return E_OK;
 }
 
@@ -1333,6 +1430,26 @@ void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd)
     FmHcTxConf(p_FmPcd->h_Hc, p_Fd);
 }
 
+t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmCtrlCodeRevisionInfo    revInfo;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->enabled, E_INVALID_HANDLE);
+
+    if ((err = FM_GetFmanCtrlCodeRevision(p_FmPcd->h_Fm, &revInfo)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    if (revInfo.packageRev != IP_OFFLOAD_PACKAGE_NUMBER)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Fman ctrl code package"));
+
+    p_FmPcd->advancedOffloadSupport = TRUE;
+
+    return E_OK;
+}
+
 uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1523,33 +1640,8 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd)
 
     return FmHcDumpRegs(p_FmPcd->h_Hc);
 }
-
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
-t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
-{
-    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t        bitMask = 0;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigException - guest mode!"));
-
-    GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
-    if(bitMask)
-    {
-        if (enable)
-            p_FmPcd->exceptions |= bitMask;
-        else
-            p_FmPcd->exceptions &= ~bitMask;
-   }
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
-
-    return E_OK;
-}
-
 t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 617ce46..712743d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -104,57 +104,6 @@ switch(exception){                                                  \
         bitMask = FM_PCD_EX_PRS_SINGLE_ECC; break;                  \
     default: bitMask = 0;break;}
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-/***********************************************************************/
-/*          SW parser IP_FRAG patch                                    */
-/***********************************************************************/
-#define SW_PRS_IP_FRAG_PATCH                           \
-{                                                      \
-        0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-        0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-        0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
-        0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
-        0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0, \
-        0x00,0x4F,0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
-        0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-        0x00,0x00,0x53,0x2F,0x00,0x00,0x31,0x52,0x00,0xDA, \
-        0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x2F, \
-        0x00,0x00,0x1B,0x31,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
-        0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F, \
-        0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43, \
-        0x30,0x7E,0x43,0x59,0x00,0x2C,0x32,0x11,0x28,0x41, \
-        0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
-        0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
-        0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
-        0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
-        0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x3C,0x00,0x03, \
-        0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0, \
-        0x00,0x4F,0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
-        0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-        0x00,0x00,0x43,0x6E,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-        0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00, \
-        0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
-        0x28,0x43,0x30,0x7E,0x43,0x80,0x00,0x00,0x30,0x7E, \
-        0x43,0x80,0x00,0x3C,0x1B,0x9A,0x32,0x11,0x28,0x41, \
-        0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
-        0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
-        0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
-        0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
-        0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x79,0x30,0x7E, \
-        0x53,0xB0,0x00,0x2B,0x32,0x11,0x28,0x41,0x32,0x11, \
-        0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
-        0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
-        0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
-        0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0xC4,0x00,0x00, \
-        0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x41,0x06,0x29, \
-        0x32,0x01,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
-        0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
-        0x1B,0xFE,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
-        0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x00,0x01, \
-        0x1B,0xFE,                                         \
-};
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-
 /****************************/
 /* Parser defines           */
 /****************************/
@@ -362,7 +311,6 @@ switch(exception){                                                  \
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 typedef _Packed struct {
    volatile uint32_t kgoe_sp;
@@ -401,7 +349,7 @@ typedef _Packed struct {
     volatile uint32_t kgfeer;
     volatile uint32_t res6[38];
     u_FmPcdKgIndirectAccessRegs   indirectAccessRegs;
-    volatile uint32_t res[42];                  /*(0xfc-sizeof(u_FmPcdKgIndirectAccessRegs))/4 */
+    volatile uint32_t res[40];                  /*(0xfc-sizeof(u_FmPcdKgIndirectAccessRegs))/4 */
     volatile uint32_t kgar;
 } _PackedType t_FmPcdKgRegs;
 
@@ -471,7 +419,6 @@ typedef _Packed struct {
     volatile uint32_t fcscs;
 } _PackedType t_FmPcdPrsRegs;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -520,7 +467,10 @@ typedef struct {
 } t_FmPcdKgClsPlanGrp;
 
 typedef struct {
-    volatile bool       lock;
+	t_Handle			h_FmPcd;
+	uint8_t				schemeId;
+	volatile bool       lock;
+    t_Handle            h_Spinlock;
     bool                valid;
     uint8_t             netEnvId;
     uint8_t             owners;
@@ -537,6 +487,9 @@ typedef struct {
     bool                extractedOrs;
     uint8_t             bitOffsetInPlcrProfile;
     bool                directPlcr;
+#if DPAA_VERSION >= 3
+    bool                vspe;
+#endif
 } t_FmPcdKgScheme;
 
 typedef struct {
@@ -549,6 +502,8 @@ typedef struct {
     t_FmPcdKgRegs       *p_FmPcdKgRegs;
     uint32_t            schemeExceptionsBitMask;
     uint8_t             numOfSchemes;
+    t_Handle            h_HwSpinlock;
+    t_Handle            h_SwSpinlock;
     uint8_t             schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
     t_FmPcdKgScheme     schemes[FM_PCD_KG_NUM_OF_SCHEMES];
     t_FmPcdKgClsPlanGrp clsPlanGrps[FM_MAX_NUM_OF_PORTS];
@@ -564,11 +519,14 @@ typedef struct {
 } t_FmPcdPlcrMapParam;
 
 typedef struct {
-    bool                valid;
-    volatile bool       lock;
-    t_FmPcdAllocMng     profilesMng;
-    uint8_t             pointedOwners;
-    uint32_t            requiredAction;
+	uint16_t							absoluteProfileId;
+	t_Handle							h_FmPcd;
+    bool                                valid;
+    /*volatile bool                       lock;*/
+    t_Handle                            h_Spinlock;
+    t_FmPcdAllocMng                     profilesMng;
+    uint8_t                             pointedOwners;
+    uint32_t                            requiredAction;
     e_FmPcdEngine                       nextEngineOnGreen;          /**< Green next engine type */
     u_FmPcdPlcrNextEngineParams         paramsOnGreen;              /**< Green next engine params */
 
@@ -585,6 +543,9 @@ typedef struct {
     uint16_t                        numOfSharedProfiles;
     uint16_t                        sharedProfilesIds[FM_PCD_PLCR_NUM_ENTRIES];
     t_FmPcdPlcrMapParam             portsMapping[FM_MAX_NUM_OF_PORTS];
+    t_Handle                        h_HwSpinlock;
+    t_Handle                        h_SwSpinlock;
+
 } t_FmPcdPlcr;
 
 typedef struct {
@@ -610,7 +571,10 @@ typedef struct {
 } t_FmPcdNetEnvAliases;
 
 typedef struct {
+	uint8_t						netEnvId;
+	t_Handle					h_FmPcd;
     volatile bool               lock;
+    t_Handle                    h_Spinlock;
     bool                        used;
     uint8_t                     owners;
     uint8_t                     clsPlanGrpId;
@@ -626,9 +590,11 @@ typedef struct {
     uint16_t                    prsMaxParseCycleLimit;
 } t_FmPcdDriverParam;
 
+
 typedef struct {
     t_Handle                    h_Fm;
     t_Handle                    h_FmMuram;
+    t_FmRevisionInfo            fmRevInfo;
     uint64_t                    physicalMuramBase;
     volatile bool               lock;
     t_Handle                    h_Spinlock;
@@ -643,13 +609,20 @@ typedef struct {
     t_FmPcdPlcr                 *p_FmPcdPlcr;
     t_FmPcdPrs                  *p_FmPcdPrs;
 
+    void                        *p_CcShadow;     /**< CC MURAM shadow */
+    uint32_t                    ccShadowSize;
+    uint32_t                    ccShadowAlign;
+    volatile bool               shadowLock;
+    t_Handle                    h_ShadowSpinlock;
+
     t_Handle                    h_Hc;
 
     uint32_t                    exceptions;
     t_FmPcdExceptionCallback    *f_Exception;
     t_FmPcdIdExceptionCallback  *f_FmPcdIndexedException;
     t_Handle                    h_App;
-    t_Handle                    h_FragIdPtr;
+    uintptr_t                   ipv6FrameIdAddr;
+    bool                        advancedOffloadSupport;
 
     t_FmPcdDriverParam          *p_FmPcdDriverParam;
 } t_FmPcd;
@@ -667,14 +640,10 @@ void        FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t cls
 e_NetHeaderType FmPcdGetAliasHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
 uint8_t     FmPcdNetEnvGetUnitIdForSingleHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
 uint8_t     FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr, bool interchangable, protocolOpt_t opt);
-uint8_t     FmPcdGetNetEnvId(t_FmPcd *p_FmPcd, t_Handle h_NetEnv);
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-t_Error     FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint32_t groupId);
-t_Error     FmPcdManipDeleteIpReassmSchemes(t_FmPcd *p_FmPcd, t_Handle h_Manip);
-bool        FmPcdManipIsIpv4Present(t_FmPcd *p_FmPcd, uint8_t netEnvId);
-bool        FmPcdManipIsIpv6Present(t_FmPcd *p_FmPcd, uint8_t netEnvId);
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+t_Error     FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint8_t groupId);
+t_Error     FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip);
+bool        FmPcdManipIsIpPresent(t_FmPcd *p_FmPcd, uint8_t netEnvId, bool ipv6);
 
 t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     KgInit(t_FmPcd *p_FmPcd);
@@ -709,20 +678,40 @@ void        PrsDisable(t_FmPcd *p_FmPcd);
 void        PrsFree(t_FmPcd *p_FmPcd );
 t_Error     PrsIncludePortInStatistics(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, bool include);
 
-t_Handle    FmPcdCcConfig(t_Handle h_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     FmPcdCcGetGrpParams(t_Handle treeId, uint8_t grpId, uint32_t *p_GrpBits, uint8_t *p_GrpBase);
 uint8_t     FmPcdCcGetOffset(t_Handle h_CcNode);
 uint8_t     FmPcdCcGetParseCode(t_Handle h_CcNode);
 uint16_t    FmPcdCcGetNumOfKeys(t_Handle h_CcNode);
+t_Error     ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 void        FmPcdManipUpdateOwner(t_Handle h_Manip, bool add);
 t_Error     FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_InfoForManip, uint32_t *requiredAction);
 void        FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew);
 void        FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew, uint32_t adTableOffset);
-uint32_t    FmPcdManipCheckNia(t_Handle h_FmPcd, t_Handle h_Ad);
 void        FmPcdManipUpdateOwner(t_Handle h_Manip, bool add);
 t_Error     FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcdCcNode);
-
+#ifdef FM_CAPWAP_SUPPORT
+t_Handle    FmPcdManipApplSpecificBuild(void);
+bool        FmPcdManipIsCapwapApplSpecific(t_Handle h_Manip);
+#endif /* FM_CAPWAP_SUPPORT */
+#if DPAA_VERSION >= 3
+void *      FrmReplicGetSourceTableDescriptor(t_Handle h_ReplicGroup);
+void        FrmReplicUpdateGroupOwner(t_Handle h_ReplicGroup, bool add, bool fullUpdate, t_Handle h_FmPcdCcNode);
+void        FrmReplicUpdateAdContLookupForCc(t_Handle h_ReplicGroup, t_Handle p_Ad, t_Handle *h_AdNew);
+
+void        FmPcdCcGetAdTablesThatPointOnReplicGroup(t_Handle   h_Node,
+                                                     t_Handle   h_ReplicGroup,
+                                                     t_List     *p_AdTables,
+                                                     uint32_t   *p_NumOfAdTables);
+#endif /* DPAA_VERSION >= 3 */
+
+void EnqueueNodeInfoToRelevantLst(t_List *p_List, t_CcNodeInformation *p_CcInfo);
+t_CcNodeInformation* FmPcdCcFindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info);
+void FmPcdCcDequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info);
+
+void NextStepAd(t_Handle p_Ad, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_FmPcd *p_FmPcd);
+void FillAdOfTypeResult(t_Handle p_Ad, t_FmPcd *p_FmPcd, t_FmPcdCcNextEngineParams *p_CcNextEngineParams);
+void ReleaseLst(t_List *p_List);
 
 static __inline__ t_Handle FmPcdGetMuramHandle(t_Handle h_FmPcd)
 {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
index 57f3764..497dc95 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -53,7 +53,6 @@
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 /**************************************************************************//**
  @Description   Structure for getting a sw parser address according to a label
@@ -79,40 +78,49 @@ typedef _Packed struct t_FmPcdIpcSwPrsLable
                 Some fields are optional (depending on configuration) and
                 will be analized by the port and FM modules accordingly.
 *//***************************************************************************/
+
 typedef  struct t_FmPcdIpcKgSchemesParams
 {
-    uint8_t     guestId;                                    /**< IN */
-    uint8_t     numOfSchemes;                               /**< IN */
-    uint8_t     schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];       /**< OUT */
+    uint8_t     guestId;
+    uint8_t     numOfSchemes;
+    uint8_t     schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
 } _PackedType t_FmPcdIpcKgSchemesParams;
 
 typedef  struct t_FmPcdIpcKgClsPlanParams
 {
-    uint8_t     guestId;                                    /**< IN */
-    uint16_t    numOfClsPlanEntries;                        /**< IN */
-    uint8_t     clsPlanBase;                                /**< IN in alloc only */
+    uint8_t     guestId;
+    uint16_t    numOfClsPlanEntries;
+    uint8_t     clsPlanBase;
 } _PackedType t_FmPcdIpcKgClsPlanParams;
 
 typedef _Packed struct t_FmPcdIpcPlcrAllocParams
 {
-    uint16_t num;
-    uint8_t  hardwarePortId;
-    uint16_t plcrProfilesBase;
+    uint16_t    num;
+    uint8_t     hardwarePortId;
+    uint16_t    plcrProfilesBase;
 } _PackedType t_FmPcdIpcPlcrAllocParams;
 
 typedef _Packed struct t_FmPcdIpcSharedPlcrAllocParams
 {
-    uint16_t  num;                                    /**< IN */
-    //uint16_t  profilesIds[FM_PCD_PLCR_NUM_ENTRIES];   /**< OUT */
+    uint16_t    num;
     uint32_t    sharedProfilesMask[8];
 } _PackedType t_FmPcdIpcSharedPlcrAllocParams;
 
 typedef _Packed struct t_FmPcdIpcPrsIncludePort
 {
-    uint8_t hardwarePortId;     /* IN */
-    bool    include;            /* IN */
+    uint8_t     hardwarePortId;
+    bool        include;
 } _PackedType t_FmPcdIpcPrsIncludePort;
 
+#if DPAA_VERSION >= 3
+typedef _Packed struct t_FmPcdIpcSpAllocParams
+{
+    uint16_t    num;
+    uint8_t     hardwarePortId;
+    uint16_t    spProfilesBase;
+} _PackedType t_FmPcdIpcSpAllocParams;
+#endif /* DPAA_VERSION >= 3 */
+
 
 #define FM_PCD_MAX_REPLY_SIZE           16
 #define FM_PCD_MAX_MSG_SIZE             36
@@ -130,7 +138,6 @@ typedef _Packed struct t_FmPcdIpcReply
     uint8_t     replyBody[FM_PCD_MAX_REPLY_BODY_SIZE];
 } _PackedType t_FmPcdIpcReply;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -282,7 +289,7 @@ typedef _Packed struct t_FmPcdIpcReply
 
  @Param[in/out] t_FmPcdIpcKgClsPlanParams Pointer
 *//***************************************************************************/
-#define FM_PCD_FREE_KG_CLSPLAN                     22
+#define FM_PCD_FREE_KG_CLSPLAN                  22
 
 /**************************************************************************//**
  @Function      FM_PCD_ALLOC_KG_CLSPLAN
@@ -291,7 +298,7 @@ typedef _Packed struct t_FmPcdIpcReply
 
  @Param[in/out] t_FmPcdIpcKgClsPlanParams Pointer
 *//***************************************************************************/
-#define FM_PCD_ALLOC_KG_CLSPLAN                    23
+#define FM_PCD_ALLOC_KG_CLSPLAN                 23
 
 /**************************************************************************//**
  @Function      FM_PCD_MASTER_IS_ALIVE
@@ -319,6 +326,13 @@ typedef _Packed struct t_FmPcdIpcReply
  @Param[in/out] t_FmPcdIpcPrsIncludePort Pointer
 *//***************************************************************************/
 #define FM_PCD_PRS_INC_PORT_STATS               26
+
+#if DPAA_VERSION >= 3
+/* TODO - doc */
+#define FM_PCD_ALLOC_SP                         27
+#endif /* DPAA_VERSION >= 3 */
+
+
 /** @} */ /* end of FM_PCD_IPC_grp group */
 /** @} */ /* end of FM_grp group */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index 478a064..b848615 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -47,8 +47,45 @@
 #include "fm_hc.h"
 #include "fm_pcd_ipc.h"
 
+static uint32_t PlcrProfileLock(t_Handle h_Profile)
+{
+    ASSERT_COND(h_Profile);
+
+    return XX_LockIntrSpinlock(((t_FmPcdPlcrProfile*)h_Profile)->h_Spinlock);
+}
+
+static void PlcrProfileUnlock(t_Handle h_Profile, uint32_t intFlags)
+{
+    ASSERT_COND(h_Profile);
+
+    XX_UnlockIntrSpinlock(((t_FmPcdPlcrProfile*)h_Profile)->h_Spinlock, intFlags);
+}
+
+static uint32_t PlcrHwLock(t_Handle h_FmPcdPlcr)
+{
+    ASSERT_COND(h_FmPcdPlcr);
+    return XX_LockIntrSpinlock(((t_FmPcdPlcr*)h_FmPcdPlcr)->h_HwSpinlock);
+}
+
+static void PlcrHwUnlock(t_Handle h_FmPcdPlcr, uint32_t intFlags)
+{
+    ASSERT_COND(h_FmPcdPlcr);
+    XX_UnlockIntrSpinlock(((t_FmPcdPlcr*)h_FmPcdPlcr)->h_HwSpinlock, intFlags);
+}
+
+static uint32_t PlcrSwLock(t_Handle h_FmPcdPlcr)
+{
+    ASSERT_COND(h_FmPcdPlcr);
+    return XX_LockIntrSpinlock(((t_FmPcdPlcr*)h_FmPcdPlcr)->h_SwSpinlock);
+}
 
-static bool FmPcdPlcrIsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+static void PlcrSwUnlock(t_Handle h_FmPcdPlcr, uint32_t intFlags)
+{
+    ASSERT_COND(h_FmPcdPlcr);
+    XX_UnlockIntrSpinlock(((t_FmPcdPlcr*)h_FmPcdPlcr)->h_SwSpinlock, intFlags);
+}
+
+static bool IsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint16_t        i;
@@ -64,7 +101,7 @@ static bool FmPcdPlcrIsProfileShared(t_Handle h_FmPcd, uint16_t absoluteProfileI
 static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcdPlcrNextEngineParams *p_NextEngineParams, uint32_t *nextAction)
 {
     uint32_t    nia;
-    uint16_t    absoluteProfileId = (uint16_t)(PTR_TO_UINT(p_NextEngineParams->h_Profile)-1);
+    uint16_t    absoluteProfileId;
     uint8_t     relativeSchemeId, physicalSchemeId;
 
     nia = FM_PCD_PLCR_NIA_VALID;
@@ -75,31 +112,32 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
             switch (p_NextEngineParams->action)
             {
                 case e_FM_PCD_DROP_FRAME :
-                    nia |= (NIA_ENG_BMI | NIA_BMI_AC_DISCARD);
+                    nia |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
                     break;
                 case e_FM_PCD_ENQ_FRAME:
-                    nia |= (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+                    nia |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
                     break;
                 default:
                     RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             }
             break;
         case e_FM_PCD_KG:
-            physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_NextEngineParams->h_DirectScheme)-1);
+            physicalSchemeId = FmPcdKgGetSchemeId(p_NextEngineParams->h_DirectScheme);
             relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
             if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
-            if (!FmPcdKgIsSchemeValidSw(p_FmPcd, relativeSchemeId))
+            if (!FmPcdKgIsSchemeValidSw(p_NextEngineParams->h_DirectScheme))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
             if(!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Policer Profile may point only to a scheme that is always direct."));
             nia |= NIA_ENG_KG | NIA_KG_DIRECT | physicalSchemeId;
             break;
         case e_FM_PCD_PLCR:
-             if(!FmPcdPlcrIsProfileShared(p_FmPcd, absoluteProfileId))
-               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next profile must be a shared profile"));
-             if(!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
-               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile "));
+            absoluteProfileId = ((t_FmPcdPlcrProfile *)p_NextEngineParams->h_Profile)->absoluteProfileId;
+            if(!IsProfileShared(p_FmPcd, absoluteProfileId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next profile must be a shared profile"));
+            if(!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile "));
             nia |= NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId;
             break;
         default:
@@ -111,24 +149,24 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
     return E_OK;
 }
 
-static uint32_t FPP_Function(uint32_t fpp)
+static uint32_t CalcFPP(uint32_t fpp)
 {
-    if(fpp > 15)
+    if (fpp > 15)
         return 15 - (0x1f - fpp);
     else
         return 16 + fpp;
 }
 
-static void GetInfoRateReg(e_FmPcdPlcrRateMode rateMode,
-                                uint32_t rate,
-                                uint64_t tsuInTenthNano,
-                                uint32_t fppShift,
-                                uint64_t *p_Integer,
-                                uint64_t *p_Fraction)
+static void GetInfoRateReg(e_FmPcdPlcrRateMode  rateMode,
+                           uint32_t             rate,
+                           uint64_t             tsuInTenthNano,
+                           uint32_t             fppShift,
+                           uint64_t             *p_Integer,
+                           uint64_t             *p_Fraction)
 {
     uint64_t tmp, div;
 
-    if(rateMode == e_FM_PCD_PLCR_BYTE_MODE)
+    if (rateMode == e_FM_PCD_PLCR_BYTE_MODE)
     {
         /* now we calculate the initial integer for the bigger rate */
         /* from Kbps to Bytes/TSU */
@@ -161,8 +199,13 @@ static void GetInfoRateReg(e_FmPcdPlcrRateMode rateMode,
 
 /* .......... */
 
-static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_NonPassthroughAlgParam,
-                        uint32_t *cir, uint32_t *cbs, uint32_t *pir_eir, uint32_t *pbs_ebs, uint32_t *fpp)
+static void CalcRates(t_Handle                              h_FmPcd,
+                      t_FmPcdPlcrNonPassthroughAlgParams    *p_NonPassthroughAlgParam,
+                      uint32_t                              *cir,
+                      uint32_t                              *cbs,
+                      uint32_t                              *pir_eir,
+                      uint32_t                              *pbs_ebs,
+                      uint32_t                              *fpp)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint64_t    integer, fraction;
@@ -174,22 +217,39 @@ static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_No
     tsuInTenthNanos = (uint32_t)(1000*10/(1<<bitFor1Micro));
 
     /* we choose the faster rate to calibrate fpp */
+    /* The meaning of this step:
+     * when fppShift is 0 it means all TS bits are treated as integer and TSU is the TS LSB count.
+     * In this configuration we calculate the integer and fraction that represent the higher infoRate
+     * When this is done, we can tell where we have "spare" unused bits and optimize the division of TS
+     * into "integer" and "fraction" where the logic is - as many bits as possible for integer at
+     * high rate, as many bits as possible for fraction at low rate.
+     */
     if (p_NonPassthroughAlgParam->comittedInfoRate > p_NonPassthroughAlgParam->peakOrAccessiveInfoRate)
         GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, tsuInTenthNanos, 0, &integer, &fraction);
     else
         GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, tsuInTenthNanos, 0, &integer, &fraction);
 
-
     /* we shift integer, as in cir/pir it is represented by the MSB 16 bits, and
      * the LSB bits are for the fraction */
     temp = (uint32_t)((integer<<16) & 0x00000000FFFFFFFF);
     /* temp is effected by the rate. For low rates it may be as low as 0, and then we'll
-     * take max fpp=31.
+     * take max FP = 31.
      * For high rates it will never exceed the 32 bit reg (after the 16 shift), as it is
      * limited by the 10G physical port.
      */
     if(temp != 0)
     {
+	/* In this case, the largest rate integer is non 0, if it does not occupy all (high) 16
+	 * bits of the PIR_EIR we can use this fact and enlarge it to occupy all 16 bits.
+	 * The logic is to have as many bits for integer in the higher rates, but if we have "0"s
+	 * in the integer part of the cir/pir register, than these bits are wasted. So we want
+	 * to use these bits for the fraction. in this way we will have for fraction - the number
+	 * of "0" bits and the rest - for integer.
+	 * In other words: For each bit we shift it in PIR_EIR, we move the FP in the TS
+	 * one bit to the left - preserving the relationship and achieving more bits
+	 * for integer in the TS.
+	 */
+
         /* count zeroes left of the higher used bit (in order to shift the value such that
          * unused bits may be used for fraction).
          */
@@ -208,11 +268,11 @@ static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_No
     {
         temp = (uint32_t)fraction; /* fraction will alyas be smaller than 2^16 */
         if(!temp)
-            /* integer and fraction are 0, we set fpp to its max val */
+            /* integer and fraction are 0, we set FP to its max val */
             fppShift = 31;
         else
         {
-            /* integer was 0 but fraction is not. fpp is 16 for the integer,
+            /* integer was 0 but fraction is not. FP is 16 for the fraction,
              * + all left zeroes of the fraction. */
             fppShift=16;
             /* count zeroes left of the higher used bit (in order to shift the value such that
@@ -227,9 +287,9 @@ static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_No
     }
 
     /*
-     * This means that the FM TS register will now be used so that 'count' bits are for
+     * This means that the FM TS register will now be used so that 'fppShift' bits are for
      * fraction and the rest for integer */
-    /* now we re-calculate cir */
+    /* now we re-calculate cir and pir_eir with the calculated FP */
     GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->comittedInfoRate, tsuInTenthNanos, fppShift, &integer, &fraction);
     *cir = (uint32_t)(integer << 16 | (fraction & 0xFFFF));
     GetInfoRateReg(p_NonPassthroughAlgParam->rateMode, p_NonPassthroughAlgParam->peakOrAccessiveInfoRate, tsuInTenthNanos, fppShift, &integer, &fraction);
@@ -238,9 +298,11 @@ static void calcRates(t_Handle h_FmPcd, t_FmPcdPlcrNonPassthroughAlgParams *p_No
     *cbs     =  p_NonPassthroughAlgParam->comittedBurstSize;
     *pbs_ebs =  p_NonPassthroughAlgParam->peakOrAccessiveBurstSize;
 
-    /* get fpp as it should be written to reg.*/
-    *fpp = FPP_Function(fppShift);
-
+    /* convert FP as it should be written to reg.
+     * 0-15 --> 16-31
+     * 16-31 --> 0-15
+     */
+    *fpp = CalcFPP(fppShift);
 }
 
 static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
@@ -256,7 +318,7 @@ static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
 /*********************************************/
 /*............Policer Exception..............*/
 /*********************************************/
-static void PcdPlcrException(t_Handle h_FmPcd)
+static void EventsCB(t_Handle h_FmPcd)
 {
     t_FmPcd *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t event, mask, force;
@@ -283,7 +345,7 @@ static void PcdPlcrException(t_Handle h_FmPcd)
 
 /* ..... */
 
-static void PcdPlcrErrorException(t_Handle h_FmPcd)
+static void ErrorExceptionsCB(t_Handle h_FmPcd)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
     uint32_t            event, force, captureReg, mask;
@@ -301,9 +363,9 @@ static void PcdPlcrErrorException(t_Handle h_FmPcd)
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
 
-    if(event & FM_PCD_PLCR_DOUBLE_ECC)
+    if (event & FM_PCD_PLCR_DOUBLE_ECC)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC);
-    if(event & FM_PCD_PLCR_INIT_ENTRY_ERROR)
+    if (event & FM_PCD_PLCR_INIT_ENTRY_ERROR)
     {
         captureReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_upcr);
         /*ASSERT_COND(captureReg & PLCR_ERR_UNINIT_CAP);
@@ -315,181 +377,491 @@ static void PcdPlcrErrorException(t_Handle h_FmPcd)
     }
 }
 
-void FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bool add)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
 
-    if(add)
-        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners++;
-    else
-        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners--;
-}
 
-uint32_t FmPcdPlcrGetPointedOwners(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+t_Handle PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr *p_FmPcdPlcr;
+    /*uint8_t i=0;*/
 
-   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+    UNUSED(p_FmPcd);
+    UNUSED(p_FmPcdParams);
 
-    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners;
-}
-uint32_t FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    p_FmPcdPlcr = (t_FmPcdPlcr *) XX_Malloc(sizeof(t_FmPcdPlcr));
+    if (!p_FmPcdPlcr)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer structure allocation FAILED"));
+        return NULL;
+    }
+    memset(p_FmPcdPlcr, 0, sizeof(t_FmPcdPlcr));
+    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    {
+        p_FmPcdPlcr->p_FmPcdPlcrRegs  = (t_FmPcdPlcrRegs *)UINT_TO_PTR(FmGetPcdPlcrBaseAddr(p_FmPcdParams->h_Fm));
+        p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh    = DEFAULT_plcrAutoRefresh;
+        p_FmPcd->exceptions |= (DEFAULT_fmPcdPlcrExceptions | DEFAULT_fmPcdPlcrErrorExceptions);
+    }
 
-   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+    p_FmPcdPlcr->numOfSharedProfiles = DEFAULT_numOfSharedPlcrProfiles;
 
-    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction;
+    return p_FmPcdPlcr;
 }
 
-t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
+t_Error PlcrInit(t_FmPcd *p_FmPcd)
 {
-    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
-    t_Error                     err = E_OK;
-    uint16_t                    base;
-    uint16_t                    swPortIndex = 0;
-    t_FmPcdIpcMsg               msg;
-    uint32_t                    replyLength;
-    t_FmPcdIpcReply             reply;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    t_FmPcdDriverParam              *p_Param = p_FmPcd->p_FmPcdDriverParam;
+    t_FmPcdPlcr                     *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
+    uint32_t                        tmpReg32 = 0;
+    t_Error                         err = E_OK;
+    t_FmPcdPlcrRegs                 *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    t_FmPcdIpcMsg                   msg;
+    uint32_t                        replyLength;
+    t_FmPcdIpcReply                 reply;
 
-    if(!numOfProfiles)
-        return E_OK;
+    p_FmPcdPlcr->h_HwSpinlock = XX_InitSpinlock();
+    if (!p_FmPcdPlcr->h_HwSpinlock)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer HW spinlock"));
 
-    memset(&ipcPlcrParams, 0, sizeof(ipcPlcrParams));
+    p_FmPcdPlcr->h_SwSpinlock = XX_InitSpinlock();
+    if (!p_FmPcdPlcr->h_SwSpinlock)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer SW spinlock"));
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
+        (p_FmPcdPlcr->numOfSharedProfiles))
     {
-        /* Alloc resources using IPC messaging */
+        int         i, j, index = 0;
+        uint32_t    walking1Mask = 0x80000000;
+        uint32_t    sharedProfilesMask[FM_PCD_PLCR_NUM_ENTRIES/32];
+
+        memset(sharedProfilesMask, 0, FM_PCD_PLCR_NUM_ENTRIES/32 * sizeof(uint32_t));
         memset(&reply, 0, sizeof(reply));
         memset(&msg, 0, sizeof(msg));
-        ipcPlcrParams.num = numOfProfiles;
-        ipcPlcrParams.hardwarePortId = hardwarePortId;
-        msg.msgId = FM_PCD_ALLOC_PROFILES;
-        memcpy(msg.msgBody, &ipcPlcrParams, sizeof(ipcPlcrParams));
-        replyLength = sizeof(uint32_t) + sizeof(uint16_t);
+        msg.msgId = FM_PCD_ALLOC_SHARED_PROFILES;
+        memcpy(msg.msgBody, (uint8_t *)&p_FmPcdPlcr->numOfSharedProfiles, sizeof(uint16_t));
+        replyLength = sizeof(uint32_t) + sizeof(sharedProfilesMask);
         if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
                                      (uint8_t*)&msg,
-                                     sizeof(msg.msgId) +sizeof(ipcPlcrParams),
+                                     sizeof(msg.msgId)+ sizeof(p_FmPcdPlcr->numOfSharedProfiles),
                                      (uint8_t*)&reply,
                                      &replyLength,
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MAJOR, err,NO_MSG);
-        if (replyLength != sizeof(uint32_t) + sizeof(uint16_t))
+        if (replyLength != (sizeof(uint32_t) + sizeof(sharedProfilesMask)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        if((t_Error)reply.error != E_OK)
-            RETURN_ERROR(MAJOR, (t_Error)reply.error, ("PLCR profiles allocation failed"));
 
-        memcpy((uint8_t*)&base, reply.replyBody, sizeof(uint16_t));
+        memcpy(sharedProfilesMask, reply.replyBody, sizeof(sharedProfilesMask));
+        /* translate 8 regs of 32 bits masks into an array of up to 256 indexes. */
+        for(i = 0; i<FM_PCD_PLCR_NUM_ENTRIES/32 ; i++)
+        {
+            if(sharedProfilesMask[i])
+            {
+                for(j = 0 ; j<32 ; j++)
+                {
+                    if(sharedProfilesMask[i] & walking1Mask)
+                        p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[index++] = (uint16_t)(i*32+j);
+                    walking1Mask >>= 1;
+                }
+                walking1Mask = 0x80000000;
+            }
+        }
+        return (t_Error)reply.error;
     }
-    else /* master */
+
+    if(p_FmPcdPlcr->numOfSharedProfiles)
     {
-        err = PlcrAllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
+        err = PlcrAllocSharedProfiles(p_FmPcd, p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
         if(err)
             RETURN_ERROR(MAJOR, err,NO_MSG);
     }
-    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
-
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = numOfProfiles;
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = base;
-
-    return E_OK;
-}
-
-t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
-{
-    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
-    t_Error                     err = E_OK;
-    uint16_t                    swPortIndex = 0;
-    t_FmPcdIpcMsg               msg;
-    uint32_t                    replyLength;
-    t_FmPcdIpcReply             reply;
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    /**********************FMPL_GCR******************/
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+    if(p_Param->plcrAutoRefresh)
+        tmpReg32 |= FM_PCD_PLCR_GCR_DAR;
+    tmpReg32 |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
 
-    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+    WRITE_UINT32(p_Regs->fmpl_gcr, tmpReg32);
+    /**********************FMPL_GCR******************/
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-    {
-        /* Alloc resources using IPC messaging */
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        ipcPlcrParams.num = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles;
-        ipcPlcrParams.hardwarePortId = hardwarePortId;
-        ipcPlcrParams.plcrProfilesBase = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase;
-        msg.msgId = FM_PCD_FREE_PROFILES;
-        memcpy(msg.msgBody, &ipcPlcrParams, sizeof(ipcPlcrParams));
-        replyLength = sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId) +sizeof(ipcPlcrParams),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
-        if (replyLength != sizeof(uint32_t))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        if ((t_Error)reply.error != E_OK)
-            RETURN_ERROR(MINOR, (t_Error)reply.error, ("PLCR Free Profiles failed"));
-    }
-    else /* master */
+    /**********************FMPL_EEVR******************/
+    WRITE_UINT32(p_Regs->fmpl_eevr, (FM_PCD_PLCR_DOUBLE_ECC | FM_PCD_PLCR_INIT_ENTRY_ERROR));
+    /**********************FMPL_EEVR******************/
+    /**********************FMPL_EIER******************/
+    tmpReg32 = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
     {
-        err = PlcrFreeProfiles(p_FmPcd, hardwarePortId, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
-        if(err)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
+        FmEnableRamsEcc(p_FmPcd->h_Fm);
+        tmpReg32 |= FM_PCD_PLCR_DOUBLE_ECC;
     }
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
-    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
+        tmpReg32 |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
+    WRITE_UINT32(p_Regs->fmpl_eier, tmpReg32);
+    /**********************FMPL_EIER******************/
 
-    return E_OK;
-}
+    /**********************FMPL_EVR******************/
+    WRITE_UINT32(p_Regs->fmpl_evr, (FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE | FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE));
+    /**********************FMPL_EVR******************/
+    /**********************FMPL_IER******************/
+    tmpReg32 = 0;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE)
+        tmpReg32 |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
+    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE )
+        tmpReg32 |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
+    WRITE_UINT32(p_Regs->fmpl_ier, tmpReg32);
+    /**********************FMPL_IER******************/
 
-bool    FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
-{
-    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
-    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    /* register even if no interrupts enabled, to allow future enablement */
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR, ErrorExceptionsCB, p_FmPcd);
+    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL, EventsCB, p_FmPcd);
 
-    return p_FmPcdPlcr->profiles[absoluteProfileId].valid;
+    /* driver initializes one DFLT profile at the last entry*/
+    /**********************FMPL_DPMR******************/
+    tmpReg32 = 0;
+    WRITE_UINT32(p_Regs->fmpl_dpmr, tmpReg32);
+    p_FmPcd->p_FmPcdPlcr->profiles[0].profilesMng.allocated = TRUE;
+
+    return E_OK;
 }
 
-t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
+t_Error PlcrFree(t_FmPcd *p_FmPcd)
 {
-    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    uint32_t        profilesFound, log2Num, tmpReg32;
-    uint32_t        intFlags;
-    uint16_t        first, i;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    t_Error                             err;
+    t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
+    t_FmPcdIpcMsg                       msg;
 
-    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    if(!numOfProfiles)
-        return E_OK;
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR);
+    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL);
 
-    ASSERT_COND(hardwarePortId);
+    if(p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
+    {
+        if(p_FmPcd->guestId != NCSW_MASTER_ID)
+        {
+            int i;
+            memset(ipcSharedPlcrParams.sharedProfilesMask, 0, sizeof(ipcSharedPlcrParams.sharedProfilesMask));
+            /* Free resources using IPC messaging */
+            ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
 
-    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+            /* translate the allocated profile id's to a 32bit * 8regs mask */
+            for(i = 0;i<p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;i++)
+                ipcSharedPlcrParams.sharedProfilesMask[p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i]/32] |= (0x80000000 >> (p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i] % 32));
+
+            memset(&msg, 0, sizeof(msg));
+            msg.msgId = FM_PCD_FREE_SHARED_PROFILES;
+            memcpy(msg.msgBody, &ipcSharedPlcrParams, sizeof(ipcSharedPlcrParams));
+            if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                         (uint8_t*)&msg,
+                                         sizeof(msg.msgId)+sizeof(ipcSharedPlcrParams),
+                                         NULL,
+                                         NULL,
+                                         NULL,
+                                         NULL)) != E_OK)
+                RETURN_ERROR(MAJOR, err,NO_MSG);
+        }
+       /* else
+            PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);*/
+    }
+    return E_OK;
+}
+
+void PlcrEnable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) | FM_PCD_PLCR_GCR_EN);
+}
+
+void PlcrDisable(t_FmPcd *p_FmPcd)
+{
+    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+
+    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) & ~FM_PCD_PLCR_GCR_EN);
+}
+
+t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t requiredAction)
+{
+    t_FmPcd         *p_FmPcd           = (t_FmPcd *)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        tmpReg32, intFlags;
+    t_Error         err;
+
+    if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile out of range"));
+
+    if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileIndx))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile is not valid"));
+
+    intFlags = PlcrProfileLock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx]);
+
+    if (p_FmPcd->h_Hc)
+    {
+        err = FmHcPcdPlcrCcGetSetParams(p_FmPcd->h_Hc, profileIndx, requiredAction);
+
+        FmPcdPlcrUpatePointedOwner(p_FmPcd, profileIndx, TRUE);
+        FmPcdPlcrUpdateRequiredAction(p_FmPcd, profileIndx, requiredAction);
+
+        PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+        return err;
+    }
+
+    /* lock the HW because once we read the registers we don't them to be changed
+     * by another access. (We can copy to a tmp location and release the lock!) */
+
+    intFlags = PlcrHwLock(p_FmPcdPlcr);
+    WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
+
+    if(!p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners ||
+       !(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction & requiredAction))
+    {
+        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        {
+            if((p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnGreen!= e_FM_PCD_DONE) ||
+               (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnYellow!= e_FM_PCD_DONE) ||
+               (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnRed!= e_FM_PCD_DONE))
+            {
+                PlcrHwUnlock(p_FmPcdPlcr, intFlags);
+                PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                RETURN_ERROR (MAJOR, E_OK, ("In this case the next engine can be e_FM_PCD_DONE"));
+            }
+
+            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnGreen.action == e_FM_PCD_ENQ_FRAME)
+            {
+                tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia);
+                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                {
+                    PlcrHwUnlock(p_FmPcdPlcr, intFlags);
+                    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+                }
+                tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+                WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia, tmpReg32);
+                tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+                tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEGNIA;
+                WritePar(p_FmPcd, tmpReg32);
+            }
+
+            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnYellow.action == e_FM_PCD_ENQ_FRAME)
+            {
+                tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia);
+                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                {
+                    PlcrHwUnlock(p_FmPcdPlcr, intFlags);
+                    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+                }
+                tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+                WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia, tmpReg32);
+                tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+                tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEYNIA;
+                WritePar(p_FmPcd, tmpReg32);
+                PlcrHwUnlock(p_FmPcdPlcr, intFlags);
+            }
+
+            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnRed.action == e_FM_PCD_ENQ_FRAME)
+            {
+                tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia);
+                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                {
+                    PlcrHwUnlock(p_FmPcdPlcr, intFlags);
+                    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+                }
+                tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+                WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia, tmpReg32);
+                tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
+                tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PERNIA;
+                WritePar(p_FmPcd, tmpReg32);
+
+            }
+        }
+    }
+    PlcrHwUnlock(p_FmPcdPlcr, intFlags);
+
+    FmPcdPlcrUpatePointedOwner(p_FmPcd, profileIndx, TRUE);
+    FmPcdPlcrUpdateRequiredAction(p_FmPcd, profileIndx, requiredAction);
+
+    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);
+
+    return E_OK;
+}
+
+void FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bool add)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    /* this routine is protected by calling routine */
+
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+
+    if(add)
+        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners++;
+    else
+        p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners--;
+}
+
+uint32_t FmPcdPlcrGetPointedOwners(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+
+    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners;
+}
+
+uint32_t FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+
+    return p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction;
+}
+
+t_Error  FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
+    t_Error                     err = E_OK;
+    uint16_t                    base;
+    uint16_t                    swPortIndex = 0;
+    t_FmPcdIpcMsg               msg;
+    uint32_t                    replyLength;
+    t_FmPcdIpcReply             reply;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    if(!numOfProfiles)
+        return E_OK;
+
+    memset(&ipcPlcrParams, 0, sizeof(ipcPlcrParams));
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        /* Alloc resources using IPC messaging */
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        ipcPlcrParams.num = numOfProfiles;
+        ipcPlcrParams.hardwarePortId = hardwarePortId;
+        msg.msgId = FM_PCD_ALLOC_PROFILES;
+        memcpy(msg.msgBody, &ipcPlcrParams, sizeof(ipcPlcrParams));
+        replyLength = sizeof(uint32_t) + sizeof(uint16_t);
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) +sizeof(ipcPlcrParams),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+        if (replyLength != sizeof(uint32_t) + sizeof(uint16_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        if((t_Error)reply.error != E_OK)
+            RETURN_ERROR(MAJOR, (t_Error)reply.error, ("PLCR profiles allocation failed"));
+
+        memcpy((uint8_t*)&base, reply.replyBody, sizeof(uint16_t));
+    }
+    else /* master */
+    {
+        err = PlcrAllocProfiles(p_FmPcd, hardwarePortId, numOfProfiles, &base);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = numOfProfiles;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = base;
+
+    return E_OK;
+}
+
+t_Error  FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdIpcPlcrAllocParams   ipcPlcrParams;
+    t_Error                     err = E_OK;
+    uint16_t                    swPortIndex = 0;
+    t_FmPcdIpcMsg               msg;
+    uint32_t                    replyLength;
+    t_FmPcdIpcReply             reply;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        /* Alloc resources using IPC messaging */
+        memset(&reply, 0, sizeof(reply));
+        memset(&msg, 0, sizeof(msg));
+        ipcPlcrParams.num = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles;
+        ipcPlcrParams.hardwarePortId = hardwarePortId;
+        ipcPlcrParams.plcrProfilesBase = p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase;
+        msg.msgId = FM_PCD_FREE_PROFILES;
+        memcpy(msg.msgBody, &ipcPlcrParams, sizeof(ipcPlcrParams));
+        replyLength = sizeof(uint32_t);
+        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                     (uint8_t*)&msg,
+                                     sizeof(msg.msgId) +sizeof(ipcPlcrParams),
+                                     (uint8_t*)&reply,
+                                     &replyLength,
+                                     NULL,
+                                     NULL)) != E_OK)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+        if (replyLength != sizeof(uint32_t))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+        if ((t_Error)reply.error != E_OK)
+            RETURN_ERROR(MINOR, (t_Error)reply.error, ("PLCR Free Profiles failed"));
+    }
+    else /* master */
+    {
+        err = PlcrFreeProfiles(p_FmPcd, hardwarePortId, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles, p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase);
+        if(err)
+            RETURN_ERROR(MAJOR, err,NO_MSG);
+    }
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles = 0;
+    p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase = 0;
+
+    return E_OK;
+}
+
+bool    FmPcdPlcrIsProfileValid(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
+
+    return p_FmPcdPlcr->profiles[absoluteProfileId].valid;
+}
+
+t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t numOfProfiles, uint16_t *p_Base)
+{
+    t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    uint32_t        profilesFound, log2Num, tmpReg32;
+    uint32_t        intFlags;
+    uint16_t        first, i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+    if(!numOfProfiles)
+        return E_OK;
+
+    ASSERT_COND(hardwarePortId);
+
+    if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
 
     if (!POWER_OF_2(numOfProfiles))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
 
-    intFlags = FmPcdLock(p_FmPcd);
 
     if(GET_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1]) & FM_PCD_PLCR_PMR_V)
-    {
-        FmPcdUnlock(p_FmPcd, intFlags);
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The requesting port has already an allocated profiles window."));
-    }
 
     first = 0;
     profilesFound = 0;
+    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
+
     for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES;)
     {
         if(!p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated)
@@ -516,9 +888,10 @@ t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t nu
     }
     else
     {
-        FmPcdUnlock(p_FmPcd, intFlags);
+        PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
         RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
     }
+    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
     /**********************FMPL_PMRx******************/
     LOG2((uint64_t)numOfProfiles, log2Num);
@@ -529,14 +902,12 @@ t_Error  PlcrAllocProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t nu
 
     *p_Base = first;
 
-    FmPcdUnlock(p_FmPcd, intFlags);
-
     return E_OK;
 }
 
 t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
 {
-    uint32_t        profilesFound;
+    uint32_t        profilesFound, intFlags;
     uint16_t        i, k=0;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
@@ -548,6 +919,10 @@ t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint1
     if (numOfProfiles>FM_PCD_PLCR_NUM_ENTRIES)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
 
+    /* Find numOfProfiles free profiles (may be spread) */
+
+    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
+
     profilesFound = 0;
     for(i=0;i<FM_PCD_PLCR_NUM_ENTRIES; i++)
     {
@@ -561,13 +936,18 @@ t_Error  PlcrAllocSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint1
         }
     }
     if(profilesFound != numOfProfiles)
+    {
+        PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
         RETURN_ERROR(MAJOR, E_INVALID_STATE,NO_MSG);
+    }
     for(i = 0;i<k;i++)
     {
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = TRUE;
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.ownerId = 0;
     }
 
+    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+
     return E_OK;
 }
 
@@ -575,14 +955,18 @@ t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num
 {
     t_FmPcdPlcrRegs *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
     uint16_t        i;
+    uint32_t        intFlags;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+
     WRITE_UINT32(p_Regs->fmpl_pmr[hardwarePortId-1], 0);
 
+    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
     for(i = base; i<base+numOfProfiles;i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId == hardwarePortId);
@@ -591,6 +975,7 @@ t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num
         p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
         p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
     }
+    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
     return E_OK;
 }
@@ -598,93 +983,46 @@ t_Error  PlcrFreeProfiles(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint16_t num
 void  PlcrFreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_t *profilesIds)
 {
     uint16_t        i;
+    uint32_t        intFlags;
 
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
+
+    intFlags = PlcrSwLock(p_FmPcd->p_FmPcdPlcr);
+
     for(i=0;i<numOfProfiles; i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
     }
-}
-
-void PlcrEnable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-
-    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) | FM_PCD_PLCR_GCR_EN);
-}
-
-void PlcrDisable(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdPlcrRegs             *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
-    WRITE_UINT32(p_Regs->fmpl_gcr, GET_UINT32(p_Regs->fmpl_gcr) & ~FM_PCD_PLCR_GCR_EN);
 }
 
-t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
+t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_ProfileParams, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs)
 {
-   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
-   uint32_t tmpReg32;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-
-    if(!FmIsMaster(p_FmPcd->h_Fm))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPlcrStatistics - guest mode!"));
-
-    tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
-    if(enable)
-        tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
-    else
-        tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
-
-    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr, tmpReg32);
-    return E_OK;
-}
-
-t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
-{
-   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-
-    if(!FmIsMaster(p_FmPcd->h_Fm))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPlcrAutoRefreshMode - guest mode!"));
-
-    p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
-
-    return E_OK;
-}
-
 
-t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs)
-{
+    t_FmPcd         		*p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_Error         		err = E_OK;
+    uint32_t        		pemode, gnia, ynia, rnia;
 
-    t_FmPcd         *p_FmPcd            = (t_FmPcd*)h_FmPcd;
-    t_Error         err = E_OK;
-    uint32_t        pemode, gnia, ynia, rnia;
 
 /* Set G, Y, R Nia */
-    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnGreen,  &(p_Profile->paramsOnGreen), &gnia);
+    err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnGreen,  &(p_ProfileParams->paramsOnGreen), &gnia);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
-    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnYellow, &(p_Profile->paramsOnYellow), &ynia);
+    err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnYellow, &(p_ProfileParams->paramsOnYellow), &ynia);
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
-    err = SetProfileNia(p_FmPcd, p_Profile->nextEngineOnRed,    &(p_Profile->paramsOnRed), &rnia);
+    err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnRed,    &(p_ProfileParams->paramsOnRed), &rnia);
    if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-
 /* Mode fmpl_pemode */
     pemode = FM_PCD_PLCR_PEMODE_PI;
 
-    switch (p_Profile->algSelection)
+    switch (p_ProfileParams->algSelection)
     {
         case    e_FM_PCD_PLCR_PASS_THROUGH:
             p_PlcrRegs->fmpl_pecir         = 0;
@@ -695,11 +1033,11 @@ t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Prof
             p_PlcrRegs->fmpl_pects         = 0;
             p_PlcrRegs->fmpl_pepts_ets     = 0;
             pemode &= ~FM_PCD_PLCR_PEMODE_ALG_MASK;
-            switch (p_Profile->colorMode)
+            switch (p_ProfileParams->colorMode)
             {
                 case    e_FM_PCD_PLCR_COLOR_BLIND:
                     pemode |= FM_PCD_PLCR_PEMODE_CBLND;
-                    switch (p_Profile->color.dfltColor)
+                    switch (p_ProfileParams->color.dfltColor)
                     {
                         case e_FM_PCD_PLCR_GREEN:
                             pemode &= ~FM_PCD_PLCR_PEMODE_DEFC_MASK;
@@ -729,7 +1067,7 @@ t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Prof
         case    e_FM_PCD_PLCR_RFC_2698:
             /* Select algorithm MODE[ALG] = "01" */
             pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC2698;
-            if (p_Profile->nonPassthroughAlgParams.comittedInfoRate > p_Profile->nonPassthroughAlgParams.peakOrAccessiveInfoRate)
+            if (p_ProfileParams->nonPassthroughAlgParams.comittedInfoRate > p_ProfileParams->nonPassthroughAlgParams.peakOrAccessiveInfoRate)
                 RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("in RFC2698 Peak rate must be equal or larger than comittedInfoRate."));
             goto cont_rfc;
         case    e_FM_PCD_PLCR_RFC_4115:
@@ -737,7 +1075,7 @@ t_Error FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Prof
             pemode |= FM_PCD_PLCR_PEMODE_ALG_RFC4115;
 cont_rfc:
             /* Select Color-Blind / Color-Aware operation (MODE[CBLND]) */
-            switch (p_Profile->colorMode)
+            switch (p_ProfileParams->colorMode)
             {
                 case    e_FM_PCD_PLCR_COLOR_BLIND:
                     pemode |= FM_PCD_PLCR_PEMODE_CBLND;
@@ -745,7 +1083,7 @@ cont_rfc:
                 case    e_FM_PCD_PLCR_COLOR_AWARE:
                     pemode &= ~FM_PCD_PLCR_PEMODE_CBLND;
                     /*In color aware more select override color interpretation (MODE[OVCLR]) */
-                    switch (p_Profile->color.override)
+                    switch (p_ProfileParams->color.override)
                     {
                         case e_FM_PCD_PLCR_GREEN:
                             pemode &= ~FM_PCD_PLCR_PEMODE_OVCLR_MASK;
@@ -767,11 +1105,11 @@ cont_rfc:
                     RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             }
             /* Select Measurement Unit Mode to BYTE or PACKET (MODE[PKT]) */
-            switch (p_Profile->nonPassthroughAlgParams.rateMode)
+            switch (p_ProfileParams->nonPassthroughAlgParams.rateMode)
             {
                 case e_FM_PCD_PLCR_BYTE_MODE :
                     pemode &= ~FM_PCD_PLCR_PEMODE_PKT;
-                        switch (p_Profile->nonPassthroughAlgParams.byteModeParams.frameLengthSelection)
+                        switch (p_ProfileParams->nonPassthroughAlgParams.byteModeParams.frameLengthSelection)
                         {
                             case e_FM_PCD_PLCR_L2_FRM_LEN:
                                 pemode |= FM_PCD_PLCR_PEMODE_FLS_L2;
@@ -788,7 +1126,7 @@ cont_rfc:
                             default:
                                 RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
                         }
-                        switch (p_Profile->nonPassthroughAlgParams.byteModeParams.rollBackFrameSelection)
+                        switch (p_ProfileParams->nonPassthroughAlgParams.byteModeParams.rollBackFrameSelection)
                         {
                             case e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN:
                                 pemode &= ~FM_PCD_PLCR_PEMODE_RBFLS;
@@ -801,254 +1139,90 @@ cont_rfc:
                         }
                     break;
                 case e_FM_PCD_PLCR_PACKET_MODE :
-                    pemode |= FM_PCD_PLCR_PEMODE_PKT;
-                    break;
-                default:
-                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-            }
-            /* Select timeStamp floating point position (MODE[FPP]) to fit the actual traffic rates. For PACKET
-               mode with low traffic rates move the fixed point to the left to increase fraction accuracy. For BYTE
-               mode with high traffic rates move the fixed point to the right to increase integer accuracy. */
-
-            /* Configure Traffic Parameters*/
-            {
-                uint32_t cir=0, cbs=0, pir_eir=0, pbs_ebs=0, fpp=0;
-
-                calcRates(h_FmPcd, &p_Profile->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
-
-                /*  Set Committed Information Rate (CIR) */
-                p_PlcrRegs->fmpl_pecir = cir;
-                /*  Set Committed Burst Size (CBS). */
-                p_PlcrRegs->fmpl_pecbs =  cbs;
-                /*  Set Peak Information Rate (PIR_EIR used as PIR) */
-                p_PlcrRegs->fmpl_pepepir_eir = pir_eir;
-                /*   Set Peak Burst Size (PBS_EBS used as PBS) */
-                p_PlcrRegs->fmpl_pepbs_ebs = pbs_ebs;
-
-                /* Initialize the Metering Buckets to be full (write them with 0xFFFFFFFF. */
-                /* Peak Rate Token Bucket Size (PTS_ETS used as PTS) */
-                p_PlcrRegs->fmpl_pepts_ets = 0xFFFFFFFF;
-                /* Committed Rate Token Bucket Size (CTS) */
-                p_PlcrRegs->fmpl_pects = 0xFFFFFFFF;
-
-                /* Set the FPP based on calculation */
-                pemode |= (fpp << FM_PCD_PLCR_PEMODE_FPP_SHIFT);
-            }
-            break;  /* FM_PCD_PLCR_PEMODE_ALG_RFC2698 , FM_PCD_PLCR_PEMODE_ALG_RFC4115 */
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
-    }
-
-    p_PlcrRegs->fmpl_pemode = pemode;
-
-    p_PlcrRegs->fmpl_pegnia = gnia;
-    p_PlcrRegs->fmpl_peynia = ynia;
-    p_PlcrRegs->fmpl_pernia = rnia;
-
-    /* Zero Counters */
-    p_PlcrRegs->fmpl_pegpc     = 0;
-    p_PlcrRegs->fmpl_peypc     = 0;
-    p_PlcrRegs->fmpl_perpc     = 0;
-    p_PlcrRegs->fmpl_perypc    = 0;
-    p_PlcrRegs->fmpl_perrpc    = 0;
-
-    return E_OK;
-}
-
-void  FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    ASSERT_COND(!p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
-    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = TRUE;
-}
-
-void  FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
-{
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
-    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = FALSE;
-}
-
-t_Handle PlcrConfig(t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
-{
-    t_FmPcdPlcr *p_FmPcdPlcr;
-    /*uint8_t i=0;*/
-
-    UNUSED(p_FmPcd);
-    UNUSED(p_FmPcdParams);
-
-    p_FmPcdPlcr = (t_FmPcdPlcr *) XX_Malloc(sizeof(t_FmPcdPlcr));
-    if (!p_FmPcdPlcr)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM Policer structure allocation FAILED"));
-        return NULL;
-    }
-    memset(p_FmPcdPlcr, 0, sizeof(t_FmPcdPlcr));
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
-    {
-        p_FmPcdPlcr->p_FmPcdPlcrRegs  = (t_FmPcdPlcrRegs *)UINT_TO_PTR(FmGetPcdPlcrBaseAddr(p_FmPcdParams->h_Fm));
-        p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh    = DEFAULT_plcrAutoRefresh;
-        p_FmPcd->exceptions |= (DEFAULT_fmPcdPlcrExceptions | DEFAULT_fmPcdPlcrErrorExceptions);
-    }
-
-    p_FmPcdPlcr->numOfSharedProfiles = DEFAULT_numOfSharedPlcrProfiles;
-
-    return p_FmPcdPlcr;
-}
-
-t_Error PlcrInit(t_FmPcd *p_FmPcd)
-{
-    t_FmPcdDriverParam              *p_Param = p_FmPcd->p_FmPcdDriverParam;
-    t_FmPcdPlcr                     *p_FmPcdPlcr = p_FmPcd->p_FmPcdPlcr;
-    uint32_t                        tmpReg32 = 0;
-    t_Error                         err = E_OK;
-    t_FmPcdPlcrRegs                 *p_Regs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    t_FmPcdIpcMsg                   msg;
-    uint32_t                        replyLength;
-    t_FmPcdIpcReply                 reply;
-
-    if ((p_FmPcd->guestId != NCSW_MASTER_ID) &&
-        (p_FmPcdPlcr->numOfSharedProfiles))
-    {
-        int         i, j, index = 0;
-        uint32_t    walking1Mask = 0x80000000;
-        uint32_t    sharedProfilesMask[FM_PCD_PLCR_NUM_ENTRIES/32];
-
-        memset(sharedProfilesMask, 0, FM_PCD_PLCR_NUM_ENTRIES/32 * sizeof(uint32_t));
-        memset(&reply, 0, sizeof(reply));
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_ALLOC_SHARED_PROFILES;
-        memcpy(msg.msgBody, (uint8_t *)&p_FmPcdPlcr->numOfSharedProfiles, sizeof(uint16_t));
-        replyLength = sizeof(uint32_t) + sizeof(sharedProfilesMask);
-        if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                     (uint8_t*)&msg,
-                                     sizeof(msg.msgId)+ sizeof(p_FmPcdPlcr->numOfSharedProfiles),
-                                     (uint8_t*)&reply,
-                                     &replyLength,
-                                     NULL,
-                                     NULL)) != E_OK)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
-        if (replyLength != (sizeof(uint32_t) + sizeof(sharedProfilesMask)))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-
-        memcpy(sharedProfilesMask, reply.replyBody, sizeof(sharedProfilesMask));
-        /* translate 8 regs of 32 bits masks into an array of up to 256 indexes. */
-        for(i = 0; i<FM_PCD_PLCR_NUM_ENTRIES/32 ; i++)
-        {
-            if(sharedProfilesMask[i])
-            {
-                for(j = 0 ; j<32 ; j++)
-                {
-                    if(sharedProfilesMask[i] & walking1Mask)
-                        p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[index++] = (uint16_t)(i*32+j);
-                    walking1Mask >>= 1;
-                }
-                walking1Mask = 0x80000000;
+                    pemode |= FM_PCD_PLCR_PEMODE_PKT;
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             }
-        }
-        return (t_Error)reply.error;
-    }
+            /* Select timeStamp floating point position (MODE[FPP]) to fit the actual traffic rates. For PACKET
+               mode with low traffic rates move the fixed point to the left to increase fraction accuracy. For BYTE
+               mode with high traffic rates move the fixed point to the right to increase integer accuracy. */
 
-    if(p_FmPcdPlcr->numOfSharedProfiles)
-    {
-        err = PlcrAllocSharedProfiles(p_FmPcd, p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);
-        if(err)
-            RETURN_ERROR(MAJOR, err,NO_MSG);
-    }
+            /* Configure Traffic Parameters*/
+            {
+                uint32_t cir=0, cbs=0, pir_eir=0, pbs_ebs=0, fpp=0;
 
-    /**********************FMPL_GCR******************/
-    tmpReg32 = 0;
-    tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
-    if(p_Param->plcrAutoRefresh)
-        tmpReg32 |= FM_PCD_PLCR_GCR_DAR;
-    tmpReg32 |= NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME;
+                CalcRates(h_FmPcd, &p_ProfileParams->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
 
-    WRITE_UINT32(p_Regs->fmpl_gcr, tmpReg32);
-    /**********************FMPL_GCR******************/
+                /*  Set Committed Information Rate (CIR) */
+                p_PlcrRegs->fmpl_pecir = cir;
+                /*  Set Committed Burst Size (CBS). */
+                p_PlcrRegs->fmpl_pecbs =  cbs;
+                /*  Set Peak Information Rate (PIR_EIR used as PIR) */
+                p_PlcrRegs->fmpl_pepepir_eir = pir_eir;
+                /*   Set Peak Burst Size (PBS_EBS used as PBS) */
+                p_PlcrRegs->fmpl_pepbs_ebs = pbs_ebs;
 
-    /**********************FMPL_EEVR******************/
-    WRITE_UINT32(p_Regs->fmpl_eevr, (FM_PCD_PLCR_DOUBLE_ECC | FM_PCD_PLCR_INIT_ENTRY_ERROR));
-    /**********************FMPL_EEVR******************/
-    /**********************FMPL_EIER******************/
-    tmpReg32 = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_DOUBLE_ECC)
-    {
-        FmEnableRamsEcc(p_FmPcd->h_Fm);
-        tmpReg32 |= FM_PCD_PLCR_DOUBLE_ECC;
+                /* Initialize the Metering Buckets to be full (write them with 0xFFFFFFFF. */
+                /* Peak Rate Token Bucket Size (PTS_ETS used as PTS) */
+                p_PlcrRegs->fmpl_pepts_ets = 0xFFFFFFFF;
+                /* Committed Rate Token Bucket Size (CTS) */
+                p_PlcrRegs->fmpl_pects = 0xFFFFFFFF;
+
+                /* Set the FPP based on calculation */
+                pemode |= (fpp << FM_PCD_PLCR_PEMODE_FPP_SHIFT);
+            }
+            break;  /* FM_PCD_PLCR_PEMODE_ALG_RFC2698 , FM_PCD_PLCR_PEMODE_ALG_RFC4115 */
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
     }
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_INIT_ENTRY_ERROR)
-        tmpReg32 |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
-    WRITE_UINT32(p_Regs->fmpl_eier, tmpReg32);
-    /**********************FMPL_EIER******************/
 
-    /**********************FMPL_EVR******************/
-    WRITE_UINT32(p_Regs->fmpl_evr, (FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE | FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE));
-    /**********************FMPL_EVR******************/
-    /**********************FMPL_IER******************/
-    tmpReg32 = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_PRAM_SELF_INIT_COMPLETE)
-        tmpReg32 |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PLCR_ATOMIC_ACTION_COMPLETE )
-        tmpReg32 |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
-    WRITE_UINT32(p_Regs->fmpl_ier, tmpReg32);
-    /**********************FMPL_IER******************/
+    p_PlcrRegs->fmpl_pemode = pemode;
 
-    /* register even if no interrupts enabled, to allow future enablement */
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR, PcdPlcrErrorException, p_FmPcd);
-    FmRegisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL, PcdPlcrException, p_FmPcd);
+    p_PlcrRegs->fmpl_pegnia = gnia;
+    p_PlcrRegs->fmpl_peynia = ynia;
+    p_PlcrRegs->fmpl_pernia = rnia;
 
-    /* driver initializes one DFLT profile at the last entry*/
-    /**********************FMPL_DPMR******************/
-    tmpReg32 = 0;
-    WRITE_UINT32(p_Regs->fmpl_dpmr, tmpReg32);
-    p_FmPcd->p_FmPcdPlcr->profiles[0].profilesMng.allocated = TRUE;
+    /* Zero Counters */
+    p_PlcrRegs->fmpl_pegpc     = 0;
+    p_PlcrRegs->fmpl_peypc     = 0;
+    p_PlcrRegs->fmpl_perpc     = 0;
+    p_PlcrRegs->fmpl_perypc    = 0;
+    p_PlcrRegs->fmpl_perrpc    = 0;
 
     return E_OK;
 }
 
-t_Error PlcrFree(t_FmPcd *p_FmPcd)
+void  FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
 {
-    t_Error                             err;
-    t_FmPcdIpcSharedPlcrAllocParams     ipcSharedPlcrParams;
-    t_FmPcdIpcMsg                       msg;
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    intFlags;
 
-    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_ERR);
-    FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PLCR, 0, e_FM_INTR_TYPE_NORMAL);
+    ASSERT_COND(!p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
 
-    if(p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles)
-    {
-        if(p_FmPcd->guestId != NCSW_MASTER_ID)
-        {
-            int i;
-            memset(ipcSharedPlcrParams.sharedProfilesMask, 0, sizeof(ipcSharedPlcrParams.sharedProfilesMask));
-            /* Free resources using IPC messaging */
-            ipcSharedPlcrParams.num = p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;
+    intFlags = PlcrProfileLock(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId]);
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = TRUE;
+    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId], intFlags);
+}
 
-            /* translate the allocated profile id's to a 32bit * 8regs mask */
-            for(i = 0;i<p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles;i++)
-                ipcSharedPlcrParams.sharedProfilesMask[p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i]/32] |= (0x80000000 >> (p_FmPcd->p_FmPcdPlcr->sharedProfilesIds[i] % 32));
+void  FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId)
+{
+    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    uint32_t    intFlags;
 
-            memset(&msg, 0, sizeof(msg));
-            msg.msgId = FM_PCD_FREE_SHARED_PROFILES;
-            memcpy(msg.msgBody, &ipcSharedPlcrParams, sizeof(ipcSharedPlcrParams));
-            if ((err = XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                         (uint8_t*)&msg,
-                                         sizeof(msg.msgId)+sizeof(ipcSharedPlcrParams),
-                                         NULL,
-                                         NULL,
-                                         NULL,
-                                         NULL)) != E_OK)
-                RETURN_ERROR(MAJOR, err,NO_MSG);
-        }
-       /* else
-            PlcrFreeSharedProfiles(p_FmPcd, p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles, p_FmPcd->p_FmPcdPlcr->sharedProfilesIds);*/
-    }
-    return E_OK;
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+
+    intFlags = PlcrProfileLock(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId]);
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid = FALSE;
+    PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId], intFlags);
+}
+
+uint16_t     FmPcdPlcrProfileGetAbsoluteId(t_Handle h_Profile)
+{
+	    return ((t_FmPcdPlcrProfile*)h_Profile)->absoluteProfileId;
 }
 
-t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle                      h_FmPcd,
+t_Error     FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle                      h_FmPcd,
                                           e_FmPcdProfileTypeSelection   profileType,
                                           t_Handle                      h_FmPort,
                                           uint16_t                      relativeProfile,
@@ -1174,127 +1348,262 @@ void FmPcdPlcrUpdateRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId,
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-   ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+    /* this routine is protected by calling routine */
+
+    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
+
+    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction |= requiredAction;
+}
+
+/*t_Error FmPcdPlcrProfileTryLock(t_Handle h_FmPcdPlcr, uint16_t profileId, bool intr)
+{
+    t_FmPcdPlcr         *p_FmPcdPlcr = (t_FmPcdPlcr *)h_FmPcdPlcr;
+    bool            ans;
+
+    if (intr)
+        ans = TRY_LOCK(p_FmPcdPlcr->h_SwSpinlock, &p_FmPcdPlcr->profiles[profileId].lock);
+    else
+        ans = TRY_LOCK(p_FmPcdPlcr->h_SwSpinlock, &p_FmPcdPlcr->profiles[profileId].lock);
+    if (ans)
+        return E_OK;
+    return ERROR_CODE(E_BUSY);
+}
+
+void FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcdPlcr, uint16_t profileId)
+{
+    RELEASE_LOCK(((t_FmPcdPlcr*)h_FmPcdPlcr)->profiles[profileId].lock);
+}
+*/
+
+/**************************************************/
+/*............Policer API.........................*/
+/**************************************************/
+
+t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPlcrAutoRefreshMode - guest mode!"));
+
+    p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
+
+    return E_OK;
+}
+
+t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles)
+{
+   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles = numOfSharedPlcrProfiles;
+
+    return E_OK;
+}
+
+t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
+{
+   t_FmPcd  *p_FmPcd = (t_FmPcd*)h_FmPcd;
+   uint32_t tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+
+    if(!FmIsMaster(p_FmPcd->h_Fm))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPlcrStatistics - guest mode!"));
+
+    tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
+    if(enable)
+        tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
+    else
+        tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
 
-    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].requiredAction = requiredAction;
+    WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr, tmpReg32);
+    return E_OK;
 }
 
-t_Error FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId, bool intr)
-{
-    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    bool            ans;
-    if (intr)
-        ans = TRY_LOCK(NULL, &p_FmPcd->p_FmPcdPlcr->profiles[profileId].lock);
-    else
-        ans = TRY_LOCK(p_FmPcd->h_Spinlock, &p_FmPcd->p_FmPcdPlcr->profiles[profileId].lock);
-    if (ans)
+/* ... */
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
+{
+    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    int                 i = 0;
+    t_FmPcdIpcMsg       msg;
+
+    DECLARE_DUMP;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    {
+        memset(&msg, 0, sizeof(msg));
+        msg.msgId = FM_PCD_PLCR_DUMP_REGS;
+        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
+                                 (uint8_t*)&msg,
+                                 sizeof(msg.msgId),
+                                 NULL,
+                                 NULL,
+                                 NULL,
+                                 NULL);
+    }
+    else
+    {
+        DUMP_SUBTITLE(("\n"));
+        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
+
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
+
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
+        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
+
+
+        DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
+        DUMP_SUBSTRUCT_ARRAY(i, 63)
+        {
+            DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
+        }
+
         return E_OK;
-    return ERROR_CODE(E_BUSY);
-}
-
-void FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId)
-{
-    RELEASE_LOCK(((t_FmPcd*)h_FmPcd)->p_FmPcdPlcr->profiles[profileId].lock);
+    }
 }
+#endif /* (defined(DEBUG_ERRORS) && ... */
 
-/**************************************************/
-/*............Policer API.........................*/
-/**************************************************/
-
-t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
-                               t_FmPcdPlcrProfileParams *p_Profile)
+t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
+                               t_FmPcdPlcrProfileParams *p_ProfileParams)
 {
-    t_FmPcd                             *p_FmPcd            = (t_FmPcd*)h_FmPcd;
+    t_FmPcd                             *p_FmPcd;
     t_FmPcdPlcrRegs                     *p_FmPcdPlcrRegs;
     t_FmPcdPlcrInterModuleProfileRegs   plcrProfileReg;
     uint32_t                            intFlags;
     uint16_t                            absoluteProfileId;
     t_Error                             err = E_OK;
     uint32_t                            tmpReg32;
+    t_FmPcdPlcrProfile				    *p_Profile;
 
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
 
-    if (p_FmPcd->h_Hc)
-        return FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, p_Profile);
+    /*
+        err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
+        if (err)
+            return NULL;
+    */
 
-    p_FmPcdPlcrRegs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE, NULL);
 
-    if (p_Profile->modify)
+    if(p_ProfileParams->modify)
     {
-        absoluteProfileId = (uint16_t)(PTR_TO_UINT(p_Profile->id.h_Profile)-1);
+	p_Profile = (t_FmPcdPlcrProfile *)p_ProfileParams->id.h_Profile;
+	p_FmPcd = p_Profile->h_FmPcd;
+	absoluteProfileId = p_Profile->absoluteProfileId;
         if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
         {
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
             return NULL;
         }
-        if (FmPcdPlcrProfileTryLock(p_FmPcd, absoluteProfileId, FALSE))
-            return NULL;
+
+        SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
+
     }
     else
     {
-        intFlags = FmPcdLock(p_FmPcd);
-        err = FmPcdPlcrGetAbsoluteProfileId(h_FmPcd,
-                                            p_Profile->id.newParams.profileType,
-                                            p_Profile->id.newParams.h_FmPort,
-                                            p_Profile->id.newParams.relativeProfileId,
-                                            &absoluteProfileId);
-        if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
-        {
-            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
-            return NULL;
-        }
-        if(err)
-        {
-            FmPcdUnlock(p_FmPcd, intFlags);
-            REPORT_ERROR(MAJOR, err, NO_MSG);
-            return NULL;
-        }
-        err = FmPcdPlcrProfileTryLock(p_FmPcd, absoluteProfileId, TRUE);
-        FmPcdUnlock(p_FmPcd, intFlags);
-        if (err)
-            return NULL;
+	p_FmPcd = (t_FmPcd*)h_FmPcd;
+
+        SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE, NULL);
+
+
+        /* SMP: needs to be protected only if another core now changes the windows */
+        err = FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd,
+                                             p_ProfileParams->id.newParams.profileType,
+                                             p_ProfileParams->id.newParams.h_FmPort,
+                                             p_ProfileParams->id.newParams.relativeProfileId,
+                                             &absoluteProfileId);
+
+         if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
+         {
+             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
+             return NULL;
+         }
+
+         if(FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
+         {
+             REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer Profile is already used"));
+             return NULL;
+         }
+
+         /* initialize profile struct */
+         p_Profile = &p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId];
+         p_Profile->h_FmPcd = p_FmPcd;
+         p_Profile->absoluteProfileId = absoluteProfileId;
     }
 
-    /* if no override, check first that this profile is unused */
-    if(!p_Profile->modify)
+    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
+
+    p_Profile->nextEngineOnGreen = p_ProfileParams->nextEngineOnGreen;
+    memcpy(&p_Profile->paramsOnGreen, &(p_ProfileParams->paramsOnGreen), sizeof(u_FmPcdPlcrNextEngineParams));
+
+    p_Profile->nextEngineOnYellow = p_ProfileParams->nextEngineOnYellow;
+    memcpy(&p_Profile->paramsOnYellow, &(p_ProfileParams->paramsOnYellow), sizeof(u_FmPcdPlcrNextEngineParams));
+
+    p_Profile->nextEngineOnRed = p_ProfileParams->nextEngineOnRed;
+    memcpy(&p_Profile->paramsOnRed, &(p_ProfileParams->paramsOnRed), sizeof(u_FmPcdPlcrNextEngineParams));
+
+    p_Profile->h_Spinlock = XX_InitSpinlock();
+    if (!p_Profile->h_Spinlock)
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PLCR Profile spinlock"));
+
+    if (p_FmPcd->h_Hc)
     {
-        /* read specified profile into profile registers */
-        tmpReg32 = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
-        intFlags = FmPcdLock(p_FmPcd);
-        WritePar(p_FmPcd, tmpReg32);
-        tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode);
-        FmPcdUnlock(p_FmPcd, intFlags);
-        if (tmpReg32 & FM_PCD_PLCR_PEMODE_PI)
-        {
-            RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
-            REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Policer Profile is already used"));
-            return NULL;
-        }
+         err = FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, (t_Handle)p_Profile, p_ProfileParams);
+         if(err)
+         {
+             if (p_Profile->h_Spinlock)
+                 XX_FreeSpinlock(p_Profile->h_Spinlock);
+             return NULL;
+         }
+         if (!p_ProfileParams->modify)
+             FmPcdPlcrValidateProfileSw(p_FmPcd,absoluteProfileId);
+         return (t_Handle)p_Profile;
     }
 
+    p_FmPcdPlcrRegs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
+    SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE, NULL);
+
     memset(&plcrProfileReg, 0, sizeof(t_FmPcdPlcrInterModuleProfileRegs));
 
-    err =  FmPcdPlcrBuildProfile(h_FmPcd, p_Profile, &plcrProfileReg);
+    /* build the policer profile registers */
+    err =  FmPcdPlcrBuildProfile(h_FmPcd, p_ProfileParams, &plcrProfileReg);
     if(err)
     {
-        RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+        if (p_Profile->h_Spinlock)
+            XX_FreeSpinlock(p_Profile->h_Spinlock);
         REPORT_ERROR(MAJOR, err, NO_MSG);
         return NULL;
     }
 
-    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].nextEngineOnGreen = p_Profile->nextEngineOnGreen;
-    memcpy(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].paramsOnGreen, &(p_Profile->paramsOnGreen), sizeof(u_FmPcdPlcrNextEngineParams));
-
-    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].nextEngineOnYellow = p_Profile->nextEngineOnYellow;
-    memcpy(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].paramsOnYellow, &(p_Profile->paramsOnYellow), sizeof(u_FmPcdPlcrNextEngineParams));
-
-    p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].nextEngineOnRed = p_Profile->nextEngineOnRed;
-    memcpy(&p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].paramsOnRed, &(p_Profile->paramsOnRed), sizeof(u_FmPcdPlcrNextEngineParams));
-
-    intFlags = FmPcdLock(p_FmPcd);
+    intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
     WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode , plcrProfileReg.fmpl_pemode);
     WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia , plcrProfileReg.fmpl_pegnia);
     WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia , plcrProfileReg.fmpl_peynia);
@@ -1315,55 +1624,78 @@ t_Handle FM_PCD_PlcrSetProfile(t_Handle     h_FmPcd,
     tmpReg32 = FmPcdPlcrBuildWritePlcrActionRegs(absoluteProfileId);
     WritePar(p_FmPcd, tmpReg32);
 
-    FmPcdUnlock(p_FmPcd, intFlags);
+    PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
-    if (!p_Profile->modify)
+    if (!p_ProfileParams->modify)
         FmPcdPlcrValidateProfileSw(p_FmPcd,absoluteProfileId);
 
-    RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);
+    /*RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].lock);*/
 
-    return UINT_TO_PTR((uint64_t)absoluteProfileId+1);
+    return (t_Handle)p_Profile;
 }
 
-t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile)
+t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile)
 {
-    t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint16_t        profileIndx = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
-    uint32_t        tmpReg32, intFlags;
-
+	t_FmPcdPlcrProfile	*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd         	*p_FmPcd;
+    uint16_t        	profileIndx;
+    uint32_t        	tmpReg32, intFlags;
+    t_Error             err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
+    p_FmPcd = p_Profile->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((profileIndx < FM_PCD_PLCR_NUM_ENTRIES), E_INVALID_SELECTION);
+
+    profileIndx = p_Profile->absoluteProfileId;
+
+    /*
+         err = FmPcdKgSchemeTryLock(p_FmPcd, p_Scheme);
+         if (err)
+             return NULL;
+     */
 
     if (p_FmPcd->h_Hc)
-        return FmHcPcdPlcrDeleteProfile(p_FmPcd->h_Hc, h_Profile);
+    {
+        err = FmHcPcdPlcrDeleteProfile(p_FmPcd->h_Hc, h_Profile);
+        /* FmPcdKgReleaseSchemeLock(h_Scheme); */
+        FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
+        if (p_Profile->h_Spinlock)
+            XX_FreeSpinlock(p_Profile->h_Spinlock);
 
-    FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
+        return err;
+    }
 
-    intFlags = FmPcdLock(p_FmPcd);
+    intFlags = PlcrHwLock(p_FmPcd->p_FmPcdPlcr);
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->profileRegs.fmpl_pemode, ~FM_PCD_PLCR_PEMODE_PI);
 
     tmpReg32 = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
     WritePar(p_FmPcd, tmpReg32);
-    FmPcdUnlock(p_FmPcd, intFlags);
+    PlcrHwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
+
+    FmPcdPlcrInvalidateProfileSw(p_FmPcd,profileIndx);
+
+    /* FmPcdKgReleaseSchemeLock(h_Scheme); */
+
+    if (p_Profile->h_Spinlock)
+        XX_FreeSpinlock(p_Profile->h_Spinlock);
 
     return E_OK;
 }
 
-/* ......... */
 /***************************************************/
 /*............Policer Profile Counter..............*/
 /***************************************************/
-uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
+uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter)
 {
-    t_FmPcd         *p_FmPcd    = (t_FmPcd*)h_FmPcd;
-    uint16_t        profileIndx = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
-    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs;
-    uint32_t        intFlags, counterVal = 0;
-
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
-    SANITY_CHECK_RETURN_VALUE(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE, 0);
+	t_FmPcdPlcrProfile	*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd         	*p_FmPcd;
+    uint16_t        	profileIndx;
+    uint32_t        	intFlags, counterVal = 0;
+    t_FmPcdPlcrRegs		*p_FmPcdPlcrRegs;
+
+    SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
+    p_FmPcd = p_Profile->h_FmPcd;
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdPlcrGetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter);
@@ -1371,21 +1703,16 @@ uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_Fm
     p_FmPcdPlcrRegs = p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs;
     SANITY_CHECK_RETURN_VALUE(p_FmPcdPlcrRegs, E_INVALID_HANDLE, 0);
 
+    profileIndx = p_Profile->absoluteProfileId;
+
     if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
     {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("profileId too Big "));
         return 0;
     }
-    intFlags = FmPcdLock(p_FmPcd);
+    intFlags = PlcrHwLock(p_FmPcd);
     WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
 
-    if(!FmPcdPlcrHwProfileIsValid(GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode)))
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized profile"));
-        FmPcdUnlock(p_FmPcd, intFlags);
-        return 0;
-    }
-
     switch (counter)
     {
         case e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER:
@@ -1407,119 +1734,23 @@ uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_Fm
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             break;
     }
-    FmPcdUnlock(p_FmPcd, intFlags);
+    PlcrHwUnlock(p_FmPcd, intFlags);
 
     return counterVal;
 }
 
-
-t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t requiredAction)
+t_Error FM_PCD_PlcrProfileSetCounter(t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
 {
-    t_FmPcd         *p_FmPcd           = (t_FmPcd *)h_FmPcd;
-    t_FmPcdPlcr     *p_FmPcdPlcr        = p_FmPcd->p_FmPcdPlcr;
-    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs    = p_FmPcdPlcr->p_FmPcdPlcrRegs;
-    uint32_t        tmpReg32, intFlags;
-
-    if (p_FmPcd->h_Hc)
-        return FmHcPcdPlcrCcGetSetParams(p_FmPcd->h_Hc, profileIndx, requiredAction);
-
-    if (profileIndx >= FM_PCD_PLCR_NUM_ENTRIES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile out of range"));
-
-    if (FmPcdPlcrProfileTryLock(p_FmPcd, profileIndx, FALSE))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE,("Lock on PP FAILED"));
-
-    intFlags = FmPcdLock(p_FmPcd);
-    WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
-
-    if(!FmPcdPlcrHwProfileIsValid(GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pemode)))
-    {
-        FmPcdUnlock(p_FmPcd, intFlags);
-        RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].lock);
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("Policer profile is not valid"));
-    }
-
-    ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].valid);
-
-    if(!p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners ||
-       !(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction & requiredAction))
-    {
-        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
-        {
-            if((p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnGreen!= e_FM_PCD_DONE) ||
-               (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnYellow!= e_FM_PCD_DONE) ||
-               (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnRed!= e_FM_PCD_DONE))
-            {
-                FmPcdUnlock(p_FmPcd, intFlags);
-                RETURN_ERROR (MAJOR, E_OK, ("In this case the next engine can be e_FM_PCD_DONE"));
-            }
-
-            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnGreen.action == e_FM_PCD_ENQ_FRAME)
-            {
-                tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia);
-                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
-                {
-                    FmPcdUnlock(p_FmPcd, intFlags);
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
-                }
-                tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
-                WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia, tmpReg32);
-                tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
-                tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEGNIA;
-                WritePar(p_FmPcd, tmpReg32);
-            }
-
-            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnYellow.action == e_FM_PCD_ENQ_FRAME)
-            {
-                tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia);
-                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
-                {
-                    FmPcdUnlock(p_FmPcd, intFlags);
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
-                }
-                tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
-                WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia, tmpReg32);
-                tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
-                tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEYNIA;
-                WritePar(p_FmPcd, tmpReg32);
-            }
-
-            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnRed.action == e_FM_PCD_ENQ_FRAME)
-            {
-                tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia);
-                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
-                {
-                    FmPcdUnlock(p_FmPcd, intFlags);
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
-                }
-                tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
-                WRITE_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia, tmpReg32);
-                tmpReg32 = FmPcdPlcrBuildWritePlcrActionReg(profileIndx);
-                tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PERNIA;
-                WritePar(p_FmPcd, tmpReg32);
-            }
-        }
-    }
-    FmPcdUnlock(p_FmPcd, intFlags);
-
-    p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners += 1;
-    p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction |= requiredAction;
-
-    RELEASE_LOCK(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].lock);
-
-    return E_OK;
-}
+	t_FmPcdPlcrProfile	*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd         	*p_FmPcd;
+    uint16_t        	profileIndx;
+    uint32_t        	tmpReg32, intFlags;
+    t_FmPcdPlcrRegs		*p_FmPcdPlcrRegs;
 
-t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value)
-{
-    t_FmPcd         *p_FmPcd    = (t_FmPcd*)h_FmPcd;
-    uint16_t        profileIndx = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
-    t_FmPcdPlcrRegs *p_FmPcdPlcrRegs;
-    uint32_t        tmpReg32, intFlags;
+    SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
 
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
+    p_FmPcd = p_Profile->h_FmPcd;
+    profileIndx = p_Profile->absoluteProfileId;
 
     if (p_FmPcd->h_Hc)
         return FmHcPcdPlcrSetProfileCounter(p_FmPcd->h_Hc, h_Profile, counter, value);
@@ -1560,95 +1791,24 @@ t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmP
     return E_OK;
 }
 
-t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles)
-{
-   t_FmPcd *p_FmPcd = (t_FmPcd*)h_FmPcd;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-
-    p_FmPcd->p_FmPcdPlcr->numOfSharedProfiles = numOfSharedPlcrProfiles;
-
-    return E_OK;
-}
-
-
-/* ... */
-
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
-t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
-{
-    t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    int                 i = 0;
-    t_FmPcdIpcMsg       msg;
-
-    DECLARE_DUMP;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
-    {
-        memset(&msg, 0, sizeof(msg));
-        msg.msgId = FM_PCD_PLCR_DUMP_REGS;
-        return XX_IpcSendMessage(p_FmPcd->h_IpcSession,
-                                 (uint8_t*)&msg,
-                                 sizeof(msg.msgId),
-                                 NULL,
-                                 NULL,
-                                 NULL,
-                                 NULL);
-    }
-    else
-    {
-        DUMP_SUBTITLE(("\n"));
-        DUMP_TITLE(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs, ("FmPcdPlcrRegs Regs"));
-
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gcr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_gsr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_evr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ier);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ifr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eevr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eier);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_eifr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rpcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_ypcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rrpcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
-
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
-        DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
-
-
-        DUMP_TITLE(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr, ("fmpl_pmr"));
-        DUMP_SUBSTRUCT_ARRAY(i, 63)
-        {
-            DUMP_MEMORY(&p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i], sizeof(uint32_t));
-        }
-
-        return E_OK;
-    }
-}
-
-t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_FmPcd, t_Handle h_Profile)
+t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile)
 {
-    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+	t_FmPcdPlcrProfile					*p_Profile = (t_FmPcdPlcrProfile*)h_Profile;
+    t_FmPcd         					*p_FmPcd;
     t_FmPcdPlcrInterModuleProfileRegs   *p_ProfilesRegs;
+    uint16_t        					profileIndx;
     uint32_t                            tmpReg, intFlags;
-    uint16_t                            profileIndx = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
     t_FmPcdIpcMsg                       msg;
 
     DECLARE_DUMP;
 
+    SANITY_CHECK_RETURN_ERROR(p_Profile, E_INVALID_HANDLE);
+    p_FmPcd = p_Profile->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
+
+    profileIndx = p_Profile->absoluteProfileId;
 
     if(p_FmPcd->guestId != NCSW_MASTER_ID)
     {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index a4b8bcc..ff110d7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -151,34 +151,16 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
 {
     t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
-    uint32_t            tmpReg;
+    uint32_t            tmpReg, i, j;
+    uint32_t            *p_SwPrsCode = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode,
+                                                            FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
+    uint8_t             swPrsPatch[] = SW_PRS_IP_FRAG_PATCH;
 
     if(p_FmPcd->guestId != NCSW_MASTER_ID)
         return E_OK;
 
     ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
 
-#ifdef FM_PRS_MEM_ERRATA_FMAN_SW003
-    {
-        uint32_t            i;
-        uint32_t            regsToGlobalOffset = 0x840;
-        uint32_t            firstPortToGlobalOffset = 0x45800;
-        uint64_t            globalAddr = PTR_TO_UINT(p_Regs) - regsToGlobalOffset;
-        uint32_t            firstPortAddr = (uint32_t)(globalAddr - (uint64_t)firstPortToGlobalOffset);
-        uint32_t            portSize = 0x1000;
-        t_FmRevisionInfo    revInfo;
-
-        FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-        {
-            /* clear all parser memory */
-            IOMemSet32(UINT_TO_PTR(globalAddr), 0x00000000, 0x800);
-            for(i = 0;i<16;i++)
-                IOMemSet32(UINT_TO_PTR(firstPortAddr+i*portSize), (uint8_t)0x00000000, (uint32_t)0x80);
-        }
-    }
-#endif /* FM_PRS_MEM_ERRATA_FMAN_SW003 */
-
     /**********************RPCLIM******************/
     WRITE_UINT32(p_Regs->rpclim, (uint32_t)p_Param->prsMaxParseCycleLimit);
     /**********************FMPL_RPCLIM******************/
@@ -222,34 +204,21 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
     /**********************PPCS******************/
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    ASSERT_COND(sizeof(swPrsPatch)<= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
+    /* load sw parser Ip-Frag patch */
+    if (p_FmPcd->fmRevInfo.majorRev >= 2)
     {
-        uint32_t            i, j;
-        t_FmRevisionInfo    revInfo;
-        uint32_t            *p_SwPrsCode;
-        uint8_t             swPrsPatch[] = SW_PRS_IP_FRAG_PATCH;
-
-        /* To keep the compiler happy, we're initializing this here rather than at declaration! */
-        p_SwPrsCode = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode, FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
-
-        ASSERT_COND(sizeof(swPrsPatch)<= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
-        /* load sw parser Ip-Frag patch */
-        FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 2) || (revInfo.majorRev == 3))
+        for(i=0; i < (sizeof(swPrsPatch) / 4);i++)
         {
-            for(i=0;i<sizeof(swPrsPatch)/4;i++)
-            {
-               tmpReg = 0;
-               for(j =0;j<4;j++)
-               {
-                  tmpReg <<= 8;
-                  tmpReg |= swPrsPatch[i*4+j];
-               }
-               WRITE_UINT32(*(p_SwPrsCode + i), tmpReg);
-            }
+           tmpReg = 0;
+           for (j=0; j < 4; j++)
+           {
+              tmpReg <<= 8;
+              tmpReg |= swPrsPatch[i*4+j];
+           }
+           WRITE_UINT32(*(p_SwPrsCode + i), tmpReg);
         }
     }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     return E_OK;
 }
@@ -391,6 +360,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                *p_LoadTarget, tmpReg;
+    uint8_t                 *p_TmpCode;
     int                     i, j;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
@@ -410,6 +380,16 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     if(p_SwPrs->size > FM_PCD_SW_PRS_SIZE - FM_PCD_PRS_SW_TAIL_SIZE - p_SwPrs->base*2)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size may not be larger than MAX_SW_PRS_CODE_SIZE"));
 
+    p_TmpCode = p_SwPrs->p_Code;
+    if(p_SwPrs->size % 4)
+    {
+        p_TmpCode = (uint8_t *)XX_Malloc(p_SwPrs->size + 2);
+        if (!p_TmpCode)
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Tmp Sw-Parser code allocation FAILED"));
+        memset(p_TmpCode, 0, p_SwPrs->size + 2);
+        memcpy(p_TmpCode, p_SwPrs->p_Code, p_SwPrs->size);
+    }
+
     /* save sw parser labels */
     if(p_SwPrs->override)
         p_FmPcd->p_FmPcdPrs->currLabel = 0;
@@ -419,17 +399,17 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     p_FmPcd->p_FmPcdPrs->currLabel += p_SwPrs->numOfLabels;
     /* load sw parser code */
     p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;
-    for(i=0;i<p_SwPrs->size/4;i++)
+    for(i=0;i<DIV_CEIL(p_SwPrs->size,4);i++)
     {
         tmpReg = 0;
         for(j =0;j<4;j++)
         {
             tmpReg <<= 8;
-            tmpReg |= *(p_SwPrs->p_Code+i*4+j);
+            tmpReg |= *(p_TmpCode+i*4+j);
         }
         WRITE_UINT32(*(p_LoadTarget + i), tmpReg);
     }
-    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + p_SwPrs->size/4;
+    p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + DIV_CEIL(p_SwPrs->size,4);
 
     /* copy data parameters */
     for(i=0;i<FM_PCD_PRS_NUM_OF_HDRS;i++)
@@ -439,6 +419,9 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     /* Clear last 4 bytes */
     WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+(PRS_SW_DATA-FM_PCD_PRS_SW_TAIL_SIZE)/4), 0);
 
+    if(p_SwPrs->size % 4)
+        XX_Free(p_TmpCode);
+
     return E_OK;
 }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index d05b79a..ffd597d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -40,7 +40,6 @@
 #include "string_ext.h"
 #include "sprint_ext.h"
 #include "debug_ext.h"
-#include "fm_pcd_ext.h"
 
 #include "fm_port.h"
 
@@ -54,12 +53,13 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     t_FmPortDriverParam *p_Params = p_FmPort->p_FmPortDriverParam;
     t_Error             ans = E_OK;
     uint32_t            unusedMask;
-    uint8_t             i;
-    uint8_t             j;
-    bool                found;
 
     if (p_FmPort->imEn)
     {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            if(p_FmPort->fifoDeqPipelineDepth > 2)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for IM 10G can't be larger than 2"));
+
         if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
             return ERROR_CODE(ans);
     }
@@ -74,61 +74,21 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
             if(!p_Params->extBufPools.numOfPoolsUsed)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
 
-            if(p_Params->extBufPools.numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", FM_PORT_MAX_NUM_OF_EXT_POOLS));
-
-            for(i=0;i<p_Params->extBufPools.numOfPoolsUsed;i++)
-            {
-                if(p_Params->extBufPools.extBufPool[i].id >= BM_MAX_NUM_OF_POOLS)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[%d].id can't be larger than %d", i, BM_MAX_NUM_OF_POOLS));
-                if(!p_Params->extBufPools.extBufPool[i].size)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[%d].size is 0", i));
-            }
-
-            /* backup BM pools indication is valid only for some chip deriviatives
-               (limited by the config routine) */
-            if(p_Params->p_BackupBmPools)
-            {
-                if(p_Params->p_BackupBmPools->numOfBackupPools >= p_Params->extBufPools.numOfPoolsUsed)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_BackupBmPools must be smaller than extBufPools.numOfPoolsUsed"));
-                found = FALSE;
-                for(i = 0;i<p_Params->p_BackupBmPools->numOfBackupPools;i++)
-                    for(j=0;j<p_Params->extBufPools.numOfPoolsUsed;j++)
-                        if(p_Params->p_BackupBmPools->poolIds[i] == p_Params->extBufPools.extBufPool[j].id)
-                            found = TRUE;
-                if (!found)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("All p_BackupBmPools.poolIds must be included in extBufPools.extBufPool[n].id"));
-            }
-
-            /* up to extBufPools.numOfPoolsUsed pools may be defined */
-            if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable)
-            {
-                if((p_Params->bufPoolDepletion.numOfPools > p_Params->extBufPools.numOfPoolsUsed))
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can't be larger than %d and can't be larger than numOfPoolsUsed", FM_PORT_MAX_NUM_OF_EXT_POOLS));
+            if(FmSpCheckBufPoolsParams(&p_Params->extBufPools, p_Params->p_BackupBmPools, &p_Params->bufPoolDepletion)!= E_OK)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
-                if(!p_Params->bufPoolDepletion.numOfPools)
-                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"));
-            }
             /* Check that part of IC that needs copying is small enough to enter start margin */
-            if(p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins)
+            if(p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
 
             if(p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
-#ifdef FM_PARTITION_ARRAY
-            {
-                t_FmRevisionInfo revInfo;
-                FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-                if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                {
-                    if(p_Params->liodnOffset >= MAX_LIODN_OFFSET)
-                    {
-                        p_Params->liodnOffset = (uint16_t)(p_Params->liodnOffset & (MAX_LIODN_OFFSET-1));
-                        DBG(WARNING, ("liodnOffset number is out of rev1 range - MSB bits cleard."));
-                    }
-                }
-            }
-#endif /* FM_PARTITION_ARRAY */
+
+#ifdef FM_NO_BACKUP_POOLS
+    if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
+	if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("BackupBmPools"));
+#endif /* FM_NO_BACKUP_POOLS */
         }
 
         /****************************************/
@@ -136,12 +96,21 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         else
         {
-            if(p_Params->deqSubPortal >= MAX_QMI_DEQ_SUBPORTAL)
-                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", MAX_QMI_DEQ_SUBPORTAL));
+            if(p_Params->deqSubPortal >= FM_MAX_NUM_OF_SUB_PORTALS)
+                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", FM_MAX_NUM_OF_SUB_PORTALS));
 
             /* to protect HW internal-context from overwrite */
             if((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
+
+            if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+                    /* in O/H DEFAULT_notSupported indicates that it is not suppported and should not be checked */
+                    || (p_FmPort->fifoDeqPipelineDepth != DEFAULT_notSupported))
+            {
+                /* Check that not larger than 8 */
+                if((!p_FmPort->fifoDeqPipelineDepth) ||( p_FmPort->fifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
+            }
         }
 
         /****************************************/
@@ -188,30 +157,22 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         if(p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
 
-        /* Check the margin definition */
-        if(p_Params->bufMargins.startMargins > MAX_EXT_BUFFER_OFFSET)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
-        if(p_Params->bufMargins.endMargins > MAX_EXT_BUFFER_OFFSET)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.endMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
+        if(FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
         /* extra FIFO size (allowed only to Rx ports) */
         if(p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
 
-        if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable &&
+        if(p_Params->bufPoolDepletion.poolsGrpModeEnable &&
            !p_Params->bufPoolDepletion.numOfPools)
-              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when numberOfPoolsModeEnable=TRUE"));
+              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when poolsGrpModeEnable=TRUE"));
 #ifdef FM_CSI_CFED_LIMIT
+        if (p_FmPort->fmRevInfo.majorRev == 4)
         {
-            t_FmRevisionInfo revInfo;
-            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-
-            if (revInfo.majorRev == 4)
-            {
-                /* Check that not larger than 16 */
-                if(p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
-            }
+            /* Check that not larger than 16 */
+            if(p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
         }
 #endif /* FM_CSI_CFED_LIMIT */
     }
@@ -223,18 +184,6 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     else if (p_FmPort->fifoBufs.extra)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No fifoBufs.extra for non Rx ports"));
 
-    /****************************************/
-    /*   Rx & Tx                            */
-    /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-    {
-        /* Check that not larger than 16 */
-        if(p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
-    }
 
     /****************************************/
     /*   Tx only                            */
@@ -252,12 +201,9 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         if(!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
 
-        /* Check that not larger than 8 */
-        if((!p_FmPort->txFifoDeqPipelineDepth) ||( p_FmPort->txFifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
         if(p_FmPort->portType == e_FM_PORT_TYPE_TX)
-            if(p_FmPort->txFifoDeqPipelineDepth > 2)
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoDeqPipelineDepth for !G can't be larger than 2"));
+            if(p_FmPort->fifoDeqPipelineDepth > 2)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
     }
     /****************************************/
     /*   Non Tx Ports                       */
@@ -283,29 +229,47 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         if (p_Params->errorsToDiscard & unusedMask)
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("errorsToDiscard contains undefined bits"));
     }
+    /****************************************/
+    /*   Offline Ports                      */
+    /****************************************/
+#ifdef FM_OP_OPEN_DMA_MIN_LIMIT
+    if ((p_FmPort->fmRevInfo.majorRev >= 6) &&
+        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
+        (p_FmPort->openDmas.num < MIN_NUM_OF_OP_DMAS))
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Offline port, openDmas.num can't be smaller than %d", MIN_NUM_OF_OP_DMAS));
+#endif /* FM_OP_OPEN_DMA_MIN_LIMIT */
 
     /****************************************/
+    /*   Offline & HC Ports                 */
+    /****************************************/
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+    {
+#ifndef FM_FRAME_END_PARAMS_FOR_OP
+	if ((p_FmPort->fmRevInfo.majorRev < 6) &&
+            (p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore != DEFAULT_notSupported))
+                 /* this is an indication that user called config for this mode which is not supported in this integration */
+		RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("cheksumLastBytesIgnore is available for Rx & Tx ports only"));
+#endif /* !FM_FRAME_END_PARAMS_FOR_OP */
+
+#ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
+	if ((!((p_FmPort->fmRevInfo.majorRev == 4) ||
+               (p_FmPort->fmRevInfo.majorRev >= 6))) &&
+            (p_FmPort->fifoDeqPipelineDepth != DEFAULT_notSupported))
+		    /* this is an indication that user called config for this mode which is not supported in this integration */
+		RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("fifoDeqPipelineDepth is available for Tx ports only"));
+#endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
+    }
+    /****************************************/
     /*   All ports                          */
     /****************************************/
 
-    /* Check that divisible by 16 and not larger than 240 */
-    if (p_Params->intContext.intContextOffset >MAX_INT_OFFSET)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset can't be larger than %d", MAX_INT_OFFSET));
-    if (p_Params->intContext.intContextOffset % OFFSET_UNITS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset has to be divisible by %d", OFFSET_UNITS));
-
-    /* check that ic size+ic internal offset, does not exceed ic block size */
-    if(p_Params->intContext.size + p_Params->intContext.intContextOffset > MAX_IC_SIZE)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size + intContext.intContextOffset has to be smaller than %d", MAX_IC_SIZE));
-    /* Check that divisible by 16 and not larger than 256 */
-    if(p_Params->intContext.size % OFFSET_UNITS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size  has to be divisible by %d", OFFSET_UNITS));
-
-    /* Check that divisible by 16 and not larger than 4K */
-    if(p_Params->intContext.extBufOffset > MAX_EXT_OFFSET)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset can't be larger than %d", MAX_EXT_OFFSET));
-    if(p_Params->intContext.extBufOffset % OFFSET_UNITS)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset  has to be divisible by %d", OFFSET_UNITS));
+    /* Check that not larger than 16 */
+    if((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
+
+    if(FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
     /* common BMI registers values */
     if((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS))
@@ -321,10 +285,17 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     if(p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
 
+#ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+    if (p_FmPort->fmRevInfo.majorRev == 4)
+        if(p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
+            /* this is an indication that user called config for this mode which is not supported in this integration */
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("deqPrefetchOption"));
+#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
+
     return E_OK;
 }
 
-static uint32_t VerifyAndUpdateSizeOfFifo(t_FmPort *p_FmPort)
+static void VerifySizeOfFifo(t_FmPort *p_FmPort)
 {
     uint32_t                minFifoSizeRequired = 0;
 
@@ -344,7 +315,7 @@ static uint32_t VerifyAndUpdateSizeOfFifo(t_FmPort *p_FmPort)
             minFifoSizeRequired = (uint32_t)((p_FmPort->maxFrameLength % BMI_FIFO_UNITS ?
                                    (p_FmPort->maxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
                                    p_FmPort->maxFrameLength) +
-                                   (p_FmPort->txFifoDeqPipelineDepth+3)*BMI_FIFO_UNITS);
+                                   (p_FmPort->fifoDeqPipelineDepth+3)*BMI_FIFO_UNITS);
         /* add some margin for back to back capability to improve performance
          * allows the hardware to pipeline new frame dma while the previous
          * frame not yet transmitted). */
@@ -372,16 +343,9 @@ static uint32_t VerifyAndUpdateSizeOfFifo(t_FmPort *p_FmPort)
               (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
              !p_FmPort->imEn)
     {
-#ifdef FM_FIFO_ALLOCATION_OLD_ALG
-        t_FmRevisionInfo revInfo;
 
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if(revInfo.majorRev != 4)
-            minFifoSizeRequired = (uint32_t)(((p_FmPort->rxPoolsParams.largestBufSize % BMI_FIFO_UNITS) ?
-                                    ((p_FmPort->rxPoolsParams.largestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
-                                    p_FmPort->rxPoolsParams.largestBufSize) + (7*BMI_FIFO_UNITS));
-        else
-#endif /* FM_FIFO_ALLOCATION_OLD_ALG */
+#ifdef FM_FIFO_ALLOCATION_ALG
+        if(p_FmPort->fmRevInfo.majorRev == 4)
         {
             if(p_FmPort->rxPoolsParams.numOfPools == 1)
                 minFifoSizeRequired = 8*BMI_FIFO_UNITS;
@@ -391,6 +355,12 @@ static uint32_t VerifyAndUpdateSizeOfFifo(t_FmPort *p_FmPort)
                                     p_FmPort->rxPoolsParams.secondLargestBufSize) +
                                     (7*BMI_FIFO_UNITS));
         }
+        else
+#endif /* FM_FIFO_ALLOCATION_ALG */
+            minFifoSizeRequired = (uint32_t)(((p_FmPort->rxPoolsParams.largestBufSize % BMI_FIFO_UNITS) ?
+                                    ((p_FmPort->rxPoolsParams.largestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                    p_FmPort->rxPoolsParams.largestBufSize) + (7*BMI_FIFO_UNITS));
+
         if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
             minFifoSizeRequired += 12*BMI_FIFO_UNITS;
         else
@@ -398,18 +368,13 @@ static uint32_t VerifyAndUpdateSizeOfFifo(t_FmPort *p_FmPort)
     }
 
     /* For O/H ports, check fifo size and update if necessary */
-    else if((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        minFifoSizeRequired = (uint32_t)((p_FmPort->txFifoDeqPipelineDepth+4)*BMI_FIFO_UNITS);
-
-    /* for all ports - update if necassary */
-    if(minFifoSizeRequired && (p_FmPort->fifoBufs.num < minFifoSizeRequired))
-    {
-        if(!p_FmPort->explicitUserSizeOfFifo)
-            p_FmPort->fifoBufs.num = minFifoSizeRequired;
-        else
-            DBG(INFO, ("User defined FIFO size should be enlarged to %d",minFifoSizeRequired));
+    else if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
+             (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        minFifoSizeRequired = (uint32_t)((p_FmPort->tasks.num + 4)*BMI_FIFO_UNITS);
 
-    }
+    /* for all ports - verify size  */
+    if (minFifoSizeRequired && (p_FmPort->fifoBufs.num < minFifoSizeRequired))
+        DBG(WARNING, ("User defined FIFO size should be enlarged to %d",minFifoSizeRequired));
 
     /* check if pool size is not too big */
     /* This is a definition problem in which if the fifo for the RX port
@@ -424,8 +389,6 @@ static uint32_t VerifyAndUpdateSizeOfFifo(t_FmPort *p_FmPort)
                     p_FmPort->fifoBufs.num, p_FmPort->rxPoolsParams.largestBufSize));
 
     }
-
-    return p_FmPort->fifoBufs.num;
 }
 
 static void FmPortDriverParamFree(t_FmPort *p_FmPort)
@@ -437,32 +400,30 @@ static void FmPortDriverParamFree(t_FmPort *p_FmPort)
     }
 }
 
+// TODO - ask why we save it in fmPortDriverParam and p_FmPort - Ganit
 static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 {
-    t_FmPortExtPools            *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
-    t_FmPortBufPoolDepletion    *p_BufPoolDepletion = &p_FmPort->p_FmPortDriverParam->bufPoolDepletion;
+    t_FmExtPools                *p_ExtBufPools = &p_FmPort->p_FmPortDriverParam->extBufPools;
+    t_FmBufPoolDepletion        *p_BufPoolDepletion = &p_FmPort->p_FmPortDriverParam->bufPoolDepletion;
     volatile uint32_t           *p_ExtBufRegs;
     volatile uint32_t           *p_BufPoolDepletionReg;
     bool                        rxPort;
-    bool                        found;
     uint8_t                     orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
     uint16_t                    sizesArray[BM_MAX_NUM_OF_POOLS];
-    uint8_t                     count = 0;
     uint8_t                     numOfPools;
-    uint16_t                    bufSize = 0, largestBufSize = 0;
-    int                         i=0, j=0, k=0;
+    int                         i=0, j=0;
     uint32_t                    tmpReg, vector;
 
     memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
     memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
-    memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmPortExtPools));
+    memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmExtPools));
 
     switch(p_FmPort->portType)
     {
         case(e_FM_PORT_TYPE_RX_10G):
         case(e_FM_PORT_TYPE_RX):
             p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi;
-            p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_mpd;
+            p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rmpd;
             rxPort = TRUE;
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
@@ -474,40 +435,9 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for port type"));
     }
 
-    /* First we copy the external buffers pools information to an ordered local array */
-    for(i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
-    {
-        /* get pool size */
-        bufSize = p_ExtBufPools->extBufPool[i].size;
-
-        /* keep sizes in an array according to poolId for direct access */
-        sizesArray[p_ExtBufPools->extBufPool[i].id] =  bufSize;
-
-        /* save poolId in an ordered array according to size */
-        for (j=0;j<=i;j++)
-        {
-            /* this is the next free place in the array */
-            if (j==i)
-                orderedArray[i] = p_ExtBufPools->extBufPool[i].id;
-            else
-            {
-                /* find the right place for this poolId */
-                if(bufSize < sizesArray[orderedArray[j]])
-                {
-                    /* move the poolIds one place ahead to make room for this poolId */
-                    for(k=i;k>j;k--)
-                       orderedArray[k] = orderedArray[k-1];
-
-                    /* now k==j, this is the place for the new size */
-                    orderedArray[k] = p_ExtBufPools->extBufPool[i].id;
-                    break;
-                }
-            }
-        }
-    }
+    FmSpSetBufPoolsInAscOrderOfBufSizes(p_ExtBufPools, orderedArray, sizesArray);
 
     /* build the register value */
-
     for(i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
     {
         tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
@@ -527,7 +457,7 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
         XX_Free(p_FmPort->p_FmPortDriverParam->p_BackupBmPools);
 
-   numOfPools = (uint8_t)(rxPort ? FM_PORT_MAX_NUM_OF_EXT_POOLS:FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS);
+    numOfPools = (uint8_t)(rxPort ? FM_PORT_MAX_NUM_OF_EXT_POOLS:FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS);
 
     /* clear unused pools */
     for(i=p_ExtBufPools->numOfPoolsUsed;i<numOfPools;i++)
@@ -535,17 +465,15 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 
     /* save pools parameters for later use */
     p_FmPort->rxPoolsParams.numOfPools = p_ExtBufPools->numOfPoolsUsed;
-    p_FmPort->rxPoolsParams.largestBufSize = largestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-1]];
+    p_FmPort->rxPoolsParams.largestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-1]];
     p_FmPort->rxPoolsParams.secondLargestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-2]];
 
-    /* pool depletion */
+    /* FMBM_RMPD reg. - pool depletion */
     tmpReg = 0;
-    if(p_BufPoolDepletion->numberOfPoolsModeEnable)
+    if(p_BufPoolDepletion->poolsGrpModeEnable)
     {
         /* calculate vector for number of pools depletion */
-        found = FALSE;
         vector = 0;
-        count = 0;
         for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
             if(p_BufPoolDepletion->poolsToConsider[i])
@@ -555,20 +483,11 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
                     if (i == orderedArray[j])
                     {
                         vector |= 0x80000000 >> j;
-                        found = TRUE;
-                        count++;
                         break;
                     }
                 }
-                if (!found)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
-                else
-                    found = FALSE;
             }
         }
-        if (count < p_BufPoolDepletion->numOfPools)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools is larger than the number of pools defined."));
-
         /* configure num of pools and vector for number of pools mode */
         tmpReg |= (((uint32_t)p_BufPoolDepletion->numOfPools - 1) << BMI_POOL_DEP_NUM_OF_POOLS_SHIFT);
         tmpReg |= vector;
@@ -577,9 +496,7 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     if(p_BufPoolDepletion->singlePoolModeEnable)
     {
         /* calculate vector for number of pools depletion */
-        found = FALSE;
         vector = 0;
-        count = 0;
         for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
             if(p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
@@ -589,23 +506,31 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
                     if (i == orderedArray[j])
                      {
                         vector |= 0x00000080 >> j;
-                        found = TRUE;
-                        count++;
                         break;
                     }
                 }
-                if (!found)
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
-                else
-                    found = FALSE;
             }
         }
-        if (!count)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("No pools defined for single buffer mode pool depletion."));
+        tmpReg |= vector;
+    }
 
-        /* configure num of pools and vector for number of pools mode */
+#if DPAA_VERSION >= 3
+    /* fill QbbPEV */
+    if (p_BufPoolDepletion->poolsGrpModeEnable ||
+        p_BufPoolDepletion->singlePoolModeEnable)
+    {
+        vector = 0;
+        for (i=0; i<FM_MAX_NUM_OF_PFC_PRIORITIES; i++)
+        {
+            if (p_BufPoolDepletion->pfcPrioritiesEn[i] == TRUE)
+            {
+                vector |= 0x00008000 >> i;
+                break;
+            }
+        }
         tmpReg |= vector;
     }
+#endif /* DPAA_VERSION >= 3 */
 
     WRITE_UINT32(*p_BufPoolDepletionReg, tmpReg);
 
@@ -663,16 +588,11 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
 
     WRITE_UINT32(p_Regs->fmbm_rfp, tmpReg);
 
-    {
-#ifdef FM_NO_THRESHOLD_REG
-         t_FmRevisionInfo        revInfo;
-
-         FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-         if (revInfo.majorRev > 1)
-#endif /* FM_NO_THRESHOLD_REG */
-            /* always allow access to the extra resources */
-            WRITE_UINT32(p_Regs->fmbm_reth, BMI_RX_FIFO_THRESHOLD_BC);
-    }
+#ifdef FM_NO_RESTRICT_ON_ACCESS_RSRC
+    if (p_FmPort->fmRevInfo.majorRev < 6)
+        /* always allow access to the extra resources */
+        WRITE_UINT32(p_Regs->fmbm_reth, BMI_RX_FIFO_THRESHOLD_BC);
+#endif /* FM_NO_RESTRICT_ON_ACCESS_RSRC */
 
      /* frame end parameters */
     tmpReg = 0;
@@ -691,24 +611,39 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
 
     if (!p_FmPort->imEn)
     {
+        /* Call the external Buffer routine which also checks fifo
+           size and updates it if necessary */
+        /* define external buffer pools and pool depletion*/
+        err = SetExtBufferPools(p_FmPort);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
         /* check if the largest external buffer pool is large enough */
-        if(p_Params->bufMargins.startMargins + MIN_EXT_BUF_SIZE + p_Params->bufMargins.endMargins > p_FmPort->rxPoolsParams.largestBufSize)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins (%d) + minimum buf size (64) + bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
-                            p_Params->bufMargins.startMargins, p_Params->bufMargins.endMargins, p_FmPort->rxPoolsParams.largestBufSize));
+        if ((p_Params->bufMargins.startMargins +
+             MIN_EXT_BUF_SIZE +
+             p_Params->bufMargins.endMargins) > p_FmPort->rxPoolsParams.largestBufSize)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("bufMargins.startMargins (%d) + minimum buf size (64) + "
+                          "bufMargins.endMargins (%d) is larger than maximum external buffer size (%d)",
+                            p_Params->bufMargins.startMargins,
+                            p_Params->bufMargins.endMargins,
+                            p_FmPort->rxPoolsParams.largestBufSize));
 
         /* buffer margins */
         tmpReg = 0;
         tmpReg |= (((uint32_t)p_Params->bufMargins.startMargins) << BMI_EXT_BUF_MARG_START_SHIFT);
         tmpReg |= (((uint32_t)p_Params->bufMargins.endMargins) << BMI_EXT_BUF_MARG_END_SHIFT);
-
+#if DPAA_VERSION >= 3
+        if (p_Params->noScatherGather)
+            tmpReg |= BMI_SG_DISABLE;
+#endif
         WRITE_UINT32(p_Regs->fmbm_rebm, tmpReg);
     }
 
-
-    if(p_FmPort->internalBufferOffset)
+    if (p_FmPort->internalBufferOffset)
     {
-        tmpReg = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
-                            (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
+        tmpReg = (uint32_t)((p_FmPort->internalBufferOffset%OFFSET_UNITS) ?
+                            (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1) :
                             (p_FmPort->internalBufferOffset/OFFSET_UNITS));
         p_FmPort->internalBufferOffset = (uint8_t)(tmpReg * OFFSET_UNITS);
         WRITE_UINT32(p_Regs->fmbm_rim, tmpReg << BMI_IM_FOF_SHIFT);
@@ -724,7 +659,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
             tmpReg |= BMI_PORT_RFNE_FRWD_RPD;
         /* L3/L4 checksum verify is enabled by default. */
         /*tmpReg |= BMI_PORT_RFNE_FRWD_DCL4C;*/
-        WRITE_UINT32(p_Regs->fmbm_rfne, tmpReg | NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+        WRITE_UINT32(p_Regs->fmbm_rfne, tmpReg | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
     }
     WRITE_UINT32(p_Regs->fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
 
@@ -799,14 +734,14 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
     /* Configure Tx Fifo params */
     tmpReg = 0;
     tmpReg |= ((p_Params->txFifoMinFillLevel/BMI_FIFO_UNITS) << BMI_TX_FIFO_MIN_FILL_SHIFT);
-    tmpReg |= (((uint32_t)p_FmPort->txFifoDeqPipelineDepth - 1) << BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT);
+    tmpReg |= (((uint32_t)p_FmPort->fifoDeqPipelineDepth - 1) << BMI_FIFO_PIPELINE_DEPTH_SHIFT);
     tmpReg |= ((p_Params->txFifoLowComfLevel/BMI_FIFO_UNITS - 1) << BMI_TX_LOW_COMF_SHIFT);
 
     WRITE_UINT32(p_Regs->fmbm_tfp, tmpReg);
 
     /* frame end parameters */
     tmpReg = 0;
-    tmpReg |= ((uint32_t)p_Params->cheksumLastBytesIgnore << BMI_TX_FRAME_END_CS_IGNORE_SHIFT);
+    tmpReg |= ((uint32_t)p_Params->cheksumLastBytesIgnore << BMI_FRAME_END_CS_IGNORE_SHIFT);
 
     WRITE_UINT32(p_Regs->fmbm_tfed, tmpReg);
 
@@ -824,12 +759,12 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
     /* NIA */
     if (p_FmPort->imEn)
     {
-        WRITE_UINT32(p_Regs->fmbm_tfne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
+        WRITE_UINT32(p_Regs->fmbm_tfdne, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
         WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_FM_CTL | NIA_FM_CTL_AC_IND_MODE_TX);
     }
     else
     {
-        WRITE_UINT32(p_Regs->fmbm_tfne, NIA_ENG_QMI_DEQ);
+        WRITE_UINT32(p_Regs->fmbm_tfdne, NIA_ENG_QMI_DEQ);
         WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
         /* The line bellow is a trick so the FM will not release the buffer
            to BM nor will try to enq the frame to QM */
@@ -884,7 +819,6 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     uint32_t                tmpReg, errorsToEnq = 0;
     t_FmPortDriverParam     *p_Params = p_FmPort->p_FmPortDriverParam;
     t_FmPortPerformanceCnt  performanceContersParams;
-    t_Error                 err;
 
     /* check that port is not busy */
     if (GET_UINT32(p_Regs->fmbm_ocfg) & BMI_PORT_CFG_EN)
@@ -943,21 +877,20 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         WRITE_UINT32(p_Regs->fmbm_ofsem, errorsToEnq);
 
         /* NIA */
-        WRITE_UINT32(p_Regs->fmbm_ofne, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
-        {
-#ifdef FM_NO_OP_OBSERVED_POOLS
-            t_FmRevisionInfo        revInfo;
+        WRITE_UINT32(p_Regs->fmbm_ofne, (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
 
-            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-            if ((revInfo.majorRev == 4) && (p_Params->enBufPoolDepletion))
-#endif /* FM_NO_OP_OBSERVED_POOLS */
-            {
-                /* define external buffer pools */
-                err = SetExtBufferPools(p_FmPort);
-                if(err)
-                    RETURN_ERROR(MAJOR, err, NO_MSG);
-            }
+#ifndef FM_NO_OP_OBSERVED_POOLS
+        /* Call the external Buffer routine which also checks fifo
+           size and updates it if necessary */
+        if ((p_FmPort->fmRevInfo.majorRev == 4) &&
+            p_Params->enBufPoolDepletion)
+        {
+            /* define external buffer pools */
+            t_Error err = SetExtBufferPools(p_FmPort);
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
         }
+#endif /* FM_NO_OP_OBSERVED_POOLS */
     }
     else
         /* NIA */
@@ -967,7 +900,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     WRITE_UINT32(p_Regs->fmbm_ofqid, p_Params->dfltFqid);
     WRITE_UINT32(p_Regs->fmbm_oefqid, p_Params->errFqid);
 
-    if(p_FmPort->internalBufferOffset)
+    if (p_FmPort->internalBufferOffset)
     {
         tmpReg = (uint32_t)((p_FmPort->internalBufferOffset % OFFSET_UNITS) ?
                             (p_FmPort->internalBufferOffset/OFFSET_UNITS + 1):
@@ -985,6 +918,25 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams);
 
     WRITE_UINT32(p_Regs->fmbm_opc, BMI_COUNTERS_EN);
+#ifdef FM_DEQ_PIPELINE_PARAMS_FOR_OP
+    if ((p_FmPort->fmRevInfo.majorRev == 4) ||
+        (p_FmPort->fmRevInfo.majorRev >= 6))
+    {
+        tmpReg = (((uint32_t)p_FmPort->fifoDeqPipelineDepth - 1) << BMI_FIFO_PIPELINE_DEPTH_SHIFT);
+        WRITE_UINT32(p_Regs->fmbm_ofp, tmpReg);
+    }
+#endif /* FM_DEQ_PIPELINE_PARAMS_FOR_OP */
+
+#ifdef FM_FRAME_END_PARAMS_FOR_OP
+    if(p_FmPort->fmRevInfo.majorRev >= 6)
+    {
+        /* frame end parameters */
+        tmpReg = 0;
+        tmpReg |= ((uint32_t)p_Params->cheksumLastBytesIgnore << BMI_FRAME_END_CS_IGNORE_SHIFT);
+
+        WRITE_UINT32(p_Regs->fmbm_ofed, tmpReg);
+    }
+#endif /* FM_FRAME_END_PARAMS_FOR_OP */
 
     return E_OK;
 }
@@ -1022,19 +974,6 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
             WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
             /* define enqueue NIA */
             WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
-
-            if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            {
-                t_FmRevisionInfo            fmRevInfo;
-                t_FmCtrlCodeRevisionInfo    fmanCtrlCodeRevInfo;
-
-                FM_GetRevision(p_FmPort->h_Fm, &fmRevInfo);
-                FM_GetFmanCtrlCodeRevision(p_FmPort->h_Fm, &fmanCtrlCodeRevInfo);
-                if ((fmanCtrlCodeRevInfo.packageRev == 106) &&
-                    (fmRevInfo.majorRev < 4))
-                    /* Set pop to next step nia for QMI Enqueue Frame*/
-                    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL);
-            }
         }
 
         /* configure dequeue */
@@ -1057,7 +996,9 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue type"));
         }
 
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+#ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+		if(p_FmPort->fmRevInfo.majorRev != 4)
+#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
         switch(p_Params->deqPrefetchOption)
         {
             case(e_FM_PORT_DEQ_NO_PREFETCH):
@@ -1072,7 +1013,6 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue prefetch option"));
         }
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
         tmpReg |= p_Params->deqByteCnt;
         tmpReg |= (uint32_t)p_Params->deqSubPortal << QMI_DEQ_CFG_SUBPORTAL_SHIFT;
@@ -1109,6 +1049,7 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
         case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
         case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             if(!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
@@ -1161,6 +1102,9 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_rbdc;
             break;
+        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+            *p_Ptr = &p_BmiRegs->fmbm_rpec;
+            break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
     }
@@ -1250,6 +1194,7 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case(e_FM_PORT_COUNTERS_FRAME):
         case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
         case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
         case(e_FM_PORT_COUNTERS_WRED_DISCARD):
         case(e_FM_PORT_COUNTERS_LENGTH_ERR):
         case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
@@ -1258,8 +1203,8 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
-            if(p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Host Command ports"));
+            /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
+            ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
             if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
@@ -1306,6 +1251,12 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_obdc;
             break;
+        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+            *p_Ptr = &p_BmiRegs->fmbm_oodc;
+            break;
+        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+            *p_Ptr = &p_BmiRegs->fmbm_opec;
+            break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
     }
@@ -1345,20 +1296,11 @@ static t_Error  AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrP
                 break;
             case(HEADER_TYPE_PPPoE):
                 if(p_prsOpts->pppoePrsOptions.enableMTUCheck)
-                {
-#ifdef FM_PPPOE_NO_MTU_CHECK
-                    t_FmRevisionInfo revInfo;
-                    FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Invalid parser option"));
-                    else
-#endif /* FM_PPPOE_NO_MTU_CHECK */
-                        tmpReg |= PRS_HDR_PPPOE_MTU_CHECK_EN;
-                }
+                    tmpReg |= PRS_HDR_PPPOE_MTU_CHECK_EN;
                 break;
             case(HEADER_TYPE_IPv6):
-                if(p_prsOpts->ipv6PrsOptions.routingHdrDisable)
-                    tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_DIS;
+                if(p_prsOpts->ipv6PrsOptions.routingHdrEnable)
+                    tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_EN;
                 break;
             case(HEADER_TYPE_TCP):
                 if(p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
@@ -1397,7 +1339,7 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
     p_SchemeBind->useClsPlan = p_FmPort->useClsPlan;
     p_SchemeBind->numOfSchemes = 0;
     tmp = p_FmPort->schemesPerPortVector;
-    if(tmp)
+    if (tmp)
     {
         while (tmp)
         {
@@ -1415,109 +1357,6 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
     return tmp;
 }
 
-static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
-{
-    uint32_t                        tmp;
-
-    ASSERT_COND(p_FmPort);
-
-    /* Align start of internal context data to 16 byte */
-    p_FmPort->p_FmPortDriverParam->intContext.extBufOffset =
-        (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize & (OFFSET_UNITS-1)) ?
-            ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize + OFFSET_UNITS) & ~(uint16_t)(OFFSET_UNITS-1)) :
-             p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize);
-
-    /* Translate margin and intContext params to FM parameters */
-    /* Initialize with illegal value. Later we'll set legal values. */
-    p_FmPort->bufferOffsets.prsResultOffset = (uint32_t)ILLEGAL_BASE;
-    p_FmPort->bufferOffsets.timeStampOffset = (uint32_t)ILLEGAL_BASE;
-    p_FmPort->bufferOffsets.hashResultOffset= (uint32_t)ILLEGAL_BASE;
-    p_FmPort->bufferOffsets.pcdInfoOffset   = (uint32_t)ILLEGAL_BASE;
-
-    /* Internally the driver supports 4 options
-       1. prsResult/timestamp/hashResult selection (in fact 8 options, but for simplicity we'll
-          relate to it as 1).
-       2. All IC context (from AD) not including debug.*/
-
-    /* This 'if' covers option 2. We copy from beginning of context. */
-    if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo)
-    {
-        p_FmPort->p_FmPortDriverParam->intContext.size = 128; /* must be aligned to 16 */
-        /* Start copying data after 16 bytes (FD) from the beginning of the internal context */
-        p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = 16;
-
-        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo)
-            p_FmPort->bufferOffsets.pcdInfoOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
-        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult)
-            p_FmPort->bufferOffsets.prsResultOffset =
-                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 16);
-        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp)
-            p_FmPort->bufferOffsets.timeStampOffset =
-                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 48);
-        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult)
-            p_FmPort->bufferOffsets.hashResultOffset =
-                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 56);
-    }
-    else
-    {
-        /* This case covers the options under 1 */
-        /* Copy size must be in 16-byte granularity. */
-        p_FmPort->p_FmPortDriverParam->intContext.size =
-            (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 : 0) +
-                      ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ||
-                      p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 16 : 0));
-
-        /* Align start of internal context data to 16 byte */
-        p_FmPort->p_FmPortDriverParam->intContext.intContextOffset =
-            (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 :
-                      ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp  ||
-                       p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 64 : 0));
-
-        if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult)
-            p_FmPort->bufferOffsets.prsResultOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
-        if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp)
-            p_FmPort->bufferOffsets.timeStampOffset =  p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
-                                        (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult)) :
-                                        p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
-        if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult)
-            /* If PR is not requested, whether TS is requested or not, IC will be copied from TS */
-            p_FmPort->bufferOffsets.hashResultOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
-                                          (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult) + 8) :
-                                          p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 8;
-    }
-
-    p_FmPort->p_FmPortDriverParam->bufMargins.startMargins =
-        (uint16_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset +
-                   p_FmPort->p_FmPortDriverParam->intContext.size);
-#if (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_CAPWAP_SUPPORT))
-    /* save extra space for manip in both external and internal buffers */
-    if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace)
-    {
-        uint8_t extraSpace;
-#ifdef FM_CAPWAP_SUPPORT
-        if((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + CAPWAP_FRAG_EXTRA_SPACE) >= 256)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + 32 can not be equal or larger to 256"));
-        extraSpace = (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + CAPWAP_FRAG_EXTRA_SPACE);
-#else
-        extraSpace = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace;
-#endif /* FM_CAPWAP_SUPPORT */
-        p_FmPort->bufferOffsets.manipOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
-        p_FmPort->p_FmPortDriverParam->bufMargins.startMargins += extraSpace;
-        p_FmPort->p_FmPortDriverParam->internalBufferOffset = extraSpace;
-    }
-#endif /* (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_CAPWAP_SUPPORT)) */
-
-    /* align data start */
-    tmp = (uint32_t)(p_FmPort->p_FmPortDriverParam->bufMargins.startMargins %
-                     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign);
-    if (tmp)
-        p_FmPort->p_FmPortDriverParam->bufMargins.startMargins += (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign-tmp);
-    p_FmPort->bufferOffsets.dataOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
-    p_FmPort->internalBufferOffset = p_FmPort->p_FmPortDriverParam->internalBufferOffset;
-
-    return E_OK;
-}
-
 static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 {
     t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
@@ -1548,7 +1387,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
-    p_FmPort->netEnvId = (uint8_t)(PTR_TO_UINT(p_PcdParams->h_NetEnv)-1);
+    p_FmPort->netEnvId = FmPcdGetNetEnvId(p_PcdParams->h_NetEnv);
 
     p_FmPort->pcdEngines = 0;
 
@@ -1561,8 +1400,6 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             break;
         case(e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
-            if (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser support is required"));
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
         case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
@@ -1584,50 +1421,43 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-#if (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_IPSEC_SUPPORT))
         case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
-#endif /* (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || ... */
         case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-
 #ifdef FM_CAPWAP_SUPPORT
         case(e_FM_PORT_PCD_SUPPORT_CC_ONLY):
-            if (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser support is required"));
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
         case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
-            if (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser support is required"));
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
         case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
-            if (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser support is required"));
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
 #endif /* FM_CAPWAP_SUPPORT */
+
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid pcdSupport"));
     }
 
-    if((p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams > FM_PCD_PRS_NUM_OF_HDRS))
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
+        (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams > FM_PCD_PRS_NUM_OF_HDRS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Port parser numOfHdrsWithAdditionalParams may not exceed %d", FM_PCD_PRS_NUM_OF_HDRS));
 
     /* check that parameters exist for each and only each defined engine */
-    if((!!(p_FmPort->pcdEngines & FM_PCD_PRS) != !!p_PcdParams->p_PrsParams) ||
+    if ((!!(p_FmPort->pcdEngines & FM_PCD_PRS) != !!p_PcdParams->p_PrsParams) ||
         (!!(p_FmPort->pcdEngines & FM_PCD_KG) != !!p_PcdParams->p_KgParams) ||
         (!!(p_FmPort->pcdEngines & FM_PCD_CC) != !!p_PcdParams->p_CcParams))
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistant with pcdSupport"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
 
     /* get PCD registers pointers */
     switch(p_FmPort->portType)
@@ -1654,9 +1484,13 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     /* set PCD port parameter */
     if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset, h_FmPort);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd,
+                              p_PcdParams,
+                              p_PcdParams->p_CcParams->h_CcTree,
+                              &ccTreePhysOffset,
+                              h_FmPort);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
 
         WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
         p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
@@ -1677,20 +1511,6 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
 
          p_FmPort->useClsPlan = !isEmptyClsPlanGrp;
-#ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
-        {
-            t_FmRevisionInfo revInfo;
-
-            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-            if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
-                (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia)) &&
-                (revInfo.majorRev <= 3))
-            {
-                for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
-                    FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PcdParams->p_KgParams->h_Schemes[i], UPDATE_KG_NIA_CC_WA);
-            }
-        }
-#endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
 
         schemeBind.netEnvId = p_FmPort->netEnvId;
         schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
@@ -1700,10 +1520,17 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         /* for each scheme */
         for(i=0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
         {
-            physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_PcdParams->p_KgParams->h_Schemes[i])-1);
+            ASSERT_COND(p_PcdParams->p_KgParams->h_Schemes[i]);
+            physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_Schemes[i]);
             schemeBind.schemesIds[i] = physicalSchemeId;
             /* build vector */
             p_FmPort->schemesPerPortVector |= 1 << (31 - (uint32_t)physicalSchemeId);
+#if DPAA_VERSION >= 3
+            /*because of the state that VSPE is defined per port - all PCD path should be according to this requirement
+             if !VSPE - in port, for relevant scheme VSPE can not be set*/
+            if(!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSPE is not at port level"));
+#endif
         }
 
         err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
@@ -1714,16 +1541,18 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     /***************************/
     /* configure NIA after BMI */
     /***************************/
-    if (!CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
-        /* rfne may contain FDCS bits, so first we read them. */
-        p_FmPort->savedBmiNia = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
+    /* rfne may contain FDCS bits, so first we read them. */
+    p_FmPort->savedBmiNia = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
 
     /* If policer is used directly after BMI or PRS */
-    if((p_FmPort->pcdEngines & FM_PCD_PLCR) &&
+    if ((p_FmPort->pcdEngines & FM_PCD_PLCR) &&
         ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
-                (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
+         (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
     {
-        absoluteProfileId = (uint16_t)(PTR_TO_UINT(p_PcdParams->p_PlcrParams->h_Profile)-1);
+        if(!p_PcdParams->p_PlcrParams->h_Profile)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Profile should be initialized"));
+
+        absoluteProfileId = (uint16_t)FmPcdPlcrProfileGetAbsoluteId(p_PcdParams->p_PlcrParams->h_Profile);
 
         if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Private port profile not valid."));
@@ -1742,7 +1571,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
 #ifdef FM_CAPWAP_SUPPORT
     /* if CC is used directly after BMI */
-    if((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_ONLY) ||
+    if ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_ONLY) ||
         (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG) ||
         (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR))
     {
@@ -1760,14 +1589,13 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->firstPrsHdr);
         if (hdrNum == ILLEGAL_HDR_NUM)
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
-        if (!CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia))
-            p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum));
+        p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum));
         /* set after parser NIA */
         tmpReg = 0;
         switch(p_PcdParams->pcdSupport)
         {
             case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
-                WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME);
+                WRITE_UINT32(*p_BmiPrsNia, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd));
                 break;
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
@@ -1776,7 +1604,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
                 if(p_PcdParams->p_KgParams->directScheme)
                 {
-                    physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_PcdParams->p_KgParams->h_DirectScheme)-1);
+                    physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_DirectScheme);
                     /* check that this scheme was bound to this port */
                     for(i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
                         if(p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
@@ -1787,11 +1615,9 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
                 break;
-#if (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_IPSEC_SUPPORT))
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
                 WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 break;
-#endif /* (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || ... */
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
                 break;
             default:
@@ -1896,28 +1722,28 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
             tmpHxs[hdrNum] |= tmpReg;
         }
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-        /* check if reassembly port */
-        if(FmPcdIsIpFrag(p_FmPort->h_FmPcd, p_FmPort->netEnvId))
+
+        /* Check if ip-reassembly port - need to update NIAs */
+        if (p_FmPort->h_IpReassemblyManip)
         {
            /* link to sw parser code for IP Frag - only if no other code is applied. */
             GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
-            if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+            if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
                 tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv4);
             GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
-            if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_0);
+            if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6);
         }
-        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd) &&
+            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         {
             /* link to sw parser code for IP Frag - only if no other code is applied. */
             GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
-            if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_1);
+            if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6);
         }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
-        for(i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
+        for (i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
         {
             /* For all header set LCV as taken from netEnv*/
             WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->hdrs[i].lcv,  FmPcdGetLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId, (uint8_t)i));
@@ -2017,6 +1843,15 @@ static t_Error DeletePcd(t_Handle h_FmPort)
 
     if(p_FmPort->pcdEngines & FM_PCD_KG)
     {
+        t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+
+        /* unbind all schemes */
+        p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
+
+        err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
         err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
@@ -2037,9 +1872,10 @@ static t_Error DeletePcd(t_Handle h_FmPort)
 }
 
 
-/********************************************/
-/*  Inter-module API                        */
-/********************************************/
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+
 void FmPortSetMacsecLcv(t_Handle h_FmPort)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2138,8 +1974,9 @@ pndn, pnen ... maybe were changed because of the Tree requirement*/
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     /* check that current NIA is BMI to BMI */
-    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
+                     ("may be called only for ports in BMI-to-BMI state."));
 
     WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
 
@@ -2149,10 +1986,27 @@ pndn, pnen ... maybe were changed because of the Tree requirement*/
     if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    if(p_FmPort->requiredAction & UPDATE_NIA_RFENE)
-        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiRfene);
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, p_FmPort->savedBmiFene);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
+    }
+    if(p_FmPort->requiredAction & UPDATE_NIA_FPNE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne, p_FmPort->savedBmiFpne);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
+    }
+    if(p_FmPort->requiredAction & UPDATE_NIA_CMNE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
+    }
 
     return E_OK;
 }
@@ -2165,47 +2019,57 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
 
     /* this function called from Cc for pass and receive parameters port params between CC and PORT*/
 
-    if((p_CcParams->getCcParams.type & OFFSET_OF_PR) && (p_FmPort->bufferOffsets.prsResultOffset != ILLEGAL_BASE))
+    if ((p_CcParams->getCcParams.type & OFFSET_OF_PR) &&
+        (p_FmPort->bufferOffsets.prsResultOffset != ILLEGAL_BASE))
     {
         p_CcParams->getCcParams.prOffset = (uint8_t)p_FmPort->bufferOffsets.prsResultOffset;
         p_CcParams->getCcParams.type &= ~OFFSET_OF_PR;
     }
-    if(p_CcParams->getCcParams.type & HW_PORT_ID)
+    if (p_CcParams->getCcParams.type & HW_PORT_ID)
     {
         p_CcParams->getCcParams.hardwarePortId = (uint8_t)p_FmPort->hardwarePortId;
         p_CcParams->getCcParams.type &= ~HW_PORT_ID;
     }
-    if((p_CcParams->getCcParams.type & OFFSET_OF_DATA) && (p_FmPort->bufferOffsets.dataOffset != ILLEGAL_BASE))
+    if ((p_CcParams->getCcParams.type & OFFSET_OF_DATA) &&
+        (p_FmPort->bufferOffsets.dataOffset != ILLEGAL_BASE))
     {
         p_CcParams->getCcParams.dataOffset = (uint16_t)p_FmPort->bufferOffsets.dataOffset;
         p_CcParams->getCcParams.type &= ~OFFSET_OF_DATA;
     }
-    if(p_CcParams->getCcParams.type & NUM_OF_TASKS)
+    if (p_CcParams->getCcParams.type & NUM_OF_TASKS)
     {
         p_CcParams->getCcParams.numOfTasks = (uint8_t)p_FmPort->tasks.num;
         p_CcParams->getCcParams.type &= ~NUM_OF_TASKS;
     }
-    if(p_CcParams->getCcParams.type & NUM_OF_EXTRA_TASKS)
+    if (p_CcParams->getCcParams.type & NUM_OF_EXTRA_TASKS)
     {
         p_CcParams->getCcParams.numOfExtraTasks = (uint8_t)p_FmPort->tasks.extra;
         p_CcParams->getCcParams.type &= ~NUM_OF_EXTRA_TASKS;
     }
-    if(p_CcParams->getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+    if (p_CcParams->getCcParams.type & FM_REV)
     {
-        if(p_CcParams->getCcParams.poolIndex < p_FmPort->extBufPools.numOfPoolsUsed)
-        {
-            p_CcParams->getCcParams.poolIdForManip = p_FmPort->extBufPools.extBufPool[p_CcParams->getCcParams.poolIndex].id;
-            p_CcParams->getCcParams.type &= ~BUFFER_POOL_ID_FOR_MANIP;
-        }
+        p_CcParams->getCcParams.revInfo.majorRev = p_FmPort->fmRevInfo.majorRev;
+        p_CcParams->getCcParams.revInfo.minorRev = p_FmPort->fmRevInfo.minorRev;
+        p_CcParams->getCcParams.type &= ~FM_REV;
+    }
+    if (p_CcParams->getCcParams.type & GET_NIA_FPNE)
+    {
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne);
+        else
+            p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne);
+        p_CcParams->getCcParams.type &= ~GET_NIA_FPNE;
     }
 
-    if((p_CcParams->setCcParams.type & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY) && !(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY))
+    if ((p_CcParams->setCcParams.type & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY) &&
+        !(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY))
     {
         p_FmPort->requiredAction |= UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         p_FmPort->orFmanCtrl = p_CcParams->setCcParams.orFmanCtrl;
     }
 
-    if((p_CcParams->setCcParams.type & UPDATE_NIA_PNEN) && !(p_FmPort->requiredAction & UPDATE_NIA_PNEN))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNEN) &&
+        !(p_FmPort->requiredAction & UPDATE_NIA_PNEN))
     {
         p_FmPort->savedQmiPnen = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_PNEN;
@@ -2213,34 +2077,67 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
     {
        if(p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("pnen was defined previously different"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNEN was defined previously different"));
     }
 
-    if((p_CcParams->setCcParams.type & UPDATE_NIA_PNDN) && !(p_FmPort->requiredAction & UPDATE_NIA_PNDN))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_PNDN) &&
+        !(p_FmPort->requiredAction & UPDATE_NIA_PNDN))
     {
         p_FmPort->savedNonRxQmiRegsPndn = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_PNDN;
     }
-    else if(p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
+    else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
     {
         if(p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("pndn was defined previously different"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNDN was defined previously different"));
+    }
+
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FENE) &&
+        !(p_FmPort->requiredAction & UPDATE_NIA_FENE))
+    {
+        p_FmPort->savedBmiFene = p_CcParams->setCcParams.nia;
+        p_FmPort->requiredAction |= UPDATE_NIA_FENE;
+    }
+    else if (p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
+    {
+       if(p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFENE was defined previously different"));
+    }
+
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FPNE) &&
+        !(p_FmPort->requiredAction & UPDATE_NIA_FPNE))
+    {
+        p_FmPort->savedBmiFpne = p_CcParams->setCcParams.nia;
+        p_FmPort->requiredAction |= UPDATE_NIA_FPNE;
+    }
+    else if (p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
+    {
+       if(p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFPNE was defined previously different"));
     }
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    if((p_CcParams->setCcParams.type & UPDATE_NIA_RFENE) && !(p_FmPort->requiredAction & UPDATE_NIA_RFENE))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_CMNE) &&
+        !(p_FmPort->requiredAction & UPDATE_NIA_CMNE))
     {
-        p_FmPort->savedBmiRfene = p_CcParams->setCcParams.nia;
-        p_FmPort->requiredAction |= UPDATE_NIA_RFENE;
+        p_FmPort->savedBmiCmne = p_CcParams->setCcParams.nia;
+        p_FmPort->requiredAction |= UPDATE_NIA_CMNE;
     }
-    else if (p_CcParams->setCcParams.type & UPDATE_NIA_RFENE)
+    else if (p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
     {
-       if(p_FmPort->savedBmiRfene != p_CcParams->setCcParams.nia)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("rfene was defined previously different"));
+       if(p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xCMNE was defined previously different"));
     }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
-    if((p_CcParams->setCcParams.type & UPDATE_PSO) && !(p_FmPort->requiredAction & UPDATE_PSO))
+    if ((p_CcParams->setCcParams.type & UPDATE_NIA_FNE) &&
+        p_CcParams->setCcParams.immediateWrite)
+    {
+        if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("port type must be e_FM_PORT_TYPE_OH_OFFLINE_PARSING"));
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne, p_CcParams->setCcParams.nia);
+    }
+
+    if ((p_CcParams->setCcParams.type & UPDATE_PSO) &&
+        !(p_FmPort->requiredAction & UPDATE_PSO))
     {
         /* get PCD registers pointers */
          switch(p_FmPort->portType)
@@ -2269,17 +2166,20 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         if(p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser start offset was defoned previousley different"));
     }
+
     return E_OK;
 }
-/**********************************         End of inter-module routines ********************************/
+/*********************** End of inter-module routines ************************/
+
 
 /****************************************/
 /*       API Init unit functions        */
 /****************************************/
+
 t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 {
-    t_FmPort    *p_FmPort;
-    uintptr_t   baseAddr = p_FmPortParams->baseAddr;
+    t_FmPort            *p_FmPort;
+    uintptr_t           baseAddr = p_FmPortParams->baseAddr;
 
     /* Allocate FM structure */
     p_FmPort = (t_FmPort *) XX_Malloc(sizeof(t_FmPort));
@@ -2308,9 +2208,13 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->h_App         = p_FmPortParams->h_App;
     p_FmPort->h_Fm          = p_FmPortParams->h_Fm;
 
+    /* get FM revision */
+    FM_GetRevision(p_FmPort->h_Fm, &p_FmPort->fmRevInfo);
+
     /* calculate global portId number */
     SW_PORT_ID_TO_HW_PORT_ID(p_FmPort->hardwarePortId, p_FmPort->portType, p_FmPortParams->portId);
 
+
     /* Initialize FM port parameters for initialization phase only */
     p_FmPort->p_FmPortDriverParam->baseAddr                         = baseAddr;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize = DEFAULT_PORT_bufferPrefixContent_privDataSize;
@@ -2325,20 +2229,18 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = DEFAULT_PORT_dmaScatterGatherCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
     p_FmPort->p_FmPortDriverParam->liodnBase                        = p_FmPortParams->liodnBase;
+    p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore           = DEFAULT_PORT_cheksumLastBytesIgnore;
+    p_FmPort->p_FmPortDriverParam->color                            = DEFAULT_PORT_color;
 
     p_FmPort->maxFrameLength                                        = DEFAULT_PORT_maxFrameLength;
     /* resource distribution. */
-
-    /* Patch for getting GA4.3 defaults */
-    p_FmPort->fifoBufs.num                                          = DEFAULT_PORT_sizeOfFifo(p_FmPort->portType);
-
-    p_FmPort->fifoBufs.extra                                        = 0;
-    p_FmPort->openDmas.num                                          = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
+    p_FmPort->fifoBufs.num                                          = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
+    p_FmPort->fifoBufs.extra                                        = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
+    p_FmPort->openDmas.num                                          = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType, p_FmPort->fmRevInfo.majorRev);
     p_FmPort->openDmas.extra                                        = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
     p_FmPort->tasks.num                                             = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
     p_FmPort->tasks.extra                                           = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
 
-    p_FmPort->p_FmPortDriverParam->color                            = DEFAULT_PORT_color;
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
         p_FmPort->p_FmPortDriverParam->syncReq                      = DEFAULT_PORT_syncReqForHc;
     else
@@ -2361,35 +2263,54 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = DEFAULT_PORT_rxFifoThreshold;
         p_FmPort->p_FmPortDriverParam->bufMargins.endMargins        = DEFAULT_PORT_BufMargins_endMargins;
         p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
-        p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
         p_FmPort->p_FmPortDriverParam->forwardReuseIntContext       = DEFAULT_PORT_forwardIntContextReuse;
+#if DPAA_VERSION >= 3
+        p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
+#endif /*DPAA_VERSION*/
         break;
 
     case(e_FM_PORT_TYPE_TX):
-        p_FmPort->txFifoDeqPipelineDepth                            = DEFAULT_PORT_txFifoDeqPipelineDepth_1G;
         p_FmPort->p_FmPortDriverParam->dontReleaseBuf               = FALSE;
+        p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
+        p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
+        p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_1G;
+        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
+        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
+        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
+        break;
+
     case(e_FM_PORT_TYPE_TX_10G):
-        p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
         p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
         p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
+        p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
+        p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_10G;
+        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_10G;
+        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_10G;
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
+        break;
+
     case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
+#if DPAA_VERSION >= 3
+        p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
+#endif /*DPAA_VERSION*/
     case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
         p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
         p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
-        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
         p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
-
-        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            p_FmPort->p_FmPortDriverParam->errorsToDiscard          = DEFAULT_PORT_errorsToDiscard;
-
-        if(p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
-        {
-            p_FmPort->txFifoDeqPipelineDepth                        = DEFAULT_PORT_txFifoDeqPipelineDepth_10G;
-            p_FmPort->p_FmPortDriverParam->deqHighPriority          = DEFAULT_PORT_deqHighPriority_10G;
-            p_FmPort->p_FmPortDriverParam->deqByteCnt               = DEFAULT_PORT_deqByteCnt_10G;
-        }
+        p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+#ifndef FM_FRAME_END_PARAMS_FOR_OP
+        if(p_FmPort->fmRevInfo.majorRev < 6)
+            p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore   = DEFAULT_notSupported;
+#endif /* !FM_FRAME_END_PARAMS_FOR_OP */
+
+#ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
+    if (!((p_FmPort->fmRevInfo.majorRev == 4) ||
+          (p_FmPort->fmRevInfo.majorRev >= 6)))
+            p_FmPort->fifoDeqPipelineDepth                          = DEFAULT_notSupported;
+#endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
         break;
 
     default:
@@ -2398,14 +2319,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
         return NULL;
     }
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
-    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
-        p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
-
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        p_FmPort->txFifoDeqPipelineDepth                            = OH_PIPELINE_DEPTH;
+#ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+	if(p_FmPort->fmRevInfo.majorRev == 4)
+	p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
+#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     p_FmPort->imEn = p_FmPortParams->independentModeEnable;
 
@@ -2413,7 +2330,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     {
         if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
             (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
-            p_FmPort->txFifoDeqPipelineDepth = DEFAULT_PORT_txFifoDeqPipelineDepth_IM;
+            p_FmPort->fifoDeqPipelineDepth = DEFAULT_PORT_fifoDeqPipelineDepth_IM;
         FmPortConfigIM(p_FmPort, p_FmPortParams);
     }
     else
@@ -2425,7 +2342,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             /* Initialize FM port parameters for initialization phase only */
             memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
                    &p_FmPortParams->specificParams.rxParams.extBufPools,
-                   sizeof(t_FmPortExtPools));
+                   sizeof(t_FmExtPools));
             p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.rxParams.errFqid;
             p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
             p_FmPort->p_FmPortDriverParam->liodnOffset                  = p_FmPortParams->specificParams.rxParams.liodnOffset;
@@ -2495,8 +2412,13 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if ((err = BuildBufferStructure(p_FmPort)) != E_OK)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+    err = FmSpBuildBufferStructure(&p_FmPort->p_FmPortDriverParam->intContext,
+                                   &p_FmPort->p_FmPortDriverParam->bufferPrefixContent,
+                                   &p_FmPort->p_FmPortDriverParam->bufMargins,
+                                   &p_FmPort->bufferOffsets,
+                                   &p_FmPort->internalBufferOffset);
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     CHECK_INIT_PARAMETERS(p_FmPort, CheckInitParameters);
 
@@ -2507,19 +2429,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     p_FmPort->p_FmPortBmiRegs     = (u_FmPortBmiRegs *)UINT_TO_PTR(p_Params->baseAddr + BMI_PORT_REGS_OFFSET);
     p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(p_Params->baseAddr + PRS_PORT_REGS_OFFSET);
 
-    /* For Rx Ports, call the external Buffer routine which also checks fifo
-       size and updates it if necessary */
-    if(((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-        && !p_FmPort->imEn)
-    {
-        /* define external buffer pools and pool depletion*/
-        err = SetExtBufferPools(p_FmPort);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-
-
-
     /************************************************************/
     /* Call FM module routine for communicating parameters      */
     /************************************************************/
@@ -2530,26 +2439,27 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
     fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
-    fmParams.sizeOfFifo         = VerifyAndUpdateSizeOfFifo(p_FmPort); /* will not make a change if configured by user */
+    if(p_FmPort->explicitUserSizeOfFifo)
+        VerifySizeOfFifo(p_FmPort);
+    fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
     fmParams.extraSizeOfFifo    = p_FmPort->fifoBufs.extra;
     fmParams.independentMode    = p_FmPort->imEn;
     fmParams.liodnOffset        = p_Params->liodnOffset;
     fmParams.liodnBase          = p_Params->liodnBase;
-
-    switch(p_FmPort->portType)
+    fmParams.deqPipelineDepth   = p_FmPort->fifoDeqPipelineDepth;
+#ifndef FM_DEQ_PIPELINE_PARAMS_FOR_OP
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
-            break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+        if (!((p_FmPort->fmRevInfo.majorRev == 4) ||
+                (p_FmPort->fmRevInfo.majorRev >= 6)))
+            /* HC ports do not have fifoDeqPipelineDepth, but it is needed only
+             * for deq threshold calculation.
+             */
+            fmParams.deqPipelineDepth = 2;
     }
+#endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
+
 
     err = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
     if(err)
@@ -2631,19 +2541,23 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     if (p_FmPort->imEn)
         FmPortImFree(p_FmPort);
 
-    if (p_FmPort->h_Spinlock)
-        XX_FreeSpinlock(p_FmPort->h_Spinlock);
-
     FmPortDriverParamFree(p_FmPort);
 
     fmParams.hardwarePortId = p_FmPort->hardwarePortId;
     fmParams.portType = (e_FmPortType)p_FmPort->portType;
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
-    fmParams.deqPipelineDepth = p_FmPort->txFifoDeqPipelineDepth;
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+    fmParams.deqPipelineDepth = p_FmPort->fifoDeqPipelineDepth;
 
     FmFreePortParams(p_FmPort->h_Fm, &fmParams);
 
+#if DPAA_VERSION >= 3
+    if(FmVSPFree( p_FmPort->h_Fm,
+                  p_FmPort->portType,
+                  p_FmPort->portId) != E_OK)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSP free of port FAILED"));
+#endif
+    if (p_FmPort->h_Spinlock)
+        XX_FreeSpinlock(p_FmPort->h_Spinlock);
+
     XX_Free(p_FmPort);
 
     return E_OK;
@@ -2719,7 +2633,6 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
     return E_OK;
 }
 
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2731,30 +2644,20 @@ t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOp
     p_FmPort->p_FmPortDriverParam->deqPrefetchOption = deqPrefetchOption;
     return E_OK;
 }
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
-t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmPortBackupBmPools *p_BackupBmPools)
+t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_BackupBmPools)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
-#ifdef FM_NO_BACKUP_POOLS
-    t_FmRevisionInfo    revInfo;
-#endif /* FM_NO_BACKUP_POOLS */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
     if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-#ifdef FM_NO_BACKUP_POOLS
-    FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-    if (revInfo.majorRev != 4)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigBackupPools"));
-#endif /* FM_NO_BACKUP_POOLS */
-
-    p_FmPort->p_FmPortDriverParam->p_BackupBmPools = (t_FmPortBackupBmPools *)XX_Malloc(sizeof(t_FmPortBackupBmPools));
+    p_FmPort->p_FmPortDriverParam->p_BackupBmPools = (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
     if(!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
-    memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmPortBackupBmPools));
+    memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmBackupBmPools));
 
     return E_OK;
 }
@@ -2773,14 +2676,14 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmPortBufferPrefixContent *p_FmPortBufferPrefixContent)
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmBufferPrefixContent *p_FmBufferPrefixContent)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent, p_FmPortBufferPrefixContent, sizeof(t_FmPortBufferPrefixContent));
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufferPrefixContent, p_FmBufferPrefixContent, sizeof(t_FmBufferPrefixContent));
     /* if dataAlign was not initialized by user, we return to driver's deafult */
     if (!p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign)
         p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign = DEFAULT_PORT_bufferPrefixContent_dataAlign;
@@ -2794,8 +2697,6 @@ t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumL
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx & Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore = cheksumLastBytesIgnore;
 
@@ -2816,7 +2717,7 @@ t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion *p_BufPoolDepletion)
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_BufPoolDepletion)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
@@ -2826,7 +2727,7 @@ t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
-    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, p_BufPoolDepletion, sizeof(t_FmPortBufPoolDepletion));
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, p_BufPoolDepletion, sizeof(t_FmBufPoolDepletion));
 
     return E_OK;
 }
@@ -2841,264 +2742,284 @@ t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedB
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
-    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion, &p_FmPortObservedBufPoolDepletion->poolDepletionParams, sizeof(t_FmPortBufPoolDepletion));
-    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, &p_FmPortObservedBufPoolDepletion->poolsParams, sizeof(t_FmPortExtPools));
+    memcpy(&p_FmPort->p_FmPortDriverParam->bufPoolDepletion,
+           &p_FmPortObservedBufPoolDepletion->poolDepletionParams,
+           sizeof(t_FmBufPoolDepletion));
+    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
+           &p_FmPortObservedBufPoolDepletion->poolsParams,
+           sizeof(t_FmExtPools));
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmPortExtPools *p_FmPortExtPools)
+t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
     if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
-    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmPortExtPools, sizeof(t_FmPortExtPools));
+    memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmExtPools, sizeof(t_FmExtPools));
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
+t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->rxFifoThreshold = fifoThreshold;
+    p_FmPort->p_FmPortDriverParam->dontReleaseBuf = TRUE;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel)
+t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
-
-    p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel = priElevationLevel;
+    p_FmPort->p_FmPortDriverParam->color = color;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel)
+t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = minFillLevel;
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
+
+    p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigTxFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth)
+
+t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) &&
-        (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
-    if (p_FmPort->imEn)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for IM ports!"));
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
 
-    p_FmPort->txFifoDeqPipelineDepth = deqPipelineDepth;
+    p_FmPort->p_FmPortDriverParam->frmDiscardOverride = override;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel)
+t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+                                                            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
-    p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = fifoLowComfLevel;
+    p_FmPort->p_FmPortDriverParam->errorsToDiscard = errs;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort)
+t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->dontReleaseBuf = TRUE;
+    p_FmPort->p_FmPortDriverParam->dmaSwapData = swapData;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color)
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intContextCacheAttr)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    p_FmPort->p_FmPortDriverParam->color = color;
+
+    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr = intContextCacheAttr;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCacheAttr)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
-
-    p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
+    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr = headerCacheAttr;
 
     return E_OK;
 }
 
-
-t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption scatterGatherCacheAttr)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
 
-    p_FmPort->p_FmPortDriverParam->frmDiscardOverride = override;
+    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr = scatterGatherCacheAttr;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
+t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-                                                            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
-    p_FmPort->p_FmPortDriverParam->errorsToDiscard = errs;
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
+
+    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
 
     return E_OK;
 }
-
-t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData)
+#if DPAA_VERSION >= 3
+t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
+    UNUSED(noScatherGather);
+    UNUSED(p_FmPort);
+
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dmaSwapData = swapData;
+    p_FmPort->p_FmPortDriverParam->noScatherGather = noScatherGather;
 
     return E_OK;
 }
-
-t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmPortDmaCache intContextCacheAttr)
+#endif /*DPAA_VERSION*/
+t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr = intContextCacheAttr;
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
+
+    p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCacheAttr)
+t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr = headerCacheAttr;
+    p_FmPort->maxFrameLength = length;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache scatterGatherCacheAttr)
+/****************************************************/
+/*       Hidden-DEBUG Only API                      */
+/****************************************************/
+
+
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
-    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr = scatterGatherCacheAttr;
+    p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = minFillLevel;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
+t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
+    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Rx ports"));
 
-    p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
+    if (p_FmPort->imEn)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for IM ports!"));
+
+    p_FmPort->fifoDeqPipelineDepth = deqPipelineDepth;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReuse)
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
-
-    p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
+    p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = fifoLowComfLevel;
 
     return E_OK;
 }
 
-t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length)
+t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-    p_FmPort->maxFrameLength = length;
+    p_FmPort->p_FmPortDriverParam->rxFifoThreshold = fifoThreshold;
 
     return E_OK;
 }
 
+t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
 
-/****************************************************/
-/*       PCD Advaced config API                     */
-/****************************************************/
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
+    p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel = priElevationLevel;
+
+    return E_OK;
+}
 /****************************************************/
 /*       API Run-time Control unit functions        */
 /****************************************************/
@@ -3132,8 +3053,8 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for host command port where number is always 1"));
+    /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
+    ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
 
     if((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
@@ -3157,11 +3078,11 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if(!p_SizeOfFifo->num || (p_SizeOfFifo->num > BMI_MAX_FIFO_SIZE))
+    if (!p_SizeOfFifo->num || (p_SizeOfFifo->num > BMI_MAX_FIFO_SIZE))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-    if(p_SizeOfFifo->num % BMI_FIFO_UNITS)
+    if (p_SizeOfFifo->num % BMI_FIFO_UNITS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be divisible by %d", BMI_FIFO_UNITS));
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* extra FIFO size (allowed only to Rx ports) */
          if(p_SizeOfFifo->extra % BMI_FIFO_UNITS)
@@ -3175,7 +3096,7 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
 
     p_FmPort->explicitUserSizeOfFifo = TRUE;
     /* we do not change user's parameter */
-    VerifyAndUpdateSizeOfFifo(p_FmPort);
+    VerifySizeOfFifo(p_FmPort);
 
     err = FmSetSizeOfFifo(p_FmPort->h_Fm, p_FmPort->hardwarePortId, p_SizeOfFifo->num, p_SizeOfFifo->extra, FALSE);
     if(err)
@@ -3304,7 +3225,11 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
                 --tries)
             XX_UDelay(1);
         if (!tries)
+        {
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+                         GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
             RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+        }
     }
 
     /* Disable BMI */
@@ -3319,7 +3244,14 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
         XX_UDelay(1);
 
     if (!tries)
+    {
+        if (!rxPort && !p_FmPort->imEn)
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+                         GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
+        WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
+
         RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+    }
 
     p_FmPort->enabled = 0;
 
@@ -3445,10 +3377,8 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
     else
     {
 #ifndef FM_NO_ADVANCED_RATE_LIMITER
-        t_FmRevisionInfo    revInfo;
 
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if (revInfo.majorRev == 4)
+        if ((p_FmPort->fmRevInfo.majorRev == 4) || (p_FmPort->fmRevInfo.majorRev >= 6))
         {
             switch(p_RateLimit->rateLimitDivider)
             {
@@ -3939,8 +3869,6 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
                 return 0;
         }
     }
-
-    return 0;
 }
 
 t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint32_t value)
@@ -4145,8 +4073,96 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum)
     return E_OK;
 }
 
+/*****************************************************************************/
+/*       API Run-time PCD Control unit functions                             */
+/*****************************************************************************/
+
+#if DPAA_VERSION >= 3
+t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
+{
+    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
+    t_Error                     err = E_OK;
+    volatile uint32_t           *p_BmiStorageProfileId = NULL, *p_BmiVspe = NULL;
+    uint32_t                    tmpReg = 0;
+    uint16_t                    hwStoragePrflId;
 
-/*       API Run-time PCD Control unit functions        */
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->h_Fm, E_INVALID_HANDLE);
+    /*for numOfProfiles = 0 don't call this function*/
+    SANITY_CHECK_RETURN_ERROR(p_VSPParams->numOfProfiles, E_INVALID_VALUE);
+    /*dfltRelativeId should be in the range of numOfProfiles*/
+    SANITY_CHECK_RETURN_ERROR(IN_RANGE(0, p_VSPParams->dfltRelativeId, (p_VSPParams->numOfProfiles - 1)), E_INVALID_VALUE);
+    /*p_FmPort should be from Rx type or OP*/
+    SANITY_CHECK_RETURN_ERROR(((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
+                               (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+                               (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)), E_INVALID_VALUE);
+    /*port should be disabled*/
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->enabled, E_INVALID_STATE);
+    /*if its called for Rx port relevant Tx Port should be passed (initialized) too and it should be disabled*/
+    SANITY_CHECK_RETURN_ERROR(((p_VSPParams->h_FmTxPort &&
+                                !((t_FmPort *)(p_VSPParams->h_FmTxPort))->enabled) ||
+                               (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)), E_INVALID_VALUE);
+    /*should be called before SetPCD - this port should be without PCD*/
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->pcdEngines, E_INVALID_STATE);
+
+    /*alloc window of VSPs for this port*/
+    err = FmVSPAlloc(p_FmPort->h_Fm,
+                             p_FmPort->portType,
+                             p_FmPort->portId,
+                             p_VSPParams->numOfProfiles);
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    /*get absolute VSP ID for dfltRelative*/
+    err = FmVSPGetAbsoluteProfileId(p_FmPort->h_Fm,
+                                    p_FmPort->portType,
+                                    p_FmPort->portId,
+                                    p_VSPParams->dfltRelativeId,
+                                    &hwStoragePrflId);
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err,NO_MSG);
+
+    /*fill relevant registers for p_FmPort and relative TxPort in the case p_FmPort from Rx type*/
+    switch (p_FmPort->portType)
+    {
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
+            /* TODO - for TxConf EBD should be set */
+            p_BmiStorageProfileId = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfqid);
+            p_BmiVspe = &(((t_FmPort *)(p_VSPParams->h_FmTxPort))->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfne);
+
+            tmpReg = GET_UINT32(*p_BmiStorageProfileId) & ~BMI_SP_ID_MASK;
+            tmpReg |= (uint32_t)hwStoragePrflId<<BMI_SP_ID_SHIFT;
+            WRITE_UINT32(*p_BmiStorageProfileId, tmpReg);
+
+            tmpReg = GET_UINT32(*p_BmiVspe);
+            WRITE_UINT32(*p_BmiVspe, tmpReg | BMI_SP_EN);
+
+            p_BmiStorageProfileId = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfqid;
+            p_BmiVspe = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpp;
+            hwStoragePrflId = p_VSPParams->dfltRelativeId;
+            break;
+
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            p_BmiStorageProfileId = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofqid;
+            p_BmiVspe = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opp;
+            break;
+
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+    }
+
+    p_FmPort->vspe = TRUE;
+
+    tmpReg = GET_UINT32(*p_BmiStorageProfileId) & ~BMI_SP_ID_MASK;
+    tmpReg |= (uint32_t)hwStoragePrflId<<BMI_SP_ID_SHIFT;
+    WRITE_UINT32(*p_BmiStorageProfileId, tmpReg);
+
+    tmpReg = GET_UINT32(*p_BmiVspe);
+    WRITE_UINT32(*p_BmiVspe, tmpReg | BMI_SP_EN);
+    return E_OK;
+}
+#endif /* DPAA_VERSION >= 3 */
 
 t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
 {
@@ -4156,14 +4172,20 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
 
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+         return ERROR_CODE(E_BUSY);
+
     if(numOfProfiles)
     {
         err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
         if(err)
             RETURN_ERROR(MAJOR, err,NO_MSG);
     }
+    /* set the port handle within the PCD policer, even if no profiles defined */
     FmPcdPortRegister(p_FmPort->h_FmPcd, h_FmPort, p_FmPort->hardwarePortId);
 
+    RELEASE_LOCK(p_FmPort->lock);
+
     return E_OK;
 }
 
@@ -4172,9 +4194,16 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                     err = E_OK;
 
+    if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
+         return ERROR_CODE(E_BUSY);
+
     err = FmPcdPlcrFreeProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId);
+
+    RELEASE_LOCK(p_FmPort->lock);
+
     if(err)
         RETURN_ERROR(MAJOR, err,NO_MSG);
+
     return E_OK;
 }
 
@@ -4209,7 +4238,7 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     /* if we want to change to direct scheme, we need to check that this scheme is valid */
     if(p_FmPcdKgScheme->direct)
     {
-        physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_FmPcdKgScheme->h_DirectScheme)-1);
+        physicalSchemeId = FmPcdKgGetSchemeId(p_FmPcdKgScheme->h_DirectScheme);
         /* check that this scheme is bound to this port */
         if(!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
         {
@@ -4224,7 +4253,7 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
             RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
         }
 
-        if(!FmPcdKgIsSchemeValidSw(p_FmPort->h_FmPcd, relativeSchemeId))
+        if(!FmPcdKgIsSchemeValidSw(p_FmPcdKgScheme->h_DirectScheme))
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
@@ -4245,7 +4274,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
     volatile uint32_t               *p_BmiNia;
     volatile uint32_t               *p_BmiHpnia;
     uint32_t                        tmpReg;
-    uint16_t                        absoluteProfileId = (uint16_t)(PTR_TO_UINT(h_Profile)-1);
+    uint16_t                        absoluteProfileId = FmPcdPlcrProfileGetAbsoluteId(h_Profile);
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -4328,11 +4357,11 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     }
 
     /* check that current NIA is BMI to BMI */
-    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
-/*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...
-         it has to be returned to the default state - initially*/
+    /*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...
+             it has to be returned to the default state - initially*/
 
     p_FmPort->requiredAction = 0;
 
@@ -4365,7 +4394,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         RELEASE_LOCK(p_FmPort->lock);
     }
     else
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Coarse CLassification not defined for this port."));
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Coarse Classification not defined for this port."));
 
     return E_OK;
 }
@@ -4463,13 +4492,13 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
         }
     }
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    if(p_FmPort->requiredAction & UPDATE_NIA_RFENE)
+    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
-        /*TODO - check!!*/
-        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
     }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
         if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
@@ -4481,6 +4510,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 {
     t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                                 err = E_OK;
+    t_FmPortPcdParams                       modifiedPcdParams;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -4490,22 +4520,171 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
         return ERROR_CODE(E_BUSY);
+
     p_FmPort->h_FmPcd = FmGetPcdHandle(p_FmPort->h_Fm);
     ASSERT_COND(p_FmPort->h_FmPcd);
 
-    err = SetPcd( h_FmPort, p_PcdParams);
+    memcpy(&modifiedPcdParams, p_PcdParams, sizeof(t_FmPortPcdParams));
+    p_PcdParams = &modifiedPcdParams;
+    if (p_PcdParams->h_IpReassemblyManip)
+    {
+        if ((p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG) &&
+            (p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC) &&
+            (p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR) &&
+            (p_PcdParams->pcdSupport != e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR))
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("pcdSupport must have KG for supporting IPR"));
+        }
+        p_FmPort->h_IpReassemblyManip = p_PcdParams->h_IpReassemblyManip;
+        if (((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG) ||
+             (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR)) &&
+             !p_PcdParams->p_CcParams)
+        {
+            /* No user-tree, need to build internal tree */
+            t_FmPcdCcTreeParams         *p_fmPcdCcTreeParams = NULL;
+            t_FmPortPcdCcParams         fmPortPcdCcParams;
+
+            p_fmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
+            if(!p_fmPcdCcTreeParams)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_fmPcdCcTreeParams"));
+
+            memset(p_fmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
+            memset(&fmPortPcdCcParams, 0, sizeof(t_FmPortPcdCcParams));
+
+            p_fmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
+            p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_fmPcdCcTreeParams);
+            if (!p_FmPort->h_IpReassemblyTree)
+            {
+                XX_Free(p_fmPcdCcTreeParams);
+                RELEASE_LOCK(p_FmPort->lock);
+                RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM_PCD_CcBuildTree for IPR failed"));
+            }
+            if (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_KG)
+                p_PcdParams->pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC;
+            else
+                p_PcdParams->pcdSupport = e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR;
+
+            fmPortPcdCcParams.h_CcTree = p_FmPort->h_IpReassemblyTree;
+            p_PcdParams->p_CcParams = &fmPortPcdCcParams;
+
+            XX_Free(p_fmPcdCcTreeParams);
+        }
+        if (!p_PcdParams->p_CcParams)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
+        err = FmPcdCcTreeAddIPR(p_FmPort->h_FmPcd,
+                                p_PcdParams->p_CcParams->h_CcTree,
+                                p_PcdParams->h_NetEnv,
+                                p_FmPort->h_IpReassemblyManip,
+                                TRUE);
+        if (err != E_OK)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+    }
+    err = SetPcd(h_FmPort, p_PcdParams);
     if(err)
     {
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if ((p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
+    if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
+        (p_PcdParams->p_PrsParams->includeInPrsStatistics))
         FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
 
     FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
+    if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd))
+    {
+        t_FmPortGetSetCcParams      fmPortGetSetCcParams;
+
+        memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        {
+            /* Set post-bmi-fetch nia */
+            p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+            p_FmPort->savedBmiNia |= (NIA_FM_CTL_AC_POST_BMI_FETCH | NIA_ENG_FM_CTL);
+
+            /* Set pre-bmi-fetch nia */
+            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
+            fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER | NIA_ENG_FM_CTL);
+            if ((err = FmPortGetSetCcParams(p_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            {
+                RELEASE_LOCK(p_FmPort->lock);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+#ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
+            if ((p_FmPort->fmRevInfo.majorRev < 6) &&
+                (p_FmPort->pcdEngines & FM_PCD_KG))
+            {
+                int i;
+                for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                    FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
+                                          p_PcdParams->p_KgParams->h_Schemes[i],
+                                          UPDATE_KG_NIA_CC_WA,
+                                          0);
+            }
+#endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
+        }
+
+        /* Set pop-to-next-step nia */
+#if DPAA_VERSION < 3
+        if (p_FmPort->fmRevInfo.majorRev < 6)
+        {
+            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
+            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        }
+        else
+        {
+#endif /* DPAA_VERSION < 3 */
+        fmPortGetSetCcParams.getCcParams.type = GET_NIA_FPNE;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_CMNE;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+#if DPAA_VERSION < 3
+        }
+#endif /* DPAA_VERSION < 3 */
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+
+        /* Set the ORR bit (for order-restoration) */
+#if DPAA_VERSION < 3
+        if (p_FmPort->fmRevInfo.majorRev < 6)
+        {
+            fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FENE;
+            /* Set frag-check nia */
+            fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ENG_FM_CTL | NIA_ORDER_RESTOR);
+        }
+        else
+        {
+#endif /* DPAA_VERSION < 3 */
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_FPNE;
+        fmPortGetSetCcParams.setCcParams.nia = fmPortGetSetCcParams.getCcParams.nia | NIA_ORDER_RESTOR;
+#if DPAA_VERSION < 3
+        }
+#endif /* DPAA_VERSION < 3 */
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        {
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MINOR, err, NO_MSG);
+        }
+    }
+
     err = FmPortAttachPCD(h_FmPort);
+    if(err)
+    {
+        DeletePcd(p_FmPort);
+        if (p_FmPort->h_IpReassemblyTree)
+            FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
@@ -4514,7 +4693,6 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
 {
     t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
     t_Error                                 err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
@@ -4544,20 +4722,22 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
         (p_FmPort->pcdEngines & FM_PCD_PRS))
         FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, FALSE);
 
-    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    err = DeletePcd(h_FmPort);
+    if(err)
     {
-        /* unbind all schemes */
-        p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
-
-        err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
-        if(err)
+        RELEASE_LOCK(p_FmPort->lock);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    if (p_FmPort->h_IpReassemblyTree)
+    {
+        err = FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+        if (err)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, err, NO_MSG);
         }
     }
 
-    err = DeletePcd(h_FmPort);
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
@@ -4581,16 +4761,28 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
     schemeBind.useClsPlan = p_FmPort->useClsPlan;
     for (i=0; i<schemeBind.numOfSchemes; i++)
     {
-        schemeBind.schemesIds[i] = (uint8_t)(PTR_TO_UINT(p_PortScheme->h_Schemes[i])-1);
+        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(p_PortScheme->h_Schemes[i]);
         /* build vector */
         tmpScmVec |= 1 << (31 - (uint32_t)schemeBind.schemesIds[i]);
     }
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
         return ERROR_CODE(E_BUSY);
+
     err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
     if (err == E_OK)
         p_FmPort->schemesPerPortVector |= tmpScmVec;
+#ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
+
+    if ((FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd)) &&
+        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
+        (p_FmPort->fmRevInfo.majorRev < 6))
+    {
+        for(i = 0; i<p_PortScheme->numOfSchemes; i++)
+            FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PortScheme->h_Schemes[i], UPDATE_KG_NIA_CC_WA, 0);
+    }
+#endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
+
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
@@ -4613,7 +4805,7 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
     schemeBind.numOfSchemes = p_PortScheme->numOfSchemes;
     for (i=0; i<schemeBind.numOfSchemes; i++)
     {
-        schemeBind.schemesIds[i] = (uint8_t)(PTR_TO_UINT(p_PortScheme->h_Schemes[i])-1);
+        schemeBind.schemesIds[i] = FmPcdKgGetSchemeId(p_PortScheme->h_Schemes[i]);
         /* build vector */
         tmpScmVec |= 1 << (31 - (uint32_t)schemeBind.schemesIds[i]);
     }
@@ -4658,7 +4850,8 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
     }
 
     /* check that current NIA is BMI to BMI */
-    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) !=
+        GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
@@ -4673,7 +4866,9 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
     WRITE_UINT32(*p_BmiNia, (uint32_t)(NIA_ENG_PRS | (uint32_t)hdrNum | tmpReg));
 
     /* set start parsing offset */
-    WRITE_UINT32(*p_BmiPrsStartOffset, (uint32_t)(p_FmPcdPrsStart->parsingOffset + p_FmPort->internalBufferOffset));
+    WRITE_UINT32(*p_BmiPrsStartOffset,
+                 (uint32_t)(p_FmPcdPrsStart->parsingOffset +
+                            p_FmPort->internalBufferOffset));
     RELEASE_LOCK(p_FmPort->lock);
 
     return E_OK;
@@ -4764,11 +4959,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
 
         {
 #ifndef FM_NO_OP_OBSERVED_POOLS
-            t_FmRevisionInfo    revInfo;
-
-            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-            if (revInfo.majorRev == 4)
-#endif /* !FM_NO_OP_OBSERVED_POOLS */
+            if (p_FmPort->fmRevInfo.majorRev == 4)
             {
                 DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi, ("fmbm_oebmpi"));
 
@@ -4778,6 +4969,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
                 }
                 DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocgm);
             }
+#endif /* !FM_NO_OP_OBSERVED_POOLS */
         }
 
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ostc);
@@ -4832,13 +5024,13 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         {
             DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], sizeof(uint32_t));
         }
-        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm, ("fmbm_cgm"));
+        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm, ("fmbm_rcgm"));
         DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_NUM_OF_CONGESTION_GRPS/32)
         {
-            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[i], sizeof(uint32_t));
+            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[i], sizeof(uint32_t));
         }
         DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_mpd);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rmpd);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rstc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfrc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfbc);
@@ -4855,7 +5047,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rduc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfuc);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rdbg);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rdcfg);
         break;
     case(2):
 
@@ -4866,7 +5058,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfp);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfed);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ticp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdne);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfca);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfqid);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfeqid);
@@ -4916,30 +5108,31 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
     bool                tmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS], opPort;
+    uint8_t             priorityTmpArray[FM_PORT_NUM_OF_CONGESTION_GRPS];
     int                 i;
     uint8_t             mod;
     uint32_t            tmpReg = 0;
+#if DPAA_VERSION >= 3
+    int                 j;
+    t_Error             err;
+#endif /* DPAA_VERSION >= 3 */
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    {
 #ifdef FM_NO_OP_OBSERVED_CGS
-        t_FmRevisionInfo    revInfo;
 
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if (revInfo.majorRev != 4)
-        {
-            if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-                    (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
-        }
-        else
-#endif /* FM_NO_OP_OBSERVED_CGS */
+    if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
+    {
         if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-                (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-                (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
+                (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
     }
+    else
+#endif /* FM_NO_OP_OBSERVED_CGS */
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+            (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
 
     opPort = (bool)((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? TRUE:FALSE);
 
@@ -4948,27 +5141,51 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
     representing each possible group. */
 
     memset(&tmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(bool));
+    memset(&priorityTmpArray, 0, FM_PORT_NUM_OF_CONGESTION_GRPS*sizeof(uint8_t));
+
     for(i=0;i<p_CongestionGrps->numOfCongestionGrpsToConsider;i++)
+    {
+
         tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
 
+#if DPAA_VERSION >= 3
+        for(j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
+        {
+            if(p_CongestionGrps->pfcPrioritiesEn[i][j])
+            {
+                priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j+1));
+            }
+        }
+#endif /* DPAA_VERSION >= 3 */
+    }
     for(i=0;i<FM_PORT_NUM_OF_CONGESTION_GRPS;i++)
     {
         mod = (uint8_t)(i%32);
         /* each 32 congestion groups are represented by a register */
         if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
-            tmpReg = opPort ?   GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
-                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[7-i/32]);
+            tmpReg = opPort ? GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
+                              GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32]);
 
         /* set in the register, the bit representing the relevant congestion group. */
+
         if(tmpArray[i])
+        {
+
             tmpReg |=  (0x00000001 << (uint32_t)mod);
 
+#if DPAA_VERSION >= 3
+            err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm,i,priorityTmpArray[i]);
+            if (err)
+                return err;
+#endif /* DPAA_VERSION >= 3 */
+        }
+
         if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
         {
-            if(opPort)
+            if (opPort)
                 WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
             else
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[7-i/32], tmpReg);
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32], tmpReg);
         }
     }
 
@@ -4985,24 +5202,20 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    {
 #ifdef FM_NO_OP_OBSERVED_CGS
-        t_FmRevisionInfo    revInfo;
-
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if (revInfo.majorRev != 4)
-        {
-            if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-                    (p_FmPort->portType != e_FM_PORT_TYPE_RX))
-                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
-        }
-        else
+    if ((p_FmPort->fmRevInfo.majorRev != 4) &&
+        (p_FmPort->fmRevInfo.majorRev < 6))
+    {
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+                (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx ports only"));
+    }
+    else
 #endif /* FM_NO_OP_OBSERVED_CGS */
-        if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
-                (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
-                (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+            (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Available for Rx & OP ports only"));
-    }
 
     opPort = (bool)((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? TRUE:FALSE);
 
@@ -5019,79 +5232,30 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
         /* each 32 congestion groups are represented by a register */
         if (mod == 0) /* first in a 32 bunch of congestion groups, get the currest register state  */
             tmpReg = opPort ?   GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm):
-                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[7-i/32]);
+                                GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32]);
 
         /* set in the register, the bit representing the relevant congestion group. */
         if(tmpArray[i])
+        {
             tmpReg &=  ~(0x00000001 << (uint32_t)mod);
 
+#if DPAA_VERSION >= 3
+            {
+                t_Error err = FmSetCongestionGroupPFCpriority(p_FmPort->h_Fm, i, 0);
+                if (err)
+                    return err;
+            }
+#endif /* DPAA_VERSION >= 3 */
+        }
         if (mod == 31) /* last in a 32 bunch of congestion groups - write the corresponding register */
         {
             if(opPort)
                 WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocgm, tmpReg);
             else
-                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_cgm[7-i/32], tmpReg);
+                WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[7-i/32], tmpReg);
         }
     }
 
     return  E_OK;
 }
 
-#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
-t_Error FM_PORT_SetOpWorkarounds(t_Handle h_FmPort, fmOpPortWorkaroundsSelect_t workarounds)
-{
-    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-
-    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for OP ports only"));
-
-#ifdef FM_DISABLE_SEC_ERRORS
-    if (workarounds & FM_OP_PORT_WA_SEC_ERR)
-    {
-        t_Error                 err;
-        t_FmPortGetSetCcParams  fmPortGetSetCcParams;
-
-        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
-        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_NO_PCD);
-
-        memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
-        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
-        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_FETCH | NIA_ENG_FM_CTL);
-        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-    }
-#endif /* FM_DISABLE_SEC_ERRORS */
-#ifdef FM_DISABLE_UDP_CHECKSUM_AFTER_SEC
-    if (workarounds & FM_OP_PORT_WA_DISABLE_UDP_CKSM)
-    {
-        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
-        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD);
-    }
-#endif /* FM_DISABLE_UDP_CHECKSUM_AFTER_SEC */
-#ifdef FM_ETH_TYPE_FIX
-    if (workarounds & FM_OP_PORT_WA_ETH_TYPE)
-    {
-        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
-        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD);
-    }
-#endif /* FM_ETH_TYPE_FIX */
-#ifdef FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
-    if (workarounds & FM_OP_PORT_WA_COPY_CTXB)
-    {
-        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
-        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD);
-    }
-#endif /* FM_NO_CTXA_COPY_ERRATA_FMAN_SW001 */
-#ifdef FM_UPDATE_UDP_LENGTH_AFTER_SEC
-    if (workarounds & FM_OP_PORT_WA_UPDATE_UDP_LEN)
-    {
-        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
-        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN);
-    }
-#endif /* FM_UPDATE_UDP_LENGTH_AFTER_SEC */
-
-    return E_OK;
-}
-#endif /* FM_IPSEC_SUPPORT  || FM_IP_FRAG_N_REASSEM_SUPPORT*/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 3151fe4..515636e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -43,6 +43,7 @@
 #include "fm_port_ext.h"
 
 #include "fm_common.h"
+#include "fm_sp_common.h"
 
 
 #define __ERR_MODULE__  MODULE_FM_PORT
@@ -65,32 +66,35 @@
 #define DEFAULT_PORT_deqHighPriority_1G                 FALSE
 #define DEFAULT_PORT_deqHighPriority_10G                TRUE
 #define DEFAULT_PORT_deqType                            e_FM_PORT_DEQ_TYPE1
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 #define DEFAULT_PORT_deqPrefetchOption                  e_FM_PORT_DEQ_FULL_PREFETCH
 #define DEFAULT_PORT_deqPrefetchOption_HC               e_FM_PORT_DEQ_NO_PREFETCH
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 #define DEFAULT_PORT_deqByteCnt_10G                     0x1400
 #define DEFAULT_PORT_deqByteCnt_1G                      0x400
-#define DEFAULT_PORT_bufferPrefixContent_privDataSize   0
-#define DEFAULT_PORT_bufferPrefixContent_passPrsResult  FALSE
-#define DEFAULT_PORT_bufferPrefixContent_passTimeStamp  FALSE
-#define DEFAULT_PORT_bufferPrefixContent_allOtherPCDInfo    FALSE
-#define DEFAULT_PORT_bufferPrefixContent_dataAlign      DATA_ALIGNMENT
+#define DEFAULT_PORT_bufferPrefixContent_privDataSize   DEFAULT_FM_SP_bufferPrefixContent_privDataSize
+#define DEFAULT_PORT_bufferPrefixContent_passPrsResult  DEFAULT_FM_SP_bufferPrefixContent_passPrsResult
+#define DEFAULT_PORT_bufferPrefixContent_passTimeStamp  DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp
+#define DEFAULT_PORT_bufferPrefixContent_allOtherPCDInfo DEFAULT_FM_SP_bufferPrefixContent_allOtherPCDInfo
+#define DEFAULT_PORT_bufferPrefixContent_dataAlign      DEFAULT_FM_SP_bufferPrefixContent_dataAlign
 #define DEFAULT_PORT_cheksumLastBytesIgnore             0
 #define DEFAULT_PORT_cutBytesFromEnd                    4
 #define DEFAULT_PORT_txFifoMinFillLevel                 0
-#define DEFAULT_PORT_txFifoDeqPipelineDepth_IM          2
-#define DEFAULT_PORT_txFifoDeqPipelineDepth_1G          1
-#define DEFAULT_PORT_txFifoDeqPipelineDepth_10G         4
+#define DEFAULT_PORT_fifoDeqPipelineDepth_IM            2
+#define DEFAULT_PORT_fifoDeqPipelineDepth_1G            1
+#define DEFAULT_PORT_fifoDeqPipelineDepth_10G           4
+#define DEFAULT_PORT_fifoDeqPipelineDepth_OH            2
+
 #define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
 #define DEFAULT_PORT_rxFifoPriElevationLevel            BMI_MAX_FIFO_SIZE
 #define DEFAULT_PORT_rxFifoThreshold                    (BMI_MAX_FIFO_SIZE*3/4)
 #define DEFAULT_PORT_frmDiscardOverride                 FALSE
-#define DEFAULT_PORT_dmaSwapData                        e_FM_PORT_DMA_NO_SWP
-#define DEFAULT_PORT_dmaIntContextCacheAttr             e_FM_PORT_DMA_NO_STASH
-#define DEFAULT_PORT_dmaHeaderCacheAttr                 e_FM_PORT_DMA_NO_STASH
-#define DEFAULT_PORT_dmaScatterGatherCacheAttr          e_FM_PORT_DMA_NO_STASH
-#define DEFAULT_PORT_dmaWriteOptimize                   TRUE
+
+#define DEFAULT_PORT_dmaSwapData                        DEFAULT_FM_SP_dmaSwapData
+#define DEFAULT_PORT_dmaIntContextCacheAttr             DEFAULT_FM_SP_dmaIntContextCacheAttr
+#define DEFAULT_PORT_dmaHeaderCacheAttr                 DEFAULT_FM_SP_dmaHeaderCacheAttr
+#define DEFAULT_PORT_dmaScatterGatherCacheAttr          DEFAULT_FM_SP_dmaScatterGatherCacheAttr
+#define DEFAULT_PORT_dmaWriteOptimize                   DEFAULT_FM_SP_dmaWriteOptimize
+
+#define DEFAULT_PORT_noScatherGather                    DEFAULT_FM_SP_noScatherGather
 #define DEFAULT_PORT_forwardIntContextReuse             FALSE
 #define DEFAULT_PORT_BufMargins_startMargins            32
 #define DEFAULT_PORT_BufMargins_endMargins              0
@@ -103,6 +107,8 @@
 #define DEFAULT_PORT_exception                          IM_EV_BSY
 #define DEFAULT_PORT_maxFrameLength                     9600
 
+#define DEFAULT_notSupported                            0xff
+
 /* Host command port MUST NOT be changed to more than 1 !!! */
 #define DEFAULT_PORT_numOfTasks(type)                       \
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
@@ -118,9 +124,9 @@
                  ((type) == e_FM_PORT_TYPE_TX) ||           \
                  ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 2 : 0))
 
-#define DEFAULT_PORT_numOfOpenDmas(type)                  \
+#define DEFAULT_PORT_numOfOpenDmas(type, rev)                  \
     (uint32_t)((((type) == e_FM_PORT_TYPE_TX_10G) ||      \
-                ((type) == e_FM_PORT_TYPE_RX_10G)) ? 8 : 1)
+                ((type) == e_FM_PORT_TYPE_RX_10G)) ? 8 : ((rev>=6) ? 2 : 1))
 
 #define DEFAULT_PORT_extraNumOfOpenDmas(type)               \
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
@@ -129,19 +135,32 @@
                  ((type) == e_FM_PORT_TYPE_TX) ||           \
                  ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 1 : 0))
 
-#define DEFAULT_PORT_sizeOfFifo(type)                                   \
-    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||                    \
-                ((type) == e_FM_PORT_TYPE_TX_10G)) ? (16*KILOBYTE) :    \
-               ((((type) == e_FM_PORT_TYPE_RX) ||                       \
-                 ((type) == e_FM_PORT_TYPE_TX) ||                       \
-                 ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? (4*KILOBYTE) : (1536)))
+#define DEFAULT_PORT_numOfFifoBufs(type)                    \
+    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
+                ((type) == e_FM_PORT_TYPE_TX_10G)) ? 48 :   \
+               ((((type) == e_FM_PORT_TYPE_RX) ||           \
+                 ((type) == e_FM_PORT_TYPE_TX)) ? 44 : 8))
+
+#define DEFAULT_PORT_extraNumOfFifoBufs             0
 
 #define DEFAULT_PORT_txBdRingLength                 16
 #define DEFAULT_PORT_rxBdRingLength                 128
 #define DEFAULT_PORT_ImfwExtStructsMemId            0
 #define DEFAULT_PORT_ImfwExtStructsMemAttr          MEMORY_ATTR_CACHEABLE
 
-#define OH_PIPELINE_DEPTH                           2
+/**************************************************************************//**
+ @Collection    PCD Engines
+*//***************************************************************************/
+typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
+
+#define FM_PCD_NONE                                 0                   /**< No PCD Engine indicated */
+#define FM_PCD_PRS                                  0x80000000          /**< Parser indicated */
+#define FM_PCD_KG                                   0x40000000          /**< Keygen indicated */
+#define FM_PCD_CC                                   0x20000000          /**< Coarse classification indicated */
+#define FM_PCD_PLCR                                 0x10000000          /**< Policer indicated */
+#define FM_PCD_MANIP                                0x08000000          /**< Manipulation indicated */
+/* @} */
+
 
 /**************************************************************************//**
  @Description       Memory Mapped Registers
@@ -150,7 +169,6 @@
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 #define FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS   8
 #define FM_PORT_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS 256
@@ -172,7 +190,7 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rpp;       /**< Rx Policer Profile  */
     volatile uint32_t   fmbm_rccb;      /**< Rx Coarse Classification Base */
     volatile uint32_t   fmbm_reth;      /**< Rx Excessive Threshold */
-    volatile uint32_t   reserved1[1];   /**< (0x03C 0x03F) */
+    volatile uint32_t   reserved1[0x01];/**< (0x03C) */
     volatile uint32_t   fmbm_rprai[FM_PORT_PRS_RESULT_NUM_OF_WORDS];
                                         /**< Rx Parse Results Array Initialization*/
     volatile uint32_t   fmbm_rfqid;     /**< Rx Frame Queue ID*/
@@ -180,17 +198,19 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rfsdm;     /**< Rx Frame Status Discard Mask*/
     volatile uint32_t   fmbm_rfsem;     /**< Rx Frame Status Error Mask*/
     volatile uint32_t   fmbm_rfene;     /**< Rx Frame Enqueue Next Engine */
-    volatile uint32_t   reserved2[0x23];/**< (0x074 0x0FF)  */
+    volatile uint32_t   reserved2[0x02];/**< (0x074 0x078)  */
+    volatile uint32_t   fmbm_rcmne;     /**< Rx Frame Continuous Mode Next Engine */
+    volatile uint32_t   reserved3[0x20];/**< (0x080 0x0FF)  */
     volatile uint32_t   fmbm_ebmpi[FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS];
                                         /**< Buffer Manager pool Information-*/
     volatile uint32_t   fmbm_acnt[FM_PORT_MAX_NUM_OF_EXT_POOLS_ALL_INTEGRATIONS];
                                         /**< Allocate Counter-*/
-    volatile uint32_t   reserved3[8];
+    volatile uint32_t   reserved4[0x08];
                                         /**< 0x130/0x140 - 0x15F reserved -*/
-    volatile uint32_t   fmbm_cgm[FM_PORT_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS/32];
+    volatile uint32_t   fmbm_rcgm[FM_PORT_NUM_OF_CONGESTION_GRPS_ALL_INTEGRATIONS/32];
                                         /**< Congestion Group Map*/
-    volatile uint32_t   fmbm_mpd;       /**< BM Pool Depletion  */
-    volatile uint32_t   reserved4[0x1F];/**< (0x184 0x1FF) */
+    volatile uint32_t   fmbm_rmpd;      /**< BM Pool Depletion  */
+    volatile uint32_t   reserved5[0x1F];/**< (0x184 0x1FF) */
     volatile uint32_t   fmbm_rstc;      /**< Rx Statistics Counters*/
     volatile uint32_t   fmbm_rfrc;      /**< Rx Frame Counter*/
     volatile uint32_t   fmbm_rfbc;      /**< Rx Bad Frames Counter*/
@@ -200,7 +220,8 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rfldec;    /**< Rx Frames List DMA Error Counter*/
     volatile uint32_t   fmbm_rodc;      /**< Rx Out of Buffers Discard Counter-*/
     volatile uint32_t   fmbm_rbdc;      /**< Rx Buffers Deallocate Counter-*/
-    volatile uint32_t   reserved5[0x17];/**< (0x224 0x27F) */
+    volatile uint32_t   fmbm_rpec;      /**< Rx RX Prepare to enqueue Counter-*/
+    volatile uint32_t   reserved6[0x16];/**< (0x228 0x27F) */
     volatile uint32_t   fmbm_rpc;       /**< Rx Performance Counters*/
     volatile uint32_t   fmbm_rpcp;      /**< Rx Performance Count Parameters*/
     volatile uint32_t   fmbm_rccn;      /**< Rx Cycle Counter*/
@@ -209,8 +230,10 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rduc;      /**< Rx DMA Utilization Counter*/
     volatile uint32_t   fmbm_rfuc;      /**< Rx FIFO Utilization Counter*/
     volatile uint32_t   fmbm_rpac;      /**< Rx Pause Activation Counter*/
-    volatile uint32_t   reserved6[0x18];/**< (0x2A0 0x2FF) */
-    volatile uint32_t   fmbm_rdbg;      /**< Rx Debug-*/
+    volatile uint32_t   reserved7[0x18];/**< (0x2A0-0x2FF) */
+    volatile uint32_t   fmbm_rdcfg;     /**< Rx Debug-*/
+    volatile uint32_t   fmbm_rgpr;      /**< TODO */
+    volatile uint32_t   reserved8[0x3c];/**< (0x310-0x3FF) */
 } _PackedType t_FmPortRxBmiRegs;
 
 typedef _Packed struct
@@ -221,21 +244,26 @@ typedef _Packed struct
     volatile uint32_t   fmbm_tfp;       /**< Tx FIFO Parameters */
     volatile uint32_t   fmbm_tfed;      /**< Tx Frame End Data */
     volatile uint32_t   fmbm_ticp;      /**< Tx Internal Context Parameters */
-    volatile uint32_t   fmbm_tfne;      /**< Tx Frame Next Engine. */
+    volatile uint32_t   fmbm_tfdne;     /**< Tx Frame Dequeue Next Engine. */
     volatile uint32_t   fmbm_tfca;      /**< Tx Frame Command attribute. */
     volatile uint32_t   fmbm_tcfqid;    /**< Tx Confirmation Frame Queue ID. */
     volatile uint32_t   fmbm_tfeqid;    /**< Tx Frame Error Queue ID */
     volatile uint32_t   fmbm_tfene;     /**< Tx Frame Enqueue Next Engine */
     volatile uint32_t   fmbm_trlmts;    /**< Tx Rate Limiter Scale */
     volatile uint32_t   fmbm_trlmt;     /**< Tx Rate Limiter */
-    volatile uint32_t   reserved0[0x73];/**< (0x038-0x200) */
+    volatile uint32_t   fmbm_tccb;      /**< Tx Coarse Classification Base */
+    volatile uint32_t   reserved0[0x0e];/**< (0x038-0x070) */
+    volatile uint32_t   fmbm_tfne;      /**< Tx Frame Next Engine */
+    volatile uint32_t   reserved1[0x02];/**< (0x074-0x7C) */
+    volatile uint32_t   fmbm_tcmne;     /**< Tx Frame Continuous Mode Next Engine */
+    volatile uint32_t   reserved2[0x60];/**< (0x080-0x200) */
     volatile uint32_t   fmbm_tstc;      /**< Tx Statistics Counters */
     volatile uint32_t   fmbm_tfrc;      /**< Tx Frame Counter */
     volatile uint32_t   fmbm_tfdc;      /**< Tx Frames Discard Counter */
     volatile uint32_t   fmbm_tfledc;    /**< Tx Frame Length error discard counter */
     volatile uint32_t   fmbm_tfufdc;    /**< Tx Frame unsupported format discard Counter */
     volatile uint32_t   fmbm_tbdc;      /**< Tx Buffers Deallocate Counter */
-    volatile uint32_t   reserved1[0x1A];/**< (0x218-0x280) */
+    volatile uint32_t   reserved3[0x1A];/**< (0x218-0x280) */
     volatile uint32_t   fmbm_tpc;       /**< Tx Performance Counters*/
     volatile uint32_t   fmbm_tpcp;      /**< Tx Performance Count Parameters*/
     volatile uint32_t   fmbm_tccn;      /**< Tx Cycle Counter*/
@@ -243,6 +271,10 @@ typedef _Packed struct
     volatile uint32_t   fmbm_ttcquc;    /**< Tx Transmit Confirm Queue Utilization Counter*/
     volatile uint32_t   fmbm_tduc;      /**< Tx DMA Utilization Counter*/
     volatile uint32_t   fmbm_tfuc;      /**< Tx FIFO Utilization Counter*/
+    volatile uint32_t   reserved4[16];  /**< (0x29C-0x2FF) */
+    volatile uint32_t   fmbm_tdcfg;     /**< Tx Debug-*/
+    volatile uint32_t   fmbm_tgpr;      /**< TODO */
+    volatile uint32_t   reserved5[0x3c];/**< (0x310-0x3FF) */
 } _PackedType t_FmPortTxBmiRegs;
 
 typedef _Packed struct
@@ -259,7 +291,9 @@ typedef _Packed struct
     volatile uint32_t   fmbm_opp;       /**< O/H Policer Profile */
     volatile uint32_t   fmbm_occb;      /**< O/H Coarse Classification base */
     volatile uint32_t   fmbm_oim;       /**< O/H Internal margins*/
-    volatile uint32_t   reserved0[4];   /**< (0x030 - 0x03F) */
+    volatile uint32_t   fmbm_ofp;       /**< O/H Fifo Parameters*/
+    volatile uint32_t   fmbm_ofed;      /**< O/H Frame End Data*/
+    volatile uint32_t   reserved0[2];   /**< (0x038 - 0x03F) */
     volatile uint32_t   fmbm_oprai[FM_PORT_PRS_RESULT_NUM_OF_WORDS];
                                         /**< O/H Parse Results Array Initialization  */
     volatile uint32_t   fmbm_ofqid;     /**< O/H Frame Queue ID  */
@@ -269,16 +303,14 @@ typedef _Packed struct
     volatile uint32_t   fmbm_ofene;     /**< O/H Frame Enqueue Next Engine  */
     volatile uint32_t   fmbm_orlmts;    /**< O/H Rate Limiter Scale  */
     volatile uint32_t   fmbm_orlmt;     /**< O/H Rate Limiter  */
-    volatile uint32_t   reserved0a[0x21];
-                                        /**< 0x07C - 0x0FF Reserved */
+    volatile uint32_t   fmbm_ocmne;     /**< O/H Continuous Mode Next Engine  */
+    volatile uint32_t   reserved1[0x20];/**< (0x080 - 0x0FF) */
     volatile uint32_t   fmbm_oebmpi[2]; /**< Buffer Manager Observed Pool Information */
-    volatile uint32_t   reserved0b[0x16];
-                                        /**< 0x108 - 0x15F Reserved */
+    volatile uint32_t   reserved2[0x16];/**< (0x108 - 0x15F) */
     volatile uint32_t   fmbm_ocgm;      /**< Observed Congestion Group Map */
-    volatile uint32_t   reserved0c[0x7];/**< 0x164 - 0x17F Reserved */
+    volatile uint32_t   reserved3[0x7]; /**< (0x164 - 0x17F) */
     volatile uint32_t   fmbm_ompd;      /**< Observed BMan Pool Depletion */
-    volatile uint32_t   reserved0d[0x1F];
-                                        /**< 0x184 - 0x1FF Reserved */
+    volatile uint32_t   reserved4[0x1F];/**< (0x184 - 0x1FF) */
     volatile uint32_t   fmbm_ostc;      /**< O/H Statistics Counters  */
     volatile uint32_t   fmbm_ofrc;      /**< O/H Frame Counter  */
     volatile uint32_t   fmbm_ofdc;      /**< O/H Frames Discard Counter  */
@@ -288,13 +320,19 @@ typedef _Packed struct
     volatile uint32_t   fmbm_ofwdc;     /**< - Rx Frames WRED Discard Counter  */
     volatile uint32_t   fmbm_ofldec;    /**< O/H Frames List DMA Error Counter */
     volatile uint32_t   fmbm_obdc;      /**< O/H Buffers Deallocate Counter */
-    volatile uint32_t   reserved2[0x17];/**< (0x218 - 0x27F) */
+    volatile uint32_t   fmbm_oodc;      /**< O/H Out of Buffers Discard Counter */
+    volatile uint32_t   fmbm_opec;      /**< O/H Prepare to enqueue Counter */
+    volatile uint32_t   reserved5[0x15];/**< ( - 0x27F) */
     volatile uint32_t   fmbm_opc;       /**< O/H Performance Counters  */
     volatile uint32_t   fmbm_opcp;      /**< O/H Performance Count Parameters  */
     volatile uint32_t   fmbm_occn;      /**< O/H Cycle Counter  */
     volatile uint32_t   fmbm_otuc;      /**< O/H Tasks Utilization Counter  */
     volatile uint32_t   fmbm_oduc;      /**< O/H DMA Utilization Counter */
     volatile uint32_t   fmbm_ofuc;      /**< O/H FIFO Utilization Counter */
+    volatile uint32_t   reserved6[17];  /**< (0x298-0x2FF) */
+    volatile uint32_t   fmbm_odcfg;     /**< O/H Debug-*/
+    volatile uint32_t   fmbm_ogpr;      /**< TODO */
+    volatile uint32_t   reserved7[0x3c];/**< (0x310 0x3FF) */
 } _PackedType t_FmPortOhBmiRegs;
 
 typedef _Packed union
@@ -373,7 +411,6 @@ typedef _Packed struct
     volatile uint8_t    reserved1[0xa0];    /**< 0x60 - 0xff */
 } _PackedType t_FmPortImPram;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -386,13 +423,20 @@ typedef _Packed struct
 /**************************************************************************//**
  @Description       BMI defines
 *//***************************************************************************/
+#if DPAA_VERSION >= 3
+#define BMI_SP_ID_MASK                          0xff000000
+#define BMI_SP_ID_SHIFT                         24
+#define BMI_SP_EN                               0x01000000
+#endif /* DPAA_VERSION >= 3 */
+
 #define BMI_PORT_CFG_EN                         0x80000000
 #define BMI_PORT_CFG_EN_MACSEC                  0x00800000
 #define BMI_PORT_CFG_FDOVR                      0x02000000
 #define BMI_PORT_CFG_IM                         0x01000000
 #define BMI_PORT_STATUS_BSY                     0x80000000
 #define BMI_COUNTERS_EN                         0x80000000
-#define BMI_DMA_ATTR_WRITE_OPTIMIZE             0x00100000
+#define BMI_DMA_ATTR_WRITE_OPTIMIZE             FM_SP_DMA_ATTR_WRITE_OPTIMIZE
+
 #define BMI_PORT_RFNE_FRWD_DCL4C                0x10000000
 #define BMI_PORT_RFNE_FRWD_RPD                  0x40000000
 #define BMI_RFNE_FDCS_MASK                      0xFF000000
@@ -413,9 +457,11 @@ typedef _Packed struct
 #define BMI_CMD_ATTR_MACCMD_SECURED             0x00001000
 #define BMI_CMD_ATTR_MACCMD_SC_MASK             0x00000f00
 
-#define BMI_EXT_BUF_POOL_VALID                  0x80000000
-#define BMI_EXT_BUF_POOL_EN_COUNTER             0x40000000
-#define BMI_EXT_BUF_POOL_BACKUP                 0x20000000
+#define BMI_EXT_BUF_POOL_EN_COUNTER             FM_SP_EXT_BUF_POOL_EN_COUNTER
+#define BMI_EXT_BUF_POOL_VALID                  FM_SP_EXT_BUF_POOL_VALID
+
+#define BMI_EXT_BUF_POOL_BACKUP                 FM_SP_EXT_BUF_POOL_BACKUP
+
 #define BMI_EXT_BUF_POOL_ID_MASK                0x003F0000
 #define BMI_STATUS_RX_MASK_UNUSED               (uint32_t)(~(FM_PORT_FRM_ERR_DMA                    | \
                                                              FM_PORT_FRM_ERR_PHYSICAL               | \
@@ -450,7 +496,6 @@ typedef _Packed struct
 #define BMI_PRS_RESULT_LOW                      0xFFFFFFFF
 
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
 #define RX_ERRS_TO_ENQ                          (FM_PORT_FRM_ERR_DMA                    | \
                                                  FM_PORT_FRM_ERR_PHYSICAL               | \
                                                  FM_PORT_FRM_ERR_SIZE                   | \
@@ -466,22 +511,7 @@ typedef _Packed struct
                                                  FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW       | \
                                                  FM_PORT_FRM_ERR_IPRE                   | \
                                                  FM_PORT_FRM_ERR_IPFE)
-#else
-#define RX_ERRS_TO_ENQ                          (FM_PORT_FRM_ERR_DMA                    | \
-                                                 FM_PORT_FRM_ERR_PHYSICAL               | \
-                                                 FM_PORT_FRM_ERR_SIZE                   | \
-                                                 FM_PORT_FRM_ERR_EXTRACTION             | \
-                                                 FM_PORT_FRM_ERR_NO_SCHEME              | \
-                                                 FM_PORT_FRM_ERR_ILL_PLCR               | \
-                                                 FM_PORT_FRM_ERR_PLCR_FRAME_LEN         | \
-                                                 FM_PORT_FRM_ERR_PRS_TIMEOUT            | \
-                                                 FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT       | \
-                                                 FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED   | \
-                                                 FM_PORT_FRM_ERR_PRS_HDR_ERR            | \
-                                                 FM_PORT_FRM_ERR_PROCESS_TIMEOUT        | \
-                                                 FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW)
 
-#endif
 #ifdef FM_DISABLE_SEC_ERRORS
 #define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
                                                  FM_PORT_FRM_ERR_LENGTH                 | \
@@ -496,10 +526,10 @@ typedef _Packed struct
 
 /* shifts */
 #define BMI_PORT_CFG_MS_SEL_SHIFT               16
-#define BMI_DMA_ATTR_SWP_SHIFT                  30
-#define BMI_DMA_ATTR_IC_CACHE_SHIFT             28
-#define BMI_DMA_ATTR_HDR_CACHE_SHIFT            26
-#define BMI_DMA_ATTR_SG_CACHE_SHIFT             24
+#define BMI_DMA_ATTR_SWP_SHIFT                  FM_SP_DMA_ATTR_SWP_SHIFT
+#define BMI_DMA_ATTR_IC_CACHE_SHIFT             FM_SP_DMA_ATTR_IC_CACHE_SHIFT
+#define BMI_DMA_ATTR_HDR_CACHE_SHIFT            FM_SP_DMA_ATTR_HDR_CACHE_SHIFT
+#define BMI_DMA_ATTR_SG_CACHE_SHIFT             FM_SP_DMA_ATTR_SG_CACHE_SHIFT
 
 #define BMI_IM_FOF_SHIFT                        28
 #define BMI_PR_PORTID_SHIFT                     24
@@ -510,14 +540,15 @@ typedef _Packed struct
 #define BMI_RX_FRAME_END_CS_IGNORE_SHIFT        24
 #define BMI_RX_FRAME_END_CUT_SHIFT              16
 
-#define BMI_IC_TO_EXT_SHIFT                     16
-#define BMI_IC_FROM_INT_SHIFT                   8
-#define BMI_IC_SIZE_SHIFT                       0
+#define BMI_IC_TO_EXT_SHIFT                     FM_SP_IC_TO_EXT_SHIFT
+#define BMI_IC_FROM_INT_SHIFT                   FM_SP_IC_FROM_INT_SHIFT
+#define BMI_IC_SIZE_SHIFT                       FM_SP_IC_SIZE_SHIFT
 
 #define BMI_INT_BUF_MARG_SHIFT                  28
 
-#define BMI_EXT_BUF_MARG_START_SHIFT            16
-#define BMI_EXT_BUF_MARG_END_SHIFT              0
+#define BMI_EXT_BUF_MARG_START_SHIFT            FM_SP_EXT_BUF_MARG_START_SHIFT
+#define BMI_SG_DISABLE                          FM_SP_SG_DISABLE
+#define BMI_EXT_BUF_MARG_END_SHIFT              FM_SP_EXT_BUF_MARG_END_SHIFT
 
 #define BMI_CMD_ATTR_COLOR_SHIFT                26
 #define BMI_CMD_ATTR_COM_MODE_SHIFT             16
@@ -526,16 +557,15 @@ typedef _Packed struct
 #define BMI_CMD_ATTR_MACCMD_SECURED_SHIFT       12
 #define BMI_CMD_ATTR_MACCMD_SC_SHIFT            8
 
-#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT         16
+#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT         FM_SP_POOL_DEP_NUM_OF_POOLS_SHIFT
 #define BMI_POOL_DEP_NUM_OF_POOLS_VECTOR_SHIFT  24
 
-#define BMI_EXT_BUF_POOL_ID_SHIFT               16
-
+#define BMI_EXT_BUF_POOL_ID_SHIFT               FM_SP_EXT_BUF_POOL_ID_SHIFT
 #define BMI_TX_FIFO_MIN_FILL_SHIFT              16
-#define BMI_TX_FIFO_PIPELINE_DEPTH_SHIFT        12
+#define BMI_FIFO_PIPELINE_DEPTH_SHIFT        	12
 #define BMI_TX_LOW_COMF_SHIFT                   0
 
-#define BMI_TX_FRAME_END_CS_IGNORE_SHIFT        24
+#define BMI_FRAME_END_CS_IGNORE_SHIFT        	24
 
 #define BMI_PERFORMANCE_TASK_COMP_SHIFT         24
 #define BMI_PERFORMANCE_PORT_COMP_SHIFT         16
@@ -547,13 +577,8 @@ typedef _Packed struct
 
 /* sizes */
 #define FRAME_END_DATA_SIZE                     16
-#define OFFSET_UNITS                            16
 #define FRAME_OFFSET_UNITS                      16
-#define MAX_EXT_OFFSET                          496
-#define MAX_EXT_BUFFER_OFFSET                   511
-#define MAX_INT_OFFSET                          240
 #define MIN_TX_INT_OFFSET                       16
-#define MAX_IC_SIZE                             256
 #define MAX_FRAME_OFFSET                        64
 #define MAX_FIFO_PIPELINE_DEPTH                 8
 #define MAX_PERFORMANCE_TASK_COMP               64
@@ -565,7 +590,7 @@ typedef _Packed struct
 #define MAX_NUM_OF_DMAS                         16
 #define MAX_NUM_OF_EXTRA_DMAS                   8
 #define MAX_BURST_SIZE                          1024
-#define CAPWAP_FRAG_EXTRA_SPACE                 32
+#define MIN_NUM_OF_OP_DMAS                      2
 
 /**************************************************************************//**
  @Description       QMI defines
@@ -601,7 +626,7 @@ typedef _Packed struct
 #define PRS_TPID_DFLT                           0x91009100
 
 #define PRS_HDR_MPLS_LBL_INTER_EN               0x00200000
-#define PRS_HDR_IPV6_ROUTE_HDR_DIS              0x00008000
+#define PRS_HDR_IPV6_ROUTE_HDR_EN              	0x00008000
 #define PRS_HDR_PPPOE_MTU_CHECK_EN              0x80000000
 #define PRS_HDR_UDP_PAD_REMOVAL                 0x80000000
 #define PRS_HDR_TCP_PAD_REMOVAL                 0x80000000
@@ -643,10 +668,6 @@ typedef _Packed struct
 #define SCTP_SW_PATCH_START                     0x4D
 #define DCCP_SW_PATCH_START                     0x41
 
-#define IP_FRAG_SW_PATCH_IPv4                   0x300
-#define IP_FRAG_SW_PATCH_IPv6_0                 0x31E
-#define IP_FRAG_SW_PATCH_IPv6_1                 0x364
-
 /**************************************************************************//**
  @Description       IM defines
 *//***************************************************************************/
@@ -716,36 +737,6 @@ typedef struct {
     t_FmPortImTxConfCallback    *f_TxConf;
 } t_FmMacIm;
 
-/**************************************************************************//**
- @Description   structure for defining internal context copying
-*//***************************************************************************/
-typedef struct
-{
-    uint16_t    extBufOffset;       /**< Offset in External buffer to which internal
-                                         context is copied to (Rx) or taken from (Tx, Op). */
-    uint8_t     intContextOffset;   /**< Offset within internal context to copy from
-                                         (Rx) or to copy to (Tx, Op). */
-    uint16_t    size;               /**< Internal offset size to be copied */
-} t_FmPortIntContextDataCopy;
-
-/**************************************************************************//**
- @Description   struct for defining external buffer margins
-*//***************************************************************************/
-typedef struct {
-    uint16_t    startMargins;           /**< Number of bytes to be left at the beginning
-                                             of the external buffer (must be divisible by 16) */
-    uint16_t    endMargins;             /**< number of bytes to be left at the end
-                                             of the external buffer(must be divisible by 16) */
-} t_FmPortBufMargins;
-
-typedef struct {
-    uint32_t      dataOffset;
-    uint32_t      prsResultOffset;
-    uint32_t      timeStampOffset;
-    uint32_t      hashResultOffset;
-    uint32_t      pcdInfoOffset;
-    uint32_t      manipOffset;
-} t_FmPortBufferOffsets;
 
 typedef struct {
     uint32_t                            dfltFqid;
@@ -755,13 +746,11 @@ typedef struct {
     uint8_t                             deqSubPortal;
     bool                                deqHighPriority;
     e_FmPortDeqType                     deqType;
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     e_FmPortDeqPrefetchOption           deqPrefetchOption;
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
     uint16_t                            deqByteCnt;
     uint8_t                             cheksumLastBytesIgnore;
     uint8_t                             cutBytesFromEnd;
-    t_FmPortBufPoolDepletion            bufPoolDepletion;
+    t_FmBufPoolDepletion                bufPoolDepletion;
     uint8_t                             pipelineDepth;
     uint16_t                            fifoLowComfLevel;
     bool                                frmDiscardOverride;
@@ -771,29 +760,32 @@ typedef struct {
     bool                                enBufPoolDepletion;
     uint16_t                            liodnOffset;
     uint16_t                            liodnBase;
-    t_FmPortExtPools                    extBufPools;
-    e_FmPortDmaSwap                     dmaSwapData;
-    e_FmPortDmaCache                    dmaIntContextCacheAttr;
-    e_FmPortDmaCache                    dmaHeaderCacheAttr;
-    e_FmPortDmaCache                    dmaScatterGatherCacheAttr;
+    t_FmExtPools                        extBufPools;
+    e_FmDmaSwapOption                   dmaSwapData;
+    e_FmDmaCacheOption                  dmaIntContextCacheAttr;
+    e_FmDmaCacheOption                  dmaHeaderCacheAttr;
+    e_FmDmaCacheOption                  dmaScatterGatherCacheAttr;
     bool                                dmaReadOptimize;
     bool                                dmaWriteOptimize;
     uint32_t                            txFifoMinFillLevel;
     uint32_t                            txFifoLowComfLevel;
     uint32_t                            rxFifoPriElevationLevel;
     uint32_t                            rxFifoThreshold;
-    t_FmPortBufMargins                  bufMargins;
-    t_FmPortIntContextDataCopy          intContext;
+    t_FmSpBufMargins                  bufMargins;
+    t_FmSpIntContextDataCopy            intContext;
     bool                                syncReq;
     e_FmPortColor                       color;
     fmPortFrameErrSelect_t              errorsToDiscard;
     fmPortFrameErrSelect_t              errorsToEnq;
     uint64_t                            fmMuramPhysBaseAddr;
     bool                                forwardReuseIntContext;
-    t_FmPortBufferPrefixContent         bufferPrefixContent;
-    uint8_t                             internalBufferOffset;
-    t_FmPortBackupBmPools               *p_BackupBmPools;
+    t_FmBufferPrefixContent             bufferPrefixContent;
+     t_FmBackupBmPools                   *p_BackupBmPools;
     bool                                dontReleaseBuf;
+#if DPAA_VERSION >= 3
+    bool                                noScatherGather;
+#endif /*DPAA_VERSION*/
+
 } t_FmPortDriverParam;
 
 
@@ -804,10 +796,10 @@ typedef struct t_FmPortRxPoolsParams
     uint16_t    largestBufSize;
 } t_FmPortRxPoolsParams;
 
-
 typedef struct {
     t_Handle                    h_Fm;
     t_Handle                    h_FmPcd;
+    t_FmRevisionInfo            fmRevInfo;
     uint8_t                     portId;
     e_FmPortType                portType;
     int                         enabled;
@@ -829,11 +821,11 @@ typedef struct {
     t_Handle                    ccTreeId;
     t_Handle                    completeArg;
     void                        (*f_Complete)(t_Handle arg);
-    t_FmPortBufferOffsets       bufferOffsets;
+    t_FmSpBufferOffsets         bufferOffsets;
     /* Independent-Mode parameters support */
     bool                        imEn;
     t_FmMacIm                   im;
-    uint8_t                     txFifoDeqPipelineDepth;
+    uint8_t                     fifoDeqPipelineDepth;
     volatile bool               lock;
     t_Handle                    h_Spinlock;
     t_FmPortExceptionCallback   *f_Exception;
@@ -842,12 +834,12 @@ typedef struct {
     uint8_t                     fmanCtrlEventId;
     uint32_t                    exceptions;
     bool                        polling;
-    t_FmPortExtPools            extBufPools;
+    t_FmExtPools                extBufPools;
     uint32_t                    requiredAction;
     uint32_t                    savedQmiPnen;
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    uint32_t                    savedBmiRfene;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+    uint32_t                    savedBmiFene;
+    uint32_t                    savedBmiFpne;
+    uint32_t                    savedBmiCmne;
     uint32_t                    savedNonRxQmiRegsPndn;
     int                         savedPrsStartOffset;
     uint16_t                    maxFrameLength;
@@ -856,14 +848,15 @@ typedef struct {
     t_FmPortRsrc                tasks;
     t_FmPortRsrc                fifoBufs;
     t_FmPortRxPoolsParams       rxPoolsParams;
-    t_FmPortDriverParam         *p_FmPortDriverParam;
     bool                        explicitUserSizeOfFifo;
+    t_Handle                    h_IpReassemblyManip;
+    t_Handle                    h_IpReassemblyTree;
+#if DPAA_VERSION >= 3
+    bool                        vspe;
+#endif
+    t_FmPortDriverParam         *p_FmPortDriverParam;
 } t_FmPort;
 
-#define CHECK_FM_CTL_AC_POST_FETCH_PCD(savedBmiNia) \
-    ((((savedBmiNia) & NIA_ENG_MASK) == NIA_ENG_FM_CTL) && \
-     ((((savedBmiNia) & NIA_FM_CTL_AC_POST_FETCH_PCD) == NIA_FM_CTL_AC_POST_FETCH_PCD) || \
-      (((savedBmiNia) & NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN) == NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN)))
 
 void FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams);
 t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index 607110a..e81eb1b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -314,21 +314,6 @@ t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must at least 256!!!"));
         if(p_FmPort->p_FmPortDriverParam->liodnOffset & ~FM_LIODN_OFFSET_MASK)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
-#ifdef FM_PARTITION_ARRAY
-        {
-            t_FmRevisionInfo revInfo;
-            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            {
-                if(p_FmPort->p_FmPortDriverParam->liodnOffset >= MAX_LIODN_OFFSET)
-                {
-                    p_FmPort->p_FmPortDriverParam->liodnOffset =
-                        (uint16_t)(p_FmPort->p_FmPortDriverParam->liodnOffset & (MAX_LIODN_OFFSET-1));
-                    DBG(WARNING, ("liodnOffset number is out of rev1 range - MSB bits cleard."));
-                }
-            }
-        }
-#endif /* FM_PARTITION_ARRAY */
 /* TODO - add checks */
     }
     else
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
index 890b124..27ee116 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -585,7 +585,7 @@ t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams
     WRITE_UINT32(p_MemMap->tmr_alarm[p_FmRtcAlarmParams->alarmId].tmr_alarm_h,
                  (uint32_t)(tmpAlarm >> 32));
 
-    if (p_FmRtcAlarmParams->f_AlarmCallback)
+    if(p_FmRtcAlarmParams->f_AlarmCallback)
     {
         p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].f_AlarmCallback = p_FmRtcAlarmParams->f_AlarmCallback;
         p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].clearOnExpiration = p_FmRtcAlarmParams->clearOnExpiration;
@@ -629,10 +629,10 @@ t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_
 
     WRITE_UINT32(p_MemMap->tmr_fiper[p_FmRtcPeriodicPulseParams->periodicPulseId], (uint32_t)tmpFiper);
 
-    if (p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback)
+    if(p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback)
     {
         p_Rtc->periodicPulseParams[p_FmRtcPeriodicPulseParams->periodicPulseId].f_PeriodicPulseCallback =
-            p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback;
+                                                                p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback;
 
         if(p_FmRtcPeriodicPulseParams->periodicPulseId == 0)
             tmpReg = TMR_TEVENT_PP1;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
index a3a2f30..f35dc75 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -108,7 +108,6 @@
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 /**************************************************************************//**
  @Description FM RTC timer alarm
@@ -153,7 +152,6 @@ typedef _Packed struct
     volatile uint32_t PTP_RESERVED6[3];
 } _PackedType t_FmRtcMemMap;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/Makefile
new file mode 100644
index 0000000..1765b74
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-sp.o
+
+fsl-ncsw-sp-objs	:=   fm_sp.o
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
new file mode 100644
index 0000000..706753b
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
@@ -0,0 +1,832 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_sp.c
+
+ @Description   FM PCD Storage profile  ...
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "net_ext.h"
+
+#include "fm_vsp_ext.h"
+#include "fm_sp.h"
+#include "fm_common.h"
+
+
+#if DPAA_VERSION >= 3
+#ifdef UNDER_CONSTRUCTION_FM_GEN
+static uint32_t fm_vsp_get_statistics(fm_pcd_storage_profile_regs   *regs,
+                                      uint16_t                      index)
+{
+    fm_pcd_storage_profile_regs *sp_regs;
+    ASSERT_COND(regs);
+
+    sp_regs = &regs[index];
+    return GET_UINT32(sp_regs->fm_sp_acnt);
+}
+
+static void fm_vsp_set_statistics(  fm_pcd_storage_profile_regs *regs,
+                                    uint16_t                index,
+                                    uint32_t                value)
+{
+    fm_pcd_storage_profile_regs *sp_regs;
+    ASSERT_COND(regs);
+
+    sp_regs = &regs[index];
+    WRITE_UINT32(sp_regs->fm_sp_acnt, value);
+}
+#endif /* UNDER_CONSTRUCTION_FM_GEN */
+
+static void fm_vsp_fill_entry(fm_pcd_storage_profile_regs   *regs,
+                              uint16_t                      index,
+                              fm_storage_profile_params     *fm_vsp_params)
+{
+    int i = 0, j = 0;
+    fm_pcd_storage_profile_regs *sp_regs;
+    uint32_t tmp_reg, vector;
+    t_FmExtPools *ext_buf_pools             = fm_vsp_params->fm_ext_pools;
+    t_FmBufPoolDepletion *buf_pool_depletion= fm_vsp_params->buf_pool_depletion;
+    t_FmBackupBmPools *backup_pools         = fm_vsp_params->backup_pools;
+    t_FmSpIntContextDataCopy *int_context_data_copy = fm_vsp_params->int_context;
+    t_FmSpBufMargins *external_buffer_margins = fm_vsp_params->buf_margins;
+    bool no_scather_gather                  = fm_vsp_params->no_scather_gather;
+    uint16_t    liodn_offset                = fm_vsp_params->liodn_offset;
+
+    ASSERT_COND(regs);
+    ASSERT_COND(ext_buf_pools);
+    ASSERT_COND(int_context_data_copy);
+    ASSERT_COND(external_buffer_margins);
+    ASSERT_COND(IN_RANGE(0, index, FM_VSP_MAX_NUM_OF_ENTRIES));
+
+    sp_regs = &regs[index];
+
+    /* fill external buffers manager pool information register*/
+    for (i=0;i<ext_buf_pools->numOfPoolsUsed;i++)
+    {
+        tmp_reg = FM_SP_EXT_BUF_POOL_VALID | FM_SP_EXT_BUF_POOL_EN_COUNTER;
+        tmp_reg |= ((uint32_t)ext_buf_pools->extBufPool[i].id << FM_SP_EXT_BUF_POOL_ID_SHIFT);
+        tmp_reg |= ext_buf_pools->extBufPool[i].size;
+        /* functionality available only for some deriviatives (limited by config) */
+        if (backup_pools)
+            for (j=0;j<backup_pools->numOfBackupPools;j++)
+                if (ext_buf_pools->extBufPool[i].id == backup_pools->poolIds[j])
+                {
+                    tmp_reg |= FM_SP_EXT_BUF_POOL_BACKUP;
+                    break;
+                }
+
+        WRITE_UINT32(sp_regs->fm_sp_ebmpi[i], tmp_reg);
+    }
+
+    /* clear unused pools */
+    for (i=ext_buf_pools->numOfPoolsUsed;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+        WRITE_UINT32(sp_regs->fm_sp_ebmpi[i], 0);
+
+    /* fill pool depletion register*/
+    tmp_reg = 0;
+
+    if (buf_pool_depletion && buf_pool_depletion->poolsGrpModeEnable)
+    {
+        /* calculate vector for number of pools depletion */
+        vector = 0;
+        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+            if (buf_pool_depletion->poolsToConsider[i])
+                for (j=0;j<ext_buf_pools->numOfPoolsUsed;j++)
+                    if (i == ext_buf_pools->extBufPool[j].id)
+                    {
+                        vector |= 0x80000000 >> j;
+                        break;
+                    }
+
+        /* configure num of pools and vector for number of pools mode */
+        tmp_reg |= (((uint32_t)buf_pool_depletion->numOfPools - 1) << FM_SP_POOL_DEP_NUM_OF_POOLS_SHIFT);
+        tmp_reg |= vector;
+    }
+
+    if (buf_pool_depletion && buf_pool_depletion->singlePoolModeEnable)
+    {
+        /* calculate vector for number of pools depletion */
+        vector = 0;
+        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+            if (buf_pool_depletion->poolsToConsiderForSingleMode[i])
+                for (j=0;j<ext_buf_pools->numOfPoolsUsed;j++)
+                    if (i == ext_buf_pools->extBufPool[j].id)
+                    {
+                        vector |= 0x00000080 >> j;
+                        break;
+                    }
+
+        /* configure num of pools and vector for number of pools mode */
+        tmp_reg |= vector;
+    }
+
+    /* fill QbbPEV */
+    if (buf_pool_depletion)
+    {
+        vector = 0;
+        for (i=0; i<FM_MAX_NUM_OF_PFC_PRIORITIES; i++)
+            if (buf_pool_depletion->pfcPrioritiesEn[i] == TRUE)
+                vector|= 0x00008000 >> i;
+        tmp_reg |= vector;
+    }
+    WRITE_UINT32(sp_regs->fm_sp_mpd, tmp_reg);
+
+    /* fill dma attrubutes register */
+    tmp_reg = 0;
+    tmp_reg |= (uint32_t)fm_vsp_params->dma_swap_data << FM_SP_DMA_ATTR_SWP_SHIFT;
+    tmp_reg |= (uint32_t)fm_vsp_params->int_context_cache_attr << FM_SP_DMA_ATTR_IC_CACHE_SHIFT;
+    tmp_reg |= (uint32_t)fm_vsp_params->header_cache_attr << FM_SP_DMA_ATTR_HDR_CACHE_SHIFT;
+    tmp_reg |= (uint32_t)fm_vsp_params->scatter_gather_cache_attr << FM_SP_DMA_ATTR_SG_CACHE_SHIFT;
+    if(fm_vsp_params->dma_write_optimize)
+        tmp_reg |= FM_SP_DMA_ATTR_WRITE_OPTIMIZE;
+    WRITE_UINT32(sp_regs->fm_sp_da, tmp_reg);
+
+    /* IC parameters - fill internal context parameters register */
+    tmp_reg = 0;
+    tmp_reg |= (((uint32_t)int_context_data_copy->extBufOffset/OFFSET_UNITS) << FM_SP_IC_TO_EXT_SHIFT);
+    tmp_reg |= (((uint32_t)int_context_data_copy->intContextOffset/OFFSET_UNITS) << FM_SP_IC_FROM_INT_SHIFT);
+    tmp_reg |= (((uint32_t)int_context_data_copy->size/OFFSET_UNITS)  << FM_SP_IC_SIZE_SHIFT);
+    WRITE_UINT32(sp_regs->fm_sp_icp, tmp_reg);
+
+    /* buffer margins - fill external buffer margins register */
+    tmp_reg = 0;
+    tmp_reg |= (((uint32_t)external_buffer_margins->startMargins) << FM_SP_EXT_BUF_MARG_START_SHIFT);
+    tmp_reg |= (((uint32_t)external_buffer_margins->endMargins) << FM_SP_EXT_BUF_MARG_END_SHIFT);
+    if (no_scather_gather)
+        tmp_reg |= FM_SP_SG_DISABLE;
+    WRITE_UINT32(sp_regs->fm_sp_ebm, tmp_reg);
+
+    /* buffer margins - fill spliodn register */
+    WRITE_UINT32(sp_regs->fm_sp_spliodn, liodn_offset);
+}
+
+static t_Error CheckParams(t_FmVspEntry *p_FmVspEntry)
+{
+    t_Error err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->h_Fm, E_INVALID_HANDLE);
+
+    if ((err = FmSpCheckBufPoolsParams(&p_FmVspEntry->p_FmVspEntryDriverParams->extBufPools,
+                                        p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools,
+                                        p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion)) != E_OK)
+
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if ((err = FmSpCheckIntContextParams(&p_FmVspEntry->intContext))!= E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    if ((err =  FmSpCheckBufMargins(&p_FmVspEntry->bufMargins)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if (p_FmVspEntry->p_FmVspEntryDriverParams->liodnOffset & ~FM_LIODN_OFFSET_MASK)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
+
+    return err;
+}
+#endif /* DPAA_VERSION >= 3 */
+
+
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+void FmSpSetBufPoolsInAscOrderOfBufSizes(t_FmExtPools   *p_FmExtPools,
+                                         uint8_t        *orderedArray,
+                                         uint16_t       *sizesArray)
+{
+    uint16_t                    bufSize = 0;
+    int                         i=0, j=0, k=0;
+
+    /* First we copy the external buffers pools information to an ordered local array */
+    for (i=0;i<p_FmExtPools->numOfPoolsUsed;i++)
+    {
+        /* get pool size */
+        bufSize = p_FmExtPools->extBufPool[i].size;
+
+        /* keep sizes in an array according to poolId for direct access */
+        sizesArray[p_FmExtPools->extBufPool[i].id] =  bufSize;
+
+        /* save poolId in an ordered array according to size */
+        for (j=0;j<=i;j++)
+        {
+            /* this is the next free place in the array */
+            if (j==i)
+                orderedArray[i] = p_FmExtPools->extBufPool[i].id;
+            else
+            {
+                /* find the right place for this poolId */
+                if(bufSize < sizesArray[orderedArray[j]])
+                {
+                    /* move the poolIds one place ahead to make room for this poolId */
+                    for(k=i;k>j;k--)
+                       orderedArray[k] = orderedArray[k-1];
+
+                    /* now k==j, this is the place for the new size */
+                    orderedArray[k] = p_FmExtPools->extBufPool[i].id;
+                    break;
+                }
+            }
+        }
+    }
+}
+
+// TODO - ask Ganit - SetExtBufferPools called for Rx and Op but parameters check only for Rx
+t_Error FmSpCheckBufPoolsParams(t_FmExtPools            *p_FmExtPools,
+                                t_FmBackupBmPools       *p_FmBackupBmPools,
+                                t_FmBufPoolDepletion    *p_FmBufPoolDepletion)
+{
+
+    int         i = 0, j = 0;
+    bool        found;
+    uint8_t     count = 0;
+
+    if(p_FmExtPools)
+    {
+        if(p_FmExtPools->numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", FM_PORT_MAX_NUM_OF_EXT_POOLS));
+
+        for(i=0;i<p_FmExtPools->numOfPoolsUsed;i++)
+        {
+            if(p_FmExtPools->extBufPool[i].id >= BM_MAX_NUM_OF_POOLS)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[%d].id can't be larger than %d", i, BM_MAX_NUM_OF_POOLS));
+            if(!p_FmExtPools->extBufPool[i].size)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[%d].size is 0", i));
+        }
+    }
+    if(!p_FmExtPools && (p_FmBackupBmPools || p_FmBufPoolDepletion))
+          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("backupBmPools ot bufPoolDepletion can not be defined without external pools"));
+
+    /* backup BM pools indication is valid only for some chip deriviatives
+       (limited by the config routine) */
+    if(p_FmBackupBmPools)
+    {
+        if(p_FmBackupBmPools->numOfBackupPools >= p_FmExtPools->numOfPoolsUsed)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_BackupBmPools must be smaller than extBufPools.numOfPoolsUsed"));
+        found = FALSE;
+        for(i = 0;i<p_FmBackupBmPools->numOfBackupPools;i++)
+        {
+
+            for(j=0;j<p_FmExtPools->numOfPoolsUsed;j++)
+            {
+                if(p_FmBackupBmPools->poolIds[i] == p_FmExtPools->extBufPool[j].id)
+                {
+                    found = TRUE;
+                    break;
+                }
+
+            }
+            if (!found)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("All p_BackupBmPools.poolIds must be included in extBufPools.extBufPool[n].id"));
+            else
+                found = FALSE;
+        }
+    }
+
+    /* up to extBufPools.numOfPoolsUsed pools may be defined */
+    if (p_FmBufPoolDepletion && p_FmBufPoolDepletion->poolsGrpModeEnable)
+    {
+        if ((p_FmBufPoolDepletion->numOfPools > p_FmExtPools->numOfPoolsUsed))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools can't be larger than %d and can't be larger than numOfPoolsUsed", FM_PORT_MAX_NUM_OF_EXT_POOLS));
+
+        if (!p_FmBufPoolDepletion->numOfPools)
+          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when poolsGrpModeEnable=TRUE"));
+
+        found = FALSE;
+        count = 0;
+        /* for each pool that is in poolsToConsider, check if it is defined
+           in extBufPool */
+        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        {
+            if (p_FmBufPoolDepletion->poolsToConsider[i])
+            {
+                for (j=0;j<p_FmExtPools->numOfPoolsUsed;j++)
+                 {
+                    if (i == p_FmExtPools->extBufPool[j].id)
+                    {
+                        found = TRUE;
+                        count++;
+                        break;
+                    }
+                 }
+                if (!found)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                else
+                    found = FALSE;
+            }
+        }
+        /* check that the number of pools that we have checked is equal to the number announced by the user */
+        if (count != p_FmBufPoolDepletion->numOfPools)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPools is larger than the number of pools defined."));
+    }
+
+    if (p_FmBufPoolDepletion && p_FmBufPoolDepletion->singlePoolModeEnable)
+    {
+        /* calculate vector for number of pools depletion */
+        found = FALSE;
+        count = 0;
+        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        {
+            if(p_FmBufPoolDepletion->poolsToConsiderForSingleMode[i])
+            {
+                for (j=0;j<p_FmExtPools->numOfPoolsUsed;j++)
+                {
+                    if (i == p_FmExtPools->extBufPool[j].id)
+                    {
+                        found = TRUE;
+                        count++;
+                        break;
+                    }
+                }
+                if (!found)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pools selected for depletion are not used."));
+                else
+                    found = FALSE;
+            }
+        }
+        if (!count)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("No pools defined for single buffer mode pool depletion."));
+    }
+
+    return E_OK;
+}
+
+t_Error FmSpCheckIntContextParams(t_FmSpIntContextDataCopy *p_FmSpIntContextDataCopy)
+{
+    /* Check that divisible by 16 and not larger than 240 */
+    if (p_FmSpIntContextDataCopy->intContextOffset >MAX_INT_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset can't be larger than %d", MAX_INT_OFFSET));
+    if (p_FmSpIntContextDataCopy->intContextOffset % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset has to be divisible by %d", OFFSET_UNITS));
+
+    /* check that ic size+ic internal offset, does not exceed ic block size */
+    if (p_FmSpIntContextDataCopy->size + p_FmSpIntContextDataCopy->intContextOffset > MAX_IC_SIZE)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size + intContext.intContextOffset has to be smaller than %d", MAX_IC_SIZE));
+    /* Check that divisible by 16 and not larger than 256 */
+    if (p_FmSpIntContextDataCopy->size % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size  has to be divisible by %d", OFFSET_UNITS));
+
+    /* Check that divisible by 16 and not larger than 4K */
+    if (p_FmSpIntContextDataCopy->extBufOffset > MAX_EXT_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset can't be larger than %d", MAX_EXT_OFFSET));
+    if (p_FmSpIntContextDataCopy->extBufOffset % OFFSET_UNITS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.extBufOffset  has to be divisible by %d", OFFSET_UNITS));
+
+    return E_OK;
+}
+
+t_Error FmSpCheckBufMargins(t_FmSpBufMargins *p_FmSpBufMargins)
+{
+    /* Check the margin definition */
+    if (p_FmSpBufMargins->startMargins > MAX_EXT_BUFFER_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.startMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
+    if (p_FmSpBufMargins->endMargins > MAX_EXT_BUFFER_OFFSET)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.endMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
+
+    return E_OK;
+}
+
+t_Error FmSpBuildBufferStructure(t_FmSpIntContextDataCopy   *p_FmSpIntContextDataCopy,
+                                 t_FmBufferPrefixContent     *p_BufferPrefixContent,
+                                 t_FmSpBufMargins            *p_FmSpBufMargins,
+                                 t_FmSpBufferOffsets         *p_FmSpBufferOffsets,
+                                 uint8_t                     *internalBufferOffset)
+{
+    uint32_t                        tmp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmSpIntContextDataCopy,  E_INVALID_VALUE);
+    ASSERT_COND(p_FmSpIntContextDataCopy);
+    ASSERT_COND(p_BufferPrefixContent);
+    ASSERT_COND(p_FmSpBufMargins);
+    ASSERT_COND(p_FmSpBufferOffsets);
+
+    /* Align start of internal context data to 16 byte */
+    p_FmSpIntContextDataCopy->extBufOffset =
+        (uint16_t)((p_BufferPrefixContent->privDataSize & (OFFSET_UNITS-1)) ?
+            ((p_BufferPrefixContent->privDataSize + OFFSET_UNITS) & ~(uint16_t)(OFFSET_UNITS-1)) :
+             p_BufferPrefixContent->privDataSize);
+
+    /* Translate margin and intContext params to FM parameters */
+    /* Initialize with illegal value. Later we'll set legal values. */
+    p_FmSpBufferOffsets->prsResultOffset = (uint32_t)ILLEGAL_BASE;
+    p_FmSpBufferOffsets->timeStampOffset = (uint32_t)ILLEGAL_BASE;
+    p_FmSpBufferOffsets->hashResultOffset= (uint32_t)ILLEGAL_BASE;
+    p_FmSpBufferOffsets->pcdInfoOffset   = (uint32_t)ILLEGAL_BASE;
+
+    /* Internally the driver supports 4 options
+       1. prsResult/timestamp/hashResult selection (in fact 8 options, but for simplicity we'll
+          relate to it as 1).
+       2. All IC context (from AD) not including debug.*/
+
+    /* This 'if' covers option 2. We copy from beginning of context. */
+    if (p_BufferPrefixContent->passAllOtherPCDInfo)
+    {
+        p_FmSpIntContextDataCopy->size = 128; /* must be aligned to 16 */
+        /* Start copying data after 16 bytes (FD) from the beginning of the internal context */
+        p_FmSpIntContextDataCopy->intContextOffset = 16;
+
+        if (p_BufferPrefixContent->passAllOtherPCDInfo)
+            p_FmSpBufferOffsets->pcdInfoOffset = p_FmSpIntContextDataCopy->extBufOffset;
+        if (p_BufferPrefixContent->passPrsResult)
+            p_FmSpBufferOffsets->prsResultOffset =
+                (uint32_t)(p_FmSpIntContextDataCopy->extBufOffset + 16);
+        if (p_BufferPrefixContent->passTimeStamp)
+            p_FmSpBufferOffsets->timeStampOffset =
+                (uint32_t)(p_FmSpIntContextDataCopy->extBufOffset + 48);
+        if (p_BufferPrefixContent->passHashResult)
+            p_FmSpBufferOffsets->hashResultOffset =
+                (uint32_t)(p_FmSpIntContextDataCopy->extBufOffset + 56);
+    }
+    else
+    {
+        /* This case covers the options under 1 */
+        /* Copy size must be in 16-byte granularity. */
+        p_FmSpIntContextDataCopy->size =
+            (uint16_t)((p_BufferPrefixContent->passPrsResult ? 32 : 0) +
+                      ((p_BufferPrefixContent->passTimeStamp ||
+                      p_BufferPrefixContent->passHashResult) ? 16 : 0));
+
+        /* Align start of internal context data to 16 byte */
+        p_FmSpIntContextDataCopy->intContextOffset =
+            (uint8_t)(p_BufferPrefixContent->passPrsResult ? 32 :
+                      ((p_BufferPrefixContent->passTimeStamp  ||
+                       p_BufferPrefixContent->passHashResult) ? 64 : 0));
+
+        if (p_BufferPrefixContent->passPrsResult)
+            p_FmSpBufferOffsets->prsResultOffset = p_FmSpIntContextDataCopy->extBufOffset;
+        if (p_BufferPrefixContent->passTimeStamp)
+            p_FmSpBufferOffsets->timeStampOffset =  p_BufferPrefixContent->passPrsResult ?
+                                        (p_FmSpIntContextDataCopy->extBufOffset + sizeof(t_FmPrsResult)) :
+                                        p_FmSpIntContextDataCopy->extBufOffset;
+        if (p_BufferPrefixContent->passHashResult)
+            /* If PR is not requested, whether TS is requested or not, IC will be copied from TS */
+            p_FmSpBufferOffsets->hashResultOffset = p_BufferPrefixContent->passPrsResult ?
+                                          (p_FmSpIntContextDataCopy->extBufOffset + sizeof(t_FmPrsResult) + 8) :
+                                          p_FmSpIntContextDataCopy->extBufOffset + 8;
+    }
+
+    if (p_FmSpIntContextDataCopy->size)
+		p_FmSpBufMargins->startMargins =
+			(uint16_t)(p_FmSpIntContextDataCopy->extBufOffset +
+					   p_FmSpIntContextDataCopy->size);
+    else
+	/* No Internal Context passing, STartMargin is immediately after privateInfo */
+	p_FmSpBufMargins->startMargins = p_BufferPrefixContent->privDataSize;
+
+    /* save extra space for manip in both external and internal buffers */
+    if (p_BufferPrefixContent->manipExtraSpace)
+    {
+        uint8_t extraSpace;
+#ifdef FM_CAPWAP_SUPPORT
+        if ((p_BufferPrefixContent->manipExtraSpace + CAPWAP_FRAG_EXTRA_SPACE) >= 256)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                         ("p_BufferPrefixContent->manipExtraSpace should be less than %d",
+                          256-CAPWAP_FRAG_EXTRA_SPACE));
+        extraSpace = (uint8_t)(p_BufferPrefixContent->manipExtraSpace + CAPWAP_FRAG_EXTRA_SPACE);
+#else
+        extraSpace = p_BufferPrefixContent->manipExtraSpace;
+#endif /* FM_CAPWAP_SUPPORT */
+        p_FmSpBufferOffsets->manipOffset = p_FmSpBufMargins->startMargins;
+        p_FmSpBufMargins->startMargins += extraSpace;
+        *internalBufferOffset = extraSpace;
+    }
+
+    /* align data start */
+    tmp = (uint32_t)(p_FmSpBufMargins->startMargins % p_BufferPrefixContent->dataAlign);
+    if (tmp)
+        p_FmSpBufMargins->startMargins += (p_BufferPrefixContent->dataAlign-tmp);
+    p_FmSpBufferOffsets->dataOffset = p_FmSpBufMargins->startMargins;
+
+    return E_OK;
+}
+/*********************** End of inter-module routines ************************/
+
+
+#if DPAA_VERSION >= 3
+/*****************************************************************************/
+/*              API routines                                                 */
+/*****************************************************************************/
+t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams)
+{
+    t_FmVspEntry          *p_FmVspEntry = NULL;
+
+    p_FmVspEntry = (t_FmVspEntry *)XX_Malloc(sizeof(t_FmVspEntry));
+    if(!p_FmVspEntry)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_StorageProfile allocation failed"));
+        return NULL;
+    }
+    memset(p_FmVspEntry, 0, sizeof(t_FmVspEntry));
+
+    p_FmVspEntry->p_FmVspEntryDriverParams = (t_FmVspEntryDriverParams *)XX_Malloc(sizeof(t_FmVspEntryDriverParams));
+    if(!p_FmVspEntry->p_FmVspEntryDriverParams)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_StorageProfile allocation failed"));
+        XX_Free(p_FmVspEntry);
+        return NULL;
+    }
+    memset(p_FmVspEntry->p_FmVspEntryDriverParams, 0, sizeof(t_FmVspEntryDriverParams));
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.privDataSize = DEFAULT_FM_SP_bufferPrefixContent_privDataSize;
+    p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.passPrsResult= DEFAULT_FM_SP_bufferPrefixContent_passPrsResult;
+    p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.passTimeStamp= DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp;
+    p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.passAllOtherPCDInfo
+                                                                    = DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp;
+    p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.dataAlign    = DEFAULT_FM_SP_bufferPrefixContent_dataAlign;
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaSwapData                      = DEFAULT_FM_SP_dmaSwapData;
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaIntContextCacheAttr           = DEFAULT_FM_SP_dmaIntContextCacheAttr;
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaHeaderCacheAttr               = DEFAULT_FM_SP_dmaHeaderCacheAttr;
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaScatterGatherCacheAttr        = DEFAULT_FM_SP_dmaScatterGatherCacheAttr;
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaWriteOptimize                 = DEFAULT_FM_SP_dmaWriteOptimize;
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->noScatherGather                  = DEFAULT_FM_SP_noScatherGather;
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->liodnOffset                      = p_FmVspParams->liodnOffset;
+
+    memcpy(&p_FmVspEntry->p_FmVspEntryDriverParams->extBufPools, &p_FmVspParams->extBufPools, sizeof(t_FmExtPools));
+
+    p_FmVspEntry->h_Fm                                                       = p_FmVspParams->h_Fm;
+    p_FmVspEntry->portType                                                   = p_FmVspParams->portParams.portType;
+    p_FmVspEntry->portId                                                     = p_FmVspParams->portParams.portId  ;
+
+    p_FmVspEntry->relativeProfileId                                          = p_FmVspParams->relativeProfileId;
+
+   return p_FmVspEntry;
+}
+
+t_Error FM_VSP_Init(t_Handle h_FmVsp)
+{
+
+    t_FmVspEntry                *p_FmVspEntry = (t_FmVspEntry *)h_FmVsp;
+    fm_storage_profile_params   fm_vsp_params;
+    uint8_t                     orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+    uint16_t                    sizesArray[BM_MAX_NUM_OF_POOLS];
+    t_Error                     err;
+    uint16_t                    absoluteProfileId = 0;
+    int                         i = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams,E_INVALID_HANDLE);
+
+    memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
+    memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
+
+    err = FmSpBuildBufferStructure(&p_FmVspEntry->intContext,
+                                   &p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent,
+                                   &p_FmVspEntry->bufMargins,
+                                   &p_FmVspEntry->bufferOffsets,
+                                   &p_FmVspEntry->internalBufferOffset);
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = CheckParams(p_FmVspEntry);
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    err = FmVSPGetAbsoluteProfileId(p_FmVspEntry->h_Fm,
+                                   p_FmVspEntry->portType,
+                                   p_FmVspEntry->portId,
+                                   p_FmVspEntry->relativeProfileId,
+                                   &absoluteProfileId);
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("storage profileId too Big "));
+
+    if (absoluteProfileId >= FM_VSP_MAX_NUM_OF_ENTRIES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("storage profileId too Big "));
+
+    p_FmVspEntry->p_FmSpRegsBase =
+        (fm_pcd_storage_profile_regs *)FmGetVSPBaseAddr(p_FmVspEntry->h_Fm);
+    if (!p_FmVspEntry->p_FmSpRegsBase)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("impossible to initialize SpRegsBase"));
+
+    /* order external buffer pools in ascending order of buffer pools sizes */
+    FmSpSetBufPoolsInAscOrderOfBufSizes(&(p_FmVspEntry->p_FmVspEntryDriverParams)->extBufPools,
+                                        orderedArray,
+                                        sizesArray);
+
+    p_FmVspEntry->extBufPools.numOfPoolsUsed =
+        p_FmVspEntry->p_FmVspEntryDriverParams->extBufPools.numOfPoolsUsed;
+    for (i = 0; i < p_FmVspEntry->extBufPools.numOfPoolsUsed; i++)
+    {
+       p_FmVspEntry->extBufPools.extBufPool[i].id = orderedArray[i];
+       p_FmVspEntry->extBufPools.extBufPool[i].size = sizesArray[orderedArray[i]];
+    }
+
+    /* on user responsibility to fill it according requirement */
+    memset(&fm_vsp_params, 0, sizeof(fm_storage_profile_params));
+    fm_vsp_params.dma_swap_data              = p_FmVspEntry->p_FmVspEntryDriverParams->dmaSwapData;
+    fm_vsp_params.int_context_cache_attr     = p_FmVspEntry->p_FmVspEntryDriverParams->dmaIntContextCacheAttr;
+    fm_vsp_params.header_cache_attr          = p_FmVspEntry->p_FmVspEntryDriverParams->dmaHeaderCacheAttr;
+    fm_vsp_params.scatter_gather_cache_attr  = p_FmVspEntry->p_FmVspEntryDriverParams->dmaScatterGatherCacheAttr;
+    fm_vsp_params.dma_write_optimize         = p_FmVspEntry->p_FmVspEntryDriverParams->dmaWriteOptimize;
+    fm_vsp_params.liodn_offset               = p_FmVspEntry->p_FmVspEntryDriverParams->liodnOffset;
+    fm_vsp_params.no_scather_gather          = p_FmVspEntry->p_FmVspEntryDriverParams->noScatherGather;
+
+    fm_vsp_params.buf_pool_depletion         = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion;
+    fm_vsp_params.backup_pools               = p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools;
+    fm_vsp_params.fm_ext_pools               = &p_FmVspEntry->extBufPools;
+
+    fm_vsp_params.buf_margins                = &p_FmVspEntry->bufMargins;
+    fm_vsp_params.int_context                = &p_FmVspEntry->intContext;
+
+    /*set all registers related to VSP*/
+    fm_vsp_fill_entry(p_FmVspEntry->p_FmSpRegsBase, absoluteProfileId, &fm_vsp_params);
+
+    p_FmVspEntry->absoluteSpId = absoluteProfileId;
+
+    if (p_FmVspEntry->p_FmVspEntryDriverParams)
+        XX_Free(p_FmVspEntry->p_FmVspEntryDriverParams);
+    p_FmVspEntry->p_FmVspEntryDriverParams = NULL;
+
+    return E_OK;
+}
+
+t_Error FM_VSP_Free(t_Handle h_FmVsp)
+{
+    t_FmVspEntry   *p_FmVspEntry = (t_FmVspEntry *)h_FmVsp;
+    SANITY_CHECK_RETURN_ERROR(h_FmVsp, E_INVALID_HANDLE);
+    XX_Free(p_FmVspEntry);
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigBufferPrefixContent(t_Handle h_FmVsp, t_FmBufferPrefixContent *p_FmBufferPrefixContent)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+
+    memcpy(&p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent, p_FmBufferPrefixContent, sizeof(t_FmBufferPrefixContent));
+    /* if dataAlign was not initialized by user, we return to driver's default */
+    if (!p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.dataAlign)
+        p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.dataAlign = DEFAULT_FM_SP_bufferPrefixContent_dataAlign;
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigDmaSwapData(t_Handle h_FmVsp, e_FmDmaSwapOption swapData)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaSwapData = swapData;
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigDmaIcCacheAttr(t_Handle h_FmVsp, e_FmDmaCacheOption intContextCacheAttr)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaIntContextCacheAttr = intContextCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigDmaHdrAttr(t_Handle h_FmVsp, e_FmDmaCacheOption headerCacheAttr)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaHeaderCacheAttr = headerCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigDmaScatterGatherAttr(t_Handle h_FmVsp, e_FmDmaCacheOption scatterGatherCacheAttr)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+
+     p_FmVspEntry->p_FmVspEntryDriverParams->dmaScatterGatherCacheAttr = scatterGatherCacheAttr;
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigDmaWriteOptimize(t_Handle h_FmVsp, bool optimize)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaWriteOptimize = optimize;
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigNoScatherGather(t_Handle h_FmVsp, bool noScatherGather)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->noScatherGather = noScatherGather;
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigPoolDepletion(t_Handle h_FmVsp, t_FmBufPoolDepletion *p_BufPoolDepletion)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmVsp, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_BufPoolDepletion, E_INVALID_HANDLE);
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion = (t_FmBufPoolDepletion *)XX_Malloc(sizeof(t_FmBufPoolDepletion));
+    if(!p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BufPoolDepletion allocation failed"));
+    memcpy(p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion, p_BufPoolDepletion, sizeof(t_FmBufPoolDepletion));
+
+    return E_OK;
+}
+
+t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBmPools)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmVsp, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_BackupBmPools, E_INVALID_HANDLE);
+
+    p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools = (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
+    if(!p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
+    memcpy(p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmBackupBmPools));
+
+    return E_OK;
+}
+
+#ifdef UNDER_CONSTRUCTION_FM_GEN
+uint32_t FM_VSP_GetStatistics(t_Handle h_FmVsp)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmVsp, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmSpRegsBase, E_INVALID_HANDLE);
+
+    return fm_vsp_get_statistics(p_FmVspEntry->p_FmSpRegsBase, p_FmVspEntry->absoluteSpId);
+}
+t_Error FM_VSP_ModifyCounter(t_Handle h_FmVsp, uint32_t value)
+{
+    t_FmVspEntry *p_FmVspEntry = (t_FmVspEntry*)h_FmVsp;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmVsp, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmVspEntry->p_FmVspEntryDriverParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmVspEntry->p_FmSpRegsBase, E_INVALID_HANDLE);
+
+    fm_vsp_set_statistics(p_FmVspEntry->p_FmSpRegsBase, p_FmVspEntry->absoluteSpId, value);
+
+    return E_OK;
+}
+#endif /* UNDER_CONSTRUCTION_FM_GEN */
+#endif /* DPAA_VERSION >= 3 */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.h
new file mode 100644
index 0000000..30b41b6
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.h
@@ -0,0 +1,131 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_sp.h
+
+ @Description   FM SP  ...
+*//***************************************************************************/
+#ifndef __FM_SP_H
+#define __FM_SP_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+
+#include "fm_sp_common.h"
+#include "fm_common.h"
+
+
+#define __ERR_MODULE__  MODULE_FM_SP
+
+
+
+/***********************************************************************/
+/*          Memory map                                                 */
+/***********************************************************************/
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+typedef _Packed struct {
+    volatile uint32_t   fm_sp_ebmpi[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                         /*offset 0 - 0xc*/
+                                         /**< Buffer Manager pool Information-*/
+
+    volatile uint32_t   res[8-FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                         /*offset 0x10 - 0xc*/
+    volatile uint32_t   fm_sp_acnt;      /*offset 0x20*/
+    volatile uint32_t   fm_sp_ebm;       /*offset 0x24*/
+    volatile uint32_t   fm_sp_da;        /*offset 0x28*/
+    volatile uint32_t   fm_sp_icp;       /*offset 0x2c*/
+    volatile uint32_t   fm_sp_mpd;       /*offset 0x30*/
+    volatile uint32_t   res1[2];         /*offset 0x34 - 0x38*/
+    volatile uint32_t   fm_sp_spliodn;   /*offset 0x3c*/
+} _PackedType fm_pcd_storage_profile_regs;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+typedef struct fm_storage_profile_params {
+    t_FmExtPools                *fm_ext_pools;
+    t_FmBackupBmPools           *backup_pools;
+    t_FmSpIntContextDataCopy    *int_context;
+    t_FmSpBufMargins            *buf_margins;
+
+    e_FmDmaSwapOption           dma_swap_data;
+    e_FmDmaCacheOption          int_context_cache_attr;
+    e_FmDmaCacheOption          header_cache_attr;
+    e_FmDmaCacheOption          scatter_gather_cache_attr;
+    bool                        dma_write_optimize;
+    uint16_t                    liodn_offset;
+    bool                        no_scather_gather;
+    t_FmBufPoolDepletion        *buf_pool_depletion;
+} fm_storage_profile_params;
+
+typedef struct {
+    t_FmBufferPrefixContent             bufferPrefixContent;
+    e_FmDmaSwapOption                   dmaSwapData;
+    e_FmDmaCacheOption                  dmaIntContextCacheAttr;
+    e_FmDmaCacheOption                  dmaHeaderCacheAttr;
+    e_FmDmaCacheOption                  dmaScatterGatherCacheAttr;
+    bool                                dmaWriteOptimize;
+    uint16_t                            liodnOffset;
+    bool                                noScatherGather;
+    t_FmBufPoolDepletion                *p_BufPoolDepletion;
+    t_FmBackupBmPools                   *p_BackupBmPools;
+    t_FmExtPools                        extBufPools;
+} t_FmVspEntryDriverParams;
+
+typedef struct {
+    bool                        valid;
+    volatile bool               lock;
+    uint8_t                     pointedOwners;
+    uint16_t                    absoluteSpId;
+    uint8_t                     internalBufferOffset;
+    t_FmSpBufMargins            bufMargins;
+    t_FmSpIntContextDataCopy    intContext;
+    t_FmSpBufferOffsets         bufferOffsets;
+    t_Handle                    h_Fm;
+    e_FmPortType                portType;           /**< Port type */
+    uint8_t                     portId;             /**< Port Id - relative to type */
+    uint8_t                     relativeProfileId;
+    fm_pcd_storage_profile_regs *p_FmSpRegsBase;
+    t_FmExtPools                extBufPools;
+    t_FmVspEntryDriverParams    *p_FmVspEntryDriverParams;
+} t_FmVspEntry;
+
+
+#endif /* __FM_SP_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 5ab0cf1..66e8a62 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -75,6 +75,7 @@ static bool IsFmanCtrlCodeLoaded(t_Fm *p_Fm)
 
 static t_Error CheckFmParameters(t_Fm *p_Fm)
 {
+
     if (IsFmanCtrlCodeLoaded(p_Fm) && !p_Fm->p_FmDriverParam->resetOnInit)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old FMan CTRL code is loaded; FM must be reset!"));
     if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
@@ -101,6 +102,10 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
     if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency must be smaller than dmaWriteBufThresholds.assertEmergency"));
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev >= 6) &&
+        ((p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_READ_EM)||(p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_WRITE_EM)))
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaDbgCntMode not supported by this integration."));
+
 
     if(!p_Fm->p_FmStateStruct->fmClkFreq)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq must be set."));
@@ -108,18 +113,10 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                      ("dmaWatchdog depends on FM clock. dmaWatchdog(in microseconds) * clk (in Mhz), may not exceed 0x08x", DMA_MAX_WATCHDOG));
 
-#ifdef FM_PARTITION_ARRAY
-    {
-        t_FmRevisionInfo revInfo;
-        uint8_t     i;
-
-        FM_GetRevision(p_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            for (i=0; i<FM_SIZE_OF_LIODN_TABLE; i++)
-                if (p_Fm->p_FmDriverParam->liodnBasePerPort[i] & ~FM_LIODN_BASE_MASK)
-                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodn number is out of range"));
-    }
-#endif /* FM_PARTITION_ARRAY */
+#if DPAA_VERSION >= 3
+    if ((p_Fm->partVSPBase + p_Fm->partNumOfVSPs) > FM_VSP_MAX_NUM_OF_ENTRIES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("partVSPBase+partNumOfVSPs out of range!!!"));
+#endif /* DPAA_VERSION >= 3 */
 
     if(p_Fm->p_FmStateStruct->totalFifoSize % BMI_FIFO_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be divisible by %d", BMI_FIFO_UNITS));
@@ -127,8 +124,10 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalFifoSize number has to be in the range 256 - %d", BMI_MAX_FIFO_SIZE));
     if(!p_Fm->p_FmStateStruct->totalNumOfTasks || (p_Fm->p_FmStateStruct->totalNumOfTasks > BMI_MAX_NUM_OF_TASKS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("totalNumOfTasks number has to be in the range 1 - %d", BMI_MAX_NUM_OF_TASKS));
+#ifndef FM_NO_TOTAL_DMAS
     if(!p_Fm->p_FmStateStruct->maxNumOfOpenDmas || (p_Fm->p_FmStateStruct->maxNumOfOpenDmas > BMI_MAX_NUM_OF_DMAS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfOpenDmas number has to be in the range 1 - %d", BMI_MAX_NUM_OF_DMAS));
+#endif /* FM_NO_TOTAL_DMAS */
 
     if(p_Fm->p_FmDriverParam->thresholds.dispLimit > FPM_MAX_DISP_LIMIT)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("thresholds.dispLimit can't be greater than %d", FPM_MAX_DISP_LIMIT));
@@ -138,6 +137,40 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
     if(!p_Fm->f_BusError)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
 
+#ifdef FM_NO_WATCHDOG
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 2) && (p_Fm->p_FmDriverParam->dmaWatchdog))
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("watchdog!"));
+#endif /* FM_NO_WATCHDOG */
+
+#ifdef FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) && (p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError))
+	RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
+#endif /* not FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
+#ifdef FM_NO_TNUM_AGING
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
+        if(p_Fm->p_FmDriverParam->tnumAgingPeriod)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Tnum aging!"));
+#endif /* FM_NO_TNUM_AGING */
+
+    /* check that user did not set revision-dependent exceptions */
+#ifdef FM_NO_DISPATCH_RAM_ECC
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
+        if(p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
+		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_BMI_DISPATCH_RAM_ECC!"));
+#endif /* FM_NO_DISPATCH_RAM_ECC */
+
+#ifdef FM_QMI_NO_ECC_EXCEPTIONS
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
+        if(p_Fm->p_FmDriverParam->userSetExceptions & (FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC))
+		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC/e_FM_EX_QMI_DOUBLE_ECC!"));
+#endif /* FM_QMI_NO_ECC_EXCEPTIONS */
+
+#ifdef FM_QMI_NO_SINGLE_ECC_EXCEPTION
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        if(p_Fm->p_FmDriverParam->userSetExceptions & FM_EX_QMI_SINGLE_ECC)
+		RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("exception e_FM_EX_QMI_SINGLE_ECC!"));
+#endif /* FM_QMI_NO_SINGLE_ECC_EXCEPTION */
+
     return E_OK;
 }
 
@@ -156,13 +189,14 @@ static void SendIpcIsr(t_Fm *p_Fm, uint32_t macEvent, uint32_t pendingReg)
         fmIpcIsr.pendingReg = pendingReg;
         fmIpcIsr.boolErr = FALSE;
         memcpy(msg.msgBody, &fmIpcIsr, sizeof(fmIpcIsr));
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->intrMng[macEvent].guestId],
+		err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->intrMng[macEvent].guestId],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId) + sizeof(fmIpcIsr),
                                      NULL,
                                      NULL,
                                      NULL,
-                                     NULL)) != E_OK)
+                                     NULL);
+        if (err != E_OK)
             REPORT_ERROR(MINOR, err, NO_MSG);
         return;
     }
@@ -187,8 +221,8 @@ static void    BmiErrEvent(t_Fm *p_Fm)
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, event);
 
-    if(event & BMI_ERR_INTR_EN_PIPELINE_ECC)
-        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_PIPELINE_ECC);
+    if(event & BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC)
+        p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_STORAGE_PROFILE_ECC);
     if(event & BMI_ERR_INTR_EN_LIST_RAM_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_BMI_LIST_RAM_ECC);
     if(event & BMI_ERR_INTR_EN_STATISTICS_RAM_ECC)
@@ -261,6 +295,8 @@ static void    DmaErrEvent(t_Fm *p_Fm)
     }
     if(mask & DMA_MODE_ECC)
     {
+        if (status & DMA_STATUS_FM_SPDAT_ECC)
+            p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_SINGLE_PORT_ECC);
         if (status & DMA_STATUS_READ_ECC)
             p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_READ_ECC);
         if (status & DMA_STATUS_SYSTEM_WRITE_ECC)
@@ -294,10 +330,12 @@ static void    MuramErrIntr(t_Fm *p_Fm)
     event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
     mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
 
+    ASSERT_COND(event & FPM_RAM_CTL_MURAM_ECC);
+
     /* clear MURAM event bit */
+    /* Prior to V3 this event bit clearing does not work ! ) */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_IRAM_ECC);
 
-    ASSERT_COND(event & FPM_RAM_CTL_MURAM_ECC);
     ASSERT_COND(event & FPM_RAM_CTL_RAMS_ECC_EN);
 
     if ((mask & FPM_MURAM_ECC_ERR_EX_EN))
@@ -310,10 +348,13 @@ static void IramErrIntr(t_Fm *p_Fm)
 
     event = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr) ;
     mask = GET_UINT32(p_Fm->p_FmFpmRegs->fmrie);
+
+    ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC);
+
     /* clear the acknowledged events (do not clear IRAM event) */
+    /* Prior to V3 this event bit clearing does not work ! ) */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, event & ~FPM_RAM_CTL_MURAM_ECC);
 
-    ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC);
     ASSERT_COND(event & FPM_RAM_CTL_IRAM_ECC_EN);
 
     if ((mask & FPM_IRAM_ECC_ERR_EX_EN))
@@ -452,10 +493,13 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
         WRITE_UINT32(p_Iram->iadd, IRAM_IADD_AIE);
         while (GET_UINT32(p_Iram->iadd) != IRAM_IADD_AIE) ;
         for (i=0; i < (p_Fm->p_FmDriverParam->firmware.size / 4); i++)
-            if ((tmp=GET_UINT32(p_Iram->idata)) != p_Fm->p_FmDriverParam->firmware.p_Code[i])
+        {
+			tmp = GET_UINT32(p_Iram->idata);
+            if (tmp != p_Fm->p_FmDriverParam->firmware.p_Code[i])
                 RETURN_ERROR(MAJOR, E_WRITE_FAILED,
                              ("UCode write error : write 0x%x, read 0x%x",
                               p_Fm->p_FmDriverParam->firmware.p_Code[i],tmp));
+        }
         WRITE_UINT32(p_Iram->iadd, 0x0);
     }
 
@@ -493,35 +537,214 @@ do {                                    \
         FM_G_CALL_1G_MAC_ERR_ISR(3);
     if (pending & ERR_INTR_EN_1G_MAC4)
         FM_G_CALL_1G_MAC_ERR_ISR(4);
+    if (pending & ERR_INTR_EN_1G_MAC5)
+        FM_G_CALL_1G_MAC_ERR_ISR(5);
+    if (pending & ERR_INTR_EN_1G_MAC6)
+        FM_G_CALL_1G_MAC_ERR_ISR(6);
+    if (pending & ERR_INTR_EN_1G_MAC7)
+        FM_G_CALL_1G_MAC_ERR_ISR(7);
     if (pending & ERR_INTR_EN_10G_MAC0)
         FM_G_CALL_10G_MAC_ERR_ISR(0);
+    if (pending & ERR_INTR_EN_10G_MAC1)
+        FM_G_CALL_10G_MAC_ERR_ISR(1);
 }
 
 static void GuestEventIsr(t_Fm *p_Fm, uint32_t pending)
 {
-#define FM_G_CALL_1G_MAC_TMR_ISR(_id)   \
+#define FM_G_CALL_1G_MAC_ISR(_id)   \
+do {                                    \
+    p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].h_SrcHandle);\
+} while (0)
+#define FM_G_CALL_10G_MAC_ISR(_id)   \
 do {                                    \
-    p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0_TMR+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0_TMR+_id)].h_SrcHandle);\
+    p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id)].h_SrcHandle);\
 } while (0)
 
-    if (pending & INTR_EN_1G_MAC0_TMR)
-        FM_G_CALL_1G_MAC_TMR_ISR(0);
-    if (pending & INTR_EN_1G_MAC1_TMR)
-        FM_G_CALL_1G_MAC_TMR_ISR(1);
-    if (pending & INTR_EN_1G_MAC2_TMR)
-        FM_G_CALL_1G_MAC_TMR_ISR(2);
-    if (pending & INTR_EN_1G_MAC3_TMR)
-        FM_G_CALL_1G_MAC_TMR_ISR(3);
-    if (pending & INTR_EN_1G_MAC4_TMR)
-        FM_G_CALL_1G_MAC_TMR_ISR(4);
+    if (pending & INTR_EN_1G_MAC0)
+        FM_G_CALL_1G_MAC_ISR(0);
+    if (pending & INTR_EN_1G_MAC1)
+        FM_G_CALL_1G_MAC_ISR(1);
+    if (pending & INTR_EN_1G_MAC2)
+        FM_G_CALL_1G_MAC_ISR(2);
+    if (pending & INTR_EN_1G_MAC3)
+        FM_G_CALL_1G_MAC_ISR(3);
+    if (pending & INTR_EN_1G_MAC4)
+        FM_G_CALL_1G_MAC_ISR(4);
+    if (pending & INTR_EN_1G_MAC5)
+        FM_G_CALL_1G_MAC_ISR(5);
+    if (pending & INTR_EN_1G_MAC6)
+        FM_G_CALL_1G_MAC_ISR(6);
+    if (pending & INTR_EN_1G_MAC7)
+        FM_G_CALL_1G_MAC_ISR(7);
+    if (pending & INTR_EN_10G_MAC0)
+        FM_G_CALL_10G_MAC_ISR(0);
+    if (pending & INTR_EN_10G_MAC1)
+        FM_G_CALL_10G_MAC_ISR(1);
     if(pending & INTR_EN_TMR)
         p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
 }
 
+t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
+                                        uint32_t     congestionGroupId,
+                                        uint8_t      priorityBitMap)
+{
+    t_Fm         *p_Fm  = (t_Fm *)h_Fm;
+
+    ASSERT_COND(h_Fm);
+
+    if (congestionGroupId > FM_PORT_NUM_OF_CONGESTION_GRPS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Congestion group ID bigger than %d \n!",FM_PORT_NUM_OF_CONGESTION_GRPS));
+
+    if (p_Fm->guestId == NCSW_MASTER_ID)
+    {
+        uint32_t      *p_Cpg = (uint32_t*)p_Fm->baseAddr+FM_MM_CGP;
+        uint32_t      tmpReg;
+        uint32_t      reg_num;
+        uint32_t      offset;
+
+        ASSERT_COND(p_Fm->baseAddr);
+        reg_num = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))/4;
+        offset  = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))%4;
+
+
+        tmpReg = GET_UINT32(p_Cpg[reg_num]);
+
+        if(priorityBitMap)//adding priority
+        {
+            if(tmpReg & (0xFF<<(28-(offset*8))))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PFC priority for the congestion group is already set!"));
+
+        }
+        tmpReg |= (uint32_t)priorityBitMap <<(28-(offset*8));
+            WRITE_UINT32(p_Cpg[reg_num], tmpReg);
+    }
+    else if (p_Fm->h_IpcSessions)
+    {
+        t_Error                              err;
+        t_FmIpcMsg                           msg;
+        t_FmIpcSetCongestionGroupPfcPriority FmIpcSetCongestionGroupPfcPriority;
+        memset(&msg, 0, sizeof(msg));
+        memset(&FmIpcSetCongestionGroupPfcPriority, 0, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
+        FmIpcSetCongestionGroupPfcPriority.congestionGroupId = congestionGroupId;
+        FmIpcSetCongestionGroupPfcPriority.priorityBitMap    = priorityBitMap;
+
+        msg.msgId                               = FM_SET_CONG_GRP_PFC_PRIO;
+        memcpy(msg.msgBody, &FmIpcSetCongestionGroupPfcPriority, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
+
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->guestId],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("guest without IPC!"));
+
+    return E_OK;
+}
+
+#if DPAA_VERSION >= 3
+t_Error FmVSPSetWindow(t_Handle  h_Fm,
+                                  uint8_t   hardwarePortId,
+                                  uint8_t   baseStorageProfile,
+                       uint8_t  log2NumOfProfiles)
+{
+    t_Fm                    *p_Fm = (t_Fm *)h_Fm;
+    uint32_t                tmpReg;
+    t_Error                 err = E_OK;
+
+    ASSERT_COND(h_Fm);
+    ASSERT_COND(hardwarePortId);
+
+    if (p_Fm->p_FmBmiRegs)
+    {
+        tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1]);
+        tmpReg |= (uint32_t)((uint32_t)baseStorageProfile & 0x3f) << 16;
+        tmpReg |= (uint32_t)log2NumOfProfiles << 28;
+        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], tmpReg);
+    }
+    else if ((p_Fm->guestId != NCSW_MASTER_ID) && p_Fm->h_IpcSessions)
+    {
+
+        t_FmIpcMsg          msg;
+        t_FmIpcVspSetPortWindow fmIpcVspSetPortWindow;
+        memset(&msg, 0, sizeof(msg));
+        memset(&fmIpcVspSetPortWindow, 0, sizeof(t_FmIpcVspSetPortWindow));
+        fmIpcVspSetPortWindow.hardwarePortId      = hardwarePortId;
+        fmIpcVspSetPortWindow.baseStorageProfile  = baseStorageProfile;
+        fmIpcVspSetPortWindow.log2NumOfProfiles   = log2NumOfProfiles;
+        msg.msgId                               = FM_VSP_SET_PORT_WINDOW;
+        memcpy(msg.msgBody, &fmIpcVspSetPortWindow, sizeof(t_FmIpcVspSetPortWindow));
+
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[p_Fm->guestId],
+                                (uint8_t*)&msg,
+                                sizeof(msg.msgId),
+                                NULL,
+                                NULL,
+                                NULL,
+                                NULL);
+        if (err != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("guest without either regs or IPC!"));
+    return err;
+}
+
+static uint8_t FmVSPsAlloc(t_Handle  h_Fm, uint8_t base, uint8_t numOfStorageProfiles, uint8_t guestId)
+{
+    t_Fm    *p_Fm = (t_Fm *)h_Fm;
+    uint8_t  profilesFound = 0;
+    int     i     = 0;
+
+    if (!numOfStorageProfiles)
+        return E_OK;
+    if (numOfStorageProfiles>FM_VSP_MAX_NUM_OF_ENTRIES)
+        return (uint8_t)ILLEGAL_BASE;
+
+    XX_LockSpinlock(p_Fm->h_Spinlock);
+    for (i = base; i < base + numOfStorageProfiles; i++)
+        if (p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == (uint8_t)ILLEGAL_BASE)
+            profilesFound++;
+        else
+            break;
+
+    if (profilesFound == numOfStorageProfiles)
+        for (i = base; i<base + numOfStorageProfiles; i++)
+            p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = guestId;
+    else
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        return (uint8_t)ILLEGAL_BASE;
+    }
+    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+
+    return base;
+}
+
+static void FmVSPsFree(t_Handle  h_Fm, uint8_t base, uint8_t numOfStorageProfiles, uint8_t guestId)
+{
+    t_Fm    *p_Fm = (t_Fm *)h_Fm;
+    int i = 0;
+
+    ASSERT_COND(p_Fm);
+    ASSERT_COND(p_Fm->p_FmSp);
+
+    for (i = base; i < numOfStorageProfiles; i++)
+    {
+        if(p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == guestId)
+           p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
+        else
+            DBG(WARNING, ("Request for freeing storage profile window which wasn't allocated to this partition"));
+    }
+}
+#endif /* DPAA_VERSION >= 3 */
+
 
-/****************************************/
-/*       Inter-Module functions         */
-/****************************************/
 static t_Error FmGuestHandleIpcMsgCB(t_Handle  h_Fm,
                                      uint8_t   *p_Msg,
                                      uint32_t  msgLength,
@@ -569,6 +792,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
                                 uint8_t   *p_Reply,
                                 uint32_t  *p_ReplyLength)
 {
+    t_Error         err;
     t_Fm            *p_Fm       = (t_Fm*)h_Fm;
     t_FmIpcMsg      *p_IpcMsg   = (t_FmIpcMsg*)p_Msg;
     t_FmIpcReply    *p_IpcReply = (t_FmIpcReply*)p_Reply;
@@ -690,21 +914,55 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
         }
         case (FM_SET_MAC_MAX_FRAME):
         {
-            t_Error                     err;
             t_FmIpcMacMaxFrameParams    ipcMacMaxFrameParams;
 
             memcpy((uint8_t*)&ipcMacMaxFrameParams, p_IpcMsg->msgBody, sizeof(t_FmIpcMacMaxFrameParams));
-            if ((err = FmSetMacMaxFrame(p_Fm,
+			err = FmSetMacMaxFrame(p_Fm,
                                         (e_FmMacType)(ipcMacMaxFrameParams.macParams.enumType),
                                         ipcMacMaxFrameParams.macParams.id,
-                                        ipcMacMaxFrameParams.maxFrameLength)) != E_OK)
+                                  ipcMacMaxFrameParams.maxFrameLength);
+            if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
         }
-        case (FM_GET_CLK_FREQ):
-            memcpy(p_IpcReply->replyBody, (uint8_t*)&p_Fm->p_FmStateStruct->fmClkFreq, sizeof(uint16_t));
-            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint16_t);
+#if DPAA_VERSION >= 3
+        case (FM_VSP_ALLOC) :
+        {
+            t_FmIpcVspAllocParams   ipcVspAllocParams;
+            uint8_t                 vspBase;
+            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcVspAllocParams));
+            vspBase =  FmVSPsAlloc(h_Fm, ipcVspAllocParams.base, ipcVspAllocParams.numOfProfiles, ipcVspAllocParams.guestId);
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&vspBase, sizeof(uint8_t));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
+            break;
+        }
+        case (FM_VSP_FREE) :
+        {
+            t_FmIpcVspAllocParams   ipcVspAllocParams;
+            memcpy(&ipcVspAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcVspAllocParams));
+            FmVSPsFree(h_Fm, ipcVspAllocParams.base, ipcVspAllocParams.numOfProfiles, ipcVspAllocParams.guestId);
             break;
+        }
+        case(FM_VSP_SET_PORT_WINDOW) :
+        {
+            t_FmIpcVspSetPortWindow   ipcVspSetPortWindow;
+            memcpy(&ipcVspSetPortWindow, p_IpcMsg->msgBody, sizeof(t_FmIpcVspSetPortWindow));
+            err = FmVSPSetWindow(h_Fm,
+                                            ipcVspSetPortWindow.hardwarePortId,
+                                            ipcVspSetPortWindow.baseStorageProfile,
+                                            ipcVspSetPortWindow.log2NumOfProfiles);
+            return err;
+        }
+        case(FM_SET_CONG_GRP_PFC_PRIO) :
+        {
+            t_FmIpcSetCongestionGroupPfcPriority    FmIpcSetCongestionGroupPfcPriority;
+            memcpy(&FmIpcSetCongestionGroupPfcPriority, p_IpcMsg->msgBody, sizeof(t_FmIpcSetCongestionGroupPfcPriority));
+            err = FmSetCongestionGroupPFCpriority(h_Fm,
+                                                  FmIpcSetCongestionGroupPfcPriority.congestionGroupId,
+                                                  FmIpcSetCongestionGroupPfcPriority.priorityBitMap);
+            return err;
+        }
+#endif /* DPAA_VERSION >= 3 */
         case (FM_FREE_PORT):
         {
             t_FmInterModulePortFreeParams   portParams;
@@ -713,9 +971,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             memcpy((uint8_t*)&ipcPortParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortFreeParams));
             portParams.hardwarePortId = ipcPortParams.hardwarePortId;
             portParams.portType = (e_FmPortType)(ipcPortParams.enumPortType);
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
             portParams.deqPipelineDepth = ipcPortParams.deqPipelineDepth;
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
             FmFreePortParams(h_Fm, &portParams);
             break;
         }
@@ -730,32 +986,50 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
         case (FM_DUMP_REGS):
         {
-            t_Error     err;
-            if ((err = FM_DumpRegs(h_Fm)) != E_OK)
+		err = FM_DumpRegs(h_Fm);
+            if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
         }
         case (FM_DUMP_PORT_REGS):
         {
-            t_Error     err;
-
-            if ((err = FmDumpPortRegs(h_Fm, p_IpcMsg->msgBody[0])) != E_OK)
+		err = FmDumpPortRegs(h_Fm, p_IpcMsg->msgBody[0]);
+            if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
         }
 #endif /* (defined(DEBUG_ERRORS) && ... */
-        case (FM_GET_REV):
+        case (FM_GET_PARAMS):
+        {
+             t_FmIpcParams  ipcParams;
+             uint32_t       tmpReg;
+
+            /* Get clock frequency */
+            ipcParams.fmClkFreq = p_Fm->p_FmStateStruct->fmClkFreq;
+
+            /* read FM revision register 1 */
+            tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
+            ipcParams.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
+            ipcParams.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
+
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcParams, sizeof(t_FmIpcParams));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcParams);
+             break;
+        }
+        case (FM_GET_FMAN_CTRL_CODE_REV):
         {
-            t_FmRevisionInfo    revInfo;
-            t_FmIpcRevisionInfo ipcRevInfo;
-
-            p_IpcReply->error = (uint32_t)FM_GetRevision(h_Fm, &revInfo);
-            ipcRevInfo.majorRev = revInfo.majorRev;
-            ipcRevInfo.minorRev = revInfo.minorRev;
-            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcRevInfo, sizeof(t_FmIpcRevisionInfo));
-            *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcRevisionInfo);
+            t_FmCtrlCodeRevisionInfo        fmanCtrlRevInfo;
+            t_FmIpcFmanCtrlCodeRevisionInfo ipcRevInfo;
+
+            p_IpcReply->error = (uint32_t)FM_GetFmanCtrlCodeRevision(h_Fm, &fmanCtrlRevInfo);
+            ipcRevInfo.packageRev = fmanCtrlRevInfo.packageRev;
+            ipcRevInfo.majorRev = fmanCtrlRevInfo.majorRev;
+            ipcRevInfo.minorRev = fmanCtrlRevInfo.minorRev;
+            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcRevInfo, sizeof(t_FmIpcFmanCtrlCodeRevisionInfo));
+            *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcFmanCtrlCodeRevisionInfo);
             break;
         }
+
         case (FM_DMA_STAT):
         {
             t_FmDmaStatus       dmaStatus;
@@ -767,6 +1041,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             ipcDmaStatus.boolReadBufEccError = (uint8_t)dmaStatus.readBufEccError;
             ipcDmaStatus.boolWriteBufEccSysError = (uint8_t)dmaStatus.writeBufEccSysError;
             ipcDmaStatus.boolWriteBufEccFmError = (uint8_t)dmaStatus.writeBufEccFmError;
+            ipcDmaStatus.boolSinglePortEccError = (uint8_t)dmaStatus.singlePortEccError;
             memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcDmaStatus, sizeof(t_FmIpcDmaStatus));
             *p_ReplyLength = sizeof(uint32_t) + sizeof(t_FmIpcDmaStatus);
             break;
@@ -829,34 +1104,39 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
         }
         case (FM_ENABLE_RAM_ECC):
         {
-            t_Error     err;
-
             if (((err = FM_EnableRamsEcc(h_Fm)) != E_OK) ||
                 ((err = FM_SetException(h_Fm, e_FM_EX_IRAM_ECC, TRUE)) != E_OK) ||
                 ((err = FM_SetException(h_Fm, e_FM_EX_MURAM_ECC, TRUE)) != E_OK))
+#if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
+				UNUSED(err);
+#else
                 REPORT_ERROR(MINOR, err, NO_MSG);
+#endif /* (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0)) */
             break;
         }
         case (FM_DISABLE_RAM_ECC):
         {
-            t_Error     err;
 
             if (((err = FM_SetException(h_Fm, e_FM_EX_IRAM_ECC, FALSE)) != E_OK) ||
                 ((err = FM_SetException(h_Fm, e_FM_EX_MURAM_ECC, FALSE)) != E_OK) ||
                 ((err = FM_DisableRamsEcc(h_Fm)) != E_OK))
+#if (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0))
+				UNUSED(err);
+#else
                 REPORT_ERROR(MINOR, err, NO_MSG);
+#endif /* (!(defined(DEBUG_ERRORS)) || (DEBUG_ERRORS == 0)) */
             break;
         }
         case (FM_SET_NUM_OF_FMAN_CTRL):
         {
-            t_Error                     err;
             t_FmIpcPortNumOfFmanCtrls   ipcPortNumOfFmanCtrls;
 
             memcpy((uint8_t*)&ipcPortNumOfFmanCtrls, p_IpcMsg->msgBody, sizeof(t_FmIpcPortNumOfFmanCtrls));
-            if ((err = FmSetNumOfRiscsPerPort(h_Fm,
+            err = FmSetNumOfRiscsPerPort(h_Fm,
                                               ipcPortNumOfFmanCtrls.hardwarePortId,
                                               ipcPortNumOfFmanCtrls.numOfFmanCtrls,
-                                              ipcPortNumOfFmanCtrls.orFmanCtrl)) != E_OK)
+                                         ipcPortNumOfFmanCtrls.orFmanCtrl);
+            if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
         }
@@ -882,6 +1162,13 @@ static void ErrorIsrCB(t_Handle h_Fm)
        else                                                                                         \
             p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id)].h_SrcHandle);\
     }
+#define FM_M_CALL_10G_MAC_ERR_ISR(_id)   \
+    {                                   \
+       if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id)].guestId) \
+            SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id), pending);             \
+       else                                                                                         \
+            p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id)].h_SrcHandle);\
+    }
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     uint32_t                pending;
 
@@ -922,13 +1209,17 @@ static void ErrorIsrCB(t_Handle h_Fm)
         FM_M_CALL_1G_MAC_ERR_ISR(3);
     if(pending & ERR_INTR_EN_1G_MAC4)
         FM_M_CALL_1G_MAC_ERR_ISR(4);
+    if(pending & ERR_INTR_EN_1G_MAC5)
+        FM_M_CALL_1G_MAC_ERR_ISR(5);
+    if(pending & ERR_INTR_EN_1G_MAC6)
+        FM_M_CALL_1G_MAC_ERR_ISR(6);
+    if(pending & ERR_INTR_EN_1G_MAC7)
+        FM_M_CALL_1G_MAC_ERR_ISR(7);
     if(pending & ERR_INTR_EN_10G_MAC0)
-    {
-       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].guestId)
-            SendIpcIsr(p_Fm, e_FM_EV_ERR_10G_MAC0, pending);
-        else
-            p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
-    }
+        FM_M_CALL_10G_MAC_ERR_ISR(0);
+    if(pending & ERR_INTR_EN_10G_MAC1)
+        FM_M_CALL_10G_MAC_ERR_ISR(1);
+
 #ifdef FM_MACSEC_SUPPORT
     if(pending & ERR_INTR_EN_MACSEC_MAC0)
     {
@@ -941,6 +1232,9 @@ static void ErrorIsrCB(t_Handle h_Fm)
 }
 
 
+/****************************************/
+/*       Inter-Module functions         */
+/****************************************/
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
 {
@@ -997,8 +1291,12 @@ uintptr_t FmGetPcdPrsBaseAddr(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Guset"));
+    if (!p_Fm->baseAddr)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE,
+                     ("No base-addr; probably Guest with IPC!"));
+        return 0;
+    }
 
     return (p_Fm->baseAddr + FM_MM_PRS);
 }
@@ -1009,8 +1307,12 @@ uintptr_t FmGetPcdKgBaseAddr(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Guset"));
+    if (!p_Fm->baseAddr)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE,
+                     ("No base-addr; probably Guest with IPC!"));
+        return 0;
+    }
 
     return (p_Fm->baseAddr + FM_MM_KG);
 }
@@ -1021,12 +1323,27 @@ uintptr_t FmGetPcdPlcrBaseAddr(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Guset"));
+    if (!p_Fm->baseAddr)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE,
+                     ("No base-addr; probably Guest with IPC!"));
+        return 0;
+    }
 
     return (p_Fm->baseAddr + FM_MM_PLCR);
 }
 
+#if DPAA_VERSION >= 3
+uintptr_t FmGetVSPBaseAddr(t_Handle h_Fm)
+{
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+
+    return p_Fm->vspBaseAddr;
+}
+#endif /* DPAA_VERSION >= 3 */
+
 t_Handle FmGetMuramHandle(t_Handle h_Fm)
 {
     t_Fm        *p_Fm = (t_Fm*)h_Fm;
@@ -1051,13 +1368,14 @@ void FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_GET_PHYS_MURAM_BASE;
         replyLength = sizeof(uint32_t) + sizeof(t_FmPhysAddr);
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId),
                                      (uint8_t*)&reply,
                                      &replyLength,
                                      NULL,
-                                     NULL)) != E_OK)
+                                NULL);
+        if (err != E_OK)
         {
             REPORT_ERROR(MINOR, err, NO_MSG);
             return;
@@ -1078,6 +1396,124 @@ void FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *p_FmPhysAddr)
     p_FmPhysAddr->high = (uint8_t)((p_Fm->fmMuramPhysBaseAddr & 0x000000ff00000000LL) >> 32);
 }
 
+#if DPAA_VERSION >= 3
+t_Error FmVSPFree(  t_Handle        h_Fm,
+                    e_FmPortType    portType,
+                    uint8_t         portId)
+{
+    t_Fm           *p_Fm = (t_Fm *)h_Fm;
+    uint8_t        swPortIndex, hardwarePortId, first, numOfVSPs, i;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    numOfVSPs = p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
+    first = p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
+
+    XX_LockSpinlock(p_Fm->h_Spinlock);
+
+    for(i = first; i < first + numOfVSPs; i++)
+           p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
+
+    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+
+    p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = 0;
+    p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase = 0;
+
+    return E_OK;
+
+}
+t_Error FmVSPAlloc          (t_Handle  h_Fm,
+                           e_FmPortType    portType,
+                           uint8_t         portId,
+                           uint8_t   numOfVSPs)
+{
+    t_Fm           *p_Fm = (t_Fm *)h_Fm;
+    t_Error        err = E_OK;
+    uint32_t       profilesFound;
+    uint8_t        first, i;
+    uint8_t        log2Num;
+    uint8_t        swPortIndex, hardwarePortId;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+     if (!numOfVSPs)
+        return E_OK;
+
+    if (numOfVSPs>FM_VSP_MAX_NUM_OF_ENTRIES)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("numProfiles is too big."));
+
+    if (!POWER_OF_2(numOfVSPs))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numProfiles must be a power of 2."));
+
+    XX_LockSpinlock(p_Fm->h_Spinlock);
+
+    if (p_Fm->partVSPBase == 0)
+        first = 0;
+    else if (p_Fm->partVSPBase <= numOfVSPs)
+      first = numOfVSPs ;
+    else
+    {
+        for (i = p_Fm->partVSPBase; i < p_Fm->partNumOfVSPs; i++)
+        {
+            if (POWER_OF_2(i))
+            {
+                first = i;
+                break;
+            }
+        }
+    }
+    if (first>= (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
+    }
+    profilesFound = 0;
+    for (i=first;i<p_Fm->partNumOfVSPs;)
+    {
+        if (!p_Fm->p_FmSp->profiles[i].profilesMng.allocated)
+        {
+            profilesFound++;
+            i++;
+            if(profilesFound == numOfVSPs)
+                break;
+        }
+        else
+        {
+            profilesFound = 0;
+            /* advance i to the next aligned address */
+            first = i = (uint8_t)(first + numOfVSPs);
+        }
+    }
+    if (profilesFound == numOfVSPs)
+        for(i = first; i<first + numOfVSPs; i++)
+            p_Fm->p_FmSp->profiles[i].profilesMng.allocated = TRUE;
+    else
+    {
+        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
+    }
+
+    LOG2((uint64_t)numOfVSPs, log2Num);
+
+    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = numOfVSPs;
+    p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase = first;
+
+    if ((err = FmVSPSetWindow(h_Fm,hardwarePortId, first,log2Num)) != E_OK)
+        for(i = first; i < first + numOfVSPs; i++)
+            p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
+    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+    return err;
+}
+
+
+#endif /* UNDER_CONSTRUCTION_FM_STORAGE_PRFL */
+
 t_Error FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
@@ -1135,13 +1571,14 @@ void FmFreeFmanCtrlEventReg(t_Handle h_Fm, uint8_t eventId)
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_FREE_FMAN_CTRL_EVENT_REG;
         msg.msgBody[0] = eventId;
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId)+sizeof(eventId),
                                      NULL,
                                      NULL,
                                      NULL,
-                                     NULL)) != E_OK)
+                                NULL);
+        if (err != E_OK)
             REPORT_ERROR(MINOR, err, NO_MSG);
         return;
     }
@@ -1157,17 +1594,17 @@ void FmRegisterIntr(t_Handle h_Fm,
                         t_Handle    h_Arg)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    uint8_t             event= 0;
     t_FmIpcRegisterIntr fmIpcRegisterIntr;
     t_Error             err;
     t_FmIpcMsg          msg;
+    int                 event = 0;
 
     ASSERT_COND(h_Fm);
 
     GET_FM_MODULE_EVENT(module, modId,intrType, event);
+    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
 
     /* register in local FM structure */
-    ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
     p_Fm->intrMng[event].f_Isr = f_Isr;
     p_Fm->intrMng[event].h_SrcHandle = h_Arg;
 
@@ -1176,18 +1613,19 @@ void FmRegisterIntr(t_Handle h_Fm,
         if(p_Fm->h_IpcSessions[0])
         {
             /* register in Master FM structure */
-            fmIpcRegisterIntr.event = event;
+            fmIpcRegisterIntr.event = (uint32_t)event;
             fmIpcRegisterIntr.guestId = p_Fm->guestId;
             memset(&msg, 0, sizeof(msg));
             msg.msgId = FM_REGISTER_INTR;
             memcpy(msg.msgBody, &fmIpcRegisterIntr, sizeof(fmIpcRegisterIntr));
-            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+            err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                          (uint8_t*)&msg,
                                          sizeof(msg.msgId) + sizeof(fmIpcRegisterIntr),
                                          NULL,
                                          NULL,
                                          NULL,
-                                         NULL)) != E_OK)
+                                    NULL);
+            if (err != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
         }
         else
@@ -1202,13 +1640,13 @@ void FmUnregisterIntr(t_Handle h_Fm,
                         e_FmIntrType            intrType)
 {
     t_Fm       *p_Fm = (t_Fm*)h_Fm;
-    uint8_t     event= 0;
+    int         event = 0;
 
     ASSERT_COND(h_Fm);
 
     GET_FM_MODULE_EVENT(module, modId,intrType, event);
-
     ASSERT_COND(event != e_FM_EV_DUMMY_LAST);
+
     p_Fm->intrMng[event].f_Isr = UnimplementedIsr;
     p_Fm->intrMng[event].h_SrcHandle = NULL;
 }
@@ -1227,13 +1665,14 @@ void FmSetFmanCtrlIntr(t_Handle h_Fm, uint8_t   eventRegId, uint32_t enableEvent
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_SET_FMAN_CTRL_EVENTS_ENABLE;
         memcpy(msg.msgBody, &fmanCtrl, sizeof(fmanCtrl));
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId)+sizeof(fmanCtrl),
                                      NULL,
                                      NULL,
                                      NULL,
-                                     NULL)) != E_OK)
+                                NULL);
+        if (err != E_OK)
             REPORT_ERROR(MINOR, err, NO_MSG);
         return;
     }
@@ -1257,13 +1696,14 @@ uint32_t FmGetFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
         msg.msgId = FM_GET_FMAN_CTRL_EVENTS_ENABLE;
         msg.msgBody[0] = eventRegId;
         replyLength = sizeof(uint32_t) + sizeof(uint32_t);
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId)+sizeof(eventRegId),
                                      (uint8_t*)&reply,
                                      &replyLength,
                                      NULL,
-                                     NULL)) != E_OK)
+                                NULL);
+        if (err != E_OK)
         {
             REPORT_ERROR(MINOR, err, NO_MSG);
             return 0;
@@ -1393,14 +1833,9 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
 
     /* order restoration */
 
+
     tmpReg |= (orFmanCtrl << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | orFmanCtrl;
 
-    /*
-    if(hardwarePortId%2)
-        tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | FPM_PORT_FM_CTL1;
-    else
-        tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | FPM_PORT_FM_CTL2;
-    */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
     XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
 
@@ -1486,7 +1921,9 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+#ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+	if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
     if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
     {
@@ -1520,7 +1957,6 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         if(update)
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
     }
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
 #ifdef FM_LOW_END_RESTRICTION
     if((hardwarePortId==0x1) || (hardwarePortId==0x29))
@@ -1555,6 +1991,8 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], (uint32_t)p_PortParams->liodnOffset);
 
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+    {
     tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
     if(p_PortParams->independentMode)
     {
@@ -1574,15 +2012,9 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
             tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
     }
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
+    }
 
     {
-#ifdef FM_PARTITION_ARRAY
-        t_FmRevisionInfo revInfo;
-
-        FM_GetRevision(p_Fm, &revInfo);
-        if (revInfo.majorRev >= 2)
-#endif /* FM_PARTITION_ARRAY */
-        {
             /* set LIODN base for this port */
             tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
             if(hardwarePortId%2)
@@ -1597,7 +2029,6 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
             }
             WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], tmpReg);
         }
-    }
 
     FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
     XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
@@ -1620,19 +2051,18 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     {
         portParams.hardwarePortId = p_PortParams->hardwarePortId;
         portParams.enumPortType = (uint32_t)p_PortParams->portType;
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
         portParams.deqPipelineDepth = p_PortParams->deqPipelineDepth;
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
         memset(&msg, 0, sizeof(msg));
         msg.msgId = FM_FREE_PORT;
         memcpy(msg.msgBody, &portParams, sizeof(portParams));
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId)+sizeof(portParams),
                                      NULL,
                                      NULL,
                                      NULL,
-                                     NULL)) != E_OK)
+                                NULL);
+        if (err != E_OK)
             REPORT_ERROR(MINOR, err, NO_MSG);
         return;
     }
@@ -1677,7 +2107,9 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], 0);
     /* WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], 0); */
 
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+#ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+	if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
     if ((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
         (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
@@ -1703,7 +2135,6 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc, tmpReg);
     }
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
 #ifdef FM_LOW_END_RESTRICTION
     if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
@@ -2067,7 +2498,15 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     }
 
     if(extraSizeOfFifo > oldVal)
+    {
+        if(extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
+            /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
+             * must be initialized to 1 buffer per port
+             */
+            p_Fm->p_FmStateStruct->extraFifoPoolSize    = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+
         p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
+    }
 
     if(!initialConfig)
         /* read into oldVal the current num of tasks */
@@ -2235,22 +2674,33 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
 
     /* check that there are enough uncommitted open DMA's */
     ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >= oldVal);
-    if((p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas) >
-       p_Fm->p_FmStateStruct->maxNumOfOpenDmas)
+#ifndef FM_NO_TOTAL_DMAS
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) &&
+        (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas >
+		p_Fm->p_FmStateStruct->maxNumOfOpenDmas))
         RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
                      ("Requested numOfOpenDmas for fm%d exceeds total numOfOpenDmas.",
                       p_Fm->p_FmStateStruct->fmId));
+#else /* FM_NO_TOTAL_DMAS */
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev >= 6) &&
+        (p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas - oldVal + numOfOpenDmas > DMA_THRESH_MAX_COMMQ+1))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                     ("Requested numOfOpenDmas for fm%d exceeds DMA Command queue (%d)",
+                      p_Fm->p_FmStateStruct->fmId, DMA_THRESH_MAX_COMMQ+1));
+#endif /* FM_NO_TOTAL_DMAS */
     else
     {
         /* update acummulated */
         p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -= oldVal;
         p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas += numOfOpenDmas;
+
         /* calculate reg */
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
         tmpReg |= (uint32_t)(((numOfOpenDmas-1) << BMI_NUM_OF_DMAS_SHIFT) |
                     (numOfExtraOpenDmas << BMI_EXTRA_NUM_OF_DMAS_SHIFT));
         WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], tmpReg);
 
+
         /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
         tmpReg |= (uint32_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize - 1) << BMI_CFG2_DMAS_SHIFT;
@@ -2260,6 +2710,54 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     return E_OK;
 }
 
+#if DPAA_VERSION >= 3
+
+t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
+                                  e_FmPortType    portType,
+                                  uint8_t         portId,
+                                  uint16_t        relativeProfile,
+                                  uint16_t        *p_AbsoluteId)
+{
+    t_Fm         *p_Fm;
+    t_FmSp      *p_FmPcdSp;
+    uint8_t     swPortIndex=0, hardwarePortId;
+
+    ASSERT_COND(h_Fm);
+    p_Fm = (t_Fm*)h_Fm;
+
+    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    ASSERT_COND(hardwarePortId);
+    HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
+
+    p_FmPcdSp = p_Fm->p_FmSp;
+    ASSERT_COND(p_FmPcdSp);
+
+    if (!p_FmPcdSp->portsMapping[swPortIndex].numOfProfiles)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Port has no allocated profiles"));
+    if (relativeProfile >= p_FmPcdSp->portsMapping[swPortIndex].numOfProfiles)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION , ("Profile id is out of range"));
+    *p_AbsoluteId = (uint16_t)(p_FmPcdSp->portsMapping[swPortIndex].profilesBase + relativeProfile);
+
+    return E_OK;
+}
+
+void VspInvalidateProfileSw(t_Handle h_Fm, uint16_t absoluteProfileId)
+{
+    t_Fm     *p_Fm = (t_Fm*)h_Fm;
+
+    ASSERT_COND(p_Fm->p_FmSp->profiles[absoluteProfileId].valid);
+    p_Fm->p_FmSp->profiles[absoluteProfileId].valid = FALSE;
+}
+
+void VspValidateProfileSw(t_Handle h_Fm, uint16_t absoluteProfileId)
+{
+    t_Fm     *p_Fm = (t_Fm*)h_Fm;
+
+    ASSERT_COND(!p_Fm->p_FmSp->profiles[absoluteProfileId].valid);
+    p_Fm->p_FmSp->profiles[absoluteProfileId].valid = TRUE;
+}
+#endif /* DPAA_VERSION >= 3 */
+
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FmDumpPortRegs (t_Handle h_Fm,uint8_t hardwarePortId)
 {
@@ -2371,10 +2869,12 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->independentMode   = FALSE;
     p_Fm->p_FmStateStruct->ramsEccEnable     = FALSE;
     p_Fm->p_FmStateStruct->totalNumOfTasks   = BMI_MAX_NUM_OF_TASKS;
-    p_Fm->p_FmStateStruct->totalFifoSize     = DEFAULT_totalFifoSize;
     p_Fm->p_FmStateStruct->maxNumOfOpenDmas  = BMI_MAX_NUM_OF_DMAS;
-    p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
+    p_Fm->p_FmStateStruct->extraFifoPoolSize    = 0;
     p_Fm->p_FmStateStruct->exceptions        = DEFAULT_exceptions;
+    /* Chip dependent, will be configured in Init */
+    p_Fm->p_FmStateStruct->totalFifoSize        = 0;
+
     for(i = 0;i<FM_MAX_NUM_OF_1G_MACS;i++)
         p_Fm->p_FmStateStruct->macMaxFrameLengths1G[i] = DEFAULT_mtu;
 #if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
@@ -2392,14 +2892,9 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         return NULL;
     }
 
-#ifdef FM_PARTITION_ARRAY
-    /* Initialize FM driver parameters parameters (for initialization phase only) */
-    memcpy(p_Fm->p_FmDriverParam->liodnBasePerPort, p_FmParam->liodnBasePerPort, FM_SIZE_OF_LIODN_TABLE*sizeof(uint16_t));
-#endif /* FM_PARTITION_ARRAY */
-
     /*p_Fm->p_FmDriverParam->numOfPartitions                      = p_FmParam->numOfPartitions;    */
     p_Fm->p_FmDriverParam->enCounters                           = FALSE;
-
+    p_Fm->p_FmDriverParam->tnumAgingPeriod                      = 0;
     p_Fm->p_FmDriverParam->resetOnInit                          = DEFAULT_resetOnInit;
 
     p_Fm->p_FmDriverParam->thresholds.dispLimit                 = DEFAULT_dispLimit;
@@ -2458,6 +2953,12 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         memcpy(p_Fm->p_FmDriverParam->firmware.p_Code, p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
     }
 
+#if DPAA_VERSION >= 3
+    p_Fm->partVSPBase   = p_FmParam->partVSPBase;
+    p_Fm->partNumOfVSPs = p_FmParam->partNumOfVSPs;
+    p_Fm->vspBaseAddr = p_FmParam->vspBaseAddr;
+#endif /* DPAA_VERSION >= 3 */
+
     return p_Fm;
 }
 
@@ -2479,16 +2980,26 @@ t_Error FM_Init(t_Handle h_Fm)
     int                     i;
     uint16_t                periodInFmClocks;
     uint8_t                 remainder;
-    t_FmRevisionInfo        revInfo;
 
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
 
+#if DPAA_VERSION >= 3
+    p_Fm->p_FmSp = (t_FmSp*)XX_Malloc(sizeof(t_FmSp));
+    if (!p_Fm->p_FmSp)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation for internal data structure failed"));
+
+    memset(p_Fm->p_FmSp, 0, sizeof(t_FmSp));
+    for (i = 0; i < FM_VSP_MAX_NUM_OF_ENTRIES; i++)
+        p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
+#endif /* DPAA_VERSION >= 3 */
+
     if(p_Fm->guestId != NCSW_MASTER_ID)
     {
         uint8_t             isMasterAlive;
         t_FmIpcMsg          msg;
         t_FmIpcReply        reply;
         uint32_t            replyLength;
+        t_FmIpcParams       ipcParams;
 
         /* build the FM guest partition IPC address */
         if(Sprint (p_Fm->fmModuleName, "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, p_Fm->guestId) != (p_Fm->guestId<10 ? 6:7))
@@ -2531,10 +3042,11 @@ t_Error FM_Init(t_Handle h_Fm)
                 isMasterAlive = *(uint8_t*)(reply.replyBody);
             } while (!isMasterAlive);
 
+            /* read FM parameters and save */
             memset(&msg, 0, sizeof(msg));
             memset(&reply, 0, sizeof(reply));
-            msg.msgId = FM_GET_CLK_FREQ;
-            replyLength = sizeof(uint32_t) + sizeof(p_Fm->p_FmStateStruct->fmClkFreq);
+            msg.msgId = FM_GET_PARAMS;
+            replyLength = sizeof(uint32_t) + sizeof(t_FmIpcParams);
             if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                          (uint8_t*)&msg,
                                          sizeof(msg.msgId),
@@ -2543,9 +3055,14 @@ t_Error FM_Init(t_Handle h_Fm)
                                          NULL,
                                          NULL)) != E_OK)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
-            if(replyLength != (sizeof(uint32_t) + sizeof(p_Fm->p_FmStateStruct->fmClkFreq)))
+            if(replyLength != (sizeof(uint32_t) + sizeof(t_FmIpcParams)))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-            memcpy((uint8_t*)&p_Fm->p_FmStateStruct->fmClkFreq, reply.replyBody, sizeof(uint16_t));
+            memcpy((uint8_t*)&ipcParams, reply.replyBody, sizeof(t_FmIpcParams));
+
+            p_Fm->p_FmStateStruct->fmClkFreq = ipcParams.fmClkFreq;
+            p_Fm->p_FmStateStruct->revInfo.majorRev = ipcParams.majorRev;
+            p_Fm->p_FmStateStruct->revInfo.minorRev = ipcParams.minorRev;
+
         }
         else
         {
@@ -2556,8 +3073,43 @@ t_Error FM_Init(t_Handle h_Fm)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No baseAddr configured for guest without IPC"));
         }
 
-        XX_Free(p_Fm->p_FmDriverParam);
-        p_Fm->p_FmDriverParam = NULL;
+#if DPAA_VERSION >= 3
+        if (p_Fm->h_IpcSessions[p_Fm->guestId])
+        {
+            t_FmIpcVspAllocParams   fmIpcVspAllocParams;
+
+            memset(&msg, 0, sizeof(msg));
+            memset(&reply, 0, sizeof(reply));
+            memset(&fmIpcVspAllocParams, 0, sizeof(t_FmIpcVspAllocParams));
+            fmIpcVspAllocParams.guestId         = p_Fm->guestId;
+            fmIpcVspAllocParams.numOfProfiles   = p_Fm->partNumOfVSPs;
+            fmIpcVspAllocParams.base            = p_Fm->partVSPBase;
+            msg.msgId                           = FM_VSP_ALLOC;
+            memcpy(msg.msgBody, &fmIpcVspAllocParams, sizeof(t_FmIpcVspAllocParams));
+            replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                             (uint8_t*)&msg,
+                                             sizeof(msg.msgId) + sizeof(t_FmIpcVspAllocParams),
+                                             (uint8_t*)&reply,
+                                             &replyLength,
+                                             NULL,
+                                             NULL)) != E_OK)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+
+            if ((err != E_OK) ||
+                (replyLength != (sizeof(uint32_t) + sizeof(uint8_t))))
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            else
+                memcpy((uint8_t*)&p_Fm->partVSPBase, reply.replyBody, sizeof(uint8_t));
+            if (p_Fm->partVSPBase == ILLEGAL_BASE)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+        else
+            DBG(WARNING, ("FM Guest mode, without IPC - can't validate VSP range!"));
+#endif /* DPAA_VERSION >= 3 */
+
+        XX_Free(p_Fm->p_FmDriverParam);
+        p_Fm->p_FmDriverParam = NULL;
 
         if ((p_Fm->guestId == NCSW_MASTER_ID) ||
             (p_Fm->h_IpcSessions[0]))
@@ -2570,26 +3122,48 @@ t_Error FM_Init(t_Handle h_Fm)
         return E_OK;
     }
 
+
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
-    FM_GetRevision(p_Fm, &revInfo);
+    /* read revision register 1 */
+    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
+    p_Fm->p_FmStateStruct->revInfo.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
+    p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
 
+    /* if user didn't configured totalFifoSize - (totalFifoSize=0) we configure default
+     * according to chip. otherwise, we use user's configuration.
+     */
+    if(p_Fm->p_FmStateStruct->totalFifoSize == 0)
+        p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev);
+
+    CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
+
+    p_FmDriverParam = p_Fm->p_FmDriverParam;
+
+    /* clear revision-dependent non existing exception */
 #ifdef FM_NO_DISPATCH_RAM_ECC
-    if (revInfo.majorRev != 4)
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
         p_Fm->p_FmStateStruct->exceptions &= ~FM_EX_BMI_DISPATCH_RAM_ECC;
 #endif /* FM_NO_DISPATCH_RAM_ECC */
 
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
-    if (revInfo.majorRev == 4)
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
         p_Fm->p_FmStateStruct->exceptions  &= ~(FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC);
 #endif /* FM_QMI_NO_ECC_EXCEPTIONS */
 
-    CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
-
-    p_FmDriverParam = p_Fm->p_FmDriverParam;
+#ifdef FM_QMI_NO_SINGLE_ECC_EXCEPTION
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+       p_Fm->p_FmStateStruct->exceptions &= ~FM_EX_QMI_SINGLE_ECC;
+#endif /* FM_QMI_NO_SINGLE_ECC_EXCEPTION */
 
     FmMuramClear(p_Fm->h_FmMuram);
 
+    /* clear CPG */
+    IOMemSet32(UINT_TO_PTR(p_Fm->baseAddr + FM_MM_CGP), 0, FM_PORT_NUM_OF_CONGESTION_GRPS);
+
+    /* add to the default exceptions the user's definitions */
+    p_Fm->p_FmStateStruct->exceptions |= p_FmDriverParam->userSetExceptions;
+
 #ifdef FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
     if (p_FmDriverParam->resetOnInit)
     {
@@ -2662,6 +3236,12 @@ t_Error FM_Init(t_Handle h_Fm)
     WRITE_BLOCK(UINT_TO_PTR(p_Fm->resAddr), 0, 256);
 #endif /* FM_CAPWAP_SUPPORT */
 
+#if DPAA_VERSION >= 3
+    p_Fm->partVSPBase = FmVSPsAlloc(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
+    if (p_Fm->partVSPBase == ILLEGAL_BASE)
+        DBG(WARNING, ("partition VSPs allocation is FAILED"));
+#endif /* DPAA_VERSION >= 3 */
+
     /* General FM driver initialization */
     p_Fm->fmMuramPhysBaseAddr = (uint64_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->baseAddr + FM_MM_MURAM)));
     for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
@@ -2673,8 +3253,10 @@ t_Error FM_Init(t_Handle h_Fm)
     /* Init DMA Registers */
     /**********************/
     /* clear status reg events */
-    tmpReg = (DMA_STATUS_BUS_ERR | DMA_STATUS_READ_ECC | DMA_STATUS_SYSTEM_WRITE_ECC | DMA_STATUS_FM_WRITE_ECC);
-    /*tmpReg |= (DMA_STATUS_SYSTEM_DPEXT_ECC | DMA_STATUS_FM_DPEXT_ECC | DMA_STATUS_SYSTEM_DPDAT_ECC | DMA_STATUS_FM_DPDAT_ECC | DMA_STATUS_FM_SPDAT_ECC);*/
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        tmpReg = DMA_STATUS_FM_SPDAT_ECC;
+    else
+        tmpReg = DMA_STATUS_FM_ECC;
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr) | tmpReg);
 
     /* configure mode register */
@@ -2684,8 +3266,16 @@ t_Error FM_Init(t_Handle h_Fm)
         tmpReg |= DMA_MODE_AID_OR;
     if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_BUS_ERROR)
         tmpReg |= DMA_MODE_BER;
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+    {
+        if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SINGLE_PORT_ECC)
+            tmpReg |= DMA_MODE_ECC;
+    }
+    else
+    {
     if ((p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_FM_WRITE_ECC))
         tmpReg |= DMA_MODE_ECC;
+    }
     if(p_FmDriverParam->dmaStopOnBusError)
         tmpReg |= DMA_MODE_SBER;
     tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
@@ -2733,14 +3323,11 @@ t_Error FM_Init(t_Handle h_Fm)
     if (!p_Fm->camBaseAddr )
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
 
-    WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr), 0, (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
+    WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
+                0,
+                (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    {
-        t_FmRevisionInfo revInfo;
-
-        FM_GetRevision(p_Fm, &revInfo);
-        if (revInfo.majorRev == 2)
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev == 2)
         {
             FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
 
@@ -2750,51 +3337,34 @@ t_Error FM_Init(t_Handle h_Fm)
             if (!p_Fm->camBaseAddr)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
 
-            WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr), 0, (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128));
+        WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr),
+                   0,
+                   (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128));
 
             switch(p_FmDriverParam->dmaCamNumOfEntries)
             {
                 case(8):
-                    *(volatile uint32_t*)p_Fm->camBaseAddr = 0xff000000;
+                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xff000000);
                     break;
                 case(16):
-                    *(volatile uint32_t*)p_Fm->camBaseAddr = 0xffff0000;
-/*                    WRITE_UINT32(p_Fm->camBaseAddr, 0xffff0000); */
+                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffff0000);
                     break;
                 case(24):
-                    *(volatile uint32_t*)p_Fm->camBaseAddr = 0xffffff00;
-/*                    WRITE_UINT32(p_Fm->camBaseAddr, 0xffffff00); */
+                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffffff00);
                     break;
                 case(32):
-                    *(volatile uint32_t*)p_Fm->camBaseAddr = 0xffffffff;
-/*                    WRITE_UINT32(p_Fm->camBaseAddr, 0xffffffff); */
+                WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xffffffff);
                     break;
                 default:
+		FreeInitResources(p_Fm);
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("wrong dmaCamNumOfEntries"));
             }
         }
-    }
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     /* VirtToPhys */
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
                  (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->camBaseAddr)) - p_Fm->fmMuramPhysBaseAddr));
 
-#ifdef FM_PARTITION_ARRAY
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            /* liodn-partitions */
-            for (i=0 ; i<FM_SIZE_OF_LIODN_TABLE ; i+=2)
-            {
-                tmpReg = (((uint32_t)p_FmDriverParam->liodnBasePerPort[i] << DMA_LIODN_SHIFT) |
-                            (uint32_t)p_FmDriverParam->liodnBasePerPort[i+1]);
-                WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[i/2], tmpReg);
-            }
-    }
-#endif /* FM_PARTITION_ARRAY */
-
     /**********************/
     /* Init FPM Registers */
     /**********************/
@@ -2813,6 +3383,7 @@ t_Error FM_Init(t_Handle h_Fm)
                 ((uint32_t)p_FmDriverParam->thresholds.fmCtl2DispTh  << FPM_THR2_FM_CTL2_SHIFT));
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmdis2, tmpReg);
 
+
     /* define exceptions and error behavior */
     tmpReg = 0;
     /* Clear events */
@@ -2859,7 +3430,7 @@ t_Error FM_Init(t_Handle h_Fm)
         tmpReg |= FPM_IRAM_ECC_ERR_EX_EN;
         FmEnableRamsEcc(p_Fm);
     }
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_NURAM_ECC)
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_MURAM_ECC)
     {
         tmpReg |= FPM_MURAM_ECC_ERR_EX_EN;
         FmEnableRamsEcc(p_Fm);
@@ -2876,7 +3447,10 @@ t_Error FM_Init(t_Handle h_Fm)
                                                        p_Fm->p_FmStateStruct->totalFifoSize,
                                                        BMI_FIFO_ALIGN));
     if (!p_Fm->fifoBaseAddr)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for FIFO failed"));
+    {
+	FreeInitResources(p_Fm);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for BMI FIFO failed"));
+    }
 
     tmpReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->fifoBaseAddr)) - p_Fm->fmMuramPhysBaseAddr);
     tmpReg = tmpReg / BMI_FIFO_ALIGN;
@@ -2891,13 +3465,13 @@ t_Error FM_Init(t_Handle h_Fm)
     /* define unmaskable exceptions, enable and clear events */
     tmpReg = 0;
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ievr, (BMI_ERR_INTR_EN_LIST_RAM_ECC |
-                                                BMI_ERR_INTR_EN_PIPELINE_ECC |
+                                                BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC |
                                                 BMI_ERR_INTR_EN_STATISTICS_RAM_ECC |
                                                 BMI_ERR_INTR_EN_DISPATCH_RAM_ECC));
     if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC)
         tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_PIPELINE_ECC)
-        tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
+    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STORAGE_PROFILE_ECC)
+        tmpReg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
     if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC)
         tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
     if(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC)
@@ -2937,19 +3511,23 @@ t_Error FM_Init(t_Handle h_Fm)
     }
     tmpReg = 0;
     /* Clear interrupt events */
+    if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
+    {
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
     if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
         tmpReg |= QMI_INTR_EN_SINGLE_ECC;
     /* enable events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
+    }
 
     /* clear & enable global counters  - calculate reg and save for later,
        because it's the same reg for QMI enable */
     if(p_Fm->p_FmDriverParam->enCounters)
         cfgReg = QMI_CFG_EN_COUNTERS;
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
+#ifndef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+	if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
     cfgReg |= (uint32_t)(((QMI_DEF_TNUMS_THRESH) << 8) |  (uint32_t)QMI_DEF_TNUMS_THRESH);
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
+#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
     if (p_Fm->p_FmStateStruct->irq != NO_IRQ)
     {
@@ -2965,11 +3543,17 @@ t_Error FM_Init(t_Handle h_Fm)
 
     /* build the FM master partition IPC address */
     if (Sprint (p_Fm->fmModuleName, "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, NCSW_MASTER_ID) != 6)
+    {
+	FreeInitResources(p_Fm);
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+    }
 
     err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
     if(err)
+    {
+	FreeInitResources(p_Fm);
         RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 
     /**********************/
     /* Enable all modules */
@@ -2983,6 +3567,7 @@ t_Error FM_Init(t_Handle h_Fm)
         p_Fm->p_FmDriverParam->firmware.p_Code = NULL;
     }
 
+
     XX_Free(p_Fm->p_FmDriverParam);
     p_Fm->p_FmDriverParam = NULL;
 
@@ -3008,6 +3593,38 @@ t_Error FM_Free(t_Handle h_Fm)
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
+#if DPAA_VERSION >= 3
+        if (p_Fm->h_IpcSessions[0])
+        {
+            t_FmIpcMsg          msg;
+            t_FmIpcReply        reply;
+            uint32_t            replyLength;
+            t_FmIpcVspAllocParams   fmIpcVspAllocParams;
+            t_Error             err;
+
+            memset(&msg, 0, sizeof(msg));
+            memset(&reply, 0, sizeof(reply));
+            memset(&fmIpcVspAllocParams, 0, sizeof(t_FmIpcVspAllocParams));
+            fmIpcVspAllocParams.guestId         = p_Fm->guestId;
+            fmIpcVspAllocParams.numOfProfiles   = p_Fm->partNumOfVSPs;
+            fmIpcVspAllocParams.base            = p_Fm->partVSPBase;
+            msg.msgId                           = FM_VSP_FREE;
+            memcpy(msg.msgBody, &fmIpcVspAllocParams, sizeof(t_FmIpcVspAllocParams));
+            replyLength = sizeof(uint32_t) + sizeof(uint8_t);
+            if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+                                             (uint8_t*)&msg,
+                                             sizeof(msg.msgId) + sizeof(t_FmIpcVspAllocParams),
+                                             (uint8_t*)&reply,
+                                             &replyLength,
+                                             NULL,
+                                             NULL)) != E_OK)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+
+            if (err != E_OK)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+        }
+#endif /* DPAA_VERSION >= 3 */
+
         XX_IpcUnregisterMsgHandler(p_Fm->fmModuleName);
 
         if(!p_Fm->recoveryMode)
@@ -3046,6 +3663,16 @@ t_Error FM_Free(t_Handle h_Fm)
         }
     }
 
+#if DPAA_VERSION >= 3
+    FmVSPsFree(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
+
+    if (p_Fm->p_FmSp)
+    {
+        XX_Free(p_Fm->p_FmSp);
+        p_Fm->p_FmSp = NULL;
+    }
+#endif /* DPAA_VERSION >= 3 */
+
     if (p_Fm->h_Spinlock)
         XX_FreeSpinlock(p_Fm->h_Spinlock);
 
@@ -3098,18 +3725,6 @@ t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize)
 }
 
 
-t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-
-    memcpy(&p_Fm->p_FmDriverParam->thresholds, p_FmThresholds, sizeof(t_FmThresholds));
-
-    return E_OK;
-}
-
 t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
@@ -3170,64 +3785,6 @@ t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries)
     return E_OK;
 }
 
-t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
-{
-    t_Fm                *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-
-#ifdef FM_NO_WATCHDOG
-    {
-        t_FmRevisionInfo    revInfo;
-        FM_GetRevision(h_Fm, &revInfo);
-        if (revInfo.majorRev != 4)
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("watchdog!"));
-    }
-#endif /* FM_NO_WATCHDOG */
-
-    p_Fm->p_FmDriverParam->dmaWatchdog = watchdogValue;
-
-    return E_OK;
-}
-
-t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
-
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-
-    memcpy(&p_Fm->p_FmDriverParam->dmaWriteBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
-
-    return E_OK;
-}
-
-t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-
-    memcpy(&p_Fm->p_FmDriverParam->dmaCommQThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
-
-    return E_OK;
-}
-
-t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-
-    memcpy(&p_Fm->p_FmDriverParam->dmaReadBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
-
-    return E_OK;
-}
-
 t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
@@ -3281,18 +3838,6 @@ t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop)
     return E_OK;
 }
 
-t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-
-    p_Fm->p_FmDriverParam->dmaSosEmergency = dmaSosEmergency;
-
-    return E_OK;
-}
-
 t_Error FM_ConfigEnableCounters(t_Handle h_Fm)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
@@ -3336,6 +3881,9 @@ t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_ConfigEnableMuramTestMode!"));
+
     p_Fm->p_FmDriverParam->enMuramTestMode = TRUE;
 
     return E_OK;
@@ -3348,6 +3896,9 @@ t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_ConfigEnableMuramTestMode!"));
+
     p_Fm->p_FmDriverParam->enIramTestMode = TRUE;
 
     return E_OK;
@@ -3367,56 +3918,30 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable)
 
 t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable)
 {
-#ifdef FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
-#else  /* not FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
-    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError = enable;
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_ConfigHaltOnUnrecoverableEccError"));
 
+    p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError = enable;
     return E_OK;
-#endif /* not FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
 }
 
 t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
     uint32_t            bitMask = 0;
-    t_FmRevisionInfo    revInfo;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-    FM_GetRevision(p_Fm, &revInfo);
-#ifdef FM_QMI_NO_ECC_EXCEPTIONS
-    if(((exception == e_FM_EX_QMI_SINGLE_ECC) || (exception == e_FM_EX_QMI_DOUBLE_ECC)) &&
-            enable)
-    {
-        if (revInfo.majorRev == 4)
-        {
-            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("QMI ECC exception!"));
-            return E_OK;
-        }
-    }
-#endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
-#ifdef FM_NO_DISPATCH_RAM_ECC
-    if((exception == e_FM_EX_BMI_DISPATCH_RAM_ECC) && (enable))
-    {
-        if (revInfo.majorRev != 4)
-        {
-            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_DISPATCH_RAM_ECC!"));
-            return E_OK;
-        }
-    }
-#endif   /* FM_NO_DISPATCH_RAM_ECC */
-
     GET_EXCEPTION_FLAG(bitMask, exception);
     if(bitMask)
     {
         if (enable)
-            p_Fm->p_FmStateStruct->exceptions |= bitMask;
+            p_Fm->p_FmDriverParam->userSetExceptions |= bitMask;
         else
             p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
    }
@@ -3440,18 +3965,9 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable)
 t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod)
 {
     t_Fm             *p_Fm = (t_Fm*)h_Fm;
-#ifdef FM_NO_TNUM_AGING
-    t_FmRevisionInfo revInfo;
-#endif /* FM_NO_TNUM_AGING */
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-#ifdef FM_NO_TNUM_AGING
-    FM_GetRevision(h_Fm, &revInfo);
-    if (revInfo.majorRev != 4)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_ConfigTnumAgingPeriod!"));
-#endif /* FM_NO_TNUM_AGING */
-
     p_Fm->p_FmDriverParam->tnumAgingPeriod = tnumAgingPeriod;
 
     return E_OK;
@@ -3459,24 +3975,161 @@ t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod)
 }
 
 /****************************************************/
-/*       API Run-time Control uint functions        */
+/*       Hidden-DEBUG Only API                      */
 /****************************************************/
-t_Handle FM_GetPcdHandle(t_Handle h_Fm)
+
+t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaSosEmergency = dmaSosEmergency;
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaCommQThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Functionality not supported on this integration."));
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaReadBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Functionality not supported on this integration."));
+
+    memcpy(&p_Fm->p_FmDriverParam->dmaWriteBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_Fm->p_FmDriverParam->thresholds, p_FmThresholds, sizeof(t_FmThresholds));
+
+    return E_OK;
+}
+
+t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
 {
-    SANITY_CHECK_RETURN_VALUE(h_Fm, E_INVALID_HANDLE, NULL);
-    SANITY_CHECK_RETURN_VALUE(!((t_Fm*)h_Fm)->p_FmDriverParam, E_INVALID_STATE, NULL);
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+
+    p_Fm->p_FmDriverParam->dmaWatchdog = watchdogValue;
 
-    return ((t_Fm*)h_Fm)->h_Pcd;
+    return E_OK;
 }
 
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    switch(exception)
+{
+        case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DEQ_FROM_DEF);
+            break;
+        case e_FM_EX_QMI_SINGLE_ECC:
+            if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_SINGLE_ECC not supported on this integration."));
+
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, QMI_INTR_EN_SINGLE_ECC);
+            break;
+        case e_FM_EX_QMI_DOUBLE_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DOUBLE_ECC);
+            break;
+        case e_FM_EX_BMI_LIST_RAM_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_LIST_RAM_ECC);
+            break;
+        case e_FM_EX_BMI_STORAGE_PROFILE_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STORAGE_PROFILE_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC);
+            break;
+        case e_FM_EX_BMI_STATISTICS_RAM_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STATISTICS_RAM_ECC);
+            break;
+        case e_FM_EX_BMI_DISPATCH_RAM_ECC:
+            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC))
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
+            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_DISPATCH_RAM_ECC);
+            break;
+        default:
+            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
+    }
+
+    return E_OK;
+}
+
+
+/****************************************************/
+/*       API Run-time Control uint functions        */
+/****************************************************/
 void FM_EventIsr(t_Handle h_Fm)
 {
-#define FM_M_CALL_1G_MAC_TMR_ISR(_id)   \
+#define FM_M_CALL_1G_MAC_ISR(_id)   \
     {                                   \
-        if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0_TMR+_id)].guestId)    \
-            SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_1G_MAC0_TMR+_id), pending);                 \
+        if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].guestId)    \
+            SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id), pending);                 \
         else                                                                                            \
-            p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0_TMR+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0_TMR+_id)].h_SrcHandle);\
+            p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].h_SrcHandle);\
+    }
+#define FM_M_CALL_10G_MAC_ISR(_id)   \
+    {                                   \
+        if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id)].guestId)    \
+            SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id), pending);                 \
+        else                                                                                            \
+            p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id)].h_SrcHandle);\
     }
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
     uint32_t                pending, event;
@@ -3486,30 +4139,36 @@ void FM_EventIsr(t_Handle h_Fm)
     /* normal interrupts */
     pending = GET_UINT32(p_Fm->p_FmFpmRegs->fmnpi);
     ASSERT_COND(pending);
-    if (pending & INTR_EN_BMI)
-        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("BMI Event - undefined!"));
     if (pending & INTR_EN_QMI)
         QmiEvent(p_Fm);
     if (pending & INTR_EN_PRS)
         p_Fm->intrMng[e_FM_EV_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_PRS].h_SrcHandle);
     if (pending & INTR_EN_PLCR)
         p_Fm->intrMng[e_FM_EV_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_PLCR].h_SrcHandle);
-    if (pending & INTR_EN_KG)
-        p_Fm->intrMng[e_FM_EV_KG].f_Isr(p_Fm->intrMng[e_FM_EV_KG].h_SrcHandle);
     if (pending & INTR_EN_TMR)
             p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
 
     /* MAC events may belong to different partitions */
-    if (pending & INTR_EN_1G_MAC0_TMR)
-        FM_M_CALL_1G_MAC_TMR_ISR(0);
-    if (pending & INTR_EN_1G_MAC1_TMR)
-        FM_M_CALL_1G_MAC_TMR_ISR(1);
-    if (pending & INTR_EN_1G_MAC2_TMR)
-        FM_M_CALL_1G_MAC_TMR_ISR(2);
-    if (pending & INTR_EN_1G_MAC3_TMR)
-        FM_M_CALL_1G_MAC_TMR_ISR(3);
-    if (pending & INTR_EN_1G_MAC4_TMR)
-        FM_M_CALL_1G_MAC_TMR_ISR(4);
+    if (pending & INTR_EN_1G_MAC0)
+        FM_M_CALL_1G_MAC_ISR(0);
+    if (pending & INTR_EN_1G_MAC1)
+        FM_M_CALL_1G_MAC_ISR(1);
+    if (pending & INTR_EN_1G_MAC2)
+        FM_M_CALL_1G_MAC_ISR(2);
+    if (pending & INTR_EN_1G_MAC3)
+        FM_M_CALL_1G_MAC_ISR(3);
+    if (pending & INTR_EN_1G_MAC4)
+        FM_M_CALL_1G_MAC_ISR(4);
+    if (pending & INTR_EN_1G_MAC5)
+        FM_M_CALL_1G_MAC_ISR(5);
+    if (pending & INTR_EN_1G_MAC6)
+        FM_M_CALL_1G_MAC_ISR(6);
+    if (pending & INTR_EN_1G_MAC7)
+        FM_M_CALL_1G_MAC_ISR(7);
+    if (pending & INTR_EN_10G_MAC0)
+        FM_M_CALL_10G_MAC_ISR(0);
+    if (pending & INTR_EN_10G_MAC1)
+        FM_M_CALL_10G_MAC_ISR(1);
 
     /* IM port events may belong to different partitions */
     if (pending & INTR_EN_REV0)
@@ -3679,7 +4338,7 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm)
         tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmrcr);
         if(tmpReg & FPM_RAM_CTL_RAMS_ECC_EN_SRC_SEL)
         {
-            DBG(WARNING, ("Rams ECC is configured to be controlled through JTAG"));
+           // DBG(WARNING, ("Rams ECC is configured to be controlled through JTAG"));
             WRITE_UINT32(p_Fm->p_FmFpmRegs->fmrcr, tmpReg | FPM_RAM_CTL_IRAM_ECC_EN);
         }
         else
@@ -3810,39 +4469,31 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg);
                 break;
             case( e_FM_EX_QMI_SINGLE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
-                if(enable)
-                {
-#ifdef FM_QMI_NO_ECC_EXCEPTIONS
-                    t_FmRevisionInfo revInfo;
-                    FM_GetRevision(p_Fm, &revInfo);
-                    if (revInfo.majorRev == 4)
+#if defined(FM_QMI_NO_ECC_EXCEPTIONS) || defined(FM_QMI_NO_SINGLE_ECC_EXCEPTION)
+               if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 4) || (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
                     {
                        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_SINGLE_ECC"));
                        return E_OK;
                     }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
+                if(enable)
                     tmpReg |= QMI_INTR_EN_SINGLE_ECC;
-                }
                 else
                     tmpReg &= ~QMI_INTR_EN_SINGLE_ECC;
                 WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
                 break;
              case(e_FM_EX_QMI_DOUBLE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-                if(enable)
-                {
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
-                    t_FmRevisionInfo revInfo;
-                    FM_GetRevision(p_Fm, &revInfo);
-                    if (revInfo.majorRev == 4)
+                if (p_Fm->p_FmStateStruct->revInfo.majorRev == 4)
                     {
                        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_QMI_DOUBLE_ECC"));
                        return E_OK;
                     }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
+                tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
+                if(enable)
                     tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
-                }
                 else
                     tmpReg &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
                 WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
@@ -3863,12 +4514,12 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                     tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
                 break;
-             case(e_FM_EX_BMI_PIPELINE_ECC):
+             case(e_FM_EX_BMI_STORAGE_PROFILE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
                 if(enable)
-                    tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
+                    tmpReg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
                 else
-                    tmpReg &= ~BMI_ERR_INTR_EN_PIPELINE_ECC;
+                    tmpReg &= ~BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
                 break;
              case(e_FM_EX_BMI_STATISTICS_RAM_ECC):
@@ -3884,9 +4535,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                if(enable)
                {
 #ifdef FM_NO_DISPATCH_RAM_ECC
-                   t_FmRevisionInfo     revInfo;
-                   FM_GetRevision(p_Fm, &revInfo);
-                   if (revInfo.majorRev != 4)
+                   if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
                    {
                        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_DISPATCH_RAM_ECC"));
                        return E_OK;
@@ -3947,22 +4596,32 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 t_Error FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    uint32_t            tmpReg;
+
+    p_FmRevisionInfo->majorRev = p_Fm->p_FmStateStruct->revInfo.majorRev;
+    p_FmRevisionInfo->minorRev = p_Fm->p_FmStateStruct->revInfo.minorRev;
+
+    return E_OK;
+}
+
+t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_RevisionInfo)
+{
+    t_Fm                            *p_Fm = (t_Fm*)h_Fm;
+    t_FMIramRegs                    *p_Iram;
     t_Error             err;
     t_FmIpcMsg          msg;
     t_FmIpcReply        reply;
-    uint32_t            replyLength;
-    t_FmIpcRevisionInfo ipcRevInfo;
+    uint32_t                        replyLength, revInfo;
+    t_FmIpcFmanCtrlCodeRevisionInfo ipcRevInfo;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_FmRevisionInfo, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_RevisionInfo, E_NULL_POINTER);
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
-        msg.msgId = FM_GET_REV;
-        replyLength = sizeof(uint32_t) + sizeof(t_FmRevisionInfo);
+        msg.msgId = FM_GET_FMAN_CTRL_CODE_REV;
+        replyLength = sizeof(uint32_t) + sizeof(t_FmCtrlCodeRevisionInfo);
         if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId),
@@ -3971,39 +4630,22 @@ t_Error FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
-        if (replyLength != (sizeof(uint32_t) + sizeof(t_FmRevisionInfo)))
+        if (replyLength != (sizeof(uint32_t) + sizeof(t_FmCtrlCodeRevisionInfo)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        memcpy((uint8_t*)&ipcRevInfo, reply.replyBody, sizeof(t_FmRevisionInfo));
-        p_FmRevisionInfo->majorRev = ipcRevInfo.majorRev;
-        p_FmRevisionInfo->minorRev = ipcRevInfo.minorRev;
+        memcpy((uint8_t*)&ipcRevInfo, reply.replyBody, sizeof(t_FmCtrlCodeRevisionInfo));
+        p_RevisionInfo->packageRev = ipcRevInfo.packageRev;
+        p_RevisionInfo->majorRev = ipcRevInfo.majorRev;
+        p_RevisionInfo->minorRev = ipcRevInfo.minorRev;
         return (t_Error)(reply.error);
     }
 
-    /* read revision register 1 */
-    tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_ip_rev_1);
-    p_FmRevisionInfo->majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
-    p_FmRevisionInfo->minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
-
-    return E_OK;
-}
-
-t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_RevisionInfo)
-{
-    t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    t_FMIramRegs        *p_Iram;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_RevisionInfo, E_NULL_POINTER);
-
-    if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("IPC"));
-
     p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
     WRITE_UINT32(p_Iram->iadd, 0x4);
     while (GET_UINT32(p_Iram->iadd) != 0x4) ;
-    p_RevisionInfo->packageRev = ((uint16_t *)&p_Iram->idata)[0];
-    p_RevisionInfo->majorRev = ((uint8_t *)&p_Iram->idata)[2];
-    p_RevisionInfo->minorRev = ((uint8_t *)&p_Iram->idata)[3];
+    revInfo = GET_UINT32(p_Iram->idata);
+    p_RevisionInfo->packageRev = (uint16_t)((revInfo & 0xFFFF0000) >> 16);
+    p_RevisionInfo->majorRev = (uint8_t)((revInfo & 0x0000FF00) >> 8);
+    p_RevisionInfo->minorRev = (uint8_t)(revInfo & 0x000000FF);
 
     return E_OK;
 }
@@ -4020,7 +4662,6 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
 
-
     if(p_Fm->guestId != NCSW_MASTER_ID)
     {
         memset(&msg, 0, sizeof(msg));
@@ -4043,6 +4684,29 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
         return outCounter;
      }
 
+    /* When applicable (when there is an 'enable counters' bit,
+    check that counters are enabled */
+    switch(counter)
+    {
+        case(e_FM_COUNTERS_DEQ_1):
+        case(e_FM_COUNTERS_DEQ_2):
+        case(e_FM_COUNTERS_DEQ_3):
+              if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_0):
+        case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
+        case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
+        case(e_FM_COUNTERS_DEQ_FROM_FD):
+        case(e_FM_COUNTERS_DEQ_CONFIRM):
+            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            break;
+        default:
+            break;
+    }
+
     switch(counter)
     {
         case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
@@ -4065,13 +4729,6 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dffc);
         case(e_FM_COUNTERS_DEQ_CONFIRM):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc);
-        case(e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT):
-            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsefrc);
-        case(e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT):
-            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsqfrc);
-        case(e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT):
-            return GET_UINT32(p_Fm->p_FmDmaRegs->fmdmssrc);
-        default:
             break;
     }
     /* should never get here */
@@ -4091,12 +4748,14 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
     check that counters are enabled */
     switch(counter)
     {
-        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
-        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
-        case(e_FM_COUNTERS_DEQ_0):
         case(e_FM_COUNTERS_DEQ_1):
         case(e_FM_COUNTERS_DEQ_2):
         case(e_FM_COUNTERS_DEQ_3):
+             if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
+        case(e_FM_COUNTERS_ENQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_TOTAL_FRAME):
+        case(e_FM_COUNTERS_DEQ_0):
         case(e_FM_COUNTERS_DEQ_FROM_DEFAULT):
         case(e_FM_COUNTERS_DEQ_FROM_CONTEXT):
         case(e_FM_COUNTERS_DEQ_FROM_FD):
@@ -4141,15 +4800,6 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
         case(e_FM_COUNTERS_DEQ_CONFIRM):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_dcc, val);
             break;
-        case(e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT):
-            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsefrc, val);
-            break;
-        case(e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT):
-            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsqfrc, val);
-            break;
-        case(e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT):
-            WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmssrc, val);
-            break;
         default:
             break;
     }
@@ -4206,13 +4856,14 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_DMA_STAT;
         replyLength = sizeof(uint32_t) + sizeof(t_FmIpcDmaStatus);
-        if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
+        err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
                                      sizeof(msg.msgId),
                                      (uint8_t*)&reply,
                                      &replyLength,
                                      NULL,
-                                     NULL)) != E_OK)
+                                NULL);
+        if (err != E_OK)
         {
             REPORT_ERROR(MINOR, err, NO_MSG);
             return;
@@ -4229,6 +4880,7 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
         p_FmDmaStatus->readBufEccError = (bool)ipcDmaStatus.boolReadBufEccError;        /**< Double ECC error on buffer Read */
         p_FmDmaStatus->writeBufEccSysError =(bool)ipcDmaStatus.boolWriteBufEccSysError;    /**< Double ECC error on buffer write from system side */
         p_FmDmaStatus->writeBufEccFmError = (bool)ipcDmaStatus.boolWriteBufEccFmError;     /**< Double ECC error on buffer write from FM side */
+        p_FmDmaStatus->singlePortEccError = (bool)ipcDmaStatus.boolSinglePortEccError;     /**< Double ECC error on buffer write from FM side */
         return;
     }
 
@@ -4236,80 +4888,175 @@ void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus)
 
     p_FmDmaStatus->cmqNotEmpty = (bool)(tmpReg & DMA_STATUS_CMD_QUEUE_NOT_EMPTY);
     p_FmDmaStatus->busError = (bool)(tmpReg & DMA_STATUS_BUS_ERR);
+    if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+        p_FmDmaStatus->singlePortEccError = (bool)(tmpReg & DMA_STATUS_FM_SPDAT_ECC);
+    else
+    {
     p_FmDmaStatus->readBufEccError = (bool)(tmpReg & DMA_STATUS_READ_ECC);
     p_FmDmaStatus->writeBufEccSysError = (bool)(tmpReg & DMA_STATUS_SYSTEM_WRITE_ECC);
     p_FmDmaStatus->writeBufEccFmError = (bool)(tmpReg & DMA_STATUS_FM_WRITE_ECC);
+    }
+
     return;
 }
 
-t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
+void FM_Resume(t_Handle h_Fm)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
+    uint32_t        tmpReg;
+
+    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    if (p_Fm->guestId == NCSW_MASTER_ID)
+    {
+        tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
+        /* clear tmpReg event bits in order not to clear standing events */
+        tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
+        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg | FPM_EV_MASK_RELEASE_FM);
+    }
+    else
+        ASSERT_COND(0); /* TODO */
+}
+
+t_Error FM_GetSpecialOperationCoding(t_Handle h_Fm,
+                                     fmSpecialOperations_t spOper,
+                                     uint8_t *p_SpOperCoding)
+{
+    t_Fm                        *p_Fm = (t_Fm*)h_Fm;
+    t_FmCtrlCodeRevisionInfo    revInfo;
+    t_Error                     err;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_SpOperCoding, E_NULL_POINTER);
 
-    switch(exception)
+    if (!spOper)
     {
-        case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DEQ_FROM_DEF);
+        *p_SpOperCoding = 0;
+        return E_OK;
+    }
+    if ((err = FM_GetFmanCtrlCodeRevision(p_Fm, &revInfo)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    if (revInfo.packageRev != IP_OFFLOAD_PACKAGE_NUMBER)
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Fman ctrl code package"));
+    if (revInfo.packageRev == IP_OFFLOAD_PACKAGE_NUMBER)
+    {
+        switch (spOper)
+        {
+            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP):
+            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
+                    *p_SpOperCoding = 5;
             break;
-        case e_FM_EX_QMI_SINGLE_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, QMI_INTR_EN_SINGLE_ECC);
+            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP):
+            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_MANIP|FM_SP_OP_RPD):
+                    *p_SpOperCoding = 6;
             break;
-        case e_FM_EX_QMI_DOUBLE_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, QMI_ERR_INTR_EN_DOUBLE_ECC);
+            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN|FM_SP_OP_RPD):
+                    *p_SpOperCoding = 3;
             break;
-        case e_FM_EX_BMI_LIST_RAM_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_LIST_RAM_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_LIST_RAM_ECC);
+            case (FM_SP_OP_IPSEC|FM_SP_OP_IPSEC_UPDATE_UDP_LEN):
+                    *p_SpOperCoding = 1;
             break;
-        case e_FM_EX_BMI_PIPELINE_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_PIPELINE_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_PIPELINE_ECC);
+            case (FM_SP_OP_IPSEC|FM_SP_OP_RPD):
+                    *p_SpOperCoding = 4;
             break;
-        case e_FM_EX_BMI_STATISTICS_RAM_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_STATISTICS_RAM_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_STATISTICS_RAM_ECC);
-            break;
-        case e_FM_EX_BMI_DISPATCH_RAM_ECC:
-            if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_BMI_DISPATCH_RAM_ECC))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
-            WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ifr, BMI_ERR_INTR_EN_DISPATCH_RAM_ECC);
+            case (FM_SP_OP_IPSEC):
+                    *p_SpOperCoding = 2;
             break;
         default:
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
+                RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+        }
+    }
+    return E_OK;
+}
+
+t_Error FM_CtrlMonStart(t_Handle h_Fm)
+{
+    t_Fm            *p_Fm = (t_Fm *)h_Fm;
+    t_FmTrbRegs     *p_MonRegs;
+    uint8_t         fmCtrlNum, i;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->baseAddr, E_INVALID_STATE);
+
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6 )
+        fmCtrlNum = 2;
+    else
+        fmCtrlNum = 4;
+
+    for (i = 0; i < fmCtrlNum; i++)
+    {
+        p_MonRegs = (t_FmTrbRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_TRB(i));
+
+        /* Reset control registers */
+        WRITE_UINT32(p_MonRegs->tcrh, TRB_TCRH_RESET);
+        WRITE_UINT32(p_MonRegs->tcrl, TRB_TCRL_RESET);
+
+        /* Configure counter #1 to count all stalls of FM Controller */
+        WRITE_UINT32(p_MonRegs->tcrl, TRB_TCRL_RESET | TRB_TCRL_UTIL);
+
+        /* Enable monitoring */
+        WRITE_UINT32(p_MonRegs->tcrh, TRB_TCRH_ENABLE_COUNTERS);
     }
 
     return E_OK;
 }
 
-void FM_Resume(t_Handle h_Fm)
+t_Error FM_CtrlMonStop(t_Handle h_Fm)
 {
     t_Fm            *p_Fm = (t_Fm*)h_Fm;
-    uint32_t        tmpReg;
+    t_FmTrbRegs     *p_MonRegs;
+    uint8_t         fmCtrlNum, i;
 
-    SANITY_CHECK_RETURN(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->baseAddr, E_INVALID_STATE);
 
-    if (p_Fm->guestId == NCSW_MASTER_ID)
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6 )
+        fmCtrlNum = 2;
+    else
+        fmCtrlNum = 4;
+
+    for (i = 0; i < fmCtrlNum; i++)
     {
-        tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fpmem);
-        /* clear tmpReg event bits in order not to clear standing events */
-        tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
-        WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmem, tmpReg | FPM_EV_MASK_RELEASE_FM);
+        p_MonRegs = (t_FmTrbRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_TRB(i));
+        WRITE_UINT32(p_MonRegs->tcrh, TRB_TCRH_DISABLE_COUNTERS);
     }
+
+    return E_OK;
+}
+
+t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p_Mon)
+{
+    t_Fm            *p_Fm = (t_Fm *)h_Fm;
+    t_FmTrbRegs     *p_MonRegs;
+    uint64_t        clkCnt, monValue;
+    uint8_t         fmCtrlNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->baseAddr, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Mon, E_NULL_POINTER);
+
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6 )
+        fmCtrlNum = 2;
     else
-        ASSERT_COND(0); /* TODO */
+        fmCtrlNum = 4;
+
+    if (fmCtrlIndex >= fmCtrlNum)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FM Controller index"));
+
+    p_MonRegs = (t_FmTrbRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_TRB(fmCtrlIndex));
+
+    clkCnt = (uint64_t)
+            ((uint64_t)GET_UINT32(p_MonRegs->tpcch) << 32 | GET_UINT32(p_MonRegs->tpccl));
+
+    monValue = (uint64_t)
+            ((uint64_t)GET_UINT32(p_MonRegs->tpc1h) << 32 | GET_UINT32(p_MonRegs->tpc1l));
+
+    p_Mon->percentCnt[0] = (uint8_t)((clkCnt - monValue) * 100 / clkCnt);
+    return E_OK;
 }
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -4325,7 +5072,6 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
 
-
     if(p_Fm->guestId != NCSW_MASTER_ID)
     {
         memset(&msg, 0, sizeof(msg));
@@ -4344,7 +5090,7 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
 
     DUMP_SUBTITLE(("\n"));
 
-    DUMP_TITLE(p_Fm->p_FmFpmRegs, ("FmFpmRegs Regs"));
+    DUMP_TITLE(p_Fm->p_FmFpmRegs, ("FM-FPM Regs"));
 
     DUMP_VAR(p_Fm->p_FmFpmRegs,fpmtnc);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fpmpr);
@@ -4405,7 +5151,7 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     }
 
 
-    DUMP_TITLE(p_Fm->p_FmDmaRegs, ("p_FmDmaRegs Regs"));
+    DUMP_TITLE(p_Fm->p_FmDmaRegs, ("FM-DMA Regs"));
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsr);
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmemsr);
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmmr);
@@ -4419,25 +5165,16 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmrd);
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmwcr);
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmebcr);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqdr);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqvr1);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmccqvr2);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr3);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr4);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmcqvr5);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsefrc);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsqfrc);
-    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmssrc);
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmdcr);
 
     DUMP_TITLE(&p_Fm->p_FmDmaRegs->fmdmplr, ("fmdmplr"));
 
-    DUMP_SUBSTRUCT_ARRAY(i, FM_SIZE_OF_LIODN_TABLE/2)
+    DUMP_SUBSTRUCT_ARRAY(i, FM_MAX_NUM_OF_HW_PORT_IDS/2)
     {
         DUMP_MEMORY(&p_Fm->p_FmDmaRegs->fmdmplr[i], sizeof(uint32_t));
     }
 
-    DUMP_TITLE(p_Fm->p_FmBmiRegs, ("p_FmBmiRegs COMMON Regs"));
+    DUMP_TITLE(p_Fm->p_FmBmiRegs, ("FM-BMI COMMON Regs"));
     DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_init);
     DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg1);
     DUMP_VAR(p_Fm->p_FmBmiRegs,fmbm_cfg2);
@@ -4451,7 +5188,7 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     }
 
 
-    DUMP_TITLE(p_Fm->p_FmQmiRegs, ("p_FmQmiRegs COMMON Regs"));
+    DUMP_TITLE(p_Fm->p_FmQmiRegs, ("FM-QMI COMMON Regs"));
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gc);
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eie);
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_eien);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
index b281c7b..9ccadcb 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -63,67 +63,76 @@
 #define FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID   0x00800000      /**< Dequeu from default queue id */
 #define FM_EX_QMI_DOUBLE_ECC                0x00400000
 #define FM_EX_BMI_LIST_RAM_ECC              0x00200000
-#define FM_EX_BMI_PIPELINE_ECC              0x00100000
+#define FM_EX_BMI_STORAGE_PROFILE_ECC       0x00100000
 #define FM_EX_BMI_STATISTICS_RAM_ECC        0x00080000
 #define FM_EX_IRAM_ECC                      0x00040000
-#define FM_EX_NURAM_ECC                     0x00020000
+#define FM_EX_MURAM_ECC                     0x00020000
 #define FM_EX_BMI_DISPATCH_RAM_ECC          0x00010000
-
-#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
-    case e_FM_EX_DMA_BUS_ERROR:                                         \
-        bitMask = FM_EX_DMA_BUS_ERROR; break;                           \
-    case e_FM_EX_DMA_READ_ECC:                                          \
-        bitMask = FM_EX_DMA_READ_ECC; break;                            \
-    case e_FM_EX_DMA_SYSTEM_WRITE_ECC:                                  \
-        bitMask = FM_EX_DMA_SYSTEM_WRITE_ECC; break;                    \
-    case e_FM_EX_DMA_FM_WRITE_ECC:                                      \
-        bitMask = FM_EX_DMA_FM_WRITE_ECC; break;                        \
-    case e_FM_EX_FPM_STALL_ON_TASKS:                                    \
-        bitMask = FM_EX_FPM_STALL_ON_TASKS; break;                      \
-    case e_FM_EX_FPM_SINGLE_ECC:                                        \
-        bitMask = FM_EX_FPM_SINGLE_ECC; break;                          \
-    case e_FM_EX_FPM_DOUBLE_ECC:                                        \
-        bitMask = FM_EX_FPM_DOUBLE_ECC; break;                          \
-    case e_FM_EX_QMI_SINGLE_ECC:                                        \
-        bitMask = FM_EX_QMI_SINGLE_ECC; break;                          \
-    case e_FM_EX_QMI_DOUBLE_ECC:                                        \
-        bitMask = FM_EX_QMI_DOUBLE_ECC; break;                          \
-    case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:                           \
-        bitMask = FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID; break;             \
-    case e_FM_EX_BMI_LIST_RAM_ECC:                                      \
-        bitMask = FM_EX_BMI_LIST_RAM_ECC; break;                        \
-    case e_FM_EX_BMI_PIPELINE_ECC:                                      \
-        bitMask = FM_EX_BMI_PIPELINE_ECC; break;                        \
-    case e_FM_EX_BMI_STATISTICS_RAM_ECC:                                \
-        bitMask = FM_EX_BMI_STATISTICS_RAM_ECC; break;                  \
-    case e_FM_EX_BMI_DISPATCH_RAM_ECC:                                  \
-        bitMask = FM_EX_BMI_DISPATCH_RAM_ECC; break;                    \
-    case e_FM_EX_IRAM_ECC:                                              \
-        bitMask = FM_EX_IRAM_ECC; break;                                \
-    case e_FM_EX_MURAM_ECC:                                             \
-        bitMask = FM_EX_NURAM_ECC; break;                               \
-    default: bitMask = 0;break;}
+#define FM_EX_DMA_SINGLE_PORT_ECC           0x00008000
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)              \
+switch(exception){                                          \
+    case e_FM_EX_DMA_BUS_ERROR:                             \
+        bitMask = FM_EX_DMA_BUS_ERROR; break;               \
+    case e_FM_EX_DMA_SINGLE_PORT_ECC:                       \
+        bitMask = FM_EX_DMA_SINGLE_PORT_ECC; break;         \
+    case e_FM_EX_DMA_READ_ECC:                              \
+        bitMask = FM_EX_DMA_READ_ECC; break;                \
+    case e_FM_EX_DMA_SYSTEM_WRITE_ECC:                      \
+        bitMask = FM_EX_DMA_SYSTEM_WRITE_ECC; break;        \
+    case e_FM_EX_DMA_FM_WRITE_ECC:                          \
+        bitMask = FM_EX_DMA_FM_WRITE_ECC; break;            \
+    case e_FM_EX_FPM_STALL_ON_TASKS:                        \
+        bitMask = FM_EX_FPM_STALL_ON_TASKS; break;          \
+    case e_FM_EX_FPM_SINGLE_ECC:                            \
+        bitMask = FM_EX_FPM_SINGLE_ECC; break;              \
+    case e_FM_EX_FPM_DOUBLE_ECC:                            \
+        bitMask = FM_EX_FPM_DOUBLE_ECC; break;              \
+    case e_FM_EX_QMI_SINGLE_ECC:                            \
+        bitMask = FM_EX_QMI_SINGLE_ECC; break;              \
+    case e_FM_EX_QMI_DOUBLE_ECC:                            \
+        bitMask = FM_EX_QMI_DOUBLE_ECC; break;              \
+    case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:               \
+        bitMask = FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID; break; \
+    case e_FM_EX_BMI_LIST_RAM_ECC:                          \
+        bitMask = FM_EX_BMI_LIST_RAM_ECC; break;            \
+    case e_FM_EX_BMI_STORAGE_PROFILE_ECC:                   \
+        bitMask = FM_EX_BMI_STORAGE_PROFILE_ECC; break;     \
+    case e_FM_EX_BMI_STATISTICS_RAM_ECC:                    \
+        bitMask = FM_EX_BMI_STATISTICS_RAM_ECC; break;      \
+    case e_FM_EX_BMI_DISPATCH_RAM_ECC:                      \
+        bitMask = FM_EX_BMI_DISPATCH_RAM_ECC; break;        \
+    case e_FM_EX_IRAM_ECC:                                  \
+        bitMask = FM_EX_IRAM_ECC; break;                    \
+    case e_FM_EX_MURAM_ECC:                                 \
+        bitMask = FM_EX_MURAM_ECC; break;                   \
+    default: bitMask = 0;break;                             \
+}
 
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
-#define DEFAULT_exceptions                  (FM_EX_DMA_BUS_ERROR            |\
+#define DEFAULT_exceptions                 (FM_EX_DMA_BUS_ERROR            |\
                                             FM_EX_DMA_READ_ECC              |\
                                             FM_EX_DMA_SYSTEM_WRITE_ECC      |\
                                             FM_EX_DMA_FM_WRITE_ECC          |\
                                             FM_EX_FPM_STALL_ON_TASKS        |\
                                             FM_EX_FPM_SINGLE_ECC            |\
                                             FM_EX_FPM_DOUBLE_ECC            |\
-                                            FM_EX_QMI_SINGLE_ECC            |\
                                             FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID|\
-                                            FM_EX_QMI_DOUBLE_ECC            |\
                                             FM_EX_BMI_LIST_RAM_ECC          |\
-                                            FM_EX_BMI_PIPELINE_ECC          |\
+                                            FM_EX_BMI_STORAGE_PROFILE_ECC   |\
                                             FM_EX_BMI_STATISTICS_RAM_ECC    |\
-                                            FM_EX_BMI_DISPATCH_RAM_ECC      |\
                                             FM_EX_IRAM_ECC                  |\
-                                            FM_EX_NURAM_ECC                 )
-#define DEFAULT_totalFifoSize               (BMI_MAX_FIFO_SIZE*3/4)
+                                            FM_EX_MURAM_ECC 				|\
+                                            FM_EX_BMI_DISPATCH_RAM_ECC      |\
+                                            FM_EX_QMI_DOUBLE_ECC            |\
+                                            FM_EX_QMI_SINGLE_ECC)
+
+
+#define DEFAULT_totalFifoSize(major)       ((major != 0) ?  (BMI_MAX_FIFO_SIZE*3/4):0)
+
+
 #define DEFAULT_eccEnable                   FALSE
 #define DEFAULT_dispLimit                   0
 #define DEFAULT_prsDispTh                   16
@@ -176,10 +185,12 @@
 #define FM_MM_FPM               0x000C3000
 #define FM_MM_PLCR              0x000C0000
 #define FM_MM_IMEM              0x000C4000
+#define FM_MM_CGP               0x000DB000
+#define FM_MM_TRB(i)            (0x000D0200 + 0x400 * (i))
+#if DPAA_VERSION >= 3
+#define FM_MM_SP                0x000dc000
+#endif /* DPAA_VERSION >= 3 */
 
-/**************************************************************************//**
- @Description       Interrupt Enable/Mask
-*//***************************************************************************/
 
 /**************************************************************************//**
  @Description       Memory Mapped Registers
@@ -188,7 +199,6 @@
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 typedef _Packed struct
 {
@@ -299,44 +309,74 @@ typedef _Packed struct
 
 typedef _Packed struct
 {
-    volatile uint32_t   fmdmsr;         /**<    FM DMA status register 0x04 */
-    volatile uint32_t   fmdmmr;         /**<    FM DMA mode register 0x08 */
-    volatile uint32_t   fmdmtr;         /**<    FM DMA bus threshold register 0x0c */
-    volatile uint32_t   fmdmhy;         /**<    FM DMA bus hysteresis register 0x10 */
-    volatile uint32_t   fmdmsetr;       /**<    FM DMA SOS emergency Threshold Register 0x14 */
-    volatile uint32_t   fmdmtah;        /**<    FM DMA transfer bus address high register 0x18  */
-    volatile uint32_t   fmdmtal;        /**<    FM DMA transfer bus address low register 0x1C  */
-    volatile uint32_t   fmdmtcid;       /**<    FM DMA transfer bus communication ID register 0x20  */
-    volatile uint32_t   fmdmra;         /**<    FM DMA bus internal ram address register 0x24  */
-    volatile uint32_t   fmdmrd;         /**<    FM DMA bus internal ram data register 0x28  */
-    volatile uint32_t   fmdmwcr;        /**<    FM DMA CAM watchdog counter value 0x2C  */
-    volatile uint32_t   fmdmebcr;       /**<    FM DMA CAM base in MURAM register 0x30  */
-    volatile uint32_t   fmdmccqdr;      /**<    FM DMA CAM and CMD Queue Debug register 0x34  */
-    volatile uint32_t   fmdmccqvr1;     /**<    FM DMA CAM and CMD Queue Value register #1 0x38  */
-    volatile uint32_t   fmdmccqvr2;     /**<    FM DMA CAM and CMD Queue Value register #2 0x3C  */
-    volatile uint32_t   fmdmcqvr3;      /**<    FM DMA CMD Queue Value register #3 0x40  */
-    volatile uint32_t   fmdmcqvr4;      /**<    FM DMA CMD Queue Value register #4 0x44  */
-    volatile uint32_t   fmdmcqvr5;      /**<    FM DMA CMD Queue Value register #5 0x48  */
-    volatile uint32_t   fmdmsefrc;      /**<    FM DMA Semaphore Entry Full Reject Counter 0x50  */
-    volatile uint32_t   fmdmsqfrc;      /**<    FM DMA Semaphore Queue Full Reject Counter 0x54  */
-    volatile uint32_t   fmdmssrc;       /**<    FM DMA Semaphore SYNC Reject Counter 0x54  */
-    volatile uint32_t   fmdmdcr;        /**<    FM DMA Debug Counter */
-    volatile uint32_t   fmdmemsr;       /**<    FM DMA Emrgency Smoother Register */
+    volatile uint32_t   fmdmsr;         /**< FM DMA status register 0x04 */
+    volatile uint32_t   fmdmmr;         /**< FM DMA mode register 0x08 */
+    volatile uint32_t   fmdmtr;         /**< FM DMA bus threshold register 0x0c */
+    volatile uint32_t   fmdmhy;         /**< FM DMA bus hysteresis register 0x10 */
+    volatile uint32_t   fmdmsetr;       /**< FM DMA SOS emergency Threshold Register 0x14 */
+    volatile uint32_t   fmdmtah;        /**< FM DMA transfer bus address high register 0x18  */
+    volatile uint32_t   fmdmtal;        /**< FM DMA transfer bus address low register 0x1C  */
+    volatile uint32_t   fmdmtcid;       /**< FM DMA transfer bus communication ID register 0x20  */
+    volatile uint32_t   fmdmra;         /**< FM DMA bus internal ram address register 0x24  */
+    volatile uint32_t   fmdmrd;         /**< FM DMA bus internal ram data register 0x28  */
+    volatile uint32_t   fmdmwcr;        /**< FM DMA CAM watchdog counter value 0x2C  */
+    volatile uint32_t   fmdmebcr;       /**< FM DMA CAM base in MURAM register 0x30  */
+    volatile uint32_t   fmdmccqdr;      /**< FM DMA CAM and CMD Queue Debug register 0x34  */
+    volatile uint32_t   fmdmccqvr1;     /**< FM DMA CAM and CMD Queue Value register #1 0x38  */
+    volatile uint32_t   fmdmccqvr2;     /**< FM DMA CAM and CMD Queue Value register #2 0x3C  */
+    volatile uint32_t   fmdmcqvr3;      /**< FM DMA CMD Queue Value register #3 0x40  */
+    volatile uint32_t   fmdmcqvr4;      /**< FM DMA CMD Queue Value register #4 0x44  */
+    volatile uint32_t   fmdmcqvr5;      /**< FM DMA CMD Queue Value register #5 0x48  */
+    volatile uint32_t   fmdmsefrc;      /**< FM DMA Semaphore Entry Full Reject Counter 0x50  */
+    volatile uint32_t   fmdmsqfrc;      /**< FM DMA Semaphore Queue Full Reject Counter 0x54  */
+    volatile uint32_t   fmdmssrc;       /**< FM DMA Semaphore SYNC Reject Counter 0x54  */
+    volatile uint32_t   fmdmdcr;        /**< FM DMA Debug Counter */
+    volatile uint32_t   fmdmemsr;       /**< FM DMA Emrgency Smoother Register */
     volatile uint32_t   reserved;
-    volatile uint32_t   fmdmplr[FM_SIZE_OF_LIODN_TABLE/2];
-                                        /**<    FM DMA PID-LIODN # register  */
+    volatile uint32_t   fmdmplr[FM_MAX_NUM_OF_HW_PORT_IDS/2];
+                                        /**< FM DMA PID-LIODN # register  */
 } _PackedType t_FmDmaRegs;
 
 typedef _Packed struct
 {
-    volatile uint32_t   iadd;           /**<    FM IRAM instruction address register */
-    volatile uint32_t   idata;          /**<    FM IRAM instruction data register */
-    volatile uint32_t   itcfg;          /**<    FM IRAM timing config register */
-    volatile uint32_t   iready;         /**<    FM IRAM ready register */
+    volatile uint32_t   iadd;           /**< FM IRAM instruction address register */
+    volatile uint32_t   idata;          /**< FM IRAM instruction data register */
+    volatile uint32_t   itcfg;          /**< FM IRAM timing config register */
+    volatile uint32_t   iready;         /**< FM IRAM ready register */
     volatile uint8_t    res[0x80000-0x10];
 } _PackedType t_FMIramRegs;
 
-#define MEM_MAP_END
+/* Trace buffer registers -
+   each FM Controller has its own trace buffer residing at FM_MM_TRB(fmCtrlIndex) offset */
+typedef _Packed struct t_FmTrbRegs
+{
+    volatile uint32_t   tcrh;
+    volatile uint32_t   tcrl;
+    volatile uint32_t   tesr;
+    volatile uint32_t   tecr0h;
+    volatile uint32_t   tecr0l;
+    volatile uint32_t   terf0h;
+    volatile uint32_t   terf0l;
+    volatile uint32_t   tecr1h;
+    volatile uint32_t   tecr1l;
+    volatile uint32_t   terf1h;
+    volatile uint32_t   terf1l;
+    volatile uint32_t   tpcch;
+    volatile uint32_t   tpccl;
+    volatile uint32_t   tpc1h;
+    volatile uint32_t   tpc1l;
+    volatile uint32_t   tpc2h;
+    volatile uint32_t   tpc2l;
+    volatile uint32_t   twdimr;
+    volatile uint32_t   twicvr;
+    volatile uint32_t   tar;
+    volatile uint32_t   tdr;
+    volatile uint32_t   tsnum1;
+    volatile uint32_t   tsnum2;
+    volatile uint32_t   tsnum3;
+    volatile uint32_t   tsnum4;
+} _PackedType t_FmTrbRegs;
+
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -345,15 +385,12 @@ typedef _Packed struct
 /**************************************************************************//**
  @Description       General defines
 *//***************************************************************************/
-
 #define FM_DEBUG_STATUS_REGISTER_OFFSET     0x000d1084UL
 #define FM_UCODE_DEBUG_INSTRUCTION          0x6ffff805UL
 
-
 /**************************************************************************//**
  @Description       DMA definitions
 *//***************************************************************************/
-
 /* masks */
 #define DMA_MODE_AID_OR                     0x20000000
 #define DMA_MODE_SBER                       0x10000000
@@ -382,6 +419,17 @@ typedef _Packed struct
 #define DMA_STATUS_FM_DPDAT_ECC             0x00100000
 #define DMA_STATUS_FM_SPDAT_ECC             0x00080000
 
+#define DMA_STATUS_FM_ECC                   (DMA_STATUS_READ_ECC |          \
+                                            DMA_STATUS_SYSTEM_WRITE_ECC |   \
+                                            DMA_STATUS_FM_WRITE_ECC |       \
+                                            DMA_STATUS_SYSTEM_DPEXT_ECC |   \
+                                            DMA_STATUS_FM_DPEXT_ECC |       \
+                                            DMA_STATUS_SYSTEM_DPDAT_ECC |   \
+                                            DMA_STATUS_FM_DPDAT_ECC |       \
+                                            DMA_STATUS_FM_SPDAT_ECC)
+
+
+
 #define FM_LIODN_BASE_MASK                  0x00000FFF
 
 /* shifts */
@@ -416,7 +464,6 @@ typedef _Packed struct
 /**************************************************************************//**
  @Description       FPM defines
 *//***************************************************************************/
-
 /* masks */
 #define FPM_EV_MASK_DOUBLE_ECC          0x80000000
 #define FPM_EV_MASK_STALL               0x40000000
@@ -508,7 +555,7 @@ typedef _Packed struct
 *//***************************************************************************/
 /* masks */
 #define BMI_INIT_START                      0x80000000
-#define BMI_ERR_INTR_EN_PIPELINE_ECC        0x80000000
+#define BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC 0x80000000
 #define BMI_ERR_INTR_EN_LIST_RAM_ECC        0x40000000
 #define BMI_ERR_INTR_EN_STATISTICS_RAM_ECC  0x20000000
 #define BMI_ERR_INTR_EN_DISPATCH_RAM_ECC    0x10000000
@@ -534,7 +581,6 @@ typedef _Packed struct
 /* others */
 #define BMI_FIFO_ALIGN                  0x100
 
-
 /**************************************************************************//**
  @Description       QMI defines
 *//***************************************************************************/
@@ -554,7 +600,6 @@ typedef _Packed struct
 #define QMI_CFG_ENQ_SHIFT               8
 #define QMI_TAPC_TAP                    22
 
-
 /**************************************************************************//**
  @Description       IRAM defines
 *//***************************************************************************/
@@ -562,19 +607,25 @@ typedef _Packed struct
 #define IRAM_IADD_AIE                   0x80000000
 #define IRAM_READY                      0x80000000
 
+/**************************************************************************//**
+ @Description       TRB defines
+*//***************************************************************************/
+/* masks */
+#define TRB_TCRH_RESET              0x04000000
+#define TRB_TCRH_ENABLE_COUNTERS    0x84008000
+#define TRB_TCRH_DISABLE_COUNTERS   0x8400C000
+#define TRB_TCRL_RESET              0x20000000
+#define TRB_TCRL_UTIL               0x00000800
+
 typedef struct {
     void        (*f_Isr) (t_Handle h_Arg, uint32_t event);
     t_Handle    h_SrcHandle;
 } t_FmanCtrlIntrSrc;
 
-
 typedef struct
 {
  /*   uint8_t                     numOfPartitions; */
     bool                        resetOnInit;
-#ifdef FM_PARTITION_ARRAY
-    uint16_t                    liodnBasePerPort[FM_SIZE_OF_LIODN_TABLE];
-#endif
     bool                        enCounters;
     t_FmThresholds              thresholds;
     e_FmDmaCacheOverride        dmaCacheOverride;
@@ -601,8 +652,9 @@ typedef struct
     bool                        enIramTestMode;
     bool                        externalEccRamsEnable;
     uint16_t                    tnumAgingPeriod;
-    t_FmPcdFirmwareParams       firmware;
+    t_FmFirmwareParams          firmware;
     bool                        fwVerify;
+    uint32_t                    userSetExceptions;
 } t_FmDriverParam;
 
 typedef void (t_FmanCtrlIsr)( t_Handle h_Fm, uint32_t event);
@@ -611,10 +663,10 @@ typedef struct
 {
 /***************************/
 /* Master/Guest parameters */
-/***************************/
     uint8_t                     fmId;
     e_FmPortType                portsTypes[FM_MAX_NUM_OF_HW_PORT_IDS];
     uint16_t                    fmClkFreq;
+    t_FmRevisionInfo            revInfo;
 /**************************/
 /* Master Only parameters */
 /**************************/
@@ -626,9 +678,7 @@ typedef struct
     uint8_t                     accumulatedNumOfTasks;
     uint32_t                    accumulatedFifoSize;
     uint8_t                     accumulatedNumOfOpenDmas;
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     uint8_t                     accumulatedNumOfDeqTnums;
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 #ifdef FM_LOW_END_RESTRICTION
     bool                        lowEndRestriction;
 #endif /* FM_LOW_END_RESTRICTION */
@@ -648,7 +698,34 @@ typedef struct
     uint16_t                    macMaxFrameLengths1G[FM_MAX_NUM_OF_1G_MACS];
 } t_FmStateStruct;
 
-typedef struct
+#if DPAA_VERSION >= 3
+typedef struct t_FmMapParam {
+    uint16_t        profilesBase;
+    uint16_t        numOfProfiles;
+    t_Handle        h_FmPort;
+} t_FmMapParam;
+
+typedef struct t_FmAllocMng {
+    bool            allocated;
+    uint8_t         ownerId; /* guestId for KG in multi-partition only,
+                                portId for PLCR in any environment */
+} t_FmAllocMng;
+
+typedef struct t_FmPcdSpEntry {
+    bool            valid;
+    t_FmAllocMng    profilesMng;
+} t_FmPcdSpEntry;
+
+typedef struct t_FmSp {
+    void            *p_FmPcdStoragePrflRegs;
+    t_FmPcdSpEntry  profiles[FM_VSP_MAX_NUM_OF_ENTRIES];
+    t_FmMapParam    portsMapping[FM_MAX_NUM_OF_PORTS];
+} t_FmSp;
+
+#endif /* DPAA_VERSION >= 3 */
+
+
+typedef struct t_Fm
 {
 /***************************/
 /* Master/Guest parameters */
@@ -677,6 +754,12 @@ typedef struct
     t_Handle                    h_Spinlock;
     bool                        recoveryMode;
     t_FmStateStruct             *p_FmStateStruct;
+#if DPAA_VERSION >= 3
+    t_FmSp                      *p_FmSp;
+    uint8_t                     partNumOfVSPs;
+    uint8_t                     partVSPBase;
+    uintptr_t                   vspBaseAddr;
+#endif /* DPAA_VERSION >= 3 */
 
 /* un-needed for recovery */
     t_FmDriverParam             *p_FmDriverParam;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index b2594ef..e63c104 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -61,7 +61,6 @@
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 /**************************************************************************//**
  @Description   enum for defining MAC types
@@ -148,9 +147,7 @@ typedef _Packed struct t_FmIpcPortFifoParams {
 typedef _Packed struct t_FmIpcPortFreeParams {
     uint8_t             hardwarePortId;         /**< IN. port Id */
     uint32_t            enumPortType;           /**< IN. Port type */
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     uint8_t             deqPipelineDepth;       /**< IN. Port's requested resource */
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 } _PackedType t_FmIpcPortFreeParams;
 
 /**************************************************************************//**
@@ -162,6 +159,7 @@ typedef _Packed struct t_FmIpcDmaStatus {
     uint8_t    boolReadBufEccError;        /**< Double ECC error on buffer Read */
     uint8_t    boolWriteBufEccSysError;    /**< Double ECC error on buffer write from system side */
     uint8_t    boolWriteBufEccFmError;     /**< Double ECC error on buffer write from FM side */
+    uint8_t    boolSinglePortEccError;     /**< Single port ECC error from FM side */
 } _PackedType t_FmIpcDmaStatus;
 
 typedef _Packed struct t_FmIpcRegisterIntr
@@ -177,12 +175,23 @@ typedef _Packed struct t_FmIpcIsr
 } _PackedType t_FmIpcIsr;
 
 /**************************************************************************//**
- @Description   structure for returning revision information
+ @Description   structure for returning FM parameters
 *//***************************************************************************/
-typedef _Packed struct t_FmIpcRevisionInfo {
+typedef _Packed struct t_FmIpcParams {
+    uint16_t        fmClkFreq;              /**< OUT: FM Clock frequency */
+    uint8_t         majorRev;               /**< OUT: FM Major revision */
+    uint8_t         minorRev;               /**< OUT: FM Minor revision */
+} _PackedType t_FmIpcParams;
+
+
+/**************************************************************************//**
+ @Description   structure for returning Fman Ctrl Code revision information
+*//***************************************************************************/
+typedef _Packed struct t_FmIpcFmanCtrlCodeRevisionInfo {
+    uint16_t        packageRev;             /**< OUT: Package revision */
     uint8_t         majorRev;               /**< OUT: Major revision */
     uint8_t         minorRev;               /**< OUT: Minor revision */
-} _PackedType t_FmIpcRevisionInfo;
+} _PackedType t_FmIpcFmanCtrlCodeRevisionInfo;
 
 /**************************************************************************//**
  @Description   Structure for defining Fm number of Fman controlers
@@ -201,9 +210,27 @@ typedef _Packed struct t_FmIpcFmanEvents {
     uint32_t        enableEvents;             /**< IN/OUT: required enabled events mask */
 } _PackedType t_FmIpcFmanEvents;
 
+typedef _Packed struct t_FmIpcVspAllocParams {
+    uint8_t guestId;
+    uint8_t numOfProfiles;
+    uint8_t base;
+}_PackedType t_FmIpcVspAllocParams;
+
+typedef _Packed struct t_FmIpcVspSetPortWindow {
+    uint8_t hardwarePortId;
+    uint8_t baseStorageProfile;
+    uint8_t log2NumOfProfiles;
+}_PackedType t_FmIpcVspSetPortWindow;
+
+typedef _Packed struct t_FmIpcSetCongestionGroupPfcPriority {
+        uint32_t     congestionGroupId;
+        uint8_t      priorityBitMap;
+}_PackedType t_FmIpcSetCongestionGroupPfcPriority;
+
 #define FM_IPC_MAX_REPLY_BODY_SIZE  16
 #define FM_IPC_MAX_REPLY_SIZE       (FM_IPC_MAX_REPLY_BODY_SIZE + sizeof(uint32_t))
 #define FM_IPC_MAX_MSG_SIZE         30
+
 typedef _Packed struct t_FmIpcMsg
 {
     uint32_t    msgId;
@@ -216,7 +243,6 @@ typedef _Packed struct t_FmIpcReply
     uint8_t     replyBody[FM_IPC_MAX_REPLY_BODY_SIZE];
 } _PackedType t_FmIpcReply;
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -314,14 +340,14 @@ typedef _Packed struct t_FmIpcReply
 #define FM_DUMP_PORT_REGS           9
 
 /**************************************************************************//**
- @Function      FM_GET_REV
+ @Function      FM_GET_PARAMS
 
  @Description   Used by FM front-end for the PORT module in order to dump
-                all port registers.
+                return FM parameters.
 
  @Param[in]     uint8_t Pointer
 *//***************************************************************************/
-#define FM_GET_REV                  10
+#define FM_GET_PARAMS                  10
 
 /**************************************************************************//**
  @Function      FM_REGISTER_INTR
@@ -334,15 +360,6 @@ typedef _Packed struct t_FmIpcReply
 #define FM_REGISTER_INTR            11
 
 /**************************************************************************//**
- @Function      FM_GET_CLK_FREQ
-
- @Description   Used by FM Front-end to read the FM clock frequency.
-
- @Param[out]    uint32_t Pointer
-*//***************************************************************************/
-#define FM_GET_CLK_FREQ             12
-
-/**************************************************************************//**
  @Function      FM_DMA_STAT
 
  @Description   Used by FM front-end to read the FM DMA status.
@@ -423,7 +440,11 @@ typedef _Packed struct t_FmIpcReply
 #define FM_SET_SIZE_OF_FIFO         24
 #define FM_SET_NUM_OF_TASKS         25
 #define FM_SET_NUM_OF_OPEN_DMAS     26
-
+#define FM_VSP_ALLOC                27
+#define FM_VSP_FREE                 28
+#define FM_VSP_SET_PORT_WINDOW      29
+#define FM_GET_FMAN_CTRL_CODE_REV   30
+#define FM_SET_CONG_GRP_PFC_PRIO    31
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 #define FM_10G_TX_ECC_WA            100
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
index 1225144..a42fa8a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -158,7 +158,17 @@ t_Error FM_MURAM_FreeMem(t_Handle h_FmMuram, void *ptr)
     SANITY_CHECK_RETURN_ERROR(p_FmMuram->h_Mem, E_INVALID_HANDLE);
 
     if (MM_Put(p_FmMuram->h_Mem, PTR_TO_UINT(ptr)) == 0)
-        RETURN_ERROR(MINOR, E_INVALID_HANDLE, ("memory pointer!!!"));
+        RETURN_ERROR(MINOR, E_INVALID_ADDRESS, ("memory pointer!!!"));
 
     return E_OK;
 }
+
+uint64_t FM_MURAM_GetFreeMemSize(t_Handle h_FmMuram)
+{
+    t_FmMuram   *p_FmMuram = ( t_FmMuram *)h_FmMuram;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmMuram, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(p_FmMuram->h_Mem, E_INVALID_HANDLE, 0);
+
+    return MM_GetFreeMemSize(p_FmMuram->h_Mem);
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index f89b120..b273931 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -41,15 +41,125 @@
 #include "error_ext.h"
 #include "std_ext.h"
 #include "fm_pcd_ext.h"
+#include "fm_ext.h"
 #include "fm_port_ext.h"
 
+#define e_FM_PORT_TYPE_OH_HOST_COMMAND      e_FM_PORT_TYPE_DUMMY
+
 #define CLS_PLAN_NUM_PER_GRP                        8
 
+#define IP_OFFLOAD_PACKAGE_NUMBER                   106
+
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmEventModules{
+    e_FM_MOD_PRS,                   /**< Parser event */
+    e_FM_MOD_KG,                    /**< Keygen event */
+    e_FM_MOD_PLCR,                  /**< Policer event */
+    e_FM_MOD_10G_MAC,               /**< 10G MAC event */
+    e_FM_MOD_1G_MAC,                /**< 1G MAC event */
+    e_FM_MOD_TMR,                   /**< Timer event */
+    e_FM_MOD_FMAN_CTRL,             /**< FMAN Controller  Timer event */
+    e_FM_MOD_MACSEC,
+    e_FM_MOD_DUMMY_LAST
+} e_FmEventModules;
+
+/**************************************************************************//**
+ @Description   Enum for interrupts types
+*//***************************************************************************/
+typedef enum e_FmIntrType {
+    e_FM_INTR_TYPE_ERR,
+    e_FM_INTR_TYPE_NORMAL
+} e_FmIntrType;
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmInterModuleEvent
+{
+    e_FM_EV_PRS = 0,                /**< Parser event */
+    e_FM_EV_ERR_PRS,                /**< Parser error event */
+    e_FM_EV_KG,                     /**< Keygen event */
+    e_FM_EV_ERR_KG,                 /**< Keygen error event */
+    e_FM_EV_PLCR,                   /**< Policer event */
+    e_FM_EV_ERR_PLCR,               /**< Policer error event */
+    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
+    e_FM_EV_ERR_10G_MAC1,           /**< 10G MAC 1 error event */
+    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
+    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
+    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
+    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
+    e_FM_EV_ERR_1G_MAC4,            /**< 1G MAC 4 error event */
+    e_FM_EV_ERR_1G_MAC5,            /**< 1G MAC 5 error event */
+    e_FM_EV_ERR_1G_MAC6,            /**< 1G MAC 6 error event */
+    e_FM_EV_ERR_1G_MAC7,            /**< 1G MAC 7 error event */
+    e_FM_EV_ERR_MACSEC_MAC0,
+    e_FM_EV_TMR,                    /**< Timer event */
+    e_FM_EV_10G_MAC0,               /**< 10G MAC 0 event (Magic packet detection)*/
+    e_FM_EV_10G_MAC1,               /**< 10G MAC 1 event (Magic packet detection)*/
+    e_FM_EV_1G_MAC0,                /**< 1G MAC 0 event (Magic packet detection)*/
+    e_FM_EV_1G_MAC1,                /**< 1G MAC 1 event (Magic packet detection)*/
+    e_FM_EV_1G_MAC2,                /**< 1G MAC 2 (Magic packet detection)*/
+    e_FM_EV_1G_MAC3,                /**< 1G MAC 3 (Magic packet detection)*/
+    e_FM_EV_1G_MAC4,                /**< 1G MAC 4 (Magic packet detection)*/
+    e_FM_EV_1G_MAC5,                /**< 1G MAC 5 (Magic packet detection)*/
+    e_FM_EV_1G_MAC6,                /**< 1G MAC 6 (Magic packet detection)*/
+    e_FM_EV_1G_MAC7,                /**< 1G MAC 7 (Magic packet detection)*/
+    e_FM_EV_MACSEC_MAC0,            /**< MACSEC MAC 0 event */
+    e_FM_EV_FMAN_CTRL_0,            /**< Fman controller event 0 */
+    e_FM_EV_FMAN_CTRL_1,            /**< Fman controller event 1 */
+    e_FM_EV_FMAN_CTRL_2,            /**< Fman controller event 2 */
+    e_FM_EV_FMAN_CTRL_3,            /**< Fman controller event 3 */
+    e_FM_EV_DUMMY_LAST
+} e_FmInterModuleEvent;
+
+
+#define GET_FM_MODULE_EVENT(_mod, _id, _intrType, _event)                                           \
+    switch(_mod) {                                                                                  \
+        case e_FM_MOD_PRS:                                                                          \
+            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS : e_FM_EV_PRS;        \
+            break;                                                                                  \
+        case e_FM_MOD_KG:                                                                           \
+            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG : e_FM_EV_DUMMY_LAST;  \
+            break;                                                                                  \
+        case e_FM_MOD_PLCR:                                                                         \
+            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR : e_FM_EV_PLCR;      \
+            break;                                                                                  \
+        case e_FM_MOD_TMR:                                                                          \
+            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_TMR;     \
+            break;                                                                                  \
+        case e_FM_MOD_10G_MAC:                                                                      \
+            if (_id >= FM_MAX_NUM_OF_10G_MACS) _event = e_FM_EV_DUMMY_LAST;                         \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? (e_FM_EV_ERR_10G_MAC0 + _id) : (e_FM_EV_10G_MAC0 + _id); \
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC:                                                                       \
+            if (_id >= FM_MAX_NUM_OF_1G_MACS) _event = e_FM_EV_DUMMY_LAST;                          \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? (e_FM_EV_ERR_1G_MAC0 + _id) : (e_FM_EV_1G_MAC0 + _id); \
+            break;                                                                                  \
+        case e_FM_MOD_MACSEC:                                                                       \
+            switch(_id){                                                                            \
+                 case(0): _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_MACSEC_MAC0:e_FM_EV_MACSEC_MAC0; \
+                 break;                                                                             \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_FMAN_CTRL:                                                                    \
+            if (_intrType == e_FM_INTR_TYPE_ERR) _event = e_FM_EV_DUMMY_LAST;                       \
+            else _event = (e_FM_EV_FMAN_CTRL_0 + _id);                                              \
+            break;                                                                                  \
+        default: _event = e_FM_EV_DUMMY_LAST;                                                       \
+        break;                                                                                      \
+    }
+
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 /**************************************************************************//**
  @Description   PCD KG scheme registers
@@ -93,6 +203,8 @@ typedef _Packed struct t_FmPcdKgInterModuleSchemeRegs {
     volatile uint32_t kgse_dv1;     /**< KeyGen Scheme Entry Default Value 1 */
     volatile uint32_t kgse_ccbs;    /**< KeyGen Scheme Entry Coarse Classification Bit*/
     volatile uint32_t kgse_mv;      /**< KeyGen Scheme Entry Match vector */
+    volatile uint32_t kgse_om;      /**< KeyGen Scheme Entry Operation Mode bits */
+    volatile uint32_t kgse_vsp;     /**< KeyGen Scheme Entry Virtual Storage Profile */
 } _PackedType t_FmPcdKgInterModuleSchemeRegs;
 
 typedef _Packed struct t_FmPcdCcCapwapReassmTimeoutParams {
@@ -103,7 +215,6 @@ typedef _Packed struct t_FmPcdCcCapwapReassmTimeoutParams {
 
 
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -118,7 +229,6 @@ typedef uint32_t t_FmFmanCtrl;
 
 
 
-
 #define NUM_OF_SCRATCH_POOL_BUFFERS     1000 /*TODO - Change it!!*/
 
 typedef struct t_FmPcdCcFragScratchPoolCmdParams {
@@ -170,23 +280,23 @@ typedef struct
 #define CC_NEXT_NODE_F_OBJECT(ptr)  LIST_OBJECT(ptr, t_CcNodeInfo, node)
 
 typedef struct {
-    uint32_t    type;
-    uint8_t     prOffset;
-
-    uint16_t    dataOffset;
-    uint8_t     poolIndex;
-
-    uint8_t     poolIdForManip;
-    uint8_t     numOfTasks;
-    uint8_t     numOfExtraTasks;
-    uint8_t     hardwarePortId;
-
+    uint32_t            type;
+    uint8_t             prOffset;
+    uint16_t            dataOffset;
+  //  uint8_t             poolIndex;
+  //  uint8_t             poolIdForManip;
+    uint8_t             numOfTasks;
+    uint8_t             numOfExtraTasks;
+    uint8_t             hardwarePortId;
+    t_FmRevisionInfo    revInfo;
+    uint32_t            nia;
 } t_GetCcParams;
 
 typedef struct {
     uint32_t        type;
     int             psoSize;
     uint32_t        nia;
+    bool            immediateWrite;
     t_FmFmanCtrl    orFmanCtrl;
 } t_SetCcParams;
 
@@ -203,6 +313,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
         intFlags = XX_LockIntrSpinlock(h_Spinlock);
     else
         intFlags = XX_DisableAllIntr();
+
     if (*p_Flag)
     {
         if (h_Spinlock)
@@ -212,10 +323,12 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
         return FALSE;
     }
     *p_Flag = TRUE;
+
     if (h_Spinlock)
         XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
     else
         XX_RestoreAllIntr(intFlags);
+
     return TRUE;
 }
 
@@ -227,20 +340,22 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 *//***************************************************************************/
 #define INTERNAL_CONTEXT_OFFSET                 0x80000000
 #define OFFSET_OF_PR                            0x40000000
-#define BUFFER_POOL_ID_FOR_MANIP                0x20000000
+//#define BUFFER_POOL_ID_FOR_MANIP                0x20000000
 #define NUM_OF_TASKS                            0x10000000
 #define OFFSET_OF_DATA                          0x08000000
 #define HW_PORT_ID                              0x04000000
-#define NUM_OF_EXTRA_TASKS                      0x02000000
-
+#define FM_REV                                  0x02000000
+#define GET_NIA_FPNE                            0x01000000
+#define NUM_OF_EXTRA_TASKS                      0x00800000
 
 #define UPDATE_NIA_PNEN                         0x80000000
 #define UPDATE_PSO                              0x40000000
 #define UPDATE_NIA_PNDN                         0x20000000
 #define UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY      0x10000000
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-#define UPDATE_NIA_RFENE                        0x04000000
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+#define UPDATE_NIA_FENE                         0x04000000
+#define UPDATE_NIA_CMNE                         0x02000000
+#define UPDATE_NIA_FPNE                         0x01000000
+#define UPDATE_NIA_FNE                          0x00800000
 /* @} */
 
 /**************************************************************************//**
@@ -251,6 +366,8 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_CC_WITH_TREE                     0x40000000
 #define UPDATE_CC_WITH_DELETE_TREE              0x20000000
 #define UPDATE_KG_NIA_CC_WA                     0x10000000
+#define UPDATE_KG_OPT_MODE                      0x08000000
+#define UPDATE_KG_NIA                           0x04000000
 /* @} */
 
 /**************************************************************************//**
@@ -269,26 +386,33 @@ typedef uint32_t t_FmBlockErrIntrEnable;
 #define ERR_INTR_EN_MURAM       0x00040000
 #define ERR_INTR_EN_IRAM        0x00020000
 #define ERR_INTR_EN_10G_MAC0    0x00008000
+#define ERR_INTR_EN_10G_MAC1    0x00000040
 #define ERR_INTR_EN_1G_MAC0     0x00004000
 #define ERR_INTR_EN_1G_MAC1     0x00002000
 #define ERR_INTR_EN_1G_MAC2     0x00001000
 #define ERR_INTR_EN_1G_MAC3     0x00000800
 #define ERR_INTR_EN_1G_MAC4     0x00000400
-#define ERR_INTR_EN_MACSEC_MAC0 0x00000200
+#define ERR_INTR_EN_1G_MAC5     0x00000200
+#define ERR_INTR_EN_1G_MAC6     0x00000100
+#define ERR_INTR_EN_1G_MAC7     0x00000080
+#define ERR_INTR_EN_MACSEC_MAC0 0x00000001
 
 
 typedef uint32_t t_FmBlockIntrEnable;
 
-#define INTR_EN_BMI             0x80000000
 #define INTR_EN_QMI             0x40000000
 #define INTR_EN_PRS             0x20000000
-#define INTR_EN_KG              0x10000000
 #define INTR_EN_PLCR            0x08000000
-#define INTR_EN_1G_MAC0_TMR     0x00080000
-#define INTR_EN_1G_MAC1_TMR     0x00040000
-#define INTR_EN_1G_MAC2_TMR     0x00020000
-#define INTR_EN_1G_MAC3_TMR     0x00010000
-#define INTR_EN_1G_MAC4_TMR     0x00000040
+#define INTR_EN_1G_MAC0         0x00080000
+#define INTR_EN_1G_MAC1         0x00040000
+#define INTR_EN_1G_MAC2         0x00020000
+#define INTR_EN_1G_MAC3         0x00010000
+#define INTR_EN_1G_MAC4         0x00000040
+#define INTR_EN_1G_MAC5         0x00000020
+#define INTR_EN_1G_MAC6         0x00000008
+#define INTR_EN_1G_MAC7         0x00000002
+#define INTR_EN_10G_MAC0        0x00200000
+#define INTR_EN_10G_MAC1        0x00100000
 #define INTR_EN_REV0            0x00008000
 #define INTR_EN_REV1            0x00004000
 #define INTR_EN_REV2            0x00002000
@@ -312,6 +436,9 @@ typedef uint32_t t_FmBlockIntrEnable;
 /**************************************************************************//**
   @Description       NIA Description
 *//***************************************************************************/
+#define NIA_ENG_MASK                0x007C0000
+#define NIA_AC_MASK                 0x0003ffff
+
 #define NIA_ORDER_RESTOR            0x00800000
 #define NIA_ENG_FM_CTL              0x00000000
 #define NIA_ENG_PRS                 0x00440000
@@ -320,19 +447,20 @@ typedef uint32_t t_FmBlockIntrEnable;
 #define NIA_ENG_BMI                 0x00500000
 #define NIA_ENG_QMI_ENQ             0x00540000
 #define NIA_ENG_QMI_DEQ             0x00580000
-#define NIA_ENG_MASK                0x007C0000
 
 #define NIA_FM_CTL_AC_CC                        0x00000006
 #define NIA_FM_CTL_AC_HC                        0x0000000C
 #define NIA_FM_CTL_AC_IND_MODE_TX               0x00000008
 #define NIA_FM_CTL_AC_IND_MODE_RX               0x0000000A
 #define NIA_FM_CTL_AC_FRAG                      0x0000000e
-#define NIA_FM_CTL_AC_PRE_FETCH                 0x00000010
-#define NIA_FM_CTL_AC_POST_FETCH_PCD            0x00000012
-#define NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN    0x00000018
-#define NIA_FM_CTL_AC_POST_FETCH_NO_PCD         0x00000012
+#define NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER      0x00000010
+#define NIA_FM_CTL_AC_PRE_BMI_FETCH_FULL_FRAME  0x00000018
+#define NIA_FM_CTL_AC_POST_BMI_FETCH            0x00000012
+#define NIA_FM_CTL_AC_PRE_BMI_ENQ_FRAME         0x0000001A
+#define NIA_FM_CTL_AC_PRE_BMI_DISCARD_FRAME     0x0000001E
 #define NIA_FM_CTL_AC_FRAG_CHECK                0x00000014
 #define NIA_FM_CTL_AC_PRE_CC                    0x00000020
+#define NIA_FM_CTL_AC_SWITCH_PORT               0x00000020
 
 
 #define NIA_BMI_AC_ENQ_FRAME        0x00000002
@@ -349,10 +477,21 @@ typedef uint32_t t_FmBlockIntrEnable;
 
 #define NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA    0x00000202
 
+#define GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)   \
+    (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd))?(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_ENQ_FRAME): \
+                                                          (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+#define GET_NIA_BMI_AC_DISCARD_FRAME(h_FmPcd)   \
+    (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd))?(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_DISCARD_FRAME): \
+                                                          (NIA_ENG_BMI | NIA_BMI_AC_DISCARD))
+
 /**************************************************************************//**
  @Description       Port Id defines
 *//***************************************************************************/
+#if (DPAA_VERSION == 2)
 #define BASE_OH_PORTID              1
+#else
+#define BASE_OH_PORTID              2
+#endif /* (DPAA_VERSION == 2) */
 #define BASE_1G_RX_PORTID           8
 #define BASE_10G_RX_PORTID          0x10
 #define BASE_1G_TX_PORTID           0x28
@@ -535,6 +674,109 @@ switch(hdr)                                                 \
 }
 
 /***********************************************************************/
+/*          SW parser IP_FRAG patch                                    */
+/***********************************************************************/
+#if (DPAA_VERSION == 2)
+/* Version: 106.5 */
+#define SW_PRS_IP_FRAG_PATCH                           \
+{                                                      \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
+    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
+    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0, \
+    0x00,0x4A,0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x28,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x31,0x52,0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x53,0x8F,0x00,0x00,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
+    0x43,0x42,0x00,0x00,0x30,0x7E,0x43,0x42,0x00,0x3C, \
+    0x1B,0x5C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
+    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x1B,0x3B,0x30,0x7E,0x53,0x72,0x00,0x2B, \
+    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
+    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
+    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00, \
+    0x9B,0x8E,0x53,0x86,0x00,0x00,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00, \
+    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
+    0x28,0x43,0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
+    0x00,0x55,0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55, \
+    0x00,0x28,0x28,0x43,0x1B,0xC0,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E, \
+    0x43,0xB7,0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11, \
+    0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F, \
+    0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00, \
+    0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D, \
+    0x28,0x43,0x06,0x00,0x1B,0x9A,0x00,0x03,0x00,0x02, \
+    0x00,0x00,0x00,0x01,0x32,0xC1,0x32,0xF0,0x00,0x4A, \
+    0x00,0x80,0x1F,0xFF,0x00,0x01,0x1B,0xFE,           \
+};
+#define IP_FRAG_SW_PATCH_IPv4                   0x300
+#define IP_FRAG_SW_PATCH_IPv6                   0x31E
+#else
+/* version: 106.5 */
+#define SW_PRS_IP_FRAG_PATCH                           \
+{                                                      \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
+    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x2A,0x34,0xF5, \
+    0x00,0xFB,0xFF,0xFF,0x00,0x7F,0x00,0x00,0x00,0x00, \
+    0x2A,0x9F,0x34,0xB7,0x00,0xF9,0x00,0x00,0x01,0x00, \
+    0x00,0x00,0x00,0x00,0x2B,0x97,0x00,0x03,0x00,0x02, \
+    0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0,0x00,0x4F, \
+    0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+    0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x43,0x36,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+    0x00,0xDA,0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x53,0x9D,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x50, \
+    0x00,0x00,0x30,0x7E,0x43,0x50,0x00,0x3C,0x1B,0x6A, \
+    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
+    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
+    0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
+    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
+    0x1B,0x49,0x30,0x7E,0x53,0x80,0x00,0x2B,0x32,0x11, \
+    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E, \
+    0x53,0x94,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x41,0x06,0x29,0x32,0x01,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x41,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x43,0x1B,0xDC,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x41,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xC5, \
+    0x00,0x2C,0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
+    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x1B,0xA8,0x34,0xF5,0x00,0xFB,0xFF,0xFF, \
+    0x00,0x7F,0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7, \
+    0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00, \
+    0x2B,0x97,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01, \
+    0x32,0xC1,0x32,0xF0,0x00,0x4A,0x00,0x80,0x1F,0xFF, \
+    0x00,0x01,0x1B,0xFE,                               \
+};
+#define IP_FRAG_SW_PATCH_IPv4                   0x300
+#define IP_FRAG_SW_PATCH_IPv6                   0x32C
+#endif /* (DPAA_VERSION == 2) */
+
+/***********************************************************************/
 /*          Policer defines                                            */
 /***********************************************************************/
 #define FM_PCD_PLCR_PAR_GO                    0x80000000
@@ -549,6 +791,16 @@ switch(hdr)                                                 \
 /*          Keygen defines                                             */
 /***********************************************************************/
 /* maskes */
+#if DPAA_VERSION >= 3
+#define KG_SCH_VSP_SHIFT_MASK                   0x0003f000
+#define KG_SCH_OM_VSPE                          0x00000001
+#define KG_SCH_VSP_NO_KSP_EN                    0x80000000
+
+#define MAX_SP_SHIFT                            23
+#define KG_SCH_VSP_MASK_SHIFT                   12
+#define KG_SCH_VSP_SHIFT                        24
+#endif /* DPAA_VERSION >= 3 */
+
 #define KG_SCH_PP_SHIFT_HIGH                    0x80000000
 #define KG_SCH_PP_NO_GEN                        0x10000000
 #define KG_SCH_PP_SHIFT_LOW                     0x0000F000
@@ -675,7 +927,7 @@ typedef uint8_t t_GenericCodes;
 
 /* others */
 #define NUM_OF_SW_DEFAULTS                  3
-#define MAX_PP_SHIFT                        15
+#define MAX_PP_SHIFT                        23
 #define MAX_KG_SCH_SIZE                     16
 #define MASK_FOR_GENERIC_BASE_ID            0x20
 #define MAX_HASH_SHIFT                      40
@@ -747,44 +999,29 @@ uint32_t    FmPcdGetLcv(t_Handle h_FmPcd, uint32_t netEnvId, uint8_t hdrNum);
 uint32_t    FmPcdGetMacsecLcv(t_Handle h_FmPcd, uint32_t netEnvId);
 void        FmPcdIncNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
 void        FmPcdDecNetEnvOwners(t_Handle h_FmPcd, uint8_t netEnvId);
+uint8_t		FmPcdGetNetEnvId(t_Handle h_NetEnv);
 void        FmPcdPortRegister(t_Handle h_FmPcd, t_Handle h_FmPort, uint8_t hardwarePortId);
 uint32_t    FmPcdLock(t_Handle h_FmPcd);
 void        FmPcdUnlock(t_Handle h_FmPcd, uint32_t  intFlags);
 bool        FmPcdNetEnvIsHdrExist(t_Handle h_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
-bool        FmPcdIsIpFrag(t_Handle h_FmPcd, uint8_t netEnvId);
 t_Error     FmPcdFragHcScratchPoolInit(t_Handle h_FmPcd, uint8_t scratchBpid);
 t_Error     FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl);
 t_Error     FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl);
-t_Error     FmPcdCcReleaseModifiedDataStructure(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_List *h_FmPcdNewPointersLst, uint16_t numOfGoodChanges, t_Handle *h_Params);
-uint32_t    FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer);
-t_Error     FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
-t_Error     FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPCdCcKeyParams,  t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_Params);
-t_Error     FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst,  t_List *h_NewLst, t_Handle *h_AdditionalParams);
-t_Error     FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
-t_Error     FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams);
-t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
-t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint16_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams);
-uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
-t_Error     FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree);
-t_Error     FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List);
-void        FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree);
-void        FmPcdCcNodeTreeReleaseLock(t_List *p_List);
-t_Handle    FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree, uint8_t   manipIndx);
-void        FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams, uint8_t   manipIndx);
+bool        FmPcdIsAdvancedOffloadSupported(t_Handle h_FmPcd);
 
-bool        FmPcdKgIsSchemeValidSw(t_Handle h_FmPcd, uint8_t schemeId);
 uint8_t     FmPcdKgGetClsPlanGrpBase(t_Handle h_FmPcd, uint8_t clsPlanGrp);
 uint16_t    FmPcdKgGetClsPlanGrpSize(t_Handle h_FmPcd, uint8_t clsPlanGrp);
-
-t_Error     FmPcdKgBuildScheme(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_Scheme, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
+t_Error 	FmPcdKgBuildScheme(t_Handle h_Scheme,  t_FmPcdKgSchemeParams *p_SchemeParams, t_FmPcdKgInterModuleSchemeRegs *p_SchemeRegs);
 t_Error     FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_Grp, t_FmPcdKgInterModuleClsPlanSet *p_ClsPlanSet);
-uint8_t     FmPcdKgGetNumOfPartitionSchemes(t_Handle h_FmPcd);
-uint8_t     FmPcdKgGetPhysicalSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
+uint8_t     FmPcdKgGetSchemeId(t_Handle h_Scheme);
+#if DPAA_VERSION >= 3
+bool        FmPcdKgGetVspe(t_Handle h_Scheme);
+#endif
 uint8_t     FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId);
 void        FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId);
-void        FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
-void        FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
-t_Error     FmPcdKgCheckInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+//void        FmPcdKgValidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+//void        FmPcdKgInvalidateSchemeSw(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     FmPcdKgCheckInvalidateSchemeSw(t_Handle h_Scheme);
 t_Error     FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPortToSchemes, uint32_t *p_SpReg, bool add);
 void        FmPcdKgIncSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
 void        FmPcdKgDecSchemeOwners(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort);
@@ -799,9 +1036,10 @@ uint32_t    FmPcdKgBuildWritePortSchemeBindActionReg(uint8_t hardwarePortId);
 uint32_t    FmPcdKgBuildReadPortSchemeBindActionReg(uint8_t hardwarePortId);
 uint32_t    FmPcdKgBuildWritePortClsPlanBindActionReg(uint8_t hardwarePortId);
 uint8_t     FmPcdKgGetSchemeSwId(t_Handle h_FmPcd, uint8_t schemeHwId);
-t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, uint8_t schemeId, bool intr);
-void        FmPcdKgReleaseSchemeLock(t_Handle h_FmPcd, uint8_t schemeId);
-void        FmPcdKgUpatePointedOwner(t_Handle h_FmPcd, uint8_t schemeId, bool add);
+/*t_Error     FmPcdKgSchemeTryLock(t_Handle h_FmPcd, t_Handle h_Scheme);*/
+/*void        FmPcdKgReleaseSchemeLock(t_Handle h_Scheme);*/
+void        FmPcdKgUpatePointedOwner(t_Handle h_Scheme, bool add);
+bool        FmPcdKgIsSchemeValidSw(t_Handle h_Scheme);
 
 t_Error     FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes  *p_SchemeBind);
 t_Error     FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_SchemeBind);
@@ -809,10 +1047,13 @@ uint32_t    FmPcdKgGetRequiredAction(t_Handle h_FmPcd, uint8_t schemeId);
 uint32_t    FmPcdKgGetPointedOwners(t_Handle h_FmPcd, uint8_t schemeId);
 e_FmPcdDoneAction FmPcdKgGetDoneAction(t_Handle h_FmPcd, uint8_t schemeId);
 e_FmPcdEngine FmPcdKgGetNextEngine(t_Handle h_FmPcd, uint8_t schemeId);
-void        FmPcdKgUpdateRequiredAction(t_Handle h_FmPcd, uint8_t schemeId, uint32_t requiredAction);
+void        FmPcdKgUpdateRequiredAction(t_Handle h_Scheme, uint32_t requiredAction);
 bool        FmPcdKgIsDirectPlcr(t_Handle h_FmPcd, uint8_t schemeId);
 bool        FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId);
 uint16_t    FmPcdKgGetRelativeProfileId(t_Handle h_FmPcd, uint8_t schemeId);
+t_Error     FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t requiredAction, uint32_t value);
+t_Error     FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp);
+t_Error     FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
 
 /* FM-PCD parser API routines */
 t_Error     FmPcdPrsIncludePortInStatistics(t_Handle p_FmPcd, uint8_t hardwarePortId,  bool include);
@@ -828,7 +1069,8 @@ uint32_t    FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter);
 uint32_t    FmPcdPlcrBuildWritePlcrActionReg(uint16_t absoluteProfileId);
 uint32_t    FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId);
 t_Error     FmPcdPlcrBuildProfile(t_Handle h_FmPcd, t_FmPcdPlcrProfileParams *p_Profile, t_FmPcdPlcrInterModuleProfileRegs *p_PlcrRegs);
-t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle                      h_FmPcd,
+uint16_t    FmPcdPlcrProfileGetAbsoluteId(t_Handle h_Profile);
+t_Error     FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle                      h_FmPcd,
                                           e_FmPcdProfileTypeSelection   profileType,
                                           t_Handle                      h_FmPort,
                                           uint16_t                      relativeProfile,
@@ -836,36 +1078,50 @@ t_Error     FmPcdPlcrGetAbsoluteProfileId(t_Handle                      h_FmPcd,
 void        FmPcdPlcrInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 void        FmPcdPlcrValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 bool        FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg);
-t_Error     FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId, bool intr);
-void        FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId);
+/*t_Error     FmPcdPlcrProfileTryLock(t_Handle h_FmPcd, uint16_t profileId, bool intr);
+void        FmPcdPlcrReleaseProfileLock(t_Handle h_FmPcd, uint16_t profileId);*/
 uint32_t    FmPcdPlcrGetRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 uint32_t    FmPcdPlcrGetPointedOwners(t_Handle h_FmPcd, uint16_t absoluteProfileId);
 void        FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bool add);
 uint32_t    FmPcdPlcrBuildNiaProfileReg(bool green, bool yellow, bool red);
 void        FmPcdPlcrUpdateRequiredAction(t_Handle h_FmPcd, uint16_t absoluteProfileId, uint32_t requiredAction);
+t_Error     FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx,uint32_t requiredAction);
 
 /* FM-PCD Coarse-Classification API routines */
 uint8_t     FmPcdCcGetParseCode(t_Handle h_CcNode);
 uint8_t     FmPcdCcGetOffset(t_Handle h_CcNode);
-
-t_Error     FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree, bool modify);
-t_Error     FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_FmPortGetSetCcParams);
-uint32_t    FmPcdManipGetRequiredAction (t_Handle h_Manip);
+uint32_t    FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer);
+t_Error     FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex);
+t_Error     FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPCdCcKeyParams);
+t_Error     FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask);
+t_Error     FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams);
+t_Error     FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint16_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
+t_Error     FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree);
+void        FmPcdCcTreeReleaseLock(t_Handle h_FmPcdCcTree);
+t_Handle    FmPcdCcTreeGetSavedManipParams(t_Handle h_FmTree);
+void        FmPcdCcTreeSetSavedManipParams(t_Handle h_FmTree, t_Handle h_SavedManipParams);
+t_Error     FmPcdCcTreeAddIPR(t_Handle h_FmPcd, t_Handle h_FmTree, t_Handle h_NetEnv, t_Handle h_IpReassemblyManip, bool schemes);
 t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_CcTree,  uint32_t  *p_Offset,t_Handle h_FmPort);
 t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
 
-t_Error     FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx,uint32_t requiredAction);
-t_Error     FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t requiredAction);
+t_Error     FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree, bool modify);
+uint32_t    FmPcdManipGetRequiredAction (t_Handle h_Manip);
 
+t_Error     FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_FmPortGetSetCcParams);
 uint8_t     FmPortGetNetEnvId(t_Handle h_FmPort);
 uint8_t     FmPortGetHardwarePortId(t_Handle h_FmPort);
 uint32_t    FmPortGetPcdEngines(t_Handle h_FmPort);
 void        FmPortPcdKgSwUnbindClsPlanGrp (t_Handle h_FmPort);
 t_Error     FmPortAttachPCD(t_Handle h_FmPort);
-t_Error     FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t netEnvId, protocolOpt_t *p_OptArray, uint8_t *p_ClsPlanGrpId, bool *p_IsEmptyClsPlanGrp);
-t_Error     FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, uint8_t clsPlanGrpId);
 
 
+#if DPAA_VERSION >= 3
+t_Error     FmPcdFrmReplicUpdate(t_Handle h_FmPcd, t_Handle h_FmPort, t_Handle h_FrmReplic);
+#endif /* DPAA_VERSION >= 3 */
+
 /**************************************************************************//**
  @Function      FmRegisterIntr
 
@@ -881,7 +1137,7 @@ t_Error     FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hard
 
  @Return        None.
 *//***************************************************************************/
-void FmRegisterIntr(t_Handle                h_Fm,
+void FmRegisterIntr(t_Handle               h_Fm,
                     e_FmEventModules       mod,
                     uint8_t                modId,
                     e_FmIntrType           intrType,
@@ -962,9 +1218,7 @@ typedef struct t_FmInterModulePortInitParams {
 typedef struct t_FmInterModulePortFreeParams {
     uint8_t             hardwarePortId;     /**< IN. port Id */
     e_FmPortType        portType;           /**< IN. Port type */
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
     uint8_t             deqPipelineDepth;   /**< IN. Port's requested resource */
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 } t_FmInterModulePortFreeParams;
 
 /**************************************************************************//**
@@ -1035,7 +1289,7 @@ void FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr);
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
-uint32_t    FmGetTimeStampScale(t_Handle h_Fm);
+uint32_t FmGetTimeStampScale(t_Handle h_Fm);
 
 /**************************************************************************//**
  @Function      FmResumeStalledPort
@@ -1154,6 +1408,24 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls, t_FmFmanCtrl orFmanCtrl);
 
 
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//*
+ @Function      FmDumpPortRegs
+
+ @Description   Dumps FM port registers which are part of FM common registers
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     hardwarePortId    HW port id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only FM_Init().
+*//***************************************************************************/
+t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+
 void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
 void        FmUnregisterPcd(t_Handle h_Fm);
 t_Handle    FmGetPcdHandle(t_Handle h_Fm);
@@ -1176,20 +1448,44 @@ t_Error     Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId);
 
 void        FmMuramClear(t_Handle h_FmMuram);
 t_Error     FmSetNumOfOpenDmas(t_Handle h_Fm,
-                                uint8_t hardwarePortId,
-                                uint8_t numOfOpenDmas,
-                                uint8_t numOfExtraOpenDmas,
-                                bool    initialConfig);
+                               uint8_t  hardwarePortId,
+                               uint8_t  numOfOpenDmas,
+                               uint8_t  numOfExtraOpenDmas,
+                               bool     initialConfig);
 t_Error     FmSetNumOfTasks(t_Handle    h_Fm,
-                                uint8_t     hardwarePortId,
-                                uint8_t     numOfTasks,
-                                uint8_t     numOfExtraTasks,
-                                bool        initialConfig);
-t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
-                        uint8_t     hardwarePortId,
-                        uint32_t     sizeOfFifo,
-                        uint32_t     extraSizeOfFifo,
-                        bool        initialConfig);
+                            uint8_t     hardwarePortId,
+                            uint8_t     numOfTasks,
+                            uint8_t     numOfExtraTasks,
+                            bool        initialConfig);
+t_Error     FmSetSizeOfFifo(t_Handle    h_Fm,
+                            uint8_t     hardwarePortId,
+                            uint32_t    sizeOfFifo,
+                            uint32_t    extraSizeOfFifo,
+                            bool        initialConfig);
+
+t_Error     FmSetCongestionGroupPFCpriority(t_Handle    h_Fm,
+                                            uint32_t    congestionGroupId,
+                                            uint8_t     priorityBitMap);
+
+#if DPAA_VERSION >= 3
+t_Error     FmVSPAlloc(t_Handle         h_Fm,
+                               e_FmPortType     portType,
+                               uint8_t          portId,
+                               uint8_t          numOfStorageProfiles);
+
+t_Error     FmVSPFree(  t_Handle        h_Fm,
+                        e_FmPortType    portType,
+                        uint8_t         portId);
+
+t_Error     FmVSPGetAbsoluteProfileId(t_Handle      h_Fm,
+                                      e_FmPortType  portType,
+                                      uint8_t       portId,
+                                      uint16_t      relativeProfile,
+                                      uint16_t      *p_AbsoluteId);
+
+uintptr_t   FmGetVSPBaseAddr(t_Handle h_Fm);
+
+#endif /* DPAA_VERSION >= 3 */
 
 
 #endif /* __FM_COMMON_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
index 780fcc8..c28760f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -49,33 +49,26 @@ typedef struct t_FmHcParams {
 
 t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams);
 void        FmHcFree(t_Handle h_FmHc);
+t_Error     FmHcSetFramesDataMemory(t_Handle h_FmHc,
+                                    uint8_t  memId);
 t_Error     FmHcDumpRegs(t_Handle h_FmHc);
 
 void        FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd);
 
-t_Handle    FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme);
+t_Error    	FmHcPcdKgSetScheme(t_Handle h_FmHc, t_Handle h_Scheme, t_FmPcdKgSchemeParams *p_Scheme);
 t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
 t_Error     FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams );
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
 t_Error     FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams);
 t_Error     FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams *p_CcIpReassmTimeoutParams, uint8_t *p_Result);
-uint32_t    FmHcPcdCcIpFrag(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragCmdParams);
-#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
 t_Error     FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set);
 t_Error     FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t clsPlanGrpId);
 
 t_Error     FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t value);
 uint32_t    FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme);
 
-t_Error     FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-t_Error     FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-t_Error     FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-t_Error     FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex);
-t_Error     FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
-t_Error     FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
-t_Error     FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
+t_Error     FmHcPcdCcDoDynamicChange(t_Handle h_FmHc, uint32_t oldAdAddrOffset, uint32_t newAdAddrOffset);
 
-t_Handle    FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile);
+t_Error 	FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrProfileParams *p_ProfileParams);
 t_Error     FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile);
 
 t_Error     FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
@@ -84,8 +77,9 @@ uint32_t    FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_
 t_Error     FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, bool add);
 t_Error     FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg);
 
-t_Error     FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t requiredAction);
+t_Error     FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t requiredAction, uint32_t value);
 t_Error     FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, uint32_t requiredAction);
 
 
+
 #endif /* __FM_HC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h
new file mode 100644
index 0000000..af71d96
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_sp_common.h
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_sp_common.h
+
+ @Description   FM SP  ...
+*//***************************************************************************/
+#ifndef __FM_SP_COMMON_H
+#define __FM_SP_COMMON_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+
+#include "fm_ext.h"
+#include "fm_pcd_ext.h"
+
+/* sizes */
+#define CAPWAP_FRAG_EXTRA_SPACE                 32
+#define OFFSET_UNITS                            16
+#define MAX_INT_OFFSET                          240
+#define MAX_IC_SIZE                             256
+#define MAX_EXT_OFFSET                          496
+#define MAX_EXT_BUFFER_OFFSET                   511
+
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+#define DEFAULT_FM_SP_bufferPrefixContent_privDataSize   0
+#define DEFAULT_FM_SP_bufferPrefixContent_passPrsResult  FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp  FALSE
+#define DEFAULT_FM_SP_bufferPrefixContent_allOtherPCDInfo    FALSE
+//#define DEFAULT_FM_SP_bufferPrefixContent_dataAlign      DATA_ALIGNMENT - // TODO should be this way
+#define DEFAULT_FM_SP_bufferPrefixContent_dataAlign      64
+#define DEFAULT_FM_SP_dmaSwapData                        e_FM_DMA_NO_SWP
+#define DEFAULT_FM_SP_dmaIntContextCacheAttr             e_FM_DMA_NO_STASH
+#define DEFAULT_FM_SP_dmaHeaderCacheAttr                 e_FM_DMA_NO_STASH
+#define DEFAULT_FM_SP_dmaScatterGatherCacheAttr          e_FM_DMA_NO_STASH
+#define DEFAULT_FM_SP_dmaWriteOptimize                   FALSE
+#define DEFAULT_FM_SP_noScatherGather                   FALSE
+
+/**************************************************************************//**
+ @Description       Registers bit fields
+*//***************************************************************************/
+#define FM_SP_EXT_BUF_POOL_EN_COUNTER             0x40000000
+#define FM_SP_EXT_BUF_POOL_VALID                  0x80000000
+#define FM_SP_EXT_BUF_POOL_BACKUP                 0x20000000
+#define FM_SP_DMA_ATTR_WRITE_OPTIMIZE             0x00100000
+#define FM_SP_SG_DISABLE                          0x80000000
+
+/* shifts */
+#define FM_SP_EXT_BUF_POOL_ID_SHIFT               16
+#define FM_SP_POOL_DEP_NUM_OF_POOLS_SHIFT         16
+#define FM_SP_EXT_BUF_MARG_START_SHIFT            16
+#define FM_SP_EXT_BUF_MARG_END_SHIFT              0
+#define FM_SP_DMA_ATTR_SWP_SHIFT                  30
+#define FM_SP_DMA_ATTR_IC_CACHE_SHIFT             28
+#define FM_SP_DMA_ATTR_HDR_CACHE_SHIFT            26
+#define FM_SP_DMA_ATTR_SG_CACHE_SHIFT             24
+#define FM_SP_IC_TO_EXT_SHIFT                     16
+#define FM_SP_IC_FROM_INT_SHIFT                   8
+#define FM_SP_IC_SIZE_SHIFT                       0
+
+
+/**************************************************************************//**
+ @Description   structure for defining internal context copying
+*//***************************************************************************/
+typedef struct
+{
+    uint16_t    extBufOffset;       /**< Offset in External buffer to which internal
+                                         context is copied to (Rx) or taken from (Tx, Op). */
+    uint8_t     intContextOffset;   /**< Offset within internal context to copy from
+                                         (Rx) or to copy to (Tx, Op). */
+    uint16_t    size;               /**< Internal offset size to be copied */
+} t_FmSpIntContextDataCopy;
+
+/**************************************************************************//**
+ @Description   struct for defining external buffer margins
+*//***************************************************************************/
+typedef struct {
+    uint16_t    startMargins;           /**< Number of bytes to be left at the beginning
+                                             of the external buffer (must be divisible by 16) */
+    uint16_t    endMargins;             /**< number of bytes to be left at the end
+                                             of the external buffer(must be divisible by 16) */
+} t_FmSpBufMargins;
+
+typedef struct {
+    uint32_t      dataOffset;
+    uint32_t      prsResultOffset;
+    uint32_t      timeStampOffset;
+    uint32_t      hashResultOffset;
+    uint32_t      pcdInfoOffset;
+    uint32_t      manipOffset;
+} t_FmSpBufferOffsets;
+
+
+t_Error        FmSpBuildBufferStructure(t_FmSpIntContextDataCopy      *p_FmPortIntContextDataCopy,
+                                        t_FmBufferPrefixContent       *p_BufferPrefixContent,
+                                        t_FmSpBufMargins              *p_FmPortBufMargins,
+                                        t_FmSpBufferOffsets           *p_FmPortBufferOffsets,
+                                        uint8_t                       *internalBufferOffset);
+
+t_Error     FmSpCheckIntContextParams(t_FmSpIntContextDataCopy *p_FmSpIntContextDataCopy);
+t_Error     FmSpCheckBufPoolsParams(t_FmExtPools *p_FmExtPools,
+                                    t_FmBackupBmPools *p_FmBackupBmPools,
+                                    t_FmBufPoolDepletion *p_FmBufPoolDepletion);
+t_Error     FmSpCheckBufMargins(t_FmSpBufMargins *p_FmSpBufMargins);
+void        FmSpSetBufPoolsInAscOrderOfBufSizes(t_FmExtPools *p_FmExtPools, uint8_t *orderedArray, uint16_t *sizesArray);
+
+t_Error     FmPcdSpAllocProfiles(t_Handle h_FmPcd,
+                                 uint8_t  hardwarePortId,
+                                 uint16_t numOfStorageProfiles,
+                                 uint16_t *base,
+                                 uint8_t  *log2Num);
+t_Error     FmPcdSpGetAbsoluteProfileId(t_Handle                        h_FmPcd,
+                                        t_Handle                        h_FmPort,
+                                        uint16_t                        relativeProfile,
+                                        uint16_t                        *p_AbsoluteId);
+void SpInvalidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+void SpValidateProfileSw(t_Handle h_FmPcd, uint16_t absoluteProfileId);
+
+
+#endif /* __FM_SP_COMMON_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
index 6909baf..a6fcb4c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -37,8 +37,8 @@
  @Description   General errors and events reporting utilities.
 *//***************************************************************************/
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 const char *dbgLevelStrings[] =
 {
      "CRITICAL"
@@ -61,7 +61,6 @@ const char *errTypeStrings[] =
     ,"Invalid Value"                        /* E_INVALID_VALUE */
     ,"Invalid Selection"                    /* E_INVALID_SELECTION */
     ,"Invalid Communication Mode"           /* E_INVALID_COMM_MODE */
-    ,"Invalid Byte Order"                   /* E_INVALID_BYTE_ORDER */
     ,"Invalid Memory Type"                  /* E_INVALID_MEMORY_TYPE */
     ,"Invalid Interrupt Queue"              /* E_INVALID_INTR_QUEUE */
     ,"Invalid Priority"                     /* E_INVALID_PRIORITY */
@@ -90,29 +89,4 @@ const char *errTypeStrings[] =
     ,"Receive Operation Failed"             /* E_RECEIVE_FAILED */
     ,"Operation Timed Out"                  /* E_TIMEOUT */
 };
-
-
-#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
-
-const char *eventStrings[] =
-{
-     "Rx Discard"                           /* EV_RX_DISCARD */
-    ,"Rx Error"                             /* EV_RX_ERROR */
-    ,"Tx Error"                             /* EV_TX_ERROR */
-    ,"No Buffer Objects"                    /* EV_NO_BUFFERS */
-    ,"No MB-Frame Objects"                  /* EV_NO_MB_FRAMES */
-    ,"No SB-Frame Objects"                  /* EV_NO_SB_FRAMES */
-    ,"Tx Queue Is Full"                     /* EV_TX_QUEUE_FULL */
-    ,"Rx Queue Is Full"                     /* EV_RX_QUEUE_FULL */
-    ,"Interrupts Queue Is Full"             /* EV_INTR_QUEUE_FULL */
-    ,"Data Buffer Is Unavailable"           /* EV_NO_DATA_BUFFER */
-    ,"Objects Pool Is Empty"                /* EV_OBJ_POOL_EMPTY */
-    ,"Illegal bus access"                   /* EV_BUS_ERROR */
-    ,"PTP Tx Timestamps Queue Is Full"      /* EV_PTP_TXTS_QUEUE_FULL */
-    ,"PTP Rx Timestamps Queue Is Full"      /* EV_PTP_RXTS_QUEUE_FULL */
-};
-
-#endif /* (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0)) */
-
 #endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
-
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
index 6c336f3..99c340a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
index 9e48fa8..e72be23 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
index 85fc292..00a1d2a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -33,7 +33,6 @@
 #include "string_ext.h"
 #include "error_ext.h"
 #include "std_ext.h"
-#include "sprint_ext.h"
 #include "part_ext.h"
 #include "xx_ext.h"
 
@@ -614,14 +613,17 @@ t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MM spinlock!"));
     }
 
-    /* initializes a new memory block */
+    /* Initializes counter of free memory to total size */
+    p_MM->freeMemSize = size;
+
+    /* Initializes a new memory block */
     if ((p_MM->memBlocks = CreateNewBlock(base, size)) == NULL)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
 
     /* A busy list is empty */
     p_MM->busyBlocks = 0;
 
-    /*Initializes a new free block for each free list*/
+    /* Initializes a new free block for each free list*/
     for (i=0; i <= MM_MAX_ALIGNMENT; i++)
     {
         newBase = MAKE_ALIGNED( base, (0x1 << i) );
@@ -754,6 +756,9 @@ uint64_t MM_Get(t_Handle h_MM, uint64_t size, uint64_t alignment, char* name)
         return (uint64_t)(ILLEGAL_BASE);
     }
 
+    /* Decreasing the allocated memory size from free memory size */
+    p_MM->freeMemSize -= size;
+
     /* insert the new busy block into the list of busy blocks */
     AddBusy ( p_MM, p_NewBusyB );
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
@@ -807,6 +812,9 @@ uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
         return (uint64_t)(ILLEGAL_BASE);
     }
 
+    /* Decreasing the allocated memory size from free memory size */
+	p_MM->freeMemSize -= size;
+
     /* insert the new busy block into the list of busy blocks */
     AddBusy ( p_MM, p_NewBusyB );
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
@@ -892,6 +900,9 @@ uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, uint64_t alignment, uint64
         return (uint64_t)(ILLEGAL_BASE);
     }
 
+    /* Decreasing the allocated memory size from free memory size */
+	p_MM->freeMemSize -= size;
+
     /* insert the new busy block into the list of busy blocks */
     AddBusy( p_MM, p_NewBusyB );
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
@@ -942,6 +953,9 @@ uint64_t MM_Put(t_Handle h_MM, uint64_t base)
 
     size = p_BusyB->end - p_BusyB->base;
 
+    /* Adding the deallocated memory size to free memory size */
+	p_MM->freeMemSize += size;
+
     XX_Free(p_BusyB);
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
 
@@ -958,6 +972,7 @@ uint64_t MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size)
     ASSERT_COND(p_MM);
 
     intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+
     if ( CutBusy( p_MM, base, end ) != E_OK )
     {
         XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
@@ -969,6 +984,10 @@ uint64_t MM_PutForce(t_Handle h_MM, uint64_t base, uint64_t size)
         XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
         return (uint64_t)(0);
     }
+
+    /* Adding the deallocated memory size to free memory size */
+	p_MM->freeMemSize += size;
+
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
 
     return (size);
@@ -988,6 +1007,7 @@ t_Error MM_Add(t_Handle h_MM, uint64_t base, uint64_t size)
      * memory block
      */
     intFlags = XX_LockIntrSpinlock(p_MM->h_Spinlock);
+
     p_MemB = p_MM->memBlocks;
     while ( p_MemB->p_Next )
     {
@@ -1024,6 +1044,10 @@ t_Error MM_Add(t_Handle h_MM, uint64_t base, uint64_t size)
         XX_Free(p_NewMemB);
         return ((t_Error)errCode);
     }
+
+    /* Adding the new block size to free memory size */
+	p_MM->freeMemSize += size;
+
     XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
 
     return (E_OK);
@@ -1077,7 +1101,17 @@ bool MM_InRange(t_Handle h_MM, uint64_t addr)
 }
 
 /*****************************************************************************/
-void MM_Dump(t_Handle h_MM, void *buff)
+uint64_t MM_GetFreeMemSize(t_Handle h_MM)
+{
+	t_MM       *p_MM = (t_MM*)h_MM;
+
+	ASSERT_COND(p_MM);
+
+	return p_MM->freeMemSize;
+}
+
+/*****************************************************************************/
+void MM_Dump(t_Handle h_MM)
 {
     t_MM        *p_MM = (t_MM *)h_MM;
     t_FreeBlock *p_FreeB;
@@ -1085,25 +1119,23 @@ void MM_Dump(t_Handle h_MM, void *buff)
     int          i;
 
     p_BusyB = p_MM->busyBlocks;
-    Sprint(buff, "List of busy blocks:\n");
+    XX_Print("List of busy blocks:\n");
     while (p_BusyB)
     {
-        Sprint(buff, "\t0x%p: (%s: b=0x%lx, e=0x%lx)\n",
-               p_BusyB, p_BusyB->name, p_BusyB->base, p_BusyB->end );
+        XX_Print("\t0x%p: (%s: b=0x%llx, e=0x%llx)\n", p_BusyB, p_BusyB->name, p_BusyB->base, p_BusyB->end );
         p_BusyB = p_BusyB->p_Next;
     }
 
-    Sprint(buff, "\nLists of free blocks according to alignment:\n");
+    XX_Print("\nLists of free blocks according to alignment:\n");
     for (i=0; i <= MM_MAX_ALIGNMENT; i++)
     {
-        Sprint(buff, "%d alignment:\n", (0x1 << i));
+        XX_Print("%d alignment:\n", (0x1 << i));
         p_FreeB = p_MM->freeBlocks[i];
         while (p_FreeB)
         {
-            Sprint(buff, "\t0x%p: (b=0x%lx, e=0x%lx)\n",
-                   p_FreeB, p_FreeB->base, p_FreeB->end);
+            XX_Print("\t0x%p: (b=0x%llx, e=0x%llx)\n", p_FreeB, p_FreeB->base, p_FreeB->end);
             p_FreeB = p_FreeB->p_Next;
         }
-        Sprint(buff, "\n");
+        XX_Print("\n");
     }
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
index cfcdd7c..ed46e9f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -55,7 +55,7 @@
     (((uint64_t)(addr) + ((align) - 1)) & (~(((uint64_t)align) - 1)))
 
 
-/* t_MemBlock data stucutre defines parameters of the Memory Block */
+/* t_MemBlock data structure defines parameters of the Memory Block */
 typedef struct t_MemBlock
 {
     struct t_MemBlock *p_Next;      /* Pointer to the next memory block */
@@ -65,7 +65,7 @@ typedef struct t_MemBlock
 } t_MemBlock;
 
 
-/* t_FreeBlock data stucutre defines parameters of the Free Block */
+/* t_FreeBlock data structure defines parameters of the Free Block */
 typedef struct t_FreeBlock
 {
     struct t_FreeBlock *p_Next;     /* Pointer to the next free block */
@@ -75,7 +75,7 @@ typedef struct t_FreeBlock
 } t_FreeBlock;
 
 
-/* t_BusyBlock data stucutre defines parameters of the Busy Block  */
+/* t_BusyBlock data structure defines parameters of the Busy Block  */
 typedef struct t_BusyBlock
 {
     struct t_BusyBlock *p_Next;         /* Pointer to the next free block */
@@ -90,11 +90,14 @@ typedef struct t_BusyBlock
 /* t_MM data structure defines parameters of the MM object */
 typedef struct t_MM
 {
-    t_MemBlock      *memBlocks;     /* List of memory blocks (Memory list) */
+	t_Handle        h_Spinlock;
+
+	t_MemBlock      *memBlocks;     /* List of memory blocks (Memory list) */
     t_BusyBlock     *busyBlocks;    /* List of busy blocks (Busy list) */
     t_FreeBlock     *freeBlocks[MM_MAX_ALIGNMENT + 1];
                                     /* Alignment lists of free blocks (Free lists) */
-    t_Handle        h_Spinlock;
+
+    uint64_t		freeMemSize;	/* Total size of free memory (in bytes) */
 } t_MM;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
index abf08ce..3dfd308 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
index 861f701..4745fb1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
index 5981fed..03457d5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -53,7 +53,6 @@
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 /**************************************************************************//**
  @Description   Frame descriptor
@@ -195,7 +194,6 @@ do {                                                            \
 #define DPAA_SGTE_SET_OFFSET(sgte,val)    (((t_DpaaSGTE *)sgte)->offset = ((((t_DpaaSGTE *)sgte)->offset & ~DPAA_SGTE_OFFSET_MASK) | (((val) << (31-31))& DPAA_SGTE_OFFSET_MASK) )) /**< Macro to set SGTE OFFSET field */
 /* @} */
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index 67ba811..d00b6da 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -54,31 +54,29 @@
 /**************************************************************************//**
  @Group         FM_lib_grp FM library
 
- @Description   FM API functions, definitions and enums
+ @Description   FM API functions, definitions and enum's.
+
                 The FM module is the main driver module and is a mandatory module
-                for FM driver users. Before any further module initialization,
-                this module must be initialized.
-                The FM is a "singletone" module. It is responsible of the common
-                HW modules: FPM, DMA, common QMI, common BMI initializations and
+                for FM driver users. This module must be initialized first prior
+                to any other drivers modules.
+                The FM is a "singleton" module. It is responsible of the common
+                HW modules: FPM, DMA, common QMI and common BMI initializations and
                 run-time control routines. This module must be initialized always
                 when working with any of the FM modules.
-                NOTE - We assumes that the FML will be initialize only by core No. 0!
+                NOTE - We assume that the FMlibrary will be initialize only by core No. 0!
 
  @{
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Description   enum for defining port types
+ @Description   Enum for defining port types
 *//***************************************************************************/
 typedef enum e_FmPortType {
-    e_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port (id's: 0-6, share id's with
-                                                 host command, so must have exclusive id) */
-    e_FM_PORT_TYPE_OH_HOST_COMMAND,         /**< Host command port (id's: 0-6, share id's with
-                                                 offline parsing ports, so must have exclusive id) */
-    e_FM_PORT_TYPE_RX,                      /**< 1G Rx port (id's: 0-3) */
-    e_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port (id's: 0) */
-    e_FM_PORT_TYPE_TX,                      /**< 1G Tx port (id's: 0-3) */
-    e_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port (id's: 0) */
+    e_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port */
+    e_FM_PORT_TYPE_RX,                      /**< 1G Rx port */
+    e_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port */
+    e_FM_PORT_TYPE_TX,                      /**< 1G Tx port */
+    e_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port */
     e_FM_PORT_TYPE_DUMMY
 } e_FmPortType;
 
@@ -93,7 +91,6 @@ typedef enum e_FmPortType {
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-#define MEM_MAP_START
 
 /**************************************************************************//**
  @Description   FM physical Address
@@ -172,6 +169,19 @@ typedef _Packed struct t_FmContextA {
 typedef uint32_t t_FmContextB;
 
 /**************************************************************************//**
+ @Collection   Special Operation options
+*//***************************************************************************/
+typedef uint32_t fmSpecialOperations_t;                 /**< typedef for defining Special Operation options */
+
+#define  FM_SP_OP_IPSEC                     0x80000000  /**< activate features that related to IPSec (e.g fix Eth-type) */
+#define  FM_SP_OP_IPSEC_UPDATE_UDP_LEN      0x40000000  /**< update the UDP-Len after Encryption */
+#define  FM_SP_OP_IPSEC_MANIP               0x20000000  /**< handle the IPSec-manip options */
+#define  FM_SP_OP_RPD                       0x10000000  /**< Set the RPD bit */
+#define  FM_SP_OP_DCL4C                     0x08000000  /**< Set the DCL4C bit */
+#define  FM_SP_OP_CHECK_SEC_ERRORS          0x04000000  /**< Check SEC errors */
+/* @} */
+
+/**************************************************************************//**
  @Collection   Context A macros
 *//***************************************************************************/
 #define FM_CONTEXTA_OVERRIDE_MASK       0x80000000
@@ -211,7 +221,6 @@ typedef uint32_t t_FmContextB;
 #define FM_CONTEXTB_SET_FQID(contextB,val)  (*((t_FmContextB *)contextB) = ((*((t_FmContextB *)contextB) & ~FM_CONTEXTB_FQID_MASK) | ((val) & FM_CONTEXTB_FQID_MASK)))
 /* @} */
 
-#define MEM_MAP_END
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
@@ -222,17 +231,18 @@ typedef uint32_t t_FmContextB;
 *//***************************************************************************/
 typedef enum e_FmExceptions {
     e_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
-    e_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
-    e_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
-    e_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
+    e_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error (Valid for FM rev < 6)*/
+    e_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
+    e_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
+    e_FM_EX_DMA_SINGLE_PORT_ECC,        /**< Single Port ECC error on FM side (Valid for FM rev > 6)*/
     e_FM_EX_FPM_STALL_ON_TASKS,         /**< Stall of tasks on FPM */
     e_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
     e_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
     e_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
     e_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occurred on QMI */
-    e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeu from unknown port id */
+    e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeue from unknown port id */
     e_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
-    e_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
+    e_FM_EX_BMI_STORAGE_PROFILE_ECC,    /**< Storage Profile ECC Error */
     e_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
     e_FM_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
     e_FM_EX_IRAM_ECC,                   /**< Double bit ECC occurred on IRAM*/
@@ -240,6 +250,26 @@ typedef enum e_FmExceptions {
 } e_FmExceptions;
 
 /**************************************************************************//**
+ @Description   Enum for defining port DMA swap mode
+*//***************************************************************************/
+typedef enum e_FmDmaSwapOption {
+    e_FM_DMA_NO_SWP,           /**< No swap, transfer data as is.*/
+    e_FM_DMA_SWP_PPC_LE,       /**< The transferred data should be swapped
+                                    in PowerPc Little Endian mode. */
+    e_FM_DMA_SWP_BE            /**< The transferred data should be swapped
+                                    in Big Endian mode */
+} e_FmDmaSwapOption;
+
+/**************************************************************************//**
+ @Description   Enum for defining port DMA cache attributes
+*//***************************************************************************/
+typedef enum e_FmDmaCacheOption {
+    e_FM_DMA_NO_STASH = 0,     /**< Cacheable, no Allocate (No Stashing) */
+    e_FM_DMA_STASH = 1         /**< Cacheable and Allocate (Stashing on) */
+} e_FmDmaCacheOption;
+
+
+/**************************************************************************//**
  @Group         FM_init_grp FM Initialization Unit
 
  @Description   FM Initialization Unit
@@ -247,9 +277,9 @@ typedef enum e_FmExceptions {
                 Initialization Flow
                 Initialization of the FM Module will be carried out by the application
                 according to the following sequence:
-                a.  Calling the configuration routine with basic parameters.
-                b.  Calling the advance initialization routines to change driver's defaults.
-                c.  Calling the initialization routine.
+                -  Calling the configuration routine with basic parameters.
+                -  Calling the advance initialization routines to change driver's defaults.
+                -  Calling the initialization routine.
 
  @{
 *//***************************************************************************/
@@ -288,76 +318,160 @@ typedef void (t_FmBusErrorCallback) (t_Handle        h_App,
                                      uint16_t        liodn);
 
 /**************************************************************************//**
- @Description   structure for defining Ucode patch for loading.
-*//***************************************************************************/
-typedef struct t_FmPcdFirmwareParams {
+ @Description   A structure for defining buffer prefix area content.
+*//***************************************************************************/
+typedef struct t_FmBufferPrefixContent {
+    uint16_t    privDataSize;       /**< Number of bytes to be left at the beginning
+                                         of the external buffer; Note that the private-area will
+                                         start from the base of the buffer address. */
+    bool        passPrsResult;      /**< TRUE to pass the parse result to/from the FM;
+                                         User may use FM_PORT_GetBufferPrsResult() in order to
+                                         get the parser-result from a buffer. */
+    bool        passTimeStamp;      /**< TRUE to pass the timeStamp to/from the FM
+                                         User may use FM_PORT_GetBufferTimeStamp() in order to
+                                         get the parser-result from a buffer. */
+    bool        passHashResult;     /**< TRUE to pass the KG hash result to/from the FM
+                                         User may use FM_PORT_GetBufferHashResult() in order to
+                                         get the parser-result from a buffer. */
+    bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
+                                         AD, hash-result, key, etc. */
+    uint16_t    dataAlign;          /**< 0 to use driver's default alignment, other value
+                                         for selecting a data alignment (must be a
+                                         power of 2) */
+    uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size);
+                                         Note that this field impacts the size of the buffer-prefix
+                                         (i.e. it pushes the data offset); in addition, in some cases
+                                         (like DPAA_VERSION>2 and it is related to Rx FM-Port) */
+} t_FmBufferPrefixContent;
+
+/**************************************************************************//**
+ @Description   A structure of information about each of the external
+                buffer pools used by a port or storage-profile.
+*//***************************************************************************/
+typedef struct t_FmExtPoolParams {
+    uint8_t                 id;     /**< External buffer pool id */
+    uint16_t                size;   /**< External buffer pool buffer size */
+} t_FmExtPoolParams;
+
+/**************************************************************************//**
+ @Description   A structure for informing the driver about the external
+                buffer pools allocated in the BM and used by a port or a
+                storage-profile.
+*//***************************************************************************/
+typedef struct t_FmExtPools {
+    uint8_t                 numOfPoolsUsed;     /**< Number of pools use by this port */
+    t_FmExtPoolParams       extBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                                /**< Parameters for each port */
+} t_FmExtPools;
+
+/**************************************************************************//**
+ @Description   A structure for defining backup BM Pools.
+*//***************************************************************************/
+typedef struct t_FmBackupBmPools {
+    uint8_t     numOfBackupPools;       /**< Number of BM backup pools -
+                                             must be smaller than the total number of
+                                             pools defined for the specified port.*/
+    uint8_t     poolIds[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+                                        /**< numOfBackupPools pool id's, specifying which
+                                             pools should be used only as backup. Pool
+                                             id's specified here must be a subset of the
+                                             pools used by the specified port.*/
+} t_FmBackupBmPools;
+
+/**************************************************************************//**
+ @Description   A structure for defining BM pool depletion criteria
+*//***************************************************************************/
+typedef struct t_FmBufPoolDepletion {
+    bool        poolsGrpModeEnable;                 /**< select mode in which pause frames will be sent after
+                                                         a number of pools (all together!) are depleted */
+    uint8_t     numOfPools;                         /**< the number of depleted pools that will invoke
+                                                         pause frames transmission. */
+    bool        poolsToConsider[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!). */
+    bool        singlePoolModeEnable;               /**< select mode in which pause frames will be sent after
+                                                         a single-pool is depleted; */
+    bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_POOLS];
+                                                    /**< For each pool, TRUE if it should be considered for
+                                                         depletion (Note - this pool must be used by this port!) */
+#if DPAA_VERSION >= 3
+    bool        pfcPrioritiesEn[FM_MAX_NUM_OF_PFC_PRIORITIES];
+                                                    /**< This field is used by the MAC as the Priority Enable Vector in the PFC frame which is transmitted */
+#endif /* DPAA_VERSION >= 3 */
+} t_FmBufPoolDepletion;
+
+/**************************************************************************//**
+ @Description   A Structure for defining Ucode patch for loading.
+*//***************************************************************************/
+typedef struct t_FmFirmwareParams {
     uint32_t                size;                   /**< Size of uCode */
     uint32_t                *p_Code;                /**< A pointer to the uCode */
-} t_FmPcdFirmwareParams;
+} t_FmFirmwareParams;
 
 /**************************************************************************//**
- @Description   structure representing FM initialization parameters
+ @Description   A Structure for defining FM initialization parameters
 *//***************************************************************************/
-#define FM_SIZE_OF_LIODN_TABLE  64
 typedef struct t_FmParams {
     uint8_t                 fmId;                   /**< Index of the FM */
-
     uint8_t                 guestId;                /**< FM Partition Id */
-
-    uintptr_t               baseAddr;               /**< Relevant when guestId = NCSW_MASSTER_ID only.
+    uintptr_t               baseAddr;               /**< Relevant when guestId = NCSW_MASTER_ID only;
                                                          A pointer to base of memory mapped FM registers (virtual);
-                                                         NOTE that this should include ALL common regs of the FM including
-                                                         the PCD regs area. */
-    t_Handle                h_FmMuram;              /**< Relevant when guestId = NCSW_MASSTER_ID only.
+                                                         NOTE that this should include ALL common registers of the FM including
+                                                         the PCD registers area (i.e. until the VSP pages - 880KB). */
+    t_Handle                h_FmMuram;              /**< Relevant when guestId = NCSW_MASTER_ID only;
                                                          A handle of an initialized MURAM object,
                                                          to be used by the FM */
-    uint16_t                fmClkFreq;              /**< Relevant when guestId = NCSW_MASSTER_ID only.
+    uint16_t                fmClkFreq;              /**< Relevant when guestId = NCSW_MASTER_ID only;
                                                          In Mhz */
-#ifdef FM_PARTITION_ARRAY
-    uint16_t                liodnBasePerPort[FM_SIZE_OF_LIODN_TABLE];
-                                                    /**< Relevant when guestId = NCSW_MASSTER_ID only.
-                                                         For each partition, LIODN should be configured here. */
-#endif /* FM_PARTITION_ARRAY */
-    t_FmExceptionsCallback  *f_Exception;           /**< Relevant when guestId = NCSW_MASSTER_ID only.
+    t_FmExceptionsCallback  *f_Exception;           /**< Relevant when guestId = NCSW_MASTER_ID only;
                                                          An application callback routine to
                                                          handle exceptions.*/
-    t_FmBusErrorCallback    *f_BusError;            /**< Relevant when guestId = NCSW_MASSTER_ID only.
+    t_FmBusErrorCallback    *f_BusError;            /**< Relevant when guestId = NCSW_MASTER_ID only;
                                                          An application callback routine to
                                                          handle exceptions.*/
-    t_Handle                h_App;                  /**< Relevant when guestId = NCSW_MASSTER_ID only.
+    t_Handle                h_App;                  /**< Relevant when guestId = NCSW_MASTER_ID only;
                                                          A handle to an application layer object; This handle will
                                                          be passed by the driver upon calling the above callbacks */
-    int                     irq;                    /**< Relevant when guestId = NCSW_MASSTER_ID only.
+    int                     irq;                    /**< Relevant when guestId = NCSW_MASTER_ID only;
                                                          FM interrupt source for normal events */
-    int                     errIrq;                 /**< Relevant when guestId = NCSW_MASSTER_ID only.
+    int                     errIrq;                 /**< Relevant when guestId = NCSW_MASTER_ID only;
                                                          FM interrupt source for errors */
-    t_FmPcdFirmwareParams   firmware;               /**< Relevant when guestId = NCSW_MASSTER_ID only.
-                                                         Ucode */
+    t_FmFirmwareParams      firmware;               /**< The firmware parameters structure;
+                                                         Relevant when guestId = NCSW_MASTER_ID only. */
+
+#if DPAA_VERSION >= 3
+    uintptr_t               vspBaseAddr;            /**< A pointer to base of memory mapped FM VSP registers (virtual);
+                                                         i.e. up to 24KB, depending on the specific chip. */
+    uint8_t                 partVSPBase;            /**< The first Virtual-Storage-Profile-id dedicated to this partition.
+                                                         NOTE: this parameter relevant only when working with multiple partitions. */
+    uint8_t                 partNumOfVSPs;          /**< Number of VSPs dedicated to this partition.
+                                                         NOTE: this parameter relevant only when working with multiple partitions. */
+#endif /* DPAA_VERSION >= 3 */
 } t_FmParams;
 
 
 /**************************************************************************//**
  @Function      FM_Config
 
- @Description   Creates descriptor for the FM module.
-
-                The routine returns a handle (descriptor) to the FM object.
+ @Description   Creates the FM module and returns its handle (descriptor).
                 This descriptor must be passed as first parameter to all other
                 FM function calls.
 
                 No actual initialization or configuration of FM hardware is
-                done by this routine.
+                done by this routine. All FM parameters get default values that
+                may be changed by calling one or more of the advance config routines.
 
- @Param[in]     p_FmParams  - A pointer to data structure of parameters
+ @Param[in]     p_FmParams  - A pointer to a data structure of mandatory FM parameters
 
- @Return        Handle to FM object, or NULL for Failure.
+ @Return        A handle to the FM object, or NULL for Failure.
 *//***************************************************************************/
 t_Handle FM_Config(t_FmParams *p_FmParams);
 
 /**************************************************************************//**
  @Function      FM_Init
 
- @Description   Initializes the FM module
+ @Description   Initializes the FM module by defining the software structure
+                and configuring the hardware registers.
 
  @Param[in]     h_Fm - FM module descriptor
 
@@ -382,13 +496,15 @@ t_Error FM_Free(t_Handle h_Fm);
 /**************************************************************************//**
  @Group         FM_advanced_init_grp    FM Advanced Configuration Unit
 
- @Description   Configuration functions used to change default values;
-                Note: Advanced init routines are not available for guest partition.
+ @Description   Advanced configuration routines are optional routines that may
+                be called in order to change the default driver settings.
+
+                Note: Advanced configuration routines are not available for guest partition.
  @{
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Description   DMA debug mode
+ @Description   Enum for selecting DMA debug mode
 *//***************************************************************************/
 typedef enum e_FmDmaDbgCntMode {
     e_FM_DMA_DBG_NO_CNT             = 0,    /**< No counting */
@@ -402,7 +518,7 @@ typedef enum e_FmDmaDbgCntMode {
 } e_FmDmaDbgCntMode;
 
 /**************************************************************************//**
- @Description   DMA Cache Override
+ @Description   Enum for selecting DMA Cache Override
 *//***************************************************************************/
 typedef enum e_FmDmaCacheOverride {
     e_FM_DMA_NO_CACHE_OR = 0,               /**< No override of the Cache field */
@@ -412,7 +528,7 @@ typedef enum e_FmDmaCacheOverride {
 } e_FmDmaCacheOverride;
 
 /**************************************************************************//**
- @Description   DMA External Bus Priority
+ @Description   Enum for selecting DMA External Bus Priority
 *//***************************************************************************/
 typedef enum e_FmDmaExtBusPri {
     e_FM_DMA_EXT_BUS_NORMAL = 0,            /**< Normal priority */
@@ -422,7 +538,7 @@ typedef enum e_FmDmaExtBusPri {
 } e_FmDmaExtBusPri;
 
 /**************************************************************************//**
- @Description   enum for choosing the field that will be output on AID
+ @Description   Enum for choosing the field that will be output on AID
 *//***************************************************************************/
 typedef enum e_FmDmaAidMode {
     e_FM_DMA_AID_OUT_PORT_ID = 0,           /**< 4 LSB of PORT_ID */
@@ -430,23 +546,24 @@ typedef enum e_FmDmaAidMode {
 } e_FmDmaAidMode;
 
 /**************************************************************************//**
- @Description   FPM Catasrophic error behaviour
+ @Description   Enum for selecting FPM Catastrophic error behavior
 *//***************************************************************************/
 typedef enum e_FmCatastrophicErr {
     e_FM_CATASTROPHIC_ERR_STALL_PORT = 0,   /**< Port_ID is stalled (only reset can release it) */
-    e_FM_CATASTROPHIC_ERR_STALL_TASK        /**< Only errornous task is stalled */
+    e_FM_CATASTROPHIC_ERR_STALL_TASK        /**< Only erroneous task is stalled */
 } e_FmCatastrophicErr;
 
 /**************************************************************************//**
- @Description   FPM DMA error behaviour
+ @Description   Enum for selecting FPM DMA Error behavior
 *//***************************************************************************/
 typedef enum e_FmDmaErr {
-    e_FM_DMA_ERR_CATASTROPHIC = 0,          /**< Dma error is treated as a catastrophic error */
+    e_FM_DMA_ERR_CATASTROPHIC = 0,          /**< Dma error is treated as a catastrophic
+                                                 error (e_FmCatastrophicErr)*/
     e_FM_DMA_ERR_REPORT                     /**< Dma error is just reported */
 } e_FmDmaErr;
 
 /**************************************************************************//**
- @Description   DMA Emergency level by BMI emergency signal
+ @Description   Enum for selecting DMA Emergency level by BMI emergency signal
 *//***************************************************************************/
 typedef enum e_FmDmaEmergencyLevel {
     e_FM_DMA_EM_EBS = 0,                    /**< EBS emergency */
@@ -454,7 +571,7 @@ typedef enum e_FmDmaEmergencyLevel {
 } e_FmDmaEmergencyLevel;
 
 /**************************************************************************//**
- @Collection   DMA emergency options
+ @Collection   Enum for selecting DMA Emergency options
 *//***************************************************************************/
 typedef uint32_t fmEmergencyBus_t;          /**< DMA emergency options */
 
@@ -473,46 +590,10 @@ typedef struct t_FmDmaEmergency {
 } t_FmDmaEmergency;
 
 /**************************************************************************//**
- @Description   structure for defining FM threshold
-*//***************************************************************************/
-typedef struct t_FmThresholds {
-    uint8_t                 dispLimit;                      /**< The number of times a frames may
-                                                                 be passed in the FM before assumed to
-                                                                 be looping. */
-    uint8_t                 prsDispTh;                      /**< This is the number pf packets that may be
-                                                                 queued in the parser dispatch queue*/
-    uint8_t                 plcrDispTh;                     /**< This is the number pf packets that may be
-                                                                 queued in the policer dispatch queue*/
-    uint8_t                 kgDispTh;                       /**< This is the number pf packets that may be
-                                                                 queued in the keygen dispatch queue*/
-    uint8_t                 bmiDispTh;                      /**< This is the number pf packets that may be
-                                                                 queued in the BMI dispatch queue*/
-    uint8_t                 qmiEnqDispTh;                   /**< This is the number pf packets that may be
-                                                                 queued in the QMI enqueue dispatch queue*/
-    uint8_t                 qmiDeqDispTh;                   /**< This is the number pf packets that may be
-                                                                 queued in the QMI dequeue dispatch queue*/
-    uint8_t                 fmCtl1DispTh;                   /**< This is the number pf packets that may be
-                                                                 queued in fmCtl1 dispatch queue*/
-    uint8_t                 fmCtl2DispTh;                   /**< This is the number pf packets that may be
-                                                                 queued in fmCtl2 dispatch queue*/
-} t_FmThresholds;
-
-/**************************************************************************//**
- @Description   structure for defining DMA thresholds
-*//***************************************************************************/
-typedef struct t_FmDmaThresholds {
-    uint8_t                     assertEmergency;            /**< When this value is reached,
-                                                                 assert emergency (Threshold)*/
-    uint8_t                     clearEmergency;             /**< After emergency is asserted, it is held
-                                                                 until this value is reached (Hystheresis) */
-} t_FmDmaThresholds;
-
-
-/**************************************************************************//**
  @Function      FM_ConfigResetOnInit
 
- @Description   Tell the driver whether to reset the FM before initialization or
-                not. It changes the default configuration [FALSE].
+ @Description   Define whether to reset the FM before initialization.
+                Change the default configuration [FALSE].
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     enable              When TRUE, FM will be reset before any initialization.
@@ -520,14 +601,17 @@ typedef struct t_FmDmaThresholds {
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
 
 /**************************************************************************//**
  @Function      FM_ConfigTotalFifoSize
 
- @Description   Change the total Fifo size from its default
-                configuration [BMI_MAX_FIFO_SIZE]
+ @Description   Define Total FIFO size for the whole FM.
+                Calling this routine changes the total Fifo size in the internal driver
+                data base from its default configuration [major]
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     totalFifoSize       The selected new value.
@@ -535,38 +619,17 @@ t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
 
-/**************************************************************************//**
- @Function      FM_ConfigThresholds
-
- @Description   Calling this routine changes the internal driver data base
-                from its default FM threshold configuration:
-                    dispLimit:    [0]
-                    prsDispTh:    [16]
-                    plcrDispTh:   [16]
-                    kgDispTh:     [16]
-                    bmiDispTh:    [16]
-                    qmiEnqDispTh: [16]
-                    qmiDeqDispTh: [16]
-                    fmCtl1DispTh: [16]
-                    fmCtl2DispTh: [16]
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     p_FmThresholds  A structure of threshold parameters.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
-
  /**************************************************************************//**
  @Function      FM_ConfigDmaCacheOverride
 
- @Description   Calling this routine changes the internal driver data base
-                from its default configuration of cache override mode [e_FM_DMA_NO_CACHE_OR]
+ @Description   Define cache override mode.
+                Calling this routine changes the cache override mode
+                in the internal driver data base from its default configuration [e_FM_DMA_NO_CACHE_OR]
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     cacheOverride   The selected new value.
@@ -574,14 +637,17 @@ t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverride);
 
 /**************************************************************************//**
  @Function      FM_ConfigDmaAidOverride
 
- @Description   Calling this routine changes the internal driver data base
-                from its default configuration of aid override mode [TRUE]
+ @Description   Define DMA AID override mode.
+                Calling this routine changes the AID override mode
+                in the internal driver data base from its default configuration  [TRUE]
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     aidOverride     The selected new value.
@@ -589,14 +655,17 @@ t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverr
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
 
 /**************************************************************************//**
  @Function      FM_ConfigDmaAidMode
 
- @Description   Calling this routine changes the internal driver data base
-                from its default configuration of aid mode [e_FM_DMA_AID_OUT_TNUM]
+ @Description   Define DMA AID  mode.
+                Calling this routine changes the AID  mode in the internal
+                driver data base from its default configuration [e_FM_DMA_AID_OUT_TNUM]
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     aidMode         The selected new value.
@@ -604,14 +673,17 @@ t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
 
 /**************************************************************************//**
  @Function      FM_ConfigDmaAxiDbgNumOfBeats
 
- @Description   Calling this routine changes the internal driver data base
-                from its default configuration of axi debug [1]
+ @Description   Define DMA AXI number of beats.
+                Calling this routine changes the AXI number of beats in the internal
+                driver data base from its default configuration [1]
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     axiDbgNumOfBeats    The selected new value.
@@ -619,14 +691,17 @@ t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
 
 /**************************************************************************//**
  @Function      FM_ConfigDmaCamNumOfEntries
 
- @Description   Calling this routine changes the internal driver data base
-                from its default configuration of number of CAM entries [32]
+ @Description   Define number of CAM entries.
+                Calling this routine changes the number of CAM entries in the internal
+                driver data base from its default configuration [32].
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     numOfEntries    The selected new value.
@@ -634,116 +709,34 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries);
 
 /**************************************************************************//**
- @Function      FM_ConfigDmaWatchdog
-
- @Description   Calling this routine changes the internal driver data base
-                from its default watchdog configuration, which is disabled
-                [0].
-
- @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     watchDogValue   The selected new value - in microseconds.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
-
-/**************************************************************************//**
- @Function      FM_ConfigDmaWriteBufThresholds
-
- @Description   Calling this routine changes the internal driver data base
-                from its default configuration of DMA write buffer threshold
-                assertEmergency: [DMA_THRESH_MAX_BUF]
-                clearEmergency:  [DMA_THRESH_MAX_BUF]
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emergency behavior -
-                                    When 'assertEmergency' value is reached, emergency is asserted,
-                                    then it is held until 'clearEmergency' value is reached.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
-
- /**************************************************************************//**
- @Function      FM_ConfigDmaCommQThresholds
-
- @Description   Calling this routine changes the internal driver data base
-                from its default configuration of DMA command queue threshold
-                assertEmergency: [DMA_THRESH_MAX_COMMQ]
-                clearEmergency:  [DMA_THRESH_MAX_COMMQ]
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emergency behavior -
-                                    When 'assertEmergency' value is reached, emergency is asserted,
-                                    then it is held until 'clearEmergency' value is reached..
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
-
-/**************************************************************************//**
- @Function      FM_ConfigDmaReadBufThresholds
-
- @Description   Calling this routine changes the internal driver data base
-                from its default configuration of DMA read buffer threshold
-                assertEmergency: [DMA_THRESH_MAX_BUF]
-                clearEmergency:  [DMA_THRESH_MAX_BUF]
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emergency behavior -
-                                    When 'assertEmergency' value is reached, emergency is asserted,
-                                    then it is held until 'clearEmergency' value is reached..
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
-
-/**************************************************************************//**
- @Function      FM_ConfigDmaSosEmergencyThreshold
-
- @Description   Calling this routine changes the internal driver data base
-                from its default dma SOS emergency configuration [0]
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     dmaSosEmergency     The selected new value.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency);
-
-/**************************************************************************//**
  @Function      FM_ConfigEnableCounters
 
- @Description   Calling this routine changes the internal driver data base
-                from its default counters configuration where counters are disabled.
+ @Description   Enable counters.
+                Calling this routine changes the internal driver data
+                base from its default configuration where counters are disabled.
 
  @Param[in]     h_Fm    A handle to an FM Module.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
 
 /**************************************************************************//**
  @Function      FM_ConfigDmaDbgCounter
 
- @Description   Calling this routine changes the internal driver data base
-                from its default DMA debug counters configuration [e_FM_DMA_DBG_NO_CNT]
+ @Description   Define DMA debug counter.
+                Calling this routine changes the number of the DMA debug counter in the internal
+                driver data base from its default configuration [e_FM_DMA_DBG_NO_CNT].
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     fmDmaDbgCntMode     An enum selecting the debug counter mode.
@@ -751,15 +744,18 @@ t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode);
 
 /**************************************************************************//**
  @Function      FM_ConfigDmaStopOnBusErr
 
- @Description   Calling this routine changes the internal driver data base
-                from its default selection of bus error behavior [FALSE]
-
+ @Description   Define bus error behavior.
+                Calling this routine changes the bus error behavior definition
+                in the internal driver data base from its default
+                configuration [FALSE].
 
  @Param[in]     h_Fm    A handle to an FM Module.
  @Param[in]     stop    TRUE to stop on bus error, FALSE to continue.
@@ -768,14 +764,18 @@ t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
                 Only if bus error is enabled.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
 
 /**************************************************************************//**
  @Function      FM_ConfigDmaEmergency
 
- @Description   Calling this routine changes the internal driver data base
-                from its default selection of DMA emergency where's it's disabled.
+ @Description   Define DMA emergency.
+                Calling this routine changes the DMA emergency definition
+                in the internal driver data base from its default
+                configuration where's it's disabled.
 
  @Param[in]     h_Fm        A handle to an FM Module.
  @Param[in]     p_Emergency An OR mask of all required options.
@@ -783,15 +783,19 @@ t_Error FM_ConfigDmaStopOnBusErr(t_Handle h_Fm, bool stop);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
 
 /**************************************************************************//**
  @Function      FM_ConfigDmaEmergencySmoother
 
- @Description   sets the minimum amount of DATA beats transferred on the AXI
-                READ and WRITE ports before lowering the emergency level.
-                By default smother is disabled.
+ @Description   Define DMA emergency smoother.
+                Calling this routine changes the definition of the minimum
+                amount of DATA beats transferred on the AXI READ and WRITE
+                ports before lowering the emergency level.
+                By default smoother is disabled.
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     emergencyCnt    emergency switching counter.
@@ -799,14 +803,18 @@ t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
 
 /**************************************************************************//**
  @Function      FM_ConfigDmaErr
 
- @Description   Calling this routine changes the internal driver data base
-                from its default DMA error treatment [e_FM_DMA_ERR_CATASTROPHIC]
+ @Description   DMA error treatment.
+                Calling this routine changes the DMA error treatment
+                in the internal driver data base from its default
+                configuration [e_FM_DMA_ERR_CATASTROPHIC].
 
  @Param[in]     h_Fm    A handle to an FM Module.
  @Param[in]     dmaErr  The selected new choice.
@@ -814,14 +822,18 @@ t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
 
 /**************************************************************************//**
  @Function      FM_ConfigCatastrophicErr
 
- @Description   Calling this routine changes the internal driver data base
-                from its default behavior on catastrophic error [e_FM_CATASTROPHIC_ERR_STALL_PORT]
+ @Description   Define FM behavior on catastrophic error.
+                Calling this routine changes the FM behavior on catastrophic
+                error in the internal driver data base from its default
+                [e_FM_CATASTROPHIC_ERR_STALL_PORT].
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     catastrophicErr     The selected new choice.
@@ -829,13 +841,16 @@ t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophicErr);
 
 /**************************************************************************//**
  @Function      FM_ConfigEnableMuramTestMode
 
- @Description   Calling this routine changes the internal driver data base
+ @Description   Enable MURAM test mode.
+                Calling this routine changes the internal driver data base
                 from its default selection of test mode where it's disabled.
 
  @Param[in]     h_Fm    A handle to an FM Module.
@@ -843,13 +858,16 @@ t_Error FM_ConfigCatastrophicErr(t_Handle h_Fm, e_FmCatastrophicErr catastrophic
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm);
 
 /**************************************************************************//**
  @Function      FM_ConfigEnableIramTestMode
 
- @Description   Calling this routine changes the internal driver data base
+ @Description   Enable IRAM test mode.
+                Calling this routine changes the internal driver data base
                 from its default selection of test mode where it's disabled.
 
  @Param[in]     h_Fm    A handle to an FM Module.
@@ -857,15 +875,18 @@ t_Error FM_ConfigEnableMuramTestMode(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
 
 /**************************************************************************//**
  @Function      FM_ConfigHaltOnExternalActivation
 
- @Description   Calling this routine changes the internal driver data base
-                from its default selection of FM behaviour on external halt
-                activation [FALSE].
+ @Description   Define FM behavior on external halt activation.
+                Calling this routine changes the FM behavior on external halt
+                activation in the internal driver data base from its default
+                [FALSE].
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     enable          TRUE to enable halt on external halt
@@ -874,15 +895,18 @@ t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
 
 /**************************************************************************//**
  @Function      FM_ConfigHaltOnUnrecoverableEccError
 
- @Description   Calling this routine changes the internal driver data base
-                from its default selection of FM behaviour on unrecoverable
-                Ecc error [FALSE].
+ @Description   Define FM behavior on external halt activation.
+                Calling this routine changes the FM behavior on unrecoverable
+                ECC error in the internal driver data base from its default
+                [FALSE].
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     enable          TRUE to enable halt on unrecoverable Ecc error
@@ -890,15 +914,17 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable);
 
 /**************************************************************************//**
  @Function      FM_ConfigException
 
- @Description   Calling this routine changes the internal driver data base
-                from its default selection of exceptions enablement.
-                By default all exceptions are enabled.
+ @Description   Define FM exceptions.
+                Calling this routine changes the exceptions defaults in the
+                internal driver data base where all exceptions are enabled.
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     exception       The exception to be selected.
@@ -907,16 +933,19 @@ t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
 
 /**************************************************************************//**
  @Function      FM_ConfigExternalEccRamsEnable
 
- @Description   Calling this routine changes the internal driver data base
-                from its default [FALSE].
-                When this option is enabled Rams ECC enable is not effected
-                by the FPM RCR bit, but by a JTAG.
+ @Description   Select external ECC enabling.
+                Calling this routine changes the ECC enabling control in the internal
+                driver data base from its default [FALSE].
+                When this option is enabled Rams ECC enabling is not effected
+                by FM_EnableRamsEcc/FM_DisableRamsEcc, but by a JTAG.
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     enable          TRUE to enable this option.
@@ -924,16 +953,18 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
 
 /**************************************************************************//**
  @Function      FM_ConfigTnumAgingPeriod
 
- @Description   Calling this routine changes the internal driver data base
-                from its default configuration for aging of dequeue TNUM's
-                in the QMI.[0]
-                Note that this functionality is not available in all chips.
+ @Description   Define Tnum aging period.
+                Calling this routine changes the Tnum aging of dequeue TNUM's
+                in the QMI in the internal driver data base from its default
+                [0].
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     tnumAgingPeriod     Tnum Aging Period in microseconds.
@@ -944,9 +975,172 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
 
+
+/**************************************************************************//*
+ @Description   structure for defining FM threshold
+*//***************************************************************************/
+typedef struct t_FmThresholds {
+    uint8_t                 dispLimit;                      /**< The number of times a frames may
+                                                                 be passed in the FM before assumed to
+                                                                 be looping. */
+    uint8_t                 prsDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the parser dispatch queue*/
+    uint8_t                 plcrDispTh;                     /**< This is the number pf packets that may be
+                                                                 queued in the policer dispatch queue*/
+    uint8_t                 kgDispTh;                       /**< This is the number pf packets that may be
+                                                                 queued in the keygen dispatch queue*/
+    uint8_t                 bmiDispTh;                      /**< This is the number pf packets that may be
+                                                                 queued in the BMI dispatch queue*/
+    uint8_t                 qmiEnqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI enqueue dispatch queue*/
+    uint8_t                 qmiDeqDispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in the QMI dequeue dispatch queue*/
+    uint8_t                 fmCtl1DispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in fmCtl1 dispatch queue*/
+    uint8_t                 fmCtl2DispTh;                   /**< This is the number pf packets that may be
+                                                                 queued in fmCtl2 dispatch queue*/
+} t_FmThresholds;
+
+/**************************************************************************//*
+ @Description   structure for defining DMA thresholds
+*//***************************************************************************/
+typedef struct t_FmDmaThresholds {
+    uint8_t                     assertEmergency;            /**< When this value is reached,
+                                                                 assert emergency (Threshold)*/
+    uint8_t                     clearEmergency;             /**< After emergency is asserted, it is held
+                                                                 until this value is reached (Hystheresis) */
+} t_FmDmaThresholds;
+
+/**************************************************************************//*
+ @Function      FM_ConfigThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default FM threshold configuration:
+                    dispLimit:    [0]
+                    prsDispTh:    [16]
+                    plcrDispTh:   [16]
+                    kgDispTh:     [16]
+                    bmiDispTh:    [16]
+                    qmiEnqDispTh: [16]
+                    qmiDeqDispTh: [16]
+                    fmCtl1DispTh: [16]
+                    fmCtl2DispTh: [16]
+
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     p_FmThresholds  A structure of threshold parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
+
+/**************************************************************************//*
+ @Function      FM_ConfigDmaSosEmergencyThreshold
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default dma SOS emergency configuration [0]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     dmaSosEmergency     The selected new value.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency);
+
+/**************************************************************************//*
+ @Function      FM_ConfigDmaWriteBufThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA write buffer threshold
+                assertEmergency: [DMA_THRESH_MAX_BUF]
+                clearEmergency:  [DMA_THRESH_MAX_BUF]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emergency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+ /**************************************************************************//*
+ @Function      FM_ConfigDmaCommQThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA command queue threshold
+                assertEmergency: [DMA_THRESH_MAX_COMMQ]
+                clearEmergency:  [DMA_THRESH_MAX_COMMQ]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emergency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached..
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+/**************************************************************************//*
+ @Function      FM_ConfigDmaReadBufThresholds
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default configuration of DMA read buffer threshold
+                assertEmergency: [DMA_THRESH_MAX_BUF]
+                clearEmergency:  [DMA_THRESH_MAX_BUF]
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emergency behavior -
+                                    When 'assertEmergency' value is reached, emergency is asserted,
+                                    then it is held until 'clearEmergency' value is reached..
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
+
+/**************************************************************************//*
+ @Function      FM_ConfigDmaWatchdog
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default watchdog configuration, which is disabled
+                [0].
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     watchDogValue   The selected new value - in microseconds.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
+
 /** @} */ /* end of FM_advanced_init_grp group */
 /** @} */ /* end of FM_init_grp group */
 
@@ -954,8 +1148,8 @@ t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
 /**************************************************************************//**
  @Group         FM_runtime_control_grp FM Runtime Control Unit
 
- @Description   FM Runtime control unit API functions, definitions and enums.
-                The FM driver provides a set of control routines for each module.
+ @Description   FM Runtime control unit API functions, definitions and enum's.
+                The FM driver provides a set of control routines.
                 These routines may only be called after the module was fully
                 initialized (both configuration and initialization routines were
                 called). They are typically used to get information from hardware
@@ -972,11 +1166,11 @@ t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
                                      FM_MAX_NUM_OF_1G_RX_PORTS +    \
                                      FM_MAX_NUM_OF_10G_RX_PORTS +   \
                                      FM_MAX_NUM_OF_1G_TX_PORTS +    \
-                                     FM_MAX_NUM_OF_10G_TX_PORTS)
+                                     FM_MAX_NUM_OF_10G_TX_PORTS)      /**< Number of available FM ports */
 /* @} */
 
 /**************************************************************************//**
- @Description   Structure for Port bandwidth requirement. Port is identified
+ @Description   A Structure for Port bandwidth requirement. Port is identified
                 by type and relative id.
 *//***************************************************************************/
 typedef struct t_FmPortBandwidth {
@@ -992,7 +1186,8 @@ typedef struct t_FmPortBandwidth {
                 up to 100.
 *//***************************************************************************/
 typedef struct t_FmPortsBandwidthParams {
-    uint8_t             numOfPorts;         /**< num of ports listed in the array below */
+    uint8_t             numOfPorts;         /**< The number of relevant ports, which is the
+                                                 number of valid entries in the array below */
     t_FmPortBandwidth   portsBandwidths[FM_MAX_NUM_OF_VALID_PORTS];
                                             /**< for each port, it's bandwidth (all port's
                                                  bandwidths must add up to 100.*/
@@ -1007,7 +1202,7 @@ typedef enum e_FmDmaMuramPort {
 } e_FmDmaMuramPort;
 
 /**************************************************************************//**
- @Description   enum for defining FM counters
+ @Description   Enum for defining FM counters
 *//***************************************************************************/
 typedef enum e_FmCounters {
     e_FM_COUNTERS_ENQ_TOTAL_FRAME = 0,              /**< QMI total enqueued frames counter */
@@ -1019,14 +1214,11 @@ typedef enum e_FmCounters {
     e_FM_COUNTERS_DEQ_FROM_DEFAULT,                 /**< QMI dequeue from default queue counter */
     e_FM_COUNTERS_DEQ_FROM_CONTEXT,                 /**< QMI dequeue from FQ context counter */
     e_FM_COUNTERS_DEQ_FROM_FD,                      /**< QMI dequeue from FD command field counter */
-    e_FM_COUNTERS_DEQ_CONFIRM,                      /**< QMI dequeue confirm counter */
-    e_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,       /**< DMA semaphor reject due to full entry counter */
-    e_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,       /**< DMA semaphor reject due to full CAM queue counter */
-    e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT              /**< DMA semaphor reject due to sync counter */
+    e_FM_COUNTERS_DEQ_CONFIRM                       /**< QMI dequeue confirm counter */
 } e_FmCounters;
 
 /**************************************************************************//**
- @Description   structure for returning FM revision information
+ @Description   A Structure for returning FM revision information
 *//***************************************************************************/
 typedef struct t_FmRevisionInfo {
     uint8_t         majorRev;               /**< Major revision */
@@ -1034,7 +1226,7 @@ typedef struct t_FmRevisionInfo {
 } t_FmRevisionInfo;
 
 /**************************************************************************//**
- @Description   structure for returning FM ctrl code revision information
+ @Description   A Structure for returning FM ctrl code revision information
 *//***************************************************************************/
 typedef struct t_FmCtrlCodeRevisionInfo {
     uint16_t        packageRev;             /**< Package revision */
@@ -1043,16 +1235,24 @@ typedef struct t_FmCtrlCodeRevisionInfo {
 } t_FmCtrlCodeRevisionInfo;
 
 /**************************************************************************//**
- @Description   struct for defining DMA status
+ @Description   A Structure for defining DMA status
 *//***************************************************************************/
 typedef struct t_FmDmaStatus {
     bool    cmqNotEmpty;            /**< Command queue is not empty */
     bool    busError;               /**< Bus error occurred */
-    bool    readBufEccError;        /**< Double ECC error on buffer Read */
-    bool    writeBufEccSysError;    /**< Double ECC error on buffer write from system side */
-    bool    writeBufEccFmError;     /**< Double ECC error on buffer write from FM side */
+    bool    readBufEccError;        /**< Double ECC error on buffer Read (Valid for FM rev < 6)*/
+    bool    writeBufEccSysError;    /**< Double ECC error on buffer write from system side (Valid for FM rev < 6)*/
+    bool    writeBufEccFmError;     /**< Double ECC error on buffer write from FM side (Valid for FM rev < 6) */
+    bool    singlePortEccError;     /**< Single Port ECC error from FM side (Valid for FM rev >= 6)*/
 } t_FmDmaStatus;
 
+/**************************************************************************//**
+ @Description   A Structure for obtaining FM controller monitor values
+*//***************************************************************************/
+typedef struct t_FmCtrlMon {
+    uint8_t percentCnt[1];          /**< Percentage value */
+} t_FmCtrlMon;
+
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 /**************************************************************************//**
@@ -1064,7 +1264,7 @@ typedef struct t_FmDmaStatus {
 
  @Return        E_OK on success;
 
- @Cautions      Allowed only FM_Init().
+ @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
 t_Error FM_DumpRegs(t_Handle h_Fm);
 #endif /* (defined(DEBUG_ERRORS) && ... */
@@ -1073,7 +1273,6 @@ t_Error FM_DumpRegs(t_Handle h_Fm);
  @Function      FM_SetException
 
  @Description   Calling this routine enables/disables the specified exception.
-                Note: Not available for guest partition.
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     exception       The exception to be selected.
@@ -1082,6 +1281,8 @@ t_Error FM_DumpRegs(t_Handle h_Fm);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
 
@@ -1089,7 +1290,6 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
  @Function      FM_SetPortsBandwidth
 
  @Description   Sets relative weights between ports when accessing common resources.
-                Note: Not available for guest partition.
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     p_PortsBandwidth    A structure of ports bandwidths in percentage, i.e.
@@ -1098,6 +1298,8 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
 
@@ -1111,13 +1313,14 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
                 setting of ECC, this routine effects IRAM ECC only.
                 This routine is also called by the driver if an ECC exception is
                 enabled.
-                Note: Not available for guest partition.
 
  @Param[in]     h_Fm            A handle to an FM Module.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_EnableRamsEcc(t_Handle h_Fm);
 
@@ -1131,14 +1334,14 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm);
                 setting of ECC, this routine effects IRAM ECC only.
                 In opposed to FM_EnableRamsEcc, this routine must be called
                 explicitly to disable all Rams ECC.
-                Note: Not available for guest partition.
-
 
  @Param[in]     h_Fm            A handle to an FM Module.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_DisableRamsEcc(t_Handle h_Fm);
 
@@ -1191,7 +1394,6 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
  @Function      FM_ModifyCounter
 
  @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
-                Note: Not available for guest partition.
 
  @Param[in]     h_Fm        A handle to an FM Module.
  @Param[in]     counter     The requested counter.
@@ -1200,6 +1402,8 @@ uint32_t  FM_GetCounter(t_Handle h_Fm, e_FmCounters counter);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
 
@@ -1207,11 +1411,14 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val);
  @Function      FM_Resume
 
  @Description   Release FM after halt FM command or after unrecoverable ECC error.
-                Note: Not available for guest partition.
 
  @Param[in]     h_Fm        A handle to an FM Module.
 
  @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_Resume(t_Handle h_Fm);
 
@@ -1219,7 +1426,6 @@ void FM_Resume(t_Handle h_Fm);
  @Function      FM_SetDmaEmergency
 
  @Description   Manual emergency set
-                Note: Not available for guest partition.
 
  @Param[in]     h_Fm        A handle to an FM Module.
  @Param[in]     muramPort   MURAM direction select.
@@ -1228,14 +1434,15 @@ void FM_Resume(t_Handle h_Fm);
  @Return        None.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
 
 /**************************************************************************//**
  @Function      FM_SetDmaExtBusPri
 
- @Description   Manual emergency set
-                Note: Not available for guest partition.
+ @Description   Set the DMA external bus priority
 
  @Param[in]     h_Fm    A handle to an FM Module.
  @Param[in]     pri     External bus priority select
@@ -1243,103 +1450,175 @@ void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable);
  @Return        None.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_SetDmaExtBusPri(t_Handle h_Fm, e_FmDmaExtBusPri pri);
 
 /**************************************************************************//**
- @Function      FM_ForceIntr
+ @Function      FM_GetDmaStatus
 
- @Description   Causes an interrupt event on the requested source.
-                Note: Not available for guest partition.
+ @Description   Reads the DMA current status
 
  @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     exception       An exception to be forced.
-
- @Return        E_OK on success; Error code if the exception is not enabled,
-                or is not able to create interrupt.
+ @Param[out]    p_FmDmaStatus   A structure of DMA status parameters.
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
-t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
+void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus);
 
 /**************************************************************************//**
- @Function      FM_GetDmaStatus
+ @Function      FM_ErrorIsr
 
- @Description   Reads the DMA current status
+ @Description   FM interrupt-service-routine for errors.
 
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[out]    p_FmDmaStatus      A structure of DMA status parameters.
+ @Param[in]     h_Fm            A handle to an FM Module.
 
- @Return        None
+ @Return        E_OK on success; E_EMPTY if no errors found in register, other
+                error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
-void FM_GetDmaStatus(t_Handle h_Fm, t_FmDmaStatus *p_FmDmaStatus);
+t_Error FM_ErrorIsr(t_Handle h_Fm);
+
+/**************************************************************************//**
+ @Function      FM_EventIsr
+
+ @Description   FM interrupt-service-routine for normal events.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+void FM_EventIsr(t_Handle h_Fm);
 
 /**************************************************************************//**
- @Function      FM_GetPcdHandle
+ @Function      FM_GetSpecialOperationCoding
 
- @Description   Used by FMC in order to get PCD handle
+ @Description   Return a specific coding according to the input mask.
 
- @Param[in]     h_Fm     A handle to an FM Module.
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     spOper          special operation mask.
+ @Param[out]    p_SpOperCoding  special operation code.
 
- @Return        A handle to the PCD module, NULL if uninitialized.
+ @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
-t_Handle FM_GetPcdHandle(t_Handle h_Fm);
+t_Error FM_GetSpecialOperationCoding(t_Handle               h_Fm,
+                                     fmSpecialOperations_t  spOper,
+                                     uint8_t                *p_SpOperCoding);
 
 /**************************************************************************//**
- @Function      FM_ErrorIsr
-                Note: Not available for guest partition.
+ @Function      FM_CtrlMonStart
 
- @Description   FM interrupt-service-routine for errors.
+ @Description   Start monitoring utilization of all available FM controllers.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
 
  @Param[in]     h_Fm            A handle to an FM Module.
 
- @Return        E_OK on success; E_EMPTY if no errors found in register, other
-                error code otherwise.
+ @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
                 This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
+                (i.e. guestId != NCSW_MASTER_ID).
 *//***************************************************************************/
-t_Error FM_ErrorIsr(t_Handle h_Fm);
+t_Error FM_CtrlMonStart(t_Handle h_Fm);
 
 /**************************************************************************//**
- @Function      FM_EventIsr
-                Note: Not available for guest partition.
+ @Function      FM_CtrlMonStop
 
- @Description   FM interrupt-service-routine for normal events.
+ @Description   Stop monitoring utilization of all available FM controllers.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
 
  @Param[in]     h_Fm            A handle to an FM Module.
 
+ @Return        E_OK on success; Error code otherwise.
+
  @Cautions      Allowed only following FM_Init().
                 This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
+                (i.e. guestId != NCSW_MASTER_ID).
 *//***************************************************************************/
-void FM_EventIsr(t_Handle h_Fm);
+t_Error FM_CtrlMonStop(t_Handle h_Fm);
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 /**************************************************************************//**
- @Function      FmDumpPortRegs
+ @Function      FM_CtrlMonGetCounters
 
- @Description   Dumps FM port registers which are part of FM common registers
+ @Description   Obtain FM controller utilization parameters.
+
+                In order to obtain FM controllers utilization the following sequence
+                should be used:
+                -# FM_CtrlMonStart()
+                -# FM_CtrlMonStop()
+                -# FM_CtrlMonGetCounters() - issued for each FM controller
 
  @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in]     hardwarePortId    HW port id.
+ @Param[in]     fmCtrlIndex     FM Controller index for that utilization results
+                                are requested.
+ @Param[in]     p_Mon           Pointer to utilization results structure.
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only FM_Init().
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID).
 *//***************************************************************************/
-t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
-#endif /* (defined(DEBUG_ERRORS) && ... */
+t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p_Mon);
 
 
+/**************************************************************************//*
+ @Function      FM_ForceIntr
+
+ @Description   Causes an interrupt event on the requested source.
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+ @Param[in]     exception       An exception to be forced.
+
+ @Return        E_OK on success; Error code if the exception is not enabled,
+                or is not able to create interrupt.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
+
 /** @} */ /* end of FM_runtime_control_grp group */
 /** @} */ /* end of FM_lib_grp group */
 /** @} */ /* end of FM_grp group */
 
+#ifdef NCSW_BACKWARD_COMPATIBLE_API
+typedef t_FmBufferPrefixContent     t_FmPortBufferPrefixContent;
+typedef t_FmExtPoolParams           t_FmPortExtPoolParams;
+typedef t_FmExtPools                t_FmPortExtPools;
+typedef t_FmBackupBmPools           t_FmPortBackupBmPools;
+typedef t_FmBufPoolDepletion        t_FmPortBufPoolDepletion;
+typedef e_FmDmaSwapOption           e_FmPortDmaSwapOption;
+typedef e_FmDmaCacheOption          e_FmPortDmaCacheOption;
+
+#define FM_CONTEXTA_GET_OVVERIDE    FM_CONTEXTA_GET_OVERRIDE
+
+#define e_FM_EX_BMI_PIPELINE_ECC    e_FM_EX_BMI_STORAGE_PROFILE_ECC
+#define e_FM_PORT_DMA_NO_SWP        e_FM_DMA_NO_SWP
+#define e_FM_PORT_DMA_SWP_PPC_LE    e_FM_DMA_SWP_PPC_LE
+#define e_FM_PORT_DMA_SWP_BE        e_FM_DMA_SWP_BE
+#define e_FM_PORT_DMA_NO_STASH      e_FM_DMA_NO_STASH
+#define e_FM_PORT_DMA_STASH         e_FM_DMA_STASH
+#endif /* NCSW_BACKWARD_COMPATIBLE_API */
+
 
 #endif /* __FM_EXT */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index 87057a4..6d341b1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -59,6 +59,8 @@
  @{
 *//***************************************************************************/
 
+#define FM_MAC_NO_PFC   0xffff
+
 
 /**************************************************************************//**
  @Description   FM MAC Exceptions
@@ -105,11 +107,26 @@ typedef enum e_FmMacExceptions {
 *//***************************************************************************/
 typedef enum e_FmMacStatisticsLevel {
     e_FM_MAC_NONE_STATISTICS = 0,       /**< No statistics */
-    e_FM_MAC_PARTIAL_STATISTICS,        /**< Only error counters are available. Optimized for performance */
-    e_FM_MAC_FULL_STATISTICS            /**< All counters available. Not optimized for performance */
+    e_FM_MAC_PARTIAL_STATISTICS,        /**< Only error counters are available; Optimized for performance */
+    e_FM_MAC_FULL_STATISTICS            /**< All counters available; Not optimized for performance */
 } e_FmMacStatisticsLevel;
 
 
+#if DPAA_VERSION >= 3
+/**************************************************************************//**
+ @Description   Priority Flow Control Parameters
+*//***************************************************************************/
+typedef struct t_FmMacPfcParams {
+    bool        pfcEnable;                                      /**< Enable/Disable PFC */
+
+    uint16_t    pauseQuanta[FM_MAX_NUM_OF_PFC_PRIORITIES];      /**< Pause Quanta per priority to be sent in a pause frame. Each quanta represents a 512 bit-times*/
+
+    uint16_t    pauseThresholdQuanta[FM_MAX_NUM_OF_PFC_PRIORITIES];/**< Pause threshold per priority, when timer passes this threshold time a PFC frames is sent again if the port is still congested or BM pool in depletion*/
+
+
+} t_FmMacPfcParams;
+#endif /* DPAA_VERSION >= 3 */
+
 /**************************************************************************//**
  @Function      t_FmMacExceptionCallback
 
@@ -119,7 +136,6 @@ typedef enum e_FmMacStatisticsLevel {
 
  @Param[in]     exceptions        - The exception that occurred
 
-
  @Return        void.
 *//***************************************************************************/
 typedef void (t_FmMacExceptionCallback)(t_Handle h_App, e_FmMacExceptions exceptions);
@@ -140,14 +156,15 @@ typedef struct t_FmMacStatistics {
 /* */
     uint64_t  eStatFragments;          /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
     uint64_t  eStatJabbers;            /**< Total number of packets longer than valid maximum length octets */
-    uint64_t  eStatsDropEvents;        /**< number of dropped packets due to internal errors of the MAC Client. */
+    uint64_t  eStatsDropEvents;        /**< number of dropped packets due to internal errors of the MAC Client (during recieve). */
     uint64_t  eStatCRCAlignErrors;     /**< Incremented when frames of correct length but with CRC error are received.*/
-    uint64_t  eStatUndersizePkts;      /**< Total number of packets that were less than 64 octets long with a good CRC.*/
-    uint64_t  eStatOversizePkts;       /**< T,B.D*/
+    uint64_t  eStatUndersizePkts;      /**< Incremented for frames under 64 bytes with a valid FCS and otherwise well formed;
+                                            This count does not include range length errors */
+    uint64_t  eStatOversizePkts;       /**< Incremented for frames which exceed 1518 (non VLAN) or 1522 (VLAN) and contains
+                                            a valid FCS and otherwise well formed */
 /* Pause */
     uint64_t  teStatPause;             /**< Pause MAC Control received */
     uint64_t  reStatPause;             /**< Pause MAC Control sent */
-
 /* MIB II */
     uint64_t  ifInOctets;              /**< Total number of byte received. */
     uint64_t  ifInPkts;                /**< Total number of packets received.*/
@@ -173,7 +190,7 @@ typedef struct t_FmMacStatistics {
 
 
 /**************************************************************************//**
- @Group         FM_mac_init_grp Initialization Unit
+ @Group         FM_mac_init_grp FM MAC Initialization Unit
 
  @Description   FM MAC Initialization Unit
 
@@ -215,7 +232,7 @@ typedef struct t_FmMacParams {
 
  @Retval        Handle to FM MAC object, or NULL for Failure.
 *//***************************************************************************/
-t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam);
+t_Handle FM_MAC_Config(t_FmMacParams *p_FmMacParam);
 
 /**************************************************************************//**
  @Function      FM_MAC_Init
@@ -226,7 +243,7 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam);
 
  @Return        E_OK on success; Error code otherwise.
 *//***************************************************************************/
-t_Error  FM_MAC_Init (t_Handle h_FmMac);
+t_Error  FM_MAC_Init(t_Handle h_FmMac);
 
 /**************************************************************************//**
  @Function      FM_Free
@@ -239,11 +256,11 @@ t_Error  FM_MAC_Init (t_Handle h_FmMac);
 
  @Return        E_OK on success; Error code otherwise.
 *//***************************************************************************/
-t_Error  FM_MAC_Free (t_Handle h_FmMac);
+t_Error  FM_MAC_Free(t_Handle h_FmMac);
 
 
 /**************************************************************************//**
- @Group         FM_mac_advanced_init_grp    Advanced Configuration Unit
+ @Group         FM_mac_advanced_init_grp    FM MAC Advanced Configuration Unit
 
  @Description   Configuration functions used to change default values.
 
@@ -263,7 +280,7 @@ t_Error  FM_MAC_Free (t_Handle h_FmMac);
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable);
+t_Error FM_MAC_ConfigResetOnInit(t_Handle h_FmMac, bool enable);
 
 /**************************************************************************//**
  @Function      FM_MAC_ConfigLoopback
@@ -277,7 +294,7 @@ t_Error FM_MAC_ConfigResetOnInit (t_Handle h_FmMac, bool enable);
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool enable);
+t_Error FM_MAC_ConfigLoopback(t_Handle h_FmMac, bool enable);
 
 /**************************************************************************//**
  @Function      FM_MAC_ConfigMaxFrameLength
@@ -291,7 +308,7 @@ t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool enable);
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal);
+t_Error FM_MAC_ConfigMaxFrameLength(t_Handle h_FmMac, uint16_t newVal);
 
 /**************************************************************************//**
  @Function      FM_MAC_ConfigWan
@@ -305,7 +322,7 @@ t_Error FM_MAC_ConfigMaxFrameLength (t_Handle h_FmMac, uint16_t newVal);
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool enable);
+t_Error FM_MAC_ConfigWan(t_Handle h_FmMac, bool enable);
 
 /**************************************************************************//**
  @Function      FM_MAC_ConfigPadAndCrc
@@ -319,7 +336,7 @@ t_Error FM_MAC_ConfigWan (t_Handle h_FmMac, bool enable);
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool enable);
+t_Error FM_MAC_ConfigPadAndCrc(t_Handle h_FmMac, bool enable);
 
 /**************************************************************************//**
  @Function      FM_MAC_ConfigHalfDuplex
@@ -333,7 +350,21 @@ t_Error FM_MAC_ConfigPadAndCrc (t_Handle h_FmMac, bool enable);
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool enable);
+t_Error FM_MAC_ConfigHalfDuplex(t_Handle h_FmMac, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MAC_ConfigTbiPhyAddr
+
+ @Description   Configures the address of internal TBI PHY.
+
+ @Param[in]     h_FmMac    A handle to a FM MAC Module.
+ @Param[in]     newVal     TBI PHY address (1-31).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
+*//***************************************************************************/
+t_Error FM_MAC_ConfigTbiPhyAddr(t_Handle h_FmMac, uint8_t newVal);
 
 /**************************************************************************//**
  @Function      FM_MAC_ConfigLengthCheck
@@ -347,7 +378,7 @@ t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool enable);
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ConfigLengthCheck (t_Handle h_FmMac, bool enable);
+t_Error FM_MAC_ConfigLengthCheck(t_Handle h_FmMac, bool enable);
 
 /**************************************************************************//**
  @Function      FM_MAC_ConfigException
@@ -372,7 +403,7 @@ t_Error FM_MAC_ConfigSkipFman11Workaround (t_Handle h_FmMac);
 
 
 /**************************************************************************//**
- @Group         FM_mac_runtime_control_grp Runtime Control Unit
+ @Group         FM_mac_runtime_control_grp FM MAC Runtime Control Unit
 
  @Description   FM MAC Runtime control unit API functions, definitions and enums.
 
@@ -391,7 +422,7 @@ t_Error FM_MAC_ConfigSkipFman11Workaround (t_Handle h_FmMac);
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode);
+t_Error FM_MAC_Enable(t_Handle h_FmMac,  e_CommMode mode);
 
 /**************************************************************************//**
  @Function      FM_MAC_Disable
@@ -405,7 +436,7 @@ t_Error FM_MAC_Enable  (t_Handle h_FmMac,  e_CommMode mode);
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_Disable (t_Handle h_FmMac, e_CommMode mode);
+t_Error FM_MAC_Disable(t_Handle h_FmMac, e_CommMode mode);
 
 /**************************************************************************//**
  @Function      FM_MAC_Enable1588TimeStamp
@@ -436,56 +467,66 @@ t_Error FM_MAC_Disable1588TimeStamp(t_Handle h_Fm);
 /**************************************************************************//**
  @Function      FM_MAC_SetTxAutoPauseFrames
 
- @Description   Enable/Disable transmition of Pause-Frames.
-
- @Param[in]     h_FmMac     A handle to a FM MAC Module.
- @Param[in]     pauseTime   Pause quanta value used with transmitted pause frames.
-                            Each quanta represents a 512 bit-times; Note that '0'
-                            as an input here will be used as disabling the
-                            transmission of the pause-frames.
+ @Description   Enable/Disable transmission of Pause-Frames.
+                The routine will ct changes the default configuration [0xf000].
+
+ @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
+ @Param[in]     priority      -  the PFC class of service; use 'FM_MAC_NO_PFC'
+                                 to indicate legacy pause support (i.e. no PFC).
+ @Param[in]     pauseTime     -  Pause quanta value used with transmitted pause frames.
+                                 Each quanta represents a 512 bit-times;
+                                 Note that '0' as an input here will be used as disabling the
+                                 transmission of the pause-frames.
+ @Param[in]     threshTime    -  Pause Threshold equanta value used by the MAC to retransmit pause frame.
+                                 if the situation causing a pause frame to be sent didn't finish when the timer
+                                 reached the threshold quanta, the MAC will retransmit the pause frame.
+                                 Each quanta represents a 512 bit-times.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_SetTxAutoPauseFrames (t_Handle h_FmMac, uint16_t pauseTime);
+t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
+                                    uint8_t  priority,
+                                    uint16_t pauseTime,
+                                    uint16_t threshTime);
 
 /**************************************************************************//**
  @Function      FM_MAC_SetRxIgnorePauseFrames
 
  @Description   Enable/Disable ignoring of Pause-Frames.
 
- @Param[in]     h_FmMac     A handle to a FM MAC Module.
- @Param[in]     en          boolean indicates whether to ignore the incoming pause
-                            frames or not.
+ @Param[in]     h_FmMac    - A handle to a FM MAC Module.
+ @Param[in]     en         - boolean indicates whether to ignore the incoming pause
+                             frames or not.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_SetRxIgnorePauseFrames (t_Handle h_FmMac, bool en);
+t_Error FM_MAC_SetRxIgnorePauseFrames(t_Handle h_FmMac, bool en);
 
 /**************************************************************************//**
  @Function      FM_MAC_ResetCounters
 
  @Description   reset all statistics counters
 
- @Param[in]     h_FmMac     A handle to a FM MAC Module.
+ @Param[in]     h_FmMac    - A handle to a FM MAC Module.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ResetCounters (t_Handle h_FmMac);
+t_Error FM_MAC_ResetCounters(t_Handle h_FmMac);
 
 /**************************************************************************//**
  @Function      FM_MAC_SetException
 
  @Description   Enable/Disable a specific Exception
 
- @Param[in]     h_FmMac         A handle to a FM MAC Module.
- @Param[in]     ex              Type of the desired exceptions
- @Param[in]     enable          TRUE to enable the specified exception, FALSE to disable it.
+ @Param[in]     h_FmMac        - A handle to a FM MAC Module.
+ @Param[in]     ex             - Type of the desired exceptions
+ @Param[in]     enable         - TRUE to enable the specified exception, FALSE to disable it.
 
 
  @Return        E_OK on success; Error code otherwise.
@@ -502,31 +543,31 @@ t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
                 overflow interrupt in order to keep counters accurate
                 and account for overflows.
 
- @Param[in]     h_FmMac         A handle to a FM MAC Module.
- @Param[in]     statisticsLevel Full statistics level provides all standard counters but may
-                                reduce performance. Partial statistics provides only special
-                                event counters (errors etc.). If selected, regular counters (such as
-                                byte/packet) will be invalid and will return -1.
+ @Param[in]     h_FmMac         - A handle to a FM MAC Module.
+ @Param[in]     statisticsLevel - Full statistics level provides all standard counters but may
+                                  reduce performance. Partial statistics provides only special
+                                  event counters (errors etc.). If selected, regular counters (such as
+                                  byte/packet) will be invalid and will return -1.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_SetStatistics (t_Handle h_FmMac, e_FmMacStatisticsLevel statisticsLevel);
+t_Error FM_MAC_SetStatistics(t_Handle h_FmMac, e_FmMacStatisticsLevel statisticsLevel);
 
 /**************************************************************************//**
  @Function      FM_MAC_GetStatistics
 
  @Description   get all statistics counters
 
- @Param[in]     h_FmMac         A handle to a FM MAC Module.
- @Param[in]     p_Statistics    Staructure with statistics
+ @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
+ @Param[in]     p_Statistics  -  Staructure with statistics
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
-t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
+t_Error FM_MAC_GetStatistics(t_Handle h_FmMac, t_FmMacStatistics *p_Statistics);
 
 /**************************************************************************//**
  @Function      FM_MAC_ModifyMacAddr
@@ -540,7 +581,7 @@ t_Error FM_MAC_GetStatistics (t_Handle h_FmMac, t_FmMacStatistics *p_Statistics)
 
  @Cautions      Allowed only after FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+t_Error FM_MAC_ModifyMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
 
 /**************************************************************************//**
  @Function      FM_MAC_AddHashMacAddr
@@ -555,7 +596,7 @@ t_Error FM_MAC_ModifyMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
  @Cautions      Allowed only following FM_MAC_Init(). It is a filter only address.
  @Cautions      Some address need to be filterd out in upper FM blocks.
 *//***************************************************************************/
-t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+t_Error FM_MAC_AddHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
 
 /**************************************************************************//**
  @Function      FM_MAC_RemoveHashMacAddr
@@ -569,7 +610,7 @@ t_Error FM_MAC_AddHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
 
  @Cautions      Allowed only following FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+t_Error FM_MAC_RemoveHashMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
 
 /**************************************************************************//**
  @Function      FM_MAC_AddExactMatchMacAddr
@@ -584,7 +625,7 @@ t_Error FM_MAC_RemoveHashMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
 
  @Cautions      Allowed only after FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+t_Error FM_MAC_AddExactMatchMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
 
 /**************************************************************************//**
  @Function      FM_MAC_RemovelExactMatchMacAddr
@@ -598,7 +639,7 @@ t_Error FM_MAC_AddExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
 
  @Cautions      Allowed only after FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
+t_Error FM_MAC_RemovelExactMatchMacAddr(t_Handle h_FmMac, t_EnetAddr *p_EnetAddr);
 
 /**************************************************************************//**
  @Function      FM_MAC_SetPromiscuous
@@ -612,7 +653,7 @@ t_Error FM_MAC_RemovelExactMatchMacAddr (t_Handle h_FmMac, t_EnetAddr *p_EnetAdd
 
  @Cautions      Allowed only after FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_SetPromiscuous (t_Handle h_FmMac, bool enable);
+t_Error FM_MAC_SetPromiscuous(t_Handle h_FmMac, bool enable);
 
 /**************************************************************************//**
  @Function      FM_MAC_AdjustLink
@@ -640,7 +681,7 @@ t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
 
  @Cautions      Allowed only after FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *p_MacId);
+t_Error FM_MAC_GetId(t_Handle h_FmMac, uint32_t *p_MacId);
 
 /**************************************************************************//**
  @Function      FM_MAC_GetVesrion
@@ -654,7 +695,7 @@ t_Error FM_MAC_GetId (t_Handle h_FmMac, uint32_t *p_MacId);
 
  @Cautions      Allowed only after FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *p_MacVresion);
+t_Error FM_MAC_GetVesrion(t_Handle h_FmMac, uint32_t *p_MacVresion);
 
 /**************************************************************************//**
  @Function      FM_MAC_MII_WritePhyReg
@@ -670,7 +711,7 @@ t_Error FM_MAC_GetVesrion (t_Handle h_FmMac, uint32_t *p_MacVresion);
 
  @Cautions      Allowed only after FM_MAC_Init().
 *//***************************************************************************/
-t_Error FM_MAC_MII_WritePhyReg (t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error FM_MAC_MII_WritePhyReg(t_Handle h_FmMac, uint8_t phyAddr, uint8_t reg, uint16_t data);
 
 /**************************************************************************//**
  @Function      FM_MAC_MII_ReadPhyReg
@@ -716,4 +757,5 @@ void DtsecRestartTbiAN(t_Handle h_Dtsec);
 /** @} */ /* end of FM_mac_grp group */
 /** @} */ /* end of FM_grp group */
 
+
 #endif /* __FM_MAC_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
index 0802677..e73f516 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -60,7 +60,7 @@
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Group         FM_muram_init_grp FM MURAM Initialization
+ @Group         FM_muram_init_grp FM MURAM Initialization Unit
 
  @Description   FM MURAM initialization API functions, definitions and enums
 
@@ -103,7 +103,7 @@ t_Error  FM_MURAM_Free(t_Handle h_FmMuram);
 
 
 /**************************************************************************//**
- @Group         FM_muram_ctrl_grp FM MURAM Control
+ @Group         FM_muram_ctrl_grp FM MURAM Control Unit
 
  @Description   FM MURAM control API functions, definitions and enums
 
@@ -149,6 +149,17 @@ void  * FM_MURAM_AllocMemForce(t_Handle h_FmMuram, uint64_t base, uint32_t size)
 *//***************************************************************************/
 t_Error FM_MURAM_FreeMem(t_Handle h_FmMuram, void *ptr);
 
+/**************************************************************************//**
+ @Function      FM_MURAM_GetFreeMemSize
+
+ @Description   Returns the size (in bytes) of free MURAM memory.
+
+ @Param[in]     h_FmMuram - FM-MURAM module descriptor.
+
+ @Return        Free MURAM memory size in bytes.
+*//***************************************************************************/
+uint64_t FM_MURAM_GetFreeMemSize(t_Handle h_FmMuram);
+
 /** @} */ /* end of FM_muram_ctrl_grp group */
 /** @} */ /* end of FM_muram_grp group */
 /** @} */ /* end of FM_grp group */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 1f1a6f8..0556687 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -48,7 +48,7 @@
 
  @Group         FM_grp Frame Manager API
 
- @Description   FM API functions, definitions and enums
+ @Description   Frame Manager Application Programming Interface
 
  @{
 *//***************************************************************************/
@@ -56,18 +56,18 @@
 /**************************************************************************//**
  @Group         FM_PCD_grp FM PCD
 
- @Description   FM PCD API functions, definitions and enums
+ @Description   Frame Manager PCD (Parse-Classify-Distribute) API.
 
                 The FM PCD module is responsible for the initialization of all
                 global classifying FM modules. This includes the parser general and
                 common registers, the key generator global and common registers,
-                and the Policer global and common registers.
+                and the policer global and common registers.
                 In addition, the FM PCD SW module will initialize all required
-                key generator schemes, coarse classification flows, and Policer
-                profiles. When An FM module is configured to work with one of these
+                key generator schemes, coarse classification flows, and policer
+                profiles. When FM module is configured to work with one of these
                 entities, it will register to it using the FM PORT API. The PCD
                 module will manage the PCD resources - i.e. resource management of
-                Keygen schemes, etc.
+                KeyGen schemes, etc.
 
  @{
 *//***************************************************************************/
@@ -75,52 +75,47 @@
 /**************************************************************************//**
  @Collection    General PCD defines
 *//***************************************************************************/
-typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
-
-#define FM_PCD_NONE                                 0                   /**< No PCD Engine indicated */
-#define FM_PCD_PRS                                  0x80000000          /**< Parser indicated */
-#define FM_PCD_KG                                   0x40000000          /**< Keygen indicated */
-#define FM_PCD_CC                                   0x20000000          /**< Coarse classification indicated */
-#define FM_PCD_PLCR                                 0x10000000          /**< Policer indicated */
-#define FM_PCD_MANIP                                0x08000000          /**< Manipulation indicated */
-
 #define FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
 
 #define FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
 #define FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
-                                                                        /**< number of distinction units is limited by
-                                                                             register size (32), - reserved bits for
-                                                                             private headers. */
-
-#define FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers in a distinction unit */
-#define FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
-#define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
-                                                                             For reason of HW implementation, in most
-                                                                             cases less than this will be allowed. The
-                                                                             driver will return error in initialization
-                                                                             time if resource is overused. */
-#define FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
+                                                                        /**< Number of distinction units is limited by
+                                                                             register size (32 bits) minus reserved bits
+                                                                             for private headers. */
+#define FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers
+                                                                             in a distinction unit */
+#define FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KeyGen registers */
+#define FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration;
+                                                                             For HW implementation reasons, in most
+                                                                             cases less than this will be allowed; The
+                                                                             driver will return an initialization error
+                                                                             if resource is unavailable. */
+#define FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KeyGen extractions. */
 #define FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
 
-#define FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
-#define FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of sw parser area */
+#define FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Maximum number of SW parser labels */
+#define FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of SW parser area */
 #define FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
                                                                              of the SW parser area */
 #define FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000200          /**< Number of bytes saved for patches */
 #define FM_PCD_PRS_SW_TAIL_SIZE                     4                   /**< Number of bytes that must be cleared at
                                                                              the end of the SW parser area */
 #define FM_SW_PRS_MAX_IMAGE_SIZE                    (FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_OFFSET-FM_PCD_PRS_SW_TAIL_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE)
-                                                                        /**< Max possible size of SW parser code */
+                                                                        /**< Maximum size of SW parser code */
 
-#define FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Max possible size of insertion template for
-                                                                             insert manipulation*/
+#define FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
+                                                                             insert manipulation */
+
+#if DPAA_VERSION >= 3
+#define FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
+#endif /* DPAA_VERSION >= 3 */
 /* @} */
 
 
 /**************************************************************************//**
  @Group         FM_PCD_init_grp FM PCD Initialization Unit
 
- @Description   FM PCD Initialization Unit
+ @Description   Frame Manager PCD Initialization Unit API
 
  @{
 *//***************************************************************************/
@@ -129,44 +124,46 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
  @Description   PCD counters
 *//***************************************************************************/
 typedef enum e_FmPcdCounters {
-    e_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< Policer counter */
-    e_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter */
-    e_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter */
-    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter */
-    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter */
-    e_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter */
-    e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter */
-    e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter */
-    e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter */
-    e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter */
-    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter */
-    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter */
-    e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter */
+    e_FM_PCD_KG_COUNTERS_TOTAL,                                 /**< KeyGen counter */
+    e_FM_PCD_PLCR_COUNTERS_RED,                                 /**< Policer counter - counts the total number of RED packets that exit the Policer. */
+    e_FM_PCD_PLCR_COUNTERS_YELLOW,                              /**< Policer counter - counts the total number of YELLOW packets that exit the Policer. */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED,                    /**< Policer counter - counts the number of packets that changed color to RED by the Policer;
+                                                                     This is a subset of e_FM_PCD_PLCR_COUNTERS_RED packet count, indicating active color changes. */
+    e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW,                 /**< Policer counter - counts the number of packets that changed color to YELLOW by the Policer;
+                                                                     This is a subset of e_FM_PCD_PLCR_COUNTERS_YELLOW packet count, indicating active color changes. */
+    e_FM_PCD_PLCR_COUNTERS_TOTAL,                               /**< Policer counter - counts the total number of packets passed in the Policer. */
+    e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH,                     /**< Policer counter - counts the number of packets with length mismatch. */
+    e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH,                       /**< Parser counter - counts the number of times the parser block is dispatched. */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L2 parse result is returned (including errors). */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L3 parse result is returned (including errors). */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED,             /**< Parser counter - counts the number of times L4 parse result is returned (including errors). */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED,           /**< Parser counter - counts the number of times SHIM parse result is returned (including errors). */
+    e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L2 parse result is returned with errors. */
+    e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L3 parse result is returned with errors. */
+    e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR,    /**< Parser counter - counts the number of times L4 parse result is returned with errors. */
+    e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR,  /**< Parser counter - counts the number of times SHIM parse result is returned with errors. */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES,                      /**< Parser counter - counts the number of cycles spent executing soft parser instruction (including stall cycles). */
+    e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES,                /**< Parser counter - counts the number of cycles stalled waiting for parser internal memory reads while executing soft parser instruction. */
+    e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES,     /**< Parser counter - counts the number of cycles spent executing hard parser (including stall cycles). */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES,                    /**< MURAM counter - counts the number of cycles while performing FMan Memory read. */
+    e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES,              /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory read. */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES,                   /**< MURAM counter - counts the number of cycles while performing FMan Memory write. */
+    e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES,             /**< MURAM counter - counts the number of cycles stalled while performing FMan Memory write. */
+    e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES              /**< FPM counter - counts the number of cycles stalled while performing a FPM Command. */
 } e_FmPcdCounters;
 
 /**************************************************************************//**
  @Description   PCD interrupts
 *//***************************************************************************/
 typedef enum e_FmPcdExceptions {
-    e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< Keygen ECC error */
-    e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Read Buffer ECC error */
-    e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< Write Buffer ECC error on system side */
-    e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Write Buffer ECC error on FM side */
-    e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,    /**< Self init complete */
-    e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,     /**< Atomic action complete */
-    e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                  /**< Parser ECC error */
-    e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                   /**< Parser single ECC */
+    e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC,                   /**< KeyGen double-bit ECC error is detected on internal memory read access. */
+    e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW,             /**< KeyGen scheme configuration error indicating a key size larger than 56 bytes. */
+    e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC,                 /**< Policer double-bit ECC error has been detected on PRAM read access. */
+    e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR,           /**< Policer access to a non-initialized profile has been detected. */
+    e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE,    /**< Policer RAM self-initialization complete */
+    e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE,     /**< Policer atomic action complete */
+    e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC,                  /**< Parser double-bit ECC error */
+    e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC                   /**< Parser single-bit ECC error */
 } e_FmPcdExceptions;
 
 
@@ -194,7 +191,7 @@ typedef void (t_FmPcdIdExceptionCallback) ( t_Handle           h_App,
 /**************************************************************************//**
  @Description   A callback for enqueuing frame onto a QM queue.
 
- @Param[in]     h_App           - User's application descriptor.
+ @Param[in]     h_QmArg         - Application's handle passed to QM module on enqueue.
  @Param[in]     p_Fd            - Frame descriptor for the frame.
 
  @Return        E_OK on success; Error code otherwise.
@@ -202,54 +199,48 @@ typedef void (t_FmPcdIdExceptionCallback) ( t_Handle           h_App,
 typedef t_Error (t_FmPcdQmEnqueueCallback) (t_Handle h_QmArg, void *p_Fd);
 
 /**************************************************************************//**
- @Description   A structure for Host-Command
+ @Description   Host-Command parameters structure.
+
                 When using Host command for PCD functionalities, a dedicated port
                 must be used. If this routine is called for a PCD in a single partition
-                environment, or it is the Master partition in a Multi partition
+                environment, or it is the Master partition in a Multi-partition
                 environment, The port will be initialized by the PCD driver
                 initialization routine.
  *//***************************************************************************/
 typedef struct t_FmPcdHcParams {
-    uintptr_t                   portBaseAddr;       /**< Host-Command Port Virtual Address of
-                                                         memory mapped registers.*/
-    uint8_t                     portId;             /**< Host-Command Port Id (0-6 relative
-                                                         to Host-Command/Offline parsing ports) */
-    uint16_t                    liodnBase;          /**< Irrelevant for P4080 rev 1. LIODN base for this port, to be
-                                                         used together with LIODN offset. */
-    uint32_t                    errFqid;            /**< Host-Command Port Error Queue Id. */
-    uint32_t                    confFqid;           /**< Host-Command Port Confirmation queue Id. */
-    uint32_t                    qmChannel;          /**< Host-Command port - QM-channel dedicated to
-                                                         this port will be used by the FM for dequeue. */
-    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;       /**< Call back routine for enqueuing a frame to the QM */
-    t_Handle                    h_QmArg;            /**< A handle of the QM module */
+    uintptr_t                   portBaseAddr;       /**< Virtual Address of Host-Command Port memory mapped registers.*/
+    uint8_t                     portId;             /**< Port Id (0-6 relative to Host-Command/Offline-Parsing ports) */
+    uint16_t                    liodnBase;          /**< LIODN base for this port, to be used together with LIODN offset
+                                                         (irrelevant for P4080 revision 1.0) */
+    uint32_t                    errFqid;            /**< Host-Command Port error queue Id. */
+    uint32_t                    confFqid;           /**< Host-Command Port confirmation queue Id. */
+    uint32_t                    qmChannel;          /**< QM channel dedicated to this Host-Command port;
+                                                         will be used by the FM for dequeue. */
+    t_FmPcdQmEnqueueCallback    *f_QmEnqueue;       /**< Callback routine for enqueuing a frame to the QM */
+    t_Handle                    h_QmArg;            /**< Application's handle passed to QM module on enqueue */
 } t_FmPcdHcParams;
 
 /**************************************************************************//**
  @Description   The main structure for PCD initialization
  *//***************************************************************************/
 typedef struct t_FmPcdParams {
-    bool                        prsSupport;             /**< TRUE if Parser will be used for any
-                                                             of the FM ports */
+    bool                        prsSupport;             /**< TRUE if Parser will be used for any of the FM ports. */
     bool                        ccSupport;              /**< TRUE if Coarse Classification will be used for any
-                                                             of the FM ports */
-    bool                        kgSupport;              /**< TRUE if Keygen will be used for any
-                                                             of the FM ports */
-    bool                        plcrSupport;            /**< TRUE if Policer will be used for any
-                                                             of the FM ports */
-    t_Handle                    h_Fm;                   /**< A handle to the FM module */
+                                                             of the FM ports. */
+    bool                        kgSupport;              /**< TRUE if KeyGen will be used for any of the FM ports. */
+    bool                        plcrSupport;            /**< TRUE if Policer will be used for any of the FM ports. */
+    t_Handle                    h_Fm;                   /**< A handle to the FM module. */
     uint8_t                     numOfSchemes;           /**< Number of schemes dedicated to this partition. */
     bool                        useHostCommand;         /**< Optional for single partition, Mandatory for Multi partition */
-    t_FmPcdHcParams             hc;                     /**< Relevant only if useHostCommand=TRUE.
-                                                             Host Command parameters. */
-
-    t_FmPcdExceptionCallback    *f_Exception;           /**< Relevant for master (or single) partition only: Callback routine
-                                                             to be called of PCD exception */
-    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Relevant for master (or single) partition only: Callback routine
-                                                             to be used for a single scheme and
-                                                             profile exceptions */
-    t_Handle                    h_App;                  /**< Relevant for master (or single) partition only: A handle to an
-                                                             application layer object; This handle will
-                                                             be passed by the driver upon calling the above callbacks */
+    t_FmPcdHcParams             hc;                     /**< Host Command parameters, relevant only if useHostCommand = TRUE. */
+
+    t_FmPcdExceptionCallback    *f_Exception;           /**< Callback routine for general PCD exceptions;
+                                                             Relevant for master (or single) partition only. */
+    t_FmPcdIdExceptionCallback  *f_ExceptionId;         /**< Callback routine for specific KeyGen scheme or Policer profile
+                                                             exceptions; Relevant for master (or single) partition only. */
+    t_Handle                    h_App;                  /**< A handle to an application layer object; This handle will
+                                                             be passed by the driver upon calling the above callbacks;
+                                                             Relevant for master (or single) partition only. */
 } t_FmPcdParams;
 
 
@@ -290,58 +281,79 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd);
 t_Error FM_PCD_Free(t_Handle h_FmPcd);
 
 /**************************************************************************//**
- @Group         FM_PCD_advanced_init_grp    FM PCD Advanced Configuration Unit
+ @Group         FM_PCD_advanced_cfg_grp    FM PCD Advanced Configuration Unit
 
- @Description   Configuration functions used to change default values.
+ @Description   Frame Manager PCD Advanced Configuration API.
 
  @{
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Function      FM_PCD_ConfigPlcrNumOfSharedProfiles
+ @Function      FM_PCD_ConfigException
 
  @Description   Calling this routine changes the internal driver data base
                 from its default selection of exceptions enablement.
-                [4].
+                By default all exceptions are enabled.
 
- @Param[in]     h_FmPcd                     FM PCD module descriptor.
- @Param[in]     numOfSharedPlcrProfiles     Number of profiles to
-                                            be shared between ports on this partition
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
 
  @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
-t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles);
+t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
 
 /**************************************************************************//**
- @Function      FM_PCD_ConfigException
+ @Function      FM_PCD_ConfigHcFramesDataMemory
 
- @Description   Calling this routine changes the internal driver data base
-                from its default selection of exceptions enablement.
-                By default all exceptions are enabled.
+ @Description   Configures memory partition for FMan-Controller Host-Command
+                frames. Calling this routine changes the internal driver data
+                base from its default configuration [0].
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     exception       The exception to be selected.
- @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+ @Param[in]     memId           Memory partition ID.
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Not available for guest partition.
+ @Cautions      This routine may be called only if 'useHostCommand' was TRUE
+                when FM_PCD_Config() routine was called.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
-t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
+t_Error FM_PCD_ConfigHcFramesDataMemory(t_Handle h_FmPcd, uint8_t memId);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ConfigPlcrNumOfSharedProfiles
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement.
+                [4].
+
+ @Param[in]     h_FmPcd                     FM PCD module descriptor.
+ @Param[in]     numOfSharedPlcrProfiles     Number of profiles to
+                                            be shared between ports on this partition
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSharedPlcrProfiles);
 
 /**************************************************************************//**
  @Function      FM_PCD_ConfigPlcrAutoRefreshMode
 
  @Description   Calling this routine changes the internal driver data base
                 from its default selection of exceptions enablement.
-                By default autorefresh is enabled.
+                By default auto-refresh is enabled.
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     enable          TRUE to enable, FALSE to disable
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Not available for guest partition.
+ @Cautions      This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
 
@@ -358,46 +370,47 @@ t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Not available for guest partition.
+ @Cautions      This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
 
-/** @} */ /* end of FM_PCD_advanced_init_grp group */
+/** @} */ /* end of FM_PCD_advanced_cfg_grp group */
 /** @} */ /* end of FM_PCD_init_grp group */
 
 
 /**************************************************************************//**
  @Group         FM_PCD_Runtime_grp FM PCD Runtime Unit
 
- @Description   FM PCD Runtime Unit
+ @Description   Frame Manager PCD Runtime Unit API
 
                 The runtime control allows creation of PCD infrastructure modules
                 such as Network Environment Characteristics, Classification Plan
                 Groups and Coarse Classification Trees.
                 It also allows on-the-fly initialization, modification and removal
-                of PCD modules such as Keygen schemes, coarse classification nodes
+                of PCD modules such as KeyGen schemes, coarse classification nodes
                 and Policer profiles.
 
 
                 In order to explain the programming model of the PCD driver interface
                 a few terms should be explained, and will be used below.
-                  * Distinction Header - One of the 16 protocols supported by the FM parser,
-                    or one of the shim headers (1 or 2). May be a header with a special
+                  - Distinction Header - One of the 16 protocols supported by the FM parser,
+                    or one of the SHIM headers (1 or 2). May be a header with a special
                     option (see below).
-                  * Interchangeable Headers Group- This is a group of Headers recognized
+                  - Interchangeable Headers Group - This is a group of Headers recognized
                     by either one of them. For example, if in a specific context the user
                     chooses to treat IPv4 and IPV6 in the same way, they may create an
                     interchangeable Headers Unit consisting of these 2 headers.
-                  * A Distinction Unit - a Distinction Header or an Interchangeable Headers
+                  - A Distinction Unit - a Distinction Header or an Interchangeable Headers
                     Group.
-                  * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
-                    ipv6, includes multicast, broadcast and other protocol specific options.
+                  - Header with special option - applies to Ethernet, MPLS, VLAN, IPv4 and
+                    IPv6, includes multicast, broadcast and other protocol specific options.
                     In terms of hardware it relates to the options available in the classification
                     plan.
-                  * Network Environment Characteristics - a set of Distinction Units that define
+                  - Network Environment Characteristics - a set of Distinction Units that define
                     the total recognizable header selection for a certain environment. This is
                     NOT the list of all headers that will ever appear in a flow, but rather
-                    everything that needs distinction in a flow, where distinction is made by keygen
+                    everything that needs distinction in a flow, where distinction is made by KeyGen
                     schemes and coarse classification action descriptors.
 
                 The PCD runtime modules initialization is done in stages. The first stage after
@@ -410,20 +423,20 @@ t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value);
 *//***************************************************************************/
 
 /**************************************************************************//**
- @Description   A structure for sw parser labels
+ @Description   A structure for SW parser labels
  *//***************************************************************************/
 typedef struct t_FmPcdPrsLabelParams {
     uint32_t                instructionOffset;              /**< SW parser label instruction offset (2 bytes
                                                                  resolution), relative to Parser RAM. */
-    e_NetHeaderType         hdr;                            /**< The existance of this header will envoke
-                                                                 the sw parser code. */
-    uint8_t                 indexPerHdr;                    /**< Normally 0, if more than one sw parser
+    e_NetHeaderType         hdr;                            /**< The existence of this header will invoke
+                                                                 the SW parser code. */
+    uint8_t                 indexPerHdr;                    /**< Normally 0, if more than one SW parser
                                                                  attachments for the same header, use this
                                                                  index to distinguish between them. */
 } t_FmPcdPrsLabelParams;
 
 /**************************************************************************//**
- @Description   A structure for sw parser
+ @Description   A structure for SW parser
  *//***************************************************************************/
 typedef struct t_FmPcdPrsSwParams {
     bool                    override;                   /**< FALSE to invoke a check that nothing else
@@ -490,28 +503,45 @@ t_Error FM_PCD_Disable(t_Handle h_FmPcd);
 uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter);
 
 /**************************************************************************//**
-@Function      FM_PCD_PrsLoadSw
+@Function       FM_PCD_PrsLoadSw
 
-@Description   This routine may be called in order to load software parsing code.
+@Description    This routine may be called in order to load software parsing code.
 
 
-@Param[in]     h_FmPcd         FM PCD module descriptor.
-@Param[in]     p_SwPrs         A pointer to a structure of software
+@Param[in]      h_FmPcd        FM PCD module descriptor.
+@Param[in]      p_SwPrs        A pointer to a structure of software
                                parser parameters, including the software
                                parser image.
 
+@Return         E_OK on success; Error code otherwise.
+
+@Cautions       Allowed only following FM_PCD_Init() and when PCD is disabled.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
+
+/**************************************************************************//**
+@Function      FM_PCD_SetAdvancedOffloadSupport
+
+@Description   This routine must be called in order to support the following features:
+               IP-fragmentation, IP-reassembly, IPsec, Header-manipulation, frame-replicator.
+
+@Param[in]     h_FmPcd         FM PCD module descriptor.
+
 @Return        E_OK on success; Error code otherwise.
 
 @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-               Not available for guest partition.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
-t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
+t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd);
 
 /**************************************************************************//**
  @Function      FM_PCD_KgSetDfltValue
 
  @Description   Calling this routine sets a global default value to be used
-                by the keygen when parser does not recognize a required
+                by the KeyGen when parser does not recognize a required
                 field/header.
                 By default default values are 0.
 
@@ -522,14 +552,15 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-                Not available for guest partition.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value);
 
 /**************************************************************************//**
  @Function      FM_PCD_KgSetAdditionalDataAfterParsing
 
- @Description   Calling this routine allows the keygen to access data past
+ @Description   Calling this routine allows the KeyGen to access data past
                 the parser finishing point.
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
@@ -538,7 +569,8 @@ t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init() and when PCD is disabled.
-                Not available for guest partition.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payloadOffset);
 
@@ -554,7 +586,8 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
-                Not available for guest partition.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool enable);
 
@@ -570,7 +603,8 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
-                Not available for guest partition.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t value);
 
@@ -586,7 +620,8 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
-                Not available for guest partition.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
 
@@ -601,7 +636,8 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable);
  @Return        None
 
  @Cautions      Allowed only following FM_PCD_Init().
-                Not available for guest partition.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
 
@@ -617,7 +653,8 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
                 or is not able to create interrupt.
 
  @Cautions      Allowed only following FM_PCD_Init().
-                Not available for guest partition.
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception);
 
@@ -665,7 +702,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd);
 /**************************************************************************//**
  @Function      FM_PCD_PlcrDumpRegs
 
- @Description   Dumps all PCD Plcr registers
+ @Description   Dumps all PCD Policer registers
 
  @Param[in]     h_FmPcd         A handle to an FM PCD Module.
 
@@ -678,21 +715,20 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd);
 /**************************************************************************//**
  @Function      FM_PCD_PlcrProfileDumpRegs
 
- @Description   Dumps all PCD Plcr registers
+ @Description   Dumps all PCD Policer profile registers
 
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     h_Profile       A handle to a profile.
+ @Param[in]     h_Profile       A handle to a Policer profile.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_FmPcd, t_Handle h_Profile);
+t_Error FM_PCD_PlcrProfileDumpRegs(t_Handle h_Profile);
 
 /**************************************************************************//**
  @Function      FM_PCD_PrsDumpRegs
 
- @Description   Dumps all PCD Prs registers
+ @Description   Dumps all PCD Parser registers
 
  @Param[in]     h_FmPcd         A handle to an FM PCD Module.
 
@@ -719,9 +755,9 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
 
 
 /**************************************************************************//**
- @Group         FM_PCD_Runtime_tree_buildgrp FM PCD Tree building Unit
+ KeyGen         FM_PCD_Runtime_build_grp FM PCD Runtime Building Unit
 
- @Description   FM PCD Runtime Unit
+ @Description   Frame Manager PCD Runtime Building API
 
                 This group contains routines for setting, deleting and modifying
                 PCD resources, for defining the total PCD tree.
@@ -730,17 +766,18 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
 
 /**************************************************************************//**
  @Collection    Definitions of coarse classification
-                parameters as required by keygen (when coarse classification
+                parameters as required by KeyGen (when coarse classification
                 is the next engine after this scheme).
 *//***************************************************************************/
-#define FM_PCD_MAX_NUM_OF_CC_NODES          255
-#define FM_PCD_MAX_NUM_OF_CC_TREES          8
-#define FM_PCD_MAX_NUM_OF_CC_GROUPS         16
-#define FM_PCD_MAX_NUM_OF_CC_UNITS          4
-#define FM_PCD_MAX_NUM_OF_KEYS              256
-#define FM_PCD_MAX_SIZE_OF_KEY              56
-#define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP 16
-#define FM_PCD_LAST_KEY_INDEX               0xffff
+#define FM_PCD_MAX_NUM_OF_CC_NODES              255
+#define FM_PCD_MAX_NUM_OF_CC_TREES              8
+#define FM_PCD_MAX_NUM_OF_CC_GROUPS             16
+#define FM_PCD_MAX_NUM_OF_CC_UNITS              4
+#define FM_PCD_MAX_NUM_OF_KEYS                  256
+#define FM_PCD_MAX_SIZE_OF_KEY                  56
+#define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
+#define FM_PCD_LAST_KEY_INDEX                   0xffff
+
 /* @} */
 
 /**************************************************************************//**
@@ -753,33 +790,30 @@ typedef protocolOpt_t   ethProtocolOpt_t;       /**< Ethernet protocol options.
 #define ETH_BROADCAST               0x80000000  /**< Ethernet Broadcast. */
 #define ETH_MULTICAST               0x40000000  /**< Ethernet Multicast. */
 
-typedef protocolOpt_t   vlanProtocolOpt_t;      /**< Vlan protocol options. */
-#define VLAN_STACKED                0x20000000  /**< Vlan Stacked. */
+typedef protocolOpt_t   vlanProtocolOpt_t;      /**< VLAN protocol options. */
+#define VLAN_STACKED                0x20000000  /**< Stacked VLAN. */
 
 typedef protocolOpt_t   mplsProtocolOpt_t;      /**< MPLS protocol options. */
-#define MPLS_STACKED                0x10000000  /**< MPLS Stacked. */
+#define MPLS_STACKED                0x10000000  /**< Stacked MPLS. */
 
 typedef protocolOpt_t   ipv4ProtocolOpt_t;      /**< IPv4 protocol options. */
 #define IPV4_BROADCAST_1            0x08000000  /**< IPv4 Broadcast. */
 #define IPV4_MULTICAST_1            0x04000000  /**< IPv4 Multicast. */
 #define IPV4_UNICAST_2              0x02000000  /**< Tunneled IPv4 - Unicast. */
 #define IPV4_MULTICAST_BROADCAST_2  0x01000000  /**< Tunneled IPv4 - Broadcast/Multicast. */
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+
 #define IPV4_FRAG_1                 0x00000008  /**< IPV4 reassembly option.
                                                      IPV4 Reassembly manipulation requires network
                                                      environment with IPV4 header and IPV4_FRAG_1 option  */
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
 typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
 #define IPV6_MULTICAST_1            0x00800000  /**< IPv6 Multicast. */
 #define IPV6_UNICAST_2              0x00400000  /**< Tunneled IPv6 - Unicast. */
 #define IPV6_MULTICAST_2            0x00200000  /**< Tunneled IPv6 - Multicast. */
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+
 #define IPV6_FRAG_1                 0x00000004  /**< IPV6 reassembly option.
                                                      IPV6 Reassembly manipulation requires an IPV4 network
                                                      environment unit with IPV4_FRAG_1 option  */
-
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 /* @} */
 
 /**************************************************************************//**
@@ -795,16 +829,18 @@ typedef    uint8_t    t_FmPcdKgKeyOrder [FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
  @Description   All PCD engines
 *//***************************************************************************/
 typedef enum e_FmPcdEngine {
-    e_FM_PCD_INVALID = 0,   /**< Invalid PCD engine indicated*/
+    e_FM_PCD_INVALID = 0,   /**< Invalid PCD engine */
     e_FM_PCD_DONE,          /**< No PCD Engine indicated */
-    e_FM_PCD_KG,            /**< Keygen indicated */
-    e_FM_PCD_CC,            /**< Coarse classification indicated */
-    e_FM_PCD_PLCR,          /**< Policer indicated */
-    e_FM_PCD_PRS            /**< Parser indicated */
+    e_FM_PCD_KG,            /**< KeyGen */
+    e_FM_PCD_CC,            /**< Coarse classifier */
+    e_FM_PCD_PLCR,          /**< Policer */
+    e_FM_PCD_PRS,           /**< Parser */
+    e_FM_PCD_FR,            /**< Frame-Replicator */
+    e_FM_PCD_HASH           /**< Hash table */
 } e_FmPcdEngine;
 
 /**************************************************************************//**
- @Description   An enum for selecting extraction by header types
+ @Description   Enumeration type for selecting extraction by header types
 *//***************************************************************************/
 typedef enum e_FmPcdExtractByHdrType {
     e_FM_PCD_EXTRACT_FROM_HDR,      /**< Extract bytes from header */
@@ -813,7 +849,7 @@ typedef enum e_FmPcdExtractByHdrType {
 } e_FmPcdExtractByHdrType;
 
 /**************************************************************************//**
- @Description   An enum for selecting extraction source
+ @Description   Enumeration type for selecting extraction source
                 (when it is not the header)
 *//***************************************************************************/
 typedef enum e_FmPcdExtractFrom {
@@ -828,7 +864,7 @@ typedef enum e_FmPcdExtractFrom {
 } e_FmPcdExtractFrom;
 
 /**************************************************************************//**
- @Description   An enum for selecting extraction type
+ @Description   Enumeration type for selecting extraction type
 *//***************************************************************************/
 typedef enum e_FmPcdExtractType {
     e_FM_PCD_EXTRACT_BY_HDR,                /**< Extract according to header */
@@ -837,7 +873,7 @@ typedef enum e_FmPcdExtractType {
 } e_FmPcdExtractType;
 
 /**************************************************************************//**
- @Description   An enum for selecting a default
+ @Description   Enumeration type for selecting default extraction value
 *//***************************************************************************/
 typedef enum e_FmPcdKgExtractDfltSelect {
     e_FM_PCD_KG_DFLT_GBL_0,          /**< Default selection is KG register 0 */
@@ -848,9 +884,8 @@ typedef enum e_FmPcdKgExtractDfltSelect {
 } e_FmPcdKgExtractDfltSelect;
 
 /**************************************************************************//**
- @Description   An enum defining all default groups -
-                each group shares a default value, one of 4 user
-                initialized values.
+ @Description   Enumeration type defining all default groups - each group shares
+                a default value, one of four user-initialized values.
 *//***************************************************************************/
 typedef enum e_FmPcdKgKnownFieldsDfltTypes {
     e_FM_PCD_KG_MAC_ADDR,               /**< MAC Address */
@@ -859,25 +894,26 @@ typedef enum e_FmPcdKgKnownFieldsDfltTypes {
     e_FM_PCD_KG_PPP_SESSION_ID,         /**< PPP Session id */
     e_FM_PCD_KG_PPP_PROTOCOL_ID,        /**< PPP Protocol id */
     e_FM_PCD_KG_MPLS_LABEL,             /**< MPLS label */
-    e_FM_PCD_KG_IP_ADDR,                /**< IP addr */
+    e_FM_PCD_KG_IP_ADDR,                /**< IP address */
     e_FM_PCD_KG_PROTOCOL_TYPE,          /**< Protocol type */
     e_FM_PCD_KG_IP_TOS_TC,              /**< TOS or TC */
     e_FM_PCD_KG_IPV6_FLOW_LABEL,        /**< IPV6 flow label */
     e_FM_PCD_KG_IPSEC_SPI,              /**< IPSEC SPI */
     e_FM_PCD_KG_L4_PORT,                /**< L4 Port */
     e_FM_PCD_KG_TCP_FLAG,               /**< TCP Flag */
-    e_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by sw,
+    e_FM_PCD_KG_GENERIC_FROM_DATA,      /**< grouping implemented by SW,
                                              any data extraction that is not the full
                                              field described above  */
-    e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by sw,
+    e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V, /**< grouping implemented by SW,
                                              any data extraction without validation */
-    e_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by sw,
+    e_FM_PCD_KG_GENERIC_NOT_FROM_DATA   /**< grouping implemented by SW,
                                              extraction from parser result or
                                              direct use of default value  */
 } e_FmPcdKgKnownFieldsDfltTypes;
 
 /**************************************************************************//**
- @Description   enum for defining header index when headers may repeat
+ @Description   Enumeration type for defining header index for scenarios with
+                multiple (tunneled) headers
 *//***************************************************************************/
 typedef enum e_FmPcdHdrIndex {
     e_FM_PCD_HDR_INDEX_NONE = 0,        /**< used when multiple headers not used, also
@@ -889,7 +925,7 @@ typedef enum e_FmPcdHdrIndex {
 } e_FmPcdHdrIndex;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile functional type
+ @Description   Enumeration type for selecting the policer profile functional type
 *//***************************************************************************/
 typedef enum e_FmPcdProfileTypeSelection {
     e_FM_PCD_PLCR_PORT_PRIVATE,         /**< Port dedicated profile */
@@ -897,16 +933,16 @@ typedef enum e_FmPcdProfileTypeSelection {
 } e_FmPcdProfileTypeSelection;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile algorithem
+ @Description   Enumeration type for selecting the policer profile algorithm
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrAlgorithmSelection {
     e_FM_PCD_PLCR_PASS_THROUGH,         /**< Policer pass through */
-    e_FM_PCD_PLCR_RFC_2698,             /**< Policer algorythm RFC 2698 */
-    e_FM_PCD_PLCR_RFC_4115              /**< Policer algorythm RFC 4115 */
+    e_FM_PCD_PLCR_RFC_2698,             /**< Policer algorithm RFC 2698 */
+    e_FM_PCD_PLCR_RFC_4115              /**< Policer algorithm RFC 4115 */
 } e_FmPcdPlcrAlgorithmSelection;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile color mode
+ @Description   Enumeration type for selecting a policer profile color mode
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrColorMode {
     e_FM_PCD_PLCR_COLOR_BLIND,          /**< Color blind */
@@ -914,17 +950,17 @@ typedef enum e_FmPcdPlcrColorMode {
 } e_FmPcdPlcrColorMode;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile color functional mode
+ @Description   Enumeration type for selecting a policer profile color
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrColor {
-    e_FM_PCD_PLCR_GREEN,                /**< Green */
-    e_FM_PCD_PLCR_YELLOW,               /**< Yellow */
-    e_FM_PCD_PLCR_RED,                  /**< Red */
-    e_FM_PCD_PLCR_OVERRIDE              /**< Color override */
+    e_FM_PCD_PLCR_GREEN,                /**< Green color code */
+    e_FM_PCD_PLCR_YELLOW,               /**< Yellow color code */
+    e_FM_PCD_PLCR_RED,                  /**< Red color code */
+    e_FM_PCD_PLCR_OVERRIDE              /**< Color override code */
 } e_FmPcdPlcrColor;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile packet frame length selector
+ @Description   Enumeration type for selecting the policer profile packet frame length selector
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrFrameLengthSelect {
   e_FM_PCD_PLCR_L2_FRM_LEN,             /**< L2 frame length */
@@ -934,15 +970,15 @@ typedef enum e_FmPcdPlcrFrameLengthSelect {
 } e_FmPcdPlcrFrameLengthSelect;
 
 /**************************************************************************//**
- @Description   An enum for selecting rollback frame
+ @Description   Enumeration type for selecting roll-back frame
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrRollBackFrameSelect {
-  e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Rollback L2 frame length */
-  e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Rollback Full frame length */
+  e_FM_PCD_PLCR_ROLLBACK_L2_FRM_LEN,    /**< Roll-back L2 frame length */
+  e_FM_PCD_PLCR_ROLLBACK_FULL_FRM_LEN   /**< Roll-back Full frame length */
 } e_FmPcdPlcrRollBackFrameSelect;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile packet or byte mode
+ @Description   Enumeration type for selecting the policer profile packet or byte mode
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrRateMode {
     e_FM_PCD_PLCR_BYTE_MODE,            /**< Byte mode */
@@ -950,7 +986,7 @@ typedef enum e_FmPcdPlcrRateMode {
 } e_FmPcdPlcrRateMode;
 
 /**************************************************************************//**
- @Description   An enum for defining action of frame
+ @Description   Enumeration type for defining action of frame
 *//***************************************************************************/
 typedef enum e_FmPcdDoneAction {
     e_FM_PCD_ENQ_FRAME = 0,        /**< Enqueue frame */
@@ -958,7 +994,7 @@ typedef enum e_FmPcdDoneAction {
 } e_FmPcdDoneAction;
 
 /**************************************************************************//**
- @Description   A structure for selecting the policer counter
+ @Description   Enumeration type for selecting the policer counter
 *//***************************************************************************/
 typedef enum e_FmPcdPlcrProfileCounters {
     e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER,               /**< Green packets counter */
@@ -969,84 +1005,113 @@ typedef enum e_FmPcdPlcrProfileCounters {
 } e_FmPcdPlcrProfileCounters;
 
 /**************************************************************************//**
- @Description   A structure for selecting action
+ @Description   Enumeration type for selecting the PCD action after extraction
 *//***************************************************************************/
 typedef enum e_FmPcdAction {
     e_FM_PCD_ACTION_NONE,                           /**< NONE  */
-    e_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction*/
-    e_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
+    e_FM_PCD_ACTION_EXACT_MATCH,                    /**< Exact match on the selected extraction */
+    e_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction */
 } e_FmPcdAction;
 
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
- @Description   An enum for selecting type of insert manipulation
+ @Description   Enumeration type for selecting type of insert manipulation
 *//***************************************************************************/
-typedef enum e_FmPcdManipInsrtType {
-    e_FM_PCD_MANIP_INSRT_NONE = 0,                          /**< No insertion */
-    e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR,   /**< Insert internal frame header to start of frame */
-    e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE         /**< Insert template to start of frame*/
-} e_FmPcdManipInsrtType;
+typedef enum e_FmPcdManipHdrInsrtType {
+    e_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
+#ifdef FM_CAPWAP_SUPPORT
+    e_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
+    e_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
+#endif /* FM_CAPWAP_SUPPORT */
+} e_FmPcdManipHdrInsrtType;
 
 /**************************************************************************//**
- @Description   An enum for selecting type of remove manipulation
+ @Description   Enumeration type for selecting type of remove manipulation
 *//***************************************************************************/
-typedef enum e_FmPcdManipRmvParamsType {
-    e_FM_PCD_MANIP_RMV_NONE = 0,                                        /**< No remove */
-    e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION,      /**< Remove from start of frame till (excluding) specified indication */
-    e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,   /**< Remove from start of frame till (including) specified indication */
-    e_FM_PCD_MANIP_RMV_INT_FRAME_HDR                                    /**< Remove internal frame header to start of frame */
-} e_FmPcdManipRmvParamsType;
+typedef enum e_FmPcdManipHdrRmvType {
+    e_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
+#ifdef FM_CAPWAP_SUPPORT
+    e_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
+#endif /* FM_CAPWAP_SUPPORT */
+} e_FmPcdManipHdrRmvType;
 
+
+#ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
- @Description   An enum for selecting type of location
+ @Description   Enumeration type for selecting type of header removal
 *//***************************************************************************/
-typedef enum e_FmPcdManipLocateType {
-    e_FM_PCD_MANIP_LOC_BY_HDR = 0,            /**< Locate according to header */
-    e_FM_PCD_MANIP_LOC_NON_HDR                /**< Locate from data that is not the header */
-} e_FmPcdManipLocateType;
+typedef enum e_FmPcdManipHdrRmvByHdrType {
+#ifdef FM_CAPWAP_SUPPORT
+    e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START            /**< Locate from data that is not the header */
+#endif /* FM_CAPWAP_SUPPORT */
+} e_FmPcdManipHdrRmvByHdrType;
+#endif /* FM_CAPWAP_SUPPORT */
 
 /**************************************************************************//**
- @Description   An enum for selecting type of Timeout mode
+ @Description   Enumeration type for selecting type of timeout mode
 *//***************************************************************************/
 typedef enum e_FmPcdManipReassemTimeOutMode {
-    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES, /**< limits the time of the reassm process from the first frag to the last */
-    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG    /**< limits the time of receiving the fragment */
+    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES, /**< Limits the time of the reassembly process
+                                                 from the first fragment to the last */
+    e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG    /**< Limits the time of receiving the fragment */
 } e_FmPcdManipReassemTimeOutMode;
 
 /**************************************************************************//**
- @Description   An enum for selecting type of WaysNumber mode
+ @Description   Enumeration type for selecting type of WaysNumber mode
 *//***************************************************************************/
 typedef enum e_FmPcdManipReassemWaysNumber {
-    e_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< one way hash */
-    e_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< two ways hash*/
-    e_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< three ways hash */
-    e_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< four ways hash*/
-    e_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< five ways hash */
-    e_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< six ways hash*/
-    e_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< seven ways hash */
-    e_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< eight ways hash*/
+    e_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< One way hash    */
+    e_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< Two ways hash   */
+    e_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< Three ways hash */
+    e_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< Four ways hash  */
+    e_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< Five ways hash  */
+    e_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< Six ways hash   */
+    e_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< Seven ways hash */
+    e_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< Eight ways hash */
 } e_FmPcdManipReassemWaysNumber;
 
+#ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
- @Description   An enum for selecting type of statistics mode
+ @Description   Enumeration type for selecting type of statistics mode
 *//***************************************************************************/
 typedef enum e_FmPcdStatsType {
-    e_FM_PCD_STATS_PER_FLOWID = 0   /**< type where flowId used as index for getting statistics */
+    e_FM_PCD_STATS_PER_FLOWID = 0       /**< Flow ID is used as index for getting statistics */
 } e_FmPcdStatsType;
+#endif /* FM_CAPWAP_SUPPORT */
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting manipulation type
+*//***************************************************************************/
+typedef enum e_FmPcdManipType {
+    e_FM_PCD_MANIP_HDR = 0,             /**< Header manipulation */
+    e_FM_PCD_MANIP_REASSEM,             /**< Reassembly */
+    e_FM_PCD_MANIP_FRAG,                /**< Fragmentation */
+    e_FM_PCD_MANIP_SPECIAL_OFFLOAD      /**< Special Offloading */
+} e_FmPcdManipType;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum e_FmPcdCcStatsMode {
+    e_FM_PCD_CC_STATS_MODE_NONE = 0,    /**< No statistics support */
+    e_FM_PCD_CC_STATS_MODE_FRAME        /**< Frame count statistics */
+} e_FmPcdCcStatsMode;
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
 /**************************************************************************//**
- @Description   An enum for Don't Fragment Action. If an IP packet is larger
-                than MTU and its DF bit is set, then this enum determine
-                the action to be taken.
+ @Description   Enumeration type for determining the action in case an IP packet
+                is larger than MTU but its DF (Don't Fragment) bit is set.
 *//***************************************************************************/
 typedef enum e_FmPcdManipDontFragAction {
-    e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = 0,      /**< Discard packet */
-    e_FM_PCD_MANIP_FRAGMENT_PACKECT,        /**< Fragment packet and continue normal processing */
-    e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG    /**< Continue normal processing without fragmenting the packet */
+    e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = 0,  /**< Discard packet */
+    e_FM_PCD_MANIP_FRAGMENT_PACKECT,                    /**< Fragment packet and continue normal processing */
+    e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG                /**< Continue normal processing without fragmenting the packet */
 } e_FmPcdManipDontFragAction;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of special offload manipulation
+*//***************************************************************************/
+typedef enum e_FmPcdManipSpecialOffloadType {
+    e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC    /**< IPSec offload manipulation */
+} e_FmPcdManipSpecialOffloadType;
 
 
 /**************************************************************************//**
@@ -1054,7 +1119,7 @@ typedef enum e_FmPcdManipDontFragAction {
 *//***************************************************************************/
 typedef union u_FmPcdHdrProtocolOpt {
     ethProtocolOpt_t    ethOpt;     /**< Ethernet options */
-    vlanProtocolOpt_t   vlanOpt;    /**< Vlan options */
+    vlanProtocolOpt_t   vlanOpt;    /**< VLAN options */
     mplsProtocolOpt_t   mplsOpt;    /**< MPLS options */
     ipv4ProtocolOpt_t   ipv4Opt;    /**< IPv4 options */
     ipv6ProtocolOpt_t   ipv6Opt;    /**< IPv6 options */
@@ -1083,7 +1148,7 @@ typedef union t_FmPcdFields {
 } t_FmPcdFields;
 
 /**************************************************************************//**
- @Description   structure for defining header extraction for key generation
+ @Description   Parameters for defining header extraction for key generation
 *//***************************************************************************/
 typedef struct t_FmPcdFromHdr {
     uint8_t             size;           /**< Size in byte */
@@ -1091,7 +1156,7 @@ typedef struct t_FmPcdFromHdr {
 } t_FmPcdFromHdr;
 
 /**************************************************************************//**
- @Description   structure for defining field extraction for key generation
+ @Description   Parameters for defining field extraction for key generation
 *//***************************************************************************/
 typedef struct t_FmPcdFromField {
     t_FmPcdFields       field;          /**< Field selection */
@@ -1100,24 +1165,25 @@ typedef struct t_FmPcdFromField {
 } t_FmPcdFromField;
 
 /**************************************************************************//**
- @Description   A structure of parameters used to define a single network
-                environment unit.
-                A unit should be defined if it will later be used by one or
-                more PCD engines to distinguich between flows.
+ @Description   Parameters for defining a single network environment unit
+
+                A distinction unit should be defined if it will later be used
+                by one or more PCD engines to distinguish between flows.
 *//***************************************************************************/
 typedef struct t_FmPcdDistinctionUnit {
     struct {
         e_NetHeaderType         hdr;        /**< One of the headers supported by the FM */
-        u_FmPcdHdrProtocolOpt   opt;        /**< only one option !! */
+        u_FmPcdHdrProtocolOpt   opt;        /**< Select only one option ! */
     } hdrs[FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS];
 } t_FmPcdDistinctionUnit;
 
 /**************************************************************************//**
- @Description   A structure of parameters used to define the different
-                units supported by a specific PCD Network Environment
-                Characteristics module. Each unit represent
-                a protocol or a group of protocols that may be used later
-                by the different PCD engined to distinguich between flows.
+ @Description   Parameters for defining all different distinction units supported
+                by a specific PCD Network Environment Characteristics module.
+
+                Each unit represent a protocol or a group of protocols that may
+                be used later by the different PCD engined to distinguish
+                between flows.
 *//***************************************************************************/
 typedef struct t_FmPcdNetEnvParams {
     uint8_t                 numOfDistinctionUnits;                      /**< Number of different units to be identified */
@@ -1126,8 +1192,8 @@ typedef struct t_FmPcdNetEnvParams {
 } t_FmPcdNetEnvParams;
 
 /**************************************************************************//**
- @Description   structure for defining a single extraction action
-                when creating a key
+ @Description   Parameters for defining a single extraction action when
+                creating a key
 *//***************************************************************************/
 typedef struct t_FmPcdExtractEntry {
     e_FmPcdExtractType                  type;           /**< Extraction type select */
@@ -1137,12 +1203,12 @@ typedef struct t_FmPcdExtractEntry {
             bool                        ignoreProtocolValidation;
                                                         /**< Ignore protocol validation */
             e_FmPcdHdrIndex             hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled
-                                                             IP. Otherwise should be cleared.*/
+                                                             IP. Otherwise should be cleared. */
             e_FmPcdExtractByHdrType     type;           /**< Header extraction type select */
             union {
                 t_FmPcdFromHdr          fromHdr;        /**< Extract bytes from header parameters */
-                t_FmPcdFromField        fromField;      /**< Extract bytes from field parameters*/
-                t_FmPcdFields           fullField;      /**< Extract full filed parameters*/
+                t_FmPcdFromField        fromField;      /**< Extract bytes from field parameters */
+                t_FmPcdFields           fullField;      /**< Extract full filed parameters */
             } extractByHdrType;
         } extractByHdr;                                 /**< used when type = e_FM_PCD_KG_EXTRACT_BY_HDR */
         struct {
@@ -1150,7 +1216,7 @@ typedef struct t_FmPcdExtractEntry {
             e_FmPcdAction               action;         /**< Relevant for CC Only */
             uint16_t                    icIndxMask;     /**< Relevant only for CC when
                                                              action = e_FM_PCD_ACTION_INDEXED_LOOKUP;
-                                                             Note that the number of bits that are set whithin
+                                                             Note that the number of bits that are set within
                                                              this mask must be log2 of the CC-node 'numOfKeys'.
                                                              Note that the mask cannot be set on the lower bits. */
             uint8_t                     offset;         /**< Byte offset */
@@ -1160,8 +1226,7 @@ typedef struct t_FmPcdExtractEntry {
 } t_FmPcdExtractEntry;
 
 /**************************************************************************//**
- @Description   A structure for defining masks for each extracted
-                field in the key.
+ @Description   Parameters for defining masks for each extracted field in the key.
 *//***************************************************************************/
 typedef struct t_FmPcdKgExtractMask {
     uint8_t                             extractArrayIndex;  /**< Index in the extraction array, as initialized by user */
@@ -1170,17 +1235,15 @@ typedef struct t_FmPcdKgExtractMask {
 } t_FmPcdKgExtractMask;
 
 /**************************************************************************//**
- @Description   A structure for defining default selection per groups
-                of fields
+ @Description   Parameters for defining default selection per groups of fields
 *//***************************************************************************/
 typedef struct t_FmPcdKgExtractDflt {
-    e_FmPcdKgKnownFieldsDfltTypes       type;                /**< Default type select*/
+    e_FmPcdKgKnownFieldsDfltTypes       type;                /**< Default type select */
     e_FmPcdKgExtractDfltSelect          dfltSelect;          /**< Default register select */
 } t_FmPcdKgExtractDflt;
 
 /**************************************************************************//**
- @Description   A structure for defining all parameters needed for
-                generation a key and using a hash function
+ @Description   Parameters for defining key extraction and hashing
 *//***************************************************************************/
 typedef struct t_FmPcdKgKeyExtractAndHashParams {
     uint32_t                    privateDflt0;                /**< Scheme default register 0 */
@@ -1207,8 +1270,7 @@ typedef struct t_FmPcdKgKeyExtractAndHashParams {
 } t_FmPcdKgKeyExtractAndHashParams;
 
 /**************************************************************************//**
- @Description   A structure of parameters for defining a single
-                Fqid mask (extracted OR).
+ @Description   Parameters for defining a single FQID mask (extracted OR).
 *//***************************************************************************/
 typedef struct t_FmPcdKgExtractedOrParams {
     e_FmPcdExtractType              type;               /**< Extraction type select */
@@ -1252,7 +1314,7 @@ typedef struct t_FmPcdKgExtractedOrParams {
 } t_FmPcdKgExtractedOrParams;
 
 /**************************************************************************//**
- @Description   A structure for configuring scheme counter
+ @Description   Parameters for configuring a scheme counter
 *//***************************************************************************/
 typedef struct t_FmPcdKgSchemeCounter {
     bool        update;     /**< FALSE to keep the current counter state
@@ -1263,29 +1325,27 @@ typedef struct t_FmPcdKgSchemeCounter {
 } t_FmPcdKgSchemeCounter;
 
 /**************************************************************************//**
- @Description   A structure for defining policer profile
-                parameters as required by keygen (when policer
-                is the next engine after this scheme).
+ @Description   Parameters for configuring a policer profile for a KeyGen scheme
+                (when policer is the next engine after this scheme).
 *//***************************************************************************/
 typedef struct t_FmPcdKgPlcrProfile {
     bool                sharedProfile;              /**< TRUE if this profile is shared between ports
-                                                         (i.e. managed by master partition) May not be TRUE
+                                                         (managed by master partition); Must not be TRUE
                                                          if profile is after Coarse Classification*/
     bool                direct;                     /**< if TRUE, directRelativeProfileId only selects the profile
                                                          id, if FALSE fqidOffsetRelativeProfileIdBase is used
                                                          together with fqidOffsetShift and numOfProfiles
                                                          parameters, to define a range of profiles from
-                                                         which the keygen result will determine the
+                                                         which the KeyGen result will determine the
                                                          destination policer profile.  */
     union {
         uint16_t        directRelativeProfileId;    /**< Used if 'direct' is TRUE, to select policer profile.
-                                                         This parameter should
-                                                         indicate the policer profile offset within the port's
-                                                         policer profiles or SHARED window. */
+                                                         should indicate the policer profile offset within the
+                                                         port's policer profiles or shared window. */
         struct {
-            uint8_t     fqidOffsetShift;            /**< shift of KG results without the qid base */
+            uint8_t     fqidOffsetShift;            /**< Shift of KeyGen results without the FQID base */
             uint8_t     fqidOffsetRelativeProfileIdBase;
-                                                    /**< OR of KG results without the qid base
+                                                    /**< OR of KeyGen results without the FQID base
                                                          This parameter should indicate the policer profile
                                                          offset within the port's policer profiles window or
                                                          SHARED window depends on sharedProfile */
@@ -1294,23 +1354,50 @@ typedef struct t_FmPcdKgPlcrProfile {
     } profileSelect;                                /**< Direct/indirect profile selection and parameters */
 } t_FmPcdKgPlcrProfile;
 
+#if DPAA_VERSION >= 3
 /**************************************************************************//**
- @Description   A structure for CC parameters if CC is the next engine after KG
+ @Description   Parameters for configuring a storage profile for a KeyGen scheme.
+*//***************************************************************************/
+typedef struct t_FmPcdKgStorageProfile {
+    bool                direct;                     /**< If TRUE, directRelativeProfileId only selects the
+                                                         profile id;
+                                                         If FALSE, fqidOffsetRelativeProfileIdBase is used
+                                                         together with fqidOffsetShift and numOfProfiles
+                                                         parameters to define a range of profiles from which
+                                                         the KeyGen result will determine the destination
+                                                         storage profile. */
+    union {
+        uint16_t        directRelativeProfileId;    /**< Used when 'direct' is TRUE, to select a storage profile;
+                                                         should indicate the storage profile offset within the
+                                                         port's storage profiles window. */
+        struct {
+            uint8_t     fqidOffsetShift;            /**< Shift of KeyGen results without the FQID base */
+            uint8_t     fqidOffsetRelativeProfileIdBase;
+                                                    /**< OR of KeyGen results without the FQID base;
+                                                         should indicate the policer profile offset within the
+                                                         port's storage profiles window. */
+            uint8_t     numOfProfiles;              /**< Range of profiles starting at base. */
+        } indirectProfile;                          /**< Indirect profile parameters. */
+    } profileSelect;                                /**< Direct/indirect profile selection and parameters. */
+} t_FmPcdKgStorageProfile;
+#endif /* DPAA_VERSION >= 3 */
+
+/**************************************************************************//**
+ @Description   Parameters for defining CC as the next engine after KeyGen
 *//***************************************************************************/
 typedef struct t_FmPcdKgCc {
-    t_Handle                h_CcTree;           /**< A handle to a CC Tree */
-    uint8_t                 grpId;              /**< CC group id within the CC tree */
-    bool                    plcrNext;           /**< TRUE if after CC, in case of data frame,
-                                                     policing is required. */
-    bool                    bypassPlcrProfileGeneration;
-                                                /**< TRUE to bypass keygen policer profile
-                                                     generation (profile selected is the one selected at
-                                                     port initialization). */
-    t_FmPcdKgPlcrProfile    plcrProfile;        /**< only if plcrNext=TRUE and bypassPlcrProfileGeneration=FALSE */
+    t_Handle                h_CcTree;                       /**< A handle to a CC Tree */
+    uint8_t                 grpId;                          /**< CC group id within the CC tree */
+    bool                    plcrNext;                       /**< TRUE if after CC, in case of data frame,
+                                                                 policing is required. */
+    bool                    bypassPlcrProfileGeneration;    /**< TRUE to bypass KeyGen policer profile generation;
+                                                                 selected profile is the one set at port initialization. */
+    t_FmPcdKgPlcrProfile    plcrProfile;                    /**< Valid only if plcrNext = TRUE and
+                                                                 bypassPlcrProfileGeneration = FALSE */
 } t_FmPcdKgCc;
 
 /**************************************************************************//**
- @Description   A structure for initializing a keygen single scheme
+ @Description   Parameters for defining initializing a KeyGen scheme
 *//***************************************************************************/
 typedef struct t_FmPcdKgSchemeParams {
     bool                                modify;                 /**< TRUE to change an existing scheme */
@@ -1318,35 +1405,41 @@ typedef struct t_FmPcdKgSchemeParams {
     {
         uint8_t                         relativeSchemeId;       /**< if modify=FALSE:Partition relative scheme id */
         t_Handle                        h_Scheme;               /**< if modify=TRUE: a handle of the existing scheme */
-    }id;
-    bool                                alwaysDirect;           /**< This scheme is reached only directly, i.e.                                                              no need for match vector. Keygen will ignore
-                                                                     it when matching   */
+    } id;
+    bool                                alwaysDirect;           /**< This scheme is reached only directly, i.e. no need
+                                                                     for match vector; KeyGen will ignore it when matching */
     struct {                                                    /**< HL Relevant only if alwaysDirect = FALSE */
         t_Handle                        h_NetEnv;               /**< A handle to the Network environment as returned
-                                                                     by FM_PCD_SetNetEnvCharacteristics() */
-        uint8_t                         numOfDistinctionUnits;  /**< Number of netenv units listed in unitIds array */
+                                                                     by FM_PCD_NetEnvCharacteristicsSet() */
+        uint8_t                         numOfDistinctionUnits;  /**< Number of NetEnv units listed in unitIds array */
         uint8_t                         unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
                                                                 /**< Indexes as passed to SetNetEnvCharacteristics array*/
     } netEnvParams;
-    bool                                useHash;                /**< use the KG Hash functionality  */
+    bool                                useHash;                /**< use the KeyGen Hash functionality  */
     t_FmPcdKgKeyExtractAndHashParams    keyExtractAndHashParams;
                                                                 /**< used only if useHash = TRUE */
     bool                                bypassFqidGeneration;   /**< Normally - FALSE, TRUE to avoid FQID update in the IC;
-                                                                     In such a case FQID after KG will be the default FQID
+                                                                     In such a case FQID after KeyGen will be the default FQID
                                                                      defined for the relevant port, or the FQID defined by CC
                                                                      in cases where CC was the previous engine. */
     uint32_t                            baseFqid;               /**< Base FQID; Relevant only if bypassFqidGeneration = FALSE;
                                                                      If hash is used and an even distribution is expected
                                                                      according to hashDistributionNumOfFqids, baseFqid must be aligned to
-                                                                     hashDistributionNumOfFqids.  */
-    uint8_t                             numOfUsedExtractedOrs;  /**< Number of Fqid masks listed in extractedOrs array*/
+                                                                     hashDistributionNumOfFqids. */
+    uint8_t                             numOfUsedExtractedOrs;  /**< Number of FQID masks listed in extractedOrs array */
     t_FmPcdKgExtractedOrParams          extractedOrs[FM_PCD_KG_NUM_OF_GENERIC_REGS];
-                                                                /**< IN: FM_PCD_KG_NUM_OF_GENERIC_REGS
+                                                                /**< FM_PCD_KG_NUM_OF_GENERIC_REGS
                                                                      registers are shared between qidMasks
                                                                      functionality and some of the extraction
                                                                      actions; Normally only some will be used
                                                                      for qidMask. Driver will return error if
                                                                      resource is full at initialization time. */
+
+#if DPAA_VERSION >= 3
+    bool                                overrideStorageProfile; /**< TRUE if KeyGen override previously decided storage profile */
+    t_FmPcdKgStorageProfile             storageProfile;         /**< Used when overrideStorageProfile TRUE */
+#endif /* DPAA_VERSION >= 3 */
+
     e_FmPcdEngine                       nextEngine;             /**< may be BMI, PLCR or CC */
     union {                                                     /**< depends on nextEngine */
         e_FmPcdDoneAction               doneAction;             /**< Used when next engine is BMI (done) */
@@ -1358,23 +1451,21 @@ typedef struct t_FmPcdKgSchemeParams {
 } t_FmPcdKgSchemeParams;
 
 /**************************************************************************//**
- @Description   A structure for defining CC params when CC is the
-                next engine after a CC node.
+ @Description   Parameters for defining CC as the next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextCcParams {
     t_Handle    h_CcNode;               /**< A handle of the next CC node */
 } t_FmPcdCcNextCcParams;
 
 /**************************************************************************//**
- @Description   A structure for defining PLCR params when PLCR is the
-                next engine after a CC node.
+ @Description   Parameters for defining Policer as the next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextPlcrParams {
     bool        overrideParams;         /**< TRUE if CC override previously decided parameters*/
     bool        sharedProfile;          /**< Relevant only if overrideParams=TRUE:
                                              TRUE if this profile is shared between ports */
     uint16_t    newRelativeProfileId;   /**< Relevant only if overrideParams=TRUE:
-                                             (otherwise profile id is taken from keygen);
+                                             (otherwise profile id is taken from KeyGen);
                                              This parameter should indicate the policer
                                              profile offset within the port's
                                              policer profiles or from SHARED window.*/
@@ -1383,65 +1474,78 @@ typedef struct t_FmPcdCcNextPlcrParams {
                                              In earlier chips  if policer next engine is KEYGEN,
                                              this parameter can be 0, because the KEYGEN
                                              always decides the enqueue FQID.*/
-    bool        statisticsEn;           /**< In the case of TRUE Statistic counter is
-                                             incremented for each received frame passed through
-                                             this Coarse Classification entry.*/
+#if DPAA_VERSION >= 3
+    uint8_t     newRelativeStorageProfileId;
+                                        /**< Indicates the relative storage profile offset within
+                                             the port's storage profiles window;
+                                             Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 3 */
 } t_FmPcdCcNextPlcrParams;
 
 /**************************************************************************//**
- @Description   A structure for defining enqueue params when BMI is the
-                next engine after a CC node.
+ @Description   Parameters for defining enqueue as the next action after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextEnqueueParams {
-
     e_FmPcdDoneAction    action;        /**< Action - when next engine is BMI (done) */
-    bool                 overrideFqid;  /**< TRUE if CC override previously decided Fqid(by Keygen),
+    bool                 overrideFqid;  /**< TRUE if CC override previously decided FQID (by KeyGen),
                                              relevant if action = e_FM_PCD_ENQ_FRAME */
     uint32_t             newFqid;       /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
-                                             (otherwise FQID is taken from keygen),
-                                             relevant if action = e_FM_PCD_ENQ_FRAME*/
-    bool                 statisticsEn;  /**< In the case of TRUE Statistic counter is
-                                             incremented for each received frame passed through
-                                             this Coarse Classification entry.*/
+                                             (otherwise FQID is taken from KeyGen),
+                                             relevant if action = e_FM_PCD_ENQ_FRAME */
+#if DPAA_VERSION >= 3
+    uint8_t              newRelativeStorageProfileId;
+                                        /**< Indicates the relative storage profile offset within
+                                             the port's storage profiles window;
+                                             Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 3 */
 } t_FmPcdCcNextEnqueueParams;
 
 /**************************************************************************//**
- @Description   A structure for defining KG params when KG is the
-                next engine after a CC node.
+ @Description   Parameters for defining KeyGen as the next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextKgParams {
-    bool        overrideFqid;           /**< TRUE if CC override previously decided Fqid (by keygen),
-                                             Note - this parameters irrelevant for earlier chips*/
+    bool        overrideFqid;           /**< TRUE if CC override previously decided FQID (by KeyGen),
+                                             Note - this parameters irrelevant for earlier chips */
     uint32_t    newFqid;                /**< Valid if overrideFqid=TRUE, FQID for enqueuing the frame
-                                             (otherwise FQID is taken from keygen),
-                                             Note - this parameters irrelevant for earlier chips*/
+                                             (otherwise FQID is taken from KeyGen),
+                                             Note - this parameters irrelevant for earlier chips */
     t_Handle    h_DirectScheme;         /**< Direct scheme handle to go to. */
-    bool        statisticsEn;           /**< In the case of TRUE Statistic counter is
-                                             incremented for each received frame passed through
-                                             this Coarse Classification entry.*/
+#if DPAA_VERSION >= 3
+    uint8_t     newRelativeStorageProfileId;
+                                        /**< Indicates the relative storage profile offset within
+                                             the port's storage profiles window;
+                                             Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 3 */
 } t_FmPcdCcNextKgParams;
 
 /**************************************************************************//**
- @Description   A structure for defining next engine params after a CC node.
+ @Description   Parameters for defining the next engine after a CC node.
 *//***************************************************************************/
 typedef struct t_FmPcdCcNextEngineParams {
-    e_FmPcdEngine                       nextEngine;    /**< User has to initialize parameters
-                                                            according to nextEngine definition */
+    e_FmPcdEngine                       nextEngine;     /**< User has to initialize parameters
+                                                             according to nextEngine definition */
     union {
-        t_FmPcdCcNextCcParams           ccParams;      /**< Parameters in case next engine is CC */
-        t_FmPcdCcNextPlcrParams         plcrParams;    /**< Parameters in case next engine is PLCR */
-        t_FmPcdCcNextEnqueueParams      enqueueParams; /**< Parameters in case next engine is BMI */
-        t_FmPcdCcNextKgParams           kgParams;      /**< Parameters in case next engine is KG */
+        t_FmPcdCcNextCcParams           ccParams;       /**< Parameters in case next engine is CC */
+        t_FmPcdCcNextPlcrParams         plcrParams;     /**< Parameters in case next engine is PLCR */
+        t_FmPcdCcNextEnqueueParams      enqueueParams;  /**< Parameters in case next engine is BMI */
+        t_FmPcdCcNextKgParams           kgParams;       /**< Parameters in case next engine is KG */
+#if DPAA_VERSION >= 3
+        t_Handle                        h_FrmReplic;    /**< Handle to frame replicator group;
+                                                             Relevant if next engine is e_FM_PCD_INVALID) */
+#endif /* DPAA_VERSION >= 3 */
     } params;
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
-    t_Handle                            h_Manip;       /**< Handler to headerManip.
-                                                            Relevant if next engine of the type result
-                                                            (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+
+    t_Handle                            h_Manip;        /**< Handle to Manipulation object.
+                                                             Relevant if next engine is of type result
+                                                             (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
+
+    bool                                statisticsEn;   /**< If TRUE, statistics counters are incremented
+                                                             for each frame passing through this
+                                                             Coarse Classification entry. */
 } t_FmPcdCcNextEngineParams;
 
 /**************************************************************************//**
- @Description   A structure for defining a single CC Key parameters
+ @Description   Parameters for defining a single CC key
 *//***************************************************************************/
 typedef struct t_FmPcdCcKeyParams {
     uint8_t                     *p_Key;     /**< pointer to the key of the size defined in keySize */
@@ -1454,39 +1558,80 @@ typedef struct t_FmPcdCcKeyParams {
 } t_FmPcdCcKeyParams;
 
 /**************************************************************************//**
- @Description   A structure for defining CC Keys parameters
+ @Description   Parameters for defining CC keys parameters
+
+                The driver supports two methods for CC node allocation: dynamic and static.
+                Static mode was created in order to prevent runtime alloc/free
+                of FMan memory (MURAM), which may cause fragmentation; in this mode,
+                the driver automatically allocates the memory according to
+                'maxNumOfKeys' parameter. The driver calculates the maximal memory
+                size that may be used for this CC-Node taking into consideration
+                'maskSupport' and 'statisticsMode' parameters.
+                In dynamic mode, 'maxNumOfKeys' must be zeroed. At initialization,
+                all required structures are allocated according to 'numOfKeys'
+                parameter. During runtime modification, these structures are
+                re-allocated according to the updated number of keys.
 *//***************************************************************************/
 typedef struct t_KeysParams {
-    uint16_t                    numOfKeys;      /**< Number Of relevant Keys;
-                                                     Note that in case of action = e_FM_PCD_ACTION_INDEXED_LOOKUP,
-                                                     this field should be power-of-2 of the number of bits that are
-                                                     set in 'icIndxMask'. */
-    uint8_t                     keySize;        /**< size of the key - in the case of the extraction of
-                                                     the type FULL_FIELD keySize has to be as standard size of the relevant
-                                                     key. In the another type of extraction keySize has to be as size of extraction.
-                                                     In the case of action = e_FM_PCD_ACTION_INDEXED_LOOKUP the size of keySize has to be 2*/
+    uint16_t                    maxNumOfKeys;   /**< Maximum number of keys that will (ever) be used in this CC-Node;
+                                                     A value of zero may be used for dynamic memory allocation. */
+    bool                        maskSupport;    /**< This parameter is relevant only if a node is initialized with
+                                                     action = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
+                                                     Should be TRUE if the node was initialized 'empty' (no keys)
+                                                     or with keys without masks, and user wants to be able to add
+                                                     a mask to a key later on in run-time. */
+    e_FmPcdCcStatsMode          statisticsMode; /**< If enabled, the required structures for the requested statistics
+                                                     mode will be allocated according to 'maxNumOfKeys'. */
+    uint16_t                    numOfKeys;      /**< Number of initial keys;
+                                                     Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP
+                                                     (but the 'src' is not e_FM_PCD_EXTRACT_FROM_HASH; in this case,
+                                                     'numOfKeys' should be zero), this field should be power-of-2
+                                                     of the number of bits that are set in 'icIndxMask'. */
+    uint8_t                     keySize;        /**< Size of key - for extraction of type FULL_FIELD, keySize has
+                                                     to be the standard size of the selected key; For other extraction
+                                                     types, keySize has to be as size of extraction; When 'action' =
+                                                     e_FM_PCD_ACTION_INDEXED_LOOKUP, keySize has to be 2. */
     t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
-                                                /**< it's array with 'numOfKeys' entries each entry in
-                                                     the array of the type t_FmPcdCcKeyParams */
+                                                /**< An array with 'numOfKeys' entries, each entry specifies the
+                                                     corresponding key parameters. */
     t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;
-                                                /**< parameters for the next step of
-                                                     unfound (or undefined) key . Not relevant in the case
-                                                     of action = e_FM_PCD_ACTION_INDEXED_LOOKUP*/
+                                                /**< Parameters for defining the next engine when a key is not matched;
+                                                     Not relevant if action = e_FM_PCD_ACTION_INDEXED_LOOKUP. */
 } t_KeysParams;
 
 /**************************************************************************//**
- @Description   A structure for defining the CC node params
+ @Description   Parameters for defining a CC node
 *//***************************************************************************/
 typedef struct t_FmPcdCcNodeParams {
-    t_FmPcdExtractEntry         extractCcParams;    /**< params which defines extraction parameters */
-    t_KeysParams                keysParams;         /**< params which defines Keys parameters of the
-                                                         extraction defined in extractCcParams */
+    t_FmPcdExtractEntry         extractCcParams;    /**< Extraction parameters */
+    t_KeysParams                keysParams;         /**< Keys definition matching the selected extraction */
 } t_FmPcdCcNodeParams;
 
 /**************************************************************************//**
- @Description   A structure for defining each CC tree group in term of
-                NetEnv units and the action to be taken in each case.
-                the unitIds list must be in order from lower to higher indexes.
+ @Description   Parameters for defining a hash table
+*//***************************************************************************/
+typedef struct t_FmPcdHashTableParams {
+    uint16_t                    maxNumOfKeys;               /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
+    e_FmPcdCcStatsMode          statisticsMode;             /**< If enabled, the required structures for the requested statistics
+                                                                 mode will be allocated according to maxNumOfKeys. */
+    uint16_t                    hashResMask;                /**< Mask that will be used on the hash-result;
+                                                                 The number-of-sets for this hash will be calculated
+                                                                 as (2^(number of bits set in 'hashResMask'));
+                                                                 The 4 lower bits must be cleared. */
+    uint8_t                     hashShift;                  /**< Byte offset from the beginning of the KeyGen hash result to the
+                                                                 2-bytes to be used as hash index. */
+    uint8_t                     matchKeySize;               /**< Size of the exact match keys held by the hash buckets */
+
+    t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;  /**< Parameters for defining the next engine when a key is not matched */
+
+} t_FmPcdHashTableParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining a CC tree group.
+
+                This structure defines a CC group in terms of NetEnv units
+                and the action to be taken in each case. The unitIds list must
+                be given in order from low to high indices.
 
                 t_FmPcdCcNextEngineParams is a list of 2^numOfDistinctionUnits
                 structures where each defines the next action to be taken for
@@ -1503,30 +1648,27 @@ typedef struct t_FmPcdCcNodeParams {
                                                         unit 1 - found; unit 3 - found;
 *//***************************************************************************/
 typedef struct t_FmPcdCcGrpParams {
-    uint8_t                     numOfDistinctionUnits;          /**< up to 4 */
+    uint8_t                     numOfDistinctionUnits;          /**< Up to 4 */
     uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_CC_UNITS];
-                                                                /**< Indexes of the units as defined in
-                                                                     FM_PCD_SetNetEnvCharacteristics() */
+                                                                /**< Indices of the units as defined in
+                                                                     FM_PCD_NetEnvCharacteristicsSet() */
     t_FmPcdCcNextEngineParams   nextEnginePerEntriesInGrp[FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP];
-                                                                /**< Max size is 16 - if only one group used */
+                                                                /**< Maximum entries per group is 16 */
 } t_FmPcdCcGrpParams;
 
 /**************************************************************************//**
- @Description   A structure for defining the CC tree groups
+ @Description   Parameters for defining CC tree groups
 *//***************************************************************************/
 typedef struct t_FmPcdCcTreeParams {
-    t_Handle                h_NetEnv;                                   /**< A handle to the Network environment as returned
-                                                                             by FM_PCD_SetNetEnvCharacteristics() */
-    uint8_t                 numOfGrps;                                  /**< Number of CC groups within the CC tree */
-    t_FmPcdCcGrpParams      ccGrpParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];   /**< Parameters for each group. */
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    t_Handle                h_IpReassemblyManip;                        /**< IP Reassembly manipulation handle should be given
-                                                                             as a parameter to the tree */
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+    t_Handle                h_NetEnv;                   /**< A handle to the Network environment as returned
+                                                             by FM_PCD_NetEnvCharacteristicsSet() */
+    uint8_t                 numOfGrps;                  /**< Number of CC groups within the CC tree */
+    t_FmPcdCcGrpParams      ccGrpParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];
+                                                        /**< Parameters for each group. */
 } t_FmPcdCcTreeParams;
 
 /**************************************************************************//**
- @Description   A structure for defining parameters for byte rate
+ @Description   Parameters for defining policer byte rate
 *//***************************************************************************/
 typedef struct t_FmPcdPlcrByteRateModeParams {
     e_FmPcdPlcrFrameLengthSelect    frameLengthSelection;   /**< Frame length selection */
@@ -1535,30 +1677,30 @@ typedef struct t_FmPcdPlcrByteRateModeParams {
 } t_FmPcdPlcrByteRateModeParams;
 
 /**************************************************************************//**
- @Description   A structure for selcting the policer profile RFC-2698 or
-                RFC-4115 parameters
+ @Description   Parameters for defining the policer profile (based on
+                RFC-2698 or RFC-4115 attributes).
 *//***************************************************************************/
 typedef struct t_FmPcdPlcrNonPassthroughAlgParams {
-    e_FmPcdPlcrRateMode              rateMode;                       /**< Byte / Packet */
+    e_FmPcdPlcrRateMode              rateMode;                       /**< Byte mode or Packet mode */
     t_FmPcdPlcrByteRateModeParams    byteModeParams;                 /**< Valid for Byte NULL for Packet */
-    uint32_t                         comittedInfoRate;               /**< KBits/Sec or Packets/Sec */
+    uint32_t                         comittedInfoRate;               /**< KBits/Second or Packets/Second */
     uint32_t                         comittedBurstSize;              /**< Bytes/Packets */
-    uint32_t                         peakOrAccessiveInfoRate;        /**< KBits/Sec or Packets/Sec */
+    uint32_t                         peakOrAccessiveInfoRate;        /**< KBits/Second or Packets/Second */
     uint32_t                         peakOrAccessiveBurstSize;       /**< Bytes/Packets */
 } t_FmPcdPlcrNonPassthroughAlgParams;
 
 /**************************************************************************//**
- @Description   A union for defining Policer next engine parameters
+ @Description   Parameters for defining the next engine after policer
 *//***************************************************************************/
 typedef union u_FmPcdPlcrNextEngineParams {
-        e_FmPcdDoneAction               action;             /**< Action - when next engine is BMI (done) */
-        t_Handle                        h_Profile;          /**< Policer profile handle -  used when next engine
-                                                                 is PLCR, must be a SHARED profile */
-        t_Handle                        h_DirectScheme;     /**< Direct scheme select - when next engine is Keygen */
+    e_FmPcdDoneAction               action;             /**< Action - when next engine is BMI (done) */
+    t_Handle                        h_Profile;          /**< Policer profile handle -  used when next engine
+                                                             is Policer, must be a SHARED profile */
+    t_Handle                        h_DirectScheme;     /**< Direct scheme select - when next engine is KeyGen */
 } u_FmPcdPlcrNextEngineParams;
 
 /**************************************************************************//**
- @Description   A structure for selecting the policer profile entry parameters
+ @Description   Parameters for defining the policer profile entry
 *//***************************************************************************/
 typedef struct t_FmPcdPlcrProfileParams {
     bool                                modify;                     /**< TRUE to change an existing profile */
@@ -1567,87 +1709,81 @@ typedef struct t_FmPcdPlcrProfileParams {
             e_FmPcdProfileTypeSelection profileType;                /**< Type of policer profile */
             t_Handle                    h_FmPort;                   /**< Relevant for per-port profiles only */
             uint16_t                    relativeProfileId;          /**< Profile id - relative to shared group or to port */
-        } newParams;                                                /**< use it when modify=FALSE */
+        } newParams;                                                /**< use it when modify = FALSE */
         t_Handle                        h_Profile;                  /**< A handle to a profile - use it when modify=TRUE */
     } id;
     e_FmPcdPlcrAlgorithmSelection       algSelection;               /**< Profile Algorithm PASS_THROUGH, RFC_2698, RFC_4115 */
     e_FmPcdPlcrColorMode                colorMode;                  /**< COLOR_BLIND, COLOR_AWARE */
 
     union {
-        e_FmPcdPlcrColor                dfltColor;                  /**< For Color-Blind Pass-Through mode. the policer will re-color
+        e_FmPcdPlcrColor                dfltColor;                  /**< For Color-Blind Pass-Through mode; the policer will re-color
                                                                          any incoming packet with the default value. */
-        e_FmPcdPlcrColor                override;                   /**< For Color-Aware modes. The profile response to a
+        e_FmPcdPlcrColor                override;                   /**< For Color-Aware modes; the profile response to a
                                                                          pre-color value of 2'b11. */
     } color;
 
-    t_FmPcdPlcrNonPassthroughAlgParams  nonPassthroughAlgParams;    /**< RFC2698 or RFC4115 params */
+    t_FmPcdPlcrNonPassthroughAlgParams  nonPassthroughAlgParams;    /**< RFC2698 or RFC4115 parameters */
 
-    e_FmPcdEngine                       nextEngineOnGreen;          /**< Green next engine type */
-    u_FmPcdPlcrNextEngineParams         paramsOnGreen;              /**< Green next engine params */
+    e_FmPcdEngine                       nextEngineOnGreen;          /**< Next engine for green-colored frames */
+    u_FmPcdPlcrNextEngineParams         paramsOnGreen;              /**< Next engine parameters for green-colored frames  */
 
-    e_FmPcdEngine                       nextEngineOnYellow;         /**< Yellow next engine type */
-    u_FmPcdPlcrNextEngineParams         paramsOnYellow;             /**< Yellow next engine params */
+    e_FmPcdEngine                       nextEngineOnYellow;         /**< Next engine for yellow-colored frames */
+    u_FmPcdPlcrNextEngineParams         paramsOnYellow;             /**< Next engine parameters for yellow-colored frames  */
 
-    e_FmPcdEngine                       nextEngineOnRed;            /**< Red next engine type */
-    u_FmPcdPlcrNextEngineParams         paramsOnRed;                /**< Red next engine params */
+    e_FmPcdEngine                       nextEngineOnRed;            /**< Next engine for red-colored frames */
+    u_FmPcdPlcrNextEngineParams         paramsOnRed;                /**< Next engine parameters for red-colored frames  */
 
     bool                                trapProfileOnFlowA;         /**< Trap on flow A */
     bool                                trapProfileOnFlowB;         /**< Trap on flow B */
     bool                                trapProfileOnFlowC;         /**< Trap on flow C */
 } t_FmPcdPlcrProfileParams;
 
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
- @Description   A structure for selecting the location of manipulation
+ @Description   Parameters for selecting a location for requested manipulation
 *//***************************************************************************/
-typedef struct t_FmPcdManipLocationParams {
-    e_FmPcdManipLocateType              type;           /**< location of manipulation type select */
-    struct {                                            /**< used when type = e_FM_PCD_MANIP_BY_HDR */
-        e_NetHeaderType                 hdr;            /**< Header selection */
-        e_FmPcdHdrIndex                 hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled
-                                                             IP. Otherwise should be cleared. */
-        bool                            byField;        /**< TRUE if the location of manipulation is according to some field in the specific header*/
-        t_FmPcdFields                   fullField;      /**< Relevant only when byField = TRUE: Extract field */
-    } manipByHdr;
-} t_FmPcdManipLocationParams;
+typedef struct t_FmManipHdrInfo
+{
+    e_NetHeaderType                     hdr;            /**< Header selection */
+    e_FmPcdHdrIndex                     hdrIndex;       /**< Relevant only for MPLS, VLAN and tunneled IP. Otherwise should be cleared. */
+    bool                                byField;        /**< TRUE if the location of manipulation is according to some field in the specific header*/
+    t_FmPcdFields                       fullField;      /**< Relevant only when byField = TRUE: Extract field */
+} t_FmManipHdrInfo;
 
+#ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
- @Description   structure for defining insert manipulation
-                of the type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
+ @Description   Parameters for defining an insertion manipulation
+                of type e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
 *//***************************************************************************/
-typedef struct t_FmPcdManipInsrtByTemplateParams {
-    uint8_t         size;                               /**< size of insert template to the start of the frame. */
+typedef struct t_FmPcdManipHdrInsrtByTemplateParams {
+    uint8_t         size;                               /**< Size of insert template to the start of the frame. */
     uint8_t         hdrTemplate[FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE];
-                                                        /**< array of the insertion template. */
+                                                        /**< Array of the insertion template. */
 
     bool            modifyOuterIp;                      /**< TRUE if user want to modify some fields in outer IP. */
     struct {
-        uint16_t    ipOuterOffset;                      /**< offset of outer IP in the insert template, relevant if modifyOuterIp = TRUE.*/
+        uint16_t    ipOuterOffset;                      /**< Offset of outer IP in the insert template, relevant if modifyOuterIp = TRUE.*/
         uint16_t    dscpEcn;                            /**< value of dscpEcn in IP outer, relevant if modifyOuterIp = TRUE.
                                                              in IPV4 dscpEcn only byte - it has to be adjusted to the right*/
         bool        udpPresent;                         /**< TRUE if UDP is present in the insert template, relevant if modifyOuterIp = TRUE.*/
-        uint8_t     udpOffset;                          /**< offset in the insert template of UDP, relevant if modifyOuterIp = TRUE and udpPresent=TRUE.*/
+        uint8_t     udpOffset;                          /**< Offset in the insert template of UDP, relevant if modifyOuterIp = TRUE and udpPresent=TRUE.*/
         uint8_t     ipIdentGenId;                       /**< Used by FMan-CTRL to calculate IP-identification field,relevant if modifyOuterIp = TRUE.*/
         bool        recalculateLength;                  /**< TRUE if recalculate length has to be performed due to the engines in the path which can change the frame later, relevant if modifyOuterIp = TRUE.*/
         struct {
-            uint8_t blockSize;                          /**< The CAAM block-size; Used by FMan-CTRL to calculate the IP-total-len field.*/
-            uint8_t extraBytesAddedAlignedToBlockSize;  /**< Used by FMan-CTRL to calculate the IP-total-len field and UDP length*/
-            uint8_t extraBytesAddedNotAlignedToBlockSize;/**< Used by FMan-CTRL to calculate the IP-total-len field and UDP length.*/
-        } recalculateLengthParams;                      /**< recalculate length parameters - relevant if modifyOuterIp = TRUE and recalculateLength = TRUE */
+            uint8_t blockSize;                          /**< The CAAM block-size; Used by FMan-CTRL to calculate the IP Total Length field.*/
+            uint8_t extraBytesAddedAlignedToBlockSize;  /**< Used by FMan-CTRL to calculate the IP Total Length field and UDP length*/
+            uint8_t extraBytesAddedNotAlignedToBlockSize;/**< Used by FMan-CTRL to calculate the IP Total Length field and UDP length.*/
+        } recalculateLengthParams;                      /**< Recalculate length parameters - relevant if modifyOuterIp = TRUE and recalculateLength = TRUE */
     } modifyOuterIpParams;                              /**< Outer IP modification parameters - ignored if modifyOuterIp is FALSE */
 
-    bool            modifyOuterVlan;                    /**< TRUE if user wants to modify vpri field in the outer VLAN header*/
+    bool            modifyOuterVlan;                    /**< TRUE if user wants to modify VPri field in the outer VLAN header*/
     struct {
-        uint8_t     vpri;                               /**< value of vpri, relevant if modifyOuterVlan = TRUE
-                                                             vpri only 3 bits, it has to be adjusted to the right*/
+        uint8_t     vpri;                               /**< Value of VPri, relevant if modifyOuterVlan = TRUE
+                                                             VPri only 3 bits, it has to be adjusted to the right*/
     } modifyOuterVlanParams;
-} t_FmPcdManipInsrtByTemplateParams;
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
-
+} t_FmPcdManipHdrInsrtByTemplateParams;
 
-#ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
- @Description   structure for defining CAPWAP fragmentation
+ @Description   Parameters for defining CAPWAP fragmentation
 *//***************************************************************************/
 typedef struct t_CapwapFragmentationParams {
     uint16_t         sizeForFragmentation;              /**< if length of the frame is greater than this value, CAPWAP fragmentation will be executed.*/
@@ -1657,171 +1793,363 @@ typedef struct t_CapwapFragmentationParams {
 } t_CapwapFragmentationParams;
 
 /**************************************************************************//**
- @Description   structure for defining CAPWAP Re-assembly
+ @Description   Parameters for defining CAPWAP reassembly
 *//***************************************************************************/
 typedef struct t_CapwapReassemblyParams {
-    uint16_t                         maxNumFramesInProcess; /**< Number of frames which can be processed by Reassembly in the same time.
-                                                                 It has to be power of 2.
-                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be reassembled concurrently; must be power of 2.
+                                                                 In case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
                                                                  maxNumFramesInProcess has to be in the range of 4 - 512,
-                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 In case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
                                                                  maxNumFramesInProcess has to be in the range of 8 - 2048 */
-    bool                            haltOnDuplicationFrag;  /**< In the case of TRUE, Reassembly process halted due to duplicated fragment,
-                                                                 and all processed fragments passed for enqueue with error indication.
-                                                                 In the case of FALSE, only duplicated fragment passed for enqueue with error indication */
+    bool                            haltOnDuplicationFrag;  /**< If TRUE, reassembly process will be halted due to duplicated fragment,
+                                                                 and all processed fragments will be enqueued with error indication;
+                                                                 If FALSE, only duplicated fragments will be enqueued with error indication. */
 
-    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
-    uint32_t                        fqidForTimeOutFrames;   /**< Fqid in which time out frames will enqueue during Time Out Process  */
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by the reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process  */
     uint32_t                        timeoutRoutineRequestTime;
                                                             /**< Represents the time interval in microseconds between consecutive
                                                                  timeout routine requests It has to be power of 2. */
     uint32_t                        timeoutThresholdForReassmProcess;
-                                                            /**< Represents the time interval in microseconds which defines
-                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+                                                            /**< Time interval (microseconds) for marking frames in process as too old;
+                                                                 Frames in process are those for which at least one fragment was received
+                                                                 but not all fragments. */
 
-    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;/**< Number of frames per hash entry needed for reassembly process */
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;/**< Number of frames per hash entry (needed for the reassembly process) */
 } t_CapwapReassemblyParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining fragmentation/reassembly manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragOrReasmParams {
+    bool                                frag;               /**< TRUE if using the structure for fragmentation,
+                                                                 otherwise this structure is used for reassembly */
+    uint8_t                             sgBpid;             /**< Scatter/Gather buffer pool id;
+                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                             of this pool need to be allocated in the same memory area as the received buffers.
+                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                             mutual to all these sources. */
+    e_NetHeaderType                     hdr;                /**< Header selection */
+    union {
+        t_CapwapFragmentationParams     capwapFragParams;   /**< Structure for CAPWAP fragmentation,
+                                                                 relevant if 'frag' = TRUE, 'hdr' = HEADER_TYPE_CAPWAP */
+        t_CapwapReassemblyParams        capwapReasmParams;  /**< Structure for CAPWAP reassembly,
+                                                                 relevant if 'frag' = FALSE, 'hdr' = HEADER_TYPE_CAPWAP */
+    } u;
+} t_FmPcdManipFragOrReasmParams;
+
+#endif /* FM_CAPWAP_SUPPORT */
+
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   Parameters for defining header removal by header type
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrRmvByHdrParams {
+    e_FmPcdManipHdrRmvByHdrType         type;           /**< Selection of header removal location */
+    union {
+#ifdef FM_CAPWAP_SUPPORT
+        struct {
+            bool                        include;        /**< If FALSE, remove until the specified header (not including the header);
+                                                             If TRUE, remove also the specified header. */
+            t_FmManipHdrInfo            hdrInfo;
+        } fromStartByHdr;                               /**< Relevant when type = e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START */
+#endif /* FM_CAPWAP_SUPPORT */
+    } u;
+} t_FmPcdManipHdrRmvByHdrParams;
 #endif /* FM_CAPWAP_SUPPORT */
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
 /**************************************************************************//**
- @Description   structure for defining IP fragmentation
+ @Description   Parameters for configuring IP fragmentation manipulation
 *//***************************************************************************/
-typedef struct t_IpFragmentationParams {
-    uint16_t                    sizeForFragmentation;   /**< if length of the frame is greater than this value,
+typedef struct t_FmPcdManipFragIpParams {
+    uint16_t                    sizeForFragmentation;   /**< If length of the frame is greater than this value,
                                                              IP fragmentation will be executed.*/
+#if (DPAA_VERSION == 2)
     uint8_t                     scratchBpid;            /**< Absolute buffer pool id according to BM configuration.*/
-    e_FmPcdManipDontFragAction  dontFragAction;         /**< Don't Fragment Action - If an IP packet is larger
+#endif /* (DPAA_VERSION == 2) */
+    bool                        sgBpidEn;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                             received frame's buffer. */
+    uint8_t                     sgBpid;                 /**< Scatter/Gather buffer pool id;
+                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                             of this pool need to be allocated in the same memory area as the received buffers.
+                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                             mutual to all these sources. */
+    e_FmPcdManipDontFragAction  dontFragAction;         /**< Dont Fragment Action - If an IP packet is larger
                                                              than MTU and its DF bit is set, then this field will
                                                              determine the action to be taken.*/
-} t_IpFragmentationParams;
+} t_FmPcdManipFragIpParams;
 
 /**************************************************************************//**
- @Description   structure for defining IP Re-assembly
-                This structure is a common structure for IPv4 and Ipv6 reassembly manipulation
-                together or separately. for using reassembly manipulation
-                for both IPv4 and IPv6, fill "HEADER_TYPE_IPv6" value in the hdr
-                filed at t_FmPcdManipFragOrReasmParams structure.
+ @Description   Parameters for configuring IP reassembly manipulation.
+
+                This is a common structure for both IPv4 and IPv6 reassembly
+                manipulation. For reassembly of both IPv4 and IPv6, make sure to
+                set the 'hdr' field in t_FmPcdManipReassemParams to HEADER_TYPE_IPv6.
 *//***************************************************************************/
-typedef struct t_IpReassemblyParams {
-    uint8_t                         relativeSchemeId[2];    /**< Partition relative scheme id -
-                                                                 relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation.
-                                                                 relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation.
+typedef struct t_FmPcdManipReassemIpParams {
+    uint8_t                         relativeSchemeId[2];    /**< Partition relative scheme id:
+                                                                 relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
+                                                                 relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
                                                                  Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
-                                                                 the user schemes id to ensure that the reassembly's schemes will be first match.
-                                                                 Rest schemes, if defined, should have higher relative scheme ID */
+                                                                 the user schemes id to ensure that the reassemblys schemes will be first match.
+                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
+#ifdef UNDER_CONSTRUCTION_V3_IPR
+    t_Handle                        h_CouplingFmPort;       /**< Must be given if storage profile virtualization is required */
+#endif /* UNDER_CONSTRUCTION_V3_IPR */
     uint8_t                         sgBpid;                 /**< Buffer pool id for the S/G frame created by the reassembly process */
-    uint8_t                         dataMemId;              /**< Memory partition ID for data buffers */
+    uint8_t                         dataMemId;              /**< Memory partition ID for the IPR's external tables structure */
     uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
-    uint16_t                        minFragSize[2];         /**< Minimum frag size.
-                                                                 minFragSize[0] - for ipv4
-                                                                 minFragSize[1] - for ipv6 */
-    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by Reassembly in the same time.
-                                                                 It has to be power of 2.
+    uint16_t                        minFragSize[2];         /**< Minimum fragment size:
+                                                                 minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry[2];
+                                                            /**< Number of frames per hash entry needed for reassembly process:
+                                                                 numOfFramesPerHashEntry[0] - for ipv4 (max value is e_FM_PCD_MANIP_EIGHT_WAYS_HASH);
+                                                                 numOfFramesPerHashEntry[1] - for ipv6 (max value is e_FM_PCD_MANIP_SIX_WAYS_HASH). */
+    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by Reassembly in the same time;
+                                                                 Must be power of 2;
                                                                  In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 4 - 512,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
                                                                  In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
-                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048 */
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
     e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
-    uint32_t                        fqidForTimeOutFrames;   /**< Fqid in which time out frames will enqueue during Time Out Process  */
-    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;/**< Number of frames per hash entry needed for reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process  */
     uint32_t                        timeoutThresholdForReassmProcess;
                                                             /**< Represents the time interval in microseconds which defines
                                                                  if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
-} t_IpReassemblyParams;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+} t_FmPcdManipReassemIpParams;
 
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
- @Description   structure for defining fragmentation/reassembly
+ @Description   structure for defining IPSEC manipulation
 *//***************************************************************************/
-typedef struct t_FmPcdManipFragOrReasmParams {
-    bool                                frag;               /**< TRUE if using the structure for fragmentation,
-                                                                 otherwise this structure is used for reassembly */
-    uint8_t                             extBufPoolIndx;     /**< Index of the buffer pool ID which was configured for port
-                                                                 and can be used for manipulation;
-                                                                 NOTE: This field is relevant only for CAPWAP fragmentation
-                                                                 and reassembly */
-    e_NetHeaderType                     hdr;                /**< Header selection */
+typedef struct t_FmPcdManipSpecialOffloadIPSecParams {
+    bool    decryption;                     /**< TRUE if being used in decryption direction;
+                                                 FALSE if being used in encryption direction. */
+    bool    ecnCopy;                        /**< TRUE to copy the ECN bits from inner/outer to outer/inner
+                                                 (direction depends on the 'decryption' field). */
+    bool    dscpCopy;                       /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
+                                                 (direction depends on the 'decryption' field). */
+    bool    variableIpHdrLen;               /**< TRUE for supporting variable IP header length in decryption. */
+} t_FmPcdManipSpecialOffloadIPSecParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining special offload manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipSpecialOffloadParams {
+    e_FmPcdManipSpecialOffloadType              type;       /**< Type of special offload manipulation */
+    union
+    {
+        t_FmPcdManipSpecialOffloadIPSecParams   ipsec;      /**< Parameters for IPSec; Relevant when
+                                                                 type = e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC */
+    } u;
+} t_FmPcdManipSpecialOffloadParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic removal manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrRmvGenericParams {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the removal */
+    uint8_t                         size;           /**< Size of removed section */
+} t_FmPcdManipHdrRmvGenericParams;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtGenericParams {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the insertion */
+    uint8_t                         size;           /**< Size of inserted section */
+    bool                            replace;        /**< TRUE to override (replace) existing data at
+                                                         'offset', FALSE to insert */
+    uint8_t                         *p_Data;        /**< Pointer to data to be inserted */
+} t_FmPcdManipHdrInsrtGenericParams;
+
+
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipHdrInsrtParams {
+    e_FmPcdManipHdrInsrtType                    type;   /**< Type of insertion manipulation */
     union {
+        t_FmPcdManipHdrInsrtGenericParams       generic;
+                                                        /**< Parameters for defining generic header insertion manipulation,
+                                                             relevant if type = e_FM_PCD_MANIP_INSRT_GENERIC */
 #ifdef FM_CAPWAP_SUPPORT
-        t_CapwapFragmentationParams     capwapFragParams;   /**< Structure for CAPWAP fragmentation, relevant if frag = TRUE, hdr = HEADER_TYPE_CAPWAP */
-        t_CapwapReassemblyParams        capwapReasmParams;  /**< Structure for CAPWAP reassembly, relevant if frag = FALSE, hdr = HEADER_TYPE_CAPWAP */
+        t_FmPcdManipHdrInsrtByTemplateParams    byTemplate;
+                                                        /**< Parameters for defining header insertion manipulation by template,
+                                                             relevant if type = e_FM_PCD_MANIP_INSRT_BY_TEMPLATE */
 #endif /* FM_CAPWAP_SUPPORT */
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-        t_IpFragmentationParams         ipFragParams;       /**< Structure for IP-fragmentation, relevant if frag = TRUE, hdr = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
-        t_IpReassemblyParams            ipReasmParams;      /**< Structure for IP-reassembly, relevant if frag = FALSE, hdr = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-    };
-} t_FmPcdManipFragOrReasmParams;
+    } u;
+} t_FmPcdManipHdrInsrtParams;
 
 /**************************************************************************//**
- @Description   structure for defining insert manipulation
+ @Description   Parameters for defining header removal manipulation
 *//***************************************************************************/
-typedef struct t_FmPcdManipInsrtParams {
-    e_FmPcdManipInsrtType                       type;       /**< Type of insert manipulation */
+typedef struct t_FmPcdManipHdrRmvParams {
+    e_FmPcdManipHdrRmvType                  type;       /**< Type of header removal manipulation */
     union {
-        t_FmPcdManipInsrtByTemplateParams       insrtByTemplateParams;
-                                                            /**< parameters for insert manipulation, relevant if
-                                                                 type = e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE */
-    };
-} t_FmPcdManipInsrtParams;
+#ifdef FM_CAPWAP_SUPPORT
+        t_FmPcdManipHdrRmvByHdrParams       byHdr;      /**< Parameters for defining header removal manipulation by header type,
+                                                             relevant if type = e_FM_PCD_MANIP_RMV_BY_HDR */
+#endif /* FM_CAPWAP_SUPPORT */
+        t_FmPcdManipHdrRmvGenericParams     generic;    /**< Parameters for defining generic header removal manipulation,
+                                                             relevant if type = e_FM_PCD_MANIP_RMV_GENERIC */
+    } u;
+} t_FmPcdManipHdrRmvParams;
 
 /**************************************************************************//**
- @Description   structure for defining remove manipulation
+ @Description   Parameters for defining header manipulation node
 *//***************************************************************************/
-typedef struct t_FmPcdManipRmvParams {
-    e_FmPcdManipRmvParamsType                   type;   /**< Type of remove manipulation */
-    t_FmPcdManipLocationParams                  rmvSpecificLocationParams;
-                                                        /**< Specified location of remove manipulation;
-                                                              This params should be initialized in cases:
-                                                              - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION
-                                                              - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION */
-} t_FmPcdManipRmvParams;
+typedef struct t_FmPcdManipHdrParams {
+    bool                                        rmv;                /**< TRUE, to define removal manipulation */
+    t_FmPcdManipHdrRmvParams                    rmvParams;          /**< Parameters for removal manipulation, relevant if rmv = TRUE */
+
+    bool                                        insrt;              /**< TRUE, to define insertion manipulation */
+    t_FmPcdManipHdrInsrtParams                  insrtParams;        /**< Parameters for insertion manipulation, relevant if insrt = TRUE */
+
+
+    bool                                        dontParseAfterManip;/**< FALSE to activate the parser a second time after
+                                                                         completing the manipulation on the frame */
+} t_FmPcdManipHdrParams;
+
+/**************************************************************************//**
+ @Description   structure for defining fragmentation manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragParams {
+    e_NetHeaderType                     hdr;          /**< Header selection */
+    union {
+        t_FmPcdManipFragIpParams        ipFrag;       /**< Parameters for defining IP fragmentation,
+                                                           relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} t_FmPcdManipFragParams;
+
+/**************************************************************************//**
+ @Description   structure for defining reassemble manipulation
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemParams {
+    e_NetHeaderType                     hdr;          /**< Header selection */
+    union {
+        t_FmPcdManipReassemIpParams     ipReassem;    /**< Parameters for defining IP reassembly,
+                                                           relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} t_FmPcdManipReassemParams;
 
 /**************************************************************************//**
- @Description   structure for defining manipulation
+ @Description   Parameters for defining a manipulation node
 *//***************************************************************************/
 typedef struct t_FmPcdManipParams {
-    bool                                        rmv;                /**< TRUE, if defined remove manipulation */
-    t_FmPcdManipRmvParams                       rmvParams;          /**< Parameters for remove manipulation, relevant if rmv = TRUE */
+    e_FmPcdManipType                        type;               /**< Selects type of manipulation node */
+    union{
+        t_FmPcdManipHdrParams               hdr;                /**< Parameters for defining header manipulation node */
+        t_FmPcdManipReassemParams           reassem;            /**< Parameters for defining reassembly manipulation node */
+        t_FmPcdManipFragParams              frag;               /**< Parameters for defining fragmentation manipulation node */
+        t_FmPcdManipSpecialOffloadParams    specialOffload;     /**< Parameters for defining special offload manipulation node */
+    } u;
+     t_Handle                               h_NextManip;        /**< Handle to another (previously defined) manipulation node;
+                                                                     Allows concatenation of manipulation actions */
+#ifdef FM_CAPWAP_SUPPORT
+    bool                                    fragOrReasm;        /**< TRUE, if defined fragmentation/reassembly manipulation */
+    t_FmPcdManipFragOrReasmParams           fragOrReasmParams;  /**< Parameters for fragmentation/reassembly manipulation,
+                                                                     relevant if fragOrReasm = TRUE */
+#endif /* FM_CAPWAP_SUPPORT */
+} t_FmPcdManipParams;
 
-    bool                                        insrt;              /**< TRUE, if defined insert manipulation */
-    t_FmPcdManipInsrtParams                     insrtParams;        /**< Parameters for insert manipulation, relevant if insrt = TRUE */
+/**************************************************************************//**
+ @Description   Structure for retrieving IP reassembly statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemIpStats {
+    /* common counters for both IPv4 and IPv6 */
+    uint32_t    timeout;                        /**< Counts the number of TimeOut occurrences */
+    uint32_t    rfdPoolBusy;                    /**< Counts the number of failed attempts to allocate
+                                                     a Reassembly Frame Descriptor */
+    uint32_t    internalBufferBusy;             /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t    externalBufferBusy;             /**< Counts the number of times external buffer busy occurred */
+    uint32_t    sgFragments;                    /**< Counts the number of Scatter/Gather fragments */
+    uint32_t    dmaSemaphoreDepletion;          /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    struct {
+        uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
+        uint32_t    validFragments;             /**< Counts the total number of valid fragments that
+                                                     have been processed for all frames */
+        uint32_t    processedFragments;         /**< Counts the number of processed fragments
+                                                     (valid and error fragments) for all frames */
+        uint32_t    malformedFragments;         /**< Counts the number of malformed fragments processed for all frames */
+        uint32_t    discardedFragments;         /**< Counts the number of fragments discarded by the reassembly process */
+        uint32_t    autoLearnBusy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                     to access an IP-Reassembly Automatic Learning Hash set */
+        uint32_t    moreThan16Fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                     exceeds 16 */
+    } specificHdrStatistics[2];                 /**< slot '0' is for IPv4, slot '1' is for IPv6 */
+} t_FmPcdManipReassemIpStats;
 
-    bool                                        fragOrReasm;        /**< TRUE, if defined fragmentation/reassembly manipulation */
-    t_FmPcdManipFragOrReasmParams               fragOrReasmParams;  /**< Parameters for fragmentation/reassembly manipulation, relevant if fragOrReasm = TRUE */
+/**************************************************************************//**
+ @Description   Structure for retrieving IP fragmentation statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipFragIpStats {
+    uint32_t    totalFrames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmentedFrames;       /**< Number of frames that were fragmented */
+    uint32_t    generatedFragments;     /**< Number of fragments that were generated */
+} t_FmPcdManipFragIpStats;
 
-    /**< General parameters */
-    bool                                        treatFdStatusFieldsAsErrors;
-                                                                    /**< Set to TRUE when the port that is using this manip is chained
-                                                                         to SEC (i.e. the traffic was forwarded from SEC) */
-} t_FmPcdManipParams;
+/**************************************************************************//**
+ @Description   Structure for retrieving reassembly statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipReassemStats {
+    union {
+        t_FmPcdManipReassemIpStats  ipReassem;  /**< Structure for IP reassembly statistics */
+    } u;
+} t_FmPcdManipReassemStats;
 
 /**************************************************************************//**
- @Description   structure for defining statistics node
+ @Description   structure for retrieving fragmentation statistics
 *//***************************************************************************/
-typedef struct t_FmPcdStatsParams {
-    e_FmPcdStatsType        type; /**< type of statistics node */
-} t_FmPcdStatsParams;
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+typedef struct t_FmPcdManipFragStats {
+    union {
+        t_FmPcdManipFragIpStats     ipFrag;     /**< Structure for IP fragmentation statistics */
+    } u;
+} t_FmPcdManipFragStats;
 
+/**************************************************************************//**
+ @Description   structure for defining manipulation statistics
+*//***************************************************************************/
+typedef struct t_FmPcdManipStats {
+    union{
+        t_FmPcdManipReassemStats    reassem;    /**< Structure for reassembly statistics */
+        t_FmPcdManipFragStats       frag;       /**< Structure for fragmentation statistics */
+    } u;
+} t_FmPcdManipStats;
 
+#if DPAA_VERSION >= 3
 /**************************************************************************//**
- @Function      FM_PCD_SetNetEnvCharacteristics
+ @Description   Parameters for defining frame replicator group and its members
+*//***************************************************************************/
+typedef struct t_FmPcdFrmReplicGroupParams {
+    uint8_t                     maxNumOfEntries;    /**< Maximal number of members in the group  - must be at least two */
+    uint8_t                     numOfEntries;       /**< Number of members in the group - must be at least 1 */
+    t_FmPcdCcNextEngineParams   nextEngineParams[FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
+                                                    /**< Array of members' parameters */
+} t_FmPcdFrmReplicGroupParams;
+#endif /* DPAA_VERSION >= 3 */
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_NetEnvCharacteristicsSet
 
  @Description   Define a set of Network Environment Characteristics.
+
                 When setting an environment it is important to understand its
                 application. It is not meant to describe the flows that will run
                 on the ports using this environment, but what the user means TO DO
                 with the PCD mechanisms in order to parse-classify-distribute those
                 frames.
                 By specifying a distinction unit, the user means it would use that option
-                for distinction between frames at either a keygen scheme keygen or a coarse
+                for distinction between frames at either a KeyGen scheme or a coarse
                 classification action descriptor. Using interchangeable headers to define a
                 unit means that the user is indifferent to which of the interchangeable
-                headers is present in the frame, and they want the distinction to be based
+                headers is present in the frame, and wants the distinction to be based
                 on the presence of either one of them.
+
                 Depending on context, there are limitations to the use of environments. A
                 port using the PCD functionality is bound to an environment. Some or even
                 all ports may share an environment but also an environment per port is
@@ -1830,6 +2158,7 @@ typedef struct t_FmPcdStatsParams {
                 stated and related to. When a port is bound to a scheme, a classification
                 plan group, or a coarse classification tree, it MUST be bound to the same
                 environment.
+
                 The different PCD modules, may relate (for flows definition) ONLY on
                 distinction units as defined by their environment. When initializing a
                 scheme for example, it may not choose to select IPV4 as a match for
@@ -1837,6 +2166,7 @@ typedef struct t_FmPcdStatsParams {
                 fact, to guide the user through the configuration of the PCD, each module's
                 characterization in terms of flows is not done using protocol names, but using
                 environment indexes.
+
                 In terms of HW implementation, the list of distinction units sets the LCV vectors
                 and later used for match vector, classification plan vectors and coarse classification
                 indexing.
@@ -1849,153 +2179,182 @@ typedef struct t_FmPcdStatsParams {
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams *p_NetEnvParams);
+t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams *p_NetEnvParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_DeleteNetEnvCharacteristics
+ @Function      FM_PCD_NetEnvCharacteristicsDelete
 
  @Description   Deletes a set of Network Environment Characteristics.
 
- @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     h_NetEnv        A handle to the Network environment.
 
  @Return        E_OK on success; Error code otherwise.
 *//***************************************************************************/
-t_Error FM_PCD_DeleteNetEnvCharacteristics(t_Handle h_FmPcd, t_Handle h_NetEnv);
+t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv);
 
 /**************************************************************************//**
- @Function      FM_PCD_KgSetScheme
+ @Function      FM_PCD_KgSchemeSet
 
- @Description   Initializing or modifying and enabling a scheme for the keygen.
+ @Description   Initializing or modifying and enabling a scheme for the KeyGen.
                 This routine should be called for adding or modifying a scheme.
                 When a scheme needs modifying, the API requires that it will be
                 rewritten. In such a case 'modify' should be TRUE. If the
                 routine is called for a valid scheme and 'modify' is FALSE,
                 it will return error.
 
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in,out] p_Scheme        A structure of parameters for defining the scheme
+ @Param[in]     h_FmPcd         If this is a new scheme - A handle to an FM PCD Module.
+                                Otherwise NULL (ignored by driver).
+ @Param[in,out] p_SchemeParams  A structure of parameters for defining the scheme
 
  @Return        A handle to the initialized scheme on success; NULL code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle FM_PCD_KgSetScheme (t_Handle                h_FmPcd,
-                             t_FmPcdKgSchemeParams   *p_Scheme);
+t_Handle FM_PCD_KgSchemeSet(t_Handle                h_FmPcd,
+                            t_FmPcdKgSchemeParams   *p_SchemeParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_KgDeleteScheme
+ @Function      FM_PCD_KgSchemeDelete
 
  @Description   Deleting an initialized scheme.
 
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet()
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_Init().
+ @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
 *//***************************************************************************/
-t_Error     FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme);
+t_Error     FM_PCD_KgSchemeDelete(t_Handle h_Scheme);
 
 /**************************************************************************//**
- @Function      FM_PCD_KgGetSchemeCounter
+ @Function      FM_PCD_KgSchemeGetCounter
 
  @Description   Reads scheme packet counter.
 
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet().
 
  @Return        Counter's current value.
 
- @Cautions      Allowed only following FM_PCD_Init().
+ @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
 *//***************************************************************************/
-uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme);
+uint32_t  FM_PCD_KgSchemeGetCounter(t_Handle h_Scheme);
 
 /**************************************************************************//**
- @Function      FM_PCD_KgSetSchemeCounter
+ @Function      FM_PCD_KgSchemeSetCounter
 
  @Description   Writes scheme packet counter.
 
- @Param[in]     h_FmPcd         FM PCD module descriptor.
- @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme.
+ @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSchemeSet().
  @Param[in]     value           New scheme counter value - typically '0' for
                                 resetting the counter.
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_Init().
+ @Cautions      Allowed only following FM_PCD_Init() & FM_PCD_KgSchemeSet().
 *//***************************************************************************/
-t_Error  FM_PCD_KgSetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t value);
+t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcBuildTree
+ @Function      FM_PCD_PlcrProfileSet
 
- @Description   This routine must be called to define a complete coarse
-                classification tree. This is the way to define coarse
-                classification to a certain flow - the keygen schemes
-                may point only to trees defined in this way.
+ @Description   Sets a profile entry in the policer profile table.
+                The routine overrides any existing value.
 
- @Param[in]     h_FmPcd                 FM PCD module descriptor.
- @Param[in]     p_FmPcdCcTreeParams     A structure of parameters to define the tree.
+ @Param[in]     h_FmPcd           A handle to an FM PCD Module.
+ @Param[in]     p_Profile         A structure of parameters for defining a
+                                  policer profile entry.
 
  @Return        A handle to the initialized object on success; NULL code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle FM_PCD_CcBuildTree (t_Handle             h_FmPcd,
-                             t_FmPcdCcTreeParams  *p_FmPcdCcTreeParams);
+t_Handle FM_PCD_PlcrProfileSet(t_Handle                  h_FmPcd,
+                               t_FmPcdPlcrProfileParams  *p_Profile);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcDeleteTree
+ @Function      FM_PCD_PlcrProfileDelete
 
- @Description   Deleting an built tree.
+ @Description   Delete a profile entry in the policer profile table.
+                The routine set entry to invalid.
 
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     h_CcTree        A handle to a CC tree.
+ @Param[in]     h_Profile       A handle to the profile.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree);
+t_Error FM_PCD_PlcrProfileDelete(t_Handle h_Profile);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcSetNode
+ @Function      FM_PCD_PlcrProfileGetCounter
 
- @Description   This routine should be called for each CC (coarse classification)
-                node. The whole CC tree should be built bottom up so that each
-                node points to already defined nodes.
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
 
- @Param[in]     h_FmPcd             FM PCD module descriptor.
- @Param[in]     p_CcNodeParam       A structure of parameters defining the CC node
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter         Counter selector.
+
+ @Return        specific counter value.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+uint32_t FM_PCD_PlcrProfileGetCounter(t_Handle                      h_Profile,
+                                      e_FmPcdPlcrProfileCounters    counter);
+
+/**************************************************************************//**
+ @Function      FM_PCD_PlcrProfileSetCounter
+
+ @Description   Sets an entry in the classification plan.
+                The routine overrides any existing value.
+
+ @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     counter         Counter selector.
+ @Param[in]     value           value to set counter with.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_PlcrProfileSetCounter(t_Handle                   h_Profile,
+                                     e_FmPcdPlcrProfileCounters counter,
+                                     uint32_t                   value);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcRoot
+
+ @Description   This routine must be called to define a complete coarse
+                classification tree. This is the way to define coarse
+                classification to a certain flow - the KeyGen schemes
+                may point only to trees defined in this way.
+
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     p_Params        A structure of parameters to define the tree.
 
  @Return        A handle to the initialized object on success; NULL code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle   FM_PCD_CcSetNode(t_Handle             h_FmPcd,
-                            t_FmPcdCcNodeParams  *p_CcNodeParam);
+t_Handle FM_PCD_CcRootBuild (t_Handle             h_FmPcd,
+                             t_FmPcdCcTreeParams  *p_Params);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcDeleteNode
+ @Function      FM_PCD_CcRootDelete
 
- @Description   Deleting an built node.
+ @Description   Deleting an built tree.
 
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     h_CcNode        A handle to a CC node.
+ @Param[in]     h_CcTree        A handle to a CC tree.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode);
+t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcTreeModifyNextEngine
+ @Function      FM_PCD_CcRootModifyNextEngine
 
  @Description   Modify the Next Engine Parameters in the entry of the tree.
 
- @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcTree                    A handle to the tree
  @Param[in]     grpId                       A Group index in the tree
  @Param[in]     index                       Entry index in the group defined by grpId
@@ -2005,95 +2364,119 @@ t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode);
 
  @Cautions      Allowed only following FM_PCD_CcBuildTree().
 *//***************************************************************************/
-t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle                  h_FmPcd,
-                                      t_Handle                  h_CcTree,
+t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
                                       uint8_t                   grpId,
                                       uint8_t                   index,
                                       t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcNodeModifyNextEngine
+ @Function      FM_PCD_EmSetNode
 
- @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
+ @Description   This routine should be called for each CC (coarse classification)
+                node. The whole CC tree should be built bottom up so that each
+                node points to already defined nodes.
 
- @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keyIndex                    Key index for Next Engine Params modifications
- @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+ @Param[in]     h_FmPcd         FM PCD module descriptor.
+ @Param[in]     p_Param         A structure of parameters defining the CC node
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Handle   FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams  *p_Param);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableDelete
+
+ @Description   Deleting an built node.
+
+ @Param[in]     h_CcNode        A handle to a CC node.
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode().
+ @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle                  h_FmPcd,
-                                      t_Handle                  h_CcNode,
-                                      uint16_t                  keyIndex,
-                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcNodeModifyMissNextEngine
+ @Function      FM_PCD_MatchTableModifyMissNextEngine
 
  @Description   Modify the Next Engine Parameters of the Miss key case of the node.
 
- @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine params
+ @Param[in]     p_FmPcdCcNextEngineParams   Parameters for defining next engine
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode().
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle                  h_FmPcd,
-                                          t_Handle                  h_CcNode,
-                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error FM_PCD_MatchTableModifyMissNextEngine(t_Handle                  h_CcNode,
+                                              t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcNodeRemoveKey
+ @Function      FM_PCD_MatchTableRemoveKey
 
- @Description   Remove the key (include Next Engine Parameters of this key) defined by the index of the relevant node .
+ @Description   Remove the key (including next engine parameters of this key)
+                defined by the index of the relevant node.
 
- @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcNode                    A handle to the node
  @Param[in]     keyIndex                    Key index for removing
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
-                relevant node but also the node that points to this node
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex);
+t_Error FM_PCD_MatchTableRemoveKey(t_Handle h_CcNode, uint16_t keyIndex);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcNodeAddKey
+ @Function      FM_PCD_MatchTableAddKey
 
- @Description   Add the key(include Next Engine Parameters of this key in the
-                index defined by the keyIndex.
+ @Description   Add the key (including next engine parameters of this key in the
+                index defined by the keyIndex. Note that 'FM_PCD_LAST_KEY_INDEX'
+                may be used by user that don't care about the position of the
+                key in the table - in that case, the key will be automatically
+                add by the driver in the last available entry.
+
+ @Param[in]     h_CcNode     A handle to the node
+ @Param[in]     keyIndex     Key index for adding.
+ @Param[in]     keySize      Key size of added key
+ @Param[in]     p_KeyParams  A pointer to the parameters includes
+                             new key with Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableAddKey(t_Handle            h_CcNode,
+                                uint16_t            keyIndex,
+                                uint8_t             keySize,
+                                t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableModifyNextEngine
+
+ @Description   Modify the Next Engine Parameters in the relevant key entry of the node.
 
- @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keyIndex                    Key index for adding
- @Param[in]     keySize                     Key size of added key
- @Param[in]     p_KeyParams                 A pointer to the parameters includes
-                                            new key with Next Engine Parameters
+ @Param[in]     keyIndex                    Key index for Next Engine modifications
+ @Param[in]     p_FmPcdCcNextEngineParams   Parameters for defining next engine
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
-                relevant node but also the node that points to this node
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeAddKey(t_Handle            h_FmPcd,
-                            t_Handle            h_CcNode,
-                            uint16_t            keyIndex,
-                            uint8_t             keySize,
-                            t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error FM_PCD_MatchTableModifyNextEngine(t_Handle                  h_CcNode,
+                                          uint16_t                  keyIndex,
+                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcNodeModifyKeyAndNextEngine
+ @Function      FM_PCD_MatchTableModifyKeyAndNextEngine
 
  @Description   Modify the key and Next Engine Parameters of this key in the
                 index defined by the keyIndex.
 
- @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcNode                    A handle to the node
  @Param[in]     keyIndex                    Key index for adding
  @Param[in]     keySize                     Key size of added key
@@ -2102,21 +2485,19 @@ t_Error FM_PCD_CcNodeAddKey(t_Handle            h_FmPcd,
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
-                relevant node but also the node that points to this node
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle            h_FmPcd,
-                                            t_Handle            h_CcNode,
-                                            uint16_t            keyIndex,
-                                            uint8_t             keySize,
-                                            t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error FM_PCD_MatchTableModifyKeyAndNextEngine(t_Handle            h_CcNode,
+                                                uint16_t            keyIndex,
+                                                uint8_t             keySize,
+                                                t_FmPcdCcKeyParams  *p_KeyParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcNodeModifyKey
+ @Function      FM_PCD_MatchTableModifyKey
 
  @Description   Modify the key  in the index defined by the keyIndex.
 
- @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcNode                    A handle to the node
  @Param[in]     keyIndex                    Key index for adding
  @Param[in]     keySize                     Key size of added key
@@ -2126,160 +2507,319 @@ t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle            h_FmPcd,
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
-                relevant node but also the node that points to this node
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd,
-                               t_Handle h_CcNode,
-                               uint16_t keyIndex,
-                               uint8_t  keySize,
-                               uint8_t  *p_Key,
-                               uint8_t  *p_Mask);
+t_Error FM_PCD_MatchTableModifyKey(t_Handle h_CcNode,
+                                   uint16_t keyIndex,
+                                   uint8_t  keySize,
+                                   uint8_t  *p_Key,
+                                   uint8_t  *p_Mask);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcIndexedHashNodeGetBucket
+ @Function      FM_PCD_MatchTableFindNRemoveKey
 
- @Description   TODO
+ @Description   Remove the key (including next engine parameters of this key)
+                defined by the key and mask. Note that this routine will search
+                the node to locate the index of the required key (& mask) to remove.
 
- @Param[in]     h_FmPcd                 A handle to an FM PCD Module.
- @Param[in]     h_CcNode                A handle to the node
- @Param[in]     kgKeySize               Key size as it was configured in the KG
-                                        scheme that leads to this hash.
- @Param[in]     p_KgKey                 Pointer to the key; must be like the key
-                                        that the KG is generated, i.e. the same
-                                        extraction and with mask if exist.
- @Param[in]     kgHashShift             hash-shift as it was configured in the KG
-                                        scheme that leads to this hash.
- @Param[out]    p_CcNodeBucketHandle    Pointer to retrieve the bucket.
- @Param[out]    p_BucketIndex           TODO
- @Param[out]    p_LastIndex             Pointer to retrieve the last index in the bucket.
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keySize                     Key size of the one to remove.
+ @Param[in]     p_Key                       A pointer to the requested key to remove.
+ @Param[in]     p_Mask                      A pointer to the mask if relevant,
+                                            otherwise pointer to NULL
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
-                relevant node but also the node that points to this node
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
 *//***************************************************************************/
-t_Error FM_PCD_CcIndexedHashNodeGetBucket(t_Handle    h_FmPcd,
-                                          t_Handle    h_CcNode,
-                                          uint8_t     kgKeySize,
-                                          uint8_t     *p_KgKey,
-                                          uint8_t     kgHashShift,
-                                          t_Handle    *p_CcNodeBucketHandle,
-                                          uint8_t     *p_BucketIndex,
-                                          uint16_t    *p_LastIndex);
+t_Error FM_PCD_MatchTableFindNRemoveKey(t_Handle h_CcNode,
+                                        uint8_t  keySize,
+                                        uint8_t  *p_Key,
+                                        uint8_t  *p_Mask);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcNodeGetNextEngine
+ @Function      FM_PCD_MatchTableFindNModifyNextEngine
 
- @Description   Gets NextEngine of the relevant keyIndex.
+ @Description   Modify the Next Engine Parameters in the relevant key entry of
+                the node. Note that this routine will search the node to locate
+                the index of the required key (& mask) to modify.
 
- @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
- @Param[in]     h_CcNode                    Cc Node.
- @Param[in]     keyIndex                    keyIndex in the releavnt node.
- @Param[out]    p_FmPcdCcNextEngineParams   here updated nextEngine parameters for
-                                            the relevant keyIndex of the Cc Node
-                                            received as parameter to this function
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keySize                     Key size of the one to modify.
+ @Param[in]     p_Key                       A pointer to the requested key to modify.
+ @Param[in]     p_Mask                      A pointer to the mask if relevant,
+                                            otherwise pointer to NULL
+ @Param[in]     p_FmPcdCcNextEngineParams   Parameters for defining next engine
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_Init().
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeGetNextEngine(t_Handle                     h_FmPcd,
-                                   t_Handle                     h_CcNode,
-                                   uint16_t                     keyIndex,
-                                   t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
+t_Error FM_PCD_MatchTableFindNModifyNextEngine(t_Handle                  h_CcNode,
+                                               uint8_t                   keySize,
+                                               uint8_t                   *p_Key,
+                                               uint8_t                   *p_Mask,
+                                               t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_CcNodeGetKeyCounter
+ @Function      FM_PCD_MatchTableFindNModifyKeyAndNextEngine
+
+ @Description   Modify the key and Next Engine Parameters of this key in the
+                index defined by the keyIndex. Note that this routine will search
+                the node to locate the index of the required key (& mask) to modify.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keySize                     Key size of the one to modify.
+ @Param[in]     p_Key                       A pointer to the requested key to modify.
+ @Param[in]     p_Mask                      A pointer to the mask if relevant,
+                                            otherwise pointer to NULL
+ @Param[in]     p_KeyParams                 A pointer to the parameters includes
+                                            modified key and modified Next Engine Parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableFindNModifyKeyAndNextEngine(t_Handle            h_CcNode,
+                                                     uint8_t             keySize,
+                                                     uint8_t             *p_Key,
+                                                     uint8_t             *p_Mask,
+                                                     t_FmPcdCcKeyParams  *p_KeyParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableFindNModifyKey
+
+ @Description   Modify the key  in the index defined by the keyIndex. Note that
+                this routine will search the node to locate the index of the
+                required key (& mask) to modify.
+
+ @Param[in]     h_CcNode                    A handle to the node
+ @Param[in]     keySize                     Key size of the one to modify.
+ @Param[in]     p_Key                       A pointer to the requested key to modify.
+ @Param[in]     p_Mask                      A pointer to the mask if relevant,
+                                            otherwise pointer to NULL
+ @Param[in]     p_NewKey                    A pointer to the new key
+ @Param[in]     p_NewMask                   A pointer to the new mask if relevant,
+                                            otherwise pointer to NULL
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_MatchTableSet() was called for this
+                node and the nodes that lead to it.
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableFindNModifyKey(t_Handle h_CcNode,
+                                        uint8_t  keySize,
+                                        uint8_t  *p_Key,
+                                        uint8_t  *p_Mask,
+                                        uint8_t  *p_NewKey,
+                                        uint8_t  *p_NewMask);
+
+/**************************************************************************//**
+ @Function      FM_PCD_MatchTableGetKeyCounter
 
  @Description   This routine may be used to get a counter of specific key in a CC
                 Node; This counter reflects how many frames passed that were matched
                 this key.
 
- @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
- @Param[in]     h_CcNode                    A handle to the node
- @Param[in]     keyIndex                    Key index for adding
+ @Param[in]     h_CcNode        A handle to the node
+ @Param[in]     keyIndex        Key index for adding
 
  @Return        The specific key counter.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
-                relevant node but also the node that points to this node
+ @Cautions      Allowed only following FM_PCD_MatchTableSet().
 *//***************************************************************************/
-uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex);
+uint32_t FM_PCD_MatchTableGetKeyCounter(t_Handle h_CcNode, uint16_t keyIndex);
 
-/**************************************************************************//**
- @Function      FM_PCD_PlcrSetProfile
+/**************************************************************************//*
+ @Function      FM_PCD_MatchTableGetNextEngine
 
- @Description   Sets a profile entry in the policer profile table.
-                The routine overrides any existing value.
+ @Description   Gets NextEngine of the relevant keyIndex.
 
- @Param[in]     h_FmPcd           A handle to an FM PCD Module.
- @Param[in]     p_Profile         A structure of parameters for defining a
-                                  policer profile entry.
+ @Param[in]     h_CcNode                    A handle to the node.
+ @Param[in]     keyIndex                    keyIndex in the relevant node.
+ @Param[out]    p_FmPcdCcNextEngineParams   here updated nextEngine parameters for
+                                            the relevant keyIndex of the CC Node
+                                            received as parameter to this function
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
+                                       uint16_t                     keyIndex,
+                                       t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//*
+ @Function      FM_PCD_MatchTableGetIndexedHashBucket
+
+ @Description   This routine simulates KeyGen operation on the provided key and
+                calculates to which hash bucket it will be mapped.
+
+ @Param[in]     h_CcNode                A handle to the node.
+ @Param[in]     kgKeySize               Key size as it was configured in the KG
+                                        scheme that leads to this hash.
+ @Param[in]     p_KgKey                 Pointer to the key; must be like the key
+                                        that the KG is generated, i.e. the same
+                                        extraction and with mask if exist.
+ @Param[in]     kgHashShift             Hash-shift as it was configured in the KG
+                                        scheme that leads to this hash.
+ @Param[out]    p_CcNodeBucketHandle    Pointer to the bucket of the provided key.
+ @Param[out]    p_BucketIndex           Index to the bucket of the provided key
+ @Param[out]    p_LastIndex             Pointer to last index in the bucket of the
+                                        provided key.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet()
+*//***************************************************************************/
+t_Error FM_PCD_MatchTableGetIndexedHashBucket(t_Handle    h_CcNode,
+                                              uint8_t     kgKeySize,
+                                              uint8_t     *p_KgKey,
+                                              uint8_t     kgHashShift,
+                                              t_Handle    *p_CcNodeBucketHandle,
+                                              uint8_t     *p_BucketIndex,
+                                              uint16_t    *p_LastIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableSet
+
+ @Description   This routine initializes a hash table structure.
+                KeyGen hash result determines the hash bucket.
+                Next, KeyGen key is compared against all keys of this
+                bucket (exact match).
+                Number of sets (number of buckets) of the hash equals to the
+                number of 1-s in 'hashResMask' in the provided parameters.
+                Number of hash table ways is then calculated by dividing
+                'maxNumOfKeys' equally between the hash sets. This is the maximal
+                number of keys that a hash bucket may hold.
+                The hash table is initialized empty and keys may be
+                added to it following the initialization. Keys masks are not
+                supported in current hash table implementation.
+                The initialized hash table can be integrated as a node in a
+                CC tree.
+
+ @Param[in]     h_FmPcd     FM PCD module descriptor.
+ @Param[in]     p_Param     A structure of parameters defining the hash table
 
  @Return        A handle to the initialized object on success; NULL code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle FM_PCD_PlcrSetProfile(t_Handle                  h_FmPcd,
-                               t_FmPcdPlcrProfileParams  *p_Profile);
+t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param);
 
 /**************************************************************************//**
- @Function      FM_PCD_PlcrDeleteProfile
+ @Function      FM_PCD_HashTableDelete
 
- @Description   Delete a profile entry in the policer profile table.
-                The routine set entry to invalid.
+ @Description   This routine deletes the provided hash table and released all
+                its allocated resources.
 
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     h_Profile       A handle to the profile.
+ @Param[in]     h_HashTbl       A handle to a hash table
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_Init().
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
 *//***************************************************************************/
-t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile);
+t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl);
 
 /**************************************************************************//**
- @Function      FM_PCD_PlcrGetProfileCounter
+ @Function      FM_PCD_HashTableAddKey
 
- @Description   Sets an entry in the classification plan.
-                The routine overrides any existing value.
+ @Description   This routine adds the provided key (including next engine
+                parameters of this key) to the hash table.
+                The key is added as the last key of the bucket that it is
+                mapped to.
 
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     h_Profile       A handle to the profile.
- @Param[in]     counter         Counter selector.
+ @Param[in]     h_HashTbl    A handle to a hash table
+ @Param[in]     keySize      Key size of added key
+ @Param[in]     p_KeyParams  A pointer to the parameters includes
+                             new key with next engine parameters; The pointer
+                             to the key mask must be NULL, as masks are not
+                             supported in hash table implementation.
 
- @Return        specific counter value.
+ @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_Init().
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
 *//***************************************************************************/
-uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle                      h_FmPcd,
-                                      t_Handle                      h_Profile,
-                                      e_FmPcdPlcrProfileCounters    counter);
+t_Error FM_PCD_HashTableAddKey(t_Handle            h_HashTbl,
+                               uint8_t             keySize,
+                               t_FmPcdCcKeyParams  *p_KeyParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_PlcrSetProfileCounter
+ @Function      FM_PCD_HashTableRemoveKey
 
- @Description   Sets an entry in the classification plan.
-                The routine overrides any existing value.
+ @Description   This routine removes the requested key (including next engine
+                parameters of this key) from the hash table.
 
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     h_Profile       A handle to the profile.
- @Param[in]     counter         Counter selector.
- @Param[in]     value           value to set counter with.
+ @Param[in]     h_HashTbl    A handle to a hash table
+ @Param[in]     keySize      Key size of the one to remove.
+ @Param[in]     p_Key        A pointer to the requested key to remove.
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_Init().
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
 *//***************************************************************************/
-t_Error FM_PCD_PlcrSetProfileCounter(t_Handle                   h_FmPcd,
-                                     t_Handle                   h_Profile,
-                                     e_FmPcdPlcrProfileCounters counter,
-                                     uint32_t                   value);
+t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
+                                  uint8_t  keySize,
+                                  uint8_t  *p_Key);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableModifyNextEngine
+
+ @Description   This routine modifies the next engine for the provided key. The
+                key should be previously added to the hash table.
+
+ @Param[in]     h_HashTbl                   A handle to a hash table
+ @Param[in]     keySize                     Key size of the key to modify.
+ @Param[in]     p_Key                       A pointer to the requested key to modify.
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine
+                                            parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableModifyNextEngine(t_Handle                  h_HashTbl,
+                                         uint8_t                   keySize,
+                                         uint8_t                   *p_Key,
+                                         t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_HashTableModifyMissNextEngine
+
+ @Description   This routine modifies the next engine on key match miss.
+
+ @Param[in]     h_HashTbl                   A handle to a hash table
+ @Param[in]     p_FmPcdCcNextEngineParams   A structure for defining new next engine
+                                            parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableModifyMissNextEngine(t_Handle                  h_HashTbl,
+                                             t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+
+/**************************************************************************//*
+ @Function      FM_PCD_HashTableGetMissNextEngine
+
+ @Description   Gets NextEngine in case of key match miss.
+
+ @Param[in]     h_HashTbl                   A handle to a hash table
+ @Param[out]    p_FmPcdCcNextEngineParams   Next engine parameters for the specified
+                                            hash table.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+t_Error FM_PCD_HashTableGetMissNextEngine(t_Handle                     h_HashTbl,
+                                          t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
 
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
- @Function      FM_PCD_ManipSetNode
+ @Function      FM_PCD_ManipNodeSet
 
  @Description   This routine should be called for defining a manipulation
                 node. A manipulation node must be defined before the CC node
@@ -2292,29 +2832,109 @@ t_Error FM_PCD_PlcrSetProfileCounter(t_Handle                   h_FmPcd,
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_FmPcdManipParams);
+t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_FmPcdManipParams);
 
 /**************************************************************************//**
- @Function      FM_PCD_ManipDeleteNode
+ @Function      FM_PCD_ManipNodeDelete
 
- @Description   Delete an existing manip node.
+ @Description   Delete an existing manipulation node.
 
- @Param[in]     h_FmPcd         A handle to an FM PCD Module.
- @Param[in]     h_HdrManipNode  A handle to a Manip node.
+ @Param[in]     h_ManipNode     A handle to a manipulation node.
 
  @Return        E_OK on success; Error code otherwise.
 
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+t_Error  FM_PCD_ManipNodeDelete(t_Handle h_ManipNode);
+
+/**************************************************************************//**
+ @Function      FM_PCD_ManipGetStatistics
+
+ @Description   Retrieve the manipulation statistics.
+
+ @Param[in]     h_ManipNode         A handle to a manipulation node.
+ @Param[out]    p_FmPcdManipStats   A structure for retrieving the manipulation statistics
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_ManipNodeSet().
+*//***************************************************************************/
+t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmPcdManipStats);
+
+#if DPAA_VERSION >= 3
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicSetGroup
+
+ @Description   Initialize a Frame Replicator group.
+
+ @Param[in]     h_FmPcd                FM PCD module descriptor.
+ @Param[in]     p_FrmReplicGroupParam  A structure of parameters for the initialization of
+                                       the frame replicator group.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Error  FM_PCD_ManipDeleteNode(t_Handle h_FmPcd, t_Handle h_HdrManipNode);
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+t_Handle FM_PCD_FrmReplicSetGroup(t_Handle h_FmPcd, t_FmPcdFrmReplicGroupParams *p_FrmReplicGroupParam);
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicDeleteGroup
+
+ @Description   Delete a Frame Replicator group.
+
+ @Param[in]     h_FrmReplicGroup  A handle to the frame replicator group.
+
+ @Return        E_OK on success;  Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup().
+*//***************************************************************************/
+t_Error FM_PCD_FrmReplicDeleteGroup(t_Handle h_FrmReplicGroup);
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicAddMember
+
+ @Description   Add the member in the index defined by the memberIndex.
+
+ @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]     memberIndex        member index for adding.
+ @Param[in]     p_MemberParams     A pointer to the new member parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+t_Error FM_PCD_FrmReplicAddMember(t_Handle                   h_FrmReplicGroup,
+                                  uint16_t                   memberIndex,
+                                  t_FmPcdCcNextEngineParams *p_MemberParams);
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicRemoveMember
+
+ @Description   Remove the member defined by the index from the relevant group.
+
+ @Param[in]     h_FrmReplicGroup   A handle to the frame replicator group.
+ @Param[in]     memberIndex        member index for removing.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup() of this group.
+*//***************************************************************************/
+t_Error FM_PCD_FrmReplicRemoveMember(t_Handle h_FrmReplicGroup,
+                                     uint16_t memberIndex);
+#endif /* DPAA_VERSION >= 3 */
 
 #ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
+ @Description   structure for defining statistics node
+*//***************************************************************************/
+typedef struct t_FmPcdStatsParams {
+    e_FmPcdStatsType    type;   /**< type of statistics node */
+} t_FmPcdStatsParams;
+
+/**************************************************************************//**
  @Function      FM_PCD_StatisticsSetNode
 
- @Description   This routine should be called for defining a statistics
-                node.
+ @Description   This routine should be called for defining a statistics node.
 
  @Param[in]     h_FmPcd             FM PCD module descriptor.
  @Param[in]     p_FmPcdstatsParams  A structure of parameters defining the statistics
@@ -2326,11 +2946,71 @@ t_Error  FM_PCD_ManipDeleteNode(t_Handle h_FmPcd, t_Handle h_HdrManipNode);
 t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcdstatsParams);
 #endif /* FM_CAPWAP_SUPPORT */
 
-/** @} */ /* end of FM_PCD_Runtime_tree_buildgrp group */
+/** @} */ /* end of FM_PCD_Runtime_build_grp group */
 /** @} */ /* end of FM_PCD_Runtime_grp group */
 /** @} */ /* end of FM_PCD_grp group */
 /** @} */ /* end of FM_grp group */
 
 
+#define NCSW_BACKWARD_COMPATIBLE_API
+#ifdef NCSW_BACKWARD_COMPATIBLE_API
+#define FM_PCD_SetNetEnvCharacteristics(_pcd, _params)  \
+    FM_PCD_NetEnvCharacteristicsSet(_pcd, _params)
+#define FM_PCD_KgSetScheme(_pcd, _params)       FM_PCD_KgSchemeSet(_pcd, _params)
+#define FM_PCD_CcBuildTree(_pcd, _params)       FM_PCD_CcRootBuild(_pcd, _params)
+#define FM_PCD_CcSetNode(_pcd, _params)         FM_PCD_MatchTableSet(_pcd, _params)
+#define FM_PCD_PlcrSetProfile(_pcd, _params)    FM_PCD_PlcrProfileSet(_pcd, _params)
+#define FM_PCD_ManipSetNode(_pcd, _params)      FM_PCD_ManipNodeSet(_pcd, _params)
+
+#define FM_PCD_DeleteNetEnvCharacteristics(_pcd, ...)   \
+    FM_PCD_NetEnvCharacteristicsDelete(__VA_ARGS__)
+#define FM_PCD_KgDeleteScheme(_pcd, ...)   \
+    FM_PCD_KgSchemeDelete(__VA_ARGS__)
+#define FM_PCD_KgGetSchemeCounter(_pcd, ...)   \
+    FM_PCD_KgSchemeGetCounter(__VA_ARGS__)
+#define FM_PCD_KgSetSchemeCounter(_pcd, ...)   \
+    FM_PCD_KgSchemeSetCounter(__VA_ARGS__)
+#define FM_PCD_PlcrDeleteProfile(_pcd, ...)   \
+    FM_PCD_PlcrProfileDelete(__VA_ARGS__)
+#define FM_PCD_PlcrGetProfileCounter(_pcd, ...)   \
+    FM_PCD_PlcrProfileGetCounter(__VA_ARGS__)
+#define FM_PCD_PlcrSetProfileCounter(_pcd, ...)   \
+    FM_PCD_PlcrProfileSetCounter(__VA_ARGS__)
+#define FM_PCD_CcDeleteTree(_pcd, ...)   \
+    FM_PCD_CcRootDelete(__VA_ARGS__)
+#define FM_PCD_CcTreeModifyNextEngine(_pcd, ...)   \
+    FM_PCD_CcRootModifyNextEngine(__VA_ARGS__)
+#define FM_PCD_CcDeleteNode(_pcd, ...)   \
+    FM_PCD_MatchTableDelete(__VA_ARGS__)
+#define FM_PCD_CcNodeModifyMissNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableModifyMissNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeRemoveKey(_pcd, ...)   \
+    FM_PCD_MatchTableRemoveKey(__VA_ARGS__)
+#define FM_PCD_CcNodeAddKey(_pcd, ...)   \
+    FM_PCD_MatchTableAddKey(__VA_ARGS__)
+#define FM_PCD_CcNodeModifyNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableModifyNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeModifyKeyAndNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableModifyKeyAndNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeModifyKey(_pcd, ...)   \
+    FM_PCD_MatchTableModifyKey(__VA_ARGS__)
+#define FM_PCD_CcNodeFindNRemoveKey(_pcd, ...)   \
+    FM_PCD_MatchTableFindNRemoveKey(__VA_ARGS__)
+#define FM_PCD_CcNodeFindNModifyNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableFindNModifyNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeFindNModifyKeyAndNextEngine(_pcd, ...) \
+    FM_PCD_MatchTableFindNModifyKeyAndNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeFindNModifyKey(_pcd, ...)   \
+    FM_PCD_MatchTableFindNModifyKey(__VA_ARGS__)
+#define FM_PCD_CcIndexedHashNodeGetBucket(_pcd, ...)   \
+    FM_PCD_MatchTableGetIndexedHashBucket(__VA_ARGS__)
+#define FM_PCD_CcNodeGetNextEngine(_pcd, ...)   \
+    FM_PCD_MatchTableGetNextEngine(__VA_ARGS__)
+#define FM_PCD_CcNodeGetKeyCounter(_pcd, ...)   \
+    FM_PCD_MatchTableGetKeyCounter(__VA_ARGS__)
+#define FM_PCD_ManipDeleteNode(_pcd, ...)   \
+    FM_PCD_ManipNodeDelete(__VA_ARGS__)
+#endif /* NCSW_BACKWARD_COMPATIBLE_API */
+
 
 #endif /* __FM_PCD_EXT */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 443286c..2aed870 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -60,21 +60,18 @@
  @Description   FM Port API
 
                 The FM uses a general module called "port" to represent a Tx port
-                (MAC), an Rx port (MAC), offline parsing flow or host command
-                flow. There may be up to 17 (may change) ports in an FM - 5 Tx
-                ports (4 for the 1G MACs, 1 for the 10G MAC), 5 Rx Ports, and 7
-                Host command/Offline parsing ports. The SW driver manages these
-                ports as sub-modules of the FM, i.e. after an FM is initialized,
-                its ports may be initialized and operated upon.
+                (MAC), an Rx port (MAC) or Offline Parsing port.
+                The number of ports in an FM varies between SOC's.
+                The SW driver manages these ports as sub-modules of the FM, i.e.
+                after an FM is initialized, its ports may be initialized and
+                operated upon.
 
                 The port is initialized aware of its type, but other functions on
                 a port may be indifferent to its type. When necessary, the driver
-                verifies coherency and returns error if applicable.
+                verifies coherence and returns error if applicable.
 
                 On initialization, user specifies the port type and it's index
-                (relative to the port's type). Host command and Offline parsing
-                ports share the same id range, I.e user may not initialized host
-                command port 0 and offline parsing port 0.
+                (relative to the port's type) - always starting at 0.
 
  @{
 *//***************************************************************************/
@@ -85,6 +82,11 @@
                 all engines have to be used, but all have to be enabled. The real
                 flow of a specific frame depends on the PCD configuration and the
                 frame headers and payload.
+                Note: the first engine and the first engine after the parser (if
+                exists) should be in order, the order is important as it will
+                define the flow of the port. However, as for the rest engines
+                (the ones that follows), the order is not important anymore as
+                it is defined by the PCD graph itself.
 *//***************************************************************************/
 typedef enum e_FmPortPcdSupport {
       e_FM_PORT_PCD_SUPPORT_NONE = 0                /**< BMI to BMI, PCD is not used */
@@ -96,9 +98,7 @@ typedef enum e_FmPortPcdSupport {
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
                                                     /**< Use all PCD engines */
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
-#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
     , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
-#endif /* defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
 #ifdef FM_CAPWAP_SUPPORT
     , e_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
     , e_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
@@ -132,10 +132,9 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 #define FM_PORT_FRM_ERR_NON_FM                          0x00400000  /**< non Frame-Manager error; probably come from SEC that
                                                                          was chained to FM */
 #endif /* FM_DISABLE_SEC_ERRORS */
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+
 #define FM_PORT_FRM_ERR_IPRE                            0x00200000
 #define FM_PORT_FRM_ERR_IPFE                            0x00100000
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
 #ifdef FM_CAPWAP_SUPPORT
 #define FM_PORT_FRM_ERR_CRE                             0x00200000
@@ -222,49 +221,30 @@ typedef void (t_FmPortImTxConfCallback) (t_Handle   h_App,
                                          t_Handle   h_BufContext);
 
 /**************************************************************************//**
- @Description   A structure of information about each of the external
-                buffer pools used by the port,
-*//***************************************************************************/
-typedef struct t_FmPortExtPoolParams {
-    uint8_t                 id;                 /**< External buffer pool id */
-    uint16_t                size;               /**< External buffer pool buffer size */
-} t_FmPortExtPoolParams;
-
-/**************************************************************************//**
- @Description   A structure for informing the driver about the external
-                buffer pools allocated in the BM and used by this port.
-*//***************************************************************************/
-typedef struct t_FmPortExtPools {
-    uint8_t                 numOfPoolsUsed;     /**< Number of pools use by this port */
-    t_FmPortExtPoolParams   extBufPool[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-                                                /**< Parameters for each port */
-} t_FmPortExtPools;
-
-/**************************************************************************//**
- @Description   structure for additional Rx port parameters
+ @Description   A structure for additional Rx port parameters
 *//***************************************************************************/
 typedef struct t_FmPortRxParams {
     uint32_t                errFqid;            /**< Error Queue Id. */
     uint32_t                dfltFqid;           /**< Default Queue Id.  */
     uint16_t                liodnOffset;        /**< Port's LIODN offset. */
-    t_FmPortExtPools        extBufPools;        /**< Which external buffer pools are used
+    t_FmExtPools            extBufPools;        /**< Which external buffer pools are used
                                                      (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes. */
 } t_FmPortRxParams;
 
 /**************************************************************************//**
- @Description   structure for additional non-Rx port parameters
+ @Description   A structure for additional non-Rx port parameters
 *//***************************************************************************/
 typedef struct t_FmPortNonRxParams {
     uint32_t                errFqid;            /**< Error Queue Id. */
-    uint32_t                dfltFqid;           /**< For Tx and HC - Default Confirmation queue,
+    uint32_t                dfltFqid;           /**< For Tx - Default Confirmation queue,
                                                      0 means no Tx confirmation for processed
-                                                     frames. For OP - default Rx queue. */
+                                                     frames. For OP port - default Rx queue. */
     uint32_t                qmChannel;          /**< QM-channel dedicated to this port; will be used
                                                      by the FM for dequeue. */
 } t_FmPortNonRxParams;
 
 /**************************************************************************//**
- @Description   structure for additional Rx port parameters
+ @Description   A structure for additional Rx port parameters
 *//***************************************************************************/
 typedef struct t_FmPortImRxTxParams {
     t_Handle                    h_FmMuram;          /**< A handle of the FM-MURAM partition */
@@ -277,7 +257,7 @@ typedef struct t_FmPortImRxTxParams {
 } t_FmPortImRxTxParams;
 
 /**************************************************************************//**
- @Description   Union for additional parameters depending on port type
+ @Description   A union for additional parameters depending on port type
 *//***************************************************************************/
 typedef union u_FmPortSpecificParams {
     t_FmPortImRxTxParams        imRxTxParams;       /**< Rx/Tx Independent-Mode port parameter structure */
@@ -286,7 +266,7 @@ typedef union u_FmPortSpecificParams {
 } u_FmPortSpecificParams;
 
 /**************************************************************************//**
- @Description   structure representing FM initialization parameters
+ @Description   A structure representing FM initialization parameters
 *//***************************************************************************/
 typedef struct t_FmPortParams {
     uintptr_t                   baseAddr;           /**< Virtual Address of memory mapped FM Port registers.*/
@@ -309,7 +289,7 @@ typedef struct t_FmPortParams {
 /**************************************************************************//**
  @Function      FM_PORT_Config
 
- @Description   Creates descriptor for the FM PORT module.
+ @Description   Creates a descriptor for the FM PORT module.
 
                 The routine returns a handle (descriptor) to the FM PORT object.
                 This descriptor must be passed as first parameter to all other
@@ -327,7 +307,8 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams);
 /**************************************************************************//**
  @Function      FM_PORT_Init
 
- @Description   Initializes the FM PORT module
+ @Description   Initializes the FM PORT module by defining the software structure
+                and configuring the hardware registers.
 
  @Param[in]     h_FmPort - FM PORT module descriptor
 
@@ -369,7 +350,6 @@ typedef enum e_FmPortDeqType {
                                          and override Intra-Class Scheduling */
 } e_FmPortDeqType;
 
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 /**************************************************************************//**
  @Description   enum for defining QM frame dequeue
 *//***************************************************************************/
@@ -382,26 +362,6 @@ typedef enum e_FmPortDeqPrefetchOption {
                                          no dedicated portId tnums are waiting. */
 
 } e_FmPortDeqPrefetchOption;
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
-
-/**************************************************************************//**
- @Description   enum for defining port DMA swap mode
-*//***************************************************************************/
-typedef enum e_FmPortDmaSwap {
-    e_FM_PORT_DMA_NO_SWP,           /**< No swap, transfer data as is.*/
-    e_FM_PORT_DMA_SWP_PPC_LE,       /**< The transferred data should be swapped
-                                         in PowerPc Little Endian mode. */
-    e_FM_PORT_DMA_SWP_BE            /**< The transferred data should be swapped
-                                         in Big Endian mode */
-} e_FmPortDmaSwap;
-
-/**************************************************************************//**
- @Description   enum for defining port DMA cache attributes
-*//***************************************************************************/
-typedef enum e_FmPortDmaCache {
-    e_FM_PORT_DMA_NO_STASH = 0,     /**< Cacheable, no Allocate (No Stashing) */
-    e_FM_PORT_DMA_STASH = 1         /**< Cacheable and Allocate (Stashing on) */
-} e_FmPortDmaCache;
 
 /**************************************************************************//**
  @Description   enum for defining port default color
@@ -414,7 +374,7 @@ typedef enum e_FmPortColor {
 } e_FmPortColor;
 
 /**************************************************************************//**
- @Description   struct for defining Dual Tx rate limiting scale
+ @Description   A structure for defining Dual Tx rate limiting scale
 *//***************************************************************************/
 typedef enum e_FmPortDualRateLimiterScaleDown {
     e_FM_PORT_DUAL_RATE_LIMITER_NONE = 0,           /**< Use only single rate limiter  */
@@ -425,7 +385,7 @@ typedef enum e_FmPortDualRateLimiterScaleDown {
 
 
 /**************************************************************************//**
- @Description   struct for defining FM port resources
+ @Description   A structure for defining FM port resources
 *//***************************************************************************/
 typedef struct t_FmPortRsrc {
     uint32_t    num;                /**< Committed required resource */
@@ -433,50 +393,32 @@ typedef struct t_FmPortRsrc {
 } t_FmPortRsrc;
 
 /**************************************************************************//**
- @Description   struct for defining pool depletion criteria
-*//***************************************************************************/
-typedef struct t_FmPortBufPoolDepletion {
-    bool        numberOfPoolsModeEnable;            /**< select mode in which pause frames will be sent after
-                                                         a number of pools are depleted */
-    uint8_t     numOfPools;                         /**< the minimum number of depleted pools that will
-                                                         invoke pause frames transmission. */
-    bool        poolsToConsider[BM_MAX_NUM_OF_POOLS];
-                                                    /**< For each pool, TRUE if it should be considered for
-                                                         depletion (Note - this pool must be used by this port!) */
-    bool        singlePoolModeEnable;               /**< select mode in which pause frames will be sent after
-                                                         a single of pools are depleted */
-    bool        poolsToConsiderForSingleMode[BM_MAX_NUM_OF_POOLS];
-                                                    /**< For each pool, TRUE if it should be considered for
-                                                         depletion (Note - this pool must be used by this port!) */
-} t_FmPortBufPoolDepletion;
-
-/**************************************************************************//**
- @Description   struct for defining observed pool depletion
+ @Description   A structure for defining observed pool depletion
 *//***************************************************************************/
 typedef struct t_FmPortObservedBufPoolDepletion {
-    t_FmPortBufPoolDepletion    poolDepletionParams;/**< parameters to define pool depletion */
-    t_FmPortExtPools            poolsParams;        /**< Which external buffer pools are observed
-                                                         (up to FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS),
-                                                         and their sizes. */
+    t_FmBufPoolDepletion    poolDepletionParams;/**< parameters to define pool depletion */
+    t_FmExtPools            poolsParams;        /**< Which external buffer pools are observed
+                                                     (up to FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS),
+                                                     and their sizes. */
 } t_FmPortObservedBufPoolDepletion;
 
 /**************************************************************************//**
- @Description   struct for defining Tx rate limiting
+ @Description   A structure for defining Tx rate limiting
 *//***************************************************************************/
 typedef struct t_FmPortRateLimit {
-    uint16_t                            maxBurstSize;           /**< in kBytes for Tx ports, in frames
-                                                                     for offline parsing ports. (note that
+    uint16_t                            maxBurstSize;           /**< in KBytes for Tx ports, in frames
+                                                                     for OP ports. (note that
                                                                      for early chips burst size is
                                                                      rounded up to a multiply of 1000 frames).*/
     uint32_t                            rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
-                                                                     offline parsing ports. Rate limit refers to
+                                                                     OP ports. Rate limit refers to
                                                                      data rate (rather than line rate). */
-    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For offline parsing ports only. Not-valid
+    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For OP ports only. Not-valid
                                                                      for some earlier chip revisions */
 } t_FmPortRateLimit;
 
 /**************************************************************************//**
- @Description   struct for defining define the parameters of
+ @Description   A structure for defining define the parameters of
                 the Rx port performance counters
 *//***************************************************************************/
 typedef struct t_FmPortPerformanceCnt {
@@ -487,38 +429,6 @@ typedef struct t_FmPortPerformanceCnt {
     uint32_t    fifoCompVal;            /**< Fifo compare value (in bytes) */
 } t_FmPortPerformanceCnt;
 
-/**************************************************************************//**
- @Description   struct for defining buffer content.
-*//***************************************************************************/
-typedef struct t_FmPortBufferPrefixContent {
-    uint16_t    privDataSize;       /**< Number of bytes to be left at the beginning
-                                         of the external buffer */
-    bool        passPrsResult;      /**< TRUE to pass the parse result to/from the FM */
-    bool        passTimeStamp;      /**< TRUE to pass the timeStamp to/from the FM */
-    bool        passHashResult;     /**< TRUE to pass the KG hash result to/from the FM */
-    bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
-                                         AD, hash-result, key, etc. */
-    uint16_t    dataAlign;          /**< 0 to use driver's default alignment, other value
-                                         for selecting a data alignment (must be a
-                                         power of 2) */
-#if (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_CAPWAP_SUPPORT))
-    uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size) */
-#endif /* FM_CAPWAP_SUPPORT */
-} t_FmPortBufferPrefixContent;
-
-/**************************************************************************//**
- @Description   struct for defining backup Bm Pools.
-*//***************************************************************************/
-typedef struct t_FmPortBackupBmPools {
-    uint8_t     numOfBackupPools;        /**< Number of BM backup pools -
-                                             must be smaller than the total number of
-                                             pools defined for the specified port.*/
-    uint8_t     poolIds[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-                                        /**< numOfBackupPools pool id's, specifying which
-                                             pools should be used only as backup. Pool
-                                             id's specified here must be a subset of the
-                                             pools used by the specified port.*/
-} t_FmPortBackupBmPools;
 
 
 /**************************************************************************//**
@@ -547,9 +457,9 @@ t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_OpenDmas)
                 internal driver data base from its default configuration
                 [type]
 
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     p_OpenDmas  A pointer to a structure of parameters defining
-                            the tasks allocation.
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_NumOfTasks    A pointer to a structure of parameters defining
+                                the tasks allocation.
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -565,9 +475,9 @@ t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
                 internal driver data base from its default configuration
                 [DEFAULT_PORT_sizeOfFifo]
 
- @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     p_OpenDmas  A pointer to a structure of parameters defining
-                            the FIFO allocation.
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     p_SizeOfFifo    A pointer to a structure of parameters defining
+                                the FIFO allocation.
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -612,7 +522,6 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
 *//***************************************************************************/
 t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
 
-#ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 /**************************************************************************//**
  @Function      FM_PORT_ConfigDeqPrefetchOption
 
@@ -631,7 +540,6 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
 t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOption deqPrefetchOption);
-#endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigDeqByteCnt
@@ -653,109 +561,6 @@ t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOp
 t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
 
 /**************************************************************************//**
- @Function      FM_PORT_ConfigTxFifoMinFillLevel
-
- @Description   Calling this routine changes the fifo minimum
-                fill level parameter in the internal driver data base
-                from its default configuration  [0]
-
-                May be used for Tx ports only
-
- @Param[in]     h_FmPort        A handle to a FM Port module.
- @Param[in]     minFillLevel    New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigTxFifoDeqPipelineDepth
-
- @Description   Calling this routine changes the fifo dequeue
-                pipeline depth parameter in the internal driver data base
-
-                from its default configuration: 1G ports: [1],
-                10G port: [4]
-
-                May be used for Tx ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     deqPipelineDepth    New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigTxFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigTxFifoLowComfLevel
-
- @Description   Calling this routine changes the fifo low comfort level
-                parameter in internal driver data base
-                from its default configuration  [5]
-
-                May be used for Tx ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     fifoLowComfLevel    New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigRxFifoThreshold
-
- @Description   Calling this routine changes the threshold of the FIFO
-                fill level parameter in the internal driver data base
-                from its default configuration [BMI_MAX_FIFO_SIZE]
-
-                If the total number of buffers which are
-                currently in use and associated with the
-                specific RX port exceed this threshold, the
-                BMI will signal the MAC to send a pause frame
-                over the link.
-
-                May be used for Rx ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     fifoThreshold       New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
-
-/**************************************************************************//**
- @Function      FM_PORT_ConfigRxFifoPriElevationLevel
-
- @Description   Calling this routine changes the priority elevation level
-                parameter in the internal driver data base from its default
-                configuration  [BMI_MAX_FIFO_SIZE]
-
-                If the total number of buffers which are currently in use and
-                associated with the specific RX port exceed the amount specified
-                in priElevationLevel, BMI will signal the main FM's DMA to
-                elevate the FM priority on the system bus.
-
-                May be used for Rx ports only
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     priElevationLevel   New value
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
-
-/**************************************************************************//**
  @Function      FM_PORT_ConfigBufferPrefixContent
 
  @Description   Defines the structure, size and content of the application buffer.
@@ -768,14 +573,14 @@ t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priEle
                 application buffer, and to offset.
                 Calling this routine changes the buffer margins definitions
                 in the internal driver data base from its default
-                configuration: Data size:  [0]
-                               Pass Parser result: [FALSE].
-                               Pass timestamp: [FALSE].
+                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
 
                 May be used for all ports
 
  @Param[in]     h_FmPort                        A handle to a FM Port module.
- @Param[in,out] p_FmPortBufferPrefixContent     A structure of parameters describing the
+ @Param[in,out] p_FmBufferPrefixContent         A structure of parameters describing the
                                                 structure of the buffer.
                                                 Out parameter: Start margin - offset
                                                 of data from start of external buffer.
@@ -785,8 +590,7 @@ t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priEle
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
 t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle                      h_FmPort,
-                                          t_FmPortBufferPrefixContent   *p_FmPortBufferPrefixContent);
-
+                                          t_FmBufferPrefixContent       *p_FmBufferPrefixContent);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigCheksumLastBytesIgnore
@@ -798,7 +602,7 @@ t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle                      h_FmPort
                 May be used by Tx & Rx ports only
 
  @Param[in]     h_FmPort                A handle to a FM Port module.
- @Param[in]     cheksumLastBytesIgnore    New value
+ @Param[in]     cheksumLastBytesIgnore  New value
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -811,7 +615,7 @@ t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumL
 
  @Description   Calling this routine changes the number of bytes to cut from a
                 frame's end parameter in the internal driver data base
-                from its default configuration  [4]
+                from its default configuration [4]
                 Note that if the result of (frame length before chop - cutBytesFromEnd) is
                 less than 14 bytes, the chop operation is not executed.
 
@@ -842,7 +646,7 @@ t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion *p_BufPoolDepletion);
+t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_BufPoolDepletion);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigObservedPoolDepletion
@@ -854,39 +658,38 @@ t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmPortBufPoolDepletion
 
                 Note: Available for some chips only
 
-                May be used for Offline Parsing ports only
+                May be used for OP ports only
 
  @Param[in]     h_FmPort                            A handle to a FM Port module.
  @Param[in]     p_FmPortObservedBufPoolDepletion    A structure of parameters for pool depletion.
 
-
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion);
+t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort,
+                                            t_FmPortObservedBufPoolDepletion *p_FmPortObservedBufPoolDepletion);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigExtBufPools
 
- @Description   This routine should be called for offline parsing ports
+ @Description   This routine should be called for OP ports
                 that internally use BM buffer pools. In such cases, e.g. for fragmentation and
                 re-assembly, the FM needs new BM buffers. By calling this routine the user
                 specifies the BM buffer pools that should be used.
 
                 Note: Available for some chips only
 
-                May be used for Offline Parsing ports only
+                May be used for OP ports only
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     p_FmPortExtPools    A structure of parameters for the external pools.
-
+ @Param[in]     p_FmExtPools        A structure of parameters for the external pools.
 
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmPortExtPools *p_FmPortExtPools);
+t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigBackupPools
@@ -906,7 +709,7 @@ t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmPortExtPools *p_FmPortE
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmPortBackupBmPools *p_FmPortBackupBmPools);
+t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_FmPortBackupBmPools);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigFrmDiscardOverride
@@ -915,7 +718,7 @@ t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmPortBackupBmPools *p_Fm
                 in the internal driver data base from its default configuration:
                 override = [FALSE]
 
-                May be used for Rx and offline parsing ports only
+                May be used for Rx and OP ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     override    TRUE to override discarding of error frames and
@@ -938,8 +741,7 @@ t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
                 Errors that were not defined either as "ErrorsToEnqueue" nor as
                 "ErrorsToDiscard", will be forwarded to CPU.
 
-
-                May be used for Rx and offline parsing ports only
+                May be used for Rx and OP ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     errs        A list of errors to discard
@@ -955,7 +757,7 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
 
  @Description   Calling this routine changes the DMA swap data aparameter
                 in the internal driver data base from its default
-                configuration  [e_FM_PORT_DMA_NO_SWP]
+                configuration  [DEFAULT_FM_SP_dmaSwapData]
 
                 May be used for all port types
 
@@ -966,14 +768,14 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData);
+t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigDmaIcCacheAttr
 
  @Description   Calling this routine changes the internal context cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [e_FM_PORT_DMA_NO_STASH]
+                from its default configuration  [DEFAULT_FM_SP_dmaIntContextCacheAttr]
 
                 May be used for all port types
 
@@ -984,14 +786,14 @@ t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmPortDmaSwap swapData);
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmPortDmaCache intContextCacheAttr);
+t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intContextCacheAttr);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigDmaHdrAttr
 
  @Description   Calling this routine changes the header cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [e_FM_PORT_DMA_NO_STASH]
+                from its default configuration  [DEFAULT_FM_SP_dmaHeaderCacheAttr]
 
                 May be used for all port types
 
@@ -1002,14 +804,14 @@ t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmPortDmaCache intCont
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCacheAttr);
+t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCacheAttr);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigDmaScatterGatherAttr
 
  @Description   Calling this routine changes the scatter gather cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [e_FM_PORT_DMA_NO_STASH]
+                from its default configuration  [DEFAULT_FM_SP_dmaScatterGatherCacheAttr]
 
                 May be used for all port types
 
@@ -1020,14 +822,14 @@ t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmPortDmaCache headerCache
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache scatterGatherCacheAttr);
+t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption scatterGatherCacheAttr);
 
 /**************************************************************************//**
  @Function      FM_PORT_ConfigDmaWriteOptimize
 
  @Description   Calling this routine changes the write optimization
                 parameter in the internal driver data base
-                from its default configuration:  optimize = [TRUE]
+                from its default configuration:  optimize = [DEFAULT_FM_SP_dmaWriteOptimize]
 
                 May be used for non-Tx port types
 
@@ -1041,6 +843,22 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmPortDmaCache s
 t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize);
 
 /**************************************************************************//**
+ @Function      FM_PORT_ConfigNoScatherGather
+
+ @Description    Calling this routine changes the noScatherGather parameter in internal driver data base
+                 from its default configuration.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     noScatherGather (TRUE - frame is discarded if can not be stored in single buffer,
+                                 FALSE - frame can be stored in scatter gather (S/G) format).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather);
+
+/**************************************************************************//**
  @Function      FM_PORT_ConfigDfltColor
 
  @Description   Calling this routine changes the internal default color parameter
@@ -1079,16 +897,16 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
 /**************************************************************************//**
  @Function      FM_PORT_ConfigForwardReuseIntContext
 
- @Description   This routine is relevant for Rx ports that are routed to offline
-                parsing. It changes the internal context reuse option
-                in the internal driver data base from its default configuration:
+ @Description   This routine is relevant for Rx ports that are routed to OP port.
+                It changes the internal context reuse option in the internal
+                driver data base from its default configuration:
                 reuse = [FALSE]
 
                 May be used for Rx ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     reuse           TRUE to reuse internal context on frames
-                                forwarded to offline parsing.
+                                forwarded to OP port.
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1218,7 +1036,7 @@ t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
                 only for Tx ports or ports working in independent mode.
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
-                length          Max size of frame
+ @Param[in]     length          Max size of frame
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1227,6 +1045,109 @@ t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
 *//***************************************************************************/
 t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
 
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigTxFifoMinFillLevel
+
+ @Description   Calling this routine changes the fifo minimum
+                fill level parameter in the internal driver data base
+                from its default configuration  [0]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     minFillLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
+
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigFifoDeqPipelineDepth
+
+ @Description   Calling this routine changes the fifo dequeue
+                pipeline depth parameter in the internal driver data base
+
+                from its default configuration: 1G ports: [1],
+                10G port: [4]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     deqPipelineDepth    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
+
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigTxFifoLowComfLevel
+
+ @Description   Calling this routine changes the fifo low comfort level
+                parameter in internal driver data base
+                from its default configuration  [5]
+
+                May be used for Tx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoLowComfLevel    New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigRxFifoThreshold
+
+ @Description   Calling this routine changes the threshold of the FIFO
+                fill level parameter in the internal driver data base
+                from its default configuration [BMI_MAX_FIFO_SIZE]
+
+                If the total number of buffers which are
+                currently in use and associated with the
+                specific RX port exceed this threshold, the
+                BMI will signal the MAC to send a pause frame
+                over the link.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     fifoThreshold       New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
+
+/**************************************************************************//*
+ @Function      FM_PORT_ConfigRxFifoPriElevationLevel
+
+ @Description   Calling this routine changes the priority elevation level
+                parameter in the internal driver data base from its default
+                configuration  [BMI_MAX_FIFO_SIZE]
+
+                If the total number of buffers which are currently in use and
+                associated with the specific RX port exceed the amount specified
+                in priElevationLevel, BMI will signal the main FM's DMA to
+                elevate the FM priority on the system bus.
+
+                May be used for Rx ports only
+
+ @Param[in]     h_FmPort            A handle to a FM Port module.
+ @Param[in]     priElevationLevel   New value
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
+
 /** @} */ /* end of FM_PORT_advanced_init_grp group */
 /** @} */ /* end of FM_PORT_init_grp group */
 
@@ -1254,18 +1175,20 @@ typedef enum e_FmPortCounters {
     e_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
     e_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
     e_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
-    e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
     e_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
     e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx, OP & HC statistics counter */
+    e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER,  /**< BMI Rx, OP & HC only statistics counter */
     e_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
     e_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
     e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
-    e_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
-    e_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
+    e_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI total QM dequeues counter */
+    e_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI total QM enqueues counter */
     e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
     e_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
 } e_FmPortCounters;
 
+
 /**************************************************************************//**
  @Description   Structure for Port id parameters.
                 Fields commented 'IN' are passed by the port module to be used
@@ -1273,32 +1196,20 @@ typedef enum e_FmPortCounters {
                 Fields commented 'OUT' will be filled by FM before returning to port.
 *//***************************************************************************/
 typedef struct t_FmPortCongestionGrps {
-    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required congestion groups
+    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required CGs
                                                              to define the size of the following array */
     uint8_t     congestionGrpsToConsider[FM_PORT_NUM_OF_CONGESTION_GRPS];
-                                                        /**< An array of 'numOfCongestionGrpsToConsider'
-                                                             describing the groups */
+                                                        /**< An array of CG indexes;
+                                                             Note that the size of the array should be
+                                                             'numOfCongestionGrpsToConsider'. */
+#if DPAA_VERSION >= 3
+    bool        pfcPrioritiesEn[FM_PORT_NUM_OF_CONGESTION_GRPS][FM_MAX_NUM_OF_PFC_PRIORITIES];
+                                                        /**< a matrix that represents the map between the CG ids
+                                                             defined in 'congestionGrpsToConsider' to the priorties
+                                                             mapping array. */
+#endif /* DPAA_VERSION >= 3 */
 } t_FmPortCongestionGrps;
 
-#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
-/**************************************************************************//**
- @Collection   FM OP PORT Workarounds
-*//***************************************************************************/
-typedef uint32_t    fmOpPortWorkaroundsSelect_t;                    /**< typedef for defining port workarounds */
-#endif /* defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
-
-#ifdef FM_IPSEC_SUPPORT
-#define FM_OP_PORT_WA_SEC_ERR                           0x80000000  /**< TODO */
-#define FM_OP_PORT_WA_DISABLE_UDP_CKSM                  0x40000000  /**< TODO */
-#define FM_OP_PORT_WA_ETH_TYPE                          0x20000000  /**< TODO */
-#define FM_OP_PORT_WA_UPDATE_UDP_LEN                    0x08000000  /**< TODO */
-#endif /* FM_IPSEC_SUPPORT */
-#ifdef FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
-#define FM_OP_PORT_WA_COPY_CTXB                         0x10000000  /**< Offline port workaround - copy 9 bits from
-                                                                         contextB to flow-id location*/
-#endif /* FM_NO_CTXA_COPY_ERRATA_FMAN_SW001 */
-/* @} */
-
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 /**************************************************************************//**
@@ -1441,7 +1352,7 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort);
                 The selected rate limit specified here would be
                 rounded DOWN to the nearest 16M.
 
-                May be used for Tx and offline parsing ports only
+                May be used for Tx and OP ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_RateLimit     A structure of rate limit parameters
@@ -1458,7 +1369,7 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
  @Description   Calling this routine disables and clears rate limit
                 initialization.
 
-                May be used for Tx and offline parsing ports only
+                May be used for Tx and OP ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
 
@@ -1649,7 +1560,7 @@ t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort,  uint8_t poolId, uint32
                 Each call to this routine may add one or more congestion
                 groups to be considered relevant to this port.
 
-                May be used for Rx, or  RX+OP ports only (depending on chip)
+                May be used for Rx, or RX+OP ports only (depending on chip)
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
  @Param[in]     p_CongestionGrps    A pointer to an array of congestion groups
@@ -1738,7 +1649,7 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
                 Errors that were configured to be discarded (at initialization)
                 may not be selected here.
 
-                May be used for Rx and offline parsing ports only
+                May be used for Rx and OP ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     errs        A list of errors to enqueue to error queue
@@ -1753,7 +1664,6 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
  @Function      FM_PORT_SetIMExceptions
 
  @Description   Calling this routine enables/disables FM PORT interrupts.
-                Note: Not available for guest partition.
 
  @Param[in]     h_FmPort        FM PORT module descriptor.
  @Param[in]     exception       The exception to be selected.
@@ -1762,25 +1672,11 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
 
-#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
-/**************************************************************************//**
- @Function      FM_PORT_SetOpWorkarounds
-
- @Description   Calling this routine sets the required offline port workaround.
-
- @Param[in]     h_FmPort        FM PORT module descriptor.
- @Param[in]     workarounds)    Reuired workaround.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetOpWorkarounds(t_Handle h_FmPort, fmOpPortWorkaroundsSelect_t workarounds);
-#endif /* defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
-
 
 /**************************************************************************//**
  @Group         FM_PORT_pcd_runtime_control_grp FM Port PCD Runtime Control Unit
@@ -1837,7 +1733,7 @@ typedef union u_FmPcdHdrPrsOpts {
 
     /* IPV6 */
     struct{
-        bool            routingHdrDisable;          /**< Disable routing header */
+        bool            routingHdrEnable;          /**< TRUE to enable routing header, otherwise ignore */
     } ipv6PrsOptions;
 
     /* UDP */
@@ -1943,6 +1839,7 @@ typedef struct t_FmPortPcdParams {
     t_FmPortPcdCcParams     *p_CcParams;        /**< Coarse classification parameters for this port */
     t_FmPortPcdKgParams     *p_KgParams;        /**< Keygen parameters for this port */
     t_FmPortPcdPlcrParams   *p_PlcrParams;      /**< Policer parameters for this port */
+    t_Handle                h_IpReassemblyManip;/**< IP Reassembly manipulation */
 } t_FmPortPcdParams;
 
 /**************************************************************************//**
@@ -1955,6 +1852,19 @@ typedef struct t_FmPcdPrsStart {
                                              'parsingOffset' */
 } t_FmPcdPrsStart;
 
+#if DPAA_VERSION >= 3
+/**************************************************************************//**
+ @Description   struct for defining external buffer margins
+*//***************************************************************************/
+typedef struct t_FmPortVSPAllocParams {
+    uint8_t     numOfProfiles;          /**< Number of Virtual Storage Profiles */
+    uint8_t     dfltRelativeId;         /**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
+                                             The same default Virtual-Storage-Profile-id will be for coupled Tx port
+                                             if relevant function called for Rx port */
+    t_Handle    h_FmTxPort;             /**< Handle to coupled Tx Port */
+} t_FmPortVSPAllocParams;
+#endif /* DPAA_VERSION >= 3 */
+
 
 /**************************************************************************//**
  @Function      FM_PORT_SetPCD
@@ -1964,7 +1874,7 @@ typedef struct t_FmPcdPrsStart {
                 disabled (BMI to BMI) and configures it according to the passed
                 parameters.
 
-                May be used for Rx and offline parsing ports only
+                May be used for Rx and OP ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_FmPortPcd     A Structure of parameters defining the port's PCD
@@ -1983,7 +1893,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd);
                 The port returns to its default configuration which is PCD
                 disabled (BMI to BMI) and all PCD configuration is removed.
 
-                May be used for Rx and offline parsing ports which are
+                May be used for Rx and OP ports which are
                 in PCD mode  only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
@@ -2002,7 +1912,7 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort);
                 The couple of routines are used to allow PCD configuration changes
                 that demand that PCD will not be used while changes take place.
 
-                May be used for Rx and offline parsing ports which are
+                May be used for Rx and OP ports which are
                 in PCD mode only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
@@ -2019,7 +1929,7 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort);
  @Description   Calling this routine detaches the port from its PCD functionality.
                 The port returns to its default flow which is BMI to BMI.
 
-                May be used for Rx and offline parsing ports which are
+                May be used for Rx and OP ports which are
                 in PCD mode only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
@@ -2041,7 +1951,8 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort);
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(),
+                and before FM_PORT_SetPCD().
 *//***************************************************************************/
 t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
 
@@ -2054,10 +1965,30 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles);
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(), and before FM_PORT_SetPCD().
+ @Cautions      Allowed only following FM_PORT_Init() and FM_PCD_Init(),
+                and before FM_PORT_SetPCD().
 *//***************************************************************************/
 t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
 
+#if DPAA_VERSION >= 3
+/**************************************************************************//**
+ @Function      FM_PORT_VSPAlloc
+
+ @Description   This routine allocated VSPs per port and forces the port to work
+                in VSP mode. Note that the port is initialized by default with the
+                physical-storage-profile only.
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_Params    A structure of parameters for allocation VSP's per port
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init(), and before FM_PORT_SetPCD()
+                and also before FM_PORT_Enable() (i.e. the port should be disabled).
+*//***************************************************************************/
+t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_Params);
+#endif /* DPAA_VERSION >= 3 */
+
 /**************************************************************************//**
  @Function      FM_PORT_PcdKgModifyInitialScheme
 
@@ -2238,5 +2169,9 @@ t_Error  FM_PORT_ImRx(t_Handle h_FmPort);
 
 
 
+#ifdef NCSW_BACKWARD_COMPATIBLE_API
+#define FM_PORT_ConfigTxFifoDeqPipelineDepth FM_PORT_ConfigFifoDeqPipelineDepth
+#endif /* NCSW_BACKWARD_COMPATIBLE_API */
+
 
 #endif /* __FM_PORT_EXT */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
index e891df1..8436944 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -544,7 +544,7 @@ t_Error FM_RTC_SetCurrentTime(t_Handle h_FmRtc, uint64_t ts);
 /**************************************************************************//**
  @Function      FM_RTC_GetFreqCompensation
 
- @Description   TODO
+ @Description   Retrieves the frequency compensation value
 
  @Param[in]     h_FmRtc         - Handle to FM RTC object.
  @Param[out]    p_Compensation  - A pointer to the returned value of compensation.
@@ -558,10 +558,10 @@ t_Error FM_RTC_GetFreqCompensation(t_Handle h_FmRtc, uint32_t *p_Compensation);
 /**************************************************************************//**
  @Function      FM_RTC_SetFreqCompensation
 
- @Description   TODO
+ @Description   Sets a new frequency compensation value.
 
  @Param[in]     h_FmRtc             - Handle to FM RTC object.
- @Param[in]     freqCompensation    - the new desired compensation value to be set.
+ @Param[in]     freqCompensation    - The new frequency compensation value to set.
 
  @Return        E_OK on success; Error code otherwise.
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h
new file mode 100644
index 0000000..311357e
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_vsp_ext.h
@@ -0,0 +1,354 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/**************************************************************************//**
+ @File          fm_vsp_ext.h
+
+ @Description   FM Virtual Storage-Profile ...
+*//***************************************************************************/
+#ifndef __FM_VSP_EXT_H
+#define __FM_VSP_EXT_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+
+#include "fm_ext.h"
+
+
+/**************************************************************************//**
+
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_VSP_grp FM Virtual-Storage-Profile
+
+ @Description   FM Virtual-Storage-Profile API
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_VSP_init_grp FM VSP Initialization Unit
+
+ @Description   FM VSP initialization API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   Virtual Storage Profile
+*//***************************************************************************/
+typedef struct t_FmVspParams {
+    t_Handle            h_Fm;               /**< A handle to the FM object this VSP related to */
+    t_FmExtPools        extBufPools;        /**< Which external buffer pools are used
+                                                 (up to FM_PORT_MAX_NUM_OF_EXT_POOLS), and their sizes.
+                                                 parameter associated with Rx / OP port */
+    uint16_t            liodnOffset;        /**< VSP's LIODN offset */
+    struct {
+        e_FmPortType    portType;           /**< Port type */
+        uint8_t         portId;             /**< Port Id - relative to type */
+    } portParams;
+    uint8_t             relativeProfileId;  /**< VSP Id - relative to VSP's range
+                                                 defined in relevant FM object */
+} t_FmVspParams;
+
+
+/**************************************************************************//**
+ @Function      FM_VSP_Config
+
+ @Description   Creates descriptor for the FM VSP module.
+
+                The routine returns a handle (descriptor) to the FM VSP object.
+                This descriptor must be passed as first parameter to all other
+                FM VSP function calls.
+
+                No actual initialization or configuration of FM hardware is
+                done by this routine.
+
+@Param[in]      p_FmVspParams   Pointer to data structure of parameters
+
+ @Retval        Handle to FM VSP object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams);
+
+/**************************************************************************//**
+ @Function      FM_VSP_Init
+
+ @Description   Initializes the FM VSP module
+
+ @Param[in]     h_FmVsp - FM VSP module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_VSP_Init(t_Handle h_FmVsp);
+
+/**************************************************************************//**
+ @Function      FM_VSP_Free
+
+ @Description   Frees all resources that were assigned to FM VSP module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmVsp - FM VSP module descriptor
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_VSP_Free(t_Handle h_FmVsp);
+
+
+/**************************************************************************//**
+ @Group         FM_VSP_adv_config_grp  FM VSP Advanced Configuration Unit
+
+ @Description   FM VSP advanced configuration functions.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigBufferPrefixContent
+
+ @Description   Defines the structure, size and content of the application buffer.
+
+                The prefix will
+                In VSPs defined for Tx ports, if 'passPrsResult', the application
+                should set a value to their offsets in the prefix of
+                the FM will save the first 'privDataSize', than,
+                depending on 'passPrsResult' and 'passTimeStamp', copy parse result
+                and timeStamp, and the packet itself (in this order), to the
+                application buffer, and to offset.
+
+                Calling this routine changes the buffer margins definitions
+                in the internal driver data base from its default
+                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+
+ @Param[in]     h_FmVsp                         A handle to a FM VSP module.
+ @Param[in,out] p_FmBufferPrefixContent         A structure of parameters describing the
+                                                structure of the buffer.
+                                                Out parameter: Start margin - offset
+                                                of data from start of external buffer.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigBufferPrefixContent(t_Handle                   h_FmVsp,
+                                         t_FmBufferPrefixContent    *p_FmBufferPrefixContent);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaSwapData
+
+ @Description   Calling this routine changes the DMA swap data parameter
+                in the internal driver data base from its default
+                configuration  [DEFAULT_FM_SP_dmaSwapData]
+
+ @Param[in]     h_FmVsp     A handle to a FM VSP module.
+ @Param[in]     swapData    New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaSwapData(t_Handle h_FmVsp, e_FmDmaSwapOption swapData);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaIcCacheAttr
+
+ @Description   Calling this routine changes the internal context cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_FM_SP_dmaIntContextCacheAttr]
+
+ @Param[in]     h_FmVsp                 A handle to a FM VSP module.
+ @Param[in]     intContextCacheAttr     New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaIcCacheAttr(t_Handle            h_FmVsp,
+                                    e_FmDmaCacheOption  intContextCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaHdrAttr
+
+ @Description   Calling this routine changes the header cache
+                attribute parameter in the internal driver data base
+                from its default configuration  [DEFAULT_FM_SP_dmaHeaderCacheAttr]
+
+ @Param[in]     h_FmVsp                     A handle to a FM VSP module.
+ @Param[in]     headerCacheAttr             New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaHdrAttr(t_Handle h_FmVsp, e_FmDmaCacheOption headerCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaScatterGatherAttr
+
+ @Description   Calling this routine changes the scatter gather cache
+                attribute parameter in the internal driver data base
+                from its default configuration [DEFAULT_FM_SP_dmaScatterGatherCacheAttr]
+
+ @Param[in]     h_FmVsp                     A handle to a FM VSP module.
+ @Param[in]     scatterGatherCacheAttr      New selection
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaScatterGatherAttr(t_Handle              h_FmVsp,
+                                          e_FmDmaCacheOption    scatterGatherCacheAttr);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigDmaWriteOptimize
+
+ @Description   Calling this routine changes the write optimization
+                parameter in the internal driver data base
+                from its default configuration: optimize = [DEFAULT_FM_SP_dmaWriteOptimize]
+
+ @Param[in]     h_FmVsp     A handle to a FM VSP module.
+ @Param[in]     optimize    TRUE to enable optimization, FALSE for normal operation
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigDmaWriteOptimize(t_Handle h_FmVsp, bool optimize);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigNoScatherGather
+
+ @Description   Calling this routine changes the possibility to receive S/G frame
+                in the internal driver data base
+                from its default configuration: optimize = [DEFAULT_FM_SP_noScatherGather]
+
+ @Param[in]     h_FmVsp             A handle to a FM VSP module.
+ @Param[in]     noScatherGather     TRUE to operate without scatter/gather capability.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigNoScatherGather(t_Handle h_FmVsp, bool noScatherGather);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigPoolDepletion
+
+ @Description   Calling this routine enables pause frame generation depending on the
+                depletion status of BM pools. It also defines the conditions to activate
+                this functionality. By default, this functionality is disabled.
+
+ @Param[in]     h_FmVsp                 A handle to a FM VSP module.
+ @Param[in]     p_BufPoolDepletion      A structure of pool depletion parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigPoolDepletion(t_Handle h_FmVsp, t_FmBufPoolDepletion *p_BufPoolDepletion);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ConfigBackupPools
+
+ @Description   Calling this routine allows the configuration of some of the BM pools
+                defined for this port as backup pools.
+                A pool configured to be a backup pool will be used only if all other
+                enabled non-backup pools are depleted.
+
+ @Param[in]     h_FmVsp                 A handle to a FM VSP module.
+ @Param[in]     p_BackupBmPools         An array of pool id's. All pools specified here will
+                                        be defined as backup pools.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Config() and before FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBmPools);
+
+/** @} */ /* end of FM_VSP_adv_config_grp group */
+/** @} */ /* end of FM_VSP_init_grp group */
+
+#ifdef UNDER_CONSTRUCTION_FM_GEN
+/**************************************************************************//**
+ @Group         FM_VSP_control_grp FM VSP Control Unit
+
+ @Description   FM VSP runtime control API.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_VSP_GetStatistics
+
+ @Description   Reads FM VSP counter.
+
+ @Param[in]     h_FmVsp             A handle to a FM VSP module.
+
+ @Return        Counter's current value.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+                Note that counters in summary of BM pools defined for this VSP
+*//***************************************************************************/
+uint32_t FM_VSP_GetStatistics(t_Handle h_FmVsp);
+
+/**************************************************************************//**
+ @Function      FM_VSP_ModifyCounter
+
+ @Description   Sets a value to an enabled counter. Use "0" to reset the counter.
+
+ @Param[in]     h_FmVsp             A handle to a FM VSP module.
+ @Param[in]     value               The requested value to be written into the counter.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_VSP_Init().
+*//***************************************************************************/
+t_Error FM_VSP_ModifyCounter(t_Handle h_FmVsp, uint32_t value);
+
+/** @} */ /* end of FM_VSP_control_grp group */
+#endif /* UNDER_CONSTRUCTION_FM_GEN */
+/** @} */ /* end of FM_VSP_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_VSP_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
index 6cee3a3..5b38fdb 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
index 8130c73..4b0c1e5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -55,6 +55,10 @@
 #error "Must define core as little-endian or big-endian!"
 #endif /* (!defined(CORE_IS_LITTLE_ENDIAN) && ... */
 
+#ifndef CORE_CACHELINE_SIZE
+#error "Must define the core cache-line size!"
+#endif /* !CORE_CACHELINE_SIZE */
+
 
 /**************************************************************************//**
  @Function      CORE_GetId
@@ -75,7 +79,7 @@ uint32_t CORE_GetId(void);
  @Return        None.
 *//***************************************************************************/
 void CORE_MemoryBarrier(void);
-
+#define fsl_mem_core_barrier() CORE_MemoryBarrier()
 
 #endif /* __CORE_EXT_H */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
index 26c2641..1beb5a6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -193,6 +193,7 @@ typedef enum e_E500mcL2CacheMode
     e_L2_CACHE_MODE_DATA_AND_INST  = 0x00000003    /**< Cache data and instructions */
 } e_E500mcL2CacheMode;
 
+#if defined(CORE_E500MC) || defined(CORE_E5500)
 /**************************************************************************//**
  @Function      E500_L2CacheEnable
 
@@ -237,6 +238,65 @@ void E500_L2CacheFlush(void);
  @Return        None.
 *//***************************************************************************/
 void E500_L2SetStashId(uint8_t stashId);
+#endif /* defined(CORE_E500MC) || defined(CORE_E5500) */
+
+#ifdef CORE_E6500
+/**************************************************************************//**
+ @Function      E6500_L2CacheEnable
+
+ @Description   Enables the cache for memory pages that are not cache inhibited.
+
+ @param[in]     mode - L2 cache mode: support data & instruction only.
+
+ @Return        None.
+
+ @Cautions      This routine must be call only ONCE for both caches. I.e. it is
+                not possible to call this routine for i-cache and than to call
+                again for d-cache; The second call will override the first one.
+*//***************************************************************************/
+void E6500_L2CacheEnable(uintptr_t clusterBase);
+
+/**************************************************************************//**
+ @Function      E6500_L2CacheDisable
+
+ @Description   Disables the cache (data instruction or both).
+
+ @Return        None.
+
+*//***************************************************************************/
+void E6500_L2CacheDisable(uintptr_t clusterBase);
+
+/**************************************************************************//**
+ @Function      E6500_L2CacheFlush
+
+ @Description   Flushes the cache.
+
+ @Return        None.
+*//***************************************************************************/
+void E6500_L2CacheFlush(uintptr_t clusterBase);
+
+/**************************************************************************//**
+ @Function      E6500_L2SetStashId
+
+ @Description   Set Stash Id
+
+ @Param[in]     stashId     the stash id to be set.
+
+ @Return        None.
+*//***************************************************************************/
+void E6500_L2SetStashId(uintptr_t clusterBase, uint8_t stashId);
+
+/**************************************************************************//**
+ @Function      E6500_GetCcsrBase
+
+ @Description   Obtain SoC CCSR base address
+
+ @Param[in]     None.
+
+ @Return        Physical CCSR base address.
+*//***************************************************************************/
+physAddress_t E6500_GetCcsrBase(void);
+#endif /* CORE_E6500 */
 
 /**************************************************************************//**
  @Function      E500_AddressBusStreamingEnable
@@ -374,9 +434,9 @@ int E500_TestAndSet(volatile int *p);
 *//***************************************************************************/
 static __inline__ void E500_MemoryBarrier(void)
 {
-#ifdef CORE_E500MC
+#ifndef CORE_E500V2
     __asm__ ("mbar 1");
-#else
+#else  /* CORE_E500V2 */
     /**** ERRATA WORK AROUND START ****/
     /* ERRATA num:  CPU1 */
     /* Description: "mbar MO = 1" instruction fails to order caching-inhibited
@@ -387,7 +447,7 @@ static __inline__ void E500_MemoryBarrier(void)
     __asm__ ("msync");
 
     /**** ERRATA WORK AROUND END ****/
-#endif
+#endif /* CORE_E500V2 */
 }
 
 /**************************************************************************//**
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
index bccd1b8..57c2889 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -46,6 +46,14 @@
 
 #define CORE_IS_BIG_ENDIAN
 
+#if defined(CORE_E300) || defined(CORE_E500V2)
+#define CORE_CACHELINE_SIZE     32
+#elif defined(CORE_E500MC) || defined(CORE_E5500) || defined(CORE_E6500)
+#define CORE_CACHELINE_SIZE     64
+#else
+#error "Core not defined!"
+#endif /* defined(CORE_E300) || ... */
+
 
 /**************************************************************************//**
  @Function      CORE_TestAndSet
@@ -117,11 +125,13 @@ void CORE_ICacheDisable(void);
 
 
 
-
 #if defined(CORE_E300)
 #include "e300_ext.h"
-#elif defined(CORE_E500V2) || defined(CORE_E500MC)
+#elif defined(CORE_E500V2) || defined(CORE_E500MC) || defined(CORE_E5500) || defined(CORE_E6500)
 #include "e500v2_ext.h"
+#if !defined(NCSW_LINUX)
+#include "e500v2_asm_ext.h"
+#endif
 #else
 #error "Core not defined!"
 #endif
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
index 13dfb71..706f35a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
index 2331a43..1d915ea 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
index 93ce535..99b08e8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
index d432ef1..ae4b267 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -74,7 +74,8 @@ typedef enum e_EnetInterface
     e_ENET_IF_RTBI  = 0x00070000,   /**< RTBI interface */
     e_ENET_IF_SGMII = 0x00080000,   /**< SGMII interface */
     e_ENET_IF_XGMII = 0x00090000,   /**< XGMII interface */
-    e_ENET_IF_QSGMII= 0x000a0000    /**< QSGMII interface */
+    e_ENET_IF_QSGMII= 0x000a0000,   /**< QSGMII interface */
+    e_ENET_IF_XFI	= 0x000b0000    /**< XFI interface */
 } e_EnetInterface;
 
 /**************************************************************************//**
@@ -118,8 +119,9 @@ typedef enum e_EnetMode
     e_ENET_MODE_SGMII_10    = (e_ENET_IF_SGMII | e_ENET_SPEED_10),      /**<    10 Mbps SGMII */
     e_ENET_MODE_SGMII_100   = (e_ENET_IF_SGMII | e_ENET_SPEED_100),     /**<   100 Mbps SGMII */
     e_ENET_MODE_SGMII_1000  = (e_ENET_IF_SGMII | e_ENET_SPEED_1000),    /**<  1000 Mbps SGMII */
-    e_ENET_MODE_XGMII_10000 = (e_ENET_IF_XGMII | e_ENET_SPEED_10000),    /**< 10000 Mbps XGMII */
-    e_ENET_MODE_QSGMII_1000 = (e_ENET_IF_QSGMII| e_ENET_SPEED_1000)    /**<  1000 Mbps QSGMII */
+    e_ENET_MODE_XGMII_10000 = (e_ENET_IF_XGMII | e_ENET_SPEED_10000),   /**< 10000 Mbps XGMII */
+    e_ENET_MODE_QSGMII_1000 = (e_ENET_IF_QSGMII| e_ENET_SPEED_1000),    /**<  1000 Mbps QSGMII */
+    e_ENET_MODE_XFI_10000 	= (e_ENET_IF_XFI   | e_ENET_SPEED_10000)    /**< 10000 Mbps XFI */
 } e_EnetMode;
 
 
@@ -140,7 +142,8 @@ typedef enum e_EnetMode
          ((mode) == e_ENET_MODE_SGMII_100  ) || \
          ((mode) == e_ENET_MODE_SGMII_1000 ) || \
          ((mode) == e_ENET_MODE_XGMII_10000) || \
-         ((mode) == e_ENET_MODE_QSGMII_1000))
+         ((mode) == e_ENET_MODE_QSGMII_1000) || \
+         ((mode) == e_ENET_MODE_XFI_10000))
 
 
 #define MAKE_ENET_MODE(_interface, _speed)     (e_EnetMode)((_interface) | (_speed))
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
index 13bad9c..5917edd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -43,6 +43,8 @@
 #include "xx_ext.h"
 #include "core_ext.h"
 
+
+
 /**************************************************************************//**
  @Group         gen_id  General Drivers Utilities
 
@@ -119,10 +121,6 @@ typedef enum e_ErrorType    /*   Comments / Associated Message Strings
                             /*   String: none, unless the function takes in more than one
                                  communication mode indications (in this case add
                                  parameter description).                                    */
-    ,E_INVALID_BYTE_ORDER   /**< Invalid byte order.                                        */
-                            /*   String: none, unless the function takes in more than one
-                                 byte order indications (in this case add parameter
-                                 description).                                              */
     ,E_INVALID_MEMORY_TYPE  /**< Invalid memory type.                                       */
                             /*   String: none, unless the function takes in more than one
                                  memory types (in this case add memory description,
@@ -363,30 +361,12 @@ int ERROR_DYNAMIC_LEVEL = ERROR_GLOBAL_LEVEL;
 #define RETURN_ERROR(_level, _err, _vmsg) \
         return ERROR_CODE(_err)
 
-#if (REPORT_EVENTS > 0)
-
-#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
-    do { \
-        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
-            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
-        } \
-    } while (0)
-
-#else
-
-#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
-
-#endif /* (REPORT_EVENTS > 0) */
-
 
 #else /* DEBUG_ERRORS > 0 */
 
 extern const char *dbgLevelStrings[];
 extern const char *errTypeStrings[];
 extern const char *moduleStrings[];
-#if (REPORT_EVENTS > 0)
-extern const char *eventStrings[];
-#endif /* (REPORT_EVENTS > 0) */
 
 
 #if ((defined(DEBUG_USING_STATIC_LEVEL)) && (DEBUG_DYNAMIC_LEVEL < REPORT_LEVEL_WARNING))
@@ -428,29 +408,6 @@ extern const char *eventStrings[];
     } while (0)
 
 
-#if (REPORT_EVENTS > 0)
-
-#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
-    do { \
-        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
-            XX_Print("~ %s %s Event " PRINT_FORMAT ": %s (flags: 0x%04x); ", \
-                     dbgLevelStrings[_ev##_LEVEL - 1], \
-                     moduleStrings[__ERR_MODULE__ >> 16], \
-                     PRINT_FMT_PARAMS, \
-                     eventStrings[((_ev) - EV_NO_EVENT - 1)], \
-                     (uint16_t)(_flg)); \
-            XX_Print _vmsg; \
-            XX_Print("\r\n"); \
-            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
-        } \
-    } while (0)
-
-#else /* not REPORT_EVENTS */
-
-#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
-
-#endif /* (REPORT_EVENTS > 0) */
-
 #endif /* (DEBUG_ERRORS > 0) */
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
index cdcac00..822b2bc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -229,7 +229,7 @@ static __inline__ void LIST_Add(t_List *p_New, t_List *p_Head)
                 This is useful for implementing queues.
 
  @Param[in]     p_New  - A pointer to a new list entry to be added.
- @Param[in]     p_Head - A pointer to a list head to add it after.
+ @Param[in]     p_Head - A pointer to a list head to add it before.
 
  @Return        none.
 *//***************************************************************************/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
index 94a9823..e12f382 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
index d8ab46e..6157bdc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
index 01e71e6..740a4fd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -245,12 +245,11 @@ t_Error     MM_Add(t_Handle h_MM, uint64_t base, uint64_t size);
 /**************************************************************************//**
  @Function      MM_Dump
 
- @Description   Prints results of free and busy lists into the file.
+ @Description   Prints results of free and busy lists.
 
  @Param[in]     h_MM        - Handle to the MM object.
- @Param[in]     buff        - A pointer to a buffer
 *//***************************************************************************/
-void        MM_Dump(t_Handle h_MM, void *buff);
+void        MM_Dump(t_Handle h_MM);
 
 /**************************************************************************//**
  @Function      MM_Free
@@ -293,6 +292,17 @@ uint64_t    MM_GetMemBlock(t_Handle h_MM, int index);
 *//***************************************************************************/
 bool        MM_InRange(t_Handle h_MM, uint64_t addr);
 
+/**************************************************************************//**
+ @Function      MM_GetFreeMemSize
+
+ @Description   Returns the size (in bytes) of free memory.
+
+ @Param[in]     h_MM    - Handle to the MM object.
+
+ @Return        Free memory size in bytes.
+*//***************************************************************************/
+uint64_t MM_GetFreeMemSize(t_Handle h_MM);
+
 
 /** @} */ /* end of mm_grp group */
 /** @} */ /* end of etc_id group */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
index 09a4b4f..ad5c412 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -45,13 +45,6 @@
 #if defined(NCSW_LINUX) && defined(__KERNEL__)
 #include <linux/kernel.h>
 
-#elif defined(NCSW_LINUX_USD)
-#include <stdio.h>
-#include "stdarg_ext.h"
-#include "std_ext.h"
-
-extern int vsscanf(const char *, const char *, va_list);
-
 #elif defined(NCSW_VXWORKS)
 #include "private/stdioP.h"
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
index 4ac4752..edddfe1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -42,21 +42,23 @@
 #include "std_ext.h"
 
 
+#define DPAA_VERSION    2
+
 typedef enum e_DpaaSwPortal {
     e_DPAA_SWPORTAL0 = 0,
     e_DPAA_SWPORTAL1,
-    e_DPAA_SWPORTAL2
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL_DUMMY_LAST
 } e_DpaaSwPortal;
 
 typedef enum {
     e_DPAA_DCPORTAL0 = 0,
-    e_DPAA_DCPORTAL1,
     e_DPAA_DCPORTAL2,
-    e_DPAA_DCPORTAL3
+    e_DPAA_DCPORTAL_DUMMY_LAST
 } e_DpaaDcPortal;
 
-#define DPAA_MAX_NUM_OF_SW_PORTALS  3
-#define DPAA_MAX_NUM_OF_DC_PORTALS  3
+#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
+#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
 
 /*****************************************************************************
  QMAN INTEGRATION-SPECIFIC DEFINITIONS
@@ -117,8 +119,8 @@ typedef enum {
 #define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
 #define FM_MAX_NUM_OF_MACSECS       1
 
-/*#define FM_MACSEC_SUPPORT*/
-/*#define FM_CAPWAP_SUPPORT*/
+#define FM_MACSEC_SUPPORT
+#define FM_CAPWAP_SUPPORT
 #define FM_DISABLE_SEC_ERRORS
 
 #define FM_LOW_END_RESTRICTION      /* prevents the use of TX port 1 with OP port 0 */
@@ -144,7 +146,6 @@ typedef enum {
 
 /* QMI defines */
 #define QMI_MAX_NUM_OF_TNUMS            15
-#define MAX_QMI_DEQ_SUBPORTAL           7
 
 /* FPM defines */
 #define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
@@ -159,110 +160,6 @@ typedef enum {
 #define BMI_MAX_FIFO_SIZE              (FM_MURAM_SIZE)
 #define PORT_MAX_WEIGHT                 4
 
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-typedef enum e_FmEventModules{
-    e_FM_MOD_PRS,                   /**< Parser event */
-    e_FM_MOD_KG,                    /**< Keygen event */
-    e_FM_MOD_PLCR,                  /**< Policer event */
-    e_FM_MOD_10G_MAC,               /**< 10G MAC  error event */
-    e_FM_MOD_1G_MAC,                /**< 1G MAC  error event */
-    e_FM_MOD_TMR,                   /**< Timer event */
-    e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC  Timer event */
-    e_FM_MOD_FMAN_CTRL,             /**< FMAN Controller  Timer event */
-    e_FM_MOD_MACSEC,
-    e_FM_MOD_DUMMY_LAST
-} e_FmEventModules;
-
-/**************************************************************************//**
- @Description   Enum for interrupts types
-*//***************************************************************************/
-typedef enum e_FmIntrType {
-    e_FM_INTR_TYPE_ERR,
-    e_FM_INTR_TYPE_NORMAL
-} e_FmIntrType;
-
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-typedef enum e_FmInterModuleEvent {
-    e_FM_EV_PRS,                    /**< Parser event */
-    e_FM_EV_ERR_PRS,                /**< Parser error event */
-    e_FM_EV_KG,                     /**< Keygen event */
-    e_FM_EV_ERR_KG,                 /**< Keygen error event */
-    e_FM_EV_PLCR,                   /**< Policer event */
-    e_FM_EV_ERR_PLCR,               /**< Policer error event */
-    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
-    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
-    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
-    e_FM_EV_ERR_MACSEC_MAC0,        /**< MACSEC MAC 0 error event */
-    e_FM_EV_TMR,                    /**< Timer event */
-    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
-    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
-    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
-    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
-    e_FM_EV_MACSEC_MAC0,            /**< MACSEC MAC 0 event */
-    e_FM_EV_FMAN_CTRL_0,            /**< Fman controller event 0 */
-    e_FM_EV_FMAN_CTRL_1,            /**< Fman controller event 1 */
-    e_FM_EV_FMAN_CTRL_2,            /**< Fman controller event 2 */
-    e_FM_EV_FMAN_CTRL_3,            /**< Fman controller event 3 */
-    e_FM_EV_DUMMY_LAST
-} e_FmInterModuleEvent;
-
-#define GET_FM_MODULE_EVENT(mod, id, intrType, event)                                                  \
-    switch(mod){                                                                                    \
-        case e_FM_MOD_PRS:                                                                          \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS:e_FM_EV_PRS;            \
-            break;                                                                                  \
-        case e_FM_MOD_KG:                                                                           \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG:e_FM_EV_DUMMY_LAST;      \
-            break;                                                                                  \
-        case e_FM_MOD_PLCR:                                                                         \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR:e_FM_EV_PLCR;          \
-            break;                                                                                  \
-        case e_FM_MOD_1G_MAC:                                                                       \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC0:e_FM_EV_DUMMY_LAST; break; \
-                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC1:e_FM_EV_DUMMY_LAST; break;    \
-                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC2:e_FM_EV_DUMMY_LAST; break;    \
-                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC3:e_FM_EV_DUMMY_LAST; break;    \
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_TMR:                                                                          \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_TMR;         \
-            break;                                                                                  \
-        case e_FM_MOD_1G_MAC_TMR:                                                                   \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC0_TMR; break; \
-                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC1_TMR; break; \
-                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC2_TMR; break; \
-                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST:e_FM_EV_1G_MAC3_TMR; break; \
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_MACSEC:                                                                   \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_MACSEC_MAC0:e_FM_EV_MACSEC_MAC0; break; \
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_FMAN_CTRL:                                                                    \
-            if (intrType == e_FM_INTR_TYPE_ERR) event = e_FM_EV_DUMMY_LAST;                         \
-            else switch(id){                                                                        \
-                 case(0): event = e_FM_EV_FMAN_CTRL_0; break;                                       \
-                 case(1): event = e_FM_EV_FMAN_CTRL_1; break;                                       \
-                 case(2): event = e_FM_EV_FMAN_CTRL_2; break;                                       \
-                 case(3): event = e_FM_EV_FMAN_CTRL_3; break;                                       \
-                 }                                                                                  \
-            break;                                                                                  \
-        default:event = e_FM_EV_DUMMY_LAST;                                                         \
-        break;}
-
 /*****************************************************************************
  FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
@@ -305,6 +202,9 @@ typedef enum e_FmMacsecInterModuleEvent {
 #define FM_QMI_NO_ECC_EXCEPTIONS
 #define FM_CSI_CFED_LIMIT
 #define FM_PEDANTIC_DMA
+#define FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+#define FM_FIFO_ALLOCATION_ALG
+#define FM_DEQ_PIPELINE_PARAMS_FOR_OP
 
 /* FM erratas */
 #define FM_RX_PREAM_4_ERRATA_DTSEC_A001
@@ -312,9 +212,15 @@ typedef enum e_FmMacsecInterModuleEvent {
 
 #define FM_DEBUG_TRACE_FMAN_A004                        /* No implementation, Out of LLD scope */
 #define FM_INT_BUF_LEAK_FMAN_A005                       /* No implementation, Out of LLD scope. App must avoid S/G */
+//TODO: #define FM___ERRATA_FMAN_A006
 
 /* #define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
 
+/*
+TKT056919 - axi12axi0 can hang if read request follows the single byte write on the very next cycle
+TKT038900 - FM dma lockup occur due to AXI slave protocol violation
+*/
 #define FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
 
-#endif /* __FM_INTEGRATION_EXT_H */
+
+#endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_ext.h
index 9e7c385..6814d5f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
index 7176900..3253782 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -40,9 +40,7 @@
 #define __PART_INTEGRATION_EXT_H
 
 #include "std_ext.h"
-#ifndef NCSW_LINUX
 #include "ddr_std_ext.h"
-#endif
 #include "dpaa_integration_ext.h"
 
 
@@ -394,9 +392,7 @@ t_Error P1023_GetDdrFactor( uintptr_t   gutilBase,
 
  @Return        E_OK on success; Other value otherwise.
 *//***************************************************************************/
-#ifndef NCSW_LINUX
 t_Error P1023_GetDdrType(uintptr_t gutilBase, e_DdrType *p_DdrType );
-#endif
 
 
 /** @} */ /* end of 1023_init_grp group */
@@ -431,16 +427,17 @@ t_Error P1023_GetDdrType(uintptr_t gutilBase, e_DdrType *p_DdrType );
 #define MODULE_FM_PORT          0x00150000
 #define MODULE_FM_MACSEC        0x00160000
 #define MODULE_FM_MACSEC_SECY   0x00170000
-#define MODULE_ECM              0x00180000
-#define MODULE_DMA              0x00190000
-#define MODULE_DDR              0x001a0000
-#define MODULE_LAW              0x001b0000
-#define MODULE_LBC              0x001c0000
-#define MODULE_I2C              0x001d0000
-#define MODULE_ESPI             0x001e0000
-#define MODULE_PCI              0x001f0000
-#define MODULE_DPA_PORT         0x00200000
-#define MODULE_USB              0x00210000
+#define MODULE_FM_SP            0x00280000
+#define MODULE_ECM              0x00190000
+#define MODULE_DMA              0x001a0000
+#define MODULE_DDR              0x001b0000
+#define MODULE_LAW              0x001c0000
+#define MODULE_LBC              0x001d0000
+#define MODULE_I2C              0x001e0000
+#define MODULE_ESPI             0x001f0000
+#define MODULE_PCI              0x00200000
+#define MODULE_DPA_PORT         0x00210000
+#define MODULE_USB              0x00220000
 
 /*****************************************************************************
  LBC INTEGRATION-SPECIFIC DEFINITIONS
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index e11f5a9..389572d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -42,7 +42,13 @@
 #include "std_ext.h"
 
 
-typedef enum {
+#define DPAA_VERSION    2
+
+/**************************************************************************//**
+ @Description   DPAA SW Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
     e_DPAA_SWPORTAL0 = 0,
     e_DPAA_SWPORTAL1,
     e_DPAA_SWPORTAL2,
@@ -56,7 +62,11 @@ typedef enum {
     e_DPAA_SWPORTAL_DUMMY_LAST
 } e_DpaaSwPortal;
 
-typedef enum {
+/**************************************************************************//**
+ @Description   DPAA Direct Connect Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
     e_DPAA_DCPORTAL0 = 0,
     e_DPAA_DCPORTAL1,
     e_DPAA_DCPORTAL2,
@@ -123,7 +133,7 @@ typedef enum
     e_QM_FQ_CHANNEL_FMAN0_SP9,
     e_QM_FQ_CHANNEL_FMAN0_SP10,
     e_QM_FQ_CHANNEL_FMAN0_SP11,
-
+/* difference between 5020 and 4080 :) */
     e_QM_FQ_CHANNEL_FMAN1_SP0 = 0x60,
     e_QM_FQ_CHANNEL_FMAN1_SP1,
     e_QM_FQ_CHANNEL_FMAN1_SP2,
@@ -152,14 +162,7 @@ typedef enum
 /*****************************************************************************
  BMan INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffer pools */
-
-
-/*****************************************************************************
- SEC INTEGRATION-SPECIFIC DEFINITIONS
-******************************************************************************/
-#define SEC_NUM_OF_DECOS    5
-#define SEC_ALL_DECOS_MASK  0x0000001F
+#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
 
 
 /*****************************************************************************
@@ -185,12 +188,9 @@ typedef enum
 #define FM_MAX_NUM_OF_SUB_PORTALS               12
 #define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
 
-#define FM_IPSEC_SUPPORT
-#define FM_IP_FRAG_N_REASSEM_SUPPORT
-
-/* Rams defines */
-#define FM_MURAM_SIZE                   (160*KILOBYTE)
-#define FM_IRAM_SIZE                    (64*KILOBYTE)
+/* RAMs defines */
+#define FM_MURAM_SIZE                   (160 * KILOBYTE)
+#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
 
 /* PCD defines */
 #define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
@@ -221,110 +221,6 @@ typedef enum
 #define PORT_MAX_WEIGHT                 16
 
 
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-typedef enum e_FmEventModules{
-    e_FM_MOD_PRS,                   /**< Parser event */
-    e_FM_MOD_KG,                    /**< Keygen event */
-    e_FM_MOD_PLCR,                  /**< Policer event */
-    e_FM_MOD_10G_MAC,               /**< 10G MAC error event */
-    e_FM_MOD_1G_MAC,                /**< 1G MAC error event */
-    e_FM_MOD_TMR,                   /**< Timer event */
-    e_FM_MOD_1G_MAC_TMR,            /**< 1G MAC timer event */
-    e_FM_MOD_FMAN_CTRL,             /**< FMAN Controller timer event */
-    e_FM_MOD_DUMMY_LAST
-} e_FmEventModules;
-
-/**************************************************************************//**
- @Description   Enum for interrupts types
-*//***************************************************************************/
-typedef enum e_FmIntrType {
-    e_FM_INTR_TYPE_ERR,
-    e_FM_INTR_TYPE_NORMAL
-} e_FmIntrType;
-
-/**************************************************************************//**
- @Description   Enum for inter-module interrupts registration
-*//***************************************************************************/
-typedef enum e_FmInterModuleEvent {
-    e_FM_EV_PRS,                    /**< Parser event */
-    e_FM_EV_ERR_PRS,                /**< Parser error event */
-    e_FM_EV_KG,                     /**< Keygen event */
-    e_FM_EV_ERR_KG,                 /**< Keygen error event */
-    e_FM_EV_PLCR,                   /**< Policer event */
-    e_FM_EV_ERR_PLCR,               /**< Policer error event */
-    e_FM_EV_ERR_10G_MAC0,           /**< 10G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC0,            /**< 1G MAC 0 error event */
-    e_FM_EV_ERR_1G_MAC1,            /**< 1G MAC 1 error event */
-    e_FM_EV_ERR_1G_MAC2,            /**< 1G MAC 2 error event */
-    e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
-    e_FM_EV_ERR_1G_MAC4,            /**< 1G MAC 4 error event */
-    e_FM_EV_TMR,                    /**< Timer event */
-    e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
-    e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
-    e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
-    e_FM_EV_1G_MAC3_TMR,            /**< 1G MAC 3 Timer event */
-    e_FM_EV_1G_MAC4_TMR,            /**< 1G MAC 4 Timer event */
-    e_FM_EV_FMAN_CTRL_0,            /**< Fman controller event 0 */
-    e_FM_EV_FMAN_CTRL_1,            /**< Fman controller event 1 */
-    e_FM_EV_FMAN_CTRL_2,            /**< Fman controller event 2 */
-    e_FM_EV_FMAN_CTRL_3,            /**< Fman controller event 3 */
-    e_FM_EV_DUMMY_LAST
-} e_FmInterModuleEvent;
-
-#define GET_FM_MODULE_EVENT(mod, id, intrType, event)                                               \
-    switch(mod){                                                                                    \
-        case e_FM_MOD_PRS:                                                                          \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS : e_FM_EV_PRS;          \
-            break;                                                                                  \
-        case e_FM_MOD_KG:                                                                           \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG : e_FM_EV_DUMMY_LAST;    \
-            break;                                                                                  \
-        case e_FM_MOD_PLCR:                                                                         \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR : e_FM_EV_PLCR;        \
-            break;                                                                                  \
-        case e_FM_MOD_10G_MAC:                                                                      \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_10G_MAC0 : e_FM_EV_DUMMY_LAST;\
-            break;                                                                                  \
-        case e_FM_MOD_1G_MAC:                                                                       \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC0 : e_FM_EV_DUMMY_LAST; break; \
-                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC1 : e_FM_EV_DUMMY_LAST; break; \
-                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC2 : e_FM_EV_DUMMY_LAST; break; \
-                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC3 : e_FM_EV_DUMMY_LAST; break; \
-                 case(4): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_1G_MAC4 : e_FM_EV_DUMMY_LAST; break; \
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_TMR:                                                                          \
-            if (id) event = e_FM_EV_DUMMY_LAST;                                                     \
-            else event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_TMR;       \
-            break;                                                                                  \
-        case e_FM_MOD_1G_MAC_TMR:                                                                   \
-            switch(id){                                                                             \
-                 case(0): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC0_TMR; break;\
-                 case(1): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC1_TMR; break;\
-                 case(2): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC2_TMR; break;\
-                 case(3): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC3_TMR; break;\
-                 case(4): event = (intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_1G_MAC4_TMR; break;\
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_FMAN_CTRL:                                                                    \
-            if (intrType == e_FM_INTR_TYPE_ERR) event = e_FM_EV_DUMMY_LAST;                         \
-            else switch(id){                                                                        \
-                 case(0): event = e_FM_EV_FMAN_CTRL_0; break;                                       \
-                 case(1): event = e_FM_EV_FMAN_CTRL_1; break;                                       \
-                 case(2): event = e_FM_EV_FMAN_CTRL_2; break;                                       \
-                 case(3): event = e_FM_EV_FMAN_CTRL_3; break;                                       \
-                 }                                                                                  \
-            break;                                                                                  \
-        default: event = e_FM_EV_DUMMY_LAST;                                                        \
-        break;}
-
 #define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
 
 /* p4080-rev1 unique features */
@@ -376,16 +272,8 @@ typedef enum e_FmInterModuleEvent {
 #define FM_PRS_MEM_ERRATA_FMAN_SW003
 #define FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
 
-#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 #define FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
 #define FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
-#ifdef FM_IPSEC_SUPPORT
-#define FM_DISABLE_UDP_CHECKSUM_AFTER_SEC
-#define FM_UPDATE_UDP_LENGTH_AFTER_SEC
-#define FM_ETH_TYPE_FIX
-#define FM_DISABLE_SEC_ERRORS
-#endif /* FM_IPSEC_SUPPORT */
-#endif /* defined(FM_IPSEC_SUPPORT) || ... */
 
 
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h
index 25e7b15..512f0ba 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
index c7b04a2..7dddd5a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -248,9 +248,14 @@ typedef enum e_ModuleId
 #define MODULE_FM_RTC           0x00160000
 #define MODULE_FM_MAC           0x00170000
 #define MODULE_FM_PORT          0x00180000
-#define MODULE_DPA              0x00190000
-#define MODULE_SRIO             0x00200000
-#define MODULE_DMA              0x00100000
+#define MODULE_FM_SP            0x00190000
+#define MODULE_DPA_PORT         0x001a0000
+#define MODULE_MII              0x001b0000
+#define MODULE_I2C              0x001c0000
+#define MODULE_DMA              0x001d0000
+#define MODULE_DDR              0x001e0000
+#define MODULE_ESPI             0x001f0000
+#define MODULE_DPAA_IPSEC       0x00200000
 
 /*****************************************************************************
  PAMU INTEGRATION-SPECIFIC DEFINITIONS
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
index 4c5515b..a622fc5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
index a0c76c4..a89b604 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -49,7 +49,6 @@
 #define UINT_TO_PTR(_val)           ((void*)(uintptr_t)(_val))
 
 #define PTR_MOVE(_ptr, _offset)     (void*)((uint8_t*)(_ptr) + (_offset))
-#define PTR_MOVE_16(_ptr, _offset)  (void*)((uint16_t*)(_ptr) + (_offset))
 
 
 #define WRITE_UINT8_UINT24(arg, data08, data24) WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
index 1cd804b..1c8aa58 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
index 3df9957..95e452d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
index 519c9a8..8037f7646 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
index 28d05bf..b3a8b57 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
index 1f79d51..298fdb8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
index 342bafd..40e6bf9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -39,13 +39,9 @@
 #ifndef __TYPES_EXT_H
 #define __TYPES_EXT_H
 
-
 #if defined(NCSW_LINUX)
 #include "types_linux.h"
 
-#elif defined(NCSW_LINUX_USD)
-#include "types_linux_usd.h"
-
 #elif defined(NCSW_VXWORKS)
 #include "types_vxworks.h"
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
index 9ffda3e..cab73f8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -54,27 +54,6 @@
  @{
 *//***************************************************************************/
 
-#if (defined(REPORT_EVENTS) && (REPORT_EVENTS > 0))
-/**************************************************************************//**
- @Function      XX_EventById
-
- @Description   Event reporting routine - executed only when REPORT_EVENTS=1.
-
- @Param[in]     event - Event code (e_Event).
- @Param[in]     appId - Application identifier.
- @Param[in]     flags - Event flags.
- @Param[in]     msg   - Event message.
-
- @Return        None
-*//***************************************************************************/
-void XX_EventById(uint32_t event, t_Handle appId, uint16_t flags, char *msg);
-
-#else  /* not REPORT_EVENTS */
-#define XX_EventById(event, appId, flags, msg)
-#endif /* REPORT_EVENTS */
-
-
-
 #ifdef DEBUG_XX_MALLOC
 void * XX_MallocDebug(uint32_t size, char *fname, int line);
 
@@ -142,19 +121,6 @@ void XX_FreeSmart(void *p_Memory);
 void XX_Free(void *p_Memory);
 
 /**************************************************************************//**
- @Function      XX_GetMemPartitionBase
-
- @Description   This routine gets the address of a memory segment according to
-                the memory type.
-
- @Param[in]     memPartitionId  - Memory partition ID; The value zero must
-                                  be mapped to the default heap partition.
-
- @Return        The address of the required memory type.
-*//***************************************************************************/
-void * XX_GetMemPartitionBase(int memPartitionId);
-
-/**************************************************************************//**
  @Function      XX_Print
 
  @Description   print a string.
@@ -163,16 +129,7 @@ void * XX_GetMemPartitionBase(int memPartitionId);
 
  @Return        None.
 *//***************************************************************************/
-void    XX_Print(char *str, ...);
-
-/**************************************************************************//**
- @Function      XX_GetChar
-
- @Description   Get character from console.
-
- @Return        Character is returned on success. Zero is returned otherwise.
-*//***************************************************************************/
-char    XX_GetChar(void);
+void XX_Print(char *str, ...);
 
 /**************************************************************************//**
  @Function      XX_SetIntr
@@ -243,27 +200,6 @@ uint32_t XX_DisableAllIntr(void);
 *//***************************************************************************/
 void XX_RestoreAllIntr(uint32_t flags);
 
-/**************************************************************************//**
- @Function      XX_Call
-
- @Description   Call a service in another task.
-
-                Activate the routine "f" via the queue identified by "IntrManagerId". The
-                parameter to "f" is Id - the handle of the destination object
-
- @Param[in]     intrManagerId   - Queue ID.
- @Param[in]     f               - routine pointer.
- @Param[in]     Id              - the parameter to be passed to f().
- @Param[in]     h_App           - Application handle.
- @Param[in]     flags           - Unused,
-
- @Return        E_OK is returned on success. E_FAIL is returned otherwise (usually an operating system level failure).
-*//***************************************************************************/
-t_Error XX_Call( uint32_t intrManagerId,
-                 t_Error (* f)(t_Handle),
-                 t_Handle Id,
-                 t_Handle h_App,
-                 uint16_t flags );
 
 /**************************************************************************//**
  @Function      XX_Exit
@@ -274,6 +210,7 @@ t_Error XX_Call( uint32_t intrManagerId,
 *//***************************************************************************/
 void    XX_Exit(int status);
 
+
 /*****************************************************************************/
 /*                        Tasklet Service Routines                           */
 /*****************************************************************************/
@@ -515,18 +452,6 @@ void XX_StartTimer(t_Handle h_Timer,
 void XX_StopTimer(t_Handle h_Timer);
 
 /**************************************************************************//**
- @Function      XX_GetExpirationTime
-
- @Description   Returns the time (in milliseconds) remaining until the
-                expiration of a timer.
-
- @Param[in]     h_Timer - A handle to a timer.
-
- @Return        The time left until the timer expires.
-*//***************************************************************************/
-uint32_t XX_GetExpirationTime(t_Handle h_Timer);
-
-/**************************************************************************//**
  @Function      XX_ModTimer
 
  @Description   Updates the expiration time of a timer.
@@ -543,17 +468,6 @@ uint32_t XX_GetExpirationTime(t_Handle h_Timer);
 void XX_ModTimer(t_Handle h_Timer, uint32_t msecs);
 
 /**************************************************************************//**
- @Function      XX_TimerIsActive
-
- @Description   Checks whether a timer is active (pending) or not.
-
- @Param[in]     h_Timer - A handle to a timer.
-
- @Return        0 - the timer is inactive; Non-zero value - the timer is active;
-*//***************************************************************************/
-int XX_TimerIsActive(t_Handle h_Timer);
-
-/**************************************************************************//**
  @Function      XX_Sleep
 
  @Description   Non-busy wait until the desired time (in milliseconds) has passed.
@@ -564,7 +478,7 @@ int XX_TimerIsActive(t_Handle h_Timer);
 
  @Cautions      This routine enables interrupts during its wait time.
 *//***************************************************************************/
-uint32_t XX_Sleep(uint32_t msecs);
+void XX_Sleep(uint32_t msecs);
 
 /**************************************************************************//**
  @Function      XX_UDelay
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
index 8886db2..0721079 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -58,6 +58,7 @@ const char *moduleStrings[] =
     ,"FM-Port"                  /* MODULE_FM_PORT */
     ,"FM-MACSEC"                /* MODULE_FM_MACSEC */
     ,"FM-MACSEC-SecY"           /* MODULE_FM_MACSEC_SECY */
+    ,"FM-SP"                    /* MODULE_FM_SP */
     ,"ECM"                      /* MODULE_ECM */
     ,"DMA"                      /* MODULE_DMA */
     ,"DDR"                      /* MODULE_DDR */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c
index ecf0bfd..36b99bc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/p1023_dflags.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/p1023_dflags.h
index b946944..5f61eb5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/p1023_dflags.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/p1023_dflags.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/p3040_4080_5020_dflags.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/p3040_4080_5020_dflags.h
index 2e3b5b9..7438974 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/p3040_4080_5020_dflags.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/p3040_4080_5020_dflags.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_ext.h
index 8813a33..20f27d2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_io_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_io_ext.h
index 2d36aa5..d6aa9d4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_io_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_io_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/types_linux.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/types_linux.h
index d7d9d72..ac15d66 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/types_linux.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/types_linux.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
index 5f5c808..893180b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -127,7 +127,7 @@ struct fm_port_non_rx_params {
     bool                    hash_results;       /**< Whether to have the hash-results in the Received buffer */
     bool                    time_stamp;         /**< Whether to have the time-stamp in the Received buffer */
     bool                    frag_enable;        /**< Whether to call extra config functions for OH, to enable fragmentation */
-    t_FmPortExtPools        op_ext_pools;       /**< External Buffer Pool params for OH port only */
+    t_FmExtPools            op_ext_pools;       /**< External Buffer Pool params for OH port only */
 };
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h
index 672b244..0b1a526 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h
@@ -42,8 +42,8 @@
 #include <linux/types.h>
 #include <linux/smp.h>  /* smp_processor_id() */
 
-/*#define FMT_K_DBG*/
-/*#define FMT_K_DBG_RUNTIME*/
+//#define FMT_K_DBG
+//#define FMT_K_DBG_RUNTIME
 
 #define _fmt_prk(stage, format, arg...)	\
 	printk(stage "fmt (cpu:%u): " format, smp_processor_id(), ##arg)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h
index 39ea260..8dda657 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/xx/xx.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/xx/xx.h
index 9d53d82..b183c86 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/xx/xx.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/xx/xx.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/system/sys_io.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/system/sys_io.c
index b2f097c..c106a8b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/system/sys_io.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/system/sys_io.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/Makefile
index 73ce182..ee3dbfc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/Makefile
@@ -5,6 +5,7 @@ EXTRA_CFLAGS           += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
+NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc
 
 EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 EXTRA_CFLAGS += -I$(NET_DPA)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
index df20707..4a906e5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,14 +29,11 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_fm.c
-
  @Author        Shlomi Gridish
-
  @Description   FM Linux wrapper functions.
-
 */
 
 #include <linux/version.h>
@@ -401,7 +398,6 @@ typedef _Packed struct {
     p_Ppids = (t_Ppids *)UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr+FM_BMI_PPIDS_OFFSET);
 
     for (i=0; i<FM_MAX_NUM_OF_1G_RX_PORTS; i++)
-        /* TODO: this was .rxPartitionId = ; liodnOffset seems to have the same meaning */
         p_LnxWrpFmDev->rxPorts[i].settings.param.specificParams.rxParams.liodnOffset =
                 p_Ppids->fmbm_ppid[phys1GRxPortId[i]-1];
 
@@ -796,23 +792,26 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if (FM_Init(p_LnxWrpFmDev->h_Dev) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
 
+    /* TODO: Why we mask these interrupts? */
     if (p_LnxWrpFmDev->err_irq == 0) {
         FM_SetException(p_LnxWrpFmDev->h_Dev, e_FM_EX_DMA_BUS_ERROR,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_READ_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_SYSTEM_WRITE_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_FM_WRITE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_DMA_SINGLE_PORT_ECC, FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_STALL_ON_TASKS , FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_SINGLE_ECC, FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_DOUBLE_ECC,FALSE);
-        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_IRAM_ECC,FALSE);
-        /* TODO: FmDisableRamsEcc assert for ramsEccOwners.
-         * FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_MURAM_ECC,FALSE);*/
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_SINGLE_ECC, FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DOUBLE_ECC,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_LIST_RAM_ECC,FALSE);
-        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_PIPELINE_ECC,FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_STORAGE_PROFILE_ECC, FALSE);
         FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_STATISTICS_RAM_ECC, FALSE);
-        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_FPM_SINGLE_ECC, FALSE);
-        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_QMI_SINGLE_ECC, FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_BMI_DISPATCH_RAM_ECC, FALSE);
+        FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_IRAM_ECC,FALSE);
+        /* TODO: FmDisableRamsEcc assert for ramsEccOwners.
+         * FM_SetException(p_LnxWrpFmDev->h_Dev,e_FM_EX_MURAM_ECC,FALSE);*/
     }
 
     if (p_LnxWrpFmDev->fmRtcBaseAddr)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
index 840ccd0..3e8cdce 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_fm.h
 
  @Author        Shlomi Gridish
@@ -66,8 +66,8 @@
 #define FM_DEFAULT_TX10G_OPENDMA 8 /* default TX 10g open dmas */
 #define FM_DEFAULT_RX10G_OPENDMA 8 /* default RX 10g open dmas */
 
-#define FRAG_DATA_ALIGN 64
 #define FRAG_MANIP_SPACE 128
+#define FRAG_DATA_ALIGN 64
 
 #ifndef CONFIG_FSL_FM_MAX_FRAME_SIZE
 #define CONFIG_FSL_FM_MAX_FRAME_SIZE 0
@@ -106,7 +106,7 @@ typedef struct {
     e_LnxWrpFmPortPcdDefUseCase defPcd;
     t_Handle                    h_DefNetEnv;
     t_Handle                    h_Schemes[FM_PCD_KG_NUM_OF_SCHEMES];
-    t_FmPortBufferPrefixContent buffPrefixContent;
+    t_FmBufferPrefixContent     buffPrefixContent;
     t_Handle                    h_Dev;
     t_Handle                    h_LnxWrpFmDev;
     uint16_t                    txCh;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
index 9c6d93b..2652ab3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_fm_port.c
 
  @Description   FMD wrapper - FMan port functions.
@@ -52,6 +52,7 @@
 #include <linux/spinlock.h>
 
 #include "sprint_ext.h"
+#include "fm_common.h"
 #include "fm_port_ext.h"
 #include "fm_ioctls.h"
 #include "lnxwrp_resources.h"
@@ -461,6 +462,8 @@ static t_Error ConfigureFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 	return E_OK;
 }
 
+#if 0
+TODO: To be removed.
 static t_Error InitFmPort3TupleDefPcd(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 {
 	t_LnxWrpFmDev *p_LnxWrpFmDev =
@@ -506,8 +509,7 @@ static t_Error InitFmPort3TupleDefPcd(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 		HEADER_TYPE_IPv4;	/* no special options */
 	p_netEnvParam->units[1].hdrs[0].hdr = HEADER_TYPE_ETH;
 	p_LnxWrpFmPortDev->h_DefNetEnv =
-		FM_PCD_SetNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev,
-						p_netEnvParam);
+		FM_PCD_NetEnvCharacteristicsSet(p_netEnvParam);
 	kfree(p_netEnvParam);
 	if (!p_LnxWrpFmPortDev->h_DefNetEnv)
 		RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM PCD!"));
@@ -604,8 +606,7 @@ static t_Error InitFmPort3TupleDefPcd(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 		}
 
 		p_LnxWrpFmPortDev->h_Schemes[i] =
-			FM_PCD_KgSetScheme(p_LnxWrpFmDev->h_PcdDev,
-					   p_schemeParam);
+			FM_PCD_KgSchemeSet(p_schemeParam);
 		if (!p_LnxWrpFmPortDev->h_Schemes[i]) {
 			kfree(p_schemeParam);
 			RETURN_ERROR(MAJOR, E_INVALID_HANDLE,
@@ -636,6 +637,7 @@ static t_Error InitFmPort3TupleDefPcd(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 
 	return FM_PORT_SetPCD(p_LnxWrpFmPortDev->h_Dev, &pcdParam);
 }
+#endif
 
 static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 {
@@ -681,28 +683,29 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
    and invoke the matching routine with proper casting of arguments. */
 	while (p_LnxWrpFmPortDev->settings.advConfig[i].p_Function
 	       && (i < FM_MAX_NUM_OF_ADV_SETTINGS)) {
-		ADV_CONFIG_CHECK_START(&
-				       (p_LnxWrpFmPortDev->settings.
-					advConfig[i]))
+
+/* TODO: Change this MACRO */
+			ADV_CONFIG_CHECK_START(
+				&(p_LnxWrpFmPortDev->settings.advConfig[i]))
 
 			ADV_CONFIG_CHECK(p_LnxWrpFmPortDev->h_Dev,
 					 FM_PORT_ConfigBufferPrefixContent,
 					 NCSW_PARAMS(1,
-						(t_FmPortBufferPrefixContent
-						 *)))
+						(t_FmBufferPrefixContent *)))
 
 			if((p_LnxWrpFmPortDev->settings.param.portType ==
 				    e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
 				   (p_LnxWrpFmPortDev->settings.
 						frag_enabled == TRUE)) {
+
 				ADV_CONFIG_CHECK(p_LnxWrpFmPortDev->h_Dev,
 					FM_PORT_ConfigExtBufPools,
-					NCSW_PARAMS(1, (t_FmPortExtPools *)))
-
+					NCSW_PARAMS(1, (t_FmExtPools *)))
 
+                /* this define contains an else */
+                MY_ADV_CONFIG_CHECK_END
+                }
 
-				MY_ADV_CONFIG_CHECK_END
-			}
 			/* Advance to next advanced configuration entry */
 			i++;
 	}
@@ -763,11 +766,11 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
  *  . for P4080, MXT is in range (0..63)
  *
  */
-
+#if 0
 	if ((p_LnxWrpFmPortDev->defPcd != e_NO_PCD) &&
 	    (InitFmPort3TupleDefPcd(p_LnxWrpFmPortDev) != E_OK))
 		RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-
+#endif
 	return E_OK;
 }
 
@@ -813,8 +816,6 @@ void fm_set_rx_port_params(struct fm_port *port,
 }
 EXPORT_SYMBOL(fm_set_rx_port_params);
 
-/* this function is called from oh_probe as well, thus it contains oh port
- * specific parameters (make sure everything is checked) */
 void fm_set_tx_port_params(struct fm_port *port,
 			   struct fm_port_non_rx_params *params)
 {
@@ -833,34 +834,35 @@ void fm_set_tx_port_params(struct fm_port *port,
 		params->hash_results;
 	p_LnxWrpFmPortDev->buffPrefixContent.passTimeStamp =
 		params->time_stamp;
-	p_LnxWrpFmPortDev->settings.frag_enabled = FALSE;
 
-	if ((params->frag_enable == TRUE) &&
-		(p_LnxWrpFmPortDev->settings.param.portType ==
-			e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) {
+    p_LnxWrpFmPortDev->settings.frag_enabled = FALSE;
 
-		p_LnxWrpFmPortDev->settings.frag_enabled = TRUE;
-		p_LnxWrpFmPortDev->buffPrefixContent.dataAlign =
-			FRAG_DATA_ALIGN;
-		p_LnxWrpFmPortDev->buffPrefixContent.manipExtraSpace =
-			FRAG_MANIP_SPACE;
-	}
+    if ((params->frag_enable == TRUE) &&
+        (p_LnxWrpFmPortDev->settings.param.portType ==
+            e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) {
+
+        p_LnxWrpFmPortDev->settings.frag_enabled = TRUE;
+        p_LnxWrpFmPortDev->buffPrefixContent.dataAlign =
+            FRAG_DATA_ALIGN;
+        p_LnxWrpFmPortDev->buffPrefixContent.manipExtraSpace =
+            FRAG_MANIP_SPACE;
+    }
 
 	ADD_ADV_CONFIG_START(p_LnxWrpFmPortDev->settings.advConfig,
 			     FM_MAX_NUM_OF_ADV_SETTINGS)
 
-		ADD_ADV_CONFIG_NO_RET(FM_PORT_ConfigBufferPrefixContent,
-				      ARGS(1,
-					   (&p_LnxWrpFmPortDev->
-					    buffPrefixContent)));
-
-		/* oh port specific parameter (for fragmentation only) */
-		if ((params->frag_enable == TRUE) &&
-			(p_LnxWrpFmPortDev->settings.param.portType ==
-				e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) {
-			ADD_ADV_CONFIG_NO_RET(FM_PORT_ConfigExtBufPools,
-					ARGS(1, (&params->op_ext_pools)));
-		}
+    ADD_ADV_CONFIG_NO_RET(FM_PORT_ConfigBufferPrefixContent,
+		      ARGS(1,
+                        (&p_LnxWrpFmPortDev->
+                        buffPrefixContent)));
+
+       /* oh port specific parameter (for fragmentation only) */
+       if ((params->frag_enable == TRUE) &&
+           (p_LnxWrpFmPortDev->settings.param.portType ==
+               e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) {
+           ADD_ADV_CONFIG_NO_RET(FM_PORT_ConfigExtBufPools,
+                   ARGS(1, (&params->op_ext_pools)));
+       }
 
 	ADD_ADV_CONFIG_END InitFmPortDev(p_LnxWrpFmPortDev);
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
index 60f5d1a..2b3c6de 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,14 +29,11 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_ioctls_fm.c
-
  @Author        Shlomi Gridish
-
  @Description   FM Linux wrapper functions.
-
 */
 
 /* Linux Headers ------------------- */
@@ -51,6 +48,7 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 #include <linux/fs.h>
 #include <linux/cdev.h>
 #include <linux/device.h>
@@ -90,48 +88,63 @@
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_SCHEMES)
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
 #error Error: please synchronize IOC_ defines!
 #endif
 
-/* please check for this one in fm_common.h: */
-#define FM_PCD_MAX_NUM_OF_OPTIONS(clsPlanEntries)   ((clsPlanEntries==256)? 8:((clsPlanEntries==128)? 7: ((clsPlanEntries==64)? 6: ((clsPlanEntries==32)? 5:0))))
-#if (IOC_FM_PCD_MAX_NUM_OF_OPTIONS != FM_PCD_MAX_NUM_OF_OPTIONS(FM_PCD_MAX_NUM_OF_CLS_PLANS))
+#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_GENERIC_REGS)
 #error Error: please synchronize IOC_ defines!
 #endif
-#undef FM_PCD_MAX_NUM_OF_OPTIONS
 
-#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
+#if CMP_IOC_DEFINE(FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY)
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_GENERIC_REGS)
+#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if CMP_IOC_DEFINE(FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY)
+#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_DEFAULT_GROUPS)
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_CLS_PLANS)
+#if CMP_IOC_DEFINE(FM_PCD_PRS_NUM_OF_LABELS)
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+#if CMP_IOC_DEFINE(FM_PCD_SW_PRS_SIZE)
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if CMP_IOC_DEFINE(FM_PCD_KG_NUM_OF_DEFAULT_GROUPS)
+#if CMP_IOC_DEFINE(FM_PCD_PRS_SW_OFFSET)
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#if CMP_IOC_DEFINE(FM_PCD_PRS_NUM_OF_LABELS)
+#if CMP_IOC_DEFINE(FM_PCD_PRS_SW_PATCHES_SIZE)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_PRS_SW_TAIL_SIZE)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_SW_PRS_MAX_IMAGE_SIZE)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if DPAA_VERSION >= 3
+#if CMP_IOC_DEFINE(FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES)
 #error Error: please synchronize IOC_ defines!
 #endif
+#endif
 
 #if CMP_IOC_DEFINE(FM_PCD_MAX_NUM_OF_CC_NODES)
 #error Error: please synchronize IOC_ defines!
@@ -161,11 +174,22 @@
 #error Error: please synchronize IOC_ defines!
 #endif
 
+#if CMP_IOC_DEFINE(FM_PCD_LAST_KEY_INDEX)
+#error Error: please synchronize IOC_ defines!
+#endif
+
 /* net_ioctls.h === net_ext.h assertions */
-#if CMP_IOC_DEFINE(NET_HEADER_FIELD_PPP_ALL_FIELDS)
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_PPP_PID)
 #error Error: please synchronize IOC_ defines!
 #endif
 
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_PPP_COMPRESSED)
+#error Error: please synchronize IOC_ defines!
+#endif
+
+#if CMP_IOC_DEFINE(NET_HEADER_FIELD_PPP_ALL_FIELDS)
+#error Error: please synchronize IOC_ defines!
+#endif
 
 #if CMP_IOC_DEFINE(NET_HEADER_FIELD_PPPoE_ALL_FIELDS)
 #error Error: please synchronize IOC_ defines!
@@ -309,43 +333,117 @@
 #error Error: please synchronize IOC_ defines!
 #endif
 
-#define ASSERT_IOC_NET_ENUM(def) ASSERT_COND((unsigned long)e_IOC_NET_##def == (unsigned long)def)
-
 void LnxWrpPCDIOCTLTypeChecking(void)
 {
+    /* fm_ext.h == fm_ioctls.h */
+    ASSERT_COND(sizeof(ioc_fm_port_bandwidth_params) == sizeof(t_FmPortsBandwidthParams));
+    ASSERT_COND(sizeof(ioc_fm_revision_info_t) == sizeof(t_FmRevisionInfo));
+
+    /* fm_pcd_ext.h == fm_pcd_ioctls.h */
+    /*ioc_fm_pcd_counters_params_t  : NOT USED */
+    /*ioc_fm_pcd_exception_params_t : private */
+    ASSERT_COND(sizeof(ioc_fm_pcd_prs_label_params_t) == sizeof(t_FmPcdPrsLabelParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_prs_sw_params_t) == sizeof(t_FmPcdPrsSwParams));
-    ASSERT_COND(sizeof(t_FmPcdKgSchemeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_kg_scheme_params_t));
-    /* t_FmPcdCcNodeParams */
-    ASSERT_COND(sizeof(t_FmPcdExtractEntry) == sizeof(ioc_fm_pcd_extract_entry_t));
-    ASSERT_COND(sizeof(t_KeysParams) == sizeof(t_KeysParams));
-
-    ASSERT_COND(sizeof(t_FmPcdCcTreeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_cc_tree_params_t));
-    ASSERT_COND(sizeof(t_FmPcdPlcrProfileParams) + sizeof(void *) == sizeof(ioc_fm_pcd_plcr_profile_params_t));
+    /*ioc_fm_pcd_kg_dflt_value_params_t : private */
+    ASSERT_COND(sizeof(ioc_fm_pcd_hdr_protocol_opt_u) == sizeof(u_FmPcdHdrProtocolOpt));
+    ASSERT_COND(sizeof(ioc_fm_pcd_fields_u) == sizeof(t_FmPcdFields));
+    ASSERT_COND(sizeof(ioc_fm_pcd_from_hdr_t) == sizeof(t_FmPcdFromHdr));
+    ASSERT_COND(sizeof(ioc_fm_pcd_from_field_t) == sizeof(t_FmPcdFromField));
+    ASSERT_COND(sizeof(ioc_fm_pcd_distinction_unit_t) == sizeof(t_FmPcdDistinctionUnit));
+    ASSERT_COND(sizeof(ioc_fm_pcd_net_env_params_t) == sizeof(t_FmPcdNetEnvParams) + sizeof(void *));
+    ASSERT_COND(sizeof(ioc_fm_pcd_extract_entry_t) == sizeof(t_FmPcdExtractEntry));
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_extract_mask_t) == sizeof(t_FmPcdKgExtractMask));
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_extract_dflt_t) == sizeof(t_FmPcdKgExtractDflt));
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_key_extract_and_hash_params_t) == sizeof(t_FmPcdKgKeyExtractAndHashParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_extracted_or_params_t) == sizeof(t_FmPcdKgExtractedOrParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_scheme_counter_t) == sizeof(t_FmPcdKgSchemeCounter));
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_plcr_profile_t) == sizeof(t_FmPcdKgPlcrProfile));
+#if DPAA_VERSION >= 3
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_storage_profile_t) == sizeof(t_FmPcdKgStorageProfile));
+#endif
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_cc_t) == sizeof(t_FmPcdKgCc));
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_scheme_params_t) == sizeof(t_FmPcdKgSchemeParams) + sizeof(void *));
+    ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_cc_params_t) == sizeof(t_FmPcdCcNextCcParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_plcr_params_t) == sizeof(t_FmPcdCcNextPlcrParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_enqueue_params_t) == sizeof(t_FmPcdCcNextEnqueueParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_kg_params_t) == sizeof(t_FmPcdCcNextKgParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_engine_params_t) == sizeof(t_FmPcdCcNextEngineParams));
     ASSERT_COND(sizeof(ioc_fm_pcd_cc_key_params_t) == sizeof(t_FmPcdCcKeyParams));
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
-    ASSERT_COND(sizeof(t_FmPcdManipRmvParams) == sizeof(ioc_fm_pcd_manip_rmv_params_t));
-    ASSERT_COND(sizeof(t_FmPcdManipInsrtParams) == sizeof(ioc_fm_pcd_manip_insrt_params_t));
-    ASSERT_COND(sizeof(t_FmPcdManipFragOrReasmParams) == sizeof(ioc_fm_pcd_manip_frag_or_reasm_params_t));
-    ASSERT_COND(sizeof(t_FmPcdManipLocationParams) == sizeof(ioc_fm_pcd_manip_location_params_t));
-    ASSERT_COND(sizeof(t_FmPcdManipInsrtByTemplateParams) == sizeof(ioc_fm_pcd_manip_insrt_by_template_params_t));
-    ASSERT_COND(sizeof(t_FmPcdStatsParams) == sizeof(ioc_fm_pcd_stats_params_t));
-#endif /* defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
+    ASSERT_COND(sizeof(ioc_keys_params_t) == sizeof(t_KeysParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_cc_node_params_t) == sizeof(t_FmPcdCcNodeParams) + sizeof(void *));
+    ASSERT_COND(sizeof(ioc_fm_pcd_hash_table_params_t) == sizeof(t_FmPcdHashTableParams) + sizeof(void *));
+    ASSERT_COND(sizeof(ioc_fm_pcd_cc_grp_params_t) == sizeof(t_FmPcdCcGrpParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_cc_tree_params_t) == sizeof(t_FmPcdCcTreeParams) + sizeof(void *));
+    ASSERT_COND(sizeof(ioc_fm_pcd_plcr_byte_rate_mode_param_t) == sizeof(t_FmPcdPlcrByteRateModeParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_plcr_non_passthrough_alg_param_t) == sizeof(t_FmPcdPlcrNonPassthroughAlgParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_plcr_next_engine_params_u) == sizeof(u_FmPcdPlcrNextEngineParams));
+    /*fm_pcd_port_params_t : private */
+    ASSERT_COND(sizeof(ioc_fm_pcd_plcr_profile_params_t) == sizeof(t_FmPcdPlcrProfileParams) + sizeof(void *));
+    /*ioc_fm_pcd_cc_tree_modify_next_engine_params_t : private */
 
 #ifdef FM_CAPWAP_SUPPORT
-    ASSERT_COND( sizeof(t_FmPcdStatsParams) == sizeof(ioc_fm_pcd_stats_params_t));
+#error TODO: unsupported feature
+/*
+    ASSERT_COND(sizeof(TODO) == sizeof(t_FmPcdManipHdrInsrtByTemplateParams));
+    ASSERT_COND(sizeof(TODO) == sizeof(t_CapwapFragmentationParams));
+    ASSERT_COND(sizeof(TODO) == sizeof(t_CapwapReassemblyParams));
+    ASSERT_COND(sizeof(TODO) == sizeof(t_FmPcdManipFragOrReasmParams));
+    ASSERT_COND(sizeof(TODO) == sizeof(t_FmPcdManipHdrRmvByHdrParams));
+*/
 #endif
+
+    /*ioc_fm_pcd_cc_node_modify_next_engine_params_t : private */
+    /*ioc_fm_pcd_cc_node_remove_key_params_t : private */
+    /*ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t : private */
+    /*ioc_fm_pcd_cc_node_modify_key_params_t : private */
+    /*ioc_fm_manip_hdr_info_t : private */
+    /*ioc_fm_pcd_hash_table_set_t : private */
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_ip_params_t) == sizeof(t_FmPcdManipFragIpParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_ip_params_t) == sizeof(t_FmPcdManipReassemIpParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_special_offload_ipsec_params_t) == sizeof(t_FmPcdManipSpecialOffloadIPSecParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_special_offload_params_t) == sizeof(t_FmPcdManipSpecialOffloadParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_rmv_generic_params_t) == sizeof(t_FmPcdManipHdrRmvGenericParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_insrt_generic_params_t) == sizeof(t_FmPcdManipHdrInsrtGenericParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_insrt_params_t) == sizeof(t_FmPcdManipHdrInsrtParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_rmv_params_t) == sizeof(t_FmPcdManipHdrRmvParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_hdr_params_t) == sizeof(t_FmPcdManipHdrParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_params_t) == sizeof(t_FmPcdManipFragParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_params_t) == sizeof(t_FmPcdManipReassemParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_params_t) == sizeof(t_FmPcdManipParams) + sizeof(void *));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_ip_stats_t) == sizeof(t_FmPcdManipReassemIpStats));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_ip_stats_t) == sizeof(t_FmPcdManipFragIpStats));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_reassem_stats_t) == sizeof(t_FmPcdManipReassemStats));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_stats_t) == sizeof(t_FmPcdManipFragStats));
+    ASSERT_COND(sizeof(ioc_fm_pcd_manip_stats_t) == sizeof(t_FmPcdManipStats));
+#if DPAA_VERSION >= 3
+    ASSERT_COND(sizeof(ioc_fm_pcd_frm_replic_group_params_t) == sizeof(t_FmPcdFrmReplicGroupParams));
+#endif
+
+    /* fm_port_ext.h == fm_port_ioctls.h */
+    ASSERT_COND(sizeof(ioc_fm_port_rate_limit_t) == sizeof(t_FmPortRateLimit));
+    ASSERT_COND(sizeof(ioc_fm_port_pcd_params_t) == sizeof(t_FmPortPcdParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_kg_scheme_select_t) == sizeof(t_FmPcdKgSchemeSelect));
+    ASSERT_COND(sizeof(ioc_fm_pcd_port_schemes_params_t) == sizeof(t_FmPcdPortSchemesParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_prs_start_t) == sizeof(t_FmPcdPrsStart));
+
+    return;
 }
 
+#define ASSERT_IOC_NET_ENUM(def) ASSERT_COND((unsigned long)e_IOC_NET_##def == (unsigned long)def)
+
 void LnxWrpPCDIOCTLEnumChecking(void)
 {
-    /* sampling checks */
+    /* net_ext.h == net_ioctls.h : sampling checks */
     ASSERT_IOC_NET_ENUM(HEADER_TYPE_MACSEC);
     ASSERT_IOC_NET_ENUM(HEADER_TYPE_PPP);
     ASSERT_IOC_NET_ENUM(MAX_HEADER_TYPE_COUNT);
+
+    /* fm_ext.h == fm_ioctls.h */
     ASSERT_COND((unsigned long)e_IOC_FM_PORT_TYPE_DUMMY == (unsigned long)e_FM_PORT_TYPE_DUMMY);
-    ASSERT_COND((unsigned long)e_IOC_FM_EX_MURAM_ECC == (unsigned long)e_FM_EX_MURAM_ECC);
-    ASSERT_COND((unsigned long)e_IOC_FM_COUNTERS_SEMAPHOR_SYNC_REJECT == (unsigned long)e_FM_COUNTERS_SEMAPHOR_SYNC_REJECT);
+    ASSERT_COND((unsigned long)e_IOC_EX_MURAM_ECC == (unsigned long)e_FM_EX_MURAM_ECC);
+    ASSERT_COND((unsigned long)e_IOC_FM_COUNTERS_DEQ_CONFIRM == (unsigned long)e_FM_COUNTERS_DEQ_CONFIRM);
+
+    /* fm_pcd_ext.h == fm_pcd_ioctls.h */
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES == (unsigned long)e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES);
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_PRS_EXCEPTION_SINGLE_ECC == (unsigned long)e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC);
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_PRS == (unsigned long)e_FM_PCD_PRS);
@@ -354,7 +452,7 @@ void LnxWrpPCDIOCTLEnumChecking(void)
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO == (unsigned long)e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO);
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_KG_DFLT_ILLEGAL == (unsigned long)e_FM_PCD_KG_DFLT_ILLEGAL);
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_KG_GENERIC_NOT_FROM_DATA == (unsigned long)e_FM_PCD_KG_GENERIC_NOT_FROM_DATA);
-    ASSERT_COND((unsigned long)e_IOC_FM_PCD_HDR_INDEX_3 == (unsigned long)e_FM_PCD_HDR_INDEX_3);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_HDR_INDEX_LAST == (unsigned long)e_FM_PCD_HDR_INDEX_LAST);
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_SHARED == (unsigned long)e_FM_PCD_PLCR_SHARED);
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_RFC_4115 == (unsigned long)e_FM_PCD_PLCR_RFC_4115);
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_COLOR_AWARE == (unsigned long)e_FM_PCD_PLCR_COLOR_AWARE);
@@ -366,17 +464,89 @@ void LnxWrpPCDIOCTLEnumChecking(void)
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER == (unsigned long)e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER);
     ASSERT_COND((unsigned long)e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP == (unsigned long)e_FM_PCD_ACTION_INDEXED_LOOKUP);
     ASSERT_COND((unsigned long)e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR == (unsigned long)e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR);
+#if !defined(FM_CAPWAP_SUPPORT)
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_INSRT_GENERIC == (unsigned long)e_FM_PCD_MANIP_INSRT_GENERIC);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_RMV_GENERIC == (unsigned long)e_FM_PCD_MANIP_RMV_GENERIC);
+#else
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE == (unsigned long)e_FM_PCD_MANIP_INSRT_BY_TEMPLATE);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_RMV_BY_HDR == (unsigned long)e_FM_PCD_MANIP_RMV_BY_HDR);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START == (unsigned long)e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START);
+#endif
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG == (unsigned long)e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH == (unsigned long)e_FM_PCD_MANIP_EIGHT_WAYS_HASH);
+
 #ifdef FM_CAPWAP_SUPPORT
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_STATS_PER_FLOWID == (unsigned long)e_FM_PCD_STATS_PER_FLOWID);
+#endif
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD == (unsigned long)e_FM_PCD_MANIP_SPECIAL_OFFLOAD);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_CC_STATS_MODE_FRAME == (unsigned long)e_FM_PCD_CC_STATS_MODE_FRAME);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG == (unsigned long)e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG);
+    ASSERT_COND((unsigned long)e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC == (unsigned long)e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC);
+
+    /* fm_port_ext.h == fm_port_ioctls.h */
+#if !defined(FM_CAPWAP_SUPPORT)
+    ASSERT_COND((unsigned long)e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR == (unsigned long)e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR);
+#else
     ASSERT_COND((unsigned long)e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR == (unsigned long)e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR);
 #endif
     ASSERT_COND((unsigned long)e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM == (unsigned long)e_FM_PORT_COUNTERS_DEQ_CONFIRM);
     ASSERT_COND((unsigned long)e_IOC_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8 == (unsigned long)e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8);
+
+    return;
 }
 
 static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned long arg, bool compat)
 {
     t_Error err = E_READ_FAILED;
 
+/*
+    Status: PCD API to fmlib (file: drivers/net/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h):
+
+Status: not exported, should be thru sysfs
+    FM_PCD_KgSchemeGetCounter
+    FM_PCD_KgSchemeSetCounter
+    FM_PCD_PlcrProfileGetCounter
+    FM_PCD_PlcrProfileSetCounter
+
+Status: not exported
+    FM_PCD_MatchTableFindNRemoveKey
+    FM_PCD_MatchTableFindNModifyNextEngine
+    FM_PCD_MatchTableFindNModifyKeyAndNextEngine
+    FM_PCD_MatchTableFindNModifyKey
+    FM_PCD_MatchTableGetIndexedHashBucket
+    FM_PCD_MatchTableGetNextEngine
+    FM_PCD_MatchTableGetKeyCounter
+
+Status: Exported, Not tested (no test available)
+    FM_PCD_HashTableSet
+    FM_PCD_HashTableDelete
+    FM_PCD_HashTableAddKey
+    FM_PCD_HashTableRemoveKey
+
+Status: not exported, would be nice to have
+    FM_PCD_HashTableModifyNextEngine
+    FM_PCD_HashTableModifyMissNextEngine
+    FM_PCD_HashTableGetMissNextEngine
+    FM_PCD_ManipGetStatistics
+
+Status: not exported
+#if DPAA_VERSION >= 3
+    FM_PCD_FrmReplicSetGroup
+    FM_PCD_FrmReplicDeleteGroup
+    FM_PCD_FrmReplicAddMember
+    FM_PCD_FrmReplicRemoveMember
+#endif
+
+Status: feature not supported
+#ifdef FM_CAPWAP_SUPPORT
+#error unsported feature
+    FM_PCD_StatisticsSetNode
+#endif
+
+*/
+    _fm_ioctl_dbg("cmd:0x%08x(type:0x%02x, nr:%u).\n",
+        cmd, _IOC_TYPE(cmd), _IOC_NR(cmd) - 20);
+
     switch (cmd)
     {
 #if defined(CONFIG_COMPAT)
@@ -460,6 +630,9 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             break;
         }
 
+        case FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT:
+            return  FM_PCD_SetAdvancedOffloadSupport(p_LnxWrpFmDev->h_PcdDev);
+
         case FM_PCD_IOC_ENABLE:
             return FM_PCD_Enable(p_LnxWrpFmDev->h_PcdDev);
 
@@ -631,7 +804,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 }
             }
 
-            param->id = FM_PCD_SetNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdNetEnvParams*)param);
+            param->id = FM_PCD_NetEnvCharacteristicsSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdNetEnvParams*)param);
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -692,7 +865,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     break;
             }
 
-            return FM_PCD_DeleteNetEnvCharacteristics(p_LnxWrpFmDev->h_PcdDev, id.obj);
+            return FM_PCD_NetEnvCharacteristicsDelete(id.obj);
         }
 
 #if defined(CONFIG_COMPAT)
@@ -746,7 +919,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 }
             }
 
-            param->id = FM_PCD_KgSetScheme(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdKgSchemeParams*)param);
+            param->id = FM_PCD_KgSchemeSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdKgSchemeParams*)param);
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -809,7 +982,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     break;
             }
 
-            return FM_PCD_KgDeleteScheme(p_LnxWrpFmDev->h_PcdDev, id.obj);
+            return FM_PCD_KgSchemeDelete(id.obj);
         }
 
 #if defined(CONFIG_COMPAT)
@@ -921,7 +1094,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 }
             }
 
-            param->id = FM_PCD_CcSetNode(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcNodeParams*)param);
+            param->id = FM_PCD_MatchTableSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcNodeParams*)param);
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -987,7 +1160,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     break;
             }
 
-            return FM_PCD_CcDeleteNode(p_LnxWrpFmDev->h_PcdDev, id.obj);
+            return FM_PCD_MatchTableDelete(id.obj);
         }
 
 #if defined(CONFIG_COMPAT)
@@ -1041,7 +1214,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 }
             }
 
-            param->id = FM_PCD_CcBuildTree(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcTreeParams*)param);
+            param->id = FM_PCD_CcRootBuild(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdCcTreeParams*)param);
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -1104,7 +1277,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     break;
             }
 
-            return FM_PCD_CcDeleteTree(p_LnxWrpFmDev->h_PcdDev, id.obj);
+            return FM_PCD_CcRootDelete(id.obj);
         }
 
 #if defined(CONFIG_COMPAT)
@@ -1135,7 +1308,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 }
 
                 memset(compat_param, 0, sizeof(ioc_fm_pcd_plcr_profile_params_t));
-                if (copy_from_user(compat_param, (ioc_compat_fm_pcd_plcr_profile_params_t *)compat_ptr(arg),
+                if (copy_from_user(compat_param, (
+                            ioc_compat_fm_pcd_plcr_profile_params_t *)compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_plcr_profile_params_t))) {
                     XX_Free(compat_param);
                     XX_Free(param);
@@ -1195,7 +1369,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                         }
                         goto invalid_port_id;
 
-                    case (e_IOC_FM_PORT_TYPE_OFFLINE_PARSING):
+                    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                         if (port_params->port_id && port_params->port_id < FM_MAX_NUM_OF_OH_PORTS) {
                             h_Port = p_LnxWrpFmDev->opPorts[port_params->port_id - 1].h_Dev;
                             break;
@@ -1213,7 +1387,7 @@ invalid_port_id:
                 XX_Free(port_params);
             }
 
-            param->id = FM_PCD_PlcrSetProfile(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdPlcrProfileParams*)param);
+            param->id = FM_PCD_PlcrProfileSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdPlcrProfileParams*)param);
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -1274,7 +1448,7 @@ invalid_port_id:
                     break;
             }
 
-            return FM_PCD_PlcrDeleteProfile(p_LnxWrpFmDev->h_PcdDev, id.obj);
+            return FM_PCD_PlcrProfileDelete(id.obj);
         }
 
 #if defined(CONFIG_COMPAT)
@@ -1328,15 +1502,15 @@ invalid_port_id:
                 }
             }
 
-            err = FM_PCD_CcTreeModifyNextEngine(p_LnxWrpFmDev->h_PcdDev,
-                    param->id,
-                    param->grp_indx,
-                    param->indx,
-                    (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+            err = FM_PCD_CcRootModifyNextEngine(param->id,
+                                                param->grp_indx,
+                                                param->indx,
+                                                (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
 
             XX_Free(param);
             break;
         }
+
 #if defined(CONFIG_COMPAT)
         case FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT:
 #endif
@@ -1388,8 +1562,7 @@ invalid_port_id:
                 }
             }
 
-            err = FM_PCD_CcNodeModifyNextEngine(p_LnxWrpFmDev->h_PcdDev,
-                    param->id,
+            err = FM_PCD_MatchTableModifyNextEngine(param->id,
                     param->key_indx,
                     (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
 
@@ -1448,7 +1621,7 @@ invalid_port_id:
                 }
             }
 
-            err = FM_PCD_CcNodeModifyMissNextEngine(p_LnxWrpFmDev->h_PcdDev, param->id,
+            err = FM_PCD_MatchTableModifyMissNextEngine(param->id,
                     (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
 
             XX_Free(param);
@@ -1508,12 +1681,11 @@ invalid_port_id:
                 }
             }
 
-            err = FM_PCD_CcNodeRemoveKey(p_LnxWrpFmDev->h_PcdDev, param->id, param->key_indx);
+            err = FM_PCD_MatchTableRemoveKey(param->id, param->key_indx);
 
             XX_Free(param);
             break;
         }
-
 #if defined(CONFIG_COMPAT)
         case FM_PCD_IOC_CC_NODE_ADD_KEY_COMPAT:
 #endif
@@ -1588,8 +1760,7 @@ invalid_port_id:
             }
             param->key_params.p_mask = p_mask;
 
-            err = FM_PCD_CcNodeAddKey(p_LnxWrpFmDev->h_PcdDev,
-                    param->id,
+            err = FM_PCD_MatchTableAddKey(param->id,
                     param->key_indx,
                     param->key_size,
                     (t_FmPcdCcKeyParams*)(&param->key_params));
@@ -1652,8 +1823,7 @@ invalid_port_id:
                 }
             }
 
-            err = FM_PCD_CcNodeModifyKeyAndNextEngine(p_LnxWrpFmDev->h_PcdDev,
-                    param->id,
+            err = FM_PCD_MatchTableModifyKeyAndNextEngine(param->id,
                     param->key_indx,
                     param->key_size,
                     (t_FmPcdCcKeyParams*)(&param->key_params));
@@ -1661,7 +1831,147 @@ invalid_port_id:
             XX_Free(param);
             break;
         }
+#if defined(CONFIG_COMPAT)
+#error TODO: compat ioctl call not implemented!
+        case FM_PCD_IOC_HASH_TABLE_SET_COMPAT:
+#endif
+        case FM_PCD_IOC_HASH_TABLE_SET:
+        {
+            ioc_fm_pcd_hash_table_params_t *param;
+
+            param = kmalloc(sizeof(*param), GFP_KERNEL);
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                /* TODO: return -ENOMEM;*/
+
+            memset(param, 0, sizeof(*param)) ;
+
+#if defined(CONFIG_COMPAT)
+#warning TODO: compat ioctl call not implemented!
+            if (compat)
+            {
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_hash_table_params_t *)arg,
+                                    sizeof(ioc_fm_pcd_hash_table_params_t)))
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            param->id = FM_PCD_HashTableSet(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdHashTableParams *) param);
+
+#if defined(CONFIG_COMPAT)
+#warning TODO: compat ioctl call not implemented!
+            if (compat)
+            {
+            }
+            else
+#endif
+            {
+                if (param->id && !copy_to_user((ioc_fm_pcd_hash_table_params_t *)arg,
+                                        param, sizeof(ioc_fm_pcd_hash_table_params_t)))
+                    err = E_OK;
+            }
+
+            kfree(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_HASH_TABLE_DELETE_COMPAT:
+#endif
+        case FM_PCD_IOC_HASH_TABLE_DELETE:
+        {
+            ioc_fm_obj_t id;
+
+            memset(&id, 0, sizeof(ioc_fm_obj_t));
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_obj_t compat_id;
+
+                if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+
+                id.obj = compat_ptr(compat_id.obj);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&id, (ioc_fm_obj_t *) arg, sizeof(ioc_fm_obj_t)))
+                    break;
+            }
+
+            return FM_PCD_HashTableDelete(id.obj);
+        }
+#if defined(CONFIG_COMPAT)
+#warning TODO: compat ioctl call not implemented!
+        case FM_PCD_IOC_HASH_TABLE_ADD_KEY_COMPAT:
+#endif
+        case FM_PCD_IOC_HASH_TABLE_ADD_KEY:
+        {
+            ioc_fm_pcd_hash_table_add_key_params_t *param = NULL;
+
+            param = kmalloc(sizeof(*param), GFP_KERNEL);
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                /* TODO: return -ENOMEM;*/
+
+            memset(param, 0, sizeof(*param)) ;
+
+#if defined(CONFIG_COMPAT)
+#warning TODO: compat ioctl call not implemented!
+            if (compat)
+            {
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_hash_table_add_key_params_t *)arg,
+                                    sizeof(ioc_fm_pcd_hash_table_add_key_params_t)))
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
+            err = FM_PCD_HashTableAddKey(param->p_hash_tbl, param->key_size, (t_FmPcdCcKeyParams  *)param->p_key_params);
+
+            kfree(param);
+            break;
+        }
+
+#if defined(CONFIG_COMPAT)
+#warning TODO: compat ioctl call not implemented!
+        case FM_PCD_IOC_HASH_TABLE_REMOVE_KEY_COMPAT:
+#endif
+        case FM_PCD_IOC_HASH_TABLE_REMOVE_KEY:
+        {
+            ioc_fm_pcd_hash_table_remove_key_params_t *param = NULL;
+
+            param = kmalloc(sizeof(*param), GFP_KERNEL);
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                /* TODO: return -ENOMEM;*/
+
+            memset(param, 0, sizeof(*param)) ;
+
+#if defined(CONFIG_COMPAT)
+#warning TODO: compat ioctl call not implemented!
+            if (compat)
+            {
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_hash_table_remove_key_params_t *)arg,
+                                    sizeof(ioc_fm_pcd_hash_table_remove_key_params_t)))
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+            }
 
+            err = FM_PCD_HashTableRemoveKey(param->p_hash_tbl, param->key_size, param->p_key);
+
+            kfree(param);
+            break;
+        }
 #if defined(CONFIG_COMPAT)
         case FM_PCD_IOC_CC_NODE_MODIFY_KEY_COMPAT:
 #endif
@@ -1760,8 +2070,7 @@ invalid_port_id:
                 param->p_mask = mask;
             }
 
-            err = FM_PCD_CcNodeModifyKey(p_LnxWrpFmDev->h_PcdDev,
-                    param->id,
+            err = FM_PCD_MatchTableModifyKey(param->id,
                     param->key_indx,
                     param->key_size,
                     param->p_key,
@@ -1773,7 +2082,7 @@ invalid_port_id:
             XX_Free(param);
             break;
         }
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+
 #if defined(CONFIG_COMPAT)
         case FM_PCD_IOC_MANIP_SET_NODE_COMPAT:
 #else
@@ -1828,7 +2137,7 @@ invalid_port_id:
                 }
             }
 
-            param->id = FM_PCD_ManipSetNode(p_LnxWrpFmDev->h_PcdDev,
+            param->id = FM_PCD_ManipNodeSet(p_LnxWrpFmDev->h_PcdDev,
                             (t_FmPcdManipParams *)param);
 
 #if defined(CONFIG_COMPAT)
@@ -1867,6 +2176,7 @@ invalid_port_id:
             XX_Free(param);
         }
         break;
+
 #if defined(CONFIG_COMPAT)
         case FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT:
 #else
@@ -1893,10 +2203,9 @@ invalid_port_id:
                     break;
             }
 
-            return FM_PCD_ManipDeleteNode(p_LnxWrpFmDev->h_PcdDev, id.obj);
+            return FM_PCD_ManipNodeDelete(id.obj);
         }
         break;
-#endif /* defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
 
 #ifdef FM_CAPWAP_SUPPORT
 #if defined(CONFIG_COMPAT)
@@ -1914,7 +2223,10 @@ invalid_port_id:
 #endif /* FM_CAPWAP_SUPPORT */
 
         default:
-            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL cmd (0x%08x):(0x%02x:0x%02x)!", cmd, _IOC_TYPE(cmd), _IOC_NR(cmd)));
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                ("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
+                cmd, _IOC_TYPE(cmd), _IOC_NR(cmd)));
+
             break;
     }
 
@@ -1925,16 +2237,12 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
 {
     t_Error err = E_READ_FAILED;
 
-    DBG(TRACE, ("p_LnxWrpFmDev - 0x%08lx, cmd - 0x%08x, arg - 0x%08lx \n", (uintptr_t)p_LnxWrpFmDev, cmd, arg));
-
     switch (cmd)
     {
         case FM_IOC_SET_PORTS_BANDWIDTH:
         {
             ioc_fm_port_bandwidth_params *param;
 
-            ASSERT_COND(sizeof(t_FmPortsBandwidthParams) == sizeof(ioc_fm_port_bandwidth_params));
-
             param = (ioc_fm_port_bandwidth_params*) XX_Malloc(sizeof(ioc_fm_port_bandwidth_params));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
@@ -1969,8 +2277,6 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
         {
             ioc_fm_revision_info_t *param;
 
-            ASSERT_COND(sizeof(t_FmRevisionInfo) == sizeof(ioc_fm_revision_info_t));
-
             param = (ioc_fm_revision_info_t *) XX_Malloc(sizeof(ioc_fm_revision_info_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
@@ -2115,7 +2421,9 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
 t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd, unsigned long arg, bool compat)
 {
     t_Error err = E_READ_FAILED;
-    DBG(TRACE, ("p_LnxWrpFmPortDev - 0x%08lx, cmd - 0x%08x, arg - 0x%08lx", (uintptr_t)p_LnxWrpFmPortDev, cmd, arg));
+
+    _fm_ioctl_dbg("cmd:0x%08x(type:0x%02x, nr:%u).\n",
+        cmd, _IOC_TYPE(cmd), _IOC_NR(cmd) - 50);
 
     switch (cmd)
     {
@@ -2151,8 +2459,6 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
         {
             ioc_fm_port_rate_limit_t *param;
 
-            ASSERT_COND(sizeof(t_FmPortRateLimit) == sizeof(ioc_fm_port_rate_limit_t));
-
             param = (ioc_fm_port_rate_limit_t *) XX_Malloc(sizeof(ioc_fm_port_rate_limit_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
@@ -2295,8 +2601,6 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
 
             long copy_fail = 0;
 
-            ASSERT_COND(sizeof(t_FmPortPcdParams) == sizeof(ioc_fm_port_pcd_params_t));
-
             port_pcd_params = (ioc_fm_port_pcd_params_t *) XX_Malloc(
                     sizeof(ioc_fm_port_pcd_params_t) +
                     sizeof(ioc_fm_port_pcd_prs_params_t) +
@@ -2312,6 +2616,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
                     sizeof(ioc_fm_port_pcd_cc_params_t) +
                     sizeof(ioc_fm_port_pcd_kg_params_t) +
                     sizeof(ioc_fm_port_pcd_plcr_params_t));
+
             port_pcd_prs_params  = (ioc_fm_port_pcd_prs_params_t *)  (port_pcd_params + 1);
             port_pcd_cc_params   = (ioc_fm_port_pcd_cc_params_t *)   (port_pcd_prs_params + 1);
             port_pcd_kg_params   = (ioc_fm_port_pcd_kg_params_t *)   (port_pcd_cc_params + 1);
@@ -2484,8 +2789,6 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
         {
             ioc_fm_pcd_kg_scheme_select_t *param;
 
-            ASSERT_COND(sizeof(t_FmPcdKgSchemeSelect) == sizeof(ioc_fm_pcd_kg_scheme_select_t));
-
             param = (ioc_fm_pcd_kg_scheme_select_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_kg_scheme_select_t));
             if (!param)
@@ -2571,8 +2874,6 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
         {
             ioc_fm_pcd_port_schemes_params_t *param;
 
-            ASSERT_COND(sizeof(t_FmPcdPortSchemesParams) == sizeof(ioc_fm_pcd_port_schemes_params_t));
-
             param = (ioc_fm_pcd_port_schemes_params_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_port_schemes_params_t));
             if (!param)
@@ -2616,8 +2917,6 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
         {
             ioc_fm_pcd_port_schemes_params_t *param;
 
-            ASSERT_COND(sizeof(t_FmPcdPortSchemesParams) == sizeof(ioc_fm_pcd_port_schemes_params_t));
-
             param = (ioc_fm_pcd_port_schemes_params_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_port_schemes_params_t));
             if (!param)
@@ -2658,8 +2957,6 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
         {
             ioc_fm_pcd_prs_start_t *param;
 
-            ASSERT_COND(sizeof(t_FmPcdPrsStart) == sizeof(ioc_fm_pcd_prs_start_t));
-
             param = (ioc_fm_pcd_prs_start_t *) XX_Malloc(sizeof(ioc_fm_pcd_prs_start_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
@@ -2761,7 +3058,9 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
         }
 #endif /* defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
         default:
-            RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL cmd (0x%08x):(0x%02x:0x%02x)!", cmd, _IOC_TYPE(cmd), _IOC_NR(cmd)));
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION,
+                ("invalid ioctl: cmd:0x%08x(type:0x%02x, nr:0x%02x.\n",
+                cmd, _IOC_TYPE(cmd), _IOC_NR(cmd)));
     }
 
     RETURN_ERROR(MINOR, E_INVALID_OPERATION, ("IOCTL port"));
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
index 5e09ae8..7f8767e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_fm_compat_ioctls.c
 
  @Description   FM PCD compat functions
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
index ce8f412..be509e8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_ioctls_fm_compat.h
 
  @Description   FM PCD compat structures definition.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
index be0940d..00dd846 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_resources.c
 
  @Description   FMD wrapper resource allocation functions.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h
index eb1517d..1b72e1d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_resources.h
 
  @Description   FMD wrapper resource allocation functions.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c
index 210725a..bbce091 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_sysfs.c
 
  @Description   FM wrapper sysfs related functions.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h
index 713e973..d5ba46d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_sysfs.h
 
  @Description   FM sysfs functions.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c
index 37d5e09..4eeb7fd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_sysfs_fm.c
 
  @Description   FM sysfs related functions.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h
index 3c98ff1..8aff850 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_sysfs_fm.h
 
  @Description   FM sysfs functions.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c
index 856139c..8e058d7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_sysfs_fm_port.c
 
  @Description   FM port sysfs related functions.
@@ -309,13 +309,14 @@ int fm_port_sysfs_create(struct device *dev)
 		    (&dev->kobj, &fm_rx_port_dev_stats_attr_grp) != 0)
 			return -EIO;
 		break;
+	/* TODO:FMD16 e_FM_PORT_TYPE_DUMMY is accutally a HC port.
+	 * NetCommSw defined this way... no idea why!!! */
+	case e_FM_PORT_TYPE_DUMMY:
 	case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
-	case e_FM_PORT_TYPE_OH_HOST_COMMAND:
 		if (sysfs_create_group
 		    (&dev->kobj, &fm_oh_port_dev_stats_attr_grp) != 0)
 			return -EIO;
 		break;
-	case e_FM_PORT_TYPE_DUMMY:
 	default:
 		WARN(1, "FMD: failure at %s:%d/%s()!\n", __FILE__, __LINE__,
 		     __func__);
@@ -349,11 +350,12 @@ void fm_port_sysfs_destroy(struct device *dev)
 	case e_FM_PORT_TYPE_RX_10G:
 		sysfs_remove_group(&dev->kobj, &fm_rx_port_dev_stats_attr_grp);
 		break;
+	/* TODO:FMD16 e_FM_PORT_TYPE_DUMMY is accutally a HC port.
+	 * NetCommSw defined this way... no idea why!!! */
+	case e_FM_PORT_TYPE_DUMMY:
 	case e_FM_PORT_TYPE_OH_OFFLINE_PARSING:
-	case e_FM_PORT_TYPE_OH_HOST_COMMAND:
 		sysfs_remove_group(&dev->kobj, &fm_oh_port_dev_stats_attr_grp);
 		break;
-	case e_FM_PORT_TYPE_DUMMY:
 	default:
 		WARN(1, "FMD: failure at %s:%d/%s()!\n", __FILE__, __LINE__,
 		     __func__);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h
index 8ca7ca3..03b3a03 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -29,8 +29,8 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-/*
 
+/*
  @File          lnxwrp_sysfs_fm_port.h
 
  @Description   FM port sysfs functions.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/stdlib.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/stdlib.c
index 8032753b..851bcf1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/stdlib.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/stdlib.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/udivdi3.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/udivdi3.c
index 1990f02..419e27e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/udivdi3.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/udivdi3.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
index 9419e40..e439bc6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
@@ -1,5 +1,5 @@
-/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
- * All rights reserved.
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -675,13 +675,15 @@ int XX_TimerIsActive(t_Handle h_Timer)
   return timer_pending((struct timer_list *)h_Timer);
 }
 
-uint32_t XX_Sleep(uint32_t msecs)
+void XX_Sleep(uint32_t msecs)
 {
     int tmp_jiffies = (msecs*HZ)/1000;
 
     if ((msecs*HZ)%1000)
         tmp_jiffies++;
-    return schedule_timeout(tmp_jiffies);
+    schedule_timeout(tmp_jiffies);
+
+    return;
 }
 
 /*BEWARE!!!!! UDelay routine is BUSY WAITTING!!!!!*/
diff --git a/include/linux/fmd/Peripherals/fm_ioctls.h b/include/linux/fmd/Peripherals/fm_ioctls.h
index ea86c14..cee9d19 100644
--- a/include/linux/fmd/Peripherals/fm_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_ioctls.h
@@ -103,14 +103,11 @@ typedef uint32_t    ioc_fm_port_frame_err_select_t;                     /**< typ
                 (must match enum e_FmPortType defined in fm_ext.h)
 *//***************************************************************************/
 typedef enum ioc_fm_port_type {
-    e_IOC_FM_PORT_TYPE_OFFLINE_PARSING, /**< Offline parsing port (id's: 0-6, share id's with
-                                             host command, so must have exclusive id) */
-    e_IOC_FM_PORT_TYPE_HOST_COMMAND,    /**< Host command port (id's: 0-6, share id's with
-                                             offline parsing ports, so must have exclusive id) */
-    e_IOC_FM_PORT_TYPE_RX,              /**< 1G Rx port (id's: 0-3) */
-    e_IOC_FM_PORT_TYPE_RX_10G,          /**< 10G Rx port (id's: 0) */
-    e_IOC_FM_PORT_TYPE_TX,              /**< 1G Tx port (id's: 0-3) */
-    e_IOC_FM_PORT_TYPE_TX_10G,          /**< 10G Tx port (id's: 0) */
+    e_IOC_FM_PORT_TYPE_OH_OFFLINE_PARSING = 0,  /**< Offline parsing port */
+    e_IOC_FM_PORT_TYPE_RX,                      /**< 1G Rx port */
+    e_IOC_FM_PORT_TYPE_RX_10G,                  /**< 10G Rx port */
+    e_IOC_FM_PORT_TYPE_TX,                      /**< 1G Tx port */
+    e_IOC_FM_PORT_TYPE_TX_10G,                  /**< 10G Tx port */
     e_IOC_FM_PORT_TYPE_DUMMY
 } ioc_fm_port_type;
 
@@ -136,24 +133,24 @@ typedef enum ioc_fm_port_type {
 *//***************************************************************************/
 typedef enum ioc_fm_exceptions {
     e_IOC_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
-    e_IOC_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error */
-    e_IOC_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side */
-    e_IOC_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side */
-    e_IOC_FM_EX_FPM_STALL_ON_TASKS ,        /**< Stall of tasks on FPM */
-    e_IOC_FM_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
-    e_IOC_FM_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
-    e_IOC_FM_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
-    e_IOC_FM_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occured on QMI */
-    e_IOC_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeu from unknown port id */
-    e_IOC_FM_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
-    e_IOC_FM_EX_BMI_PIPELINE_ECC,           /**< Pipeline Table ECC Error */
-    e_IOC_FM_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
-    e_IOC_FM_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
-    e_IOC_FM_EX_IRAM_ECC,                   /**< Double bit ECC occured on IRAM*/
-    e_IOC_FM_EX_MURAM_ECC                   /**< Double bit ECC occured on MURAM*/
+    e_IOC_EX_DMA_READ_ECC,               /**< Read Buffer ECC error (Valid for FM rev < 6)*/
+    e_IOC_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
+    e_IOC_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
+    e_IOC_EX_DMA_SINGLE_PORT_ECC,        /**< Single Port ECC error on FM side (Valid for FM rev > 6)*/
+    e_IOC_EX_FPM_STALL_ON_TASKS,         /**< Stall of tasks on FPM */
+    e_IOC_EX_FPM_SINGLE_ECC,             /**< Single ECC on FPM. */
+    e_IOC_EX_FPM_DOUBLE_ECC,             /**< Double ECC error on FPM ram access */
+    e_IOC_EX_QMI_SINGLE_ECC,             /**< Single ECC on QMI. */
+    e_IOC_EX_QMI_DOUBLE_ECC,             /**< Double bit ECC occurred on QMI */
+    e_IOC_EX_QMI_DEQ_FROM_UNKNOWN_PORTID,/**< Dequeue from unknown port id */
+    e_IOC_EX_BMI_LIST_RAM_ECC,           /**< Linked List RAM ECC error */
+    e_IOC_EX_BMI_STORAGE_PROFILE_ECC,    /**< Storage Profile ECC Error */
+    e_IOC_EX_BMI_STATISTICS_RAM_ECC,     /**< Statistics Count RAM ECC Error Enable */
+    e_IOC_EX_BMI_DISPATCH_RAM_ECC,       /**< Dispatch RAM ECC Error Enable */
+    e_IOC_EX_IRAM_ECC,                   /**< Double bit ECC occurred on IRAM*/
+    e_IOC_EX_MURAM_ECC                   /**< Double bit ECC occurred on MURAM*/
 } ioc_fm_exceptions;
 
-
 /**************************************************************************//**
  @Group         lnx_ioctl_FM_runtime_control_grp FM Runtime Control Unit
 
@@ -171,11 +168,11 @@ typedef enum ioc_fm_exceptions {
 /**************************************************************************//**
  @Collection   General FM defines.
  *//***************************************************************************/
-#define IOC_FM_MAX_NUM_OF_VALID_PORTS (FM_MAX_NUM_OF_OH_PORTS + \
-        FM_MAX_NUM_OF_1G_RX_PORTS +  \
-        FM_MAX_NUM_OF_10G_RX_PORTS + \
-        FM_MAX_NUM_OF_1G_TX_PORTS +  \
-        FM_MAX_NUM_OF_10G_TX_PORTS)
+#define IOC_FM_MAX_NUM_OF_VALID_PORTS  (FM_MAX_NUM_OF_OH_PORTS + \
+                                        FM_MAX_NUM_OF_1G_RX_PORTS +  \
+                                        FM_MAX_NUM_OF_10G_RX_PORTS + \
+                                        FM_MAX_NUM_OF_1G_TX_PORTS +  \
+                                        FM_MAX_NUM_OF_10G_TX_PORTS)
 /* @} */
 
 /**************************************************************************//**
@@ -185,7 +182,7 @@ typedef enum ioc_fm_exceptions {
 *//***************************************************************************/
 typedef struct ioc_fm_port_bandwidth_t {
     ioc_fm_port_type    type;           /**< FM port type */
-    uint8_t             relativePortId; /**< Type relative port id */
+    uint8_t             relative_port_id; /**< Type relative port id */
     uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
 } ioc_fm_port_bandwidth_t;
 
@@ -197,10 +194,9 @@ typedef struct ioc_fm_port_bandwidth_t {
                 (must be identical to t_FmPortsBandwidthParams defined in fm_ext.h)
 *//***************************************************************************/
 typedef struct ioc_fm_port_bandwidth_params {
-    uint8_t                     numOfPorts;
+    uint8_t                     num_of_ports;
                                 /**< num of ports listed in the array below */
-/*TODO:Andy64 BUG*/
-    ioc_fm_port_bandwidth_t     portsBandwidths[IOC_FM_MAX_NUM_OF_VALID_PORTS];
+    ioc_fm_port_bandwidth_t     ports_bandwidths[IOC_FM_MAX_NUM_OF_VALID_PORTS];
                                 /**< for each port, it's bandwidth (all port's
                                   bandwidths must add up to 100.*/
 } ioc_fm_port_bandwidth_params;
@@ -219,9 +215,6 @@ typedef enum ioc_fm_counters {
     e_IOC_FM_COUNTERS_DEQ_FROM_CONTEXT,             /**< QMI dequeue from FQ context counter */
     e_IOC_FM_COUNTERS_DEQ_FROM_FD,                  /**< QMI dequeue from FD command field counter */
     e_IOC_FM_COUNTERS_DEQ_CONFIRM,                  /**< QMI dequeue confirm counter */
-    e_IOC_FM_COUNTERS_SEMAPHOR_ENTRY_FULL_REJECT,   /**< DMA semaphor reject due to full entry counter */
-    e_IOC_FM_COUNTERS_SEMAPHOR_QUEUE_FULL_REJECT,   /**< DMA semaphor reject due to full CAM queue counter */
-    e_IOC_FM_COUNTERS_SEMAPHOR_SYNC_REJECT          /**< DMA semaphor reject due to sync counter */
 } ioc_fm_counters;
 
 typedef struct ioc_fm_obj_t {
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index f736ede..d48fd98 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -75,37 +75,37 @@
 #define IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS              2                   /**< Number of units/headers saved for user */
 
 #define IOC_FM_PCD_PRS_NUM_OF_HDRS                      16                  /**< Number of headers supported by HW parser */
-
-#ifdef CONFIG_FMAN_P1023
-#define IOC_FM_PCD_KG_NUM_OF_SCHEMES                    16                  /**< Total number of KG schemes */
-#else
-#define IOC_FM_PCD_KG_NUM_OF_SCHEMES                    32                  /**< Total number of KG schemes */
-#endif
 #define IOC_FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS         (32 - IOC_FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
-                                                                            /**< Maximum number of netenv distinction units */
-#ifdef CONFIG_FMAN_P1023
-#define IOC_FM_PCD_MAX_NUM_OF_OPTIONS                   7                   /**< Maximum number of netenv distinction units options */
-#else
-#define IOC_FM_PCD_MAX_NUM_OF_OPTIONS                   8                   /**< Maximum number of netenv distinction units options */
-#endif
-#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers in a distinction unit */
-#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KG registers */
-#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration.
-                                                                                 For reason of HW implemetation, in most
-                                                                                 cases less than this will be allowed. The
-                                                                                 driver will return error in initialization
-                                                                                 time if resource is overused. */
-#ifdef CONFIG_FMAN_P1023
-#define IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS                 128                 /**< Number of classification plan entries. */
-#else
-#define IOC_FM_PCD_MAX_NUM_OF_CLS_PLANS                 256                 /**< Number of classification plan entries. */
-#endif
-#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KG extractions. */
+                                                                        /**< Number of distinction units is limited by
+                                                                             register size (32 bits) minus reserved bits
+                                                                             for private headers. */
+#define IOC_FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS      4                   /**< Maximum number of interchangeable headers
+                                                                             in a distinction unit */
+#define IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS               8                   /**< Total number of generic KeyGen registers */
+#define IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY       35                  /**< Max number allowed on any configuration;
+                                                                             For HW implementation reasons, in most
+                                                                             cases less than this will be allowed; The
+                                                                             driver will return an initialization error
+                                                                             if resource is unavailable. */
+#define IOC_FM_PCD_KG_NUM_OF_EXTRACT_MASKS              4                   /**< Total number of masks allowed on KeyGen extractions. */
 #define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
 
-#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
-#define IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Max possible size of insertion template for
-                                                                             insert manipulation*/
+#define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Maximum number of SW parser labels */
+#define IOC_FM_PCD_SW_PRS_SIZE                          0x00000800          /**< Total size of SW parser area */
+#define IOC_FM_PCD_PRS_SW_OFFSET                        0x00000040          /**< Size of illegal addresses at the beginning
+                                                                             of the SW parser area */
+#define IOC_FM_PCD_PRS_SW_PATCHES_SIZE                  0x00000200          /**< Number of bytes saved for patches */
+#define IOC_FM_PCD_PRS_SW_TAIL_SIZE                     4                   /**< Number of bytes that must be cleared at
+                                                                             the end of the SW parser area */
+#define IOC_FM_SW_PRS_MAX_IMAGE_SIZE                    (IOC_FM_PCD_SW_PRS_SIZE-IOC_FM_PCD_PRS_SW_OFFSET-IOC_FM_PCD_PRS_SW_TAIL_SIZE-IOC_FM_PCD_PRS_SW_PATCHES_SIZE)
+                                                                        /**< Maximum size of SW parser code */
+
+#define IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Maximum size of insertion template for
+                                                                             insert manipulation */
+
+#if DPAA_VERSION >= 3
+#define IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES        64                  /**< Maximum possible entries for frame replicator group */
+#endif /* DPAA_VERSION >= 3 */
 
 /* @} */
 
@@ -368,6 +368,8 @@ typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
 *//***************************************************************************/
 #define FM_PCD_IOC_GET_COUNTER  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(9), ioc_fm_pcd_counters_params_t)
 
+#if 0
+TODO: unused IOCTL
 /**************************************************************************//**
  @Function      FM_PCD_IOC_SET_COUNTER
 
@@ -380,6 +382,7 @@ typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
  @Cautions      Allowed only following PCD_Init().
 *//***************************************************************************/
 #define FM_PCD_IOC_SET_COUNTER  _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(10), ioc_fm_pcd_counters_params_t)
+#endif
 
 /**************************************************************************//**
  @Function      FM_PCD_IOC_FORCE_INTR
@@ -400,13 +403,15 @@ typedef struct ioc_fm_pcd_kg_dflt_value_params_t {
                 parameters as required by keygen (when coarse classification
                 is the next engine after this scheme).
 *//***************************************************************************/
-#define IOC_FM_PCD_MAX_NUM_OF_CC_NODES          255
-#define IOC_FM_PCD_MAX_NUM_OF_CC_TREES            8
-#define IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS          16
-#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS            4
-#define IOC_FM_PCD_MAX_NUM_OF_KEYS              256
-#define IOC_FM_PCD_MAX_SIZE_OF_KEY               56
-#define IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP  16
+#define IOC_FM_PCD_MAX_NUM_OF_CC_NODES              255
+#define IOC_FM_PCD_MAX_NUM_OF_CC_TREES              8
+#define IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS             16
+#define IOC_FM_PCD_MAX_NUM_OF_CC_UNITS              4
+#define IOC_FM_PCD_MAX_NUM_OF_KEYS                  256
+#define IOC_FM_PCD_MAX_SIZE_OF_KEY                  56
+#define IOC_FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
+#define IOC_FM_PCD_LAST_KEY_INDEX                   0xffff
+
 /* @} */
 
 /**************************************************************************//**
@@ -644,27 +649,32 @@ typedef enum ioc_fm_pcd_action {
     e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
 } ioc_fm_pcd_action;
 
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
- @Description   enums sinchronized w/ the enums from fm_pcd_ext.h
+ @Description   Enumeration type for selecting type of insert manipulation
 *//***************************************************************************/
-typedef enum ioc_fm_pcd_manip_insrt {
-    e_IOC_FM_PCD_MANIP_INSRT_NONE = 0,
-    e_IOC_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR,
-    e_IOC_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
-} ioc_fm_pcd_manip_insrt;
+typedef enum ioc_fm_pcd_manip_hdr_insrt_type {
+    e_IOC_FM_PCD_MANIP_INSRT_GENERIC,                   /**< Insert according to offset & size */
+#ifdef FM_CAPWAP_SUPPORT
+    e_IOC_FM_PCD_MANIP_INSRT_BY_HDR,                    /**< Insert according to protocol */
+    e_IOC_FM_PCD_MANIP_INSRT_BY_TEMPLATE                /**< Insert template to start of frame */
+#endif /* FM_CAPWAP_SUPPORT */
+} ioc_fm_pcd_manip_hdr_insrt_type;
 
-typedef enum ioc_fm_pcd_manip_rmv {
-    e_IOC_FM_PCD_MANIP_RMV_NONE = 0,
-    e_IOC_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION,
-    e_IOC_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,
-    e_IOC_FM_PCD_MANIP_RMV_INT_FRAME_HDR
-} ioc_fm_pcd_manip_rmv;
+typedef enum ioc_fm_pcd_manip_hdr_rmv_type {
+    e_IOC_FM_PCD_MANIP_RMV_GENERIC,                     /**< Remove according to offset & size */
+#ifdef FM_CAPWAP_SUPPORT
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR                       /**< Remove according to offset & size */
+#endif /* FM_CAPWAP_SUPPORT */
+} ioc_fm_pcd_manip_hdr_rmv_type;
 
-typedef enum ioc_fm_pcd_manip_locate {
-    e_IOC_FM_PCD_MANIP_LOC_BY_HDR = 0,
-    e_IOC_FM_PCD_MANIP_LOC_NON_HDR
-} ioc_fm_pcd_manip_locate;
+#ifdef FM_CAPWAP_SUPPORT
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of header removal
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_hdr_rmv_by_hdr_type {
+    e_IOC_FM_PCD_MANIP_RMV_BY_HDR_FROM_START            /**< Locate from data that is not the header */
+} ioc_fm_pcd_manip_hdr_rmv_by_hdr_type;
+#endif /* FM_CAPWAP_SUPPORT */
 
 typedef enum ioc_fm_pcd_manip_reassem_time_out_mode {
     e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES,
@@ -682,18 +692,46 @@ typedef enum ioc_fm_pcd_manip_reassem_ways_number {
     e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH
 } ioc_fm_pcd_manip_reassem_ways_number;
 
+#ifdef FM_CAPWAP_SUPPORT
 typedef enum ioc_fm_pcd_stats {
     e_IOC_FM_PCD_STATS_PER_FLOWID = 0
 } ioc_fm_pcd_stats;
+#endif
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+/**************************************************************************//**
+ @Description   Enumeration type for selecting manipulation type
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_type {
+    e_IOC_FM_PCD_MANIP_HDR = 0,             /**< Header manipulation */
+    e_IOC_FM_PCD_MANIP_REASSEM,             /**< Reassembly */
+    e_IOC_FM_PCD_MANIP_FRAG,                /**< Fragmentation */
+    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD      /**< Special Offloading */
+} ioc_fm_pcd_manip_type;
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of statistics mode
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_cc_stats_mode {
+    e_IOC_FM_PCD_CC_STATS_MODE_NONE = 0,    /**< No statistics support */
+    e_IOC_FM_PCD_CC_STATS_MODE_FRAME        /**< Frame count statistics */
+} ioc_fm_pcd_cc_stats_mode;
+
+/**************************************************************************//**
+ @Description   Enumeration type for determining the action in case an IP packet
+                is larger than MTU but its DF (Don't Fragment) bit is set.
+*//***************************************************************************/
 typedef enum ioc_fm_pcd_manip_dont_frag_action {
-    e_IOC_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = 0,
-    e_IOC_FM_PCD_MANIP_FRAGMENT_PACKECT,
-    e_IOC_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG
+    e_IOC_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = 0,  /**< Discard packet */
+    e_IOC_FM_PCD_MANIP_FRAGMENT_PACKECT,                    /**< Fragment packet and continue normal processing */
+    e_IOC_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG                /**< Continue normal processing without fragmenting the packet */
 } ioc_fm_pcd_manip_dont_frag_action;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+
+/**************************************************************************//**
+ @Description   Enumeration type for selecting type of special offload manipulation
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_special_offload_type {
+    e_IOC_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC    /**< IPSec offload manipulation */
+} ioc_fm_pcd_manip_special_offload_type;
 
 /**************************************************************************//**
  @Description   A Union of protocol dependent special options
@@ -934,6 +972,34 @@ typedef struct ioc_fm_pcd_kg_plcr_profile_t {
     } profile_select;
 } ioc_fm_pcd_kg_plcr_profile_t;
 
+#if DPAA_VERSION >= 3
+/**************************************************************************//**
+ @Description   Parameters for configuring a storage profile for a KeyGen scheme.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_kg_storage_profile_t {
+    bool                direct;                     /**< If TRUE, directRelativeProfileId only selects the
+                                                         profile id;
+                                                         If FALSE, fqidOffsetRelativeProfileIdBase is used
+                                                         together with fqidOffsetShift and numOfProfiles
+                                                         parameters to define a range of profiles from which
+                                                         the KeyGen result will determine the destination
+                                                         storage profile. */
+    union {
+        uint16_t        direct_relative_profileId;    /**< Used when 'direct' is TRUE, to select a storage profile;
+                                                         should indicate the storage profile offset within the
+                                                         port's storage profiles window. */
+        struct {
+            uint8_t     fqid_offset_shift;            /**< Shift of KeyGen results without the FQID base */
+            uint8_t     fqid_offset_relative_profile_id_base;
+                                                    /**< OR of KeyGen results without the FQID base;
+                                                         should indicate the policer profile offset within the
+                                                         port's storage profiles window. */
+            uint8_t     num_of_profiles;              /**< Range of profiles starting at base. */
+        } indirect_profile;                          /**< Indirect profile parameters. */
+    } profile_select;                                /**< Direct/indirect profile selection and parameters. */
+} ioc_fm_pcd_kg_storage_profile_t;
+#endif /* DPAA_VERSION >= 3 */
+
 /**************************************************************************//**
  @Description   A structure for CC parameters if CC is the next engine after KG
 *//***************************************************************************/
@@ -989,6 +1055,11 @@ typedef struct ioc_fm_pcd_kg_scheme_params_t {
                                                               actions; Normally only some will be used
                                                               for qidMask. Driver will return error if
                                                               resource is full at initialization time. */
+#if DPAA_VERSION >= 3
+    bool                                override_storage_profile; /**< TRUE if KeyGen override previously decided storage profile */
+    ioc_fm_pcd_kg_storage_profile       storage_profile;        /**< Used when overrideStorageProfile TRUE */
+#endif /* DPAA_VERSION >= 3 */
+
     ioc_fm_pcd_engine                   next_engine;     /**< may be BMI, PLCR or CC */
     union{                                               /**< depends on nextEngine */
         ioc_fm_pcd_done_action          done_action;     /**< Used when next engine is BMI (done) */
@@ -1027,9 +1098,13 @@ typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
                                                 In earlier chips  if policer next engine is KEYGEN,
                                                 this parameter can be 0, because the KEYGEN always decides
                                                 the enqueue FQID.*/
-    bool        statistics_en;               /**< In the case of TRUE Statistic counter is
-                                                incremented for each received frame passed through
-                                                this Coarse Classification entry.*/
+#if DPAA_VERSION >= 3
+    uint8_t     new_relative_storage_profileId;
+                                        /**< Indicates the relative storage profile offset within
+                                             the port's storage profiles window;
+                                             Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 3 */
+
 } ioc_fm_pcd_cc_next_plcr_params_t;
 
 /**************************************************************************//**
@@ -1043,9 +1118,13 @@ typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
     uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
                                                  (otherwise FQID is taken from keygen),
                                                  relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
-    bool                    statistics_en;   /**< In the case of TRUE Statistic counter is
-                                                 incremented for each received frame passed through
-                                                 this Coarse Classification entry.*/
+#if DPAA_VERSION >= 3
+    uint8_t              new_relative_storage_profile_id;
+                                        /**< Indicates the relative storage profile offset within
+                                             the port's storage profiles window;
+                                             Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 3 */
+
 } ioc_fm_pcd_cc_next_enqueue_params_t;
 
 /**************************************************************************//**
@@ -1059,9 +1138,12 @@ typedef struct ioc_fm_pcd_cc_next_kg_params_t {
                                          (otherwise FQID is taken from keygen),
                                           Note - this parameters unrelevant for earlier chips*/
     void       *p_direct_scheme;        /**< Direct scheme handle to go to. */
-    bool       statistics_en;           /**< In the case of TRUE Statistic counter is
-                                             incremented for each received frame passed through
-                                             this Coarse Classification entry.*/
+#if DPAA_VERSION >= 3
+    uint8_t              new_relative_storage_profile_id;
+                                        /**< Indicates the relative storage profile offset within
+                                             the port's storage profiles window;
+                                             Relevant only if the port was configured with VSP. */
+#endif /* DPAA_VERSION >= 3 */
 } ioc_fm_pcd_cc_next_kg_params_t;
 
 /**************************************************************************//**
@@ -1077,9 +1159,18 @@ typedef struct ioc_fm_pcd_cc_next_engine_params_t {
             ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
             ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
     } params;
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
-    void                                        *manip;
-#endif /* defined(FM_CAPWAP_SUPPORT) */
+#if DPAA_VERSION >= 3
+    void                                        *p_frm_replic_id; /**< Handle to frame replicator group;
+                                                                       Relevant if next engine is e_FM_PCD_INVALID) */
+#endif /* DPAA_VERSION >= 3 */
+
+    void                                        *manip_id;      /**< Handle to Manipulation object.
+                                                                     Relevant if next engine is of type result
+                                                                     (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
+
+    bool                                        statistics_en;   /**< If TRUE, statistics counters are incremented
+                                                                      for each frame passing through this
+                                                                      Coarse Classification entry. */
 } ioc_fm_pcd_cc_next_engine_params_t;
 
 /**************************************************************************//**
@@ -1100,7 +1191,19 @@ typedef struct ioc_fm_pcd_cc_key_params_t {
  @Description   A structure for defining CC Keys parameters
 *//***************************************************************************/
 typedef struct ioc_keys_params_t {
-    uint16_t                            num_of_keys;    /**< num Of relevant Keys  */
+    uint16_t                            max_num_of_keys;
+    bool                                mask_support;   /**< This parameter is relevant only if a node is initialized with
+                                                             action = e_FM_PCD_ACTION_EXACT_MATCH and maxNumOfKeys > 0;
+                                                             Should be TRUE if the node was initialized 'empty' (no keys)
+                                                             or with keys without masks, and user wants to be able to add
+                                                             a mask to a key later on in run-time. */
+    ioc_fm_pcd_cc_stats_mode            statistics_mode;/**< If enabled, the required structures for the requested statistics
+                                                             mode will be allocated according to 'maxNumOfKeys'. */
+    uint16_t                            num_of_keys;      /**< Number of initial keys;
+                                                               Note that in case of 'action' = e_FM_PCD_ACTION_INDEXED_LOOKUP
+                                                              (but the 'src' is not e_FM_PCD_EXTRACT_FROM_HASH; in this case,
+                                                              'numOfKeys' should be zero), this field should be power-of-2
+                                                              of the number of bits that are set in 'icIndxMask'. */
     uint8_t                             key_size;       /**< size of the key - in the case of the extraction of
                                                              the type FULL_FIELD keySize has to be as standard size of the relevant
                                                              key. In the another type of extraction keySize has to be as size of extraction. */
@@ -1123,6 +1226,33 @@ typedef struct ioc_fm_pcd_cc_node_params_t {
 } ioc_fm_pcd_cc_node_params_t;
 
 /**************************************************************************//**
+ @Description   Parameters for defining a hash table
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_hash_table_params_t {
+    uint16_t                    max_num_of_keys;               /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
+    ioc_fm_pcd_cc_stats_mode    statistics_mode;             /**< If enabled, the required structures for the requested statistics
+                                                                 mode will be allocated according to maxNumOfKeys. */
+    uint16_t                    hash_res_mask;                /**< Mask that will be used on the hash-result;
+                                                                 The number-of-sets for this hash will be calculated
+                                                                 as (2^(number of bits set in 'hashResMask'));
+                                                                 The 4 lower bits must be cleared. */
+    uint8_t                     hash_shift;                  /**< Byte offset from the beginning of the KeyGen hash result to the
+                                                                 2-bytes to be used as hash index. */
+    uint8_t                     match_key_size;               /**< Size of the exact match keys held by the hash buckets */
+
+    ioc_fm_pcd_cc_next_engine_params_t   cc_next_engine_params_for_miss;  /**< Parameters for defining the next engine when a key is not matched */
+
+    void                        *id;
+
+} ioc_fm_pcd_hash_table_params_t;
+
+typedef struct ioc_fm_pcd_hash_table_add_key_params_t {
+    void                        *p_hash_tbl;
+    uint8_t                     key_size;
+    ioc_fm_pcd_cc_key_params_t  *p_key_params;
+} ioc_fm_pcd_hash_table_add_key_params_t;
+
+/**************************************************************************//**
  @Description   A structure for defining each CC tree group in term of
                 NetEnv units and the action to be taken in each case.
                 the unit_ids list must be in order from lower to higher indexes.
@@ -1160,9 +1290,6 @@ typedef struct ioc_fm_pcd_cc_tree_params_t {
         uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
         ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
                                                         /**< Parameters for each group. */
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-        void *                          *ip_reassembly_manip;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
         void                            *id;            /**< output parameter; Returns the tree Id to be used */
 } ioc_fm_pcd_cc_tree_params_t;
 
@@ -1268,25 +1395,25 @@ typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
 } ioc_fm_pcd_cc_node_modify_next_engine_params_t;
 
 /**************************************************************************//**
- @Description   A structure for modifying CC node key and next engine
+ @Description   A structure for remove CC node key
 *//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
+typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
     void                                *id;                /**< CC node Id to be used */
     uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
                                                                  NOTE: This parameter is IGNORED for miss-key!  */
-    uint8_t                             key_size;           /**< Key size of added key */
-    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
-                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
-} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
+} ioc_fm_pcd_cc_node_remove_key_params_t;
 
 /**************************************************************************//**
- @Description   A structure for remove CC node key
+ @Description   A structure for modifying CC node key and next engine
 *//***************************************************************************/
-typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
+typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
     void                                *id;                /**< CC node Id to be used */
     uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
                                                                  NOTE: This parameter is IGNORED for miss-key!  */
-} ioc_fm_pcd_cc_node_remove_key_params_t;
+    uint8_t                             key_size;           /**< Key size of added key */
+    ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
+                                                                 the array of the type ioc_fm_pcd_cc_key_params_t */
+} ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t;
 
 /**************************************************************************//**
  @Description   A structure for modifying CC node key
@@ -1302,128 +1429,290 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
                                                                  of the same size defined in the keySize */
 } ioc_fm_pcd_cc_node_modify_key_params_t;
 
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
- @Description  must match the struct defined in fm_pcd_ext.h
+ @Description   Parameters for selecting a location for requested manipulation
 *//***************************************************************************/
-typedef struct ioc_fm_pcd_manip_location_params_t {
-    ioc_fm_pcd_manip_locate             type;
-    struct {
-        ioc_net_header_type             hdr;
-        ioc_fm_pcd_hdr_index            hdr_index;
-        bool                            by_field;
-        ioc_fm_pcd_fields_u             full_field;
-    } manip_by_hdr;
-} ioc_fm_pcd_manip_location_params_t;
-
-typedef struct ioc_fm_pcd_manip_insrt_by_template_params_t {
-    uint8_t         size;
-    uint8_t         hdr_template[IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE];
-    bool            modify_outer_ip;
-    struct {
-        uint16_t    ip_outer_offset;
-        uint16_t    dscp_ecn;
-        bool        udp_present;
-        uint8_t     udp_offset;
-        uint8_t     ip_ident_genId;
-        bool        recalculate_length;
-        struct {
-            uint8_t block_size;
-            uint8_t extra_bytes_added_aligned_to_block_size;
-            uint8_t extra_bytes_added_not_aligned_to_block_size;
-        } recalculate_length_params;
-    } modify_outer_ip_params;
-    bool            modify_outer_vlan;
-    struct {
-        uint8_t     vpri;
-    } modify_outer_vlan_params;
-} ioc_fm_pcd_manip_insrt_by_template_params_t;
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+typedef struct ioc_fm_manip_hdr_info_t {
+    ioc_net_header_type                 hdr;            /**< Header selection */
+    ioc_fm_pcd_hdr_index                hdr_index;      /**< Relevant only for MPLS, VLAN and tunneled IP. Otherwise should be cleared. */
+    bool                                by_field;       /**< TRUE if the location of manipulation is according to some field in the specific header*/
+    ioc_fm_pcd_fields_u                 full_field;      /**< Relevant only when byField = TRUE: Extract field */
+} ioc_fm_manip_hdr_info_t;
 
 #ifdef FM_CAPWAP_SUPPORT
-typedef struct ioc_capwap_fragmentation_params_t {
-    uint16_t         size_for_fragmentation;
-    bool             header_options_compr;
-} ioc_capwap_fragmentation_params_t;
-
-typedef struct ioc_capwap_reassembly_params_t {
-    uint16_t                         max_numFrames_in_process;
-    bool                             halt_on_duplication_frag;
-    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;
-    uint32_t                        fqid_for_time_out_frames;
-    uint32_t                        timeout_routine_request_time;
+TODO: missing code
+#endif
+
+typedef struct ioc_fm_pcd_hash_table_remove_key_params_t {
+    void    *p_hash_tbl;
+    uint8_t key_size;
+    uint8_t *p_key;
+} ioc_fm_pcd_hash_table_remove_key_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP fragmentation manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_ip_params_t {
+    uint16_t                    size_for_fragmentation;   /**< If length of the frame is greater than this value,
+                                                             IP fragmentation will be executed.*/
+#if (DPAA_VERSION == 2)
+    uint8_t                     scratch_bpid;            /**< Absolute buffer pool id according to BM configuration.*/
+#endif /* (DPAA_VERSION == 2) */
+    bool                        sg_bpid_en;               /**< Enable a dedicated buffer pool id for the Scatter/Gather buffer allocation;
+                                                             If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
+                                                             received frame's buffer. */
+    uint8_t                     sg_bpid;                 /**< Scatter/Gather buffer pool id;
+                                                             Same LIODN number is used for these buffers as for the received frames buffers, so buffers
+                                                             of this pool need to be allocated in the same memory area as the received buffers.
+                                                             If the received buffers arrive from different sources, the Scatter/Gather BP id should be
+                                                             mutual to all these sources. */
+    ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;  /**< Dont Fragment Action - If an IP packet is larger
+                                                             than MTU and its DF bit is set, then this field will
+                                                             determine the action to be taken.*/
+} ioc_fm_pcd_manip_frag_ip_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for configuring IP reassembly manipulation.
+
+                This is a common structure for both IPv4 and IPv6 reassembly
+                manipulation. For reassembly of both IPv4 and IPv6, make sure to
+                set the 'hdr' field in t_FmPcdManipReassemParams to HEADER_TYPE_IPv6.
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_ip_params_t {
+    uint8_t                         relative_scheme_id[2];    /**< Partition relative scheme id:
+                                                                 relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
+                                                                 relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
+                                                                 Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
+                                                                 the user schemes id to ensure that the reassemblys schemes will be first match.
+                                                                 Rest schemes, if defined, should have higher relative scheme ID. */
+    uint8_t                         sg_bpid;                  /**< Buffer pool id for the S/G frame created by the reassembly process */
+    uint8_t                         data_mem_id;              /**< Memory partition ID for the IPR's external tables structure */
+    uint16_t                        data_liodn_offset;        /**< LIODN offset for access the IPR's external tables structure. */
+    uint16_t                        min_frag_size[2];         /**< Minimum fragment size:
+                                                                 minFragSize[0] - for ipv4, minFragSize[1] - for ipv6 */
+    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry[2];
+                                                            /**< Number of frames per hash entry needed for reassembly process:
+                                                                 numOfFramesPerHashEntry[0] - for ipv4 (max value is e_FM_PCD_MANIP_EIGHT_WAYS_HASH);
+                                                                 numOfFramesPerHashEntry[1] - for ipv6 (max value is e_FM_PCD_MANIP_SIX_WAYS_HASH). */
+    uint16_t                        max_num_frames_in_process;  /**< Number of frames which can be processed by Reassembly in the same time;
+                                                                 Must be power of 2;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512;
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048. */
+    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqid_for_time_out_frames;   /**< FQID in which time out frames will enqueue during Time Out Process  */
     uint32_t                        timeout_threshold_for_reassm_process;
-    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry;
-} ioc_capwap_reassembly_params_t;
-#endif /* FM_CAPWAP_SUPPORT */
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} ioc_fm_pcd_manip_reassem_ip_params_t;
 
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-typedef struct ioc_ip_fragmentation_params_t {
-    uint16_t                    size_for_fragmentation;
-    uint8_t                     scratch_bpid;
-    ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;
-} ioc_ip_fragmentation_params_t;
-
-typedef struct ioc_ip_reassembly_params_t {
-    uint8_t                         relative_schemeId[2];
-    uint8_t                         sg_bpid;
-    uint8_t                         data_mem_id;
-    uint16_t                        data_liodn_offset;
-    uint16_t                        min_frag_size[2];
-    uint16_t                        max_num_frames_in_process;
-    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;
-
-    uint32_t                        fqid_for_time_out_frames;
-    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry;
+/**************************************************************************//**
+ @Description   structure for defining IPSEC manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_ipsec_params_t {
+    bool    decryption;                     /**< TRUE if being used in decryption direction;
+                                                 FALSE if being used in encryption direction. */
+    bool    ecn_copy;                        /**< TRUE to copy the ECN bits from inner/outer to outer/inner
+                                                 (direction depends on the 'decryption' field). */
+    bool    dscp_copy;                       /**< TRUE to copy the DSCP bits from inner/outer to outer/inner
+                                                 (direction depends on the 'decryption' field). */
+    bool    variable_ip_hdr_len;               /**< TRUE for supporting variable IP header length in decryption. */
+} ioc_fm_pcd_manip_special_offload_ipsec_params_t;
 
-    uint32_t                        timeout_threshold_for_reassm_process;
-} ioc_ip_reassembly_params_t;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+/**************************************************************************//**
+ @Description   Parameters for defining special offload manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_special_offload_params_t {
+    ioc_fm_pcd_manip_special_offload_type              type;       /**< Type of special offload manipulation */
+    union
+    {
+        ioc_fm_pcd_manip_special_offload_ipsec_params_t   ipsec;
+    } u;
+} ioc_fm_pcd_manip_special_offload_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic removal manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_generic_params_t {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the removal */
+    uint8_t                         size;           /**< Size of removed section */
+} ioc_fm_pcd_manip_hdr_rmv_generic_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining generic insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_generic_params_t {
+    uint8_t                         offset;         /**< Offset from beginning of header to the start
+                                                         location of the insertion */
+    uint8_t                         size;           /**< Size of inserted section */
+    bool                            replace;        /**< TRUE to override (replace) existing data at
+                                                         'offset', FALSE to insert */
+    uint8_t                         *p_Data;        /**< Pointer to data to be inserted */
+} ioc_fm_pcd_manip_hdr_insrt_generic_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header insertion manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_insrt_params_t {
+    ioc_fm_pcd_manip_hdr_insrt_type                     type;   /**< Type of insertion manipulation */
+    union {
+        ioc_fm_pcd_manip_hdr_insrt_generic_params_t       generic;
+                                                        /**< Parameters for defining generic header insertion manipulation,
+                                                             relevant if type = e_FM_PCD_MANIP_INSRT_GENERIC */
+#ifdef FM_CAPWAP_SUPPORT
+TODO:
+#endif /* FM_CAPWAP_SUPPORT */
+    } u;
+} ioc_fm_pcd_manip_hdr_insrt_params_t;
 
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
-typedef struct ioc_fm_pcd_manip_frag_or_reasm_params_t {
-    bool                                frag;
-    uint8_t                             ext_buf_pool_indx;
-    ioc_net_header_type                 hdr;
+/**************************************************************************//**
+ @Description   Parameters for defining header removal manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_rmv_params_t {
+    ioc_fm_pcd_manip_hdr_rmv_type                  type;       /**< Type of header removal manipulation */
     union {
 #ifdef FM_CAPWAP_SUPPORT
-        ioc_capwap_fragmentation_params_t capwap_frag_params;
-        ioc_capwap_reassembly_params      capwapReasmParams;
+TODO:
 #endif /* FM_CAPWAP_SUPPORT */
-#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-        ioc_ip_fragmentation_params_t     ip_frag_params;
-        ioc_ip_reassembly_params_t        ip_reasm_params;
-#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
-    };
-} ioc_fm_pcd_manip_frag_or_reasm_params_t;
+        ioc_fm_pcd_manip_hdr_rmv_generic_params_t     generic;    /**< Parameters for defining generic header removal manipulation,
+                                                             relevant if type = e_FM_PCD_MANIP_RMV_GENERIC */
+    } u;
+} ioc_fm_pcd_manip_hdr_rmv_params_t;
+
+/**************************************************************************//**
+ @Description   Parameters for defining header manipulation node
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_hdr_params_t {
+    bool                                        rmv;                /**< TRUE, to define removal manipulation */
+    ioc_fm_pcd_manip_hdr_rmv_params_t           rmv_params;          /**< Parameters for removal manipulation, relevant if rmv = TRUE */
 
-typedef struct ioc_fm_pcd_manip_insrt_params_t {
-    ioc_fm_pcd_manip_insrt                           type;
+    bool                                        insrt;              /**< TRUE, to define insertion manipulation */
+    ioc_fm_pcd_manip_hdr_insrt_params_t         insrt_params;        /**< Parameters for insertion manipulation, relevant if insrt = TRUE */
+
+
+    bool                                        dont_parse_after_manip;/**< FALSE to activate the parser a second time after
+                                                                         completing the manipulation on the frame */
+} ioc_fm_pcd_manip_hdr_params_t;
+
+
+/**************************************************************************//**
+ @Description   structure for defining fragmentation manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_params_t {
+    ioc_net_header_type                 hdr;          /**< Header selection */
     union {
-        ioc_fm_pcd_manip_insrt_by_template_params_t  insrt_by_template_params;
-    };
-} ioc_fm_pcd_manip_insrt_params_t;
+        ioc_fm_pcd_manip_frag_ip_params_t ip_frag;       /**< Parameters for defining IP fragmentation,
+                                                            relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} ioc_fm_pcd_manip_frag_params_t;
 
-typedef struct ioc_fm_pcd_manip_rmv_params_t {
-    ioc_fm_pcd_manip_rmv                type ;
-    ioc_fm_pcd_manip_location_params_t  rmv_specific_location_params;
-} ioc_fm_pcd_manip_rmv_params_t;
+/**************************************************************************//**
+ @Description   structure for defining reassemble manipulation
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_params_t {
+    ioc_net_header_type                 hdr;          /**< Header selection */
+    union {
+        ioc_fm_pcd_manip_reassem_ip_params_t ip_reassem;    /**< Parameters for defining IP reassembly,
+                                                           relevant if 'hdr' = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+    } u;
+} ioc_fm_pcd_manip_reassem_params_t;
 
+/**************************************************************************//**
+ @Description   Parameters for defining a manipulation node
+*//***************************************************************************/
 typedef struct ioc_fm_pcd_manip_params_t {
-    bool                                        rmv;
-    ioc_fm_pcd_manip_rmv_params_t               rmv_params;
-    bool                                        insrt;
-    ioc_fm_pcd_manip_insrt_params_t             insrt_params;
-    bool                                        frag_or_reasm;
-    ioc_fm_pcd_manip_frag_or_reasm_params_t     frag_or_reasm_params;
-    bool                                        treat_fd_status_fields_as_errors;
-    void                                        *id;
+    ioc_net_header_type                           type;               /**< Selects type of manipulation node */
+    union{
+        ioc_fm_pcd_manip_hdr_params_t             hdr;                /**< Parameters for defining header manipulation node */
+        ioc_fm_pcd_manip_reassem_params_t         reassem;            /**< Parameters for defining reassembly manipulation node */
+        ioc_fm_pcd_manip_frag_params_t            frag;               /**< Parameters for defining fragmentation manipulation node */
+        ioc_fm_pcd_manip_special_offload_params_t special_offload;     /**< Parameters for defining special offload manipulation node */
+    } u;
+     void*                                        p_next_manip;        /**< Handle to another (previously defined) manipulation node;
+                                                                            Allows concatenation of manipulation actions */
+#ifdef FM_CAPWAP_SUPPORT
+TODO:
+#endif
+	void                                      *id;
 } ioc_fm_pcd_manip_params_t;
 
-typedef struct ioc_fm_pcd_stats_params_t {
-    ioc_fm_pcd_stats  type;
-} ioc_fm_pcd_stats_params_t;
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+/**************************************************************************//**
+ @Description   Structure for retrieving IP reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_ip_stats_t {
+    /* common counters for both IPv4 and IPv6 */
+    uint32_t    timeout;                        /**< Counts the number of TimeOut occurrences */
+    uint32_t    rfd_pool_busy;                    /**< Counts the number of failed attempts to allocate
+                                                     a Reassembly Frame Descriptor */
+    uint32_t    internal_buffer_busy;             /**< Counts the number of times an internal buffer busy occurred */
+    uint32_t    external_buffer_busy;             /**< Counts the number of times external buffer busy occurred */
+    uint32_t    sg_fragments;                    /**< Counts the number of Scatter/Gather fragments */
+    uint32_t    dma_semaphore_depletion;          /**< Counts the number of failed attempts to allocate a DMA semaphore */
+    struct {
+        uint32_t    successfully_reassembled;    /**< Counts the number of successfully reassembled frames */
+        uint32_t    valid_fragments;             /**< Counts the total number of valid fragments that
+                                                     have been processed for all frames */
+        uint32_t    processed_fragments;         /**< Counts the number of processed fragments
+                                                     (valid and error fragments) for all frames */
+        uint32_t    malformed_fragments;         /**< Counts the number of malformed fragments processed for all frames */
+        uint32_t    discarded_fragments;         /**< Counts the number of fragments discarded by the reassembly process */
+        uint32_t    auto_learn_busy;              /**< Counts the number of times a busy condition occurs when attempting
+                                                     to access an IP-Reassembly Automatic Learning Hash set */
+        uint32_t    more_than16fragments;        /**< Counts the fragment occurrences in which the number of fragments-per-frame
+                                                     exceeds 16 */
+    } specific_hdr_statistics[2];                 /**< slot '0' is for IPv4, slot '1' is for IPv6 */
+} ioc_fm_pcd_manip_reassem_ip_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving IP fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_ip_stats_t {
+    uint32_t    total_frames;            /**< Number of frames that passed through the manipulation node */
+    uint32_t    fragmented_frames;       /**< Number of frames that were fragmented */
+    uint32_t    generated_fragments;     /**< Number of fragments that were generated */
+} ioc_fm_pcd_manip_frag_ip_stats_t;
+
+/**************************************************************************//**
+ @Description   Structure for retrieving reassembly statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_reassem_stats_t {
+    union {
+        ioc_fm_pcd_manip_reassem_ip_stats_t  ip_reassem;  /**< Structure for IP reassembly statistics */
+    } u;
+} ioc_fm_pcd_manip_reassem_stats_t;
+
+/**************************************************************************//**
+ @Description   structure for retrieving fragmentation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_frag_stats_t {
+    union {
+        ioc_fm_pcd_manip_frag_ip_stats_t     ip_frag;     /**< Structure for IP fragmentation statistics */
+    } u;
+} ioc_fm_pcd_manip_frag_stats_t;
+
+/**************************************************************************//**
+ @Description   structure for defining manipulation statistics
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_stats_t {
+    union{
+        ioc_fm_pcd_manip_reassem_stats_t  reassem;    /**< Structure for reassembly statistics */
+        ioc_fm_pcd_manip_frag_stats_t     frag;       /**< Structure for fragmentation statistics */
+    } u;
+} ioc_fm_pcd_manip_stats_t;
+
+#if DPAA_VERSION >= 3
+/**************************************************************************//**
+ @Description   Parameters for defining frame replicator group and its members
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_frm_replic_group_params_t {
+    uint8_t                     max_num_of_entries;    /**< Maximal number of members in the group  - must be at least two */
+    uint8_t                     num_of_entries;       /**< Number of members in the group - must be at least 1 */
+    ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
+                                                    /**< Array of members' parameters */
+} ioc_fm_pcd_frm_replic_group_params_t;
+#endif /* DPAA_VERSION >= 3 */
 
 /**************************************************************************//**
  @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
@@ -1707,6 +1996,81 @@ typedef struct ioc_fm_pcd_stats_params_t {
 #endif
 #define FM_PCD_IOC_CC_NODE_MODIFY_KEY   _IOW(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(36), ioc_fm_pcd_cc_node_modify_key_params_t)
 
+/**************************************************************************//*
+ @Function      FM_PCD_IOC_HASH_TABLE_SET
+
+ @Description   This routine simulates KeyGen operation on the provided key and
+                calculates to which hash bucket it will be mapped.
+
+ @Param[in]     TODO  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet()
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#error TODO: compat ioctl call not implemented!
+#define FM_PCD_IOC_HASH_TABLE_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_pcd_hash_table_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_hash_table_params_t)
+
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_HASH_TABLE_DELETE
+
+ @Description   This routine deletes the provided hash table and released all
+                its allocated resources.
+
+ @Param[in]     p_hash_tbl A handle to a hash table
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#error TODO: compat ioctl call not implemented!
+#define FM_PCD_IOC_HASH_TABLE_DELETE_COMPAT _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_DELETE _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_HASH_TABLE_ADD_KEY
+
+ @Description   This routine adds the provided key (including next engine
+                parameters of this key) to the hash table.
+                The key is added as the last key of the bucket that it is
+                mapped to.
+
+ @Param[in]     TODO  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#error TODO: compat ioctl call not implemented!
+#define FM_PCD_IOC_HASH_TABLE_ADD_KEY_COMPAT _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_compat_fm_pcd_hash_table_add_key_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_ADD_KEY _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_fm_pcd_hash_table_add_key_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_IOC_HASH_TABLE_REMOVE_KEY
+
+ @Description   This routine removes the requested key (including next engine
+                parameters of this key) from the hash table.
+
+ @Param[in]     TODO  A pointer to a structure with the relevant parameters
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_HashTableSet().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#error TODO: compat ioctl call not implemented!
+#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY_COMPAT _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_compat_fm_pcd_hash_table_remove_key_params_t)
+#endif
+#define FM_PCD_IOC_HASH_TABLE_REMOVE_KEY _IOR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_fm_pcd_hash_table_remove_key_params_t)
+
 /**************************************************************************//**
  @Function      FM_PCD_IOC_PLCR_SET_PROFILE
 
@@ -1721,9 +2085,9 @@ typedef struct ioc_fm_pcd_stats_params_t {
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_compat_fm_pcd_plcr_profile_params_t)
+#define FM_PCD_IOC_PLCR_SET_PROFILE_COMPAT     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_compat_fm_pcd_plcr_profile_params_t)
 #endif
-#define FM_PCD_IOC_PLCR_SET_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(37), ioc_fm_pcd_plcr_profile_params_t)
+#define FM_PCD_IOC_PLCR_SET_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(41), ioc_fm_pcd_plcr_profile_params_t)
 
 /**************************************************************************//**
  @Function      FM_PCD_IOC_PLCR_DEL_PROFILE
@@ -1738,32 +2102,29 @@ typedef struct ioc_fm_pcd_stats_params_t {
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_PLCR_DEL_PROFILE_COMPAT  _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(42), ioc_compat_fm_obj_t)
 #endif
-#define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)
-
-
-#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+#define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(42), ioc_fm_obj_t)
 
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_compat_fm_pcd_manip_params_t)
+#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_compat_fm_pcd_manip_params_t)
 #endif
-#define FM_PCD_IOC_MANIP_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_fm_pcd_manip_params_t)
+#define FM_PCD_IOC_MANIP_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(43), ioc_fm_pcd_manip_params_t)
 
 
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_compat_fm_obj_t)
+#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_compat_fm_obj_t)
 #endif
-#define FM_PCD_IOC_MANIP_DELETE_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_fm_obj_t)
+#define FM_PCD_IOC_MANIP_DELETE_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(44), ioc_fm_obj_t)
 
-#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+#define FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45))
 
 #ifdef FM_CAPWAP_SUPPORT
 #warning "CAPWAP IOCTL not implemented"
 #if defined(CONFIG_COMPAT)
-#define FM_PCD_IOC_STATISTICS_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), void *)
+#define FM_PCD_IOC_STATISTICS_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
 #endif
-#define FM_PCD_IOC_STATISTICS_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), void *)
+#define FM_PCD_IOC_STATISTICS_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45), void *)
 
 #endif /* FM_CAPWAP_SUPPORT */
 
diff --git a/include/linux/fmd/Peripherals/fm_port_ioctls.h b/include/linux/fmd/Peripherals/fm_port_ioctls.h
index 88ff8d9..336a427 100644
--- a/include/linux/fmd/Peripherals/fm_port_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -98,19 +98,21 @@
                 (must match enum e_FmPortPcdSupport defined in fm_port_ext.h)
 *//***************************************************************************/
 typedef enum ioc_fm_port_pcd_support {
-    e_IOC_FM_PORT_PCD_SUPPORT_NONE = 0,             /**< BMI to BMI, PCD is not used */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
-    e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR, /**< Use all PCD engines */
-    e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR,  /**< Use Parser, Keygen and Policer */
+      e_IOC_FM_PORT_PCD_SUPPORT_NONE = 0                /**< BMI to BMI, PCD is not used */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_ONLY                /**< Use only Parser */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PLCR_ONLY               /**< Use only Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR            /**< Use Parser and Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG              /**< Use Parser and Keygen */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC       /**< Use Parser, Keygen and Coarse Classification */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
+                                                    /**< Use all PCD engines */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
+    , e_IOC_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
 #ifdef FM_CAPWAP_SUPPORT
-    e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY,              /**< Use only Coarse Classification */
-    e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG,            /**< Use Coarse Classification,and Keygen */
-    e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR    /**< Use Coarse Classification, Keygen and Policer */
-#endif
+    , e_IOC_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
+    , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
+    , e_IOC_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
+#endif /* FM_CAPWAP_SUPPORT */
 } ioc_fm_port_pcd_support;
 
 /**************************************************************************//**
@@ -129,14 +131,15 @@ typedef enum fm_port_counters {
     e_IOC_FM_PORT_COUNTERS_DEALLOC_BUF,                 /**< BMI deallocate buffer statistics counter */
     e_IOC_FM_PORT_COUNTERS_RX_BAD_FRAME,                /**< BMI Rx only statistics counter */
     e_IOC_FM_PORT_COUNTERS_RX_LARGE_FRAME,              /**< BMI Rx only statistics counter */
-    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx only statistics counter */
     e_IOC_FM_PORT_COUNTERS_RX_FILTER_FRAME,             /**< BMI Rx & OP only statistics counter */
     e_IOC_FM_PORT_COUNTERS_RX_LIST_DMA_ERR,             /**< BMI Rx, OP & HC only statistics counter */
+    e_IOC_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD,   /**< BMI Rx, OP & HC statistics counter */
+    e_IOC_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER,  /**< BMI Rx, OP & HC only statistics counter */
     e_IOC_FM_PORT_COUNTERS_WRED_DISCARD,                /**< BMI OP & HC only statistics counter */
     e_IOC_FM_PORT_COUNTERS_LENGTH_ERR,                  /**< BMI non-Rx statistics counter */
     e_IOC_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT,           /**< BMI non-Rx statistics counter */
-    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI counter */
-    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI counter */
+    e_IOC_FM_PORT_COUNTERS_DEQ_TOTAL,                   /**< QMI total QM dequeues counter */
+    e_IOC_FM_PORT_COUNTERS_ENQ_TOTAL,                   /**< QMI total QM enqueues counter */
     e_IOC_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT,            /**< QMI counter */
     e_IOC_FM_PORT_COUNTERS_DEQ_CONFIRM                  /**< QMI counter */
 } fm_port_counters;
@@ -295,7 +298,7 @@ typedef struct ioc_fm_pcd_prs_start_t {
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_port_schemes_params_t {
     uint8_t     num_of_schemes;                         /**< Number of schemes for port to be bound to. */
-    void        *scheme_ids [IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+    void        *scheme_ids [FM_PCD_KG_NUM_OF_SCHEMES];
                                                         /**< Array of 'num_of_schemes' schemes for the
                                                              port to be bound to */
 } ioc_fm_pcd_port_schemes_params_t;
@@ -401,7 +404,7 @@ typedef struct ioc_fm_port_pcd_cc_params_t {
 *//***************************************************************************/
 typedef struct ioc_fm_port_pcd_kg_params_t {
     uint8_t             num_of_schemes;                 /**< Number of schemes for port to be bound to. */
-    void                *schemes_ids[IOC_FM_PCD_KG_NUM_OF_SCHEMES];
+    void                *schemes_ids[FM_PCD_KG_NUM_OF_SCHEMES];
                                                         /**< Array of 'numOfSchemes' schemes for the
                                                              port to be bound to */
     bool                direct_scheme;                  /**< TRUE for going from parser to a specific scheme,
@@ -431,6 +434,7 @@ typedef struct ioc_fm_port_pcd_params_t {
     ioc_fm_port_pcd_cc_params_t     *p_cc_params;   /**< Coarse classification parameters for this port */
     ioc_fm_port_pcd_kg_params_t     *p_kg_params;   /**< Keygen parameters for this port */
     ioc_fm_port_pcd_plcr_params_t   *p_plcr_params; /**< Policer parameters for this port */
+    void                            *p_ip_reassembly_manip;
 } ioc_fm_port_pcd_params_t;
 
 /**************************************************************************//**
diff --git a/include/linux/fmd/integrations/integration_ioctls.h b/include/linux/fmd/integrations/integration_ioctls.h
index 02f6c61..61d696e 100644
--- a/include/linux/fmd/integrations/integration_ioctls.h
+++ b/include/linux/fmd/integrations/integration_ioctls.h
@@ -43,5 +43,14 @@
 #define FM_IOC_TYPE_BASE            (NCSW_IOC_TYPE_BASE+1)
 #define FMT_IOC_TYPE_BASE           (NCSW_IOC_TYPE_BASE+3)
 
+/*#define FM_IOCTL_DBG*/
+
+#if defined(FM_IOCTL_DBG)
+    #define _fm_ioctl_dbg(format, arg...) \
+        printk("fm ioctl [%s:%u](cpu:%u) - " format, \
+            __func__, __LINE__, smp_processor_id(), ##arg)
+#else
+#   define _fm_ioctl_dbg(arg...)
+#endif
 
 #endif /* __INTG_IOCTLS_H */
-- 
1.7.9.7

