From ddc09e273cd25102ae33863d02b9b66786e13df5 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Mon, 4 Aug 2014 16:18:55 +0800
Subject: [PATCH] dpa_offload: Add reparsing option to HM operations

Added the reparsing option to the DPA classifier driver API so that
users can request a relaunch of the FMan parser immediatley after
the configured header manipulation operation.

Change-Id: Id1d1d7e2e7128b62705f9b2d2956e75a245d8e03
Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/15194
Reviewed-by: Radu-Andrei Bulie <Radu.Bulie@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Tested-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Baogen shang <baogen.shang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_classifier.c   |   81 ++++++++++++++++----
 .../staging/fsl_dpa_offload/dpa_classifier_ioctl.h |   21 ++++--
 .../staging/fsl_dpa_offload/wrp_dpa_classifier.c   |   33 +++++---
 include/linux/fsl_dpa_classifier.h                 |   38 +++++++++
 4 files changed, 137 insertions(+), 36 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier.c b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
index 224474f..50afba8 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier.c
@@ -3744,7 +3744,6 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 	BUG_ON(!node_array);
 	BUG_ON(!hm);
 
-	/* This HM operation is linked to another HM op */
 	for (i = num_nodes - 1; i >= 0; i--) {
 		/*
 		 * If the node is empty, save an empty space and skip
@@ -3790,6 +3789,9 @@ static int import_hm_nodes_to_chain(void * const *node_array,
 			hm->hm_node[i]->node = node_array[i];
 			INIT_LIST_HEAD(&hm->hm_node[i]->list_node);
 
+			/* Initialize dontParseAfterManip to TRUE */
+			hm->hm_node[i]->params.u.hdr.dontParseAfterManip = TRUE;
+
 			/* Add this new node to the HM chain: */
 			list_add(&hm->hm_node[i]->list_node,
 				hm->hm_chain);
@@ -4399,6 +4401,10 @@ static int nat_hm_prepare_nodes(struct dpa_cls_hm *pnat_hm,
 				return -ENOMEM;
 			}
 			INIT_LIST_HEAD(&hm_node->list_node);
+
+			/* Initialize dontParseAfterManip to TRUE */
+			hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 			pnat_hm->hm_node[0] = hm_node;
 		}
 	}
@@ -4418,6 +4424,10 @@ static int nat_hm_prepare_nodes(struct dpa_cls_hm *pnat_hm,
 				return -ENOMEM;
 			}
 			INIT_LIST_HEAD(&hm_node->list_node);
+
+			/* Initialize dontParseAfterManip to TRUE */
+			hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 			pnat_hm->hm_node[1] = hm_node;
 		}
 	}
@@ -4446,7 +4456,12 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
 		hm_node = pnat_hm->hm_node[0];
 
 		hm_node->params.type = e_FM_PCD_MANIP_HDR;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+		if (pnat_hm->hm_node[1])
+			hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+		else
+			hm_node->params.u.hdr.dontParseAfterManip &=
+					(pnat_hm->nat_params.reparse) ? FALSE :
+						TRUE;
 
 		if (pnat_hm->nat_params.type ==
 					DPA_CLS_HM_NAT_TYPE_TRADITIONAL) {
@@ -4561,10 +4576,12 @@ static int nat_hm_update_params(struct dpa_cls_hm *pnat_hm)
 
 		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.fieldUpdate	= TRUE;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 		hm_node->params.u.hdr.fieldUpdateParams.type =
 				e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP;
 
+		hm_node->params.u.hdr.dontParseAfterManip &=
+				(pnat_hm->nat_params.reparse) ? FALSE : TRUE;
+
 		if (pnat_hm->nat_params.flags & DPA_CLS_HM_NAT_UPDATE_SPORT) {
 			hm_node->params.u.hdr.fieldUpdateParams.u.tcpUdp.
 				validUpdates |= HDR_MANIP_TCP_UDP_SRC;
@@ -4896,6 +4913,10 @@ static int fwd_hm_prepare_nodes(struct dpa_cls_hm *pfwd_hm,
 	}
 
 	INIT_LIST_HEAD(&hm_node->list_node);
+
+	/* Initialize dontParseAfterManip to TRUE */
+	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 	pfwd_hm->hm_node[0]	= hm_node;
 
 	if (pfwd_hm->update_params.ip_frag_params.mtu) {
@@ -4934,8 +4955,10 @@ static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 
 	hm_node = pfwd_hm->hm_node[0];
 
-	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
-	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+	hm_node->params.type = e_FM_PCD_MANIP_HDR;
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pfwd_hm->fwd_params.reparse) ? FALSE : TRUE;
+
 	switch (pfwd_hm->fwd_params.out_if_type) {
 	case DPA_CLS_HM_IF_TYPE_ETHERNET:
 		/* Update Ethernet MACS */
@@ -4943,7 +4966,6 @@ static int fwd_hm_update_params(struct dpa_cls_hm *pfwd_hm)
 		hm_node->params.u.hdr.insrtParams.type	=
 						e_FM_PCD_MANIP_INSRT_GENERIC;
 		hm_node->params.u.hdr.insrtParams.u.generic.replace = TRUE;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		size = (uint8_t)(sizeof(struct ethhdr) - ETHERTYPE_SIZE);
 		pdata = kzalloc(size, GFP_KERNEL);
@@ -5322,6 +5344,10 @@ static int remove_hm_prepare_nodes(struct dpa_cls_hm *premove_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 		premove_hm->hm_node[0]	= hm_node;
 
 		add_local_hm_nodes_to_chain(premove_hm);
@@ -5346,9 +5372,11 @@ static int remove_hm_update_params(struct dpa_cls_hm *premove_hm)
 
 	hm_node = premove_hm->hm_node[0];
 
-	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
-	hm_node->params.u.hdr.rmv		= TRUE;
-	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+	hm_node->params.type            = e_FM_PCD_MANIP_HDR;
+	hm_node->params.u.hdr.rmv       = TRUE;
+
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(premove_hm->remove_params.reparse) ? FALSE : TRUE;
 
 	switch (premove_hm->remove_params.type) {
 	case DPA_CLS_HM_REMOVE_ETHERNET:
@@ -5607,6 +5635,10 @@ static int insert_hm_prepare_nodes(struct dpa_cls_hm *pinsert_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 		pinsert_hm->hm_node[0]	= hm_node;
 
 		add_local_hm_nodes_to_chain(pinsert_hm);
@@ -5637,7 +5669,9 @@ static int insert_hm_update_params(struct dpa_cls_hm *pinsert_hm)
 	hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 	hm_node->params.u.hdr.insrt		= TRUE;
 	hm_node->params.u.hdr.insrtParams.type	= e_FM_PCD_MANIP_INSRT_GENERIC;
-	hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pinsert_hm->insert_params.reparse) ? FALSE : TRUE;
 
 	switch (pinsert_hm->insert_params.type) {
 	case DPA_CLS_HM_INSERT_ETHERNET:
@@ -6069,6 +6103,9 @@ static int update_hm_prepare_nodes(struct dpa_cls_hm *pupdate_hm,
 			}
 
 			INIT_LIST_HEAD(&hm_node->list_node);
+
+			/* Initialize dontParseAfterManip to TRUE */
+			hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 		}
 
 		pupdate_hm->hm_node[0] = hm_node;
@@ -6115,10 +6152,10 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 
 	hm_node = pupdate_hm->hm_node[0];
 
+	hm_node->params.type = e_FM_PCD_MANIP_HDR;
+
 	if (pupdate_hm->update_params.op_flags & update_ops) {
-		hm_node->params.type			= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.fieldUpdate	= TRUE;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_UPDATE_IPv4_UPDATE) {
@@ -6258,11 +6295,9 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 	}
 
 	if (pupdate_hm->update_params.op_flags & replace_ops) {
-		hm_node->params.type		= e_FM_PCD_MANIP_HDR;
 		hm_node->params.u.hdr.custom	= TRUE;
 		hm_node->params.u.hdr.customParams.type =
 				e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		if (pupdate_hm->update_params.op_flags &
 				DPA_CLS_HM_REPLACE_IPv4_BY_IPv6) {
@@ -6301,6 +6336,9 @@ static int update_hm_update_params(struct dpa_cls_hm *pupdate_hm)
 		}
 	}
 
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pupdate_hm->update_params.reparse) ? FALSE : TRUE;
+
 	hm_node = pupdate_hm->hm_node[1];
 
 	if (pupdate_hm->update_params.ip_frag_params.mtu) {
@@ -6683,6 +6721,10 @@ static int vlan_hm_prepare_nodes(struct dpa_cls_hm *pvlan_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 		pvlan_hm->hm_node[0]	= hm_node;
 
 		add_local_hm_nodes_to_chain(pvlan_hm);
@@ -6711,6 +6753,9 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 
 	hm_node->params.type = e_FM_PCD_MANIP_HDR;
 
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pvlan_hm->vlan_params.reparse) ? FALSE : TRUE;
+
 	switch (pvlan_hm->vlan_params.type) {
 	case DPA_CLS_HM_VLAN_INGRESS:
 		hm_node->params.u.hdr.rmv = TRUE;
@@ -6720,7 +6765,6 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 					e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2;
 		hm_node->params.u.hdr.rmvParams.u.byHdr.u.specificL2 =
 					e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS;
-		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 		break;
 	case DPA_CLS_HM_VLAN_EGRESS:
@@ -6762,7 +6806,6 @@ static int vlan_hm_update_params(struct dpa_cls_hm *pvlan_hm)
 			hm_node->params.u.hdr.fieldUpdate = TRUE;
 			hm_node->params.u.hdr.fieldUpdateParams.type =
 					e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN;
-			hm_node->params.u.hdr.dontParseAfterManip = TRUE;
 
 			switch (pvlan_hm->vlan_params.egress.update_op) {
 			case DPA_CLS_HM_VLAN_UPDATE_VPri:
@@ -7070,6 +7113,10 @@ static int mpls_hm_prepare_nodes(struct dpa_cls_hm *pmpls_hm,
 		}
 
 		INIT_LIST_HEAD(&hm_node->list_node);
+
+		/* Initialize dontParseAfterManip to TRUE */
+		hm_node->params.u.hdr.dontParseAfterManip = TRUE;
+
 		pmpls_hm->hm_node[0]	= hm_node;
 
 		add_local_hm_nodes_to_chain(pmpls_hm);
@@ -7097,6 +7144,8 @@ static int mpls_hm_update_params(struct dpa_cls_hm *pmpls_hm)
 	hm_node = pmpls_hm->hm_node[0];
 
 	hm_node->params.type = e_FM_PCD_MANIP_HDR;
+	hm_node->params.u.hdr.dontParseAfterManip &=
+			(pmpls_hm->mpls_params.reparse) ? FALSE : TRUE;
 
 	switch (pmpls_hm->mpls_params.type) {
 	case DPA_CLS_HM_MPLS_REMOVE_ALL_LABELS:
diff --git a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
index 88a157c..1e73bd6 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_classifier_ioctl.h
@@ -298,6 +298,7 @@ struct dpa_cls_compat_hm_remove_params {
 	enum dpa_cls_hm_remove_type	type;
 	struct dpa_cls_hm_custom_rm_params custom;
 	compat_uptr_t fm_pcd;
+	bool reparse;
 };
 
 struct compat_ioc_dpa_cls_hm_remove_params {
@@ -320,14 +321,15 @@ struct dpa_cls_compat_hm_custom_ins_params {
 };
 
 struct dpa_cls_compat_hm_insert_params {
-	enum dpa_cls_hm_insert_type	type;
+	enum dpa_cls_hm_insert_type type;
 	union {
 		struct dpa_cls_hm_eth_ins_params eth;
-		struct dpa_cls_hm_pppoe_ins_params		pppoe;
-		uint16_t					ppp_pid;
-		struct dpa_cls_compat_hm_custom_ins_params	custom;
+		struct dpa_cls_hm_pppoe_ins_params pppoe;
+		uint16_t ppp_pid;
+		struct dpa_cls_compat_hm_custom_ins_params custom;
 	};
-	compat_uptr_t	fm_pcd;
+	compat_uptr_t fm_pcd;
+	bool reparse;
 };
 
 struct compat_ioc_dpa_cls_hm_insert_params {
@@ -346,6 +348,7 @@ struct dpa_cls_compat_hm_vlan_params {
 		struct dpa_cls_hm_egress_vlan_params	egress;
 	};
 	compat_uptr_t	fm_pcd;
+	bool reparse;
 };
 
 struct dpa_cls_compat_hm_vlan_resources {
@@ -377,7 +380,7 @@ struct dpa_cls_compat_hm_nat_pt_params {
 };
 
 struct dpa_cls_compat_hm_nat_params {
-	int	flags;
+	int		flags;
 	enum dpa_cls_hm_nat_proto	proto;
 	enum dpa_cls_hm_nat_type	type;
 	union {
@@ -387,6 +390,7 @@ struct dpa_cls_compat_hm_nat_params {
 	uint16_t	sport;
 	uint16_t	dport;
 	compat_uptr_t	fm_pcd;
+	bool		reparse;
 };
 
 struct dpa_cls_compat_hm_nat_resources {
@@ -404,7 +408,7 @@ struct compat_ioc_dpa_cls_hm_nat_params {
 };
 
 struct dpa_cls_compat_hm_update_params {
-	int	op_flags;
+	int					op_flags;
 	union {
 		struct compat_ipv4_header	new_ipv4_hdr;
 		struct ipv6_header		new_ipv6_hdr;
@@ -415,6 +419,7 @@ struct dpa_cls_compat_hm_update_params {
 	} update;
 	struct dpa_cls_hm_ip_frag_params	ip_frag_params;
 	compat_uptr_t				fm_pcd;
+	bool					reparse;
 };
 
 struct dpa_cls_compat_hm_update_resources {
@@ -441,6 +446,7 @@ struct dpa_cls_compat_hm_fwd_params {
 	};
 	struct dpa_cls_hm_ip_frag_params	ip_frag_params;
 	compat_uptr_t				fm_pcd;
+	bool					reparse;
 };
 
 struct dpa_cls_compat_hm_fwd_resources {
@@ -463,6 +469,7 @@ struct dpa_cls_compat_hm_mpls_params {
 	struct mpls_header		mpls_hdr[DPA_CLS_HM_MAX_MPLS_LABELS];
 	unsigned int			num_labels;
 	compat_uptr_t			fm_pcd;
+	bool				reparse;
 };
 
 struct dpa_cls_compat_hm_mpls_resources {
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
index 4065abb..e6b5571 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_classifier.c
@@ -2637,9 +2637,10 @@ int dpa_cls_hm_remove_params_compatcpy(
 	memcpy(&kparam->rm_params.custom, &uparam->rm_params.custom,
 		sizeof(struct dpa_cls_hm_custom_rm_params));
 
-	kparam->rm_params.fm_pcd = compat_ptr(uparam->rm_params.fm_pcd);
-	kparam->next_hmd	= uparam->next_hmd;
-	kparam->hmd		= uparam->hmd;
+	kparam->rm_params.fm_pcd        = compat_ptr(uparam->rm_params.fm_pcd);
+	kparam->rm_params.reparse       = uparam->rm_params.reparse;
+	kparam->next_hmd                = uparam->next_hmd;
+	kparam->hmd                     = uparam->hmd;
 
 	if (uparam->res.remove_node)
 		kparam->res.remove_node	= compat_get_id2ptr(
@@ -2687,9 +2688,10 @@ int dpa_cls_hm_insert_params_compatcpy(
 		break;
 	}
 
-	kparam->ins_params.fm_pcd = compat_ptr(uparam->ins_params.fm_pcd);
-	kparam->next_hmd	= uparam->next_hmd;
-	kparam->hmd		= uparam->hmd;
+	kparam->ins_params.fm_pcd       = compat_ptr(uparam->ins_params.fm_pcd);
+	kparam->ins_params.reparse      = uparam->ins_params.reparse;
+	kparam->next_hmd                = uparam->next_hmd;
+	kparam->hmd                     = uparam->hmd;
 	if (uparam->res.insert_node)
 		kparam->res.insert_node	= compat_get_id2ptr(
 							uparam->res.insert_node,
@@ -2727,6 +2729,7 @@ int dpa_cls_hm_vlan_params_compatcpy(
 	}
 
 	kparam->vlan_params.fm_pcd = compat_ptr(uparam->vlan_params.fm_pcd);
+	kparam->vlan_params.reparse = uparam->vlan_params.reparse;
 	kparam->next_hmd	= uparam->next_hmd;
 	kparam->hmd		= uparam->hmd;
 
@@ -2778,11 +2781,12 @@ int dpa_cls_hm_nat_params_compatcpy(
 			memcpy(&kparam->nat_params.nat, &uparam->nat_params.nat,
 			      sizeof(struct dpa_cls_hm_traditional_nat_params));
 
-	kparam->nat_params.fm_pcd = compat_ptr(uparam->nat_params.fm_pcd);
-	kparam->nat_params.sport = uparam->nat_params.sport;
-	kparam->nat_params.dport = uparam->nat_params.dport;
-	kparam->next_hmd	= uparam->next_hmd;
-	kparam->hmd		= uparam->hmd;
+	kparam->nat_params.fm_pcd       = compat_ptr(uparam->nat_params.fm_pcd);
+	kparam->nat_params.reparse      = uparam->nat_params.reparse;
+	kparam->nat_params.sport        = uparam->nat_params.sport;
+	kparam->nat_params.dport        = uparam->nat_params.dport;
+	kparam->next_hmd                = uparam->next_hmd;
+	kparam->hmd                     = uparam->hmd;
 
 	if (uparam->res.l3_update_node)
 		kparam->res.l3_update_node = compat_get_id2ptr(
@@ -2840,6 +2844,7 @@ int dpa_cls_hm_update_params_compatcpy(
 
 
 	kparam->update_params.fm_pcd = compat_ptr(uparam->update_params.fm_pcd);
+	kparam->update_params.reparse = uparam->update_params.reparse;
 	kparam->next_hmd	= uparam->next_hmd;
 	kparam->hmd		= uparam->hmd;
 
@@ -2869,8 +2874,9 @@ int dpa_cls_hm_fwd_params_compatcpy(
 {
 	int type;
 
-	kparam->fwd_params.out_if_type = uparam->fwd_params.out_if_type;
-	kparam->fwd_params.fm_pcd = compat_ptr(uparam->fwd_params.fm_pcd);
+	kparam->fwd_params.out_if_type  = uparam->fwd_params.out_if_type;
+	kparam->fwd_params.fm_pcd       = compat_ptr(uparam->fwd_params.fm_pcd);
+	kparam->fwd_params.reparse      = uparam->fwd_params.reparse;
 
 	type = kparam->fwd_params.out_if_type;
 	switch (type) {
@@ -2932,6 +2938,7 @@ int dpa_cls_hm_mpls_params_compatcpy(
 		sizeof(struct mpls_header) * DPA_CLS_HM_MAX_MPLS_LABELS);
 	kparam->mpls_params.num_labels = uparam->mpls_params.num_labels;
 	kparam->mpls_params.fm_pcd = compat_ptr(uparam->mpls_params.fm_pcd);
+	kparam->mpls_params.reparse = uparam->mpls_params.reparse;
 	kparam->next_hmd	= uparam->next_hmd;
 	kparam->hmd		= uparam->hmd;
 
diff --git a/include/linux/fsl_dpa_classifier.h b/include/linux/fsl_dpa_classifier.h
index f81909f..cefa20c 100644
--- a/include/linux/fsl_dpa_classifier.h
+++ b/include/linux/fsl_dpa_classifier.h
@@ -634,6 +634,11 @@ struct dpa_cls_hm_nat_params {
 	 * manipulation object.
 	 */
 	void							*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this NAT.
+	 */
+	bool							reparse;
 };
 
 /* Output interface type for forwarding */
@@ -766,6 +771,12 @@ struct dpa_cls_hm_fwd_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this forwarding
+	 * header manipulation.
+	 */
+	bool						reparse;
 };
 
 /* Types of the remove header manipulation operations */
@@ -831,6 +842,11 @@ struct dpa_cls_hm_remove_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this header remove.
+	 */
+	bool						reparse;
 };
 
 /* Types of insert header manipulation operations */
@@ -953,6 +969,11 @@ struct dpa_cls_hm_insert_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this header insert.
+	 */
+	bool						reparse;
 };
 
 /* Update header manipulation op flags */
@@ -1111,6 +1132,11 @@ struct dpa_cls_hm_update_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this header update.
+	 */
+	bool						reparse;
 };
 
 /* VLAN specific header manipulation operation types */
@@ -1231,6 +1257,12 @@ struct dpa_cls_hm_vlan_params {
 	 * manipulation object.
 	 */
 	void						*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this VLAN header
+	 * update.
+	 */
+	bool						reparse;
 };
 
 /* MPLS specific header manipulation operation types */
@@ -1281,6 +1313,12 @@ struct dpa_cls_hm_mpls_params {
 	 * manipulation object.
 	 */
 	void				*fm_pcd;
+
+	/*
+	 * Request re-parsing of the packet headers after this MPLS header
+	 * update.
+	 */
+	bool				reparse;
 };
 
 
-- 
1.7.5.4

