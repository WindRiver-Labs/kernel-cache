From 459846e151520067e3c56068e00f12d545dc948a Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 28 Jul 2014 10:04:36 +0800
Subject: [PATCH 48/50] gianfar: remove some unnecessary PM functions

SDK 1.4 committed a patch

5bd97eb6025b213ca843f16ec70385b3e77e6fde
(gianfar: add support for wake-on-packe),

but SDK 1.6 has abandoned it.

[Based on QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |  190 ------------------------------
 1 files changed, 0 insertions(+), 190 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 5b239f1..96aa5f3 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -164,18 +164,8 @@ static void gfar_clear_exact_match(struct net_device *dev);
 static void gfar_set_mac_for_addr(struct net_device *dev, int num,
 				  const u8 *addr);
 static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
-static void gfar_schedule_rx_cleanup(struct gfar_priv_grp *grp);
 static void gfar_align_skb(struct sk_buff *skb);
 
-#ifdef CONFIG_PM
-static void gfar_halt_rx(struct net_device *dev);
-static void gfar_rx_start(struct net_device *dev);
-static void gfar_enable_filer(struct net_device *dev);
-static void gfar_disable_filer(struct net_device *dev);
-static void gfar_config_filer_table(struct net_device *dev);
-static void gfar_restore_filer_table(struct net_device *dev);
-#endif
-
 LIST_HEAD(gfar_recycle_queues);
 
 bool gfar_skb_recycling_en = true;
@@ -1849,110 +1839,6 @@ static int gfar_resume(struct device *dev)
 	return 0;
 }
 
-static void gfar_enable_filer(struct net_device *dev)
-{
-	struct gfar_private *priv = netdev_priv(dev);
-	struct gfar __iomem *regs = priv->gfargrp[0].regs;
-	u32 temp;
-
-	temp = gfar_read(&regs->rctrl);
-	temp &= ~(RCTRL_FSQEN | RCTRL_PRSDEP_MASK);
-	temp |= RCTRL_FILREN | RCTRL_PRSDEP_L2L3;
-	gfar_write(&regs->rctrl, temp);
-}
-
-static void gfar_disable_filer(struct net_device *dev)
-{
-	struct gfar_private *priv = netdev_priv(dev);
-	struct gfar __iomem *regs = priv->gfargrp[0].regs;
-	u32 temp;
-
-	temp = gfar_read(&regs->rctrl);
-	temp &= ~RCTRL_FILREN;
-	gfar_write(&regs->rctrl, temp);
-}
-
-static void gfar_restore_filer_table(struct net_device *dev)
-{
-	struct gfar_private *priv = netdev_priv(dev);
-	u32 rqfcr, rqfpr;
-	int i;
-
-	for (i = 0; i <= MAX_FILER_IDX; i++) {
-		rqfcr = priv->ftp_rqfcr[i];
-		rqfpr = priv->ftp_rqfpr[i];
-		gfar_write_filer(priv, i, rqfcr, rqfpr);
-	}
-}
-
-static void gfar_config_filer_table(struct net_device *dev)
-{
-	struct gfar_private *priv = netdev_priv(dev);
-	u32 dest_mac_addr;
-	u32 rqfcr, rqfpr;
-	unsigned int index;
-	u8 rqfcr_queue;
-
-	if (gfar_get_ip(dev)) {
-		netif_err(priv, wol, dev, "WOL: get the ip address error\n");
-		return;
-	}
-
-	/* init filer table */
-	rqfcr = RQFCR_RJE | RQFCR_CMP_MATCH;
-	rqfpr = 0x0;
-	for (index = 0; index <= MAX_FILER_IDX; index++)
-		gfar_write_filer(priv, index, rqfcr, rqfpr);
-
-	index = 0;
-	/* select a rx queue in group 0 */
-	rqfcr_queue = (u8)find_first_bit(&priv->gfargrp[0].napi_rx->rx_bit_map,
-							priv->num_rx_queues);
-	if (priv->wol_opts & GIANFAR_WOL_ARP) {
-		/* ARP request filer, filling the packet to the last queue */
-		rqfcr = (rqfcr_queue << 10) | RQFCR_AND |
-					RQFCR_CMP_EXACT | RQFCR_PID_MASK;
-		rqfpr = RQFPR_ARQ;
-		gfar_write_filer(priv, index++, rqfcr, rqfpr);
-
-		rqfcr = (rqfcr_queue << 10) | RQFCR_AND |
-					RQFCR_CMP_EXACT | RQFCR_PID_PARSE;
-		rqfpr = RQFPR_ARQ;
-		gfar_write_filer(priv, index++, rqfcr, rqfpr);
-
-		/*
-		 * DEST_IP address in ARP packet,
-		 * filling it to the last queue.
-		 */
-		rqfcr = (rqfcr_queue << 10) | RQFCR_AND |
-					RQFCR_CMP_EXACT | RQFCR_PID_MASK;
-		rqfpr = FPR_FILER_MASK;
-		gfar_write_filer(priv, index++, rqfcr, rqfpr);
-
-		rqfcr = (rqfcr_queue << 10) | RQFCR_GPI |
-					RQFCR_CMP_EXACT | RQFCR_PID_DIA;
-		rqfpr = priv->ip_addr;
-		gfar_write_filer(priv, index++, rqfcr, rqfpr);
-	}
-
-	if (priv->wol_opts & GIANFAR_WOL_UCAST) {
-		/* Unicast packet, filling it to the last queue */
-		dest_mac_addr = (dev->dev_addr[0] << 16) |
-				(dev->dev_addr[1] << 8) | dev->dev_addr[2];
-		rqfcr = (rqfcr_queue << 10) | RQFCR_AND |
-					RQFCR_CMP_EXACT | RQFCR_PID_DAH;
-		rqfpr = dest_mac_addr;
-		gfar_write_filer(priv, index++, rqfcr, rqfpr);
-
-		dest_mac_addr = (dev->dev_addr[3] << 16) |
-				(dev->dev_addr[4] << 8) | dev->dev_addr[5];
-		rqfcr = (rqfcr_queue << 10) | RQFCR_GPI |
-					RQFCR_CMP_EXACT | RQFCR_PID_DAL;
-		rqfpr = dest_mac_addr;
-		gfar_write_filer(priv, index++, rqfcr, rqfpr);
-	}
-}
-
 static int gfar_restore(struct device *dev)
 {
 	struct gfar_private *priv = dev_get_drvdata(dev);
@@ -2150,48 +2036,6 @@ static int __gfar_is_rx_idle(struct gfar_private *priv)
 	return 0;
 }
 
-#ifdef CONFIG_PM
-/* Halt the receive queues */
-static void gfar_halt_rx(struct net_device *dev)
-{
-	struct gfar_private *priv = netdev_priv(dev);
-	struct gfar __iomem *regs = priv->gfargrp[0].regs;
-	u32 tempval;
-	int i = 0;
-
-	for (i = 0; i < priv->num_grps; i++) {
-		regs = priv->gfargrp[i].regs;
-		/* Mask all interrupts */
-		gfar_write(&regs->imask, IMASK_INIT_CLEAR);
-
-		/* Clear all interrupts */
-		gfar_write(&regs->ievent, IEVENT_INIT_CLEAR);
-	}
-
-	regs = priv->gfargrp[0].regs;
-	/* Stop the DMA, and wait for it to stop */
-	tempval = gfar_read(&regs->dmactrl);
-	if ((tempval & DMACTRL_GRS) != DMACTRL_GRS) {
-		int ret;
-
-		tempval |= DMACTRL_GRS;
-		gfar_write(&regs->dmactrl, tempval);
-
-		do {
-			ret = spin_event_timeout(((gfar_read(&regs->ievent) &
-				IEVENT_GRSC) == IEVENT_GRSC), 1000000, 0);
-			if (!ret && !(gfar_read(&regs->ievent) & IEVENT_GRSC))
-				ret = __gfar_is_rx_idle(priv);
-		} while (!ret);
-	}
-
-	/* Disable Rx in MACCFG1  */
-	tempval = gfar_read(&regs->maccfg1);
-	tempval &= ~MACCFG1_RX_EN;
-	gfar_write(&regs->maccfg1, tempval);
-}
-#endif
-
 /* Halt the receive and transmit queues */
 static void gfar_halt_nodisable(struct gfar_private *priv)
 {
@@ -2416,40 +2260,6 @@ void gfar_start(struct gfar_private *priv)
 	priv->ndev->trans_start = jiffies; /* prevent tx timeout */
 }
 
-#ifdef CONFIG_PM
-void gfar_rx_start(struct net_device *dev)
-{
-	struct gfar_private *priv = netdev_priv(dev);
-	struct gfar __iomem *regs = priv->gfargrp[0].regs;
-	u32 tempval;
-	int i = 0;
-
-	/* Enable Rx in MACCFG1 */
-	tempval = gfar_read(&regs->maccfg1);
-	tempval |= MACCFG1_RX_EN;
-	gfar_write(&regs->maccfg1, tempval);
-
-	/* Initialize DMACTRL to have WWR and WOP */
-	tempval = gfar_read(&regs->dmactrl);
-	tempval |= DMACTRL_INIT_SETTINGS;
-	gfar_write(&regs->dmactrl, tempval);
-
-	/* Make sure we aren't stopped */
-	tempval = gfar_read(&regs->dmactrl);
-	tempval &= ~DMACTRL_GRS;
-	gfar_write(&regs->dmactrl, tempval);
-
-	for (i = 0; i < priv->num_grps; i++) {
-		regs = priv->gfargrp[i].regs;
-		/* Clear RHLT, so that the DMA starts polling now */
-		gfar_write(&regs->rstat, priv->gfargrp[i].napi_rx->rstat);
-
-		/* Unmask the interrupts we look for */
-		gfar_write(&regs->imask, IMASK_FGPI | IMASK_MAG);
-	}
-}
-#endif
-
 static void gfar_configure_tx_coalescing(struct gfar_private *priv,
 					 unsigned long tx_mask)
 {
-- 
1.7.5.4

