From bc1363095738aec2f5fa0f832681d765e55bfb70 Mon Sep 17 00:00:00 2001
From: Horia Geanta <horia.geanta@freescale.com>
Date: Wed, 30 Oct 2013 19:50:44 +0200
Subject: [PATCH 466/466] crypto: caam - add support for TLS 1.0 record

Update to SDK 1.6 version.
TLS 1.0 descriptors run on SEC Era 4 or higher.
For now, only tls10(hmac(sha1),cbc(aes)) algorithm
is registered by the driver.

Change-Id: I98a71d8eb61a0e5f2dd65835e99b1c906468bf52
Signed-off-by: Tudor Ambarus <tudor.ambarus@freescale.com>
Signed-off-by: Horia Geanta <horia.geanta@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/10376
Reviewed-by: Cristian Stoica <cristian.stoica@freescale.com>
Reviewed-by: Mircea Pop <mircea.pop@freescale.com>
Reviewed-by: Alexandru Porosanu <alexandru.porosanu@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/crypto/caam/caamalg.c |   70 ++++++++++++++++++-----------------------
 1 file changed, 31 insertions(+), 39 deletions(-)

diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c
index 8252319..d3aa733 100644
--- a/drivers/crypto/caam/caamalg.c
+++ b/drivers/crypto/caam/caamalg.c
@@ -2073,15 +2073,14 @@ static void init_tls_job(u32 *sh_desc, dma_addr_t ptr,
 	 * For decrypt, do not strip ICV, Padding, Padding length since
 	 * upper layer(s) perform padding checking.
 	 */
-	append_seq_out_ptr(desc, dst_dma, req->cryptlen, out_options);
-
 	if (encrypt)
-		append_seq_in_ptr(desc, src_dma, req->assoclen + ivsize +
-				  req->cryptlen - authsize - padsize,
-				  in_options);
+		append_seq_out_ptr(desc, dst_dma, req->cryptlen + padsize +
+				   authsize, out_options);
 	else
-		append_seq_in_ptr(desc, src_dma, req->assoclen + ivsize +
-				  req->cryptlen, in_options);
+		append_seq_out_ptr(desc, dst_dma, req->cryptlen, out_options);
+
+	append_seq_in_ptr(desc, src_dma, req->assoclen + ivsize +
+			  req->cryptlen, in_options);
 }
 
 /*
@@ -2146,7 +2145,7 @@ static void init_ablkcipher_job(u32 *sh_desc, dma_addr_t ptr,
  */
 static struct aead_edesc *aead_edesc_alloc(struct aead_request *req,
 					   int desc_bytes, bool *all_contig_ptr,
-					   bool encrypt)
+					   bool encrypt, bool strip_icv)
 {
 	struct crypto_aead *aead = crypto_aead_reqtfm(req);
 	struct caam_ctx *ctx = crypto_aead_ctx(aead);
@@ -2167,10 +2166,15 @@ static struct aead_edesc *aead_edesc_alloc(struct aead_request *req,
 	assoc_nents = sg_count(req->assoc, req->assoclen, &assoc_chained);
 
 	if (unlikely(req->dst != req->src)) {
+		int extralen;
+
 		src_nents = sg_count(req->src, req->cryptlen, &src_chained);
-		dst_nents = sg_count(req->dst,
-				     req->cryptlen +
-					(encrypt ? authsize : (-authsize)),
+
+		if (encrypt)
+			extralen = authsize;
+		else
+			extralen = strip_icv ? (-authsize) : 0;
+		dst_nents = sg_count(req->dst, req->cryptlen + extralen,
 				     &dst_chained);
 	} else {
 		src_nents = sg_count(req->src,
@@ -2291,7 +2295,7 @@ static int aead_encrypt(struct aead_request *req)
 
 	/* allocate extended descriptor */
 	edesc = aead_edesc_alloc(req, DESC_JOB_IO_LEN *
-				 CAAM_CMD_SZ, &all_contig, true);
+				 CAAM_CMD_SZ, &all_contig, true, true);
 	if (IS_ERR(edesc))
 		return PTR_ERR(edesc);
 
@@ -2328,7 +2332,7 @@ static int aead_decrypt(struct aead_request *req)
 
 	/* allocate extended descriptor */
 	edesc = aead_edesc_alloc(req, DESC_JOB_IO_LEN *
-				 CAAM_CMD_SZ, &all_contig, false);
+				 CAAM_CMD_SZ, &all_contig, false, true);
 	if (IS_ERR(edesc))
 		return PTR_ERR(edesc);
 
@@ -2531,34 +2535,20 @@ static int tls_encrypt(struct aead_request *req)
 	unsigned int blocksize = crypto_aead_blocksize(aead);
 	unsigned int padsize;
 
-	/*
-	 * Assumption 1: req->cryptlen is initially equal to the length of the
-	 * payload (no ICV length, no padding length included).
-	 *
-	 * Assumption 2: req->dst big enough (we will be using
-	 * req->cryptlen = payloadlen + icvlen + paddinglen both for req->src
-	 * and req->dst).
-	 *
-	 * Reasoning: For decryption, exact size of payload cannot be known
-	 * before decrypting the pad length; thus, it is sane to expect
-	 * the upper layer to either decrypt in place (req->dst == req->src) or
-	 * allocate req->dst such that len(req->dst) = len(req->src).
-	 */
-	req->cryptlen += ctx->authsize;
-	padsize = blocksize - (req->cryptlen % blocksize);
-	req->cryptlen += padsize;
+	padsize = blocksize - ((req->cryptlen +  ctx->authsize) % blocksize);
 
 	/*
 	 * allocate extended tls descriptor
-	 * For TLS 1.0, aead_edesc_alloc seems to be enough, no need for a
-	 * different function.
 	 * TLS 1.0 has no explicit IV in the packet, but it is needed as input
 	 * since it is used by CBC.
+	 * ctx->authsize is temporary set to include also padlen
 	 */
+	ctx->authsize += padsize;
 	edesc = aead_edesc_alloc(req, DESC_JOB_IO_LEN * CAAM_CMD_SZ,
-				 &all_contig);
+				 &all_contig, true, true);
 	if (IS_ERR(edesc))
 		return PTR_ERR(edesc);
+	ctx->authsize -= padsize;
 
 	/* Create and submit job descriptor */
 	init_tls_job(ctx->sh_desc_enc, ctx->sh_desc_enc_dma, edesc, req,
@@ -2593,13 +2583,14 @@ static int tls_decrypt(struct aead_request *req)
 
 	/*
 	 * allocate extended tls descriptor
-	 * For TLS 1.0, aead_edesc_alloc seems to be enough, no need for
-	 * a different function.
 	 * TLS 1.0 has no explicit IV in the packet, but it is needed as input
 	 * since it is used by CBC.
+	 * Assumption: since padding and ICV are not stripped (upper layer
+	 * checks padding), req->dst has to be big enough to hold payloadlen +
+	 * padlen + icvlen.
 	 */
 	edesc = aead_edesc_alloc(req, DESC_JOB_IO_LEN * CAAM_CMD_SZ,
-				 &all_contig);
+				 &all_contig, false, false);
 	if (IS_ERR(edesc))
 		return PTR_ERR(edesc);
 
@@ -3542,7 +3533,7 @@ static int __init caam_algapi_init(void)
 	struct device_node *dev_node;
 	struct platform_device *pdev;
 	struct device *ctrldev;
-	void *priv;
+	struct caam_drv_private *priv;
 	int i = 0, err = 0;
 
 	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
@@ -3576,9 +3567,9 @@ static int __init caam_algapi_init(void)
 
 		/* check if h/w supports alg */
 		if (priv->era > 0 && priv->era < driver_algs[i].min_era) {
-			dev_warn(ctrldev, "%s needs Era %d or higher but SEC is Era %d, skipping it\n",
-				 driver_algs[i].driver_name,
-				 driver_algs[i].min_era, priv->era);
+			pr_warn("%s needs Era %d or higher but SEC is Era %d, skipping it\n",
+				driver_algs[i].driver_name,
+				driver_algs[i].min_era, priv->era);
 			continue;
 		}
 
@@ -3610,3 +3601,4 @@ module_exit(caam_algapi_exit);
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("FSL CAAM support for crypto API");
 MODULE_AUTHOR("Freescale Semiconductor - NMG/STC");
+
-- 
1.7.10.4

