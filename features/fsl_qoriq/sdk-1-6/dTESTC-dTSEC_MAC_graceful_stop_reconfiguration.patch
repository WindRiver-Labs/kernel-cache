From 0ca5d696682d701023b4c49ef7486c24c3a3cecf Mon Sep 17 00:00:00 2001
From: "H.J.chen" <hongjun.chen@nxp.com>
Date: Fri, 2 Jun 2017 13:10:02 +0800
Subject: [PATCH] dTESTC: dTSEC_MAC_graceful_stop_reconfiguration

fix dTSEC_MAC_graceful_stop_reconfiguration

Signed-off-by: H.J.chen <hongjun.chen@nxp.com>
Signed-off-by: Hu <yadi.hu@windriver.com>
---
 .../freescale/fman/Peripherals/FM/MAC/dtsec.c      |   58 ++++++++++++++++----
 1 files changed, 48 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
index e8cc70a..2ed4a91 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
@@ -48,7 +48,6 @@
 #include "dtsec.h"
 #include "fsl_fman_dtsec.h"
 #include "fsl_fman_dtsec_mii_acc.h"
-
 /*****************************************************************************/
 /*                      Internal routines                                    */
 /*****************************************************************************/
@@ -386,6 +385,7 @@ static void FreeInitResources(t_Dtsec *p_Dtsec)
 static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
 {
     struct dtsec_regs *p_MemMap;
+    int pollTimeout = 0;
 
     ASSERT_COND(p_Dtsec);
 
@@ -408,16 +408,32 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
     }
 
     if (mode & e_COMM_MODE_TX)
-#if defined(FM_GTS_ERRATA_DTSEC_A004) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012)
-    if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
-        DBG(INFO, ("GTS not supported due to DTSEC_A004 errata."));
-#else  /* not defined(FM_GTS_ERRATA_DTSEC_A004) ||... */
-#ifdef FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014
-        DBG(INFO, ("GTS not supported due to DTSEC_A0014 errata."));
-#else  /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
+    {
+#if defined(FM_GTS_ERRATA_DTSEC_A004)
+        if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+            DBG(INFO, ("GTS not supported due to DTSEC_A004 errata."));
+#else  /* not defined(FM_GTS_ERRATA_DTSEC_A004) */
+
         fman_dtsec_stop_tx(p_MemMap);
-#endif /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
-#endif /* defined(FM_GTS_ERRATA_DTSEC_A004) ||...  */
+
+#if defined(FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012)
+        XX_UDelay(10);
+#endif /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 || FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012 */
+#endif /* defined(FM_GTS_ERRATA_DTSEC_A004) */
+    }
+
+    /* Poll GRSC/GTSC bits in IEVENT register until both are set */
+#if defined(FM_GRS_ERRATA_DTSEC_A002) || defined(FM_GTS_ERRATA_DTSEC_A004) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012) || defined(FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014) || defined(FM_GTS_AFTER_DROPPED_FRAME_ERRATA_DTSEC_A004839)
+    XX_UDelay(10);
+#else
+    while (fman_dtsec_get_event(p_MemMap, DTSEC_IMASK_GRSCEN | DTSEC_IMASK_GTSCEN) != (DTSEC_IMASK_GRSCEN | DTSEC_IMASK_GTSCEN))
+    {
+        if (pollTimeout == 100)
+            break;
+        XX_UDelay(1);
+        pollTimeout++;
+    }
+#endif
 
     return E_OK;
 }
@@ -636,7 +652,12 @@ static t_Error DtsecSetTxPauseFrames(t_Handle h_Dtsec,
                       " value should be greater than 320."));
 #endif /* FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003 */
 
+    GracefulStop(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     fman_dtsec_set_tx_pause_frames(p_Dtsec->p_MemMap, pauseTime);
+
+    GracefulRestart(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     return E_OK;
 }
 
@@ -657,8 +678,12 @@ static t_Error DtsecRxIgnoreMacPause(t_Handle h_Dtsec, bool en)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
+    GracefulStop(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     fman_dtsec_handle_rx_pause(p_Dtsec->p_MemMap, accept_pause);
 
+    GracefulRestart(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     return E_OK;
 }
 
@@ -791,8 +816,13 @@ static t_Error DtsecModifyMacAddress (t_Handle h_Dtsec, t_EnetAddr *p_EnetAddr)
     /* Initialize MAC Station Address registers (1 & 2)    */
     /* Station address have to be swapped (big endian to little endian */
     p_Dtsec->addr = ENET_ADDR_TO_UINT64(*p_EnetAddr);
+
+    GracefulStop(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     fman_dtsec_set_mac_address(p_Dtsec->p_MemMap, (uint8_t *)(*p_EnetAddr));
 
+    GracefulRestart(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     return E_OK;
 }
 
@@ -1080,8 +1110,12 @@ static t_Error DtsecSetWakeOnLan(t_Handle h_Dtsec, bool en)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
+    GracefulStop(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     fman_dtsec_set_wol(p_Dtsec->p_MemMap, en);
 
+    GracefulRestart(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     return E_OK;
 }
 
@@ -1102,11 +1136,15 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
     enet_speed = (enum enet_speed) ENET_SPEED_FROM_MODE(p_Dtsec->enetMode);
     p_Dtsec->halfDuplex = !fullDuplex;
 
+    GracefulStop(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     err = (t_Error)fman_dtsec_adjust_link(p_Dtsec->p_MemMap, enet_interface, enet_speed, fullDuplex);
 
     if (err == E_CONFLICT)
         RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
 
+    GracefulRestart(p_Dtsec, e_COMM_MODE_RX_AND_TX);
+
     return err;
 }
 
-- 
1.7.5.4

