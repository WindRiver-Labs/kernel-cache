From c50272b197e6bf948ae97aa1b1c4724b22ed5098 Mon Sep 17 00:00:00 2001
From: Ying Xue <ying.xue@windriver.com>
Date: Tue, 23 Jun 2015 16:02:46 +0800
Subject: [PATCH] Fix USDPAA incorrect locking policies

When a new portal element is inserted into ctx->portals list in
ioctl_portal_map(), the ctx->portals list is protected by mem_lock,
however, when a portal is deleted from the list in usdpaa_release(),
the list is not protected by any lock at all. Meanwhile, when the
list is iterated in usdpaa_get_portal_config(), it's protected by
a different lock - ctx->lock. This inconsistent or incorrect locking
policies often lead to serious bugs, such as kernel panic.

So the locking policies associated with USDPAA are uniformly adjusted
as follows:
- ctx->portals, which is protected by mem_lock
- ctx->maps, which is protected by mem_lock
- ctx->resources[], which is protected by ctx->lock
- mem_list, which is protected by mem_lock

By the way, we also found other locking issues, for example:
- While accessing ctx->resources[], the resources[] is not protected
  by ctx->lock at all in several places.
- While iterating mem_list in ioctl_dma_stats(), the list is not
  protected too.

Signed-off-by: Ying Xue <ying.xue@windriver.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c |   25 ++++++++++++++++++++-----
 1 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index fb701229..0f30812 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -475,22 +475,29 @@ static bool check_channel_device(void *_ctx, u32 channel)
 	struct active_resource *res;
 
 	/* See if the FQ is destined for one of the portals we're cleaning up */
+	spin_lock(&mem_lock);
 	list_for_each_entry_safe(portal, tmpportal, &ctx->portals, list) {
 		if (portal->user.type == usdpaa_portal_qman) {
 			if (portal->qportal->public_cfg.channel == channel) {
 				/* This FQs destination is a portal
 				   we're cleaning, send a retire */
+				spin_unlock(&mem_lock);
 				return true;
 			}
 		}
 	}
+	spin_unlock(&mem_lock);
 
 	/* Check the pool channels that will be released as well */
+	spin_lock(&ctx->lock);
 	list_for_each_entry(res, &ctx->resources[usdpaa_id_qpool], list) {
 		if ((res->id >= channel) &&
-		    ((res->id + res->num - 1) <= channel))
+		    ((res->id + res->num - 1) <= channel)) {
+			spin_unlock(&ctx->lock);
 			return true;
+		}
 	}
+	spin_unlock(&ctx->lock);
 	return false;
 }
 
@@ -528,6 +535,7 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 	   in the kernel
 	*/
 
+	spin_lock(&mem_lock);
 	list_for_each_entry_safe(portal, tmpportal, &ctx->portals, list) {
 		/* Try to recover any portals that weren't shut down */
 		if (portal->user.type == usdpaa_portal_qman) {
@@ -552,6 +560,8 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 				bm_cleanup_portal = &portal->bman_portal_low;
 		}
 	}
+	spin_unlock(&mem_lock);
+
 	/* If no portal was found, allocate one for cleanup */
 	if (!qm_cleanup_portal) {
 		qm_alloced_portal = qm_get_unused_portal();
@@ -585,6 +595,7 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 
 	while (backend->id_type != usdpaa_id_max) {
 		int leaks = 0;
+		spin_lock(&ctx->lock);
 		list_for_each_entry(res, &ctx->resources[backend->id_type],
 				    list) {
 			if (backend->id_type == usdpaa_id_fqid) {
@@ -599,6 +610,7 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 			leaks += res->num;
 			backend->release(res->id, res->num);
 		}
+		spin_unlock(&ctx->lock);
 		if (leaks)
 			pr_crit("USDPAA process leaking %d %s%s\n", leaks,
 				backend->acronym, (leaks > 1) ? "s" : "");
@@ -625,7 +637,6 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 		list_del(&map->list);
 		kfree(map);
 	}
-	spin_unlock(&mem_lock);
 
 	/* Return portals */
 	list_for_each_entry_safe(portal, tmpportal, &ctx->portals, list) {
@@ -642,6 +653,8 @@ static int usdpaa_release(struct inode *inode, struct file *filp)
 		list_del(&portal->list);
 		kfree(portal);
 	}
+	spin_unlock(&mem_lock);
+
 	if (qm_alloced_portal) {
 		qm_put_unused_portal(qm_alloced_portal);
 		kfree(qm_cleanup_portal);
@@ -1150,10 +1163,12 @@ static long ioctl_dma_stats(struct ctx *ctx, void __user *arg)
 	result.free_bytes = 0;
 	result.total_bytes = phys_size;
 
+	spin_lock(&mem_lock);
 	list_for_each_entry(frag, &mem_list, list) {
 		if (frag->refs == 0)
 			result.free_bytes += frag->len;
 	}
+	spin_unlock(&mem_lock);
 
 	return copy_to_user(arg, &result, sizeof(result)); }
 
@@ -1742,7 +1757,7 @@ int usdpaa_get_portal_config(struct file *filp, void *cinh,
 	if (filp->f_op->open != usdpaa_open)
 		return -ENODEV;
 	context = filp->private_data;
-	spin_lock(&context->lock);
+	spin_lock(&mem_lock);
 	list_for_each_entry(portal, &context->portals, list) {
 		if (portal->user.type == ptype &&
 		    portal->user.addr.cinh == cinh) {
@@ -1755,11 +1770,11 @@ int usdpaa_get_portal_config(struct file *filp, void *cinh,
 				*iir_reg = portal->bportal->addr_virt[1] +
 					BM_REG_IIR;
 			}
-			spin_unlock(&context->lock);
+			spin_unlock(&mem_lock);
 			return 0;
 		}
 	}
-	spin_unlock(&context->lock);
+	spin_unlock(&mem_lock);
 	return -EINVAL;
 }
 
-- 
1.7.5.4

