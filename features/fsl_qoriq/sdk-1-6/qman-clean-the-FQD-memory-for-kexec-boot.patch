From 15f5a98afe3d0ba4d796ad500ebb8d0d1101b76a Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 16 Feb 2015 10:58:10 +0800
Subject: [PATCH 1/6] qman: clean the FQD memory for kexec boot

Clean the FQD memory for kexec boot.

Zeroing of FQD memory is required by QMAN hardware.
Each FQ is maintained in an FQ-entry in the 'FQD array' in FQD memory.
The FQD entry records the state of the FQ.
Zeroing FQD memory at startup ensures that the FQs stored in FQD memory
are all out-of-service.
As for PFDR memory, initializing the PFDR free pool is done by using
the 0x01 command code in QMAN_MCR, so we don't need to clean it at this point.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl_qbman/qman_config.c |   13 +++++++++----
 1 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index a6eae6e..dfdb29a 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -357,7 +357,7 @@ static int qm_is_initalized(struct qman *qm, enum qm_memory memory)
 	u32 offset = (memory == qm_memory_fqd) ? REG_FQD_BARE : REG_PFDR_BARE;
 	return __qm_in(qm, offset + REG_offset_BAR);
 }
-static void qm_reserve_memory(struct qman *qm, enum qm_memory memory)
+static void qm_reserve_memory(struct qman *qm, enum qm_memory memory, int zero)
 {
 	u64 upper_ba = 0;
 	u32 lower_ba = 0;
@@ -367,6 +367,7 @@ static void qm_reserve_memory(struct qman *qm, enum qm_memory memory)
 	u32 size = 0;
 	u32 offset = (memory == qm_memory_fqd) ? REG_FQD_BARE : REG_PFDR_BARE;
 	int ret;
+	unsigned long vaddr;
 
 	upper_ba = __qm_in(qm, offset);
 	lower_ba = __qm_in(qm, offset + REG_offset_BAR);
@@ -381,6 +382,10 @@ static void qm_reserve_memory(struct qman *qm, enum qm_memory memory)
 	addr = max(addr, memblock_start_of_DRAM());
 	end = min(addr + size, memblock_end_of_DRAM());
 	ret = memblock_reserve(addr, end - addr);
+	vaddr = (unsigned long)phys_to_virt(addr);
+	if (zero)
+		memset((void *)vaddr, 0, end - addr);
+	flush_dcache_range(vaddr, vaddr + (end - addr));
 	WARN_ON(ret);
 }
 #else
@@ -388,7 +393,7 @@ static int qm_is_initalized(struct qman *qm, enum qm_memory memory)
 {
 	return 0;
 }
-static void qm_reserve_memory(struct qman *qm, enum qm_memory memory)
+static void qm_reserve_memory(struct qman *qm, enum qm_memory memory, int zero)
 {
 }
 #endif
@@ -558,7 +563,7 @@ static int __init fsl_qman_init(struct device_node *node)
 		/* Unfortunately we have to reserve those memory used for Qman
 		 * since currently we can't clean these usage from boot kernel.
 		 */
-			qm_reserve_memory(qm, qm_memory_fqd);
+			qm_reserve_memory(qm, qm_memory_fqd, 1);
 		if (!qm_is_initalized(qm, qm_memory_pfdr)) {
 			ret = parse_mem_property(node, "fsl,qman-pfdr",
 						&pfdr_a, &pfdr_sz, 0);
@@ -567,7 +572,7 @@ static int __init fsl_qman_init(struct device_node *node)
 		/* Unfortunately we have to reserve those memory used for Qman
 		 * since currently we can't clean these usage from boot kernel.
 		 */
-			qm_reserve_memory(qm, qm_memory_pfdr);
+			qm_reserve_memory(qm, qm_memory_pfdr, 0);
 	}
 	/* Global configuration */
 	qm_node = node;
-- 
1.7.5.4

