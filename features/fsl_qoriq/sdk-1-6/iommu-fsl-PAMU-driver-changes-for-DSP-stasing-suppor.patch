From 531fa88ec7a83c633d61fd05b1b1a783eab9e831 Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Fri, 12 Sep 2014 17:38:33 +0800
Subject: [PATCH 0784/1089] iommu/fsl: PAMU driver changes for DSP stasing
 support.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Modifications to PAMU driver for supporting DSP stashing.

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Change-Id: I1462806c85f0f398a332ac321bb7b67a8cabc1bb
Reviewed-on: http://git.am.freescale.net:8181/9617
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 arch/powerpc/include/asm/fsl_pamu_stash.h | 18 +++++++
 drivers/iommu/fsl_pamu.c                  | 80 ++++++++++++++-----------------
 drivers/iommu/fsl_pamu.h                  | 12 ++---
 drivers/iommu/fsl_pamu_domain.c           | 49 +++++++++----------
 drivers/iommu/fsl_pamu_domain.h           | 15 +++---
 include/linux/iommu.h                     | 16 +------
 6 files changed, 93 insertions(+), 97 deletions(-)

diff --git a/arch/powerpc/include/asm/fsl_pamu_stash.h b/arch/powerpc/include/asm/fsl_pamu_stash.h
index caa1b21..d961be8 100644
--- a/arch/powerpc/include/asm/fsl_pamu_stash.h
+++ b/arch/powerpc/include/asm/fsl_pamu_stash.h
@@ -19,11 +19,23 @@
 #ifndef __FSL_PAMU_STASH_H
 #define __FSL_PAMU_STASH_H
 
+/* Define operation mapping indexes */
+enum omap_index {
+	OMI_QMAN,
+	OMI_FMAN,
+	OMI_QMAN_PRIV,
+	OMI_CAAM,
+	OMI_PMAN,
+	OMI_DSP,
+	OMI_MAX,
+};
+
 /* cache stash targets */
 enum pamu_stash_target {
 	PAMU_ATTR_CACHE_L1 = 1,
 	PAMU_ATTR_CACHE_L2,
 	PAMU_ATTR_CACHE_L3,
+	PAMU_ATTR_CACHE_DSP_L2,
 };
 
 /*
@@ -34,6 +46,12 @@ enum pamu_stash_target {
 struct pamu_stash_attribute {
 	u32 	cpu;	/* cpu number */
 	u32 	cache;	/* cache to stash to: L1,L2,L3 */
+	u32 window; /* ~0 indicates all windows */
+};
+
+struct pamu_omi_attribute {
+	u32 omi;   /* index in the operation mapping table */
+	u32 window; /* ~0 indicates all windows */
 };
 
 #endif  /* __FSL_PAMU_STASH_H */
diff --git a/drivers/iommu/fsl_pamu.c b/drivers/iommu/fsl_pamu.c
index 1e5df6f..6b50295 100644
--- a/drivers/iommu/fsl_pamu.c
+++ b/drivers/iommu/fsl_pamu.c
@@ -311,7 +311,7 @@ void pamu_free_subwins(int liodn)
 }
 
 /*
- * Function used for updating stash destination for the coressponding
+ * Function used for updating a specifc PAACE field for the coressponding
  * LIODN.
  */
 int  pamu_update_paace_field(int liodn, u32 subwin, int field, u32 value)
@@ -320,7 +320,7 @@ int  pamu_update_paace_field(int liodn, u32 subwin, int field, u32 value)
 
 	paace = pamu_get_ppaace(liodn);
 	if (!paace) {
-		pr_debug("Invalid liodn entry\n");
+		pr_err("Invalid liodn entry\n");
 		return -ENOENT;
 	}
 	if (subwin) {
@@ -575,64 +575,55 @@ void get_ome_index(u32 *omi_index, struct device *dev)
  * We get the stash id programmed by SDOS from the shared
  * cluster L2 l2csr1 register.
  */
-static u32 get_dsp_l2_stash_id(u32 cluster)
+static u32 get_dsp_l2_stash_id(u32 vcpu)
 {
 	const u32 *prop;
 	struct device_node *node;
-	struct device_node *dsp_cpu_node;
 	struct ccsr_cluster_l2 *l2cache_regs;
 	u32 stash_id;
 
-	for_each_compatible_node(node, NULL, "fsl,sc3900-cluster") {
+	for_each_compatible_node(node, NULL, "fsl,sc3900") {
 		prop = of_get_property(node, "reg", 0);
 		if (!prop) {
-			pr_err("missing reg property in dsp cluster %s\n",
-				node->full_name);
+			pr_err("missing reg property in dsp cpu node %s\n",
+			       node->full_name);
 			of_node_put(node);
 			return ~(u32)0;
 		}
 
-		if (*prop == cluster) {
-			dsp_cpu_node = of_find_compatible_node(node, NULL, "fsl,sc3900");
-			if (!dsp_cpu_node) {
-				pr_err("missing dsp cpu node in dsp cluster %s\n",
-					node->full_name);
-				of_node_put(node);
-				return ~(u32)0;
-			}
-			of_node_put(node);
-
-			prop = of_get_property(dsp_cpu_node, "next-level-cache", 0);
-			if (!prop) {
-				pr_err("missing next level cache property in dsp cpu %s\n",
-					node->full_name);
-				of_node_put(dsp_cpu_node);
-				return ~(u32)0;
-			}
-			of_node_put(dsp_cpu_node);
+		if (*prop != vcpu)
+			continue;
 
-			node = of_find_node_by_phandle(*prop);
-			if (!node) {
-				pr_err("Invalid node for cache hierarchy %s\n",
-					node->full_name);
-				return ~(u32)0;
-			}
+		prop = of_get_property(node, "next-level-cache", 0);
+		if (!prop) {
+			pr_err("missing next level cache property in dsp cpu %s\n",
+			       node->full_name);
+			of_node_put(node);
+			return ~(u32)0;
+		}
+		of_node_put(node);
 
-			l2cache_regs = of_iomap(node, 0);
-			if (!l2cache_regs) {
-				pr_err("failed to map cluster l2 cache registers %s\n",
-					node->full_name);
-				of_node_put(node);
-				return ~(u32)0;
-			}
+		node = of_find_node_by_phandle(*prop);
+		if (!node) {
+			pr_err("Invalid node for cache hierarchy %s\n",
+			       node->full_name);
+			return ~(u32)0;
+		}
 
-			stash_id = in_be32(&l2cache_regs->l2csr1) &
-					 CLUSTER_L2_STASH_MASK;
+		l2cache_regs = of_iomap(node, 0);
+		if (!l2cache_regs) {
+			pr_err("failed to map cluster l2 cache registers %s\n",
+			       node->full_name);
 			of_node_put(node);
-			iounmap(l2cache_regs);
-
-			return stash_id;
+			return ~(u32)0;
 		}
+
+		stash_id = in_be32(&l2cache_regs->l2csr1) &
+				 CLUSTER_L2_STASH_MASK;
+		of_node_put(node);
+		iounmap(l2cache_regs);
+
+		return stash_id;
 	}
 	return ~(u32)0;
 }
@@ -655,9 +646,10 @@ u32 get_stash_id(u32 stash_dest_hint, u32 vcpu)
 	int i;
 
 	/* check for DSP L2 cache */
-	if (stash_dest_hint == IOMMU_ATTR_CACHE_DSP_L2) {
+	if (stash_dest_hint == PAMU_ATTR_CACHE_DSP_L2) {
 		return get_dsp_l2_stash_id(vcpu);
 	}
+
 	/* Fastpath, exit early if L3/CPC cache is target for stashing */
 	if (stash_dest_hint == PAMU_ATTR_CACHE_L3) {
 		node = of_find_matching_node(NULL, l3_device_ids);
diff --git a/drivers/iommu/fsl_pamu.h b/drivers/iommu/fsl_pamu.h
index abc2bde..89940fa 100644
--- a/drivers/iommu/fsl_pamu.h
+++ b/drivers/iommu/fsl_pamu.h
@@ -321,6 +321,12 @@ struct paace {
 	u32 reserved[8];			/* not currently implemented */
 };
 
+enum  paace_field {
+	PAACE_STASH_FIELD,
+	PAACE_OMI_FIELD,
+	PAACE_FIELD_MAX,
+};
+
 /* OME : Operation mapping entry
  * MOE : Mapped Operation Encodings
  * The operation mapping table is table containing operation mapping entries (OME).
@@ -389,12 +395,6 @@ struct ome {
 #define EOE_WWSAOL      0x1e    /* Write with stash allocate only and lock */
 #define EOE_VALID       0x80
 
-enum  paace_field {
-	PAACE_STASH_FIELD,
-	PAACE_OMI_FIELD,
-	PAACE_FIELD_MAX,
-};
-
 /* Function prototypes */
 int pamu_domain_init(void);
 int pamu_enable_liodn(int liodn);
diff --git a/drivers/iommu/fsl_pamu_domain.c b/drivers/iommu/fsl_pamu_domain.c
index 8162ba5..edd5095 100644
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@ -540,21 +540,6 @@ static int pamu_set_domain_geometry(struct fsl_dma_domain *dma_domain,
 	return ret;
 }
 
-/* Update stash destination for all LIODNs associated with the domain */
-static int update_domain_stash(struct fsl_dma_domain *dma_domain, u32 val)
-{
-	struct device_domain_info *info;
-	int ret = 0;
-
-	list_for_each_entry(info, &dma_domain->devices, link) {
-		ret = update_liodn_stash(info->liodn, dma_domain, val);
-		if (ret)
-			break;
-	}
-
-	return ret;
-}
-
 /* Update domain mappings for all LIODNs associated with the domain */
 static int update_domain_mapping(struct fsl_dma_domain *dma_domain, u32 wnd_nr)
 {
@@ -867,7 +852,7 @@ static int configure_domain_op_map(struct fsl_dma_domain *dma_domain,
 	unsigned long flags;
 	struct pamu_attr_info attr_info;
 	int ret, i;
-	struct iommu_omi_attribute *omi_attr = data;
+	struct pamu_omi_attribute *omi_attr = data;
 
 	spin_lock_irqsave(&dma_domain->domain_lock, flags);
 
@@ -925,7 +910,7 @@ static int configure_domain_stash(struct fsl_dma_domain *dma_domain, void *data)
 					    stash_attr->cpu);
 	if ((~stash_id == 0) ||
 		 check_attr_window(stash_attr->window, dma_domain)) {
-		pr_debug("Invalid stash attributes\n");
+		pr_err("Invalid stash attributes\n");
 		spin_unlock_irqrestore(&dma_domain->domain_lock, flags);
 		return -EINVAL;
 	}
@@ -934,13 +919,15 @@ static int configure_domain_stash(struct fsl_dma_domain *dma_domain, void *data)
 		wnd = &dma_domain->win_arr[0];
 		for (i = 0; i < dma_domain->win_cnt; i++) {
 			wnd[i].stash_id = stash_id;
-			memcpy(&wnd[i].stash_attr, stash_attr, sizeof(struct iommu_stash_attribute));
+			memcpy(&wnd[i].stash_attr, stash_attr,
+			       sizeof(struct pamu_stash_attribute));
 			wnd[i].stash_attr.window = i;
 		}
 	} else {
 		wnd = &dma_domain->win_arr[stash_attr->window];
 		wnd->stash_id = stash_id;
-		memcpy(&wnd->stash_attr, stash_attr, sizeof(struct iommu_stash_attribute));
+		memcpy(&wnd->stash_attr,
+		       stash_attr, sizeof(struct pamu_stash_attribute));
 	}
 
 	attr_info.window = stash_attr->window;
@@ -1002,6 +989,9 @@ static int fsl_pamu_set_domain_attr(struct iommu_domain *domain,
 	case DOMAIN_ATTR_PAMU_OP_MAP:
 		ret = configure_domain_op_map(dma_domain, data);
 		break;
+	case DOMAIN_ATTR_FSL_PAMU_OP_MAP:
+		ret = configure_domain_op_map(dma_domain, data);
+		break;
 	default:
 		pr_debug("Unsupported attribute type\n");
 		ret = -EINVAL;
@@ -1025,8 +1015,8 @@ static int fsl_pamu_get_domain_attr(struct iommu_domain *domain,
 	case DOMAIN_ATTR_FSL_PAMUV1:
 		*(int *)data = DOMAIN_ATTR_FSL_PAMUV1;
 		break;
-	case DOMAIN_ATTR_PAMU_STASH: {
-		struct iommu_stash_attribute *stash_attr = data;
+	case DOMAIN_ATTR_FSL_PAMU_STASH: {
+		struct pamu_stash_attribute *stash_attr = data;
 		struct dma_window *wnd;
 
 		if (stash_attr->window >= dma_domain->win_cnt ||
@@ -1034,11 +1024,12 @@ static int fsl_pamu_get_domain_attr(struct iommu_domain *domain,
 			return -EINVAL;
 
 		wnd = &dma_domain->win_arr[stash_attr->window];
-		memcpy(stash_attr, &wnd->stash_attr, sizeof(struct iommu_stash_attribute));
+		memcpy(stash_attr, &wnd->stash_attr,
+		       sizeof(struct pamu_stash_attribute));
 		break;
 	}
-	case DOMAIN_ATTR_PAMU_OP_MAP: {
-		struct iommu_omi_attribute *omi_attr = data;
+	case DOMAIN_ATTR_FSL_PAMU_OP_MAP: {
+		struct pamu_omi_attribute *omi_attr = data;
 		struct dma_window *wnd;
 
 		if (omi_attr->window >= dma_domain->win_cnt ||
@@ -1270,6 +1261,16 @@ static void dma_domain_init_windows(struct fsl_dma_domain *dma_domain)
 	}
 }
 
+static void dma_domain_init_windows(struct fsl_dma_domain *dma_domain)
+{
+	int i;
+
+	for (i = 0; i < dma_domain->win_cnt; i++) {
+		dma_domain->win_arr[i].stash_id = ~(u32)0;
+		dma_domain->win_arr[i].omi = ~(u32)0;
+	}
+}
+
 static int fsl_pamu_set_windows(struct iommu_domain *domain, u32 w_count)
 {
 	struct fsl_dma_domain *dma_domain = domain->priv;
diff --git a/drivers/iommu/fsl_pamu_domain.h b/drivers/iommu/fsl_pamu_domain.h
index 86af82d..60a8452 100644
--- a/drivers/iommu/fsl_pamu_domain.h
+++ b/drivers/iommu/fsl_pamu_domain.h
@@ -22,11 +22,13 @@
 #include "fsl_pamu.h"
 
 struct dma_window {
-	phys_addr_t                   paddr;
-	u64 size;
-	int                          valid;
-	int                          prot;
-	u32                          omi;
+	phys_addr_t                 paddr;
+	u64                         size;
+	int                         valid;
+	int                         prot;
+	struct pamu_stash_attribute stash_attr;
+	u32                         stash_id;
+	u32                         omi;
 };
 
 struct fsl_dma_domain {
@@ -68,9 +70,6 @@ struct fsl_dma_domain {
 	 */
 	int				mapped;
 	int				enabled;
-	/* stash_id obtained from the stash attribute details */
-	u32				stash_id;
-	struct pamu_stash_attribute	dma_stash;
 	u32				snoop_id;
 	struct iommu_domain		*iommu_domain;
 	spinlock_t			domain_lock;
diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index 4b1d05c..9c3fe60 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -43,11 +43,6 @@ struct notifier_block;
 typedef int (*iommu_fault_handler_t)(struct iommu_domain *,
 			struct device *, unsigned long, int, void *);
 
-struct iommu_omi_attribute {
-	u32 omi;   /* index in the operation mapping table */
-	u32 window; /* ~0 indicates all windows */
-};
-
 struct iommu_domain_geometry {
 	dma_addr_t aperture_start; /* First address that can be mapped    */
 	dma_addr_t aperture_end;   /* Last address that can be mapped     */
@@ -65,16 +60,6 @@ struct iommu_domain {
 #define IOMMU_CAP_CACHE_COHERENCY	0x1
 #define IOMMU_CAP_INTR_REMAP		0x2	/* isolates device intrs */
 
-/* define indexes for each operation mapping scenario */
-enum omap_index {
-	OMI_QMAN,
-	OMI_FMAN,
-	OMI_QMAN_PRIV,
-	OMI_CAAM,
-	OMI_PMAN,
-	OMI_DSP,
-	OMI_MAX,
-};
 
 /*
  * Following constraints are specifc to FSL_PAMUV1:
@@ -94,6 +79,7 @@ enum iommu_attr {
 	DOMAIN_ATTR_PAGING,
 	DOMAIN_ATTR_WINDOWS,
 	DOMAIN_ATTR_FSL_PAMU_STASH,
+	DOMAIN_ATTR_FSL_PAMU_OP_MAP,
 	DOMAIN_ATTR_FSL_PAMU_ENABLE,
 	DOMAIN_ATTR_FSL_PAMUV1,
 	DOMAIN_ATTR_PAMU_OP_MAP,
-- 
2.0.2

