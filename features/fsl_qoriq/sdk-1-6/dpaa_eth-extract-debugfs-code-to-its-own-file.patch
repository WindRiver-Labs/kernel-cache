From 73360b2d995ec488b962c3475a9535bf7e3fc66a Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Fri, 19 Apr 2013 20:07:57 +0000
Subject: [PATCH 0219/1089] dpaa_eth: extract debugfs code to its own file

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Code cleanup, move debugfs code outside dpaa_eth.c.
Also fixed some checkpatch.pl reports in the existing code.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>

Change-Id: Ia70e55d367ffd5743f44cee5ce93c83bb3f7594d
Reviewed-on: http://git.am.freescale.net:8181/1719
Reviewed-by: Sovaiala Cristian-Constantin-B39531 <Cristian.Sovaiala@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/Kconfig        |   7 +
 drivers/net/ethernet/freescale/dpa/Makefile       |   2 +
 drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c | 285 ++++++++++++++++++++++
 drivers/net/ethernet/freescale/dpa/dpaa_debugfs.h |  42 ++++
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c     | 240 +-----------------
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h     |  11 +-
 6 files changed, 354 insertions(+), 233 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/dpaa_debugfs.h

diff --git a/drivers/net/ethernet/freescale/dpa/Kconfig b/drivers/net/ethernet/freescale/dpa/Kconfig
index b54831d..8a14c88 100644
--- a/drivers/net/ethernet/freescale/dpa/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/Kconfig
@@ -119,3 +119,10 @@ config DPAA_ETH_UNIT_TESTS
 	bool
 	depends on DPA_ETH
 	default n
+
+config FSL_DPAA_ETH_DEBUGFS
+	tristate "DPAA Ethernet debugfs interface"
+	depends on DEBUG_FS
+	default y
+	---help---
+	  This option compiles debugfs code for the DPAA Ethernet driver.
diff --git a/drivers/net/ethernet/freescale/dpa/Makefile b/drivers/net/ethernet/freescale/dpa/Makefile
index eb78df8..7278394 100644
--- a/drivers/net/ethernet/freescale/dpa/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/Makefile
@@ -10,6 +10,8 @@ EXTRA_CFLAGS += -I$(NET_DPA)
 
 obj-$(CONFIG_FSL_DPA_1588) += dpaa_1588.o
 obj-$(CONFIG_DPAA_ETH_SG_SUPPORT) += fsl-dpa-sg.o
+# dpaa_debugfs needs to be initialized before dpaa_eth
+obj-$(CONFIG_FSL_DPAA_ETH_DEBUGFS) += dpaa_debugfs.o
 obj-$(CONFIG_DPA_ETH) += fsl-mac.o fsl-dpa.o
 obj-$(CONFIG_DPA_OFFLINE_PORTS) += fsl-oh.o
 
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c b/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c
new file mode 100644
index 0000000..4544f97
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c
@@ -0,0 +1,285 @@
+/*
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+#include <linux/fsl_qman.h>	/* struct qm_mcr_querycgr */
+#include <linux/debugfs.h>
+#include <asm/debug.h>
+#include "dpaa_debugfs.h"
+#include "dpaa_eth.h" /* struct dpa_priv_s, dpa_percpu_priv_s, dpa_bp */
+
+#define DPA_DEBUGFS_DESCRIPTION "FSL DPAA Ethernet debugfs entries"
+#define DPA_ETH_DEBUGFS_ROOT "fsl_dpa"
+
+static int __cold dpa_debugfs_open(struct inode *inode, struct file *file);
+
+static struct dentry *dpa_debugfs_root;
+static const struct file_operations dpa_debugfs_fops = {
+	.open		= dpa_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int dpa_debugfs_show(struct seq_file *file, void *offset)
+{
+	int				 i;
+	struct dpa_priv_s		*priv;
+	struct dpa_percpu_priv_s	*percpu_priv, total;
+	struct dpa_bp *dpa_bp;
+	unsigned int dpa_bp_count = 0;
+	unsigned int count_total = 0;
+	struct qm_mcr_querycgr query_cgr;
+
+	BUG_ON(offset == NULL);
+
+	priv = netdev_priv((struct net_device *)file->private);
+
+	dpa_bp = priv->dpa_bp;
+
+	memset(&total, 0, sizeof(total));
+
+	/* "Standard" counters */
+	seq_printf(file, "\nDPA counters for %s:\n", priv->net_dev->name);
+	seq_printf(file, "CPU           irqs        rx        tx   recycle   ");
+	seq_printf(file, "confirm     tx sg    tx err    rx err   bp count\n");
+
+
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+
+		/* Only private interfaces have an associated counter for bp
+		 * buffers. Also the counter isn't initialized before the first
+		 * ifconfig up
+		 */
+		if (!priv->shared && percpu_priv->dpa_bp_count)
+			dpa_bp_count = *percpu_priv->dpa_bp_count;
+
+		total.in_interrupt += percpu_priv->in_interrupt;
+		total.stats.rx_packets += percpu_priv->stats.rx_packets;
+		total.stats.tx_packets += percpu_priv->stats.tx_packets;
+		total.tx_returned += percpu_priv->tx_returned;
+		total.tx_confirm += percpu_priv->tx_confirm;
+		total.tx_frag_skbuffs += percpu_priv->tx_frag_skbuffs;
+		total.stats.tx_errors += percpu_priv->stats.tx_errors;
+		total.stats.rx_errors += percpu_priv->stats.rx_errors;
+		count_total += dpa_bp_count;
+
+		seq_printf(file, "     %hu/%hu  %8llu  %8llu  %8llu  %8llu  ",
+				get_hard_smp_processor_id(i), i,
+				percpu_priv->in_interrupt,
+				percpu_priv->stats.rx_packets,
+				percpu_priv->stats.tx_packets,
+				percpu_priv->tx_returned);
+		seq_printf(file, "%8llu  %8llu  %8llu  %8llu     %8d\n",
+				percpu_priv->tx_confirm,
+				percpu_priv->tx_frag_skbuffs,
+				percpu_priv->stats.tx_errors,
+				percpu_priv->stats.rx_errors,
+				dpa_bp_count);
+	}
+	seq_printf(file, "Total     %8llu  %8llu  %8llu  %8llu  ",
+			total.in_interrupt,
+			total.stats.rx_packets,
+			total.stats.tx_packets,
+			total.tx_returned);
+	seq_printf(file, "%8llu  %8llu  %8llu  %8llu     %8d\n",
+			total.tx_confirm,
+			total.tx_frag_skbuffs,
+			total.stats.tx_errors,
+			total.stats.rx_errors,
+			count_total);
+
+	/* Congestion stats */
+	seq_printf(file, "\nDevice congestion stats:\n");
+	seq_printf(file, "Device has been congested for %d ms.\n",
+		jiffies_to_msecs(priv->cgr_data.congested_jiffies));
+
+	qman_query_cgr(&priv->cgr_data.cgr, &query_cgr);
+	seq_printf(file, "CGR id %d avg count: %llu\n",
+		priv->cgr_data.cgr.cgrid, qm_mcr_querycgr_a_get64(&query_cgr));
+	seq_printf(file, "Device entered congestion %u times. ",
+			priv->cgr_data.cgr_congested_count);
+	seq_printf(file, "Current congestion state is: %s.\n",
+		query_cgr.cgr.cs ? "congested" : "not congested");
+	/* Reset congestion stats (like QMan CGR API does) */
+	priv->cgr_data.congested_jiffies = 0;
+	priv->cgr_data.cgr_congested_count = 0;
+
+	/* Rx Errors demultiplexing */
+	seq_printf(file, "\nDPA RX Errors:\nCPU        dma err  phys err");
+	seq_printf(file, "  size err   hdr err  csum err\n");
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+
+		total.rx_errors.dme += percpu_priv->rx_errors.dme;
+		total.rx_errors.fpe += percpu_priv->rx_errors.fpe;
+		total.rx_errors.fse += percpu_priv->rx_errors.fse;
+		total.rx_errors.phe += percpu_priv->rx_errors.phe;
+		total.rx_errors.cse += percpu_priv->rx_errors.cse;
+
+		seq_printf(file, "     %hu/%hu  %8llu  %8llu  ",
+				get_hard_smp_processor_id(i), i,
+				percpu_priv->rx_errors.dme,
+				percpu_priv->rx_errors.fpe);
+		seq_printf(file, "%8llu  %8llu  %8llu\n",
+				percpu_priv->rx_errors.fse,
+				percpu_priv->rx_errors.phe,
+				percpu_priv->rx_errors.cse);
+	}
+	seq_printf(file, "Total     %8llu  %8llu  %8llu  %8llu  %8llu\n",
+			total.rx_errors.dme,
+			total.rx_errors.fpe,
+			total.rx_errors.fse,
+			total.rx_errors.phe,
+			total.rx_errors.cse);
+
+	/* ERN demultiplexing */
+	seq_printf(file, "\nDPA ERN counters:\n  CPU     cg_td      wred  ");
+	seq_printf(file, "err_cond   early_w    late_w     fq_td    fq_ret");
+	seq_printf(file, "     orp_z\n");
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+
+		total.ern_cnt.cg_tdrop += percpu_priv->ern_cnt.cg_tdrop;
+		total.ern_cnt.wred += percpu_priv->ern_cnt.wred;
+		total.ern_cnt.err_cond += percpu_priv->ern_cnt.err_cond;
+		total.ern_cnt.early_window += percpu_priv->ern_cnt.early_window;
+		total.ern_cnt.late_window += percpu_priv->ern_cnt.late_window;
+		total.ern_cnt.fq_tdrop += percpu_priv->ern_cnt.fq_tdrop;
+		total.ern_cnt.fq_retired += percpu_priv->ern_cnt.fq_retired;
+		total.ern_cnt.orp_zero += percpu_priv->ern_cnt.orp_zero;
+
+		seq_printf(file, "  %hu/%hu  %8llu  %8llu  %8llu  %8llu  ",
+			get_hard_smp_processor_id(i), i,
+			percpu_priv->ern_cnt.cg_tdrop,
+			percpu_priv->ern_cnt.wred,
+			percpu_priv->ern_cnt.err_cond,
+			percpu_priv->ern_cnt.early_window);
+		seq_printf(file, "%8llu  %8llu  %8llu  %8llu\n",
+			percpu_priv->ern_cnt.late_window,
+			percpu_priv->ern_cnt.fq_tdrop,
+			percpu_priv->ern_cnt.fq_retired,
+			percpu_priv->ern_cnt.orp_zero);
+	}
+	seq_printf(file, "Total  %8llu  %8llu  %8llu  %8llu  ",
+		total.ern_cnt.cg_tdrop,
+		total.ern_cnt.wred,
+		total.ern_cnt.err_cond,
+		total.ern_cnt.early_window);
+	seq_printf(file, "%8llu  %8llu  %8llu  %8llu\n",
+		total.ern_cnt.late_window,
+		total.ern_cnt.fq_tdrop,
+		total.ern_cnt.fq_retired,
+		total.ern_cnt.orp_zero);
+
+	return 0;
+}
+
+static int __cold dpa_debugfs_open(struct inode *inode, struct file *file)
+{
+	int			 _errno;
+	const struct net_device	*net_dev;
+
+	_errno = single_open(file, dpa_debugfs_show, inode->i_private);
+	if (unlikely(_errno < 0)) {
+		net_dev = (struct net_device *)inode->i_private;
+
+		if (netif_msg_drv((struct dpa_priv_s *)netdev_priv(net_dev)))
+			netdev_err(net_dev, "single_open() = %d\n",
+					_errno);
+	}
+	return _errno;
+}
+
+int dpa_netdev_debugfs_create(struct net_device *net_dev)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+
+	if (unlikely(dpa_debugfs_root == NULL)) {
+		pr_err(KBUILD_MODNAME ": %s:%hu:%s(): \t%s\n",
+				   KBUILD_BASENAME".c", __LINE__, __func__,
+				   "root debugfs missing, possible module ordering issue");
+		return -ENOMEM;
+	}
+
+	priv->debugfs_file = debugfs_create_file(net_dev->name,
+							 S_IRUGO,
+							 dpa_debugfs_root,
+							 net_dev,
+							 &dpa_debugfs_fops);
+	if (unlikely(priv->debugfs_file == NULL)) {
+		netdev_err(net_dev, "debugfs_create_file(%s/%s/%s)",
+				powerpc_debugfs_root->d_iname,
+				dpa_debugfs_root->d_iname,
+				net_dev->name);
+
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+void dpa_netdev_debugfs_remove(struct net_device *net_dev)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+
+	debugfs_remove(priv->debugfs_file);
+}
+
+static int __init dpa_debugfs_module_init(void)
+{
+	int	 _errno = 0;
+
+	pr_info(KBUILD_MODNAME ": " DPA_DEBUGFS_DESCRIPTION " (" VERSION ")\n");
+
+	dpa_debugfs_root = debugfs_create_dir(DPA_ETH_DEBUGFS_ROOT,
+					      powerpc_debugfs_root);
+	if (unlikely(dpa_debugfs_root == NULL)) {
+		_errno = -ENOMEM;
+		pr_err(KBUILD_MODNAME ": %s:%hu:%s():\n",
+				   KBUILD_BASENAME".c", __LINE__, __func__);
+		pr_err("\tdebugfs_create_dir(%s/"KBUILD_MODNAME") = %d\n",
+			   powerpc_debugfs_root->d_iname, _errno);
+	}
+
+	return _errno;
+}
+
+static void __exit dpa_debugfs_module_exit(void)
+{
+	debugfs_remove(dpa_debugfs_root);
+}
+
+module_init(dpa_debugfs_module_init);
+module_exit(dpa_debugfs_module_exit);
+MODULE_LICENSE("Dual BSD/GPL");
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.h b/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.h
new file mode 100644
index 0000000..923f51a
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef DPAA_DEBUGFS_H_
+#define DPAA_DEBUGFS_H_
+
+#include <linux/netdevice.h>
+#include <linux/dcache.h>	/* struct dentry needed in dpaa_eth.h */
+
+int dpa_netdev_debugfs_create(struct net_device *net_dev);
+void dpa_netdev_debugfs_remove(struct net_device *net_dev);
+
+#endif /* DPAA_DEBUGFS_H_ */
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 7c88065..3a35dcd 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -57,10 +57,6 @@
 #include <linux/percpu.h>
 #include <linux/dma-mapping.h>
 #include <asm/smp.h>		/* get_hard_smp_processor_id() */
-#ifdef CONFIG_DEBUG_FS
-#include <linux/debugfs.h>
-#include <asm/debug.h>
-#endif
 #include <linux/fsl_bman.h>
 
 #include "fsl_fman.h"
@@ -70,6 +66,9 @@
 #include "mac.h"
 #include "dpaa_eth.h"
 #include "dpaa_1588.h"
+#ifdef CONFIG_FSL_DPAA_ETH_DEBUGFS
+#include "dpaa_debugfs.h"
+#endif /* CONFIG_FSL_DPAA_ETH_DEBUGFS */
 
 /* CREATE_TRACE_POINTS only needs to be defined once. Other dpa files
  * using trace events only need to #include <trace/events/sched.h>
@@ -158,10 +157,6 @@ static uint16_t tx_timeout = 1000;
 module_param(tx_timeout, ushort, S_IRUGO);
 MODULE_PARM_DESC(tx_timeout, "The Tx timeout in ms");
 
-#ifdef CONFIG_DEBUG_FS
-static struct dentry *dpa_debugfs_root;
-#endif
-
 /* dpaa_eth mirror for the FMan values */
 static int dpa_rx_extra_headroom;
 static int dpa_max_frm;
@@ -3298,185 +3293,6 @@ static const char fsl_qman_frame_queues[][25] = {
 	[TX] = "fsl,qman-frame-queues-tx"
 };
 
-#ifdef CONFIG_DEBUG_FS
-static int __cold dpa_debugfs_show(struct seq_file *file, void *offset)
-{
-	int				 i;
-	struct dpa_priv_s		*priv;
-	struct dpa_percpu_priv_s	*percpu_priv, total;
-	struct dpa_bp *dpa_bp;
-	unsigned int dpa_bp_count = 0;
-	unsigned int count_total = 0;
-	struct qm_mcr_querycgr query_cgr;
-
-	BUG_ON(offset == NULL);
-
-	priv = netdev_priv((struct net_device *)file->private);
-
-	dpa_bp = priv->dpa_bp;
-
-	memset(&total, 0, sizeof(total));
-
-	/* "Standard" counters */
-	seq_printf(file, "\nDPA counters for %s:\n"
-		"CPU           irqs        rx        tx   recycle" \
-		"   confirm     tx sg    tx err    rx err   bp count\n",
-		priv->net_dev->name);
-
-	for_each_online_cpu(i) {
-		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
-
-		/* Only private interfaces have an associated counter for bp
-		 * buffers. Also the counter isn't initialized before the first
-		 * ifconfig up
-		 */
-		if (!priv->shared && percpu_priv->dpa_bp_count)
-			dpa_bp_count = *percpu_priv->dpa_bp_count;
-
-		total.in_interrupt += percpu_priv->in_interrupt;
-		total.stats.rx_packets += percpu_priv->stats.rx_packets;
-		total.stats.tx_packets += percpu_priv->stats.tx_packets;
-		total.tx_returned += percpu_priv->tx_returned;
-		total.tx_confirm += percpu_priv->tx_confirm;
-		total.tx_frag_skbuffs += percpu_priv->tx_frag_skbuffs;
-		total.stats.tx_errors += percpu_priv->stats.tx_errors;
-		total.stats.rx_errors += percpu_priv->stats.rx_errors;
-		count_total += dpa_bp_count;
-
-		seq_printf(file, "     %hu/%hu  %8llu  %8llu  %8llu  %8llu  "
-				"%8llu  %8llu  %8llu  %8llu     %8d\n",
-				get_hard_smp_processor_id(i), i,
-				percpu_priv->in_interrupt,
-				percpu_priv->stats.rx_packets,
-				percpu_priv->stats.tx_packets,
-				percpu_priv->tx_returned,
-				percpu_priv->tx_confirm,
-				percpu_priv->tx_frag_skbuffs,
-				percpu_priv->stats.tx_errors,
-				percpu_priv->stats.rx_errors,
-				dpa_bp_count);
-	}
-	seq_printf(file, "Total     %8llu  %8llu  %8llu  %8llu  %8llu  %8llu  "
-			"%8llu  %8llu     %8d\n",
-			total.in_interrupt,
-			total.stats.rx_packets,
-			total.stats.tx_packets,
-			total.tx_returned,
-			total.tx_confirm,
-			total.tx_frag_skbuffs,
-			total.stats.tx_errors,
-			total.stats.rx_errors,
-			count_total);
-
-	/* Congestion stats */
-	seq_printf(file, "\nDevice congestion stats:\n");
-	seq_printf(file, "Device has been congested for %d ms.\n",
-		jiffies_to_msecs(priv->cgr_data.congested_jiffies));
-
-	qman_query_cgr(&priv->cgr_data.cgr, &query_cgr);
-	seq_printf(file, "CGR id %d avg count: %llu\n",
-		priv->cgr_data.cgr.cgrid, qm_mcr_querycgr_a_get64(&query_cgr));
-	seq_printf(file, "Device entered congestion %u times. "
-		"Current congestion state is: %s.\n",
-		priv->cgr_data.cgr_congested_count,
-		query_cgr.cgr.cs ? "congested" : "not congested");
-	/* Reset congestion stats (like QMan CGR API does) */
-	priv->cgr_data.congested_jiffies = 0;
-	priv->cgr_data.cgr_congested_count = 0;
-
-	/* Rx Errors demultiplexing */
-	seq_printf(file, "\nDPA RX Errors:\nCPU        dma err  phys err" \
-				"  size err   hdr err  csum err\n");
-	for_each_online_cpu(i) {
-		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
-
-		total.rx_errors.dme += percpu_priv->rx_errors.dme;
-		total.rx_errors.fpe += percpu_priv->rx_errors.fpe;
-		total.rx_errors.fse += percpu_priv->rx_errors.fse;
-		total.rx_errors.phe += percpu_priv->rx_errors.phe;
-		total.rx_errors.cse += percpu_priv->rx_errors.cse;
-
-		seq_printf(file, "     %hu/%hu  %8llu  %8llu  %8llu  %8llu  "
-				"%8llu\n",
-				get_hard_smp_processor_id(i), i,
-				percpu_priv->rx_errors.dme,
-				percpu_priv->rx_errors.fpe,
-				percpu_priv->rx_errors.fse,
-				percpu_priv->rx_errors.phe,
-				percpu_priv->rx_errors.cse);
-	}
-	seq_printf(file, "Total     %8llu  %8llu  %8llu  %8llu  %8llu\n",
-			total.rx_errors.dme,
-			total.rx_errors.fpe,
-			total.rx_errors.fse,
-			total.rx_errors.phe,
-			total.rx_errors.cse);
-
-	/* ERN demultiplexing */
-	seq_printf(file, "\nDPA ERN counters:\n  CPU     cg_td      wred  " \
-			"err_cond   early_w    late_w     fq_td    fq_ret" \
-			"     orp_z\n");
-	for_each_online_cpu(i) {
-		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
-
-		total.ern_cnt.cg_tdrop += percpu_priv->ern_cnt.cg_tdrop;
-		total.ern_cnt.wred += percpu_priv->ern_cnt.wred;
-		total.ern_cnt.err_cond += percpu_priv->ern_cnt.err_cond;
-		total.ern_cnt.early_window += percpu_priv->ern_cnt.early_window;
-		total.ern_cnt.late_window += percpu_priv->ern_cnt.late_window;
-		total.ern_cnt.fq_tdrop += percpu_priv->ern_cnt.fq_tdrop;
-		total.ern_cnt.fq_retired += percpu_priv->ern_cnt.fq_retired;
-		total.ern_cnt.orp_zero += percpu_priv->ern_cnt.orp_zero;
-
-		seq_printf(file, "  %hu/%hu  %8llu  %8llu  %8llu  %8llu  "
-			"%8llu  %8llu  %8llu  %8llu\n",
-			get_hard_smp_processor_id(i), i,
-			percpu_priv->ern_cnt.cg_tdrop,
-			percpu_priv->ern_cnt.wred,
-			percpu_priv->ern_cnt.err_cond,
-			percpu_priv->ern_cnt.early_window,
-			percpu_priv->ern_cnt.late_window,
-			percpu_priv->ern_cnt.fq_tdrop,
-			percpu_priv->ern_cnt.fq_retired,
-			percpu_priv->ern_cnt.orp_zero);
-	}
-	seq_printf(file, "Total  %8llu  %8llu  %8llu  %8llu  %8llu  %8llu  "
-			"%8llu  %8llu\n",
-		total.ern_cnt.cg_tdrop,
-		total.ern_cnt.wred,
-		total.ern_cnt.err_cond,
-		total.ern_cnt.early_window,
-		total.ern_cnt.late_window,
-		total.ern_cnt.fq_tdrop,
-		total.ern_cnt.fq_retired,
-		total.ern_cnt.orp_zero);
-
-	return 0;
-}
-
-static int __cold dpa_debugfs_open(struct inode *inode, struct file *file)
-{
-	int			 _errno;
-	const struct net_device	*net_dev;
-
-	_errno = single_open(file, dpa_debugfs_show, inode->i_private);
-	if (unlikely(_errno < 0)) {
-		net_dev = (struct net_device *)inode->i_private;
-
-		if (netif_msg_drv((struct dpa_priv_s *)netdev_priv(net_dev)))
-			netdev_err(net_dev, "single_open() = %d\n",
-					_errno);
-	}
-	return _errno;
-}
-
-static const struct file_operations dpa_debugfs_fops = {
-	.open		= dpa_debugfs_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-#endif
 
 #ifdef CONFIG_DPAA_ETH_USE_NDO_SELECT_QUEUE
 static u16 dpa_select_queue(struct net_device *net_dev, struct sk_buff *skb)
@@ -4009,20 +3825,14 @@ static int dpa_netdev_init(struct device_node *dpa_node,
 		return err;
 	}
 
-#ifdef CONFIG_DEBUG_FS
-	priv->debugfs_file = debugfs_create_file(net_dev->name, S_IRUGO,
-						 dpa_debugfs_root, net_dev,
-						 &dpa_debugfs_fops);
-	if (unlikely(priv->debugfs_file == NULL)) {
-		netdev_err(net_dev, "debugfs_create_file(%s/%s/%s) = %d\n",
-				powerpc_debugfs_root->d_iname,
-				dpa_debugfs_root->d_iname,
-				net_dev->name, err);
-
+#ifdef CONFIG_FSL_DPAA_ETH_DEBUGFS
+	/* create debugfs entry for this net_device */
+	err = dpa_netdev_debugfs_create(net_dev);
+	if (err) {
 		unregister_netdev(net_dev);
-		return -ENOMEM;
+		return err;
 	}
-#endif
+#endif /* CONFIG_FSL_DPAA_ETH_DEBUGFS */
 
 	return 0;
 }
@@ -4496,9 +4306,10 @@ static int __cold dpa_remove(struct platform_device *of_dev)
 
 	dpa_bp_free(priv, priv->dpa_bp);
 
-#ifdef CONFIG_DEBUG_FS
-	debugfs_remove(priv->debugfs_file);
-#endif
+#ifdef CONFIG_FSL_DPAA_ETH_DEBUGFS
+	/* remove debugfs entry for this net_device */
+	dpa_netdev_debugfs_remove(net_dev);
+#endif /* CONFIG_FSL_DPAA_ETH_DEBUGFS */
 
 #ifdef CONFIG_FSL_DPA_1588
 	if (priv->tsu && priv->tsu->valid)
@@ -4530,34 +4341,13 @@ static int __init __cold dpa_load(void)
 	dpa_rx_extra_headroom = fm_get_rx_extra_headroom();
 	dpa_max_frm = fm_get_max_frm();
 
-#ifdef CONFIG_DEBUG_FS
-	dpa_debugfs_root = debugfs_create_dir(KBUILD_MODNAME,
-					      powerpc_debugfs_root);
-	if (unlikely(dpa_debugfs_root == NULL)) {
-		_errno = -ENOMEM;
-		pr_err(KBUILD_MODNAME ": %s:%hu:%s(): "
-			   "debugfs_create_dir(%s/"KBUILD_MODNAME") = %d\n",
-			   KBUILD_BASENAME".c", __LINE__, __func__,
-			   powerpc_debugfs_root->d_iname, _errno);
-		goto _return;
-	}
-#endif
-
 	_errno = platform_driver_register(&dpa_driver);
 	if (unlikely(_errno < 0)) {
 		pr_err(KBUILD_MODNAME
 			": %s:%hu:%s(): platform_driver_register() = %d\n",
 			KBUILD_BASENAME".c", __LINE__, __func__, _errno);
-		goto _return_debugfs_remove;
 	}
 
-	goto _return;
-
-_return_debugfs_remove:
-#ifdef CONFIG_DEBUG_FS
-	debugfs_remove(dpa_debugfs_root);
-#endif
-_return:
 	pr_debug(KBUILD_MODNAME ": %s:%s() ->\n",
 		KBUILD_BASENAME".c", __func__);
 
@@ -4572,10 +4362,6 @@ static void __exit __cold dpa_unload(void)
 
 	platform_driver_unregister(&dpa_driver);
 
-#ifdef CONFIG_DEBUG_FS
-	debugfs_remove(dpa_debugfs_root);
-#endif
-
 	pr_debug(KBUILD_MODNAME ": %s:%s() ->\n",
 		KBUILD_BASENAME".c", __func__);
 }
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 5500509..21e699c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -42,9 +42,6 @@
 #include <linux/if_vlan.h>	/* vlan_eth_hdr */
 #include <linux/ip.h>		/* ip_hdr */
 #include <linux/ipv6.h>		/* ipv6_hdr */
-#ifdef CONFIG_DEBUG_FS
-#include <linux/dcache.h>	/* struct dentry */
-#endif
 
 #include <linux/fsl_qman.h>	/* struct qman_fq */
 
@@ -55,7 +52,9 @@
 #include "fm_port_ext.h" /* FM_PORT_FRM_ERR_* */
 
 #include "mac.h"		/* struct mac_device */
-
+#ifdef CONFIG_FSL_DPAA_ETH_DEBUGFS
+#include "dpaa_debugfs.h"
+#endif /* CONFIG_FSL_DPAA_ETH_DEBUGFS */
 #include "dpaa_eth_trace.h"
 
 #ifdef CONFIG_DPAA_ETH_SG_SUPPORT
@@ -363,9 +362,9 @@ struct dpa_priv_s {
 	struct mac_device	*mac_dev;
 
 	struct dpa_percpu_priv_s	*percpu_priv;
-#ifdef CONFIG_DEBUG_FS
+#ifdef CONFIG_FSL_DPAA_ETH_DEBUGFS
 	struct dentry		*debugfs_file;
-#endif
+#endif /* CONFIG_FSL_DPAA_ETH_DEBUGFS */
 
 	uint32_t		 msg_enable;	/* net_device message level */
 #ifdef CONFIG_FSL_DPA_1588
-- 
2.0.2

