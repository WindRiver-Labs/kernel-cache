From ccefeb19472d5f84e4bffe2f35146e90edd7de57 Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@Freescale.com>
Date: Wed, 8 Jan 2014 04:21:34 -0600
Subject: [PATCH 039/466] fsl_qbman: Fix the checkpatch warning type
 PREFER_PR_LEVEL

WARNING:PREFER_PR_LEVEL: Prefer pr_warn(... to pr_warning(...

Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Change-Id: Ie1f3ba88a41b0e01284e7788a6bd512ca4f3c2e6
Reviewed-on: http://git.am.freescale.net:8181/7777
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Haiying Wang <Haiying.Wang@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Emilian Medve <Emilian.Medve@freescale.com>
[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/bman_config.c |   14 +++++++-------
 drivers/staging/fsl_qbman/qman_config.c |   22 +++++++++++-----------
 drivers/staging/fsl_qbman/qman_driver.c |   10 +++++-----
 drivers/staging/fsl_qbman/qman_high.c   |    4 ++--
 4 files changed, 25 insertions(+), 25 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index 9330840..9bba4f4 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -401,7 +401,7 @@ static int __init fsl_bman_init(struct device_node *node)
 		bman_ip_rev = BMAN_REV21;
 		bman_pool_max = 64;
 	} else {
-		pr_warning("unknown Bman version, default to rev1.0\n");
+		pr_warn("unknown Bman version, default to rev1.0\n");
 	}
 
 	/* Unfortunately we have to reserve those memory used for Bman
@@ -523,17 +523,17 @@ static void log_edata_bits(u32 bit_count)
 {
 	u32 i, j, mask = 0xffffffff;
 
-	pr_warning("Bman ErrInt, EDATA:\n");
+	pr_warn("Bman ErrInt, EDATA:\n");
 	i = bit_count/32;
 	if (bit_count%32) {
 		i++;
 		mask = ~(mask << bit_count%32);
 	}
 	j = 16-i;
-	pr_warning("  0x%08x\n", bm_in(EDATA(j)) & mask);
+	pr_warn("  0x%08x\n", bm_in(EDATA(j)) & mask);
 	j++;
 	for (; j < 16; j++)
-		pr_warning("  0x%08x\n", bm_in(EDATA(j)));
+		pr_warn("  0x%08x\n", bm_in(EDATA(j)));
 }
 
 static void log_additional_error_info(u32 isr_val, u32 ecsr_val)
@@ -544,13 +544,13 @@ static void log_additional_error_info(u32 isr_val, u32 ecsr_val)
 	ecir_val.ecir_raw = bm_in(ECIR);
 	/* Is portal info valid */
 	if (ecsr_val & PORTAL_ECSR_ERR) {
-		pr_warning("Bman ErrInt: SWP id %d, numb %d, pid %d\n",
+		pr_warn("Bman ErrInt: SWP id %d, numb %d, pid %d\n",
 			ecir_val.info.portal_num, ecir_val.info.numb,
 			ecir_val.info.pid);
 	}
 	if (ecsr_val & (BM_EIRQ_SBEI|BM_EIRQ_MBEI)) {
 		eadr_val.eadr_raw = bm_in(EADR);
-		pr_warning("Bman ErrInt: EADR Memory: %s, 0x%x\n",
+		pr_warn("Bman ErrInt: EADR Memory: %s, 0x%x\n",
 			error_mdata[eadr_val.info.memid].txt,
 			error_mdata[eadr_val.info.memid].addr_mask
 				& eadr_val.info.eadr);
@@ -572,7 +572,7 @@ static irqreturn_t bman_isr(int irq, void *ptr)
 		return IRQ_NONE;
 	for (i = 0; i < BMAN_HWE_COUNT; i++) {
 		if (bman_hwerr_txts[i].mask & isr_mask) {
-			pr_warning("Bman ErrInt: %s\n", bman_hwerr_txts[i].txt);
+			pr_warn("Bman ErrInt: %s\n", bman_hwerr_txts[i].txt);
 			if (bman_hwerr_txts[i].mask & ecsr_val) {
 				log_additional_error_info(isr_mask, ecsr_val);
 				/* Re-arm error capture registers */
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 0574e75..0f0d0b2 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -675,7 +675,7 @@ static int __init fsl_qman_init(struct device_node *node)
 		else if ((major == 3) && (minor == 1))
 			qman_ip_rev = QMAN_REV31;
 		else {
-			pr_warning("unknown Qman version, default to rev1.1\n");
+			pr_warn("unknown Qman version, default to rev1.1\n");
 			qman_ip_rev = QMAN_REV11;
 		}
 	}
@@ -738,17 +738,17 @@ static void log_edata_bits(u32 bit_count)
 {
 	u32 i, j, mask = 0xffffffff;
 
-	pr_warning("Qman ErrInt, EDATA:\n");
+	pr_warn("Qman ErrInt, EDATA:\n");
 	i = bit_count/32;
 	if (bit_count%32) {
 		i++;
 		mask = ~(mask << bit_count%32);
 	}
 	j = 16-i;
-	pr_warning("  0x%08x\n", qm_in(EDATA(j)) & mask);
+	pr_warn("  0x%08x\n", qm_in(EDATA(j)) & mask);
 	j++;
 	for (; j < 16; j++)
-		pr_warning("  0x%08x\n", qm_in(EDATA(j)));
+		pr_warn("  0x%08x\n", qm_in(EDATA(j)));
 }
 
 static void log_additional_error_info(u32 isr_val, u32 ecsr_val)
@@ -762,17 +762,17 @@ static void log_additional_error_info(u32 isr_val, u32 ecsr_val)
 	union qman_ecir2 ecir2_val;
 	ecir2_val.ecir2_raw = qm_in(ECIR2);
 		if (ecsr_val & PORTAL_ECSR_ERR) {
-			pr_warning("Qman ErrInt: %s id %d\n",
+			pr_warn("Qman ErrInt: %s id %d\n",
 				(ecir2_val.info.portal_type) ?
 				"DCP" : "SWP", ecir2_val.info.portal_num);
 		}
 		if (ecsr_val & (FQID_ECSR_ERR | QM_EIRQ_IECE)) {
-			pr_warning("Qman ErrInt: ecir.fqid 0x%x\n",
+			pr_warn("Qman ErrInt: ecir.fqid 0x%x\n",
 				ecir_val.info.fqid);
 		}
 		if (ecsr_val & (QM_EIRQ_SBEI|QM_EIRQ_MBEI)) {
 			eadr_val.eadr_raw = qm_in(EADR);
-			pr_warning("Qman ErrInt: EADR Memory: %s, 0x%x\n",
+			pr_warn("Qman ErrInt: EADR Memory: %s, 0x%x\n",
 				error_mdata[eadr_val.info_rev3.memid].txt,
 				error_mdata[eadr_val.info_rev3.memid].addr_mask
 					& eadr_val.info_rev3.eadr);
@@ -781,17 +781,17 @@ static void log_additional_error_info(u32 isr_val, u32 ecsr_val)
 		}
 	} else {
 		if (ecsr_val & PORTAL_ECSR_ERR) {
-			pr_warning("Qman ErrInt: %s id %d\n",
+			pr_warn("Qman ErrInt: %s id %d\n",
 				(ecir_val.info.portal_type) ?
 				"DCP" : "SWP", ecir_val.info.portal_num);
 		}
 		if (ecsr_val & FQID_ECSR_ERR) {
-			pr_warning("Qman ErrInt: ecir.fqid 0x%x\n",
+			pr_warn("Qman ErrInt: ecir.fqid 0x%x\n",
 				ecir_val.info.fqid);
 		}
 		if (ecsr_val & (QM_EIRQ_SBEI|QM_EIRQ_MBEI)) {
 			eadr_val.eadr_raw = qm_in(EADR);
-			pr_warning("Qman ErrInt: EADR Memory: %s, 0x%x\n",
+			pr_warn("Qman ErrInt: EADR Memory: %s, 0x%x\n",
 				error_mdata[eadr_val.info.memid].txt,
 				error_mdata[eadr_val.info.memid].addr_mask
 					& eadr_val.info.eadr);
@@ -814,7 +814,7 @@ static irqreturn_t qman_isr(int irq, void *ptr)
 		return IRQ_NONE;
 	for (i = 0; i < QMAN_HWE_COUNT; i++) {
 		if (qman_hwerr_txts[i].mask & isr_mask) {
-			pr_warning("Qman ErrInt: %s\n", qman_hwerr_txts[i].txt);
+			pr_warn("Qman ErrInt: %s\n", qman_hwerr_txts[i].txt);
 			if (qman_hwerr_txts[i].mask & ecsr_val) {
 				log_additional_error_info(isr_mask, ecsr_val);
 				/* Re-arm error capture registers */
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 7604e8a..cc86726 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -345,12 +345,12 @@ void qman_get_ip_revision(struct device_node *dn)
 			if (ip_rev) {
 				qman_ip_rev = ip_rev;
 			} else {
-				pr_warning("unknown Qman version,"
+				pr_warn("unknown Qman version,"
 					" default to rev1.1\n");
 				qman_ip_rev = QMAN_REV11;
 			}
 		} else if (ip_rev && (qman_ip_rev != ip_rev))
-			pr_warning("Revision=0x%04x, but portal '%s' has"
+			pr_warn("Revision=0x%04x, but portal '%s' has"
 							" 0x%04x\n",
 			qman_ip_rev, dn->full_name, ip_rev);
 		if (qman_ip_rev == ip_rev)
@@ -541,7 +541,7 @@ _no_iommu:
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	if (qman_set_sdest(pcfg->public_cfg.channel, cpu))
 #endif
-		pr_warning("Failed to set QMan portal's stash request queue\n");
+		pr_warn("Failed to set QMan portal's stash request queue\n");
 
 	return;
 
@@ -661,7 +661,7 @@ static void qman_portal_update_sdest(const struct qm_portal_config *pcfg,
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	if (qman_set_sdest(pcfg->public_cfg.channel, cpu))
 #endif
-		pr_warning("Failed to update portal's stash request queue\n");
+		pr_warn("Failed to update portal's stash request queue\n");
 }
 
 static void qman_offline_cpu(unsigned int cpu)
@@ -741,7 +741,7 @@ __init int qman_init(void)
 
 		clk = of_get_property(dn, "clock-frequency", NULL);
 		if (!clk)
-			pr_warning("Can't find Qman clock frequency\n");
+			pr_warn("Can't find Qman clock frequency\n");
 		else
 			qman_clk = *clk;
 	}
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 146419d..756d78e 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -2634,7 +2634,7 @@ int qman_create_cgr_to_dcp(struct qman_cgr *cgr, u32 flags, u16 dcp_portal,
 	int ret;
 
 	if ((qman_ip_rev & 0xFF00) < QMAN_REV30) {
-		pr_warning("This QMan version doesn't support to send CSCN to"
+		pr_warn("This QMan version doesn't support to send CSCN to"
 						" DCP portal\n");
 		return -EINVAL;
 	}
@@ -2719,7 +2719,7 @@ EXPORT_SYMBOL(qman_delete_cgr);
 int qm_get_clock(u64 *clock_hz)
 {
 	if (!qman_clk) {
-		pr_warning("Qman clock speed is unknown\n");
+		pr_warn("Qman clock speed is unknown\n");
 		return  -EINVAL;
 	}
 	*clock_hz = (u64)qman_clk;
-- 
1.7.10.4

