From 6449228371792de99ca2e13349dcf5198517715e Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 5 Feb 2015 17:46:07 +0800
Subject: [PATCH 2/6] fsl_qbman: reserve memory when b(q)man has been
 initalized

Reserve memory when b(q)man has been initalized.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl_qbman/bman_config.c |   11 +++++------
 drivers/staging/fsl_qbman/qman_config.c |   20 ++++++++++----------
 2 files changed, 15 insertions(+), 16 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index c9305a7..a3c7b7a 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -374,7 +374,11 @@ static int __init fsl_bman_init(struct device_node *node)
 		ret = parse_mem_property(node, "fsl,bman-fbpr",
 					&fbpr_a, &fbpr_sz, 0);
 		BUG_ON(ret);
-	}
+	} else
+	/* Unfortunately we have to reserve those memory used for Bman
+	 * since currently we can't clean these usage from boot kernel.
+	 */
+		bm_reserve_memory(bm);
 	/* Global configuration */
 	bm_node = node;
 	bm_get_version(bm, &id, &major, &minor);
@@ -392,11 +396,6 @@ static int __init fsl_bman_init(struct device_node *node)
 		pr_warn("unknown Bman version, default to rev1.0\n");
 	}
 
-	/* Unfortunately we have to reserve those memory used for Bman
-	 * since currently we can't clean these usage from boot kernel.
-	 */
-	bm_reserve_memory(bm);
-
 	if (standby) {
 		pr_info("  -> in standby mode\n");
 		return 0;
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index a8a857b..a6d3195 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -555,12 +555,20 @@ static int __init fsl_qman_init(struct device_node *node)
 			ret = parse_mem_property(node, "fsl,qman-fqd",
 						&fqd_a, &fqd_sz, 1);
 			BUG_ON(ret);
-		}
+		} else /* FQD memory */
+		/* Unfortunately we have to reserve those memory used for Qman
+		 * since currently we can't clean these usage from boot kernel.
+		 */
+			qm_reserve_memory(qm, qm_memory_fqd);
 		if (!qm_is_initalized(qm, qm_memory_pfdr)) {
 			ret = parse_mem_property(node, "fsl,qman-pfdr",
 						&pfdr_a, &pfdr_sz, 0);
 			BUG_ON(ret);
-		}
+		} else /* PFDR memory */
+		/* Unfortunately we have to reserve those memory used for Qman
+		 * since currently we can't clean these usage from boot kernel.
+		 */
+			qm_reserve_memory(qm, qm_memory_pfdr);
 	}
 	/* Global configuration */
 	qm_node = node;
@@ -588,14 +596,6 @@ static int __init fsl_qman_init(struct device_node *node)
 		qman_ip_cfg = cfg;
 	}
 
-	/* Unfortunately we have to reserve those memory used for Qman
-	 * since currently we can't clean these usage from boot kernel.
-	 */
-	/* FQD memory */
-	qm_reserve_memory(qm, qm_memory_fqd);
-	/* PFDR memory */
-	qm_reserve_memory(qm, qm_memory_pfdr);
-
 	if (standby) {
 		pr_info("  -> in standby mode\n");
 		return 0;
-- 
1.7.5.4

