From 9905640a5f9155aab7839ad7a3ab389c6c40562a Mon Sep 17 00:00:00 2001
From: Wang Dongsheng <dongsheng.wang@freescale.com>
Date: Thu, 20 Mar 2014 11:19:37 +0800
Subject: [PATCH 400/466] fsl/pci: The new pci suspend/resume implementation

commit 48b16180d0d91324e5d2423c6d53d97bbe3dcc14 upstream

If we do nothing in suspend/resume, some platform PCIe ip-block
can't guarantee the link back to L0 state from sleep, then, when
we read the EP device will hang. Only we send pme turnoff message
in pci controller suspend, and send pme exit message in resume, the
link state will be normal.

When we send pme turnoff message in pci controller suspend, the
links will into l2/l3 ready, then, host cannot communicate with
ep device, but pci-driver will call back EP device to save them
state. So we need to change platform_driver->suspend/resume to
syscore->suspend/resume.

So the new suspend/resume implementation, send pme turnoff message
in suspend, and send pme exit message in resume. And add a PME handler,
to response PME & message interrupt.

Change platform_driver->suspend/resume to syscore->suspend/resume.
pci-driver will call back EP device, to save EP state in
pci_pm_suspend_noirq, so we need to keep the link, until
pci_pm_suspend_noirq finish.

Signed-off-by: Wang Dongsheng <dongsheng.wang@freescale.com>
Signed-off-by: Scott Wood <scottwood@freescale.com>
[Just a minor modification to port 3.10 kernel]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/powerpc/platforms/85xx/corenet_generic.c |    1 +
 arch/powerpc/platforms/85xx/ge_imp3a.c        |    1 +
 arch/powerpc/platforms/85xx/mpc8536_ds.c      |    1 +
 arch/powerpc/platforms/85xx/mpc85xx_cds.c     |    1 +
 arch/powerpc/platforms/85xx/mpc85xx_ds.c      |    3 +
 arch/powerpc/platforms/85xx/mpc85xx_mds.c     |    3 +
 arch/powerpc/platforms/85xx/mpc85xx_rdb.c     |   10 ++
 arch/powerpc/platforms/85xx/p1010rdb.c        |    1 +
 arch/powerpc/platforms/85xx/p1022_ds.c        |    1 +
 arch/powerpc/platforms/85xx/p1022_rdk.c       |    1 +
 arch/powerpc/platforms/85xx/p1023_rds.c       |    2 +
 arch/powerpc/platforms/85xx/qemu_e500.c       |    1 +
 arch/powerpc/platforms/85xx/sbc8548.c         |    1 +
 arch/powerpc/sysdev/fsl_pci.c                 |  190 ++++++++++++++++---------
 arch/powerpc/sysdev/fsl_pci.h                 |   14 ++
 15 files changed, 162 insertions(+), 69 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/corenet_generic.c b/arch/powerpc/platforms/85xx/corenet_generic.c
index dba1c0d..036ef56 100644
--- a/arch/powerpc/platforms/85xx/corenet_generic.c
+++ b/arch/powerpc/platforms/85xx/corenet_generic.c
@@ -269,6 +269,7 @@ define_machine(corenet_generic) {
 	.init_IRQ		= corenet_gen_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_coreint_irq,
 	.restart		= fsl_rstcr_restart,
diff --git a/arch/powerpc/platforms/85xx/ge_imp3a.c b/arch/powerpc/platforms/85xx/ge_imp3a.c
index e6285ae..0b3c041 100644
--- a/arch/powerpc/platforms/85xx/ge_imp3a.c
+++ b/arch/powerpc/platforms/85xx/ge_imp3a.c
@@ -215,6 +215,7 @@ define_machine(ge_imp3a) {
 	.show_cpuinfo		= ge_imp3a_show_cpuinfo,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
diff --git a/arch/powerpc/platforms/85xx/mpc8536_ds.c b/arch/powerpc/platforms/85xx/mpc8536_ds.c
index 15ce4b5..5c88de0 100644
--- a/arch/powerpc/platforms/85xx/mpc8536_ds.c
+++ b/arch/powerpc/platforms/85xx/mpc8536_ds.c
@@ -76,6 +76,7 @@ define_machine(mpc8536_ds) {
 	.init_IRQ		= mpc8536_ds_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_cds.c b/arch/powerpc/platforms/85xx/mpc85xx_cds.c
index 7a31a0e..633a514 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_cds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_cds.c
@@ -385,6 +385,7 @@ define_machine(mpc85xx_cds) {
 #ifdef CONFIG_PCI
 	.restart	= mpc85xx_cds_restart,
 	.pcibios_fixup_bus	= mpc85xx_cds_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #else
 	.restart	= fsl_rstcr_restart,
 #endif
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_ds.c b/arch/powerpc/platforms/85xx/mpc85xx_ds.c
index 9ebb91e..e5e4983 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_ds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_ds.c
@@ -209,6 +209,7 @@ define_machine(mpc8544_ds) {
 	.init_IRQ		= mpc85xx_ds_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -223,6 +224,7 @@ define_machine(mpc8572_ds) {
 	.init_IRQ		= mpc85xx_ds_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -237,6 +239,7 @@ define_machine(p2020_ds) {
 	.init_IRQ		= mpc85xx_ds_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_mds.c b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
index 3c190b4..c111fba 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_mds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
@@ -392,6 +392,7 @@ define_machine(mpc8568_mds) {
 	.progress	= udbg_progress,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 };
 
@@ -413,6 +414,7 @@ define_machine(mpc8569_mds) {
 	.progress	= udbg_progress,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 };
 
@@ -435,6 +437,7 @@ define_machine(p1021_mds) {
 	.progress	= udbg_progress,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 };
 
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_rdb.c b/arch/powerpc/platforms/85xx/mpc85xx_rdb.c
index 1cd6421..b071a2c 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_rdb.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_rdb.c
@@ -272,6 +272,7 @@ define_machine(p2020_rdb) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -286,6 +287,7 @@ define_machine(p1020_rdb) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -300,6 +302,7 @@ define_machine(p1021_rdb_pc) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -314,6 +317,7 @@ define_machine(p2020_rdb_pc) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -328,6 +332,7 @@ define_machine(p1025_rdb) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -342,6 +347,7 @@ define_machine(p1020_mbg_pc) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -356,6 +362,7 @@ define_machine(p1020_utm_pc) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -370,6 +377,7 @@ define_machine(p1020_rdb_pc) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -384,6 +392,7 @@ define_machine(p1020_rdb_pd) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
@@ -398,6 +407,7 @@ define_machine(p1024_rdb) {
 	.init_IRQ		= mpc85xx_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
diff --git a/arch/powerpc/platforms/85xx/p1010rdb.c b/arch/powerpc/platforms/85xx/p1010rdb.c
index d6a3dd3..1a77ca7 100644
--- a/arch/powerpc/platforms/85xx/p1010rdb.c
+++ b/arch/powerpc/platforms/85xx/p1010rdb.c
@@ -78,6 +78,7 @@ define_machine(p1010_rdb) {
 	.init_IRQ		= p1010_rdb_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
diff --git a/arch/powerpc/platforms/85xx/p1022_ds.c b/arch/powerpc/platforms/85xx/p1022_ds.c
index d5159bb..9c5aecc 100644
--- a/arch/powerpc/platforms/85xx/p1022_ds.c
+++ b/arch/powerpc/platforms/85xx/p1022_ds.c
@@ -658,6 +658,7 @@ define_machine(p1022_ds) {
 	.init_IRQ		= p1022_ds_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
diff --git a/arch/powerpc/platforms/85xx/p1022_rdk.c b/arch/powerpc/platforms/85xx/p1022_rdk.c
index 8c92971..ba3cc2d 100644
--- a/arch/powerpc/platforms/85xx/p1022_rdk.c
+++ b/arch/powerpc/platforms/85xx/p1022_rdk.c
@@ -147,6 +147,7 @@ define_machine(p1022_rdk) {
 	.init_IRQ		= p1022_rdk_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_irq,
 	.restart		= fsl_rstcr_restart,
diff --git a/arch/powerpc/platforms/85xx/p1023_rds.c b/arch/powerpc/platforms/85xx/p1023_rds.c
index 47cd535..1c5ef8a 100644
--- a/arch/powerpc/platforms/85xx/p1023_rds.c
+++ b/arch/powerpc/platforms/85xx/p1023_rds.c
@@ -146,6 +146,7 @@ define_machine(p1023_rds) {
 	.progress		= udbg_progress,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.init_early		= p1023_rds_init_early,
 };
@@ -162,5 +163,6 @@ define_machine(p1023_rdb) {
 	.init_early		= p1023_rds_init_early,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 };
diff --git a/arch/powerpc/platforms/85xx/qemu_e500.c b/arch/powerpc/platforms/85xx/qemu_e500.c
index 5cefc5a..cd96177 100644
--- a/arch/powerpc/platforms/85xx/qemu_e500.c
+++ b/arch/powerpc/platforms/85xx/qemu_e500.c
@@ -66,6 +66,7 @@ define_machine(qemu_e500) {
 	.init_IRQ		= qemu_e500_pic_init,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.get_irq		= mpic_get_coreint_irq,
 	.restart		= fsl_rstcr_restart,
diff --git a/arch/powerpc/platforms/85xx/sbc8548.c b/arch/powerpc/platforms/85xx/sbc8548.c
index f621218..857c532 100644
--- a/arch/powerpc/platforms/85xx/sbc8548.c
+++ b/arch/powerpc/platforms/85xx/sbc8548.c
@@ -135,6 +135,7 @@ define_machine(sbc8548) {
 	.restart	= fsl_rstcr_restart,
 #ifdef CONFIG_PCI
 	.pcibios_fixup_bus	= fsl_pcibios_fixup_bus,
+	.pcibios_fixup_phb	= fsl_pcibios_fixup_phb,
 #endif
 	.calibrate_decr = generic_calibrate_decr,
 	.progress	= udbg_progress,
diff --git a/arch/powerpc/sysdev/fsl_pci.c b/arch/powerpc/sysdev/fsl_pci.c
index c1d4202..d47865c 100644
--- a/arch/powerpc/sysdev/fsl_pci.c
+++ b/arch/powerpc/sysdev/fsl_pci.c
@@ -1012,7 +1012,7 @@ void fsl_pci_assign_primary(void)
 	}
 }
 
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 static irqreturn_t fsl_pci_pme_handle(int irq, void *dev_id)
 {
 	struct pci_controller *hose = dev_id;
@@ -1020,98 +1020,117 @@ static irqreturn_t fsl_pci_pme_handle(int irq, void *dev_id)
 	u32 dr;
 
 	dr = in_be32(&pci->pex_pme_mes_dr);
-	if (dr)
-		out_be32(&pci->pex_pme_mes_dr, dr);
-	else
+	if (!dr)
 		return IRQ_NONE;
 
+	out_be32(&pci->pex_pme_mes_dr, dr);
+
 	return IRQ_HANDLED;
 }
 
-static int fsl_pci_pme_probe(struct platform_device *pdev)
+static int fsl_pci_pme_probe(struct pci_controller *hose)
 {
-	struct pci_controller *hose;
+	struct ccsr_pci __iomem *pci;
+	struct pci_dev *dev;
 	int pme_irq;
 	int res;
+	u16 pms;
 
-	pme_irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
-	if (!pme_irq) {
-		pr_warn("Failed to map PME interrupt.\n");
+	/* Get hose's pci_dev */
+	dev = list_first_entry(&hose->bus->devices, typeof(*dev), bus_list);
+
+	/* PME Disable */
+	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pms);
+	pms &= ~PCI_PM_CTRL_PME_ENABLE;
+	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pms);
 
+	pme_irq = irq_of_parse_and_map(hose->dn, 0);
+	if (!pme_irq) {
+		dev_err(&dev->dev, "Failed to map PME interrupt.\n");
 		return -ENXIO;
 	}
 
-	hose = pci_find_hose_for_OF_device(pdev->dev.of_node);
-
-	res = devm_request_irq(&pdev->dev, pme_irq,
+	res = devm_request_irq(hose->parent, pme_irq,
 			fsl_pci_pme_handle,
-			IRQF_DISABLED | IRQF_SHARED,
+			IRQF_SHARED,
 			"[PCI] PME", hose);
 	if (res < 0) {
-		pr_warn("Unable to requiest irq %d for PME\n", pme_irq);
+		dev_err(&dev->dev, "PCI: Requiest irq %d failed\n", pme_irq);
 		irq_dispose_mapping(pme_irq);
-
 		return -ENODEV;
 	}
 
+	pci = hose->private_data;
+
+	/* Enable PTOD, ENL23D & EXL23D */
+	clrbits32(&pci->pex_pme_mes_disr,
+		  PME_DISR_EN_PTOD | PME_DISR_EN_ENL23D | PME_DISR_EN_EXL23D);
+
+	out_be32(&pci->pex_pme_mes_ier, 0);
+	setbits32(&pci->pex_pme_mes_ier,
+		  PME_DISR_EN_PTOD | PME_DISR_EN_ENL23D | PME_DISR_EN_EXL23D);
+
+	/* PME Enable */
+	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pms);
+	pms |= PCI_PM_CTRL_PME_ENABLE;
+	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pms);
+
 	return 0;
 }
 
 static int pcie_slot_flag;
 
 /* Workaround: p1022ds need reset slot when the system wakeup from deep sleep */
-#ifdef CONFIG_P1022_DS
-extern void p1022ds_reset_pcie_slot(void);
-#endif
 static int reset_pcie_slot(void)
 {
 #ifdef CONFIG_P1022_DS
 	p1022ds_reset_pcie_slot();
 #endif
-
 	return 0;
 }
 
 static void send_pme_turnoff_message(struct pci_controller *hose)
 {
 	struct ccsr_pci __iomem *pci = hose->private_data;
-	u32 value;
+	u32 dr;
 	int i;
 
 	/* Send PME_Turn_Off Message Request */
 	setbits32(&pci->pex_pmcr, PEX_PMCR_PTOMR);
 
-	for (i = 0; i < 100; i++) {
-		value = in_be32(&pci->pex_pme_mes_dr);
-		if (value & (1 << PEX_PME_MES_DR_ENL23_SHIFT)) {
-			out_be32(&pci->pex_pme_mes_dr, value);
+	/* Wait trun off done */
+	/* RC will get this detect quickly */
+	for (i = 0; i < 50; i++) {
+		dr = in_be32(&pci->pex_pme_mes_dr);
+		if (dr & ENL23_DETECT_BIT) {
+			out_be32(&pci->pex_pme_mes_dr, dr);
 			break;
-		} else {
-			udelay(1000);
 		}
+
+		mdelay(1);
 	}
+
+	/*
+	 * "PCI Bus Power Management Interface Specification" define
+	 * Minimum System Software Guaranteed Delays
+	 *
+	 * D0, D1 or D2 --> D3, need delay 10ms.
+	 * But based on my test results, we need to delay 30ms when EP
+	 * plug in p1022 slot2. And we need to delay 100ms when EP plug
+	 * in p1022 slot1. So need to get maximum delay.
+	 */
+	mdelay(100);
 }
 
 static void fsl_pci_syscore_do_suspend(struct pci_controller *hose)
 {
 	suspend_state_t pm_state;
-	u32 svr;
-
-	svr = mfspr(SPRN_SVR);
 	pm_state = pm_suspend_state();
 
-	switch (pm_state) {
-	case PM_SUSPEND_STANDBY:
-		if (SVR_SOC_VER(svr) != SVR_T4240 && SVR_REV(svr) != 0x20)
-			break;
-		send_pme_turnoff_message(hose);
-		break;
-	case PM_SUSPEND_MEM:
+	send_pme_turnoff_message(hose);
+
+	if (pm_state == PM_SUSPEND_MEM)
 		pcie_slot_flag = 0;
-		break;
-	default:
-		break;
-	}
 }
 
 static int fsl_pci_syscore_suspend(void)
@@ -1128,40 +1147,70 @@ static int fsl_pci_syscore_suspend(void)
 static void fsl_pci_syscore_do_resume(struct pci_controller *hose)
 {
 	struct ccsr_pci __iomem *pci = hose->private_data;
-
-	u32 svr, pms;
+	struct pci_dev *dev;
+	u32 svr = mfspr(SPRN_SVR);
+	u32 dr;
 	suspend_state_t pm_state;
+	int i;
+	u16 pms;
 
-	svr = mfspr(SPRN_SVR);
-	pm_state = pm_suspend_state();
+	/* Send Exit L2 State Message */
+	setbits32(&pci->pex_pmcr, PEX_PMCR_EXL2S);
 
-	switch (pm_state) {
-	case PM_SUSPEND_STANDBY:
-		if (SVR_SOC_VER(svr) != SVR_T4240 && SVR_REV(svr) != 0x20)
+	/* Wait exit done */
+	/* RC will get this detect quickly */
+	for (i = 0; i < 50; i++) {
+		dr = in_be32(&pci->pex_pme_mes_dr);
+		if (dr & EXL23_DETECT_BIT) {
+			out_be32(&pci->pex_pme_mes_dr, dr);
 			break;
-		/* Send Exit L2 State Message */
-		setbits32(&pci->pex_pmcr, 0x2);
+		}
 
-		/* PME Enable */
-		indirect_read_config(hose->bus, 0, PCI_FSL_PM_CTRL, 4, &pms);
-		pms |= 0x100;
-		indirect_write_config(hose->bus, 0, PCI_FSL_PM_CTRL, 4, pms);
-		break;
-	case PM_SUSPEND_MEM:
-		if (SVR_SOC_VER(svr) != SVR_P1022 || pcie_slot_flag)
-			break;
+		mdelay(1);
+	}
+
+	/*
+	 * "PCI Bus Power Management Interface Specification" define
+	 * Minimum System Software Guaranteed Delays
+	 *
+	 * D0, D1 or D2 --> D3, need delay 10ms.
+	 * But based on my test results, we need to delay 30ms when EP
+	 * plug in p1022 slot2. And we need to delay 100ms when EP plug
+	 * in p1022 slot1. So need to get maximum delay.
+	 */
+	mdelay(100);
+
+	pm_state = pm_suspend_state();
+	if (pm_state != PM_SUSPEND_MEM)
+		goto setup_atmu;
 
-		/* only reset slot, we can rework the EP device */
+	/* After resume from deep-sleep, we need to restore below registers */
+	/* Enable PTOD, ENL23D & EXL23D */
+	clrbits32(&pci->pex_pme_mes_disr,
+		  PME_DISR_EN_PTOD | PME_DISR_EN_ENL23D | PME_DISR_EN_EXL23D);
+
+	out_be32(&pci->pex_pme_mes_ier, 0);
+	setbits32(&pci->pex_pme_mes_ier,
+		  PME_DISR_EN_PTOD | PME_DISR_EN_ENL23D | PME_DISR_EN_EXL23D);
+
+	/* Get hose's pci_dev */
+	dev = list_first_entry(&hose->bus->devices, typeof(*dev), bus_list);
+
+	/* PME Enable */
+	pci_read_config_word(dev, dev->pm_cap + PCI_PM_CTRL, &pms);
+	pms |= PCI_PM_CTRL_PME_ENABLE;
+	pci_write_config_word(dev, dev->pm_cap + PCI_PM_CTRL, pms);
+
+	/* Only reset slot, we can rework the EP device */
+	if (SVR_SOC_VER(svr) == SVR_P1022 && !pcie_slot_flag) {
 		reset_pcie_slot();
 		pcie_slot_flag = 1;
-
-		spin_event_timeout(!fsl_pcie_check_link(hose),
-				PCIE_RESET_SLOT_WAITTIME, 0);
-		break;
-	default:
-		break;
 	}
 
+	spin_event_timeout(!fsl_pcie_check_link(hose),
+			   PCIE_RESET_SLOT_WAITTIME, 0);
+
+setup_atmu:
 	setup_pci_atmu(hose);
 }
 
@@ -1179,6 +1228,13 @@ static struct syscore_ops pci_syscore_pm_ops = {
 };
 #endif
 
+void fsl_pcibios_fixup_phb(struct pci_controller *phb)
+{
+#ifdef CONFIG_PM_SLEEP
+	fsl_pci_pme_probe(phb);
+#endif
+}
+
 static int fsl_pci_probe(struct platform_device *pdev)
 {
 	int ret;
@@ -1205,10 +1261,6 @@ static int fsl_pci_probe(struct platform_device *pdev)
 	}
 #endif
 
-#ifdef CONFIG_PM
-	fsl_pci_pme_probe(pdev);
-#endif
-
 #ifdef CONFIG_EDAC_MPC85XX
 	mpc85xx_pci_err_probe(pdev);
 #endif
@@ -1226,7 +1278,7 @@ static struct platform_driver fsl_pci_driver = {
 
 static int __init fsl_pci_init(void)
 {
-#ifdef CONFIG_PM
+#ifdef CONFIG_PM_SLEEP
 	register_syscore_ops(&pci_syscore_pm_ops);
 #endif
 	return platform_driver_register(&fsl_pci_driver);
diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 6c0352cc..df02db2 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -33,6 +33,15 @@ struct platform_device;
 
 #define PCI_FSL_PM_CTRL		0x48
 #define PEX_PMCR_PTOMR		0x1
+#define PEX_PMCR_EXL2S		0x2
+
+#define PME_DISR_EN_PTOD	0x00008000
+#define PME_DISR_EN_ENL23D	0x00002000
+#define PME_DISR_EN_EXL23D	0x00001000
+
+#define ENL23_DETECT_BIT	0x00002000
+#define EXL23_DETECT_BIT	0x00001000
+
 #define PEX_PME_MES_DR_ENL23_SHIFT	13
 
 /* PCI/PCI Express outbound window reg */
@@ -149,6 +158,7 @@ struct ccsr_pci {
 
 extern int fsl_add_bridge(struct platform_device *pdev, int is_primary);
 extern void fsl_pcibios_fixup_bus(struct pci_bus *bus);
+void fsl_pcibios_fixup_phb(struct pci_controller *phb);
 extern int mpc83xx_add_bridge(struct device_node *dev);
 u64 fsl_pci_immrbar_base(struct pci_controller *hose);
 
@@ -160,6 +170,10 @@ void fsl_pci_assign_primary(void);
 static inline void fsl_pci_assign_primary(void) {}
 #endif
 
+#ifdef CONFIG_P1022_DS
+void p1022ds_reset_pcie_slot(void);
+#endif
+
 #ifdef CONFIG_EDAC_MPC85XX
 int mpc85xx_pci_err_probe(struct platform_device *op);
 #endif
-- 
1.7.10.4

