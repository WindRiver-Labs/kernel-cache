From 65b9308353b550a353d0d5a4043312550d92176c Mon Sep 17 00:00:00 2001
From: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Date: Thu, 23 May 2013 12:41:34 +0300
Subject: [PATCH 0308/1089] dpa_offload: Fix for dpa_stats counter selection

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

The selection of a counter that has offset zero caused returning of
default counter value(zero) for all selections matching this patters.
The reassembly NCSP and all the Classif CC Node counters supported on
FMAN v3 are now marked with UNSUPPORTED_CNT_SEL and only for them the
default counter value is returned.

Change-Id: I52cdca2cb65765af88b8e43517d66c88626a7143
Signed-off-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/2669
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Floarea Anca Jeanina-B12569 <anca.floarea@freescale.com>
Reviewed-by: Chereji Marian-Cornel-R27762 <marian.chereji@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c | 38 ++++++++++++++++++++++++++---
 1 file changed, 35 insertions(+), 3 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 51f5fc5..0d8f65f 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -46,6 +46,7 @@
 #include "fm_pcd_ext.h"
 
 #define STATS_VAL_SIZE 4
+#define UNSUPPORTED_CNT_SEL -1
 #define CLASSIF_STATS_SHIFT 4
 #define WORKQUEUE_MAX_ACTIVE 3
 
@@ -738,7 +739,7 @@ static void create_cnt_reass_stats(struct dpa_stats *dpa_stats)
 			struct t_FmPcdManipReassemIpStats,
 			nonConsistentSp);
 #else
-	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][6] = 0;
+	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][6] = UNSUPPORTED_CNT_SEL;
 #endif /* (DPAA_VERSION >= 11) */
 	/* DPA_STATS_CNT_REASS_IPv4_FRAMES */
 	dpa_stats->stats_sel[DPA_STATS_CNT_REASS][8] = offsetof(
@@ -879,6 +880,37 @@ static void create_classif_stats(struct dpa_stats *dpa_stats)
 	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][11] = offsetof(
 			struct t_FmPcdCcKeyStatistics,
 			frameLengthRangeCount[9]);
+#else
+	/* DPA_STATS_CNT_CLASSIF_RANGE1 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][2] =
+			UNSUPPORTED_CNT_SEL;
+	/* DPA_STATS_CNT_CLASSIF_RANGE2 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][3] =
+			UNSUPPORTED_CNT_SEL;
+	/* DPA_STATS_CNT_CLASSIF_RANGE3 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][4] =
+			UNSUPPORTED_CNT_SEL;
+	/* DPA_STATS_CNT_CLASSIF_RANGE4 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][5] =
+			UNSUPPORTED_CNT_SEL;
+	/* DPA_STATS_CNT_CLASSIF_RANGE5 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][6] =
+			UNSUPPORTED_CNT_SEL;
+	/* DPA_STATS_CNT_CLASSIF_RANGE6 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][7] =
+			UNSUPPORTED_CNT_SEL;
+	/* DPA_STATS_CNT_CLASSIF_RANGE7 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][8] =
+			UNSUPPORTED_CNT_SEL;
+	/* DPA_STATS_CNT_CLASSIF_RANGE8 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][9] =
+			UNSUPPORTED_CNT_SEL;
+	/* DPA_STATS_CNT_CLASSIF_RANGE9 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][10] =
+			UNSUPPORTED_CNT_SEL;
+	/* DPA_STATS_CNT_CLASSIF_RANGE10 */
+	dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE][11] =
+			UNSUPPORTED_CNT_SEL;
 #endif
 }
 
@@ -2068,12 +2100,12 @@ static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 
 	for (j = 0; j < stats_info->stats_num; j++) {
 
-		if (!stats_info->stats_off[j]) {
+		if (stats_info->stats_off[j] == UNSUPPORTED_CNT_SEL) {
 			/* Write the memory location */
 			memset(req_cb->request_area, 0, STATS_VAL_SIZE);
 
 			/* Update the memory pointer */
-			req_cb->request_area += STATS_VAL_SIZE ;
+			req_cb->request_area += STATS_VAL_SIZE;
 			continue;
 		}
 
-- 
2.0.2

