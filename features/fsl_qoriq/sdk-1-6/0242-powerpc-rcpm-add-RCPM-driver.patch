From da41a395996f5b51cf24b53d32c35ba1c0ee38c9 Mon Sep 17 00:00:00 2001
From: Chenhui Zhao <chenhui.zhao@freescale.com>
Date: Tue, 1 Jul 2014 14:07:43 +0800
Subject: [PATCH 242/466] powerpc/rcpm: add RCPM driver

There is a RCPM (Run Control/Power Management) in Freescale QorIQ
series processors. The device performs tasks associated with device
run control and power management.

The driver implements some features: mask/unmask irq, enter/exit low
power states, freeze time base, etc.

There are two versions of register map in RCPM, which is specified by
the compatible entry in the RCPM node of device tree.

Change-Id: I113211311c7241df95f067103d0ed81ada26d2ed
Signed-off-by: Chenhui Zhao <chenhui.zhao@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/10706
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Yang Li <LeoLi@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/powerpc/include/asm/fsl_guts.h |    2 +-
 arch/powerpc/include/asm/fsl_pm.h   |   37 ++++
 arch/powerpc/platforms/85xx/Kconfig |    2 +-
 arch/powerpc/platforms/85xx/smp.c   |   74 +++-----
 arch/powerpc/sysdev/fsl_rcpm.c      |  345 ++++++++++++++++++++++++++---------
 5 files changed, 319 insertions(+), 141 deletions(-)
 create mode 100644 arch/powerpc/include/asm/fsl_pm.h

diff --git a/arch/powerpc/include/asm/fsl_guts.h b/arch/powerpc/include/asm/fsl_guts.h
index 193d1f1..1b5055d 100644
--- a/arch/powerpc/include/asm/fsl_guts.h
+++ b/arch/powerpc/include/asm/fsl_guts.h
@@ -106,7 +106,7 @@ struct ccsr_guts {
 /* Alternate function signal multiplex control */
 #define MPC85xx_PMUXCR_QE(x) (0x8000 >> (x))
 
-struct ccsr_rcpm {
+struct ccsr_rcpm_v1 {
 	u8	res0000[4];
 	__be32	cdozsr;		/* 0x0004 - Core Doze Status Register */
 	u8	res0008[4];
diff --git a/arch/powerpc/include/asm/fsl_pm.h b/arch/powerpc/include/asm/fsl_pm.h
new file mode 100644
index 0000000..03f35a4
--- /dev/null
+++ b/arch/powerpc/include/asm/fsl_pm.h
@@ -0,0 +1,37 @@
+/*
+ * Support Power Management
+ *
+ * Copyright 2014 Freescale Semiconductor Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#ifndef __PPC_FSL_PM_H
+#define __PPC_FSL_PM_H
+#ifdef	__KERNEL__
+
+#define E500_PM_PH10	1
+#define E500_PM_PH15	2
+#define E500_PM_PH20	3
+#define E500_PM_PH30	4
+#define E500_PM_DOZE	E500_PM_PH10
+#define E500_PM_NAP	E500_PM_PH15
+
+#define PLAT_PM_SLEEP	20
+#define PLAT_PM_LPM20	30
+
+struct fsl_pm_ops {
+	void (*irq_mask)(int cpu);
+	void (*irq_unmask)(int cpu);
+	void (*cpu_enter_state)(int cpu, int state);
+	void (*cpu_exit_state)(int cpu, int state);
+	int (*plat_enter_state)(int state);
+	void (*freeze_time_base)(int freeze);
+	void (*set_ip_power)(int enable, u32 mask);
+};
+
+extern const struct fsl_pm_ops *qoriq_pm_ops;
+#endif	/* __KERNEL__ */
+#endif  /* __PPC_FSL_PM_H */
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 624c9bc..5c46747 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -8,7 +8,7 @@ menuconfig FSL_SOC_BOOKE
 	select FSL_PCI if PCI
 	select SERIAL_8250_EXTENDED if SERIAL_8250
 	select SERIAL_8250_SHARE_IRQ if SERIAL_8250
-	select FSL_CORENET_RCPM if SUSPEND && PPC_E500MC
+	select FSL_CORENET_RCPM if PPC_E500MC
 	default y
 
 if FSL_SOC_BOOKE
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index 58947169..b9f7fa0 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -27,6 +27,7 @@
 #include <asm/dbell.h>
 #include <asm/fsl_guts.h>
 #include <asm/cputhreads.h>
+#include <asm/fsl_pm.h>
 
 #include <sysdev/fsl_soc.h>
 #include <sysdev/mpic.h>
@@ -46,10 +47,12 @@ static u64 timebase;
 static int tb_req;
 static int tb_valid;
 static u32 cur_booting_core;
-static bool rcpmv2;
 
 extern void fsl_enable_threads(void);
 
+/* specify the cpu PM state when cpu dies, PH15/NAP is the default */
+int qoriq_cpu_die_state = E500_PM_PH15;
+
 #ifdef CONFIG_PPC_E500MC
 /* get a physical mask of online cores and booting core */
 static inline u32 get_phy_cpu_mask(void)
@@ -72,25 +75,10 @@ static inline u32 get_phy_cpu_mask(void)
 	return mask;
 }
 
-static void __cpuinit mpc85xx_timebase_freeze(int freeze)
+static void mpc85xx_timebase_freeze(int freeze)
 {
-	u32 *addr;
-	u32 mask = get_phy_cpu_mask();
-
-	if (rcpmv2)
-		addr = &((struct ccsr_rcpm_v2 *)guts_regs)->pctbenr;
-	else
-		addr = &((struct ccsr_rcpm *)guts_regs)->ctbenr;
-
-	if (freeze)
-		clrbits32(addr, mask);
-	else
-		setbits32(addr, mask);
-
-	/* read back to push the previous write */
-	in_be32(addr);
+	qoriq_pm_ops->freeze_time_base(freeze);
 }
-
 #else
 static void __cpuinit mpc85xx_timebase_freeze(int freeze)
 {
@@ -212,11 +200,16 @@ static void __cpuinit smp_85xx_mach_cpu_die(void)
 {
 	unsigned int cpu = smp_processor_id();
 
-	local_irq_disable();
+	hard_irq_disable();
 	idle_task_exit();
-	mb();
+
+	if (qoriq_pm_ops->irq_mask)
+		qoriq_pm_ops->irq_mask(cpu);
 
 	mtspr(SPRN_TCR, 0);
+	mtspr(SPRN_TSR, mfspr(SPRN_TSR));
+
+	generic_set_cpu_dead(cpu);
 
 	if (is_core_down(cpu))
 		__flush_disable_L1();
@@ -224,7 +217,8 @@ static void __cpuinit smp_85xx_mach_cpu_die(void)
 	if (cur_cpu_spec->l2cache_type == PPC_L2_CACHE_CORE)
 		disable_backside_L2_cache();
 
-	generic_set_cpu_dead(cpu);
+	if (is_core_down(cpu))
+		qoriq_pm_ops->cpu_enter_state(cpu, qoriq_cpu_die_state);
 
 	if (cpu_has_feature(CPU_FTR_SMT)) {
 		cpu = cpu_thread_in_core(cpu);
@@ -237,21 +231,6 @@ static void __cpuinit smp_85xx_mach_cpu_die(void)
 		;
 }
 
-void platform_cpu_die(unsigned int cpu)
-{
-	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
-	struct ccsr_rcpm __iomem *rcpm;
-
-	if (rcpmv2 && is_core_down(cpu)) {
-		/* enter PH20 status */
-		setbits32(&((struct ccsr_rcpm_v2 *)guts_regs)->pcph20setr,
-				1 << cpu_core_index_of_thread(hw_cpu));
-	} else if (!rcpmv2 && guts_regs) {
-		rcpm = guts_regs;
-		/* Core Nap Operation */
-		setbits32(&rcpm->cnapcr, 1 << hw_cpu);
-	}
-}
 #else
 /* for e500v1 and e500v2 */
 static void __cpuinit smp_85xx_mach_cpu_die(void)
@@ -334,10 +313,6 @@ static int __cpuinit smp_85xx_kick_cpu(int nr)
 	int hw_cpu = get_hard_smp_processor_id(nr);
 	int ioremappable;
 	int ret = 0;
-#ifdef CONFIG_PPC_E500MC
-	struct ccsr_rcpm __iomem *rcpm = guts_regs;
-	struct ccsr_rcpm_v2 __iomem *rcpm_v2 = guts_regs;
-#endif
 #ifdef CONFIG_PPC64
 	unsigned long *ptr = NULL;
 	static int secondary_cpus_released;
@@ -425,15 +400,6 @@ static int __cpuinit smp_85xx_kick_cpu(int nr)
 		out_be32(&spin_table->addr_l, 0);
 		flush_spin_table(spin_table);
 
-#ifdef CONFIG_PPC_E500MC
-		/* Due to an erratum, wake the core before reset. */
-		if (rcpmv2)
-			setbits32(&rcpm_v2->pcph20clrr,
-				1 << cpu_core_index_of_thread(hw_cpu));
-		else
-			clrbits32(&rcpm->cnapcr, 1 << hw_cpu);
-#endif
-
 		/*
 		 * We don't set the BPTR register here since it already points
 		 * to the boot page properly.
@@ -456,6 +422,11 @@ static int __cpuinit smp_85xx_kick_cpu(int nr)
 
 		/*  clear the acknowledge status */
 		__secondary_hold_acknowledge = -1;
+
+#ifdef CONFIG_PPC_E500MC
+		if (qoriq_pm_ops->irq_unmask)
+			qoriq_pm_ops->irq_unmask(nr);
+#endif
 	}
 #ifdef CONFIG_PPC32
 	flush_spin_table(spin_table);
@@ -681,9 +652,6 @@ void __init mpc85xx_smp_init(void)
 
 	np = of_find_matching_node(NULL, mpc85xx_smp_guts_ids);
 	if (np) {
-		if (of_device_is_compatible(np, "fsl,qoriq-rcpm-2.0"))
-			rcpmv2 = true;
-
 		guts_regs = of_iomap(np, 0);
 		of_node_put(np);
 		if (!guts_regs) {
@@ -696,6 +664,8 @@ void __init mpc85xx_smp_init(void)
 #ifdef CONFIG_HOTPLUG_CPU
 		ppc_md.cpu_die = smp_85xx_mach_cpu_die;
 #endif
+		if (!strcmp(cur_cpu_spec->cpu_name, "e6500"))
+			qoriq_cpu_die_state = E500_PM_PH20;
 	}
 
 	smp_ops = &smp_85xx_ops;
diff --git a/arch/powerpc/sysdev/fsl_rcpm.c b/arch/powerpc/sysdev/fsl_rcpm.c
index eec51ea..4f888f1 100644
--- a/arch/powerpc/sysdev/fsl_rcpm.c
+++ b/arch/powerpc/sysdev/fsl_rcpm.c
@@ -1,7 +1,9 @@
 /*
  * RCPM(Run Control/Power Management) support
  *
- * Copyright 2012 Freescale Semiconductor Inc.
+ * Copyright 2012-2014 Freescale Semiconductor Inc.
+ *
+ * Author: Chenhui Zhao <chenhui.zhao@freescale.com>
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -10,151 +12,320 @@
  */
 #include <linux/types.h>
 #include <linux/errno.h>
-#include <linux/fsl_devices.h>
-#include <linux/suspend.h>
-#include <linux/device.h>
-#include <linux/delay.h>
-#include <linux/of_platform.h>
+#include <linux/of_address.h>
 #include <linux/export.h>
 
 #include <asm/io.h>
-#include <asm/cacheflush.h>
 #include <asm/fsl_guts.h>
+#include <asm/cputhreads.h>
+#include <asm/fsl_pm.h>
+
+#define RCPM_V1		1
+#define RCPM_V2		2
+
+const struct fsl_pm_ops *qoriq_pm_ops;
+
+static struct ccsr_rcpm_v1 __iomem *rcpm_v1_regs;
+static struct ccsr_rcpm_v2 __iomem *rcpm_v2_regs;
+
+static void rcpm_v1_irq_mask(int cpu)
+{
+	int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	setbits32(&rcpm_v1_regs->cpmimr, mask);
+	setbits32(&rcpm_v1_regs->cpmcimr, mask);
+	setbits32(&rcpm_v1_regs->cpmmcmr, mask);
+	setbits32(&rcpm_v1_regs->cpmnmimr, mask);
+}
+
+static void rcpm_v1_irq_unmask(int cpu)
+{
+	int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	clrbits32(&rcpm_v1_regs->cpmimr, mask);
+	clrbits32(&rcpm_v1_regs->cpmcimr, mask);
+	clrbits32(&rcpm_v1_regs->cpmmcmr, mask);
+	clrbits32(&rcpm_v1_regs->cpmnmimr, mask);
+}
+
+static void rcpm_v1_set_ip_power(int enable, u32 mask)
+{
+	if (enable)
+		setbits32(&rcpm_v1_regs->ippdexpcr, mask);
+	else
+		clrbits32(&rcpm_v1_regs->ippdexpcr, mask);
+}
 
-struct ccsr_rcpm __iomem *rcpm1_regs;
-struct ccsr_rcpm_v2 __iomem *rcpm2_regs;
+static void rcpm_v1_cpu_enter_state(int cpu, int state)
+{
+	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
 
-static int rcpm_suspend_enter(suspend_state_t state)
+	switch (state) {
+	case E500_PM_PH10:
+		setbits32(&rcpm_v1_regs->cdozcr, mask);
+		break;
+	case E500_PM_PH15:
+		setbits32(&rcpm_v1_regs->cnapcr, mask);
+		break;
+	default:
+		pr_err("%s: Unknown cpu PM state (%d)\n", __func__, state);
+		break;
+	}
+}
+
+static void rcpm_v1_cpu_exit_state(int cpu, int state)
 {
+	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	switch (state) {
+	case E500_PM_PH10:
+		clrbits32(&rcpm_v1_regs->cdozcr, mask);
+		break;
+	case E500_PM_PH15:
+		clrbits32(&rcpm_v1_regs->cnapcr, mask);
+		break;
+	default:
+		pr_err("%s: Unknown cpu PM state (%d)\n", __func__, state);
+		break;
+	}
+}
+
+static int rcpm_v1_plat_enter_state(int state)
+{
+	u32 *pmcsr_reg = &rcpm_v1_regs->powmgtcsr;
 	int ret = 0;
 	int result;
 
 	switch (state) {
-	case PM_SUSPEND_STANDBY:
-
-		flush_dcache_L1();
-		flush_backside_L2_cache();
+	case PLAT_PM_SLEEP:
+		setbits32(pmcsr_reg, RCPM_POWMGTCSR_SLP);
 
-		setbits32(&rcpm1_regs->powmgtcsr, RCPM_POWMGTCSR_SLP);
 		/* At this point, the device is in sleep mode. */
 
-		/* Upon resume, wait for SLP bit to be clear. */
+		/* Upon resume, wait for RCPM_POWMGTCSR_SLP bit to be clear. */
 		result = spin_event_timeout(
-		  (in_be32(&rcpm1_regs->powmgtcsr) & RCPM_POWMGTCSR_SLP) == 0,
-		  10000, 10);
+		  !(in_be32(pmcsr_reg) & RCPM_POWMGTCSR_SLP), 10000, 10);
 		if (!result) {
-			pr_err("%s: timeout waiting for SLP bit "
-				"to be cleared\n", __func__);
+			pr_err("%s: timeout waiting for SLP bit to be cleared\n",
+			       __func__);
 			ret = -ETIMEDOUT;
 		}
 		break;
-
 	default:
+		pr_err("%s: Unknown platform PM state (%d)\n",
+		       __func__, state);
 		ret = -EINVAL;
-
 	}
+
 	return ret;
 }
 
-static int rcpm_v2_suspend_enter(suspend_state_t state)
+static void rcpm_common_freeze_time_base(u32 *tben_reg, int freeze)
 {
+	static u32 mask;
+
+	if (freeze) {
+		mask = in_be32(tben_reg);
+		clrbits32(tben_reg, mask);
+	} else {
+		setbits32(tben_reg, mask);
+	}
+
+	/* read back to push the previous write */
+	in_be32(tben_reg);
+}
+
+static void rcpm_v1_freeze_time_base(int freeze)
+{
+	rcpm_common_freeze_time_base(&rcpm_v1_regs->ctbenr, freeze);
+}
+
+static void rcpm_v2_freeze_time_base(int freeze)
+{
+	rcpm_common_freeze_time_base(&rcpm_v2_regs->pctbenr, freeze);
+}
+
+static void rcpm_v2_irq_mask(int cpu)
+{
+	int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	setbits32(&rcpm_v2_regs->tpmimr0, mask);
+	setbits32(&rcpm_v2_regs->tpmcimr0, mask);
+	setbits32(&rcpm_v2_regs->tpmmcmr0, mask);
+	setbits32(&rcpm_v2_regs->tpmnmimr0, mask);
+}
+
+static void rcpm_v2_irq_unmask(int cpu)
+{
+	int hw_cpu = get_hard_smp_processor_id(cpu);
+	unsigned int mask = 1 << hw_cpu;
+
+	clrbits32(&rcpm_v2_regs->tpmimr0, mask);
+	clrbits32(&rcpm_v2_regs->tpmcimr0, mask);
+	clrbits32(&rcpm_v2_regs->tpmmcmr0, mask);
+	clrbits32(&rcpm_v2_regs->tpmnmimr0, mask);
+}
+
+static void rcpm_v2_set_ip_power(int enable, u32 mask)
+{
+	if (enable)
+		/* enable power of IP blocks in deep sleep mode */
+		setbits32(&rcpm_v2_regs->ippdexpcr[0], mask);
+	else
+		clrbits32(&rcpm_v2_regs->ippdexpcr[0], mask);
+}
+
+static void rcpm_v2_cpu_enter_state(int cpu, int state)
+{
+	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
+	u32 mask = 1 << cpu_core_index_of_thread(hw_cpu);
+
+	switch (state) {
+	case E500_PM_PH10:
+		/* one bit corresponds to one thread for PH10 of 6500 */
+		setbits32(&rcpm_v2_regs->tph10setr0, 1 << hw_cpu);
+		break;
+	case E500_PM_PH15:
+		setbits32(&rcpm_v2_regs->pcph15setr, mask);
+		break;
+	case E500_PM_PH20:
+		setbits32(&rcpm_v2_regs->pcph20setr, mask);
+		break;
+	case E500_PM_PH30:
+		setbits32(&rcpm_v2_regs->pcph30setr, mask);
+		break;
+	default:
+		pr_err("%s: Unknown cpu PM state (%d)\n", __func__, state);
+	}
+}
+
+static void rcpm_v2_cpu_exit_state(int cpu, int state)
+{
+	unsigned int hw_cpu = get_hard_smp_processor_id(cpu);
+	u32 mask = 1 << cpu_core_index_of_thread(hw_cpu);
+
+	switch (state) {
+	case E500_PM_PH10:
+		setbits32(&rcpm_v2_regs->tph10clrr0, 1 << hw_cpu);
+		break;
+	case E500_PM_PH15:
+		setbits32(&rcpm_v2_regs->pcph15clrr, mask);
+		break;
+	case E500_PM_PH20:
+		setbits32(&rcpm_v2_regs->pcph20clrr, mask);
+		break;
+	case E500_PM_PH30:
+		setbits32(&rcpm_v2_regs->pcph30clrr, mask);
+		break;
+	default:
+		pr_err("%s: Unknown cpu PM state (%d)\n", __func__, state);
+	}
+}
+
+static int rcpm_v2_plat_enter_state(int state)
+{
+	u32 *pmcsr_reg = &rcpm_v2_regs->powmgtcsr;
 	int ret = 0;
 	int result;
 
 	switch (state) {
-	case PM_SUSPEND_STANDBY:
-
+	case PLAT_PM_LPM20:
 		/* clear previous LPM20 status */
-		setbits32(&rcpm2_regs->powmgtcsr, RCPM_POWMGTCSR_P_LPM20_ST);
+		setbits32(pmcsr_reg, RCPM_POWMGTCSR_P_LPM20_ST);
 		/* enter LPM20 status */
-		setbits32(&rcpm2_regs->powmgtcsr, RCPM_POWMGTCSR_LPM20_RQ);
+		setbits32(pmcsr_reg, RCPM_POWMGTCSR_LPM20_RQ);
 
 		/* At this point, the device is in LPM20 status. */
 
 		/* resume ... */
 		result = spin_event_timeout(
-		      (in_be32(&rcpm2_regs->powmgtcsr) & RCPM_POWMGTCSR_LPM20_ST)
-		      == 0, 10000, 10);
+		  !(in_be32(pmcsr_reg) & RCPM_POWMGTCSR_LPM20_ST), 10000, 10);
 		if (!result) {
 			pr_err("%s: timeout waiting for LPM20 bit to be cleared\n",
-				__func__);
+			       __func__);
 			ret = -ETIMEDOUT;
 		}
-
 		break;
-
 	default:
+		pr_err("%s: Unknown platform PM state (%d)\n",
+		       __func__, state);
 		ret = -EINVAL;
-
 	}
 
 	return ret;
-
 }
 
-static int rcpm_suspend_valid(suspend_state_t state)
-{
-	if (state == PM_SUSPEND_STANDBY) {
-		set_pm_suspend_state(state);
-		return 1;
-	}
-	else
-		return 0;
-}
+static const struct fsl_pm_ops qoriq_rcpm_v1_ops = {
+	.irq_mask = rcpm_v1_irq_mask,
+	.irq_unmask = rcpm_v1_irq_unmask,
+	.cpu_enter_state = rcpm_v1_cpu_enter_state,
+	.cpu_exit_state = rcpm_v1_cpu_exit_state,
+	.plat_enter_state = rcpm_v1_plat_enter_state,
+	.set_ip_power = rcpm_v1_set_ip_power,
+	.freeze_time_base = rcpm_v1_freeze_time_base,
+};
 
-static void rcpm_suspend_end(void)
-{
-	set_pm_suspend_state(PM_SUSPEND_ON);
-}
+static const struct fsl_pm_ops qoriq_rcpm_v2_ops = {
+	.irq_mask = rcpm_v2_irq_mask,
+	.irq_unmask = rcpm_v2_irq_unmask,
+	.cpu_enter_state = rcpm_v2_cpu_enter_state,
+	.cpu_exit_state = rcpm_v2_cpu_exit_state,
+	.plat_enter_state = rcpm_v2_plat_enter_state,
+	.set_ip_power = rcpm_v2_set_ip_power,
+	.freeze_time_base = rcpm_v2_freeze_time_base,
+};
 
-static struct platform_suspend_ops rcpm_suspend_ops = {
-	.valid = rcpm_suspend_valid,
-	.end = rcpm_suspend_end,
+static const struct of_device_id rcpm_matches[] = {
+	{
+		.compatible = "fsl,qoriq-rcpm-1.0",
+		.data = (void *)RCPM_V1,
+	},
+	{
+		.compatible = "fsl,qoriq-rcpm-2.0",
+		.data = (void *)RCPM_V2,
+	},
+	{},
 };
 
-static int rcpm_probe(struct platform_device *pdev)
+int fsl_rcpm_init(void)
 {
-	struct device_node *np = pdev->dev.of_node;
-
-	if (of_device_is_compatible(np, "fsl,qoriq-rcpm-2.0")) {
-		rcpm2_regs = of_iomap(np, 0);
-		if (!rcpm2_regs)
-			return -ENOMEM;
-
-		rcpm_suspend_ops.enter = rcpm_v2_suspend_enter;
-	} else {
-		rcpm1_regs = of_iomap(np, 0);
-		if (!rcpm1_regs)
-			return -ENOMEM;
-
-		rcpm_suspend_ops.enter = rcpm_suspend_enter;
+	struct device_node *np;
+	const struct of_device_id *match;
+	void __iomem *base;
+
+	np = of_find_matching_node_and_match(NULL, rcpm_matches, &match);
+	if (!np) {
+		pr_err("%s: can't find the rcpm node.\n", __func__);
+		return -EINVAL;
 	}
 
-	suspend_set_ops(&rcpm_suspend_ops);
-	set_pm_suspend_state(PM_SUSPEND_ON);
+	base = of_iomap(np, 0);
+	of_node_put(np);
+	if (!base)
+		return -ENOMEM;
 
-	dev_info(&pdev->dev, "Freescale RCPM driver\n");
-	return 0;
-}
+	switch ((unsigned long)match->data) {
+	case RCPM_V1:
+		rcpm_v1_regs = base;
+		qoriq_pm_ops = &qoriq_rcpm_v1_ops;
+		break;
 
-static const struct of_device_id rcpm_ids[] = {
-	{ .compatible = "fsl,qoriq-rcpm-1.0", },
-	{ .compatible = "fsl,qoriq-rcpm-2.0", },
-	{ },
-};
+	case RCPM_V2:
+		rcpm_v2_regs = base;
+		qoriq_pm_ops = &qoriq_rcpm_v2_ops;
+		break;
 
-static struct platform_driver rcpm_driver = {
-	.driver = {
-		.name = "fsl-rcpm",
-		.owner = THIS_MODULE,
-		.of_match_table = rcpm_ids,
-	},
-	.probe = rcpm_probe,
-};
+	default:
+		break;
+	}
 
-static int __init rcpm_init(void)
-{
-	return platform_driver_register(&rcpm_driver);
+	return 0;
 }
 
-device_initcall(rcpm_init);
+/* need to call this before SMP init */
+early_initcall(fsl_rcpm_init);
-- 
1.7.10.4

