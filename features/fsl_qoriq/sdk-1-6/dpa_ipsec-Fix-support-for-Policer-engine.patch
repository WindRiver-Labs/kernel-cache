From d45cd8b375ba7c29f37ae71909437291d197127b Mon Sep 17 00:00:00 2001
From: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Date: Thu, 16 May 2013 16:35:55 +0300
Subject: [PATCH 0277/1089] dpa_ipsec: Fix support for Policer engine

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

The support for Policer engine was either lacking
or had multiple bugs. A Policer engine can be
configured in multiple cases: policy miss action,
post ipsec action and/or policy action.  A clean
fix-up could only be performed if the code of
non-compat mode is completely separated from the
code of compat mode.

This patch is related to CR ENGR00260484.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Change-Id: Iecb43d7efddad550ee25a982150e656ca5216c2d
Reviewed-on: http://git.am.freescale.net:8181/2557
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c     |   19 +
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c | 1211 +++++++++++++----------
 2 files changed, 716 insertions(+), 514 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 82cc2f2..28e3fdf 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -2506,6 +2506,20 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	       &sa_params->sa_in_params.post_ipsec_action,
 	       sizeof(struct dpa_cls_tbl_action));
 
+	if (sa->def_sa_action.type == DPA_CLS_TBL_ACTION_ENQ &&
+	    sa->def_sa_action.enq_params.policer_params) {
+		struct dpa_cls_tbl_policer_params	*policer_params;
+		policer_params = kzalloc(sizeof(*policer_params), GFP_KERNEL);
+		if (!policer_params) {
+			pr_err("Could not allocate memory for policer parameters\n");
+			return -ENOMEM;
+		}
+		memcpy(policer_params,
+		       sa->def_sa_action.enq_params.policer_params,
+		       sizeof(*policer_params));
+		sa->def_sa_action.enq_params.policer_params = policer_params;
+	}
+
 	sa->sec_desc->pdb_dec.seq_num =
 			sa_params->start_seq_num & SEQ_NUM_LOW_MASK;
 	sa->sec_desc->pdb_dec.options = PDBOPTS_ESP_TUNNEL |
@@ -3579,6 +3593,11 @@ static int remove_inbound_sa(struct dpa_ipsec_sa *sa)
 			return err;
 	}
 
+	/* Free policer pointer */
+	if (sa->def_sa_action.type == DPA_CLS_TBL_ACTION_ENQ &&
+	    sa->def_sa_action.enq_params.policer_params)
+		kfree(sa->def_sa_action.enq_params.policer_params);
+
 	/* Mark SA as free */
 	err = put_sa(sa);
 	if (err < 0) {
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index e066b34..3ad2325 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -34,7 +34,6 @@
  * DPA IPsec Wrapper implementation.
  */
 
-#include <linux/kernel.h>
 #include <linux/uaccess.h>
 #include <linux/export.h>
 
@@ -62,16 +61,14 @@ static const struct file_operations dpa_ipsec_fops = {
 
 static int dpa_ipsec_cdev_major = -1;
 static long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
-				   unsigned long args, bool compat);
+				   unsigned long args);
 
 #ifdef CONFIG_COMPAT
-
-#define COMPAT_K_TO_US 0 /* copy from Kernel to User */
-#define COMPAT_US_TO_K 1 /* copy from User to Kernel */
+static long wrp_dpa_ipsec_do_compat_ioctl(struct file *filp, unsigned int cmd,
+				   unsigned long args);
 
 static void compat_copy_dpa_ipsec_init(struct ioc_dpa_ipsec_params *prm,
-				struct ioc_compat_dpa_ipsec_params *compat_prm,
-				uint8_t	compat)
+				struct ioc_compat_dpa_ipsec_params *compat_prm)
 {
 	struct ioc_compat_ipsec_init_params *init_compat_prm;
 	struct dpa_ipsec_params	*init_prm;
@@ -79,201 +76,120 @@ static void compat_copy_dpa_ipsec_init(struct ioc_dpa_ipsec_params *prm,
 	init_compat_prm = &compat_prm->dpa_ipsec_params;
 	init_prm = &prm->dpa_ipsec_params;
 
-	if (compat == COMPAT_US_TO_K) {
-		init_prm->fm_pcd = (void *)compat_ptr(init_compat_prm->fm_pcd);
-		init_prm->fqid_range = (struct dpa_ipsec_fqid_range *)
-					compat_ptr(init_compat_prm->fqid_range);
-		init_prm->ipf_bpid = init_compat_prm->ipf_bpid;
-		init_prm->max_sa_pairs = init_compat_prm->max_sa_pairs;
-		init_prm->post_sec_in_params =
-					init_compat_prm->post_sec_in_params;
-		init_prm->max_sa_manip_ops = init_compat_prm->max_sa_manip_ops;
-		init_prm->post_sec_out_params =
-					init_compat_prm->post_sec_out_params;
-		init_prm->pre_sec_in_params =
-					init_compat_prm->pre_sec_in_params;
-		init_prm->pre_sec_out_params =
-					init_compat_prm->pre_sec_out_params;
-		init_prm->qm_sec_ch = init_compat_prm->qm_sec_ch;
-	} else
-		/* copy the ID of the newly initialized DPA IPSec instance */
-		compat_prm->dpa_ipsec_id = prm->dpa_ipsec_id;
-		/*
-		 * the other members of structure have not been changed and
-		 * there is no need to update their values
-		 */
+	init_prm->fm_pcd = (void *)compat_ptr(init_compat_prm->fm_pcd);
+	init_prm->fqid_range = (struct dpa_ipsec_fqid_range *)
+				compat_ptr(init_compat_prm->fqid_range);
+	init_prm->ipf_bpid = init_compat_prm->ipf_bpid;
+	init_prm->max_sa_pairs = init_compat_prm->max_sa_pairs;
+	init_prm->post_sec_in_params = init_compat_prm->post_sec_in_params;
+	init_prm->max_sa_manip_ops = init_compat_prm->max_sa_manip_ops;
+	init_prm->post_sec_out_params = init_compat_prm->post_sec_out_params;
+	init_prm->pre_sec_in_params = init_compat_prm->pre_sec_in_params;
+	init_prm->pre_sec_out_params = init_compat_prm->pre_sec_out_params;
+	init_prm->qm_sec_ch = init_compat_prm->qm_sec_ch;
 }
 
 static void compat_copy_sa_in_params(struct dpa_ipsec_sa_in_params *prm,
-				struct ioc_compat_sa_in_params *compat_prm,
-				uint8_t	compat)
+				     struct ioc_compat_sa_in_params *compat_prm)
 {
-	if (compat == COMPAT_US_TO_K) {
-		prm->arw = compat_prm->arw;
-		prm->use_var_iphdr_len = compat_prm->use_var_iphdr_len;
-		prm->src_addr = compat_prm->src_addr;
-		prm->dest_addr = compat_prm->dest_addr;
-		prm->use_udp_encap = compat_prm->use_udp_encap;
-		prm->src_port = compat_prm->src_port;
-		prm->dest_port = compat_prm->dest_port;
-		memset(&prm->policy_miss_action, 0,
-		       sizeof(prm->policy_miss_action));
-		dpa_cls_tbl_action_params_compatcpy(&prm->policy_miss_action,
-					&compat_prm->policy_miss_action);
-		memset(&prm->post_ipsec_action, 0,
-		       sizeof(prm->post_ipsec_action));
-		dpa_cls_tbl_action_params_compatcpy(&prm->post_ipsec_action,
-					&compat_prm->post_ipsec_action);
-	}
-	/*
-	 * for COMPAT_K_TO_US no member values have to be updated
-	 * because none have been changed by the call to the DPA IPSec function
-	 */
+	prm->arw = compat_prm->arw;
+	prm->use_var_iphdr_len = compat_prm->use_var_iphdr_len;
+	prm->src_addr = compat_prm->src_addr;
+	prm->dest_addr = compat_prm->dest_addr;
+	prm->use_udp_encap = compat_prm->use_udp_encap;
+	prm->src_port = compat_prm->src_port;
+	prm->dest_port = compat_prm->dest_port;
+	dpa_cls_tbl_action_params_compatcpy(&prm->policy_miss_action,
+				&compat_prm->policy_miss_action);
+	dpa_cls_tbl_action_params_compatcpy(&prm->post_ipsec_action,
+				&compat_prm->post_ipsec_action);
 }
 static void compat_copy_sa_out_params(struct dpa_ipsec_sa_out_params *prm,
-				struct ioc_compat_sa_out_params *compat_prm,
-				uint8_t	compat)
+				struct ioc_compat_sa_out_params *compat_prm)
 {
-	if (compat == COMPAT_US_TO_K) {
-		prm->init_vector = (struct dpa_ipsec_init_vector *)
-					compat_ptr(compat_prm->init_vector);
-		prm->ip_ver = compat_prm->ip_ver;
-		prm->ip_hdr_size = compat_prm->ip_hdr_size;
-		prm->outer_ip_header = (void *)
-					compat_ptr(compat_prm->outer_ip_header);
-		prm->outer_udp_header =	(void *)
+	prm->init_vector = (struct dpa_ipsec_init_vector *)
+				compat_ptr(compat_prm->init_vector);
+	prm->ip_ver = compat_prm->ip_ver;
+	prm->ip_hdr_size = compat_prm->ip_hdr_size;
+	prm->outer_ip_header = (void *)compat_ptr(compat_prm->outer_ip_header);
+	prm->outer_udp_header =	(void *)
 				compat_ptr(compat_prm->outer_udp_header);
-		prm->post_sec_flow_id = compat_prm->post_sec_flow_id;
-	}
-	/*
-	 * for COMPAT_K_TO_US no member values have to be updated
-	 * because none have been changed by the call to the DPA IPSec function
-	 */
+	prm->post_sec_flow_id = compat_prm->post_sec_flow_id;
 }
 
 static void compat_copy_sa_crypto_params(struct dpa_ipsec_sa_crypto_params *prm,
-				struct ioc_compat_sa_crypto_params *compat_prm,
-				uint8_t	compat)
+				struct ioc_compat_sa_crypto_params *compat_prm)
 {
-	if (compat == COMPAT_US_TO_K) {
-
-		prm->alg_suite = compat_prm->alg_suite;
-		prm->auth_key = (uint8_t *)compat_ptr(compat_prm->auth_key);
-		prm->auth_key_len = compat_prm->auth_key_len;
-		prm->cipher_key = (uint8_t *)compat_ptr(compat_prm->cipher_key);
-		prm->cipher_key_len = compat_prm->cipher_key_len;
-	}
-	/*
-	 * for COMPAT_K_TO_US no member values have to be updated
-	 * because none have been changed by the call to the DPA IPSec function
-	 */
+	prm->alg_suite = compat_prm->alg_suite;
+	prm->auth_key = (uint8_t *)compat_ptr(compat_prm->auth_key);
+	prm->auth_key_len = compat_prm->auth_key_len;
+	prm->cipher_key = (uint8_t *)compat_ptr(compat_prm->cipher_key);
+	prm->cipher_key_len = compat_prm->cipher_key_len;
 }
 
 static void compat_copy_sa_params(struct dpa_ipsec_sa_params *sa_prm,
-				struct ioc_compat_sa_params *sa_compat_prm,
-				bool compat)
-{
-	if (compat == COMPAT_US_TO_K) {
-		/* copy common (both IN & OUT SA) parameters */
-		sa_prm->spi = sa_compat_prm->spi;
-		sa_prm->use_ext_seq_num = sa_compat_prm->use_ext_seq_num;
-		sa_prm->start_seq_num = sa_compat_prm->start_seq_num;
-		sa_prm->l2_hdr_size = sa_compat_prm->l2_hdr_size;
-		sa_prm->sa_mode = sa_compat_prm->sa_mode;
-		sa_prm->sa_proto = sa_compat_prm->sa_proto;
-		sa_prm->hdr_upd_flags = sa_compat_prm->hdr_upd_flags;
-		sa_prm->sa_wqid = sa_compat_prm->sa_wqid;
-		sa_prm->sa_bpid = sa_compat_prm->sa_bpid;
-		sa_prm->enable_stats = sa_compat_prm->enable_stats;
-		sa_prm->sa_dir = sa_compat_prm->sa_dir;
-
-		/* copy crypto parameters (containing multiple pointers) */
-		compat_copy_sa_crypto_params(&sa_prm->crypto_params,
-					     &sa_compat_prm->crypto_params,
-					     COMPAT_US_TO_K);
-
-		/* copy direction specific (IN / OUT) parameters */
-		if (sa_prm->sa_dir == DPA_IPSEC_INBOUND)
-			compat_copy_sa_in_params(&sa_prm->sa_in_params,
-						 &sa_compat_prm->sa_in_params,
-						 COMPAT_US_TO_K);
-		else
-			compat_copy_sa_out_params(&sa_prm->sa_out_params,
-						  &sa_compat_prm->sa_out_params,
-						  COMPAT_US_TO_K);
-	}
-	/*
-	 * for COMPAT_K_TO_US no member values have to be updated
-	 * because none have been changed by the call to the DPA IPSec function
-	 */
-}
-
-static void compat_copy_dpa_ipsec_create_sa(struct ioc_dpa_ipsec_sa_params *prm,
-			struct ioc_compat_dpa_ipsec_sa_params *compat_prm,
-			uint8_t	compat)
+				  struct ioc_compat_sa_params *sa_compat_prm)
 {
-	if (compat == COMPAT_US_TO_K)
-		/* copy SA params from userspace */
-		compat_copy_sa_params(&prm->sa_params, &compat_prm->sa_params,
-				      compat);
+	/* copy common (both IN & OUT SA) parameters */
+	sa_prm->spi = sa_compat_prm->spi;
+	sa_prm->use_ext_seq_num = sa_compat_prm->use_ext_seq_num;
+	sa_prm->start_seq_num = sa_compat_prm->start_seq_num;
+	sa_prm->l2_hdr_size = sa_compat_prm->l2_hdr_size;
+	sa_prm->sa_mode = sa_compat_prm->sa_mode;
+	sa_prm->sa_proto = sa_compat_prm->sa_proto;
+	sa_prm->hdr_upd_flags = sa_compat_prm->hdr_upd_flags;
+	sa_prm->sa_wqid = sa_compat_prm->sa_wqid;
+	sa_prm->sa_bpid = sa_compat_prm->sa_bpid;
+	sa_prm->enable_stats = sa_compat_prm->enable_stats;
+	sa_prm->sa_dir = sa_compat_prm->sa_dir;
+
+	/* copy crypto parameters (containing multiple pointers) */
+	compat_copy_sa_crypto_params(&sa_prm->crypto_params,
+				     &sa_compat_prm->crypto_params);
+
+	/* copy direction specific (IN / OUT) parameters */
+	if (sa_prm->sa_dir == DPA_IPSEC_INBOUND)
+		compat_copy_sa_in_params(&sa_prm->sa_in_params,
+					 &sa_compat_prm->sa_in_params);
 	else
-		/* copy the ID of the newly created DPA IPSec SA */
-		compat_prm->sa_id = prm->sa_id;
-		/*
-		 * the other members of structure have not been changed and
-		 * there is no need to update their values
-		 */
+		compat_copy_sa_out_params(&sa_prm->sa_out_params,
+					&sa_compat_prm->sa_out_params);
 }
 
 static int compat_copy_sa_out_iv(struct dpa_ipsec_init_vector *sa_iv,
-				compat_uptr_t compat_iv_ptr, uint8_t compat)
+				 compat_uptr_t compat_iv_ptr)
 {
 	struct ioc_compat_sa_init_vector *compat_sa_iv, tmp_sa_iv;
 
 	compat_sa_iv =
 		(struct ioc_compat_sa_init_vector *)compat_ptr(compat_iv_ptr);
 
-	if (compat == COMPAT_US_TO_K) {
-		if (copy_from_user(&tmp_sa_iv, compat_sa_iv, sizeof(tmp_sa_iv)))
-			return -EINVAL;
-		sa_iv->init_vector = (uint8_t *)
-					compat_ptr(tmp_sa_iv.init_vector);
-		sa_iv->length = tmp_sa_iv.length;
-	}
-	/*
-	 * for COMPAT_K_TO_US no member values have to be updated
-	 * because none have been changed by the call to the DPA IPSec function
-	 */
+	if (copy_from_user(&tmp_sa_iv, compat_sa_iv, sizeof(tmp_sa_iv)))
+		return -EINVAL;
+
+	sa_iv->init_vector = (uint8_t *) compat_ptr(tmp_sa_iv.init_vector);
+	sa_iv->length = tmp_sa_iv.length;
+
 	return 0;
 }
 
 static void compat_copy_dpa_ipsec_rekey_sa(struct ioc_dpa_ipsec_rekey_prm *prm,
-			struct ioc_compat_dpa_ipsec_rekey_prm *compat_prm,
-			uint8_t	compat)
+			struct ioc_compat_dpa_ipsec_rekey_prm *compat_prm)
 {
-	if (compat == COMPAT_US_TO_K) {
-		/* copy rekeying specific params */
-		prm->auto_rmv_old_sa = compat_prm->auto_rmv_old_sa;
-		prm->sa_id = compat_prm->sa_id;
+	/* copy rekeying specific params */
+	prm->auto_rmv_old_sa = compat_prm->auto_rmv_old_sa;
+	prm->sa_id = compat_prm->sa_id;
 
-		/* copy SA params from userspace */
-		compat_copy_sa_params(&prm->sa_params, &compat_prm->sa_params,
-				      compat);
-	} else
-		/* copy the ID of the newly created DPA IPSec SA */
-		compat_prm->new_sa_id = prm->new_sa_id;
-		/*
-		 * the other members of structure have not been changed and
-		 * there is no need to update their values
-		 */
+	/* copy SA params from userspace */
+	compat_copy_sa_params(&prm->sa_params, &compat_prm->sa_params);
 }
 
 static void compat_copy_dpa_ipsec_add_rem_policy(
 			struct ioc_dpa_ipsec_add_rem_policy *prm,
 			struct ioc_compat_dpa_ipsec_add_rem_policy *compat_prm,
-			uint8_t compat)
+			bool copy_from_us)
 {
-	if (compat == COMPAT_US_TO_K) {
+	if (copy_from_us) {
 		prm->sa_id = compat_prm->sa_id;
 		prm->pol_params.src_addr = compat_prm->pol_params.src_addr;
 		prm->pol_params.src_prefix_len =
@@ -285,8 +201,6 @@ static void compat_copy_dpa_ipsec_add_rem_policy(
 		prm->pol_params.masked_proto =
 					    compat_prm->pol_params.masked_proto;
 		prm->pol_params.l4 = compat_prm->pol_params.l4;
-		memset(&prm->pol_params.dir_params, 0,
-					    sizeof(prm->pol_params.dir_params));
 		if (compat_prm->pol_params.dir_params.type ==
 						DPA_IPSEC_POL_DIR_PARAMS_MANIP)
 			prm->pol_params.dir_params.manip_desc =
@@ -302,8 +216,6 @@ static void compat_copy_dpa_ipsec_add_rem_policy(
 		prm->pol_params.priority =
 					 compat_prm->pol_params.priority;
 	} else {
-		memset(compat_prm, 0,
-			sizeof(struct ioc_compat_dpa_ipsec_add_rem_policy));
 		compat_prm->sa_id = prm->sa_id;
 		compat_prm->pol_params.src_addr = prm->pol_params.src_addr;
 		compat_prm->pol_params.src_prefix_len =
@@ -315,8 +227,6 @@ static void compat_copy_dpa_ipsec_add_rem_policy(
 		compat_prm->pol_params.masked_proto =
 						   prm->pol_params.masked_proto;
 		compat_prm->pol_params.l4 = prm->pol_params.l4;
-		memset(&compat_prm->pol_params.dir_params, 0,
-		       sizeof(compat_prm->pol_params.dir_params));
 		if (prm->pol_params.dir_params.type ==
 						DPA_IPSEC_POL_DIR_PARAMS_MANIP)
 			compat_prm->pol_params.dir_params.manip_desc =
@@ -332,47 +242,64 @@ static void compat_copy_dpa_ipsec_add_rem_policy(
 		compat_prm->pol_params.priority =
 						prm->pol_params.priority;
 	}
-
 }
 
 static void compat_copy_dpa_ipsec_get_pols(
 			struct ioc_dpa_ipsec_get_policies *prm,
-			struct ioc_compat_dpa_ipsec_get_policies *compat_prm,
-			uint8_t compat)
+			struct ioc_compat_dpa_ipsec_get_policies *compat_prm)
 {
-	if (compat == COMPAT_US_TO_K) {
-		prm->num_pol = compat_prm->num_pol;
-		prm->sa_id = compat_prm->sa_id;
-		prm->policy_params = (struct dpa_ipsec_policy_params *)
-					compat_ptr(compat_prm->policy_params);
-	} else
-		compat_prm->num_pol = prm->num_pol;
+	prm->num_pol = compat_prm->num_pol;
+	prm->sa_id = compat_prm->sa_id;
+	prm->policy_params = (struct dpa_ipsec_policy_params *)
+				compat_ptr(compat_prm->policy_params);
 }
 
+static int compat_alloc_plcr_params(struct dpa_cls_tbl_action	*kparam,
+			const struct dpa_cls_compat_tbl_action	*uparam)
+{
+	if (uparam->type == DPA_CLS_TBL_ACTION_ENQ &&
+	    compat_ptr(uparam->enq_params.policer_params)) {
+		kparam->enq_params.policer_params = kmalloc(
+				sizeof(struct dpa_cls_tbl_policer_params),
+				GFP_KERNEL);
+		if (!kparam->enq_params.policer_params) {
+			pr_err("Error alloc CLS POL param\n");
+			return -ENOMEM;
+		}
+	}
+	return 0;
+}
 #endif
 
-static int copy_policer_params(struct dpa_cls_tbl_action *cls_action,
-			       struct dpa_cls_tbl_policer_params **policer_prm)
+static int copy_policer_params(struct dpa_cls_tbl_action *cls_action)
 {
-	struct dpa_cls_tbl_policer_params *policer_params;
+	struct dpa_cls_tbl_policer_params *policer_params = NULL;
+	int err = 0;
 
 	if (cls_action->type == DPA_CLS_TBL_ACTION_ENQ &&
 	    cls_action->enq_params.policer_params != NULL) {
 		policer_params = kmalloc(sizeof(*policer_params), GFP_KERNEL);
 		if (!policer_params) {
-			pr_err("Error alloc CLS POL param");
-			return -ENOMEM;
+			pr_err("Error alloc CLS POL param\n");
+			err = -ENOMEM;
+			goto clean_policer_params;
 		}
-		*policer_prm = policer_params;
 		if (copy_from_user(policer_params,
 				  cls_action->enq_params.policer_params,
 				  sizeof(*policer_params))) {
-			pr_err("Error - copy CLS POL param");
-			return -EINVAL;
+			pr_err("Error - copy CLS POL param\n");
+			err = -EINVAL;
+			goto clean_policer_params;
 		}
 		cls_action->enq_params.policer_params = policer_params;
+		return 0;
 	}
-	return 0;
+
+clean_policer_params:
+	cls_action->enq_params.policer_params = NULL;
+	kfree(policer_params);
+
+	return err;
 }
 
 /* free memory allocated for copying SA params from US */
@@ -408,23 +335,18 @@ static void free_sa_params(struct dpa_ipsec_sa_params *prm)
 }
 
 /* handle any required memory transfers (US to K) when creating/rekeying a SA */
-#ifdef CONFIG_COMPAT
-static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm,
-			     struct ioc_compat_sa_params *compat_prm,
-			     bool compat)
-#else
-static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
-#endif
+static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm, void *args)
 {
 	struct dpa_ipsec_sa_out_params *sa_out_prm;
 	struct dpa_ipsec_sa_crypto_params *crypto_params;
 	struct dpa_ipsec_init_vector *sa_out_iv = NULL;
 	uint8_t *auth_key =  NULL, *cipher_key = NULL, *iv_array = NULL;
 	void *out_ip_hdr = NULL, *out_udp_hdr = NULL;
-	struct dpa_cls_tbl_policer_params *policer_prm_hit = NULL;
-	struct dpa_cls_tbl_policer_params *policer_prm_miss = NULL;
 	int err = 0;
-
+#ifdef CONFIG_COMPAT
+	struct ioc_compat_sa_params *compat_prm =
+					(struct ioc_compat_sa_params *)args;
+#endif
 	/* allocate memory and copy SA out params (if required)*/
 	if (prm->sa_dir == DPA_IPSEC_OUTBOUND) {
 		sa_out_prm = &prm->sa_out_params;
@@ -432,13 +354,13 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 			out_ip_hdr = kmalloc(sa_out_prm->ip_hdr_size,
 					     GFP_KERNEL);
 			if (!out_ip_hdr) {
-				pr_err("Error - alloc SA out hdr");
+				pr_err("Error - alloc SA out hdr\n");
 				return -ENOMEM;
 			}
 			if (copy_from_user(out_ip_hdr,
 					   sa_out_prm->outer_ip_header,
 					   sa_out_prm->ip_hdr_size)) {
-				pr_err("Error - copy SA out hdr");
+				pr_err("Error - copy SA out hdr\n");
 				err = -EINVAL;
 				goto free_create_copied_sa_mem;
 			}
@@ -447,14 +369,14 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 		if (sa_out_prm->outer_udp_header) {
 			out_udp_hdr = kmalloc(UDP_HDR_SIZE, GFP_KERNEL);
 			if (!out_udp_hdr) {
-				pr_err("Error - alloc SA out udp hdr");
+				pr_err("Error - alloc SA out udp hdr\n");
 				err = -ENOMEM;
 				goto free_create_copied_sa_mem;
 			}
 			if (copy_from_user(out_udp_hdr,
 					   sa_out_prm->outer_udp_header,
 					   UDP_HDR_SIZE)) {
-				pr_err("Error - copy SA out udp hdr");
+				pr_err("Error - copy SA out udp hdr\n");
 				err = -EINVAL;
 				goto free_create_copied_sa_mem;
 			}
@@ -463,26 +385,20 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 		if (sa_out_prm->init_vector) {
 			sa_out_iv = kmalloc(sizeof(*sa_out_iv), GFP_KERNEL);
 			if (!sa_out_iv) {
-				pr_err("Error - alloc SA out IV struct");
+				pr_err("Error - alloc SA out IV struct\n");
 				err = -ENOMEM;
 				goto free_create_copied_sa_mem;
 			}
 #ifdef CONFIG_COMPAT
-			if (compat) {
-				struct ioc_compat_sa_out_params *compat_out_prm;
-
-				compat_out_prm = &compat_prm->sa_out_params;
-				err = compat_copy_sa_out_iv(sa_out_iv,
-						compat_out_prm->init_vector,
-						COMPAT_US_TO_K);
-			} else
+			err = compat_copy_sa_out_iv(sa_out_iv,
+					compat_prm->sa_out_params.init_vector);
+#else
+			if (copy_from_user(sa_out_iv, sa_out_prm->init_vector,
+					   sizeof(*sa_out_iv)))
+				err = -EINVAL;
 #endif
-				if (copy_from_user(sa_out_iv,
-						   sa_out_prm->init_vector,
-						   sizeof(*sa_out_iv)))
-					err = -EINVAL;
 			if (err < 0) {
-				pr_err("Error - copy SA out IV struct");
+				pr_err("Error - copy SA out IV struct\n");
 				kfree(sa_out_iv);
 				return err;
 			}
@@ -494,41 +410,18 @@ static int do_copy_sa_params(struct dpa_ipsec_sa_params *prm)
 
 			iv_array = kmalloc(sa_out_iv->length, GFP_KERNEL);
 			if (!iv_array) {
-				pr_err("Error - alloc SA out IV array");
+				pr_err("Error - alloc SA out IV array\n");
 				err = -ENOMEM;
 				goto free_create_copied_sa_mem;
 			}
 			if (copy_from_user(iv_array, sa_out_iv->init_vector,
 					   sa_out_iv->length)) {
-				pr_err("Error - copy SA out IV array");
+				pr_err("Error - copy SA out IV array\n");
 				err = -EINVAL;
 				goto free_create_copied_sa_mem;
 			}
 			sa_out_iv->init_vector = iv_array;
 		}
-	} else {
-		/* handle any required memory transfer from US to K */
-		struct dpa_cls_tbl_action *cls_action;
-
-		/* copy policer params for policy miss action -  if any */
-		cls_action = &prm->sa_in_params.policy_miss_action;
-		err = copy_policer_params(cls_action, &policer_prm_miss);
-		if (err < 0) {
-			if (!policer_prm_miss)
-				return err;
-			else
-				goto free_create_copied_sa_mem;
-		}
-
-		/* copy policer params for post decryption action -  if any */
-		cls_action = &prm->sa_in_params.post_ipsec_action;
-		err = copy_policer_params(cls_action, &policer_prm_hit);
-		if (err < 0) {
-			if (!policer_prm_hit)
-				return err;
-			else
-				goto free_create_copied_sa_mem;
-		}
 	}
 
 copy_crypto_keys:
@@ -540,13 +433,13 @@ copy_crypto_keys:
 	if (crypto_params->auth_key) {
 		auth_key = kmalloc(crypto_params->auth_key_len, GFP_KERNEL);
 		if (!auth_key) {
-			pr_err("Couldn't allocate memory for SA auth key");
+			pr_err("Couldn't allocate memory for SA auth key\n");
 			err = -ENOMEM;
 			goto free_create_sa_keys_mem;
 		}
 		if (copy_from_user(auth_key, crypto_params->auth_key,
 				   crypto_params->auth_key_len)) {
-			pr_err("Could not copy SA auth key!");
+			pr_err("Could not copy SA auth key!\n");
 			err = -EINVAL;
 			goto free_create_sa_keys_mem;
 		}
@@ -556,13 +449,13 @@ copy_crypto_keys:
 	if (crypto_params->cipher_key) {
 		cipher_key = kmalloc(crypto_params->cipher_key_len, GFP_KERNEL);
 		if (!cipher_key) {
-			pr_err("Couldn't allocate memory for SA cipher key");
+			pr_err("Couldn't allocate memory for SA cipher key\n");
 			err = -ENOMEM;
 			goto free_create_sa_keys_mem;
 		}
 		if (copy_from_user(cipher_key, crypto_params->cipher_key,
 				   crypto_params->cipher_key_len)) {
-			pr_err("Could not copy SA auth key!");
+			pr_err("Could not copy SA auth key!\n");
 			err = -EINVAL;
 			goto free_create_sa_keys_mem;
 		}
@@ -581,119 +474,136 @@ free_create_copied_sa_mem:
 		kfree(sa_out_iv);
 		kfree(out_ip_hdr);
 		kfree(out_udp_hdr);
-	} else {
-		kfree(policer_prm_miss);
-		kfree(policer_prm_hit);
 	}
 
 	return err;
 }
 
-static int do_init_ioctl(void *args, bool compat)
+static int do_init_ioctl(struct ioc_dpa_ipsec_params *kprm)
 {
-	struct ioc_dpa_ipsec_params prm;
-#ifdef CONFIG_COMPAT
-	struct ioc_compat_dpa_ipsec_params compat_prm;
-#endif
 	struct dpa_ipsec_fqid_range *fqid_range = NULL;
 	struct file *fm_pcd_file;
 	t_LnxWrpFmDev *fm_wrapper_dev;
 	int err;
 
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
-			pr_err("Could not copy DPA IPSec init parameters");
-			return -EINVAL;
-		}
-		compat_copy_dpa_ipsec_init(&prm, &compat_prm, COMPAT_US_TO_K);
-	} else
-#endif
-		if (copy_from_user(&prm, args, sizeof(prm))) {
-			pr_err("Could not copy DPA IPSec init parameters");
-			return -EINVAL;
-		}
-
 	/* copy FQID range params - if configured */
-	if (prm.dpa_ipsec_params.fqid_range) {
+	if (kprm->dpa_ipsec_params.fqid_range) {
 		fqid_range = kmalloc(sizeof(*fqid_range), GFP_KERNEL);
 		if (!fqid_range) {
 			pr_err("FQID range allocation failed!\n");
 			return -EINVAL;
 		}
 		if (copy_from_user(fqid_range,
-				   prm.dpa_ipsec_params.fqid_range,
+				   kprm->dpa_ipsec_params.fqid_range,
 				   sizeof(*fqid_range))) {
 			pr_err("Could not copy FQID range params!\n");
 			err = -EINVAL;
 			goto free_ipsec_init_mem;
 		}
-		prm.dpa_ipsec_params.fqid_range = fqid_range;
+		kprm->dpa_ipsec_params.fqid_range = fqid_range;
 	}
 
 	/* Translate FM_PCD file descriptor */
-	fm_pcd_file = fcheck((unsigned long)prm.dpa_ipsec_params.fm_pcd);
+	fm_pcd_file = fcheck((unsigned long)kprm->dpa_ipsec_params.fm_pcd);
 	if (!fm_pcd_file) {
-		pr_err("Could not acquire PCD handle");
+		pr_err("Could not acquire PCD handle\n");
 		err = -EINVAL;
 		goto free_ipsec_init_mem;
 	}
 	fm_wrapper_dev = ((t_LnxWrpFmDev *)fm_pcd_file->private_data);
-	prm.dpa_ipsec_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
-	err = dpa_ipsec_init(&prm.dpa_ipsec_params,
-			     &prm.dpa_ipsec_id);
+	kprm->dpa_ipsec_params.fm_pcd = (void *)fm_wrapper_dev->h_PcdDev;
+	err = dpa_ipsec_init(&kprm->dpa_ipsec_params,
+			     &kprm->dpa_ipsec_id);
 	if (err < 0)
 		goto free_ipsec_init_mem;
 
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		compat_copy_dpa_ipsec_init(&prm, &compat_prm, COMPAT_K_TO_US);
-		if (copy_to_user((void *)args, &compat_prm,
-				 sizeof(compat_prm))) {
-			pr_err("Could not copy to user the DPA IPSec ID");
-			err = -EINVAL;
-		}
-	} else
-#endif
-		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			pr_err("Could not copy to user the ID");
-			err = -EINVAL;
-		}
-
 free_ipsec_init_mem:
 	kfree(fqid_range);
 
 	return err;
 }
 
-static int do_create_sa_ioctl(void *args, bool compat)
+static int do_create_sa_ioctl(void *args)
 {
 	struct ioc_dpa_ipsec_sa_params prm;
+	int err = 0;
+
+	if (copy_from_user(&prm, args, sizeof(prm))) {
+		pr_err("Could not copy SA parameters\n");
+		return -EINVAL;
+	}
+
+	if (prm.sa_params.sa_dir == DPA_IPSEC_INBOUND) {
+		struct dpa_ipsec_sa_in_params *sa_in_params = NULL;
+
+		sa_in_params = &prm.sa_params.sa_in_params;
+		/* copy policer params for policy miss action - if any */
+		err = copy_policer_params(&sa_in_params->policy_miss_action);
+		if (err < 0)
+			goto free_create_sa_mem;
+
+		/* copy policer params for post decryption action - if any */
+		err = copy_policer_params(&sa_in_params->post_ipsec_action);
+		if (err < 0)
+			goto free_create_sa_mem;
+	}
+
+	err = do_copy_sa_params(&prm.sa_params, NULL);
+	if (err < 0)
+		return err;
+
+	err = dpa_ipsec_create_sa(prm.dpa_ipsec_id, &prm.sa_params, &prm.sa_id);
+	if (err < 0)
+		goto free_create_sa_mem;
+
+	if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+		pr_err("Could not copy to user the SA ID\n");
+		err = -EINVAL;
+	}
+
+free_create_sa_mem:
+	free_sa_params(&prm.sa_params);
+
+	return err;
+}
+
 #ifdef CONFIG_COMPAT
+static int do_create_sa_compat_ioctl(void *args)
+{
+	struct ioc_dpa_ipsec_sa_params prm;
 	struct ioc_compat_dpa_ipsec_sa_params compat_prm;
-#endif
 	int err = 0;
 
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
-			pr_err("Could not copy SA parameters");
-			return -EINVAL;
-		}
-		compat_copy_dpa_ipsec_create_sa(&prm, &compat_prm,
-						COMPAT_US_TO_K);
-	} else
-#endif
-		if (copy_from_user(&prm, args, sizeof(prm))) {
-			pr_err("Could not copy SA parameters");
-			return -EINVAL;
-		}
+	if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+		pr_err("Could not copy SA parameters\n");
+		return -EINVAL;
+	}
 
-#ifdef CONFIG_COMPAT
-	err = do_copy_sa_params(&prm.sa_params, &compat_prm.sa_params, compat);
-#else
-	err = do_copy_sa_params(&prm.sa_params);
-#endif
+	memset(&prm, 0, sizeof(struct ioc_dpa_ipsec_sa_params));
+
+	/* allocate memory for policer parameters */
+	if (compat_prm.sa_params.sa_dir == DPA_IPSEC_INBOUND) {
+		memset(&prm.sa_params.sa_in_params.policy_miss_action,
+				0, sizeof(struct dpa_cls_tbl_action));
+		err = compat_alloc_plcr_params(
+			&prm.sa_params.sa_in_params.policy_miss_action,
+			&compat_prm.sa_params.sa_in_params.policy_miss_action);
+		if (err < 0)
+			goto free_create_sa_mem;
+
+		memset(&prm.sa_params.sa_in_params.post_ipsec_action,
+				0, sizeof(struct dpa_cls_tbl_action));
+		err = compat_alloc_plcr_params(
+			&prm.sa_params.sa_in_params.post_ipsec_action,
+			&compat_prm.sa_params.sa_in_params.post_ipsec_action);
+		if (err < 0)
+			goto free_create_sa_mem;
+	}
+
+	/* copy SA params from userspace */
+	compat_copy_sa_params(&prm.sa_params, &compat_prm.sa_params);
+
+	err = do_copy_sa_params(&prm.sa_params, &compat_prm.sa_params);
 	if (err < 0)
 		return err;
 
@@ -701,56 +611,66 @@ static int do_create_sa_ioctl(void *args, bool compat)
 	if (err < 0)
 		goto free_create_sa_mem;
 
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		compat_copy_dpa_ipsec_create_sa(&prm, &compat_prm,
-						COMPAT_K_TO_US);
-		if (copy_to_user((void *)args, &compat_prm,
-				 sizeof(compat_prm))) {
-			pr_err("Could not copy to user the SA ID");
-			err = -EINVAL;
-		}
-	} else
-#endif
-		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			pr_err("Could not copy to user the SA ID");
-			err = -EINVAL;
-		}
+	/* copy the ID of the newly created DPA IPSec SA */
+	compat_prm.sa_id = prm.sa_id;
+
+	if (copy_to_user((void *)args, &compat_prm, sizeof(compat_prm))) {
+		pr_err("Could not copy to user the SA ID\n");
+		err = -EINVAL;
+	}
 
 free_create_sa_mem:
 	free_sa_params(&prm.sa_params);
 
 	return err;
 }
+#endif
 
-static int do_sa_rekey_ioctl(void *args, bool compat)
+static int do_sa_rekey_ioctl(void *args)
 {
 	struct ioc_dpa_ipsec_rekey_prm prm;
+	int err = 0;
+
+	if (copy_from_user(&prm, args, sizeof(prm))) {
+		pr_err("Could not copy SA rekeying params\n");
+		return -EINVAL;
+	}
+
+	err = do_copy_sa_params(&prm.sa_params, NULL);
+	if (err < 0)
+		return err;
+
+	err = dpa_ipsec_sa_rekeying(prm.sa_id, &prm.sa_params,
+				    default_rekey_event_cb, prm.auto_rmv_old_sa,
+				    &prm.new_sa_id);
+	if (err < 0)
+		goto free_rekey_sa_mem;
+
+	if (copy_to_user((void *)args, &prm, sizeof(prm))) {
+		pr_err("Could not copy to user new SA ID\n");
+		err = -EINVAL;
+	}
+
+free_rekey_sa_mem:
+	free_sa_params(&prm.sa_params);
+
+	return err;
+}
+
 #ifdef CONFIG_COMPAT
+static int do_sa_rekey_compat_ioctl(void *args)
+{
+	struct ioc_dpa_ipsec_rekey_prm prm;
 	struct ioc_compat_dpa_ipsec_rekey_prm compat_prm;
-#endif
 	int err = 0;
 
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
-			pr_err("Could not copy SA rekeying params");
-			return -EINVAL;
-		}
-		compat_copy_dpa_ipsec_rekey_sa(&prm, &compat_prm,
-					       COMPAT_US_TO_K);
-	} else
-#endif
-		if (copy_from_user(&prm, args, sizeof(prm))) {
-			pr_err("Could not copy SA rekeying params");
-			return -EINVAL;
-		}
+	if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+		pr_err("Could not copy SA rekeying params\n");
+		return -EINVAL;
+	}
+	compat_copy_dpa_ipsec_rekey_sa(&prm, &compat_prm);
 
-#ifdef CONFIG_COMPAT
-	err = do_copy_sa_params(&prm.sa_params, &compat_prm.sa_params, compat);
-#else
-	err = do_copy_sa_params(&prm.sa_params);
-#endif
+	err = do_copy_sa_params(&prm.sa_params, &compat_prm.sa_params);
 	if (err < 0)
 		return err;
 
@@ -760,65 +680,35 @@ static int do_sa_rekey_ioctl(void *args, bool compat)
 	if (err < 0)
 		goto free_rekey_sa_mem;
 
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		compat_copy_dpa_ipsec_rekey_sa(&prm, &compat_prm,
-					       COMPAT_K_TO_US);
-		if (copy_to_user((void *)args, &compat_prm,
-				 sizeof(compat_prm))) {
-			pr_err("Could not copy to user new SA ID");
-			err = -EINVAL;
-		}
-	} else
-#endif
-		if (copy_to_user((void *)args, &prm, sizeof(prm))) {
-			pr_err("Could not copy to user new SA ID");
-			err = -EINVAL;
-		}
+	compat_prm.new_sa_id = prm.new_sa_id;
+	if (copy_to_user((void *)args, &compat_prm, sizeof(compat_prm))) {
+		pr_err("Could not copy to user new SA ID\n");
+		err = -EINVAL;
+	}
 
 free_rekey_sa_mem:
 	free_sa_params(&prm.sa_params);
 
 	return err;
 }
+#endif
 
-static int do_add_rem_policy_ioctl(void *args, bool add_pol, bool compat)
+static int do_add_rem_policy_ioctl(void *args, bool add_pol)
 {
 	struct ioc_dpa_ipsec_add_rem_policy prm;
-#ifdef CONFIG_COMPAT
-	struct ioc_compat_dpa_ipsec_add_rem_policy compat_prm;
-#endif
-	struct dpa_cls_tbl_policer_params *policer_prm = NULL;
 	int err;
 
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		if (copy_from_user(&compat_prm,
-			   (struct ioc_compat_dpa_ipsec_add_rem_policy *) args,
-			    sizeof(compat_prm))) {
-			pr_err("Could not copy parameters\n");
-			return -EINVAL;
-		}
-		compat_copy_dpa_ipsec_add_rem_policy(&prm, &compat_prm,
-						     COMPAT_US_TO_K);
-	} else
-#endif
-		if (copy_from_user(&prm,
-			   (struct ioc_dpa_ipsec_add_rem_policy *) args,
-			    sizeof(prm))) {
-			pr_err("Could not copy parameters\n");
-			return -EINVAL;
-		}
+	if (copy_from_user(&prm,
+			   (struct ioc_dpa_ipsec_add_rem_policy *)args,
+			   sizeof(prm))) {
+		pr_err("Could not copy parameters\n");
+		return -EINVAL;
+	}
 
 	if (prm.pol_params.dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_ACT) {
-		err = copy_policer_params(&prm.pol_params.dir_params.in_action,
-					  &policer_prm);
-		if (err < 0) {
-			if (!policer_prm)
-				return err;
-			else
-				goto free_pol_memory;
-		}
+		err = copy_policer_params(&prm.pol_params.dir_params.in_action);
+		if (err < 0)
+			goto free_pol_memory;
 	}
 
 	if (add_pol)
@@ -827,38 +717,62 @@ static int do_add_rem_policy_ioctl(void *args, bool add_pol, bool compat)
 		err = dpa_ipsec_sa_remove_policy(prm.sa_id, &prm.pol_params);
 
 free_pol_memory:
-	kfree(policer_prm);
+	kfree(prm.pol_params.dir_params.in_action.enq_params.policer_params);
+
+	return err;
+}
+
+#ifdef CONFIG_COMPAT
+static int do_add_rem_policy_compat_ioctl(void *args, bool add_pol)
+{
+	struct ioc_dpa_ipsec_add_rem_policy kprm;
+	struct ioc_compat_dpa_ipsec_add_rem_policy uprm;
+	struct dpa_cls_tbl_action *in_action = NULL;
+	int err;
+
+	if (copy_from_user(&uprm,
+		   (struct ioc_compat_dpa_ipsec_add_rem_policy *)args,
+		    sizeof(uprm))) {
+		pr_err("Could not copy parameters\n");
+		return -EINVAL;
+	}
+
+	memset(&kprm, 0, sizeof(struct ioc_dpa_ipsec_add_rem_policy));
+
+	in_action = &kprm.pol_params.dir_params.in_action;
+	if (uprm.pol_params.dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_ACT) {
+		err = compat_alloc_plcr_params(in_action,
+					&uprm.pol_params.dir_params.in_action);
+		if (err < 0)
+			return err;
+	}
+
+	compat_copy_dpa_ipsec_add_rem_policy(&kprm, &uprm, true);
+
+	if (add_pol)
+		err = dpa_ipsec_sa_add_policy(kprm.sa_id, &kprm.pol_params);
+	else
+		err = dpa_ipsec_sa_remove_policy(kprm.sa_id, &kprm.pol_params);
+
+	if (err < 0)
+		kfree(in_action->enq_params.policer_params);
 
 	return err;
 }
+#endif
 
-static int do_sa_get_policies_ioctl(void *args, bool compat)
+static int do_sa_get_policies_ioctl(void *args)
 {
 	struct ioc_dpa_ipsec_get_policies prm;
 	struct dpa_ipsec_policy_params *policy_params = NULL;
-#ifdef CONFIG_COMPAT
-	struct ioc_dpa_ipsec_add_rem_policy kparam;
-	struct ioc_compat_dpa_ipsec_get_policies compat_prm;
-	struct ioc_compat_policy_params *compat_pol_params = NULL;
-	struct ioc_compat_dpa_ipsec_add_rem_policy compat_uparam;
-	int i;
-#endif
-	int sa_id, num_pol, err = 0;
+	struct dpa_cls_tbl_policer_params **uplcr = NULL, **kplcr = NULL;
+	struct dpa_ipsec_pol_dir_params *dir;
+	int sa_id, num_pol = 0, err = 0, i;
 
-#ifdef CONFIG_COMPAT
-	if (compat) {
-		if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
-			pr_err("Could not copy params for policy retrieval");
-			return -EINVAL;
-		}
-		compat_copy_dpa_ipsec_get_pols(&prm, &compat_prm,
-					       COMPAT_US_TO_K);
-	} else
-#endif
-		if (copy_from_user(&prm, args, sizeof(prm))) {
-			pr_err("Could not copy params for policy retrieval");
-			return -EINVAL;
-		}
+	if (copy_from_user(&prm, args, sizeof(prm))) {
+		pr_err("Could not copy params for policy retrieval\n");
+		return -EINVAL;
+	}
 
 	if (prm.sa_id < 0) {
 		pr_err("Invalid input SA id\n");
@@ -874,20 +788,11 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 		}
 
 		prm.num_pol = num_pol;
-#ifdef CONFIG_COMPAT
-		if (compat) {
-			compat_copy_dpa_ipsec_get_pols(&prm, &compat_prm,
-						       COMPAT_K_TO_US);
-		if (copy_to_user(args, &compat_prm, sizeof(compat_prm))) {
-				pr_err("Cannot copy policy count to user");
-				return -EINVAL;
-			}
-		} else
-#endif
-			if (copy_to_user(args, &prm, sizeof(prm))) {
-				pr_err("Cannot copy policy count to user");
-				return -EINVAL;
-			}
+
+		if (copy_to_user(args, &prm, sizeof(prm))) {
+			pr_err("Cannot copy policy count to user\n");
+			return -EINVAL;
+		}
 		return 0;
 	}
 
@@ -899,32 +804,172 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 
 	policy_params =	kzalloc(num_pol * sizeof(*policy_params), GFP_KERNEL);
 	if (!policy_params) {
-		pr_err("Could not allocate memory for policy array");
+		pr_err("Could not allocate memory for policy array\n");
 		return -ENOMEM;
 	}
 
 	err = dpa_ipsec_sa_get_policies(sa_id, policy_params, &num_pol);
 	if (err < 0 && err != -EAGAIN) {
-		pr_err("Could not retrieve SA policies");
+		pr_err("Could not retrieve SA policies\n");
 		goto err_pol_cleanup;
 	} else if (err == -EAGAIN)
-		pr_err("Not all SA policies could be retrieved");
+		pr_err("Not all SA policies could be retrieved\n");
 
-#ifdef CONFIG_COMPAT
-	compat_pol_params = kzalloc(num_pol * sizeof(*compat_pol_params),
-				    GFP_KERNEL);
+	kplcr = kzalloc(num_pol * sizeof(*kplcr), GFP_KERNEL);
+	if (!kplcr) {
+		pr_err("Could not allocate memory for policer array\n");
+		err = -ENOMEM;
+		goto err_pol_cleanup;
+	}
+
+	uplcr = kzalloc(num_pol * sizeof(*uplcr), GFP_KERNEL);
+	if (!uplcr) {
+		pr_err("Could not allocate memory for policer array\n");
+		err = -ENOMEM;
+		goto err_pol_cleanup;
+	}
+
+	/* User needs to provide policer parameters pointer */
+	for (i = 0; i < num_pol; i++) {
+		dir = &prm.policy_params[i].dir_params;
+		if (dir->in_action.enq_params.policer_params != NULL)
+			uplcr[i] = dir->in_action.enq_params.policer_params;
+	}
+
+	for (i = 0; i < num_pol; i++) {
+		dir = &policy_params[i].dir_params;
+		if (dir->type == DPA_IPSEC_POL_DIR_PARAMS_ACT &&
+		    dir->in_action.enq_params.policer_params != NULL)
+			kplcr[i] = dir->in_action.enq_params.policer_params;
+	}
+
+	if (copy_to_user(prm.policy_params, policy_params,
+			 num_pol * sizeof(*policy_params))) {
+		pr_err("Could not return policy parameters\n");
+		err = -EINVAL;
+	}
+
+	for (i = 0; i < num_pol; i++) {
+		if (uplcr[i] && kplcr[i]) {
+			if (copy_to_user(uplcr[i], kplcr[i], sizeof(**uplcr))) {
+				pr_err("Could not return policy parameters\n");
+				err = -EINVAL;
+			}
+		}
+		prm.policy_params[i].dir_params.in_action.
+					enq_params.policer_params = uplcr[i];
+	}
+
+	/*
+	 * None of the values of the members in the input structure have been
+	 * modified, so there is no need to copy the input structure back to the
+	 * user
+	 */
+
+err_pol_cleanup:
+	kfree(policy_params);
+	kfree(uplcr);
+	kfree(kplcr);
+
+	return err;
+}
+
+#ifdef CONFIG_COMPAT
+static int do_sa_get_policies_compat_ioctl(void *args)
+{
+	struct ioc_dpa_ipsec_get_policies prm;
+	struct dpa_ipsec_policy_params *policy_params = NULL;
+	struct ioc_dpa_ipsec_add_rem_policy kparam;
+	struct ioc_compat_dpa_ipsec_get_policies compat_prm;
+	struct ioc_compat_policy_params *compat_pol_params = NULL;
+	struct ioc_compat_dpa_ipsec_add_rem_policy compat_uparam;
+	struct ioc_compat_policy_params *pol = NULL;
+	int i, sa_id, num_pol, err = 0;
+
+	if (copy_from_user(&compat_prm, args, sizeof(compat_prm))) {
+		pr_err("Could not copy params for policy retrieval\n");
+		return -EINVAL;
+	}
+	compat_copy_dpa_ipsec_get_pols(&prm, &compat_prm);
+
+	if (prm.sa_id < 0) {
+		pr_err("Invalid input SA id\n");
+		return -EINVAL;
+	}
+
+	sa_id = prm.sa_id;
+	if (!prm.policy_params) {
+		err = dpa_ipsec_sa_get_policies(sa_id, NULL, &num_pol);
+		if (err < 0) {
+			pr_err("Get policies count failed\n");
+			return err;
+		}
+
+		prm.num_pol = num_pol;
+
+		compat_prm.num_pol = prm.num_pol;
+		if (copy_to_user(args, &compat_prm, sizeof(compat_prm))) {
+				pr_err("Cannot copy policy count to user\n");
+				return -EINVAL;
+		}
+		return 0;
+	}
+
+	num_pol = prm.num_pol;
+	if (num_pol <= 0) {
+		pr_err("Invalid number of policies for SA ID# %d\n", sa_id);
+		return -EINVAL;
+	}
+
+	policy_params =	kzalloc(num_pol * sizeof(*policy_params), GFP_KERNEL);
+	if (!policy_params) {
+		pr_err("Could not allocate memory for policy array\n");
+		return -ENOMEM;
+	}
+
+	err = dpa_ipsec_sa_get_policies(sa_id, policy_params, &num_pol);
+	if (err < 0 && err != -EAGAIN) {
+		pr_err("Could not retrieve SA policies\n");
+		goto err_pol_cleanup;
+	} else if (err == -EAGAIN)
+		pr_err("Not all SA policies could be retrieved\n");
+
+	compat_pol_params = kzalloc(num_pol * sizeof(*compat_pol_params),
+				    GFP_KERNEL);
 	if (!compat_pol_params) {
 		pr_err("Could not allocate memory for compat policy array!\n");
 		kfree(policy_params);
 		return -ENOMEM;
 	}
 
+	/* Allocate memory to store the array of policy objects */
+	pol = kzalloc(sizeof(*pol) * num_pol, GFP_KERNEL);
+	if (!pol) {
+		pr_err("No more memory for array of policies\n");
+		err = -ENOMEM;
+		goto err_pol_cleanup;
+	}
+
+	if (copy_from_user(pol, compat_ptr(compat_prm.policy_params),
+			  (sizeof(*pol) * num_pol))) {
+		pr_err("Could not copy array of objects\n");
+		err = -EBUSY;
+		goto err_pol_cleanup;
+	}
+
 	for (i = 0; i < num_pol; i++) {
 		memcpy(&kparam.pol_params, &policy_params[i],
 			sizeof(kparam.pol_params));
+		memset(&compat_uparam, 0,
+			sizeof(struct ioc_compat_dpa_ipsec_add_rem_policy));
+
+		compat_uparam.pol_params.dir_params.in_action.
+			enq_params.policer_params = pol[i].dir_params.
+			in_action.enq_params.policer_params;
+
 		compat_copy_dpa_ipsec_add_rem_policy(&kparam,
 						     &compat_uparam,
-						     COMPAT_K_TO_US);
+						     false);
 		memcpy(&compat_pol_params[i], &compat_uparam.pol_params,
 			sizeof(compat_uparam.pol_params));
 	}
@@ -933,13 +978,7 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 		pr_err("Could not return policy parameters\n");
 		err = -EINVAL;
 	}
-#else
-	if (copy_to_user(prm.policy_params, policy_params,
-			 num_pol * sizeof(*policy_params))) {
-		pr_err("Could not return policy parameters\n");
-		err = -EINVAL;
-	}
-#endif
+
 	/*
 	 * None of the values of the members in the input structure have been
 	 * modified, so there is no need to copy the input structure back to the
@@ -947,13 +986,13 @@ static int do_sa_get_policies_ioctl(void *args, bool compat)
 	 */
 
 err_pol_cleanup:
-#ifdef CONFIG_COMPAT
 	kfree(compat_pol_params);
-#endif
 	kfree(policy_params);
+	kfree(pol);
 
 	return err;
 }
+#endif
 
 /* Set mprm - no compat case */
 static int do_sa_modify_ioctl(unsigned long args, int *sa_id,
@@ -1068,7 +1107,7 @@ int wrp_dpa_ipsec_init(void)
 	dpa_ipsec_cdev_major =
 	    register_chrdev(0, DPA_IPSEC_CDEV, &dpa_ipsec_fops);
 	if (dpa_ipsec_cdev_major < 0) {
-		pr_err("Could not register Dpa Ipsec character device");
+		pr_err("Could not register Dpa IPSec character device\n");
 		return dpa_ipsec_cdev_major;
 	}
 	return 0;
@@ -1097,89 +1136,249 @@ int wrp_dpa_ipsec_release(struct inode *inode, struct file *filp)
 }
 
 long wrp_dpa_ipsec_ioctl(struct file *filp, unsigned int cmd,
-			    unsigned long args)
+			 unsigned long args)
 {
-	return wrp_dpa_ipsec_do_ioctl(filp, cmd, args, false);
+	return wrp_dpa_ipsec_do_ioctl(filp, cmd, args);
 }
 
 #ifdef CONFIG_COMPAT
 long wrp_dpa_ipsec_ioctl_compat(struct file *filp, unsigned int cmd,
 				unsigned long args)
 {
-	return wrp_dpa_ipsec_do_ioctl(filp, cmd, args, true);
+
+	return wrp_dpa_ipsec_do_compat_ioctl(filp, cmd, args);
 }
 #endif
 
 long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
-			 unsigned long args, bool compat)
+			    unsigned long args)
 {
 	long ret = 0;
-	int err = 0;
 
 	switch (cmd) {
-#ifdef CONFIG_COMPAT
-	case DPA_IPSEC_IOC_INIT_COMPAT:
-#endif
 	case DPA_IPSEC_IOC_INIT: {
-		ret = do_init_ioctl((void *)args, compat);
+		struct ioc_dpa_ipsec_params kprm;
+
+		/* Copy parameters from user-space */
+		if (copy_from_user(&kprm, (void *)args, sizeof(kprm))) {
+			pr_err("Could not copy DPA IPSec init parameters\n");
+			return -EINVAL;
+		}
+
+		ret = do_init_ioctl(&kprm);
+		if (ret < 0)
+			return ret;
+
+		if (copy_to_user((void *)args, &kprm, sizeof(kprm))) {
+			pr_err("Could not copy to user the ID\n");
+			return -EINVAL;
+		}
 		break;
 	}
 
 	case DPA_IPSEC_IOC_FREE: {
 		int dpa_ipsec_id;
-		if (copy_from_user(&dpa_ipsec_id, (int *)args,
-				    sizeof(int))) {
-			pr_err("Could not copy parameters");
+		if (copy_from_user(&dpa_ipsec_id, (int *)args, sizeof(int))) {
+			pr_err("Could not copy parameters\n");
 			return -EINVAL;
 		}
-		err = dpa_ipsec_free(dpa_ipsec_id);
-		if (err < 0)
-			return err;
+		ret = dpa_ipsec_free(dpa_ipsec_id);
 		break;
 	}
 
-#ifdef CONFIG_COMPAT
-	case DPA_IPSEC_IOC_CREATE_SA_COMPAT:
-#endif
 	case DPA_IPSEC_IOC_CREATE_SA: {
-		ret = do_create_sa_ioctl((void *)args, compat);
+		ret = do_create_sa_ioctl((void *)args);
 		break;
 	}
 
 	case DPA_IPSEC_IOC_REMOVE_SA: {
 		int sa_id;
 		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
-			pr_err("Could not copy parameters");
+			pr_err("Could not copy parameters\n");
 			return -EINVAL;
 		}
-
-		err = dpa_ipsec_remove_sa(sa_id);
-		if (err < 0)
-			return err;
+		ret = dpa_ipsec_remove_sa(sa_id);
 		break;
 	}
 
-#ifdef CONFIG_COMPAT
-	case DPA_IPSEC_IOC_ADD_POLICY_COMPAT:
-#endif
 	case DPA_IPSEC_IOC_ADD_POLICY: {
-		ret = do_add_rem_policy_ioctl((void *)args, true, compat);
+		ret = do_add_rem_policy_ioctl((void *)args, true);
 		break;
 	}
 
-#ifdef CONFIG_COMPAT
-	case DPA_IPSEC_IOC_REMOVE_POLICY_COMPAT:
-#endif
 	case DPA_IPSEC_IOC_REMOVE_POLICY: {
-		ret = do_add_rem_policy_ioctl((void *)args, false, compat);
+		ret = do_add_rem_policy_ioctl((void *)args, false);
 		break;
 	}
 
-#ifdef CONFIG_COMPAT
-	case DPA_IPSEC_IOC_SA_REKEYING_COMPAT:
-#endif
 	case DPA_IPSEC_IOC_SA_REKEYING: {
-		ret = do_sa_rekey_ioctl((void *)args, compat);
+		ret = do_sa_rekey_ioctl((void *)args);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_FLUSH_ALL_SA: {
+		int dpa_ipsec_id;
+
+		if (copy_from_user(&dpa_ipsec_id, (int *)args, sizeof(int))) {
+			pr_err("Could not copy parameters\n");
+			return -EINVAL;
+		}
+
+		ret = dpa_ipsec_flush_all_sa(dpa_ipsec_id);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_GET_SA_POLICIES: {
+		ret = do_sa_get_policies_ioctl((void *)args);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_FLUSH_SA_POLICIES: {
+		int sa_id;
+
+		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
+			pr_err("Could not copy SA id\n");
+			return -EINVAL;
+		}
+
+		ret = dpa_ipsec_sa_flush_policies(sa_id);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_DISABLE_SA: {
+		int sa_id;
+
+		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
+			pr_err("Could not copy SA id\n");
+			return -EINVAL;
+		}
+
+		ret = dpa_ipsec_disable_sa(sa_id);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_GET_SA_STATS: {
+		struct ioc_dpa_ipsec_sa_get_stats prm;
+
+		if (copy_from_user(&prm,
+				   (struct ioc_dpa_ipsec_sa_get_stats *)args,
+				   sizeof(prm))) {
+			pr_err("Could not copy from user stats params\n");
+			return -EINVAL;
+		}
+
+		if (prm.sa_id < 0) {
+			pr_err("Invalid input SA id\n");
+			return -EINVAL;
+		}
+
+		ret = dpa_ipsec_sa_get_stats(prm.sa_id, &prm.sa_stats);
+		if (ret < 0) {
+			pr_err("Getting stats failed\n");
+			break;
+		}
+
+		if (copy_to_user((struct ioc_dpa_ipsec_sa_get_stats *)args,
+				 &prm, sizeof(prm))) {
+			pr_err("Could not copy stats to user\n");
+			return -EINVAL;
+		}
+		break;
+	}
+
+	case DPA_IPSEC_IOC_SA_MODIFY: {
+		struct dpa_ipsec_sa_modify_prm modify_prm;
+		int sa_id, ret;
+
+		ret = do_sa_modify_ioctl(args, &sa_id, &modify_prm);
+
+		if (IS_ERR_VALUE(ret))
+			goto free;
+
+		ret = dpa_ipsec_sa_modify(sa_id, &modify_prm);
+		if (IS_ERR_VALUE(ret))
+			pr_err("Modifying SA %d failed\n", sa_id);
+free:
+		if (modify_prm.type == DPA_IPSEC_SA_MODIFY_CRYPTO) {
+			kfree(modify_prm.crypto_params.cipher_key);
+			kfree(modify_prm.crypto_params.auth_key);
+		}
+		break;
+	}
+	default:
+		pr_err("Invalid DPA IPsec ioctl\n");
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_COMPAT
+long wrp_dpa_ipsec_do_compat_ioctl(struct file *filp, unsigned int cmd,
+				   unsigned long args)
+{
+	long ret = 0;
+
+	switch (cmd) {
+	case DPA_IPSEC_IOC_INIT_COMPAT: {
+		struct ioc_dpa_ipsec_params kprm;
+		struct ioc_compat_dpa_ipsec_params uprm;
+
+		if (copy_from_user(&uprm, (void *)args, sizeof(uprm))) {
+			pr_err("Could not copy DPA IPSec init parameters\n");
+			return -EINVAL;
+		}
+		compat_copy_dpa_ipsec_init(&kprm, &uprm);
+
+		ret = do_init_ioctl(&kprm);
+		if (ret < 0)
+			return ret;
+
+		uprm.dpa_ipsec_id = kprm.dpa_ipsec_id;
+		if (copy_to_user((void *)args, &uprm, sizeof(uprm))) {
+			pr_err("Could not copy to user the DPA IPSec ID\n");
+			return -EINVAL;
+		}
+		break;
+	}
+
+	case DPA_IPSEC_IOC_FREE: {
+		int dpa_ipsec_id;
+		if (copy_from_user(&dpa_ipsec_id, (int *)args, sizeof(int))) {
+			pr_err("Could not copy parameters\n");
+			return -EINVAL;
+		}
+		ret = dpa_ipsec_free(dpa_ipsec_id);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_CREATE_SA_COMPAT: {
+		ret = do_create_sa_compat_ioctl((void *)args);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_REMOVE_SA: {
+		int sa_id;
+		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
+			pr_err("Could not copy parameters\n");
+			return -EINVAL;
+		}
+		ret = dpa_ipsec_remove_sa(sa_id);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_ADD_POLICY_COMPAT: {
+		ret = do_add_rem_policy_compat_ioctl((void *)args, true);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_REMOVE_POLICY_COMPAT: {
+		ret = do_add_rem_policy_compat_ioctl((void *)args, false);
+		break;
+	}
+
+	case DPA_IPSEC_IOC_SA_REKEYING_COMPAT: {
+		ret = do_sa_rekey_compat_ioctl((void *)args);
 		break;
 	}
 
@@ -1188,21 +1387,16 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 
 		if (copy_from_user(&dpa_ipsec_id,
 				    (int *)args, sizeof(int))) {
-			pr_err("Could not copy parameters");
+			pr_err("Could not copy parameters\n");
 			return -EINVAL;
 		}
 
-		err = dpa_ipsec_flush_all_sa(dpa_ipsec_id);
-		if (err < 0)
-			return err;
+		ret = dpa_ipsec_flush_all_sa(dpa_ipsec_id);
 		break;
 	}
 
-#ifdef CONFIG_COMPAT
-	case DPA_IPSEC_IOC_GET_SA_POLICIES_COMPAT:
-#endif
-	case DPA_IPSEC_IOC_GET_SA_POLICIES: {
-		ret = do_sa_get_policies_ioctl((void *)args, compat);
+	case DPA_IPSEC_IOC_GET_SA_POLICIES_COMPAT: {
+		ret = do_sa_get_policies_compat_ioctl((void *)args);
 		break;
 	}
 
@@ -1210,13 +1404,11 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		int sa_id;
 
 		if (copy_from_user(&sa_id, (int *)args, sizeof(int))) {
-			pr_err("Could not copy SA id");
+			pr_err("Could not copy SA id\n");
 			return -EINVAL;
 		}
 
-		err = dpa_ipsec_sa_flush_policies(sa_id);
-		if (err < 0)
-			return err;
+		ret = dpa_ipsec_sa_flush_policies(sa_id);
 		break;
 	}
 
@@ -1228,9 +1420,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 			return -EINVAL;
 		}
 
-		err = dpa_ipsec_disable_sa(sa_id);
-		if (err < 0)
-			return err;
+		ret = dpa_ipsec_disable_sa(sa_id);
 		break;
 	}
 
@@ -1240,7 +1430,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		if (copy_from_user(&prm,
 				(struct ioc_dpa_ipsec_sa_get_stats *)args,
 				sizeof(prm))) {
-			pr_err("Could not copy from user stats params");
+			pr_err("Could not copy from user stats params\n");
 			return -EINVAL;
 		}
 
@@ -1249,10 +1439,10 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 			return -EINVAL;
 		}
 
-		err = dpa_ipsec_sa_get_stats(prm.sa_id, &prm.sa_stats);
-		if (err < 0) {
+		ret = dpa_ipsec_sa_get_stats(prm.sa_id, &prm.sa_stats);
+		if (ret < 0) {
 			pr_err("Getting stats failed\n");
-			return err;
+			break;
 		}
 
 		if (copy_to_user((struct ioc_dpa_ipsec_sa_get_stats *)args,
@@ -1268,14 +1458,7 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		struct dpa_ipsec_sa_modify_prm modify_prm;
 		int sa_id, ret;
 
-#ifdef CONFIG_COMPAT
-		if (compat)
-			ret = do_sa_modify_ioctl_compat(args, &sa_id,
-							&modify_prm);
-		else
-#endif /* CONFIG_COMPAT */
-		ret = do_sa_modify_ioctl(args, &sa_id, &modify_prm);
-
+		ret = do_sa_modify_ioctl_compat(args, &sa_id, &modify_prm);
 		if (IS_ERR_VALUE(ret))
 			goto free;
 
@@ -1297,7 +1480,7 @@ free:
 
 	return ret;
 }
-
+#endif
 
 int default_rekey_event_cb(int dpa_ipsec_id, int sa_id, int error)
 {
-- 
2.0.2

