From 854abe343fe077cf5d8c82315972fd890b403f44 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Wed, 2 Apr 2014 17:15:56 +0300
Subject: [PATCH 39/50] gianfar: Fix suspend/resume for wol magic packet

Don't detach the interfaces that are already down.
Use correct sequence to stop Tx traffic and
to prevent Tx timeout, including napi disabling.
Use netif_tx_lock() to prevent races while stopping
Tx, replacing the driver specific lock_tx_qs() which
is not correct for this purpose.
Use gfar_halt() to correctly stop the traffic at
controller level (i.e. graceful stop the DMA).
Fix the invalid device references for the wakeup
routines, from the invalid &dev->dev references to
the correct &ofdev->dev (or priv->dev) references.
Remove buggy device_set_wakeup_enable() from the
open() routine.  Only the ethtool is allowed
to enable/disable the wol capabilities.
Remove superfluous priv->bflock lock, as it's not
justified.
Use IRQF_NO_SUSPEND to be able to wake up the system
by magic packet generated interrupts.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Change-Id: If9b4a878aa3ee6df8867bab9ca19d96b731e9fa9
Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/10728
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   75 ++++++++++++-----------------
 drivers/net/ethernet/freescale/gianfar.h |    3 -
 2 files changed, 31 insertions(+), 47 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index cad7c86..9df4b2c 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -1401,7 +1401,6 @@ static int gfar_probe(struct platform_device *ofdev)
 	priv->dev = &ofdev->dev;
 	SET_NETDEV_DEV(dev, &ofdev->dev);
 
-	spin_lock_init(&priv->bflock);
 	INIT_WORK(&priv->reset_task, gfar_reset_task);
 
 	platform_set_drvdata(ofdev, priv);
@@ -1495,9 +1494,8 @@ static int gfar_probe(struct platform_device *ofdev)
 	/* Carrier starts down, phylib will bring it up */
 	netif_carrier_off(dev);
 
-	device_init_wakeup(&dev->dev,
-			   priv->device_flags &
-			   FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+	device_set_wakeup_capable(&ofdev->dev, priv->device_flags &
+				  FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
 
 	/* fill out IRQ number and name fields */
 	for (i = 0; i < priv->num_grps; i++) {
@@ -1573,36 +1571,37 @@ static int gfar_suspend(struct device *dev)
 	struct gfar_private *priv = dev_get_drvdata(dev);
 	struct net_device *ndev = priv->ndev;
 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
-	int retval;
 	u32 tempval;
+	int magic_packet = priv->wol_en &&
+			   (priv->device_flags &
+			    FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
 
-	if (!priv->wol_opts && !netif_running(ndev))
+	if (!netif_running(ndev))
 		return 0;
 
-	netif_device_detach(ndev);
 	disable_napi(priv);
-	gfar_halt(ndev);
+	netif_tx_lock(ndev);
+	netif_device_detach(ndev);
+	netif_tx_unlock(ndev);
+
+	gfar_halt(priv);
+
+	if (magic_packet) {
+		/* Enable interrupt on Magic Packet */
+		gfar_write(&regs->imask, IMASK_MAG);
 
-	if (priv->wol_opts & GIANFAR_WOL_MAGIC) {
 		/* Enable Magic Packet mode */
 		tempval = gfar_read(&regs->maccfg2);
 		tempval |= MACCFG2_MPEN;
 		gfar_write(&regs->maccfg2, tempval);
-	}
-
-	if (priv->wol_opts & (GIANFAR_WOL_ARP | GIANFAR_WOL_UCAST)) {
-		mpc85xx_pmc_set_lossless_ethernet(1);
-		gfar_disable_filer(ndev);
-		gfar_config_filer_table(ndev);
-		gfar_enable_filer(ndev);
-	}
 
-	if (priv->wol_opts) {
-		retval = mpc85xx_pmc_set_wake(dev, true);
-		if (retval)
-			return retval;
+		/* re-enable the Rx block */
+		tempval = gfar_read(&regs->maccfg1);
+		tempval |= MACCFG1_RX_EN;
+		gfar_write(&regs->maccfg1, tempval);
 
-		gfar_rx_start(ndev);
+	} else {
+		phy_stop(priv->phydev);
 	}
 
 	return 0;
@@ -1613,38 +1612,28 @@ static int gfar_resume(struct device *dev)
 	struct gfar_private *priv = dev_get_drvdata(dev);
 	struct net_device *ndev = priv->ndev;
 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
-	u32 tempval, i;
+	u32 tempval;
+	int magic_packet = priv->wol_en &&
+			   (priv->device_flags &
+			    FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
 
-	if (!priv->wol_opts && !netif_running(ndev))
+	if (!netif_running(ndev))
 		return 0;
 
-	if (priv->wol_opts) {
-		mpc85xx_pmc_set_wake(dev, false);
-		gfar_halt_rx(ndev);
-	}
-
-	if (priv->wol_opts & GIANFAR_WOL_MAGIC) {
+	if (magic_packet) {
 		/* Disable Magic Packet mode */
 		tempval = gfar_read(&regs->maccfg2);
 		tempval &= ~MACCFG2_MPEN;
 		gfar_write(&regs->maccfg2, tempval);
-	}
-
-	if (priv->wol_opts & (GIANFAR_WOL_ARP | GIANFAR_WOL_UCAST)) {
-		mpc85xx_pmc_set_lossless_ethernet(0);
-		gfar_disable_filer(ndev);
-		gfar_restore_filer_table(ndev);
+	} else {
+		phy_start(priv->phydev);
 	}
 
 	gfar_start(priv);
-	enable_napi(priv);
+
 	netif_device_attach(ndev);
+	enable_napi(priv);
 
-	if (priv->wol_opts & (GIANFAR_WOL_ARP | GIANFAR_WOL_UCAST)) {
-		/* send requests to process the received packets */
-		for (i = 0; i < priv->num_grps; i++)
-			gfar_schedule_rx_cleanup(&priv->gfargrp[i]);
-	}
 	return 0;
 }
 
@@ -2482,8 +2471,6 @@ static int gfar_enet_open(struct net_device *dev)
 	if (err)
 		return err;
 
-	device_set_wakeup_enable(&priv->ofdev->dev, (bool)!!priv->wol_opts);
-
 	return err;
 }
 
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index ced6ee2..2b78b06 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1348,9 +1348,6 @@ struct gfar_private {
 	bool rx_pause;
 	bool tx_pause;
 
-	/* Bitfield update lock */
-	spinlock_t bflock;
-
 	uint32_t msg_enable;
 
 	struct work_struct reset_task;
-- 
1.7.5.4

