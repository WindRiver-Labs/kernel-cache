From 00e1f0579edde5ccb7067eb66a7782292bf665c5 Mon Sep 17 00:00:00 2001
From: "yadi.hu@windriver.com" <yadi.hu@windriver.com>
Date: Tue, 2 Jun 2015 16:55:27 +0800
Subject: [PATCH] qman: add sync protect when do kexec fast reboot

customer rarely observed below call trace.

 NIP [c0000000046c4040] .qman_delete_cgr+0x120/0x270
 LR [c0000000046c3fd8] .qman_delete_cgr+0xb8/0x270
Call Trace:
 [c0000000046c3fd8] .qman_delete_cgr+0xb8/0x270 (unreliable)
 [c00000000468cd40] .caam_qi_shutdown+0x210/0x300
 [c00000000468a1e4] .caam_remove+0xc4/0x420
 [c00000000449c36c] .platform_drv_shutdown+0x3c/0x60
 [c0000000044968e8] .device_shutdown+0x128/0x240
 [c00000000409d2a4] .kernel_restart_prepare+0x54/0x70
 [c00000000409d2e4] .kernel_restart+0x24/0xc0
 [c00000000409d570] .SyS_reboot+0x1c0/0x2d0
 [c000000004010718] syscall_exit+0x0/0x8c

In order to avoid this scenario,adding sync protect when do kexec
fast reboot.

Signed-off-by: Hu <yadi.hu@windriver.com>
---
 drivers/staging/fsl_qbman/qman_config.c |    3 +++
 drivers/staging/fsl_qbman/qman_high.c   |   14 ++++++++++++++
 include/linux/fsl_qman.h                |    5 +++++
 3 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index dfdb29a..da42b56 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -1130,9 +1130,12 @@ void of_fsl_qman_shutdown(struct platform_device *ofdev)
 {
 	int cpu;
 	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused; 
 	for_each_online_cpu(cpu) {
 		p = per_cpu_affine_portal(cpu);
+		qman_portal_lock(p,irqflags);
 		qman_static_dequeue_del_ex(p, ~0);
+		qman_portal_unlock(p,irqflags);
 	}
 	return;
 };
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 3896c89..609a793 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -419,6 +419,20 @@ static int qm_drain_dqrr(struct qm_portal *p)
 	qm_isr_status_clear(p, 0xffffffff);
 	return 0;
 }
+
+int qman_portal_lock(struct qman_portal *p,unsigned long irqflags)
+{
+    spin_lock_irqsave(&p->cgr_lock, irqflags);
+    return 0;
+
+}
+
+int qman_portal_unlock(struct qman_portal *p,unsigned long irqflags)
+{
+    spin_unlock_irqrestore(&p->cgr_lock, irqflags);
+    return 0;
+} 
+
 #else
 static inline int qm_drain_dqrr(struct qm_portal *p) { return 1; }
 #endif
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 2960bdc..25de4fb 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1772,6 +1772,11 @@ void qman_static_dequeue_del_ex(struct qman_portal *p, u32 pools);
  */
 struct qman_portal *per_cpu_affine_portal(int cpu);
 
+#if defined(CONFIG_KEXEC)
+
+int qman_portal_lock(struct qman_portal *p,unsigned long irqflags);
+int qman_portal_unlock(struct qman_portal *p,unsigned long irqflags) ;
+#endif
 /**
  * qman_static_dequeue_get - return the portal's current SDQCR
  *
-- 
1.7.5.4

