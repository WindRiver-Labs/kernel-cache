From 8ff44928f485c4023cbea8ceb173af652453d4a0 Mon Sep 17 00:00:00 2001
From: Horia Geanta <horia.geanta@freescale.com>
Date: Thu, 5 Dec 2013 23:09:27 +0200
Subject: [PATCH 0840/1089] crypto: caam - do not register algorithms for
 unsupported SEC Eras

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Commit 33de5f5c7455aea05b48d46f3024f78ecc83dc4b
(crypto: caam - add support for TLS 1.0 record)
added support for TLS 1.0 offloading, mentioning that the feature is
available for platforms having SEC Era 4 or above.

However, this doesn't stop one to actually run this feature on platforms
not supported (for e.g. P3041DS), leading to errors like:
platform ffe303000.jr: 40002807: DECO: desc idx 40: Invalid LOAD Command

Add a .min_era member for each algorithm registered by the driver,
specifying the lowest (compatible) SEC Era on which the descriptors
can run.

Change-Id: Idf929591361d244a4d7cd8352d0fb8ad7feff830
Signed-off-by: Horia Geanta <horia.geanta@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/7118
Reviewed-by: Mircea Pop <mircea.pop@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
(cherry picked from commit 351d2c869e446187bc78f47dccb0213f0a5e9f17)

Conflicts:
	drivers/crypto/caam/caamalg.c
	drivers/crypto/caam/ctrl.c
	drivers/crypto/caam/intern.h
Change-Id: I615578f0d0693eb46742e65004435821f6eb7de7
Reviewed-on: http://git.am.freescale.net:8181/10374
Reviewed-by: Cristian Stoica <cristian.stoica@freescale.com>
Reviewed-by: Mircea Pop <mircea.pop@freescale.com>
Reviewed-by: Alexandru Porosanu <alexandru.porosanu@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/crypto/caam/caamalg.c | 34 ++++++++++++++++++++++++++++++++--
 drivers/crypto/caam/ctrl.c    |  3 ++-
 drivers/crypto/caam/intern.h  |  2 ++
 3 files changed, 36 insertions(+), 3 deletions(-)

diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c
index 382a613..2bb3a9d 100644
--- a/drivers/crypto/caam/caamalg.c
+++ b/drivers/crypto/caam/caamalg.c
@@ -2287,6 +2287,7 @@ struct caam_alg_template {
 	u32 class1_alg_type;
 	u32 class2_alg_type;
 	u32 alg_op;
+	int min_era;
 };
 
 static struct caam_alg_template driver_algs[] = {
@@ -2309,6 +2310,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,
 		.class2_alg_type = OP_ALG_ALGSEL_MD5 | OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_MD5 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha1),cbc(aes))",
@@ -2328,6 +2330,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,
 		.class2_alg_type = OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha224),cbc(aes))",
@@ -2348,6 +2351,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA224 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA224 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha256),cbc(aes))",
@@ -2368,6 +2372,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA256 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA256 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha384),cbc(aes))",
@@ -2388,6 +2393,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA384 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA384 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 
 	{
@@ -2409,6 +2415,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA512 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA512 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(md5),cbc(des3_ede))",
@@ -2428,6 +2435,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,
 		.class2_alg_type = OP_ALG_ALGSEL_MD5 | OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_MD5 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha1),cbc(des3_ede))",
@@ -2447,6 +2455,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,
 		.class2_alg_type = OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha224),cbc(des3_ede))",
@@ -2467,6 +2476,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA224 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA224 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha256),cbc(des3_ede))",
@@ -2487,6 +2497,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA256 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA256 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha384),cbc(des3_ede))",
@@ -2507,6 +2518,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA384 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA384 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha512),cbc(des3_ede))",
@@ -2527,6 +2539,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA512 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA512 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(md5),cbc(des))",
@@ -2546,6 +2559,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,
 		.class2_alg_type = OP_ALG_ALGSEL_MD5 | OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_MD5 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha1),cbc(des))",
@@ -2565,6 +2579,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,
 		.class2_alg_type = OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha224),cbc(des))",
@@ -2585,6 +2600,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA224 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA224 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha256),cbc(des))",
@@ -2605,6 +2621,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA256 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA256 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha384),cbc(des))",
@@ -2625,6 +2642,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA384 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA384 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	{
 		.name = "authenc(hmac(sha512),cbc(des))",
@@ -2645,6 +2663,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class2_alg_type = OP_ALG_ALGSEL_SHA512 |
 				   OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA512 | OP_ALG_AAI_HMAC,
+		.min_era = 2,
 	},
 	/* TLS record descriptors */
 	{
@@ -2665,6 +2684,7 @@ static struct caam_alg_template driver_algs[] = {
 		.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,
 		.class2_alg_type = OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC_PRECOMP,
 		.alg_op = OP_ALG_ALGSEL_SHA1 | OP_ALG_AAI_HMAC,
+		.min_era = 4,
 	},
 	/* ablkcipher descriptor */
 	{
@@ -2682,6 +2702,7 @@ static struct caam_alg_template driver_algs[] = {
 			.ivsize = AES_BLOCK_SIZE,
 			},
 		.class1_alg_type = OP_ALG_ALGSEL_AES | OP_ALG_AAI_CBC,
+		.min_era = 2,
 	},
 	{
 		.name = "cbc(des3_ede)",
@@ -2698,6 +2719,7 @@ static struct caam_alg_template driver_algs[] = {
 			.ivsize = DES3_EDE_BLOCK_SIZE,
 			},
 		.class1_alg_type = OP_ALG_ALGSEL_3DES | OP_ALG_AAI_CBC,
+		.min_era = 2,
 	},
 	{
 		.name = "cbc(des)",
@@ -2714,6 +2736,7 @@ static struct caam_alg_template driver_algs[] = {
 			.ivsize = DES_BLOCK_SIZE,
 			},
 		.class1_alg_type = OP_ALG_ALGSEL_DES | OP_ALG_AAI_CBC,
+		.min_era = 2,
 	}
 };
 
@@ -2850,7 +2873,7 @@ static int __init caam_algapi_init(void)
 	struct device_node *dev_node;
 	struct platform_device *pdev;
 	struct device *ctrldev;
-	void *priv;
+	struct caam_drv_private *priv;
 	int i = 0, err = 0;
 
 	dev_node = of_find_compatible_node(NULL, NULL, "fsl,sec-v4.0");
@@ -2880,9 +2903,16 @@ static int __init caam_algapi_init(void)
 
 	/* register crypto algorithms the device supports */
 	for (i = 0; i < ARRAY_SIZE(driver_algs); i++) {
-		/* TODO: check if h/w supports alg */
 		struct caam_crypto_alg *t_alg;
 
+		/* check if h/w supports alg */
+		if (priv->era > 0 && priv->era < driver_algs[i].min_era) {
+			pr_warn("%s needs Era %d or higher but SEC is Era %d, skipping it\n",
+				driver_algs[i].driver_name,
+				driver_algs[i].min_era, priv->era);
+			continue;
+		}
+
 		t_alg = caam_alg_alloc(&driver_algs[i]);
 		if (IS_ERR(t_alg)) {
 			err = PTR_ERR(t_alg);
diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index 712a4c3..1099914 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -572,10 +572,11 @@ static int caam_probe(struct platform_device *pdev)
 	/* NOTE: RTIC detection ought to go here, around Si time */
 
 	caam_id = rd_reg64(&topregs->ctrl.perfmon.caam_id);
+	ctrlpriv->era = caam_get_era();
 
 	/* Report "alive" for developer to see */
 	dev_info(dev, "device ID = 0x%016llx (Era %d)\n", caam_id,
-		 caam_get_era());
+		 ctrlpriv->era);
 	dev_info(dev, "job rings = %d, qi = %d\n",
 		 ctrlpriv->total_jobrs, ctrlpriv->qi_present);
 
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index cbdef5e..ed0351d 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -93,6 +93,8 @@ struct caam_drv_private {
 	/* list of registered pkc algorithms */
 	struct list_head pkc_list;
 
+	int era;		/* SEC Era */
+
 #define	RNG4_MAX_HANDLES 2
 	/* RNG4 block */
 	u32 rng4_sh_init;	/* This bitmap shows which of the State
-- 
2.0.2

