From 29f76be5913152918b4ec4b626b6044cfb7f7e8a Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Sat, 28 Feb 2015 10:44:54 +0800
Subject: [PATCH 1/2] fsl: dpa: call kmalloc with GFP_ATOMIC

The kmalloc function may be called in atomic context in the
function dpa_alloc_new(), so call it with GFP_ATOMIC, else we would get
the below warning:

Freescale FM module (Feb 27 2015:16:54:22), FMD API version 21.1.0
DEBUG_LOCKS_WARN_ON(irqs_disabled_flags(flags))
------------[ cut here ]------------
WARNING: at kernel/lockdep.c:2740
Modules linked in:
CPU: 1 PID: 1 Comm: swapper/0 Not tainted 3.10.62-ltsi-WR6.0.0.0_standard #4
task: c0000000f9250000 ti: c0000000f924c000 task.ti: c0000000f924c000
NIP: c0000000000ef9d0 LR: c0000000000ef9cc CTR: c0000000005d2600
REGS: c0000000f924efb0 TRAP: 0700   Not tainted  (3.10.62-ltsi-WR6.0.0.0_standard)
MSR: 0000000080029000 <CE,EE,ME>  CR: 24ad4e82  XER: 00000000
SOFTE: 0

GPR00: c0000000000ef9cc c0000000f924f230 c0000000017bb658 000000000000002f
GPR04: c00000000006c8c0 c00000000006c248 0000000000000000 0000000000000002
GPR08: 0000000000000000 0000000000000000 c00000000166b658 c00000000163b658
GPR12: 0000000022ad4e84 c000000003fff780 c000000000001e50 0000000000000000
GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
GPR20: 0000000000000000 c0000000f936c7a0 c0000000f936c7c0 0000000000000001
GPR24: c0000000017cdbd8 0000000000000000 c0000000f9001c00 0000000000000020
GPR28: c00000000092dde0 c00000000166b528 0000000000000000 00000000000000d0
NIP [c0000000000ef9d0] .lockdep_trace_alloc+0x170/0x180
LR [c0000000000ef9cc] .lockdep_trace_alloc+0x16c/0x180
Call Trace:
[c0000000f924f230] [c0000000000ef9cc] .lockdep_trace_alloc+0x16c/0x180 (unreliable)
[c0000000f924f2c0] [c0000000001f6394] .kmem_cache_alloc_trace+0x64/0x420
[c0000000f924f380] [c00000000092dde0] .dpa_alloc_new+0x250/0x310
[c0000000f924f450] [c00000000093eeb8] .qman_create_fq+0x58/0x550
[c0000000f924f4e0] [c000000000752544] .FqAlloc.constprop.3+0x94/0x240
[c0000000f924f5b0] [c000000000752cec] .fm_port_probe+0x5fc/0x11f0
[c0000000f924f6c0] [c0000000005f1c9c] .platform_drv_probe+0x3c/0x60
[c0000000f924f740] [c0000000005ef840] .really_probe+0xb0/0x2d0
[c0000000f924f7e0] [c0000000005efc28] .__driver_attach+0x118/0x120
[c0000000f924f870] [c0000000005ecad4] .bus_for_each_dev+0x94/0x100
[c0000000f924f910] [c0000000005ef124] .driver_attach+0x34/0x50
[c0000000f924f990] [c0000000005eeb08] .bus_add_driver+0x288/0x380
[c0000000f924fa30] [c0000000005f0704] .driver_register+0x94/0x170
[c0000000f924fab0] [c0000000005f2728] .platform_driver_register+0x78/0x90
[c0000000f924fb30] [c000000000f4170c] .fm_port_load+0x1c/0x68
[c0000000f924fbb0] [c0000000000015f4] .do_one_initcall+0x164/0x1c0
[c0000000f924fc60] [c000000000f0ab48] .kernel_init_freeable+0x1f4/0x310
[c0000000f924fda0] [c000000000001e84] .kernel_init+0x34/0x11b0
[c0000000f924fe30] [c000000000000a14] .ret_from_kernel_thread+0x5c/0xc8
Instruction dump:
419eff60 3d420090 392abaa8 81290000 2f890000 40feff4c 3c62ff62 3c82ff63
3863fd18 3884c740 48a7b009 60000000 <0fe00000> 4bffff2c 60000000 60000000
---[ end trace ae4ebc5ddac7ebb4 ]---

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl_qbman/dpa_alloc.c |    8 ++++----
 1 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/drivers/staging/fsl_qbman/dpa_alloc.c b/drivers/staging/fsl_qbman/dpa_alloc.c
index e102368..6599fdc 100644
--- a/drivers/staging/fsl_qbman/dpa_alloc.c
+++ b/drivers/staging/fsl_qbman/dpa_alloc.c
@@ -457,10 +457,10 @@ int dpa_alloc_new(struct dpa_alloc *alloc, u32 *result, u32 count, u32 align,
 	/* If 'align' is 0, it should behave as though it was 1 */
 	if (!align)
 		align = 1;
-	margin_left = kmalloc(sizeof(*margin_left), GFP_KERNEL);
+	margin_left = kmalloc(sizeof(*margin_left), GFP_ATOMIC);
 	if (!margin_left)
 		goto err;
-	margin_right = kmalloc(sizeof(*margin_right), GFP_KERNEL);
+	margin_right = kmalloc(sizeof(*margin_right), GFP_ATOMIC);
 	if (!margin_right) {
 		kfree(margin_left);
 		goto err;
@@ -519,7 +519,7 @@ err:
 		return -ENOMEM;
 
 	/* Add the allocation to the used list with a refcount of 1 */
-	used_node = kmalloc(sizeof(*used_node), GFP_KERNEL);
+	used_node = kmalloc(sizeof(*used_node), GFP_ATOMIC);
 	if (!used_node) {
 		spin_unlock_irq(&alloc->lock);
 		return -ENOMEM;
@@ -659,7 +659,7 @@ int dpa_alloc_reserve(struct dpa_alloc *alloc, u32 base, u32 num)
 		}
 	}
 	/* Add the allocation to the used list with a refcount of 1 */
-	used_node = kmalloc(sizeof(*used_node), GFP_KERNEL);
+	used_node = kmalloc(sizeof(*used_node), GFP_ATOMIC);
 	if (!used_node) {
 		spin_unlock_irq(&alloc->lock);
 		return -ENOMEM;
-- 
1.7.5.4

