From ad77587ec84746090a32ddc7df7ba3ce9d3d8143 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Fri, 28 Nov 2014 17:44:20 +0800
Subject: [PATCH] mtd: spi-nor: add support for flag status register on Micron
 chips

commit c14deddec1fbd8c9757c53a49dbfd2dc83265f21 upstream

Some new Micron flash chips require reading the flag status register to
determine when operations have completed.

Furthermore, chips with multi-die stacks of the 65nm 256Mb QSPI also
require reading the status register before reading the flag status
register.

This patch adds support for the flag status register in the n25q512ax3
and n25q00 Micron QSPI flash chips.

Signed-off-by: Graham Moore <grmoore@altera.com>
Signed-off-by: Brian Norris <computersforpeace@gmail.com>
[Lu:WRL kernel didn't have wait_till_ready() callback in mtd_info struct,
introduce a new member in m25p struct to distinguish wait type.]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/mtd/devices/m25p80.c |   52 +++++++++++++++++++++++++++++++++++++++--
 1 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/drivers/mtd/devices/m25p80.c b/drivers/mtd/devices/m25p80.c
index f71f592..c1a3c59 100644
--- a/drivers/mtd/devices/m25p80.c
+++ b/drivers/mtd/devices/m25p80.c
@@ -51,6 +51,7 @@
 #define	OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
 #define	OPCODE_RDID		0x9f	/* Read JEDEC ID */
 #define	OPCODE_RDCR             0x35    /* Read configuration register */
+#define SPINOR_OP_RDFSR		0x70	/* Read flag status register */
 
 /* 4-byte address opcodes - used on Spansion and some Macronix flashes. */
 #define	OPCODE_NORM_READ_4B	0x13	/* Read data bytes (low frequency) */
@@ -82,6 +83,9 @@
 
 #define SR_QUAD_EN_MX           0x40    /* Macronix Quad I/O */
 
+/* Flag Status Register bits */
+#define FSR_READY		0x80
+
 /* Configuration Register bits. */
 #define CR_QUAD_EN_SPAN		0x2     /* Spansion Quad I/O */
 
@@ -99,6 +103,11 @@ enum read_type {
 	M25P80_QUAD,
 };
 
+enum wait_type {
+	M25P80_WAIT_NORMAL = 0,
+	M25P80_WAIT_FSR,
+};
+
 struct m25p {
 	struct spi_device	*spi;
 	struct mutex		lock;
@@ -110,6 +119,7 @@ struct m25p {
 	u8			program_opcode;
 	u8			*command;
 	enum read_type		flash_read;
+	enum wait_type		flash_wait;
 };
 
 static inline struct m25p *mtd_to_m25p(struct mtd_info *mtd)
@@ -146,6 +156,26 @@ static int read_sr(struct m25p *flash)
 }
 
 /*
+ * Read the flag status register, returning its value in the location
+ * Return the status register value.
+ * Returns negative if error occurred.
+ */
+static int read_fsr(struct m25p *flash)
+{
+	u8 code = SPINOR_OP_RDFSR;
+	int ret;
+	u8 val;
+
+	ret = spi_write_then_read(flash->spi, &code, 1, &val, 1);
+	if (ret < 0) {
+		dev_err(&flash->spi->dev, "error %d reading FSR\n", ret);
+		return ret;
+	}
+
+	return val;
+}
+
+/*
  * Read configuration register, returning its value in the
  * location. Return the configuration register value.
  * Returns negative if error occured.
@@ -237,6 +267,7 @@ static inline int set_4byte(struct m25p *flash, u32 jedec_id, int enable)
 static int wait_till_ready(struct m25p *flash)
 {
 	unsigned long deadline;
+	int fsr;
 	int sr;
 
 	deadline = jiffies + MAX_READY_WAIT_JIFFIES;
@@ -244,8 +275,16 @@ static int wait_till_ready(struct m25p *flash)
 	do {
 		if ((sr = read_sr(flash)) < 0)
 			break;
-		else if (!(sr & SR_WIP))
-			return 0;
+		else if (!(sr & SR_WIP)) {
+			if (flash->flash_wait ==  M25P80_WAIT_FSR) {
+				fsr = read_fsr(flash);
+				if (fsr < 0)
+					break;
+				if (fsr & FSR_READY)
+					return 0;
+			} else
+				return 0;
+		}
 
 		cond_resched();
 
@@ -857,6 +896,7 @@ struct flash_info {
 #define	M25P_NO_FR	0x08		/* Can't do fastread */
 #define	SECT_4K_PMC	0x10		/* OPCODE_BE_4K_PMC works uniformly */
 #define	M25P80_QUAD_READ	0x20    /* Flash supports Quad Read */
+#define	USE_FSR			0x80	/* use flag status register */
 };
 
 #define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
@@ -943,7 +983,8 @@ static const struct spi_device_id m25p_ids[] = {
 	{ "n25q128a13",  INFO(0x20ba18, 0, 64 * 1024,  256, 0) },
 	{ "n25q256a",    INFO(0x20ba19, 0, 64 * 1024,  512, SECT_4K) },
 	{ "n25q512a",    INFO(0x20bb20, 0, 64 * 1024, 1024, SECT_4K) },
-	{ "n25q512a",    INFO(0x20ba20, 0, 64 * 1024, 1024, SECT_4K) },
+	{ "n25q512ax3",  INFO(0x20ba20, 0, 64 * 1024, 1024, USE_FSR) },
+	{ "n25q00",      INFO(0x20ba21, 0, 64 * 1024, 2048, USE_FSR) },
 
 	/* PMC */
 	{ "pm25lv512",   INFO(0,        0, 32 * 1024,    2, SECT_4K_PMC) },
@@ -1205,6 +1246,11 @@ static int m25p_probe(struct spi_device *spi)
 	else
 		flash->mtd._write = m25p80_write;
 
+	if (info->flags & USE_FSR)
+		flash->flash_wait = M25P80_WAIT_FSR;
+	else
+		flash->flash_wait = M25P80_WAIT_NORMAL;
+
 	/* prefer "small sector" erase if possible */
 	if (info->flags & SECT_4K) {
 		flash->erase_opcode = OPCODE_BE_4K;
-- 
1.7.5.4

