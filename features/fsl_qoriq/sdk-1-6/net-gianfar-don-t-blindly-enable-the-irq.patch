From d5511f9493fdd1d6a851235e0fa11b6be56cec51 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Tue, 19 Nov 2013 16:27:50 +0800
Subject: [PATCH 1/2] net/gianfar: don't blindly enable the irq

The function gfar_poll_tx/rx() and gfar_start_xmit may be used in
a irq disabled context, such as netconsole, kgdboe. So the using
of spin_lock/unlock_irq in them is definitely wrong. Replace them
with spin_lock_irqsave and spin_unlock_irqrestore.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   29 +++++++++++++++++------------
 1 files changed, 17 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index be00c2e..00eb75e 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -2466,6 +2466,7 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	int skb_curtx = 0;
 #endif
 	unsigned int nr_frags, nr_txbds, bytes_sent, fcb_len = 0;
+	unsigned long flags;
 
 #ifdef CONFIG_RX_TX_BUFF_XCHG
 	rq = smp_processor_id() + 1;
@@ -2537,11 +2538,11 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 			/* BD not free for tx */
 			netif_tx_stop_queue(txq);
 			dev->stats.tx_fifo_errors++;
-			spin_lock_irq(&tx_queue->grp->grplock);
+			spin_lock_irqsave(&tx_queue->grp->grplock, flags);
 			imask = gfar_read(&regs->imask);
 			imask |= IMASK_TX_DEFAULT;
 			gfar_write(&regs->imask, imask);
-			spin_unlock_irq(&tx_queue->grp->grplock);
+			spin_unlock_irqrestore(&tx_queue->grp->grplock, flags);
 			return NETDEV_TX_BUSY;
 		}
 
@@ -2718,10 +2719,10 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	 * space, that's because outside of this function it can only grow,
 	 * and once we've got needed space, it cannot suddenly disappear.
 	 */
-	spin_lock_bh(&tx_queue->txlock);
+	spin_lock_irqsave(&tx_queue->txlock, flags);
 	/* reduce TxBD free count */
 	tx_queue->num_txbdfree -= (nr_txbds);
-	spin_unlock_bh(&tx_queue->txlock);
+	spin_unlock_irqrestore(&tx_queue->txlock, flags);
 
 	/* If the next BD still needs to be cleaned up, then the bds
 	 * are full.  We need to tell the kernel to stop sending us stuff.
@@ -3376,6 +3377,7 @@ static int gfar_poll_rx_sq(struct napi_struct *napi, int budget)
 	struct gfar __iomem *regs = gfargrp->regs;
 	struct gfar_priv_rx_q *rx_queue = gfargrp->rx_queue;
 	int work_done = 0;
+	unsigned long flags;
 
 	/* Clear IEVENT, so interrupts aren't called again
 	 * because of the packets that have already arrived
@@ -3390,11 +3392,11 @@ static int gfar_poll_rx_sq(struct napi_struct *napi, int budget)
 		/* Clear the halt bit in RSTAT */
 		gfar_write(&regs->rstat, gfargrp->rstat);
 
-		spin_lock_irq(&gfargrp->grplock);
+		spin_lock_irqsave(&gfargrp->grplock, flags);
 		imask = gfar_read(&regs->imask);
 		imask |= IMASK_RX_DEFAULT;
 		gfar_write(&regs->imask, imask);
-		spin_unlock_irq(&gfargrp->grplock);
+		spin_unlock_irqrestore(&gfargrp->grplock, flags);
 	}
 
 	return work_done;
@@ -3407,6 +3409,7 @@ static int gfar_poll_tx_sq(struct napi_struct *napi, int budget)
 	struct gfar __iomem *regs = gfargrp->regs;
 	struct gfar_priv_tx_q *tx_queue = gfargrp->tx_queue;
 	u32 imask;
+	unsigned long flags;
 
 	/* Clear IEVENT, so interrupts aren't called again
 	 * because of the packets that have already arrived
@@ -3419,11 +3422,11 @@ static int gfar_poll_tx_sq(struct napi_struct *napi, int budget)
 
 	napi_complete(napi);
 
-	spin_lock_irq(&gfargrp->grplock);
+	spin_lock_irqsave(&gfargrp->grplock, flags);
 	imask = gfar_read(&regs->imask);
 	imask |= IMASK_TX_DEFAULT;
 	gfar_write(&regs->imask, imask);
-	spin_unlock_irq(&gfargrp->grplock);
+	spin_unlock_irqrestore(&gfargrp->grplock, flags);
 
 	return 0;
 }
@@ -3476,16 +3479,17 @@ static int gfar_poll_rx(struct napi_struct *napi, int budget)
 
 	if (!num_act_queues) {
 		u32 imask;
+		unsigned long flags;
 		napi_complete(napi);
 
 		/* Clear the halt bit in RSTAT */
 		gfar_write(&regs->rstat, gfargrp->rstat);
 
-		spin_lock_irq(&gfargrp->grplock);
+		spin_lock_irqsave(&gfargrp->grplock, flags);
 		imask = gfar_read(&regs->imask);
 		imask |= IMASK_RX_DEFAULT;
 		gfar_write(&regs->imask, imask);
-		spin_unlock_irq(&gfargrp->grplock);
+		spin_unlock_irqrestore(&gfargrp->grplock, flags);
 	}
 
 	return work_done;
@@ -3500,6 +3504,7 @@ static int gfar_poll_tx(struct napi_struct *napi, int budget)
 	struct gfar_priv_tx_q *tx_queue = NULL;
 	int has_tx_work = 0;
 	int i;
+	unsigned long flags;
 
 	/* Clear IEVENT, so interrupts aren't called again
 	 * because of the packets that have already arrived
@@ -3519,11 +3524,11 @@ static int gfar_poll_tx(struct napi_struct *napi, int budget)
 		u32 imask;
 		napi_complete(napi);
 
-		spin_lock_irq(&gfargrp->grplock);
+		spin_lock_irqsave(&gfargrp->grplock, flags);
 		imask = gfar_read(&regs->imask);
 		imask |= IMASK_TX_DEFAULT;
 		gfar_write(&regs->imask, imask);
-		spin_unlock_irq(&gfargrp->grplock);
+		spin_unlock_irqrestore(&gfargrp->grplock, flags);
 	}
 
 	return 0;
-- 
1.7.5.4

