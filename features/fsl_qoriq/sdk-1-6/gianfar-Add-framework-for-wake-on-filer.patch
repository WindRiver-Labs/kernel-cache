From 5d4e1184fe13065cfdf7a13d7f51b136c8a859dc Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Thu, 3 Apr 2014 18:11:22 +0300
Subject: [PATCH 41/50] gianfar: Add framework for "wake-on-filer"

This framework enables eTSEC's filer and the FGPI Rx
interrupt (Filer General Purpose Interrupt) as a wakeup
source event.

Upon entering suspend state, the eTSEC filer can be
programmed with various match rules for the Rx packets.
For example, the rules could be matching incoming unicast
or arp packets.  If a packet matches one of the rules, it
will be enqueued in the Rx ring and a FGPI interrupt will
be generated by the filer to wakeup the system. The packet
types not matching the rules will be dropped.
The rules need to be added as filer scripts inside
gfar_filer_config_wol() to implement different WOL
capabilities.
The "fsl,wake-on-filer" DT binding limits this
capability to certain platforms only.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Cc: Li Yang <leoli@freescale.com>
Cc: Zhao Chenhui <chenhui.zhao@freescale.com>

Change-Id: Ida38d2210975a8523e4da4fc4667de4380c2b9d4
Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/10730
Reviewed-by: Yang Li <LeoLi@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c         |  170 +++++++++++++++++++---
 drivers/net/ethernet/freescale/gianfar.h         |   13 +-
 drivers/net/ethernet/freescale/gianfar_ethtool.c |   50 +++---
 3 files changed, 186 insertions(+), 47 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 9df4b2c..18f1900 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -154,6 +154,7 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit);
 static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue);
 static void gfar_process_frame(struct net_device *dev, struct sk_buff *skb,
 			       int amount_pull, struct napi_struct *napi);
+static int __gfar_is_rx_idle(struct gfar_private *priv);
 static void gfar_halt_nodisable(struct gfar_private *priv);
 static void gfar_clear_exact_match(struct net_device *dev);
 static void gfar_set_mac_for_addr(struct net_device *dev, int num,
@@ -429,7 +430,7 @@ static void gfar_mac_rx_config(struct gfar_private *priv)
 	u32 rctrl = 0;
 
 	if (priv->rx_filer_enable) {
-		rctrl |= RCTRL_FILREN;
+		rctrl |= RCTRL_FILREN | RCTRL_PRSDEP_INIT;
 		/* Program the RIR0 reg with the required distribution */
 		if (priv->poll_mode == GFAR_SQ_POLLING)
 			gfar_write(&regs->rir0, DEFAULT_2RXQ_RIR0);
@@ -454,10 +455,10 @@ static void gfar_mac_rx_config(struct gfar_private *priv)
 
 	/* Enable HW time stamping if requested from user space */
 	if (priv->hwts_rx_en)
-		rctrl |= RCTRL_PRSDEP_INIT | RCTRL_TS_ENABLE;
+		rctrl |= RCTRL_TS_ENABLE;
 
 	if (priv->ndev->features & NETIF_F_HW_VLAN_CTAG_RX)
-		rctrl |= RCTRL_VLEX | RCTRL_PRSDEP_INIT;
+		rctrl |= RCTRL_VLEX;
 
 	/* Init rctrl based on our settings */
 	gfar_write(&regs->rctrl, rctrl);
@@ -951,10 +952,8 @@ static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 		priv->wol_supported |= GIANFAR_WOL_MAGIC;
 	}
 
-	if (of_get_property(np, "fsl,wake-on-filer", NULL)) {
-		priv->wol_supported |= GIANFAR_WOL_ARP;
-		priv->wol_supported |= GIANFAR_WOL_UCAST;
-	}
+	if (of_get_property(np, "fsl,wake-on-filer", NULL))
+		priv->device_flags |= FSL_GIANFAR_DEV_HAS_WAKE_ON_FILER;
 
 	priv->phy_node = of_parse_phandle(np, "phy-handle", 0);
 
@@ -1494,8 +1493,14 @@ static int gfar_probe(struct platform_device *ofdev)
 	/* Carrier starts down, phylib will bring it up */
 	netif_carrier_off(dev);
 
-	device_set_wakeup_capable(&ofdev->dev, priv->device_flags &
-				  FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MAGIC_PACKET)
+		priv->wol_supported |= GFAR_WOL_MAGIC;
+
+	if ((priv->device_flags & FSL_GIANFAR_DEV_HAS_WAKE_ON_FILER) &&
+	     priv->rx_filer_enable)
+		priv->wol_supported |= 0;
+
+	device_set_wakeup_capable(&ofdev->dev, priv->wol_supported);
 
 	/* fill out IRQ number and name fields */
 	for (i = 0; i < priv->num_grps; i++) {
@@ -1566,15 +1571,130 @@ static int gfar_remove(struct platform_device *ofdev)
 }
 
 #ifdef CONFIG_PM
+static void __gfar_filer_disable(struct gfar_private *priv)
+{
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 temp;
+
+	temp = gfar_read(&regs->rctrl);
+	temp &= ~(RCTRL_FILREN | RCTRL_PRSDEP_INIT);
+	gfar_write(&regs->rctrl, temp);
+}
+
+static void __gfar_filer_enable(struct gfar_private *priv)
+{
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 temp;
+
+	temp = gfar_read(&regs->rctrl);
+	temp |= RCTRL_FILREN | RCTRL_PRSDEP_INIT;
+	gfar_write(&regs->rctrl, temp);
+}
+
+static void gfar_filer_config_wol(struct gfar_private *priv)
+{
+	u32 rqfcr, rqfpr;
+	unsigned int i;
+
+	__gfar_filer_disable(priv);
+
+	/* init filer table */
+	rqfcr = RQFCR_RJE | RQFCR_CMP_MATCH;
+	rqfpr = 0x0;
+	for (i = 0; i <= MAX_FILER_IDX; i++)
+		gfar_write_filer(priv, i, rqfcr, rqfpr);
+
+	__gfar_filer_enable(priv);
+}
+
+static void gfar_filer_restore_table(struct gfar_private *priv)
+{
+	u32 rqfcr, rqfpr;
+	unsigned int i;
+
+	__gfar_filer_disable(priv);
+
+	for (i = 0; i <= MAX_FILER_IDX; i++) {
+		rqfcr = priv->ftp_rqfcr[i];
+		rqfpr = priv->ftp_rqfpr[i];
+		gfar_write_filer(priv, i, rqfcr, rqfpr);
+	}
+
+	__gfar_filer_enable(priv);
+}
+
+void gfar_start_wol_filer(struct gfar_private *priv)
+{
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 tempval;
+	int i = 0;
+
+	/* Enable Rx hw queues */
+	gfar_write(&regs->rqueue, priv->rqueue);
+
+	/* Initialize DMACTRL to have WWR and WOP */
+	tempval = gfar_read(&regs->dmactrl);
+	tempval |= DMACTRL_INIT_SETTINGS;
+	gfar_write(&regs->dmactrl, tempval);
+
+	/* Make sure we aren't stopped */
+	tempval = gfar_read(&regs->dmactrl);
+	tempval &= ~DMACTRL_GRS;
+	gfar_write(&regs->dmactrl, tempval);
+
+	for (i = 0; i < priv->num_grps; i++) {
+		regs = priv->gfargrp[i].regs;
+		/* Clear RHLT, so that the DMA starts polling now */
+		gfar_write(&regs->rstat, priv->gfargrp[i].rstat);
+		/* enable the filer general purpose interrupts */
+		gfar_write(&regs->imask, IMASK_FGPI);
+	}
+
+	/* Enable Rx/Tx DMA */
+	tempval = gfar_read(&regs->maccfg1);
+	tempval |= MACCFG1_RX_EN;
+	gfar_write(&regs->maccfg1, tempval);
+}
+
+void gfar_halt_wol_filer(struct gfar_private *priv)
+{
+	struct gfar __iomem *regs = priv->gfargrp[0].regs;
+	u32 tempval;
+
+	/* Dissable the Rx hw queues */
+	gfar_write(&regs->rqueue, 0);
+
+	gfar_ints_disable(priv);
+
+	/* Stop the DMA, and wait for it to stop */
+	tempval = gfar_read(&regs->dmactrl);
+	if (!(tempval & DMACTRL_GRS)) {
+		int ret;
+
+		tempval |= DMACTRL_GRS;
+		gfar_write(&regs->dmactrl, tempval);
+
+		do {
+			ret = spin_event_timeout((gfar_read(&regs->ievent) &
+						  IEVENT_GRSC), 1000000, 0);
+			if (!ret && !(gfar_read(&regs->ievent) & IEVENT_GRSC))
+				ret = __gfar_is_rx_idle(priv);
+		} while (!ret);
+	}
+
+	/* Disable Rx DMA */
+	tempval = gfar_read(&regs->maccfg1);
+	tempval &= ~MACCFG1_RX_EN;
+	gfar_write(&regs->maccfg1, tempval);
+}
+
 static int gfar_suspend(struct device *dev)
 {
 	struct gfar_private *priv = dev_get_drvdata(dev);
 	struct net_device *ndev = priv->ndev;
 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
 	u32 tempval;
-	int magic_packet = priv->wol_en &&
-			   (priv->device_flags &
-			    FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+	u16 wol = priv->wol_opts;
 
 	if (!netif_running(ndev))
 		return 0;
@@ -1586,7 +1706,7 @@ static int gfar_suspend(struct device *dev)
 
 	gfar_halt(priv);
 
-	if (magic_packet) {
+	if (wol & GFAR_WOL_MAGIC) {
 		/* Enable interrupt on Magic Packet */
 		gfar_write(&regs->imask, IMASK_MAG);
 
@@ -1600,6 +1720,10 @@ static int gfar_suspend(struct device *dev)
 		tempval |= MACCFG1_RX_EN;
 		gfar_write(&regs->maccfg1, tempval);
 
+	} else if (wol & (GFAR_WOL_FILER_UCAST | GFAR_WOL_FILER_ARP)) {
+		gfar_filer_config_wol(priv);
+		gfar_start_wol_filer(priv);
+
 	} else {
 		phy_stop(priv->phydev);
 	}
@@ -1613,18 +1737,21 @@ static int gfar_resume(struct device *dev)
 	struct net_device *ndev = priv->ndev;
 	struct gfar __iomem *regs = priv->gfargrp[0].regs;
 	u32 tempval;
-	int magic_packet = priv->wol_en &&
-			   (priv->device_flags &
-			    FSL_GIANFAR_DEV_HAS_MAGIC_PACKET);
+	u16 wol = priv->wol_opts;
 
 	if (!netif_running(ndev))
 		return 0;
 
-	if (magic_packet) {
+	if (wol & GFAR_WOL_MAGIC) {
 		/* Disable Magic Packet mode */
 		tempval = gfar_read(&regs->maccfg2);
 		tempval &= ~MACCFG2_MPEN;
 		gfar_write(&regs->maccfg2, tempval);
+
+	} else if (wol & (GFAR_WOL_FILER_UCAST | GFAR_WOL_FILER_ARP)) {
+		gfar_halt_wol_filer(priv);
+		gfar_filer_restore_table(priv);
+
 	} else {
 		phy_start(priv->phydev);
 	}
@@ -3222,7 +3349,14 @@ irqreturn_t gfar_receive(int irq, void *grp_id)
 {
 	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
 	unsigned long flags;
-	u32 imask;
+	u32 imask, ievent;
+
+	ievent = gfar_read(&grp->regs->ievent);
+
+	if (unlikely(ievent & IEVENT_FGPI)) {
+		gfar_write(&grp->regs->ievent, IEVENT_FGPI);
+		return IRQ_HANDLED;
+	}
 
 	if (likely(napi_schedule_prep(&grp->napi_rx))) {
 		spin_lock_irqsave(&grp->grplock, flags);
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 2b78b06..f851b31 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -631,6 +631,10 @@ extern const char gfar_driver_version[];
 
 #define GFAR_INT_NAME_MAX	(IFNAMSIZ + 6)	/* '_g#_xx' */
 
+#define GFAR_WOL_MAGIC		0x00000001
+#define GFAR_WOL_FILER_UCAST	0x00000002
+#define GFAR_WOL_FILER_ARP	0x00000004
+
 struct txbd8
 {
 	union {
@@ -1081,6 +1085,7 @@ struct gfar {
 #define FSL_GIANFAR_DEV_HAS_BD_STASHING		0x00000200
 #define FSL_GIANFAR_DEV_HAS_BUF_STASHING	0x00000400
 #define FSL_GIANFAR_DEV_HAS_TIMER		0x00000800
+#define FSL_GIANFAR_DEV_HAS_WAKE_ON_FILER	0x00001000
 
 #if defined CONFIG_FSL_GIANFAR_1588
 #define FSL_GIANFAR_DEV_HAS_TS_TO_BUFFER	0x00001000
@@ -1357,8 +1362,6 @@ struct gfar_private {
 		extended_hash:1,
 		bd_stash_en:1,
 		rx_filer_enable:1,
-		/* Wake-on-LAN enabled */
-		wol_en:1,
 		/* Enable priorty based Tx scheduling in Hw */
 		prio_sched_en:1,
 		/* Flow control flags */
@@ -1372,8 +1375,6 @@ struct gfar_private {
 	struct list_head recycle_node;
 
 	u32 ip_addr;       /* the primary IP address of the device */
-	u32 wol_opts;      /* enabled Wake-on-Lan modes */
-	u32 wol_supported; /* supported Wake-on-Lan modes */
 
 	/* The total tx and rx ring size for the enabled queues */
 	unsigned int total_tx_ring_size;
@@ -1396,6 +1397,10 @@ struct gfar_private {
 	u32 __iomem *hash_regs[16];
 	int hash_width;
 
+	/* wake-on-lan settings */
+	u16 wol_opts;
+	u16 wol_supported;
+
 	/*Filer table*/
 	unsigned int ftp_rqfpr[MAX_FILER_IDX + 1];
 	unsigned int ftp_rqfcr[MAX_FILER_IDX + 1];
diff --git a/drivers/net/ethernet/freescale/gianfar_ethtool.c b/drivers/net/ethernet/freescale/gianfar_ethtool.c
index 035e0e8..6a9092e 100644
--- a/drivers/net/ethernet/freescale/gianfar_ethtool.c
+++ b/drivers/net/ethernet/freescale/gianfar_ethtool.c
@@ -640,53 +640,53 @@ static void gfar_get_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 {
 	struct gfar_private *priv = netdev_priv(dev);
 
-	wol->supported = 0;
-	wol->wolopts = 0;
+	wol->supported = wol->wolopts = 0;
 
-	if (!priv->wol_supported || !device_can_wakeup(&priv->ofdev->dev))
-		return;
-
-	if (priv->wol_supported & GIANFAR_WOL_MAGIC)
+	if (priv->wol_supported & GFAR_WOL_MAGIC)
 		wol->supported |= WAKE_MAGIC;
 
-	if (priv->wol_supported & GIANFAR_WOL_ARP)
-		wol->supported |= WAKE_ARP;
-
-	if (priv->wol_supported & GIANFAR_WOL_UCAST)
+	if (priv->wol_supported & GFAR_WOL_FILER_UCAST)
 		wol->supported |= WAKE_UCAST;
 
-	if (priv->wol_opts & GIANFAR_WOL_MAGIC)
-		wol->wolopts |= WAKE_MAGIC;
+	if (priv->wol_supported & GFAR_WOL_FILER_ARP)
+		wol->supported |= WAKE_ARP;
 
-	if (priv->wol_opts & GIANFAR_WOL_ARP)
-		wol->wolopts |= WAKE_ARP;
+	if (priv->wol_opts & GFAR_WOL_MAGIC)
+		wol->wolopts |= WAKE_MAGIC;
 
-	if (priv->wol_opts & GIANFAR_WOL_UCAST)
+	if (priv->wol_opts & GFAR_WOL_FILER_UCAST)
 		wol->wolopts |= WAKE_UCAST;
+
+	if (priv->wol_opts & GFAR_WOL_FILER_ARP)
+		wol->wolopts |= WAKE_ARP;
 }
 
 static int gfar_set_wol(struct net_device *dev, struct ethtool_wolinfo *wol)
 {
 	struct gfar_private *priv = netdev_priv(dev);
 	int err;
+	u16 wol_opts = 0;
 
-	if (!priv->wol_supported || !device_can_wakeup(&priv->ofdev->dev) ||
-		(wol->wolopts & ~(WAKE_MAGIC | WAKE_ARP | WAKE_UCAST)))
-		return -EOPNOTSUPP;
+	if (!priv->wol_supported && wol->wolopts)
+		return -EINVAL;
 
-	priv->wol_opts = 0;
+	if (wol->wolopts & ~(WAKE_MAGIC | WAKE_UCAST | WAKE_ARP))
+		return -EINVAL;
 
 	if (wol->wolopts & WAKE_MAGIC) {
-		priv->wol_opts |= GIANFAR_WOL_MAGIC;
+		wol_opts |= GFAR_WOL_MAGIC;
 	} else {
-		if (wol->wolopts & WAKE_ARP)
-			priv->wol_opts |= GIANFAR_WOL_ARP;
 		if (wol->wolopts & WAKE_UCAST)
-			priv->wol_opts |= GIANFAR_WOL_UCAST;
+			wol_opts |= GFAR_WOL_FILER_UCAST;
+		if (wol->wolopts & WAKE_ARP)
+			wol_opts |= GFAR_WOL_FILER_ARP;
 	}
-	device_set_wakeup_enable(&priv->ofdev->dev, (bool)!!priv->wol_opts);
 
-	err = mpc85xx_pmc_set_wake(priv->dev, wol->wolopts & WAKE_MAGIC);
+	priv->wol_opts = wol_opts & priv->wol_supported;
+
+	device_set_wakeup_enable(priv->dev, priv->wol_opts);
+
+	err = mpc85xx_pmc_set_wake(priv->dev, priv->wol_opts);
 	if (err) {
 		device_set_wakeup_enable(priv->dev, false);
 		return err;
-- 
1.7.5.4

