From 6fa84cf895c6744539d8824b1b270a8a91e85fd5 Mon Sep 17 00:00:00 2001
From: Yangbo Lu <yangbo.lu@freescale.com>
Date: Fri, 28 Mar 2014 16:35:24 +0800
Subject: [PATCH 34/50] gianfar: Add IEEE 1588 V2 support

This patch integrates the IEEE 1588 specification v2 ioctls with
the gianfar driver. The user space application should be IXXAT
IEEE1588 stack v1.04 or above.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Signed-off-by: Sandeep Gopalpet <sandeep.kumar@freescale.com>
Signed-off-by: Bhaskar Upadhaya <Bhaskar.Upadhaya@freescale.com>
Signed-off-by: Yangbo Lu <yangbo.lu@freescale.com>
Signed-off-by: Xie Xiaobo <X.Xie@freescale.com>
Change-Id: Ic7c3b4f2d5dd92d4e8e82dea3d41df8e75cf3559
Reviewed-on: http://git.am.freescale.net:8181/10331
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/ethernet/freescale/Kconfig   |   10 ++
 drivers/net/ethernet/freescale/Makefile  |    1 +
 drivers/net/ethernet/freescale/gianfar.c |  100 +++++++++++++++-
 drivers/net/ethernet/freescale/gianfar.h |  188 +++++++++++++++++++++++++++++-
 4 files changed, 292 insertions(+), 7 deletions(-)

diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index 5fe0588..01f8b1e 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -94,6 +94,16 @@ config GIANFAR
 	---help---
 	  This driver supports the Gigabit TSEC on the MPC83xx, MPC85xx,
 	  and MPC86xx family of chips, and the FEC on the 8540.
+
+config FSL_GIANFAR_1588
+	bool "Gianfar 1588"
+	depends on GIANFAR
+	---help---
+	  This driver supports Freescale eTSEC 1588 function.
+	  Integrate the IEEE 1588 specification v2 ioctls with the gianfar driver.
+	  The user space application should be IXXAT IEEE 1588 stack v1.04 or above.
+	  Say Y here if you want to use IXXAT 1588 stack.
+
 config RX_TX_BUFF_XCHG
         default y
 	 bool "RX and TX ring buffer exchange for Routed packets"
diff --git a/drivers/net/ethernet/freescale/Makefile b/drivers/net/ethernet/freescale/Makefile
index 3092ee1..ec83354 100644
--- a/drivers/net/ethernet/freescale/Makefile
+++ b/drivers/net/ethernet/freescale/Makefile
@@ -17,5 +17,6 @@ obj-$(if $(CONFIG_FSL_DPAA_ETH),y) += dpa/
 obj-$(CONFIG_PTP_1588_CLOCK_GIANFAR) += gianfar_ptp.o
 gianfar_driver-objs := gianfar.o \
 		gianfar_ethtool.o
+gianfar_driver-$(CONFIG_FSL_GIANFAR_1588) += gianfar_1588.o
 obj-$(CONFIG_UCC_GETH) += ucc_geth_driver.o
 ucc_geth_driver-objs := ucc_geth.o ucc_geth_ethtool.o
diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index bcb24db..910ba0d 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -962,7 +962,11 @@ static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 
 	/* Find the TBI PHY.  If it's not there, we don't support SGMII */
 	priv->tbi_node = of_parse_phandle(np, "tbi-handle", 0);
-
+#if defined CONFIG_FSL_GIANFAR_1588
+	/* Handle IEEE1588 node */
+	if (!gfar_ptp_init(np, priv))
+		dev_info(&ofdev->dev, "ptp 1588 is initialized.\n");
+#endif
 	return 0;
 
 err_grp_init:
@@ -1036,8 +1040,15 @@ static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 
 	if (!priv->phydev)
 		return -ENODEV;
-
+#if defined CONFIG_FSL_GIANFAR_1588
+	if ((cmd >= PTP_ENBL_TXTS_IOCTL) &&
+			(cmd <= PTP_CLEANUP_TS))
+		return gfar_ioctl_1588(dev, rq, cmd);
+	else
+		return phy_mii_ioctl(priv->phydev, rq, cmd);
+#else
 	return phy_mii_ioctl(priv->phydev, rq, cmd);
+#endif
 }
 
 static u32 cluster_entry_per_class(struct gfar_private *priv, u32 rqfar,
@@ -1522,6 +1533,9 @@ static int gfar_probe(struct platform_device *ofdev)
 	return 0;
 
 register_fail:
+#if defined CONFIG_FSL_GIANFAR_1588
+	gfar_ptp_cleanup(priv);
+#endif
 	unmap_group_regs(priv);
 	gfar_free_rx_queues(priv);
 	gfar_free_tx_queues(priv);
@@ -2582,9 +2596,13 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	do_csum = (CHECKSUM_PARTIAL == skb->ip_summed);
 	do_vlan = vlan_tx_tag_present(skb);
+#if defined CONFIG_FSL_GIANFAR_1588
+	do_tstamp = unlikely((skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
+		    priv->hwts_tx_en) || unlikely(priv->hwts_tx_en_ioctl);
+#else
 	do_tstamp = (skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) &&
 		    priv->hwts_tx_en;
-
+#endif
 	if (do_csum || do_vlan)
 		fcb_len = GMAC_FCB_LEN;
 
@@ -2749,8 +2767,21 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	/* Setup tx hardware time stamping if requested */
 	if (unlikely(do_tstamp)) {
+#if defined CONFIG_FSL_GIANFAR_1588
+		u32 vlan_ctrl;
+#endif
 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
 		fcb->ptp = 1;
+#if defined CONFIG_FSL_GIANFAR_1588
+		/* When PTP in FCB is enabled, VLN in FCB is ignored.
+		 * Instead VLAN tag is read from DFVLAN register. Thus need
+		 * to copy VLCTL to DFVLAN register.
+		 */
+		vlan_ctrl = gfar_read(&regs->dfvlan);
+		vlan_ctrl &= ~0xFFFF;
+		vlan_ctrl |= (fcb->vlctl & 0xFFFF);
+		gfar_write(&regs->dfvlan, vlan_ctrl);
+#endif
 	}
 
 	txbdp_start->bufPtr = dma_map_single(priv->dev, skb->data,
@@ -3005,13 +3036,48 @@ static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 				 buflen, DMA_TO_DEVICE);
 
 		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)) {
+#if defined CONFIG_FSL_GIANFAR_1588
+			struct gfar __iomem *regs = priv->gfargrp[0].regs;
+#endif
 			struct skb_shared_hwtstamps shhwtstamps;
+#if defined CONFIG_FSL_GIANFAR_1588
+			u32 high, low;
+			struct gfar_ptp_time tx_ts;
+			u64 ns;
+
+			if (priv->device_flags &
+					FSL_GIANFAR_DEV_HAS_TS_TO_BUFFER) {
+				/* get tx timestamp out of frame */
+				void *ts;
+				ts = (void *)(((uintptr_t)skb->data + 0x10)
+						& ~0x7);
+				ns = be64_to_cpup(ts);
+			} else
+				/* get tx timestamp from register */
+				ns = gfar_get_tx_timestamp(regs);
+
+			if (unlikely(priv->hwts_tx_en))
+				shhwtstamps.hwtstamp = ns_to_ktime(ns);
+			if (likely(priv->hwts_tx_en_ioctl)) {
+				high = upper_32_bits(ns);
+				low = lower_32_bits(ns);
+				gfar_cnt_to_ptp_time(high, low, &tx_ts);
+			}
+			/* remove tx fcb */
+			skb_pull(skb, GMAC_FCB_LEN + GMAC_TXPAL_LEN);
+			/* pass timestamp back */
+			if (unlikely(priv->hwts_tx_en))
+				skb_tstamp_tx(skb, &shhwtstamps);
+			if (likely(priv->hwts_tx_en_ioctl))
+				gfar_ptp_store_txstamp(dev, skb, &tx_ts);
+#else
 			u64 *ns = (u64*) (((u32)skb->data + 0x10) & ~0x7);
 
 			memset(&shhwtstamps, 0, sizeof(shhwtstamps));
 			shhwtstamps.hwtstamp = ns_to_ktime(*ns);
 			skb_pull(skb, GMAC_FCB_LEN + GMAC_TXPAL_LEN);
 			skb_tstamp_tx(skb, &shhwtstamps);
+#endif
 			bdp->lstatus &= BD_LFLAG(TXBD_WRAP);
 			bdp = next;
 		}
@@ -3244,6 +3310,32 @@ static void gfar_process_frame(struct net_device *dev, struct sk_buff *skb,
 	}
 
 	/* Get receive timestamp from the skb */
+#if defined CONFIG_FSL_GIANFAR_1588
+	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER) {
+		u32 high, low;
+
+		/* get timestamp */
+		high = *((u32 *)skb->data);
+		low = *(((u32 *)skb->data) + 1);
+		skb_pull(skb, 8);
+		/* proprietary PTP timestamping over ioctl */
+		if (unlikely(priv->hwts_rx_en_ioctl)) {
+			struct gfar_ptp_time rx_ts;
+			/* get rx timestamp */
+			gfar_cnt_to_ptp_time(high, low, &rx_ts);
+			/* parse and store rx timestamp */
+			gfar_ptp_store_rxstamp(dev, skb, &rx_ts);
+		} else if (unlikely(priv->hwts_rx_en)) {
+			/* kernel-API timestamping ? */
+			u64 nsec;
+			struct skb_shared_hwtstamps *hws;
+			hws = skb_hwtstamps(skb);
+			nsec = make64(high, low);
+			hws->hwtstamp = ns_to_ktime(nsec);
+		}
+	} else if (priv->padding)
+			skb_pull(skb, priv->padding);
+#else
 	if (priv->hwts_rx_en) {
 		struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
 		u64 *ns = (u64 *) skb->data;
@@ -3254,7 +3346,7 @@ static void gfar_process_frame(struct net_device *dev, struct sk_buff *skb,
 
 	if (priv->padding)
 		skb_pull(skb, priv->padding);
-
+#endif
 	if (dev->features & NETIF_F_RXCSUM)
 		gfar_rx_checksum(skb, fcb);
 
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 4715157..ced6ee2 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -47,6 +47,10 @@
 #include <linux/workqueue.h>
 #include <linux/ethtool.h>
 
+#if defined CONFIG_FSL_GIANFAR_1588
+#include <linux/circ_buf.h>
+#endif
+
 struct ethtool_flow_spec_container {
 	struct ethtool_rx_flow_spec fs;
 	struct list_head list;
@@ -150,6 +154,62 @@ extern const char gfar_driver_version[];
 		| SUPPORTED_Pause \
 		| SUPPORTED_Asym_Pause)
 
+#if defined CONFIG_FSL_GIANFAR_1588
+/* 1588 defines */
+#define make64(high, low) (((u64)(high) << 32) | (low))
+
+#define PTP_ENBL_TXTS_IOCTL	SIOCDEVPRIVATE
+#define PTP_DSBL_TXTS_IOCTL	(SIOCDEVPRIVATE + 1)
+#define PTP_ENBL_RXTS_IOCTL	(SIOCDEVPRIVATE + 2)
+#define PTP_DSBL_RXTS_IOCTL	(SIOCDEVPRIVATE + 3)
+#define PTP_GET_TX_TIMESTAMP	(SIOCDEVPRIVATE + 4)
+#define PTP_GET_RX_TIMESTAMP	(SIOCDEVPRIVATE + 5)
+#define PTP_SET_TIME		(SIOCDEVPRIVATE + 6)
+#define PTP_GET_TIME		(SIOCDEVPRIVATE + 7)
+#define PTP_SET_FIPER_ALARM	(SIOCDEVPRIVATE + 8)
+#define PTP_SET_ADJ		(SIOCDEVPRIVATE + 9)
+#define PTP_GET_ADJ		(SIOCDEVPRIVATE + 10)
+#define PTP_CLEANUP_TS		(SIOCDEVPRIVATE + 11)
+
+#define DEFAULT_PTP_TX_BUF_SZ		1024
+#define DEFAULT_PTP_RX_BUF_SZ		2048
+
+/* The threshold between the current found one and the oldest one */
+#define TS_ACCUMULATION_THRESHOLD	50
+
+#define GFAR_PTP_SOURCE_PORT_LENGTH	10
+#define	GFAR_PTP_HEADER_SEQ_OFFS	30
+#define GFAR_PTP_SPID_OFFS		20
+#define GFAR_PTP_HEADER_SZE		34
+#define GFAR_PTP_EVENT_PORT		0x013F
+
+#define GFAR_VLAN_QINQ_1		0x9100
+#define GFAR_VLAN_QINQ_2		0x9200
+#define GFAR_VLAN_QINQ_3		0x9300
+#define GFAR_VLAN_QINQ_4		0x88A8
+#define GFAR_VLAN_TAG_LEN		0x04
+#define GFAR_ETHTYPE_LEN		0x02
+#define GFAR_PACKET_TYPE_UDP		0x11
+/* 1588-2008 network protocol enumeration values */
+#define GFAR_PTP_PROT_IPV4		1
+#define GFAR_PTP_PROT_IPV6		2
+#define GFAR_PTP_PROT_802_3		3
+#define GFAR_PTP_PROT_DONTCARE		0xFFFF
+
+/* 1588 Module Registers bits */
+#define TMR_CTRL_CKSEL_MASK	0x00000003
+#define TMR_CTRL_ENABLE		0x00000004
+#define TMR_RTPE		0x00008000
+#define TMR_CTRL_TCLK_MASK	0x03ff0000
+#define TMR_CTRL_FIPER_START	0x10000000
+#define ONE_GIGA	1000000000
+
+/*Alarm to traigger at 15sec boundary */
+#define TMR_ALARM1_L	0xD964B800
+#define TMR_ALARM1_H	0x00000045
+#define NANOSEC_PER_SEC	1000000000
+#endif
+
 /* TBI register addresses */
 #define MII_TBICON		0x11
 
@@ -693,6 +753,80 @@ struct gfar_extra_stats {
 /* Number of stats exported via ethtool */
 #define GFAR_STATS_LEN (GFAR_RMON_LEN + GFAR_EXTRA_STATS_LEN)
 
+#if defined CONFIG_FSL_GIANFAR_1588
+/* IEEE-1588 Timer Controller Registers */
+struct gfar_regs_1588 {
+	u32	tmr_ctrl;	/* 0x.e00 - Timer Control Register */
+	u32	tmr_tevent;	/* 0x.e04 - Timer stamp event register */
+	u32	tmr_temask;	/* 0x.e08 - Timer event mask register */
+	u32	tmr_pevent;	/* 0x.e0c - Timer stamp event register */
+	u32	tmr_pemask;	/* 0x.e10 - Timer event mask register */
+	u32	tmr_stat;	/* 0x.e14 - Timer stamp status register */
+	u32	tmr_cnt_h;	/* 0x.e18 - Timer counter high register */
+	u32	tmr_cnt_l;	/* 0x.e1c - Timer counter low register */
+	u32	tmr_add;	/* 0x.e20 - Timer dirft compensation */
+					/* addend register */
+	u32	tmr_acc;	/* 0x.e24 - Timer accumulator register */
+	u32	tmr_prsc;	/* 0x.e28 - Timer prescale register */
+	u8	res24a[4];	/* 0x.e2c - 0x.e2f reserved */
+	u32	tmr_off_h;	/* 0x.e30 - Timer offset high register */
+	u32	tmr_off_l;	/* 0x.e34 - Timer offset low register */
+	u8	res24b[8];	/* 0x.e38 - 0x.e3f reserved */
+	u32	tmr_alarm1_h;	/* 0x.e40 - Timer alarm 1 high register */
+	u32	tmr_alarm1_l;	/* 0x.e44 - Timer alarm 1 low register */
+	u32	tmr_alarm2_h;	/* 0x.e48 - Timer alarm 2 high register */
+	u32	tmr_alarm2_l;	/* 0x.e4c - Timer alarm 2 low register */
+	u8	res24c[48];	/* 0x.e50 - 0x.e7f reserved */
+	u32	tmr_fiper1;	/* 0x.e80 - Timer fixed period register 1 */
+	u32	tmr_fiper2;	/* 0x.e84 - Timer fixed period register 2 */
+	u32	tmr_fiper3;	/* 0x.e88 - Timer fixed period register 3 */
+	u8	res24d[20];	/* 0x.e8c - 0x.ebf reserved */
+	u32	tmr_etts1_h;	/* 0x.ea0 - Timer stamp high of */
+					/* general purpose external trigger 1 */
+	u32	tmr_etts1_l;	/* 0x.ea4 - Timer stamp low of */
+					/* general purpose external trigger 1 */
+	u32	tmr_etts2_h;	/* 0x.ea8 - Timer stamp high of */
+					/* general purpose external trigger 2 */
+	u32	tmr_etts2_l;	/* 0x.eac - Timer stamp low of */
+};
+
+/* struct needed to identify a timestamp */
+struct gfar_ptp_ident {
+	u8  version;
+	u8  msg_type;
+	u16 netw_prot;
+	u16 seq_id;
+	u8  snd_port_id[GFAR_PTP_SOURCE_PORT_LENGTH];
+};
+
+/* timestamp format in 1588-2008 */
+struct gfar_ptp_time {
+	u64 sec; /* just 48 bit used */
+	u32 nsec;
+};
+
+/* needed for timestamp data over ioctl */
+struct gfar_ptp_data {
+	struct  gfar_ptp_ident  ident;
+	struct  gfar_ptp_time   ts;
+};
+
+/* circular buffer for ptp timestamps over ioctl */
+struct gfar_ptp_circular {
+	struct circ_buf circ_buf;
+	u32 size;
+	spinlock_t ptp_lock;
+};
+
+struct gfar_ptp_attr_t {
+	u32 tclk_period;
+	u32 nominal_freq;
+	u32 sysclock_freq;
+	u32 tmr_fiper1;
+	u32 freq_comp;
+};
+#endif
+
 struct gfar {
 	u32	tsec_id;	/* 0x.000 - Controller ID register */
 	u32	tsec_id2;	/* 0x.004 - Controller ID2 register */
@@ -765,6 +899,7 @@ struct gfar {
 	u32	tbase6;		/* 0x.234 - TxBD Base Address of ring 6 */
 	u8	res10g[4];
 	u32	tbase7;		/* 0x.23c - TxBD Base Address of ring 7 */
+#if defined CONFIG_FSL_GIANFAR_1588
 	u8	res10h[64];
 	u32	tmr_txts1_id;	/* 0x.280 Tx time stamp identification */
 	u32	tmr_txts2_id;	/* 0x.284 Tx time stamp Identification */
@@ -774,6 +909,9 @@ struct gfar {
 	u32	tmr_txts2_h;	/* 0x.2c8 Tx time stamp high */
 	u32	tmr_txts2_l;	/* 0x.2cc  Tx Time Stamp low */
 	u8	res10j[48];
+#else
+	u8	res10[192];
+#endif
 	u32	rctrl;		/* 0x.300 - Receive Control Register */
 	u32	rstat;		/* 0x.304 - Receive Status Register */
 	u8	res12[8];
@@ -824,7 +962,14 @@ struct gfar {
 	u32	rbase6;		/* 0x.434 - RxBD base address of ring 6 */
 	u8	res17g[4];
 	u32	rbase7;		/* 0x.43c - RxBD base address of ring 7 */
+#if defined CONFIG_FSL_GIANFAR_1588
+	u8	res17h[128];
+	u32	tmr_rxts_h;	/* 0x.4c0 Rx Time Stamp high */
+	u32	tmr_rxts_l;	/* 0x.4c4 Rx Time Stamp low */
+	u8	res17i[56];
+#else
 	u8	res17[192];
+#endif
 	u32	maccfg1;	/* 0x.500 - MAC Configuration 1 Register */
 	u32	maccfg2;	/* 0x.504 - MAC Configuration 2 Register */
 	u32	ipgifg;		/* 0x.508 - Inter Packet Gap/Inter Frame Gap Register */
@@ -893,7 +1038,12 @@ struct gfar {
 	u8	res23c[248];
 	u32	attr;		/* 0x.bf8 - Attributes Register */
 	u32	attreli;	/* 0x.bfc - Attributes Extract Length and Extract Index Register */
+#if defined CONFIG_FSL_GIANFAR_1588
+	u8	res24[512];
+	struct gfar_regs_1588 regs_1588;
+#else
 	u8	res24[688];
+#endif
 	u32	isrg0;		/* 0x.eb0 - Interrupt steering group 0 register */
 	u32	isrg1;		/* 0x.eb4 - Interrupt steering group 1 register */
 	u32	isrg2;		/* 0x.eb8 - Interrupt steering group 2 register */
@@ -931,7 +1081,10 @@ struct gfar {
 #define FSL_GIANFAR_DEV_HAS_BD_STASHING		0x00000200
 #define FSL_GIANFAR_DEV_HAS_BUF_STASHING	0x00000400
 #define FSL_GIANFAR_DEV_HAS_TIMER		0x00000800
+
+#if defined CONFIG_FSL_GIANFAR_1588
 #define FSL_GIANFAR_DEV_HAS_TS_TO_BUFFER	0x00001000
+#endif
 #define FSL_GIANFAR_DEV_HAS_36BIT_ADDR		0x00002000
 
 #if (MAXGROUPS == 2)
@@ -1145,16 +1298,21 @@ struct gfar_private {
 	u16 padding;
 	u32 device_flags;
 
-	unsigned long state;
-
+#if defined CONFIG_FSL_GIANFAR_1588
+	/* HW TX timestamping enabled flag */
+	u16 hwts_tx_en;
+	u16 hwts_tx_en_ioctl;
+#else
 	/* HW time stamping enabled flag */
 	int hwts_rx_en;
 	int hwts_tx_en;
-
+#endif
 	struct gfar_priv_tx_q *tx_queue[MAX_TX_QS];
 	struct gfar_priv_rx_q *rx_queue[MAX_RX_QS];
 	struct gfar_priv_grp gfargrp[MAXGROUPS];
 
+	unsigned long state;
+
 	struct gfar_priv_recycle recycle;
 	struct gfar_priv_recycle *recycle_target;
 
@@ -1167,6 +1325,17 @@ struct gfar_private {
 	/* Network Statistics */
 	struct gfar_extra_stats extra_stats;
 
+#if defined CONFIG_FSL_GIANFAR_1588
+	/* HW RX timestamping enabled flag */
+	u16 hwts_rx_en;
+	u16 hwts_rx_en_ioctl;
+
+	/* 1588 stuff */
+	struct gfar_regs_1588 __iomem *ptimer;
+	struct gfar_ptp_circular tx_timestamps;
+	struct gfar_ptp_circular rx_timestamps;
+#endif
+
 	/* PHY stuff */
 	phy_interface_t interface;
 	struct device_node *phy_node;
@@ -1309,6 +1478,19 @@ void reset_gfar(struct net_device *dev);
 void gfar_mac_reset(struct gfar_private *priv);
 void gfar_halt(struct gfar_private *priv);
 void gfar_start(struct gfar_private *priv);
+#if defined CONFIG_FSL_GIANFAR_1588
+void gfar_1588_start(struct gfar_private *priv);
+void gfar_1588_stop(struct gfar_private *priv);
+int gfar_ptp_init(struct device_node *np, struct gfar_private *priv);
+void gfar_ptp_cleanup(struct gfar_private *priv);
+int gfar_ioctl_1588(struct net_device *dev, struct ifreq *ifr, int cmd);
+void gfar_ptp_store_txstamp(struct net_device *dev,
+			struct sk_buff *skb, struct gfar_ptp_time *tx_ts);
+void gfar_ptp_store_rxstamp(struct net_device *dev,
+			struct sk_buff *skb, struct gfar_ptp_time *rx_ts);
+void gfar_cnt_to_ptp_time(u32 high, u32 low, struct gfar_ptp_time *time);
+u64 gfar_get_tx_timestamp(struct gfar __iomem *regs);
+#endif
 void gfar_phy_test(struct mii_bus *bus, struct phy_device *phydev,
  int enable, u32 regnum, u32 read);
 void gfar_configure_coalescing_all(struct gfar_private *priv);
-- 
1.7.5.4

