From f37d2eefd0faf20fe17ae7cd7d42504271417076 Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@Freescale.com>
Date: Mon, 6 Jan 2014 12:52:55 -0600
Subject: [PATCH 0629/1089] dma/fsl_raid: DMA unmapping is now handled in the
 DMA core code
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

As per '54f8d50 dmaengine: remove DMA unmap from drivers' and
'0776ae7 dmaengine: remove DMA unmap flags'

drivers/dma/fsl_raid.c: In function ‘re_jr_unmap_dest_src’:
drivers/dma/fsl_raid.c:135:16: error: ‘DMA_COMPL_SKIP_DEST_UNMAP’ undeclared (first use in this function)
  if (!(flags & DMA_COMPL_SKIP_DEST_UNMAP)) {
                ^
drivers/dma/fsl_raid.c:135:16: note: each undeclared identifier is reported only once for each function it appears in
drivers/dma/fsl_raid.c:147:16: error: ‘DMA_COMPL_SKIP_SRC_UNMAP’ undeclared (first use in this function)
  if (!(flags & DMA_COMPL_SKIP_SRC_UNMAP)) {
                ^

Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Change-Id: Ibfae0ded94c550ec83c300ffbbc9055803f2f7d2
Reviewed-on: http://git.am.freescale.net:8181/7705
Reviewed-by: Xuelin Shi <b29237@freescale.com>
Reviewed-by: Emilian Medve <Emilian.Medve@freescale.com>
Tested-by: Emilian Medve <Emilian.Medve@freescale.com>
---
 drivers/dma/fsl_raid.c | 42 ------------------------------------------
 1 file changed, 42 deletions(-)

diff --git a/drivers/dma/fsl_raid.c b/drivers/dma/fsl_raid.c
index f2178f7..df3c9da 100644
--- a/drivers/dma/fsl_raid.c
+++ b/drivers/dma/fsl_raid.c
@@ -114,47 +114,6 @@ static dma_cookie_t re_jr_tx_submit(struct dma_async_tx_descriptor *tx)
 	return cookie;
 }
 
-static void re_jr_unmap_dest_src(struct fsl_re_dma_async_tx_desc *desc)
-{
-	int i, j;
-	struct cmpnd_frame *cf;
-	dma_addr_t dest1 = 0, dest2 = 0, src;
-	struct device *dev;
-	enum dma_ctrl_flags flags;
-	enum dma_data_direction dir;
-
-	cf = desc->cf_addr;
-	dest1 = cf[1].address;
-	j = 2;
-	if (desc->dest_cnt == 2) {
-		dest2 = cf[2].address;
-		j = 3;
-	}
-	dev = desc->jr->chan.device->dev;
-	flags = desc->async_tx.flags;
-	if (!(flags & DMA_COMPL_SKIP_DEST_UNMAP)) {
-		if (desc->cdb_opcode == RE_MOVE_OPCODE)
-			dir = DMA_FROM_DEVICE;
-		else
-			dir = DMA_BIDIRECTIONAL;
-
-		dma_unmap_page(dev, dest1, desc->dma_len, dir);
-
-		if (dest2)
-			dma_unmap_page(dev, dest2, desc->dma_len, dir);
-	}
-
-	if (!(flags & DMA_COMPL_SKIP_SRC_UNMAP)) {
-		dir = DMA_TO_DEVICE;
-		for (i = j; i < desc->src_cnt + j; i++) {
-			src = cf[i].address;
-			if (src == dest1 || src == dest2)
-				continue;
-			dma_unmap_page(dev, src, desc->dma_len, dir);
-		}
-	}
-}
-
 static void re_jr_desc_done(struct fsl_re_dma_async_tx_desc *desc)
 {
 	struct dma_chan *chan = &desc->jr->chan;
@@ -171,7 +130,6 @@ static void re_jr_desc_done(struct fsl_re_dma_async_tx_desc *desc)
 		if (chan->completed_cookie == DMA_MAX_COOKIE)
 			chan->completed_cookie = DMA_MIN_COOKIE;
 	}
-	re_jr_unmap_dest_src(desc);
 
 	if (callback)
 		callback(callback_param);
-- 
2.0.2

