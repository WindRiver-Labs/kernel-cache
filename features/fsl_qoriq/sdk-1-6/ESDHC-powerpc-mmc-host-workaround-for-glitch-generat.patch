From b3410ac936eb133bc76c61f2d59afc10cd1b2789 Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Wed, 3 Sep 2014 17:20:26 +0800
Subject: [PATCH 0055/1089] ESDHC-powerpc mmc:host workaround for glitch
 generated when clock changed

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

A-005055: SDHC: Glitch is generated on the card clock with software reset or
clock divider change.

A simple workaround is to disable the SD card clock before the software reset,
and enable it when the module resumes normal operation.The Host and the SD card
are in a master-slave relationship. The Host provides clock and control
transfer across the interface. Therefore, any existing operation is discarded
when the Host controller is reset.
The recommended flow is as follows:
1. Software disable bit[3], SDCLKEN, of the System Control Register
2. Trigger software reset and/or set clock divider
3. Check bit[3], SDSTB, of the Present State Register for stable clock
4. Enable bit[3], SDCLKEN, of the System Control Register
Using the above method, the eSDHC cannot send command or transfer data when
there is a glitch in the clock line, and the glitch does not cause any issue.

In case the reason of Reset All command, we use reset data and reset command
to instead.
In case the reason of Clock change, this situation can only be occurred in card
setup phases, so just go idle state and re-init the card(Card detect can do
this for us).

Signed-off-by: Jerry Huang <Chang-Ming.Huang@freescale.com>
Signed-off-by: Haijun Zhang <haijun.zhang@freescale.com>
Change-Id: I1add2738ecf77369adc9f30718bd6a6e08ee4f17
Reviewed-on: http://git.am.freescale.net:8181/569
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 drivers/mmc/host/sdhci-of-esdhc.c | 24 ++++++++++++++++++++++++
 drivers/mmc/host/sdhci-pltfm.c    |  9 +++++++++
 include/linux/mmc/sdhci.h         |  2 ++
 3 files changed, 35 insertions(+)

diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c
index 461fed6..a602fbc 100644
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@ -139,6 +139,15 @@ static void esdhc_writeb(struct sdhci_host *host, u8 val, int reg)
 	/* Prevent SDHCI core from writing reserved bits (e.g. HISPD). */
 	if (reg == SDHCI_HOST_CONTROL)
 		val &= ~ESDHC_HOST_CONTROL_RES;
+
+	/* If we have this quirk just use reset cmd and reset data to
+	 * instead of reset all.
+	 */
+	if ((reg == SDHCI_SOFTWARE_RESET) &&
+			(host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL) &&
+			(val & SDHCI_RESET_ALL))
+		val = SDHCI_RESET_CMD | SDHCI_RESET_DATA;
+
 	sdhci_be32bs_writeb(host, val, reg);
 }
 
@@ -256,6 +265,19 @@ static void esdhc_of_resume(struct sdhci_host *host)
 }
 #endif
 
+static u32 clock;
+static void esdhc_of_platform_reset_enter(struct sdhci_host *host, u8 mask)
+{
+	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
+		clock = host->clock;
+}
+
+static void esdhc_of_platform_reset_exit(struct sdhci_host *host, u8 mask)
+{
+	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
+		host->clock = clock;
+}
+
 static void esdhc_of_platform_init(struct sdhci_host *host)
 {
 	u32 vvn;
@@ -329,6 +351,8 @@ static const struct sdhci_ops sdhci_esdhc_ops = {
 	.enable_dma = esdhc_of_enable_dma,
 	.get_max_clock = esdhc_of_get_max_clock,
 	.get_min_clock = esdhc_of_get_min_clock,
+	.platform_reset_enter = esdhc_of_platform_reset_enter,
+	.platform_reset_exit = esdhc_of_platform_reset_exit,
 	.platform_init = esdhc_of_platform_init,
 	.get_cd = esdhc_of_get_cd,
 #ifdef CONFIG_PM
diff --git a/drivers/mmc/host/sdhci-pltfm.c b/drivers/mmc/host/sdhci-pltfm.c
index bef250e..de2798e 100644
--- a/drivers/mmc/host/sdhci-pltfm.c
+++ b/drivers/mmc/host/sdhci-pltfm.c
@@ -98,6 +98,15 @@ void sdhci_get_of_property(struct platform_device *pdev)
 		    of_device_is_compatible(np, "fsl,mpc8536-esdhc"))
 			host->quirks |= SDHCI_QUIRK_BROKEN_TIMEOUT_VAL;
 
+		if (of_device_is_compatible(np, "fsl,t4240-esdhc"))
+			host->quirks2 |= SDHCI_QUIRK2_BROKEN_RESET_ALL;
+
+		if (of_device_is_compatible(np, "fsl,p4860-rev1-esdhc") ||
+		    of_device_is_compatible(np, "fsl,p1010-esdhc") ||
+		    of_device_is_compatible(np, "fsl,p2041-esdhc") ||
+		    of_device_is_compatible(np, "fsl,p3041-esdhc"))
+			host->quirks2 |= SDHCI_QUIRK2_BROKEN_RESET_ALL;
+
 		clk = of_get_property(np, "clock-frequency", &size);
 		if (clk && size == sizeof(*clk) && *clk)
 			pltfm_host->clock = be32_to_cpup(clk);
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 362927c4..8b1fdf1 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -100,6 +100,8 @@ struct sdhci_host {
 #define SDHCI_QUIRK2_BROKEN_HOST_CONTROL		(1<<5)
 /* Controller does not support HS200 */
 #define SDHCI_QUIRK2_BROKEN_HS200			(1<<6)
+/* Controller can't perform reset all successfully */
+#define SDHCI_QUIRK2_BROKEN_RESET_ALL			(1U<<31)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
-- 
2.0.2

