From a46317416ef8beb65b8f2d76ac40d67365927ac9 Mon Sep 17 00:00:00 2001
From: Zhenbo Gao <zhenbo.gao@windriver.com>
Date: Fri, 29 Dec 2017 14:19:56 +0800
Subject: [PATCH] Ipsec: Memory leak during Outbound rekeying period

When the outbound rekeying failure, the memory leak happened.
Add the release opertaion when outbound rekeying failed.

Signed-off-by: baogen shang <baogen.shang@windriver.com>
Signed-off-by: Zhenbo Gao <zhenbo.gao@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   74 +++++++++++++++++++++++++++
 1 files changed, 74 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index f86c451..bacd521 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -2317,6 +2317,39 @@ static int wait_until_fq_empty(struct qman_fq *fq, int timeout)
 	return 0;
 }
 
+static int remove_sa_sec_outbound_fq(struct dpa_ipsec_sa *sa, struct qman_fq *sec_fq)
+{
+
+	int err, flags;
+
+	BUG_ON(!sa);
+	BUG_ON(!sa->dpa_ipsec);
+	BUG_ON(!sec_fq);
+
+	err = qman_retire_fq(sec_fq, &flags);
+	if (err < 0) {
+		log_err("Failed to retire FQ %d\n", sec_fq->fqid);
+		return err;
+	}
+
+	err = qman_oos_fq(sec_fq);
+	if (err < 0) {
+		log_err("Failed to OOS FQ %d\n", sec_fq->fqid);
+		return err;
+	}
+
+	qman_destroy_fq(sec_fq, 0);
+
+	/* release FQID */
+	put_free_fqid(sa->dpa_ipsec, sec_fq->fqid);
+
+	/* Clean the FQ structure for reuse */
+	memset(sec_fq, 0, sizeof(struct qman_fq));
+
+	return 0;
+
+}
+
 static int remove_sa_sec_fq(struct dpa_ipsec_sa *sa, struct qman_fq *sec_fq)
 {
 	int err, flags, timeout = WAIT4_FQ_EMPTY_TIMEOUT;
@@ -2356,6 +2389,27 @@ static int remove_sa_sec_fq(struct dpa_ipsec_sa *sa, struct qman_fq *sec_fq)
 	return 0;
 }
 
+static int remove_outbound_sa_fq_pair(struct dpa_ipsec_sa *sa)
+{
+	struct dpa_ipsec *dpa_ipsec;
+	int err = 0;
+
+	BUG_ON(!sa);
+	dpa_ipsec = sa->dpa_ipsec;
+	BUG_ON(!dpa_ipsec);
+
+	if (qman_fq_fqid(sa->to_sec_fq) != 0)
+	{
+		remove_sa_sec_outbound_fq(sa, sa->to_sec_fq);
+	}
+	else
+	{
+		log_err("Failed to recycle TO SEC FQ \n");
+		err = -1;
+	}
+	return err;
+}
+
 static int remove_sa_fq_pair(struct dpa_ipsec_sa *sa)
 {
 	int err;
@@ -3419,6 +3473,24 @@ static int put_sa(struct dpa_ipsec_sa *sa)
 	return 0;
 }
 
+static int release_rekeying_outbound_sa(struct dpa_ipsec_sa *sa)
+{
+	int err_rb;
+
+	BUG_ON(!sa);
+
+	err_rb = remove_outbound_sa_fq_pair(sa);
+	if (err_rb < 0) {
+		log_err("Could not remove outbound SA FQs.\n");
+		return err_rb;
+	}
+
+	err_rb = put_sa(sa);
+
+	return err_rb;
+
+}
+
 static int rollback_create_sa(struct dpa_ipsec_sa *sa)
 {
 	struct dpa_ipsec *dpa_ipsec;
@@ -4620,6 +4692,8 @@ int dpa_ipsec_sa_rekeying(int sa_id,
 				new_sa->child_sa  = NULL;
 				old_sa->child_sa  = NULL;
 				old_sa->parent_sa = NULL;
+
+				(void)release_rekeying_outbound_sa(new_sa);
 				/*
 				 * AV's note TODO: investigate the removal of FQ
 				 * to SEC even is it has frames in it and is in
-- 
1.7.5.4

