From 58a8e1b9c945e50045dde662a03e7d8a0712a1a5 Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Mon, 26 Aug 2013 16:53:10 +0300
Subject: [PATCH 0530/1089] dpaa_eth: Fix check on return value

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Function dpa_bpid2pool() returns NULL if there's no initialized buffer
pool associated with the given bpid.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: I42b286c1050f273774d645fabee49c105d7ab6f1
Reviewed-on: http://git.am.freescale.net:8181/4836
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c | 4 ++--
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c     | 5 +++--
 drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c | 9 +++++----
 3 files changed, 10 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index e136615..c41c103 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -1430,7 +1430,7 @@ void dpa_release_sgt(struct qm_sg_entry *sgt, struct bm_buffer *bmb)
 
 	do {
 		dpa_bp = dpa_bpid2pool(sgt[i].bpid);
-		BUG_ON(IS_ERR(dpa_bp));
+		BUG_ON(!dpa_bp);
 
 		j = 0;
 		do {
@@ -1460,7 +1460,7 @@ dpa_fd_release(const struct net_device *net_dev, const struct qm_fd *fd)
 	_bmb.lo	= fd->addr_lo;
 
 	_dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(IS_ERR(_dpa_bp));
+	BUG_ON(!_dpa_bp);
 
 	if (fd->format == qm_fd_sg) {
 		sgt = (phys_to_virt(bm_buf_addr(&_bmb)) + dpa_fd_offset(fd));
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index cbc20bd..5919867 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -406,7 +406,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 		BUG_ON(sgt[i].extension);
 
 		dpa_bp = dpa_bpid2pool(sgt[i].bpid);
-		BUG_ON(IS_ERR(dpa_bp));
+		BUG_ON(!dpa_bp);
 		count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 
 		sg_addr = qm_sg_addr(&sgt[i]);
@@ -499,7 +499,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 
 	/* recycle the SGT fragment */
 	dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(IS_ERR(dpa_bp));
+	BUG_ON(!dpa_bp);
 	dpa_bp_recycle_frag(dpa_bp, (unsigned long)vaddr);
 	return skb;
 }
@@ -529,6 +529,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	}
 
 	dpa_bp = dpa_bpid2pool(fd->bpid);
+	BUG_ON(!dpa_bp);
 	count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 	/* Prepare to read from the buffer, but don't unmap it until
 	 * we know the skb allocation succeeded. At this point we already
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
index 31e4f0c..565b46e 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
@@ -195,6 +195,7 @@ dpa_fd_release_sg(const struct net_device *net_dev,
 	_bmb.lo	= fd->addr_lo;
 
 	_dpa_bp = dpa_bpid2pool(fd->bpid);
+	BUG_ON(!_dpa_bp);
 
 	if (_dpa_bp->vaddr) {
 		sgt = dpa_phys2virt(_dpa_bp, bm_buf_addr(&_bmb)) +
@@ -240,7 +241,7 @@ shared_rx_dqrr(struct qman_portal *portal, struct qman_fq *fq,
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
 
 	dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(IS_ERR(dpa_bp));
+	BUG_ON(!dpa_bp);
 
 	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
 		if (netif_msg_hw(priv) && net_ratelimit())
@@ -369,7 +370,7 @@ shared_tx_error_dqrr(struct qman_portal                *portal,
 	priv = netdev_priv(net_dev);
 
 	dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(IS_ERR(dpa_bp));
+	BUG_ON(!dpa_bp);
 
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
 
@@ -402,7 +403,7 @@ shared_tx_default_dqrr(struct qman_portal              *portal,
 	priv = netdev_priv(net_dev);
 
 	dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(IS_ERR(dpa_bp));
+	BUG_ON(!dpa_bp);
 
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
 
@@ -465,7 +466,7 @@ int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
 	queue_mapping = smp_processor_id();
 
 	dpa_bp = dpa_size2pool(priv, skb_headlen(skb));
-	if (unlikely(IS_ERR(dpa_bp))) {
+	if (unlikely(!dpa_bp)) {
 		percpu_priv->stats.tx_errors++;
 		err = PTR_ERR(dpa_bp);
 		goto bpools_too_small_error;
-- 
2.0.2

