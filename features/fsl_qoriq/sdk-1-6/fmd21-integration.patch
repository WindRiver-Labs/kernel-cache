From 82f180de4c25994727028dc86118a34dcfcc09fb Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Wed, 24 Apr 2013 10:56:04 +0300
Subject: [PATCH 0228/1089] fmd21 integration

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>

Prev fmd integration was fmd19
Diffs from fmd19 to fmd21:

Added kgHashShift to t_FmPcdHashTableParams
Added nonConsistentSp to t_FmPcdManipReassemIpStats

sp - 2 layers separation - for future flib integration
rtc - 2 layers separation - for future flib integration

PFC enhancement (B4 Rev2 FMAN)
API addition (for B4 rev 2): FM_PORT_SetPfcPrioritiesMappingToQmanWQ

File fsl_fman.h renamed to lnxwrp_fsl_fman.h
The name fsl_fman.h has been applied to other fman internal header file

In dpaa_eth:
Due to renaming of fsl_fman.h to lnxwrp_fsl_fman.h
The relevant include lines in some of the files had to change accordingly

Change-Id: I8f25c758963a44a75ca8676aad45f7f96767b0b5
Reviewed-on: http://git.am.freescale.net:8181/2069
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |   2 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      |   2 +-
 drivers/net/ethernet/freescale/dpa/mac-api.c       |   2 +-
 drivers/net/ethernet/freescale/dpa/mac.h           |   2 +-
 drivers/net/ethernet/freescale/dpa/offline_port.h  |   2 +-
 .../ethernet/freescale/fman/Peripherals/FM/HC/hc.c |  39 +-
 .../freescale/fman/Peripherals/FM/MAC/dtsec.c      | 150 +++--
 .../freescale/fman/Peripherals/FM/MAC/fm_mac.c     |   5 +-
 .../freescale/fman/Peripherals/FM/MAC/fman_dtsec.c |  76 +--
 .../freescale/fman/Peripherals/FM/MAC/fman_memac.c | 632 +++++++++++----------
 .../freescale/fman/Peripherals/FM/MAC/fman_tgec.c  |  55 +-
 .../Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h    |   3 +-
 .../freescale/fman/Peripherals/FM/MAC/memac.c      | 177 +++---
 .../freescale/fman/Peripherals/FM/MAC/memac.h      |   7 +-
 .../fman/Peripherals/FM/MAC/memac_mii_acc.c        |   1 -
 .../freescale/fman/Peripherals/FM/MAC/tgec.c       | 117 ++--
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.c      | 117 ++--
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.h      |   2 +
 .../freescale/fman/Peripherals/FM/Pcd/fm_kg.c      |   2 +
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.c   | 225 ++++----
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.h   |   3 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_pcd.c     |  47 +-
 .../freescale/fman/Peripherals/FM/Port/fm_port.c   | 323 ++++++-----
 .../freescale/fman/Peripherals/FM/Port/fm_port.h   | 111 ++--
 .../freescale/fman/Peripherals/FM/Rtc/Makefile     |   2 +-
 .../freescale/fman/Peripherals/FM/Rtc/fm_rtc.c     | 333 +++--------
 .../freescale/fman/Peripherals/FM/Rtc/fm_rtc.h     | 130 +----
 .../freescale/fman/Peripherals/FM/Rtc/fman_rtc.c   | 334 +++++++++++
 .../freescale/fman/Peripherals/FM/SP/Makefile      |   2 +-
 .../freescale/fman/Peripherals/FM/SP/fm_sp.c       | 191 ++-----
 .../freescale/fman/Peripherals/FM/SP/fm_sp.h       |  48 +-
 .../freescale/fman/Peripherals/FM/SP/fman_sp.c     | 197 +++++++
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    |  92 ++-
 .../ethernet/freescale/fman/Peripherals/FM/fm.h    |  85 ++-
 .../freescale/fman/Peripherals/FM/inc/fm_common.h  |  14 +-
 .../freescale/fman/Peripherals/FM/inc/fm_hc.h      |   3 +-
 .../fman/Peripherals/FM/inc/fm_sp_common.h         |  39 +-
 .../freescale/fman/inc/Peripherals/fm_ext.h        |  89 +--
 .../freescale/fman/inc/Peripherals/fm_mac_ext.h    |  50 +-
 .../freescale/fman/inc/Peripherals/fm_pcd_ext.h    |  27 +-
 .../freescale/fman/inc/Peripherals/fm_port_ext.h   |  87 +--
 .../freescale/fman/inc/Peripherals/fm_rtc_ext.h    |  32 +-
 drivers/net/ethernet/freescale/fman/inc/core_ext.h |   1 +
 .../ethernet/freescale/fman/inc/cores/e500v2_ext.h |   2 +
 .../net/ethernet/freescale/fman/inc/debug_ext.h    |   1 +
 .../net/ethernet/freescale/fman/inc/endian_ext.h   |   1 +
 .../net/ethernet/freescale/fman/inc/error_ext.h    |   2 +
 .../ethernet/freescale/fman/inc/flib/fsl_fman.h    | 117 ++++
 .../freescale/fman/inc/flib/fsl_fman_dtsec.h       | 269 +++++----
 .../freescale/fman/inc/flib/fsl_fman_memac.h       | 119 ++--
 .../freescale/fman/inc/flib/fsl_fman_rtc.h         | 429 ++++++++++++++
 .../ethernet/freescale/fman/inc/flib/fsl_fman_sp.h | 138 +++++
 .../freescale/fman/inc/flib/fsl_fman_tgec.h        | 115 ++--
 .../inc/integrations/P1023/dpaa_integration_ext.h  |  21 +-
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |  12 +-
 .../inc/integrations/T4240/dpaa_integration_ext.h  |   3 +-
 .../freescale/fman/src/inc/wrapper/fsl_fman.h      | 347 -----------
 .../freescale/fman/src/inc/wrapper/lnxwrp_fm_ext.h |   2 +-
 .../fman/src/inc/wrapper/lnxwrp_fsl_fman.h         | 347 +++++++++++
 .../freescale/fman/src/wrapper/fman_test.c         |   2 +-
 .../freescale/fman/src/wrapper/lnxwrp_fm_port.c    |  25 +-
 .../fman/src/wrapper/lnxwrp_ioctls_fm_compat.c     |  18 +-
 .../fman/src/wrapper/lnxwrp_ioctls_fm_compat.h     |   1 +
 include/uapi/linux/fmd/Peripherals/fm_ioctls.h     |   6 +-
 include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h |  10 +-
 65 files changed, 3441 insertions(+), 2404 deletions(-)
 create mode 100755 drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fman_rtc.c
 create mode 100755 drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fman_sp.c
 create mode 100755 drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
 create mode 100755 drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h
 create mode 100755 drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_sp.h
 delete mode 100644 drivers/net/ethernet/freescale/fman/src/inc/wrapper/fsl_fman.h
 create mode 100644 drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 6357e7d..c89195d 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -59,7 +59,7 @@
 #include <asm/smp.h>		/* get_hard_smp_processor_id() */
 #include <linux/fsl_bman.h>
 
-#include "fsl_fman.h"
+#include "lnxwrp_fsl_fman.h"
 #include "fm_ext.h"
 #include "fm_port_ext.h"
 
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 40bac8a..a6c5dc0 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -47,7 +47,7 @@
 
 #include "dpaa_eth-common.h"
 
-#include "fsl_fman.h"
+#include "lnxwrp_fsl_fman.h"
 #include "fm_ext.h"
 #include "fm_port_ext.h" /* FM_PORT_FRM_ERR_* */
 
diff --git a/drivers/net/ethernet/freescale/dpa/mac-api.c b/drivers/net/ethernet/freescale/dpa/mac-api.c
index 717e005..96ac239 100644
--- a/drivers/net/ethernet/freescale/dpa/mac-api.c
+++ b/drivers/net/ethernet/freescale/dpa/mac-api.c
@@ -440,7 +440,7 @@ static void adjust_link(struct net_device *net_dev)
 	if (!phy_dev->link) {
 #if (DPAA_VERSION < 11)
 		mac_priv = (struct mac_priv_s *)macdev_priv(mac_dev);
-		DtsecRestartTbiAN(mac_priv->mac);
+		FM_MAC_RestartAutoneg(mac_priv->mac);
 #endif
 		return;
 	}
diff --git a/drivers/net/ethernet/freescale/dpa/mac.h b/drivers/net/ethernet/freescale/dpa/mac.h
index 9cf1740..87c21c4 100644
--- a/drivers/net/ethernet/freescale/dpa/mac.h
+++ b/drivers/net/ethernet/freescale/dpa/mac.h
@@ -37,7 +37,7 @@
 #include <linux/phy.h>		/* phy_interface_t, struct phy_device */
 #include <linux/list.h>
 
-#include "fsl_fman.h"		/* struct port_device */
+#include "lnxwrp_fsl_fman.h"		/* struct port_device */
 
 enum {DTSEC, XGMAC, MEMAC};
 
diff --git a/drivers/net/ethernet/freescale/dpa/offline_port.h b/drivers/net/ethernet/freescale/dpa/offline_port.h
index 1b1a63f..199e6ac 100644
--- a/drivers/net/ethernet/freescale/dpa/offline_port.h
+++ b/drivers/net/ethernet/freescale/dpa/offline_port.h
@@ -33,7 +33,7 @@
 #ifndef __OFFLINE_PORT_H
 #define __OFFLINE_PORT_H
 
-#include "fsl_fman.h"
+#include "lnxwrp_fsl_fman.h"
 
 /* OH port configuration */
 struct dpa_oh_config_s {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
index ed3674f..463a095 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
@@ -296,13 +296,6 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     return (t_Handle)p_FmHc;
 }
 
-t_Handle FmGcGetHcPortDevH(t_Handle h_FmHc)
-{
-    t_FmHc  *p_FmHc = (t_FmHc *)h_FmHc;
-
-    return (p_FmHc) ? p_FmHc->h_HcPortDev : NULL;
-}
-
 void FmHcFree(t_Handle h_FmHc)
 {
     t_FmHc  *p_FmHc = (t_FmHc*)h_FmHc;
@@ -1190,3 +1183,35 @@ t_Error FmHcPcdCcDoDynamicChange(t_Handle h_FmHc, uint32_t oldAdAddrOffset, uint
     return E_OK;
 }
 
+t_Error FmHcPcdSync(t_Handle h_FmHc)
+{
+    t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame               *p_HcFrame;
+    t_DpaaFD                fmFd;
+    t_Error                 err = E_OK;
+    uint32_t                seqNum;
+
+    ASSERT_COND(p_FmHc);
+
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    /* first read SP register */
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_SYNC);
+    p_HcFrame->actionReg = 0;
+    p_HcFrame->extraReg = 0;
+    p_HcFrame->commandSequence = seqNum;
+
+    BUILD_FD(sizeof(t_HcFrame));
+
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
+
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
+
+    if (err != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return E_OK;
+}
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
index 6839fcc..cb0ddd2 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
@@ -129,7 +129,7 @@ static void UpdateStatistics(t_Dtsec *p_Dtsec)
 {
     uint32_t car1, car2;
 
-    dtsec_get_clear_carry_regs(p_Dtsec->p_MemMap, &car1, &car2);
+    fman_dtsec_get_clear_carry_regs(p_Dtsec->p_MemMap, &car1, &car2);
 
     if (car1)
     {
@@ -204,7 +204,7 @@ static uint16_t DtsecGetMaxFrameLength(t_Handle h_Dtsec)
     SANITY_CHECK_RETURN_VALUE(p_Dtsec, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE, 0);
 
-    return dtsec_get_max_frame_len(p_Dtsec->p_MemMap);
+    return fman_dtsec_get_max_frame_len(p_Dtsec->p_MemMap);
 }
 
 /* .............................................................................. */
@@ -216,11 +216,11 @@ static void DtsecIsr(t_Handle h_Dtsec)
     struct dtsec_regs   *p_DtsecMemMap = p_Dtsec->p_MemMap;
 
     /* do not handle MDIO events */
-    event = dtsec_get_event(p_DtsecMemMap, (uint32_t)(~(DTSEC_IMASK_MMRDEN | DTSEC_IMASK_MMWREN)));
+    event = fman_dtsec_get_event(p_DtsecMemMap, (uint32_t)(~(DTSEC_IMASK_MMRDEN | DTSEC_IMASK_MMWREN)));
 
-    event &= dtsec_get_interrupt_mask(p_DtsecMemMap);
+    event &= fman_dtsec_get_interrupt_mask(p_DtsecMemMap);
 
-    dtsec_ack_event(p_DtsecMemMap, event);
+    fman_dtsec_ack_event(p_DtsecMemMap, event);
 
     if (event & DTSEC_IMASK_BREN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_RX);
@@ -351,7 +351,7 @@ static void Dtsec1588Isr(t_Handle h_Dtsec)
 
     if (p_Dtsec->ptpTsuEnabled)
     {
-        event = dtsec_check_and_clear_tmr_event(p_DtsecMemMap);
+        event = fman_dtsec_check_and_clear_tmr_event(p_DtsecMemMap);
 
         if (event)
         {
@@ -397,7 +397,7 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
     /* Assert the graceful transmit stop bit */
     if (mode & e_COMM_MODE_RX)
     {
-        dtsec_stop_rx(p_MemMap);
+        fman_dtsec_stop_rx(p_MemMap);
 
 #ifdef FM_GRS_ERRATA_DTSEC_A002
         if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
@@ -417,7 +417,7 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
 #ifdef FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014
         DBG(INFO, ("GTS not supported due to DTSEC_A0014 errata."));
 #else  /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
-        dtsec_stop_tx(p_MemMap);
+        fman_dtsec_stop_tx(p_MemMap);
 #endif /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
 #endif /* defined(FM_GTS_ERRATA_DTSEC_A004) ||...  */
 
@@ -436,10 +436,10 @@ static t_Error GracefulRestart(t_Dtsec *p_Dtsec, e_CommMode mode)
 
     /* clear the graceful receive stop bit */
     if (mode & e_COMM_MODE_TX)
-        dtsec_start_tx(p_MemMap);
+        fman_dtsec_start_tx(p_MemMap);
 
     if (mode & e_COMM_MODE_RX)
-        dtsec_start_rx(p_MemMap);
+        fman_dtsec_start_rx(p_MemMap);
 
     return E_OK;
 }
@@ -449,7 +449,6 @@ static t_Error GracefulRestart(t_Dtsec *p_Dtsec, e_CommMode mode)
 /*                      dTSEC Configs modification functions                 */
 /*****************************************************************************/
 
-
 /* .............................................................................. */
 
 static t_Error DtsecConfigLoopback(t_Handle h_Dtsec, bool newVal)
@@ -535,6 +534,8 @@ static t_Error DtsecConfigLengthCheck(t_Handle h_Dtsec, bool newVal)
     return E_OK;
 }
 
+/* .............................................................................. */
+
 static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exception, bool enable)
 {
     t_Dtsec *p_Dtsec = (t_Dtsec *)h_Dtsec;
@@ -573,6 +574,8 @@ static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exceptio
     }
     return E_OK;
 }
+
+
 /*****************************************************************************/
 /*                      dTSEC Run Time API functions                         */
 /*****************************************************************************/
@@ -586,7 +589,7 @@ static t_Error DtsecEnable(t_Handle h_Dtsec,  e_CommMode mode)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    dtsec_enable(p_Dtsec->p_MemMap,
+    fman_dtsec_enable(p_Dtsec->p_MemMap,
                  (bool)!!(mode & e_COMM_MODE_RX),
                  (bool)!!(mode & e_COMM_MODE_TX));
 
@@ -606,7 +609,7 @@ static t_Error DtsecDisable (t_Handle h_Dtsec, e_CommMode mode)
 
     GracefulStop(p_Dtsec, mode);
 
-    dtsec_disable(p_Dtsec->p_MemMap,
+    fman_dtsec_disable(p_Dtsec->p_MemMap,
                   (bool)!!(mode & e_COMM_MODE_RX),
                   (bool)!!(mode & e_COMM_MODE_TX));
 
@@ -635,7 +638,7 @@ static t_Error DtsecSetTxPauseFrames(t_Handle h_Dtsec,
                       " value should be greater than 320."));
 #endif /* FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003 */
 
-    dtsec_set_tx_pause_time(p_Dtsec->p_MemMap, pauseTime);
+    fman_dtsec_set_tx_pause_frames(p_Dtsec->p_MemMap, pauseTime);
     return E_OK;
 }
 
@@ -656,7 +659,7 @@ static t_Error DtsecRxIgnoreMacPause(t_Handle h_Dtsec, bool en)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    dtsec_handle_rx_pause(p_Dtsec->p_MemMap, accept_pause);
+    fman_dtsec_handle_rx_pause(p_Dtsec->p_MemMap, accept_pause);
 
     return E_OK;
 }
@@ -671,7 +674,7 @@ static t_Error DtsecEnable1588TimeStamp(t_Handle h_Dtsec)
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     p_Dtsec->ptpTsuEnabled = TRUE;
-    dtsec_set_ts(p_Dtsec->p_MemMap, TRUE);
+    fman_dtsec_set_ts(p_Dtsec->p_MemMap, TRUE);
 
     return E_OK;
 }
@@ -686,7 +689,7 @@ static t_Error DtsecDisable1588TimeStamp(t_Handle h_Dtsec)
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     p_Dtsec->ptpTsuEnabled = FALSE;
-    dtsec_set_ts(p_Dtsec->p_MemMap, FALSE);
+    fman_dtsec_set_ts(p_Dtsec->p_MemMap, FALSE);
 
     return E_OK;
 }
@@ -711,68 +714,68 @@ static t_Error DtsecGetStatistics(t_Handle h_Dtsec, t_FmMacStatistics *p_Statist
 
     if (p_Dtsec->statisticsLevel == e_FM_MAC_FULL_STATISTICS)
     {
-        p_Statistics->eStatPkts64 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR64)
+        p_Statistics->eStatPkts64 = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR64)
                 + p_Dtsec->internalStatistics.tr64;
-        p_Statistics->eStatPkts65to127 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR127)
+        p_Statistics->eStatPkts65to127 = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR127)
                 + p_Dtsec->internalStatistics.tr127;
-        p_Statistics->eStatPkts128to255 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR255)
+        p_Statistics->eStatPkts128to255 = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR255)
                 + p_Dtsec->internalStatistics.tr255;
-        p_Statistics->eStatPkts256to511 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR511)
+        p_Statistics->eStatPkts256to511 = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR511)
                 + p_Dtsec->internalStatistics.tr511;
-        p_Statistics->eStatPkts512to1023 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR1K)
+        p_Statistics->eStatPkts512to1023 = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR1K)
                 + p_Dtsec->internalStatistics.tr1k;
-        p_Statistics->eStatPkts1024to1518 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TRMAX)
+        p_Statistics->eStatPkts1024to1518 = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TRMAX)
                 + p_Dtsec->internalStatistics.trmax;
-        p_Statistics->eStatPkts1519to1522 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TRMGV)
+        p_Statistics->eStatPkts1519to1522 = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TRMGV)
                 + p_Dtsec->internalStatistics.trmgv;
 
         /* MIB II */
-        p_Statistics->ifInOctets = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RBYT)
+        p_Statistics->ifInOctets = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RBYT)
                 + p_Dtsec->internalStatistics.rbyt;
-        p_Statistics->ifInPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RPKT)
+        p_Statistics->ifInPkts = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RPKT)
                 + p_Dtsec->internalStatistics.rpkt;
         p_Statistics->ifInUcastPkts = 0;
-        p_Statistics->ifInMcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RMCA)
+        p_Statistics->ifInMcastPkts = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RMCA)
                 + p_Dtsec->internalStatistics.rmca;
-        p_Statistics->ifInBcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RBCA)
+        p_Statistics->ifInBcastPkts = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RBCA)
                 + p_Dtsec->internalStatistics.rbca;
-        p_Statistics->ifOutOctets = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TBYT)
+        p_Statistics->ifOutOctets = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TBYT)
                 + p_Dtsec->internalStatistics.tbyt;
-        p_Statistics->ifOutPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TPKT)
+        p_Statistics->ifOutPkts = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TPKT)
                 + p_Dtsec->internalStatistics.tpkt;
         p_Statistics->ifOutUcastPkts = 0;
-        p_Statistics->ifOutMcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TMCA)
+        p_Statistics->ifOutMcastPkts = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TMCA)
                 + p_Dtsec->internalStatistics.tmca;
-        p_Statistics->ifOutBcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TBCA)
+        p_Statistics->ifOutBcastPkts = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TBCA)
                 + p_Dtsec->internalStatistics.tbca;
     }
 
-    p_Statistics->eStatFragments = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RFRG)
+    p_Statistics->eStatFragments = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RFRG)
             + p_Dtsec->internalStatistics.rfrg;
-    p_Statistics->eStatJabbers = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RJBR)
+    p_Statistics->eStatJabbers = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RJBR)
             + p_Dtsec->internalStatistics.rjbr;
-    p_Statistics->eStatsDropEvents = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RDRP)
+    p_Statistics->eStatsDropEvents = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RDRP)
             + p_Dtsec->internalStatistics.rdrp;
-    p_Statistics->eStatCRCAlignErrors = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RALN)
+    p_Statistics->eStatCRCAlignErrors = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RALN)
             + p_Dtsec->internalStatistics.raln;
-    p_Statistics->eStatUndersizePkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RUND)
+    p_Statistics->eStatUndersizePkts = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RUND)
             + p_Dtsec->internalStatistics.rund;
-    p_Statistics->eStatOversizePkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_ROVR)
+    p_Statistics->eStatOversizePkts = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_ROVR)
             + p_Dtsec->internalStatistics.rovr;
-    p_Statistics->reStatPause = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RXPF)
+    p_Statistics->reStatPause = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RXPF)
             + p_Dtsec->internalStatistics.rxpf;
-    p_Statistics->teStatPause = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TXPF)
+    p_Statistics->teStatPause = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TXPF)
             + p_Dtsec->internalStatistics.txpf;
     p_Statistics->ifInDiscards = p_Statistics->eStatsDropEvents;
     p_Statistics->ifInErrors = p_Statistics->eStatsDropEvents + p_Statistics->eStatCRCAlignErrors
-            + dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_RFLR) + p_Dtsec->internalStatistics.rflr
-            + dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_RCDE) + p_Dtsec->internalStatistics.rcde
-            + dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_RCSE) + p_Dtsec->internalStatistics.rcse;
+            + fman_dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_RFLR) + p_Dtsec->internalStatistics.rflr
+            + fman_dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_RCDE) + p_Dtsec->internalStatistics.rcde
+            + fman_dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_RCSE) + p_Dtsec->internalStatistics.rcse;
 
-    p_Statistics->ifOutDiscards = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TDRP)
+    p_Statistics->ifOutDiscards = fman_dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TDRP)
             + p_Dtsec->internalStatistics.tdrp;
     p_Statistics->ifOutErrors = p_Statistics->ifOutDiscards                                           /**< Number of frames transmitted with error: */
-            + dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_TFCS)
+            + fman_dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_TFCS)
             + p_Dtsec->internalStatistics.tfcs;
 
     return E_OK;
@@ -790,7 +793,7 @@ static t_Error DtsecModifyMacAddress (t_Handle h_Dtsec, t_EnetAddr *p_EnetAddr)
     /* Initialize MAC Station Address registers (1 & 2)    */
     /* Station address have to be swapped (big endian to little endian */
     p_Dtsec->addr = ENET_ADDR_TO_UINT64(*p_EnetAddr);
-    dtsec_set_mac_address(p_Dtsec->p_MemMap, (uint8_t *)(*p_EnetAddr));
+    fman_dtsec_set_mac_address(p_Dtsec->p_MemMap, (uint8_t *)(*p_EnetAddr));
 
     return E_OK;
 }
@@ -805,7 +808,7 @@ static t_Error DtsecResetCounters (t_Handle h_Dtsec)
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     /* clear HW counters */
-    dtsec_reset_stat(p_Dtsec->p_MemMap);
+    fman_dtsec_reset_stat(p_Dtsec->p_MemMap);
 
     /* clear SW counters holding carries */
     memset(&p_Dtsec->internalStatistics, 0, sizeof(t_InternalStatistics));
@@ -846,7 +849,7 @@ static t_Error DtsecAddExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthA
             p_Dtsec->paddr[paddrNum] = ethAddr;
 
             /* put in hardware */
-            dtsec_add_addr_in_paddr(p_Dtsec->p_MemMap, (uint64_t)PTR_TO_UINT(&ethAddr), paddrNum);
+            fman_dtsec_add_addr_in_paddr(p_Dtsec->p_MemMap, (uint64_t)PTR_TO_UINT(&ethAddr), paddrNum);
             p_Dtsec->numOfIndAddrInRegs++;
 
             return E_OK;
@@ -878,7 +881,7 @@ static t_Error DtsecDelExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthA
             /* mark this PADDR as not used */
             p_Dtsec->indAddrRegUsed[paddrNum] = FALSE;
             /* clear in hardware */
-            dtsec_clear_addr_in_paddr(p_Dtsec->p_MemMap, paddrNum);
+            fman_dtsec_clear_addr_in_paddr(p_Dtsec->p_MemMap, paddrNum);
             p_Dtsec->numOfIndAddrInRegs--;
 
             return E_OK;
@@ -904,7 +907,7 @@ static t_Error DtsecAddHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
 
     ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
-    ghtx = (bool)((dtsec_get_rctrl(p_Dtsec->p_MemMap) & RCTRL_GHTX) ? TRUE : FALSE);
+    ghtx = (bool)((fman_dtsec_get_rctrl(p_Dtsec->p_MemMap) & RCTRL_GHTX) ? TRUE : FALSE);
     mcast = (bool)((ethAddr & MAC_GROUP_ADDRESS) ? TRUE : FALSE);
 
     if (ghtx && !mcast) /* Cannot handle unicast mac addr when GHTX is on */
@@ -931,7 +934,7 @@ static t_Error DtsecAddHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
             bucket += 0x100;
     }
 
-    dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, TRUE);
+    fman_dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, TRUE);
 
     /* Create element to be added to the driver hash table */
     p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
@@ -964,7 +967,7 @@ static t_Error DtsecDelHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
 
     ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
-    ghtx = (bool)((dtsec_get_rctrl(p_Dtsec->p_MemMap) & RCTRL_GHTX) ? TRUE : FALSE);
+    ghtx = (bool)((fman_dtsec_get_rctrl(p_Dtsec->p_MemMap) & RCTRL_GHTX) ? TRUE : FALSE);
     mcast = (bool)((ethAddr & MAC_GROUP_ADDRESS) ? TRUE : FALSE);
 
     if (ghtx && !mcast) /* Cannot handle unicast mac addr when GHTX is on */
@@ -995,7 +998,7 @@ static t_Error DtsecDelHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
             }
         }
         if (LIST_IsEmpty(&p_Dtsec->p_MulticastAddrHash->p_Lsts[bucket]))
-            dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, FALSE);
+            fman_dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, FALSE);
     }
     else
     {
@@ -1011,7 +1014,7 @@ static t_Error DtsecDelHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
             }
         }
         if (LIST_IsEmpty(&p_Dtsec->p_UnicastAddrHash->p_Lsts[bucket]))
-            dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, FALSE);
+            fman_dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, FALSE);
     }
 
     /* address does not exist */
@@ -1020,17 +1023,6 @@ static t_Error DtsecDelHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
     return E_OK;
 }
 
-void DtsecRestartTbiAN(t_Handle h_Dtsec)
-{
-    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-
-    if (!p_Dtsec)
-	return;
-
-    DTSEC_MII_WritePhyReg(p_Dtsec, p_Dtsec->tbi_phy_addr, 0,
-		PHY_CR_ANE | PHY_CR_RESET_AN | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
-}
-
 /* .............................................................................. */
 
 static t_Error DtsecSetPromiscuous(t_Handle h_Dtsec, bool newVal)
@@ -1040,8 +1032,8 @@ static t_Error DtsecSetPromiscuous(t_Handle h_Dtsec, bool newVal)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    dtsec_set_uc_promisc(p_Dtsec->p_MemMap, newVal);
-    dtsec_set_mc_promisc(p_Dtsec->p_MemMap, newVal);
+    fman_dtsec_set_uc_promisc(p_Dtsec->p_MemMap, newVal);
+    fman_dtsec_set_mc_promisc(p_Dtsec->p_MemMap, newVal);
 
     return E_OK;
 }
@@ -1058,7 +1050,7 @@ static t_Error DtsecSetStatistics(t_Handle h_Dtsec, e_FmMacStatisticsLevel stati
 
     p_Dtsec->statisticsLevel = statisticsLevel;
 
-    err = (t_Error)dtsec_set_stat_level(p_Dtsec->p_MemMap,
+    err = (t_Error)fman_dtsec_set_stat_level(p_Dtsec->p_MemMap,
                                         (enum mac_stat_level)statisticsLevel);
     if (err != E_OK)
         return err;
@@ -1098,7 +1090,7 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
     enet_speed = (enum enet_speed) ENET_SPEED_FROM_MODE(p_Dtsec->enetMode);
     p_Dtsec->halfDuplex = !fullDuplex;
 
-    err = (t_Error)dtsec_adjust_link(p_Dtsec->p_MemMap, enet_interface, enet_speed, fullDuplex);
+    err = (t_Error)fman_dtsec_adjust_link(p_Dtsec->p_MemMap, enet_interface, enet_speed, fullDuplex);
 
     if (err == E_CONFLICT)
         RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
@@ -1123,7 +1115,6 @@ static t_Error DtsecRestartAutoneg(t_Handle h_Dtsec)
     return E_OK;
 }
 
-/*************************************************************************************/
 /* .............................................................................. */
 
 static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
@@ -1147,7 +1138,7 @@ static t_Error DtsecGetVersion(t_Handle h_Dtsec, uint32_t *macVersion)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    *macVersion = dtsec_get_revision(p_Dtsec->p_MemMap);
+    *macVersion = fman_dtsec_get_revision(p_Dtsec->p_MemMap);
 
     return E_OK;
 }
@@ -1176,9 +1167,9 @@ static t_Error DtsecSetException(t_Handle h_Dtsec, e_FmMacExceptions exception,
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
         if (enable)
-            dtsec_enable_interrupt(p_Dtsec->p_MemMap, bitMask);
+            fman_dtsec_enable_interrupt(p_Dtsec->p_MemMap, bitMask);
         else
-            dtsec_disable_interrupt(p_Dtsec->p_MemMap, bitMask);
+            fman_dtsec_disable_interrupt(p_Dtsec->p_MemMap, bitMask);
     }
     else
     {
@@ -1190,10 +1181,10 @@ static t_Error DtsecSetException(t_Handle h_Dtsec, e_FmMacExceptions exception,
             if (enable)
             {
                 p_Dtsec->enTsuErrExeption = TRUE;
-                dtsec_enable_tmr_interrupt(p_Dtsec->p_MemMap);
+                fman_dtsec_enable_tmr_interrupt(p_Dtsec->p_MemMap);
             } else {
                 p_Dtsec->enTsuErrExeption = FALSE;
-                dtsec_disable_tmr_interrupt(p_Dtsec->p_MemMap);
+                fman_dtsec_disable_tmr_interrupt(p_Dtsec->p_MemMap);
             }
             break;
         default:
@@ -1204,8 +1195,6 @@ static t_Error DtsecSetException(t_Handle h_Dtsec, e_FmMacExceptions exception,
     return E_OK;
 }
 
-
-
 /* ........................................................................... */
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -1218,7 +1207,6 @@ static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
 
     if (p_Dtsec->p_MemMap)
     {
-
         DUMP_TITLE(p_Dtsec->p_MemMap, ("dTSEC %d: ", p_Dtsec->macId));
         DUMP_VAR(p_Dtsec->p_MemMap, tsec_id);
         DUMP_VAR(p_Dtsec->p_MemMap, tsec_id2);
@@ -1284,7 +1272,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     enet_speed = (enum enet_speed)ENET_SPEED_FROM_MODE(p_Dtsec->enetMode);
     MAKE_ENET_ADDR_FROM_UINT64(p_Dtsec->addr, ethAddr);
 
-    err = (t_Error)dtsec_init(p_Dtsec->p_MemMap,
+    err = (t_Error)fman_dtsec_init(p_Dtsec->p_MemMap,
                               p_DtsecDriverParam,
                               enet_interface,
                               enet_speed,
@@ -1326,7 +1314,7 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     }
 
     /* Max Frame Length */
-    maxFrmLn = dtsec_get_max_frame_len(p_Dtsec->p_MemMap);
+    maxFrmLn = fman_dtsec_get_max_frame_len(p_Dtsec->p_MemMap);
     err = FmSetMacMaxFrame(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G,
             p_Dtsec->fmMacControllerDriver.macId, maxFrmLn);
 
@@ -1493,7 +1481,7 @@ t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
     /* Plant parameter structure pointer */
     p_Dtsec->p_DtsecDriverParam = p_DtsecDriverParam;
 
-    dtsec_defconfig(p_DtsecDriverParam);
+    fman_dtsec_defconfig(p_DtsecDriverParam);
 
     p_Dtsec->p_MemMap           = (struct dtsec_regs *)UINT_TO_PTR(baseAddr);
     p_Dtsec->p_MiiMemMap        = (struct dtsec_mii_reg *)UINT_TO_PTR(baseAddr + DTSEC_TO_MII_OFFSET);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
index e2deaa2..f07b174 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
@@ -350,13 +350,16 @@ t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac,
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
+    if ((priority != 0xFF) && FmGetTnumAgingPeriod(p_FmMacControllerDriver->h_Fm) == 0)
+        RETURN_ERROR(MAJOR, E_CONFLICT, ("Can't configure PFC when TNUM aging is disabled"));
+
     if (p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames)
         return p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames(h_FmMac,
                                                                   priority,
                                                                   pauseTime,
                                                                   threshTime);
 
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
 /* ......................................................................... */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
index 2ba8554..0bedf58 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
@@ -34,31 +34,31 @@
 #include "fsl_fman_dtsec.h"
 
 
-void dtsec_stop_rx(struct dtsec_regs *regs)
+void fman_dtsec_stop_rx(struct dtsec_regs *regs)
 {
 	/* Assert the graceful stop bit */
 	iowrite32be(ioread32be(&regs->rctrl) | RCTRL_GRS, &regs->rctrl);
 }
 
-void dtsec_stop_tx(struct dtsec_regs *regs)
+void fman_dtsec_stop_tx(struct dtsec_regs *regs)
 {
 	/* Assert the graceful stop bit */
 	iowrite32be(ioread32be(&regs->tctrl) | DTSEC_TCTRL_GTS, &regs->tctrl);
 }
 
-void dtsec_start_tx(struct dtsec_regs *regs)
+void fman_dtsec_start_tx(struct dtsec_regs *regs)
 {
 	/* clear the graceful stop bit */
 	iowrite32be(ioread32be(&regs->tctrl) & ~DTSEC_TCTRL_GTS, &regs->tctrl);
 }
 
-void dtsec_start_rx(struct dtsec_regs *regs)
+void fman_dtsec_start_rx(struct dtsec_regs *regs)
 {
 	/* clear the graceful stop bit */
 	iowrite32be(ioread32be(&regs->rctrl) & ~RCTRL_GRS, &regs->rctrl);
 }
 
-void dtsec_defconfig(struct dtsec_cfg *cfg)
+void fman_dtsec_defconfig(struct dtsec_cfg *cfg)
 {
 	cfg->halfdup_on = DEFAULT_HALFDUP_ON;
 	cfg->halfdup_retransmit = DEFAULT_HALFDUP_RETRANSMIT;
@@ -98,7 +98,7 @@ void dtsec_defconfig(struct dtsec_cfg *cfg)
 	cfg->tbi_phy_addr = DEFAULT_TBI_PHY_ADDR;
 }
 
-int dtsec_init(struct dtsec_regs *regs, struct dtsec_cfg *cfg,
+int fman_dtsec_init(struct dtsec_regs *regs, struct dtsec_cfg *cfg,
 		enum enet_interface iface_mode,
 		enum enet_speed iface_speed,
 		uint8_t *macaddr,
@@ -334,22 +334,22 @@ UNUSED(fm_rev_maj);UNUSED(fm_rev_min);
 		iowrite32be(0, &regs->gaddr[i]);
 	}
 
-	dtsec_reset_stat(regs);
+	fman_dtsec_reset_stat(regs);
 
 	return 0;
 }
 
-uint16_t dtsec_get_max_frame_len(struct dtsec_regs *regs)
+uint16_t fman_dtsec_get_max_frame_len(struct dtsec_regs *regs)
 {
 	return (uint16_t)ioread32be(&regs->maxfrm);
 }
 
-void dtsec_set_max_frame_len(struct dtsec_regs *regs, uint16_t length)
+void fman_dtsec_set_max_frame_len(struct dtsec_regs *regs, uint16_t length)
 {
 	iowrite32be(length, &regs->maxfrm);
 }
 
-void dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *adr)
+void fman_dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *adr)
 {
 	uint32_t tmp;
 
@@ -364,7 +364,7 @@ void dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *adr)
 	iowrite32be(tmp, &regs->macstnaddr2);
 }
 
-void dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr)
+void fman_dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr)
 {
 	uint32_t tmp1, tmp2;
 
@@ -379,7 +379,7 @@ void dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr)
 	macaddr[5] = (uint8_t)((tmp1 & 0xff000000) >> 24);
 }
 
-void dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable)
+void fman_dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable)
 {
 	int reg_idx = (bucket >> 5) & 0xf;
 	int bit_idx = bucket & 0x1f;
@@ -397,7 +397,7 @@ void dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable)
 		iowrite32be(ioread32be(reg) & (~bit_mask), reg);
 }
 
-void dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast)
+void fman_dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast)
 {
 	int		i;
 	bool	ghtx;
@@ -414,7 +414,7 @@ void dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast)
 	}
 }
 
-int dtsec_set_tbi_phy_addr(struct dtsec_regs *regs,
+int fman_dtsec_set_tbi_phy_addr(struct dtsec_regs *regs,
 		uint8_t addr)
 {
 	if (addr > 0 && addr < 32)
@@ -425,7 +425,7 @@ int dtsec_set_tbi_phy_addr(struct dtsec_regs *regs,
 	return 0;
 }
 
-int dtsec_adjust_link(struct dtsec_regs *regs,
+int fman_dtsec_adjust_link(struct dtsec_regs *regs,
 		enum enet_interface iface_mode,
 		enum enet_speed speed, bool full_dx)
 {
@@ -457,7 +457,7 @@ int dtsec_adjust_link(struct dtsec_regs *regs,
 	return 0;
 }
 
-void dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable)
+void fman_dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable)
 {
 	uint32_t		tmp;
 
@@ -471,7 +471,7 @@ void dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable)
 	iowrite32be(tmp, &regs->rctrl);
 }
 
-void dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable)
+void fman_dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable)
 {
 	uint32_t		tmp;
 
@@ -485,7 +485,7 @@ void dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable)
 	iowrite32be(tmp, &regs->rctrl);
 }
 
-bool dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
+bool fman_dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
 				uint32_t *car1, uint32_t *car2)
 {
 	/* read carry registers */
@@ -501,14 +501,14 @@ bool dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
 }
 
 
-void dtsec_reset_stat(struct dtsec_regs *regs)
+void fman_dtsec_reset_stat(struct dtsec_regs *regs)
 {
 	/* clear HW counters */
 	iowrite32be(ioread32be(&regs->ecntrl) |
 			DTSEC_ECNTRL_CLRCNT, &regs->ecntrl);
 }
 
-int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level)
+int fman_dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level)
 {
 	switch (level) {
 	case E_MAC_STAT_NONE:
@@ -550,7 +550,7 @@ int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level)
 	return 0;
 }
 
-void dtsec_set_ts(struct dtsec_regs *regs, bool en)
+void fman_dtsec_set_ts(struct dtsec_regs *regs, bool en)
 {
 	if (en) {
 		iowrite32be(ioread32be(&regs->rctrl) | RCTRL_RTSE,
@@ -565,7 +565,7 @@ void dtsec_set_ts(struct dtsec_regs *regs, bool en)
 	}
 }
 
-void dtsec_enable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
+void fman_dtsec_enable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
 {
 	uint32_t tmp;
 
@@ -580,13 +580,13 @@ void dtsec_enable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
 	iowrite32be(tmp, &regs->maccfg1);
 }
 
-void dtsec_clear_addr_in_paddr(struct dtsec_regs *regs, uint8_t paddr_num)
+void fman_dtsec_clear_addr_in_paddr(struct dtsec_regs *regs, uint8_t paddr_num)
 {
     iowrite32be(0, &regs->macaddr[paddr_num].exact_match1);
     iowrite32be(0, &regs->macaddr[paddr_num].exact_match2);
 }
 
-void dtsec_add_addr_in_paddr(struct dtsec_regs *regs,
+void fman_dtsec_add_addr_in_paddr(struct dtsec_regs *regs,
 				uint64_t addr,
 				uint8_t paddr_num)
 {
@@ -609,7 +609,7 @@ void dtsec_add_addr_in_paddr(struct dtsec_regs *regs,
 	iowrite32be(tmp, &regs->macaddr[paddr_num].exact_match2);
 }
 
-void dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
+void fman_dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
 {
 	uint32_t tmp;
 
@@ -624,7 +624,7 @@ void dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
 	iowrite32be(tmp, &regs->maccfg1);
 }
 
-void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time)
+void fman_dtsec_set_tx_pause_frames(struct dtsec_regs *regs, uint16_t time)
 {
 	uint32_t ptv = 0;
 
@@ -644,7 +644,7 @@ void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time)
 				&regs->maccfg1);
 }
 
-void dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en)
+void fman_dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en)
 {
 	uint32_t tmp;
 
@@ -658,32 +658,32 @@ void dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en)
 	iowrite32be(tmp, &regs->maccfg1);
 }
 
-uint32_t dtsec_get_rctrl(struct dtsec_regs *regs)
+uint32_t fman_dtsec_get_rctrl(struct dtsec_regs *regs)
 {
 	return ioread32be(&regs->rctrl);
 }
 
-uint32_t dtsec_get_revision(struct dtsec_regs *regs)
+uint32_t fman_dtsec_get_revision(struct dtsec_regs *regs)
 {
 	return ioread32be(&regs->tsec_id);
 }
 
-uint32_t dtsec_get_event(struct dtsec_regs *regs, uint32_t ev_mask)
+uint32_t fman_dtsec_get_event(struct dtsec_regs *regs, uint32_t ev_mask)
 {
 	return ioread32be(&regs->ievent) & ev_mask;
 }
 
-void dtsec_ack_event(struct dtsec_regs *regs, uint32_t ev_mask)
+void fman_dtsec_ack_event(struct dtsec_regs *regs, uint32_t ev_mask)
 {
 	iowrite32be(ev_mask, &regs->ievent);
 }
 
-uint32_t dtsec_get_interrupt_mask(struct dtsec_regs *regs)
+uint32_t fman_dtsec_get_interrupt_mask(struct dtsec_regs *regs)
 {
 	return ioread32be(&regs->imask);
 }
 
-uint32_t dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs)
+uint32_t fman_dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs)
 {
 	uint32_t event;
 
@@ -695,29 +695,29 @@ uint32_t dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs)
 	return event;
 }
 
-void dtsec_enable_tmr_interrupt(struct dtsec_regs *regs)
+void fman_dtsec_enable_tmr_interrupt(struct dtsec_regs *regs)
 {
 	iowrite32be(ioread32be(&regs->tmr_pemask) | TMR_PEMASK_TSREEN,
 			&regs->tmr_pemask);
 }
 
-void dtsec_disable_tmr_interrupt(struct dtsec_regs *regs)
+void fman_dtsec_disable_tmr_interrupt(struct dtsec_regs *regs)
 {
 	iowrite32be(ioread32be(&regs->tmr_pemask) & ~TMR_PEMASK_TSREEN,
 			&regs->tmr_pemask);
 }
 
-void dtsec_enable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask)
+void fman_dtsec_enable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask)
 {
 	iowrite32be(ioread32be(&regs->imask) | ev_mask, &regs->imask);
 }
 
-void dtsec_disable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask)
+void fman_dtsec_disable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask)
 {
 	iowrite32be(ioread32be(&regs->imask) & ~ev_mask, &regs->imask);
 }
 
-uint32_t dtsec_get_stat_counter(struct dtsec_regs *regs,
+uint32_t fman_dtsec_get_stat_counter(struct dtsec_regs *regs,
 		enum dtsec_stat_counters reg_name)
 {
 	uint32_t ret_val;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
index a63d06a..ad0955d 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_memac.c
@@ -34,394 +34,422 @@
 #include "fsl_fman_memac.h"
 
 
-uint32_t memac_get_event(struct memac_regs *regs, uint32_t ev_mask)
+uint32_t fman_memac_get_event(struct memac_regs *regs, uint32_t ev_mask)
 {
-	return ioread32be(&regs->ievent) & ev_mask;
+    return ioread32be(&regs->ievent) & ev_mask;
 }
 
-uint32_t memac_get_interrupt_mask(struct memac_regs *regs)
+uint32_t fman_memac_get_interrupt_mask(struct memac_regs *regs)
 {
-	return ioread32be(&regs->imask);
+    return ioread32be(&regs->imask);
 }
 
-void memac_ack_event(struct memac_regs *regs, uint32_t ev_mask)
+void fman_memac_ack_event(struct memac_regs *regs, uint32_t ev_mask)
 {
-	iowrite32be(ev_mask, &regs->ievent);
+    iowrite32be(ev_mask, &regs->ievent);
 }
 
-void memac_set_promiscuous(struct memac_regs *regs, bool val)
+void fman_memac_set_promiscuous(struct memac_regs *regs, bool val)
 {
-	uint32_t tmp;
+    uint32_t tmp;
 
-	tmp = ioread32be(&regs->command_config);
+    tmp = ioread32be(&regs->command_config);
 
-	if (val)
-		tmp |= CMD_CFG_PROMIS_EN;
-	else
-		tmp &= ~CMD_CFG_PROMIS_EN;
+    if (val)
+        tmp |= CMD_CFG_PROMIS_EN;
+    else
+        tmp &= ~CMD_CFG_PROMIS_EN;
 
-	iowrite32be(tmp, &regs->command_config);
+    iowrite32be(tmp, &regs->command_config);
 }
 
-void memac_hardware_clear_addr_in_paddr(struct memac_regs *regs,
-					uint8_t paddr_num)
+void fman_memac_clear_addr_in_paddr(struct memac_regs *regs,
+                    uint8_t paddr_num)
 {
-	if (paddr_num == 0) {
-		iowrite32be(0, &regs->mac_addr0.mac_addr_l);
-		iowrite32be(0, &regs->mac_addr0.mac_addr_u);
-	} else {
-		iowrite32be(0x0, &regs->mac_addr[paddr_num - 1].mac_addr_l);
-		iowrite32be(0x0, &regs->mac_addr[paddr_num - 1].mac_addr_u);
-	}
+    if (paddr_num == 0) {
+        iowrite32be(0, &regs->mac_addr0.mac_addr_l);
+        iowrite32be(0, &regs->mac_addr0.mac_addr_u);
+    } else {
+        iowrite32be(0x0, &regs->mac_addr[paddr_num - 1].mac_addr_l);
+        iowrite32be(0x0, &regs->mac_addr[paddr_num - 1].mac_addr_u);
+    }
 }
 
-void memac_hardware_add_addr_in_paddr(struct memac_regs *regs,
-					uint8_t *adr,
-					uint8_t paddr_num)
+void fman_memac_add_addr_in_paddr(struct memac_regs *regs,
+                    uint8_t *adr,
+                    uint8_t paddr_num)
 {
-	uint32_t tmp0, tmp1;
-
-	tmp0 = (uint32_t)(adr[0] |
-			adr[1] << 8 |
-			adr[2] << 16 |
-			adr[3] << 24);
-	tmp1 = (uint32_t)(adr[4] | adr[5] << 8);
-
-	if (paddr_num == 0) {
-		iowrite32be(tmp0, &regs->mac_addr0.mac_addr_l);
-		iowrite32be(tmp1, &regs->mac_addr0.mac_addr_u);
-	} else {
-		iowrite32be(tmp0, &regs->mac_addr[paddr_num-1].mac_addr_l);
-		iowrite32be(tmp1, &regs->mac_addr[paddr_num-1].mac_addr_u);
-	}
+    uint32_t tmp0, tmp1;
+
+    tmp0 = (uint32_t)(adr[0] |
+            adr[1] << 8 |
+            adr[2] << 16 |
+            adr[3] << 24);
+    tmp1 = (uint32_t)(adr[4] | adr[5] << 8);
+
+    if (paddr_num == 0) {
+        iowrite32be(tmp0, &regs->mac_addr0.mac_addr_l);
+        iowrite32be(tmp1, &regs->mac_addr0.mac_addr_u);
+    } else {
+        iowrite32be(tmp0, &regs->mac_addr[paddr_num-1].mac_addr_l);
+        iowrite32be(tmp1, &regs->mac_addr[paddr_num-1].mac_addr_u);
+    }
 }
 
-void memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx)
+void fman_memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx)
 {
-	uint32_t tmp;
+    uint32_t tmp;
 
-	tmp = ioread32be(&regs->command_config);
+    tmp = ioread32be(&regs->command_config);
 
-	if (apply_rx)
-		tmp |= CMD_CFG_RX_EN;
+    if (apply_rx)
+        tmp |= CMD_CFG_RX_EN;
 
-	if (apply_tx)
-		tmp |= CMD_CFG_TX_EN;
+    if (apply_tx)
+        tmp |= CMD_CFG_TX_EN;
 
-	iowrite32be(tmp, &regs->command_config);
+    iowrite32be(tmp, &regs->command_config);
 }
 
-void memac_disable(struct memac_regs *regs, bool apply_rx, bool apply_tx)
+void fman_memac_disable(struct memac_regs *regs, bool apply_rx, bool apply_tx)
 {
-	uint32_t tmp;
+    uint32_t tmp;
 
-	tmp = ioread32be(&regs->command_config);
+    tmp = ioread32be(&regs->command_config);
 
-	if (apply_rx)
-		tmp &= ~CMD_CFG_RX_EN;
+    if (apply_rx)
+        tmp &= ~CMD_CFG_RX_EN;
 
-	if (apply_tx)
-		tmp &= ~CMD_CFG_TX_EN;
+    if (apply_tx)
+        tmp &= ~CMD_CFG_TX_EN;
 
-	iowrite32be(tmp, &regs->command_config);
+    iowrite32be(tmp, &regs->command_config);
 }
 
-void memac_reset_counter(struct memac_regs *regs)
+void fman_memac_reset_stat(struct memac_regs *regs)
 {
-	uint32_t tmp;
+    uint32_t tmp;
 
-	tmp = ioread32be(&regs->statn_config);
+    tmp = ioread32be(&regs->statn_config);
 
-	tmp |= STATS_CFG_CLR;
+    tmp |= STATS_CFG_CLR;
 
-	iowrite32be(tmp, &regs->statn_config);
+    iowrite32be(tmp, &regs->statn_config);
 
-	while (ioread32be(&regs->statn_config) & STATS_CFG_CLR);
+    while (ioread32be(&regs->statn_config) & STATS_CFG_CLR);
 }
 
-void memac_reset(struct memac_regs *regs)
+void fman_memac_reset(struct memac_regs *regs)
 {
-	uint32_t tmp;
+    uint32_t tmp;
 
-	tmp = ioread32be(&regs->command_config);
+    tmp = ioread32be(&regs->command_config);
 
-	tmp |= CMD_CFG_SW_RESET;
+    tmp |= CMD_CFG_SW_RESET;
 
-	iowrite32be(tmp, &regs->command_config);
+    iowrite32be(tmp, &regs->command_config);
 
-	while (ioread32be(&regs->command_config) & CMD_CFG_SW_RESET);
+    while (ioread32be(&regs->command_config) & CMD_CFG_SW_RESET);
 }
 
-void memac_init(struct memac_regs *regs,
-		struct memac_cfg *cfg,
-		enum enet_interface enet_interface,
-		enum enet_speed enet_speed,
-		uint32_t exceptions)
+int fman_memac_init(struct memac_regs *regs,
+        struct memac_cfg *cfg,
+        enum enet_interface enet_interface,
+        enum enet_speed enet_speed,
+        uint32_t exceptions)
 {
-	uint32_t    tmp;
-
-	/* Config */
-	tmp = 0;
-	if (cfg->wan_mode_enable)
-		tmp |= CMD_CFG_WAN_MODE;
-	if (cfg->promiscuous_mode_enable)
-		tmp |= CMD_CFG_PROMIS_EN;
-	if (cfg->pause_forward_enable)
-		tmp |= CMD_CFG_PAUSE_FWD;
-	if (cfg->pause_ignore)
-		tmp |= CMD_CFG_PAUSE_IGNORE;
-	if (cfg->tx_addr_ins_enable)
-		tmp |= CMD_CFG_TX_ADDR_INS;
-	if (cfg->loopback_enable)
-		tmp |= CMD_CFG_LOOPBACK_EN;
-	if (cfg->cmd_frame_enable)
-		tmp |= CMD_CFG_CNT_FRM_EN;
-	if (cfg->send_idle_enable)
-		tmp |= CMD_CFG_SEND_IDLE;
-	if (cfg->no_length_check_enable)
-		tmp |= CMD_CFG_NO_LEN_CHK;
-	if (cfg->rx_sfd_any)
-		tmp |= CMD_CFG_SFD_ANY;
-	if (cfg->pad_enable)
-		tmp |= CMD_CFG_TX_PAD_EN;
-
-	tmp |= CMD_CFG_CRC_FWD;
-
-	iowrite32be(tmp, &regs->command_config);
-
-	/* Max Frame Length */
-	iowrite32be((uint32_t)cfg->max_frame_length, &regs->maxfrm);
-
-	/* Pause Time */
-	iowrite32be(cfg->pause_quanta, &regs->pause_quanta[0]);
-	iowrite32be(0, &regs->pause_thresh[0]);
-
-	/* interrupts */
-	iowrite32be(MEMAC_EVENTS_MASK, &regs->ievent);
-	iowrite32be(exceptions, &regs->imask);
-
-	/* IF_MODE */
-	tmp = 0;
-	switch (enet_interface) {
-	case E_ENET_IF_XGMII:
-	case E_ENET_IF_XFI:
-		tmp |= IF_MODE_XGMII;
-		break;
-	default:
-		tmp |= IF_MODE_GMII;
-		if (enet_interface == E_ENET_IF_RGMII)
-			tmp |= IF_MODE_RGMII | IF_MODE_RGMII_AUTO;
-	}
-	iowrite32be(tmp, &regs->if_mode);
+    uint32_t    tmp;
+
+    /* Config */
+    tmp = 0;
+    if (cfg->wan_mode_enable)
+        tmp |= CMD_CFG_WAN_MODE;
+    if (cfg->promiscuous_mode_enable)
+        tmp |= CMD_CFG_PROMIS_EN;
+    if (cfg->pause_forward_enable)
+        tmp |= CMD_CFG_PAUSE_FWD;
+    if (cfg->pause_ignore)
+        tmp |= CMD_CFG_PAUSE_IGNORE;
+    if (cfg->tx_addr_ins_enable)
+        tmp |= CMD_CFG_TX_ADDR_INS;
+    if (cfg->loopback_enable)
+        tmp |= CMD_CFG_LOOPBACK_EN;
+    if (cfg->cmd_frame_enable)
+        tmp |= CMD_CFG_CNT_FRM_EN;
+    if (cfg->send_idle_enable)
+        tmp |= CMD_CFG_SEND_IDLE;
+    if (cfg->no_length_check_enable)
+        tmp |= CMD_CFG_NO_LEN_CHK;
+    if (cfg->rx_sfd_any)
+        tmp |= CMD_CFG_SFD_ANY;
+    if (cfg->pad_enable)
+        tmp |= CMD_CFG_TX_PAD_EN;
+
+    tmp |= CMD_CFG_CRC_FWD;
+
+    iowrite32be(tmp, &regs->command_config);
+
+    /* Max Frame Length */
+    iowrite32be((uint32_t)cfg->max_frame_length, &regs->maxfrm);
+
+    /* Pause Time */
+    iowrite32be((uint32_t)cfg->pause_quanta, &regs->pause_quanta[0]);
+    iowrite32be((uint32_t)0, &regs->pause_thresh[0]);
+
+    /* IF_MODE */
+    tmp = 0;
+    switch (enet_interface) {
+    case E_ENET_IF_XGMII:
+    case E_ENET_IF_XFI:
+        tmp |= IF_MODE_XGMII;
+        break;
+    default:
+        tmp |= IF_MODE_GMII;
+        if (enet_interface == E_ENET_IF_RGMII && !cfg->loopback_enable)
+            tmp |= IF_MODE_RGMII | IF_MODE_RGMII_AUTO;
+    }
+    iowrite32be(tmp, &regs->if_mode);
+
+    /* clear all pending events and set-up interrupts */
+    fman_memac_ack_event(regs, 0xffffffff);
+    fman_memac_set_exception(regs, exceptions, TRUE);
+
+    return 0;
 }
 
-void memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable)
+void fman_memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable)
 {
-	uint32_t tmp;
+    uint32_t tmp;
 
-	tmp = ioread32be(&regs->imask);
-	if (enable)
-		tmp |= val;
-	else
-		tmp &= ~val;
+    tmp = ioread32be(&regs->imask);
+    if (enable)
+        tmp |= val;
+    else
+        tmp &= ~val;
 
-	iowrite32be(tmp, &regs->imask);
+    iowrite32be(tmp, &regs->imask);
 }
 
-void memac_set_hash_table(struct memac_regs *regs, uint32_t val)
+void fman_memac_set_hash_table(struct memac_regs *regs, uint32_t val)
 {
-	iowrite32be(val, &regs->hashtable_ctrl);
+    iowrite32be(val, &regs->hashtable_ctrl);
 }
 
-uint16_t memac_get_max_frame_length(struct memac_regs *regs)
+uint16_t fman_memac_get_max_frame_len(struct memac_regs *regs)
 {
-	uint32_t tmp;
+    uint32_t tmp;
 
-	tmp = ioread32be(&regs->maxfrm);
+    tmp = ioread32be(&regs->maxfrm);
 
-	return(uint16_t)tmp;
+    return(uint16_t)tmp;
 }
 
 
-void memac_set_tx_pause_frames(struct memac_regs *regs,
-				uint8_t priority,
-				uint16_t pause_time,
-				uint16_t thresh_time)
+void fman_memac_set_tx_pause_frames(struct memac_regs *regs,
+                uint8_t priority,
+                uint16_t pause_time,
+                uint16_t thresh_time)
 {
-	uint32_t tmp;
-
-	tmp = ioread32be(&regs->command_config);
-	if (priority == 0xff) {
-		tmp &= ~CMD_CFG_PFC_MODE;
-		priority = 0;
-	}
-	else
-		tmp |= CMD_CFG_PFC_MODE;
-
-	iowrite32be(tmp, &regs->command_config);
-
-	tmp = ioread32be(&regs->pause_quanta[priority / 2]);
-	if (priority % 2)
-	    tmp &= 0x0000FFFF;
-	else
-	    tmp &= 0xFFFF0000;
-	tmp |= ((uint32_t)pause_time << (16 * (priority % 2)));
-	iowrite32be(tmp, &regs->pause_quanta[priority / 2]);
-
-	tmp = ioread32be(&regs->pause_thresh[priority / 2]);
-	if (priority % 2)
-	        tmp &= 0x0000FFFF;
-	else
-	        tmp &= 0xFFFF0000;
-	tmp |= ((uint32_t)thresh_time<<(16 * (priority % 2)));
-	iowrite32be(tmp, &regs->pause_thresh[priority / 2]);
-}
+    uint32_t tmp;
 
-void memac_set_rx_ignore_pause_frames(struct memac_regs    *regs,bool enable)
-{
-	uint32_t tmp;
+    tmp = ioread32be(&regs->command_config);
+    if (priority == 0xff) {
+        tmp &= ~CMD_CFG_PFC_MODE;
+        priority = 0;
+    }
+    else
+        tmp |= CMD_CFG_PFC_MODE;
 
-	tmp = ioread32be(&regs->command_config);
-	if (enable)
-		tmp |= CMD_CFG_PAUSE_IGNORE;
-	else
-		tmp &= ~CMD_CFG_PAUSE_IGNORE;
+    iowrite32be(tmp, &regs->command_config);
+
+    tmp = ioread32be(&regs->pause_quanta[priority / 2]);
+    if (priority % 2)
+        tmp &= 0x0000FFFF;
+    else
+        tmp &= 0xFFFF0000;
+    tmp |= ((uint32_t)pause_time << (16 * (priority % 2)));
+    iowrite32be(tmp, &regs->pause_quanta[priority / 2]);
 
-	iowrite32be(tmp, &regs->command_config);
+    tmp = ioread32be(&regs->pause_thresh[priority / 2]);
+    if (priority % 2)
+            tmp &= 0x0000FFFF;
+    else
+            tmp &= 0xFFFF0000;
+    tmp |= ((uint32_t)thresh_time<<(16 * (priority % 2)));
+    iowrite32be(tmp, &regs->pause_thresh[priority / 2]);
 }
 
-void memac_set_loopback(struct memac_regs *regs, bool enable)
+void fman_memac_set_rx_ignore_pause_frames(struct memac_regs    *regs,bool enable)
 {
     uint32_t tmp;
 
     tmp = ioread32be(&regs->command_config);
-
     if (enable)
-        tmp |= CMD_CFG_LOOPBACK_EN;
+        tmp |= CMD_CFG_PAUSE_IGNORE;
     else
-        tmp &= ~CMD_CFG_LOOPBACK_EN;
+        tmp &= ~CMD_CFG_PAUSE_IGNORE;
 
     iowrite32be(tmp, &regs->command_config);
 }
 
-
 #define GET_MEMAC_CNTR_64(bn) \
-		(ioread32be(&regs->bn ## _l) | \
-		((uint64_t)ioread32be(&regs->bn ## _u) << 32))
+        (ioread32be(&regs->bn ## _l) | \
+        ((uint64_t)ioread32be(&regs->bn ## _u) << 32))
+
+uint64_t fman_memac_get_counter(struct memac_regs *regs,
+                enum memac_counters reg_name)
+{
+    uint64_t ret_val;
+
+    switch (reg_name) {
+    case E_MEMAC_COUNTER_R64:
+        ret_val = GET_MEMAC_CNTR_64(r64);
+        break;
+    case E_MEMAC_COUNTER_R127:
+        ret_val = GET_MEMAC_CNTR_64(r127);
+        break;
+    case E_MEMAC_COUNTER_R255:
+        ret_val = GET_MEMAC_CNTR_64(r255);
+        break;
+    case E_MEMAC_COUNTER_R511:
+        ret_val = GET_MEMAC_CNTR_64(r511);
+        break;
+    case E_MEMAC_COUNTER_R1023:
+        ret_val = GET_MEMAC_CNTR_64(r1023);
+        break;
+    case E_MEMAC_COUNTER_R1518:
+        ret_val = GET_MEMAC_CNTR_64(r1518);
+        break;
+    case E_MEMAC_COUNTER_R1519X:
+        ret_val = GET_MEMAC_CNTR_64(r1519x);
+        break;
+    case E_MEMAC_COUNTER_RFRG:
+        ret_val = GET_MEMAC_CNTR_64(rfrg);
+        break;
+    case E_MEMAC_COUNTER_RJBR:
+        ret_val = GET_MEMAC_CNTR_64(rjbr);
+        break;
+    case E_MEMAC_COUNTER_RDRP:
+        ret_val = GET_MEMAC_CNTR_64(rdrp);
+        break;
+    case E_MEMAC_COUNTER_RALN:
+        ret_val = GET_MEMAC_CNTR_64(raln);
+        break;
+    case E_MEMAC_COUNTER_TUND:
+        ret_val = GET_MEMAC_CNTR_64(tund);
+        break;
+    case E_MEMAC_COUNTER_ROVR:
+        ret_val = GET_MEMAC_CNTR_64(rovr);
+        break;
+    case E_MEMAC_COUNTER_RXPF:
+        ret_val = GET_MEMAC_CNTR_64(rxpf);
+        break;
+    case E_MEMAC_COUNTER_TXPF:
+        ret_val = GET_MEMAC_CNTR_64(txpf);
+        break;
+    case E_MEMAC_COUNTER_ROCT:
+        ret_val = GET_MEMAC_CNTR_64(roct);
+        break;
+    case E_MEMAC_COUNTER_RMCA:
+        ret_val = GET_MEMAC_CNTR_64(rmca);
+        break;
+    case E_MEMAC_COUNTER_RBCA:
+        ret_val = GET_MEMAC_CNTR_64(rbca);
+        break;
+    case E_MEMAC_COUNTER_RPKT:
+        ret_val = GET_MEMAC_CNTR_64(rpkt);
+        break;
+    case E_MEMAC_COUNTER_RUCA:
+        ret_val = GET_MEMAC_CNTR_64(ruca);
+        break;
+    case E_MEMAC_COUNTER_RERR:
+        ret_val = GET_MEMAC_CNTR_64(rerr);
+        break;
+    case E_MEMAC_COUNTER_TOCT:
+        ret_val = GET_MEMAC_CNTR_64(toct);
+        break;
+    case E_MEMAC_COUNTER_TMCA:
+        ret_val = GET_MEMAC_CNTR_64(tmca);
+        break;
+    case E_MEMAC_COUNTER_TBCA:
+        ret_val = GET_MEMAC_CNTR_64(tbca);
+        break;
+    case E_MEMAC_COUNTER_TUCA:
+        ret_val = GET_MEMAC_CNTR_64(tuca);
+        break;
+    case E_MEMAC_COUNTER_TERR:
+        ret_val = GET_MEMAC_CNTR_64(terr);
+        break;
+    default:
+        ret_val = 0;
+    }
+
+    return ret_val;
+}
 
-uint64_t memac_get_counter(struct memac_regs *regs,
-				enum memac_counters reg_name)
+void fman_memac_adjust_link(struct memac_regs *regs,
+        enum enet_interface iface_mode,
+        enum enet_speed speed, bool full_dx)
 {
-	uint64_t ret_val;
-
-	switch (reg_name) {
-	case E_MEMAC_COUNTER_R64:
-		ret_val = GET_MEMAC_CNTR_64(r64);
-		break;
-	case E_MEMAC_COUNTER_R127:
-		ret_val = GET_MEMAC_CNTR_64(r127);
-		break;
-	case E_MEMAC_COUNTER_R255:
-		ret_val = GET_MEMAC_CNTR_64(r255);
-		break;
-	case E_MEMAC_COUNTER_R511:
-		ret_val = GET_MEMAC_CNTR_64(r511);
-		break;
-	case E_MEMAC_COUNTER_R1023:
-		ret_val = GET_MEMAC_CNTR_64(r1023);
-		break;
-	case E_MEMAC_COUNTER_R1518:
-		ret_val = GET_MEMAC_CNTR_64(r1518);
-		break;
-	case E_MEMAC_COUNTER_R1519X:
-		ret_val = GET_MEMAC_CNTR_64(r1519x);
-		break;
-	case E_MEMAC_COUNTER_RFRG:
-		ret_val = GET_MEMAC_CNTR_64(rfrg);
-		break;
-	case E_MEMAC_COUNTER_RJBR:
-		ret_val = GET_MEMAC_CNTR_64(rjbr);
-		break;
-	case E_MEMAC_COUNTER_RDRP:
-		ret_val = GET_MEMAC_CNTR_64(rdrp);
-		break;
-	case E_MEMAC_COUNTER_RALN:
-		ret_val = GET_MEMAC_CNTR_64(raln);
-		break;
-	case E_MEMAC_COUNTER_TUND:
-		ret_val = GET_MEMAC_CNTR_64(tund);
-		break;
-	case E_MEMAC_COUNTER_ROVR:
-		ret_val = GET_MEMAC_CNTR_64(rovr);
-		break;
-	case E_MEMAC_COUNTER_RXPF:
-		ret_val = GET_MEMAC_CNTR_64(rxpf);
-		break;
-	case E_MEMAC_COUNTER_TXPF:
-		ret_val = GET_MEMAC_CNTR_64(txpf);
-		break;
-	case E_MEMAC_COUNTER_ROCT:
-		ret_val = GET_MEMAC_CNTR_64(roct);
-		break;
-	case E_MEMAC_COUNTER_RMCA:
-		ret_val = GET_MEMAC_CNTR_64(rmca);
-		break;
-	case E_MEMAC_COUNTER_RBCA:
-		ret_val = GET_MEMAC_CNTR_64(rbca);
-		break;
-	case E_MEMAC_COUNTER_RPKT:
-		ret_val = GET_MEMAC_CNTR_64(rpkt);
-		break;
-	case E_MEMAC_COUNTER_RUCA:
-		ret_val = GET_MEMAC_CNTR_64(ruca);
-		break;
-	case E_MEMAC_COUNTER_RERR:
-		ret_val = GET_MEMAC_CNTR_64(rerr);
-		break;
-	case E_MEMAC_COUNTER_TOCT:
-		ret_val = GET_MEMAC_CNTR_64(toct);
-		break;
-	case E_MEMAC_COUNTER_TMCA:
-		ret_val = GET_MEMAC_CNTR_64(tmca);
-		break;
-	case E_MEMAC_COUNTER_TBCA:
-		ret_val = GET_MEMAC_CNTR_64(tbca);
-		break;
-	case E_MEMAC_COUNTER_TUCA:
-		ret_val = GET_MEMAC_CNTR_64(tuca);
-		break;
-	case E_MEMAC_COUNTER_TERR:
-		ret_val = GET_MEMAC_CNTR_64(terr);
-		break;
-	default:
-		ret_val = 0;
-	}
-
-	return ret_val;
+    uint32_t    tmp;
+
+    tmp = ioread32be(&regs->if_mode);
+
+    if (full_dx)
+        tmp &= ~IF_MODE_HD;
+    else
+        tmp |= IF_MODE_HD;
+
+    if (iface_mode == E_ENET_IF_RGMII) {
+        /* Configure RGMII in manual mode */
+        tmp &= ~IF_MODE_RGMII_AUTO;
+        tmp &= ~IF_MODE_RGMII_SP_MASK;
+
+        if (full_dx)
+            tmp |= IF_MODE_RGMII_FD;
+        else
+            tmp &= ~IF_MODE_RGMII_FD;
+
+        switch (speed) {
+        case E_ENET_SPEED_1000:
+            tmp |= IF_MODE_RGMII_1000;
+            break;
+        case E_ENET_SPEED_100:
+            tmp |= IF_MODE_RGMII_100;
+            break;
+        case E_ENET_SPEED_10:
+            tmp |= IF_MODE_RGMII_10;
+            break;
+        default:
+            break;
+        }
+    }
+
+    iowrite32be(tmp, &regs->if_mode);
 }
 
-void memac_defconfig(struct memac_cfg *cfg)
+void fman_memac_defconfig(struct memac_cfg *cfg)
 {
-	cfg->reset_on_init		= FALSE;
-	cfg->wan_mode_enable		= FALSE;
-	cfg->promiscuous_mode_enable	= FALSE;
-	cfg->pause_forward_enable	= FALSE;
-	cfg->pause_ignore		= FALSE;
-	cfg->tx_addr_ins_enable		= FALSE;
-	cfg->loopback_enable		= FALSE;
-	cfg->cmd_frame_enable		= FALSE;
-	cfg->rx_error_discard		= FALSE;
-	cfg->send_idle_enable		= FALSE;
-	cfg->no_length_check_enable	= TRUE;
-	cfg->lgth_check_nostdr		= FALSE;
-	cfg->time_stamp_enable		= FALSE;
-	cfg->tx_ipg_length		= DEFAULT_TX_IPG_LENGTH;
-	cfg->max_frame_length		= DEFAULT_FRAME_LENGTH;
-	cfg->pause_quanta		= DEFAULT_PAUSE_QUANTA;
-	cfg->pad_enable			= TRUE;
-	cfg->phy_tx_ena_on		= FALSE;
-	cfg->rx_sfd_any			= FALSE;
-	cfg->rx_pbl_fwd			= FALSE;
-	cfg->tx_pbl_fwd			= FALSE;
-	cfg->debug_mode			= FALSE;
+    cfg->reset_on_init		= FALSE;
+    cfg->wan_mode_enable		= FALSE;
+    cfg->promiscuous_mode_enable	= FALSE;
+    cfg->pause_forward_enable	= FALSE;
+    cfg->pause_ignore		= FALSE;
+    cfg->tx_addr_ins_enable		= FALSE;
+    cfg->loopback_enable		= FALSE;
+    cfg->cmd_frame_enable		= FALSE;
+    cfg->rx_error_discard		= FALSE;
+    cfg->send_idle_enable		= FALSE;
+    cfg->no_length_check_enable	= TRUE;
+    cfg->lgth_check_nostdr		= FALSE;
+    cfg->time_stamp_enable		= FALSE;
+    cfg->tx_ipg_length		= DEFAULT_TX_IPG_LENGTH;
+    cfg->max_frame_length		= DEFAULT_FRAME_LENGTH;
+    cfg->pause_quanta		= DEFAULT_PAUSE_QUANTA;
+    cfg->pad_enable			= TRUE;
+    cfg->phy_tx_ena_on		= FALSE;
+    cfg->rx_sfd_any			= FALSE;
+    cfg->rx_pbl_fwd			= FALSE;
+    cfg->tx_pbl_fwd			= FALSE;
+    cfg->debug_mode			= FALSE;
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_tgec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_tgec.c
index fa80a36..9ff36a3 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_tgec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_tgec.c
@@ -34,7 +34,7 @@
 #include "fsl_fman_tgec.h"
 
 
-void tgec_set_mac_address(struct tgec_regs *regs, uint8_t *adr)
+void fman_tgec_set_mac_address(struct tgec_regs *regs, uint8_t *adr)
 {
 	uint32_t tmp0, tmp1;
 
@@ -47,7 +47,7 @@ void tgec_set_mac_address(struct tgec_regs *regs, uint8_t *adr)
 	iowrite32be(tmp1, &regs->mac_addr_1);
 }
 
-void tgec_reset_stat(struct tgec_regs *regs)
+void fman_tgec_reset_stat(struct tgec_regs *regs)
 {
 	uint32_t tmp;
 
@@ -57,14 +57,14 @@ void tgec_reset_stat(struct tgec_regs *regs)
 
 	iowrite32be(tmp, &regs->command_config);
 
-	while (ioread32be(&regs->command_config) & CMD_CFG_STAT_CLR);
+	while (ioread32be(&regs->command_config) & CMD_CFG_STAT_CLR) ;
 }
 
 #define GET_TGEC_CNTR_64(bn) \
 	(((uint64_t)ioread32be(&regs->bn ## _u) << 32) | \
 			ioread32be(&regs->bn ## _l))
 
-uint64_t tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name)
+uint64_t fman_tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name)
 {
 	uint64_t ret_val;
 
@@ -154,7 +154,7 @@ uint64_t tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name)
 	return ret_val;
 }
 
-void tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
+void fman_tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
 {
 	uint32_t tmp;
 
@@ -166,7 +166,7 @@ void tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
 	iowrite32be(tmp, &regs->command_config);
 }
 
-void tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
+void fman_tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
 {
 	uint32_t tmp_reg_32;
 
@@ -178,31 +178,29 @@ void tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
 	iowrite32be(tmp_reg_32, &regs->command_config);
 }
 
-void tgec_set_promiscuous(struct tgec_regs *regs, bool val)
+void fman_tgec_set_promiscuous(struct tgec_regs *regs, bool val)
 {
 	uint32_t tmp;
 
 	tmp = ioread32be(&regs->command_config);
-
 	if (val)
 		tmp |= CMD_CFG_PROMIS_EN;
 	else
 		tmp &= ~CMD_CFG_PROMIS_EN;
-
 	iowrite32be(tmp, &regs->command_config);
 }
 
-void tgec_set_hash_table(struct tgec_regs *regs, uint32_t value)
+void fman_tgec_set_hash_table(struct tgec_regs *regs, uint32_t value)
 {
 	iowrite32be(value, &regs->hashtable_ctrl);
 }
 
-void tgec_tx_mac_pause(struct tgec_regs *regs, uint16_t pause_time)
+void fman_tgec_set_tx_pause_frames(struct tgec_regs *regs, uint16_t pause_time)
 {
 	iowrite32be((uint32_t)pause_time, &regs->pause_quant);
 }
 
-void tgec_rx_ignore_mac_pause(struct tgec_regs *regs, bool en)
+void fman_tgec_set_rx_ignore_pause_frames(struct tgec_regs *regs, bool en)
 {
 	uint32_t tmp;
 
@@ -214,7 +212,7 @@ void tgec_rx_ignore_mac_pause(struct tgec_regs *regs, bool en)
 	iowrite32be(tmp, &regs->command_config);
 }
 
-void tgec_enable_1588_time_stamp(struct tgec_regs *regs, bool en)
+void fman_tgec_enable_1588_time_stamp(struct tgec_regs *regs, bool en)
 {
 	uint32_t tmp;
 
@@ -226,22 +224,22 @@ void tgec_enable_1588_time_stamp(struct tgec_regs *regs, bool en)
 	iowrite32be(tmp, &regs->command_config);
 }
 
-uint32_t tgec_get_event(struct tgec_regs *regs, uint32_t ev_mask)
+uint32_t fman_tgec_get_event(struct tgec_regs *regs, uint32_t ev_mask)
 {
 	return ioread32be(&regs->ievent) & ev_mask;
 }
 
-void tgec_ack_event(struct tgec_regs *regs, uint32_t ev_mask)
+void fman_tgec_ack_event(struct tgec_regs *regs, uint32_t ev_mask)
 {
 	iowrite32be(ev_mask, &regs->ievent);
 }
 
-uint32_t tgec_get_interrupt_mask(struct tgec_regs *regs)
+uint32_t fman_tgec_get_interrupt_mask(struct tgec_regs *regs)
 {
 	return ioread32be(&regs->imask);
 }
 
-void tgec_add_addr_in_paddr(struct tgec_regs *regs, uint8_t *adr)
+void fman_tgec_add_addr_in_paddr(struct tgec_regs *regs, uint8_t *adr)
 {
 	uint32_t tmp0, tmp1;
 
@@ -254,33 +252,33 @@ void tgec_add_addr_in_paddr(struct tgec_regs *regs, uint8_t *adr)
 	iowrite32be(tmp1, &regs->mac_addr_3);
 }
 
-void tgec_clear_addr_in_paddr(struct tgec_regs *regs)
+void fman_tgec_clear_addr_in_paddr(struct tgec_regs *regs)
 {
 	iowrite32be(0, &regs->mac_addr_2);
 	iowrite32be(0, &regs->mac_addr_3);
 }
 
-uint32_t tgec_get_revision(struct tgec_regs *regs)
+uint32_t fman_tgec_get_revision(struct tgec_regs *regs)
 {
 	return ioread32be(&regs->tgec_id);
 }
 
-void tgec_enable_interrupt(struct tgec_regs *regs, uint32_t ev_mask)
+void fman_tgec_enable_interrupt(struct tgec_regs *regs, uint32_t ev_mask)
 {
 	iowrite32be(ioread32be(&regs->imask) | ev_mask, &regs->imask);
 }
 
-void tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask)
+void fman_tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask)
 {
 	iowrite32be(ioread32be(&regs->imask) & ~ev_mask, &regs->imask);
 }
 
-uint16_t tgec_get_max_frame_len(struct tgec_regs *regs)
+uint16_t fman_tgec_get_max_frame_len(struct tgec_regs *regs)
 {
 	return (uint16_t) ioread32be(&regs->maxfrm);
 }
 
-void tgec_defconfig(struct tgec_cfg *cfg)
+void fman_tgec_defconfig(struct tgec_cfg *cfg)
 {
 	cfg->wan_mode_enable = DEFAULT_WAN_MODE_ENABLE;
 	cfg->promiscuous_mode_enable = DEFAULT_PROMISCUOUS_MODE_ENABLE;
@@ -302,7 +300,7 @@ void tgec_defconfig(struct tgec_cfg *cfg)
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 }
 
-int tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
+int fman_tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
 		uint32_t exception_mask)
 {
 	uint32_t tmp;
@@ -332,18 +330,20 @@ int tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
 	if (cfg->time_stamp_enable)
 		tmp |= CMD_CFG_EN_TIMESTAMP;
 	iowrite32be(tmp, &regs->command_config);
+
 	/* Max Frame Length */
 	iowrite32be((uint32_t)cfg->max_frame_length, &regs->maxfrm);
 	/* Pause Time */
 	iowrite32be(cfg->pause_quant, &regs->pause_quant);
 
 	/* clear all pending events and set-up interrupts */
-	tgec_ack_event(regs, 0xffffffff);
-	tgec_enable_interrupt(regs, exception_mask);
+	fman_tgec_ack_event(regs, 0xffffffff);
+	fman_tgec_enable_interrupt(regs, exception_mask);
+
 	return 0;
 }
 
-void tgec_fm_tx_fifo_corruption_errata_10gmac_a007(struct tgec_regs *regs)
+void fman_tgec_set_erratum_tx_fifo_corruption_10gmac_a007(struct tgec_regs *regs)
 {
 	uint32_t tmp;
 
@@ -351,5 +351,4 @@ void tgec_fm_tx_fifo_corruption_errata_10gmac_a007(struct tgec_regs *regs)
 	tmp = (ioread32be(&regs->tx_ipg_len) & ~TX_IPG_LENGTH_MASK) | 12;
 
 	iowrite32be(tmp, &regs->tx_ipg_len);
-
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h
index 2d74b6a..fa97965 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h
@@ -30,7 +30,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
 #ifndef __FSL_FMAN_DTSEC_MII_ACC_H
 #define __FSL_FMAN_DTSEC_MII_ACC_H
 
@@ -83,7 +82,7 @@ struct dtsec_mii_reg {
 /* dTSEC MII API */
 
 /* functions to access the mii registers for phy configuration.
- * this functionality may not be available for all dtsecs in the system.
+ * this functionality may not be available for all dTSECs in the system.
  * consult the reference manual for details */
 void dtsec_mii_reset(struct dtsec_mii_reg *regs);
 /* frequency is in MHz.
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
index 8a314d3..2687283 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
@@ -57,27 +57,27 @@
 static uint32_t GetMacAddrHashCode(uint64_t ethAddr)
 {
     uint64_t    mask1, mask2;
-    uint32_t    xor = 0;
+    uint32_t    xorVal = 0;
     uint8_t     i, j;
 
-    for (i=0; i < 6; i++)
+    for (i=0; i<6; i++)
     {
         mask1 = ethAddr & (uint64_t)0x01;
         ethAddr >>= 1;
 
-        for (j=0; j < 7; j++)
+        for (j=0; j<7; j++)
         {
             mask2 = ethAddr & (uint64_t)0x01;
             mask1 ^= mask2;
             ethAddr >>= 1;
         }
-        xor |= (mask1 << (5-i));
+
+        xorVal |= (mask1 << (5-i));
     }
 
-    return xor;
+    return xorVal;
 }
 
-
 /* ......................................................................... */
 
 static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
@@ -178,48 +178,27 @@ static t_Error CheckInitParameters(t_Memac *p_Memac)
 static void MemacErrException(t_Handle h_Memac)
 {
     t_Memac     *p_Memac = (t_Memac *)h_Memac;
-    struct memac_regs   *regs = p_Memac->p_MemMap;
-    uint32_t    event, imsk;
-
-    event = memac_get_event(regs, 0xffffffff);
-
-    /*
-     * Apparently the imask bits are shifted by 16 bits offset from
-     * their corresponding bits in the ievent - hence the >> 16
-     */
-    imsk = memac_get_interrupt_mask(regs) >> 16;;
-
-    /*
-     * Extract all event bits plus the pending interrupts according to
-     * their imask
-     */
-    event = (event & ~(MEMAC_ALL_IMASKS >> 16)) | (event & imsk);
-
-    /* Ignoring the status bits */
-    event = event & ~(MEMAC_IEVNT_RX_EMPTY |
-                      MEMAC_IEVNT_TX_EMPTY |
-                      MEMAC_IEVNT_RX_LOWP |
-                      MEMAC_IEVNT_PHY_LOS);
-
-    memac_ack_event(regs, event);
-
-    if (event & MEMAC_IEVNT_RX_FIFO_OVFL)
-        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_RX_FIFO_OVFL);
-    if (event & MEMAC_IEVNT_TX_FIFO_UNFL)
-        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_TX_FIFO_UNFL);
-    if (event & MEMAC_IEVNT_TX_FIFO_OVFL)
-        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_TX_FIFO_OVFL);
+    uint32_t    event, imask;
+
+    event = fman_memac_get_event(p_Memac->p_MemMap, 0xffffffff);
+    imask = fman_memac_get_interrupt_mask(p_Memac->p_MemMap);
+
+    /* Imask include both error and notification/event bits.
+       Leaving only error bits enabled by imask.
+       The imask error bits are shifted by 16 bits offset from
+       their corresponding location in the ievent - hence the >> 16 */
+    event &= ((imask & MEMAC_ALL_ERRS_IMASK) >> 16);
+
+    fman_memac_ack_event(p_Memac->p_MemMap, event);
+
+    if (event & MEMAC_IEVNT_TS_ECC_ER)
+        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_TS_FIFO_ECC_ERR);
     if (event & MEMAC_IEVNT_TX_ECC_ER)
         p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_1TX_ECC_ER);
     if (event & MEMAC_IEVNT_RX_ECC_ER)
         p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_RX_ECC_ER);
-    if (event & MEMAC_IEVNT_REM_FAULT)
-        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_REM_FAULT);
-    if (event & MEMAC_IEVNT_LOC_FAULT)
-        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_LOC_FAULT);
 }
 
-
 /* ......................................................................... */
 
 static void FreeInitResources(t_Memac *p_Memac)
@@ -257,7 +236,7 @@ static t_Error MemacEnable(t_Handle h_Memac,  e_CommMode mode)
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    memac_enable(p_Memac->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
+    fman_memac_enable(p_Memac->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
 
     return E_OK;
 }
@@ -271,7 +250,7 @@ static t_Error MemacDisable (t_Handle h_Memac, e_CommMode mode)
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    memac_disable(p_Memac->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
+    fman_memac_disable(p_Memac->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
 
     return E_OK;
 }
@@ -285,7 +264,7 @@ static t_Error MemacSetPromiscuous(t_Handle h_Memac, bool newVal)
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    memac_set_promiscuous(p_Memac->p_MemMap, newVal);
+    fman_memac_set_promiscuous(p_Memac->p_MemMap, newVal);
 
     return E_OK;
 }
@@ -298,8 +277,15 @@ static t_Error MemacAdjustLink(t_Handle h_Memac, e_EnetSpeed speed, bool fullDup
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
-UNUSED(p_Memac);
 
+    if ((speed >= e_ENET_SPEED_1000) && (!fullDuplex))
+        RETURN_ERROR(MAJOR, E_CONFLICT,
+                     ("Ethernet MAC 1G or 10G does not support half-duplex"));
+
+    fman_memac_adjust_link(p_Memac->p_MemMap,
+                           (enum enet_interface)ENET_INTERFACE_FROM_MODE(p_Memac->enetMode),
+                           (enum enet_speed)speed,
+                           fullDuplex);
     return E_OK;
 }
 
@@ -433,7 +419,7 @@ static t_Error MemacSetTxPauseFrames(t_Handle h_Memac,
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    memac_set_tx_pause_frames(p_Memac->p_MemMap, priority, pauseTime, threshTime);
+    fman_memac_set_tx_pause_frames(p_Memac->p_MemMap, priority, pauseTime, threshTime);
 
     return E_OK;
 }
@@ -455,7 +441,7 @@ static t_Error MemacSetRxIgnorePauseFrames(t_Handle h_Memac, bool en)
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    memac_set_rx_ignore_pause_frames(p_Memac->p_MemMap, en);
+    fman_memac_set_rx_ignore_pause_frames(p_Memac->p_MemMap, en);
 
     return E_OK;
 }
@@ -485,46 +471,46 @@ static t_Error MemacGetStatistics(t_Handle h_Memac, t_FmMacStatistics *p_Statist
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
 
-    p_Statistics->eStatPkts64           = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R64);
-    p_Statistics->eStatPkts65to127      = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R127);
-    p_Statistics->eStatPkts128to255     = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R255);
-    p_Statistics->eStatPkts256to511     = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R511);
-    p_Statistics->eStatPkts512to1023    = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R1023);
-    p_Statistics->eStatPkts1024to1518   = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R1518);
-    p_Statistics->eStatPkts1519to1522   = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R1519X);
+    p_Statistics->eStatPkts64           = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R64);
+    p_Statistics->eStatPkts65to127      = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R127);
+    p_Statistics->eStatPkts128to255     = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R255);
+    p_Statistics->eStatPkts256to511     = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R511);
+    p_Statistics->eStatPkts512to1023    = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R1023);
+    p_Statistics->eStatPkts1024to1518   = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R1518);
+    p_Statistics->eStatPkts1519to1522   = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R1519X);
 /* */
-    p_Statistics->eStatFragments        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RFRG);
-    p_Statistics->eStatJabbers          = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RJBR);
+    p_Statistics->eStatFragments        = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RFRG);
+    p_Statistics->eStatJabbers          = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RJBR);
 
-    p_Statistics->eStatsDropEvents      = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RDRP);
-    p_Statistics->eStatCRCAlignErrors   = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RALN);
+    p_Statistics->eStatsDropEvents      = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RDRP);
+    p_Statistics->eStatCRCAlignErrors   = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RALN);
 
-    p_Statistics->eStatUndersizePkts    = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TUND);
-    p_Statistics->eStatOversizePkts     = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_ROVR);
+    p_Statistics->eStatUndersizePkts    = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TUND);
+    p_Statistics->eStatOversizePkts     = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_ROVR);
 /* Pause */
-    p_Statistics->reStatPause           = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RXPF);
-    p_Statistics->teStatPause           = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TXPF);
+    p_Statistics->reStatPause           = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RXPF);
+    p_Statistics->teStatPause           = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TXPF);
 
 /* MIB II */
-    p_Statistics->ifInOctets            = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_ROCT);
-    p_Statistics->ifInUcastPkts         = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RUCA);
-    p_Statistics->ifInMcastPkts         = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RMCA);
-    p_Statistics->ifInBcastPkts         = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RBCA);
+    p_Statistics->ifInOctets            = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_ROCT);
+    p_Statistics->ifInUcastPkts         = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RUCA);
+    p_Statistics->ifInMcastPkts         = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RMCA);
+    p_Statistics->ifInBcastPkts         = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RBCA);
     p_Statistics->ifInPkts              = p_Statistics->ifInUcastPkts
                                         + p_Statistics->ifInMcastPkts
                                         + p_Statistics->ifInBcastPkts;
     p_Statistics->ifInDiscards          = 0;
-    p_Statistics->ifInErrors            = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RERR);
+    p_Statistics->ifInErrors            = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RERR);
 
-    p_Statistics->ifOutOctets           = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TOCT);
-    p_Statistics->ifOutUcastPkts        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TUCA);
-    p_Statistics->ifOutMcastPkts        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TMCA);
-    p_Statistics->ifOutBcastPkts        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TBCA);
+    p_Statistics->ifOutOctets           = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TOCT);
+    p_Statistics->ifOutUcastPkts        = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TUCA);
+    p_Statistics->ifOutMcastPkts        = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TMCA);
+    p_Statistics->ifOutBcastPkts        = fman_memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TBCA);
     p_Statistics->ifOutPkts             = p_Statistics->ifOutUcastPkts
                                         + p_Statistics->ifOutMcastPkts
                                         + p_Statistics->ifOutBcastPkts;
     p_Statistics->ifOutDiscards         = 0;
-    p_Statistics->ifOutErrors           = memac_get_counter(p_Memac->p_MemMap,  E_MEMAC_COUNTER_TERR);
+    p_Statistics->ifOutErrors           = fman_memac_get_counter(p_Memac->p_MemMap,  E_MEMAC_COUNTER_TERR);
 
     return E_OK;
 }
@@ -538,7 +524,7 @@ static t_Error MemacModifyMacAddress (t_Handle h_Memac, t_EnetAddr *p_EnetAddr)
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    memac_hardware_add_addr_in_paddr(p_Memac->p_MemMap, (uint8_t *)(*p_EnetAddr), 0);
+    fman_memac_add_addr_in_paddr(p_Memac->p_MemMap, (uint8_t *)(*p_EnetAddr), 0);
 
     return E_OK;
 }
@@ -552,7 +538,7 @@ static t_Error MemacResetCounters (t_Handle h_Memac)
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    memac_reset_counter(p_Memac->p_MemMap);
+    fman_memac_reset_stat(p_Memac->p_MemMap);
 
     return E_OK;
 }
@@ -590,7 +576,7 @@ static t_Error MemacAddExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
             p_Memac->paddr[paddrNum] = ethAddr;
 
             /* put in hardware */
-            memac_hardware_add_addr_in_paddr(p_Memac->p_MemMap, (uint8_t*)(*p_EthAddr), paddrNum);
+            fman_memac_add_addr_in_paddr(p_Memac->p_MemMap, (uint8_t*)(*p_EthAddr), paddrNum);
             p_Memac->numOfIndAddrInRegs++;
 
             return E_OK;
@@ -622,7 +608,7 @@ static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
             /* mark this PADDR as not used */
             p_Memac->indAddrRegUsed[paddrNum] = FALSE;
             /* clear in hardware */
-            memac_hardware_clear_addr_in_paddr(p_Memac->p_MemMap, paddrNum);
+            fman_memac_clear_addr_in_paddr(p_Memac->p_MemMap, paddrNum);
             p_Memac->numOfIndAddrInRegs--;
 
             return E_OK;
@@ -658,7 +644,7 @@ static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
     INIT_LIST(&p_HashEntry->node);
 
     LIST_AddToTail(&(p_HashEntry->node), &(p_Memac->p_MulticastAddrHash->p_Lsts[hash]));
-    memac_set_hash_table(p_Memac->p_MemMap, (hash | HASH_CTRL_MCAST_EN));
+    fman_memac_set_hash_table(p_Memac->p_MemMap, (hash | HASH_CTRL_MCAST_EN));
 
     return E_OK;
 }
@@ -691,7 +677,7 @@ static t_Error MemacDelHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
         }
     }
     if (LIST_IsEmpty(&p_Memac->p_MulticastAddrHash->p_Lsts[hash]))
-        memac_set_hash_table(p_Memac->p_MemMap, (hash & ~HASH_CTRL_MCAST_EN));
+        fman_memac_set_hash_table(p_Memac->p_MemMap, (hash & ~HASH_CTRL_MCAST_EN));
 
     return E_OK;
 }
@@ -718,7 +704,7 @@ static t_Error MemacSetException(t_Handle h_Memac, e_FmMacExceptions exception,
     else
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
-    memac_set_exception(p_Memac->p_MemMap, bitMask, enable);
+    fman_memac_set_exception(p_Memac->p_MemMap, bitMask, enable);
 
     return E_OK;
 }
@@ -732,7 +718,7 @@ static uint16_t MemacGetMaxFrameLength(t_Handle h_Memac)
     SANITY_CHECK_RETURN_VALUE(p_Memac, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_Memac->p_MemacDriverParam, E_INVALID_STATE, 0);
 
-    return memac_get_max_frame_length(p_Memac->p_MemMap);
+    return fman_memac_get_max_frame_len(p_Memac->p_MemMap);
 }
 
 /* ......................................................................... */
@@ -826,21 +812,41 @@ static t_Error MemacInit(t_Handle h_Memac)
 
     /* First, reset the MAC if desired. */
     if (p_MemacDriverParam->reset_on_init)
-        memac_reset(p_Memac->p_MemMap);
+        fman_memac_reset(p_Memac->p_MemMap);
 
     /* MAC Address */
     MAKE_ENET_ADDR_FROM_UINT64(p_Memac->addr, ethAddr);
-    memac_hardware_add_addr_in_paddr(p_Memac->p_MemMap, (uint8_t*)ethAddr, 0);
+    fman_memac_add_addr_in_paddr(p_Memac->p_MemMap, (uint8_t*)ethAddr, 0);
 
     enet_interface = (enum enet_interface) ENET_INTERFACE_FROM_MODE(p_Memac->enetMode);
     enet_speed = (enum enet_speed) ENET_SPEED_FROM_MODE(p_Memac->enetMode);
 
-    memac_init(p_Memac->p_MemMap,
+    fman_memac_init(p_Memac->p_MemMap,
                p_Memac->p_MemacDriverParam,
                enet_interface,
                enet_speed,
                p_Memac->exceptions);
 
+#ifdef FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
+    {
+    	uint32_t tmpReg = 0;
+
+    	FM_GetRevision(p_Memac->fmMacControllerDriver.h_Fm, &p_Memac->fmMacControllerDriver.fmRevInfo);
+        /* check the FMAN version - the bug exists only in rev1 */
+        if ((p_Memac->fmMacControllerDriver.fmRevInfo.majorRev == 6) &&
+        	(p_Memac->fmMacControllerDriver.fmRevInfo.minorRev == 0))
+        {
+        	/* MAC strips CRC from received frames - this workaround should
+        	   decrease the likelihood of bug appearance
+            */
+			tmpReg = GET_UINT32(p_Memac->p_MemMap->command_config);
+			tmpReg &= ~CMD_CFG_CRC_FWD;
+			WRITE_UINT32(p_Memac->p_MemMap->command_config, tmpReg);
+			/* DBG(WARNING, ("mEMAC strips CRC from received frames as part of A006320 errata workaround"));*/
+        }
+    }
+#endif /* FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320 */
+
     if (ENET_INTERFACE_FROM_MODE(p_Memac->enetMode) == e_ENET_IF_SGMII)
     {
         /* Configure internal SGMII PHY */
@@ -895,7 +901,6 @@ static t_Error MemacInit(t_Handle h_Memac)
                    MemacErrException,
                    p_Memac);
 
-
     XX_Free(p_MemacDriverParam);
     p_Memac->p_MemacDriverParam = NULL;
 
@@ -1017,7 +1022,7 @@ t_Handle MEMAC_Config(t_FmMacParams *p_FmMacParam)
     /* Plant parameter structure pointer */
     p_Memac->p_MemacDriverParam = p_MemacDriverParam;
 
-    memac_defconfig(p_MemacDriverParam);
+    fman_memac_defconfig(p_MemacDriverParam);
 
     p_Memac->addr           = ENET_ADDR_TO_UINT64(p_FmMacParam->addr);
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h
index e1c4c53..d0436ac 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.h
@@ -48,13 +48,16 @@
 #include "fsl_fman_memac.h"
 
 
-#define MEMAC_default_exceptions    ((uint32_t)(MEMAC_IMASK_TECC_ER | MEMAC_IMASK_RECC_ER))
+#define MEMAC_default_exceptions    \
+        ((uint32_t)(MEMAC_IMASK_TSECC_ER | MEMAC_IMASK_TECC_ER | MEMAC_IMASK_RECC_ER))
 
 #define GET_EXCEPTION_FLAG(bitMask, exception)       switch (exception){    \
     case e_FM_MAC_EX_10G_1TX_ECC_ER:                                        \
         bitMask = MEMAC_IMASK_TECC_ER; break;                               \
     case e_FM_MAC_EX_10G_RX_ECC_ER:                                         \
-        bitMask = MEMAC_IMASK_RECC_ER; break;                                     \
+        bitMask = MEMAC_IMASK_RECC_ER; break;                               \
+    case e_FM_MAC_EX_TS_FIFO_ECC_ERR:                                       \
+        bitMask = MEMAC_IMASK_TSECC_ER; break;                              \
     default: bitMask = 0;break;}
 
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.c
index be5b867..6fe7f74 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.c
@@ -148,7 +148,6 @@ static void WritePhyReg1G(t_MemacMiiAccessMemMap    *p_MiiAccess,
         XX_UDelay(1);
 
     WRITE_UINT32(p_MiiAccess->mdio_data, data);
-
     CORE_MemoryBarrier();
 
     /* Wait for write transaction to end */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
index 522d64b..1f8206b 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
@@ -99,10 +99,10 @@ static void TgecErrException(t_Handle h_Tgec)
     struct tgec_regs    *p_TgecMemMap = p_Tgec->p_MemMap;
 
     /* do not handle MDIO events */
-    event = tgec_get_event(p_TgecMemMap, ~(TGEC_IMASK_MDIO_SCAN_EVENT | TGEC_IMASK_MDIO_CMD_CMPL));
-    event &= tgec_get_interrupt_mask(p_TgecMemMap);
+    event = fman_tgec_get_event(p_TgecMemMap, ~(TGEC_IMASK_MDIO_SCAN_EVENT | TGEC_IMASK_MDIO_CMD_CMPL));
+    event &= fman_tgec_get_interrupt_mask(p_TgecMemMap);
 
-    tgec_ack_event(p_TgecMemMap, event);
+    fman_tgec_ack_event(p_TgecMemMap, event);
 
     if (event & TGEC_IMASK_REM_FAULT)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_REM_FAULT);
@@ -145,10 +145,10 @@ static void TgecException(t_Handle h_Tgec)
      struct tgec_regs   *p_TgecMemMap = p_Tgec->p_MemMap;
 
      /* handle only MDIO events */
-     event = tgec_get_event(p_TgecMemMap, (TGEC_IMASK_MDIO_SCAN_EVENT | TGEC_IMASK_MDIO_CMD_CMPL));
-     event &= tgec_get_interrupt_mask(p_TgecMemMap);
+     event = fman_tgec_get_event(p_TgecMemMap, (TGEC_IMASK_MDIO_SCAN_EVENT | TGEC_IMASK_MDIO_CMD_CMPL));
+     event &= fman_tgec_get_interrupt_mask(p_TgecMemMap);
 
-     tgec_ack_event(p_TgecMemMap, event);
+     fman_tgec_ack_event(p_TgecMemMap, event);
 
      if (event & TGEC_IMASK_MDIO_SCAN_EVENT)
          p_Tgec->f_Event(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO);
@@ -192,7 +192,7 @@ static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    tgec_enable(p_Tgec->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
+    fman_tgec_enable(p_Tgec->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
 
     return E_OK;
 }
@@ -206,7 +206,7 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    tgec_disable(p_Tgec->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
+    fman_tgec_disable(p_Tgec->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
 
     return E_OK;
 }
@@ -220,7 +220,7 @@ static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    tgec_set_promiscuous(p_Tgec->p_MemMap, newVal);
+    fman_tgec_set_promiscuous(p_Tgec->p_MemMap, newVal);
 
     return E_OK;
 }
@@ -341,7 +341,7 @@ static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime)
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
-    tgec_tx_mac_pause(p_Tgec->p_MemMap, pauseTime);
+    fman_tgec_set_tx_pause_frames(p_Tgec->p_MemMap, pauseTime);
 
 
     return E_OK;
@@ -361,7 +361,7 @@ static t_Error TgecSetTxPauseFrames(t_Handle h_Tgec,
 
     UNUSED(priority); UNUSED(threshTime);
 
-    tgec_tx_mac_pause(p_Tgec->p_MemMap, pauseTime);
+    fman_tgec_set_tx_pause_frames(p_Tgec->p_MemMap, pauseTime);
 
     return E_OK;
 }
@@ -375,7 +375,7 @@ static t_Error TgecRxIgnoreMacPause(t_Handle h_Tgec, bool en)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    tgec_rx_ignore_mac_pause(p_Tgec->p_MemMap, en);
+    fman_tgec_set_rx_ignore_pause_frames(p_Tgec->p_MemMap, en);
 
     return E_OK;
 }
@@ -393,46 +393,46 @@ static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistic
 
     p_TgecMemMap = p_Tgec->p_MemMap;
 
-    p_Statistics->eStatPkts64           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R64);
-    p_Statistics->eStatPkts65to127      = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R127);
-    p_Statistics->eStatPkts128to255     = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R255);
-    p_Statistics->eStatPkts256to511     = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R511);
-    p_Statistics->eStatPkts512to1023    = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R1023);
-    p_Statistics->eStatPkts1024to1518   = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R1518);
-    p_Statistics->eStatPkts1519to1522   = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R1519X);
+    p_Statistics->eStatPkts64           = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R64);
+    p_Statistics->eStatPkts65to127      = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R127);
+    p_Statistics->eStatPkts128to255     = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R255);
+    p_Statistics->eStatPkts256to511     = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R511);
+    p_Statistics->eStatPkts512to1023    = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R1023);
+    p_Statistics->eStatPkts1024to1518   = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R1518);
+    p_Statistics->eStatPkts1519to1522   = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R1519X);
 /* */
-    p_Statistics->eStatFragments        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TRFRG);
-    p_Statistics->eStatJabbers          = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TRJBR);
+    p_Statistics->eStatFragments        = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TRFRG);
+    p_Statistics->eStatJabbers          = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TRJBR);
 
-    p_Statistics->eStatsDropEvents      = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RDRP);
-    p_Statistics->eStatCRCAlignErrors   = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RALN);
+    p_Statistics->eStatsDropEvents      = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RDRP);
+    p_Statistics->eStatCRCAlignErrors   = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RALN);
 
-    p_Statistics->eStatUndersizePkts    = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TRUND);
-    p_Statistics->eStatOversizePkts     = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TROVR);
+    p_Statistics->eStatUndersizePkts    = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TRUND);
+    p_Statistics->eStatOversizePkts     = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TROVR);
 /* Pause */
-    p_Statistics->reStatPause           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RXPF);
-    p_Statistics->teStatPause           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TXPF);
+    p_Statistics->reStatPause           = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RXPF);
+    p_Statistics->teStatPause           = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TXPF);
 
 /* MIB II */
-    p_Statistics->ifInOctets            = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_ROCT);
-    p_Statistics->ifInUcastPkts         = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RUCA);
-    p_Statistics->ifInMcastPkts         = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RMCA);
-    p_Statistics->ifInBcastPkts         = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RBCA);
+    p_Statistics->ifInOctets            = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_ROCT);
+    p_Statistics->ifInUcastPkts         = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RUCA);
+    p_Statistics->ifInMcastPkts         = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RMCA);
+    p_Statistics->ifInBcastPkts         = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RBCA);
     p_Statistics->ifInPkts              = p_Statistics->ifInUcastPkts
                                         + p_Statistics->ifInMcastPkts
                                         + p_Statistics->ifInBcastPkts;
     p_Statistics->ifInDiscards          = 0;
-    p_Statistics->ifInErrors            = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RERR);
+    p_Statistics->ifInErrors            = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RERR);
 
-    p_Statistics->ifOutOctets           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TOCT);
-    p_Statistics->ifOutUcastPkts        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TUCA);
-    p_Statistics->ifOutMcastPkts        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TMCA);
-    p_Statistics->ifOutBcastPkts        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TBCA);
+    p_Statistics->ifOutOctets           = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TOCT);
+    p_Statistics->ifOutUcastPkts        = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TUCA);
+    p_Statistics->ifOutMcastPkts        = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TMCA);
+    p_Statistics->ifOutBcastPkts        = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TBCA);
     p_Statistics->ifOutPkts             = p_Statistics->ifOutUcastPkts
                                         + p_Statistics->ifOutMcastPkts
                                         + p_Statistics->ifOutBcastPkts;
     p_Statistics->ifOutDiscards         = 0;
-    p_Statistics->ifOutErrors           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TERR);
+    p_Statistics->ifOutErrors           = fman_tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TERR);
 
     return E_OK;
 }
@@ -446,7 +446,7 @@ static t_Error TgecEnable1588TimeStamp(t_Handle h_Tgec)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    tgec_enable_1588_time_stamp(p_Tgec->p_MemMap, 1);
+    fman_tgec_enable_1588_time_stamp(p_Tgec->p_MemMap, 1);
 
     return E_OK;
 }
@@ -460,7 +460,7 @@ static t_Error TgecDisable1588TimeStamp(t_Handle h_Tgec)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    tgec_enable_1588_time_stamp(p_Tgec->p_MemMap, 0);
+    fman_tgec_enable_1588_time_stamp(p_Tgec->p_MemMap, 0);
 
     return E_OK;
 }
@@ -475,7 +475,7 @@ static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
     p_Tgec->addr = ENET_ADDR_TO_UINT64(*p_EnetAddr);
-    tgec_set_mac_address(p_Tgec->p_MemMap, (uint8_t *)(*p_EnetAddr));
+    fman_tgec_set_mac_address(p_Tgec->p_MemMap, (uint8_t *)(*p_EnetAddr));
 
     return E_OK;
 }
@@ -489,7 +489,7 @@ static t_Error TgecResetCounters (t_Handle h_Tgec)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    tgec_reset_stat(p_Tgec->p_MemMap);
+    fman_tgec_reset_stat(p_Tgec->p_MemMap);
 
     return E_OK;
 }
@@ -528,7 +528,7 @@ static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
             p_Tgec->paddr[paddrNum] = ethAddr;
 
             /* put in hardware */
-            tgec_add_addr_in_paddr(p_Tgec->p_MemMap, (uint8_t*)(*p_EthAddr)/* , paddrNum */);
+            fman_tgec_add_addr_in_paddr(p_Tgec->p_MemMap, (uint8_t*)(*p_EthAddr)/* , paddrNum */);
             p_Tgec->numOfIndAddrInRegs++;
 
             return E_OK;
@@ -561,7 +561,7 @@ static t_Error TgecDelExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
             /* mark this PADDR as not used */
             p_Tgec->indAddrRegUsed[paddrNum] = FALSE;
             /* clear in hardware */
-            tgec_clear_addr_in_paddr(p_Tgec->p_MemMap /*, paddrNum */);
+            fman_tgec_clear_addr_in_paddr(p_Tgec->p_MemMap /*, paddrNum */);
             p_Tgec->numOfIndAddrInRegs--;
 
             return E_OK;
@@ -601,7 +601,7 @@ static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
     INIT_LIST(&p_HashEntry->node);
 
     LIST_AddToTail(&(p_HashEntry->node), &(p_Tgec->p_MulticastAddrHash->p_Lsts[hash]));
-    tgec_set_hash_table(p_Tgec->p_MemMap, (hash | TGEC_HASH_MCAST_EN));
+    fman_tgec_set_hash_table(p_Tgec->p_MemMap, (hash | TGEC_HASH_MCAST_EN));
 
     return E_OK;
 }
@@ -638,7 +638,7 @@ static t_Error TgecDelHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
         }
     }
     if (LIST_IsEmpty(&p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
-        tgec_set_hash_table(p_Tgec->p_MemMap, (hash & ~TGEC_HASH_MCAST_EN));
+        fman_tgec_set_hash_table(p_Tgec->p_MemMap, (hash & ~TGEC_HASH_MCAST_EN));
 
     return E_OK;
 }
@@ -666,7 +666,7 @@ static t_Error TgecGetVersion(t_Handle h_Tgec, uint32_t *macVersion)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    *macVersion = tgec_get_revision(p_Tgec->p_MemMap);
+    *macVersion = fman_tgec_get_revision(p_Tgec->p_MemMap);
 
     return E_OK;
 }
@@ -693,9 +693,9 @@ static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bo
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
     if (enable)
-        tgec_enable_interrupt(p_Tgec->p_MemMap, bitMask);
+        fman_tgec_enable_interrupt(p_Tgec->p_MemMap, bitMask);
     else
-        tgec_disable_interrupt(p_Tgec->p_MemMap, bitMask);
+        fman_tgec_disable_interrupt(p_Tgec->p_MemMap, bitMask);
 
     return E_OK;
 }
@@ -709,7 +709,7 @@ static uint16_t TgecGetMaxFrameLength(t_Handle h_Tgec)
     SANITY_CHECK_RETURN_VALUE(p_Tgec, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE, 0);
 
-    return tgec_get_max_frame_len(p_Tgec->p_MemMap);
+    return fman_tgec_get_max_frame_len(p_Tgec->p_MemMap);
 }
 
 /* ......................................................................... */
@@ -723,19 +723,20 @@ static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
     XX_Print("Applying 10G TX ECC workaround (10GMAC-A004) ... ");
 #endif /* (DEBUG_ERRORS > 0) */
     /* enable and set promiscuous */
-    tgec_enable(p_Tgec->p_MemMap, TRUE, TRUE);
-    tgec_set_promiscuous(p_Tgec->p_MemMap, TRUE);
+    fman_tgec_enable(p_Tgec->p_MemMap, TRUE, TRUE);
+    fman_tgec_set_promiscuous(p_Tgec->p_MemMap, TRUE);
     err = Fm10GTxEccWorkaround(p_Tgec->fmMacControllerDriver.h_Fm, p_Tgec->macId);
     /* disable */
-    tgec_set_promiscuous(p_Tgec->p_MemMap, FALSE);
-    tgec_enable(p_Tgec->p_MemMap, FALSE, FALSE);
+    fman_tgec_set_promiscuous(p_Tgec->p_MemMap, FALSE);
+    fman_tgec_enable(p_Tgec->p_MemMap, FALSE, FALSE);
+    fman_tgec_reset_stat(p_Tgec->p_MemMap);
+	fman_tgec_ack_event(p_Tgec->p_MemMap, 0xffffffff);
 #if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
     if (err)
         XX_Print("FAILED!\n");
     else
         XX_Print("done.\n");
 #endif /* (DEBUG_ERRORS > 0) */
-    tgec_reset_stat(p_Tgec->p_MemMap);
 
     return err;
 }
@@ -808,7 +809,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
     p_TgecDriverParam = p_Tgec->p_TgecDriverParam;
 
     MAKE_ENET_ADDR_FROM_UINT64(p_Tgec->addr, ethAddr);
-    tgec_set_mac_address(p_Tgec->p_MemMap, (uint8_t *)ethAddr);
+    fman_tgec_set_mac_address(p_Tgec->p_MemMap, (uint8_t *)ethAddr);
 
     /* interrupts */
 #ifdef FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
@@ -830,7 +831,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
     }
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
-    err = tgec_init(p_Tgec->p_MemMap, p_TgecDriverParam, p_Tgec->exceptions);
+    err = fman_tgec_init(p_Tgec->p_MemMap, p_TgecDriverParam, p_Tgec->exceptions);
     if (err)
     {
         FreeInitResources(p_Tgec);
@@ -846,7 +847,7 @@ static t_Error TgecInit(t_Handle h_Tgec)
 
 #ifdef FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
     if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
-        tgec_fm_tx_fifo_corruption_errata_10gmac_a007(p_Tgec->p_MemMap);
+        fman_tgec_set_erratum_tx_fifo_corruption_10gmac_a007(p_Tgec->p_MemMap);
 #endif /* FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007 */
 
     p_Tgec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
@@ -1001,7 +1002,7 @@ t_Handle TGEC_Config(t_FmMacParams *p_FmMacParam)
     /* Plant parameter structure pointer */
     p_Tgec->p_TgecDriverParam = p_TgecDriverParam;
 
-    tgec_defconfig(p_TgecDriverParam);
+    fman_tgec_defconfig(p_TgecDriverParam);
 
     p_Tgec->p_MemMap        = (struct tgec_regs *)UINT_TO_PTR(baseAddr);
     p_Tgec->p_MiiMemMap     = (t_TgecMiiAccessMemMap *)UINT_TO_PTR(baseAddr + TGEC_TO_MII_OFFSET);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
index 85810a9..a68ff12 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
@@ -377,9 +377,12 @@ static t_Error AllocAndFillAdForContLookupManip(t_Handle h_CcNode)
 
     if (!p_CcNode->h_Ad)
     {
-        p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram,
-                                           FM_PCD_CC_AD_ENTRY_SIZE,
-                                           FM_PCD_CC_AD_TABLE_ALIGN);
+        if (p_CcNode->maxNumOfKeys)
+            p_CcNode->h_Ad = p_CcNode->h_TmpAd;
+        else
+            p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(((t_FmPcd *)(p_CcNode->h_FmPcd))->h_FmMuram,
+                                                         FM_PCD_CC_AD_ENTRY_SIZE,
+                                                         FM_PCD_CC_AD_TABLE_ALIGN);
 
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
@@ -1174,6 +1177,7 @@ static void DeleteNode(t_FmPcdCcNode *p_CcNode)
     {
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_CcNode->h_FmPcd), p_CcNode->h_Ad);
         p_CcNode->h_Ad = NULL;
+        p_CcNode->h_TmpAd = NULL;
     }
 
     if (p_CcNode->h_StatsFLRs)
@@ -3185,12 +3189,12 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
     }
 }
 
-static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle        h_FmPcdCcNodeOrTree,
-                                                                uint16_t        keyIndex,
-                                                                e_ModifyState   modifyState,
-                                                                bool            ttlCheck,
-                                                                bool            hashCheck,
-                                                                bool            tree)
+static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(t_Handle        h_FmPcdCcNodeOrTree,
+                                                                 uint16_t        keyIndex,
+                                                                 e_ModifyState   modifyState,
+                                                                 bool            ttlCheck,
+                                                                 bool            hashCheck,
+                                                                 bool            tree)
 {
     t_FmPcdModifyCcKeyAdditionalParams  *p_FmPcdModifyCcKeyAdditionalParams;
     int                                 i = 0, j = 0;
@@ -3202,14 +3206,6 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcdCcNodeOrTree, E_INVALID_HANDLE, NULL);
 
-    p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*CC_MAX_NUM_OF_KEYS);
-    if (!p_KeyAndNextEngineParams)
-    {
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Next engine and required action structure"));
-        return NULL;
-    }
-    memset(p_KeyAndNextEngineParams, 0, sizeof(t_FmPcdCcKeyAndNextEngineParams)*CC_MAX_NUM_OF_KEYS);
-
     if (!tree)
     {
         p_CcNode = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
@@ -3219,22 +3215,26 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
         if (!LIST_NumOfObjs(&p_CcNode->ccPrevNodesLst) &&
             !LIST_NumOfObjs(&p_CcNode->ccTreeIdLst))
         {
-            XX_Free(p_KeyAndNextEngineParams);
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be pointed by node or tree"));
             return NULL;
         }
 
         if (!LIST_NumOfObjs(&p_CcNode->ccTreesLst) ||
-           (LIST_NumOfObjs(&p_CcNode->ccTreesLst) != 1))
+            (LIST_NumOfObjs(&p_CcNode->ccTreesLst) != 1))
         {
-            XX_Free(p_KeyAndNextEngineParams);
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be belonging to some tree and only to one tree"));
             return NULL;
         }
 
+        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*(numOfKeys+1));
+        if (!p_KeyAndNextEngineParams)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Next engine and required action structure"));
+            return NULL;
+        }
         memcpy(p_KeyAndNextEngineParams,
                p_CcNode->keyAndNextEngineParams,
-               CC_MAX_NUM_OF_KEYS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+               (numOfKeys+1) * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
         if (ttlCheck)
         {
@@ -3261,6 +3261,13 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
     {
         p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
         numOfKeys = p_FmPcdCcTree->numOfEntries;
+
+        p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*FM_PCD_MAX_NUM_OF_CC_GROUPS);
+        if (!p_KeyAndNextEngineParams)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Next engine and required action structure"));
+            return NULL;
+        }
         memcpy(p_KeyAndNextEngineParams,
                p_FmPcdCcTree->keyAndNextEngineParams,
                FM_PCD_MAX_NUM_OF_CC_GROUPS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
@@ -3779,17 +3786,15 @@ static t_Error ModifyNextEngineParamNode(t_Handle                    h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    if (p_CcNode->maxNumOfKeys)
+    if (p_CcNode->maxNumOfKeys &&
+        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
     {
-        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
-        {
-            XX_Free(p_ModifyKeyParams);
-            return ERROR_CODE(E_BUSY);
-        }
+        XX_Free(p_ModifyKeyParams);
+        return ERROR_CODE(E_BUSY);
     }
 
     err = BuildNewNodeModifyNextEngine(h_FmPcd,
@@ -4327,18 +4332,18 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
 
     keyIndex = (uint16_t)(p_FmPcdCcTree->fmPcdGroupParam[grpId].baseGroupEntry + index);
 
-    p_ModifyKeyParams = ModifyKeyCommonPart1(p_FmPcdCcTree, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, TRUE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_FmPcdCcTree, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, FALSE, TRUE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     p_ModifyKeyParams->tree = TRUE;
 
-    if (p_FmPcd->p_CcShadow)
-        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
-        {
-            XX_Free(p_ModifyKeyParams);
-            return ERROR_CODE(E_BUSY);
-        }
+    if (p_FmPcd->p_CcShadow &&
+        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+    {
+        XX_Free(p_ModifyKeyParams);
+        return ERROR_CODE(E_BUSY);
+    }
 
     err = BuildNewNodeModifyNextEngine(p_FmPcd,
                                        p_FmPcdCcTree,
@@ -4388,7 +4393,7 @@ t_Error FmPcdCcRemoveKey(t_Handle   h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_REMOVE, TRUE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_REMOVE, TRUE, TRUE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -4475,7 +4480,7 @@ t_Error FmPcdCcModifyKey(t_Handle   h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -4548,17 +4553,15 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle                   h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, FALSE, TRUE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
-    if (p_CcNode->maxNumOfKeys)
+    if (p_CcNode->maxNumOfKeys &&
+        !TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
     {
-        if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
-        {
-            XX_Free(p_ModifyKeyParams);
-            return ERROR_CODE(E_BUSY);
-        }
+        XX_Free(p_ModifyKeyParams);
+        return ERROR_CODE(E_BUSY);
     }
 
     err = BuildNewNodeModifyNextEngine(h_FmPcd,
@@ -4621,7 +4624,7 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
                        p_FmPcdCcKeyParams->p_Mask,
                        &tmpKeyIndex);
     if (GET_ERROR_TYPE(err) != E_NOT_FOUND)
-        RETURN_ERROR(MINOR, E_ALREADY_EXISTS,
+        RETURN_ERROR(MAJOR, E_ALREADY_EXISTS,
                      ("The received key and mask pair was already found in the match table of the provided node"));
 
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
@@ -4629,7 +4632,7 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode,
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode,
                                              keyIndex,
                                              e_MODIFY_STATE_ADD,
                                              TRUE,
@@ -4725,7 +4728,7 @@ t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle              h_FmPcd,
     INIT_LIST(&h_OldPointersLst);
     INIT_LIST(&h_NewPointersLst);
 
-    p_ModifyKeyParams = ModifyKeyCommonPart1(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
+    p_ModifyKeyParams = ModifyNodeCommonPart(p_CcNode, keyIndex, e_MODIFY_STATE_CHANGE, TRUE, TRUE, FALSE);
     if (!p_ModifyKeyParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
@@ -5676,10 +5679,10 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         /* If manipulation will be initialized before this node, it will use the table
            descriptor in the AD table of previous node and this node will need an extra
            AD as his table descriptor. */
-        p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
+        p_CcNode->h_TmpAd = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
                                                      FM_PCD_CC_AD_ENTRY_SIZE,
                                                      FM_PCD_CC_AD_TABLE_ALIGN);
-        if (!p_CcNode->h_Ad)
+        if (!p_CcNode->h_TmpAd)
         {
             DeleteNode(p_CcNode);
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
@@ -5932,6 +5935,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     }
 
     FmPcdLockUnlockAll(h_FmPcd);
+
     return p_CcNode;
 }
 
@@ -5945,6 +5949,8 @@ t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
     p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
+    UNUSED(p_FmPcd);
+
     if (p_CcNode->owners)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This node cannot be removed because it is occupied; first unbind this node"));
 
@@ -6732,7 +6738,10 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     p_IndxHashCcNodeParam->keysParams.keySize        = 2;
 
     p_CcNodeHashTbl = FM_PCD_MatchTableSet(h_FmPcd, p_IndxHashCcNodeParam);
-
+ 
+    if (p_CcNodeHashTbl)
+        p_CcNodeHashTbl->kgHashShift = p_Param->kgHashShift;
+ 
     XX_Free(p_IndxHashCcNodeParam);
     XX_Free(p_ExactMatchCcNodeParam);
 
@@ -6790,7 +6799,7 @@ t_Error FM_PCD_HashTableAddKey(t_Handle            h_HashTbl,
     err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
                                                 keySize,
                                                 p_KeyParams->p_Key,
-                                                p_HashTbl->userOffset,
+                                                p_HashTbl->kgHashShift,
                                                 &h_HashBucket,
                                                 &bucketIndex,
                                                 &lastIndex);
@@ -6819,7 +6828,7 @@ t_Error FM_PCD_HashTableRemoveKey(t_Handle h_HashTbl,
     err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
                                                 keySize,
                                                 p_Key,
-                                                p_HashTbl->userOffset,
+                                                p_HashTbl->kgHashShift,
                                                 &h_HashBucket,
                                                 &bucketIndex,
                                                 &lastIndex);
@@ -6850,7 +6859,7 @@ t_Error FM_PCD_HashTableModifyNextEngine(t_Handle                  h_HashTbl,
     err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
                                                 keySize,
                                                 p_Key,
-                                                p_HashTbl->userOffset,
+                                                p_HashTbl->kgHashShift,
                                                 &h_HashBucket,
                                                 &bucketIndex,
                                                 &lastIndex);
@@ -6925,7 +6934,7 @@ t_Error FM_PCD_HashTableFindNGetKeyStatistics(t_Handle                 h_HashTbl
     err = FM_PCD_MatchTableGetIndexedHashBucket(p_HashTbl,
                                                 keySize,
                                                 p_Key,
-                                                p_HashTbl->userOffset,
+                                                p_HashTbl->kgHashShift,
                                                 &h_HashBucket,
                                                 &bucketIndex,
                                                 &lastIndex);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
index 9efe721..eeb43a2 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
@@ -326,6 +326,7 @@ typedef struct
     t_Handle            h_KeysMatchTable;
     t_Handle            h_AdTable;
     t_Handle            h_StatsAds;
+    t_Handle            h_TmpAd;
     t_Handle            h_Ad;
     t_Handle            h_StatsFLRs;
 
@@ -340,6 +341,7 @@ typedef struct
     uint32_t            shadowAction;
     uint8_t             userSizeOfExtraction;
     uint8_t             userOffset;
+    uint8_t             kgHashShift;            /* used in hash-table */
 
     t_Handle            h_Spinlock;
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
index bdbc8ae..5570bb1 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
@@ -838,6 +838,7 @@ static void UnbindPortToClsPlanGrp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId)
     KgWriteCpp(p_FmPcd, hardwarePortId, 0);
 }
 
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 static uint32_t ReadClsPlanBlockActionReg(uint8_t grpId)
 {
     return (uint32_t)(FM_KG_KGAR_GO |
@@ -851,6 +852,7 @@ static uint32_t ReadClsPlanBlockActionReg(uint8_t grpId)
        sel = (uint8_t)(0x01 << (7- (entryId % CLS_PLAN_NUM_PER_GRP)));
      */
 }
+#endif /* (defined(DEBUG_ERRORS) && ... */
 
 static void PcdKgErrorException(t_Handle h_FmPcd)
 {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
index e6c8d2d..60f71d7 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
@@ -397,7 +397,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
 
                     tmpReg = 0;
                     ASSERT_COND(p_TmpData);
-                    for (i=0; i<FM_PCD_MANIP_DSCP_VALUES; i++)
+                    for (i=0; i<HMCD_DSCP_VALUES; i++)
                     {
                         /* first we build from each 8 values a 32bit register */
                         tmpReg |= (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i]) << (32-4*(j+1));
@@ -834,9 +834,11 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
 
 static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    uint8_t         *p_WholeHmct, *p_TmpHmctPtr, *p_TmpDataPtr;
+    uint8_t         *p_WholeHmct = NULL, *p_TmpHmctPtr, *p_TmpDataPtr;
     t_FmPcdManip    *p_CurManip = p_Manip;
 
+    UNUSED(p_WholeHmct);
+
     /* Build the new table in the shadow */
     if (!MANIP_IS_UNIFIED(p_Manip))
         BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, FALSE);
@@ -2187,92 +2189,7 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
 
     return E_OK;
 }
-#endif /* FM_CAPWAP_SUPPORT */
 
-static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
-                                    t_Handle h_PcdParams,
-                                    t_Handle h_FmPort,
-                                    t_Handle h_Manip,
-                                    t_Handle h_Ad,
-                                    bool     validate,
-                                    int      level,
-                                    t_Handle h_FmTree)
-{
-    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Error      err = E_OK;
-
-    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
-
-    UNUSED(level);
-    UNUSED(h_FmPcd);
-    UNUSED(h_FmTree);
-
-    switch (p_Manip->opcode)
-    {
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
-            break;
-#ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if (!p_Manip->h_Frag)
-                break;
-        case (HMAN_OC_CAPWAP_FRAGMENTATION):
-            err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
-            break;
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if (p_Manip->h_Frag)
-                err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
-            break;
-        case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
-            break;
-#endif /* FM_CAPWAP_SUPPORT */
-        case (HMAN_OC_IP_REASSEMBLY):
-            err = UpdateInitIpReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
-            break;
-        default:
-            return E_OK;
-    }
-
-    return err;
-}
-
-static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree)
-{
-
-    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_Error         err = E_OK;
-
-    UNUSED(level);
-
-    switch (p_Manip->opcode)
-    {
-        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
-        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-
-           if (p_Manip->h_Frag)
-           {
-               if (!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
-                   !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
-                   !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation requires manipulation be updated previously in SetPcd function"));
-           }
-           break;
-#ifdef FM_CAPWAP_SUPPORT
-        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if (p_Manip->h_Frag)
-                err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
-            break;
-#endif /* FM_CAPWAP_SUPPORT */
-        default:
-            return E_OK;
-    }
-
-    return err;
-}
-
-#ifdef FM_CAPWAP_SUPPORT
 static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *parseArrayOffset)
 {
     e_NetHeaderType hdr         = p_HdrInfo->hdr;
@@ -2867,6 +2784,9 @@ static t_Error IpReassemblyStats(t_FmPcdManip *p_Manip, t_FmPcdManipReassemIpSta
     p_Stats->externalBufferBusy     = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalExternalBufferBusy);
     p_Stats->sgFragments            = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalSgFragmentCounter);
     p_Stats->dmaSemaphoreDepletion  = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalDmaSemaphoreDepletionCounter);
+#if (DPAA_VERSION >= 11)
+    p_Stats->nonConsistentSp        = GET_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->totalNCSPCounter);
+#endif /* (DPAA_VERSION >= 11) */
 
     if (p_Manip->ipReassmParams.p_Ipv4ReassTbl)
     {
@@ -3241,6 +3161,38 @@ static t_Error IPManip(t_FmPcdManip *p_Manip)
     return err;
 }
 
+static t_Error UpdateInitIpFrag(t_Handle       h_FmPcd,
+                                t_Handle       h_PcdParams,
+                                t_Handle       h_FmPort,
+                                t_FmPcdManip   *p_Manip,
+                                t_Handle       h_Ad,
+                                bool           validate)
+{
+    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->opcode == HMAN_OC_IP_FRAGMENTATION), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
+
+    UNUSED(h_FmPcd);
+    UNUSED(h_Ad);
+    UNUSED(h_PcdParams);
+    UNUSED(validate);
+    UNUSED(p_Manip);
+ 
+    fmPortGetSetCcParams.setCcParams.type = 0;
+    fmPortGetSetCcParams.getCcParams.type = MANIP_EXTRA_SPACE;
+    if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+ 
+    if (!fmPortGetSetCcParams.getCcParams.internalBufferOffset)
+        DBG(WARNING, ("manipExtraSpace must be larger than '0'"));
+ 
+    return E_OK;
+}
+
 static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
                           t_FmPcdManip          *p_Manip)
 {
@@ -3439,6 +3391,92 @@ static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd, t_FmPcd
         REPORT_ERROR(MINOR, err, ("Failed in dynamic manip change, continued to the rest of the owners."));
 }
 
+static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
+                                    t_Handle h_PcdParams,
+                                    t_Handle h_FmPort,
+                                    t_Handle h_Manip,
+                                    t_Handle h_Ad,
+                                    bool     validate,
+                                    int      level,
+                                    t_Handle h_FmTree)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error      err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+
+    UNUSED(level);
+    UNUSED(h_FmPcd);
+    UNUSED(h_FmTree);
+
+    switch (p_Manip->opcode)
+    {
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
+            break;
+#ifdef FM_CAPWAP_SUPPORT
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if (!p_Manip->h_Frag)
+                break;
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
+            err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
+            break;
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if (p_Manip->h_Frag)
+                err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
+            break;
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
+            err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+        case (HMAN_OC_IP_REASSEMBLY):
+            err = UpdateInitIpReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
+            break;
+        case (HMAN_OC_IP_FRAGMENTATION):
+            err = UpdateInitIpFrag(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
+            break;
+        default:
+            return E_OK;
+    }
+
+    return err;
+}
+
+static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree)
+{
+
+    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error         err = E_OK;
+
+    UNUSED(level);
+
+    switch (p_Manip->opcode)
+    {
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+
+           if (p_Manip->h_Frag)
+           {
+               if (!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) &&
+                   !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
+                   !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation requires manipulation be updated previously in SetPcd function"));
+           }
+           break;
+#ifdef FM_CAPWAP_SUPPORT
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if (p_Manip->h_Frag)
+                err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+        default:
+            return E_OK;
+    }
+
+    return err;
+}
+
 /*****************************************************************************/
 /*              Inter-module API routines                                    */
 /*****************************************************************************/
@@ -3550,19 +3588,6 @@ t_Error FmPcdManipCheckParamsForCcNextEngine(t_FmPcdCcNextEngineParams *p_FmPcdC
                 *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
                 break;
             case (HMAN_OC_IP_FRAGMENTATION):
-#if (DPAA_VERSION == 10)
-                if (!(p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE))
-                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                                     ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
-#else
-                if (!((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE) ||
-                      (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_PLCR)))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                                 ("For this type of header manipulation has to be nextEngine "
-                                  "e_FM_PCD_DONE or e_FM_PCD_PLCR"));
-#endif /* (DPAA_VERSION == 10) */
-                p_Manip->ownerTmp++;
-                break;
             case (HMAN_OC_IP_REASSEMBLY):
                 if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
index 390ca6e..2ab9b15 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
@@ -332,7 +332,8 @@ typedef _Packed struct t_IpReassCommonTbl {
     volatile uint32_t totalExternalBufferBusy;
     volatile uint32_t totalSgFragmentCounter;
     volatile uint32_t totalDmaSemaphoreDepletionCounter;
-    volatile uint32_t reserved3[2];
+    volatile uint32_t totalNCSPCounter;
+    volatile uint32_t reserved3[1];
 } _PackedType t_IpReassCommonTbl;
 
 typedef _Packed struct t_Hmtd {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
index 747347c..6bde6a0 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
@@ -756,10 +756,17 @@ void FmPcdLockUnlockAll(t_Handle h_FmPcd)
     CORE_MemoryBarrier();
 }
 
+t_Error FmPcdHcSync(t_Handle h_FmPcd)
+{
+    ASSERT_COND(h_FmPcd);
+    ASSERT_COND(((t_FmPcd*)h_FmPcd)->h_Hc);
+
+    return FmHcPcdSync(((t_FmPcd*)h_FmPcd)->h_Hc);
+}
+
 t_Handle FmPcdGetHcHandle(t_Handle h_FmPcd)
 {
     ASSERT_COND(h_FmPcd);
-    SANITY_CHECK_RETURN_VALUE(((t_FmPcd*)h_FmPcd)->h_Hc, E_INVALID_HANDLE, NULL);
     return ((t_FmPcd*)h_FmPcd)->h_Hc;
 }
 
@@ -895,13 +902,6 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     return p_FmPcd;
 }
 
-t_Handle FM_PCD_GetHcDevH(t_Handle h_FmPcd)
-{
-    t_FmPcd        *p_FmPcd = (t_FmPcd *) h_FmPcd;
-
-    return (p_FmPcd) ? FmGcGetHcPortDevH(p_FmPcd->h_Hc) : NULL;
-}
-
 t_Error FM_PCD_Init(t_Handle h_FmPcd)
 {
     t_FmPcd         *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -1228,7 +1228,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     uint8_t                 ipsecAhUnit = 0,ipsecEspUnit = 0;
     bool                    ipsecAhExists = FALSE, ipsecEspExists = FALSE, shim1Selected = FALSE;
     uint8_t                 hdrNum;
-    t_FmPcdNetEnvParams     *p_modifiedNetEnvParams;
+    t_FmPcdNetEnvParams     *p_ModifiedNetEnvParams;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_STATE, NULL);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, NULL);
@@ -1254,15 +1254,15 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     /* As anyone doesn't have handle of this netEnv yet, no need
        to protect it with spinlocks */
 
-    p_modifiedNetEnvParams = (t_FmPcdNetEnvParams *) XX_Malloc(sizeof(t_FmPcdNetEnvParams));
-    if (!p_modifiedNetEnvParams)
+    p_ModifiedNetEnvParams = (t_FmPcdNetEnvParams *)XX_Malloc(sizeof(t_FmPcdNetEnvParams));
+    if (!p_ModifiedNetEnvParams)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FmPcdNetEnvParams"));
         return NULL;
     }
 
-    memcpy(p_modifiedNetEnvParams, p_NetEnvParams, sizeof(t_FmPcdNetEnvParams));
-    p_NetEnvParams = p_modifiedNetEnvParams;
+    memcpy(p_ModifiedNetEnvParams, p_NetEnvParams, sizeof(t_FmPcdNetEnvParams));
+    p_NetEnvParams = p_ModifiedNetEnvParams;
 
     netEnvCurrId = (uint8_t)i;
 
@@ -1295,7 +1295,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     {
                         REPORT_ERROR(MINOR, E_FULL,
                                 ("Illegal unit - header with opt may not be interchangeable with the same header without opt"));
-                        XX_Free(p_modifiedNetEnvParams);
+                        XX_Free(p_ModifiedNetEnvParams);
                         return NULL;
                     }
                 }
@@ -1319,7 +1319,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 if (ipsecEspExists && (ipsecEspUnit != i))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
-                    XX_Free(p_modifiedNetEnvParams);
+                    XX_Free(p_ModifiedNetEnvParams);
                     return NULL;
                 }
                 else
@@ -1333,7 +1333,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 if (ipsecAhExists && (ipsecAhUnit != i))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, ("HEADER_TYPE_IPSEC_AH and HEADER_TYPE_IPSEC_ESP may not be defined in separate units"));
-                    XX_Free(p_modifiedNetEnvParams);
+                    XX_Free(p_ModifiedNetEnvParams);
                     return NULL;
                 }
                 else
@@ -1415,7 +1415,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             if (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[1].hdr != HEADER_TYPE_NONE)
             {
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header may not be interchanged with other headers"));
-                XX_Free(p_modifiedNetEnvParams);
+                XX_Free(p_ModifiedNetEnvParams);
                 return NULL;
             }
     }
@@ -1429,12 +1429,12 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     if (shim1Selected)
                     {
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header cannot be selected with UDP_IPSEC_ESP"));
-                        XX_Free(p_modifiedNetEnvParams);
+                        XX_Free(p_ModifiedNetEnvParams);
                         return NULL;
                     }
                     shim1Selected = TRUE;
                     p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000001;
-                break;
+                    break;
                 case (HEADER_TYPE_USER_DEFINED_SHIM2):
                     p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000002;
                     break;
@@ -1466,14 +1466,14 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
                 {
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
-                    XX_Free(p_modifiedNetEnvParams);
+                    XX_Free(p_ModifiedNetEnvParams);
                     return NULL;
                 }
                 p_FmPcd->netEnvs[netEnvCurrId].lcvs[hdrNum] |= p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
             }
         }
     }
-    XX_Free(p_modifiedNetEnvParams);
+    XX_Free(p_ModifiedNetEnvParams);
 
     p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock = XX_InitSpinlock();
     if (!p_FmPcd->netEnvs[netEnvCurrId].h_Spinlock)
@@ -1542,7 +1542,10 @@ t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd)
         revInfo.packageRev = IP_OFFLOAD_PACKAGE_NUMBER;
     }
     if (revInfo.packageRev != IP_OFFLOAD_PACKAGE_NUMBER)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Fman ctrl code package"));
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Fman ctrl code package"));
+
+    if (!p_FmPcd->h_Hc)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("HC must be initialized in this mode"));
 
     p_FmPcd->advancedOffloadSupport = TRUE;
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index 07cec14..5752bd6 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -45,6 +45,7 @@
 
 #include "fm_port.h"
 
+
 /****************************************/
 /*       static functions               */
 /****************************************/
@@ -88,7 +89,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 #ifdef FM_NO_BACKUP_POOLS
     if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
         if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("BackupBmPools"));
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("BackupBmPools"));
 #endif /* FM_NO_BACKUP_POOLS */
         }
 
@@ -142,7 +143,8 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /****************************************/
     /*   Rx only                            */
     /****************************************/
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* Check that divisible by 256 and not larger than 256 */
         if (p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
@@ -185,7 +187,6 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     else if (p_FmPort->fifoBufs.extra)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No fifoBufs.extra for non Rx ports"));
 
-
     /****************************************/
     /*   Tx only                            */
     /****************************************/
@@ -206,6 +207,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
             if (p_FmPort->fifoDeqPipelineDepth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
     }
+
     /****************************************/
     /*   Non Tx Ports                       */
     /****************************************/
@@ -316,7 +318,7 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 
         /* add some margin for back to back capability to improve performance
          * allows the hardware to pipeline new frame dma while the previous
-         * frame not yet transmitted). */
+         * frame not yet transmitted. */
         if (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
             minFifoSizeRequired += 3*BMI_FIFO_UNITS;
         else
@@ -594,7 +596,14 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     tmpReg = 0;
     tmpReg |= ((uint32_t)p_Params->cheksumLastBytesIgnore << BMI_RX_FRAME_END_CS_IGNORE_SHIFT);
     tmpReg |= ((uint32_t)p_Params->cutBytesFromEnd<< BMI_RX_FRAME_END_CUT_SHIFT);
-
+#ifdef FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
+    /* zero cutBytesFromEnd field which means that bmi doesn't
+       remove further bytes because the MAC already remove the CRC.
+       the workaround is relevant only in initial rev of FMan v3.
+     */
+    if ((p_FmPort->fmRevInfo.majorRev == 6) && (p_FmPort->fmRevInfo.minorRev == 0))
+        tmpReg &= 0xffe0ffff;
+#endif /* FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320 */
     WRITE_UINT32(p_Regs->fmbm_rfed, tmpReg);
 
     /* IC parameters */
@@ -969,7 +978,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
         (p_FmPort->portType != e_FM_PORT_TYPE_RX))
     {
         if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
-                        (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+            (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         {
             /* define dequeue NIA */
             WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
@@ -1058,10 +1067,10 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
         case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             if (!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
          default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
     }
 
     /* Set counter */
@@ -1113,7 +1122,7 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             *p_Ptr = &p_BmiRegs->fmbm_rpec;
             break;
         default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
     }
 
     return E_OK;
@@ -1139,10 +1148,10 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
         case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             if (!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
     }
 
     /* Set counter */
@@ -1179,7 +1188,7 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             *p_Ptr = &p_BmiRegs->fmbm_tbdc;
             break;
         default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Tx ports"));
     }
 
     return E_OK;
@@ -1207,16 +1216,16 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
         case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
         case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
             /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
             ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
             if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
-               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter(%d) is not available for O/H ports", counter));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter(%d) is not available for O/H ports", counter));
     }
 
     /* Set counter */
@@ -1265,7 +1274,7 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             *p_Ptr = &p_BmiRegs->fmbm_opec;
             break;
         default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
     }
 
     return E_OK;
@@ -1331,7 +1340,7 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     {
         tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
         if (tmpPrsOffset == ILLEGAL_BASE)
-            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
         tmpReg |= (PRS_HDR_SW_PRS_EN | tmpPrsOffset);
     }
     *p_SoftSeqAttachReg = tmpReg;
@@ -1544,7 +1553,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             /*because of the state that VSPE is defined per port - all PCD path should be according to this requirement
              if !VSPE - in port, for relevant scheme VSPE can not be set*/
             if (!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSPE is not at port level"));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("VSPE is not at port level"));
 #endif /* (DPAA_VERSION >= 11) */
         }
 
@@ -1570,7 +1579,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         absoluteProfileId = (uint16_t)FmPcdPlcrProfileGetAbsoluteId(p_PcdParams->p_PlcrParams->h_Profile);
 
         if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Private port profile not valid."));
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Private port profile not valid."));
 
         tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
 
@@ -1889,11 +1898,11 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
 
         err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
         if (err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
 
         err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
         if (err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
         p_FmPort->useClsPlan = FALSE;
     }
 
@@ -1902,7 +1911,7 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         /* unbind - we need to get the treeId too */
         err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd,  p_FmPort->ccTreeId);
         if (err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     p_FmPort->pcdEngines = 0;
@@ -1916,37 +1925,33 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
 
     ASSERT_COND(p_FmPort);
 
-    /* get PCD registers pointers */
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-    }
 
-    if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    /* get PCD registers pointers */
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+    else
+        p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
 
     /* check that current NIA is BMI to BMI */
     if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
                      ("may be called only for ports in BMI-to-BMI state."));
 
-    WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
+    if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
+    if (p_FmPort->requiredAction & UPDATE_NIA_CMNE)
+    {
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
+        else
+            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
+    }
 
     if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
 
-    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
-        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
-
     if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
@@ -1954,6 +1959,7 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
     }
+
     if (p_FmPort->requiredAction & UPDATE_NIA_FPNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
@@ -1961,12 +1967,13 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
     }
-    if (p_FmPort->requiredAction & UPDATE_NIA_CMNE)
+
+    WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
+
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
     {
-        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
-        else
-            WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
+        p_FmPort->origNonRxQmiRegsPndn = GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn);
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
     }
 
     return E_OK;
@@ -1979,56 +1986,19 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     ASSERT_COND(p_FmPort);
 
     /* get PCD registers pointers */
-    switch (p_FmPort->portType)
-    {
-        case (e_FM_PORT_TYPE_RX_10G):
-        case (e_FM_PORT_TYPE_RX):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
-            break;
-        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
-    }
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->origNonRxQmiRegsPndn);
+
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
+    else
+        p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
 
     WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
 
-    if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
-    {
-        switch (p_FmPort->portType)
-        {
-            case (e_FM_PORT_TYPE_TX_10G):
-            case (e_FM_PORT_TYPE_TX):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
-                break;
-            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case (e_FM_PORT_TYPE_RX):
-            case (e_FM_PORT_TYPE_RX_10G):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
-                break;
-           default:
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
-        }
-    }
 
-    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
-    {
-        switch (p_FmPort->portType)
-        {
-            case (e_FM_PORT_TYPE_TX_10G):
-            case (e_FM_PORT_TYPE_TX):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
-                break;
-            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-                WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
-                break;
-            default:
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Can not reach this stage"));
-        }
-    }
+    if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
+        FmPcdHcSync(p_FmPort->h_FmPcd);
 
     if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
@@ -2038,6 +2008,9 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
     }
 
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+        WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+
     if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
         if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
@@ -2224,6 +2197,11 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         p_CcParams->getCcParams.revInfo.minorRev = p_FmPort->fmRevInfo.minorRev;
         p_CcParams->getCcParams.type &= ~FM_REV;
     }
+    if (p_CcParams->getCcParams.type & MANIP_EXTRA_SPACE)
+    {
+        p_CcParams->getCcParams.internalBufferOffset = p_FmPort->internalBufferOffset;
+        p_CcParams->getCcParams.type &= ~MANIP_EXTRA_SPACE;
+    }
     if (p_CcParams->getCcParams.type & GET_NIA_FPNE)
     {
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
@@ -2413,10 +2391,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo
                                                                     = DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign    = DEFAULT_PORT_bufferPrefixContent_dataAlign;
-    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = DEFAULT_PORT_dmaSwapData;
-    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = DEFAULT_PORT_dmaIntContextCacheAttr;
-    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = DEFAULT_PORT_dmaHeaderCacheAttr;
-    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = DEFAULT_PORT_dmaScatterGatherCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaSwapData                      = (e_FmDmaSwapOption)DEFAULT_PORT_dmaSwapData;
+    p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = (e_FmDmaCacheOption)DEFAULT_PORT_dmaIntContextCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaHeaderCacheAttr               = (e_FmDmaCacheOption)DEFAULT_PORT_dmaHeaderCacheAttr;
+    p_FmPort->p_FmPortDriverParam->dmaScatterGatherCacheAttr        = (e_FmDmaCacheOption)DEFAULT_PORT_dmaScatterGatherCacheAttr;
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
     p_FmPort->p_FmPortDriverParam->liodnBase                        = p_FmPortParams->liodnBase;
     p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore           = DEFAULT_PORT_cheksumLastBytesIgnore;
@@ -2429,7 +2407,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     {
         p_FmPort->fifoBufs.num                                      = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
         p_FmPort->fifoBufs.extra                                    = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
-        p_FmPort->openDmas.num                                      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType, p_FmPort->fmRevInfo.majorRev);
+        p_FmPort->openDmas.num                                      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
         p_FmPort->openDmas.extra                                    = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
         p_FmPort->tasks.num                                         = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
         p_FmPort->tasks.extra                                       = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
@@ -2443,7 +2421,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             /* Overwrite HC defaults */
             p_FmPort->fifoBufs.num      = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
             p_FmPort->fifoBufs.extra    = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
-            p_FmPort->openDmas.num      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType, p_FmPort->fmRevInfo.majorRev);
+            p_FmPort->openDmas.num      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
             p_FmPort->openDmas.extra    = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
             p_FmPort->tasks.num         = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
             p_FmPort->tasks.extra       = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
@@ -2690,6 +2668,8 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
            (p_FmPort->portType == e_FM_PORT_TYPE_RX))
     {
         p_FmPort->p_FmPortDriverParam->errorsToDiscard |= FM_PORT_FRM_ERR_PHYSICAL;
+        if (!p_FmPort->fifoBufs.num)
+            p_FmPort->fifoBufs.num = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
         p_FmPort->fifoBufs.num += 4*KILOBYTE;
     }
 #endif /* FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669 */
@@ -2852,7 +2832,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     if (FmVSPFreeForPort(p_FmPort->h_Fm,
                         p_FmPort->portType,
                         p_FmPort->portId) != E_OK)
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSP free of port FAILED"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("VSP free of port FAILED"));
 
     if (p_FmPort->p_MuramPage)
         FM_MURAM_FreeMem(p_FmPort->h_FmMuram, p_FmPort->p_MuramPage);
@@ -3357,7 +3337,7 @@ t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDma
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
     err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfOpenDmas->num, (uint8_t*)&p_NumOfOpenDmas->extra, FALSE);
     if (err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     memcpy(&p_FmPort->openDmas, p_NumOfOpenDmas, sizeof(t_FmPortRsrc));
 
@@ -3382,7 +3362,7 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
 
     err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfTasks->num, (uint8_t*)&p_NumOfTasks->extra, FALSE);
     if (err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* update driver's struct */
     memcpy(&p_FmPort->tasks, p_NumOfTasks, sizeof(t_FmPortRsrc));
@@ -3424,7 +3404,7 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
                           &p_SizeOfFifo->extra,
                           FALSE);
     if (err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -3727,7 +3707,7 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 #endif /* ! FM_NO_ADVANCED_RATE_LIMITER */
         {
             if (p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
-                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDualRateLimitScaleDown"));
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDualRateLimitScaleDown"));
 
             if (p_RateLimit->maxBurstSize % 1000)
             {
@@ -3779,6 +3759,32 @@ t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
     return E_OK;
 }
 
+t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio, uint8_t wq)
+{
+    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
+    uint32_t    tmpReg;
+    uint32_t    wqTmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
+
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX) && (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("PFC mapping is available for Tx ports only"));
+
+    if (prio > 7)
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("PFC priority (%d) is out of range (0-7)", prio));
+    if (wq > 7)
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("WQ (%d) is out of range (0-7)", wq));
+
+    tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpfcm[0]);
+    tmpReg &= ~(0xf << ((7-prio)*4));
+    wqTmpReg = ((uint32_t)wq << ((7-prio)*4));
+    tmpReg |= wqTmpReg;
+
+    WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpfcm[0], tmpReg);
+
+    return E_OK;
+}
 
 t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
 {
@@ -3863,22 +3869,27 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
     if (!p_FmPortPerformanceCnt->taskCompVal ||
         (p_FmPortPerformanceCnt->taskCompVal > p_FmPort->tasks.num))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("performanceCnt.taskCompVal has to be in the range of 1 - %d (current value)!",
+                     ("taskCompVal (%d) has to be in the range of 1 - %d (current value)!",
+                      p_FmPortPerformanceCnt->taskCompVal,
                       p_FmPort->tasks.num));
     if (!p_FmPortPerformanceCnt->dmaCompVal ||
         (p_FmPortPerformanceCnt->dmaCompVal > p_FmPort->openDmas.num))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("performanceCnt.dmaCompVal has to be in the range of 1 - %d (current value)!",
+                     ("dmaCompVal (%d) has to be in the range of 1 - %d (current value)!",
+                      p_FmPortPerformanceCnt->dmaCompVal,
                       p_FmPort->openDmas.num));
     if (!p_FmPortPerformanceCnt->fifoCompVal ||
         (p_FmPortPerformanceCnt->fifoCompVal > p_FmPort->fifoBufs.num))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("performanceCnt.fifoCompVal has to be in the range of 256 - %d (current value)!",
+                     ("fifoCompVal (%d) has to be in the range of 256 - %d (current value)!",
+                      p_FmPortPerformanceCnt->fifoCompVal,
                       p_FmPort->fifoBufs.num));
     if (p_FmPortPerformanceCnt->fifoCompVal % BMI_FIFO_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("performanceCnt.fifoCompVal has to be divisible by %d",
+                     ("fifoCompVal (%d) has to be divisible by %d",
+                      p_FmPortPerformanceCnt->fifoCompVal,
                       BMI_FIFO_UNITS));
+
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_RX_10G):
@@ -3962,7 +3973,7 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
         failed = TRUE;
     }
     if (failed)
-        RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     memset(&savedParams, 0, sizeof(savedParams));
     while (TRUE)
@@ -4100,7 +4111,7 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
         }
     }
     if (i == FM_PORT_MAX_NUM_OF_EXT_POOLS)
-        RETURN_ERROR(MINOR, E_INVALID_VALUE,("poolId %d is not included in this ports pools", poolId));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("poolId %d is not included in this ports pools", poolId));
 
     return E_OK;
 }
@@ -4123,7 +4134,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
             if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
                 (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
             {
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
                 return 0;
             }
             bmiCounter = FALSE;
@@ -4143,7 +4154,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
             case (e_FM_PORT_TYPE_RX):
                 if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
-                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
                 break;
@@ -4151,7 +4162,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
             case (e_FM_PORT_TYPE_TX):
                 if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
-                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
                 break;
@@ -4159,12 +4170,12 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
             case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
                 if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
-                    REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
                 break;
             default:
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported port type"));
                 return 0;
         }
         return GET_UINT32(*p_Reg);
@@ -4174,7 +4185,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
         /* check that counters are enabled */
         if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
         {
-            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             return 0;
         }
 
@@ -4190,7 +4201,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
             case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc);
             default:
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available"));
                 return 0;
         }
     }
@@ -4212,7 +4223,7 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
         case (e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
             if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-                        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
         case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
@@ -4228,20 +4239,20 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
             case (e_FM_PORT_TYPE_RX_10G):
             case (e_FM_PORT_TYPE_RX):
                if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
-                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                 break;
             case (e_FM_PORT_TYPE_TX_10G):
             case (e_FM_PORT_TYPE_TX):
                if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
-                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                 break;
             case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
                if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
-                    RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                  break;
             default:
-               RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported port type"));
+               RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported port type"));
         }
         WRITE_UINT32(*p_Reg, value);
     }
@@ -4250,7 +4261,7 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
 
         /* check that counters are enabled */
         if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
 
         /* Set counter */
         switch (counter)
@@ -4268,7 +4279,7 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc, value);
                 break;
             default:
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available"));
         }
     }
 
@@ -4287,7 +4298,7 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
 
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
-        REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
         return 0;
     }
 
@@ -4303,13 +4314,13 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
                     return  GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i]);
                 else
                 {
-                    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not enabled"));
+                    REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not enabled"));
                     return 0;
                 }
             }
         }
     }
-    REPORT_ERROR(MINOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
+    REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
     return 0;
 }
 
@@ -4324,7 +4335,7 @@ t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
 
 
     for (i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
@@ -4341,11 +4352,11 @@ t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_
                     return E_OK;
                 }
                 else
-                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not enabled"));
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not enabled"));
             }
         }
     }
-    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
+    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Pool %d is not used", poolId));
 }
 
 bool FM_PORT_IsStalled(t_Handle h_FmPort)
@@ -4360,7 +4371,7 @@ bool FM_PORT_IsStalled(t_Handle h_FmPort)
     err = FmIsPortStalled(p_FmPort->h_Fm, p_FmPort->hardwarePortId, &isStalled);
     if (err != E_OK)
     {
-        REPORT_ERROR(MINOR, err, NO_MSG);
+        REPORT_ERROR(MAJOR, err, NO_MSG);
         return TRUE;
     }
     return isStalled;
@@ -4621,7 +4632,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
     /* check relevance of this routine  - only when policer is used
     directly after BMI or Parser */
     if ((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
 
     switch (p_FmPort->portType)
     {
@@ -4738,7 +4749,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         if (err)
         {
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
         }
         WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
 
@@ -4746,7 +4757,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         RELEASE_LOCK(p_FmPort->lock);
     }
     else
-        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Coarse Classification not defined for this port."));
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Coarse Classification not defined for this port."));
 
     return E_OK;
 }
@@ -4762,6 +4773,11 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort)
     if (p_FmPort->imEn)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
          DBG(TRACE, ("FM Port Try Lock - BUSY"));
@@ -4788,6 +4804,11 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
     if (p_FmPort->imEn)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
          DBG(TRACE, ("FM Port Try Lock - BUSY"));
@@ -4798,7 +4819,7 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
     if (err != E_OK)
     {
         RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if (p_FmPort->h_IpReassemblyTree)
@@ -4823,6 +4844,11 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
     if (p_FmPort->imEn)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
          DBG(TRACE, ("FM Port Try Lock - BUSY"));
@@ -4857,7 +4883,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
             /* No user-tree, need to build internal tree */
             p_FmPcdCcTreeParams = (t_FmPcdCcTreeParams*)XX_Malloc(sizeof(t_FmPcdCcTreeParams));
             if (!p_FmPcdCcTreeParams)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));  
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcTreeParams"));
             memset(p_FmPcdCcTreeParams, 0, sizeof(t_FmPcdCcTreeParams));
             p_FmPcdCcTreeParams->h_NetEnv = p_PcdParams->h_NetEnv;
             p_FmPort->h_IpReassemblyTree = FM_PCD_CcRootBuild(p_FmPort->h_FmPcd, p_FmPcdCcTreeParams);
@@ -4892,7 +4918,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 p_FmPort->h_IpReassemblyTree = NULL;
             }
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
         }
     }
 
@@ -4918,7 +4944,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
         }
         FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
         RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if ((p_FmPort->pcdEngines & FM_PCD_PRS) &&
@@ -4935,7 +4961,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
             }
             FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
         }
         p_FmPort->includeInPrsStatistics = TRUE;
     }
@@ -4986,7 +5012,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 }
                 FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
                 RELEASE_LOCK(p_FmPort->lock);
-                RETURN_ERROR(MINOR, err, NO_MSG);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
 
@@ -5017,7 +5043,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 p_FmPort->h_IpReassemblyTree = NULL;
             }
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 
         /* Set post-bmi-prepare-to-enq nia */
@@ -5032,7 +5058,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 p_FmPort->h_IpReassemblyTree = NULL;
             }
             RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 
         if (p_FmPort->h_IpReassemblyManip)
@@ -5063,7 +5089,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                     p_FmPort->h_IpReassemblyTree = NULL;
                 }
                 RELEASE_LOCK(p_FmPort->lock);
-                RETURN_ERROR(MINOR, err, NO_MSG);
+                RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
     }
@@ -5080,7 +5106,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
             p_FmPort->h_IpReassemblyTree = NULL;
         }
         RELEASE_LOCK(p_FmPort->lock);
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     RELEASE_LOCK(p_FmPort->lock);
@@ -5099,6 +5125,11 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort)
     if (p_FmPort->imEn)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independant mode ports only"));
 
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+        (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
+
     if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
     {
          DBG(TRACE, ("FM Port Try Lock - BUSY"));
@@ -5574,7 +5605,7 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
        will be more CGs available ....
     for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
         if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
-            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("CG id!"));
     */
 
 #ifdef FM_NO_OP_OBSERVED_CGS
@@ -5659,7 +5690,7 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
        will be more CGs available ....
     for (i=0; i<p_CongestionGrps->numOfCongestionGrpsToConsider; i++)
         if (p_CongestionGrps->congestionGrpsToConsider[i] >= FM_PORT_NUM_OF_CONGESTION_GRPS)
-            RETURN_ERROR(MINOR, E_INVALID_VALUE, ("CG id!"));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("CG id!"));
     */
 
 #ifdef FM_NO_OP_OBSERVED_CGS
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
index 7873595..f922df8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
@@ -45,6 +45,7 @@
 
 #include "fm_common.h"
 #include "fm_sp_common.h"
+#include "fsl_fman_sp.h"
 
 
 #define __ERR_MODULE__  MODULE_FM_PORT
@@ -78,24 +79,17 @@
 #define DEFAULT_PORT_bufferPrefixContent_dataAlign      DEFAULT_FM_SP_bufferPrefixContent_dataAlign
 #define DEFAULT_PORT_cheksumLastBytesIgnore             0
 #define DEFAULT_PORT_cutBytesFromEnd                    4
-#define DEFAULT_PORT_txFifoMinFillLevel                 0
 #define DEFAULT_PORT_fifoDeqPipelineDepth_IM            2
-#define DEFAULT_PORT_fifoDeqPipelineDepth_1G            1
-#define DEFAULT_PORT_fifoDeqPipelineDepth_10G           4
-#define DEFAULT_PORT_fifoDeqPipelineDepth_OH            2
 
-#define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
-#define DEFAULT_PORT_rxFifoPriElevationLevel            BMI_MAX_FIFO_SIZE
-#define DEFAULT_PORT_rxFifoThreshold                    (BMI_MAX_FIFO_SIZE*3/4)
 #define DEFAULT_PORT_frmDiscardOverride                 FALSE
 
-#define DEFAULT_PORT_dmaSwapData                        DEFAULT_FM_SP_dmaSwapData
-#define DEFAULT_PORT_dmaIntContextCacheAttr             DEFAULT_FM_SP_dmaIntContextCacheAttr
-#define DEFAULT_PORT_dmaHeaderCacheAttr                 DEFAULT_FM_SP_dmaHeaderCacheAttr
-#define DEFAULT_PORT_dmaScatterGatherCacheAttr          DEFAULT_FM_SP_dmaScatterGatherCacheAttr
-#define DEFAULT_PORT_dmaWriteOptimize                   DEFAULT_FM_SP_dmaWriteOptimize
+#define DEFAULT_PORT_dmaSwapData                        (e_FmDmaSwapOption)DEFAULT_FMAN_SP_DMA_SWAP_DATA
+#define DEFAULT_PORT_dmaIntContextCacheAttr             (e_FmDmaCacheOption)DEFAULT_FMAN_SP_DMA_INT_CONTEXT_CACHE_ATTR
+#define DEFAULT_PORT_dmaHeaderCacheAttr                 (e_FmDmaCacheOption)DEFAULT_FMAN_SP_DMA_HEADER_CACHE_ATTR
+#define DEFAULT_PORT_dmaScatterGatherCacheAttr          (e_FmDmaCacheOption)DEFAULT_FMAN_SP_DMA_SCATTER_GATHER_CACHE_ATTR
+#define DEFAULT_PORT_dmaWriteOptimize                   DEFAULT_FMAN_SP_DMA_WRITE_OPTIMIZE
 
-#define DEFAULT_PORT_noScatherGather                    DEFAULT_FM_SP_noScatherGather
+#define DEFAULT_PORT_noScatherGather                    DEFAULT_FMAN_SP_NO_SCATTER_GATHER
 #define DEFAULT_PORT_forwardIntContextReuse             FALSE
 #define DEFAULT_PORT_BufMargins_startMargins            32
 #define DEFAULT_PORT_BufMargins_endMargins              0
@@ -110,6 +104,17 @@
 
 #define DEFAULT_notSupported                            0xff
 
+#if (DPAA_VERSION < 11)
+#define DEFAULT_PORT_rxFifoPriElevationLevel            BMI_MAX_FIFO_SIZE
+#define DEFAULT_PORT_rxFifoThreshold                    (BMI_MAX_FIFO_SIZE*3/4)
+
+#define DEFAULT_PORT_txFifoMinFillLevel                 0
+#define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
+#define DEFAULT_PORT_fifoDeqPipelineDepth_1G            1
+#define DEFAULT_PORT_fifoDeqPipelineDepth_10G           4
+
+#define DEFAULT_PORT_fifoDeqPipelineDepth_OH            2
+
 /* Host command port MUST NOT be changed to more than 1 !!! */
 #define DEFAULT_PORT_numOfTasks(type)                       \
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
@@ -124,9 +129,9 @@
                ((((type) == e_FM_PORT_TYPE_RX) ||           \
                  ((type) == e_FM_PORT_TYPE_TX)) ? 2 : 0))
 
-#define DEFAULT_PORT_numOfOpenDmas(type, rev)             \
-    (uint32_t)((((type) == e_FM_PORT_TYPE_TX_10G) ||      \
-                ((type) == e_FM_PORT_TYPE_RX_10G)) ? 8 : ((rev>=6) ? 2 : 1))
+#define DEFAULT_PORT_numOfOpenDmas(type)                    \
+    (uint32_t)((((type) == e_FM_PORT_TYPE_TX_10G) ||        \
+                ((type) == e_FM_PORT_TYPE_RX_10G)) ? 8 : 1 )
 
 #define DEFAULT_PORT_extraNumOfOpenDmas(type)               \
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
@@ -142,6 +147,45 @@
 
 #define DEFAULT_PORT_extraNumOfFifoBufs             0
 
+#else  /* (DPAA_VERSION < 11) */
+/* Defaults are registers' reset values */
+#define DEFAULT_PORT_rxFifoPriElevationLevel            (256 * KILOBYTE)
+#define DEFAULT_PORT_rxFifoThreshold                    (256 * KILOBYTE)
+
+#define DEFAULT_PORT_txFifoMinFillLevel                 0
+#define DEFAULT_PORT_txFifoLowComfLevel                 (5 * KILOBYTE)
+#define DEFAULT_PORT_fifoDeqPipelineDepth_1G            2
+#define DEFAULT_PORT_fifoDeqPipelineDepth_10G           4
+
+#define DEFAULT_PORT_fifoDeqPipelineDepth_OH            2
+
+#define DEFAULT_PORT_numOfTasks(type)                       \
+    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
+                ((type) == e_FM_PORT_TYPE_TX_10G)) ? 14 :  \
+               (((type) == e_FM_PORT_TYPE_RX) ||            \
+                 ((type) == e_FM_PORT_TYPE_TX)) ? 4 :       \
+                 ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ? 6 : 1)
+
+#define DEFAULT_PORT_extraNumOfTasks(type)          0
+
+#define DEFAULT_PORT_numOfOpenDmas(type)                    \
+    (uint32_t)(((type) == e_FM_PORT_TYPE_RX_10G) ? 8 :      \
+               ((type) == e_FM_PORT_TYPE_TX_10G) ? 12 :    \
+               ((type) == e_FM_PORT_TYPE_RX)     ? 2 :      \
+               ((type) == e_FM_PORT_TYPE_TX)     ? 3 :      \
+               ((type) == e_FM_PORT_TYPE_OH_HOST_COMMAND) ? 2 : 4 )
+
+#define DEFAULT_PORT_extraNumOfOpenDmas(type)       0
+
+#define DEFAULT_PORT_numOfFifoBufs(type)                   \
+    (uint32_t) (((type) == e_FM_PORT_TYPE_RX_10G) ? 96 : \
+                ((type) == e_FM_PORT_TYPE_TX_10G) ? 64 : \
+                ((type) == e_FM_PORT_TYPE_OH_HOST_COMMAND) ? 10 : 50 )
+
+#define DEFAULT_PORT_extraNumOfFifoBufs             0
+
+#endif /* (DPAA_VERSION < 11) */
+
 #define DEFAULT_PORT_txBdRingLength                 16
 #define DEFAULT_PORT_rxBdRingLength                 128
 #define DEFAULT_PORT_ImfwExtStructsMemId            0
@@ -274,7 +318,7 @@ typedef _Packed struct
     volatile uint32_t   fmbm_tccb;      /**< Tx Coarse Classification Base */
     volatile uint32_t   reserved0[0x0e];/**< (0x038-0x070) */
     volatile uint32_t   fmbm_tfne;      /**< Tx Frame Next Engine */
-    volatile uint32_t   reserved1[0x02];/**< (0x074-0x7C) */
+    volatile uint32_t   fmbm_tpfcm[0x02];/**< Tx Priority based Flow Control (PFC) Mapping */
     volatile uint32_t   fmbm_tcmne;     /**< Tx Frame Continuous Mode Next Engine */
     volatile uint32_t   reserved2[0x60];/**< (0x080-0x200) */
     volatile uint32_t   fmbm_tstc;      /**< Tx Statistics Counters */
@@ -456,7 +500,7 @@ typedef _Packed struct
 #define BMI_PORT_CFG_IM                         0x01000000
 #define BMI_PORT_STATUS_BSY                     0x80000000
 #define BMI_COUNTERS_EN                         0x80000000
-#define BMI_DMA_ATTR_WRITE_OPTIMIZE             FM_SP_DMA_ATTR_WRITE_OPTIMIZE
+#define BMI_DMA_ATTR_WRITE_OPTIMIZE             FMAN_SP_DMA_ATTR_WRITE_OPTIMIZE
 
 #define BMI_PORT_RFNE_FRWD_DCL4C                0x10000000
 #define BMI_PORT_RFNE_FRWD_RPD                  0x40000000
@@ -479,10 +523,10 @@ typedef _Packed struct
 #define BMI_CMD_ATTR_MACCMD_SECURED             0x00001000
 #define BMI_CMD_ATTR_MACCMD_SC_MASK             0x00000f00
 
-#define BMI_EXT_BUF_POOL_EN_COUNTER             FM_SP_EXT_BUF_POOL_EN_COUNTER
-#define BMI_EXT_BUF_POOL_VALID                  FM_SP_EXT_BUF_POOL_VALID
+#define BMI_EXT_BUF_POOL_EN_COUNTER             FMAN_SP_EXT_BUF_POOL_EN_COUNTER
+#define BMI_EXT_BUF_POOL_VALID                  FMAN_SP_EXT_BUF_POOL_VALID
 
-#define BMI_EXT_BUF_POOL_BACKUP                 FM_SP_EXT_BUF_POOL_BACKUP
+#define BMI_EXT_BUF_POOL_BACKUP                 FMAN_SP_EXT_BUF_POOL_BACKUP
 
 #define BMI_EXT_BUF_POOL_ID_MASK                0x003F0000
 #define BMI_STATUS_RX_MASK_UNUSED               (uint32_t)(~(FM_PORT_FRM_ERR_DMA                    | \
@@ -548,10 +592,10 @@ typedef _Packed struct
 
 /* shifts */
 #define BMI_PORT_CFG_MS_SEL_SHIFT               16
-#define BMI_DMA_ATTR_SWP_SHIFT                  FM_SP_DMA_ATTR_SWP_SHIFT
-#define BMI_DMA_ATTR_IC_CACHE_SHIFT             FM_SP_DMA_ATTR_IC_CACHE_SHIFT
-#define BMI_DMA_ATTR_HDR_CACHE_SHIFT            FM_SP_DMA_ATTR_HDR_CACHE_SHIFT
-#define BMI_DMA_ATTR_SG_CACHE_SHIFT             FM_SP_DMA_ATTR_SG_CACHE_SHIFT
+#define BMI_DMA_ATTR_SWP_SHIFT                  FMAN_SP_DMA_ATTR_SWP_SHIFT
+#define BMI_DMA_ATTR_IC_CACHE_SHIFT             FMAN_SP_DMA_ATTR_IC_CACHE_SHIFT
+#define BMI_DMA_ATTR_HDR_CACHE_SHIFT            FMAN_SP_DMA_ATTR_HDR_CACHE_SHIFT
+#define BMI_DMA_ATTR_SG_CACHE_SHIFT             FMAN_SP_DMA_ATTR_SG_CACHE_SHIFT
 
 #define BMI_IM_FOF_SHIFT                        28
 #define BMI_PR_PORTID_SHIFT                     24
@@ -562,15 +606,15 @@ typedef _Packed struct
 #define BMI_RX_FRAME_END_CS_IGNORE_SHIFT        24
 #define BMI_RX_FRAME_END_CUT_SHIFT              16
 
-#define BMI_IC_TO_EXT_SHIFT                     FM_SP_IC_TO_EXT_SHIFT
-#define BMI_IC_FROM_INT_SHIFT                   FM_SP_IC_FROM_INT_SHIFT
-#define BMI_IC_SIZE_SHIFT                       FM_SP_IC_SIZE_SHIFT
+#define BMI_IC_TO_EXT_SHIFT                     FMAN_SP_IC_TO_EXT_SHIFT
+#define BMI_IC_FROM_INT_SHIFT                   FMAN_SP_IC_FROM_INT_SHIFT
+#define BMI_IC_SIZE_SHIFT                       FMAN_SP_IC_SIZE_SHIFT
 
 #define BMI_INT_BUF_MARG_SHIFT                  28
 
-#define BMI_EXT_BUF_MARG_START_SHIFT            FM_SP_EXT_BUF_MARG_START_SHIFT
-#define BMI_SG_DISABLE                          FM_SP_SG_DISABLE
-#define BMI_EXT_BUF_MARG_END_SHIFT              FM_SP_EXT_BUF_MARG_END_SHIFT
+#define BMI_EXT_BUF_MARG_START_SHIFT            FMAN_SP_EXT_BUF_MARG_START_SHIFT
+#define BMI_SG_DISABLE                          FMAN_SP_SG_DISABLE
+#define BMI_EXT_BUF_MARG_END_SHIFT              FMAN_SP_EXT_BUF_MARG_END_SHIFT
 
 #define BMI_CMD_ATTR_COLOR_SHIFT                26
 #define BMI_CMD_ATTR_COM_MODE_SHIFT             16
@@ -579,10 +623,10 @@ typedef _Packed struct
 #define BMI_CMD_ATTR_MACCMD_SECURED_SHIFT       12
 #define BMI_CMD_ATTR_MACCMD_SC_SHIFT            8
 
-#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT         FM_SP_POOL_DEP_NUM_OF_POOLS_SHIFT
+#define BMI_POOL_DEP_NUM_OF_POOLS_SHIFT         FMAN_SP_POOL_DEP_NUM_OF_POOLS_SHIFT
 #define BMI_POOL_DEP_NUM_OF_POOLS_VECTOR_SHIFT  24
 
-#define BMI_EXT_BUF_POOL_ID_SHIFT               FM_SP_EXT_BUF_POOL_ID_SHIFT
+#define BMI_EXT_BUF_POOL_ID_SHIFT               FMAN_SP_EXT_BUF_POOL_ID_SHIFT
 #define BMI_TX_FIFO_MIN_FILL_SHIFT              16
 #define BMI_FIFO_PIPELINE_DEPTH_SHIFT           12
 #define BMI_TX_LOW_COMF_SHIFT                   0
@@ -874,6 +918,7 @@ typedef struct {
     uint32_t                    savedBmiFpne;
     uint32_t                    savedBmiCmne;
     uint32_t                    savedNonRxQmiRegsPndn;
+    uint32_t                    origNonRxQmiRegsPndn;
     int                         savedPrsStartOffset;
     bool                        includeInPrsStatistics;
     uint16_t                    maxFrameLength;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/Makefile
index b82bb6f..f804c51 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/Makefile
@@ -12,4 +12,4 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-RTC.o
 
-fsl-ncsw-RTC-objs	:=   fm_rtc.o
+fsl-ncsw-RTC-objs	:=   fm_rtc.o fman_rtc.o
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
index d65b1d4..d036fcd 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.c
@@ -50,38 +50,16 @@
 #include "fm_common.h"
 
 
-/*****************************************************************************/
-static void SetDefaultParam(t_FmRtc *p_Rtc)
-{
-    t_FmRtcDriverParam  *p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
-    int                 i;
-
-    p_Rtc->outputClockDivisor = DEFAULT_outputClockDivisor;
-    p_Rtc->p_RtcDriverParam->bypass = DEFAULT_bypass;
-    p_RtcDriverParam->srcClk = DEFAULT_srcClock;
-    p_RtcDriverParam->invertInputClkPhase = DEFAULT_invertInputClkPhase;
-    p_RtcDriverParam->invertOutputClkPhase = DEFAULT_invertOutputClkPhase;
-    p_RtcDriverParam->pulseRealign = DEFAULT_pulseRealign;
-    for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
-    {
-        p_RtcDriverParam->alarmPolarity[i] = DEFAULT_alarmPolarity;
-    }
-    for (i=0; i < FM_RTC_NUM_OF_EXT_TRIGGERS; i++)
-    {
-        p_RtcDriverParam->triggerPolarity[i] = DEFAULT_triggerPolarity;
-    }
-    p_Rtc->clockPeriodNanoSec = DEFAULT_clockPeriod; /* 1 usec */
-}
 
 /*****************************************************************************/
 static t_Error CheckInitParameters(t_FmRtc *p_Rtc)
 {
-    t_FmRtcDriverParam  *p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
+    struct rtc_cfg  *p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
     int                 i;
 
-    if ((p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_EXTERNAL) &&
-        (p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM) &&
-        (p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_OSCILATOR))
+    if ((p_RtcDriverParam->src_clk != E_FMAN_RTC_SOURCE_CLOCK_EXTERNAL) &&
+        (p_RtcDriverParam->src_clk != E_FMAN_RTC_SOURCE_CLOCK_SYSTEM) &&
+        (p_RtcDriverParam->src_clk != E_FMAN_RTC_SOURCE_CLOCK_OSCILATOR))
         RETURN_ERROR(MAJOR, E_INVALID_CLOCK, ("Source clock undefined"));
 
     if (p_Rtc->outputClockDivisor == 0)
@@ -92,16 +70,16 @@ static t_Error CheckInitParameters(t_FmRtc *p_Rtc)
 
     for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
     {
-        if ((p_RtcDriverParam->alarmPolarity[i] != e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW) &&
-            (p_RtcDriverParam->alarmPolarity[i] != e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH))
+        if ((p_RtcDriverParam->alarm_polarity[i] != E_FMAN_RTC_ALARM_POLARITY_ACTIVE_LOW) &&
+            (p_RtcDriverParam->alarm_polarity[i] != E_FMAN_RTC_ALARM_POLARITY_ACTIVE_HIGH))
         {
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm %d signal polarity", i));
         }
     }
     for (i=0; i < FM_RTC_NUM_OF_EXT_TRIGGERS; i++)
     {
-        if ((p_RtcDriverParam->triggerPolarity[i] != e_FM_RTC_TRIGGER_ON_FALLING_EDGE) &&
-            (p_RtcDriverParam->triggerPolarity[i] != e_FM_RTC_TRIGGER_ON_RISING_EDGE))
+        if ((p_RtcDriverParam->trigger_polarity[i] != E_FMAN_RTC_TRIGGER_ON_FALLING_EDGE) &&
+            (p_RtcDriverParam->trigger_polarity[i] != E_FMAN_RTC_TRIGGER_ON_RISING_EDGE))
         {
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Trigger %d signal polarity", i));
         }
@@ -114,55 +92,49 @@ static t_Error CheckInitParameters(t_FmRtc *p_Rtc)
 static void RtcExceptions(t_Handle h_FmRtc)
 {
     t_FmRtc             *p_Rtc = (t_FmRtc *)h_FmRtc;
-    t_FmRtcMemMap       *p_MemMap;
+    struct rtc_regs     *p_MemMap;
     register uint32_t   events;
 
     ASSERT_COND(p_Rtc);
     p_MemMap = p_Rtc->p_MemMap;
 
-    /* Get valid events */
-    events =  GET_UINT32(p_MemMap->tmr_tevent);
-    events &= GET_UINT32(p_MemMap->tmr_temask);
-
-    /* Clear event bits */
-    WRITE_UINT32(p_MemMap->tmr_tevent, events);
-
-    if (events & TMR_TEVENT_ALM1)
+    events = fman_rtc_check_and_clear_event(p_MemMap);
+    if (events & FMAN_RTC_TMR_TEVENT_ALM1)
     {
         if (p_Rtc->alarmParams[0].clearOnExpiration)
         {
-            WRITE_UINT32(p_MemMap->tmr_alarm[0].tmr_alarm_l, 0);
-            WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~TMR_TEVENT_ALM1);
+            fman_rtc_set_timer_alarm_l(p_MemMap, 0, 0);
+            fman_rtc_disable_interupt(p_MemMap, FMAN_RTC_TMR_TEVENT_ALM1);
         }
         ASSERT_COND(p_Rtc->alarmParams[0].f_AlarmCallback);
         p_Rtc->alarmParams[0].f_AlarmCallback(p_Rtc->h_App, 0);
     }
-    if (events & TMR_TEVENT_ALM2)
+    if (events & FMAN_RTC_TMR_TEVENT_ALM2)
     {
         if (p_Rtc->alarmParams[1].clearOnExpiration)
         {
-            WRITE_UINT32(p_MemMap->tmr_alarm[1].tmr_alarm_l, 0);
-            WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~TMR_TEVENT_ALM2);
+            fman_rtc_set_timer_alarm_l(p_MemMap, 1, 0);
+            fman_rtc_disable_interupt(p_MemMap, FMAN_RTC_TMR_TEVENT_ALM2);
         }
         ASSERT_COND(p_Rtc->alarmParams[1].f_AlarmCallback);
         p_Rtc->alarmParams[1].f_AlarmCallback(p_Rtc->h_App, 1);
     }
-    if (events & TMR_TEVENT_PP1)
+    if (events & FMAN_RTC_TMR_TEVENT_PP1)
     {
         ASSERT_COND(p_Rtc->periodicPulseParams[0].f_PeriodicPulseCallback);
         p_Rtc->periodicPulseParams[0].f_PeriodicPulseCallback(p_Rtc->h_App, 0);
     }
-    if (events & TMR_TEVENT_PP2)
+    if (events & FMAN_RTC_TMR_TEVENT_PP2)
     {
         ASSERT_COND(p_Rtc->periodicPulseParams[1].f_PeriodicPulseCallback);
         p_Rtc->periodicPulseParams[1].f_PeriodicPulseCallback(p_Rtc->h_App, 1);
     }
-    if (events & TMR_TEVENT_ETS1)
+    if (events & FMAN_RTC_TMR_TEVENT_ETS1)
     {
         ASSERT_COND(p_Rtc->externalTriggerParams[0].f_ExternalTriggerCallback);
         p_Rtc->externalTriggerParams[0].f_ExternalTriggerCallback(p_Rtc->h_App, 0);
     }
-    if (events & TMR_TEVENT_ETS2)
+    if (events & FMAN_RTC_TMR_TEVENT_ETS2)
     {
         ASSERT_COND(p_Rtc->externalTriggerParams[1].f_ExternalTriggerCallback);
         p_Rtc->externalTriggerParams[1].f_ExternalTriggerCallback(p_Rtc->h_App, 1);
@@ -188,7 +160,7 @@ t_Handle FM_RTC_Config(t_FmRtcParams *p_FmRtcParam)
     memset(p_Rtc, 0, sizeof(t_FmRtc));
 
     /* Allocate memory for the FM RTC driver parameters */
-    p_Rtc->p_RtcDriverParam = (t_FmRtcDriverParam *)XX_Malloc(sizeof(t_FmRtcDriverParam));
+    p_Rtc->p_RtcDriverParam = (struct rtc_cfg *)XX_Malloc(sizeof(struct rtc_cfg));
     if (!p_Rtc->p_RtcDriverParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM RTC driver parameters"));
@@ -196,16 +168,21 @@ t_Handle FM_RTC_Config(t_FmRtcParams *p_FmRtcParam)
         return NULL;
     }
 
-    memset(p_Rtc->p_RtcDriverParam, 0, sizeof(t_FmRtcDriverParam));
+    memset(p_Rtc->p_RtcDriverParam, 0, sizeof(struct rtc_cfg));
 
     /* Store RTC configuration parameters */
     p_Rtc->h_Fm = p_FmRtcParam->h_Fm;
 
     /* Set default RTC configuration parameters */
-    SetDefaultParam(p_Rtc);
+    fman_rtc_defconfig(p_Rtc->p_RtcDriverParam);
+
+    p_Rtc->outputClockDivisor = DEFAULT_OUTPUT_CLOCK_DIVISOR;
+    p_Rtc->p_RtcDriverParam->bypass = DEFAULT_BYPASS;
+    p_Rtc->clockPeriodNanoSec = DEFAULT_CLOCK_PERIOD; /* 1 usec */
+
 
     /* Store RTC parameters in the RTC control structure */
-    p_Rtc->p_MemMap = (t_FmRtcMemMap *)UINT_TO_PTR(p_FmRtcParam->baseAddress);
+    p_Rtc->p_MemMap = (struct rtc_regs *)UINT_TO_PTR(p_FmRtcParam->baseAddress);
     p_Rtc->h_App    = p_FmRtcParam->h_App;
 
     return p_Rtc;
@@ -215,12 +192,11 @@ t_Handle FM_RTC_Config(t_FmRtcParams *p_FmRtcParam)
 t_Error FM_RTC_Init(t_Handle h_FmRtc)
 {
     t_FmRtc             *p_Rtc = (t_FmRtc *)h_FmRtc;
-    t_FmRtcDriverParam  *p_RtcDriverParam;
-    t_FmRtcMemMap       *p_MemMap;
-    uint32_t            freqCompensation;
-    uint32_t            tmrCtrl;
-    int                 i;
+    struct rtc_cfg      *p_RtcDriverParam;
+    struct rtc_regs     *p_MemMap;
+    uint32_t            freqCompensation = 0;
     uint64_t            tmpDouble;
+    bool                init_freq_comp = FALSE;
 
     p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
     p_MemMap = p_Rtc->p_MemMap;
@@ -230,85 +206,28 @@ t_Error FM_RTC_Init(t_Handle h_FmRtc)
                      ("Init Parameters are not Valid"));
 
     /* TODO check that no timestamping MACs are working in this stage. */
-    WRITE_UINT32(p_MemMap->tmr_ctrl, TMR_CTRL_TMSR);
-    XX_UDelay(10);
-    WRITE_UINT32(p_MemMap->tmr_ctrl, 0);
-
-    /* Set the source clock */
-    switch (p_RtcDriverParam->srcClk)
-    {
-        case e_FM_RTC_SOURCE_CLOCK_SYSTEM:
-            tmrCtrl = TMR_CTRL_CKSEL_MAC_CLK;
-            break;
-        case e_FM_RTC_SOURCE_CLOCK_OSCILATOR:
-            tmrCtrl = TMR_CTRL_CKSEL_OSC_CLK;
-            break;
-        default:
-            /* Use a clock from the External TMR reference clock.*/
-            tmrCtrl = TMR_CTRL_CKSEL_EXT_CLK;
-            break;
-    }
-
-    /* whatever period the user picked, the timestamp will advance in '1' every time
-     * the period passed. */
-    tmrCtrl |= ((1 << TMR_CTRL_TCLK_PERIOD_SHIFT) & TMR_CTRL_TCLK_PERIOD_MASK);
-
-    if (p_RtcDriverParam->invertInputClkPhase)
-        tmrCtrl |= TMR_CTRL_CIPH;
-    if (p_RtcDriverParam->invertOutputClkPhase)
-        tmrCtrl |= TMR_CTRL_COPH;
-
-    for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
-    {
-        if (p_RtcDriverParam->alarmPolarity[i] == e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW)
-            tmrCtrl |= (TMR_CTRL_ALMP1 >> i);
-    }
-
-    for (i=0; i < FM_RTC_NUM_OF_EXT_TRIGGERS; i++)
-        if (p_RtcDriverParam->triggerPolarity[i] == e_FM_RTC_TRIGGER_ON_FALLING_EDGE)
-            tmrCtrl |= (TMR_CTRL_ETEP1 << i);
-
-    if (!p_RtcDriverParam->timerSlaveMode && p_Rtc->p_RtcDriverParam->bypass)
-        tmrCtrl |= TMR_CTRL_BYP;
-
-    WRITE_UINT32(p_MemMap->tmr_ctrl, tmrCtrl);
-
-     for (i=0; i < FM_RTC_NUM_OF_ALARMS; i++)
-    {
-        /* Clear TMR_ALARM registers */
-        WRITE_UINT32(p_MemMap->tmr_alarm[i].tmr_alarm_l, 0xFFFFFFFF);
-        WRITE_UINT32(p_MemMap->tmr_alarm[i].tmr_alarm_h, 0xFFFFFFFF);
-    }
-
-    /* Clear TMR_TEVENT */
-    WRITE_UINT32(p_MemMap->tmr_tevent, TMR_TEVENT_ALL);
-
-    /* Initialize TMR_TEMASK */
-    WRITE_UINT32(p_MemMap->tmr_temask, 0);
-
 
     /* find source clock frequency in Mhz */
-    if (p_Rtc->p_RtcDriverParam->srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM)
-         p_Rtc->srcClkFreqMhz = p_Rtc->p_RtcDriverParam->extSrcClkFreq;
+    if (p_Rtc->p_RtcDriverParam->src_clk != E_FMAN_RTC_SOURCE_CLOCK_SYSTEM)
+         p_Rtc->srcClkFreqMhz = p_Rtc->p_RtcDriverParam->ext_src_clk_freq;
     else
         p_Rtc->srcClkFreqMhz = (uint32_t)(FmGetClockFreq(p_Rtc->h_Fm)/2);
 
     /* if timer in Master mode Initialize TMR_CTRL */
     /* We want the counter (TMR_CNT) to count in nano-seconds */
-    if (!p_RtcDriverParam->timerSlaveMode && p_Rtc->p_RtcDriverParam->bypass)
-    {
+    if (!p_RtcDriverParam->timer_slave_mode && p_Rtc->p_RtcDriverParam->bypass)
         p_Rtc->clockPeriodNanoSec = (1000 / p_Rtc->srcClkFreqMhz);
-    }
     else
     {
         /* Initialize TMR_ADD with the initial frequency compensation value:
            freqCompensation = (2^32 / frequency ratio) */
         /* frequency ratio = sorce clock/rtc clock =
          * (p_Rtc->srcClkFreqMhz*1000000))/ 1/(p_Rtc->clockPeriodNanoSec * 1000000000) */
+        init_freq_comp = TRUE;
         freqCompensation = (uint32_t)DIV_CEIL(ACCUMULATOR_OVERFLOW * 1000,
-                                    p_Rtc->clockPeriodNanoSec * p_Rtc->srcClkFreqMhz);
-        WRITE_UINT32(p_MemMap->tmr_add, freqCompensation);
+                                              p_Rtc->clockPeriodNanoSec * p_Rtc->srcClkFreqMhz);
     }
+
     /* check the legality of the relation between source and destination clocks */
     /* should be larger than 1.0001 */
     tmpDouble = 10000 * (uint64_t)p_Rtc->clockPeriodNanoSec * (uint64_t)p_Rtc->srcClkFreqMhz;
@@ -316,17 +235,14 @@ t_Error FM_RTC_Init(t_Handle h_FmRtc)
         RETURN_ERROR(MAJOR, E_CONFLICT,
               ("Invalid relation between source and destination clocks. Should be larger than 1.0001"));
 
-
-    for (i=0; i < 2; i++)
-        /* Clear TMR_FIPER registers */
-        WRITE_UINT32(p_MemMap->tmr_fiper[i], 0xFFFFFFFF);
-
-    /* Initialize TMR_PRSC */
-    WRITE_UINT32(p_MemMap->tmr_prsc, p_Rtc->outputClockDivisor);
-
-    /* Clear TMR_OFF */
-    WRITE_UINT32(p_MemMap->tmr_off_l, 0);
-    WRITE_UINT32(p_MemMap->tmr_off_h, 0);
+    fman_rtc_init(p_RtcDriverParam,
+             p_MemMap,
+             FM_RTC_NUM_OF_ALARMS,
+             FM_RTC_NUM_OF_PERIODIC_PULSES,
+             FM_RTC_NUM_OF_EXT_TRIGGERS,
+             init_freq_comp,
+             freqCompensation,
+             p_Rtc->outputClockDivisor);
 
     /* Register the FM RTC interrupt */
     FmRegisterIntr(p_Rtc->h_Fm, e_FM_MOD_TMR, 0, e_FM_INTR_TYPE_NORMAL, RtcExceptions , p_Rtc);
@@ -371,9 +287,9 @@ t_Error FM_RTC_ConfigSourceClock(t_Handle         h_FmRtc,
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    p_Rtc->p_RtcDriverParam->srcClk = srcClk;
+    p_Rtc->p_RtcDriverParam->src_clk = (enum fman_src_clock)srcClk;
     if (srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM)
-        p_Rtc->p_RtcDriverParam->extSrcClkFreq = freqInMhz;
+        p_Rtc->p_RtcDriverParam->ext_src_clk_freq = freqInMhz;
 
     return E_OK;
 }
@@ -412,7 +328,7 @@ t_Error FM_RTC_ConfigInvertedInputClockPhase(t_Handle h_FmRtc, bool inverted)
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    p_Rtc->p_RtcDriverParam->invertInputClkPhase = inverted;
+    p_Rtc->p_RtcDriverParam->invert_input_clk_phase = inverted;
 
     return E_OK;
 }
@@ -425,7 +341,7 @@ t_Error FM_RTC_ConfigInvertedOutputClockPhase(t_Handle h_FmRtc, bool inverted)
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    p_Rtc->p_RtcDriverParam->invertOutputClkPhase = inverted;
+    p_Rtc->p_RtcDriverParam->invert_output_clk_phase = inverted;
 
     return E_OK;
 }
@@ -451,7 +367,7 @@ t_Error FM_RTC_ConfigPulseRealignment(t_Handle h_FmRtc, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    p_Rtc->p_RtcDriverParam->pulseRealign = enable;
+    p_Rtc->p_RtcDriverParam->pulse_realign = enable;
 
     return E_OK;
 }
@@ -467,11 +383,10 @@ t_Error FM_RTC_ConfigAlarmPolarity(t_Handle             h_FmRtc,
     SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
     if (alarmId >= FM_RTC_NUM_OF_ALARMS)
-    {
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm ID"));
-    }
 
-    p_Rtc->p_RtcDriverParam->alarmPolarity[alarmId] = alarmPolarity;
+    p_Rtc->p_RtcDriverParam->alarm_polarity[alarmId] =
+        (enum fman_rtc_alarm_polarity)alarmPolarity;
 
     return E_OK;
 }
@@ -491,7 +406,8 @@ t_Error FM_RTC_ConfigExternalTriggerPolarity(t_Handle               h_FmRtc,
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External trigger ID"));
     }
 
-    p_Rtc->p_RtcDriverParam->triggerPolarity[triggerId] = triggerPolarity;
+    p_Rtc->p_RtcDriverParam->trigger_polarity[triggerId] =
+        (enum fman_rtc_trigger_polarity)triggerPolarity;
 
     return E_OK;
 }
@@ -500,26 +416,11 @@ t_Error FM_RTC_ConfigExternalTriggerPolarity(t_Handle               h_FmRtc,
 t_Error FM_RTC_Enable(t_Handle h_FmRtc, bool resetClock)
 {
     t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
-    uint32_t        tmrCtrl;
 
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    tmrCtrl = GET_UINT32(p_Rtc->p_MemMap->tmr_ctrl);
-
-    /* TODO check that no timestamping MACs are working in this stage. */
-    if (resetClock)
-    {
-        WRITE_UINT32(p_Rtc->p_MemMap->tmr_ctrl, (tmrCtrl | TMR_CTRL_TMSR));
-
-        XX_UDelay(10);
-        /* Clear TMR_OFF */
-        WRITE_UINT32(p_Rtc->p_MemMap->tmr_off_l, 0);
-        WRITE_UINT32(p_Rtc->p_MemMap->tmr_off_h, 0);
-    }
-
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_ctrl, (tmrCtrl | TMR_CTRL_TE));
-
+    fman_rtc_enable(p_Rtc->p_MemMap, resetClock);
     return E_OK;
 }
 
@@ -527,15 +428,13 @@ t_Error FM_RTC_Enable(t_Handle h_FmRtc, bool resetClock)
 t_Error FM_RTC_Disable(t_Handle h_FmRtc)
 {
     t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
-    uint32_t        tmrCtrl;
 
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
     /* TODO A check must be added here, that no timestamping MAC's
      * are working in this stage. */
-    tmrCtrl = GET_UINT32(p_Rtc->p_MemMap->tmr_ctrl);
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_ctrl, (tmrCtrl & ~(TMR_CTRL_TE)));
+    fman_rtc_disable(p_Rtc->p_MemMap);
 
     return E_OK;
 }
@@ -548,10 +447,7 @@ t_Error FM_RTC_SetClockOffset(t_Handle h_FmRtc, int64_t offset)
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    /* TMR_OFF_L must be written first */
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_off_l, (uint32_t)offset);
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_off_h, (uint32_t)(offset >> 32));
-
+    fman_rtc_set_timer_offset(p_Rtc->p_MemMap, offset);
     return E_OK;
 }
 
@@ -559,15 +455,12 @@ t_Error FM_RTC_SetClockOffset(t_Handle h_FmRtc, int64_t offset)
 t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams)
 {
     t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
-    t_FmRtcMemMap   *p_MemMap;
-    uint32_t        tmpReg;
     uint64_t        tmpAlarm;
+    bool            enable = FALSE;
 
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    p_MemMap = p_Rtc->p_MemMap;
-
     if (p_FmRtcAlarmParams->alarmId >= FM_RTC_NUM_OF_ALARMS)
     {
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm ID"));
@@ -579,23 +472,15 @@ t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm time must be a multiple of RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
     tmpAlarm = p_FmRtcAlarmParams->alarmTime/(uint64_t)p_Rtc->clockPeriodNanoSec;
 
-    /* TMR_ALARM_L must be written first */
-    WRITE_UINT32(p_MemMap->tmr_alarm[p_FmRtcAlarmParams->alarmId].tmr_alarm_l, (uint32_t)tmpAlarm);
-    WRITE_UINT32(p_MemMap->tmr_alarm[p_FmRtcAlarmParams->alarmId].tmr_alarm_h,
-                 (uint32_t)(tmpAlarm >> 32));
-
     if (p_FmRtcAlarmParams->f_AlarmCallback)
     {
         p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].f_AlarmCallback = p_FmRtcAlarmParams->f_AlarmCallback;
         p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].clearOnExpiration = p_FmRtcAlarmParams->clearOnExpiration;
-
-        if (p_FmRtcAlarmParams->alarmId == 0)
-            tmpReg = TMR_TEVENT_ALM1;
-        else
-            tmpReg = TMR_TEVENT_ALM2;
-        WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) | tmpReg);
+        enable = TRUE;
     }
 
+    fman_rtc_set_alarm(p_Rtc->p_MemMap, p_FmRtcAlarmParams->alarmId, (unsigned long)tmpAlarm, enable);
+
     return E_OK;
 }
 
@@ -603,20 +488,17 @@ t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams
 t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_FmRtcPeriodicPulseParams)
 {
     t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
-    t_FmRtcMemMap   *p_MemMap;
-    uint32_t        tmpReg;
+    bool            enable = FALSE;
     uint64_t        tmpFiper;
 
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    p_MemMap = p_Rtc->p_MemMap;
-
     if (p_FmRtcPeriodicPulseParams->periodicPulseId >= FM_RTC_NUM_OF_PERIODIC_PULSES)
     {
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse ID"));
     }
-    if (GET_UINT32(p_MemMap->tmr_ctrl) & TMR_CTRL_TE)
+    if (fman_rtc_is_enabled(p_Rtc->p_MemMap))
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Can't set Periodic pulse when RTC is enabled."));
     if (p_FmRtcPeriodicPulseParams->periodicPulsePeriod < p_Rtc->clockPeriodNanoSec)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse must be equal or larger than RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
@@ -626,20 +508,13 @@ t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_
     if (tmpFiper & 0xffffffff00000000LL)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse/RTC Period must be smaller than 4294967296", p_Rtc->clockPeriodNanoSec));
 
-    WRITE_UINT32(p_MemMap->tmr_fiper[p_FmRtcPeriodicPulseParams->periodicPulseId], (uint32_t)tmpFiper);
-
     if (p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback)
     {
         p_Rtc->periodicPulseParams[p_FmRtcPeriodicPulseParams->periodicPulseId].f_PeriodicPulseCallback =
                                                                 p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback;
-
-        if (p_FmRtcPeriodicPulseParams->periodicPulseId == 0)
-            tmpReg = TMR_TEVENT_PP1;
-        else
-            tmpReg = TMR_TEVENT_PP2;
-        WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) | tmpReg);
+        enable = TRUE;
     }
-
+    fman_rtc_set_periodic_pulse(p_Rtc->p_MemMap, p_FmRtcPeriodicPulseParams->periodicPulseId, (uint32_t)tmpFiper, enable);
     return E_OK;
 }
 
@@ -647,7 +522,6 @@ t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_
 t_Error FM_RTC_ClearPeriodicPulse(t_Handle h_FmRtc, uint8_t periodicPulseId)
 {
     t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
-    uint32_t    tmpReg;
 
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
@@ -658,17 +532,7 @@ t_Error FM_RTC_ClearPeriodicPulse(t_Handle h_FmRtc, uint8_t periodicPulseId)
     }
 
     p_Rtc->periodicPulseParams[periodicPulseId].f_PeriodicPulseCallback = NULL;
-
-    if (periodicPulseId == 0)
-        tmpReg = TMR_TEVENT_PP1;
-    else
-        tmpReg = TMR_TEVENT_PP2;
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_temask, GET_UINT32(p_Rtc->p_MemMap->tmr_temask) & ~tmpReg);
-
-    if (GET_UINT32(p_Rtc->p_MemMap->tmr_ctrl) & TMR_CTRL_FS)
-        WRITE_UINT32(p_Rtc->p_MemMap->tmr_ctrl, GET_UINT32(p_Rtc->p_MemMap->tmr_ctrl) & ~TMR_CTRL_FS);
-
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_fiper[periodicPulseId], 0xFFFFFFFF);
+    fman_rtc_clear_periodic_pulse(p_Rtc->p_MemMap, periodicPulseId);
 
     return E_OK;
 }
@@ -677,7 +541,7 @@ t_Error FM_RTC_ClearPeriodicPulse(t_Handle h_FmRtc, uint8_t periodicPulseId)
 t_Error FM_RTC_SetExternalTrigger(t_Handle h_FmRtc, t_FmRtcExternalTriggerParams *p_FmRtcExternalTriggerParams)
 {
     t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
-    uint32_t    tmpReg;
+    bool        enable = FALSE;
 
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
@@ -690,22 +554,10 @@ t_Error FM_RTC_SetExternalTrigger(t_Handle h_FmRtc, t_FmRtcExternalTriggerParams
     if (p_FmRtcExternalTriggerParams->f_ExternalTriggerCallback)
     {
         p_Rtc->externalTriggerParams[p_FmRtcExternalTriggerParams->externalTriggerId].f_ExternalTriggerCallback = p_FmRtcExternalTriggerParams->f_ExternalTriggerCallback;
-        if (p_FmRtcExternalTriggerParams->externalTriggerId == 0)
-            tmpReg = TMR_TEVENT_ETS1;
-        else
-            tmpReg = TMR_TEVENT_ETS2;
-        WRITE_UINT32(p_Rtc->p_MemMap->tmr_temask, GET_UINT32(p_Rtc->p_MemMap->tmr_temask) | tmpReg);
-    }
-
-    if (p_FmRtcExternalTriggerParams->usePulseAsInput)
-    {
-        if (p_FmRtcExternalTriggerParams->externalTriggerId == 0)
-            tmpReg = TMR_CTRL_PP1L;
-        else
-            tmpReg = TMR_CTRL_PP2L;
-        WRITE_UINT32(p_Rtc->p_MemMap->tmr_ctrl, GET_UINT32(p_Rtc->p_MemMap->tmr_ctrl) | tmpReg);
+        enable = TRUE;
     }
 
+    fman_rtc_set_ext_trigger(p_Rtc->p_MemMap, p_FmRtcExternalTriggerParams->externalTriggerId, enable, p_FmRtcExternalTriggerParams->usePulseAsInput);
     return E_OK;
 }
 
@@ -713,7 +565,6 @@ t_Error FM_RTC_SetExternalTrigger(t_Handle h_FmRtc, t_FmRtcExternalTriggerParams
 t_Error FM_RTC_ClearExternalTrigger(t_Handle h_FmRtc, uint8_t externalTriggerId)
 {
     t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
-    uint32_t    tmpReg;
 
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
@@ -723,19 +574,7 @@ t_Error FM_RTC_ClearExternalTrigger(t_Handle h_FmRtc, uint8_t externalTriggerId)
 
     p_Rtc->externalTriggerParams[externalTriggerId].f_ExternalTriggerCallback = NULL;
 
-    if (externalTriggerId == 0)
-        tmpReg = TMR_TEVENT_ETS1;
-    else
-        tmpReg = TMR_TEVENT_ETS2;
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_temask, GET_UINT32(p_Rtc->p_MemMap->tmr_temask) & ~tmpReg);
-
-    if (externalTriggerId == 0)
-        tmpReg = TMR_CTRL_PP1L;
-    else
-        tmpReg = TMR_CTRL_PP2L;
-
-    if (GET_UINT32(p_Rtc->p_MemMap->tmr_ctrl) & tmpReg)
-        WRITE_UINT32(p_Rtc->p_MemMap->tmr_ctrl, GET_UINT32(p_Rtc->p_MemMap->tmr_ctrl) & ~tmpReg);
+    fman_rtc_clear_external_trigger(p_Rtc->p_MemMap, externalTriggerId);
 
     return E_OK;
 }
@@ -746,21 +585,14 @@ t_Error FM_RTC_GetExternalTriggerTimeStamp(t_Handle             h_FmRtc,
                                               uint64_t          *p_TimeStamp)
 {
     t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
-    uint64_t    timeStamp;
 
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
     if (triggerId >= FM_RTC_NUM_OF_EXT_TRIGGERS)
-    {
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("External trigger ID"));
-    }
-
-    timeStamp = (uint64_t)GET_UINT32(p_Rtc->p_MemMap->tmr_etts[triggerId].tmr_etts_l);
-    timeStamp |= ((uint64_t)GET_UINT32(p_Rtc->p_MemMap->tmr_etts[triggerId].tmr_etts_h) << 32);
 
-    timeStamp = timeStamp*p_Rtc->clockPeriodNanoSec;
-    *p_TimeStamp = timeStamp;
+    *p_TimeStamp = fman_rtc_get_trigger_stamp(p_Rtc->p_MemMap, triggerId)*p_Rtc->clockPeriodNanoSec;
 
     return E_OK;
 }
@@ -769,18 +601,11 @@ t_Error FM_RTC_GetExternalTriggerTimeStamp(t_Handle             h_FmRtc,
 t_Error FM_RTC_GetCurrentTime(t_Handle h_FmRtc, uint64_t *p_Ts)
 {
     t_FmRtc     *p_Rtc = (t_FmRtc *)h_FmRtc;
-    uint64_t    time;
 
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    /* TMR_CNT_L must be read first to get an accurate value */
-    time = (uint64_t)GET_UINT32(p_Rtc->p_MemMap->tmr_cnt_l);
-    time |= ((uint64_t)GET_UINT32(p_Rtc->p_MemMap->tmr_cnt_h) << 32);
-
-    time = time*p_Rtc->clockPeriodNanoSec;
-
-    *p_Ts = time;
+    *p_Ts = fman_rtc_get_timer(p_Rtc->p_MemMap)*p_Rtc->clockPeriodNanoSec;
 
     return E_OK;
 }
@@ -794,9 +619,7 @@ t_Error FM_RTC_SetCurrentTime(t_Handle h_FmRtc, uint64_t ts)
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
     ts = ts/p_Rtc->clockPeriodNanoSec;
-    /* TMR_CNT_L must be written first to get an accurate value */
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_cnt_l, (uint32_t)ts);
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_cnt_h, (uint32_t)(ts >> 32));
+    fman_rtc_set_timer(p_Rtc->p_MemMap, (unsigned long)ts);
 
     return E_OK;
 }
@@ -809,7 +632,7 @@ t_Error FM_RTC_GetFreqCompensation(t_Handle h_FmRtc, uint32_t *p_Compensation)
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    *p_Compensation = GET_UINT32(p_Rtc->p_MemMap->tmr_add);
+    *p_Compensation = fman_rtc_get_frequency_compensation(p_Rtc->p_MemMap);
 
     return E_OK;
 }
@@ -823,7 +646,7 @@ t_Error FM_RTC_SetFreqCompensation(t_Handle h_FmRtc, uint32_t freqCompensation)
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
     /* set the new freqCompensation */
-    WRITE_UINT32(p_Rtc->p_MemMap->tmr_add, freqCompensation);
+    fman_rtc_set_frequency_compensation(p_Rtc->p_MemMap, freqCompensation);
 
     return E_OK;
 }
@@ -833,7 +656,7 @@ t_Error FM_RTC_SetFreqCompensation(t_Handle h_FmRtc, uint32_t freqCompensation)
 t_Error FM_RTC_DumpRegs(t_Handle h_FmRtc)
 {
     t_FmRtc         *p_Rtc = (t_FmRtc *)h_FmRtc;
-    t_FmRtcMemMap   *p_MemMap = p_Rtc->p_MemMap;
+    struct rtc_regs   *p_MemMap = p_Rtc->p_MemMap;
     int             i = 0;
 
     DECLARE_DUMP;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.h
index 4c1a422..843ca00 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fm_rtc.h
@@ -50,132 +50,12 @@
 
 /* General definitions */
 
-#define NANOSEC_PER_ONE_HZ_TICK         1000000000
-#define MIN_RTC_CLK_FREQ_HZ             1000
-#define MHz                             1000000
-
 #define ACCUMULATOR_OVERFLOW            ((uint64_t)(1LL << 32))
-
-/* RTC default values */
-#define DEFAULT_srcClock                e_FM_RTC_SOURCE_CLOCK_SYSTEM
-#define DEFAULT_bypass      FALSE
-#define DEFAULT_invertInputClkPhase     FALSE
-#define DEFAULT_invertOutputClkPhase    FALSE
-#define DEFAULT_outputClockDivisor      0x00000002
-#define DEFAULT_alarmPolarity           e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH
-#define DEFAULT_triggerPolarity         e_FM_RTC_TRIGGER_ON_FALLING_EDGE
-#define DEFAULT_pulseRealign            FALSE
-#define DEFAULT_clockPeriod             1000
-
-/* FM RTC Registers definitions */
-#define TMR_CTRL_ALMP1                  0x80000000
-#define TMR_CTRL_ALMP2                  0x40000000
-#define TMR_CTRL_FS                     0x10000000
-#define TMR_CTRL_PP1L                   0x08000000
-#define TMR_CTRL_PP2L                   0x04000000
-#define TMR_CTRL_TCLK_PERIOD_MASK       0x03FF0000
-#define TMR_CTRL_FRD                    0x00004000
-#define TMR_CTRL_SLV                    0x00002000
-#define TMR_CTRL_ETEP1                  0x00000100
-#define TMR_CTRL_COPH                   0x00000080
-#define TMR_CTRL_CIPH                   0x00000040
-#define TMR_CTRL_TMSR                   0x00000020
-#define TMR_CTRL_DBG                    0x00000010
-#define TMR_CTRL_BYP                    0x00000008
-#define TMR_CTRL_TE                     0x00000004
-#define TMR_CTRL_CKSEL_OSC_CLK          0x00000003
-#define TMR_CTRL_CKSEL_MAC_CLK          0x00000001
-#define TMR_CTRL_CKSEL_EXT_CLK          0x00000000
-#define TMR_CTRL_TCLK_PERIOD_SHIFT      16
-
-#define TMR_TEVENT_ETS2                 0x02000000
-#define TMR_TEVENT_ETS1                 0x01000000
-#define TMR_TEVENT_ALM2                 0x00020000
-#define TMR_TEVENT_ALM1                 0x00010000
-#define TMR_TEVENT_PP1                  0x00000080
-#define TMR_TEVENT_PP2                  0x00000040
-#define TMR_TEVENT_PP3                  0x00000020
-#define TMR_TEVENT_ALL                  (TMR_TEVENT_ETS2 | TMR_TEVENT_ETS1 | \
-                                         TMR_TEVENT_ALM2 | TMR_TEVENT_ALM1 | \
-                                         TMR_TEVENT_PP1 | TMR_TEVENT_PP2 | TMR_TEVENT_PP3)
-
-#define TMR_PRSC_OCK_MASK               0x0000FFFF
-
-
-/**************************************************************************//**
- @Description       Memory Mapped Registers
-*//***************************************************************************/
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-
-/**************************************************************************//**
- @Description FM RTC timer alarm
-*//***************************************************************************/
-typedef _Packed struct t_TmrAlaram
-{
-    volatile uint32_t   tmr_alarm_h;    /**<  */
-    volatile uint32_t   tmr_alarm_l;    /**<  */
-} _PackedType t_TmrAlaram;
-
-/**************************************************************************//**
- @Description FM RTC timer Ex trigger
-*//***************************************************************************/
-typedef _Packed struct t_TmrExtTrigger
-{
-    volatile uint32_t   tmr_etts_h;     /**<  */
-    volatile uint32_t   tmr_etts_l;     /**<  */
-} _PackedType t_TmrExtTrigger;
-
-typedef _Packed struct
-{
-    volatile uint32_t tmr_id;      /* Module ID and version register */
-    volatile uint32_t tmr_id2;     /* Module ID and configuration register */
-    volatile uint32_t PTP_RESERVED1[30];
-    volatile uint32_t tmr_ctrl;    /* timer control register */
-    volatile uint32_t tmr_tevent;  /* timer event register */
-    volatile uint32_t tmr_temask;  /* timer event mask register */
-    volatile uint32_t PTP_RESERVED2[3];
-    volatile uint32_t tmr_cnt_h;   /* timer counter high register */
-    volatile uint32_t tmr_cnt_l;   /* timer counter low register */
-    volatile uint32_t tmr_add;     /* timer drift compensation addend register */
-    volatile uint32_t tmr_acc;     /* timer accumulator register */
-    volatile uint32_t tmr_prsc;    /* timer prescale */
-    volatile uint32_t PTP_RESERVED3;
-    volatile uint32_t tmr_off_h;    /* timer offset high */
-    volatile uint32_t tmr_off_l;    /* timer offset low  */
-    volatile t_TmrAlaram tmr_alarm[FM_RTC_NUM_OF_ALARMS]; /* timer alarm */
-    volatile uint32_t PTP_RESERVED4[2];
-    volatile uint32_t tmr_fiper[FM_RTC_NUM_OF_PERIODIC_PULSES]; /* timer fixed period interval */
-    volatile uint32_t PTP_RESERVED5[2];
-    volatile t_TmrExtTrigger tmr_etts[FM_RTC_NUM_OF_EXT_TRIGGERS]; /*time stamp general purpose external */
-    volatile uint32_t PTP_RESERVED6[3];
-} _PackedType t_FmRtcMemMap;
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
+#define DEFAULT_OUTPUT_CLOCK_DIVISOR     0x00000002
+#define DEFAULT_BYPASS      			 FALSE
+#define DEFAULT_CLOCK_PERIOD             1000
 
 
-/**************************************************************************//**
- @Description   RTC FM driver parameters structure.
-*//***************************************************************************/
-typedef struct t_FmRtcDriverParam
-{
-    t_Handle                h_Fm;                   /**<  */
-    e_FmSrcClk              srcClk;               /**<  */
-    uint32_t                extSrcClkFreq;         /**<  */
-    uint32_t                rtcFreqHz;              /**<  */
-    bool                    timerSlaveMode;         /*Slave/Master Mode*/
-    bool                    invertInputClkPhase;
-    bool                    invertOutputClkPhase;
-    uint32_t                eventsMask;
-    bool                    bypass; /**< Indicates if frequency compensation is bypassed */
-    bool                    pulseRealign;
-    e_FmRtcAlarmPolarity    alarmPolarity[FM_RTC_NUM_OF_ALARMS];
-    e_FmRtcTriggerPolarity  triggerPolarity[FM_RTC_NUM_OF_EXT_TRIGGERS];
-} t_FmRtcDriverParam;
 
 typedef struct t_FmRtcAlarm
 {
@@ -202,14 +82,14 @@ typedef struct t_FmRtc
     t_Part                  *p_Part;            /**< Pointer to the integration device              */
     t_Handle                h_Fm;
     t_Handle                h_App;              /**< Application handle */
-    t_FmRtcMemMap           *p_MemMap;          /**< Pointer to RTC memory map */
+    struct rtc_regs			*p_MemMap;
     uint32_t                clockPeriodNanoSec; /**< RTC clock period in nano-seconds (for FS mode) */
     uint32_t                srcClkFreqMhz;
     uint16_t                outputClockDivisor; /**< Output clock divisor (for FS mode) */
     t_FmRtcAlarm            alarmParams[FM_RTC_NUM_OF_ALARMS];
     t_FmRtcPeriodicPulse    periodicPulseParams[FM_RTC_NUM_OF_PERIODIC_PULSES];
     t_FmRtcExternalTrigger  externalTriggerParams[FM_RTC_NUM_OF_EXT_TRIGGERS];
-    t_FmRtcDriverParam      *p_RtcDriverParam;  /**< RTC Driver parameters (for Init phase) */
+    struct rtc_cfg 			*p_RtcDriverParam;  /**< RTC Driver parameters (for Init phase) */
 } t_FmRtc;
 
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fman_rtc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fman_rtc.c
new file mode 100755
index 0000000..acdf507
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Rtc/fman_rtc.c
@@ -0,0 +1,334 @@
+/*
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fsl_fman_rtc.h"
+
+void fman_rtc_defconfig(struct rtc_cfg *cfg)
+{
+	int i;
+	cfg->src_clk = DEFAULT_SRC_CLOCK;
+	cfg->invert_input_clk_phase = DEFAULT_INVERT_INPUT_CLK_PHASE;
+	cfg->invert_output_clk_phase = DEFAULT_INVERT_OUTPUT_CLK_PHASE;
+	cfg->pulse_realign = DEFAULT_PULSE_REALIGN;
+	for (i = 0; i < FMAN_RTC_MAX_NUM_OF_ALARMS; i++)
+		cfg->alarm_polarity[i] = DEFAULT_ALARM_POLARITY;
+	for (i = 0; i < FMAN_RTC_MAX_NUM_OF_EXT_TRIGGERS; i++)
+		cfg->trigger_polarity[i] = DEFAULT_TRIGGER_POLARITY;
+}
+
+uint32_t fman_rtc_get_events(struct rtc_regs *regs)
+{
+	return ioread32be(&regs->tmr_tevent);
+}
+
+uint32_t fman_rtc_get_event(struct rtc_regs *regs, uint32_t ev_mask)
+{
+	return ioread32be(&regs->tmr_tevent) & ev_mask;
+}
+
+uint32_t fman_rtc_get_interrupt_mask(struct rtc_regs *regs)
+{
+	return ioread32be(&regs->tmr_temask);
+}
+
+void fman_rtc_set_interrupt_mask(struct rtc_regs *regs, uint32_t mask)
+{
+	iowrite32be(mask, &regs->tmr_temask);
+}
+
+void fman_rtc_ack_event(struct rtc_regs *regs, uint32_t events)
+{
+	iowrite32be(events, &regs->tmr_tevent);
+}
+
+uint32_t fman_rtc_check_and_clear_event(struct rtc_regs *regs)
+{
+	uint32_t event;
+
+	event = ioread32be(&regs->tmr_tevent);
+	event &= ioread32be(&regs->tmr_temask);
+
+	if (event)
+		iowrite32be(event, &regs->tmr_tevent);
+	return event;
+}
+
+uint32_t fman_rtc_get_frequency_compensation(struct rtc_regs *regs)
+{
+	return ioread32be(&regs->tmr_add);
+}
+
+void fman_rtc_set_frequency_compensation(struct rtc_regs *regs, uint32_t val)
+{
+	iowrite32be(val, &regs->tmr_add);
+}
+
+void fman_rtc_enable_interupt(struct rtc_regs *regs, uint32_t events)
+{
+	fman_rtc_set_interrupt_mask(regs, fman_rtc_get_interrupt_mask(regs) | events);
+}
+
+void fman_rtc_disable_interupt(struct rtc_regs *regs, uint32_t events)
+{
+	fman_rtc_set_interrupt_mask(regs, fman_rtc_get_interrupt_mask(regs) & ~events);
+}
+
+void fman_rtc_set_timer_alarm_l(struct rtc_regs *regs, int index, uint32_t val)
+{
+	iowrite32be(val, &regs->tmr_alarm[index].tmr_alarm_l);
+}
+
+void fman_rtc_set_timer_fiper(struct rtc_regs *regs, int index, uint32_t val)
+{
+	iowrite32be(val, &regs->tmr_fiper[index]);
+}
+
+void fman_rtc_set_timer_alarm(struct rtc_regs *regs, int index, int64_t val)
+{
+	iowrite32be((uint32_t)val, &regs->tmr_alarm[index].tmr_alarm_l);
+	iowrite32be((uint32_t)(val >> 32), &regs->tmr_alarm[index].tmr_alarm_h);
+}
+
+void fman_rtc_set_timer_offset(struct rtc_regs *regs, int64_t val)
+{
+	iowrite32be((uint32_t)val, &regs->tmr_off_l);
+	iowrite32be((uint32_t)(val >> 32), &regs->tmr_off_h);
+}
+
+uint64_t fman_rtc_get_trigger_stamp(struct rtc_regs *regs, int id)
+{
+	uint64_t time;
+	/* TMR_CNT_L must be read first to get an accurate value */
+	time = (uint64_t)ioread32be(&regs->tmr_etts[id].tmr_etts_l);
+	time |= ((uint64_t)ioread32be(&regs->tmr_etts[id].tmr_etts_h)
+		<< 32);
+
+	return time;
+}
+
+uint32_t fman_rtc_get_timer_ctrl(struct rtc_regs *regs)
+{
+	return ioread32be(&regs->tmr_ctrl);
+}
+
+void fman_rtc_set_timer_ctrl(struct rtc_regs *regs, uint32_t val)
+{
+	iowrite32be(val, &regs->tmr_ctrl);
+}
+
+void fman_rtc_timers_soft_reset(struct rtc_regs *regs)
+{
+	fman_rtc_set_timer_ctrl(regs, FMAN_RTC_TMR_CTRL_TMSR);
+	udelay(10);
+	fman_rtc_set_timer_ctrl(regs, 0);
+}
+
+void fman_rtc_init(struct rtc_cfg *cfg, struct rtc_regs *regs, int num_alarms,
+		int num_fipers, int num_ext_triggers, bool init_freq_comp,
+		uint32_t freq_compensation, uint32_t output_clock_divisor)
+{
+	uint32_t            tmr_ctrl;
+	int			i;
+
+	fman_rtc_timers_soft_reset(regs);
+
+	/* Set the source clock */
+	switch (cfg->src_clk) {
+	case E_FMAN_RTC_SOURCE_CLOCK_SYSTEM:
+		tmr_ctrl = FMAN_RTC_TMR_CTRL_CKSEL_MAC_CLK;
+		break;
+	case E_FMAN_RTC_SOURCE_CLOCK_OSCILATOR:
+		tmr_ctrl = FMAN_RTC_TMR_CTRL_CKSEL_OSC_CLK;
+		break;
+	default:
+		/* Use a clock from the External TMR reference clock.*/
+		tmr_ctrl = FMAN_RTC_TMR_CTRL_CKSEL_EXT_CLK;
+		break;
+	}
+
+	/* whatever period the user picked, the timestamp will advance in '1'
+	* every time the period passed. */
+	tmr_ctrl |= ((1 << FMAN_RTC_TMR_CTRL_TCLK_PERIOD_SHIFT) &
+				FMAN_RTC_TMR_CTRL_TCLK_PERIOD_MASK);
+
+	if (cfg->invert_input_clk_phase)
+		tmr_ctrl |= FMAN_RTC_TMR_CTRL_CIPH;
+	if (cfg->invert_output_clk_phase)
+		tmr_ctrl |= FMAN_RTC_TMR_CTRL_COPH;
+
+	for (i = 0; i < num_alarms; i++) {
+		if (cfg->alarm_polarity[i] ==
+			E_FMAN_RTC_ALARM_POLARITY_ACTIVE_LOW)
+			tmr_ctrl |= (FMAN_RTC_TMR_CTRL_ALMP1 >> i);
+	}
+
+	for (i = 0; i < num_ext_triggers; i++)
+		if (cfg->trigger_polarity[i] ==
+			E_FMAN_RTC_TRIGGER_ON_FALLING_EDGE)
+			tmr_ctrl |= (FMAN_RTC_TMR_CTRL_ETEP1 << i);
+
+	if (!cfg->timer_slave_mode && cfg->bypass)
+		tmr_ctrl |= FMAN_RTC_TMR_CTRL_BYP;
+
+	fman_rtc_set_timer_ctrl(regs, tmr_ctrl);
+	if (init_freq_comp)
+		fman_rtc_set_frequency_compensation(regs, freq_compensation);
+
+	/* Clear TMR_ALARM registers */
+	for (i = 0; i < num_alarms; i++)
+		fman_rtc_set_timer_alarm(regs, i, 0xFFFFFFFFFFFFFFFFLL);
+
+	/* Clear TMR_TEVENT */
+	fman_rtc_ack_event(regs, FMAN_RTC_TMR_TEVENT_ALL);
+
+	/* Initialize TMR_TEMASK */
+	fman_rtc_set_interrupt_mask(regs, 0);
+
+	/* Clear TMR_FIPER registers */
+	for (i = 0; i < num_fipers; i++)
+		fman_rtc_set_timer_fiper(regs, i, 0xFFFFFFFF);
+
+	/* Initialize TMR_PRSC */
+	iowrite32be(output_clock_divisor, &regs->tmr_prsc);
+
+	/* Clear TMR_OFF */
+	fman_rtc_set_timer_offset(regs, 0);
+}
+
+bool fman_rtc_is_enabled(struct rtc_regs *regs)
+{
+	return (bool)(fman_rtc_get_timer_ctrl(regs) & FMAN_RTC_TMR_CTRL_TE);
+}
+
+void fman_rtc_enable(struct rtc_regs *regs, bool reset_clock)
+{
+	uint32_t tmr_ctrl = fman_rtc_get_timer_ctrl(regs);
+
+	/* TODO check that no timestamping MACs are working in this stage. */
+	if (reset_clock) {
+		fman_rtc_set_timer_ctrl(regs, (tmr_ctrl | FMAN_RTC_TMR_CTRL_TMSR));
+
+		udelay(10);
+		/* Clear TMR_OFF */
+		fman_rtc_set_timer_offset(regs, 0);
+	}
+
+	fman_rtc_set_timer_ctrl(regs, (tmr_ctrl | FMAN_RTC_TMR_CTRL_TE));
+}
+
+void fman_rtc_disable(struct rtc_regs *regs)
+{
+	fman_rtc_set_timer_ctrl(regs, (fman_rtc_get_timer_ctrl(regs)
+					& ~(FMAN_RTC_TMR_CTRL_TE)));
+}
+
+void fman_rtc_clear_periodic_pulse(struct rtc_regs *regs, int id)
+{
+	uint32_t tmp_reg;
+	if (id == 0)
+		tmp_reg = FMAN_RTC_TMR_TEVENT_PP1;
+	else
+		tmp_reg = FMAN_RTC_TMR_TEVENT_PP2;
+	fman_rtc_disable_interupt(regs, tmp_reg);
+
+	tmp_reg = fman_rtc_get_timer_ctrl(regs);
+	if (tmp_reg & FMAN_RTC_TMR_CTRL_FS)
+		fman_rtc_set_timer_ctrl(regs, tmp_reg & ~FMAN_RTC_TMR_CTRL_FS);
+
+	fman_rtc_set_timer_fiper(regs, id, 0xFFFFFFFF);
+}
+
+void fman_rtc_clear_external_trigger(struct rtc_regs *regs, int id)
+{
+	uint32_t    tmpReg, tmp_ctrl;
+
+	if (id == 0)
+		tmpReg = FMAN_RTC_TMR_TEVENT_ETS1;
+	else
+		tmpReg = FMAN_RTC_TMR_TEVENT_ETS2;
+	fman_rtc_disable_interupt(regs, tmpReg);
+
+	if (id == 0)
+		tmpReg = FMAN_RTC_TMR_CTRL_PP1L;
+	else
+		tmpReg = FMAN_RTC_TMR_CTRL_PP2L;
+	tmp_ctrl = fman_rtc_get_timer_ctrl(regs);
+	if (tmp_ctrl & tmpReg)
+		fman_rtc_set_timer_ctrl(regs, tmp_ctrl & ~tmpReg);
+}
+
+void fman_rtc_set_alarm(struct rtc_regs *regs, int id, uint32_t val, bool enable)
+{
+	uint32_t    tmpReg;
+	fman_rtc_set_timer_alarm(regs, id, val);
+	if (enable) {
+		if (id == 0)
+			tmpReg = FMAN_RTC_TMR_TEVENT_ALM1;
+		else
+			tmpReg = FMAN_RTC_TMR_TEVENT_ALM2;
+		fman_rtc_enable_interupt(regs, tmpReg);
+	}
+}
+
+void fman_rtc_set_periodic_pulse(struct rtc_regs *regs, int id, uint32_t val,
+						bool enable)
+{
+	uint32_t    tmpReg;
+	fman_rtc_set_timer_fiper(regs, id, val);
+	if (enable) {
+		if (id == 0)
+			tmpReg = FMAN_RTC_TMR_TEVENT_PP1;
+		else
+			tmpReg = FMAN_RTC_TMR_TEVENT_PP2;
+		fman_rtc_enable_interupt(regs, tmpReg);
+	}
+}
+
+void fman_rtc_set_ext_trigger(struct rtc_regs *regs, int id, bool enable,
+						bool use_pulse_as_input)
+{
+	uint32_t    tmpReg;
+	if (enable) {
+		if (id == 0)
+			tmpReg = FMAN_RTC_TMR_TEVENT_ETS1;
+		else
+			tmpReg = FMAN_RTC_TMR_TEVENT_ETS2;
+		fman_rtc_enable_interupt(regs, tmpReg);
+	}
+	if (use_pulse_as_input)	{
+		if (id == 0)
+			tmpReg = FMAN_RTC_TMR_CTRL_PP1L;
+		else
+			tmpReg = FMAN_RTC_TMR_CTRL_PP2L;
+		fman_rtc_set_timer_ctrl(regs, fman_rtc_get_timer_ctrl(regs) | tmpReg);
+	}
+}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/Makefile
index 977583a..669e940 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/Makefile
@@ -12,4 +12,4 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-sp.o
 
-fsl-ncsw-sp-objs	:=   fm_sp.o
+fsl-ncsw-sp-objs	:= fm_sp.o fman_sp.o
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
index a457078..1f1cdf2 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
@@ -46,133 +46,10 @@
 #include "fm_vsp_ext.h"
 #include "fm_sp.h"
 #include "fm_common.h"
-
+#include "fsl_fman_sp.h"
 
 #if (DPAA_VERSION >= 11)
 
-static void fm_vsp_fill_entry(fm_pcd_storage_profile_regs   *regs,
-                              uint16_t                      index,
-                              fm_storage_profile_params     *fm_vsp_params)
-{
-    int i = 0, j = 0;
-    fm_pcd_storage_profile_regs *sp_regs;
-    uint32_t tmp_reg, vector;
-    t_FmExtPools *ext_buf_pools             = fm_vsp_params->fm_ext_pools;
-    t_FmBufPoolDepletion *buf_pool_depletion= fm_vsp_params->buf_pool_depletion;
-    t_FmBackupBmPools *backup_pools         = fm_vsp_params->backup_pools;
-    t_FmSpIntContextDataCopy *int_context_data_copy = fm_vsp_params->int_context;
-    t_FmSpBufMargins *external_buffer_margins = fm_vsp_params->buf_margins;
-    bool no_scather_gather                  = fm_vsp_params->no_scather_gather;
-    uint16_t    liodn_offset                = fm_vsp_params->liodn_offset;
-
-    ASSERT_COND(regs);
-    ASSERT_COND(ext_buf_pools);
-    ASSERT_COND(int_context_data_copy);
-    ASSERT_COND(external_buffer_margins);
-    ASSERT_COND(IN_RANGE(0, index, FM_VSP_MAX_NUM_OF_ENTRIES));
-
-    sp_regs = &regs[index];
-
-    /* fill external buffers manager pool information register*/
-    for (i=0;i<ext_buf_pools->numOfPoolsUsed;i++)
-    {
-        tmp_reg = FM_SP_EXT_BUF_POOL_VALID | FM_SP_EXT_BUF_POOL_EN_COUNTER;
-        tmp_reg |= ((uint32_t)ext_buf_pools->extBufPool[i].id << FM_SP_EXT_BUF_POOL_ID_SHIFT);
-        tmp_reg |= ext_buf_pools->extBufPool[i].size;
-        /* functionality available only for some deriviatives (limited by config) */
-        if (backup_pools)
-            for (j=0;j<backup_pools->numOfBackupPools;j++)
-                if (ext_buf_pools->extBufPool[i].id == backup_pools->poolIds[j])
-                {
-                    tmp_reg |= FM_SP_EXT_BUF_POOL_BACKUP;
-                    break;
-                }
-
-        WRITE_UINT32(sp_regs->fm_sp_ebmpi[i], tmp_reg);
-    }
-
-    /* clear unused pools */
-    for (i=ext_buf_pools->numOfPoolsUsed;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
-        WRITE_UINT32(sp_regs->fm_sp_ebmpi[i], 0);
-
-    /* fill pool depletion register*/
-    tmp_reg = 0;
-
-    if (buf_pool_depletion && buf_pool_depletion->poolsGrpModeEnable)
-    {
-        /* calculate vector for number of pools depletion */
-        vector = 0;
-        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
-            if (buf_pool_depletion->poolsToConsider[i])
-                for (j=0;j<ext_buf_pools->numOfPoolsUsed;j++)
-                    if (i == ext_buf_pools->extBufPool[j].id)
-                    {
-                        vector |= 0x80000000 >> j;
-                        break;
-                    }
-
-        /* configure num of pools and vector for number of pools mode */
-        tmp_reg |= (((uint32_t)buf_pool_depletion->numOfPools - 1) << FM_SP_POOL_DEP_NUM_OF_POOLS_SHIFT);
-        tmp_reg |= vector;
-    }
-
-    if (buf_pool_depletion && buf_pool_depletion->singlePoolModeEnable)
-    {
-        /* calculate vector for number of pools depletion */
-        vector = 0;
-        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
-            if (buf_pool_depletion->poolsToConsiderForSingleMode[i])
-                for (j=0;j<ext_buf_pools->numOfPoolsUsed;j++)
-                    if (i == ext_buf_pools->extBufPool[j].id)
-                    {
-                        vector |= 0x00000080 >> j;
-                        break;
-                    }
-
-        /* configure num of pools and vector for number of pools mode */
-        tmp_reg |= vector;
-    }
-
-    /* fill QbbPEV */
-    if (buf_pool_depletion)
-    {
-        vector = 0;
-        for (i=0; i<FM_MAX_NUM_OF_PFC_PRIORITIES; i++)
-            if (buf_pool_depletion->pfcPrioritiesEn[i] == TRUE)
-                vector|= 0x00008000 >> i;
-        tmp_reg |= vector;
-    }
-    WRITE_UINT32(sp_regs->fm_sp_mpd, tmp_reg);
-
-    /* fill dma attributes register */
-    tmp_reg = 0;
-    tmp_reg |= (uint32_t)fm_vsp_params->dma_swap_data << FM_SP_DMA_ATTR_SWP_SHIFT;
-    tmp_reg |= (uint32_t)fm_vsp_params->int_context_cache_attr << FM_SP_DMA_ATTR_IC_CACHE_SHIFT;
-    tmp_reg |= (uint32_t)fm_vsp_params->header_cache_attr << FM_SP_DMA_ATTR_HDR_CACHE_SHIFT;
-    tmp_reg |= (uint32_t)fm_vsp_params->scatter_gather_cache_attr << FM_SP_DMA_ATTR_SG_CACHE_SHIFT;
-    if (fm_vsp_params->dma_write_optimize)
-        tmp_reg |= FM_SP_DMA_ATTR_WRITE_OPTIMIZE;
-    WRITE_UINT32(sp_regs->fm_sp_da, tmp_reg);
-
-    /* IC parameters - fill internal context parameters register */
-    tmp_reg = 0;
-    tmp_reg |= (((uint32_t)int_context_data_copy->extBufOffset/OFFSET_UNITS) << FM_SP_IC_TO_EXT_SHIFT);
-    tmp_reg |= (((uint32_t)int_context_data_copy->intContextOffset/OFFSET_UNITS) << FM_SP_IC_FROM_INT_SHIFT);
-    tmp_reg |= (((uint32_t)int_context_data_copy->size/OFFSET_UNITS)  << FM_SP_IC_SIZE_SHIFT);
-    WRITE_UINT32(sp_regs->fm_sp_icp, tmp_reg);
-
-    /* buffer margins - fill external buffer margins register */
-    tmp_reg = 0;
-    tmp_reg |= (((uint32_t)external_buffer_margins->startMargins) << FM_SP_EXT_BUF_MARG_START_SHIFT);
-    tmp_reg |= (((uint32_t)external_buffer_margins->endMargins) << FM_SP_EXT_BUF_MARG_END_SHIFT);
-    if (no_scather_gather)
-        tmp_reg |= FM_SP_SG_DISABLE;
-    WRITE_UINT32(sp_regs->fm_sp_ebm, tmp_reg);
-
-    /* buffer margins - fill spliodn register */
-    WRITE_UINT32(sp_regs->fm_sp_spliodn, liodn_offset);
-}
-
 static t_Error CheckParamsGeneratedInternally(t_FmVspEntry *p_FmVspEntry)
 {
     t_Error err = E_OK;
@@ -530,6 +407,7 @@ t_Error FmSpBuildBufferStructure(t_FmSpIntContextDataCopy   *p_FmSpIntContextDat
 t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams)
 {
     t_FmVspEntry          *p_FmVspEntry = NULL;
+    struct fm_storage_profile_params   fm_vsp_params;
 
     p_FmVspEntry = (t_FmVspEntry *)XX_Malloc(sizeof(t_FmVspEntry));
     if (!p_FmVspEntry)
@@ -547,29 +425,25 @@ t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams)
         return NULL;
     }
     memset(p_FmVspEntry->p_FmVspEntryDriverParams, 0, sizeof(t_FmVspEntryDriverParams));
-
+    fman_vsp_defconfig(&fm_vsp_params);
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaHeaderCacheAttr = fm_vsp_params.header_cache_attr;
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaIntContextCacheAttr = fm_vsp_params.int_context_cache_attr;
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaScatterGatherCacheAttr = fm_vsp_params.scatter_gather_cache_attr;
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaSwapData = fm_vsp_params.dma_swap_data;
+    p_FmVspEntry->p_FmVspEntryDriverParams->dmaWriteOptimize = fm_vsp_params.dma_write_optimize;
+    p_FmVspEntry->p_FmVspEntryDriverParams->noScatherGather = fm_vsp_params.no_scather_gather;
     p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.privDataSize = DEFAULT_FM_SP_bufferPrefixContent_privDataSize;
     p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.passPrsResult= DEFAULT_FM_SP_bufferPrefixContent_passPrsResult;
     p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.passTimeStamp= DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp;
     p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.passAllOtherPCDInfo
                                                                     = DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp;
     p_FmVspEntry->p_FmVspEntryDriverParams->bufferPrefixContent.dataAlign    = DEFAULT_FM_SP_bufferPrefixContent_dataAlign;
-
-    p_FmVspEntry->p_FmVspEntryDriverParams->dmaSwapData                      = DEFAULT_FM_SP_dmaSwapData;
-    p_FmVspEntry->p_FmVspEntryDriverParams->dmaIntContextCacheAttr           = DEFAULT_FM_SP_dmaIntContextCacheAttr;
-    p_FmVspEntry->p_FmVspEntryDriverParams->dmaHeaderCacheAttr               = DEFAULT_FM_SP_dmaHeaderCacheAttr;
-    p_FmVspEntry->p_FmVspEntryDriverParams->dmaScatterGatherCacheAttr        = DEFAULT_FM_SP_dmaScatterGatherCacheAttr;
-    p_FmVspEntry->p_FmVspEntryDriverParams->dmaWriteOptimize                 = DEFAULT_FM_SP_dmaWriteOptimize;
-
-    p_FmVspEntry->p_FmVspEntryDriverParams->noScatherGather                  = DEFAULT_FM_SP_noScatherGather;
-
     p_FmVspEntry->p_FmVspEntryDriverParams->liodnOffset                      = p_FmVspParams->liodnOffset;
 
     memcpy(&p_FmVspEntry->p_FmVspEntryDriverParams->extBufPools, &p_FmVspParams->extBufPools, sizeof(t_FmExtPools));
-
     p_FmVspEntry->h_Fm                                                       = p_FmVspParams->h_Fm;
     p_FmVspEntry->portType                                                   = p_FmVspParams->portParams.portType;
-    p_FmVspEntry->portId                                                     = p_FmVspParams->portParams.portId  ;
+    p_FmVspEntry->portId                                                     = p_FmVspParams->portParams.portId;
 
     p_FmVspEntry->relativeProfileId                                          = p_FmVspParams->relativeProfileId;
 
@@ -580,7 +454,7 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
 {
 
     t_FmVspEntry                *p_FmVspEntry = (t_FmVspEntry *)h_FmVsp;
-    fm_storage_profile_params   fm_vsp_params;
+    struct fm_storage_profile_params   fm_vsp_params;
     uint8_t                     orderedArray[FM_PORT_MAX_NUM_OF_EXT_POOLS];
     uint16_t                    sizesArray[BM_MAX_NUM_OF_POOLS];
     t_Error                     err;
@@ -610,7 +484,7 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
 
 
      p_FmVspEntry->p_FmSpRegsBase =
-        (fm_pcd_storage_profile_regs *)FmGetVSPBaseAddr(p_FmVspEntry->h_Fm);
+        (struct fm_pcd_storage_profile_regs *)FmGetVSPBaseAddr(p_FmVspEntry->h_Fm);
     if (!p_FmVspEntry->p_FmSpRegsBase)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("impossible to initialize SpRegsBase"));
 
@@ -628,7 +502,7 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     }
 
     /* on user responsibility to fill it according requirement */
-    memset(&fm_vsp_params, 0, sizeof(fm_storage_profile_params));
+    memset(&fm_vsp_params, 0, sizeof(struct fm_storage_profile_params));
     fm_vsp_params.dma_swap_data              = p_FmVspEntry->p_FmVspEntryDriverParams->dmaSwapData;
     fm_vsp_params.int_context_cache_attr     = p_FmVspEntry->p_FmVspEntryDriverParams->dmaIntContextCacheAttr;
     fm_vsp_params.header_cache_attr          = p_FmVspEntry->p_FmVspEntryDriverParams->dmaHeaderCacheAttr;
@@ -637,12 +511,32 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     fm_vsp_params.liodn_offset               = p_FmVspEntry->p_FmVspEntryDriverParams->liodnOffset;
     fm_vsp_params.no_scather_gather          = p_FmVspEntry->p_FmVspEntryDriverParams->noScatherGather;
 
-    fm_vsp_params.buf_pool_depletion         = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion;
-    fm_vsp_params.backup_pools               = p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools;
-    fm_vsp_params.fm_ext_pools               = &p_FmVspEntry->extBufPools;
+    if (p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion)
+    {
+        fm_vsp_params.buf_pool_depletion.buf_pool_depletion_enabled = TRUE;
+        fm_vsp_params.buf_pool_depletion.pools_grp_mode_enable = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->poolsGrpModeEnable;
+        fm_vsp_params.buf_pool_depletion.num_pools = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->numOfPools;
+        fm_vsp_params.buf_pool_depletion.pools_to_consider = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->poolsToConsider;
+        fm_vsp_params.buf_pool_depletion.single_pool_mode_enable = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->singlePoolModeEnable;
+        fm_vsp_params.buf_pool_depletion.pools_to_consider_for_single_mode = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->poolsToConsiderForSingleMode;
+        fm_vsp_params.buf_pool_depletion.has_pfc_priorities = TRUE;
+        fm_vsp_params.buf_pool_depletion.pfc_priorities_en = p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion->pfcPrioritiesEn;
+    }
+    else
+        fm_vsp_params.buf_pool_depletion.buf_pool_depletion_enabled = FALSE;
+ 
+    if (p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools)
+    {
+        fm_vsp_params.backup_pools.num_backup_pools = p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools->numOfBackupPools;
+        fm_vsp_params.backup_pools.pool_ids = p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools->poolIds;
+    }
+    else
+        fm_vsp_params.backup_pools.num_backup_pools = 0;
 
-    fm_vsp_params.buf_margins                = &p_FmVspEntry->bufMargins;
-    fm_vsp_params.int_context                = &p_FmVspEntry->intContext;
+    fm_vsp_params.fm_ext_pools.num_pools_used = p_FmVspEntry->extBufPools.numOfPoolsUsed;
+    fm_vsp_params.fm_ext_pools.ext_buf_pool = (struct fman_ext_pool_params*)&p_FmVspEntry->extBufPools.extBufPool;
+    fm_vsp_params.buf_margins = (struct fman_sp_buf_margins*)&p_FmVspEntry->bufMargins;
+    fm_vsp_params.int_context = (struct fman_sp_int_context_data_copy*)&p_FmVspEntry->intContext;
 
    /*no check on err - it was checked earlier*/
     FmVSPGetAbsoluteProfileId(p_FmVspEntry->h_Fm,
@@ -651,8 +545,13 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
                                    p_FmVspEntry->relativeProfileId,
                                    &absoluteProfileId);
 
-    /*set all registers related to VSP*/
-    fm_vsp_fill_entry(p_FmVspEntry->p_FmSpRegsBase, absoluteProfileId, &fm_vsp_params);
+
+    ASSERT_COND(p_FmVspEntry->p_FmSpRegsBase);
+    ASSERT_COND(fm_vsp_params.int_context);
+    ASSERT_COND(fm_vsp_params.buf_margins);
+    ASSERT_COND(IN_RANGE(0, absoluteProfileId, FM_VSP_MAX_NUM_OF_ENTRIES));
+    /* Set all registers related to VSP */
+    fman_vsp_init(p_FmVspEntry->p_FmSpRegsBase, absoluteProfileId, &fm_vsp_params,FM_PORT_MAX_NUM_OF_EXT_POOLS, BM_MAX_NUM_OF_POOLS, FM_MAX_NUM_OF_PFC_PRIORITIES);
 
     p_FmVspEntry->absoluteSpId = absoluteProfileId;
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.h
index 30b41b6..9c171d8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.h
@@ -49,52 +49,6 @@
 
 #define __ERR_MODULE__  MODULE_FM_SP
 
-
-
-/***********************************************************************/
-/*          Memory map                                                 */
-/***********************************************************************/
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-
-typedef _Packed struct {
-    volatile uint32_t   fm_sp_ebmpi[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-                                         /*offset 0 - 0xc*/
-                                         /**< Buffer Manager pool Information-*/
-
-    volatile uint32_t   res[8-FM_PORT_MAX_NUM_OF_EXT_POOLS];
-                                         /*offset 0x10 - 0xc*/
-    volatile uint32_t   fm_sp_acnt;      /*offset 0x20*/
-    volatile uint32_t   fm_sp_ebm;       /*offset 0x24*/
-    volatile uint32_t   fm_sp_da;        /*offset 0x28*/
-    volatile uint32_t   fm_sp_icp;       /*offset 0x2c*/
-    volatile uint32_t   fm_sp_mpd;       /*offset 0x30*/
-    volatile uint32_t   res1[2];         /*offset 0x34 - 0x38*/
-    volatile uint32_t   fm_sp_spliodn;   /*offset 0x3c*/
-} _PackedType fm_pcd_storage_profile_regs;
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
-
-
-typedef struct fm_storage_profile_params {
-    t_FmExtPools                *fm_ext_pools;
-    t_FmBackupBmPools           *backup_pools;
-    t_FmSpIntContextDataCopy    *int_context;
-    t_FmSpBufMargins            *buf_margins;
-
-    e_FmDmaSwapOption           dma_swap_data;
-    e_FmDmaCacheOption          int_context_cache_attr;
-    e_FmDmaCacheOption          header_cache_attr;
-    e_FmDmaCacheOption          scatter_gather_cache_attr;
-    bool                        dma_write_optimize;
-    uint16_t                    liodn_offset;
-    bool                        no_scather_gather;
-    t_FmBufPoolDepletion        *buf_pool_depletion;
-} fm_storage_profile_params;
-
 typedef struct {
     t_FmBufferPrefixContent             bufferPrefixContent;
     e_FmDmaSwapOption                   dmaSwapData;
@@ -122,7 +76,7 @@ typedef struct {
     e_FmPortType                portType;           /**< Port type */
     uint8_t                     portId;             /**< Port Id - relative to type */
     uint8_t                     relativeProfileId;
-    fm_pcd_storage_profile_regs *p_FmSpRegsBase;
+    struct fm_pcd_storage_profile_regs *p_FmSpRegsBase;
     t_FmExtPools                extBufPools;
     t_FmVspEntryDriverParams    *p_FmVspEntryDriverParams;
 } t_FmVspEntry;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fman_sp.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fman_sp.c
new file mode 100755
index 0000000..d1f1467
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fman_sp.c
@@ -0,0 +1,197 @@
+/*
+ * Copyright 2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fsl_fman_sp.h"
+
+
+uint32_t fman_vsp_get_statistics(struct fm_pcd_storage_profile_regs   *regs,
+					uint16_t                      index)
+{
+	struct fm_pcd_storage_profile_regs *sp_regs;
+	sp_regs = &regs[index];
+	return ioread32be(&sp_regs->fm_sp_acnt);
+}
+
+void fman_vsp_set_statistics(struct fm_pcd_storage_profile_regs *regs,
+			uint16_t index,	uint32_t value)
+{
+	struct fm_pcd_storage_profile_regs *sp_regs;
+	sp_regs = &regs[index];
+	iowrite32be(value, &sp_regs->fm_sp_acnt);
+}
+
+void fman_vsp_defconfig(struct fm_storage_profile_params *cfg)
+{
+	cfg->dma_swap_data =
+			DEFAULT_FMAN_SP_DMA_SWAP_DATA;
+	cfg->int_context_cache_attr =
+			DEFAULT_FMAN_SP_DMA_INT_CONTEXT_CACHE_ATTR;
+	cfg->header_cache_attr =
+			DEFAULT_FMAN_SP_DMA_HEADER_CACHE_ATTR;
+	cfg->scatter_gather_cache_attr =
+			DEFAULT_FMAN_SP_DMA_SCATTER_GATHER_CACHE_ATTR;
+	cfg->dma_write_optimize =
+			DEFAULT_FMAN_SP_DMA_WRITE_OPTIMIZE;
+	cfg->no_scather_gather =
+			DEFAULT_FMAN_SP_NO_SCATTER_GATHER;
+}
+
+static inline uint32_t calc_vec_dep(int max_pools, bool *pools,
+		struct fman_ext_pools *ext_buf_pools, uint32_t mask)
+{
+	int i, j;
+	uint32_t vector = 0;
+	for (i = 0; i < max_pools; i++)
+		if (pools[i])
+			for (j = 0; j < ext_buf_pools->num_pools_used; j++)
+				if (i == ext_buf_pools->ext_buf_pool[j].id) {
+					vector |= mask >> j;
+					break;
+				}
+	return vector;
+}
+
+void fman_vsp_init(struct fm_pcd_storage_profile_regs   *regs,
+	uint16_t index, struct fm_storage_profile_params *fm_vsp_params,
+	int port_max_num_of_ext_pools, int bm_max_num_of_pools,
+	int max_num_of_pfc_priorities)
+{
+	int i = 0, j = 0;
+	struct fm_pcd_storage_profile_regs *sp_regs;
+	uint32_t tmp_reg, vector;
+	struct fman_ext_pools *ext_buf_pools = &fm_vsp_params->fm_ext_pools;
+	struct fman_buf_pool_depletion *buf_pool_depletion =
+					&fm_vsp_params->buf_pool_depletion;
+	struct fman_backup_bm_pools *backup_pools =
+					&fm_vsp_params->backup_pools;
+	struct fman_sp_int_context_data_copy *int_context_data_copy =
+						fm_vsp_params->int_context;
+	struct fman_sp_buf_margins *external_buffer_margins =
+						fm_vsp_params->buf_margins;
+	bool no_scather_gather = fm_vsp_params->no_scather_gather;
+	uint16_t liodn_offset = fm_vsp_params->liodn_offset;
+
+	sp_regs = &regs[index];
+
+	/* fill external buffers manager pool information register*/
+	for (i = 0; i < ext_buf_pools->num_pools_used; i++) {
+		tmp_reg = FMAN_SP_EXT_BUF_POOL_VALID |
+			FMAN_SP_EXT_BUF_POOL_EN_COUNTER;
+		tmp_reg |= ((uint32_t)ext_buf_pools->ext_buf_pool[i].id <<
+			FMAN_SP_EXT_BUF_POOL_ID_SHIFT);
+		tmp_reg |= ext_buf_pools->ext_buf_pool[i].size;
+		/* functionality available only for some deriviatives
+			 (limited by config) */
+		for (j = 0; j < backup_pools->num_backup_pools; j++)
+			if (ext_buf_pools->ext_buf_pool[i].id ==
+				backup_pools->pool_ids[j]) {
+				tmp_reg |= FMAN_SP_EXT_BUF_POOL_BACKUP;
+				break;
+			}
+		iowrite32be(tmp_reg, &sp_regs->fm_sp_ebmpi[i]);
+	}
+
+	/* clear unused pools */
+	for (i = ext_buf_pools->num_pools_used;
+		i < port_max_num_of_ext_pools; i++)
+		iowrite32be(0, &sp_regs->fm_sp_ebmpi[i]);
+
+	/* fill pool depletion register*/
+	tmp_reg = 0;
+	if (buf_pool_depletion->buf_pool_depletion_enabled && buf_pool_depletion->pools_grp_mode_enable) {
+		/* calculate vector for number of pools depletion */
+		vector = calc_vec_dep(bm_max_num_of_pools, buf_pool_depletion->
+				pools_to_consider, ext_buf_pools, 0x80000000);
+
+		/* configure num of pools and vector for number of pools mode */
+		tmp_reg |= (((uint32_t)buf_pool_depletion->num_pools - 1) <<
+			FMAN_SP_POOL_DEP_NUM_OF_POOLS_SHIFT);
+		tmp_reg |= vector;
+	}
+
+	if (buf_pool_depletion->buf_pool_depletion_enabled && buf_pool_depletion->single_pool_mode_enable) {
+		/* calculate vector for number of pools depletion */
+		vector = calc_vec_dep(bm_max_num_of_pools, buf_pool_depletion->
+				pools_to_consider_for_single_mode,
+				ext_buf_pools, 0x00000080);
+
+		/* configure num of pools and vector for number of pools mode */
+		tmp_reg |= vector;
+	}
+
+	/* fill QbbPEV */
+	if (buf_pool_depletion->buf_pool_depletion_enabled) {
+		vector = 0;
+		for (i = 0; i < max_num_of_pfc_priorities; i++)
+			if (buf_pool_depletion->pfc_priorities_en[i] == TRUE)
+				vector |= 0x00008000 >> i;
+		tmp_reg |= vector;
+	}
+	iowrite32be(tmp_reg, &sp_regs->fm_sp_mpd);
+
+	/* fill dma attributes register */
+	tmp_reg = 0;
+	tmp_reg |= (uint32_t)fm_vsp_params->dma_swap_data <<
+		FMAN_SP_DMA_ATTR_SWP_SHIFT;
+	tmp_reg |= (uint32_t)fm_vsp_params->int_context_cache_attr <<
+		FMAN_SP_DMA_ATTR_IC_CACHE_SHIFT;
+	tmp_reg |= (uint32_t)fm_vsp_params->header_cache_attr <<
+		FMAN_SP_DMA_ATTR_HDR_CACHE_SHIFT;
+	tmp_reg |= (uint32_t)fm_vsp_params->scatter_gather_cache_attr <<
+		FMAN_SP_DMA_ATTR_SG_CACHE_SHIFT;
+	if (fm_vsp_params->dma_write_optimize)
+		tmp_reg |= FMAN_SP_DMA_ATTR_WRITE_OPTIMIZE;
+	iowrite32be(tmp_reg, &sp_regs->fm_sp_da);
+
+	/* IC parameters - fill internal context parameters register */
+	tmp_reg = 0;
+	tmp_reg |= (((uint32_t)int_context_data_copy->ext_buf_offset/
+		OFFSET_UNITS) << FMAN_SP_IC_TO_EXT_SHIFT);
+	tmp_reg |= (((uint32_t)int_context_data_copy->int_context_offset/
+		OFFSET_UNITS) << FMAN_SP_IC_FROM_INT_SHIFT);
+	tmp_reg |= (((uint32_t)int_context_data_copy->size/OFFSET_UNITS) <<
+		FMAN_SP_IC_SIZE_SHIFT);
+	iowrite32be(tmp_reg, &sp_regs->fm_sp_icp);
+
+	/* buffer margins - fill external buffer margins register */
+	tmp_reg = 0;
+	tmp_reg |= (((uint32_t)external_buffer_margins->start_margins) <<
+		FMAN_SP_EXT_BUF_MARG_START_SHIFT);
+	tmp_reg |= (((uint32_t)external_buffer_margins->end_margins) <<
+		FMAN_SP_EXT_BUF_MARG_END_SHIFT);
+	if (no_scather_gather)
+		tmp_reg |= FMAN_SP_SG_DISABLE;
+	iowrite32be(tmp_reg, &sp_regs->fm_sp_ebm);
+
+	/* buffer margins - fill spliodn register */
+	iowrite32be(liodn_offset, &sp_regs->fm_sp_spliodn);
+}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index 10601ec..6f27b2c 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -183,7 +183,7 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 #ifdef FM_NO_TNUM_AGING
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) &&
         (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
-        if (p_Fm->p_FmDriverParam->tnumAgingPeriod)
+        if (p_Fm->tnumAgingPeriod)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Tnum aging!"));
 #endif /* FM_NO_TNUM_AGING */
 
@@ -1307,6 +1307,16 @@ t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
 }
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
+uint16_t FmGetTnumAgingPeriod(t_Handle h_Fm)
+{
+    t_Fm *p_Fm = (t_Fm *)h_Fm;
+
+    SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
+
+    return p_Fm->tnumAgingPeriod;
+}
+
 t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
                                         uint32_t     congestionGroupId,
                                         uint8_t      priorityBitMap)
@@ -1333,14 +1343,23 @@ t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
 
         tmpReg = GET_UINT32(p_Cpg[reg_num]);
 
-        if (priorityBitMap)//adding priority
+        /* Adding priorities*/
+        if (priorityBitMap)
         {
             if (tmpReg & (0xFF<<(offset*8)))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE,
                              ("PFC priority for the congestion group is already set!"));
         }
+        else /* Deleting priorities */
+        {
+            uint32_t mask;
+
+            mask = 0xFF<<(offset*8);
+            tmpReg &= ~mask;
+        }
+
         tmpReg |= (uint32_t)priorityBitMap << (offset*8);
-            WRITE_UINT32(p_Cpg[reg_num], tmpReg);
+        WRITE_UINT32(p_Cpg[reg_num], tmpReg);
     }
 
     else if (p_Fm->h_IpcSessions[0])
@@ -2268,11 +2287,6 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     p_Fm->p_FmStateStruct->accumulatedFifoSize -=
         (((tmpReg & BMI_FIFO_SIZE_MASK) + 1) * BMI_FIFO_UNITS);
 
-    /* clear registers */
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1], 0);
-    WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], 0);
-    /* WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], 0); */
-
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
@@ -3564,15 +3578,21 @@ static t_Error InitFmDma(t_Fm *p_Fm)
 
     /* configure thresholds register */
     tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtr);
-    tmpReg |= ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT) |
-              ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
-              ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
+    tmpReg &= ~DMA_THRESH_COMMQ_MASK;
+    tmpReg |= ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT);
+#if (DPAA_VERSION < 11)
+    tmpReg &= ~(DMA_THRESH_READ_INT_BUF_MASK | DMA_THRESH_WRITE_INT_BUF_MASK);
+    tmpReg |= ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+               ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
+#endif /* (DPAA_VERSION < 11) */
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmtr, tmpReg);
 
     /* configure hysteresis register */
-    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.clearEmergency << DMA_THRESH_COMMQ_SHIFT) |
-              ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+    tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.clearEmergency << DMA_THRESH_COMMQ_SHIFT);
+#if (DPAA_VERSION < 11)
+    tmpReg |= ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
               ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.clearEmergency);
+#endif /* (DPAA_VERSION < 11) */
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmhy, tmpReg);
 
     /* configure emergency threshold */
@@ -3771,13 +3791,13 @@ static t_Error InitFmQmi(t_Fm *p_Fm)
     /* enable events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
 
-    if (p_Fm->p_FmDriverParam->tnumAgingPeriod)
+    if (p_Fm->tnumAgingPeriod)
     {
         uint16_t                periodInFmClocks;
         uint8_t                 remainder;
 
         /* tnumAgingPeriod is in units of microseconds, p_FmClockFreq is in Mhz */
-        periodInFmClocks = (uint16_t)(p_Fm->p_FmDriverParam->tnumAgingPeriod*p_Fm->p_FmStateStruct->fmClkFreq);
+        periodInFmClocks = (uint16_t)(p_Fm->tnumAgingPeriod * p_Fm->p_FmStateStruct->fmClkFreq);
         /* periodInFmClocks must be a 64 multiply */
         remainder = (uint8_t)(periodInFmClocks % 64);
         if (remainder > 64)
@@ -4063,7 +4083,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmStateStruct->extraFifoPoolSize    = 0;
     p_Fm->p_FmStateStruct->exceptions           = DEFAULT_exceptions;
     /*p_Fm->p_FmDriverParam->numOfPartitions                    = p_FmParam->numOfPartitions;    */
-    p_Fm->p_FmDriverParam->tnumAgingPeriod                      = 0;
     p_Fm->p_FmDriverParam->resetOnInit                          = DEFAULT_resetOnInit;
 
     p_Fm->p_FmDriverParam->catastrophicErr                      = DEFAULT_catastrophicErr;
@@ -4107,25 +4126,30 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->p_FmDriverParam->dmaAidMode                       = e_FM_DMA_AID_OUT_PORT_ID;
 #endif /* FM_AID_MODE_NO_TNUM_SW005 */
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-
     if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
         p_Fm->p_FmStateStruct->totalFifoSize        = 0;
-        p_Fm->p_FmStateStruct->totalNumOfTasks      = BMI_MAX_NUM_OF_TASKS;
+        p_Fm->p_FmStateStruct->totalNumOfTasks      = DEFAULT_totalNumOfTasks;
+#ifdef FM_HAS_TOTAL_DMAS
         p_Fm->p_FmStateStruct->maxNumOfOpenDmas     = BMI_MAX_NUM_OF_DMAS;
+#endif
         p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency        = DEFAULT_dmaCommQLow;
         p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency       = DEFAULT_dmaCommQHigh;
+#if (DPAA_VERSION < 11)
         p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency      = DEFAULT_dmaReadIntBufLow;
         p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency     = DEFAULT_dmaReadIntBufHigh;
         p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency     = DEFAULT_dmaWriteIntBufLow;
         p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency    = DEFAULT_dmaWriteIntBufHigh;
+        p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats                      = DEFAULT_axiDbgNumOfBeats;
+#endif /* (DPAA_VERSION < 11) */
         p_Fm->p_FmDriverParam->dmaCacheOverride                     = DEFAULT_cacheOverride;
         p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = DEFAULT_dmaCamNumOfEntries;
         p_Fm->p_FmDriverParam->dmaDbgCntMode                        = DEFAULT_dmaDbgCntMode;
-        p_Fm->p_FmDriverParam->dmaEnEmergency                       = FALSE;
-        p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats                  = DEFAULT_axiDbgNumOfBeats;
+        p_Fm->p_FmDriverParam->dmaEnEmergency                       = DEFAULT_dmaEnEmergency;
         p_Fm->p_FmDriverParam->dmaSosEmergency                      = DEFAULT_dmaSosEmergency;
         p_Fm->p_FmDriverParam->dmaWatchdog                          = DEFAULT_dmaWatchdog;
+        p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = DEFAULT_dmaEnEmergencySmoother;
+        p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter            = DEFAULT_dmaEmergencySwitchCounter;
         p_Fm->p_FmDriverParam->thresholds.dispLimit                 = DEFAULT_dispLimit;
         p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = DEFAULT_prsDispTh;
         p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = DEFAULT_plcrDispTh;
@@ -4135,7 +4159,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = DEFAULT_qmiDeqDispTh;
         p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = DEFAULT_fmCtl1DispTh;
         p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = DEFAULT_fmCtl2DispTh;
-        p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = FALSE;
     }
     else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
@@ -4174,16 +4197,16 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->p_FmDriverParam->thresholds.dispLimit                 = (uint8_t)((tmpReg & FPM_DISP_LIMIT_MASK) << FPM_DISP_LIMIT_SHIFT);
 
         tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis1);
-        p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = (uint8_t)((tmpReg & FPM_THR1_PRS_MASK ) << FPM_THR1_PRS_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = (uint8_t)((tmpReg & FPM_THR1_KG_MASK ) << FPM_THR1_KG_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = (uint8_t)((tmpReg & FPM_THR1_PLCR_MASK ) << FPM_THR1_PLCR_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = (uint8_t)((tmpReg & FPM_THR1_BMI_MASK ) << FPM_THR1_BMI_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = (uint8_t)((tmpReg & FPM_THR1_PRS_MASK ) >> FPM_THR1_PRS_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = (uint8_t)((tmpReg & FPM_THR1_KG_MASK ) >> FPM_THR1_KG_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = (uint8_t)((tmpReg & FPM_THR1_PLCR_MASK ) >> FPM_THR1_PLCR_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = (uint8_t)((tmpReg & FPM_THR1_BMI_MASK ) >> FPM_THR1_BMI_SHIFT);
 
         tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis2);
-        p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = (uint8_t)((tmpReg & FPM_THR2_QMI_ENQ_MASK ) << FPM_THR2_QMI_ENQ_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = (uint8_t)((tmpReg & FPM_THR2_QMI_DEQ_MASK ) << FPM_THR2_QMI_DEQ_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = (uint8_t)((tmpReg & FPM_THR2_FM_CTL1_MASK ) << FPM_THR2_FM_CTL1_SHIFT);
-        p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = (uint8_t)((tmpReg & FPM_THR2_FM_CTL2_MASK ) << FPM_THR2_FM_CTL2_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = (uint8_t)((tmpReg & FPM_THR2_QMI_ENQ_MASK ) >> FPM_THR2_QMI_ENQ_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = (uint8_t)((tmpReg & FPM_THR2_QMI_DEQ_MASK ) >> FPM_THR2_QMI_DEQ_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = (uint8_t)((tmpReg & FPM_THR2_FM_CTL1_MASK ) >> FPM_THR2_FM_CTL1_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = (uint8_t)((tmpReg & FPM_THR2_FM_CTL2_MASK ) >> FPM_THR2_FM_CTL2_SHIFT);
 
         tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsetr);
         p_Fm->p_FmDriverParam->dmaSosEmergency                        = tmpReg;
@@ -4807,7 +4830,7 @@ t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    p_Fm->p_FmDriverParam->tnumAgingPeriod = tnumAgingPeriod;
+    p_Fm->tnumAgingPeriod = tnumAgingPeriod;
 
     return E_OK;
 }
@@ -5879,6 +5902,9 @@ t_Error FM_GetSpecialOperationCoding(t_Handle               h_Fm,
             case (FM_SP_OP_DCL4C):
                     *p_SpOperCoding = 7;
                     break;
+            case (FM_SP_OP_CLEAR_RPD):
+                    *p_SpOperCoding = 8;
+                    break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
         }
@@ -5896,6 +5922,9 @@ t_Error FM_CtrlMonStart(t_Handle h_Fm)
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_brkc,
+                 GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_brkc) | FPM_BRKC_RDBG);
+
     for (i = 0; i < FM_NUM_OF_CTRL; i++)
     {
         p_MonRegs = (t_FmTrbRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_TRB(i));
@@ -5931,6 +5960,9 @@ t_Error FM_CtrlMonStop(t_Handle h_Fm)
         WRITE_UINT32(p_MonRegs->tcrh, TRB_TCRH_DISABLE_COUNTERS);
     }
 
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_brkc,
+                 GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_brkc) & ~FPM_BRKC_RDBG);
+
     return E_OK;
 }
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
index 4f3ad00..5a3a005 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
@@ -170,24 +170,7 @@ switch (exception){                                         \
                                             FM_EX_QMI_DOUBLE_ECC            |\
                                             FM_EX_QMI_SINGLE_ECC)
 
-
-#define DEFAULT_totalFifoSize(major)                    \
-    (((major == 2) || (major == 5)) ?                   \
-     (100*KILOBYTE) : ((major == 6) ?                   \
-                       (288*KILOBYTE) : ((major == 4) ? \
-                                         (46*KILOBYTE) : (122*KILOBYTE))))
-
 #define DEFAULT_eccEnable                   FALSE
-#define DEFAULT_dispLimit                   0
-#define DEFAULT_prsDispTh                   16
-#define DEFAULT_plcrDispTh                  16
-#define DEFAULT_kgDispTh                    16
-#define DEFAULT_bmiDispTh                   16
-#define DEFAULT_qmiEnqDispTh                16
-#define DEFAULT_qmiDeqDispTh                16
-#define DEFAULT_fmCtl1DispTh                16
-#define DEFAULT_fmCtl2DispTh                16
-#define DEFAULT_cacheOverride               e_FM_DMA_NO_CACHE_OR
 #ifdef FM_PEDANTIC_DMA
 #define DEFAULT_aidOverride                 TRUE
 #else
@@ -197,15 +180,10 @@ switch (exception){                                         \
 #define DEFAULT_dmaStopOnBusError           FALSE
 #define DEFAULT_stopAtBusError              FALSE
 #define DEFAULT_axiDbgNumOfBeats            1
-#define DEFAULT_dmaCamNumOfEntries          32
-#define DEFAULT_dmaCommQLow                 ((DMA_THRESH_MAX_COMMQ+1)/2)
-#define DEFAULT_dmaCommQHigh                ((DMA_THRESH_MAX_COMMQ+1)*3/4)
 #define DEFAULT_dmaReadIntBufLow            ((DMA_THRESH_MAX_BUF+1)/2)
 #define DEFAULT_dmaReadIntBufHigh           ((DMA_THRESH_MAX_BUF+1)*3/4)
 #define DEFAULT_dmaWriteIntBufLow           ((DMA_THRESH_MAX_BUF+1)/2)
 #define DEFAULT_dmaWriteIntBufHigh          ((DMA_THRESH_MAX_BUF+1)*3/4)
-#define DEFAULT_dmaSosEmergency             0
-#define DEFAULT_dmaDbgCntMode               e_FM_DMA_DBG_NO_CNT
 #define DEFAULT_catastrophicErr             e_FM_CATASTROPHIC_ERR_STALL_PORT
 #define DEFAULT_dmaErr                      e_FM_DMA_ERR_CATASTROPHIC
 #define DEFAULT_resetOnInit                 FALSE
@@ -214,7 +192,62 @@ switch (exception){                                         \
 #define DEFAULT_externalEccRamsEnable       FALSE
 #define DEFAULT_VerifyUcode                 FALSE
 #define DEFAULT_tnumAgingPeriod             0
+
+#if (DPAA_VERSION < 11)
+#define DEFAULT_totalFifoSize(major)    \
+    (((major == 2) || (major == 5)) ?   \
+     (100*KILOBYTE) : ((major == 4) ?   \
+     (46*KILOBYTE) : (122*KILOBYTE)))
+#define DEFAULT_totalNumOfTasks             BMI_MAX_NUM_OF_TASKS
+
+#define DEFAULT_dmaCommQLow                 ((DMA_THRESH_MAX_COMMQ+1)/2)
+#define DEFAULT_dmaCommQHigh                ((DMA_THRESH_MAX_COMMQ+1)*3/4)
+#define DEFAULT_cacheOverride               e_FM_DMA_NO_CACHE_OR
+#define DEFAULT_dmaCamNumOfEntries          32
+#define DEFAULT_dmaDbgCntMode               e_FM_DMA_DBG_NO_CNT
+#define DEFAULT_dmaEnEmergency              FALSE
+#define DEFAULT_dmaSosEmergency             0
+#define DEFAULT_dmaWatchdog                 0 /* disabled */
+#define DEFAULT_dmaEnEmergencySmoother      FALSE
+#define DEFAULT_dmaEmergencySwitchCounter   0
+
+#define DEFAULT_dispLimit                   0
+#define DEFAULT_prsDispTh                   16
+#define DEFAULT_plcrDispTh                  16
+#define DEFAULT_kgDispTh                    16
+#define DEFAULT_bmiDispTh                   16
+#define DEFAULT_qmiEnqDispTh                16
+#define DEFAULT_qmiDeqDispTh                16
+#define DEFAULT_fmCtl1DispTh                16
+#define DEFAULT_fmCtl2DispTh                16
+
+#else  /* (DPAA_VERSION < 11) */
+/* Defaults are registers' reset values */
+#define DEFAULT_totalFifoSize(major)        (295 * KILOBYTE )
+#define DEFAULT_totalNumOfTasks             124
+
+#define DEFAULT_dmaCommQLow                 0x2A
+#define DEFAULT_dmaCommQHigh                0x3F
+#define DEFAULT_cacheOverride               e_FM_DMA_NO_CACHE_OR
+#define DEFAULT_dmaCamNumOfEntries          64
+#define DEFAULT_dmaDbgCntMode               e_FM_DMA_DBG_NO_CNT
+#define DEFAULT_dmaEnEmergency              FALSE
+#define DEFAULT_dmaSosEmergency             0
 #define DEFAULT_dmaWatchdog                 0 /* disabled */
+#define DEFAULT_dmaEnEmergencySmoother      FALSE
+#define DEFAULT_dmaEmergencySwitchCounter   0
+
+#define DEFAULT_dispLimit                   0
+#define DEFAULT_prsDispTh                   16
+#define DEFAULT_plcrDispTh                  16
+#define DEFAULT_kgDispTh                    16
+#define DEFAULT_bmiDispTh                   16
+#define DEFAULT_qmiEnqDispTh                16
+#define DEFAULT_qmiDeqDispTh                16
+#define DEFAULT_fmCtl1DispTh                16
+#define DEFAULT_fmCtl2DispTh                16
+#endif /* (DPAA_VERSION < 11) */
+
 
 #define FM_TIMESTAMP_1_USEC_BIT             8
 
@@ -529,6 +562,10 @@ typedef _Packed struct t_FmTrbRegs
 
 #define DMA_EMSR_EMSTR_MASK                 0x0000FFFF
 
+#define DMA_THRESH_COMMQ_MASK               0xFF000000
+#define DMA_THRESH_READ_INT_BUF_MASK        0x007F0000
+#define DMA_THRESH_WRITE_INT_BUF_MASK       0x0000007F
+
 /* shifts */
 #define DMA_MODE_CACHE_OR_SHIFT             30
 #define DMA_MODE_BUS_PRI_SHIFT              16
@@ -624,6 +661,8 @@ typedef _Packed struct t_FmTrbRegs
 #define FPM_THR2_FM_CTL1_MASK           0x00FF0000
 #define FPM_THR2_FM_CTL2_MASK           0x0000FF00
 
+#define FPM_BRKC_RDBG                   0x00000200
+
 /* shifts */
 #define FPM_DISP_LIMIT_SHIFT            24
 
@@ -767,7 +806,6 @@ typedef struct
     bool                        enMuramTestMode;
     bool                        enIramTestMode;
     bool                        externalEccRamsEnable;
-    uint16_t                    tnumAgingPeriod;
     t_FmFirmwareParams          firmware;
     bool                        fwVerify;
     uint32_t                    userSetExceptions;
@@ -872,6 +910,7 @@ typedef struct t_Fm
     t_Handle                    h_Spinlock;
     bool                        recoveryMode;
     t_FmStateStruct             *p_FmStateStruct;
+    uint16_t                    tnumAgingPeriod;
 #if (DPAA_VERSION >= 11)
     t_FmSp                      *p_FmSp;
     uint8_t                     partNumOfVSPs;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
index 6476c7a..288d018 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
@@ -220,7 +220,7 @@ typedef struct {
     uint8_t             prOffset;
     uint16_t            dataOffset;
   //  uint8_t             poolIndex;
-  //  uint8_t             poolIdForManip;
+    uint8_t             internalBufferOffset;
     uint8_t             numOfTasks;
     uint8_t             numOfExtraTasks;
     uint8_t             hardwarePortId;
@@ -276,7 +276,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 *//***************************************************************************/
 #define INTERNAL_CONTEXT_OFFSET                 0x80000000
 #define OFFSET_OF_PR                            0x40000000
-//#define BUFFER_POOL_ID_FOR_MANIP                0x20000000
+#define MANIP_EXTRA_SPACE                       0x20000000
 #define NUM_OF_TASKS                            0x10000000
 #define OFFSET_OF_DATA                          0x08000000
 #define HW_PORT_ID                              0x04000000
@@ -520,6 +520,7 @@ do {
     else ASSERT_COND(FALSE);                                                                                    \
 } while (0)
 
+#define BMI_MAX_FIFO_SIZE                   (FM_MURAM_SIZE)
 #define BMI_FIFO_UNITS                      0x100
 
 typedef struct {
@@ -613,6 +614,7 @@ t_Error     FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommon
 bool        FmPcdIsAdvancedOffloadSupported(t_Handle h_FmPcd);
 bool        FmPcdLockTryLockAll(t_Handle h_FmPcd);
 void        FmPcdLockUnlockAll(t_Handle h_FmPcd);
+t_Error     FmPcdHcSync(t_Handle h_FmPcd);
 
 /***********************************************************************/
 /*          Common API for FM-PCD KG module                            */
@@ -896,9 +898,13 @@ void FmGetPhysicalMuramBase(t_Handle h_Fm, t_FmPhysAddr *fmPhysAddr);
  @Description   Used internally by other modules in order to get the timeStamp
                 period as requested by the application.
 
+                This function returns bit number that is incremented every 1 usec.
+                To calculate timestamp period in nsec, use
+                1000 / (1 << FmGetTimeStampScale()).
+
  @Param[in]     h_Fm                    A handle to an FM Module.
 
- @Return        TimeStamp period in nanoseconds.
+ @Return        Bit that counts 1 usec.
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
@@ -1051,6 +1057,8 @@ void        FmUnregisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId);
 t_Error     FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_t mtu);
 bool        FmIsMaster(t_Handle h_Fm);
 uint8_t     FmGetGuestId(t_Handle h_Fm);
+uint16_t    FmGetTnumAgingPeriod(t_Handle h_Fm);
+
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 t_Error     Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId);
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h
index db2d60b..f6a1bb2 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_hc.h
@@ -49,7 +49,6 @@ typedef struct t_FmHcParams {
 
 
 t_Handle    FmHcConfigAndInit(t_FmHcParams *p_FmHcParams);
-t_Handle    FmGcGetHcPortDevH(t_Handle h_FmHc);
 void        FmHcFree(t_Handle h_FmHc);
 t_Error     FmHcSetFramesDataMemory(t_Handle h_FmHc,
                                     uint8_t  memId);
@@ -85,6 +84,8 @@ t_Error     FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cpp
 t_Error     FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t requiredAction, uint32_t value);
 t_Error     FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, uint32_t requiredAction);
 
+t_Error     FmHcPcdSync(t_Handle h_FmHc);
+
 
 
 #endif /* __FM_HC_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_sp_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_sp_common.h
index 0675444..f9dd384 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_sp_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_sp_common.h
@@ -45,15 +45,7 @@
 
 #include "fm_ext.h"
 #include "fm_pcd_ext.h"
-
-
-/* sizes */
-#define CAPWAP_FRAG_EXTRA_SPACE                 32
-#define OFFSET_UNITS                            16
-#define MAX_INT_OFFSET                          240
-#define MAX_IC_SIZE                             256
-#define MAX_EXT_OFFSET                          496
-#define MAX_EXT_BUFFER_OFFSET                   511
+#include "fsl_fman.h"
 
 /**************************************************************************//**
  @Description       defaults
@@ -63,35 +55,6 @@
 #define DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp     FALSE
 #define DEFAULT_FM_SP_bufferPrefixContent_allOtherPCDInfo   FALSE
 #define DEFAULT_FM_SP_bufferPrefixContent_dataAlign         64
-#define DEFAULT_FM_SP_dmaSwapData                           e_FM_DMA_NO_SWP
-#define DEFAULT_FM_SP_dmaIntContextCacheAttr                e_FM_DMA_NO_STASH
-#define DEFAULT_FM_SP_dmaHeaderCacheAttr                    e_FM_DMA_NO_STASH
-#define DEFAULT_FM_SP_dmaScatterGatherCacheAttr             e_FM_DMA_NO_STASH
-#define DEFAULT_FM_SP_dmaWriteOptimize                      TRUE
-#define DEFAULT_FM_SP_noScatherGather                       FALSE
-
-/**************************************************************************//**
- @Description       Registers bit fields
-*//***************************************************************************/
-#define FM_SP_EXT_BUF_POOL_EN_COUNTER             0x40000000
-#define FM_SP_EXT_BUF_POOL_VALID                  0x80000000
-#define FM_SP_EXT_BUF_POOL_BACKUP                 0x20000000
-#define FM_SP_DMA_ATTR_WRITE_OPTIMIZE             0x00100000
-#define FM_SP_SG_DISABLE                          0x80000000
-
-/* shifts */
-#define FM_SP_EXT_BUF_POOL_ID_SHIFT               16
-#define FM_SP_POOL_DEP_NUM_OF_POOLS_SHIFT         16
-#define FM_SP_EXT_BUF_MARG_START_SHIFT            16
-#define FM_SP_EXT_BUF_MARG_END_SHIFT              0
-#define FM_SP_DMA_ATTR_SWP_SHIFT                  30
-#define FM_SP_DMA_ATTR_IC_CACHE_SHIFT             28
-#define FM_SP_DMA_ATTR_HDR_CACHE_SHIFT            26
-#define FM_SP_DMA_ATTR_SG_CACHE_SHIFT             24
-#define FM_SP_IC_TO_EXT_SHIFT                     16
-#define FM_SP_IC_FROM_INT_SHIFT                   8
-#define FM_SP_IC_SIZE_SHIFT                       0
-
 
 /**************************************************************************//**
  @Description   structure for defining internal context copying
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
index 6acf50b..a45682f 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_ext.h
@@ -42,7 +42,7 @@
 #include "error_ext.h"
 #include "std_ext.h"
 #include "dpaa_ext.h"
-
+#include "fsl_fman_sp.h"
 
 /**************************************************************************//**
  @Group         FM_grp Frame Manager API
@@ -55,7 +55,7 @@
 /**************************************************************************//**
  @Group         FM_lib_grp FM library
 
- @Description   FM API functions, definitions and enums
+ @Description   FM API functions, definitions and enums.
 
                 The FM module is the main driver module and is a mandatory module
                 for FM driver users. This module must be initialized first prior
@@ -235,6 +235,7 @@ typedef uint32_t fmSpecialOperations_t;                 /**< typedef for definin
 #define  FM_SP_OP_RPD                       0x10000000  /**< Set the RPD bit */
 #define  FM_SP_OP_DCL4C                     0x08000000  /**< Set the DCL4C bit */
 #define  FM_SP_OP_CHECK_SEC_ERRORS          0x04000000  /**< Check SEC errors */
+#define  FM_SP_OP_CLEAR_RPD                 0x02000000  /**< Clear the RPD bit */
 /* @} */
 
 /**************************************************************************//**
@@ -309,19 +310,19 @@ typedef enum e_FmExceptions {
  @Description   Enum for defining port DMA swap mode
 *//***************************************************************************/
 typedef enum e_FmDmaSwapOption {
-    e_FM_DMA_NO_SWP,           /**< No swap, transfer data as is.*/
-    e_FM_DMA_SWP_PPC_LE,       /**< The transferred data should be swapped
-                                    in PowerPc Little Endian mode. */
-    e_FM_DMA_SWP_BE            /**< The transferred data should be swapped
-                                    in Big Endian mode */
+    e_FM_DMA_NO_SWP = FMAN_DMA_NO_SWP, 			/**< No swap, transfer data as is.*/
+    e_FM_DMA_SWP_PPC_LE = FMAN_DMA_SWP_PPC_LE, 	/**< The transferred data should be swapped
+                                    			in PowerPc Little Endian mode. */
+    e_FM_DMA_SWP_BE = FMAN_DMA_SWP_BE 			/**< The transferred data should be swapped
+                                    			in Big Endian mode */
 } e_FmDmaSwapOption;
 
 /**************************************************************************//**
  @Description   Enum for defining port DMA cache attributes
 *//***************************************************************************/
 typedef enum e_FmDmaCacheOption {
-    e_FM_DMA_NO_STASH = 0,     /**< Cacheable, no Allocate (No Stashing) */
-    e_FM_DMA_STASH = 1         /**< Cacheable and Allocate (Stashing on) */
+    e_FM_DMA_NO_STASH = FMAN_DMA_NO_STASH,     	/**< Cacheable, no Allocate (No Stashing) */
+    e_FM_DMA_STASH = FMAN_DMA_STASH         	/**< Cacheable and Allocate (Stashing on) */
 } e_FmDmaCacheOption;
 
 
@@ -391,7 +392,7 @@ typedef struct t_FmBufferPrefixContent {
                                          get the parser-result from a buffer. */
     bool        passAllOtherPCDInfo;/**< Add all other Internal-Context information:
                                          AD, hash-result, key, etc. */
-    uint16_t    dataAlign;          /**< 0 to use driver's default alignment [64],
+    uint16_t    dataAlign;          /**< 0 to use driver's default alignment [DEFAULT_FM_SP_bufferPrefixContent_dataAlign],
                                          other value for selecting a data alignment (must be a power of 2);
                                          if write optimization is used, must be >= 16. */
     uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size);
@@ -684,7 +685,7 @@ typedef struct t_FmDmaThresholds {
  @Function      FM_ConfigResetOnInit
 
  @Description   Define whether to reset the FM before initialization.
-                Change the default configuration [FALSE].
+                Change the default configuration [DEFAULT_resetOnInit].
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     enable              When TRUE, FM will be reset before any initialization.
@@ -702,7 +703,7 @@ t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
 
  @Description   Define Total FIFO size for the whole FM.
                 Calling this routine changes the total Fifo size in the internal driver
-                data base from its default configuration [major]
+                data base from its default configuration [DEFAULT_totalFifoSize]
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     totalFifoSize       The selected new value.
@@ -720,7 +721,7 @@ t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
 
  @Description   Define cache override mode.
                 Calling this routine changes the cache override mode
-                in the internal driver data base from its default configuration [e_FM_DMA_NO_CACHE_OR]
+                in the internal driver data base from its default configuration [DEFAULT_cacheOverride]
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     cacheOverride   The selected new value.
@@ -738,7 +739,7 @@ t_Error FM_ConfigDmaCacheOverride(t_Handle h_Fm, e_FmDmaCacheOverride cacheOverr
 
  @Description   Define DMA AID override mode.
                 Calling this routine changes the AID override mode
-                in the internal driver data base from its default configuration  [TRUE]
+                in the internal driver data base from its default configuration  [DEFAULT_aidOverride]
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     aidOverride     The selected new value.
@@ -756,7 +757,7 @@ t_Error FM_ConfigDmaAidOverride(t_Handle h_Fm, bool aidOverride);
 
  @Description   Define DMA AID  mode.
                 Calling this routine changes the AID  mode in the internal
-                driver data base from its default configuration [e_FM_DMA_AID_OUT_TNUM]
+                driver data base from its default configuration [DEFAULT_aidMode]
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     aidMode         The selected new value.
@@ -774,7 +775,7 @@ t_Error FM_ConfigDmaAidMode(t_Handle h_Fm, e_FmDmaAidMode aidMode);
 
  @Description   Define DMA AXI number of beats.
                 Calling this routine changes the AXI number of beats in the internal
-                driver data base from its default configuration [1]
+                driver data base from its default configuration [DEFAULT_axiDbgNumOfBeats]
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     axiDbgNumOfBeats    The selected new value.
@@ -792,7 +793,7 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats);
 
  @Description   Define number of CAM entries.
                 Calling this routine changes the number of CAM entries in the internal
-                driver data base from its default configuration [32].
+                driver data base from its default configuration [DEFAULT_dmaCamNumOfEntries].
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     numOfEntries    The selected new value.
@@ -821,7 +822,7 @@ t_Error FM_ConfigEnableCounters(t_Handle h_Fm);
 
  @Description   Define DMA debug counter.
                 Calling this routine changes the number of the DMA debug counter in the internal
-                driver data base from its default configuration [e_FM_DMA_DBG_NO_CNT].
+                driver data base from its default configuration [DEFAULT_dmaDbgCntMode].
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     fmDmaDbgCntMode     An enum selecting the debug counter mode.
@@ -840,7 +841,7 @@ t_Error FM_ConfigDmaDbgCounter(t_Handle h_Fm, e_FmDmaDbgCntMode fmDmaDbgCntMode)
  @Description   Define bus error behavior.
                 Calling this routine changes the bus error behavior definition
                 in the internal driver data base from its default
-                configuration [FALSE].
+                configuration [DEFAULT_dmaStopOnBusError].
 
  @Param[in]     h_Fm    A handle to an FM Module.
  @Param[in]     stop    TRUE to stop on bus error, FALSE to continue.
@@ -879,7 +880,7 @@ t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency);
  @Description   DMA error treatment.
                 Calling this routine changes the DMA error treatment
                 in the internal driver data base from its default
-                configuration [e_FM_DMA_ERR_CATASTROPHIC].
+                configuration [DEFAULT_dmaErr].
 
  @Param[in]     h_Fm    A handle to an FM Module.
  @Param[in]     dmaErr  The selected new choice.
@@ -898,7 +899,7 @@ t_Error FM_ConfigDmaErr(t_Handle h_Fm, e_FmDmaErr dmaErr);
  @Description   Define FM behavior on catastrophic error.
                 Calling this routine changes the FM behavior on catastrophic
                 error in the internal driver data base from its default
-                [e_FM_CATASTROPHIC_ERR_STALL_PORT].
+                [DEFAULT_catastrophicErr].
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     catastrophicErr     The selected new choice.
@@ -953,7 +954,7 @@ t_Error FM_ConfigEnableIramTestMode(t_Handle h_Fm);
  @Description   Define FM behavior on external halt activation.
                 Calling this routine changes the FM behavior on external halt
                 activation in the internal driver data base from its default
-                [FALSE].
+                [DEFAULT_haltOnExternalActivation].
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     enable          TRUE to enable halt on external halt
@@ -973,7 +974,7 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable);
  @Description   Define FM behavior on external halt activation.
                 Calling this routine changes the FM behavior on unrecoverable
                 ECC error in the internal driver data base from its default
-                [FALSE].
+                [DEFAULT_haltOnUnrecoverableEccError].
                 This routine is only avaiable on old FM revisions (FMan v2).
 
  @Param[in]     h_Fm            A handle to an FM Module.
@@ -1011,7 +1012,7 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 
  @Description   Select external ECC enabling.
                 Calling this routine changes the ECC enabling control in the internal
-                driver data base from its default [FALSE].
+                driver data base from its default [DEFAULT_externalEccRamsEnable].
                 When this option is enabled Rams ECC enabling is not effected
                 by FM_EnableRamsEcc/FM_DisableRamsEcc, but by a JTAG.
 
@@ -1030,9 +1031,9 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
  @Function      FM_ConfigTnumAgingPeriod
 
  @Description   Define Tnum aging period.
-                Calling this routine changes the Tnum aging of dequeue TNUM's
+                Calling this routine changes the Tnum aging of dequeue TNUMs
                 in the QMI in the internal driver data base from its default
-                [0].
+                [DEFAULT_tnumAgingPeriod].
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     tnumAgingPeriod     Tnum Aging Period in microseconds.
@@ -1045,6 +1046,8 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
  @Cautions      Allowed only following FM_Config() and before FM_Init().
                 This routine should NOT be called from guest-partition
                 (i.e. guestId != NCSW_MASTER_ID)
+                NOTE that if some MAC is configured for PFC, '0' value is NOT
+                allowed.
 *//***************************************************************************/
 t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
 
@@ -1073,15 +1076,15 @@ t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
 
  @Description   Calling this routine changes the internal driver data base
                 from its default FM threshold configuration:
-                    dispLimit:    [0]
-                    prsDispTh:    [16]
-                    plcrDispTh:   [16]
-                    kgDispTh:     [16]
-                    bmiDispTh:    [16]
-                    qmiEnqDispTh: [16]
-                    qmiDeqDispTh: [16]
-                    fmCtl1DispTh: [16]
-                    fmCtl2DispTh: [16]
+                    dispLimit:    [DEFAULT_dispLimit]
+                    prsDispTh:    [DEFAULT_prsDispTh]
+                    plcrDispTh:   [DEFAULT_plcrDispTh]
+                    kgDispTh:     [DEFAULT_kgDispTh]
+                    bmiDispTh:    [DEFAULT_bmiDispTh]
+                    qmiEnqDispTh: [DEFAULT_qmiEnqDispTh]
+                    qmiDeqDispTh: [DEFAULT_qmiDeqDispTh]
+                    fmCtl1DispTh: [DEFAULT_fmCtl1DispTh]
+                    fmCtl2DispTh: [DEFAULT_fmCtl2DispTh]
 
 
  @Param[in]     h_Fm            A handle to an FM Module.
@@ -1099,7 +1102,7 @@ t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
  @Function      FM_ConfigDmaSosEmergencyThreshold
 
  @Description   Calling this routine changes the internal driver data base
-                from its default dma SOS emergency configuration [0]
+                from its default dma SOS emergency configuration [DEFAULT_dmaSosEmergency]
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     dmaSosEmergency     The selected new value.
@@ -1117,8 +1120,8 @@ t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergenc
 
  @Description   Calling this routine changes the internal driver data base
                 from its default configuration of DMA write buffer threshold
-                assertEmergency: [DMA_THRESH_MAX_BUF]
-                clearEmergency:  [DMA_THRESH_MAX_BUF]
+                assertEmergency: [DEFAULT_dmaWriteIntBufLow]
+                clearEmergency:  [DEFAULT_dmaWriteIntBufHigh]
                 This routine is only avaiable on old FM revisions (FMan v2).
 
  @Param[in]     h_Fm                A handle to an FM Module.
@@ -1139,8 +1142,8 @@ t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDma
 
  @Description   Calling this routine changes the internal driver data base
                 from its default configuration of DMA command queue threshold
-                assertEmergency: [DMA_THRESH_MAX_COMMQ]
-                clearEmergency:  [DMA_THRESH_MAX_COMMQ]
+                assertEmergency: [DEFAULT_dmaCommQLow]
+                clearEmergency:  [DEFAULT_dmaCommQHigh]
 
  @Param[in]     h_Fm                A handle to an FM Module.
  @Param[in]     p_FmDmaThresholds   A structure of thresholds to define emergency behavior -
@@ -1160,8 +1163,8 @@ t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThr
 
  @Description   Calling this routine changes the internal driver data base
                 from its default configuration of DMA read buffer threshold
-                assertEmergency: [DMA_THRESH_MAX_BUF]
-                clearEmergency:  [DMA_THRESH_MAX_BUF]
+                assertEmergency: [DEFAULT_dmaReadIntBufLow]
+                clearEmergency:  [DEFAULT_dmaReadIntBufHigh]
                 This routine is only avaiable on old FM revisions (FMan v2).
 
  @Param[in]     h_Fm                A handle to an FM Module.
@@ -1182,7 +1185,7 @@ t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaT
 
  @Description   Calling this routine changes the internal driver data base
                 from its default watchdog configuration, which is disabled
-                [0].
+                [DEFAULT_dmaWatchdog].
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     watchDogValue   The selected new value - in microseconds.
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h
index 614622e..94b305c 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_mac_ext.h
@@ -101,6 +101,8 @@ typedef enum e_FmMacExceptions {
    ,e_FM_MAC_EX_1G_RX_DATA_ERR                                  /**< dTSEC Internal data error on receive */
    ,e_FM_MAC_EX_1G_1588_TS_RX_ERR                               /**< dTSEC Time-Stamp Receive Error */
    ,e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL                              /**< dTSEC MIB counter overflow */
+   ,e_FM_MAC_EX_TS_FIFO_ECC_ERR                                 /**< mEMAC Time-stamp FIFO ECC error interrupt;
+                                                                     not supported on T4240/B4860 rev1 chips */
 } e_FmMacExceptions;
 
 /**************************************************************************//**
@@ -211,9 +213,14 @@ typedef struct t_FmMacParams {
     uint8_t                     macId;              /**< MAC ID <dTSEC 0-3> <10G-MAC 0>      */
     e_EnetMode                  enetMode;           /**< Ethernet operation mode (MAC-PHY interface and speed);
                                                          Note that the speed should indicate the maximum rate that
-                                                         this MAC should support rather than the actuall speed;
+                                                         this MAC should support rather than the actual speed;
                                                          i.e. user should use the FM_MAC_AdjustLink() routine to
                                                          provide accurate speed;
+                                                         In case of mEMAC RGMII mode, the MAC is configured to RGMII
+                                                         automatic mode, where actual speed/duplex mode information
+                                                         is provided by PHY automatically in-band; FM_MAC_AdjustLink()
+                                                         function should be used to switch to manual RGMII speed/duplex mode
+                                                         configuration if RGMII PHY doesn't support in-band status signaling;
                                                          In addition, in mEMAC, in case where user is using the higher MACs
                                                          (i.e. the MACs that should support 10G), user should pass here
                                                          speed=10000 even if the interface is not allowing that (e.g. SGMII). */
@@ -283,7 +290,7 @@ t_Error  FM_MAC_Free(t_Handle h_FmMac);
  @Function      FM_MAC_ConfigResetOnInit
 
  @Description   Tell the driver whether to reset the FM MAC before initialization or
-                not. It changes the default configuration [FALSE].
+                not. It changes the default configuration [DEFAULT_resetOnInit].
 
  @Param[in]     h_FmMac    A handle to a FM MAC Module.
  @Param[in]     enable     When TRUE, FM will be reset before any initialization.
@@ -483,7 +490,7 @@ t_Error FM_MAC_Disable1588TimeStamp(t_Handle h_Fm);
  @Function      FM_MAC_SetTxAutoPauseFrames
 
  @Description   Enable/Disable transmission of Pause-Frames.
-                The routine changes the default configuration [0xf000].
+                The routine changes the default configuration [DEFAULT_TX_PAUSE_TIME].
 
  @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
  @Param[in]     pauseTime     -  Pause quanta value used with transmitted pause frames.
@@ -503,7 +510,7 @@ t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
 
  @Description   Enable/Disable transmission of Pause-Frames.
                 The routine changes the default configuration:
-                pause-time - [0xf000]
+                pause-time - [DEFAULT_TX_PAUSE_TIME]
                 threshold-time - [0]
 
  @Param[in]     h_FmMac       -  A handle to a FM MAC Module.
@@ -521,6 +528,9 @@ t_Error FM_MAC_SetTxAutoPauseFrames(t_Handle h_FmMac,
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Init().
+                In order for PFC to work properly the user must configure
+                TNUM-aging in the tx-port it is recommended that pre-fetch and
+                rate limit in the tx port should be disabled;
                 PFC is supported only on new mEMAC; i.e. in MACs that don't have
                 PFC support (10G-MAC and dTSEC), user should use 'FM_MAC_NO_PFC'
                 in the 'priority' field.
@@ -699,12 +709,16 @@ t_Error FM_MAC_SetPromiscuous(t_Handle h_FmMac, bool enable);
  @Function      FM_MAC_AdjustLink
 
  @Description   Adjusts the Ethernet link with new speed/duplex setup.
-                This routine is relevant only for dTSEC.
+                This routine is relevant for dTSEC and mEMAC.
+                In case of mEMAC, this routine is also used for manual
+                re-configuration of RGMII speed and duplex mode for
+                RGMII PHYs not supporting in-band status information
+                to MAC.
 
  @Param[in]     h_FmMac     - A handle to a FM Module.
  @Param[in]     speed       - Ethernet speed.
- @Param[in]     fullDuplex  - TRUE for Full-Duplex mode;
-                              FALSE for Half-Duplex mode.
+ @Param[in]     fullDuplex  - TRUE for full-duplex mode;
+                              FALSE for half-duplex mode.
 
  @Return        E_OK on success; Error code otherwise.
 *//***************************************************************************/
@@ -713,13 +727,13 @@ t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex);
 /**************************************************************************//**
  @Function      FM_MAC_RestartAutoneg
 
- @Description   Restarts the autonegotiation process.
-                When autonegegotiation process is invoked under traffic the
-                autonegotiation process between the internal TBI PHY and the
-                external PHY does not always complete succesfuly. Calling this
-                function will restart the autonegotiation process that will end
-                succesfuly. It is recomended to call this function after issuing
-                autoneg restart command to the Eth Phy.
+ @Description   Restarts the auto-negotiation process.
+                When auto-negotiation process is invoked under traffic the
+                auto-negotiation process between the internal SGMII PHY and the
+                external PHY does not always complete successfully. Calling this
+                function will restart the auto-negotiation process that will end
+                successfully. It is recommended to call this function after issuing
+                auto-negotiation restart command to the Eth Phy.
                 This routine is relevant only for dTSEC.
 
  @Param[in]     h_FmMac     - A handle to a FM Module.
@@ -807,13 +821,5 @@ t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
 /** @} */ /* end of FM_mac_grp group */
 /** @} */ /* end of FM_grp group */
 
-/**************************************************************************//**
- @Function      DtsecRestartTbiAN
-
- @Description   Restart TBI autonegotiation for a given Dtsec TBI interface.
-
- @Param[in]     h_Dtsec     -   A handle to the Dtsec.
-*//***************************************************************************/
-void DtsecRestartTbiAN(t_Handle h_Dtsec);
 
 #endif /* __FM_MAC_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
index f4dfd63..60edfd2 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_pcd_ext.h
@@ -66,7 +66,7 @@
                 and the policer global and common registers.
                 In addition, the FM PCD SW module will initialize all required
                 key generator schemes, coarse classification flows, and policer
-                profiles. When a FM module is configured to work with one of these
+                profiles. When FM module is configured to work with one of these
                 entities, it will register to it using the FM PORT API. The PCD
                 module will manage the PCD resources - i.e. resource management of
                 KeyGen schemes, etc.
@@ -275,8 +275,6 @@ typedef struct t_FmPcdParams {
 *//***************************************************************************/
 t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams);
 
-t_Handle FM_PCD_GetHcDevH(t_Handle h_FmPcd);
-
 /**************************************************************************//**
  @Function      FM_PCD_Init
 
@@ -314,7 +312,7 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd);
 
  @Description   Calling this routine changes the internal driver data base
                 from its default selection of exceptions enabling.
-                [4].
+                [DEFAULT_numOfSharedPlcrProfiles].
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     exception       The exception to be selected.
@@ -349,7 +347,7 @@ t_Error FM_PCD_ConfigHcFramesDataMemory(t_Handle h_FmPcd, uint8_t memId);
 
  @Description   Calling this routine changes the internal driver data base
                 from its default selection of exceptions enablement.
-                [4].
+                [DEFAULT_numOfSharedPlcrProfiles].
 
  @Param[in]     h_FmPcd                     FM PCD module descriptor.
  @Param[in]     numOfSharedPlcrProfiles     Number of profiles to
@@ -364,7 +362,7 @@ t_Error FM_PCD_ConfigPlcrNumOfSharedProfiles(t_Handle h_FmPcd, uint16_t numOfSha
 
  @Description   Calling this routine changes the internal driver data base
                 from its default selection of exceptions enablement.
-                By default auto-refresh is [disabled].
+                By default auto-refresh is [DEFAULT_plcrAutoRefresh].
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     enable          TRUE to enable, FALSE to disable
@@ -381,7 +379,7 @@ t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable);
 
  @Description   Calling this routine changes the internal data structure for
                 the maximum parsing time from its default value
-                [0].
+                [DEFAULT_MAX_PRS_CYC_LIM].
 
  @Param[in]     h_FmPcd         FM PCD module descriptor.
  @Param[in]     value           0 to disable the mechanism, or new
@@ -812,7 +810,6 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
 #define FM_PCD_MAX_SIZE_OF_KEY                  56
 #define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
 #define FM_PCD_LAST_KEY_INDEX                   0xffff
-#define FM_PCD_MANIP_DSCP_VALUES                64
 
 #define FM_PCD_MAX_NUM_OF_CC_NODES              255 /* Obsolete, not used - will be removed in the future */
 /* @} */
@@ -1342,7 +1339,6 @@ typedef union u_FmPcdHdrProtocolOpt {
                         NET_HEADER_FIELD_UDP_PORT_SRC
                         NET_HEADER_FIELD_UDP_PORT_DST
 
-
                     HEADER_TYPE_UDP_LITE: - relevant only if FM_CAPWAP_SUPPORT define
                         NET_HEADER_FIELD_UDP_LITE_PORT_SRC
                         NET_HEADER_FIELD_UDP_LITE_PORT_DST
@@ -1937,6 +1933,8 @@ typedef struct t_FmPcdHashTableParams {
     uint16_t                    maxNumOfKeys;               /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
     e_FmPcdCcStatsMode          statisticsMode;             /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
                                                                  requested statistics mode will be allocated according to maxNumOfKeys. */
+    uint8_t                     kgHashShift;                /**< KG-Hash-shift as it was configured in the KG-scheme
+                                                                 that leads to this hash-table. */
     uint16_t                    hashResMask;                /**< Mask that will be used on the hash-result;
                                                                  The number-of-sets for this hash will be calculated
                                                                  as (2^(number of bits set in 'hashResMask'));
@@ -2260,7 +2258,7 @@ typedef struct t_FmPcdManipReassemIpParams {
                                                                  relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
                                                                  NOTE: The following comment is relevant only for FMAN v2 devices:
                                                                  Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
-                                                                 the user schemes id to ensure that the reassembly's schemes will be first match;
+                                                                 the user schemes id to ensure that the reassembly schemes will be first match;
                                                                  Rest schemes, if defined, should have higher relative scheme ID. */
 #if (DPAA_VERSION >= 11)
     uint32_t                        nonConsistentSpFqid;    /**< In case that other fragments of the frame corresponds to different storage
@@ -2286,7 +2284,8 @@ typedef struct t_FmPcdManipReassemIpParams {
                                                                  In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
                                                                  maxNumFramesInProcess has to be in the range of 8 - 2048. */
     e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
-    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process  */
+    uint32_t                        fqidForTimeOutFrames;   /**< FQID in which time out frames will enqueue during Time Out Process;
+                                                                 Recommended value for this field is 0; in this way timed-out frames will be discarded */
     uint32_t                        timeoutThresholdForReassmProcess;
                                                             /**< Represents the time interval in microseconds which defines
                                                                  if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
@@ -2583,6 +2582,10 @@ typedef struct t_FmPcdManipReassemIpStats {
     uint32_t        externalBufferBusy;         /**< Counts the number of times external buffer busy occurred */
     uint32_t        sgFragments;                /**< Counts the number of Scatter/Gather fragments */
     uint32_t        dmaSemaphoreDepletion;      /**< Counts the number of failed attempts to allocate a DMA semaphore */
+#if (DPAA_VERSION >= 11)
+    uint32_t        nonConsistentSp;            /**< Counts the number of Non Consistent Storage Profile events for
+                                                     successfully reassembled frames */
+#endif /* (DPAA_VERSION >= 11) */
     struct {
         uint32_t    successfullyReassembled;    /**< Counts the number of successfully reassembled frames */
         uint32_t    validFragments;             /**< Counts the total number of valid fragments that
@@ -3588,6 +3591,8 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcds
 #define e_FM_PCD_MANIP_ONE_WAYS_HASH            e_FM_PCD_MANIP_ONE_WAY_HASH
 #define e_FM_PCD_MANIP_TOW_WAYS_HASH            e_FM_PCD_MANIP_TWO_WAYS_HASH
 
+#define e_FM_PCD_MANIP_FRAGMENT_PACKECT         e_FM_PCD_MANIP_FRAGMENT_PACKET /* Feb13 */
+
 #define FM_PCD_SetNetEnvCharacteristics(_pcd, _params)  \
     FM_PCD_NetEnvCharacteristicsSet(_pcd, _params)
 #define FM_PCD_KgSetScheme(_pcd, _params)       FM_PCD_KgSchemeSet(_pcd, _params)
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
index afa2cd9..89fabbc 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_port_ext.h
@@ -504,8 +504,8 @@ t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
 
  @Description   Calling this routine changes the dequeue priority in the
                 internal driver data base from its default configuration
-                1G: [FALSE]
-                10G: [TRUE]
+                1G: [DEFAULT_PORT_deqHighPriority_1G]
+                10G: [DEFAULT_PORT_deqHighPriority_10G]
 
                 May be used for Non-Rx ports only
 
@@ -523,7 +523,7 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri);
 
  @Description   Calling this routine changes the dequeue type parameter in the
                 internal driver data base from its default configuration
-                [e_FM_PORT_DEQ_TYPE1].
+                [DEFAULT_PORT_deqType].
 
                 May be used for Non-Rx ports only
 
@@ -541,7 +541,7 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType);
 
  @Description   Calling this routine changes the dequeue prefetch option parameter in the
                 internal driver data base from its default configuration
-                [e_FM_PORT_DEQ_FULL_PREFETCH]
+                [DEFAULT_PORT_deqPrefetchOption]
                 Note: Available for some chips only
 
                 May be used for Non-Rx ports only
@@ -560,8 +560,8 @@ t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOp
 
  @Description   Calling this routine changes the dequeue byte count parameter in
                 the internal driver data base from its default configuration
-                1G:[0x400].
-                10G:[0x1400].
+                1G:[DEFAULT_PORT_deqByteCnt_1G].
+                10G:[DEFAULT_PORT_deqByteCnt_10G].
 
                 May be used for Non-Rx ports only
 
@@ -587,9 +587,9 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
                 application buffer, and to offset.
                 Calling this routine changes the buffer margins definitions
                 in the internal driver data base from its default
-                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
-                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
-                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
+                configuration: Data size:  [DEFAULT_PORT_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_PORT_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_PORT_bufferPrefixContent_passTimeStamp].
 
                 May be used for all ports
 
@@ -611,7 +611,7 @@ t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle                      h_FmPort
 
  @Description   Calling this routine changes the number of checksum bytes to ignore
                 parameter in the internal driver data base from its default configuration
-                [0]
+                [DEFAULT_PORT_cheksumLastBytesIgnore]
 
                 May be used by Tx & Rx ports only
 
@@ -629,7 +629,7 @@ t_Error FM_PORT_ConfigCheksumLastBytesIgnore(t_Handle h_FmPort, uint8_t cheksumL
 
  @Description   Calling this routine changes the number of bytes to cut from a
                 frame's end parameter in the internal driver data base
-                from its default configuration [4]
+                from its default configuration [DEFAULT_PORT_cutBytesFromEnd]
                 Note that if the result of (frame length before chop - cutBytesFromEnd) is
                 less than 14 bytes, the chop operation is not executed.
 
@@ -730,7 +730,7 @@ t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_FmPort
 
  @Description   Calling this routine changes the error frames destination parameter
                 in the internal driver data base from its default configuration:
-                override = [FALSE]
+                override = [DEFAULT_PORT_frmDiscardOverride]
 
                 May be used for Rx and OP ports only
 
@@ -749,7 +749,7 @@ t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
 
  @Description   Calling this routine changes the behaviour on error parameter
                 in the internal driver data base from its default configuration:
-                [FM_PORT_FRM_ERR_CLS_DISCARD].
+                [DEFAULT_PORT_errorsToDiscard].
                 If a requested error was previously defined as "ErrorsToEnqueue" it's
                 definition will change and the frame will be discarded.
                 Errors that were not defined either as "ErrorsToEnqueue" nor as
@@ -771,7 +771,7 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
 
  @Description   Calling this routine changes the DMA swap data aparameter
                 in the internal driver data base from its default
-                configuration  [DEFAULT_FM_SP_dmaSwapData]
+                configuration  [DEFAULT_PORT_dmaSwapData]
 
                 May be used for all port types
 
@@ -789,7 +789,7 @@ t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData)
 
  @Description   Calling this routine changes the internal context cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_FM_SP_dmaIntContextCacheAttr]
+                from its default configuration  [DEFAULT_PORT_dmaIntContextCacheAttr]
 
                 May be used for all port types
 
@@ -807,7 +807,7 @@ t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intCo
 
  @Description   Calling this routine changes the header cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_FM_SP_dmaHeaderCacheAttr]
+                from its default configuration  [DEFAULT_PORT_dmaHeaderCacheAttr]
 
                 May be used for all port types
 
@@ -825,7 +825,7 @@ t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCac
 
  @Description   Calling this routine changes the scatter gather cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [DEFAULT_FM_SP_dmaScatterGatherCacheAttr]
+                from its default configuration  [DEFAULT_PORT_dmaScatterGatherCacheAttr]
 
                 May be used for all port types
 
@@ -843,7 +843,7 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
 
  @Description   Calling this routine changes the write optimization
                 parameter in the internal driver data base
-                from its default configuration:  By default optimize = [DEFAULT_FM_SP_dmaWriteOptimize].
+                from its default configuration:  By default optimize = [DEFAULT_PORT_dmaWriteOptimize].
                 Note:
 
                 1. For head optimization, data alignment must be >= 16 (supported by default).
@@ -852,7 +852,6 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
                 of the frame payload at the tail as needed to achieve optimal bus transfers, so that the last write
                 is extended to be on 16/64 bytes aligned block (chip dependent).
 
-
                 Relevant for non-Tx port types
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
@@ -885,7 +884,7 @@ t_Error FM_PORT_ConfigNoScatherGather(t_Handle h_FmPort, bool noScatherGather);
 
  @Description   Calling this routine changes the internal default color parameter
                 in the internal driver data base
-                from its default configuration  [e_FM_PORT_COLOR_GREEN]
+                from its default configuration  [DEFAULT_PORT_color]
 
                 May be used for all port types
 
@@ -903,7 +902,7 @@ t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color);
 
  @Description   Calling this routine changes the synchronization attribute parameter
                 in the internal driver data base from its default configuration:
-                syncReq = [TRUE]
+                syncReq = [DEFAULT_PORT_syncReq]
 
                 May be used for all port types
 
@@ -922,7 +921,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
  @Description   This routine is relevant for Rx ports that are routed to OP port.
                 It changes the internal context reuse option in the internal
                 driver data base from its default configuration:
-                reuse = [FALSE]
+                reuse = [DEFAULT_PORT_forwardIntContextReuse]
 
                 May be used for Rx ports only
 
@@ -988,7 +987,7 @@ t_Error FM_PORT_ConfigIMMaxRxBufLength(t_Handle h_FmPort, uint16_t newVal);
  @Function      FM_PORT_ConfigIMRxBdRingLength
 
  @Description   Changes the receive BD ring length from its default
-                configuration:[128]
+                configuration:[DEFAULT_PORT_rxBdRingLength]
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     newVal          The desired BD ring length.
@@ -1004,7 +1003,7 @@ t_Error FM_PORT_ConfigIMRxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
  @Function      FM_PORT_ConfigIMTxBdRingLength
 
  @Description   Changes the transmit BD ring length from its default
-                configuration:[16]
+                configuration:[DEFAULT_PORT_txBdRingLength]
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     newVal          The desired BD ring length.
@@ -1023,7 +1022,7 @@ t_Error FM_PORT_ConfigIMTxBdRingLength(t_Handle h_FmPort, uint16_t newVal);
                 data structures (e.g. BD rings).
                 Calling this routine changes the internal driver data base
                 from its default configuration
-                [0, MEMORY_ATTR_CACHEABLE].
+                [DEFAULT_PORT_ImfwExtStructsMemId, DEFAULT_PORT_ImfwExtStructsMemAttr].
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     memId           Memory partition ID.
@@ -1053,7 +1052,7 @@ t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
  @Function      FM_PORT_ConfigMaxFrameLength
 
  @Description   Changes the definition of the max size of frame that should be
-                transmitted/received on this port from its default value [9600].
+                transmitted/received on this port from its default value [DEFAULT_PORT_maxFrameLength].
                 This parameter is used for confirmation of the minimum Fifo
                 size calculations and only for Tx ports or ports working in
                 independent mode. This should be larger than the maximum possible
@@ -1074,7 +1073,7 @@ t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
 
  @Description   Calling this routine changes the fifo minimum
                 fill level parameter in the internal driver data base
-                from its default configuration  [0]
+                from its default configuration  [DEFAULT_PORT_txFifoMinFillLevel]
 
                 May be used for Tx ports only
 
@@ -1093,8 +1092,8 @@ t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLeve
  @Description   Calling this routine changes the fifo dequeue
                 pipeline depth parameter in the internal driver data base
 
-                from its default configuration: 1G ports: [1],
-                10G port: [4]
+                from its default configuration: 1G ports: [DEFAULT_PORT_fifoDeqPipelineDepth_1G],
+                10G port: [DEFAULT_PORT_fifoDeqPipelineDepth_10G]
 
                 May be used for Tx ports only
 
@@ -1112,7 +1111,7 @@ t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelin
 
  @Description   Calling this routine changes the fifo low comfort level
                 parameter in internal driver data base
-                from its default configuration [5]
+                from its default configuration [DEFAULT_PORT_txFifoLowComfLevel]
 
                 May be used for Tx ports only
 
@@ -1130,7 +1129,7 @@ t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComf
 
  @Description   Calling this routine changes the threshold of the FIFO
                 fill level parameter in the internal driver data base
-                from its default configuration [BMI_MAX_FIFO_SIZE]
+                from its default configuration [DEFAULT_PORT_rxFifoThreshold]
 
                 If the total number of buffers which are
                 currently in use and associated with the
@@ -1154,7 +1153,7 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 
  @Description   Calling this routine changes the priority elevation level
                 parameter in the internal driver data base from its default
-                configuration  [BMI_MAX_FIFO_SIZE]
+                configuration  [DEFAULT_PORT_rxFifoPriElevationLevel]
 
                 If the total number of buffers which are currently in use and
                 associated with the specific RX port exceed the amount specified
@@ -1427,6 +1426,8 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Init().
+                If rate limit is set on a port that need to send PFC frames,
+                it might violate the stop transmit timing.
 *//***************************************************************************/
 t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
 
@@ -1447,6 +1448,24 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
 t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort);
 
 /**************************************************************************//**
+ @Function      FM_PORT_SetPfcPrioritiesMappingToQmanWQ
+
+ @Description   Calling this routine maps each PFC received priority to the transmit WQ.
+                This WQ will be blocked upon receiving a PFC frame with this priority.
+
+                May be used for Tx ports only.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+ @Param[in]     prio            PFC priority (0-7).
+ @Param[in]     wq              Work Queue (0-7).
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio, uint8_t wq);
+
+/**************************************************************************//**
  @Function      FM_PORT_SetStatisticsCounters
 
  @Description   Calling this routine enables/disables port's statistics counters.
@@ -1926,7 +1945,7 @@ typedef struct t_FmPcdPrsStart {
  @Description   struct for defining external buffer margins
 *//***************************************************************************/
 typedef struct t_FmPortVSPAllocParams {
-    uint8_t     numOfProfiles;          /**< Number of Virtual Storage Profiles */
+    uint8_t     numOfProfiles;          /**< Number of Virtual Storage Profiles; must be a power of 2 */
     uint8_t     dfltRelativeId;         /**< The default Virtual-Storage-Profile-id dedicated to Rx/OP port
                                              The same default Virtual-Storage-Profile-id will be for coupled Tx port
                                              if relevant function called for Rx port */
@@ -2053,7 +2072,7 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Init(), and before FM_PORT_SetPCD()
-                and also before FM_PORT_Enable() (i.e. the port should be disabled).
+                and also before FM_PORT_Enable(); i.e. the port should be disabled.
 *//***************************************************************************/
 t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_Params);
 #endif /* (DPAA_VERSION >= 11) */
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_rtc_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_rtc_ext.h
index c8fa262..315405c 100644
--- a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_rtc_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_rtc_ext.h
@@ -45,7 +45,7 @@
 
 #include "error_ext.h"
 #include "std_ext.h"
-
+#include "fsl_fman_rtc.h"
 
 /**************************************************************************//**
 
@@ -77,8 +77,8 @@
 *//***************************************************************************/
 typedef enum e_FmRtcAlarmPolarity
 {
-    e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH,    /**< Active-high output polarity */
-    e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW      /**< Active-low output polarity */
+    e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH = E_FMAN_RTC_ALARM_POLARITY_ACTIVE_HIGH,    /**< Active-high output polarity */
+    e_FM_RTC_ALARM_POLARITY_ACTIVE_LOW = E_FMAN_RTC_ALARM_POLARITY_ACTIVE_LOW     /**< Active-low output polarity */
 } e_FmRtcAlarmPolarity;
 
 /**************************************************************************//**
@@ -86,8 +86,8 @@ typedef enum e_FmRtcAlarmPolarity
 *//***************************************************************************/
 typedef enum e_FmRtcTriggerPolarity
 {
-    e_FM_RTC_TRIGGER_ON_RISING_EDGE,    /**< Trigger on rising edge */
-    e_FM_RTC_TRIGGER_ON_FALLING_EDGE    /**< Trigger on falling edge */
+    e_FM_RTC_TRIGGER_ON_RISING_EDGE = E_FMAN_RTC_TRIGGER_ON_RISING_EDGE,    /**< Trigger on rising edge */
+    e_FM_RTC_TRIGGER_ON_FALLING_EDGE = E_FMAN_RTC_TRIGGER_ON_FALLING_EDGE   /**< Trigger on falling edge */
 } e_FmRtcTriggerPolarity;
 
 /**************************************************************************//**
@@ -95,9 +95,9 @@ typedef enum e_FmRtcTriggerPolarity
 *//***************************************************************************/
 typedef enum e_FmSrcClock
 {
-    e_FM_RTC_SOURCE_CLOCK_EXTERNAL,  /**< external high precision timer reference clock */
-    e_FM_RTC_SOURCE_CLOCK_SYSTEM,    /**< MAC system clock */
-    e_FM_RTC_SOURCE_CLOCK_OSCILATOR  /**< RTC clock oscilator */
+    e_FM_RTC_SOURCE_CLOCK_EXTERNAL = E_FMAN_RTC_SOURCE_CLOCK_EXTERNAL,  /**< external high precision timer reference clock */
+    e_FM_RTC_SOURCE_CLOCK_SYSTEM = E_FMAN_RTC_SOURCE_CLOCK_SYSTEM,    /**< MAC system clock */
+    e_FM_RTC_SOURCE_CLOCK_OSCILATOR = E_FMAN_RTC_SOURCE_CLOCK_OSCILATOR  /**< RTC clock oscilator */
 }e_FmSrcClk;
 
 /**************************************************************************//**
@@ -170,7 +170,7 @@ t_Error FM_RTC_Free(t_Handle h_FmRtc);
  @Function      FM_RTC_ConfigPeriod
 
  @Description   Configures the period of the timestamp if different than
-                default [1000].
+                default [DEFAULT_clockPeriod].
 
  @Param[in]     h_FmRtc         - Handle to FM RTC object.
  @Param[in]     period          - Period in nano-seconds.
@@ -202,7 +202,7 @@ t_Error FM_RTC_ConfigSourceClock(t_Handle      h_FmRtc,
  @Function      FM_RTC_ConfigPulseRealignment
 
  @Description   Configures the RTC to automatic FIPER pulse realignment in
-                response to timer adjustments [FALSE]
+                response to timer adjustments [DEFAULT_pulseRealign]
 
                 In this mode, the RTC clock is identical to the source clock.
                 This feature can be useful when the system contains an external
@@ -221,7 +221,7 @@ t_Error FM_RTC_ConfigPulseRealignment(t_Handle h_FmRtc, bool enable);
  @Function      FM_RTC_ConfigFrequencyBypass
 
  @Description   Configures the RTC to bypass the frequency compensation
-                mechanism. [FALSE]
+                mechanism. [DEFAULT_bypass]
 
                 In this mode, the RTC clock is identical to the source clock.
                 This feature can be useful when the system contains an external
@@ -241,7 +241,7 @@ t_Error FM_RTC_ConfigFrequencyBypass(t_Handle h_FmRtc, bool enabled);
  @Function      FM_RTC_ConfigInvertedInputClockPhase
 
  @Description   Configures the RTC to invert the source clock phase on input.
-                [FALSE]
+                [DEFAULT_invertInputClkPhase]
 
  @Param[in]     h_FmRtc  - Handle to FM RTC object.
  @Param[in]     inverted    - TRUE to invert the source clock phase on input.
@@ -257,7 +257,7 @@ t_Error FM_RTC_ConfigInvertedInputClockPhase(t_Handle h_FmRtc, bool inverted);
  @Function      FM_RTC_ConfigInvertedOutputClockPhase
 
  @Description   Configures the RTC to invert the output clock phase.
-                [FALSE]
+                [DEFAULT_invertOutputClkPhase]
 
  @Param[in]     h_FmRtc  - Handle to FM RTC object.
  @Param[in]     inverted    - TRUE to invert the output clock phase.
@@ -273,7 +273,7 @@ t_Error FM_RTC_ConfigInvertedOutputClockPhase(t_Handle h_FmRtc, bool inverted);
  @Function      FM_RTC_ConfigOutputClockDivisor
 
  @Description   Configures the divisor for generating the output clock from
-                the RTC clock. [0x00000002]
+                the RTC clock. [DEFAULT_outputClockDivisor]
 
  @Param[in]     h_FmRtc  - Handle to FM RTC object.
  @Param[in]     divisor     - Divisor for generation of the output clock.
@@ -288,7 +288,7 @@ t_Error FM_RTC_ConfigOutputClockDivisor(t_Handle h_FmRtc, uint16_t divisor);
  @Function      FM_RTC_ConfigAlarmPolarity
 
  @Description   Configures the polarity (active-high/active-low) of a specific
-                alarm signal. [e_FM_RTC_ALARM_POLARITY_ACTIVE_HIGH]
+                alarm signal. [DEFAULT_alarmPolarity]
 
  @Param[in]     h_FmRtc      - Handle to FM RTC object.
  @Param[in]     alarmId         - Alarm ID.
@@ -306,7 +306,7 @@ t_Error FM_RTC_ConfigAlarmPolarity(t_Handle             h_FmRtc,
  @Function      FM_RTC_ConfigExternalTriggerPolarity
 
  @Description   Configures the polarity (rising/falling edge) of a specific
-                external trigger signal. [e_FM_RTC_TRIGGER_ON_FALLING_EDGE]
+                external trigger signal. [DEFAULT_triggerPolarity]
 
  @Param[in]     h_FmRtc      - Handle to FM RTC object.
  @Param[in]     triggerId       - Trigger ID.
diff --git a/drivers/net/ethernet/freescale/fman/inc/core_ext.h b/drivers/net/ethernet/freescale/fman/inc/core_ext.h
index 9cd5669..42174cf 100644
--- a/drivers/net/ethernet/freescale/fman/inc/core_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/core_ext.h
@@ -83,3 +83,4 @@ void CORE_MemoryBarrier(void);
 #define fsl_mem_core_barrier() CORE_MemoryBarrier()
 
 #endif /* __CORE_EXT_H */
+
diff --git a/drivers/net/ethernet/freescale/fman/inc/cores/e500v2_ext.h b/drivers/net/ethernet/freescale/fman/inc/cores/e500v2_ext.h
index 099c7b9..e79b1dd 100644
--- a/drivers/net/ethernet/freescale/fman/inc/cores/e500v2_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/cores/e500v2_ext.h
@@ -59,6 +59,8 @@ void        L1DCache_Disable(void);
 void        L1ICache_Disable(void);
 void        L1DCache_Flush(void);
 void        L1ICache_Flush(void);
+uint32_t    L1ICache_IsEnabled(void);
+uint32_t    L1DCache_IsEnabled(void);
 /*
  *
  */
diff --git a/drivers/net/ethernet/freescale/fman/inc/debug_ext.h b/drivers/net/ethernet/freescale/fman/inc/debug_ext.h
index 00ae748..62865bb 100644
--- a/drivers/net/ethernet/freescale/fman/inc/debug_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/debug_ext.h
@@ -263,3 +263,4 @@
 
 
 #endif /* __DEBUG_EXT_H */
+
diff --git a/drivers/net/ethernet/freescale/fman/inc/endian_ext.h b/drivers/net/ethernet/freescale/fman/inc/endian_ext.h
index 252f89b..5cdec66 100644
--- a/drivers/net/ethernet/freescale/fman/inc/endian_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/endian_ext.h
@@ -444,3 +444,4 @@ static __inline__ void SwapUint64P(uint64_t *p_Val)
 
 
 #endif /* __ENDIAN_EXT_H */
+
diff --git a/drivers/net/ethernet/freescale/fman/inc/error_ext.h b/drivers/net/ethernet/freescale/fman/inc/error_ext.h
index bbd6743..71f9398 100644
--- a/drivers/net/ethernet/freescale/fman/inc/error_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/error_ext.h
@@ -525,3 +525,5 @@ char * ErrTypeStrings (e_ErrorType err);
 /** @} */ /* end of General Utils group */
 
 #endif /* __ERROR_EXT_H */
+
+
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
new file mode 100755
index 0000000..795f6b2
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_H
+#define __FSL_FMAN_H
+
+#include "common/general.h"
+
+
+struct fman_ext_pool_params {
+	uint8_t                 id;    /**< External buffer pool id */
+	uint16_t                size;  /**< External buffer pool buffer size */
+};
+
+struct fman_ext_pools {
+	uint8_t num_pools_used;        /**< Number of pools use by this port */
+	struct fman_ext_pool_params *ext_buf_pool;
+					/**< Parameters for each port */
+};
+
+struct fman_backup_bm_pools {
+	uint8_t		 num_backup_pools; /**< Number of BM backup pools -
+					must be smaller than the total number
+					of pools defined for the specified
+					port.*/
+	uint8_t		*pool_ids;      /**< numOfBackupPools pool id's,
+					specifying which pools should be used
+					only as backup. Pool id's specified
+					here must be a subset of the pools
+					used by the specified port.*/
+};
+
+/**************************************************************************//**
+ @Description   A structure for defining BM pool depletion criteria
+*//***************************************************************************/
+struct fman_buf_pool_depletion {
+	bool buf_pool_depletion_enabled;
+	bool pools_grp_mode_enable;    /**< select mode in which pause frames
+					will be sent after a number of pools
+					(all together!) are depleted */
+	uint8_t num_pools;             /**< the number of depleted pools that
+					will invoke pause frames transmission.
+					*/
+	bool *pools_to_consider;       /**< For each pool, TRUE if it should be
+					considered for depletion (Note - this
+					pool must be used by this port!). */
+	bool single_pool_mode_enable;  /**< select mode in which pause frames
+					will be sent after a single-pool
+					is depleted; */
+	bool *pools_to_consider_for_single_mode;
+				       /**< For each pool, TRUE if it should be
+					considered for depletion (Note - this
+					pool must be used by this port!) */
+	bool has_pfc_priorities;
+	bool *pfc_priorities_en;       /**< This field is used by the MAC as
+					the Priority Enable Vector in the PFC
+					frame which is transmitted */
+};
+
+/**************************************************************************//**
+ @Description   Enum for defining port DMA swap mode
+*//***************************************************************************/
+enum fman_dma_swap_option {
+	FMAN_DMA_NO_SWP,           /**< No swap, transfer data as is.*/
+	FMAN_DMA_SWP_PPC_LE,       /**< The transferred data should be swapped
+					in PowerPc Little Endian mode. */
+	FMAN_DMA_SWP_BE            /**< The transferred data should be swapped
+					in Big Endian mode */
+};
+
+/**************************************************************************//**
+ @Description   Enum for defining port DMA cache attributes
+*//***************************************************************************/
+enum fman_dma_cache_option {
+	FMAN_DMA_NO_STASH = 0,     /**< Cacheable, no Allocate (No Stashing) */
+	FMAN_DMA_STASH = 1         /**< Cacheable and Allocate (Stashing on) */
+};
+
+/* sizes */
+#define CAPWAP_FRAG_EXTRA_SPACE                 32
+#define OFFSET_UNITS                            16
+#define MAX_INT_OFFSET                          240
+#define MAX_IC_SIZE                             256
+#define MAX_EXT_OFFSET                          496
+#define MAX_EXT_BUFFER_OFFSET                   511
+
+
+#endif /* __FSL_FMAN_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h
index 55527c1..445e73c8 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec.h
@@ -41,19 +41,19 @@
  *
  * To prepare dTSEC block for transfer use the following call sequence:
  *
- * - dtsec_defconfig() - This step is optional and yet recommended. Its use is
+ * - fman_dtsec_defconfig() - This step is optional and yet recommended. Its use is
  * to obtain the default dTSEC configuration parameters.
  *
  * - Change dtsec configuration in &dtsec_cfg. This structure will be used
  * to customize the dTSEC behavior.
  *
- * - dtsec_init() - Applies the configuration on dTSEC hardware.  Note that
+ * - fman_dtsec_init() - Applies the configuration on dTSEC hardware.  Note that
  * dTSEC is initialized while both Tx and Rx are disabled.
  *
- * - dtsec_set_mac_address() - Set the station address (mac address).
+ * - fman_dtsec_set_mac_address() - Set the station address (mac address).
  * This is used by dTSEC to match against received packets.
  *
- * - dtsec_adjust_link() - Set the link speed and duplex parameters
+ * - fman_dtsec_adjust_link() - Set the link speed and duplex parameters
  * after the PHY establishes the link.
  *
  * - dtsec_enable_tx() and dtsec_enable_rx() to enable transmission and
@@ -63,15 +63,15 @@
 /**
  * DOC: dTSEC Graceful stop
  *
- * To temporary stop dTSEC activity use dtsec_stop_tx() and dtsec_stop_rx().
+ * To temporary stop dTSEC activity use fman_dtsec_stop_tx() and fman_dtsec_stop_rx().
  * Note that these functions request dTSEC graceful stop but return before this
  * stop is complete.  To query for graceful stop completion use
- * dtsec_get_event() and check DTSEC_IEVENT_GTSC and DTSEC_IEVENT_GRSC bits.
+ * fman_dtsec_get_event() and check DTSEC_IEVENT_GTSC and DTSEC_IEVENT_GRSC bits.
  * Alternatively the dTSEC interrupt mask can be set to enable graceful stop
  * interrupts.
  *
- * To resume operation after graceful stop use dtsec_start_tx() and
- * dtsec_start_rx().
+ * To resume operation after graceful stop use fman_dtsec_start_tx() and
+ * fman_dtsec_start_rx().
  */
 
 /**
@@ -93,10 +93,10 @@
  * occurs and its corresponding enable bit is set in the interrupt mask
  * register, the event also causes a hardware interrupt at the PIC.
  *
- * To poll for event status use the dtsec_get_event() function.
- * To configure the interrupt mask use dtsec_enable_interrupt() and
- * dtsec_disable_interrupt() functions.
- * After servicing a dTSEC interrupt use dtsec_ack_event to reset the serviced
+ * To poll for event status use the fman_dtsec_get_event() function.
+ * To configure the interrupt mask use fman_dtsec_enable_interrupt() and
+ * fman_dtsec_disable_interrupt() functions.
+ * After servicing a dTSEC interrupt use fman_dtsec_ack_event to reset the serviced
  * event bit.
  *
  * The following events may be signaled by dTSEC hardware:
@@ -107,7 +107,7 @@
  *
  * %DTSEC_IEVENT_RXC - Receive control (pause frame) interrupt.  A pause
  * control frame was received while Rx pause frame handling is enabled.
- * Also see dtsec_handle_rx_pause().
+ * Also see fman_dtsec_handle_rx_pause().
  *
  * %DTSEC_IEVENT_MSRO - MIB counter overflow.  The count for one of the MIB
  * counters has exceeded the size of its register.
@@ -115,7 +115,7 @@
  * %DTSEC_IEVENT_GTSC - Graceful transmit stop complete.  Graceful stop is now
  * complete. The transmitter is in a stopped state, in which only pause frames
  * can be transmitted.
- * Also see dtsec_stop_tx().
+ * Also see fman_dtsec_stop_tx().
  *
  * %DTSEC_IEVENT_BABT - Babbling transmit error.  The transmitted frame length
  * has exceeded the value in the MAC's Maximum Frame Length register.
@@ -139,7 +139,7 @@
  * being transmitted and transmission of the next frame commences.  This only
  * occurs while in half-duplex mode.
  * The number of retransmit attempts can be set in
- * &dtsec_halfdup_cfg.@retransmit before calling dtsec_init().
+ * &dtsec_halfdup_cfg.@retransmit before calling fman_dtsec_init().
  *
  * %DTSEC_IEVENT_XFUN - Transmit FIFO underrun.  This bit indicates that the
  * transmit FIFO became empty before the complete frame was transmitted.
@@ -654,7 +654,7 @@ enum dtsec_stat_counters {
  *			Ethernet frames and passed up to the packet interface on
  *			a DA match.  Received pause control frames are passed to
  *			the packet interface only if Rx flow control is also
- *			disabled.  See dtsec_handle_rx_pause() function.
+ *			disabled.  See fman_dtsec_handle_rx_pause() function.
  * @tx_pause_time:	Transmit pause time value.  This pause value is used as
  *			part of the pause frame to be sent when a transmit pause
  *			frame is initiated.  If set to 0 this disables
@@ -679,8 +679,8 @@ enum dtsec_stat_counters {
  *			precedes the layer 2 header.
  *
  * This structure contains basic dTSEC configuration and must be passed to
- * dtsec_init() function.  A default set of configuration values can be obtained
- * by calling dtsec_defconfig().
+ * fman_dtsec_init() function.  A default set of configuration values can be obtained
+ * by calling fman_dtsec_defconfig().
  */
 struct dtsec_cfg {
 	bool		halfdup_on;
@@ -723,17 +723,17 @@ struct dtsec_cfg {
 
 
 /**
- * dtsec_defconfig() - Get default dTSEC configuration
+ * fman_dtsec_defconfig() - Get default dTSEC configuration
  * @cfg:	pointer to configuration structure.
  *
  * Call this function to obtain a default set of configuration values for
  * initializing dTSEC.  The user can overwrite any of the values before calling
- * dtsec_init(), if specific configuration needs to be applied.
+ * fman_dtsec_init(), if specific configuration needs to be applied.
  */
-void dtsec_defconfig(struct dtsec_cfg *cfg);
+void fman_dtsec_defconfig(struct dtsec_cfg *cfg);
 
 /**
- * dtsec_init() - Init dTSEC hardware block
+ * fman_dtsec_init() - Init dTSEC hardware block
  * @regs:		Pointer to dTSEC register block
  * @cfg:		dTSEC configuration data
  * @iface_mode:		dTSEC interface mode, the type of MAC - PHY interface.
@@ -747,60 +747,98 @@ void dtsec_defconfig(struct dtsec_cfg *cfg);
  *
  * dTSEC initialization sequence:
  * Before enabling Rx/Tx call dtsec_set_address() to set MAC address,
- * dtsec_adjust_link() to configure interface speed and duplex and finally
+ * fman_dtsec_adjust_link() to configure interface speed and duplex and finally
  * dtsec_enable_tx()/dtsec_enable_rx() to start transmission and reception.
  *
  * Returns: 0 if successful, an error code otherwise.
  */
-int dtsec_init(struct dtsec_regs *regs, struct dtsec_cfg *cfg,
-		enum enet_interface iface_mode,
-		enum enet_speed iface_speed,
-		uint8_t *macaddr, uint8_t fm_rev_maj,
-		uint8_t fm_rev_min,
-		uint32_t exception_mask);
+int fman_dtsec_init(struct dtsec_regs *regs, struct dtsec_cfg *cfg,
+	enum enet_interface iface_mode,
+	enum enet_speed iface_speed,
+	uint8_t *macaddr, uint8_t fm_rev_maj,
+	uint8_t fm_rev_min,
+	uint32_t exception_mask);
 
 /**
- * dtsec_get_revision() - Get dTSEC hardware revision
+ * fman_dtsec_enable() - Enable dTSEC Tx and Tx
+ * @regs:	Pointer to dTSEC register block
+ * @apply_rx:	enable rx side
+ * @apply_tx:	enable tx side
+ *
+ * This function resets Tx and Rx graceful stop bit and enables dTSEC Tx and Rx.
+ */
+void fman_dtsec_enable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
+
+/**
+ * fman_dtsec_disable() - Disable dTSEC Tx and Rx
+ * @regs:	Pointer to dTSEC register block
+ * @apply_rx:	disable rx side
+ * @apply_tx:	disable tx side
+ *
+ * This function disables Tx and Rx in dTSEC.
+ */
+void fman_dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
+
+/**
+ * fman_dtsec_get_revision() - Get dTSEC hardware revision
  * @regs:   Pointer to dTSEC register block
  *
  * Returns dtsec_id content
  *
  * Call this function to obtain the dTSEC hardware version.
  */
-uint32_t dtsec_get_revision(struct dtsec_regs *regs);
+uint32_t fman_dtsec_get_revision(struct dtsec_regs *regs);
 
 /**
- * dtsec_set_uc_promisc() - Sets unicast promiscuous mode
+ * fman_dtsec_set_mac_address() - Set MAC station address
+ * @regs:   Pointer to dTSEC register block
+ * @macaddr:    MAC address array
+ *
+ * This function sets MAC station address.  To enable unicast reception call
+ * this after fman_dtsec_init().  While promiscuous mode is disabled dTSEC will match
+ * the destination address of received unicast frames against this address.
+ */
+void fman_dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
+
+/**
+ * fman_dtsec_get_mac_address() - Query MAC station address
+ * @regs:   Pointer to dTSEC register block
+ * @macaddr:    MAC address array
+ */
+void fman_dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
+
+/**
+ * fman_dtsec_set_uc_promisc() - Sets unicast promiscuous mode
  * @regs:	Pointer to dTSEC register block
  * @enable:	Enable unicast promiscuous mode
  *
  * Use this function to enable/disable dTSEC L2 address filtering.  If the
  * address filtering is disabled all unicast packets are accepted.
- * To set dTSEC in promiscuous mode call both dtsec_set_uc_promisc() and
- * dtsec_set_mc_promisc() to disable filtering for both unicast and multicast
+ * To set dTSEC in promiscuous mode call both fman_dtsec_set_uc_promisc() and
+ * fman_dtsec_set_mc_promisc() to disable filtering for both unicast and multicast
  * addresses.
  */
-void dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable);
+void fman_dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable);
 
 /**
- * dtsec_adjust_link() - Adjust dTSEC speed/duplex settings
+ * fman_dtsec_adjust_link() - Adjust dTSEC speed/duplex settings
  * @regs:	Pointer to dTSEC register block
  * @iface_mode: dTSEC interface mode
  * @speed:	Link speed
  * @full_dx:	True for full-duplex, false for half-duplex.
  *
  * This function configures the MAC to function and the desired rates.  Use it
- * to configure dTSEC after dtsec_init() and whenever the link speed changes
+ * to configure dTSEC after fman_dtsec_init() and whenever the link speed changes
  * (for instance following PHY auto-negociation).
  *
  * Returns: 0 if successful, an error code otherwise.
  */
-int dtsec_adjust_link(struct dtsec_regs *regs,
-		enum enet_interface iface_mode,
-		enum enet_speed speed, bool full_dx);
+int fman_dtsec_adjust_link(struct dtsec_regs *regs,
+	enum enet_interface iface_mode,
+	enum enet_speed speed, bool full_dx);
 
 /**
- * dtsec_set_tbi_phy_addr() - Updates TBI address field
+ * fman_dtsec_set_tbi_phy_addr() - Updates TBI address field
  * @regs:	Pointer to dTSEC register block
  * @address:	Valid PHY address in the range of 1 to 31. 0 is reserved.
  *
@@ -809,70 +847,29 @@ int dtsec_adjust_link(struct dtsec_regs *regs,
  *
  * Returns: 0 if successful, an error code otherwise.
  */
-int dtsec_set_tbi_phy_addr(struct dtsec_regs *regs,
-		uint8_t addr);
+int fman_dtsec_set_tbi_phy_addr(struct dtsec_regs *regs,
+	uint8_t addr);
 
 /**
- * dtsec_disable() - Disable dTSEC Tx and Rx
- * @regs:	Pointer to dTSEC register block
- * @apply_rx:	disable rx side
- * @apply_tx:	disable tx side
- *
- * This function disables Tx and Rx in dTSEC.
- */
-void dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
-
-/**
- * dtsec_enable() - Enable dTSEC Tx and Tx
- * @regs:	Pointer to dTSEC register block
- * @apply_rx:	enable rx side
- * @apply_tx:	enable tx side
- *
- * This function resets Tx and Rx graceful stop bit and enables dTSEC Tx and Rx.
- */
-void dtsec_enable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
-
-/**
- * dtsec_set_mac_address() - Set MAC station address
- * @regs:   Pointer to dTSEC register block
- * @macaddr:    MAC address array
- *
- * This function sets MAC station address.  To enable unicast reception call
- * this after dtsec_init().  While promiscuous mode is disabled dTSEC will match
- * the destination address of received unicast frames against this address.
- */
-void dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
-
-/**
- * dtsec_get_mac_address() - Query MAC station address
- * @regs:   Pointer to dTSEC register block
- * @macaddr:    MAC address array
- */
-void dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
-
-/**
- * dtsec_set_max_frame_len() - Set max frame length
+ * fman_dtsec_set_max_frame_len() - Set max frame length
  * @regs:	Pointer to dTSEC register block
  * @length:	Max frame length.
  *
  * Sets maximum frame length for received and transmitted frames.  Frames that
  * exceeds this length are truncated.
  */
-
-void dtsec_set_max_frame_len(struct dtsec_regs *regs, uint16_t length);
-
+void fman_dtsec_set_max_frame_len(struct dtsec_regs *regs, uint16_t length);
 
 /**
- * dtsec_get_max_frame_len() - Query max frame length
+ * fman_dtsec_get_max_frame_len() - Query max frame length
  * @regs:	Pointer to dTSEC register block
  *
  * Returns: the current value of the maximum frame length.
  */
-uint16_t dtsec_get_max_frame_len(struct dtsec_regs *regs);
-
+uint16_t fman_dtsec_get_max_frame_len(struct dtsec_regs *regs);
 
 /**
- * dtsec_handle_rx_pause() - Configure pause frame handling
+ * fman_dtsec_handle_rx_pause() - Configure pause frame handling
  * @regs:	Pointer to dTSEC register block
  * @en:		Enable pause frame handling in dTSEC
  *
@@ -882,20 +879,20 @@ uint16_t dtsec_get_max_frame_len(struct dtsec_regs *regs);
  * frames will be transferred to the packet interface just like regular Ethernet
  * frames.
  */
-void dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en);
+void fman_dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en);
 
 /**
- * dtsec_set_tx_pause_time() - Configure Tx pause time
+ * fman_dtsec_set_tx_pause_frames() - Configure Tx pause time
  * @regs:	Pointer to dTSEC register block
  * @time:	Time value included in pause frames
  *
  * Call this function to set the time value used in transmitted pause frames.
  * If time is 0, transmission of pause frames is disabled
  */
-void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time);
+void fman_dtsec_set_tx_pause_frames(struct dtsec_regs *regs, uint16_t time);
 
 /**
- * dtsec_ack_event() - Acknowledge handled events
+ * fman_dtsec_ack_event() - Acknowledge handled events
  * @regs:	Pointer to dTSEC register block
  * @ev_mask:	Events to acknowledge
  *
@@ -903,10 +900,10 @@ void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time);
  * call this function to reset the associated status bits in dTSEC event
  * register.
  */
-void dtsec_ack_event(struct dtsec_regs *regs, uint32_t ev_mask);
+void fman_dtsec_ack_event(struct dtsec_regs *regs, uint32_t ev_mask);
 
 /**
- * dtsec_get_event() - Returns currently asserted events
+ * fman_dtsec_get_event() - Returns currently asserted events
  * @regs:	Pointer to dTSEC register block
  * @ev_mask:	Mask of relevant events
  *
@@ -915,9 +912,10 @@ void dtsec_ack_event(struct dtsec_regs *regs, uint32_t ev_mask);
  *
  * Returns: a bit-mask of events asserted in dTSEC.
  */
-uint32_t dtsec_get_event(struct dtsec_regs *regs, uint32_t ev_mask);
+uint32_t fman_dtsec_get_event(struct dtsec_regs *regs, uint32_t ev_mask);
+
 /**
- * dtsec_get_interrupt_mask() - Returns a bit-mask of enabled interrupts
+ * fman_dtsec_get_interrupt_mask() - Returns a bit-mask of enabled interrupts
  * @regs:   Pointer to dTSEC register block
  *
  * Call this function to obtain a bit-mask of enabled interrupts
@@ -925,51 +923,51 @@ uint32_t dtsec_get_event(struct dtsec_regs *regs, uint32_t ev_mask);
  *
  * Returns: a bit-mask of enabled interrupts in dTSEC.
  */
-uint32_t dtsec_get_interrupt_mask(struct dtsec_regs *regs);
+uint32_t fman_dtsec_get_interrupt_mask(struct dtsec_regs *regs);
 
-void dtsec_clear_addr_in_paddr  (struct dtsec_regs *regs,
-                                 uint8_t paddr_num);
+void fman_dtsec_clear_addr_in_paddr(struct dtsec_regs *regs,
+	uint8_t paddr_num);
 
-void dtsec_add_addr_in_paddr    (struct dtsec_regs *regs,
-                                 uint64_t addr,
-                                 uint8_t paddr_num);
+void fman_dtsec_add_addr_in_paddr(struct dtsec_regs *regs,
+	uint64_t addr,
+	uint8_t paddr_num);
 
-void dtsec_enable_tmr_interrupt (struct dtsec_regs *regs);
+void fman_dtsec_enable_tmr_interrupt (struct dtsec_regs *regs);
 
-void dtsec_disable_tmr_interrupt(struct dtsec_regs *regs);
+void fman_dtsec_disable_tmr_interrupt(struct dtsec_regs *regs);
 
 /**
- * dtsec_disable_interrupt() - Disables interrupts for the specified events
+ * fman_dtsec_disable_interrupt() - Disables interrupts for the specified events
  * @regs:	Pointer to dTSEC register block
  * @ev_mask:	Mask of relevant events
  *
  * Call this function to disable interrupts in dTSEC for the specified events.
- * To enable interrupts use dtsec_enable_interrupt().
+ * To enable interrupts use fman_dtsec_enable_interrupt().
  */
-void dtsec_disable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
+void fman_dtsec_disable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
 
 /**
- * dtsec_enable_interrupt() - Enable interrupts for the specified events
+ * fman_dtsec_enable_interrupt() - Enable interrupts for the specified events
  * @regs:	Pointer to dTSEC register block
  * @ev_mask:	Mask of relevant events
  *
  * Call this function to enable interrupts in dTSEC for the specified events.
- * To disable interrupts use dtsec_disable_interrupt().
+ * To disable interrupts use fman_dtsec_disable_interrupt().
  */
-void dtsec_enable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
+void fman_dtsec_enable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
 
 /**
- * dtsec_set_ts() - Enables dTSEC timestamps
+ * fman_dtsec_set_ts() - Enables dTSEC timestamps
  * @regs:	Pointer to dTSEC register block
  * @en:		true to enable timestamps, false to disable them
  *
  * Call this function to enable/disable dTSEC timestamps.  This affects both
  * Tx and Rx.
  */
-void dtsec_set_ts(struct dtsec_regs *regs, bool en);
+void fman_dtsec_set_ts(struct dtsec_regs *regs, bool en);
 
 /**
- * dtsec_set_bucket() - Enables/disables a filter bucket
+ * fman_dtsec_set_bucket() - Enables/disables a filter bucket
  * @regs:   Pointer to dTSEC register block
  * @bucket: Bucket index
  * @enable: true/false to enable/disable this bucket
@@ -982,36 +980,36 @@ void dtsec_set_ts(struct dtsec_regs *regs, bool en);
  * is enabled requires further filtering and verification in the upper layers
  *
  */
-void dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable);
+void fman_dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable);
 
 /**
- * dtsec_reset_filter_table() - Resets the address filtering table
+ * fman_dtsec_reset_filter_table() - Resets the address filtering table
  * @regs:	Pointer to dTSEC register block
  * @mcast:	Reset multicast entries
  * @ucast:	Reset unicast entries
  *
  * Resets all entries in L2 address filter table.  After calling this function
- * all buckets enabled using dtsec_set_bucket() will be disabled.
+ * all buckets enabled using fman_dtsec_set_bucket() will be disabled.
  * If dtsec_init_filter_table() was called with @unicast_hash set to false,
  * @ucast argument is ignored.
  * This does not affect the primary nor the 15 additional addresses configured
  * using dtsec_set_address() or dtsec_set_match_address().
  */
-void  dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast);
+void fman_dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast);
 
 /**
- * dtsec_set_mc_promisc() - Set multicast promiscous mode
+ * fman_dtsec_set_mc_promisc() - Set multicast promiscous mode
  * @regs:	Pointer to dTSEC register block
  * @enable:	Enable multicast promiscous mode
  *
  * Call this to enable/disable L2 address filtering for multicast packets.
  */
-void dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable);
+void fman_dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable);
 
 /* statistics APIs */
 
 /**
- * dtsec_set_stat_level() - Enable a group of MIB statistics counters
+ * fman_dtsec_set_stat_level() - Enable a group of MIB statistics counters
  * @regs:	Pointer to dTSEC register block
  * @level:	Specifies a certain group of dTSEC MIB HW counters or _all_,
  *		to specify all the existing counters.
@@ -1022,16 +1020,16 @@ void dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable);
  *
  * Returns: error if invalid @level value given.
  */
-int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level);
+int fman_dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level);
 
 /**
- * dtsec_reset_stat() - Completely resets all dTSEC HW counters
+ * fman_dtsec_reset_stat() - Completely resets all dTSEC HW counters
  * @regs:	Pointer to dTSEC register block
  */
-void dtsec_reset_stat(struct dtsec_regs *regs);
+void fman_dtsec_reset_stat(struct dtsec_regs *regs);
 
 /**
- * dtsec_get_clear_carry_regs() - Read and clear carry bits (CAR1-2 registers)
+ * fman_dtsec_get_clear_carry_regs() - Read and clear carry bits (CAR1-2 registers)
  * @regs:	Pointer to dTSEC register block
  * @car1:	car1 register value
  * @car2:	car2 register value
@@ -1043,18 +1041,19 @@ void dtsec_reset_stat(struct dtsec_regs *regs);
  *
  * Returns: true if overflow occurred, otherwise - false
  */
-bool dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
-				uint32_t *car1, uint32_t *car2);
+bool fman_dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
+	uint32_t *car1, uint32_t *car2);
+
+uint32_t fman_dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs);
 
-uint32_t dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs);
+uint32_t fman_dtsec_get_stat_counter(struct dtsec_regs *regs,
+	enum dtsec_stat_counters reg_name);
 
-uint32_t dtsec_get_stat_counter(struct dtsec_regs *regs,
-				enum dtsec_stat_counters reg_name);
+void fman_dtsec_start_tx(struct dtsec_regs *regs);
+void fman_dtsec_start_rx(struct dtsec_regs *regs);
+void fman_dtsec_stop_tx(struct dtsec_regs *regs);
+void fman_dtsec_stop_rx(struct dtsec_regs *regs);
+uint32_t fman_dtsec_get_rctrl(struct dtsec_regs *regs);
 
-void dtsec_start_tx(struct dtsec_regs *regs);
-void dtsec_start_rx(struct dtsec_regs *regs);
-void dtsec_stop_rx(struct dtsec_regs *regs);
-void dtsec_stop_tx(struct dtsec_regs *regs);
-uint32_t dtsec_get_rctrl(struct dtsec_regs *regs);
 
 #endif /* __FSL_FMAN_DTSEC_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
index 5cf48c7..503eebb 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_memac.h
@@ -68,6 +68,12 @@
 #define IF_MODE_GMII		0x00000002 /* 30-31 GMII (1G) interface */
 #define IF_MODE_RGMII		0x00000004
 #define IF_MODE_RGMII_AUTO	0x00008000
+#define IF_MODE_RGMII_1000  0x00004000 /* 10 - 1000Mbps RGMII */
+#define IF_MODE_RGMII_100   0x00000000 /* 00 - 100Mbps RGMII */
+#define IF_MODE_RGMII_10    0x00002000 /* 01 - 10Mbps RGMII */
+#define IF_MODE_RGMII_SP_MASK 0x00006000 /* Setsp mask bits */
+#define IF_MODE_RGMII_FD    0x00001000 /* Full duplex RGMII */
+#define IF_MODE_HD          0x00000040 /* Half duplex operation */
 
 /* Hash table Control Register (HASHTABLE_CTRL) */
 #define HASH_CTRL_MCAST_SHIFT	26
@@ -86,12 +92,13 @@
 #define STATS_CFG_SATURATE	0x00000001 /* 31 Saturate at the maximum val */
 
 /* Interrupt Mask Register (IMASK) */
-#define MEMAC_IMASK_MGI		0x40000000 /* 1 Magic pkt detec indication */
+#define MEMAC_IMASK_MGI		0x40000000 /* 1 Magic pkt detect indication */
+#define MEMAC_IMASK_TSECC_ER 0x20000000 /* 2 Timestamp FIFO ECC error evnt */
 #define MEMAC_IMASK_TECC_ER	0x02000000 /* 6 Transmit frame ECC error evnt */
 #define MEMAC_IMASK_RECC_ER	0x01000000 /* 7 Receive frame ECC error evnt */
 
-#define MEMAC_ALL_IMASKS			\
-		((uint32_t)(MEMAC_IMASK_MGI	| \
+#define MEMAC_ALL_ERRS_IMASK			\
+		((uint32_t)(MEMAC_IMASK_TSECC_ER	| \
 			MEMAC_IMASK_TECC_ER	| \
 			MEMAC_IMASK_RECC_ER))
 
@@ -99,6 +106,7 @@
 #define MEMAC_IEVNT_AN			0x40000000 /* Auto-negotiation */
 #define MEMAC_IEVNT_LT			0x20000000 /* Link Training/New page */
 #define MEMAC_IEVNT_MGI			0x00004000 /* Magic pkt detection */
+#define MEMAC_IEVNT_TS_ECC_ER   0x00002000 /* Timestamp FIFO ECC error */
 #define MEMAC_IEVNT_RX_FIFO_OVFL	0x00001000 /* Rx FIFO overflow */
 #define MEMAC_IEVNT_TX_FIFO_UNFL	0x00000800 /* Tx FIFO underflow */
 #define MEMAC_IEVNT_TX_FIFO_OVFL	0x00000400 /* Tx FIFO overflow */
@@ -112,24 +120,6 @@
 #define MEMAC_IEVNT_REM_FAULT		0x00000002 /* Remote fault (XGMII) */
 #define MEMAC_IEVNT_LOC_FAULT		0x00000001 /* Local fault (XGMII) */
 
-#define MEMAC_EVENTS_MASK					\
-		((uint32_t)(MEMAC_IEVNT_PCS			| \
-				MEMAC_IEVNT_AN			| \
-				MEMAC_IEVNT_LT			| \
-				MEMAC_IEVNT_MGI			| \
-				MEMAC_IEVNT_RX_FIFO_OVFL	| \
-				MEMAC_IEVNT_TX_FIFO_UNFL	| \
-				MEMAC_IEVNT_TX_FIFO_OVFL	| \
-				MEMAC_IEVNT_TX_ECC_ER		| \
-				MEMAC_IEVNT_RX_ECC_ER		| \
-				MEMAC_IEVNT_LI_FAULT		| \
-				MEMAC_IEVNT_RX_EMPTY		| \
-				MEMAC_IEVNT_TX_EMPTY		| \
-				MEMAC_IEVNT_RX_LOWP		| \
-				MEMAC_IEVNT_PHY_LOS		| \
-				MEMAC_IEVNT_REM_FAULT		| \
-				MEMAC_IEVNT_LOC_FAULT))
-
 enum memac_counters {
 	E_MEMAC_COUNTER_R64,
 	E_MEMAC_COUNTER_R127,
@@ -337,45 +327,66 @@ struct memac_cfg {
 	uint32_t	tx_ipg_length;
 };
 
+
 /**
- * memac_defconfig() - Get default MEMAC configuration
+ * fman_memac_defconfig() - Get default MEMAC configuration
  * @cfg:    pointer to configuration structure.
  *
  * Call this function to obtain a default set of configuration values for
  * initializing MEMAC. The user can overwrite any of the values before calling
- * memac_init(), if specific configuration needs to be applied.
+ * fman_memac_init(), if specific configuration needs to be applied.
  */
-void memac_defconfig(struct memac_cfg *cfg);
-void memac_set_promiscuous(struct memac_regs *regs, bool val);
-void memac_hardware_add_addr_in_paddr(struct memac_regs *regs,
-					uint8_t *adr,
-					uint8_t paddr_num);
-void memac_hardware_clear_addr_in_paddr(struct memac_regs *regs,
-					uint8_t paddr_num);
-void memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
-void memac_disable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
-uint64_t memac_get_counter(struct memac_regs *regs,
-				enum memac_counters reg_name);
-void memac_set_tx_pause_frames(struct memac_regs *regs,
-				uint8_t priority,
-				uint16_t pauseTime,
-				uint16_t threshTime);
-uint16_t memac_get_max_frame_length(struct memac_regs *regs);
-void memac_init(struct memac_regs *regs,
-		struct memac_cfg *cfg,
-		enum enet_interface enet_interface,
-		enum enet_speed enet_speed,
-		uint32_t exceptions);
-void memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable);
-void memac_reset_counter(struct memac_regs *regs);
-void memac_reset(struct memac_regs *regs);
-void memac_set_hash_table(struct memac_regs *regs, uint32_t val);
-void memac_set_rx_ignore_pause_frames(struct memac_regs  *regs,bool enable);
-void memac_set_loopback(struct memac_regs *regs, bool enable);
-void memac_reset_counter(struct memac_regs *regs);
-uint32_t memac_get_event(struct memac_regs *regs, uint32_t ev_mask);
-void memac_ack_event(struct memac_regs *regs, uint32_t ev_mask);
-uint32_t memac_get_interrupt_mask(struct memac_regs *regs);
+void fman_memac_defconfig(struct memac_cfg *cfg);
+
+int fman_memac_init(struct memac_regs *regs,
+	struct memac_cfg *cfg,
+	enum enet_interface enet_interface,
+	enum enet_speed enet_speed,
+	uint32_t exceptions);
+
+void fman_memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
+
+void fman_memac_disable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
+
+void fman_memac_set_promiscuous(struct memac_regs *regs, bool val);
+
+void fman_memac_add_addr_in_paddr(struct memac_regs *regs,
+	uint8_t *adr,
+	uint8_t paddr_num);
+
+void fman_memac_clear_addr_in_paddr(struct memac_regs *regs,
+	uint8_t paddr_num);
+
+uint64_t fman_memac_get_counter(struct memac_regs *regs,
+	enum memac_counters reg_name);
+
+void fman_memac_set_tx_pause_frames(struct memac_regs *regs,
+	uint8_t priority,
+	uint16_t pauseTime,
+	uint16_t threshTime);
+
+uint16_t fman_memac_get_max_frame_len(struct memac_regs *regs);
+
+void fman_memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable);
+
+void fman_memac_reset_stat(struct memac_regs *regs);
+
+void fman_memac_reset(struct memac_regs *regs);
+
+void fman_memac_set_hash_table(struct memac_regs *regs, uint32_t val);
+
+void fman_memac_set_rx_ignore_pause_frames(struct memac_regs  *regs,bool enable);
+
+uint32_t fman_memac_get_event(struct memac_regs *regs, uint32_t ev_mask);
+
+void fman_memac_ack_event(struct memac_regs *regs, uint32_t ev_mask);
+
+uint32_t fman_memac_get_interrupt_mask(struct memac_regs *regs);
+
+void fman_memac_adjust_link(struct memac_regs *regs,
+        enum enet_interface iface_mode,
+        enum enet_speed speed, bool full_dx);
+
 
 
 #endif /*__FSL_FMAN_MEMAC_H*/
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h
new file mode 100755
index 0000000..aa6fd73
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_rtc.h
@@ -0,0 +1,429 @@
+/*
+ * Copyright 2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_RTC_H
+#define __FSL_FMAN_RTC_H
+
+#include "common/general.h"
+
+/* FM RTC Registers definitions */
+#define FMAN_RTC_TMR_CTRL_ALMP1                  0x80000000
+#define FMAN_RTC_TMR_CTRL_ALMP2                  0x40000000
+#define FMAN_RTC_TMR_CTRL_FS                     0x10000000
+#define FMAN_RTC_TMR_CTRL_PP1L                   0x08000000
+#define FMAN_RTC_TMR_CTRL_PP2L                   0x04000000
+#define FMAN_RTC_TMR_CTRL_TCLK_PERIOD_MASK       0x03FF0000
+#define FMAN_RTC_TMR_CTRL_FRD                    0x00004000
+#define FMAN_RTC_TMR_CTRL_SLV                    0x00002000
+#define FMAN_RTC_TMR_CTRL_ETEP1                  0x00000100
+#define FMAN_RTC_TMR_CTRL_COPH                   0x00000080
+#define FMAN_RTC_TMR_CTRL_CIPH                   0x00000040
+#define FMAN_RTC_TMR_CTRL_TMSR                   0x00000020
+#define FMAN_RTC_TMR_CTRL_DBG                    0x00000010
+#define FMAN_RTC_TMR_CTRL_BYP                    0x00000008
+#define FMAN_RTC_TMR_CTRL_TE                     0x00000004
+#define FMAN_RTC_TMR_CTRL_CKSEL_OSC_CLK          0x00000003
+#define FMAN_RTC_TMR_CTRL_CKSEL_MAC_CLK          0x00000001
+#define FMAN_RTC_TMR_CTRL_CKSEL_EXT_CLK          0x00000000
+#define FMAN_RTC_TMR_CTRL_TCLK_PERIOD_SHIFT      16
+
+#define FMAN_RTC_TMR_TEVENT_ETS2                 0x02000000
+#define FMAN_RTC_TMR_TEVENT_ETS1                 0x01000000
+#define FMAN_RTC_TMR_TEVENT_ALM2                 0x00020000
+#define FMAN_RTC_TMR_TEVENT_ALM1                 0x00010000
+#define FMAN_RTC_TMR_TEVENT_PP1                  0x00000080
+#define FMAN_RTC_TMR_TEVENT_PP2                  0x00000040
+#define FMAN_RTC_TMR_TEVENT_PP3                  0x00000020
+#define FMAN_RTC_TMR_TEVENT_ALL                  (FMAN_RTC_TMR_TEVENT_ETS2 |\
+						FMAN_RTC_TMR_TEVENT_ETS1 |\
+						FMAN_RTC_TMR_TEVENT_ALM2 |\
+						FMAN_RTC_TMR_TEVENT_ALM1 |\
+						FMAN_RTC_TMR_TEVENT_PP1 |\
+						FMAN_RTC_TMR_TEVENT_PP2 |\
+						FMAN_RTC_TMR_TEVENT_PP3)
+
+#define FMAN_RTC_TMR_PRSC_OCK_MASK               0x0000FFFF
+
+/**************************************************************************//**
+ @Description   FM RTC Alarm Polarity Options.
+*//***************************************************************************/
+enum fman_rtc_alarm_polarity {
+    E_FMAN_RTC_ALARM_POLARITY_ACTIVE_HIGH,  /**< Active-high output polarity */
+    E_FMAN_RTC_ALARM_POLARITY_ACTIVE_LOW    /**< Active-low output polarity */
+};
+
+/**************************************************************************//**
+ @Description   FM RTC Trigger Polarity Options.
+*//***************************************************************************/
+enum fman_rtc_trigger_polarity {
+    E_FMAN_RTC_TRIGGER_ON_RISING_EDGE,    /**< Trigger on rising edge */
+    E_FMAN_RTC_TRIGGER_ON_FALLING_EDGE    /**< Trigger on falling edge */
+};
+
+/**************************************************************************//**
+ @Description   IEEE1588 Timer Module FM RTC Optional Clock Sources.
+*//***************************************************************************/
+enum fman_src_clock {
+    E_FMAN_RTC_SOURCE_CLOCK_EXTERNAL,  /**< external high precision timer
+						reference clock */
+    E_FMAN_RTC_SOURCE_CLOCK_SYSTEM,    /**< MAC system clock */
+    E_FMAN_RTC_SOURCE_CLOCK_OSCILATOR  /**< RTC clock oscilator */
+};
+
+/* RTC default values */
+#define DEFAULT_SRC_CLOCK                E_FMAN_RTC_SOURCE_CLOCK_SYSTEM
+#define DEFAULT_INVERT_INPUT_CLK_PHASE   FALSE
+#define DEFAULT_INVERT_OUTPUT_CLK_PHASE  FALSE
+#define DEFAULT_ALARM_POLARITY           E_FMAN_RTC_ALARM_POLARITY_ACTIVE_HIGH
+#define DEFAULT_TRIGGER_POLARITY         E_FMAN_RTC_TRIGGER_ON_FALLING_EDGE
+#define DEFAULT_PULSE_REALIGN            FALSE
+
+#define FMAN_RTC_MAX_NUM_OF_ALARMS 3
+#define FMAN_RTC_MAX_NUM_OF_PERIODIC_PULSES 4
+#define FMAN_RTC_MAX_NUM_OF_EXT_TRIGGERS 3
+
+/**************************************************************************//**
+ @Description FM RTC timer alarm
+*//***************************************************************************/
+struct t_tmr_alarm{
+    uint32_t   tmr_alarm_h;    /**<  */
+    uint32_t   tmr_alarm_l;    /**<  */
+};
+
+/**************************************************************************//**
+ @Description FM RTC timer Ex trigger
+*//***************************************************************************/
+struct t_tmr_ext_trigger{
+    uint32_t   tmr_etts_h;     /**<  */
+    uint32_t   tmr_etts_l;     /**<  */
+};
+
+struct rtc_regs {
+    uint32_t tmr_id;      /* 0x000 Module ID register */
+    uint32_t tmr_id2;     /* 0x004 Controller ID register */
+    uint32_t reserved0008[30];
+    uint32_t tmr_ctrl;    /* 0x0080 timer control register */
+    uint32_t tmr_tevent;  /* 0x0084 timer event register */
+    uint32_t tmr_temask;  /* 0x0088 timer event mask register */
+    uint32_t reserved008c[3];
+    uint32_t tmr_cnt_h;   /* 0x0098 timer counter high register */
+    uint32_t tmr_cnt_l;   /* 0x009c timer counter low register */
+    uint32_t tmr_add;     /* 0x00a0 timer drift compensation addend register */
+    uint32_t tmr_acc;     /* 0x00a4 timer accumulator register */
+    uint32_t tmr_prsc;    /* 0x00a8 timer prescale */
+    uint32_t reserved00ac;
+    uint32_t tmr_off_h;    /* 0x00b0 timer offset high */
+    uint32_t tmr_off_l;    /* 0x00b4 timer offset low  */
+    struct t_tmr_alarm tmr_alarm[FMAN_RTC_MAX_NUM_OF_ALARMS]; /* 0x00b8 timer
+								alarm */
+    uint32_t tmr_fiper[FMAN_RTC_MAX_NUM_OF_PERIODIC_PULSES]; /* 0x00d0 timer
+						fixed period interval */
+    struct t_tmr_ext_trigger tmr_etts[FMAN_RTC_MAX_NUM_OF_EXT_TRIGGERS];
+			/* 0x00e0 time stamp general purpose external */
+    uint32_t reserved00f0[4];
+};
+
+struct rtc_cfg {
+    enum fman_src_clock            src_clk;
+    uint32_t                ext_src_clk_freq;
+    uint32_t                rtc_freq_hz;
+    bool                    timer_slave_mode;
+    bool                    invert_input_clk_phase;
+    bool                    invert_output_clk_phase;
+    uint32_t                events_mask;
+    bool                    bypass; /**< Indicates if frequency compensation
+					is bypassed */
+    bool                    pulse_realign;
+    enum fman_rtc_alarm_polarity    alarm_polarity[FMAN_RTC_MAX_NUM_OF_ALARMS];
+    enum fman_rtc_trigger_polarity  trigger_polarity
+					[FMAN_RTC_MAX_NUM_OF_EXT_TRIGGERS];
+};
+
+/**
+ * fman_rtc_defconfig() - Get default RTC configuration
+ * @cfg:	pointer to configuration structure.
+ *
+ * Call this function to obtain a default set of configuration values for
+ * initializing RTC.  The user can overwrite any of the values before calling
+ * fman_rtc_init(), if specific configuration needs to be applied.
+ */
+void fman_rtc_defconfig(struct rtc_cfg *cfg);
+
+/**
+ * fman_rtc_get_events() - Get the events
+ * @regs:		Pointer to RTC register block
+ *
+ * Returns: The events
+ */
+uint32_t fman_rtc_get_events(struct rtc_regs *regs);
+
+/**
+ * fman_rtc_get_interrupt_mask() - Get the events mask
+ * @regs:		Pointer to RTC register block
+ *
+ * Returns: The events mask
+ */
+uint32_t fman_rtc_get_interrupt_mask(struct rtc_regs *regs);
+
+
+/**
+ * fman_rtc_set_interrupt_mask() - Set the events mask
+ * @regs:		Pointer to RTC register block
+ * @mask:		The mask to set
+ */
+void fman_rtc_set_interrupt_mask(struct rtc_regs *regs, uint32_t mask);
+
+/**
+ * fman_rtc_get_event() - Check if specific events occured
+ * @regs:		Pointer to RTC register block
+ * @ev_mask:	a mask of the events to check
+ *
+ * Returns: 0 if the events did not occur. Non zero if one of the events occured
+ */
+uint32_t fman_rtc_get_event(struct rtc_regs *regs, uint32_t ev_mask);
+
+/**
+ * fman_rtc_check_and_clear_event() - Clear events which are on
+ * @regs:		Pointer to RTC register block
+ *
+ * Returns: A mask of the events which were cleared
+ */
+uint32_t fman_rtc_check_and_clear_event(struct rtc_regs *regs);
+
+/**
+ * fman_rtc_ack_event() - Clear events
+ * @regs:		Pointer to RTC register block
+ * @events:		The events to disable
+ */
+void fman_rtc_ack_event(struct rtc_regs *regs, uint32_t events);
+
+/**
+ * fman_rtc_enable_interupt() - Enable events interrupts
+ * @regs:		Pointer to RTC register block
+ * @mask:		The events to disable
+ */
+void fman_rtc_enable_interupt(struct rtc_regs *regs, uint32_t mask);
+
+/**
+ * fman_rtc_disable_interupt() - Disable events interrupts
+ * @regs:		Pointer to RTC register block
+ * @mask:		The events to disable
+ */
+void fman_rtc_disable_interupt(struct rtc_regs *regs, uint32_t mask);
+
+/**
+ * fman_rtc_get_timer_ctrl() - Get the control register
+ * @regs:		Pointer to RTC register block
+ *
+ * Returns: The control register value
+ */
+uint32_t fman_rtc_get_timer_ctrl(struct rtc_regs *regs);
+
+/**
+ * fman_rtc_set_timer_ctrl() - Set timer control register
+ * @regs:		Pointer to RTC register block
+ * @val:		The value to set
+ */
+void fman_rtc_set_timer_ctrl(struct rtc_regs *regs, uint32_t val);
+
+/**
+ * fman_rtc_get_frequency_compensation() - Get the frequency compensation
+ * @regs:		Pointer to RTC register block
+ *
+ * Returns: The timer counter
+ */
+uint32_t fman_rtc_get_frequency_compensation(struct rtc_regs *regs);
+
+/**
+ * fman_rtc_set_frequency_compensation() - Set frequency compensation
+ * @regs:		Pointer to RTC register block
+ * @val:		The value to set
+ */
+void fman_rtc_set_frequency_compensation(struct rtc_regs *regs, uint32_t val);
+
+/**
+ * fman_rtc_get_trigger_stamp() - Get a trigger stamp
+ * @regs:		Pointer to RTC register block
+ * @id:	The id of the trigger stamp
+ *
+ * Returns: The time stamp
+ */
+uint64_t fman_rtc_get_trigger_stamp(struct rtc_regs *regs,  int id);
+
+/**
+ * fman_rtc_set_timer_alarm_l() - Set timer alarm low register
+ * @regs:		Pointer to RTC register block
+ * @index:		The index of alarm to set
+ * @val:		The value to set
+ */
+void fman_rtc_set_timer_alarm_l(struct rtc_regs *regs, int index,
+		uint32_t val);
+
+/**
+ * fman_rtc_set_timer_alarm() - Set timer alarm
+ * @regs:		Pointer to RTC register block
+ * @index:		The index of alarm to set
+ * @val:		The value to set
+ */
+void fman_rtc_set_timer_alarm(struct rtc_regs *regs, int index, int64_t val);
+
+/**
+ * fman_rtc_set_timer_fiper() - Set timer fiper
+ * @regs:		Pointer to RTC register block
+ * @index:		The index of fiper to set
+ * @val:		The value to set
+ */
+void fman_rtc_set_timer_fiper(struct rtc_regs *regs, int index, uint32_t val);
+
+/**
+ * fman_rtc_set_timer_offset() - Set timer offset
+ * @regs:		Pointer to RTC register block
+ * @val:		The value to set
+ */
+void fman_rtc_set_timer_offset(struct rtc_regs *regs, int64_t val);
+
+/**
+ * fman_rtc_get_timer() - Get the timer counter
+ * @regs:		Pointer to RTC register block
+ *
+ * Returns: The timer counter
+ */
+static inline uint64_t fman_rtc_get_timer(struct rtc_regs *regs)
+{
+	uint64_t time;
+    /* TMR_CNT_L must be read first to get an accurate value */
+    time = (uint64_t)ioread32be(&regs->tmr_cnt_l);
+    time |= ((uint64_t)ioread32be(&regs->tmr_cnt_h) << 32);
+
+    return time;
+}
+
+/**
+ * fman_rtc_set_timer() - Set timer counter
+ * @regs:		Pointer to RTC register block
+ * @val:		The value to set
+ */
+static inline void fman_rtc_set_timer(struct rtc_regs *regs, int64_t val)
+{
+	iowrite32be((uint32_t)val, &regs->tmr_cnt_l);
+	iowrite32be((uint32_t)(val >> 32), &regs->tmr_cnt_h);
+}
+
+/**
+ * fman_rtc_timers_soft_reset() - Soft reset
+ * @regs:		Pointer to RTC register block
+ *
+ * Resets all the timer registers and state machines for the 1588 IP and
+ * the attached client 1588
+ */
+void fman_rtc_timers_soft_reset(struct rtc_regs *regs);
+
+/**
+ * fman_rtc_clear_external_trigger() - Clear an external trigger
+ * @regs:		Pointer to RTC register block
+ * @id: The id of the trigger to clear
+ */
+void fman_rtc_clear_external_trigger(struct rtc_regs *regs, int id);
+
+/**
+ * fman_rtc_clear_periodic_pulse() - Clear periodic pulse
+ * @regs:		Pointer to RTC register block
+ * @id: The id of the fiper to clear
+ */
+void fman_rtc_clear_periodic_pulse(struct rtc_regs *regs, int id);
+
+/**
+ * fman_rtc_enable() - Enable RTC hardware block
+ * @regs:		Pointer to RTC register block
+ */
+void fman_rtc_enable(struct rtc_regs *regs, bool reset_clock);
+
+/**
+ * fman_rtc_is_enabled() - Is RTC hardware block enabled
+ * @regs:		Pointer to RTC register block
+ *
+ * Return: TRUE if enabled
+ */
+bool fman_rtc_is_enabled(struct rtc_regs *regs);
+
+/**
+ * fman_rtc_disable() - Disable RTC hardware block
+ * @regs:		Pointer to RTC register block
+ */
+void fman_rtc_disable(struct rtc_regs *regs);
+
+/**
+ * fman_rtc_init() - Init RTC hardware block
+ * @cfg:		RTC configuration data
+ * @regs:		Pointer to RTC register block
+ * @num_alarms:		Number of alarms in RTC
+ * @num_fipers:		Number of fipers in RTC
+ * @num_ext_triggers:	Number of external triggers in RTC
+ * @freq_compensation:		Frequency compensation
+ * @output_clock_divisor:		Output clock divisor
+ *
+ * This function initializes RTC and applies basic configuration.
+ */
+void fman_rtc_init(struct rtc_cfg *cfg, struct rtc_regs *regs, int num_alarms,
+		int num_fipers, int num_ext_triggers, bool init_freq_comp,
+		uint32_t freq_compensation, uint32_t output_clock_divisor);
+
+/**
+ * fman_rtc_set_alarm() - Set an alarm
+ * @regs:		Pointer to RTC register block
+ * @id:			id of alarm
+ * @val:		value to write
+ * @enable:		should interrupt be enabled
+ */
+void fman_rtc_set_alarm(struct rtc_regs *regs, int id, uint32_t val, bool enable);
+
+/**
+ * fman_rtc_set_periodic_pulse() - Set an alarm
+ * @regs:		Pointer to RTC register block
+ * @id:			id of fiper
+ * @val:		value to write
+ * @enable:		should interrupt be enabled
+ */
+void fman_rtc_set_periodic_pulse(struct rtc_regs *regs, int id, uint32_t val,
+	bool enable);
+
+/**
+ * fman_rtc_set_ext_trigger() - Set an external trigger
+ * @regs:		Pointer to RTC register block
+ * @id:			id of trigger
+ * @enable:		should interrupt be enabled
+ * @use_pulse_as_input: use the pulse as input
+ */
+void fman_rtc_set_ext_trigger(struct rtc_regs *regs, int id, bool enable,
+	bool use_pulse_as_input);
+
+#endif /* __FSL_FMAN_RTC_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_sp.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_sp.h
new file mode 100755
index 0000000..f8ef7d5
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_sp.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright 2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_SP_H
+#define __FSL_FMAN_SP_H
+
+#include "common/general.h"
+#include "fsl_fman.h"
+
+
+struct fm_pcd_storage_profile_regs{
+	uint32_t   fm_sp_ebmpi[8];
+					/*offset 0 - 0xc*/
+					/**< Buffer Manager pool Information */
+
+	uint32_t   fm_sp_acnt;      /*offset 0x20*/
+	uint32_t   fm_sp_ebm;       /*offset 0x24*/
+	uint32_t   fm_sp_da;        /*offset 0x28*/
+	uint32_t   fm_sp_icp;       /*offset 0x2c*/
+	uint32_t   fm_sp_mpd;       /*offset 0x30*/
+	uint32_t   res1[2];         /*offset 0x34 - 0x38*/
+	uint32_t   fm_sp_spliodn;   /*offset 0x3c*/
+};
+
+/**************************************************************************//**
+ @Description   structure for defining internal context copying
+*//***************************************************************************/
+struct fman_sp_int_context_data_copy{
+	uint16_t ext_buf_offset;     /**< Offset in External buffer to which
+					internal context is copied to (Rx)
+					or taken from (Tx, Op). */
+	uint8_t int_context_offset; /**< Offset within internal context to copy
+					from (Rx) or to copy to (Tx, Op).*/
+	uint16_t size;             /**< Internal offset size to be copied */
+};
+
+/**************************************************************************//**
+ @Description   struct for defining external buffer margins
+*//***************************************************************************/
+struct fman_sp_buf_margins{
+	uint16_t start_margins;	/**< Number of bytes to be left at the
+				beginning of the external buffer (must be
+				divisible by 16) */
+	uint16_t end_margins;   /**< number of bytes to be left at the end of
+				 the external buffer(must be divisible by 16)*/
+};
+
+struct fm_storage_profile_params {
+	struct fman_ext_pools          		fm_ext_pools;
+	struct fman_backup_bm_pools   		backup_pools;
+	struct fman_sp_int_context_data_copy 	*int_context;
+	struct fman_sp_buf_margins            	*buf_margins;
+	enum fman_dma_swap_option    		dma_swap_data;
+	enum fman_dma_cache_option          	int_context_cache_attr;
+	enum fman_dma_cache_option          	header_cache_attr;
+	enum fman_dma_cache_option          	scatter_gather_cache_attr;
+	bool                        		dma_write_optimize;
+	uint16_t                    		liodn_offset;
+	bool                        		no_scather_gather;
+	struct fman_buf_pool_depletion        buf_pool_depletion;
+};
+
+/**************************************************************************//**
+ @Description       Registers bit fields
+*//***************************************************************************/
+#define FMAN_SP_EXT_BUF_POOL_EN_COUNTER             0x40000000
+#define FMAN_SP_EXT_BUF_POOL_VALID                  0x80000000
+#define FMAN_SP_EXT_BUF_POOL_BACKUP                 0x20000000
+#define FMAN_SP_DMA_ATTR_WRITE_OPTIMIZE             0x00100000
+#define FMAN_SP_SG_DISABLE                          0x80000000
+
+/* shifts */
+#define FMAN_SP_EXT_BUF_POOL_ID_SHIFT               16
+#define FMAN_SP_POOL_DEP_NUM_OF_POOLS_SHIFT         16
+#define FMAN_SP_EXT_BUF_MARG_START_SHIFT            16
+#define FMAN_SP_EXT_BUF_MARG_END_SHIFT              0
+#define FMAN_SP_DMA_ATTR_SWP_SHIFT                  30
+#define FMAN_SP_DMA_ATTR_IC_CACHE_SHIFT             28
+#define FMAN_SP_DMA_ATTR_HDR_CACHE_SHIFT            26
+#define FMAN_SP_DMA_ATTR_SG_CACHE_SHIFT             24
+#define FMAN_SP_IC_TO_EXT_SHIFT                     16
+#define FMAN_SP_IC_FROM_INT_SHIFT                   8
+#define FMAN_SP_IC_SIZE_SHIFT                       0
+
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+#define DEFAULT_FMAN_SP_DMA_SWAP_DATA                         FMAN_DMA_NO_SWP
+#define DEFAULT_FMAN_SP_DMA_INT_CONTEXT_CACHE_ATTR            FMAN_DMA_NO_STASH
+#define DEFAULT_FMAN_SP_DMA_HEADER_CACHE_ATTR                 FMAN_DMA_NO_STASH
+#define DEFAULT_FMAN_SP_DMA_SCATTER_GATHER_CACHE_ATTR         FMAN_DMA_NO_STASH
+#define DEFAULT_FMAN_SP_DMA_WRITE_OPTIMIZE                    TRUE
+#define DEFAULT_FMAN_SP_NO_SCATTER_GATHER                     FALSE
+
+void fman_vsp_defconfig(struct fm_storage_profile_params *cfg);
+
+void fman_vsp_init(struct fm_pcd_storage_profile_regs   *regs,
+	uint16_t index, struct fm_storage_profile_params *fm_vsp_params,
+	int port_max_num_of_ext_pools, int bm_max_num_of_pools,
+	int max_num_of_pfc_priorities);
+
+uint32_t fman_vsp_get_statistics(struct fm_pcd_storage_profile_regs *regs,
+					uint16_t index);
+
+void fman_vsp_set_statistics(struct fm_pcd_storage_profile_regs *regs,
+			uint16_t index,	uint32_t value);
+
+
+#endif /* __FSL_FMAN_SP_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_tgec.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_tgec.h
index 2505888..b95ef37 100644
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_tgec.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_tgec.h
@@ -328,8 +328,8 @@ struct tgec_regs {
  *            (increasing bandwidth).
  *
  * This structure contains basic TGEC configuration and must be passed to
- * tgec_init() function.  A default set of configuration values can be obtained
- * by calling tgec_defconfig().
+ * fman_tgec_init() function.  A default set of configuration values can be obtained
+ * by calling fman_tgec_defconfig().
  */
 struct tgec_cfg {
 	bool		rx_error_discard;
@@ -350,46 +350,66 @@ struct tgec_cfg {
 	bool		skip_fman11_workaround;
 };
 
-void tgec_set_mac_address(struct tgec_regs *regs, uint8_t *macaddr);
+
+void fman_tgec_defconfig(struct tgec_cfg *cfg);
+
+/**
+ * fman_tgec_init() - Init tgec hardware block
+ * @regs:        Pointer to tgec register block
+ * @cfg:        tgec configuration data
+ * @exceptions_mask:    initial exceptions mask
+ *
+ * This function initializes the tgec controller and applies its
+ * basic configuration.
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+
+int fman_tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
+	uint32_t exception_mask);
+
+void fman_tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
+
+void fman_tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
+
+uint32_t fman_tgec_get_revision(struct tgec_regs *regs);
+
+void fman_tgec_set_mac_address(struct tgec_regs *regs, uint8_t *macaddr);
+
+void fman_tgec_set_promiscuous(struct tgec_regs *regs, bool val);
 
 /**
- * tgec_reset_stat() - Completely resets all TGEC HW counters
+ * fman_tgec_reset_stat() - Completely resets all TGEC HW counters
  * @regs:    Pointer to TGEC register block
  */
-void tgec_reset_stat(struct tgec_regs *regs);
+void fman_tgec_reset_stat(struct tgec_regs *regs);
 
 /**
- * tgec_get_counter() - Reads TGEC HW counters
+ * fman_tgec_get_counter() - Reads TGEC HW counters
  * @regs:    Pointer to TGEC register block
  * @reg_name:    Counter name according to the appropriate enum
  *
  * Returns:    Required counter value
  */
-
-uint64_t tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name);
-
-void tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
-void tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
-void tgec_set_promiscuous(struct tgec_regs *regs, bool val);
+uint64_t fman_tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name);
 
 /**
- * tgec_set_hash_table() - Sets the Hashtable Control Register
+ * fman_tgec_set_hash_table() - Sets the Hashtable Control Register
  * @regs:    Pointer to TGEC register block
  * @value:    Value to be written in Hashtable Control Register
  */
-void tgec_set_hash_table(struct tgec_regs *regs, uint32_t value);
+void fman_tgec_set_hash_table(struct tgec_regs *regs, uint32_t value);
 
 /**
- * tgec_tx_mac_pause() - Sets the Pause Quanta Register
+ * fman_tgec_set_tx_pause_frames() - Sets the Pause Quanta Register
  * @regs:    Pointer to TGEC register block
  * @pause_time:    Pause quanta value used with transmitted pause frames.
  *        Each quanta represents a 512 bit-times
  */
-
-void tgec_tx_mac_pause(struct tgec_regs *regs, uint16_t pause_time);
+void fman_tgec_set_tx_pause_frames(struct tgec_regs *regs, uint16_t pause_time);
 
 /**
- * tgec_rx_ignore_mac_pause() - Changes the policy WRT pause frames
+ * fman_tgec_set_rx_ignore_pause_frames() - Changes the policy WRT pause frames
  * @regs:    Pointer to TGEC register block
  * @en:        Ignore/Respond to pause frame quanta
  *
@@ -398,11 +418,10 @@ void tgec_tx_mac_pause(struct tgec_regs *regs, uint16_t pause_time);
  * in the Pause frame quanta of a received Pause frame.
  * 1 - MAC ignores received Pause frames.
  */
-
-void tgec_rx_ignore_mac_pause(struct tgec_regs *regs, bool en);
+void fman_tgec_set_rx_ignore_pause_frames(struct tgec_regs *regs, bool en);
 
 /**
- * tgec_enable_1588_time_stamp() - change timestamp functionality
+ * fman_tgec_enable_1588_time_stamp() - change timestamp functionality
  * @regs:    Pointer to TGEC register block
  * @en:        enable/disable timestamp functionality
  *
@@ -411,62 +430,42 @@ void tgec_rx_ignore_mac_pause(struct tgec_regs *regs, bool en);
  * 0 disabled, 1 enabled
  */
 
-void tgec_enable_1588_time_stamp(struct tgec_regs *regs, bool en);
+void fman_tgec_enable_1588_time_stamp(struct tgec_regs *regs, bool en);
+
+uint32_t fman_tgec_get_event(struct tgec_regs *regs, uint32_t ev_mask);
 
-uint32_t tgec_get_event(struct tgec_regs *regs, uint32_t ev_mask);
-void tgec_ack_event(struct tgec_regs *regs, uint32_t ev_mask);
-uint32_t tgec_get_interrupt_mask(struct tgec_regs *regs);
+void fman_tgec_ack_event(struct tgec_regs *regs, uint32_t ev_mask);
 
+uint32_t fman_tgec_get_interrupt_mask(struct tgec_regs *regs);
 
 /**
- * tgec_add_addr_in_paddr() - Sets additional exact match MAC address
+ * fman_tgec_add_addr_in_paddr() - Sets additional exact match MAC address
  * @regs:    Pointer to TGEC register block
  * @addr_ptr:    Pointer to 6-byte array containing the MAC address
  *
  * Sets the additional station MAC address
  */
+void fman_tgec_add_addr_in_paddr(struct tgec_regs *regs, uint8_t *addr_ptr);
 
-void tgec_add_addr_in_paddr(struct tgec_regs *regs, uint8_t *addr_ptr);
-void tgec_clear_addr_in_paddr(struct tgec_regs *regs);
-uint32_t tgec_get_revision(struct tgec_regs *regs);
-void tgec_enable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
-void tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
+void fman_tgec_clear_addr_in_paddr(struct tgec_regs *regs);
 
-/**
- * tgec_get_max_frame_len() - Returns the maximum frame length value
- * @regs:    Pointer to TGEC register block
- */
+void fman_tgec_enable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
 
-uint16_t tgec_get_max_frame_len(struct tgec_regs *regs);
+void fman_tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
 
 /**
- * tgec_defconfig() - Initialize the main tgec configuration parameters
- * @cfg:    Pointer to tgec_cfg structure
- *
- * This routine determines the values of the tgec_cfg structure members.
- * This structure represents the initial parameters which the tgec controller
- * will be initialized with later when calling the tgec_init function.
+ * fman_tgec_get_max_frame_len() - Returns the maximum frame length value
+ * @regs:    Pointer to TGEC register block
  */
-
-void tgec_defconfig(struct tgec_cfg *cfg);
+uint16_t fman_tgec_get_max_frame_len(struct tgec_regs *regs);
 
 /**
- * tgec_init() - Init tgec hardware block
- * @regs:        Pointer to tgec register block
- * @cfg:        tgec configuration data
- * @exceptions_mask:    initial exceptions mask
- *
- * This function initializes the tgec controller and applies its
- * basic configuration.
+ * fman_tgec_set_erratum_tx_fifo_corruption_10gmac_a007() - Initialize the main tgec configuration parameters
+ * @regs:    Pointer to TGEC register block
  *
- * Returns: 0 if successful, an error code otherwise.
+ * TODO
  */
-
-int tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
-        uint32_t exception_mask);
-
-
-void tgec_fm_tx_fifo_corruption_errata_10gmac_a007(struct tgec_regs *regs);
+void fman_tgec_set_erratum_tx_fifo_corruption_10gmac_a007(struct tgec_regs *regs);
 
 
 #endif /* __FSL_FMAN_TGEC_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h
index cbc322a..92906db 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h
@@ -110,16 +110,19 @@ typedef enum {
 #define INTG_MAX_NUM_OF_FM          1
 
 /* Ports defines */
-#define FM_MAX_NUM_OF_1G_RX_PORTS   2
-#define FM_MAX_NUM_OF_10G_RX_PORTS  0
-#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_1G_TX_PORTS   2
-#define FM_MAX_NUM_OF_10G_TX_PORTS  0
-#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
+#define FM_MAX_NUM_OF_1G_MACS       2
+#define FM_MAX_NUM_OF_10G_MACS      0
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
 #define FM_MAX_NUM_OF_OH_PORTS      5
-#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
-#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS)
+
+#define FM_MAX_NUM_OF_1G_TX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_TX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS + FM_MAX_NUM_OF_1G_TX_PORTS)
+
 #define FM_MAX_NUM_OF_MACSECS       1
 
 #define FM_MACSEC_SUPPORT
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index a655882..257acb0 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -43,11 +43,7 @@
 
 #define DPAA_VERSION    10
 
-/**************************************************************************//**
- @Description   DPAA SW Portals Enumeration.
-*//***************************************************************************/
-typedef enum
-{
+typedef enum {
     e_DPAA_SWPORTAL0 = 0,
     e_DPAA_SWPORTAL1,
     e_DPAA_SWPORTAL2,
@@ -61,11 +57,7 @@ typedef enum
     e_DPAA_SWPORTAL_DUMMY_LAST
 } e_DpaaSwPortal;
 
-/**************************************************************************//**
- @Description   DPAA Direct Connect Portals Enumeration.
-*//***************************************************************************/
-typedef enum
-{
+typedef enum {
     e_DPAA_DCPORTAL0 = 0,
     e_DPAA_DCPORTAL1,
     e_DPAA_DCPORTAL2,
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
index 641d6c8..be08780 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
@@ -178,13 +178,13 @@ typedef enum
 ******************************************************************************/
 #define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
 
-
 /*****************************************************************************
  SEC INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
 #define SEC_NUM_OF_DECOS            3
 #define SEC_ALL_DECOS_MASK          0x00000003
 
+
 /*****************************************************************************
  FM INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
@@ -259,6 +259,7 @@ typedef enum
 /* FM errata */
 #define FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
 #define FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
+#define FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
 
 #define FM_BCB_ERRATA_BMI_SW001
 #define FM_LEN_CHECK_ERRATA_FMAN_SW002
diff --git a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/fsl_fman.h b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/fsl_fman.h
deleted file mode 100644
index 89d022b..0000000
--- a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/fsl_fman.h
+++ /dev/null
@@ -1,347 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/******************************************************************************
- @File		fsl_fman.h
-
- @Description	Linux internal kernel API
-*//***************************************************************************/
-
-#ifndef __FSL_FMAN_H
-#define __FSL_FMAN_H
-
-#include <linux/types.h>
-#include <linux/device.h>   /* struct device */
-#include <linux/fsl_qman.h> /* struct qman_fq */
-#include "dpaa_integration_ext.h"
-#include "fm_port_ext.h"
-
-/**************************************************************************//**
- @Group		FM_LnxKern_grp Frame Manager Linux wrapper API
-
- @Description	FM API functions, definitions and enums.
-
- @{
-*//***************************************************************************/
-
-/**************************************************************************//**
- @Group		FM_LnxKern_ctrl_grp Control Unit
-
- @Description	Control Unit
-
-		Internal Kernel Control Unit API
- @{
-*//***************************************************************************/
-
-/*****************************************************************************/
-/*                  Internal Linux kernel routines                           */
-/*****************************************************************************/
-
-/**************************************************************************//**
- @Description	A structure ..,
-*//***************************************************************************/
-struct fm;
-
-/**************************************************************************//**
- @Description	A structure ..,
-*//***************************************************************************/
-struct fm_port;
-
-typedef int (*alloc_pcd_fqids)(struct device *dev, uint32_t num,
-			       uint8_t alignment, uint32_t *base_fqid);
-
-typedef int (*free_pcd_fqids)(struct device *dev, uint32_t base_fqid);
-
-struct fm_port_pcd_param {
-	alloc_pcd_fqids	 cba;
-	free_pcd_fqids	 cbf;
-	struct device	*dev;
-};
-
-/**************************************************************************//**
- @Description	A structure of information about each of the external
-		buffer pools used by the port,
-*//***************************************************************************/
-struct fm_port_pool_param {
-	uint8_t		id;		/**< External buffer pool id */
-	uint16_t	size;		/**< External buffer pool buffer size */
-};
-
-/**************************************************************************//**
- @Description   structure for additional port parameters
-*//***************************************************************************/
-struct fm_port_params {
-	uint32_t errq;	    /**< Error Queue Id. */
-	uint32_t defq;	    /**< For Tx and HC - Default Confirmation queue,
-				 0 means no Tx conf for processed frames.
-				 For Rx and OP - default Rx queue. */
-	uint8_t	num_pools;  /**< Number of pools use by this port */
-	struct fm_port_pool_param pool_param[FM_PORT_MAX_NUM_OF_EXT_POOLS];
-			    /**< Parameters for each pool */
-	uint16_t priv_data_size;  /**< Area that user may save for his own
-				       need (E.g. save the SKB) */
-	bool parse_results; /**< Put the parser-results in the Rx/Tx buffer */
-	bool hash_results;  /**< Put the hash-results in the Rx/Tx buffer */
-	bool time_stamp;    /**< Put the time-stamp in the Rx/Tx buffer */
-	bool frag_enable;   /**< Fragmentation support, for OP only */
-	uint16_t data_align;  /**< value for selecting a data alignment (must be a power of 2);
-                               if write optimization is used, must be >= 16. */
-	uint8_t manip_extra_space;  /**< Maximum extra size needed (insertion-size minus removal-size);
-                                     Note that this field impacts the size of the buffer-prefix
-                                     (i.e. it pushes the data offset); */
-};
-
-/**************************************************************************//**
- @Function	fm_bind
-
- @Description	Bind to a specific FM device.
-
- @Param[in]	fm_dev	- the OF handle of the FM device.
-
- @Return	A handle of the FM device.
-
- @Cautions	Allowed only after the port was created.
-*//***************************************************************************/
-struct fm *fm_bind(struct device *fm_dev);
-
-/**************************************************************************//**
- @Function	fm_unbind
-
- @Description	Un-bind from a specific FM device.
-
- @Param[in]	fm	- A handle of the FM device.
-
- @Cautions	Allowed only after the port was created.
-*//***************************************************************************/
-void fm_unbind(struct fm *fm);
-
-void *fm_get_handle(struct fm *fm);
-void *fm_get_rtc_handle(struct fm *fm);
-struct resource *fm_get_mem_region(struct fm *fm);
-
-/**************************************************************************//**
- @Function	fm_port_bind
-
- @Description	Bind to a specific FM-port device (may be Rx or Tx port).
-
- @Param[in]	fm_port_dev - the OF handle of the FM port device.
-
- @Return	A handle of the FM port device.
-
- @Cautions	Allowed only after the port was created.
-*//***************************************************************************/
-struct fm_port *fm_port_bind(struct device *fm_port_dev);
-
-/**************************************************************************//**
- @Function	fm_port_unbind
-
- @Description	Un-bind from a specific FM-port device (may be Rx or Tx port).
-
- @Param[in]	port	- A handle of the FM port device.
-
- @Cautions	Allowed only after the port was created.
-*//***************************************************************************/
-void fm_port_unbind(struct fm_port *port);
-
-/**************************************************************************//**
- @Function	fm_set_rx_port_params
-
- @Description	Configure parameters for a specific Rx FM-port device.
-
- @Param[in]	port	- A handle of the FM port device.
- @Param[in]	params	- Rx port parameters
-
- @Cautions	Allowed only after the port is binded.
-*//***************************************************************************/
-void fm_set_rx_port_params(struct fm_port *port,
-			   struct fm_port_params *params);
-
-/**************************************************************************//**
- @Function	fm_port_pcd_bind
-
- @Description	Bind as a listener on a port PCD.
-
- @Param[in]	port	- A handle of the FM port device.
- @Param[in]	params	- PCD port parameters
-
- @Cautions	Allowed only after the port is binded.
-*//***************************************************************************/
-void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params);
-
-/**************************************************************************//**
- @Function	fm_port_get_buff_layout_ext_params
-
- @Description	Get data_align and manip_extra_space from the device tree
-                chosen node if aplied. 
-                This function will only update these two parameters.
-                When this port has no such parameters in the device tree
-                values will be set to 0.
-
- @Param[in]	port	- A handle of the FM port device.
- @Param[in]	params	- PCD port parameters
-
- @Cautions	Allowed only after the port is binded.
-*//***************************************************************************/
-void fm_port_get_buff_layout_ext_params(struct fm_port *port, struct fm_port_params *params);
-
-/**************************************************************************//**
- @Function	fm_get_tx_port_channel
-
- @Description	Get qman-channel number for this Tx port.
-
- @Param[in]	port	- A handle of the FM port device.
-
- @Return	qman-channel number for this Tx port.
-
- @Cautions	Allowed only after the port is binded.
-*//***************************************************************************/
-int fm_get_tx_port_channel(struct fm_port *port);
-
-/**************************************************************************//**
- @Function	fm_set_tx_port_params
-
- @Description	Configure parameters for a specific Tx FM-port device
-
- @Param[in]	port	- A handle of the FM port device.
- @Param[in]	params	- Tx port parameters
-
- @Cautions	Allowed only after the port is binded.
-*//***************************************************************************/
-void fm_set_tx_port_params(struct fm_port *port, struct fm_port_params *params);
-
-
-/**************************************************************************//**
- @Function	fm_mac_set_handle
-
- @Description	Set mac handle
-
- @Param[in]	h_lnx_wrp_fm_dev - A handle of the LnxWrp FM device.
- @Param[in]	h_fm_mac	 - A handle of the LnxWrp FM MAC device.
- @Param[in]	mac_id		 - MAC id.
-*//***************************************************************************/
-void fm_mac_set_handle(t_Handle h_lnx_wrp_fm_dev, t_Handle h_fm_mac,
-		       int mac_id);
-
-/**************************************************************************//**
- @Function	fm_port_enable
-
- @Description	Enable specific FM-port device (may be Rx or Tx port).
-
- @Param[in]	port	- A handle of the FM port device.
-
- @Cautions	Allowed only after the port is initialized.
-*//***************************************************************************/
-int fm_port_enable(struct fm_port *port);
-
-/**************************************************************************//**
- @Function	fm_port_disable
-
- @Description	Disable specific FM-port device (may be Rx or Tx port).
-
- @Param[in]	port	- A handle of the FM port device.
-
- @Cautions	Allowed only after the port is initialized.
-*//***************************************************************************/
-void fm_port_disable(struct fm_port *port);
-
-void *fm_port_get_handle(struct fm_port *port);
-
-/**************************************************************************//**
- @Function	fm_port_get_base_address
-
- @Description	Get base address of this port. Useful for accessing
-		port-specific registers (i.e., not common ones).
-
- @Param[in]	port		- A handle of the FM port device.
-
- @Param[out]	base_addr	- The port's base addr (virtual address).
-*//***************************************************************************/
-void fm_port_get_base_addr(const struct fm_port *port, uint64_t *base_addr);
-
-/**************************************************************************//**
- @Function	fm_mutex_lock
-
- @Description   Lock function required before any FMD/LLD call.
-*//***************************************************************************/
-void fm_mutex_lock(void);
-
-/**************************************************************************//**
- @Function	fm_mutex_unlock
-
- @Description   Unlock function required after any FMD/LLD call.
-*//***************************************************************************/
-void fm_mutex_unlock(void);
-
-/**************************************************************************//**
- @Function	fm_get_max_frm
-
- @Description   Get the maximum frame size
-*//***************************************************************************/
-int fm_get_max_frm(void);
-
-/**************************************************************************//**
- @Function	fm_get_rx_extra_headroom
-
- @Description   Get the extra headroom size
-*//***************************************************************************/
-int fm_get_rx_extra_headroom(void);
-
-/**************************************************************************//**
- @Function	fm_port_set_rate_limit
-
- @Description	Configure Shaper parameter on FM-port device (Tx port).
-
- @Param[in]	port	- A handle of the FM port device.
- @Param[in]	max_burst_size	- Value of maximum burst size allowed.
- @Param[in]	rate_limit	- The required rate value.
-
- @Cautions	Allowed only after the port is initialized.
-*//***************************************************************************/
-int fm_port_set_rate_limit(struct fm_port *port,
-			uint16_t	max_burst_size,
-			uint32_t	rate_limit);
-/**************************************************************************//**
- @Function	fm_port_set_rate_limit
-
- @Description	Delete Shaper configuration on FM-port device (Tx port).
-
- @Param[in]	port	- A handle of the FM port device.
-
- @Cautions	Allowed only after the port is initialized.
-*//***************************************************************************/
-int fm_port_del_rate_limit(struct fm_port *port);
-
-/** @} */ /* end of FM_LnxKern_ctrl_grp group */
-/** @} */ /* end of FM_LnxKern_grp group */
-
-
-#endif /* __FSL_FMAN_H */
diff --git a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fm_ext.h b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fm_ext.h
index 8dda657..1b56cbd 100644
--- a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fm_ext.h
+++ b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fm_ext.h
@@ -154,7 +154,7 @@ t_Error  LNXWRP_FM_TEST_Free(t_Handle h_FmTestLnxWrp);
  @{
 *//***************************************************************************/
 
-#include "fsl_fman.h"
+#include "lnxwrp_fsl_fman.h"
 
 /** @} */ /* end of FM_LnxKern_ctrl_grp group */
 /** @} */ /* end of FM_LnxKern_grp group */
diff --git a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
new file mode 100644
index 0000000..595a7c7
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
@@ -0,0 +1,347 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File		lnxwrp_fsl_fman.h
+
+ @Description	Linux internal kernel API
+*//***************************************************************************/
+
+#ifndef __LNXWRP_FSL_FMAN_H
+#define __LNXWRP_FSL_FMAN_H
+
+#include <linux/types.h>
+#include <linux/device.h>   /* struct device */
+#include <linux/fsl_qman.h> /* struct qman_fq */
+#include "dpaa_integration_ext.h"
+#include "fm_port_ext.h"
+
+/**************************************************************************//**
+ @Group		FM_LnxKern_grp Frame Manager Linux wrapper API
+
+ @Description	FM API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group		FM_LnxKern_ctrl_grp Control Unit
+
+ @Description	Control Unit
+
+		Internal Kernel Control Unit API
+ @{
+*//***************************************************************************/
+
+/*****************************************************************************/
+/*                  Internal Linux kernel routines                           */
+/*****************************************************************************/
+
+/**************************************************************************//**
+ @Description	A structure ..,
+*//***************************************************************************/
+struct fm;
+
+/**************************************************************************//**
+ @Description	A structure ..,
+*//***************************************************************************/
+struct fm_port;
+
+typedef int (*alloc_pcd_fqids)(struct device *dev, uint32_t num,
+			       uint8_t alignment, uint32_t *base_fqid);
+
+typedef int (*free_pcd_fqids)(struct device *dev, uint32_t base_fqid);
+
+struct fm_port_pcd_param {
+	alloc_pcd_fqids	 cba;
+	free_pcd_fqids	 cbf;
+	struct device	*dev;
+};
+
+/**************************************************************************//**
+ @Description	A structure of information about each of the external
+		buffer pools used by the port,
+*//***************************************************************************/
+struct fm_port_pool_param {
+	uint8_t		id;		/**< External buffer pool id */
+	uint16_t	size;		/**< External buffer pool buffer size */
+};
+
+/**************************************************************************//**
+ @Description   structure for additional port parameters
+*//***************************************************************************/
+struct fm_port_params {
+	uint32_t errq;	    /**< Error Queue Id. */
+	uint32_t defq;	    /**< For Tx and HC - Default Confirmation queue,
+				 0 means no Tx conf for processed frames.
+				 For Rx and OP - default Rx queue. */
+	uint8_t	num_pools;  /**< Number of pools use by this port */
+	struct fm_port_pool_param pool_param[FM_PORT_MAX_NUM_OF_EXT_POOLS];
+			    /**< Parameters for each pool */
+	uint16_t priv_data_size;  /**< Area that user may save for his own
+				       need (E.g. save the SKB) */
+	bool parse_results; /**< Put the parser-results in the Rx/Tx buffer */
+	bool hash_results;  /**< Put the hash-results in the Rx/Tx buffer */
+	bool time_stamp;    /**< Put the time-stamp in the Rx/Tx buffer */
+	bool frag_enable;   /**< Fragmentation support, for OP only */
+	uint16_t data_align;  /**< value for selecting a data alignment (must be a power of 2);
+                               if write optimization is used, must be >= 16. */
+	uint8_t manip_extra_space;  /**< Maximum extra size needed (insertion-size minus removal-size);
+                                     Note that this field impacts the size of the buffer-prefix
+                                     (i.e. it pushes the data offset); */
+};
+
+/**************************************************************************//**
+ @Function	fm_bind
+
+ @Description	Bind to a specific FM device.
+
+ @Param[in]	fm_dev	- the OF handle of the FM device.
+
+ @Return	A handle of the FM device.
+
+ @Cautions	Allowed only after the port was created.
+*//***************************************************************************/
+struct fm *fm_bind(struct device *fm_dev);
+
+/**************************************************************************//**
+ @Function	fm_unbind
+
+ @Description	Un-bind from a specific FM device.
+
+ @Param[in]	fm	- A handle of the FM device.
+
+ @Cautions	Allowed only after the port was created.
+*//***************************************************************************/
+void fm_unbind(struct fm *fm);
+
+void *fm_get_handle(struct fm *fm);
+void *fm_get_rtc_handle(struct fm *fm);
+struct resource *fm_get_mem_region(struct fm *fm);
+
+/**************************************************************************//**
+ @Function	fm_port_bind
+
+ @Description	Bind to a specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]	fm_port_dev - the OF handle of the FM port device.
+
+ @Return	A handle of the FM port device.
+
+ @Cautions	Allowed only after the port was created.
+*//***************************************************************************/
+struct fm_port *fm_port_bind(struct device *fm_port_dev);
+
+/**************************************************************************//**
+ @Function	fm_port_unbind
+
+ @Description	Un-bind from a specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]	port	- A handle of the FM port device.
+
+ @Cautions	Allowed only after the port was created.
+*//***************************************************************************/
+void fm_port_unbind(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function	fm_set_rx_port_params
+
+ @Description	Configure parameters for a specific Rx FM-port device.
+
+ @Param[in]	port	- A handle of the FM port device.
+ @Param[in]	params	- Rx port parameters
+
+ @Cautions	Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_set_rx_port_params(struct fm_port *port,
+			   struct fm_port_params *params);
+
+/**************************************************************************//**
+ @Function	fm_port_pcd_bind
+
+ @Description	Bind as a listener on a port PCD.
+
+ @Param[in]	port	- A handle of the FM port device.
+ @Param[in]	params	- PCD port parameters
+
+ @Cautions	Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_port_pcd_bind (struct fm_port *port, struct fm_port_pcd_param *params);
+
+/**************************************************************************//**
+ @Function	fm_port_get_buff_layout_ext_params
+
+ @Description	Get data_align and manip_extra_space from the device tree
+                chosen node if aplied.
+                This function will only update these two parameters.
+                When this port has no such parameters in the device tree
+                values will be set to 0.
+
+ @Param[in]	port	- A handle of the FM port device.
+ @Param[in]	params	- PCD port parameters
+
+ @Cautions	Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_port_get_buff_layout_ext_params(struct fm_port *port, struct fm_port_params *params);
+
+/**************************************************************************//**
+ @Function	fm_get_tx_port_channel
+
+ @Description	Get qman-channel number for this Tx port.
+
+ @Param[in]	port	- A handle of the FM port device.
+
+ @Return	qman-channel number for this Tx port.
+
+ @Cautions	Allowed only after the port is binded.
+*//***************************************************************************/
+int fm_get_tx_port_channel(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function	fm_set_tx_port_params
+
+ @Description	Configure parameters for a specific Tx FM-port device
+
+ @Param[in]	port	- A handle of the FM port device.
+ @Param[in]	params	- Tx port parameters
+
+ @Cautions	Allowed only after the port is binded.
+*//***************************************************************************/
+void fm_set_tx_port_params(struct fm_port *port, struct fm_port_params *params);
+
+
+/**************************************************************************//**
+ @Function	fm_mac_set_handle
+
+ @Description	Set mac handle
+
+ @Param[in]	h_lnx_wrp_fm_dev - A handle of the LnxWrp FM device.
+ @Param[in]	h_fm_mac	 - A handle of the LnxWrp FM MAC device.
+ @Param[in]	mac_id		 - MAC id.
+*//***************************************************************************/
+void fm_mac_set_handle(t_Handle h_lnx_wrp_fm_dev, t_Handle h_fm_mac,
+		       int mac_id);
+
+/**************************************************************************//**
+ @Function	fm_port_enable
+
+ @Description	Enable specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]	port	- A handle of the FM port device.
+
+ @Cautions	Allowed only after the port is initialized.
+*//***************************************************************************/
+int fm_port_enable(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function	fm_port_disable
+
+ @Description	Disable specific FM-port device (may be Rx or Tx port).
+
+ @Param[in]	port	- A handle of the FM port device.
+
+ @Cautions	Allowed only after the port is initialized.
+*//***************************************************************************/
+void fm_port_disable(struct fm_port *port);
+
+void *fm_port_get_handle(struct fm_port *port);
+
+/**************************************************************************//**
+ @Function	fm_port_get_base_address
+
+ @Description	Get base address of this port. Useful for accessing
+		port-specific registers (i.e., not common ones).
+
+ @Param[in]	port		- A handle of the FM port device.
+
+ @Param[out]	base_addr	- The port's base addr (virtual address).
+*//***************************************************************************/
+void fm_port_get_base_addr(const struct fm_port *port, uint64_t *base_addr);
+
+/**************************************************************************//**
+ @Function	fm_mutex_lock
+
+ @Description   Lock function required before any FMD/LLD call.
+*//***************************************************************************/
+void fm_mutex_lock(void);
+
+/**************************************************************************//**
+ @Function	fm_mutex_unlock
+
+ @Description   Unlock function required after any FMD/LLD call.
+*//***************************************************************************/
+void fm_mutex_unlock(void);
+
+/**************************************************************************//**
+ @Function	fm_get_max_frm
+
+ @Description   Get the maximum frame size
+*//***************************************************************************/
+int fm_get_max_frm(void);
+
+/**************************************************************************//**
+ @Function	fm_get_rx_extra_headroom
+
+ @Description   Get the extra headroom size
+*//***************************************************************************/
+int fm_get_rx_extra_headroom(void);
+
+/**************************************************************************//**
+@Function     fm_port_set_rate_limit
+
+@Description  Configure Shaper parameter on FM-port device (Tx port).
+
+@Param[in]    port   - A handle of the FM port device.
+@Param[in]    max_burst_size - Value of maximum burst size allowed.
+@Param[in]    rate_limit     - The required rate value.
+
+@Cautions     Allowed only after the port is initialized.
+*//***************************************************************************/
+int fm_port_set_rate_limit(struct fm_port *port,
+                           uint16_t max_burst_size,
+                           uint32_t rate_limit);
+/**************************************************************************//**
+@Function     fm_port_set_rate_limit
+
+@Description  Delete Shaper configuration on FM-port device (Tx port).
+
+@Param[in]    port   - A handle of the FM port device.
+
+@Cautions     Allowed only after the port is initialized.
+*//***************************************************************************/
+int fm_port_del_rate_limit(struct fm_port *port);
+
+/** @} */ /* end of FM_LnxKern_ctrl_grp group */
+/** @} */ /* end of FM_LnxKern_grp group */
+
+
+#endif /* __LNXWRP_FSL_FMAN_H */
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/fman_test.c b/drivers/net/ethernet/freescale/fman/src/wrapper/fman_test.c
index 81edc9a..4bd6261 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/fman_test.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/fman_test.c
@@ -56,7 +56,7 @@
 
 /* private headers */
 #include "fm_ext.h"
-#include "fsl_fman.h"
+#include "lnxwrp_fsl_fman.h"
 #include "fm_port_ext.h"
 #if (DPAA_VERSION == 11)
 #include "../../Peripherals/FM/MAC/memac.h"
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
index f9f3353..00b0da4 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
@@ -509,39 +509,39 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         return E_OK;
 
     uint32_prop = (uint32_t *)of_get_property(port_node, "num-tnums", &lenp);
-    if (uint32_prop) {    
+    if (uint32_prop) {
     	if (WARN_ON(lenp != sizeof(uint32_t)*2))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
- 
+
         portRsrc.num   = uint32_prop[0];
         portRsrc.extra = uint32_prop[1];
- 
+
         if ((err = FM_PORT_ConfigNumOfTasks(p_LnxWrpFmPortDev->h_Dev,
                                             &portRsrc)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
-    
+
     uint32_prop = (uint32_t *)of_get_property(port_node, "num-dmas", &lenp);
-    if (uint32_prop) {  
+    if (uint32_prop) {
     	if (WARN_ON(lenp != sizeof(uint32_t)*2))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
- 
+
         portRsrc.num   = uint32_prop[0];
         portRsrc.extra = uint32_prop[1];
- 
+
         if ((err = FM_PORT_ConfigNumOfOpenDmas(p_LnxWrpFmPortDev->h_Dev,
                                             &portRsrc)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
-    
+
     uint32_prop = (uint32_t *)of_get_property(port_node, "fifo_size", &lenp);
     if (uint32_prop) {
     	if (WARN_ON(lenp != sizeof(uint32_t)*2))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
- 
+
         portRsrc.num   = uint32_prop[0];
         portRsrc.extra = uint32_prop[1];
- 
+
         if ((err = FM_PORT_ConfigSizeOfFifo(p_LnxWrpFmPortDev->h_Dev,
                                             &portRsrc)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
@@ -580,7 +580,7 @@ static t_Error CheckNSetFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
         uint8_t                 portId;
 
         p_LnxWrpFmDev = ((t_LnxWrpFmDev *)p_LnxWrpFmPortDev->h_LnxWrpFmDev);
-    	
+
     	if (WARN_ON(lenp != sizeof(uint32_t)*2))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
 
@@ -609,7 +609,7 @@ static t_Error CheckNSetFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
                 portId += FM_MAX_NUM_OF_1G_RX_PORTS;
             portVSPAllocParams.h_FmTxPort =
                 p_LnxWrpFmDev->txPorts[portId].h_Dev;
-            fmVspParams.liodnOffset = 
+            fmVspParams.liodnOffset =
                 p_LnxWrpFmDev->rxPorts[portId].settings.param.specificParams.rxParams.liodnOffset;
             memcpy(&fmVspParams.extBufPools,
                    &p_LnxWrpFmPortDev->settings.param.specificParams.rxParams.extBufPools,
@@ -1212,7 +1212,6 @@ static int /*__devinit*/ fm_port_probe(struct platform_device *of_dev)
 		       p_LnxWrpFmDev->name, p_LnxWrpFmPortDev->id);
 		p_LnxWrpFmPortDev->minor =
 			p_LnxWrpFmPortDev->id + DEV_FM_OH_PORTS_MINOR_BASE;
-		p_LnxWrpFmPortDev->h_Dev = FM_PCD_GetHcDevH(p_LnxWrpFmDev->h_PcdDev);
 	} else if (p_LnxWrpFmPortDev->settings.param.portType ==
 		 e_FM_PORT_TYPE_OH_OFFLINE_PARSING) {
 		Sprint(p_LnxWrpFmPortDev->name, "%s-port-oh%d",
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
index c307473..a8e9f0b 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -508,6 +508,7 @@ void compat_copy_fm_pcd_hash_table(
     {
         param-> max_num_of_keys = compat_param->max_num_of_keys;
         param->statistics_mode  = compat_param->statistics_mode;
+        param->kg_hash_shift    = compat_param->kg_hash_shift;
         param->hash_res_mask    = compat_param->hash_res_mask;
         param->hash_shift       = compat_param->hash_shift;
         param->match_key_size   = compat_param->match_key_size;
@@ -517,6 +518,7 @@ void compat_copy_fm_pcd_hash_table(
     {
         compat_param-> max_num_of_keys = param->max_num_of_keys;
         compat_param->statistics_mode  = param->statistics_mode;
+        compat_param->kg_hash_shift    = param->kg_hash_shift;
         compat_param->hash_res_mask    = param->hash_res_mask;
         compat_param->hash_shift       = param->hash_shift;
         compat_param->match_key_size   = param->match_key_size;
@@ -641,10 +643,10 @@ void compat_copy_fm_pcd_kg_scheme(
         param->bypass_fqid_generation = compat_param->bypass_fqid_generation;
         param->base_fqid = compat_param->base_fqid;
 #if DPAA_VERSION >= 11
-	param->override_storage_profile =
-					 compat_param->override_storage_profile;
-	param->storage_profile = compat_param->storage_profile;
-#endif /* DPAA_VERSION >= 11 */
+        param->override_storage_profile =
+                                 compat_param->override_storage_profile;
+        param->storage_profile = compat_param->storage_profile;
+#endif
         param->num_of_used_extracted_ors = compat_param->num_of_used_extracted_ors;
         memcpy(param->extracted_ors,
                compat_param->extracted_ors,
@@ -694,10 +696,10 @@ void compat_copy_fm_pcd_kg_scheme(
         compat_param->bypass_fqid_generation = param->bypass_fqid_generation;
         compat_param->base_fqid = param->base_fqid;
 #if DPAA_VERSION >= 11
-	compat_param->override_storage_profile =
-					       param->override_storage_profile;
-	compat_param->storage_profile =  param->storage_profile;
-#endif /* DPAA_VERSION >= 11 */
+        compat_param->override_storage_profile =
+                                        param->override_storage_profile;
+        compat_param->storage_profile =  param->storage_profile;
+#endif
         compat_param->num_of_used_extracted_ors = param->num_of_used_extracted_ors;
         memcpy(compat_param->extracted_ors, param->extracted_ors, IOC_FM_PCD_KG_NUM_OF_GENERIC_REGS * sizeof(ioc_fm_pcd_kg_extracted_or_params_t));
         compat_param->next_engine = param->next_engine;
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
index e8e6677..3078003 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -292,6 +292,7 @@ typedef struct ioc_compat_fm_pcd_cc_node_params_t {
 typedef struct ioc_compat_fm_pcd_hash_table_params_t {
     uint16_t                    max_num_of_keys;
     ioc_fm_pcd_cc_stats_mode    statistics_mode;
+    uint8_t                     kg_hash_shift;
     uint16_t                    hash_res_mask;
     uint8_t                     hash_shift;
     uint8_t                     match_key_size;
diff --git a/include/uapi/linux/fmd/Peripherals/fm_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
index d1b779b..8a62398 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
@@ -621,8 +621,8 @@ typedef struct ioc_fm_ctrl_mon_counters_params_t {
 /** @} */ /* end of lnx_ioctl_FM_lib_grp group */
 /** @} */ /* end of lnx_ioctl_FM_grp */
 
-#define FMD_API_VERSION_MAJOR 18
-#define FMD_API_VERSION_MINOR 1
-#define FMD_API_VERSION_RESPIN 2
+#define FMD_API_VERSION_MAJOR 21
+#define FMD_API_VERSION_MINOR 0
+#define FMD_API_VERSION_RESPIN 0
 
 #endif /* __FM_IOCTLS_H */
diff --git a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
index 0123b17..93bbebb 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -840,7 +840,9 @@ typedef enum ioc_fm_pcd_cc_stats_mode {
     e_IOC_FM_PCD_CC_STATS_MODE_NONE = 0,        /**< No statistics support */
     e_IOC_FM_PCD_CC_STATS_MODE_FRAME,           /**< Frame count statistics */
     e_IOC_FM_PCD_CC_STATS_MODE_BYTE_AND_FRAME,  /**< Byte and frame count statistics */
+#if (DPAA_VERSION >= 11)
     e_IOC_FM_PCD_CC_STATS_MODE_RMON,            /**< Byte and frame length range count statistics */
+#endif /* (DPAA_VERSION >= 11) */
 } ioc_fm_pcd_cc_stats_mode;
 
 /**************************************************************************//**
@@ -1431,6 +1433,8 @@ typedef struct ioc_fm_pcd_hash_table_params_t {
     uint16_t                    max_num_of_keys;            /**< Maximum Number Of Keys that will (ever) be used in this Hash-table */
     ioc_fm_pcd_cc_stats_mode    statistics_mode;            /**< If not e_IOC_FM_PCD_CC_STATS_MODE_NONE, the required structures for the
                                                                  requested statistics mode will be allocated according to max_num_of_keys. */
+    uint8_t                     kg_hash_shift;              /**< KG-Hash-shift as it was configured in the KG-scheme
+                                                                 that leads to this hash-table. */
     uint16_t                    hash_res_mask;              /**< Mask that will be used on the hash-result;
                                                                  The number-of-sets for this hash will be calculated
                                                                  as (2^(number of bits set in 'hash_res_mask'));
@@ -2034,7 +2038,11 @@ typedef struct ioc_fm_pcd_manip_reassem_ip_stats_t {
     uint32_t    external_buffer_busy;             /**< Counts the number of times external buffer busy occurred */
     uint32_t    sg_fragments;                    /**< Counts the number of Scatter/Gather fragments */
     uint32_t    dma_semaphore_depletion;          /**< Counts the number of failed attempts to allocate a DMA semaphore */
-    struct {
+#if (DPAA_VERSION >= 11)
+    uint32_t        non_consistent_sp;            /**< Counts the number of Non Consistent Storage Profile events for
+                                                     successfully reassembled frames */
+#endif /* (DPAA_VERSION >= 11) */
+struct {
         uint32_t    successfully_reassembled;    /**< Counts the number of successfully reassembled frames */
         uint32_t    valid_fragments;             /**< Counts the total number of valid fragments that
                                                      have been processed for all frames */
-- 
2.0.2

