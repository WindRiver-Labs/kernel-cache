From bd1812e286807cec18e0fc09842bcce49ec8209d Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Thu, 11 Sep 2014 17:42:15 +0800
Subject: [PATCH 0657/1089] esdhc: Workaround for eSDHC clock glitch issue

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

A-003980: SDHC: Glitch is generated on the card clock with software reset or
clock divider change
Description: A glitch may occur on the SDHC card clock when the software sets
the RSTA bit (software reset) in the system control register. It can also be
generated by setting the clock divider value. The glitch produced can cause
the external card to switch to an unknown state. The occurrence is not
deterministic.
Workaround:
A simple workaround is to disable the SD card clock before the software reset,
and enable it when the module resumes normal operation.
The Host and the SD card are in a master-slave relationship. The Host provides
clock and control transfer across the interface. Therefore, any existing
operation is discarded when the Host controller is reset.
The recommended flow is as follows:
1. Software disable bit[3], SDCLKEN, of the System Control Register
2. Trigger software reset and/or set clock divider
3. Check bit[3], SDSTB, of the Present State Register for stable clock
4. Enable bit[3], SDCLKEN, of the System Control Register
Using the above method, the eSDHC cannot send command or transfer data when
there is a glitch in the clock line, and the glitch does not cause any issue.

Signed-off-by: Haijun Zhang <haijun.zhang@freescale.com>
Change-Id: I43a6ef8fdffeeeb13bfef215825d417778ce0bf3
Reviewed-on: http://git.am.freescale.net:8181/5916
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Xiaobo Xie <X.Xie@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 drivers/mmc/host/sdhci-of-esdhc.c | 39 +++++++++++++++++++++++++--------------
 include/linux/mmc/sdhci.h         |  2 ++
 2 files changed, 27 insertions(+), 14 deletions(-)

diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c
index 56535db..c001aae 100644
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@ -414,17 +414,28 @@ static void esdhc_of_resume(struct sdhci_host *host)
 }
 #endif
 
-static u32 clock;
 static void esdhc_of_platform_reset_enter(struct sdhci_host *host, u8 mask)
 {
-	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
-		clock = host->clock;
+	if ((host->quirks2 & SDHCI_QUIRK2_DISABLE_CLOCK_BEFORE_RESET) &&
+	    (mask & SDHCI_RESET_ALL)) {
+		u16 clk;
+
+		clk = esdhc_readw(host, SDHCI_CLOCK_CONTROL);
+		clk &= ~ESDHC_CLOCK_CRDEN;
+		esdhc_writew(host, clk, SDHCI_CLOCK_CONTROL);
+	}
 }
 
 static void esdhc_of_platform_reset_exit(struct sdhci_host *host, u8 mask)
 {
-	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
-		host->clock = clock;
+	if ((host->quirks2 & SDHCI_QUIRK2_DISABLE_CLOCK_BEFORE_RESET) &&
+	    (mask & SDHCI_RESET_ALL)) {
+		u16 clk;
+
+		clk = esdhc_readw(host, SDHCI_CLOCK_CONTROL);
+		clk |= ESDHC_CLOCK_CRDEN;
+		esdhc_writew(host, clk, SDHCI_CLOCK_CONTROL);
+	}
 }
 
 static void esdhc_of_platform_init(struct sdhci_host *host)
@@ -448,15 +459,15 @@ static void esdhc_of_platform_init(struct sdhci_host *host)
 	 * P2041-R1.0 P2041-R1.1 P2041-R2.0 P1010-R1.0
 	 */
 	if (((SVR_SOC_VER(svr) == SVR_T4240) && (SVR_REV(svr) == 0x10)) ||
-		((SVR_SOC_VER(svr) == SVR_B4860) && (SVR_REV(svr) == 0x10)) ||
-		((SVR_SOC_VER(svr) == SVR_B4860) && (SVR_REV(svr) == 0x20)) ||
-		((SVR_SOC_VER(svr) == SVR_B4420) && (SVR_REV(svr) == 0x10)) ||
-		((SVR_SOC_VER(svr) == SVR_B4420) && (SVR_REV(svr) == 0x20)) ||
-		((SVR_SOC_VER(svr) == SVR_P1010) && (SVR_REV(svr) == 0x10)) ||
-		((SVR_SOC_VER(svr) == SVR_P3041) && (SVR_REV(svr) == 0x10)) ||
-		((SVR_SOC_VER(svr) == SVR_P3041) && (SVR_REV(svr) == 0x20)) ||
-		((SVR_SOC_VER(svr) == SVR_P2041) && (SVR_REV(svr) <= 0x20)))
-		host->quirks2 |= SDHCI_QUIRK2_BROKEN_RESET_ALL;
+	    ((SVR_SOC_VER(svr) == SVR_B4860) && (SVR_REV(svr) == 0x10)) ||
+	    ((SVR_SOC_VER(svr) == SVR_B4860) && (SVR_REV(svr) == 0x20)) ||
+	    ((SVR_SOC_VER(svr) == SVR_B4420) && (SVR_REV(svr) == 0x10)) ||
+	    ((SVR_SOC_VER(svr) == SVR_B4420) && (SVR_REV(svr) == 0x20)) ||
+	    ((SVR_SOC_VER(svr) == SVR_P1010) && (SVR_REV(svr) == 0x10)) ||
+	    ((SVR_SOC_VER(svr) == SVR_P3041) && (SVR_REV(svr) == 0x10)) ||
+	    ((SVR_SOC_VER(svr) == SVR_P3041) && (SVR_REV(svr) == 0x20)) ||
+	    ((SVR_SOC_VER(svr) == SVR_P2041) && (SVR_REV(svr) <= 0x20)))
+		host->quirks2 |= SDHCI_QUIRK2_DISABLE_CLOCK_BEFORE_RESET;
 }
 
 static int esdhc_pltfm_bus_width(struct sdhci_host *host, int width)
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index b3ff7ae..7a40c5a 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -109,6 +109,8 @@ struct sdhci_host {
  */
 #define SDHCI_QUIRK2_CIRCUIT_SUPPORT_VS33		(1<<29)
 #define SDHCI_QUIRK2_FORCE_CMD13_DETECT_CARD		(1<<28)
+/* Controller need to disable clock before reset all */
+#define SDHCI_QUIRK2_DISABLE_CLOCK_BEFORE_RESET		(1<<27)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
-- 
2.0.2

