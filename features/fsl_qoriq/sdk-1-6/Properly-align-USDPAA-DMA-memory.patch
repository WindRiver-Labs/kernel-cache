From d6e5de706fa6e256f9f68b1f7a380862550eccdf Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Wed, 23 Apr 2014 11:49:16 -0400
Subject: [PATCH 0950/1089] Properly align USDPAA DMA memory

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

DMA memory must be aligned to the page boundary when mapped
into the processes virtual address space

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: Ibc6320991d8e5317b8724fc2cfdc23ce47faaaf4
Reviewed-on: http://git.am.freescale.net:8181/11409
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c | 24 ++++++++++++++----------
 1 file changed, 14 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index f5a82e8..9ec5fb2 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -698,6 +698,9 @@ static unsigned long usdpaa_get_unmapped_area(struct file *file,
 
 	if (len % PAGE_SIZE)
 		return -EINVAL;
+	/* Need to align to largest pagesize to ensure all pages
+	   will be correctly aligned */
+	len = largest_page_size(len);
 
 	addr = USDPAA_MEM_ROUNDUP(addr, len);
 	vma = find_vma(current->mm, addr);
@@ -903,15 +906,6 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 		ret = -EINVAL;
 		goto out;
 	}
-	/* Verify there is sufficient space to do the mapping */
-	down_write(&current->mm->mmap_sem);
-	next_addr = usdpaa_get_unmapped_area(fp, next_addr, i->len, 0, 0);
-	up_write(&current->mm->mmap_sem);
-
-	if (next_addr & ~PAGE_MASK) {
-		ret = -ENOMEM;
-		goto out;
-	}
 
 	/* Find one of more contiguous fragments that satisfy the total length
 	   trying to minimize the number of fragments
@@ -963,6 +957,16 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 	}
 	i->did_create = 1;
 do_map:
+	/* Verify there is sufficient space to do the mapping */
+	down_write(&current->mm->mmap_sem);
+	next_addr = usdpaa_get_unmapped_area(fp, next_addr, i->len, 0, 0);
+	up_write(&current->mm->mmap_sem);
+
+	if (next_addr & ~PAGE_MASK) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
 	/* We may need to divide the final fragment to accomidate the mapping */
 	next_frag = start_frag;
 	while (so_far != i->len) {
@@ -999,7 +1003,7 @@ out:
 	if (!ret) {
 		unsigned long longret;
 		down_write(&current->mm->mmap_sem);
-		longret = do_mmap_pgoff(fp, PAGE_SIZE, map->total_size,
+		longret = do_mmap_pgoff(fp, next_addr, map->total_size,
 					PROT_READ |
 					(i->flags &
 					 USDPAA_DMA_FLAG_RDONLY ? 0
-- 
2.0.2

