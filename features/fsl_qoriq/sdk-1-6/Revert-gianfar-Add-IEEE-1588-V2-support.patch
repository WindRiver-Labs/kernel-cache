From 3c1c912523d4782874af9a6763a6d66847253085 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Thu, 24 Jul 2014 16:04:29 +0800
Subject: [PATCH 04/50] Revert "gianfar: Add IEEE 1588 V2 support"

This reverts commit c401cb4e081f1eff850a60d63d0f5efb8b0f9d3c.

SDK 1.6 commits a new version patch to add 1588 V2 support.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>

Conflicts:
	drivers/net/ethernet/freescale/Makefile
	drivers/net/ethernet/freescale/gianfar.c
	drivers/net/ethernet/freescale/gianfar.h
	drivers/net/ethernet/freescale/gianfar_1588.c
	drivers/net/ethernet/freescale/gianfar_sysfs.c
---
 drivers/net/ethernet/freescale/Makefile  |    4 +-
 drivers/net/ethernet/freescale/gianfar.c |  112 +++------------------
 drivers/net/ethernet/freescale/gianfar.h |  159 +-----------------------------
 3 files changed, 23 insertions(+), 252 deletions(-)

diff --git a/drivers/net/ethernet/freescale/Makefile b/drivers/net/ethernet/freescale/Makefile
index 90d6f45..3092ee1 100644
--- a/drivers/net/ethernet/freescale/Makefile
+++ b/drivers/net/ethernet/freescale/Makefile
@@ -16,8 +16,6 @@ obj-$(if $(CONFIG_FSL_FMAN),y) += fman/
 obj-$(if $(CONFIG_FSL_DPAA_ETH),y) += dpa/
 obj-$(CONFIG_PTP_1588_CLOCK_GIANFAR) += gianfar_ptp.o
 gianfar_driver-objs := gianfar.o \
-		gianfar_ethtool.o \
-		gianfar_sysfs.o \
-		gianfar_1588.o
+		gianfar_ethtool.o
 obj-$(CONFIG_UCC_GETH) += ucc_geth_driver.o
 ucc_geth_driver-objs := ucc_geth.o ucc_geth_ethtool.o
diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 253eb79..ced00d4 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -918,10 +918,6 @@ static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 	/* Find the TBI PHY.  If it's not there, we don't support SGMII */
 	priv->tbi_node = of_parse_phandle(np, "tbi-handle", 0);
 
-	/* Handle IEEE1588 node */
-	if (!gfar_ptp_init(np, priv))
-		dev_info(&ofdev->dev, "ptp 1588 is initialized.\n");
-
 	return 0;
 
 rx_alloc_failed:
@@ -939,7 +935,6 @@ static int gfar_hwtstamp_ioctl(struct net_device *netdev,
 {
 	struct hwtstamp_config config;
 	struct gfar_private *priv = netdev_priv(netdev);
-	struct gfar __iomem *regs = priv->gfargrp[0].regs;
 
 	if (copy_from_user(&config, ifr->ifr_data, sizeof(config)))
 		return -EFAULT;
@@ -951,25 +946,11 @@ static int gfar_hwtstamp_ioctl(struct net_device *netdev,
 	switch (config.tx_type) {
 	case HWTSTAMP_TX_OFF:
 		priv->hwts_tx_en = 0;
-		/*
-		 * remove RTPE bit - disable timestamp
-		 * insertion on tx packets
-		 */
-		gfar_write(&(priv->ptimer->tmr_ctrl),
-			gfar_read(&(priv->ptimer->tmr_ctrl))
-					& (~TMR_RTPE));
 		break;
 	case HWTSTAMP_TX_ON:
 		if (!(priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER))
 			return -ERANGE;
 		priv->hwts_tx_en = 1;
-		/*
-		 * add RTPE bit - enable timestamp insertion
-		 * on tx packets
-		 */
-		gfar_write(&(priv->ptimer->tmr_ctrl),
-			gfar_read(&(priv->ptimer->tmr_ctrl))
-							| TMR_RTPE);
 		break;
 	default:
 		return -ERANGE;
@@ -980,8 +961,6 @@ static int gfar_hwtstamp_ioctl(struct net_device *netdev,
 		if (priv->hwts_rx_en) {
 			stop_gfar(netdev);
 			priv->hwts_rx_en = 0;
-			gfar_write(&regs->rctrl,
-				gfar_read(&regs->rctrl) & ~RCTRL_TS_ENABLE);
 			startup_gfar(netdev);
 		}
 		break;
@@ -991,8 +970,6 @@ static int gfar_hwtstamp_ioctl(struct net_device *netdev,
 		if (!priv->hwts_rx_en) {
 			stop_gfar(netdev);
 			priv->hwts_rx_en = 1;
-			gfar_write(&regs->rctrl,
-				gfar_read(&regs->rctrl) | RCTRL_TS_ENABLE);
 			startup_gfar(netdev);
 		}
 		config.rx_filter = HWTSTAMP_FILTER_ALL;
@@ -1017,11 +994,7 @@ static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	if (!priv->phydev)
 		return -ENODEV;
 
-	if ((cmd >= PTP_ENBL_TXTS_IOCTL) &&
-			(cmd <= PTP_CLEANUP_TS))
-		return gfar_ioctl_1588(dev, rq, cmd);
-	else
-		return phy_mii_ioctl(priv->phydev, rq, cmd);
+	return phy_mii_ioctl(priv->phydev, rq, cmd);
 }
 
 static unsigned int reverse_bitmap(unsigned int bit_map, unsigned int max_qs)
@@ -1469,7 +1442,6 @@ static int gfar_probe(struct platform_device *ofdev)
 	return 0;
 
 register_fail:
-	gfar_ptp_cleanup(priv);
 	unmap_group_regs(priv);
 	free_tx_pointers(priv);
 	free_rx_pointers(priv);
@@ -2735,21 +2707,11 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	/* Setup tx hardware time stamping if requested */
 	if (unlikely(do_tstamp)) {
-		u32 vlan_ctrl;
 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
 		if (fcb == NULL)
 			fcb = gfar_add_fcb(skb);
 		fcb->ptp = 1;
 		lstatus |= BD_LFLAG(TXBD_TOE);
-		/*
-		 * SYMM: When PTP in FCB is enabled, VLN in FCB is ignored.
-		 * Instead VLAN tag is read from DFVLAN register. Thus need
-		 * to copy VLCTL to DFVLAN register.
-		 */
-		vlan_ctrl = gfar_read(&regs->dfvlan);
-		vlan_ctrl &= ~0xFFFF;
-		vlan_ctrl |= (fcb->vlctl & 0xFFFF);
-		gfar_write(&regs->dfvlan, vlan_ctrl);
 	}
 
 	txbdp_start->bufPtr = dma_map_single(priv->dev, skb->data,
@@ -3134,39 +3096,13 @@ static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 				 buflen, DMA_TO_DEVICE);
 
 		if (unlikely(skb_shinfo(skb)->tx_flags & SKBTX_IN_PROGRESS)) {
-			struct gfar __iomem *regs = priv->gfargrp[0].regs;
 			struct skb_shared_hwtstamps shhwtstamps;
-			u32 high, low;
-			struct gfar_ptp_time tx_ts;
-			u64 ns;
-
-			if (priv->device_flags &
-					FSL_GIANFAR_DEV_HAS_TS_TO_BUFFER) {
-				/* get tx timestamp out of frame */
-				void *ts;
-				ts = (void *)(((uintptr_t)skb->data + 0x10)
-						& ~0x7);
-				ns = be64_to_cpup(ts);
-			} else
-				/* get tx timestamp from register */
-				ns = gfar_get_tx_timestamp(regs);
-
-			if (unlikely(priv->hwts_tx_en))
-				shhwtstamps.hwtstamp = ns_to_ktime(ns);
-			if (likely(priv->hwts_tx_en_ioctl)) {
-				high = upper_32_bits(ns);
-				low = lower_32_bits(ns);
-				gfar_cnt_to_ptp_time(high, low, &tx_ts);
-			}
-			/* remove tx fcb */
-			skb_pull(skb, GMAC_FCB_LEN);
-			/* pass timestamp back */
-			if (unlikely(priv->hwts_tx_en))
-				skb_tstamp_tx(skb, &shhwtstamps);
-			if (likely(priv->hwts_tx_en_ioctl)) {
-				skb_pull(skb, GMAC_TXPAL_LEN);
-				gfar_ptp_store_txstamp(dev, skb, &tx_ts);
-			}
+			u64 *ns = (u64*) (((u32)skb->data + 0x10) & ~0x7);
+
+			memset(&shhwtstamps, 0, sizeof(shhwtstamps));
+			shhwtstamps.hwtstamp = ns_to_ktime(*ns);
+			skb_pull(skb, GMAC_FCB_LEN + GMAC_TXPAL_LEN);
+			skb_tstamp_tx(skb, &shhwtstamps);
 			bdp->lstatus &= BD_LFLAG(TXBD_WRAP);
 			bdp = next;
 		}
@@ -3437,30 +3373,16 @@ static void gfar_process_frame(struct net_device *dev, struct sk_buff *skb,
 	}
 
 	/* Get receive timestamp from the skb */
-	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_TIMER) {
-		u32 high, low;
-
-		/* get timestamp */
-		high = *((u32 *)skb->data);
-		low = *(((u32 *)skb->data) + 1);
-		skb_pull(skb, 8);
-		/* proprietary PTP timestamping over ioctl */
-		if (unlikely(priv->hwts_rx_en_ioctl)) {
-			struct gfar_ptp_time rx_ts;
-			/* get rx timestamp */
-			gfar_cnt_to_ptp_time(high, low, &rx_ts);
-			/* parse and store rx timestamp */
-			gfar_ptp_store_rxstamp(dev, skb, &rx_ts);
-		} else if (unlikely(priv->hwts_rx_en)) {
-			/* kernel-API timestamping ? */
-			u64 nsec;
-			struct skb_shared_hwtstamps *hws;
-			hws = skb_hwtstamps(skb);
-			nsec = make64(high, low);
-			hws->hwtstamp = ns_to_ktime(nsec);
-		}
-	} else if (priv->padding)
-			skb_pull(skb, priv->padding);
+	if (priv->hwts_rx_en) {
+		struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb);
+		u64 *ns = (u64 *) skb->data;
+
+		memset(shhwtstamps, 0, sizeof(*shhwtstamps));
+		shhwtstamps->hwtstamp = ns_to_ktime(*ns);
+	}
+
+	if (priv->padding)
+		skb_pull(skb, priv->padding);
 
 	if (dev->features & NETIF_F_RXCSUM)
 		gfar_rx_checksum(skb, fcb);
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 16e8d0e..347d916 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -46,7 +46,6 @@
 #include <linux/crc32.h>
 #include <linux/workqueue.h>
 #include <linux/ethtool.h>
-#include <linux/circ_buf.h>
 
 struct ethtool_flow_spec_container {
 	struct ethtool_rx_flow_spec fs;
@@ -147,58 +146,6 @@ extern const char gfar_driver_version[];
 		| SUPPORTED_Autoneg \
 		| SUPPORTED_MII)
 
-/* 1588 defines */
-#define make64(high, low) (((u64)(high) << 32) | (low))
-
-#define PTP_ENBL_TXTS_IOCTL	SIOCDEVPRIVATE
-#define PTP_DSBL_TXTS_IOCTL	(SIOCDEVPRIVATE + 1)
-#define PTP_ENBL_RXTS_IOCTL	(SIOCDEVPRIVATE + 2)
-#define PTP_DSBL_RXTS_IOCTL	(SIOCDEVPRIVATE + 3)
-#define PTP_GET_TX_TIMESTAMP	(SIOCDEVPRIVATE + 4)
-#define PTP_GET_RX_TIMESTAMP	(SIOCDEVPRIVATE + 5)
-#define PTP_SET_TIME		(SIOCDEVPRIVATE + 6)
-#define PTP_GET_TIME		(SIOCDEVPRIVATE + 7)
-#define PTP_SET_FIPER_ALARM	(SIOCDEVPRIVATE + 8)
-#define PTP_SET_ADJ		(SIOCDEVPRIVATE + 9)
-#define PTP_GET_ADJ		(SIOCDEVPRIVATE + 10)
-#define PTP_CLEANUP_TS		(SIOCDEVPRIVATE + 11)
-
-#define DEFAULT_PTP_TX_BUF_SZ		1024
-#define DEFAULT_PTP_RX_BUF_SZ		2048
-/* The threshold between the current found one and the oldest one */
-#define TS_ACCUMULATION_THRESHOLD	50
-
-#define GFAR_PTP_SOURCE_PORT_LENGTH	10
-#define	GFAR_PTP_HEADER_SEQ_OFFS	30
-#define GFAR_PTP_SPID_OFFS		20
-#define GFAR_PTP_HEADER_SZE		34
-#define GFAR_PTP_EVENT_PORT		0x013F
-
-#define GFAR_VLAN_QINQ_1		0x9100
-#define GFAR_VLAN_QINQ_2		0x9200
-#define GFAR_VLAN_QINQ_3		0x9300
-#define GFAR_VLAN_QINQ_4		0x88A8
-#define GFAR_VLAN_TAG_LEN		0x04
-#define GFAR_ETHTYPE_LEN		0x02
-#define GFAR_PACKET_TYPE_UDP		0x11
-/* 1588-2008 network protocol enumeration values */
-#define GFAR_PTP_PROT_IPV4		1
-#define GFAR_PTP_PROT_IPV6		2
-#define GFAR_PTP_PROT_802_3		3
-#define GFAR_PTP_PROT_DONTCARE		0xFFFF
-
-/* 1588 Module Registers bits */
-#define TMR_CTRL_CKSEL_MASK	0x00000003
-#define TMR_CTRL_ENABLE		0x00000004
-#define TMR_RTPE		0x00008000
-#define TMR_CTRL_TCLK_MASK	0x03ff0000
-#define TMR_CTRL_FIPER_START	0x10000000
-#define ONE_GIGA	1000000000
-
-/*Alarm to traigger at 15sec boundary */
-#define TMR_ALARM1_L	0xD964B800
-#define TMR_ALARM1_H	0x00000045
-#define NANOSEC_PER_SEC	1000000000
 
 /* TBI register addresses */
 #define MII_TBICON		0x11
@@ -741,78 +688,6 @@ struct gfar_extra_stats {
 /* Number of stats exported via ethtool */
 #define GFAR_STATS_LEN (GFAR_RMON_LEN + GFAR_EXTRA_STATS_LEN)
 
-/* IEEE-1588 Timer Controller Registers */
-struct gfar_regs_1588 {
-	u32	tmr_ctrl;	/* 0x.e00 - Timer Control Register */
-	u32	tmr_tevent;	/* 0x.e04 - Timer stamp event register */
-	u32	tmr_temask;	/* 0x.e08 - Timer event mask register */
-	u32	tmr_pevent;	/* 0x.e0c - Timer stamp event register */
-	u32	tmr_pemask;	/* 0x.e10 - Timer event mask register */
-	u32	tmr_stat;	/* 0x.e14 - Timer stamp status register */
-	u32	tmr_cnt_h;	/* 0x.e18 - Timer counter high register */
-	u32	tmr_cnt_l;	/* 0x.e1c - Timer counter low register */
-	u32	tmr_add;	/* 0x.e20 - Timer dirft compensation */
-					/* addend register */
-	u32	tmr_acc;	/* 0x.e24 - Timer accumulator register */
-	u32	tmr_prsc;	/* 0x.e28 - Timer prescale register */
-	u8	res24a[4];	/* 0x.e2c - 0x.e2f reserved */
-	u32	tmr_off_h;	/* 0x.e30 - Timer offset high register */
-	u32	tmr_off_l;	/* 0x.e34 - Timer offset low register */
-	u8	res24b[8];	/* 0x.e38 - 0x.e3f reserved */
-	u32	tmr_alarm1_h;	/* 0x.e40 - Timer alarm 1 high register */
-	u32	tmr_alarm1_l;	/* 0x.e44 - Timer alarm 1 low register */
-	u32	tmr_alarm2_h;	/* 0x.e48 - Timer alarm 2 high register */
-	u32	tmr_alarm2_l;	/* 0x.e4c - Timer alarm 2 low register */
-	u8	res24c[48];	/* 0x.e50 - 0x.e7f reserved */
-	u32	tmr_fiper1;	/* 0x.e80 - Timer fixed period register 1 */
-	u32	tmr_fiper2;	/* 0x.e84 - Timer fixed period register 2 */
-	u32	tmr_fiper3;	/* 0x.e88 - Timer fixed period register 3 */
-	u8	res24d[20];	/* 0x.e8c - 0x.ebf reserved */
-	u32	tmr_etts1_h;	/* 0x.ea0 - Timer stamp high of */
-					/* general purpose external trigger 1 */
-	u32	tmr_etts1_l;	/* 0x.ea4 - Timer stamp low of */
-					/* general purpose external trigger 1 */
-	u32	tmr_etts2_h;	/* 0x.ea8 - Timer stamp high of */
-					/* general purpose external trigger 2 */
-	u32	tmr_etts2_l;	/* 0x.eac - Timer stamp low of */
-};
-
-/* struct needed to identify a timestamp */
-struct gfar_ptp_ident {
-	u8  version;
-	u8  msg_type;
-	u16 netw_prot;
-	u16 seq_id;
-	u8  snd_port_id[GFAR_PTP_SOURCE_PORT_LENGTH];
-};
-
-/* timestamp format in 1588-2008 */
-struct gfar_ptp_time {
-	u64 sec; /* just 48 bit used */
-	u32 nsec;
-};
-
-/* needed for timestamp data over ioctl */
-struct gfar_ptp_data {
-	struct  gfar_ptp_ident  ident;
-	struct  gfar_ptp_time   ts;
-};
-
-/* circular buffer for ptp timestamps over ioctl */
-struct gfar_ptp_circular {
-	struct circ_buf circ_buf;
-	u32 size;
-	spinlock_t ptp_lock;
-};
-
-struct gfar_ptp_attr_t {
-	u32 tclk_period;
-	u32 nominal_freq;
-	u32 sysclock_freq;
-	u32 tmr_fiper1;
-	u32 freq_comp;
-};
-
 struct gfar {
 	u32	tsec_id;	/* 0x.000 - Controller ID register */
 	u32	tsec_id2;	/* 0x.004 - Controller ID2 register */
@@ -944,10 +819,7 @@ struct gfar {
 	u32	rbase6;		/* 0x.434 - RxBD base address of ring 6 */
 	u8	res17g[4];
 	u32	rbase7;		/* 0x.43c - RxBD base address of ring 7 */
-	u8	res17h[128];
-	u32	tmr_rxts_h;	/* 0x.4c0 Rx Time Stamp high */
-	u32	tmr_rxts_l;	/* 0x.4c4 Rx Time Stamp low */
-	u8	res17i[56];
+	u8	res17[192];
 	u32	maccfg1;	/* 0x.500 - MAC Configuration 1 Register */
 	u32	maccfg2;	/* 0x.504 - MAC Configuration 2 Register */
 	u32	ipgifg;		/* 0x.508 - Inter Packet Gap/Inter Frame Gap Register */
@@ -1016,8 +888,7 @@ struct gfar {
 	u8	res23c[248];
 	u32	attr;		/* 0x.bf8 - Attributes Register */
 	u32	attreli;	/* 0x.bfc - Attributes Extract Length and Extract Index Register */
-	u8	res24[512];
-	struct gfar_regs_1588 regs_1588;
+	u8	res24[688];
 	u32	isrg0;		/* 0x.eb0 - Interrupt steering group 0 register */
 	u32	isrg1;		/* 0x.eb4 - Interrupt steering group 1 register */
 	u32	isrg2;		/* 0x.eb8 - Interrupt steering group 2 register */
@@ -1262,9 +1133,9 @@ struct gfar_private {
 
 	u32 device_flags;
 
-	/* HW TX timestamping enabled flag */
-	u16 hwts_tx_en;
-	u16 hwts_tx_en_ioctl;
+	/* HW time stamping enabled flag */
+	int hwts_rx_en;
+	int hwts_tx_en;
 
 	struct gfar_priv_tx_q *tx_queue[MAX_TX_QS];
 	struct gfar_priv_rx_q *rx_queue[MAX_RX_QS];
@@ -1280,15 +1151,6 @@ struct gfar_private {
 	/* Network Statistics */
 	struct gfar_extra_stats extra_stats;
 
-	/* HW RX timestamping enabled flag */
-	u16 hwts_rx_en;
-	u16 hwts_rx_en_ioctl;
-
-	/* 1588 stuff */
-	struct gfar_regs_1588 __iomem *ptimer;
-	struct gfar_ptp_circular tx_timestamps;
-	struct gfar_ptp_circular rx_timestamps;
-
 	/* PHY stuff */
 	phy_interface_t interface;
 	struct device_node *phy_node;
@@ -1407,17 +1269,6 @@ extern irqreturn_t gfar_receive(int irq, void *dev_id);
 extern int startup_gfar(struct net_device *dev);
 extern void stop_gfar(struct net_device *dev);
 extern void gfar_halt(struct net_device *dev);
-void gfar_1588_start(struct gfar_private *priv);
-void gfar_1588_stop(struct gfar_private *priv);
-int gfar_ptp_init(struct device_node *np, struct gfar_private *priv);
-void gfar_ptp_cleanup(struct gfar_private *priv);
-int gfar_ioctl_1588(struct net_device *dev, struct ifreq *ifr, int cmd);
-void gfar_ptp_store_txstamp(struct net_device *dev,
-			struct sk_buff *skb, struct gfar_ptp_time *tx_ts);
-void gfar_ptp_store_rxstamp(struct net_device *dev,
-			struct sk_buff *skb, struct gfar_ptp_time *rx_ts);
-void gfar_cnt_to_ptp_time(u32 high, u32 low, struct gfar_ptp_time *time);
-u64 gfar_get_tx_timestamp(struct gfar __iomem *regs);
 extern void gfar_phy_test(struct mii_bus *bus, struct phy_device *phydev,
 		int enable, u32 regnum, u32 read);
 extern void gfar_configure_coalescing_all(struct gfar_private *priv);
-- 
1.7.5.4

