From b069b578f85535d365d472666582d5bfa85ee747 Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@Freescale.com>
Date: Fri, 17 Jan 2014 10:23:22 -0600
Subject: [PATCH 0677/1089] fsl_qman: Use ARRAY_SIZE()

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

This fixes the following sparse errors:

error: bad constant expression
error: cannot size expression

Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Change-Id: Id3b009520ace92111175a4a00b96761f16368f16
Reviewed-on: http://git.am.freescale.net:8181/8102
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Haiying Wang <Haiying.Wang@freescale.com>
Reviewed-by: Emilian Medve <Emilian.Medve@freescale.com>
---
 drivers/staging/fsl_qbman/qman_debugfs.c | 21 +++++++++------------
 1 file changed, 9 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_debugfs.c b/drivers/staging/fsl_qbman/qman_debugfs.c
index 247938d..edf4a5c 100644
--- a/drivers/staging/fsl_qbman/qman_debugfs.c
+++ b/drivers/staging/fsl_qbman/qman_debugfs.c
@@ -54,7 +54,6 @@ static const u8 fqd_states[] = {
 	QM_MCR_NP_STATE_OOS, QM_MCR_NP_STATE_RETIRED, QM_MCR_NP_STATE_TEN_SCHED,
 	QM_MCR_NP_STATE_TRU_SCHED, QM_MCR_NP_STATE_PARKED,
 	QM_MCR_NP_STATE_ACTIVE};
-static const u32 fqd_states_count = sizeof(fqd_states)/sizeof(u8);
 
 struct mask_to_text {
 	u16 mask;
@@ -86,8 +85,6 @@ static const struct mask_filter_s mask_filter[] = {
 	{QM_FQCTRL_CGE, 0},
 	{QM_FQCTRL_CGE, 1}
 };
-static const u32 mask_filter_count =
-	sizeof(mask_filter)/sizeof(struct mask_filter_s);
 
 static const struct mask_to_text fq_ctrl_text_list[] = {
 	{
@@ -993,7 +990,7 @@ static int qman_fqd_state_show(struct seq_file *file, void *offset)
 	struct line_buffer_fq line_buf;
 	int ret, i;
 	u8 *state = file->private;
-	u32 qm_fq_state_cnt[fqd_states_count];
+	u32 qm_fq_state_cnt[ARRAY_SIZE(fqd_states)];
 
 	memset(qm_fq_state_cnt, 0, sizeof(qm_fq_state_cnt));
 	memset(&line_buf, 0, sizeof(line_buf));
@@ -1008,12 +1005,12 @@ static int qman_fqd_state_show(struct seq_file *file, void *offset)
 		if (*state == (np.state & QM_MCR_NP_STATE_MASK))
 			add_to_line_buffer(&line_buf, fq.fqid, file);
 		/* Keep a summary count of all states */
-		if ((np.state & QM_MCR_NP_STATE_MASK) < fqd_states_count)
+		if ((np.state & QM_MCR_NP_STATE_MASK) < ARRAY_SIZE(fqd_states))
 			qm_fq_state_cnt[(np.state & QM_MCR_NP_STATE_MASK)]++;
 	}
 	flush_line_buffer(&line_buf, file);
 
-	for (i = 0; i < fqd_states_count; i++) {
+	for (i = 0; i < ARRAY_SIZE(fqd_states); i++) {
 		seq_printf(file, "%s count = %u\n", state_txt[i],
 			   qm_fq_state_cnt[i]);
 	}
@@ -1096,7 +1093,7 @@ static int qman_fqd_non_prog_summary_show(struct seq_file *file, void *offset)
 	struct qm_mcr_queryfq_np np;
 	struct qman_fq fq;
 	int ret, i;
-	u32 qm_fq_state_cnt[fqd_states_count];
+	u32 qm_fq_state_cnt[ARRAY_SIZE(fqd_states)];
 
 	memset(qm_fq_state_cnt, 0, sizeof(qm_fq_state_cnt));
 
@@ -1106,11 +1103,11 @@ static int qman_fqd_non_prog_summary_show(struct seq_file *file, void *offset)
 		if (ret)
 			return ret;
 		/* Keep a summary count of all states */
-		if ((np.state & QM_MCR_NP_STATE_MASK) < fqd_states_count)
+		if ((np.state & QM_MCR_NP_STATE_MASK) < ARRAY_SIZE(fqd_states))
 			qm_fq_state_cnt[(np.state & QM_MCR_NP_STATE_MASK)]++;
 	}
 
-	for (i = 0; i < fqd_states_count; i++) {
+	for (i = 0; i < ARRAY_SIZE(fqd_states); i++) {
 		seq_printf(file, "%s count = %u\n", state_txt[i],
 			   qm_fq_state_cnt[i]);
 	}
@@ -1122,7 +1119,7 @@ static int qman_fqd_prog_summary_show(struct seq_file *file, void *offset)
 	struct qm_fqd fqd;
 	struct qman_fq fq;
 	int ret, i , j;
-	u32 qm_prog_cnt[mask_filter_count/2];
+	u32 qm_prog_cnt[ARRAY_SIZE(mask_filter)/2];
 
 	memset(qm_prog_cnt, 0, sizeof(qm_prog_cnt));
 
@@ -1133,12 +1130,12 @@ static int qman_fqd_prog_summary_show(struct seq_file *file, void *offset)
 		if (ret)
 			return ret;
 		/* Keep a summary count of all states */
-		for (j = 0; j < mask_filter_count; j += 2)
+		for (j = 0; j < ARRAY_SIZE(mask_filter); j += 2)
 			if ((fqd.fq_ctrl & QM_FQCTRL_MASK) &
 					mask_filter[j].mask)
 				qm_prog_cnt[j/2]++;
 	}
-	for (i = 0; i < mask_filter_count/2; i++) {
+	for (i = 0; i < ARRAY_SIZE(mask_filter) / 2; i++) {
 		seq_printf(file, "%s count = %u\n",
 			get_fqd_ctrl_text(mask_filter[i*2].mask),
 			   qm_prog_cnt[i]);
-- 
2.0.2

