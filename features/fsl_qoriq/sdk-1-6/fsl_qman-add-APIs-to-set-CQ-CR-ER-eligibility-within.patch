From 89bd007729a8a2644af2a2077872c1723ab6f390 Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Fri, 18 Oct 2013 15:27:13 -0400
Subject: [PATCH 0555/1089] fsl_qman: add APIs to set CQ CR/ER eligibility
 within the channel

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: I1ba0d8eb5f0a5c4b1b7156e2556253b916d351e9
Reviewed-on: http://git.am.freescale.net:8181/5871
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thorpe Geoff-R01361 <Geoff.Thorpe@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/qman_high.c | 221 ++++++++++++++++++++++------------
 include/linux/fsl_qman.h              |  28 +++++
 2 files changed, 170 insertions(+), 79 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 821349a..951ec3b 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -4039,18 +4039,154 @@ int qman_ceetm_channel_get_group(struct qm_ceetm_channel *channel, int *group_b,
 }
 EXPORT_SYMBOL(qman_ceetm_channel_get_group);
 
-#define CQ_ELIGIBILITY_MASK(n)	(1 << (7 - n))
-#define CQ_A_ELIGIBILITY_MASK	(1 << 8)
-#define CQ_B_ELIGIBILITY_MASK	(1 << 9)
+#define GROUP_A_ELIGIBILITY_SET		(1 << 8)
+#define GROUP_B_ELIGIBILITY_SET		(1 << 9)
+#define CQ_ELIGIBILITY_SET(n)		(1 << (7 - n))
+int qman_ceetm_channel_set_group_cr_eligibility(struct qm_ceetm_channel
+				*channel, int group_b, int cre)
+{
+	struct qm_mcc_ceetm_class_scheduler_config csch_config;
+	struct qm_mcr_ceetm_class_scheduler_query csch_query;
+	int i;
+
+	if (qman_ceetm_query_class_scheduler(channel, &csch_query)) {
+		pr_err("Cannot get the channel %d scheduler setting.\n",
+						channel->idx);
+		return -EINVAL;
+	}
+	csch_config.cqcid = channel->idx;
+	csch_config.dcpid = channel->dcp_idx;
+	csch_config.gpc = csch_query.gpc;
+	for (i = 0; i < 8; i++)
+		csch_config.w[i] = csch_query.w[i];
+	csch_config.erem = csch_query.erem;
+	if (group_b)
+		csch_config.crem = (csch_query.crem & ~GROUP_B_ELIGIBILITY_SET)
+					| (cre ? GROUP_B_ELIGIBILITY_SET : 0);
+	else
+		csch_config.crem = (csch_query.crem & ~GROUP_A_ELIGIBILITY_SET)
+					| (cre ? GROUP_A_ELIGIBILITY_SET : 0);
+
+	if (qman_ceetm_configure_class_scheduler(&csch_config)) {
+		pr_err("Cannot config channel %d's scheduler with "
+			"group_%c's cr eligibility\n", channel->idx,
+			group_b ? 'b' : 'a');
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_group_cr_eligibility);
+
+int qman_ceetm_channel_set_group_er_eligibility(struct qm_ceetm_channel
+				*channel, int group_b, int ere)
+{
+	struct qm_mcc_ceetm_class_scheduler_config csch_config;
+	struct qm_mcr_ceetm_class_scheduler_query csch_query;
+	int i;
+
+	if (qman_ceetm_query_class_scheduler(channel, &csch_query)) {
+		pr_err("Cannot get the channel %d scheduler setting.\n",
+						channel->idx);
+		return -EINVAL;
+	}
+	csch_config.cqcid = channel->idx;
+	csch_config.dcpid = channel->dcp_idx;
+	csch_config.gpc = csch_query.gpc;
+	for (i = 0; i < 8; i++)
+		csch_config.w[i] = csch_query.w[i];
+	csch_config.crem = csch_query.crem;
+	if (group_b)
+		csch_config.erem = (csch_query.erem & ~GROUP_B_ELIGIBILITY_SET)
+					| (ere ? GROUP_B_ELIGIBILITY_SET : 0);
+	else
+		csch_config.erem = (csch_query.erem & ~GROUP_A_ELIGIBILITY_SET)
+					| (ere ? GROUP_A_ELIGIBILITY_SET : 0);
+
+	if (qman_ceetm_configure_class_scheduler(&csch_config)) {
+		pr_err("Cannot config channel %d's scheduler with "
+			"group_%c's er eligibility\n", channel->idx,
+			group_b ? 'b' : 'a');
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_group_er_eligibility);
+
+int qman_ceetm_channel_set_cq_cr_eligibility(struct qm_ceetm_channel *channel,
+						unsigned int idx, u16 cre)
+{
+	struct qm_mcc_ceetm_class_scheduler_config csch_config;
+	struct qm_mcr_ceetm_class_scheduler_query csch_query;
+	int i;
+
+	if (idx > 7) {
+		pr_err("CQ index is out of range\n");
+		return -EINVAL;
+	}
+	if (qman_ceetm_query_class_scheduler(channel, &csch_query)) {
+		pr_err("Cannot get the channel %d scheduler setting.\n",
+						channel->idx);
+		return -EINVAL;
+	}
+	csch_config.cqcid = channel->idx;
+	csch_config.dcpid = channel->dcp_idx;
+	csch_config.gpc = csch_query.gpc;
+	for (i = 0; i < 8; i++)
+		csch_config.w[i] = csch_query.w[i];
+	csch_config.erem = csch_query.erem;
+	csch_config.crem = (csch_query.crem & ~CQ_ELIGIBILITY_SET(idx)) |
+					(cre ? CQ_ELIGIBILITY_SET(idx) : 0);
+	if (qman_ceetm_configure_class_scheduler(&csch_config)) {
+		pr_err("Cannot config channel scheduler to set "
+			"cr eligibility mask for CQ#%d\n", idx);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_cq_cr_eligibility);
+
+int qman_ceetm_channel_set_cq_er_eligibility(struct qm_ceetm_channel *channel,
+						unsigned int idx, u16 ere)
+{
+	struct qm_mcc_ceetm_class_scheduler_config csch_config;
+	struct qm_mcr_ceetm_class_scheduler_query csch_query;
+	int i;
+
+	if (idx > 7) {
+		pr_err("CQ index is out of range\n");
+		return -EINVAL;
+	}
+	if (qman_ceetm_query_class_scheduler(channel, &csch_query)) {
+		pr_err("Cannot get the channel %d scheduler setting.\n",
+						channel->idx);
+		return -EINVAL;
+	}
+	csch_config.cqcid = channel->idx;
+	csch_config.dcpid = channel->dcp_idx;
+	csch_config.gpc = csch_query.gpc;
+	for (i = 0; i < 8; i++)
+		csch_config.w[i] = csch_query.w[i];
+	csch_config.crem = csch_query.crem;
+	csch_config.erem = (csch_query.erem & ~CQ_ELIGIBILITY_SET(idx)) |
+					(ere ? CQ_ELIGIBILITY_SET(idx) : 0);
+	if (qman_ceetm_configure_class_scheduler(&csch_config)) {
+		pr_err("Cannot config channel scheduler to set "
+			"er eligibility mask for CQ#%d\n", idx);
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_cq_er_eligibility);
+
 int qman_ceetm_cq_claim(struct qm_ceetm_cq **cq,
 		struct qm_ceetm_channel *channel, unsigned int idx,
 		struct qm_ceetm_ccg *ccg)
 {
 	struct qm_ceetm_cq *p;
 	struct qm_mcc_ceetm_cq_config cq_config;
-	struct qm_mcc_ceetm_class_scheduler_config csch_config;
-	struct qm_mcr_ceetm_class_scheduler_query csch_query_result;
-	int i;
 
 	if (idx > 7) {
 		pr_err("The independent class queue id is out of range\n");
@@ -4087,29 +4223,6 @@ int qman_ceetm_cq_claim(struct qm_ceetm_cq **cq,
 		}
 	}
 
-	if (channel->shaper_enable) {
-		if (qman_ceetm_query_class_scheduler(channel,
-						&csch_query_result)) {
-			pr_err("Can't query channel#%d!\n", channel->idx);
-			return -EINVAL;
-		}
-		csch_config.cqcid = channel->idx;
-		csch_config.dcpid = channel->dcp_idx;
-		csch_config.crem = csch_query_result.crem |
-						CQ_ELIGIBILITY_MASK(idx);
-		csch_config.erem = csch_query_result.erem |
-						CQ_ELIGIBILITY_MASK(idx);
-		csch_config.gpc = csch_query_result.gpc;
-		for (i = 0; i < 8; i++)
-			csch_config.w[i] = csch_query_result.w[i];
-
-		if (qman_ceetm_configure_class_scheduler(&csch_config)) {
-			pr_err("Can't config channel scheduler to set"
-					" eligibility mask for CQ#%d\n", idx);
-			return -EINVAL;
-		}
-	}
-
 	*cq = p;
 	return 0;
 }
@@ -4121,9 +4234,6 @@ int qman_ceetm_cq_claim_A(struct qm_ceetm_cq **cq,
 {
 	struct qm_ceetm_cq *p;
 	struct qm_mcc_ceetm_cq_config cq_config;
-	struct qm_mcc_ceetm_class_scheduler_config csch_config;
-	struct qm_mcr_ceetm_class_scheduler_query csch_query_result;
-	int i;
 
 	if ((idx < 7) || (idx > 15)) {
 		pr_err("This grouped class queue id is out of range\n");
@@ -4159,28 +4269,6 @@ int qman_ceetm_cq_claim_A(struct qm_ceetm_cq **cq,
 			return -EINVAL;
 		}
 	}
-
-	if (channel->shaper_enable) {
-		if (qman_ceetm_query_class_scheduler(channel,
-						&csch_query_result)) {
-			pr_err("Can't query channel#%d!\n", channel->idx);
-			return -EINVAL;
-		}
-		csch_config.cqcid = channel->idx;
-		csch_config.dcpid = channel->dcp_idx;
-		csch_config.crem = csch_query_result.crem |
-						CQ_A_ELIGIBILITY_MASK;
-		csch_config.erem = csch_query_result.erem |
-						CQ_A_ELIGIBILITY_MASK;
-		csch_config.gpc = csch_query_result.gpc;
-		for (i = 0; i < 8; i++)
-			csch_config.w[i] = csch_query_result.w[i];
-		if (qman_ceetm_configure_class_scheduler(&csch_config)) {
-			pr_err("Can't config channel scheduler to set"
-					" eligibility mask for CQ#%d\n", idx);
-			return -EINVAL;
-		}
-	}
 	*cq = p;
 	return 0;
 }
@@ -4192,9 +4280,6 @@ int qman_ceetm_cq_claim_B(struct qm_ceetm_cq **cq,
 {
 	struct qm_ceetm_cq *p;
 	struct qm_mcc_ceetm_cq_config cq_config;
-	struct qm_mcc_ceetm_class_scheduler_config csch_config;
-	struct qm_mcr_ceetm_class_scheduler_query csch_query_result;
-	int i;
 
 	if ((idx < 11) || (idx > 15)) {
 		pr_err("This grouped class queue id is out of range\n");
@@ -4230,28 +4315,6 @@ int qman_ceetm_cq_claim_B(struct qm_ceetm_cq **cq,
 		return -EINVAL;
 		}
 	}
-
-	if (channel->shaper_enable) {
-		if (qman_ceetm_query_class_scheduler(channel,
-						&csch_query_result)) {
-			pr_err("Can't query channel#%d!\n", channel->idx);
-			return -EINVAL;
-		}
-		csch_config.cqcid = channel->idx;
-		csch_config.dcpid = channel->dcp_idx;
-		csch_config.crem = csch_query_result.crem |
-							 CQ_B_ELIGIBILITY_MASK;
-		csch_config.erem = csch_query_result.erem |
-							CQ_B_ELIGIBILITY_MASK;
-		csch_config.gpc = csch_query_result.gpc;
-		for (i = 0; i < 8; i++)
-			csch_config.w[i] = csch_query_result.w[i];
-		if (qman_ceetm_configure_class_scheduler(&csch_config)) {
-			pr_err("Can't config channel scheduler to set"
-					" eligibility mask for CQ#%d\n", idx);
-			return -EINVAL;
-		}
-	}
 	*cq = p;
 	return 0;
 }
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index e8e5818..f306c4b 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -2881,6 +2881,34 @@ int qman_ceetm_channel_get_group(struct qm_ceetm_channel *channel,
 			     unsigned int *prio_a,
 			     unsigned int *prio_b);
 
+/**
+ * qman_ceetm_channel_set_group_cr_eligibility
+ * qman_ceetm_channel_set_group_er_eligibility - Set channel group eligibitity
+ * @channel: the given channel object
+ * @group_b: indicates whether there is group B in this channel.
+ * @cre: the commit rate eligibility, 1 for enable, 0 for disable.
+ *
+ * Return zero for success, or -EINVAL if eligiblity setting fails.
+*/
+int qman_ceetm_channel_set_group_cr_eligiblility(struct qm_ceetm_channel
+				*channel, int group_b, int cre);
+int qman_ceetm_channel_set_group_er_eligiblility(struct qm_ceetm_channel
+				*channel, int group_b, int ere);
+
+/**
+ * qman_ceetm_channel_set_cq_cr_eligibility
+ * qman_ceetm_channel_set_cq_er_eligibility - Set channel cq eligibitity
+ * @channel: the given channel object
+ * @idx: is from 0 to 7 (representing CQ0 to CQ7).
+ * @cre: the commit rate eligibility, 1 for enable, 0 for disable.
+ *
+ * Return zero for success, or -EINVAL if eligiblity setting fails.
+*/
+int qman_ceetm_channel_set_cq_cr_eligiblility(struct qm_ceetm_channel *channel,
+					unsigned int idx, int cre);
+int qman_ceetm_channel_set_cq_er_eligiblility(struct qm_ceetm_channel *channel,
+					unsigned int idx, int ere);
+
 	/* --------------------- */
 	/* CEETM :: class queues */
 	/* --------------------- */
-- 
2.0.2

