From 7b6f8fe39b63cf87db04ff9713dbbc9f95940cb5 Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Tue, 16 Sep 2014 13:32:48 +0800
Subject: [PATCH 0958/1089] fsl/pm: add api to get suspend state which is
 STANDBY or MEM

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Add set_pm_suspend_state & pm_suspend_state functions to set/get
suspend state. When system going to sleep or deep sleep, devices
can get the system suspend state(STANDBY/MEM) through pm_suspend_state
function and to handle different situations.

Signed-off-by: Wang Dongsheng <dongsheng.wang@freescale.com>
Change-Id: Ibd369079f6f0777854d88d7e1af21f455eaf909e
Reviewed-on: http://git.am.freescale.net:8181/11530
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Yang Li <LeoLi@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 arch/powerpc/include/asm/fsl_pm.h      |  6 ++++++
 arch/powerpc/kernel/Makefile           |  1 +
 arch/powerpc/kernel/fsl_pm.c           | 26 ++++++++++++++++++++++++++
 arch/powerpc/platforms/85xx/qoriq_pm.c |  5 +++++
 arch/powerpc/sysdev/fsl_pmc.c          | 15 +++++++++++++--
 5 files changed, 51 insertions(+), 2 deletions(-)
 create mode 100644 arch/powerpc/kernel/fsl_pm.c

diff --git a/arch/powerpc/include/asm/fsl_pm.h b/arch/powerpc/include/asm/fsl_pm.h
index d06adaa..bcdc018 100644
--- a/arch/powerpc/include/asm/fsl_pm.h
+++ b/arch/powerpc/include/asm/fsl_pm.h
@@ -13,6 +13,8 @@
 #ifdef	__KERNEL__
 
 #ifndef __ASSEMBLY__
+#include <linux/suspend.h>
+
 #define E500_PM_PH10	1
 #define E500_PM_PH15	2
 #define E500_PM_PH20	3
@@ -47,6 +49,10 @@ extern int fsl_enter_epu_deepsleep(void);
 extern void fsl_dp_enter_low(void __iomem *ccsr_base, void __iomem *dcsr_base,
 			     void __iomem *pld_base, int pld_flag);
 extern void fsl_booke_deep_sleep_resume(void);
+
+void set_pm_suspend_state(suspend_state_t state);
+suspend_state_t pm_suspend_state(void);
+
 #endif	/* __ASSEMBLY__ */
 
 #define T1040QDS_TETRA_FLAG	1
diff --git a/arch/powerpc/kernel/Makefile b/arch/powerpc/kernel/Makefile
index 71d74c0..d29e8e2 100644
--- a/arch/powerpc/kernel/Makefile
+++ b/arch/powerpc/kernel/Makefile
@@ -62,6 +62,7 @@ obj-$(CONFIG_EEH)              += eeh.o eeh_pe.o eeh_dev.o eeh_cache.o \
 obj-$(CONFIG_GENERIC_TBSYNC)	+= smp-tbsync.o
 obj-$(CONFIG_CRASH_DUMP)	+= crash_dump.o
 obj-$(CONFIG_FA_DUMP)		+= fadump.o
+obj-$(CONFIG_FSL_SOC)		+= fsl_pm.o
 ifeq ($(CONFIG_PPC32),y)
 obj-$(CONFIG_E500)		+= idle_e500.o
 endif
diff --git a/arch/powerpc/kernel/fsl_pm.c b/arch/powerpc/kernel/fsl_pm.c
new file mode 100644
index 0000000..1d19b85
--- /dev/null
+++ b/arch/powerpc/kernel/fsl_pm.c
@@ -0,0 +1,26 @@
+/*
+ * Freescale General Power Management Implementation
+ *
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ * Author: Wang Dongsheng <dongsheng.wang@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/suspend.h>
+#include <asm/fsl_pm.h>
+
+static suspend_state_t pm_state;
+
+void set_pm_suspend_state(suspend_state_t state)
+{
+	pm_state = state;
+}
+
+suspend_state_t pm_suspend_state(void)
+{
+	return pm_state;
+}
diff --git a/arch/powerpc/platforms/85xx/qoriq_pm.c b/arch/powerpc/platforms/85xx/qoriq_pm.c
index 4578a63..9f656e9 100644
--- a/arch/powerpc/platforms/85xx/qoriq_pm.c
+++ b/arch/powerpc/platforms/85xx/qoriq_pm.c
@@ -79,12 +79,15 @@ static int qoriq_suspend_enter(suspend_state_t state)
 
 static int qoriq_suspend_valid(suspend_state_t state)
 {
+	set_pm_suspend_state(state);
+
 	if (state == PM_SUSPEND_STANDBY && (sleep_modes & FSL_SLEEP))
 		return 1;
 
 	if (state == PM_SUSPEND_MEM && (sleep_modes & FSL_DEEP_SLEEP))
 		return 1;
 
+	set_pm_suspend_state(PM_SUSPEND_ON);
 	return 0;
 }
 
@@ -100,6 +103,7 @@ static int qoriq_suspend_begin(suspend_state_t state)
 
 static void qoriq_suspend_end(void)
 {
+	set_pm_suspend_state(PM_SUSPEND_ON);
 	fsl_dp_iounmap();
 }
 
@@ -128,6 +132,7 @@ static int __init qoriq_suspend_init(void)
 	}
 
 	suspend_set_ops(&qoriq_suspend_ops);
+	set_pm_suspend_state(PM_SUSPEND_ON);
 
 	return 0;
 }
diff --git a/arch/powerpc/sysdev/fsl_pmc.c b/arch/powerpc/sysdev/fsl_pmc.c
index 81d75a6..8f50c40 100644
--- a/arch/powerpc/sysdev/fsl_pmc.c
+++ b/arch/powerpc/sysdev/fsl_pmc.c
@@ -22,6 +22,7 @@
 #include <linux/of_address.h>
 #include <linux/of_platform.h>
 #include <linux/pm.h>
+#include <asm/fsl_pm.h>
 #include <asm/switch_to.h>
 #include <asm/cacheflush.h>
 
@@ -164,16 +165,25 @@ static int pmc_suspend_enter(suspend_state_t state)
 
 static int pmc_suspend_valid(suspend_state_t state)
 {
+	set_pm_suspend_state(state);
+
 	if (((pmc_flag & PMC_SLEEP) && (state == PM_SUSPEND_STANDBY)) ||
 	    ((pmc_flag & PMC_DEEP_SLEEP) && (state == PM_SUSPEND_MEM)))
 		return 1;
-	else
-		return 0;
+
+	set_pm_suspend_state(PM_SUSPEND_ON);
+	return 0;
+}
+
+static void pmc_suspend_end(void)
+{
+	set_pm_suspend_state(PM_SUSPEND_ON);
 }
 
 static const struct platform_suspend_ops pmc_suspend_ops = {
 	.valid = pmc_suspend_valid,
 	.enter = pmc_suspend_enter,
+	.end = pmc_suspend_end,
 };
 
 static int pmc_probe(struct platform_device *pdev)
@@ -192,6 +202,7 @@ static int pmc_probe(struct platform_device *pdev)
 		pmc_flag |= PMC_DEEP_SLEEP | PMC_LOSSLESS;
 
 	suspend_set_ops(&pmc_suspend_ops);
+	set_pm_suspend_state(PM_SUSPEND_ON);
 
 	pr_info("Freescale PMC driver\n");
 	return 0;
-- 
2.0.2

