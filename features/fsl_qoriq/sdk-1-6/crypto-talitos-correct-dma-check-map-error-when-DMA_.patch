From 8c4cf0b6d34ecda575eee6244bafb46cef6607d0 Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Mon, 2 Feb 2015 14:13:54 +0800
Subject: [PATCH 3/4] crypto:talitos: correct dma check map error when
 DMA_API_DEBUG is enabled

Need to use dma_mapping_error() to check the dma address returned
by dma_map_single/page(), otherwise would get the error like below:

lib/dma-debug.c:937
CPU: 1 PID: 90 Comm: irq/58-talitos Not tainted 3.10.62-ltsi-WR6.0.0.0_cgl #4
[  144.579353] task: c6a48000 ti: effe6000 task.ti: c63d0000
[  144.583453] NIP: c04c4cec LR: c04c4cec CTR: c05e0a80
[  144.587119] REGS: effe7d20 TRAP: 0700   Not tainted  (3.10.62-ltsi-WR6.0.0.0_cgl)
[  144.593304] MSR: 00021000 <CE,ME CR: 24282084  XER: 00000000
[  144.597869]
GPR00: c04c4cec effe7dd0 c6a48000 0000008e 00021000 0000008e c0bc6750 c14be36c
GPR08: 00000000 00000000 00000000 00000176 44282084 00000000 c0bbf040 00000000
GPR16: 00000000 c5337028 00029000 00000000 ff000000 00000006 c0bc6940 c0c9ff60
GPR24: 00029000 c0b8dbbc c0c949c8 c0b90000 effe7e18 efa702a0 00000000 c0c949c0
[  144.626482] NIP [c04c4cec] check_unmap+0x498/0x9a8
[  144.629975] LR [c04c4cec] check_unmap+0x498/0x9a8
[  144.633376] Call Trace:
[  144.634521] [effe7dd0] [c04c4cec] check_unmap+0x498/0x9a8 (unreliable)
[  144.639767] [effe7e10] [c04c5274] debug_dma_unmap_page+0x78/0x8c
[  144.644486] [effe7e90] [c0720064] ipsec_esp_unmap+0x38/0x1b4
[  144.648856] [effe7eb0] [c0720214] ipsec_esp_decrypt_hwauth_done+0x34/0x80
[  144.654367] [effe7ed0] [c071d47c] flush_channel+0x184/0x26c
[  144.658652] [effe7f20] [c071d5cc] talitos_done_ch1_3+0x68/0x108
[  144.663287] [effe7f40] [c0757ec4] net_rx_action+0x13c/0x25c
[  144.667579] [effe7f90] [c005398c] __do_softirq+0x110/0x2a0
[  144.671776] [effe7ff0] [c000ee50] call_do_softirq+0x14/0x24
[  144.676062] [c63d1e50] [c000563c] do_softirq+0xc4/0xf4
[  144.679911] [c63d1e70] [c005362c] local_bh_enable+0xc8/0xe0
[  144.684199] [c63d1e80] [c00eac84] irq_forced_thread_fn+0x5c/0x74
[  144.688917] [c63d1ea0] [c00eafc0] irq_thread+0x124/0x154
[  144.692942] [c63d1ee0] [c0073f0c] kthread+0xb4/0xb8
[  144.696533] [c63d1f40] [c001103c] ret_from_kernel_thread+0x5c/0x64

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/crypto/talitos.c |  178 ++++++++++++++++++++++++++++++++++------------
 1 files changed, 132 insertions(+), 46 deletions(-)

diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c
index 636e2ec..9026f03 100644
--- a/drivers/crypto/talitos.c
+++ b/drivers/crypto/talitos.c
@@ -65,7 +65,7 @@ static void to_talitos_ptr(struct talitos_ptr *talitos_ptr, dma_addr_t dma_addr)
 /*
  * map virtual single (contiguous) pointer to h/w descriptor pointer
  */
-static void map_single_talitos_ptr(struct device *dev,
+static int map_single_talitos_ptr(struct device *dev,
 				   struct talitos_ptr *talitos_ptr,
 				   unsigned short len, void *data,
 				   unsigned char extent,
@@ -73,9 +73,14 @@ static void map_single_talitos_ptr(struct device *dev,
 {
 	dma_addr_t dma_addr = dma_map_single(dev, data, len, dir);
 
+	if (unlikely(dma_mapping_error(dev, dma_addr)))
+		return -ENOMEM;
+
 	talitos_ptr->len = cpu_to_be16(len);
 	to_talitos_ptr(talitos_ptr, dma_addr);
 	talitos_ptr->j_extent = extent;
+	
+	return 0;
 }
 
 /*
@@ -220,6 +225,12 @@ int talitos_submit(struct device *dev, int ch, struct talitos_desc *desc,
 	/* map descriptor and save caller data */
 	request->dma_desc = dma_map_single(dev, desc, sizeof(*desc),
 					   DMA_BIDIRECTIONAL);
+	
+	if (unlikely(dma_mapping_error(dev, request->dma_desc))) {
+		spin_unlock_irqrestore(&priv->chan[ch].head_lock, flags);
+		return -ENOMEM;
+	}
+	
 	request->callback = callback;
 	request->context = context;
 
@@ -1382,9 +1393,11 @@ static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,
 	int sg_link_tbl_len;
 
 	/* hmac key */
-	map_single_talitos_ptr(dev, &desc->ptr[0], ctx->authkeylen, &ctx->key,
-			       0, DMA_TO_DEVICE);
-
+	ret = map_single_talitos_ptr(dev, &desc->ptr[0], ctx->authkeylen, &ctx->key,
+				     0, DMA_TO_DEVICE);
+	if (ret)
+		goto out_hmac_error;
+	
 	/* hmac data */
 	desc->ptr[1].len = cpu_to_be16(areq->assoclen + ivsize);
 	if (edesc->assoc_nents) {
@@ -1422,10 +1435,12 @@ static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,
 	dma_sync_single_for_device(dev, edesc->iv_dma, ivsize, DMA_TO_DEVICE);
 
 	/* cipher key */
-	map_single_talitos_ptr(dev, &desc->ptr[3], ctx->enckeylen,
-			       (char *)&ctx->key + ctx->authkeylen, 0,
-			       DMA_TO_DEVICE);
-
+	ret = map_single_talitos_ptr(dev, &desc->ptr[3], ctx->enckeylen,
+				     (char *)&ctx->key + ctx->authkeylen, 0,
+			             DMA_TO_DEVICE);
+	if (ret)
+		goto out_cipher_error;
+	
 	/*
 	 * cipher in
 	 * map and adjust cipher len to aead request cryptlen.
@@ -1501,14 +1516,36 @@ static int ipsec_esp(struct talitos_edesc *edesc, struct aead_request *areq,
 	}
 
 	/* iv out */
-	map_single_talitos_ptr(dev, &desc->ptr[6], ivsize, ctx->iv, 0,
-			       DMA_FROM_DEVICE);
-
+	ret = map_single_talitos_ptr(dev, &desc->ptr[6], ivsize, ctx->iv, 0,
+                                     DMA_FROM_DEVICE);
+	if (ret)
+		goto out_iv_error;
+	
 	ret = talitos_submit(dev, ctx->ch, desc, callback, areq);
-	if (ret != -EINPROGRESS) {
-		ipsec_esp_unmap(dev, edesc, areq);
-		kfree(edesc);
-	}
+	if (ret != -EINPROGRESS)
+		goto out_submit_error;
+	return ret;
+	
+out_submit_error:
+	unmap_single_talitos_ptr(dev, &edesc->desc.ptr[6], DMA_FROM_DEVICE);
+out_iv_error:
+	unmap_single_talitos_ptr(dev, &edesc->desc.ptr[3], DMA_TO_DEVICE);
+	talitos_sg_unmap(dev, edesc, areq->src, areq->dst);
+out_cipher_error:
+	unmap_single_talitos_ptr(dev, &edesc->desc.ptr[0], DMA_TO_DEVICE);
+out_hmac_error:
+	dma_unmap_single(dev, edesc->iv_dma, ivsize, DMA_TO_DEVICE);
+	if (edesc->assoc_chained)
+		talitos_unmap_sg_chain(dev, areq->assoc, DMA_TO_DEVICE);
+	else
+		/* assoc_nents counts also for IV in non-contiguous cases */
+		dma_unmap_sg(dev, areq->assoc,
+			     edesc->assoc_nents ? edesc->assoc_nents - 1 : 1,
+			     DMA_TO_DEVICE);	
+	if (edesc->dma_len)
+		dma_unmap_single(dev, edesc->dma_link_tbl, edesc->dma_len,
+				 DMA_BIDIRECTIONAL);		
+	kfree(edesc);
 	return ret;
 }
 
@@ -1617,8 +1654,11 @@ static struct talitos_edesc *talitos_edesc_alloc(struct device *dev,
 		return ERR_PTR(-EINVAL);
 	}
 
-	if (iv)
+	if (iv) {
 		iv_dma = dma_map_single(dev, iv, ivsize, DMA_TO_DEVICE);
+		if (unlikely(dma_mapping_error(dev, iv_dma)))
+			return ERR_PTR(-ENOMEM);
+	}
 
 	if (assoc) {
 		/*
@@ -1683,10 +1723,18 @@ static struct talitos_edesc *talitos_edesc_alloc(struct device *dev,
 	edesc->dst_chained = dst_chained;
 	edesc->iv_dma = iv_dma;
 	edesc->dma_len = dma_len;
-	if (dma_len)
+	if (dma_len) {
 		edesc->dma_link_tbl = dma_map_single(dev, &edesc->link_tbl[0],
 						     edesc->dma_len,
 						     DMA_BIDIRECTIONAL);
+		if (unlikely(dma_mapping_error(dev, edesc->dma_link_tbl))) {
+			kfree(edesc);
+			talitos_unmap_sg_chain(dev, assoc, DMA_TO_DEVICE);
+			if (iv_dma)
+				dma_unmap_single(dev, iv_dma, ivsize, DMA_TO_DEVICE);
+			return ERR_PTR(-ENOMEM);
+		}
+	}
 
 	return edesc;
 }
@@ -1861,9 +1909,10 @@ static int common_nonsnoop(struct talitos_edesc *edesc,
 	desc->ptr[1].j_extent = 0;
 
 	/* cipher key */
-	map_single_talitos_ptr(dev, &desc->ptr[2], ctx->keylen,
-			       (char *)&ctx->key, 0, DMA_TO_DEVICE);
-
+	ret = map_single_talitos_ptr(dev, &desc->ptr[2], ctx->keylen,
+			             (char *)&ctx->key, 0, DMA_TO_DEVICE);
+	if (ret)
+		goto out_cipher_error;
 	/*
 	 * cipher in
 	 */
@@ -1919,20 +1968,33 @@ static int common_nonsnoop(struct talitos_edesc *edesc,
 	}
 
 	/* iv out */
-	map_single_talitos_ptr(dev, &desc->ptr[5], ivsize, ctx->iv, 0,
-			       DMA_FROM_DEVICE);
-
+	ret = map_single_talitos_ptr(dev, &desc->ptr[5], ivsize, ctx->iv, 0,
+			             DMA_FROM_DEVICE);
+	
+	if (ret)
+		goto out_iv_error;
 	/* last DWORD empty */
 	desc->ptr[6].len = 0;
 	to_talitos_ptr(&desc->ptr[6], 0);
 	desc->ptr[6].j_extent = 0;
 
 	ret = talitos_submit(dev, ctx->ch, desc, callback, areq);
-	if (ret != -EINPROGRESS) {
-		common_nonsnoop_unmap(dev, edesc, areq);
-		kfree(edesc);
-	}
+	if (ret != -EINPROGRESS) 
+		goto out_submit_error;
 	return ret;
+	
+out_submit_error:
+	unmap_single_talitos_ptr(dev, &edesc->desc.ptr[5], DMA_FROM_DEVICE);
+out_iv_error:	
+	unmap_single_talitos_ptr(dev, &edesc->desc.ptr[2], DMA_TO_DEVICE);
+	talitos_sg_unmap(dev, edesc, areq->src, areq->dst);
+out_cipher_error:
+	unmap_single_talitos_ptr(dev, &edesc->desc.ptr[1], DMA_TO_DEVICE);
+	if (edesc->dma_len)
+		dma_unmap_single(dev, edesc->dma_link_tbl, edesc->dma_len,
+				 DMA_BIDIRECTIONAL);	
+	kfree(edesc);
+	return ret;	
 }
 
 static struct talitos_edesc *ablkcipher_edesc_alloc(struct ablkcipher_request *
@@ -2044,11 +2106,14 @@ static int common_nonsnoop_hash(struct talitos_edesc *edesc,
 
 	/* hash context in */
 	if (!req_ctx->first || req_ctx->swinit) {
-		map_single_talitos_ptr(dev, &desc->ptr[1],
-				       req_ctx->hw_context_size,
-				       (char *)req_ctx->hw_context, 0,
-				       DMA_TO_DEVICE);
-		req_ctx->swinit = 0;
+		ret = map_single_talitos_ptr(dev, &desc->ptr[1],
+				             req_ctx->hw_context_size,
+				             (char *)req_ctx->hw_context, 0,
+				             DMA_TO_DEVICE);
+		if (ret)
+			goto out_hash_context_error;
+		
+		req_ctx->swinit = 0;		
 	} else {
 		desc->ptr[1] = zero_entry;
 		/* Indicate next op is not the first. */
@@ -2056,10 +2121,12 @@ static int common_nonsnoop_hash(struct talitos_edesc *edesc,
 	}
 
 	/* HMAC key */
-	if (ctx->keylen)
-		map_single_talitos_ptr(dev, &desc->ptr[2], ctx->keylen,
-				       (char *)&ctx->key, 0, DMA_TO_DEVICE);
-	else
+	if (ctx->keylen) {
+		ret = map_single_talitos_ptr(dev, &desc->ptr[2], ctx->keylen,
+				             (char *)&ctx->key, 0, DMA_TO_DEVICE);
+		if (ret)
+			goto out_hmac_error;
+	} else
 		desc->ptr[2] = zero_entry;
 
 	/*
@@ -2096,22 +2163,41 @@ static int common_nonsnoop_hash(struct talitos_edesc *edesc,
 
 	/* hash/HMAC out -or- hash context out */
 	if (req_ctx->last)
-		map_single_talitos_ptr(dev, &desc->ptr[5],
-				       crypto_ahash_digestsize(tfm),
-				       areq->result, 0, DMA_FROM_DEVICE);
+		ret = map_single_talitos_ptr(dev, &desc->ptr[5],
+				             crypto_ahash_digestsize(tfm),
+				             areq->result, 0, DMA_FROM_DEVICE);
 	else
-		map_single_talitos_ptr(dev, &desc->ptr[5],
-				       req_ctx->hw_context_size,
-				       req_ctx->hw_context, 0, DMA_FROM_DEVICE);
+		ret = map_single_talitos_ptr(dev, &desc->ptr[5],
+				             req_ctx->hw_context_size,
+				             req_ctx->hw_context, 0, DMA_FROM_DEVICE);
+
+	if (ret)
+		goto out_hash_out_error;
 
 	/* last DWORD empty */
 	desc->ptr[6] = zero_entry;
 
 	ret = talitos_submit(dev, ctx->ch, desc, callback, areq);
-	if (ret != -EINPROGRESS) {
-		common_nonsnoop_hash_unmap(dev, edesc, areq);
-		kfree(edesc);
-	}
+	if (ret != -EINPROGRESS)
+		goto out_submit_error;
+	return ret;
+	
+out_submit_error:
+	unmap_single_talitos_ptr(dev, &edesc->desc.ptr[5], DMA_FROM_DEVICE);
+out_hash_out_error:	
+	if (edesc->desc.ptr[2].len)
+		unmap_single_talitos_ptr(dev, &edesc->desc.ptr[2],
+					 DMA_TO_DEVICE);
+	talitos_sg_unmap(dev, edesc, req_ctx->psrc, NULL);
+out_hmac_error:
+	if (edesc->desc.ptr[1].len)
+		unmap_single_talitos_ptr(dev, &edesc->desc.ptr[1],
+					 DMA_TO_DEVICE);	
+out_hash_context_error:
+	if (edesc->dma_len)
+		dma_unmap_single(dev, edesc->dma_link_tbl, edesc->dma_len,
+				 DMA_BIDIRECTIONAL);	
+	kfree(edesc);	
 	return ret;
 }
 
-- 
1.7.5.4

