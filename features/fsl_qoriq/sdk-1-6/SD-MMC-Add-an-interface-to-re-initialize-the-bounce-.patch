From 08e04f99cd083e88c662ad2bc6c12cc9f930e843 Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Wed, 3 Sep 2014 09:56:56 +0800
Subject: [PATCH 0019/1089] SD/MMC: Add an interface to re-initialize the
 bounce buffer

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Add bounce_size under /sys/block/mmcblk0/bouncesz. Support dynamic adjustment of
bounce buffer in run-time (include mounted or unmounted filesystem)

/sys/block/mmcblk0/bouncesz should be integer multiple of 512, the value should
be range from 4096 to 4194304

1. Use variable instead of MMC_QUEUE_BOUNCESZ
2. Re-initialize bounce buffer accorinding to new bounce size at run-time

Signed-off-by: Qiang Liu <qiang.liu@freescale.com>
Change-Id: I66849d61f4bae903c9c329cf379a55c86bb30890
Reviewed-on: http://git.am.freescale.net:8181/324
Reviewed-by: Huang Changming-R66093 <Chang-Ming.Huang@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 Documentation/mmc/mmc-dev-attrs.txt |   2 +
 drivers/mmc/card/block.c            |  46 ++++++++++++++++
 drivers/mmc/card/queue.c            | 102 +++++++++++++++++++++++++++++++++++-
 drivers/mmc/card/queue.h            |   5 ++
 4 files changed, 154 insertions(+), 1 deletion(-)

diff --git a/Documentation/mmc/mmc-dev-attrs.txt b/Documentation/mmc/mmc-dev-attrs.txt
index 189bab0..db00d95 100644
--- a/Documentation/mmc/mmc-dev-attrs.txt
+++ b/Documentation/mmc/mmc-dev-attrs.txt
@@ -7,6 +7,8 @@ SD or MMC device.
 The following attributes are read/write.
 
 	force_ro		Enforce read-only access even if write protect switch is off.
+	bouncesz		Support dynamic adjustment of bounce buffer size at runtime,
+				from 4096 to 4194304, integer multiple of 512 bytes only.
 
 SD and MMC Device Attributes
 ============================
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 7b5424f..d76b447 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -59,6 +59,8 @@ MODULE_ALIAS("mmc:block");
 #define INAND_CMD38_ARG_SECTRIM1 0x81
 #define INAND_CMD38_ARG_SECTRIM2 0x88
 #define MMC_BLK_TIMEOUT_MS  (10 * 60 * 1000)        /* 10 minute timeout */
+#define MMC_MIN_QUEUE_BOUNCESZ 4096
+#define MMC_MAX_QUEUE_BOUNCESZ 4194304
 #define MMC_SANITIZE_REQ_TIMEOUT 240000
 #define MMC_EXTRACT_INDEX_FROM_ARG(x) ((x & 0x00FF0000) >> 16)
 
@@ -118,6 +120,7 @@ struct mmc_blk_data {
 	unsigned int	part_curr;
 	struct device_attribute force_ro;
 	struct device_attribute power_ro_lock;
+	struct device_attribute bouncesz;
 	int	area_type;
 };
 
@@ -2237,6 +2240,7 @@ static void mmc_blk_remove_req(struct mmc_blk_data *md)
 			mmc_packed_clean(&md->queue);
 		if (md->disk->flags & GENHD_FL_UP) {
 			device_remove_file(disk_to_dev(md->disk), &md->force_ro);
+			device_remove_file(disk_to_dev(md->disk), &md->bouncesz);
 			if ((md->area_type & MMC_BLK_DATA_AREA_BOOT) &&
 					card->ext_csd.boot_ro_lockable)
 				device_remove_file(disk_to_dev(md->disk),
@@ -2248,6 +2252,33 @@ static void mmc_blk_remove_req(struct mmc_blk_data *md)
 	}
 }
 
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+static ssize_t mmc_bouncesz_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	 return sprintf(buf, "%u\n", mmc_queue_bouncesz);
+}
+
+static ssize_t mmc_bouncesz_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned int bouncesz;
+	struct mmc_blk_data *md;
+
+	if ((sscanf(buf, "%d", &bouncesz) != 1) ||
+			(bouncesz < MMC_MIN_QUEUE_BOUNCESZ) ||
+			(bouncesz > MMC_MAX_QUEUE_BOUNCESZ) ||
+			(bouncesz % 512 != 0))
+		return -EINVAL;
+
+	md = mmc_blk_get(dev_to_disk(dev));
+	mmc_reinit_bounce_queue(&md->queue, md->queue.card, bouncesz);
+	mmc_blk_put(md);
+	return mmc_queue_bouncesz;
+}
+#endif
+
 static void mmc_blk_remove_parts(struct mmc_card *card,
 				 struct mmc_blk_data *md)
 {
@@ -2375,6 +2406,7 @@ static const struct mmc_fixup blk_fixups[] =
 static int mmc_blk_probe(struct mmc_card *card)
 {
 	struct mmc_blk_data *md, *part_md;
+	int err;
 	char cap_str[10];
 
 	/*
@@ -2407,6 +2439,17 @@ static int mmc_blk_probe(struct mmc_card *card)
 			goto out;
 	}
 
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+	md->bouncesz.show = mmc_bouncesz_show;
+	md->bouncesz.store = mmc_bouncesz_store;
+	sysfs_attr_init(&md->bouncesz.attr);
+	md->bouncesz.attr.name = "bouncesz";
+	md->bouncesz.attr.mode = S_IRUGO | S_IWUSR;
+	err = device_create_file(disk_to_dev(md->disk), &md->bouncesz);
+	if (err)
+		goto out;
+#endif
+
 	pm_runtime_set_autosuspend_delay(&card->dev, 3000);
 	pm_runtime_use_autosuspend(&card->dev);
 
@@ -2422,6 +2465,9 @@ static int mmc_blk_probe(struct mmc_card *card)
 	return 0;
 
  out:
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+	device_remove_file(disk_to_dev(md->disk), &md->bouncesz);
+#endif
 	mmc_blk_remove_parts(card, md);
 	mmc_blk_remove_req(md);
 	return 0;
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 3e049c1..9bfea05 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -23,6 +23,10 @@
 
 #define MMC_QUEUE_BOUNCESZ	65536
 
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+unsigned mmc_queue_bouncesz = MMC_QUEUE_BOUNCESZ;
+#endif
+
 /*
  * Prepare a MMC request. This just filters out odd stuff.
  */
@@ -217,7 +221,7 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 	if (host->max_segs == 1) {
 		unsigned int bouncesz;
 
-		bouncesz = MMC_QUEUE_BOUNCESZ;
+		bouncesz = mmc_queue_bouncesz;
 
 		if (bouncesz > host->max_req_size)
 			bouncesz = host->max_req_size;
@@ -404,6 +408,102 @@ void mmc_packed_clean(struct mmc_queue *mq)
 }
 
 /**
+ * mmc_reinit_bounce_queue - re-initialise a bounce buffer.
+ * @mq: mmc queue
+ * @card: mmc card to attach this queue
+ * @bouncesz: the bounce size that need re-initializing
+ *
+ * Initialise a MMC card request queue.
+ */
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+int mmc_reinit_bounce_queue(struct mmc_queue *mq, struct mmc_card *card,
+		   unsigned int bouncesz)
+{
+	struct mmc_host *host = card->host;
+	struct mmc_queue_req *mqrq_cur = &mq->mqrq[0];
+	struct mmc_queue_req *mqrq_prev = &mq->mqrq[1];
+	int ret;
+	struct scatterlist *curr_bounce_sg, *prev_bounce_sg;
+	char *curr_bounce_buf, *prev_bounce_buf;
+
+	mmc_claim_host(card->host);
+
+	bouncesz = min(bouncesz, host->max_req_size);
+	bouncesz = min(bouncesz, host->max_seg_size);
+	bouncesz = min(bouncesz, host->max_blk_count * 512);
+
+	/* store current using addr of bounce_buf and bounce_sg */
+	curr_bounce_sg = mqrq_cur->bounce_sg;
+	prev_bounce_sg = mqrq_prev->bounce_sg;
+	curr_bounce_buf = mqrq_cur->bounce_buf;
+	prev_bounce_buf = mqrq_prev->bounce_buf;
+
+	if (host->max_segs != 1)
+		goto restore_queue;
+
+	/* realloc bounce queue use given bounce size */
+	mqrq_cur->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+	if (!mqrq_cur->bounce_buf) {
+		printk(KERN_WARNING "%s: unable to "
+			"allocate bounce cur buffer\n",
+			mmc_card_name(card));
+		ret = -ENOMEM;
+		goto restore_queue;
+	}
+
+	mqrq_prev->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+	if (!mqrq_prev->bounce_buf) {
+		printk(KERN_WARNING "%s: unable to "
+			"allocate bounce prev buffer\n",
+			mmc_card_name(card));
+		kfree(mqrq_cur->bounce_buf);
+		mqrq_cur->bounce_buf = NULL;
+		ret = -ENOMEM;
+		goto restore_queue;
+	}
+
+	mqrq_cur->bounce_sg =
+		mmc_alloc_sg(bouncesz / 512, &ret);
+	if (ret)
+		goto cleanup_queue;
+
+	mqrq_prev->bounce_sg =
+		mmc_alloc_sg(bouncesz / 512, &ret);
+	if (ret)
+		goto cleanup_queue;
+
+	blk_queue_max_hw_sectors(mq->queue, bouncesz / 512);
+	blk_queue_max_segments(mq->queue, bouncesz / 512);
+	blk_queue_max_segment_size(mq->queue, bouncesz);
+	mmc_queue_bouncesz = bouncesz;
+
+	kfree(curr_bounce_sg);
+	kfree(prev_bounce_sg);
+	kfree(curr_bounce_buf);
+	kfree(prev_bounce_buf);
+
+	mmc_release_host(card->host);
+	return 0;
+
+cleanup_queue:
+	/* cleanup bounce queue first */
+	kfree(mqrq_cur->sg);
+	kfree(mqrq_cur->bounce_buf);
+	kfree(mqrq_prev->sg);
+	kfree(mqrq_prev->bounce_buf);
+
+restore_queue:
+	mqrq_cur->bounce_buf = curr_bounce_buf;
+	mqrq_prev->bounce_buf = prev_bounce_buf;
+	mqrq_cur->bounce_sg = curr_bounce_sg;
+	mqrq_prev->bounce_sg = prev_bounce_sg;
+
+	mmc_release_host(card->host);
+	return ret;
+}
+#endif
+
+/**
  * mmc_queue_suspend - suspend a MMC request queue
  * @mq: MMC queue to suspend
  *
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
index 5752d50..d96cb0f 100644
--- a/drivers/mmc/card/queue.h
+++ b/drivers/mmc/card/queue.h
@@ -67,6 +67,11 @@ extern void mmc_queue_resume(struct mmc_queue *);
 
 extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
 				     struct mmc_queue_req *);
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+extern int mmc_reinit_bounce_queue(struct mmc_queue *, struct mmc_card *,
+		unsigned int);
+extern unsigned mmc_queue_bouncesz;
+#endif
 extern void mmc_queue_bounce_pre(struct mmc_queue_req *);
 extern void mmc_queue_bounce_post(struct mmc_queue_req *);
 
-- 
2.0.2

