From a327da26ad8f4ad3f907a65c7e9f3bcebe26cda5 Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Wed, 10 Sep 2014 18:05:39 +0800
Subject: [PATCH 0506/1089] dpaa_eth: Fix kernel crash with timestamp support
 on

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Recent changes in the driver moved the allocation of the skb on Rx
past the point where the timestamp/1588 code used the skb.
Reorder a bit the code to avoid NULL pointer dereferencing.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: I09929c13bc88048be77c8678c1fb9956fec41039
Reviewed-on: http://git.am.freescale.net:8181/4443
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Sovaiala Cristian-Constantin-B39531 <Cristian.Sovaiala@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 30 +++++++++++++-----------
 1 file changed, 16 insertions(+), 14 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index eb300b4..cbc20bd 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -337,6 +337,11 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	vaddr = phys_to_virt(addr);
 	BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
 
+	/* Build the skb and adjust data and tail pointers */
+	skb = build_skb(vaddr, dpa_bp->size + DPA_SKB_TAILROOM);
+	if (unlikely(!skb))
+		return NULL;
+
 	/* do we need the timestamp for bad frames? */
 #ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
@@ -351,11 +356,6 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	 * skb_shinfo) be SMP_CACHE_BYTES-aligned. The former is aligned,
 	 * thanks to vaddr. We still need to adjust the size accordingly.
 	 */
-	skb = build_skb(vaddr, DPA_SKB_SIZE(dpa_bp->size) +
-		SKB_DATA_ALIGN(sizeof(struct skb_shared_info)));
-	if (unlikely(!skb))
-		return NULL;
-
 	BUG_ON(fd_off != priv->rx_headroom);
 	skb_reserve(skb, fd_off);
 	skb_put(skb, dpa_fd_length(fd));
@@ -398,15 +398,6 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 
 	vaddr = phys_to_virt(addr);
 	BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
-#ifdef CONFIG_FSL_DPAA_1588
-	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
-		dpa_ptp_store_rxstamp(priv, skb, vaddr);
-#endif
-
-#ifdef CONFIG_FSL_DPAA_TS
-	if (priv->ts_rx_en)
-		dpa_get_ts(priv, RX, skb_hwtstamps(skb), vaddr);
-#endif /* CONFIG_FSL_DPAA_TS */
 
 	/* Iterate through the SGT entries and add data buffers to the skb */
 	sgt = vaddr + fd_off;
@@ -441,6 +432,17 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 				 */
 				return NULL;
 
+#ifdef CONFIG_FSL_DPAA_1588
+			if (priv->tsu && priv->tsu->valid &&
+			    priv->tsu->hwts_rx_en_ioctl)
+				dpa_ptp_store_rxstamp(priv, skb, vaddr);
+#endif
+
+#ifdef CONFIG_FSL_DPAA_TS
+			if (priv->ts_rx_en)
+				dpa_get_ts(priv, RX, skb_hwtstamps(skb), vaddr);
+#endif /* CONFIG_FSL_DPAA_TS */
+
 			dma_unmap_single(dpa_bp->dev, sg_addr, dpa_bp->size,
 				DMA_BIDIRECTIONAL);
 
-- 
2.0.2

