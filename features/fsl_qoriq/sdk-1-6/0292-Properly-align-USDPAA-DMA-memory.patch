From e64ae70c68e0ca7a9738c885283b66eb74eb3024 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Wed, 23 Apr 2014 11:49:16 -0400
Subject: [PATCH 292/466] Properly align USDPAA DMA memory

DMA memory must be aligned to the page boundary when mapped
into the processes virtual address space

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: Ibc6320991d8e5317b8724fc2cfdc23ce47faaaf4
Reviewed-on: http://git.am.freescale.net:8181/11409
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c |   24 ++++++++++++++----------
 1 file changed, 14 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 6805508..674f534 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -702,6 +702,9 @@ static unsigned long usdpaa_get_unmapped_area(struct file *file,
 
 	if (len % PAGE_SIZE)
 		return -EINVAL;
+	/* Need to align to largest pagesize to ensure all pages
+	   will be correctly aligned */
+	len = largest_page_size(len);
 
 	addr = USDPAA_MEM_ROUNDUP(addr, len);
 	vma = find_vma(current->mm, addr);
@@ -907,15 +910,6 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 		ret = -EINVAL;
 		goto out;
 	}
-	/* Verify there is sufficient space to do the mapping */
-	down_write(&current->mm->mmap_sem);
-	next_addr = usdpaa_get_unmapped_area(fp, next_addr, i->len, 0, 0);
-	up_write(&current->mm->mmap_sem);
-
-	if (next_addr & ~PAGE_MASK) {
-		ret = -ENOMEM;
-		goto out;
-	}
 
 	/* Find one of more contiguous fragments that satisfy the total length
 	   trying to minimize the number of fragments
@@ -967,6 +961,16 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 	}
 	i->did_create = 1;
 do_map:
+	/* Verify there is sufficient space to do the mapping */
+	down_write(&current->mm->mmap_sem);
+	next_addr = usdpaa_get_unmapped_area(fp, next_addr, i->len, 0, 0);
+	up_write(&current->mm->mmap_sem);
+
+	if (next_addr & ~PAGE_MASK) {
+		ret = -ENOMEM;
+		goto out;
+	}
+
 	/* We may need to divide the final fragment to accomidate the mapping */
 	next_frag = start_frag;
 	while (so_far != i->len) {
@@ -1004,7 +1008,7 @@ out:
 		unsigned long longret;
 		unsigned long populate;
 		down_write(&current->mm->mmap_sem);
-		longret = do_mmap_pgoff(fp, PAGE_SIZE, map->total_size,
+		longret = do_mmap_pgoff(fp, next_addr, map->total_size,
 					PROT_READ |
 					(i->flags &
 					 USDPAA_DMA_FLAG_RDONLY ? 0
-- 
1.7.10.4

