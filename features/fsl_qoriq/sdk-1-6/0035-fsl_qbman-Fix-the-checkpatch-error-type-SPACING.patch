From 4543fe0d214460785c4b28b2ac7b1aa161b9fab0 Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@Freescale.com>
Date: Wed, 8 Jan 2014 04:41:02 -0600
Subject: [PATCH 035/466] fsl_qbman: Fix the checkpatch error type SPACING

ERROR:SPACING: space required before the open parenthesis '('
ERROR:SPACING: space prohibited before that close parenthesis ')'
ERROR:SPACING: space required after that ',' (ctx:VxV)

Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Change-Id: Ifa798bf9edbe187fe9ce21a6c96b70ba58598888
Reviewed-on: http://git.am.freescale.net:8181/7773
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Haiying Wang <Haiying.Wang@freescale.com>
Reviewed-by: Emilian Medve <Emilian.Medve@freescale.com>
Tested-by: Emilian Medve <Emilian.Medve@freescale.com>
[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/bman_config.c         |   14 +++++++-------
 drivers/staging/fsl_qbman/bman_test.h           |    4 ++--
 drivers/staging/fsl_qbman/dpa_sys.h             |   12 ++++++------
 drivers/staging/fsl_qbman/fsl_usdpaa.c          |    2 +-
 drivers/staging/fsl_qbman/qbman_driver.c        |    2 +-
 drivers/staging/fsl_qbman/qman_config.c         |   16 ++++++++--------
 drivers/staging/fsl_qbman/qman_high.c           |    2 +-
 drivers/staging/fsl_qbman/qman_low.h            |    2 +-
 drivers/staging/fsl_qbman/qman_test.c           |    2 +-
 drivers/staging/fsl_qbman/qman_test.h           |    4 ++--
 drivers/staging/fsl_qbman/qman_test_hotpotato.c |    2 +-
 include/linux/fsl_bman.h                        |    4 ++--
 12 files changed, 33 insertions(+), 33 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index e0807da..9330840 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -136,13 +136,13 @@ static const struct bman_error_info_mdata error_mdata[] = {
  * "write the enable register" rather than "enable the write register"!
  */
 #define bm_err_isr_status_read(bm)	__bm_err_isr_read(bm, bm_isr_status)
-#define bm_err_isr_status_clear(bm, m)	__bm_err_isr_write(bm, bm_isr_status,m)
+#define bm_err_isr_status_clear(bm, m)	__bm_err_isr_write(bm, bm_isr_status, m)
 #define bm_err_isr_enable_read(bm)	__bm_err_isr_read(bm, bm_isr_enable)
-#define bm_err_isr_enable_write(bm, v)	__bm_err_isr_write(bm, bm_isr_enable,v)
+#define bm_err_isr_enable_write(bm, v)	__bm_err_isr_write(bm, bm_isr_enable, v)
 #define bm_err_isr_disable_read(bm)	__bm_err_isr_read(bm, bm_isr_disable)
-#define bm_err_isr_disable_write(bm, v)	__bm_err_isr_write(bm, bm_isr_disable,v)
-#define bm_err_isr_inhibit(bm)		__bm_err_isr_write(bm, bm_isr_inhibit,1)
-#define bm_err_isr_uninhibit(bm)	__bm_err_isr_write(bm, bm_isr_inhibit,0)
+#define bm_err_isr_disable_write(bm, v)	__bm_err_isr_write(bm, bm_isr_disable, v)
+#define bm_err_isr_inhibit(bm)		__bm_err_isr_write(bm, bm_isr_inhibit, 1)
+#define bm_err_isr_uninhibit(bm)	__bm_err_isr_write(bm, bm_isr_inhibit, 0)
 
 /*
  * TODO: unimplemented registers
@@ -213,11 +213,11 @@ static u32 __generate_thresh(u32 val, int roundup)
 {
 	u32 e = 0;	/* co-efficient, exponent */
 	int oddbit = 0;
-	while(val > 0xff) {
+	while (val > 0xff) {
 		oddbit = val & 1;
 		val >>= 1;
 		e++;
-		if(roundup && oddbit)
+		if (roundup && oddbit)
 			val++;
 	}
 	DPA_ASSERT(e < 0x10);
diff --git a/drivers/staging/fsl_qbman/bman_test.h b/drivers/staging/fsl_qbman/bman_test.h
index 27c7c05..568492e 100644
--- a/drivers/staging/fsl_qbman/bman_test.h
+++ b/drivers/staging/fsl_qbman/bman_test.h
@@ -61,9 +61,9 @@ static inline void __hexdump(unsigned long start, unsigned long end,
 				nl = 1;
 			} else {
 				nl = 0;
-				if(!(start & 1))
+				if (!(start & 1))
 					buf[pos++] = ' ';
-				if(!(start & 3))
+				if (!(start & 3))
 					buf[pos++] = ' ';
 			}
 		} while (start & 15);
diff --git a/drivers/staging/fsl_qbman/dpa_sys.h b/drivers/staging/fsl_qbman/dpa_sys.h
index 2f33351..31a2ac5 100644
--- a/drivers/staging/fsl_qbman/dpa_sys.h
+++ b/drivers/staging/fsl_qbman/dpa_sys.h
@@ -85,23 +85,23 @@
 #define hwsync() \
 	do { \
 		__asm__ __volatile__ ("sync" : : : "memory"); \
-	} while(0)
+	} while (0)
 #define lwsync() \
 	do { \
 		__asm__ __volatile__ (stringify_in_c(LWSYNC) : : : "memory"); \
-	} while(0)
+	} while (0)
 #define dcbf(p) \
 	do { \
 		__asm__ __volatile__ ("dcbf 0,%0" : : "r" (p) : "memory"); \
-	} while(0)
+	} while (0)
 #define dcbt_ro(p) \
 	do { \
 		__asm__ __volatile__ ("dcbt 0,%0" : : "r" (p)); \
-	} while(0)
+	} while (0)
 #define dcbt_rw(p) \
 	do { \
 		__asm__ __volatile__ ("dcbtst 0,%0" : : "r" (p)); \
-	} while(0)
+	} while (0)
 #define dcbi(p) dcbf(p)
 #ifdef CONFIG_PPC_E500MC
 #define dcbzl(p) \
@@ -167,7 +167,7 @@ static inline u64 mfatb(void)
 			dump_stack(); \
 			panic("assertion failure"); \
 		} \
-	} while(0)
+	} while (0)
 #else
 #define DPA_ASSERT(x)
 #endif
diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 44c5464..3833f4a 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -1501,7 +1501,7 @@ __init void fsl_usdpaa_init_early(void)
 	}
 	phys_start = __memblock_alloc_base(phys_size,
 					   largest_page_size(phys_size),
-					   MEMBLOCK_ALLOC_ACCESSIBLE );
+					   MEMBLOCK_ALLOC_ACCESSIBLE);
 	if (!phys_start) {
 		pr_err("Failed to reserve USDPAA region (sz:%llx)\n",
 		       phys_size);
diff --git a/drivers/staging/fsl_qbman/qbman_driver.c b/drivers/staging/fsl_qbman/qbman_driver.c
index 9150be7..a2904bd 100644
--- a/drivers/staging/fsl_qbman/qbman_driver.c
+++ b/drivers/staging/fsl_qbman/qbman_driver.c
@@ -49,7 +49,7 @@ static __init int qbman_init(void)
 			is_portal_available = 1;
 	}
 
-	if (!qman_have_ccsr() && is_portal_available ) {
+	if (!qman_have_ccsr() && is_portal_available) {
 		struct qman_fq fq = {
 				.fqid = 1
 		};
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 828335c..0574e75 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -251,13 +251,13 @@ static const struct qman_error_info_mdata error_mdata[] = {
  * "write the enable register" rather than "enable the write register"!
  */
 #define qm_err_isr_status_read(qm)	__qm_err_isr_read(qm, qm_isr_status)
-#define qm_err_isr_status_clear(qm, m)	__qm_err_isr_write(qm, qm_isr_status,m)
+#define qm_err_isr_status_clear(qm, m)	__qm_err_isr_write(qm, qm_isr_status, m)
 #define qm_err_isr_enable_read(qm)	__qm_err_isr_read(qm, qm_isr_enable)
-#define qm_err_isr_enable_write(qm, v)	__qm_err_isr_write(qm, qm_isr_enable,v)
+#define qm_err_isr_enable_write(qm, v)	__qm_err_isr_write(qm, qm_isr_enable, v)
 #define qm_err_isr_disable_read(qm)	__qm_err_isr_read(qm, qm_isr_disable)
-#define qm_err_isr_disable_write(qm, v)	__qm_err_isr_write(qm, qm_isr_disable,v)
-#define qm_err_isr_inhibit(qm)		__qm_err_isr_write(qm, qm_isr_inhibit,1)
-#define qm_err_isr_uninhibit(qm)	__qm_err_isr_write(qm, qm_isr_inhibit,0)
+#define qm_err_isr_disable_write(qm, v)	__qm_err_isr_write(qm, qm_isr_disable, v)
+#define qm_err_isr_inhibit(qm)		__qm_err_isr_write(qm, qm_isr_inhibit, 1)
+#define qm_err_isr_uninhibit(qm)	__qm_err_isr_write(qm, qm_isr_inhibit, 0)
 
 /*
  * TODO: unimplemented registers
@@ -525,11 +525,11 @@ static int qm_init_pfdr(struct qman *qm, u32 pfdr_start, u32 num)
 
 	DPA_ASSERT(pfdr_start && !(pfdr_start & 7) && !(num & 7) && num);
 	/* Make sure the command interface is 'idle' */
-	if(!MCR_rslt_idle(rslt))
+	if (!MCR_rslt_idle(rslt))
 		panic("QMAN_MCR isn't idle");
 
 	/* Write the MCR command params then the verb */
-	qm_out(MCP(0), pfdr_start );
+	qm_out(MCP(0), pfdr_start);
 	/* TODO: remove this - it's a workaround for a model bug that is
 	 * corrected in more recent versions. We use the workaround until
 	 * everyone has upgraded. */
@@ -539,7 +539,7 @@ static int qm_init_pfdr(struct qman *qm, u32 pfdr_start, u32 num)
 	/* Poll for the result */
 	do {
 		rslt = MCR_get_rslt(qm_in(MCR));
-	} while(!MCR_rslt_idle(rslt));
+	} while (!MCR_rslt_idle(rslt));
 	if (MCR_rslt_ok(rslt))
 		return 0;
 	if (MCR_rslt_eaccess(rslt))
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index f39c224..8320c13 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -703,7 +703,7 @@ static inline void fq_state_change(struct qman_portal *p, struct qman_fq *fq,
 				const struct qm_mr_entry *msg, u8 verb)
 {
 	FQLOCK(fq);
-	switch(verb) {
+	switch (verb) {
 	case QM_MR_VERB_FQRL:
 		DPA_ASSERT(fq_isset(fq, QMAN_FQ_STATE_ORL));
 		fq_clear(fq, QMAN_FQ_STATE_ORL);
diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index 454a388..86d412d 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -389,7 +389,7 @@ do { \
 	DPA_ASSERT(eqcr->busy); \
 	DPA_ASSERT(eqcr->cursor->orp == (eqcr->cursor->orp & 0x00ffffff)); \
 	DPA_ASSERT(eqcr->cursor->fqid == (eqcr->cursor->fqid & 0x00ffffff)); \
-} while(0)
+} while (0)
 
 static inline void qm_eqcr_pci_commit(struct qm_portal *portal, u8 myverb)
 {
diff --git a/drivers/staging/fsl_qbman/qman_test.c b/drivers/staging/fsl_qbman/qman_test.c
index ea39449..a6538ae0 100644
--- a/drivers/staging/fsl_qbman/qman_test.c
+++ b/drivers/staging/fsl_qbman/qman_test.c
@@ -38,7 +38,7 @@ MODULE_DESCRIPTION("Qman testing");
 static int test_init(void)
 {
 	int loop = 1;
-	while(loop--) {
+	while (loop--) {
 #ifdef CONFIG_FSL_QMAN_TEST_STASH_POTATO
 		qman_test_hotpotato();
 #endif
diff --git a/drivers/staging/fsl_qbman/qman_test.h b/drivers/staging/fsl_qbman/qman_test.h
index 082d9f2..251a5b9 100644
--- a/drivers/staging/fsl_qbman/qman_test.h
+++ b/drivers/staging/fsl_qbman/qman_test.h
@@ -62,9 +62,9 @@ static inline void __hexdump(unsigned long start, unsigned long end,
 				nl = 1;
 			} else {
 				nl = 0;
-				if(!(start & 1))
+				if (!(start & 1))
 					buf[pos++] = ' ';
-				if(!(start & 3))
+				if (!(start & 3))
 					buf[pos++] = ' ';
 			}
 		} while (start & 15);
diff --git a/drivers/staging/fsl_qbman/qman_test_hotpotato.c b/drivers/staging/fsl_qbman/qman_test_hotpotato.c
index deeb1c7..74d4a06 100644
--- a/drivers/staging/fsl_qbman/qman_test_hotpotato.c
+++ b/drivers/staging/fsl_qbman/qman_test_hotpotato.c
@@ -328,7 +328,7 @@ static inline u8 num_cachelines(u32 offset)
 #define STASH_DATA_CL \
 	num_cachelines(HP_NUM_WORDS * 4)
 #define STASH_CTX_CL \
-	num_cachelines(offsetof(struct hp_handler,fqid_rx))
+	num_cachelines(offsetof(struct hp_handler, fqid_rx))
 
 static void init_handler(void *__handler)
 {
diff --git a/include/linux/fsl_bman.h b/include/linux/fsl_bman.h
index 021a916..1c48f2d 100644
--- a/include/linux/fsl_bman.h
+++ b/include/linux/fsl_bman.h
@@ -200,9 +200,9 @@ struct bm_mc_result {
 #define BM_MCR_VERB_CMD_ERR_ECC		0x70
 #define BM_MCR_VERB_ACQUIRE_BUFCOUNT	BM_MCC_VERB_ACQUIRE_BUFCOUNT /* 0..8 */
 /* Determine the "availability state" of pool 'p' from a query result 'r' */
-#define BM_MCR_QUERY_AVAILABILITY(r,p) bman_depletion_get(&r->query.as.state,p)
+#define BM_MCR_QUERY_AVAILABILITY(r, p) bman_depletion_get(&r->query.as.state, p)
 /* Determine the "depletion state" of pool 'p' from a query result 'r' */
-#define BM_MCR_QUERY_DEPLETION(r,p) bman_depletion_get(&r->query.ds.state,p)
+#define BM_MCR_QUERY_DEPLETION(r, p) bman_depletion_get(&r->query.ds.state, p)
 
 /*******************************************************************/
 /* Managed (aka "shared" or "mux/demux") portal, high-level i/face */
-- 
1.7.10.4

