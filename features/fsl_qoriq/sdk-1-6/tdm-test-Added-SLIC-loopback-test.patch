From 12ae2a393a5bbf4ef3c39893a7f36c875ed3b5a2 Mon Sep 17 00:00:00 2001
From: Sandeep Singh <sandeep@freescale.com>
Date: Wed, 14 May 2014 17:24:31 -0400
Subject: [PATCH 1034/1089] tdm/test: Added SLIC loopback test.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Modified test to cover SLIC loopback also. This test can
now be run for internal as well as external loopback. To
choose which test (internal/external) is to be executed
can be controlled by module param "in_loopback". When
in_loopback=1 test is configured for internal loopback,
when in_loopback=0 test is configured for external(SLIC)
loopback.

Signed-off-by: Sandeep Singh <sandeep@freescale.com>
Change-Id: I1244e9930e00ea7e17cff28f28e351814cc0d249
Reviewed-on: http://git.am.freescale.net:8181/12414
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Poonam Aggrwal <poonam.aggrwal@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/tdm/test/tdm_loopback_test.c | 51 ++++++++++++++++++++++--------------
 1 file changed, 32 insertions(+), 19 deletions(-)

diff --git a/drivers/tdm/test/tdm_loopback_test.c b/drivers/tdm/test/tdm_loopback_test.c
index cb2a2d1..a07b22c 100644
--- a/drivers/tdm/test/tdm_loopback_test.c
+++ b/drivers/tdm/test/tdm_loopback_test.c
@@ -41,35 +41,43 @@
 #define DRV_NAME "tdm_test"
 
 
-#define POLL_COUNT 		38
+#define POLL_COUNT		15
 #define TDM_FRAME_LENGTH	NUM_SAMPLES_PER_FRAME
 #define TDM_E_OK		0
-#define BUF_COUNT		7
+#define BUF_COUNT		5
 
-#define DEBUG 0
+#define DEBUG			0
+
+static int in_loopback = 1;
+module_param(in_loopback, int, 0);
+MODULE_PARM_DESC(in_loopback, "Loopback mode, in_loopback=1(default) internal , in_loopback=0 external(SLIC)");
 
 static int poll_count = POLL_COUNT;
 module_param(poll_count, int, 0);
 
 static struct task_struct *tdm_thread_task;
 static struct tdm_driver test_tdmdev_driver;
-static struct tdm_port *tdmport;
 static int tdm_thread_state;
 
 static int tdm_check_data(unsigned short *tx_data, unsigned short *rx_data)
 {
 	int i, error = 0;
-	static int call_count;
+	int offset;
+
+	if (in_loopback)
+		offset = 0;
+	else
+		offset = 2;
 
-	for (i = 1; i < TDM_FRAME_LENGTH; i++) {
-		if (tx_data[i] != rx_data[i])
+	for (i = 1; i + offset < TDM_FRAME_LENGTH; i++) {
+		if (tx_data[i] != rx_data[i + offset])
 			error++;
 		else
 			continue;
 	}
-
-	pr_info("Iteration: %d\n", ++call_count);
 #if DEBUG
+	static int call_count;
+	pr_info("Iteration: %d\n", ++call_count);
 	pr_info("TX DATA:\n");
 	for (i = 0; i < TDM_FRAME_LENGTH; i++) {
 		pr_info("%5x ", tx_data[i]);
@@ -77,17 +85,17 @@ static int tdm_check_data(unsigned short *tx_data, unsigned short *rx_data)
 			pr_info("\n");
 	}
 	pr_info("RX DATA:\n");
-	for (i = 0; i < TDM_FRAME_LENGTH; i++) {
-		pr_info("%5x ", rx_data[i]);
+	for (i = 0; i < TDM_FRAME_LENGTH-offset; i++) {
+		pr_info("%5x ", rx_data[i+offset]);
 		if (i%20 == 19)
 			pr_info("\n");
 	}
-#endif
 	if (error)
 		pr_info("TX and RX buffer do NOT match. Err_count:"
 				"%d\n", error);
 	else
 		pr_info("TX and RX buffer MATCH\n");
+#endif
 
 	return error;
 }
@@ -132,6 +140,8 @@ static int tdm_thread(void *ptr)
 		pr_err("Failed to get memory for buffer");
 		return 0;
 	}
+	memset(tx_data[0], 0, buffer_size);
+	memset(rx_data[0], 0, buffer_size);
 	for (i = 0; i < BUF_COUNT-1; i++) {
 		tx_data[i+1] = tx_data[i] + TDM_FRAME_LENGTH;
 		rx_data[i+1] = rx_data[i] + TDM_FRAME_LENGTH;
@@ -139,10 +149,11 @@ static int tdm_thread(void *ptr)
 	while ((poll < poll_count) && !kthread_should_stop()) {
 
 		poll++;
-		while (tdm_ch_poll(h_channel1, 10) != TDM_E_OK)
+		ret = tdm_ch_poll(h_channel1, 10);
+		if (ret != TDM_E_OK)
 			continue;
 		for (i = 0; i < TDM_FRAME_LENGTH; i++)
-			tx_data[index][i] = j*TDM_FRAME_LENGTH+i;
+			tx_data[index][i] = j*TDM_FRAME_LENGTH + i;
 
 		ret = tdm_channel_write(h_port, h_channel1, tx_data[index],
 					size);
@@ -157,18 +168,20 @@ static int tdm_thread(void *ptr)
 		 * received data. Hence we compare tx_data[0] with rx data[6]
 		 * and so on
 		 */
-		if (j++ > BUF_COUNT)
+		if (++j >= BUF_COUNT)
 			error_count += tdm_check_data(tx_data[(index + 1)
 					%BUF_COUNT], rx_data[index]);
 		index++;
 		index = index%BUF_COUNT;
 
 	}
-	pr_info("\nTDM Loppback test completed.\n");
-	if (error_count == 0)
-		pr_info("TDM loopback test PASSED!\n");
+	pr_info("TDM Loppback test completed.\n");
+	if ((error_count == 0) && (j != 0))
+		pr_info("%s TDM loopback test PASSED!\n", in_loopback ?
+				"Internal" : "External");
 	else
-		pr_info("TDM loopback test FAILED!\n");
+		pr_info("%s TDM loopback test FAILED!\n", in_loopback ?
+				"Internal" : "External");
 
 	ret = tdm_channel_close(ch1_id, 1, h_port, h_channel1);
 	if (ret != TDM_E_OK) {
-- 
2.0.2

