From 35352757cbf531a9de19c39ea23b8465ad5c03b2 Mon Sep 17 00:00:00 2001
From: Yanjiang Jin <yanjiang.jin@windriver.com>
Date: Mon, 28 Jul 2014 17:26:16 +0800
Subject: [PATCH 02/52] Revert "preempt_rt gianfar replace preempt disable
 with lock to prevent call trace"

This reverts commit 62e34bf123147849956e30910195c3633d211fa1.

Nobody refers to gfar_priv_recycle_local, and gianfar_sysfs.c will be
removed in the following patch.

Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>

Conflicts:
	drivers/net/ethernet/freescale/gianfar.c
---
 drivers/net/ethernet/freescale/gianfar.c       |   25 ++++++++++++++++-------
 drivers/net/ethernet/freescale/gianfar.h       |    4 +-
 drivers/net/ethernet/freescale/gianfar_sysfs.c |    3 +-
 3 files changed, 20 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index a6ec162..253eb79 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -1183,8 +1183,8 @@ static void gfar_init_recycle(struct gfar_private *priv)
 		struct gfar_priv_recycle_local *local;
 		local = per_cpu_ptr(rec->local, cpu);
 		skb_queue_head_init(&local->recycle_q);
-		atomic_set(&local->recycle_cnt, 0);
-		atomic_set(&local->reuse_cnt, 0);
+		local->recycle_cnt = 0;
+		local->reuse_cnt = 0;
 	}
 
 	list_add(&priv->recycle_node, &gfar_recycle_queues);
@@ -3036,6 +3036,7 @@ static void gfar_recycle_skb(struct gfar_private *priv, struct sk_buff *skb)
 	struct gfar_priv_recycle *rec_target = priv->recycle_target;
 	struct sk_buff_head *recycle_q;
 	struct gfar_priv_recycle_local *local;
+	int cpu;
 
 	if (unlikely(!rec_target))
 		goto free;
@@ -3043,17 +3044,21 @@ static void gfar_recycle_skb(struct gfar_private *priv, struct sk_buff *skb)
 	if (unlikely(!skb_is_recycleable(skb, rec_target->buff_size)))
 		goto free;
 
-	local = this_cpu_ptr(rec_target->local);
+	cpu = get_cpu();
+	local = per_cpu_ptr(rec_target->local, cpu);
 
 	if (likely(skb_queue_len(&local->recycle_q) < GFAR_RECYCLE_MAX)) {
-		atomic_inc(&local->recycle_cnt);
+		local->recycle_cnt++;
+
 		skb_recycle(skb);
 
 		gfar_align_skb(skb);
 
-		skb_queue_head(&local->recycle_q, skb);
+		__skb_queue_head(&local->recycle_q, skb);
+		put_cpu();
 		return;
 	}
+	put_cpu();
 
 	recycle_q = &rec_target->recycle_q;
 
@@ -3294,16 +3299,20 @@ static struct sk_buff *gfar_new_skb(struct gfar_private *priv)
 	struct gfar_priv_recycle *rec = &priv->recycle;
 	struct gfar_priv_recycle_local *local;
 	struct sk_buff_head *recycle_q;
+	int cpu;
 
 	if (unlikely(!rec->local))
 		goto alloc;
 
-	local = this_cpu_ptr(rec->local);
-	skb = skb_dequeue(&local->recycle_q);
+	cpu = get_cpu();
+	local = per_cpu_ptr(rec->local, cpu);
+	skb = __skb_dequeue(&local->recycle_q);
 	if (likely(skb)) {
-		atomic_inc(&local->reuse_cnt);
+		local->reuse_cnt++;
+		put_cpu();
 		return skb;
 	}
+	put_cpu();
 
 	recycle_q = &rec->recycle_q;
 
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 4292ef0..16e8d0e 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1227,8 +1227,8 @@ enum gfar_errata {
 
 struct gfar_priv_recycle_local {
 	struct sk_buff_head recycle_q; /* percpu queue */
-	atomic_t recycle_cnt;
-	atomic_t reuse_cnt;
+	unsigned int recycle_cnt;
+	unsigned int reuse_cnt;
 };
 
 #define GFAR_RECYCLE_MAX	DEFAULT_TX_RING_SIZE
diff --git a/drivers/net/ethernet/freescale/gianfar_sysfs.c b/drivers/net/ethernet/freescale/gianfar_sysfs.c
index 6266b5c..dce8350 100644
--- a/drivers/net/ethernet/freescale/gianfar_sysfs.c
+++ b/drivers/net/ethernet/freescale/gianfar_sysfs.c
@@ -380,8 +380,7 @@ static ssize_t gfar_show_recycle(struct device *dev,
 
 		local = per_cpu_ptr(rec->local, cpu);
 		pr_info("local: CPU#%d: recycled skbs %d, reused skbs %d\n",
-			cpu, atomic_read(&local->recycle_cnt),
-			atomic_read(&local->reuse_cnt));
+			cpu, local->recycle_cnt, local->reuse_cnt);
 	}
 
 	pr_info("shared: recycled skbs %d, reused skbs %d\n",
-- 
1.7.5.4

