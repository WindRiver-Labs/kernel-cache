From 610791b1b5b2ec3ff81ccac258262b5e1b1c8bb4 Mon Sep 17 00:00:00 2001
From: yhe <yongli.he@windriver.com>
Date: Thu, 28 Jun 2012 11:15:18 +0800
Subject: [PATCH 12/23] gianfar: L2SRAM integration for bd allocation

This provides support for allocation of bd's in L2SRAM.
This option can be enabled via the config variable
CONFIG_GIANFAR_L2SRAM.

Extracted from vendor drop QorIQ-NONDPAA-SDK-V1-20110429_ltib.iso
linux-2.6.35-qoriq-gianfar-L2SRAM-integration-for-bd-alloc.patch.

Signed-off-by: Sandeep Gopalpet <sandeep.kumar@freescale.com>
Signed-off-by: Jiajun Wu <b06378@freescale.com>
Integrated-by: Xufeng Zhang <xufeng.zhang@windriver.com>
Integrated-by: Yongli He <yongli.he@windriver.com>
---
 arch/powerpc/boot/dts/p2020ds.dts        |    6 +++
 arch/powerpc/sysdev/fsl_85xx_l2ctlr.c    |    6 +--
 drivers/net/ethernet/freescale/Kconfig   |    7 ++++
 drivers/net/ethernet/freescale/gianfar.c |   61 +++++++++++++++++++++++++-----
 drivers/net/ethernet/freescale/gianfar.h |    5 +++
 5 files changed, 72 insertions(+), 13 deletions(-)

diff --git a/arch/powerpc/boot/dts/p2020ds.dts b/arch/powerpc/boot/dts/p2020ds.dts
index 9d076bc..40985ae 100644
--- a/arch/powerpc/boot/dts/p2020ds.dts
+++ b/arch/powerpc/boot/dts/p2020ds.dts
@@ -19,6 +19,12 @@
 		device_type = "memory";
 	};
 
+	l2sram@fff00000 {
+		device_type = "memory";
+		compatible = "fsl,p2020-l2-cache-controller";
+		reg = <0x0 0xfff00000 0 0x10000>;
+	};
+
 	board_lbc: lbc: localbus@ffe05000 {
 		ranges = <0x0 0x0 0x0 0xe8000000 0x08000000
 			  0x1 0x0 0x0 0xe0000000 0x08000000
diff --git a/arch/powerpc/sysdev/fsl_85xx_l2ctlr.c b/arch/powerpc/sysdev/fsl_85xx_l2ctlr.c
index cedabd0..2317164 100644
--- a/arch/powerpc/sysdev/fsl_85xx_l2ctlr.c
+++ b/arch/powerpc/sysdev/fsl_85xx_l2ctlr.c
@@ -41,7 +41,7 @@ static long get_cache_sram_size(void)
 	return val;
 }
 
-static long get_cache_sram_offset(void)
+static phys_addr_t   get_cache_sram_offset(void)
 {
 	unsigned long val;
 
@@ -94,14 +94,14 @@ static int __devinit mpc85xx_l2ctlr_of_probe(struct platform_device *dev)
 	l2cache_size = *prop;
 
 	sram_params.sram_size  = get_cache_sram_size();
-	if ((int)sram_params.sram_size <= 0) {
+	if (sram_params.sram_size <= 0) {
 		dev_err(&dev->dev,
 			"Entire L2 as cache, Aborting Cache-SRAM stuff\n");
 		return -EINVAL;
 	}
 
 	sram_params.sram_offset  = get_cache_sram_offset();
-	if ((int64_t)sram_params.sram_offset <= 0) {
+	if (sram_params.sram_offset <= 0) {
 		dev_err(&dev->dev,
 			"Entire L2 as cache, provide a valid sram offset\n");
 		return -EINVAL;
diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index 3574e14..d637e9c 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -62,6 +62,13 @@ config FSL_PQ_MDIO
 	---help---
 	  This driver supports the MDIO bus used by the gianfar and UCC drivers.
 
+config GIANFAR_L2SRAM
+	bool "Selecting L2sram bd allocation"
+	depends on (GIANFAR && FSL_SOC_BOOKE)
+	select FSL_85XX_CACHE_SRAM
+	help
+	  This option supports BD alloc in L2SRAM.
+
 config UCC_GETH
 	tristate "Freescale QE Gigabit Ethernet"
 	depends on QUICC_ENGINE
diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index e7bed53..b7f5142 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -231,13 +231,33 @@ err_rxalloc_fail:
 	return -ENOMEM;
 }
 
+unsigned long alloc_bds(struct gfar_private *priv, dma_addr_t *addr)
+{
+	unsigned long vaddr;
+	unsigned long region_size;
+
+#ifdef CONFIG_GIANFAR_L2SRAM
+	region_size = (sizeof(struct txbd8) + sizeof(struct sk_buff *)) *
+			priv->total_tx_ring_size +
+			(sizeof(struct rxbd8) + sizeof(struct sk_buff *)) *
+			priv->total_rx_ring_size;
+	vaddr =  (unsigned long) mpc85xx_cache_sram_alloc(region_size,
+					(phys_addr_t *)addr, ALIGNMENT);
+#else
+	region_size = sizeof(struct txbd8) * priv->total_tx_ring_size +
+			sizeof(struct rxbd8) * priv->total_rx_ring_size;
+	vaddr = (unsigned long) dma_alloc_coherent(&priv->ofdev->dev,
+				region_size, addr, GFP_KERNEL);
+#endif
+	return vaddr;
+}
+
 static int gfar_alloc_skb_resources(struct net_device *ndev)
 {
 	void *vaddr;
 	dma_addr_t addr;
 	int i, j, k;
 	struct gfar_private *priv = netdev_priv(ndev);
-	struct device *dev = &priv->ofdev->dev;
 	struct gfar_priv_tx_q *tx_queue = NULL;
 	struct gfar_priv_rx_q *rx_queue = NULL;
 
@@ -250,10 +270,8 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 		priv->total_rx_ring_size += priv->rx_queue[i]->rx_ring_size;
 
 	/* Allocate memory for the buffer descriptors */
-	vaddr = dma_alloc_coherent(dev,
-			sizeof(struct txbd8) * priv->total_tx_ring_size +
-			sizeof(struct rxbd8) * priv->total_rx_ring_size,
-			&addr, GFP_KERNEL);
+	vaddr = alloc_bds(priv, &addr);
+	
 	if (!vaddr) {
 		netif_err(priv, ifup, ndev,
 			  "Could not allocate buffer descriptors!\n");
@@ -283,8 +301,13 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 	/* Setup the skbuff rings */
 	for (i = 0; i < priv->num_tx_queues; i++) {
 		tx_queue = priv->tx_queue[i];
+#ifdef CONFIG_GIANFAR_L2SRAM
+		tx_queue->tx_skbuff = (struct sk_buff **) vaddr;
+		vaddr += sizeof(struct sk_buff **) * tx_queue->tx_ring_size;
+#else		
 		tx_queue->tx_skbuff = kmalloc(sizeof(*tx_queue->tx_skbuff) *
 				  tx_queue->tx_ring_size, GFP_KERNEL);
+#endif
 		if (!tx_queue->tx_skbuff) {
 			netif_err(priv, ifup, ndev,
 				  "Could not allocate tx_skbuff\n");
@@ -297,8 +320,13 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 
 	for (i = 0; i < priv->num_rx_queues; i++) {
 		rx_queue = priv->rx_queue[i];
+#ifdef CONFIG_GIANFAR_L2SRAM
+		rx_queue->rx_skbuff = (struct sk_buff **) vaddr;
+		vaddr += sizeof(struct sk_buff **) * rx_queue->rx_ring_size;
+#else
 		rx_queue->rx_skbuff = kmalloc(sizeof(*rx_queue->rx_skbuff) *
 				  rx_queue->rx_ring_size, GFP_KERNEL);
+#endif
 
 		if (!rx_queue->rx_skbuff) {
 			netif_err(priv, ifup, ndev,
@@ -1633,6 +1661,19 @@ static void free_grp_irqs(struct gfar_priv_grp *grp)
 	free_irq(grp->interruptReceive, grp);
 }
 
+void free_bds(struct gfar_private *priv)
+{
+#ifdef CONFIG_GIANFAR_L2SRAM
+	mpc85xx_cache_sram_free(priv->tx_queue[0]->tx_bd_base);
+#else
+	dma_free_coherent(&priv->ofdev->dev,
+			sizeof(struct txbd8) * priv->total_tx_ring_size +
+			sizeof(struct rxbd8) * priv->total_rx_ring_size,
+			priv->tx_queue[0]->tx_bd_base,
+			priv->tx_queue[0]->tx_bd_dma_base);
+#endif
+}
+
 void stop_gfar(struct net_device *dev)
 {
 	struct gfar_private *priv = netdev_priv(dev);
@@ -1691,7 +1732,9 @@ static void free_skb_tx_queue(struct gfar_priv_tx_q *tx_queue)
 		dev_kfree_skb_any(tx_queue->tx_skbuff[i]);
 		tx_queue->tx_skbuff[i] = NULL;
 	}
+#ifndef CONFIG_GIANFAR_L2SRAM
 	kfree(tx_queue->tx_skbuff);
+#endif
 }
 
 static void free_skb_rx_queue(struct gfar_priv_rx_q *rx_queue)
@@ -1714,7 +1757,9 @@ static void free_skb_rx_queue(struct gfar_priv_rx_q *rx_queue)
 		rxbdp->bufPtr = 0;
 		rxbdp++;
 	}
+#ifndef CONFIG_GIANFAR_L2SRAM
 	kfree(rx_queue->rx_skbuff);
+#endif
 }
 
 /* If there are any tx skbs or rx skbs still around, free them.
@@ -1741,11 +1786,7 @@ static void free_skb_resources(struct gfar_private *priv)
 			free_skb_rx_queue(rx_queue);
 	}
 
-	dma_free_coherent(&priv->ofdev->dev,
-			sizeof(struct txbd8) * priv->total_tx_ring_size +
-			sizeof(struct rxbd8) * priv->total_rx_ring_size,
-			priv->tx_queue[0]->tx_bd_base,
-			priv->tx_queue[0]->tx_bd_dma_base);
+	free_bds(priv);
 	skb_queue_purge(&priv->rx_recycle);
 }
 
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 4c9f8d4..255f6ee 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -47,6 +47,11 @@
 #include <linux/workqueue.h>
 #include <linux/ethtool.h>
 
+#ifdef CONFIG_GIANFAR_L2SRAM
+#include <asm/fsl_85xx_cache_sram.h>
+#define ALIGNMENT 0x20
+#endif
+
 struct ethtool_flow_spec_container {
 	struct ethtool_rx_flow_spec fs;
 	struct list_head list;
-- 
1.7.9.7

