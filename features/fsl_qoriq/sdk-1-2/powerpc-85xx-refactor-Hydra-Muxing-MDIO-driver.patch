From d6ec569553dd43b82b8603c20bfe23aaaa8af406 Mon Sep 17 00:00:00 2001
From: Timur Tabi <timur@freescale.com>
Date: Fri, 13 Apr 2012 15:00:24 -0500
Subject: [PATCH 051/121] powerpc/85xx: refactor Hydra Muxing MDIO driver

Refactor hydra_mdio.c, which is a driver that muxes the MDIO bus on Hydra
(P3041DS and P5020DS) boards.

1) Remove extraneous include files.
2) Rename PIXIS_BRDCFG1_OFFSET to BRDCFG1.
3) Embed the irqs[] array into hydra_mdio, instead of a separate kmalloc.
4) Memory map the entire PIXIS block, not just the BRDCFG1 register.
5) Define a global mutex to protect the EMI register, and use it for
   all MDIO functions.
6) Make functions __init and/or 'static' as appropriate.
7) Don't ignore any error return code from the real bus' reset function.
8) Find the PIXIS node using fsl,fpga-ngpixis instead of the board-specific
   compatible node
9) Rename some variables (ofdev -> pdev, err -> ret, etc)
10) Streamline the parsing of the device tree
11) Display better error messages
12) Use only the node name, and not node@muxvalue, as the bus ID.  The
    previous string was too long and overwrote memory.
13) Clean up error exit handling
14) The code is not a module that can be unloaded, so don't define an 'exit'
    function.

Return an actual error code for the _reset function, instead

Signed-off-by: Timur Tabi <timur@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image. Include <linux/module.h>]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/platforms/85xx/hydra_mdio.c |  261 +++++++++++++-----------------
 1 file changed, 113 insertions(+), 148 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/hydra_mdio.c b/arch/powerpc/platforms/85xx/hydra_mdio.c
index 51b06f7..b65acd5 100644
--- a/arch/powerpc/platforms/85xx/hydra_mdio.c
+++ b/arch/powerpc/platforms/85xx/hydra_mdio.c
@@ -1,256 +1,226 @@
 /*
- * Provides PIXIS based muxing for the MDIO buses on the hydra boards
+ * Provides PIXIS-based MDIO muxing the Hydra and Super Hydra boards
  *
- * Hydra is the code for the P3041 DS & P5020 DS boards
- *
- * Copyright (c) 2010 Freescale Semiconductor, Inc.
+ * Copyright 2010-2012 Freescale Semiconductor, Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  *
+ * Hydra is the codename for the P3041 DS & P5020 DS boards
+ * Super Hydra is the codename for the P5040 DS boards
  */
 
-#include <linux/kernel.h>
-#include <linux/string.h>
 #include <linux/errno.h>
-#include <linux/unistd.h>
 #include <linux/slab.h>
-#include <linux/interrupt.h>
 #include <linux/init.h>
-#include <linux/delay.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/spinlock.h>
-#include <linux/mm.h>
-#include <linux/module.h>
 #include <linux/platform_device.h>
-#include <linux/crc32.h>
 #include <linux/mii.h>
 #include <linux/phy.h>
 #include <linux/of.h>
 #include <linux/of_mdio.h>
 #include <linux/of_platform.h>
-
+#include <linux/module.h>
 #include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/uaccess.h>
 
-
-#define PIXIS_BRDCFG1_OFFSET	0x9
+#define BRDCFG1	0x9
 #define BRDCFG1_EMI1_SEL_MASK	0x70
 #define BRDCFG1_EMI1_EN		0x08
 
-
 struct hydra_mdio {
 	struct mii_bus *real_bus;
-	u8 *pixis_brdcfg1;
+	int irqs[PHY_MAX_ADDR];
+	u8 *pixis;
 	u8 value;
 	u8 mask;
 };
 
+/* Mutex for the EMI register in PIXIS */
+static DEFINE_MUTEX(emi_lock);
+
 /* Set the BRDCFG1 pixis register, and then write the MDIO regs */
-int hydra_mdio_write(struct mii_bus *bus, int port_addr, int dev_addr,
+static int hydra_mdio_write(struct mii_bus *bus, int port_addr, int dev_addr,
 			int regnum, u16 value)
 {
 	struct hydra_mdio *priv = bus->priv;
+	struct mii_bus *real = priv->real_bus;
+	int ret;
+
+	mutex_lock(&emi_lock);
 
 	/* Write BRDCFG1 to select this bus */
-	clrsetbits_8(priv->pixis_brdcfg1, priv->mask, priv->value);
+	clrsetbits_8(priv->pixis + BRDCFG1, priv->mask, priv->value);
 
 	/* Write through to the attached MDIO bus */
-	return priv->real_bus->write(priv->real_bus, port_addr, dev_addr,
-					regnum, value);
+	ret = real->write(real, port_addr, dev_addr, regnum, value);
+
+	mutex_unlock(&emi_lock);
+
+	return ret;
 }
 
 /* Set the BRDCFG1 pixis register, and then read from the MDIO bus */
-int hydra_mdio_read(struct mii_bus *bus, int port_addr, int dev_addr,
+static int hydra_mdio_read(struct mii_bus *bus, int port_addr, int dev_addr,
 			int regnum)
 {
 	struct hydra_mdio *priv = bus->priv;
+	struct mii_bus *real = priv->real_bus;
+	int ret;
 
-	/* Write BRDCFG1 to select this bus */
-	clrsetbits_8(priv->pixis_brdcfg1, priv->mask, priv->value);
+	mutex_lock(&emi_lock);
 
-	return priv->real_bus->read(priv->real_bus, port_addr, dev_addr,
-					regnum);
-}
+	clrsetbits_8(priv->pixis + BRDCFG1, priv->mask, priv->value);
+
+	ret = real->read(real, port_addr, dev_addr, regnum);
 
+	mutex_unlock(&emi_lock);
+
+	return ret;
+}
 
 /* Reset the MIIM registers, and wait for the bus to free */
 static int hydra_mdio_reset(struct mii_bus *bus)
 {
 	struct hydra_mdio *priv = bus->priv;
+	struct mii_bus *real = priv->real_bus;
+	int ret;
 
-	mutex_lock(&bus->mdio_lock);
-	priv->real_bus->reset(priv->real_bus);
-	mutex_unlock(&bus->mdio_lock);
+	mutex_lock(&emi_lock);
 
-	return 0;
-}
+	clrsetbits_8(priv->pixis + BRDCFG1, priv->mask, priv->value);
 
-static struct of_device_id hydra_pixis_match[] = {
-	{
-		.compatible = "fsl,p3041ds-fpga",
-	},
-	{
-		.compatible = "fsl,p5020ds-fpga",
-	},
-	{}
-};
+	ret = real->reset(real);
+
+	mutex_unlock(&emi_lock);
+
+	return ret;
+}
 
-static int hydra_mdio_probe(struct platform_device *ofdev)
+static int __devinit hydra_mdio_probe(struct platform_device *pdev)
 {
-	struct device_node *np = ofdev->dev.of_node;
+	struct device_node *np = pdev->dev.of_node;
 	struct mii_bus *new_bus;
 	struct hydra_mdio *priv;
-	struct device_node *mdio, *pixis;
-	struct platform_device *ofmdiodev;
-	const u32 *addr;
-	const u32 *val;
-	u64 reg;
-	int i;
-	int err = 0;
+	struct device_node *mdio_np, *pixis_np;
+	struct platform_device *mdiodev;
+	const u32 *iprop;
+	int ret;
 
+	/* TODO: Replace with mdiobus_alloc_size() upstream */
 	new_bus = mdiobus_alloc();
-	if (NULL == new_bus)
+	if (!new_bus)
 		return -ENOMEM;
 
-	new_bus->name = "Freescale Hydra MDIO Bus",
-	new_bus->read = &hydra_mdio_read,
-	new_bus->write = &hydra_mdio_write,
-	new_bus->reset = &hydra_mdio_reset,
+	new_bus->name = "Freescale Hydra MDIO Bus";
+	new_bus->read = hydra_mdio_read;
+	new_bus->write = hydra_mdio_write;
+	new_bus->reset = hydra_mdio_reset;
+	strncpy(new_bus->id, np->name, MII_BUS_ID_SIZE);
 
-	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	priv = kzalloc(sizeof(struct hydra_mdio), GFP_KERNEL);
 	if (!priv) {
-		err = -ENOMEM;
+		ret = -ENOMEM;
 		goto err_priv_alloc;
 	}
-
 	new_bus->priv = priv;
+	new_bus->irq = priv->irqs; /* Initialized by of_mdiobus_register() */
+	new_bus->parent = &pdev->dev;
 
 	/* Get the parent (real) mdio bus */
-	mdio = of_parse_phandle(np, "fsl,mdio-handle", 0);
-
-	if (mdio == NULL) {
-		printk(KERN_ERR "Could not find real MDIO bus for %s\n",
-			new_bus->id);
-		err = -ENODEV;
+	mdio_np = of_parse_phandle(np, "fsl,mdio-handle", 0);
+	if (!mdio_np) {
+		dev_err(&pdev->dev, "could not find real MDIO bus for %s\n",
+		       np->full_name);
+		ret = -ENODEV;
 		goto err_no_mdio_node;
 	}
 
-	ofmdiodev = of_find_device_by_node(mdio);
-
-	if (!ofmdiodev) {
-		printk(KERN_ERR "No of_device for MDIO node %s\n",
-		       mdio->full_name);
-		err = -ENODEV;
+	mdiodev = of_find_device_by_node(mdio_np);
+	if (!mdiodev) {
+		dev_err(&pdev->dev, "could not find device for MDIO node %s\n",
+		       mdio_np->full_name);
+		ret = -ENODEV;
 		goto err_no_mdio_dev;
 	}
 
-	of_node_put(mdio);
-
-	priv->real_bus = dev_get_drvdata(&ofmdiodev->dev);
-
+	priv->real_bus = dev_get_drvdata(&mdiodev->dev);
 	if (!priv->real_bus) {
-		printk(KERN_ERR "The MDIO bus has no ofdev!\n");
-		err = -ENODEV;
-		goto err_no_ofdev;
+		dev_err(&pdev->dev, "MDIO node %s has not been probed\n",
+			mdio_np->full_name);
+		ret = -ENODEV;
+		goto err_no_pdev;
 	}
 
-	new_bus->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
-
-	if (NULL == new_bus->irq) {
-		err = -ENOMEM;
-		goto err_irq_alloc;
-	}
-
-	for (i = 0; i < PHY_MAX_ADDR; i++)
-		new_bus->irq[i] = PHY_POLL;
-
-	new_bus->parent = &ofdev->dev;
-	dev_set_drvdata(&ofdev->dev, new_bus);
-
 	/* Find the pixis node */
-	pixis = of_find_matching_node(NULL, hydra_pixis_match);
-	if (!pixis) {
-		err = -ENODEV;
+	pixis_np = of_find_compatible_node(NULL, NULL, "fsl,fpga-ngpixis");
+	if (!pixis_np) {
+		dev_err(&pdev->dev, "could not find PIXIS node\n");
+		ret = -ENODEV;
 		goto err_no_pixis;
 	}
 
-	addr = of_get_address(pixis, 0, NULL, NULL);
-	if (!addr) {
-		err = -ENODEV;
-		goto err_no_pixis_addr;
+	priv->pixis = of_iomap(pixis_np, 0);
+	if (!priv->pixis) {
+		dev_err(&pdev->dev, "could not map PIXIS node %s\n",
+			pixis_np->full_name);
+		ret = -ENOMEM;
+		goto err_pixis_iomap;
 	}
 
-	reg = of_translate_address(pixis, addr);
-	of_node_put(pixis);
-
-	/* Map only the register we need to select the mdio bus (BRDCFG1) */
-	priv->pixis_brdcfg1 = ioremap(reg + PIXIS_BRDCFG1_OFFSET,
-				      sizeof(*priv->pixis_brdcfg1));
-	if (!priv->pixis_brdcfg1) {
-		err = -ENOMEM;
-		goto err_ioremap;
-	}
-
-	val = of_get_property(np, "fsl,hydra-mdio-muxval", NULL);
-	if (!val) {
-		printk(KERN_ERR "No mux value found for %s\n", np->full_name);
-		err = -ENODEV;
+	iprop = of_get_property(np, "fsl,hydra-mdio-muxval", NULL);
+	if (!iprop) {
+		dev_err(&pdev->dev, "no MUX value found for %s\n",
+			np->full_name);
+		ret = -ENODEV;
 		goto err_get_muxval;
 	}
 
 	priv->mask = BRDCFG1_EMI1_SEL_MASK;
-	priv->value = BRDCFG1_EMI1_EN | *val;
-
-	sprintf(new_bus->id, "%s@%d", np->name, *val);
-
-	err = of_mdiobus_register(new_bus, np);
+	priv->value = BRDCFG1_EMI1_EN | be32_to_cpup(iprop);
 
-	if (err) {
-		printk(KERN_ERR "%s: Cannot register as MDIO bus\n",
-				new_bus->name);
+	/* Finally, register our new bus */
+	ret = of_mdiobus_register(new_bus, np);
+	if (ret) {
+		dev_err(&pdev->dev, "cannot register MDIO bus %s (ret = %i)\n",
+		       new_bus->name, ret);
 		goto err_registration;
 	}
 
+	dev_set_drvdata(&pdev->dev, new_bus);
+
+	of_node_put(pixis_np);
+	of_node_put(mdio_np);
+
 	return 0;
 
+err_registration:
 err_get_muxval:
-	iounmap(priv->pixis_brdcfg1);
-err_ioremap:
-err_no_pixis_addr:
-	of_node_put(pixis);
+	iounmap(priv->pixis);
+err_pixis_iomap:
+	of_node_put(pixis_np);
 err_no_pixis:
-err_registration:
-	kfree(new_bus->irq);
-err_irq_alloc:
-err_no_ofdev:
+err_no_pdev:
 err_no_mdio_dev:
+	of_node_put(mdio_np);
 err_no_mdio_node:
 	kfree(priv);
 err_priv_alloc:
 	mdiobus_free(new_bus);
 
-	return err;
+	return ret;
 }
 
-
-static int hydra_mdio_remove(struct platform_device *ofdev)
+static int __devexit hydra_mdio_remove(struct platform_device *pdev)
 {
-	struct device *device = &ofdev->dev;
+	struct device *device = &pdev->dev;
 	struct mii_bus *bus = dev_get_drvdata(device);
 	struct hydra_mdio *priv = bus->priv;
 
 	mdiobus_unregister(bus);
-
 	dev_set_drvdata(device, NULL);
 
-	iounmap(priv->pixis_brdcfg1);
-	kfree(bus->irq);
+	iounmap(priv->pixis);
 	kfree(bus->priv);
 
 	mdiobus_free(bus);
@@ -264,6 +234,7 @@ static struct of_device_id hydra_mdio_match[] = {
 	},
 	{}
 };
+MODULE_DEVICE_TABLE(of, mdio_match);
 
 static struct platform_driver hydra_mdio_driver = {
 	.driver = {
@@ -274,14 +245,8 @@ static struct platform_driver hydra_mdio_driver = {
 	.remove = hydra_mdio_remove,
 };
 
-int __init hydra_mdio_init(void)
+static int __init hydra_mdio_init(void)
 {
 	return platform_driver_register(&hydra_mdio_driver);
 }
-
-void hydra_mdio_exit(void)
-{
-	platform_driver_unregister(&hydra_mdio_driver);
-}
 subsys_initcall_sync(hydra_mdio_init);
-module_exit(hydra_mdio_exit);
-- 
1.7.9.7

