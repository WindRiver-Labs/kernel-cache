From 6b7651088a4b39ae798694726df45838d5a7e2b1 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 14 Mar 2012 04:49:48 +0000
Subject: [PATCH 083/121] fsl_usdpaa: auto-align mmap() requests

This implements the file_operations::get_unmapped_area() handler to
ensure that mmap() requests don't need to propose aligned virtual
addresses with MAP_FIXED - a virtual address with the appropriate
alignment will be found automatically.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/misc/fsl_usdpaa.c |   65 ++++++++++++++++++++++++++++++++-------------
 1 file changed, 46 insertions(+), 19 deletions(-)

diff --git a/drivers/misc/fsl_usdpaa.c b/drivers/misc/fsl_usdpaa.c
index 34848d9..3bea844 100644
--- a/drivers/misc/fsl_usdpaa.c
+++ b/drivers/misc/fsl_usdpaa.c
@@ -38,27 +38,53 @@ static int usdpaa_open(struct inode *inode, struct file *filp)
 
 static int usdpaa_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	size_t size = vma->vm_end - vma->vm_start;
-	if (vma->vm_pgoff) {
+	if (remap_pfn_range(vma, vma->vm_start,	usdpaa_pfn_start,
+			    vma->vm_end - vma->vm_start, vma->vm_page_prot))
+		return -EAGAIN;
+	return 0;
+}
+
+/* Return the nearest rounded-up address >= 'addr' that is 'sz'-aligned. 'sz'
+ * must be a power of 2, but both 'addr' and 'sz' can be expressions. */
+#define USDPAA_MEM_ROUNDUP(addr, sz) \
+	({ \
+		unsigned long foo_align = (sz) - 1; \
+		((addr) + foo_align) & ~foo_align; \
+	})
+/* Searching for a size-aligned virtual address range starting from 'addr' */
+static unsigned long usdpaa_get_unmapped_area(struct file *file,
+					      unsigned long addr,
+					      unsigned long len,
+					      unsigned long pgoff,
+					      unsigned long flags)
+{
+	struct mm_struct *mm = current->mm;
+	struct vm_area_struct *vma;
+
+	if (pgoff) {
 		pr_err("%s: non-zero mmap page-offset 0x%lx is invalid\n",
-			__func__, vma->vm_pgoff);
+			__func__, pgoff);
 		return -EINVAL;
 	}
-	if (size != usdpaa_phys_size) {
-		pr_err("%s: mmap size 0x%llx doesn't match region (0x%llx)\n",
-			__func__, (unsigned long long)size, usdpaa_phys_size);
+	/* Only support mappings of the right size */
+	if (len != usdpaa_phys_size) {
+		pr_err("%s: mmap size 0x%lx doesn't match region (0x%llx)\n",
+			__func__, len, usdpaa_phys_size);
 		return -EINVAL;
 	}
-	if (vma->vm_start & (usdpaa_phys_size - 1)) {
-		pr_err("%s: un-aligned mapping %llx:%llx -> %lx\n",
-			__func__, usdpaa_phys_start, usdpaa_phys_size,
-			vma->vm_start);
-		return -EINVAL;
+	addr = USDPAA_MEM_ROUNDUP(addr, len);
+	vma = find_vma(mm, addr);
+	/* Keep searching until we reach the end of currently-used virtual
+	 * address-space or we find a big enough gap. */
+	while (vma) {
+		if ((addr + len) < vma->vm_start)
+			return addr;
+		addr = USDPAA_MEM_ROUNDUP(vma->vm_end, len);
+		vma = vma->vm_next;
 	}
-	if (remap_pfn_range(vma, vma->vm_start,	usdpaa_pfn_start, size,
-				vma->vm_page_prot))
-		return -EAGAIN;
-	return 0;
+	if ((TASK_SIZE - len) < addr)
+		return -ENOMEM;
+	return addr;
 }
 
 static long usdpaa_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
@@ -73,10 +99,11 @@ static long usdpaa_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
 }
 
 static const struct file_operations usdpaa_fops = {
-	.open		= usdpaa_open,
-	.mmap		= usdpaa_mmap,
-	.unlocked_ioctl = usdpaa_ioctl,
-	.compat_ioctl = usdpaa_ioctl
+	.open		   = usdpaa_open,
+	.mmap		   = usdpaa_mmap,
+	.get_unmapped_area = usdpaa_get_unmapped_area,
+	.unlocked_ioctl    = usdpaa_ioctl,
+	.compat_ioctl      = usdpaa_ioctl
 };
 
 static struct miscdevice usdpaa_miscdev = {
-- 
1.7.9.7

