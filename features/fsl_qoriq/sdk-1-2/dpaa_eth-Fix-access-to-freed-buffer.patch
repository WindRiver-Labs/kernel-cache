From 74f228822319fe3d89b7f3f804b601b8a03c2ce0 Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Thu, 29 Mar 2012 18:49:30 +0000
Subject: [PATCH 105/128] dpaa_eth: Fix access to freed buffer

The skb back reference pointer location may be freed by
_dpa_cleanup_tx_fd() function. The code however is trying to
read the skb pointer after this function is called.

Make the cleanup function read the skb back pointer and return it
to caller.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   43 ++++++++++++-------------
 1 file changed, 21 insertions(+), 22 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 66b4d6a..d8683b6 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -622,20 +622,27 @@ dpa_fd_release(const struct net_device *net_dev, const struct qm_fd *fd)
  *
  * This function may be called on error paths in the Tx function, so guard
  * against cases when not all fd relevant fields were filled in.
+ *
+ * Return the skb backpointer, since for S/G frames the buffer containing it
+ * gets freed here.
  */
-static void _dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
+static struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 			       const struct qm_fd *fd)
 {
 	dma_addr_t addr = qm_fd_addr(fd);
 	dma_addr_t sg_addr;
 	struct dpa_bp *bp = priv->dpa_bp;
+	struct sk_buff **skbh;
+	struct sk_buff *skb = NULL;
 
 	BUG_ON(!fd);
 
 	if (unlikely(!addr))
-		return;
+		return skb;
 
-	if (fd->format == qm_fd_contig)
+	skbh = (struct sk_buff **)phys_to_virt(addr);
+
+	if (fd->format == qm_fd_contig) {
 		/* For contiguous frames, just unmap data buffer;
 		 * mapping direction depends on whether the frame was
 		 * meant to be recycled or not */
@@ -645,7 +652,9 @@ static void _dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 		else
 			dma_unmap_single(bp->dev, addr, bp->size,
 					 DMA_TO_DEVICE);
-	else {
+		/* Retrieve the skb backpointer */
+		skb = *skbh;
+	} else {
 		/* For s/g, we need to unmap both the SGT buffer and the
 		 * data buffer, and also free the SGT buffer */
 		struct qm_sg_entry *sg_entry;
@@ -661,9 +670,14 @@ static void _dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 		if (likely(sg_addr))
 			dma_unmap_single(bp->dev, sg_addr, bp->size,
 					 DMA_TO_DEVICE);
+		/* Retrieve the skb backpointer */
+		skb = *skbh;
+
 		/* Free first buffer (which was allocated on Tx) */
 		kfree(vaddr);
 	}
+
+	return skb;
 }
 
 /* net_device */
@@ -875,8 +889,6 @@ static void _dpa_tx_error(struct net_device		*net_dev,
 			  const struct qm_fd		*fd)
 {
 	struct sk_buff *skb;
-	struct sk_buff **skbh;
-	dma_addr_t addr = qm_fd_addr(fd);
 
 	if (netif_msg_hw(priv) && net_ratelimit())
 		cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
@@ -884,11 +896,7 @@ static void _dpa_tx_error(struct net_device		*net_dev,
 
 	percpu_priv->stats.tx_errors++;
 
-	skbh = (struct sk_buff **)phys_to_virt(addr);
-
-	_dpa_cleanup_tx_fd(priv, fd);
-
-	skb = *skbh;
+	skb = _dpa_cleanup_tx_fd(priv, fd);
 	dev_kfree_skb(skb);
 }
 
@@ -1035,9 +1043,7 @@ static void __hot _dpa_tx(struct net_device		*net_dev,
 			  struct dpa_percpu_priv_s	*percpu_priv,
 			  const struct qm_fd		*fd)
 {
-	struct sk_buff **skbh;
 	struct sk_buff	*skb;
-	dma_addr_t addr = qm_fd_addr(fd);
 
 	/* This might not perfectly reflect the reality, if the core dequeueing
 	 * the Tx confirmation is different from the one that did the enqueue,
@@ -1052,15 +1058,12 @@ static void __hot _dpa_tx(struct net_device		*net_dev,
 		percpu_priv->stats.tx_errors++;
 	}
 
-	skbh = (struct sk_buff **)phys_to_virt(addr);
+	skb = _dpa_cleanup_tx_fd(priv, fd);
 
 #ifdef CONFIG_FSL_DPA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_tx_en_ioctl)
 		dpa_ptp_store_txstamp(net_dev, skb, fd);
 #endif
-	_dpa_cleanup_tx_fd(priv, fd);
-
-	skb = *skbh;
 	dev_kfree_skb(skb);
 }
 
@@ -1731,7 +1734,6 @@ static void egress_ern(struct qman_portal	*portal,
 	struct net_device	*net_dev;
 	const struct dpa_priv_s	*priv;
 	struct sk_buff *skb;
-	struct sk_buff **skbh;
 	struct dpa_percpu_priv_s	*percpu_priv;
 	struct qm_fd fd = msg->ern.fd;
 
@@ -1752,10 +1754,7 @@ static void egress_ern(struct qman_portal	*portal,
 		return;
 	}
 
-	skbh = (struct sk_buff **)phys_to_virt(qm_fd_addr(&fd));
-	_dpa_cleanup_tx_fd(priv, &fd);
-
-	skb = *skbh;
+	skb = _dpa_cleanup_tx_fd(priv, &fd);
 	dev_kfree_skb_any(skb);
 }
 
-- 
1.7.9.7

