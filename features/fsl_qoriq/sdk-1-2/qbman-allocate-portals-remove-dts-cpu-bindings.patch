From 37c7b078fc2373b5371d3504764e1c10c550a8db Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 14 Mar 2012 04:49:42 +0000
Subject: [PATCH 076/121] qbman: allocate portals, remove dts cpu-bindings.

This removes portal->cpu and portal->{kernel/usdpaa} associations from
the device trees, and changes the qbman driver initialisation model.
Portals are now "allocated" for initialisation and dynamically bound
to the required cpus. The default setup is to try to allocate a portal
for each cpu, and if that fails (there are fewer portals than cpus)
one of the cpus will share its portal with those cpus that don't have
one.

Bootargs "qportals" and "bportals" can be used to override the default
setup, however. As an example of the syntax;
       bportals=s0,1-3,s4
means that cpus 1,2,3 get their own "unshared" portals, cpus 0 and 4
get "shared" portals, and any other cpus will share from one of the
portals assigned to cpus 0 or 4, selected in a round-robin fashion.
(In this example, cpu 5 would share cpu 0's portal, cpu 6 would share
cpu4's portal, and cpu 7 would share cpu 0's portal.) If no cpus are
specified for sharing and sharing is required, one will be chosen by
the driver. If there are cpus are specified for sharing but sharing is
not required, the portals will be configured without sharing support
(this uses thinner locks).

Note that one consequence of this change is that we can't abuse the
device-tree to limit certain portals to certain pool channels for
application configuration, because we no longer know which portals will
be used for what. As such, the "fsl,qman-pool-channels" links are removed,
and the qman portal driver searches for the available pool channels
instead.

This also updates the PAMU driver to preconfigure portal stashing LIODNs
for L3 - the previous assumption of L1 assumed a cpu-assignment, which is
no longer the case.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image. Remove the mods for
the specific board's dts]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi  |   72 ++++
 arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi  |   51 +++
 arch/powerpc/boot/dts/p4080ds-usdpaa.dts        |  179 ++------
 arch/powerpc/boot/dts/p4080ds.dts               |  125 +-----
 arch/powerpc/sysdev/fsl_pamu.c                  |    2 +-
 drivers/staging/fsl_qbman/Makefile              |    5 +-
 drivers/staging/fsl_qbman/bman_driver.c         |  496 ++++++++++-------------
 drivers/staging/fsl_qbman/bman_high.c           |    8 +-
 drivers/staging/fsl_qbman/bman_private.h        |    6 +-
 drivers/staging/fsl_qbman/dpa_alloc.c           |  210 ++++++++++
 drivers/staging/fsl_qbman/dpa_sys.h             |  105 +++--
 drivers/staging/fsl_qbman/qman_driver.c         |  359 ++++++++--------
 drivers/staging/fsl_qbman/qman_fqalloc.c        |  246 -----------
 drivers/staging/fsl_qbman/qman_high.c           |   13 +-
 drivers/staging/fsl_qbman/qman_private.h        |    5 +-
 drivers/staging/fsl_qbman/qman_test_hotpotato.c |   11 +-
 include/linux/fsl_bman.h                        |   35 +-
 include/linux/fsl_qman.h                        |   36 +-
 18 files changed, 909 insertions(+), 1055 deletions(-)
 create mode 100644 arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi
 create mode 100644 arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi
 create mode 100644 drivers/staging/fsl_qbman/dpa_alloc.c
 delete mode 100644 drivers/staging/fsl_qbman/qman_fqalloc.c

diff --git a/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi b/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi
new file mode 100644
index 0000000..dd7fe62
--- /dev/null
+++ b/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi
@@ -0,0 +1,72 @@
+/*
+ * QorIQ DPAA resources device tree stub [ FQIDs, BPIDs ]
+ *
+ * Copyright 2011-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* These stubs are required to alloc qbman drivers to determine what ranges of
+ * resources are available for dynamic allocation, primarily because there are
+ * some legacy "a priori" assumptions in certain subsystems (eg. networking)
+ * that certain resources are reserved for their use. When those drivers (and in
+ * some cases, their corresponding device-tree nodes) are updated to dynamically
+ * allocate their resources, then *all* resources can be managed by the
+ * allocators and there may be no further need to define these stubs.
+ *
+ * A couple of qualifiers to the above statement though:
+ *
+ * - Some resource ranges are hardware-specific, rather than being defined by
+ *   software memory allocation choices. Eg. the number of available BPIDs is
+ *   baked into silicon and so will probably always need to be expressed in the
+ *   device-tree, though in that case it will express all BPIDs, not just those
+ *   available for dynamic allocation.
+ *
+ * - Even for memory-backed resources that are software determined (FQIDs), this
+ *   information may only be configured and available on the control-plane
+ *   partition that manages the device, so in AMP or hypervised scenarios there
+ *   may still be need to a way to provide allocation ranges. Ie. for O/S
+ *   instances that don't know how many resources are available to hardware, and
+ *   possibly even for O/S instances that do know how many are available but
+ *   that should not "own" all of them.
+ */
+
+&bportals {
+	bman-bpids@0 {
+		compatible = "fsl,bpid-range";
+		fsl,bpid-range = <32 32>;
+	};
+};
+
+&qportals {
+	qman-fqids@0 {
+		compatible = "fsl,fqid-range";
+		fsl,fqid-range = <256 256>;
+	};
+};
diff --git a/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi b/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi
new file mode 100644
index 0000000..4646d16
--- /dev/null
+++ b/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi
@@ -0,0 +1,51 @@
+/*
+ * QorIQ DPAA resources device tree stub [ FQIDs, BPIDs ]
+ *
+ * Copyright 2011-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* The comments in qoriq-dpaa-res1.dtsi apply here too so will not be repeated.
+ * This alternative file is to support p1023 which does not have the same
+ * resource ranges as other SoCs to date. */
+
+&bportals {
+	bman-bpids@0 {
+		compatible = "fsl,bpid-range";
+		fsl,bpid-range = <1 7>;
+	};
+};
+
+&qportals {
+	qman-fqids@0 {
+		compatible = "fsl,fqid-range";
+		fsl,fqid-range = <256 256>;
+	};
+};
diff --git a/arch/powerpc/boot/dts/p4080ds-usdpaa.dts b/arch/powerpc/boot/dts/p4080ds-usdpaa.dts
index 9ba461f..854dd9c 100644
--- a/arch/powerpc/boot/dts/p4080ds-usdpaa.dts
+++ b/arch/powerpc/boot/dts/p4080ds-usdpaa.dts
@@ -1,7 +1,7 @@
 /*
  * P4080DS Device Tree Source
  *
- * Copyright 2009-2011 Freescale Semiconductor Inc.
+ * Copyright 2009-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -35,160 +35,31 @@
 /include/ "p4080ds.dts"
 
 / {
-	bman-portals@ff4000000 {
-		bman-portal@0 {
-			cpu-handle = <&cpu0>;
-		};
-		bman-portal@4000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu1>;
-		};
-		bman-portal@8000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu2>;
-		};
-		bman-portal@c000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu3>;
-		};
-		bman-portal@10000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu4>;
-		};
-		bman-portal@14000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu5>;
-		};
-		bman-portal@18000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu6>;
-		};
-		bman-portal@1c000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu7>;
-		};
-		bman-portal@20000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu0>;
-		};
-		bman-portal@24000 {
-			cpu-handle = <&cpu1>;
-		};
-		/* BPID 0 is used a dynamic FQID allocator */
-		buffer-pool@0 {
-			compatible = "fsl,p4080-bpool", "fsl,bpool";
-			fsl,bpid = <0>;
-			fsl,bpool-cfg = <0 0x100 0 1 0 0x100>;
-		};
-		/* NB: the bpool-ethernet-seeds is not set to avoid buffer seeding,
-		 * because apps seed these pools buffers which are determined only
-		 * at run-time.
-		 * HOWEVER, the kernel driver requires the buffer-size and also
-		 * mis-interprets things if the base-address is zero (hence the bogus
-		 * values).
-		 */
-		bp7: buffer-pool@7 {
-			compatible = "fsl,p4080-bpool", "fsl,bpool";
-			fsl,bpid = <7>;
-			fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
-			fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
-		};
-		bp8: buffer-pool@8 {
-			compatible = "fsl,p4080-bpool", "fsl,bpool";
-			fsl,bpid = <8>;
-			fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
-			fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-		};
-		bp9: buffer-pool@9 {
-			compatible = "fsl,p4080-bpool", "fsl,bpool";
-			fsl,bpid = <9>;
-			fsl,bpool-ethernet-cfg = <0 0 0 1600 0 0xfeedabba>;
-			fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
-		};
+	/* NB: "bpool-ethernet-seeds" is not set to avoid buffer seeding,
+	 * because apps seed these pools with buffers allocated at
+	 * run-time.
+	 * HOWEVER, the kernel driver requires the buffer-size so
+	 * "fsl,bpool-ethernet-cfg" is set. It also mis-interprets
+	 * things if the base-address is zero (hence the 0xdeadbeef
+	 * values).
+	 */
+	bp7: buffer-pool@7 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <7>;
+		fsl,bpool-ethernet-cfg = <0 0 0 192 0 0xdeadbeef>;
+		fsl,bpool-thresholds = <0x400 0xc00 0x0 0x0>;
 	};
-
-	qman-portals@ff4200000 {
-		qportal0: qman-portal@0 {
-			cpu-handle = <&cpu0>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
-		};
-
-		qportal1: qman-portal@4000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu1>;
-			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal2: qman-portal@8000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu2>;
-			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal3: qman-portal@c000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu3>;
-			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal4: qman-portal@10000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu4>;
-			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal5: qman-portal@14000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu5>;
-			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal6: qman-portal@18000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu6>;
-			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal7: qman-portal@1c000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu7>;
-			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal8: qman-portal@20000 {
-			fsl,usdpaa-portal;
-			cpu-handle = <&cpu0>;
-			fsl,qman-pool-channels = <&qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal9: qman-portal@24000 {
-			cpu-handle = <&cpu1>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3>;
-		};
+	bp8: buffer-pool@8 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <8>;
+		fsl,bpool-ethernet-cfg = <0 0 0 576 0 0xabbaf00d>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
+	};
+	bp9: buffer-pool@9 {
+		compatible = "fsl,p4080-bpool", "fsl,bpool";
+		fsl,bpid = <9>;
+		fsl,bpool-ethernet-cfg = <0 0 0 1600 0 0xfeedabba>;
+		fsl,bpool-thresholds = <0x100 0x300 0x0 0x0>;
 	};
 
 	fsl,dpaa {
diff --git a/arch/powerpc/boot/dts/p4080ds.dts b/arch/powerpc/boot/dts/p4080ds.dts
index 6efba57..03319bf 100644
--- a/arch/powerpc/boot/dts/p4080ds.dts
+++ b/arch/powerpc/boot/dts/p4080ds.dts
@@ -1,7 +1,7 @@
 /*
  * P4080DS Device Tree Source
  *
- * Copyright 2009-2011 Freescale Semiconductor Inc.
+ * Copyright 2009-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -75,131 +75,10 @@
 
 	bportals: bman-portals@ff4000000 {
 		ranges = <0x0 0xf 0xf4000000 0x200000>;
-		bman-portal@0 {
-			cpu-handle = <&cpu0>;
-		};
-		bman-portal@4000 {
-			cpu-handle = <&cpu1>;
-		};
-		bman-portal@8000 {
-			cpu-handle = <&cpu2>;
-		};
-		bman-portal@c000 {
-			cpu-handle = <&cpu3>;
-		};
-		bman-portal@10000 {
-			cpu-handle = <&cpu4>;
-		};
-		bman-portal@14000 {
-			cpu-handle = <&cpu5>;
-		};
-		bman-portal@18000 {
-			cpu-handle = <&cpu6>;
-		};
-		bman-portal@1c000 {
-			cpu-handle = <&cpu7>;
-		};
-		bman-portal@20000 {
-		};
-		bman-portal@24000 {
-		};
-
-		buffer-pool@0 {
-			compatible = "fsl,p4080-bpool", "fsl,bpool";
-			fsl,bpid = <0>;
-			fsl,bpool-cfg = <0 0x100 0 1 0 0x100>;
-		};
 	};
 
 	qportals: qman-portals@ff4200000 {
 		ranges = <0x0 0xf 0xf4200000 0x200000>;
-		qportal0: qman-portal@0 {
-			cpu-handle = <&cpu0>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal1: qman-portal@4000 {
-			cpu-handle = <&cpu1>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal2: qman-portal@8000 {
-			cpu-handle = <&cpu2>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal3: qman-portal@c000 {
-			cpu-handle = <&cpu3>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal4: qman-portal@10000 {
-			cpu-handle = <&cpu4>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal5: qman-portal@14000 {
-			cpu-handle = <&cpu5>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal6: qman-portal@18000 {
-			cpu-handle = <&cpu6>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal7: qman-portal@1c000 {
-			cpu-handle = <&cpu7>;
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal8: qman-portal@20000 {
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
-
-		qportal9: qman-portal@24000 {
-			fsl,qman-pool-channels = <&qpool1 &qpool2 &qpool3
-						  &qpool4 &qpool5 &qpool6
-						  &qpool7 &qpool8 &qpool9
-						  &qpool10 &qpool11 &qpool12
-						  &qpool13 &qpool14 &qpool15>;
-		};
 	};
 
 	soc: soc@ffe000000 {
@@ -616,3 +495,5 @@
 };
 
 /include/ "fsl/p4080si-post.dtsi"
+
+/include/ "fsl/qoriq-dpaa-res1.dtsi"
diff --git a/arch/powerpc/sysdev/fsl_pamu.c b/arch/powerpc/sysdev/fsl_pamu.c
index 2e53b57..e76e9cd 100644
--- a/arch/powerpc/sysdev/fsl_pamu.c
+++ b/arch/powerpc/sysdev/fsl_pamu.c
@@ -691,7 +691,7 @@ static void __init setup_liodns(void)
 				ppaace = &ppaact[*prop++];
 				ppaace->otm = PAACE_OTM_INDEXED;
 				ppaace->op_encode.index_ot.omi = OMI_QMAN;
-				cache_id = get_stash_id(1, qman_portal_dn);
+				cache_id = get_stash_id(3, qman_portal_dn);
 				pr_debug("cache_stash_id = %d\n", cache_id);
 				if (~cache_id != 0)
 					ppaace->impl_attr.cid = cache_id;
diff --git a/drivers/staging/fsl_qbman/Makefile b/drivers/staging/fsl_qbman/Makefile
index d853713..7e385aa 100644
--- a/drivers/staging/fsl_qbman/Makefile
+++ b/drivers/staging/fsl_qbman/Makefile
@@ -1,3 +1,6 @@
+# Common
+obj-$(CONFIG_FSL_DPA)		+= dpa_alloc.o
+
 # Bman
 obj-$(CONFIG_FSL_BMAN)		+= bman_high.o
 obj-$(CONFIG_FSL_BMAN_CONFIG)	+= bman_config.o bman_driver.o
@@ -9,7 +12,7 @@ bman_tester-$(CONFIG_FSL_BMAN_TEST_THRESH) += bman_test_thresh.o
 bman_debugfs_interface-y	 = bman_debugfs.o
 
 # Qman
-obj-$(CONFIG_FSL_QMAN)		+= qman_high.o qman_utility.o qman_fqalloc.o
+obj-$(CONFIG_FSL_QMAN)		+= qman_high.o qman_utility.o
 obj-$(CONFIG_FSL_QMAN_CONFIG)	+= qman_config.o qman_driver.o
 obj-$(CONFIG_FSL_QMAN_TEST)	+= qman_tester.o
 qman_tester-y			 = qman_test.o qman_test_hotpotato.o \
diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 54517a3..b31308f 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -39,109 +39,68 @@ EXPORT_SYMBOL(bman_ip_rev);
 u16 bman_pool_max;
 EXPORT_SYMBOL(bman_pool_max);
 
-/* Compatibility behaviour (when no bpool-range is present) is that;
- * (a) on a control plane, all pools that aren't explicitly mentioned in the dtb
- *     are available for allocation,
- * (b) on a non-control plane, there is never any allocation possible at all.
- *
- * New behaviour is that if any "fsl,bpool-range" nodes are declared, they
- * declare what is available for allocation, and this is independent of which
- * pools are/aren't mentioned in the dtb. Eg. to stipulate that no allocation is
- * possible, a fsl,bpool-range should be specified with zero items in it.
- *
- * This "pools" struct contains the allocator, and "explicit allocator"
- * indicates whether the range is seeded explicitly (via at least one range) or
- * implicitly (by being the set of pools that aren't declared).
- */
-static struct bman_depletion pools;
-static u8 num_pools;
-static DEFINE_SPINLOCK(pools_lock);
-static int explicit_allocator;
+/* After initialising cpus that own shared portal configs, we cache the
+ * resulting portals (ie. not just the configs) in this array. Then we
+ * initialise slave cpus that don't have their own portals, redirecting them to
+ * portals from this cache in a round-robin assignment. */
+static struct bman_portal *shared_portals[NR_CPUS];
+static int num_shared_portals;
+static int shared_portals_idx;
 
-static int __bm_pool_add(u32 bpid, u32 *cfg, int triplets)
+static int __init fsl_bpool_init(struct device_node *node)
 {
-	u64 total = 0;
-	BUG_ON(bpid >= bman_pool_max);
-	while (triplets--) {
-		struct bman_pool_params params = {
-			.bpid = bpid,
-			.flags = BMAN_POOL_FLAG_ONLY_RELEASE
-		};
-		u64 c = ((u64)cfg[0] << 32) | cfg[1];
-		u64 d = ((u64)cfg[2] << 32) | cfg[3];
-		u64 b = ((u64)cfg[4] << 32) | cfg[5];
-		struct bman_pool *pobj = bman_new_pool(&params);
-		if (!pobj)
-			return -ENOMEM;
-		while (c) {
-			struct bm_buffer bufs[8];
-			int ret, num_bufs = 0;
-			do {
-				BUG_ON(b > 0xffffffffffffull);
-				bufs[num_bufs].bpid = bpid;
-				bm_buffer_set64(&bufs[num_bufs++], b);
-				b += d;
-			} while (--c && (num_bufs < 8));
-			ret = bman_release(pobj, bufs, num_bufs,
-					BMAN_RELEASE_FLAG_WAIT);
-			if (ret)
-				panic("Seeding reserved buffer pool failed\n");
-			total += num_bufs;
-		}
-		bman_free_pool(pobj);
-		cfg += 6;
+	int ret;
+	u32 *thresh, *bpid = (u32 *)of_get_property(node, "fsl,bpid", &ret);
+	if (!bpid || (ret != 4)) {
+		pr_err("Can't get %s property 'fsl,bpid'\n", node->full_name);
+		return -ENODEV;
 	}
-	/* Remove this pool from the allocator (by treating its declaration as
-	 * an implicit "reservation") iff the allocator is *not* being set up
-	 * explicitly defined via "bpool-range" nodes. */
-	if (!explicit_allocator && !bman_depletion_get(&pools, bpid)) {
-		bman_depletion_set(&pools, bpid);
-		num_pools++;
+	thresh = (u32 *)of_get_property(node, "fsl,bpool-thresholds", &ret);
+	if (thresh) {
+		if (ret != 16) {
+			pr_err("Invalid %s property '%s'\n",
+				node->full_name, "fsl,bpool-thresholds");
+			return -ENODEV;
+		}
 	}
-	if (total)
-		pr_info("Bman: reserved bpid %d, seeded %lld items\n", bpid,
-			total);
-	else
-		pr_info("Bman: reserved bpid %d\n", bpid);
-	return 0;
-}
-
-int bm_pool_new(u32 *bpid)
-{
-	int ret = 0, b = bman_pool_max;
-	spin_lock(&pools_lock);
-	if (num_pools >= bman_pool_max)
-		ret = -ENOMEM;
-	else {
-		while (b-- && bman_depletion_get(&pools, b))
-			;
-		BUG_ON(b < 0);
-		bman_depletion_set(&pools, b);
-		*bpid = b;
-		num_pools++;
+	if (thresh) {
+#ifdef CONFIG_FSL_BMAN_CONFIG
+		ret = bm_pool_set(*bpid, thresh);
+		if (ret)
+			pr_err("No CCSR node for %s property '%s'\n",
+				node->full_name, "fsl,bpool-thresholds");
+#else
+		pr_err("Ignoring %s property '%s', no CCSR support\n",
+			node->full_name, "fsl,bpool-thresholds");
+#endif
 	}
-	spin_unlock(&pools_lock);
 	return ret;
 }
-EXPORT_SYMBOL(bm_pool_new);
 
-void bm_pool_free(u32 bpid)
+static int __init fsl_bpid_range_init(struct device_node *node)
 {
-	spin_lock(&pools_lock);
-	BUG_ON(bpid >= bman_pool_max);
-	BUG_ON(!bman_depletion_get(&pools, bpid));
-	bman_depletion_unset(&pools, bpid);
-	num_pools--;
-	spin_unlock(&pools_lock);
+	int ret;
+	u32 *range = (u32 *)of_get_property(node, "fsl,bpid-range", &ret);
+	if (!range) {
+		pr_err("No 'fsl,bpid-range' property in node %s\n",
+			node->full_name);
+		return -EINVAL;
+	}
+	if (ret != 8) {
+		pr_err("'fsl,bpid-range' is not a 2-cell range in node %s\n",
+			node->full_name);
+		return -EINVAL;
+	}
+	bman_release_bpid_range(range[0], range[1]);
+	pr_info("Bman: BPID allocator includes range %d:%d\n",
+		range[0], range[1]);
+	return 0;
 }
-EXPORT_SYMBOL(bm_pool_free);
 
-static struct bm_portal_config * __init fsl_bman_portal_init(
-						struct device_node *node)
+static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 {
 	struct bm_portal_config *pcfg;
 	const u32 *index;
-	const phandle *ph = NULL;
 	int irq, ret;
 
 	pcfg = kmalloc(sizeof(*pcfg), GFP_KERNEL);
@@ -176,19 +135,7 @@ static struct bm_portal_config * __init fsl_bman_portal_init(
 			"cell-index");
 		goto err;
 	}
-	ph = of_get_property(node, "cpu-handle", &ret);
-	if (ph) {
-		if (ret != sizeof(phandle)) {
-			pr_err("Malformed %s property '%s'\n", node->full_name,
-				"cpu-handle");
-			goto err;
-		}
-		ret = check_cpu_phandle(*ph);
-		if (ret < 0)
-			goto err;
-		pcfg->public_cfg.cpu = ret;
-	} else
-		pcfg->public_cfg.cpu = -1;
+	pcfg->public_cfg.cpu = -1;
 
 	irq = irq_of_parse_and_map(node, 0);
 	if (irq == NO_IRQ) {
@@ -213,216 +160,209 @@ err:
 	return NULL;
 }
 
-static void __init fsl_bman_portal_destroy(struct bm_portal_config *pcfg)
+static struct bm_portal_config *get_pcfg(struct list_head *list)
 {
-	iounmap(pcfg->addr_virt[DPA_PORTAL_CE]);
-	iounmap(pcfg->addr_virt[DPA_PORTAL_CI]);
-	kfree(pcfg);
+	struct bm_portal_config *pcfg;
+	if (list_empty(list))
+		return NULL;
+	pcfg = list_entry(list->prev, struct bm_portal_config, list);
+	list_del(&pcfg->list);
+	return pcfg;
 }
 
-static int __init fsl_bpool_init(struct device_node *node)
+static struct bman_portal *init_pcfg(struct bm_portal_config *pcfg)
 {
-	int ret;
-	u32 *cfg = NULL, *thresh;
-	struct device_node *tmp_node;
-	u32 *bpid = (u32 *)of_get_property(node, "fsl,bpid", &ret);
-	if (!bpid || (ret!= 4)) {
-		pr_err("Can't get %s property 'fsl,bpid'\n", node->full_name);
-		return -ENODEV;
-	}
-	thresh = (u32 *)of_get_property(node, "fsl,bpool-thresholds", &ret);
-	if (thresh) {
-		if (ret != 16) {
-			pr_err("Invalid %s property '%s'\n",
-				node->full_name, "fsl,bpool-thresholds");
-			return -ENODEV;
-		}
-#ifndef CONFIG_FSL_BMAN_CONFIG
-		pr_err("Ignoring %s property '%s', no CCSR support\n",
-			node->full_name, "fsl,bpool-thresholds");
+	struct bman_portal *p;
+	struct cpumask oldmask = *tsk_cpus_allowed(current);
+	set_cpus_allowed_ptr(current, get_cpu_mask(pcfg->public_cfg.cpu));
+	p = bman_create_affine_portal(pcfg);
+	if (p) {
+#ifdef CONFIG_FSL_DPA_PIRQ_SLOW
+		bman_irqsource_add(BM_PIRQ_RCRI | BM_PIRQ_BSCN);
 #endif
-	}
-	/* If rebooted, we should not re-seed any pools via bpool-cfg. */
-	/* TODO: parsing hypervisor fields to determine qualitative things like
-	 * "was I rebooted" should probably be wrapped in fsl_hypervisor.h. */
-	tmp_node = of_find_node_by_name(NULL, "hypervisor");
-	if (!tmp_node || !of_find_property(tmp_node, "fsl,hv-stopped-by",
-						&ret))
-		cfg = (u32 *)of_get_property(node, "fsl,bpool-cfg", &ret);
-	if (cfg && (!ret || (ret % 24))) {
-		pr_err("Invalid %s property '%s'\n", node->full_name,
-			"fsl,bpool-cfg");
-		return -ENODEV;
-	}
-	if (cfg)
-		ret = __bm_pool_add(*bpid, cfg, ret / 24);
+		pr_info("Bman portal %sinitialised, cpu %d\n",
+			pcfg->public_cfg.is_shared ? "(shared) " : "",
+			pcfg->public_cfg.cpu);
+	} else
+		pr_crit("Bman portal failure on cpu %d\n",
+			pcfg->public_cfg.cpu);
+	set_cpus_allowed_ptr(current, &oldmask);
+	return p;
+}
+
+static void init_slave(int cpu)
+{
+	struct bman_portal *p;
+	struct cpumask oldmask = *tsk_cpus_allowed(current);
+	set_cpus_allowed_ptr(current, get_cpu_mask(cpu));
+	p = bman_create_affine_slave(shared_portals[shared_portals_idx++]);
+	if (!p)
+		pr_err("Bman slave portal failure on cpu %d\n", cpu);
 	else
-		ret = __bm_pool_add(*bpid, NULL, 0);
-	if (ret) {
-		pr_err("Can't reserve bpid %d from node %s\n", *bpid,
-			node->full_name);
-		return ret;
-	}
-#ifdef CONFIG_FSL_BMAN_CONFIG
-	if (thresh) {
-		ret = bm_pool_set(*bpid, thresh);
-		if (ret)
-			pr_err("No CCSR node for %s property '%s'\n",
-				node->full_name, "fsl,bpool-thresholds");
-	}
-#endif
-	return ret;
+		pr_info("Bman portal %sinitialised, cpu %d\n", "(slave) ", cpu);
+	set_cpus_allowed_ptr(current, &oldmask);
+	if (shared_portals_idx >= num_shared_portals)
+		shared_portals_idx = 0;
 }
 
-static int __init fsl_bpool_range_init(struct device_node *node)
+/* Bootarg "bportals=[...]" has the same syntax as "qportals=", and so the
+ * parsing is in dpa_sys.h. The syntax is a comma-separated list of indexes
+ * and/or ranges of indexes, with each being optionally prefixed by "s" to
+ * explicitly mark it or them for sharing.
+ *    Eg;
+ *        bportals=s0,1-3,s4
+ * means that cpus 1,2,3 get "unshared" portals, cpus 0 and 4 get "shared"
+ * portals, and any remaining cpus share the portals that are assigned to cpus 0
+ * or 4, selected in a round-robin fashion. (In this example, cpu 5 would share
+ * cpu 0's portal, cpu 6 would share cpu4's portal, and cpu 7 would share cpu
+ * 0's portal.) */
+static struct cpumask want_unshared __initdata; /* cpus requested without "s" */
+static struct cpumask want_shared __initdata; /* cpus requested with "s" */
+
+static int __init parse_bportals(char *str)
 {
-	int ret, warned = 0;
-	u32 bpid;
-	u32 *range = (u32 *)of_get_property(node, "fsl,bpool-range", &ret);
-	if (!range) {
-		pr_err("No 'fsl,bpool-range' property in node %s\n",
-			node->full_name);
-		return -EINVAL;
-	}
-	if (ret != 8) {
-		pr_err("'fsl,bpool-range' is not a 2-cell range in node %s\n",
-			node->full_name);
-		return -EINVAL;
-	}
-	for (bpid = range[0]; bpid < (range[0] + range[1]); bpid++) {
-		if (bpid >= bman_pool_max) {
-			pr_err("BPIDs out of range in node %s\n",
-				node->full_name);
-			return -EINVAL;
-		}
-		if (!bman_depletion_get(&pools, bpid)) {
-			if (!warned) {
-				warned = 1;
-				pr_err("BPID overlap in node %s, ignoring\n",
-					node->full_name);
-			}
-		} else {
-			bman_depletion_unset(&pools, bpid);
-			num_pools--;
-		}
-	}
-	pr_info("Bman: BPID allocator includes range %d:%d\n",
-		range[0], range[1]);
-	return 0;
+	return parse_portals_bootarg(str, &want_shared, &want_unshared,
+				     "bportals");
 }
+__setup("bportals=", parse_bportals);
 
+/* Initialise the Bman driver. The meat of this function deals with portals. The
+ * following describes the flow of portal-handling, the code "steps" refer to
+ * this description;
+ * 1. Portal configs are parsed from the device-tree into 'unused_pcfgs', with
+ *    ::cpu==-1. Regions and interrupts are mapped (but interrupts are not
+ *    bound).
+ * 2. The "want_shared" and "want_unshared" lists (as filled by the
+ *    "bportals=[...]" bootarg) are processed, allocating portals and assigning
+ *    them to cpus, placing them in the relevant list and setting ::cpu as
+ *    appropriate. If no "bportals" bootarg was present, the defaut is to try to
+ *    assign portals to all online cpus at the time of driver initialisation.
+ *    Any failure to allocate portals (when parsing the "want" lists or when
+ *    using default behaviour) will be silently tolerated (the "fixup" logic in
+ *    step 3 will determine what happens in this case).
+ * 3. Do fixups relative to cpu_online_mask(). If no portals are marked for
+ *    sharing and sharing is required (because not all cpus have been assigned
+ *    portals), then one portal will marked for sharing. Conversely if no
+ *    sharing is required, any portals marked for sharing will not be shared. It
+ *    may be that sharing occurs when it wasn't expected, if portal allocation
+ *    failed to honour all the requested assignments (including the default
+ *    assignments if no bootarg is present).
+ * 4. Unshared portals are initialised on their respective cpus.
+ * 5. Shared portals are initialised on their respective cpus.
+ * 6. Each remaining cpu is initialised to slave to one of the shared portals,
+ *    which are selected in a round-robin fashion.
+ */
 static __init int bman_init(void)
 {
-	struct cpumask primary_cpus = *cpu_none_mask;
-	struct cpumask slave_cpus = *cpu_online_mask;
-	struct cpumask oldmask;
-	struct bman_portal *sharing_portal = NULL;
-	int sharing_cpu = -1;
+	struct cpumask slave_cpus;
+	struct cpumask unshared_cpus = *cpu_none_mask;
+	struct cpumask shared_cpus = *cpu_none_mask;
+	LIST_HEAD(unused_pcfgs);
+	LIST_HEAD(unshared_pcfgs);
+	LIST_HEAD(shared_pcfgs);
 	struct device_node *dn;
 	struct bm_portal_config *pcfg;
 	struct bman_portal *p;
-	int ret;
-	LIST_HEAD(cfg_list);
+	int cpu, ret;
 
+	/* Initialise the Bman (CCSR) device */
 	for_each_compatible_node(dn, NULL, "fsl,bman") {
 		if (!bman_init_error_int(dn))
 			pr_info("Bman err interrupt handler present\n");
 		else
 			pr_err("Bman err interrupt handler missing\n");
 	}
-	if (!bman_have_ccsr()) {
-		/* If there's no CCSR, our bpid allocator is empty unless
-		 * fsl,bpool-range nodes are used. */
-		bman_depletion_fill(&pools);
-		num_pools = bman_pool_max;
+	/* Initialise BPID allocation ranges */
+	for_each_compatible_node(dn, NULL, "fsl,bpid-range") {
+		ret = fsl_bpid_range_init(dn);
+		if (ret)
+			return ret;
+	}
+	/* Initialise any declared buffer pools */
+	for_each_compatible_node(dn, NULL, "fsl,bpool") {
+		ret = fsl_bpool_init(dn);
+		if (ret)
+			return ret;
 	}
+	/* Step 1. See comments at the beginning of the file. */
 	for_each_compatible_node(dn, NULL, "fsl,bman-portal") {
-		if (!of_device_is_available(dn))
-			continue;
-		pcfg = fsl_bman_portal_init(dn);
-		if (pcfg) {
-			if (pcfg->public_cfg.cpu >= 0) {
-				cpumask_set_cpu(pcfg->public_cfg.cpu,
-						&primary_cpus);
-				list_add(&pcfg->list, &cfg_list);
-			} else
-				fsl_bman_portal_destroy(pcfg);
-		}
+		pcfg = parse_pcfg(dn);
+		if (pcfg)
+			list_add_tail(&pcfg->list, &unused_pcfgs);
 	}
-	/* only consider "online" CPUs */
-	cpumask_and(&primary_cpus, &primary_cpus, cpu_online_mask);
-	if (cpumask_empty(&primary_cpus))
-		/* No portals, we're done */
-		return 0;
-	if (!cpumask_subset(cpu_online_mask, &primary_cpus)) {
-		/* Need to do some sharing. In lieu of anything more scientific
-		 * (or configurable), we pick the last-most CPU that has a
-		 * portal and share that one. */
-		int next = cpumask_first(&primary_cpus);
-		while (next < nr_cpu_ids) {
-			sharing_cpu = next;
-			next = cpumask_next(next, &primary_cpus);
-		}
+	/* Step 2. */
+	for_each_cpu(cpu, &want_shared) {
+		pcfg = get_pcfg(&unused_pcfgs);
+		if (!pcfg)
+			break;
+		pcfg->public_cfg.cpu = cpu;
+		list_add_tail(&pcfg->list, &shared_pcfgs);
+		cpumask_set_cpu(cpu, &shared_cpus);
 	}
-	/* Parsing is done and sharing decisions are made, now initialise the
-	 * portals and determine which "slave" CPUs are left over. */
-	list_for_each_entry(pcfg, &cfg_list, list) {
-		int is_shared = (!sharing_portal && (sharing_cpu >= 0) &&
-				(pcfg->public_cfg.cpu == sharing_cpu));
-		pcfg->public_cfg.is_shared = is_shared;
-		/* If it's not mapped to a CPU, or another portal is already
-		 * initialised to the same CPU, skip this portal. */
-		if (pcfg->public_cfg.cpu < 0 || !cpumask_test_cpu(
-					pcfg->public_cfg.cpu, &slave_cpus))
+	for_each_cpu(cpu, &want_unshared) {
+		if (cpumask_test_cpu(cpu, &shared_cpus))
 			continue;
-		oldmask = *tsk_cpus_allowed(current);
-		set_cpus_allowed_ptr(current,
-				     get_cpu_mask(pcfg->public_cfg.cpu));
-		p = bman_create_affine_portal(pcfg);
-		if (p) {
-#ifdef CONFIG_FSL_DPA_PIRQ_SLOW
-			bman_irqsource_add(BM_PIRQ_RCRI | BM_PIRQ_BSCN);
-#endif
-			pr_info("Bman portal %sinitialised, cpu %d\n",
-				is_shared ? "(shared) " : "",
-				pcfg->public_cfg.cpu);
-			if (is_shared)
-				sharing_portal = p;
-			cpumask_clear_cpu(pcfg->public_cfg.cpu, &slave_cpus);
-		}
-		set_cpus_allowed_ptr(current, &oldmask);
+		pcfg = get_pcfg(&unused_pcfgs);
+		if (!pcfg)
+			break;
+		pcfg->public_cfg.cpu = cpu;
+		list_add_tail(&pcfg->list, &unshared_pcfgs);
+		cpumask_set_cpu(cpu, &unshared_cpus);
 	}
-
-	if (sharing_portal) {
-		int loop;
-		for_each_cpu(loop, &slave_cpus) {
-			oldmask = *tsk_cpus_allowed(current);
-			set_cpus_allowed_ptr(current, get_cpu_mask(loop));
-			p = bman_create_affine_slave(sharing_portal);
-			set_cpus_allowed_ptr(current, &oldmask);
-			if (!p)
-				pr_err("Failed slave Bman portal for cpu %d\n",
-					loop);
-			else
-				pr_info("Bman portal %sinitialised, cpu %d\n",
-					"(slave) ", loop);
+	if (list_empty(&shared_pcfgs) && list_empty(&unshared_pcfgs)) {
+		/* Default, give an unshared portal to each online cpu */
+		for_each_online_cpu(cpu) {
+			pcfg = get_pcfg(&unused_pcfgs);
+			if (!pcfg)
+				break;
+			pcfg->public_cfg.cpu = cpu;
+			list_add_tail(&pcfg->list, &unshared_pcfgs);
+			cpumask_set_cpu(cpu, &unshared_cpus);
 		}
 	}
-	for_each_compatible_node(dn, NULL, "fsl,bpool-range") {
-		if (!explicit_allocator) {
-			explicit_allocator = 1;
-			bman_depletion_fill(&pools);
-			num_pools = 64;
+	/* Step 3. */
+	cpumask_andnot(&slave_cpus, cpu_online_mask, &shared_cpus);
+	cpumask_andnot(&slave_cpus, &slave_cpus, &unshared_cpus);
+	if (cpumask_empty(&slave_cpus)) {
+		/* No sharing required */
+		if (!list_empty(&shared_pcfgs)) {
+			/* Migrate "shared" to "unshared" */
+			cpumask_or(&unshared_cpus, &unshared_cpus,
+				   &shared_cpus);
+			cpumask_clear(&shared_cpus);
+			list_splice_tail(&shared_pcfgs, &unshared_pcfgs);
+			INIT_LIST_HEAD(&shared_pcfgs);
+		}
+	} else {
+		/* Sharing required */
+		if (list_empty(&shared_pcfgs)) {
+			/* Migrate one "unshared" to "shared" */
+			pcfg = get_pcfg(&unshared_pcfgs);
+			if (!pcfg) {
+				pr_crit("No BMan portals available!\n");
+				return 0;
+			}
+			cpumask_clear_cpu(pcfg->public_cfg.cpu, &unshared_cpus);
+			cpumask_set_cpu(pcfg->public_cfg.cpu, &shared_cpus);
+			list_add_tail(&pcfg->list, &shared_pcfgs);
 		}
-		ret = fsl_bpool_range_init(dn);
-		if (ret)
-			return ret;
 	}
-	for_each_compatible_node(dn, NULL, "fsl,bpool") {
-		ret = fsl_bpool_init(dn);
-		if (ret)
-			return ret;
+	/* Step 4. */
+	list_for_each_entry(pcfg, &unshared_pcfgs, list) {
+		pcfg->public_cfg.is_shared = 0;
+		p = init_pcfg(pcfg);
+	}
+	/* Step 5. */
+	list_for_each_entry(pcfg, &shared_pcfgs, list) {
+		pcfg->public_cfg.is_shared = 1;
+		p = init_pcfg(pcfg);
+		if (p)
+			shared_portals[num_shared_portals++] = p;
 	}
+	/* Step 6. */
+	if (!cpumask_empty(&slave_cpus))
+		for_each_cpu(cpu, &slave_cpus)
+			init_slave(cpu);
 	pr_info("Bman portals initialised\n");
 	return 0;
 }
diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index 8bce299..bfaa7ee 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -1,4 +1,4 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -551,7 +551,7 @@ struct bman_pool *bman_new_pool(const struct bman_pool_params *params)
 	u32 bpid;
 
 	if (params->flags & BMAN_POOL_FLAG_DYNAMIC_BPID) {
-		int ret = bm_pool_new(&bpid);
+		int ret = bman_alloc_bpid(&bpid);
 		if (ret)
 			return NULL;
 	} else {
@@ -602,7 +602,7 @@ err:
 		bm_pool_set(bpid, zero_thresholds);
 #endif
 	if (params->flags & BMAN_POOL_FLAG_DYNAMIC_BPID)
-		bm_pool_free(bpid);
+		bman_release_bpid(bpid);
 	if (pool) {
 		if (pool->sp)
 			kfree(pool->sp);
@@ -644,7 +644,7 @@ void bman_free_pool(struct bman_pool *pool)
 			if (ret < 8)
 				ret = bman_acquire(pool, bufs, 1, 0);
 		} while (ret > 0);
-		bm_pool_free(pool->params.bpid);
+		bman_release_bpid(pool->params.bpid);
 	}
 	kfree(pool);
 }
diff --git a/drivers/staging/fsl_qbman/bman_private.h b/drivers/staging/fsl_qbman/bman_private.h
index 5f2e31d..12180c7 100644
--- a/drivers/staging/fsl_qbman/bman_private.h
+++ b/drivers/staging/fsl_qbman/bman_private.h
@@ -1,4 +1,4 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -127,10 +127,6 @@ int bman_have_ccsr(void);
 #define bm_isr_inhibit(bm)		__bm_isr_write(bm, bm_isr_inhibit, 1)
 #define bm_isr_uninhibit(bm)		__bm_isr_write(bm, bm_isr_inhibit, 0)
 
-/* Allocate/release an unreserved buffer pool id */
-int bm_pool_new(u32 *bpid);
-void bm_pool_free(u32 bpid);
-
 #ifdef CONFIG_FSL_BMAN_CONFIG
 /* Set depletion thresholds associated with a buffer pool. Requires that the
  * operating system have access to Bman CCSR (ie. compiled in support and
diff --git a/drivers/staging/fsl_qbman/dpa_alloc.c b/drivers/staging/fsl_qbman/dpa_alloc.c
new file mode 100644
index 0000000..d26007b
--- /dev/null
+++ b/drivers/staging/fsl_qbman/dpa_alloc.c
@@ -0,0 +1,210 @@
+/* Copyright 2009-2012 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "dpa_sys.h"
+
+/* Qman and Bman APIs are front-ends to the common code; */
+
+static DECLARE_DPA_ALLOC(bpalloc);
+static DECLARE_DPA_ALLOC(fqalloc);
+
+int bman_alloc_bpid_range(u32 *result, u32 count, u32 align, int partial)
+{
+	return dpa_alloc_new(&bpalloc, result, count, align, partial);
+}
+EXPORT_SYMBOL(bman_alloc_bpid_range);
+
+void bman_release_bpid_range(u32 bpid, u32 count)
+{
+	dpa_alloc_free(&bpalloc, bpid, count);
+}
+EXPORT_SYMBOL(bman_release_bpid_range);
+
+int qman_alloc_fqid_range(u32 *result, u32 count, u32 align, int partial)
+{
+	return dpa_alloc_new(&fqalloc, result, count, align, partial);
+}
+EXPORT_SYMBOL(qman_alloc_fqid_range);
+
+void qman_release_fqid_range(u32 fqid, u32 count)
+{
+	dpa_alloc_free(&fqalloc, fqid, count);
+}
+EXPORT_SYMBOL(qman_release_fqid_range);
+
+/* The rest is the common backend to the Qman and Bman allocators */
+
+/* The allocator is a (possibly-empty) list of these; */
+struct alloc_node {
+	struct list_head list;
+	u32 base;
+	u32 num;
+};
+
+/* #define DPA_ALLOC_DEBUG */
+
+#ifdef DPA_ALLOC_DEBUG
+#define DPRINT pr_info
+static void DUMP(struct dpa_alloc *alloc)
+{
+	int off = 0;
+	char buf[256];
+	struct alloc_node *p;
+	list_for_each_entry(p, &alloc->list, list) {
+		if (off < 255)
+			off += snprintf(buf + off, 255-off, "{%d,%d}",
+				p->base, p->base + p->num - 1);
+	}
+	pr_info("%s\n", buf);
+}
+#else
+#define DPRINT(x...)	do { ; } while (0)
+#define DUMP(a)		do { ; } while (0)
+#endif
+
+int dpa_alloc_new(struct dpa_alloc *alloc, u32 *result, u32 count, u32 align,
+		  int partial)
+{
+	struct alloc_node *i = NULL, *next_best = NULL;
+	u32 base, next_best_base = 0, num = 0, next_best_num = 0;
+	struct alloc_node *margin_left, *margin_right;
+
+	*result = (u32)-1;
+	DPRINT("alloc_range(%d,%d,%d)\n", count, align, partial);
+	DUMP(alloc);
+	/* If 'align' is 0, it should behave as though it was 1 */
+	if (!align)
+		align = 1;
+	margin_left = kmalloc(sizeof(*margin_left), GFP_KERNEL);
+	if (!margin_left)
+		goto err;
+	margin_right = kmalloc(sizeof(*margin_right), GFP_KERNEL);
+	if (!margin_right) {
+		kfree(margin_left);
+		goto err;
+	}
+	spin_lock_irq(&alloc->lock);
+	list_for_each_entry(i, &alloc->list, list) {
+		base = (i->base + align - 1) / align;
+		base *= align;
+		if ((base - i->base) >= i->num)
+			/* alignment is impossible, regardless of count */
+			continue;
+		num = i->num - (base - i->base);
+		if (num >= count) {
+			/* this one will do nicely */
+			num = count;
+			goto done;
+		}
+		if (num > next_best_num) {
+			next_best = i;
+			next_best_base = base;
+			next_best_num = num;
+		}
+	}
+	if (partial && next_best) {
+		i = next_best;
+		base = next_best_base;
+		num = next_best_num;
+	} else
+		i = NULL;
+done:
+	if (i) {
+		if (base != i->base) {
+			margin_left->base = i->base;
+			margin_left->num = base - i->base;
+			list_add_tail(&margin_left->list, &i->list);
+		} else
+			kfree(margin_left);
+		if ((base + num) < (i->base + i->num)) {
+			margin_right->base = base + num;
+			margin_right->num = (i->base + i->num) -
+						(base + num);
+			list_add(&margin_right->list, &i->list);
+		} else
+			kfree(margin_right);
+		list_del(&i->list);
+		kfree(i);
+		*result = base;
+	}
+	spin_unlock_irq(&alloc->lock);
+err:
+	DPRINT("returning %d\n", i ? num : -ENOMEM);
+	DUMP(alloc);
+	return i ? (int)num : -ENOMEM;
+}
+
+/* Allocate the list node using GFP_ATOMIC, because we *really* want to avoid
+ * forcing error-handling on to users in the deallocation path. */
+void dpa_alloc_free(struct dpa_alloc *alloc, u32 fqid, u32 count)
+{
+	struct alloc_node *i, *node = kmalloc(sizeof(*node), GFP_ATOMIC);
+	BUG_ON(!node);
+	DPRINT("release_range(%d,%d)\n", fqid, count);
+	DUMP(alloc);
+	BUG_ON(!count);
+	spin_lock_irq(&alloc->lock);
+	node->base = fqid;
+	node->num = count;
+	list_for_each_entry(i, &alloc->list, list) {
+		if (i->base >= node->base) {
+			/* BUG_ON(any overlapping) */
+			BUG_ON(i->base < (node->base + node->num));
+			list_add_tail(&node->list, &i->list);
+			goto done;
+		}
+	}
+	list_add_tail(&node->list, &alloc->list);
+done:
+	/* Merge to the left */
+	i = list_entry(node->list.prev, struct alloc_node, list);
+	if (node->list.prev != &alloc->list) {
+		BUG_ON((i->base + i->num) > node->base);
+		if ((i->base + i->num) == node->base) {
+			node->base = i->base;
+			node->num += i->num;
+			list_del(&i->list);
+			kfree(i);
+		}
+	}
+	/* Merge to the right */
+	i = list_entry(node->list.next, struct alloc_node, list);
+	if (node->list.next != &alloc->list) {
+		BUG_ON((node->base + node->num) > i->base);
+		if ((node->base + node->num) == i->base) {
+			node->num += i->num;
+			list_del(&i->list);
+			kfree(i);
+		}
+	}
+	spin_unlock_irq(&alloc->lock);
+	DUMP(alloc);
+}
diff --git a/drivers/staging/fsl_qbman/dpa_sys.h b/drivers/staging/fsl_qbman/dpa_sys.h
index a32fa1f..67f9659 100644
--- a/drivers/staging/fsl_qbman/dpa_sys.h
+++ b/drivers/staging/fsl_qbman/dpa_sys.h
@@ -1,4 +1,4 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -54,42 +54,33 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/device.h>
-#include <asm/smp.h>
+#include <linux/smp.h>
 #include <sysdev/fsl_soc.h>
 #include <linux/fsl_hypervisor.h>
 #include <linux/vmalloc.h>
+#include <linux/ctype.h>
+
+/* Kernel FQID/BPID allocation uses the common logic in dpa_alloc.c via the
+ * following interface. */
+struct dpa_alloc {
+	struct list_head list;
+	spinlock_t lock;
+};
+#define DECLARE_DPA_ALLOC(name) \
+	struct dpa_alloc name = { \
+		.list = { \
+			.prev = &name.list, \
+			.next = &name.list \
+		}, \
+		.lock = __SPIN_LOCK_UNLOCKED(name.lock) \
+	}
+int dpa_alloc_new(struct dpa_alloc *alloc, u32 *result, u32 count, u32 align,
+		  int partial);
+void dpa_alloc_free(struct dpa_alloc *alloc, u32 fqid, u32 count);
 
 /* When copying aligned words or shorts, try to avoid memcpy() */
 #define CONFIG_TRY_BETTER_MEMCPY
 
-/* This takes a "phandle" and dereferences to the cpu device-tree node,
- * returning the cpu index. Returns negative error codes. */
-static inline int check_cpu_phandle(phandle ph)
-{
-	const u32 *cpu_val;
-	struct device_node *tmp_node = of_find_node_by_phandle(ph);
-	int cpu, ret;
-
-	if (!tmp_node) {
-		pr_err("Bad 'cpu-handle'\n");
-		return -EINVAL;
-	}
-	cpu_val = of_get_property(tmp_node, "reg", &ret);
-	if (!cpu_val || (ret != sizeof(*cpu_val))) {
-		pr_err("Can't get %s property 'reg'\n", tmp_node->full_name);
-		return -ENODEV;
-	}
-	for_each_present_cpu(cpu) {
-		if (*cpu_val == get_hard_smp_processor_id(cpu))
-			goto done;
-	}
-	pr_err("Invalid cpu index %d in %s\n", *cpu_val, tmp_node->full_name);
-	return -ENODEV;
-done:
-	of_node_put(tmp_node);
-	return cpu;
-}
-
 /* For 2-element tables related to cache-inhibited and cache-enabled mappings */
 #define DPA_PORTAL_CE 0
 #define DPA_PORTAL_CI 1
@@ -293,5 +284,59 @@ static inline type *name##_find(struct dpa_rbtree *tree, u32 val) \
 	return NULL; \
 }
 
+/************/
+/* Bootargs */
+/************/
+
+/* Qman has "qportals=" and Bman has "bportals=", they use the same syntax
+ * though; a comma-separated list of items, each item being a cpu index and/or a
+ * range of cpu indices, and each item optionally be prefixed by "s" to indicate
+ * that the portal associated with that cpu should be shared. See bman_driver.c
+ * for more specifics. */
+static int __parse_portals_cpu(const char **s, int *cpu)
+{
+	*cpu = 0;
+	if (!isdigit(**s))
+		return -EINVAL;
+	while (isdigit(**s))
+		*cpu = *cpu * 10 + (*((*s)++) - '0');
+	return 0;
+}
+static inline int parse_portals_bootarg(char *str, struct cpumask *want_shared,
+					struct cpumask *want_unshared,
+					const char *argname)
+{
+	const char *s = str;
+	unsigned int shared, cpu1, cpu2, loop;
+
+keep_going:
+	if (*s == 's') {
+		shared = 1;
+		s++;
+	} else
+		shared = 0;
+	if (__parse_portals_cpu(&s, &cpu1))
+		goto err;
+	if (*s == '-') {
+		s++;
+		if (__parse_portals_cpu(&s, &cpu2))
+			goto err;
+		if (cpu2 < cpu1)
+			goto err;
+	} else
+		cpu2 = cpu1;
+	for (loop = cpu1; loop <= cpu2; loop++)
+		cpumask_set_cpu(loop, shared ? want_shared : want_unshared);
+	if (*s == ',') {
+		s++;
+		goto keep_going;
+	} else if ((*s == '\0') || isspace(*s))
+		return 0;
+err:
+	pr_crit("Malformed %s argument: %s, offset: %lu\n", argname, str,
+		(unsigned long)s - (unsigned long)str);
+	return -EINVAL;
+}
+
 #endif /* DPA_SYS_H */
 
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 9e962ba..c4f838c 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -3,13 +3,13 @@
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
+ *	 notice, this list of conditions and the following disclaimer.
  *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
  *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
  *
  *
  * ALTERNATIVELY, this software may be distributed under the terms of the
@@ -30,6 +30,7 @@
  */
 
 #include "qman_private.h"
+#include <sysdev/fsl_pamu.h>
 
 /* Global variable containing revision id (even on non-control plane systems
  * where CCSR isn't available) */
@@ -41,16 +42,40 @@ EXPORT_SYMBOL(qman_ip_rev);
 static u32 fqd_size = (PAGE_SIZE << CONFIG_FSL_QMAN_FQD_SZ);
 #endif
 
-/* Parses the device-tree node, extracts the configuration, and if appropriate
- * initialises the portal for use on one or more CPUs. */
-static __init struct qm_portal_config *fsl_qman_portal_init(
-					struct device_node *node)
+/* For these variables, and the portal-initialisation logic, the
+ * comments in bman_driver.c apply here so won't be repeated. */
+static struct qman_portal *shared_portals[NR_CPUS];
+static int num_shared_portals;
+static int shared_portals_idx;
+
+/* A SDQCR mask comprising all the available/visible pool channels */
+static u32 pools_sdqcr;
+
+static __init int fsl_fqid_range_init(struct device_node *node)
+{
+	int ret;
+	u32 *range = (u32 *)of_get_property(node, "fsl,fqid-range", &ret);
+	if (!range) {
+		pr_err("No 'fsl,fqid-range' property in node %s\n",
+			node->full_name);
+		return -EINVAL;
+	}
+	if (ret != 8) {
+		pr_err("'fsl,fqid-range' is not a 2-cell range in node %s\n",
+			node->full_name);
+		return -EINVAL;
+	}
+	qman_release_fqid_range(range[0], range[1]);
+	pr_info("Qman: FQID allocator includes range %d:%d\n",
+		range[0], range[1]);
+	return 0;
+}
+
+static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 {
 	struct qm_portal_config *pcfg;
 	const u32 *index, *channel;
-	const phandle *ph;
-	struct device_node *tmp_node;
-	int irq, ret, numpools;
+	int irq, ret;
 	u16 ip_rev = 0;
 
 	pcfg = kmalloc(sizeof(*pcfg), GFP_KERNEL);
@@ -109,30 +134,7 @@ static __init struct qm_portal_config *fsl_qman_portal_init(
 		pr_err("Warning: node %s has mismatched %s and %s\n",
 			node->full_name, "cell-index", "fsl,qman-channel-id");
 	pcfg->public_cfg.channel = *channel;
-	/* Parse cpu associations for this portal. This involves dereferencing
-	 * to the cpu device-tree nodes, but it also ensures we only try to work
-	 * with CPUs that exist. (Eg. under a hypervisor.) */
-	ph = of_get_property(node, "cpu-handle", &ret);
-	if (ph) {
-		if (ret != sizeof(phandle)) {
-			pr_err("Malformed %s property '%s'\n", node->full_name,
-				"cpu-handle");
-			return NULL;
-		}
-		ret = check_cpu_phandle(*ph);
-		if (ret < 0)
-			return NULL;
-		pcfg->public_cfg.cpu = ret;
-	} else
-		pcfg->public_cfg.cpu = -1;
-
-	ph = of_get_property(node, "fsl,qman-pool-channels", &ret);
-	if (ph && (ret % sizeof(phandle))) {
-		pr_err("Malformed %s property '%s'\n", node->full_name,
-			"fsl,qman-pool-channels");
-		goto err;
-	}
-	numpools = ph ? (ret / sizeof(phandle)) : 0;
+	pcfg->public_cfg.cpu = -1;
 	irq = irq_of_parse_and_map(node, 0);
 	if (irq == NO_IRQ) {
 		pr_err("Can't get %s property '%s'\n", node->full_name,
@@ -141,7 +143,6 @@ static __init struct qm_portal_config *fsl_qman_portal_init(
 	}
 	pcfg->public_cfg.irq = irq;
 	pcfg->public_cfg.index = *index;
-	pcfg->public_cfg.pools = 0;
 	pcfg->node = node;
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	/* We need the same LIODN offset for all portals */
@@ -157,180 +158,206 @@ static __init struct qm_portal_config *fsl_qman_portal_init(
 				resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]),
 				_PAGE_GUARDED | _PAGE_NO_CACHE);
 
-	while (numpools--) {
-		for_each_compatible_node(tmp_node, NULL,
-					 "fsl,qman-pool-channel") {
-			phandle *lph = (phandle *)of_get_property(tmp_node,
-				 "linux,phandle", &ret);
-			if (*lph == *ph) {
-				u32 *index = (u32 *)of_get_property(tmp_node,
-					"cell-index", &ret);
-				pcfg->public_cfg.pools |=
-					QM_SDQCR_CHANNELS_POOL(*index);
-			}
-		}
-		ph++;
-	}
-	if (pcfg->public_cfg.pools == 0)
-		panic("Unrecoverable error linking pool channels");
-
 	return pcfg;
 err:
 	kfree(pcfg);
 	return NULL;
 }
 
-static void __init fsl_qman_portal_destroy(struct qm_portal_config *pcfg)
+static struct qm_portal_config *get_pcfg(struct list_head *list)
 {
-	iounmap(pcfg->addr_virt[DPA_PORTAL_CE]);
-	iounmap(pcfg->addr_virt[DPA_PORTAL_CI]);
-	kfree(pcfg);
+	struct qm_portal_config *pcfg;
+	if (list_empty(list))
+		return NULL;
+	pcfg = list_entry(list->prev, struct qm_portal_config, list);
+	list_del(&pcfg->list);
+	return pcfg;
 }
 
-static __init int fsl_fqid_range_init(struct device_node *node)
+#ifdef CONFIG_FSL_PAMU
+static void set_liodns(const struct qm_portal_config *pcfg, int cpu)
 {
+	unsigned int index = 0;
 	int ret;
-	u32 *range = (u32 *)of_get_property(node, "fsl,fqid-range", &ret);
-	if (!range) {
-		pr_err("No 'fsl,fqid-range' property in node %s\n",
-			node->full_name);
-		return -EINVAL;
-	}
-	if (ret != 8) {
-		pr_err("'fsl,fqid-range' is not a 2-cell range in node %s\n",
-			node->full_name);
-		return -EINVAL;
-	}
-	qman_release_fqid_range(range[0], range[1]);
-	pr_info("Qman: FQID allocator includes range %d:%d\n",
-		range[0], range[1]);
-	return 0;
+	do {
+		ret = pamu_set_stash_dest(pcfg->node, index++, cpu, 1);
+	} while (ret >= 0);
 }
+#else
+#define set_liodns(pcfg, cpu) do { } while (0)
+#endif
 
-/***************/
-/* Driver load */
-/***************/
+static struct qman_portal *init_pcfg(struct qm_portal_config *pcfg)
+{
+	struct qman_portal *p;
+	struct cpumask oldmask = *tsk_cpus_allowed(current);
+
+	set_liodns(pcfg, pcfg->public_cfg.cpu);
+	set_cpus_allowed_ptr(current, get_cpu_mask(pcfg->public_cfg.cpu));
+	p = qman_create_affine_portal(pcfg, NULL);
+	if (p) {
+		u32 irq_sources = 0;
+		/* Determine what should be interrupt-vs-poll driven */
+#ifdef CONFIG_FSL_DPA_PIRQ_SLOW
+		irq_sources |= QM_PIRQ_EQCI | QM_PIRQ_EQRI | QM_PIRQ_MRI |
+			       QM_PIRQ_CSCI;
+#endif
+#ifdef CONFIG_FSL_DPA_PIRQ_FAST
+		irq_sources |= QM_PIRQ_DQRI;
+#endif
+		qman_irqsource_add(irq_sources);
+		pr_info("Qman portal %sinitialised, cpu %d\n",
+			pcfg->public_cfg.is_shared ? "(shared) " : "",
+			pcfg->public_cfg.cpu);
+	} else
+		pr_crit("Qman portal failure on cpu %d\n",
+			pcfg->public_cfg.cpu);
+	set_cpus_allowed_ptr(current, &oldmask);
+	return p;
+}
+
+static void init_slave(int cpu)
+{
+	struct qman_portal *p;
+	struct cpumask oldmask = *tsk_cpus_allowed(current);
+	set_cpus_allowed_ptr(current, get_cpu_mask(cpu));
+	p = qman_create_affine_slave(shared_portals[shared_portals_idx++]);
+	if (!p)
+		pr_err("Qman slave portal failure on cpu %d\n", cpu);
+	else
+		pr_info("Qman portal %sinitialised, cpu %d\n", "(slave) ", cpu);
+	set_cpus_allowed_ptr(current, &oldmask);
+	if (shared_portals_idx >= num_shared_portals)
+		shared_portals_idx = 0;
+}
+
+static struct cpumask want_unshared __initdata;
+static struct cpumask want_shared __initdata;
+
+static int __init parse_qportals(char *str)
+{
+	return parse_portals_bootarg(str, &want_shared, &want_unshared,
+				     "qportals");
+}
+__setup("qportals=", parse_qportals);
 
 static __init int qman_init(void)
 {
 	struct qman_cgr cgr;
-	struct cpumask primary_cpus = *cpu_none_mask;
-	struct cpumask slave_cpus = *cpu_online_mask;
-	struct cpumask oldmask;
-	struct qman_portal *sharing_portal = NULL;
-	int sharing_cpu = -1;
+	struct cpumask slave_cpus;
+	struct cpumask unshared_cpus = *cpu_none_mask;
+	struct cpumask shared_cpus = *cpu_none_mask;
+	LIST_HEAD(unused_pcfgs);
+	LIST_HEAD(unshared_pcfgs);
+	LIST_HEAD(shared_pcfgs);
 	struct device_node *dn;
 	struct qm_portal_config *pcfg;
 	struct qman_portal *p;
-	int ret, use_bpid0 = 1;
-	LIST_HEAD(cfg_list);
+	int cpu, ret;
 
+	/* Initialise the Qman (CCSR) device */
 	for_each_compatible_node(dn, NULL, "fsl,qman") {
 		if (!qman_init_error_int(dn))
 			pr_info("Qman err interrupt handler present\n");
 		else
 			pr_err("Qman err interrupt handler missing\n");
 	}
+	/* Initialise FQID allocation ranges */
+	for_each_compatible_node(dn, NULL, "fsl,fqid-range") {
+		ret = fsl_fqid_range_init(dn);
+		if (ret)
+			return ret;
+	}
+	/* Parse pool channels */
+	for_each_compatible_node(dn, NULL, "fsl,qman-pool-channel") {
+		const u32 *index = of_get_property(dn, "cell-index", NULL);
+		pools_sdqcr |= QM_SDQCR_CHANNELS_POOL(*index);
+	}
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
+	/* Setup lookup table for FQ demux */
 	ret = qman_setup_fq_lookup_table(fqd_size/64);
 	if (ret)
 		return ret;
 #endif
+	/* Initialise portals. See bman_driver.c for comments */
 	for_each_compatible_node(dn, NULL, "fsl,qman-portal") {
-		if (!of_device_is_available(dn))
-			continue;
-		pcfg = fsl_qman_portal_init(dn);
+		pcfg = parse_pcfg(dn);
 		if (pcfg) {
-			if (pcfg->public_cfg.cpu >= 0) {
-				cpumask_set_cpu(pcfg->public_cfg.cpu,
-						&primary_cpus);
-				list_add(&pcfg->list, &cfg_list);
-			} else
-				fsl_qman_portal_destroy(pcfg);
+			pcfg->public_cfg.pools = pools_sdqcr;
+			list_add_tail(&pcfg->list, &unused_pcfgs);
 		}
 	}
-	/* only consider "online" CPUs */
-	cpumask_and(&primary_cpus, &primary_cpus, cpu_online_mask);
-	if (cpumask_empty(&primary_cpus))
-		/* No portals, we're done */
-		return 0;
-	if (!cpumask_subset(cpu_online_mask, &primary_cpus)) {
-		/* Need to do some sharing. In lieu of anything more scientific
-		 * (or configurable), we pick the last-most CPU that has a
-		 * portal and share that one. */
-		int next = cpumask_first(&primary_cpus);
-		while (next < nr_cpu_ids) {
-			sharing_cpu = next;
-			next = cpumask_next(next, &primary_cpus);
-		}
+	for_each_cpu(cpu, &want_shared) {
+		pcfg = get_pcfg(&unused_pcfgs);
+		if (!pcfg)
+			break;
+		pcfg->public_cfg.cpu = cpu;
+		list_add_tail(&pcfg->list, &shared_pcfgs);
+		cpumask_set_cpu(cpu, &shared_cpus);
 	}
-	/* Parsing is done and sharing decisions are made, now initialise the
-	 * portals and determine which "slave" CPUs are left over. */
-	list_for_each_entry(pcfg, &cfg_list, list) {
-		int is_shared = (!sharing_portal && (sharing_cpu >= 0) &&
-				(pcfg->public_cfg.cpu == sharing_cpu));
-		pcfg->public_cfg.is_shared = is_shared;
-		/* If it's not mapped to a CPU, or another portal is already
-		 * initialised to the same CPU, skip this portal. */
-		if (pcfg->public_cfg.cpu < 0 || !cpumask_test_cpu(
-					pcfg->public_cfg.cpu, &slave_cpus))
+	for_each_cpu(cpu, &want_unshared) {
+		if (cpumask_test_cpu(cpu, &shared_cpus))
 			continue;
-		oldmask = *tsk_cpus_allowed(current);
-		set_cpus_allowed_ptr(current,
-				     get_cpu_mask(pcfg->public_cfg.cpu));
-		p = qman_create_affine_portal(pcfg, NULL);
-		if (p) {
-			u32 irq_sources = 0;
-			/* Determine what should be interrupt-vs-poll driven */
-#ifdef CONFIG_FSL_DPA_PIRQ_SLOW
-			irq_sources |= QM_PIRQ_EQCI | QM_PIRQ_EQRI |
-				QM_PIRQ_MRI | QM_PIRQ_CSCI;
-#endif
-#ifdef CONFIG_FSL_DPA_PIRQ_FAST
-			irq_sources |= QM_PIRQ_DQRI;
-#endif
-			qman_irqsource_add(irq_sources);
-			pr_info("Qman portal %sinitialised, cpu %d\n",
-				is_shared ? "(shared) " : "",
-				pcfg->public_cfg.cpu);
-			if (is_shared)
-				sharing_portal = p;
-			cpumask_clear_cpu(pcfg->public_cfg.cpu, &slave_cpus);
+		pcfg = get_pcfg(&unused_pcfgs);
+		if (!pcfg)
+			break;
+		pcfg->public_cfg.cpu = cpu;
+		list_add_tail(&pcfg->list, &unshared_pcfgs);
+		cpumask_set_cpu(cpu, &unshared_cpus);
+	}
+	if (list_empty(&shared_pcfgs) && list_empty(&unshared_pcfgs)) {
+		for_each_online_cpu(cpu) {
+			pcfg = get_pcfg(&unused_pcfgs);
+			if (!pcfg)
+				break;
+			pcfg->public_cfg.cpu = cpu;
+			list_add_tail(&pcfg->list, &unshared_pcfgs);
+			cpumask_set_cpu(cpu, &unshared_cpus);
 		}
-		set_cpus_allowed_ptr(current, &oldmask);
 	}
-	if (sharing_portal) {
-		int loop;
-		for_each_cpu(loop, &slave_cpus) {
-			oldmask = *tsk_cpus_allowed(current);
-			set_cpus_allowed_ptr(current, get_cpu_mask(loop));
-			p = qman_create_affine_slave(sharing_portal);
-			set_cpus_allowed_ptr(current, &oldmask);
-			if (!p)
-				pr_err("Failed slave Qman portal for cpu %d\n",
-					loop);
-			else
-				pr_info("Qman portal %sinitialised, cpu %d\n",
-					"(slave) ", loop);
+	cpumask_andnot(&slave_cpus, cpu_online_mask, &shared_cpus);
+	cpumask_andnot(&slave_cpus, &slave_cpus, &unshared_cpus);
+	if (cpumask_empty(&slave_cpus)) {
+		if (!list_empty(&shared_pcfgs)) {
+			cpumask_or(&unshared_cpus, &unshared_cpus,
+				   &shared_cpus);
+			cpumask_clear(&shared_cpus);
+			list_splice_tail(&shared_pcfgs, &unshared_pcfgs);
+			INIT_LIST_HEAD(&shared_pcfgs);
+		}
+	} else {
+		if (list_empty(&shared_pcfgs)) {
+			pcfg = get_pcfg(&unshared_pcfgs);
+			if (!pcfg) {
+				pr_crit("No QMan portals available!\n");
+				return 0;
+			}
+			cpumask_clear_cpu(pcfg->public_cfg.cpu, &unshared_cpus);
+			cpumask_set_cpu(pcfg->public_cfg.cpu, &shared_cpus);
+			list_add_tail(&pcfg->list, &shared_pcfgs);
 		}
 	}
-	for_each_compatible_node(dn, NULL, "fsl,fqid-range") {
-		use_bpid0 = 0;
-		ret = fsl_fqid_range_init(dn);
-		if (ret)
-			return ret;
+	list_for_each_entry(pcfg, &unshared_pcfgs, list) {
+		pcfg->public_cfg.is_shared = 0;
+		p = init_pcfg(pcfg);
 	}
-	for (cgr.cgrid = 0; cgr.cgrid < __CGR_NUM; cgr.cgrid++) {
-		/* This is to ensure h/w-internal CGR memory is zeroed out. Note
-		 * that we do this for all conceivable CGRIDs, not all of which
-		 * are necessarily available on the underlying hardware version.
-		 * We ignore any errors for this reason. */
-		qman_modify_cgr(&cgr, QMAN_CGR_FLAG_USE_INIT, NULL);
+	list_for_each_entry(pcfg, &shared_pcfgs, list) {
+		pcfg->public_cfg.is_shared = 1;
+		p = init_pcfg(pcfg);
+		if (p)
+			shared_portals[num_shared_portals++] = p;
 	}
-	ret = fqalloc_init(use_bpid0);
-	if (ret)
-		return ret;
+	if (!cpumask_empty(&slave_cpus))
+		for_each_cpu(cpu, &slave_cpus)
+			init_slave(cpu);
 	pr_info("Qman portals initialised\n");
+
+	/* This is to ensure h/w-internal CGR memory is zeroed out. Note that we
+	 * do this for all conceivable CGRIDs, not all of which are necessarily
+	 * available on the underlying hardware version. We ignore any errors
+	 * for this reason. */
+	for (cgr.cgrid = 0; cgr.cgrid < __CGR_NUM; cgr.cgrid++)
+		qman_modify_cgr(&cgr, QMAN_CGR_FLAG_USE_INIT, NULL);
 	return 0;
 }
 subsys_initcall(qman_init);
diff --git a/drivers/staging/fsl_qbman/qman_fqalloc.c b/drivers/staging/fsl_qbman/qman_fqalloc.c
deleted file mode 100644
index 335b96b..0000000
--- a/drivers/staging/fsl_qbman/qman_fqalloc.c
+++ /dev/null
@@ -1,246 +0,0 @@
-/* Copyright 2009-2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "qman_private.h"
-
-#include <linux/fsl_bman.h>
-
-/****************/
-/* FQ allocator */
-/****************/
-
-/* Global flag: use BPID==0 (fq_pool), or use the range-allocator? */
-static int use_bman;
-
-static struct bman_pool *fq_pool;
-static const struct bman_pool_params fq_pool_params;
-
-__init int fqalloc_init(int __use_bman)
-{
-	use_bman = __use_bman;
-	if (use_bman) {
-		fq_pool = bman_new_pool(&fq_pool_params);
-		if (!fq_pool)
-			return -ENOMEM;
-	}
-	return 0;
-}
-
-u32 qm_fq_new(void)
-{
-	struct bm_buffer buf;
-	int ret;
-
-	if (!use_bman) {
-		u32 result;
-		if (qman_alloc_fqid(&result) < 0)
-			return 0;
-		return result;
-	}
-	BUG_ON(!fq_pool);
-	ret = bman_acquire(fq_pool, &buf, 1, 0);
-	if (ret != 1)
-		return 0;
-	return (u32)bm_buffer_get64(&buf);
-}
-EXPORT_SYMBOL(qm_fq_new);
-
-int qm_fq_free_flags(u32 fqid, __maybe_unused u32 flags)
-{
-	struct bm_buffer buf;
-	u32 bflags = 0;
-	int ret;
-	bm_buffer_set64(&buf, fqid);
-
-	if (!use_bman) {
-		qman_release_fqid(fqid);
-		return 0;
-	}
-#ifdef CONFIG_FSL_DPA_CAN_WAIT
-	if (flags & QM_FQ_FREE_WAIT) {
-		bflags |= BMAN_RELEASE_FLAG_WAIT;
-		if (flags & BMAN_RELEASE_FLAG_WAIT_INT)
-			bflags |= BMAN_RELEASE_FLAG_WAIT_INT;
-		if (flags & BMAN_RELEASE_FLAG_WAIT_SYNC)
-			bflags |= BMAN_RELEASE_FLAG_WAIT_SYNC;
-	}
-#endif
-	ret = bman_release(fq_pool, &buf, 1, bflags);
-	return ret;
-}
-EXPORT_SYMBOL(qm_fq_free_flags);
-
-/* Global state for the allocator */
-static DEFINE_SPINLOCK(alloc_lock);
-static LIST_HEAD(alloc_list);
-
-/* The allocator is a (possibly-empty) list of these; */
-struct alloc_node {
-	struct list_head list;
-	u32 base;
-	u32 num;
-};
-
-/* #define FQRANGE_DEBUG */
-
-#ifdef FQRANGE_DEBUG
-#define DPRINT		pr_info
-static void DUMP(void)
-{
-	int off = 0;
-	char buf[256];
-	struct alloc_node *p;
-	list_for_each_entry(p, &alloc_list, list) {
-		if (off < 255)
-			off += snprintf(buf + off, 255-off, "{%d,%d}",
-				p->base, p->base + p->num - 1);
-	}
-	pr_info("%s\n", buf);
-}
-#else
-#define DPRINT(x...)	do { ; } while(0)
-#define DUMP()		do { ; } while(0)
-#endif
-
-int qman_alloc_fqid_range(u32 *result, u32 count, u32 align, int partial)
-{
-	struct alloc_node *i = NULL, *next_best = NULL;
-	u32 base, next_best_base = 0, num = 0, next_best_num = 0;
-	struct alloc_node *margin_left, *margin_right;
-
-	*result = (u32)-1;
-	DPRINT("alloc_range(%d,%d,%d)\n", count, align, partial);
-	DUMP();
-	/* If 'align' is 0, it should behave as though it was 1 */
-	if (!align)
-		align = 1;
-	margin_left = kmalloc(sizeof(*margin_left), GFP_KERNEL);
-	if (!margin_left)
-		goto err;
-	margin_right = kmalloc(sizeof(*margin_right), GFP_KERNEL);
-	if (!margin_right) {
-		kfree(margin_left);
-		goto err;
-	}
-	spin_lock_irq(&alloc_lock);
-	list_for_each_entry(i, &alloc_list, list) {
-		base = (i->base + align - 1) / align;
-		base *= align;
-		if ((base - i->base) >= i->num)
-			/* alignment is impossible, regardless of count */
-			continue;
-		num = i->num - (base - i->base);
-		if (num >= count) {
-			/* this one will do nicely */
-			num = count;
-			goto done;
-		}
-		if (num > next_best_num) {
-			next_best = i;
-			next_best_base = base;
-			next_best_num = num;
-		}
-	}
-	if (partial && next_best) {
-		i = next_best;
-		base = next_best_base;
-		num = next_best_num;
-	} else
-		i = NULL;
-done:
-	if (i) {
-		if (base != i->base) {
-			margin_left->base = i->base;
-			margin_left->num = base - i->base;
-			list_add_tail(&margin_left->list, &i->list);
-		} else
-			kfree(margin_left);
-		if ((base + num) < (i->base + i->num)) {
-			margin_right->base = base + num;
-			margin_right->num = (i->base + i->num) -
-						(base + num);
-			list_add(&margin_right->list, &i->list);
-		} else
-			kfree(margin_right);
-		list_del(&i->list);
-		kfree(i);
-		*result = base;
-	}
-	spin_unlock_irq(&alloc_lock);
-err:
-	DPRINT("returning %d\n", i ? num : -ENOMEM);
-	DUMP();
-	return i ? (int)num : -ENOMEM;
-}
-EXPORT_SYMBOL(qman_alloc_fqid_range);
-
-void qman_release_fqid_range(u32 fqid, u32 count)
-{
-	struct alloc_node *i, *node = kmalloc(sizeof(*node), GFP_KERNEL);
-	DPRINT("release_range(%d,%d)\n", fqid, count);
-	DUMP();
-	spin_lock_irq(&alloc_lock);
-	node->base = fqid;
-	node->num = count;
-	list_for_each_entry(i, &alloc_list, list) {
-		if (i->base >= node->base) {
-			list_add_tail(&node->list, &i->list);
-			goto done;
-		}
-	}
-	list_add_tail(&node->list, &alloc_list);
-done:
-	/* Merge to the left */
-	i = list_entry(node->list.prev, struct alloc_node, list);
-	if (node->list.prev != &alloc_list) {
-		BUG_ON((i->base + i->num) > node->base);
-		if ((i->base + i->num) == node->base) {
-			node->base = i->base;
-			node->num += i->num;
-			list_del(&i->list);
-			kfree(i);
-		}
-	}
-	/* Merge to the right */
-	i = list_entry(node->list.next, struct alloc_node, list);
-	if (node->list.next != &alloc_list) {
-		BUG_ON((node->base + node->num) > i->base);
-		if ((node->base + node->num) == i->base) {
-			node->num += i->num;
-			list_del(&i->list);
-			kfree(i);
-		}
-	}
-	spin_unlock_irq(&alloc_lock);
-	DUMP();
-}
-EXPORT_SYMBOL(qman_release_fqid_range);
-
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index fc4bc4c..49e89b9 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -1,4 +1,4 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -1067,9 +1067,9 @@ int qman_create_fq(u32 fqid, u32 flags, struct qman_fq *fq)
 	unsigned long irqflags __maybe_unused;
 
 	if (flags & QMAN_FQ_FLAG_DYNAMIC_FQID) {
-		fqid = qm_fq_new();
-		if (!fqid)
-			return -ENOMEM;
+		int ret = qman_alloc_fqid(&fqid);
+		if (ret)
+			return ret;
 	}
 	spin_lock_init(&fq->fqlock);
 	fq->fqid = fqid;
@@ -1140,7 +1140,7 @@ err:
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	if (flags & QMAN_FQ_FLAG_DYNAMIC_FQID)
-		qm_fq_free(fqid);
+		qman_release_fqid(fqid);
 	return -EIO;
 }
 EXPORT_SYMBOL(qman_create_fq);
@@ -1154,7 +1154,7 @@ void qman_destroy_fq(struct qman_fq *fq, u32 flags __maybe_unused)
 		DPA_ASSERT(flags & QMAN_FQ_DESTROY_PARKED);
 	case qman_fq_state_oos:
 		if (fq_isset(fq, QMAN_FQ_FLAG_DYNAMIC_FQID))
-			qm_fq_free(fq->fqid);
+			qman_release_fqid(fq->fqid);
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
 		clear_fq_table_entry(fq->key);
 #endif
@@ -2070,4 +2070,3 @@ put_portal:
 	return ret;
 }
 EXPORT_SYMBOL(qman_delete_cgr);
-
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index 84e4062..3e4347c 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -1,4 +1,4 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -122,9 +122,6 @@ struct qm_portal_config {
 	struct qman_portal_config public_cfg;
 };
 
-/* Hooks for driver initialisation */
-__init int fqalloc_init(int use_bman);
-
 /* Revision info (for errata and feature handling) */
 #define QMAN_REV10 0x0100
 #define QMAN_REV11 0x0101
diff --git a/drivers/staging/fsl_qbman/qman_test_hotpotato.c b/drivers/staging/fsl_qbman/qman_test_hotpotato.c
index 5daa431..0f9e301 100644
--- a/drivers/staging/fsl_qbman/qman_test_hotpotato.c
+++ b/drivers/staging/fsl_qbman/qman_test_hotpotato.c
@@ -1,4 +1,4 @@
-/* Copyright 2009-2011 Freescale Semiconductor, Inc.
+/* Copyright 2009-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -311,7 +311,7 @@ static void destroy_per_cpu_handlers(void)
 			panic("qman_oos_fq(rx) failed");
 		qman_destroy_fq(&handler->rx, 0);
 		qman_destroy_fq(&handler->tx, 0);
-		qm_fq_free(handler->fqid_rx);
+		qman_release_fqid(handler->fqid_rx);
 		list_del(&handler->node);
 		kmem_cache_free(hp_handler_slab, handler);
 	}
@@ -368,6 +368,7 @@ static void init_phase2(void)
 
 	for (loop = 0; loop < HP_PER_CPU; loop++) {
 		list_for_each_entry(hp_cpu, &hp_cpu_list, node) {
+			int ret;
 			if (!loop)
 				hp_cpu->iterator = list_first_entry(
 						&hp_cpu->handlers,
@@ -379,9 +380,9 @@ static void init_phase2(void)
 			/* Rx FQID is the previous handler's Tx FQID */
 			hp_cpu->iterator->fqid_rx = fqid;
 			/* Allocate new FQID for Tx */
-			fqid = qm_fq_new();
-			if (!fqid)
-				panic("qm_fq_new() failed");
+			ret = qman_alloc_fqid(&fqid);
+			if (ret)
+				panic("qman_alloc_fqid() failed");
 			hp_cpu->iterator->fqid_tx = fqid;
 			/* Rx mixer is the previous handler's Tx mixer */
 			hp_cpu->iterator->rx_mixer = lfsr;
diff --git a/include/linux/fsl_bman.h b/include/linux/fsl_bman.h
index cf4cbae..8c0af38 100644
--- a/include/linux/fsl_bman.h
+++ b/include/linux/fsl_bman.h
@@ -1,4 +1,4 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -370,6 +370,39 @@ void bman_poll(void);
  */
 int bman_rcr_is_empty(void);
 
+/**
+ * bman_alloc_bpid_range - Allocate a contiguous range of BPIDs
+ * @result: is set by the API to the base BPID of the allocated range
+ * @count: the number of BPIDs required
+ * @align: required alignment of the allocated range
+ * @partial: non-zero if the API can return fewer than @count BPIDs
+ *
+ * Returns the number of buffer pools allocated, or a negative error code. If
+ * @partial is non zero, the allocation request may return a smaller range of
+ * BPs than requested (though alignment will be as requested). If @partial is
+ * zero, the return value will either be 'count' or negative.
+ */
+int bman_alloc_bpid_range(u32 *result, u32 count, u32 align, int partial);
+static inline int bman_alloc_bpid(u32 *result)
+{
+	int ret = bman_alloc_bpid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+
+/**
+ * bman_release_bpid_range - Release the specified range of buffer pool IDs
+ * @bpid: the base BPID of the range to deallocate
+ * @count: the number of BPIDs in the range
+ *
+ * This function can also be used to seed the allocator with ranges of BPIDs
+ * that it can subsequently allocate from. Returns zero for success.
+ */
+void bman_release_bpid_range(u32 bpid, unsigned int count);
+static inline void bman_release_bpid(u32 bpid)
+{
+	bman_release_bpid_range(bpid, 1);
+}
+
 
 	/* Pool management */
 	/* --------------- */
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 223067b..f9edf85 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1,4 +1,4 @@
-/* Copyright 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright 2008-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -78,33 +78,6 @@ enum qm_dc_portal {
 #define QM_PIRQ_SLOW	(QM_PIRQ_CSCI | QM_PIRQ_EQCI | QM_PIRQ_EQRI | \
 			QM_PIRQ_MRI)
 
-
-/* ------------------------ */
-/* --- FQ allocator API --- */
-
-/* Flags to qm_fq_free_flags() */
-#ifdef CONFIG_FSL_DPA_CAN_WAIT
-#define QM_FQ_FREE_WAIT       0x00000001 /* wait if RCR is full */
-#define QM_FQ_FREE_WAIT_INT   0x00000002 /* if wait, interruptible? */
-#ifdef CONFIG_FSL_DPA_CAN_WAIT_SYNC
-#define QM_FQ_FREE_WAIT_SYNC  0x00000004 /* if wait, until consumed? */
-#endif
-#endif
-
-/* Allocate an unused FQID from the FQ allocator, returns zero for failure */
-u32 qm_fq_new(void);
-/* Release a FQID back to the FQ allocator */
-int qm_fq_free_flags(u32 fqid, u32 flags);
-#ifdef CONFIG_FSL_DPA_CAN_WAIT
-static inline void qm_fq_free(u32 fqid)
-{
-	if (qm_fq_free_flags(fqid, QM_FQ_FREE_WAIT))
-		BUG();
-}
-#else
-#define qm_fq_free(fqid) qm_fq_free_flags(fqid, 0)
-#endif
-
 /* For qman_static_dequeue_*** APIs */
 #define QM_SDQCR_CHANNELS_POOL_MASK	0x00007fff
 /* for n in [1,15] */
@@ -1632,7 +1605,7 @@ int qman_enqueue_orp(struct qman_fq *fq, const struct qm_fd *fd, u32 flags,
  * @count: the number of FQIDs required
  * @align: required alignment of the allocated range
  * @partial: non-zero if the API can return fewer than @count FQIDs
-
+ *
  * Returns the number of frame queues allocated, or a negative error code. If
  * @partial is non zero, the allocation request may return a smaller range of
  * FQs than requested (though alignment will be as requested). If @partial is
@@ -1641,7 +1614,8 @@ int qman_enqueue_orp(struct qman_fq *fq, const struct qm_fd *fd, u32 flags,
 int qman_alloc_fqid_range(u32 *result, u32 count, u32 align, int partial);
 static inline int qman_alloc_fqid(u32 *result)
 {
-	return qman_alloc_fqid_range(result, 1, 0, 0);
+	int ret = qman_alloc_fqid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
 }
 
 /**
@@ -1650,7 +1624,7 @@ static inline int qman_alloc_fqid(u32 *result)
  * @count: the number of FQIDs in the range
  *
  * This function can also be used to seed the allocator with ranges of FQIDs
- * that it can subsequently use. Returns zero for success.
+ * that it can subsequently allocate from. Returns zero for success.
  */
 void qman_release_fqid_range(u32 fqid, unsigned int count);
 static inline void qman_release_fqid(u32 fqid)
-- 
1.7.9.7

