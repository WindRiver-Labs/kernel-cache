From 7853b6b996e6e2d3dcfccb8008cc662968c37ad1 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Thu, 3 Nov 2011 13:53:00 -0500
Subject: [PATCH 067/128] qman: remove CONFIG_FSL_QMAN_NULL_FQ_DEMUX

The current implementation of this feature is complicating other
development work, in part because it was not implemented properly.
Eg. the use of the "struct qman_fq_cb" type implies a default ERN
handler, yet s/w ERN handling by its nature can not be part of NULL
demuxing - enqueues require a FQ object, so that is the object that
the ERN demuxes to, so there is no NULL case. (In particular, ERNs
demux using a "tag" field that is copied from the enqueue command
because there is no "contextB" in this path of the qman interface,
whereas NULL_FQ_DEMUX is all about setting contextB to zero...)

In terms of use-cases, DC_ERN handling is the only aspect of this
feature that is a known requirement, and that case is outright broken
in the current implementation (I have reimplemented DC_ERN handling
via a new interface in a subsequent patch).

Finally, for these kind of handlers (ie. not based on FQ objects) to
be flexible, it should be possible to set them globally (ie. for use
by all portals managed by the driver instance) which the current
implementation doesn't allow. Ie. if users want the same behaviour for
each portal/core, they shouldn't have to repeat the same API call for
all of them. This NULL_FQ_DEMUX feature will be reimplemented properly
once the current rework is done.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/Kconfig        |   12 -----
 drivers/staging/fsl_qbman/qman_driver.c  |   27 ----------
 drivers/staging/fsl_qbman/qman_high.c    |   86 +++++-------------------------
 drivers/staging/fsl_qbman/qman_private.h |    1 -
 include/linux/fsl_qman.h                 |   26 +--------
 5 files changed, 13 insertions(+), 139 deletions(-)

diff --git a/drivers/staging/fsl_qbman/Kconfig b/drivers/staging/fsl_qbman/Kconfig
index dd20878..8849edc 100644
--- a/drivers/staging/fsl_qbman/Kconfig
+++ b/drivers/staging/fsl_qbman/Kconfig
@@ -138,18 +138,6 @@ config FSL_QMAN_PORTAL_DISABLEAUTO_DCA
 	  discrete-consumption acknowledgements, but this may be unimplemented
 	  in the simulation model.
 
-config FSL_QMAN_NULL_FQ_DEMUX
-	bool "support NULL demux handlers"
-	default y
-	---help---
-	  Normally, incoming frame dequeues and messages from Qman to a software
-	  portal provide a direct demux to the owner of the corresponding FQ.
-	  However, exotic "zero-conf" possibilities can be supported if other
-	  cpus (or operating systems) can schedule "NULL" FQs to a receiver's
-	  portal. If this option is selected, the driver will support this
-	  feature, but it adds a small overhead to the hottest-path in the
-	  driver, so it should be disabled unless needed.
-
 config FSL_QMAN_CONFIG
 	bool "Qman device management"
 	default y
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 4b8b018..cf9ca12 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -55,30 +55,6 @@ const struct dpa_uio_class *dpa_uio_qman(void)
 }
 EXPORT_SYMBOL(dpa_uio_qman);
 
-#ifdef CONFIG_FSL_QMAN_NULL_FQ_DEMUX
-/* Handlers for NULL portal callbacks (ie. where the contextB field, normally
- * pointing to the corresponding FQ object, is NULL). */
-static enum qman_cb_dqrr_result null_cb_dqrr(struct qman_portal *qm,
-					struct qman_fq *fq,
-					const struct qm_dqrr_entry *dqrr)
-{
-	pr_warning("Ignoring unowned DQRR frame on portal %p.\n", qm);
-	return qman_cb_dqrr_consume;
-}
-static void null_cb_mr(struct qman_portal *qm, struct qman_fq *fq,
-			const struct qm_mr_entry *msg)
-{
-	pr_warning("Ignoring unowned MR msg on portal %p, verb 0x%02x.\n",
-			qm, msg->verb);
-}
-static const struct qman_fq_cb null_cb = {
-	.dqrr = null_cb_dqrr,
-	.ern = null_cb_mr,
-	.dc_ern = null_cb_mr,
-	.fqs = null_cb_mr
-};
-#endif
-
 #ifdef CONFIG_FSL_QMAN_PORTAL
 /* This structure carries parameters from the device-tree handling code that
  * wants to set up a portal for use on 1 or more CPUs, and each temporary thread
@@ -105,9 +81,6 @@ static __init int thread_init_affine_portal(void *__data)
 	else {
 		/* TODO: cgrs ?? */
 		data->portal = qman_create_affine_portal(pconfig, NULL,
-#ifdef CONFIG_FSL_QMAN_NULL_FQ_DEMUX
-				&null_cb,
-#endif
 				data->recovery_mode);
 		if (data->portal) {
 			u32 irq_sources = 0;
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index f454735..e1a529f 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -90,12 +90,6 @@ struct qman_portal {
 #endif
 	u32 sdqcr;
 	int dqrr_disable_ref;
-#ifdef CONFIG_FSL_QMAN_NULL_FQ_DEMUX
-	/* If we receive a DQRR or MR ring entry for a "null" FQ, ie. for which
-	 * FQD::contextB is NULL rather than pointing to a FQ object, we use
-	 * these handlers. (This is not considered a fast-path mechanism.) */
-	struct qman_fq_cb null_cb;
-#endif
 	/* When the cpu-affine portal is activated, this is non-NULL */
 	const struct qm_portal_config *config;
 	/* This is needed for providing a non-NULL device to dma_map_***() */
@@ -355,7 +349,6 @@ static void post_recovery(struct qman_portal *p __always_unused,
 struct qman_portal *qman_create_affine_portal(
 			const struct qm_portal_config *config,
 			const struct qman_cgrs *cgrs,
-			const struct qman_fq_cb *null_cb,
 			int recovery_mode)
 {
 	struct qman_portal *portal = get_raw_affine_portal();
@@ -369,12 +362,6 @@ struct qman_portal *qman_create_affine_portal(
 	 * This means we can put_affine_portal() and yet continue to use
 	 * "portal", which in turn means aspects of this routine can sleep. */
 	put_affine_portal();
-#ifndef CONFIG_FSL_QMAN_NULL_FQ_DEMUX
-	if (null_cb) {
-		pr_err("Driver does not support 'NULL FQ' callbacks\n");
-		return NULL;
-	}
-#endif
 	/* prep the low-level portal struct with the mapped addresses from the
 	 * config, everything that follows depends on it and "config" is more
 	 * for (de)reference... */
@@ -477,12 +464,6 @@ drain_loop:
 			QM_SDQCR_DEDICATED_PRECEDENCE | QM_SDQCR_TYPE_PRIO_QOS |
 			QM_SDQCR_TOKEN_SET(0xab) | QM_SDQCR_CHANNELS_DEDICATED;
 	portal->dqrr_disable_ref = 0;
-#ifdef CONFIG_FSL_QMAN_NULL_FQ_DEMUX
-	if (null_cb)
-		portal->null_cb = *null_cb;
-	else
-		memset(&portal->null_cb, 0, sizeof(*null_cb));
-#endif
 	sprintf(buf, "qportal-%d", config->public_cfg.channel);
 	portal->pdev = platform_device_alloc(buf, -1);
 	if (!portal->pdev)
@@ -645,24 +626,6 @@ const struct qman_portal_config *qman_get_portal_config(void)
 }
 EXPORT_SYMBOL(qman_get_portal_config);
 
-#ifdef CONFIG_FSL_QMAN_NULL_FQ_DEMUX
-void qman_get_null_cb(struct qman_fq_cb *null_cb)
-{
-	struct qman_portal *p = get_affine_portal();
-	*null_cb = p->null_cb;
-	put_affine_portal();
-}
-EXPORT_SYMBOL(qman_get_null_cb);
-
-void qman_set_null_cb(const struct qman_fq_cb *null_cb)
-{
-	struct qman_portal *p = get_affine_portal();
-	p->null_cb = *null_cb;
-	put_affine_portal();
-}
-EXPORT_SYMBOL(qman_set_null_cb);
-#endif
-
 /* Inline helper to reduce nesting in __poll_portal_slow() */
 static inline void fq_state_change(struct qman_portal *p, struct qman_fq *fq,
 				const struct qm_mr_entry *msg, u8 verb)
@@ -784,17 +747,6 @@ mr_loop:
 				else
 					fq->cb.dc_ern(p, fq, msg);
 			}
-#ifdef CONFIG_FSL_QMAN_NULL_FQ_DEMUX
-			else {
-				/* use portal default handlers for 'null's */
-				if (likely(!(verb & QM_MR_VERB_DC_ERN)))
-					p->null_cb.ern(p, NULL, msg);
-				else if (verb == QM_MR_VERB_DC_ERN)
-					p->null_cb.dc_ern(p, NULL, msg);
-				else if (p->null_cb.fqs)
-					p->null_cb.fqs(p, NULL, msg);
-			}
-#endif
 			num++;
 			qm_mr_next(&p->p);
 			goto mr_loop;
@@ -883,22 +835,12 @@ loop:
 #else
 		fq = (void *)(uintptr_t)dq->contextB;
 #endif
-#ifdef CONFIG_FSL_QMAN_NULL_FQ_DEMUX
-		if (unlikely(!fq)) {
-			/* use portal default handlers */
-			res = p->null_cb.dqrr(p, NULL, dq);
-			DPA_ASSERT(res == qman_cb_dqrr_consume);
-			res = qman_cb_dqrr_consume;
-		} else
-#endif
-		{
-			/* Now let the callback do its stuff */
-			res = fq->cb.dqrr(p, fq, dq);
-			/* The callback can request that we exit without
-			 * consuming this entry nor advancing; */
-			if (res == qman_cb_dqrr_stop)
-				goto done;
-		}
+		/* Now let the callback do its stuff */
+		res = fq->cb.dqrr(p, fq, dq);
+		/* The callback can request that we exit without consuming this
+		 * entry nor advancing; */
+		if (res == qman_cb_dqrr_stop)
+			goto done;
 	}
 	/* Interpret 'dq' from a driver perspective. */
 	/* Parking isn't possible unless HELDACTIVE was set. NB,
@@ -1500,20 +1442,16 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 		mcc->initfq = *opts;
 	mcc->initfq.fqid = fq->fqid;
 	mcc->initfq.count = 0;
-	/* If INITFQ_FLAG_NULL is passed, contextB is set to zero. Otherwise,
-	 * if the FQ does *not* have the TO_DCPORTAL flag, contextB is set as a
-	 * demux pointer. Otherwise, TO_DCPORTAL is set, so the caller-provided
-	 * value is allowed to stand, don't overwrite it. */
-	if ((flags & QMAN_INITFQ_FLAG_NULL) ||
-			fq_isclear(fq, QMAN_FQ_FLAG_TO_DCPORTAL)) {
+	/* If the FQ does *not* have the TO_DCPORTAL flag, contextB is set as a
+	 * demux pointer. Otherwise, the caller-provided value is allowed to
+	 * stand, don't overwrite it. */
+	if (fq_isclear(fq, QMAN_FQ_FLAG_TO_DCPORTAL)) {
 		dma_addr_t phys_fq;
 		mcc->initfq.we_mask |= QM_INITFQ_WE_CONTEXTB;
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
-		mcc->initfq.fqd.context_b = (flags & QMAN_INITFQ_FLAG_NULL) ?
-						0 : fq->key;
+		mcc->initfq.fqd.context_b = fq->key;
 #else
-		mcc->initfq.fqd.context_b = (flags & QMAN_INITFQ_FLAG_NULL) ?
-						0 : (u32)(uintptr_t)fq;
+		mcc->initfq.fqd.context_b = (u32)(uintptr_t)fq;
 #endif
 		/* and the physical address - NB, if the user wasn't trying to
 		 * set CONTEXTA, clear the stashing settings. */
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index 0ac0a59..6f5004b 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -142,7 +142,6 @@ void qman_liodn_fixup(enum qm_channel channel);
 struct qman_portal *qman_create_affine_portal(
 			const struct qm_portal_config *config,
 			const struct qman_cgrs *cgrs,
-			const struct qman_fq_cb *null_cb,
 			int recovery_mode);
 struct qman_portal *qman_create_affine_slave(struct qman_portal *redirect);
 const struct qm_portal_config *qman_destroy_affine_portal(void);
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index cd04f74..78e1494 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1139,7 +1139,6 @@ struct qman_cgr {
 
 /* Flags to qman_init_fq() */
 #define QMAN_INITFQ_FLAG_SCHED       0x00000001 /* schedule rather than park */
-#define QMAN_INITFQ_FLAG_NULL        0x00000002 /* zero 'contextB', no demux */
 #define QMAN_INITFQ_FLAG_LOCAL       0x00000004 /* set dest portal */
 
 /* Flags to qman_volatile_dequeue() */
@@ -1192,23 +1191,6 @@ struct qman_cgr {
  */
 const struct qman_portal_config *qman_get_portal_config(void);
 
-#ifdef CONFIG_FSL_QMAN_NULL_FQ_DEMUX
-/**
- * qman_get_null_cb - get callbacks currently used for "null" frame queues
- *
- * Copies the callbacks used for the affine portal of the current cpu.
- */
-void qman_get_null_cb(struct qman_fq_cb *null_cb);
-
-/**
- * qman_set_null_cb - set callbacks to use for "null" frame queues
- *
- * Sets the callbacks to use for the affine portal of the current cpu, whenever
- * a DQRR or MR entry refers to a "null" FQ object. (Eg. zero-conf messaging.)
- */
-void qman_set_null_cb(const struct qman_fq_cb *null_cb);
-#endif
-
 /**
  * qman_irqsource_get - return the portal work that is interrupt-driven
  *
@@ -1438,11 +1420,7 @@ void qman_fq_state(struct qman_fq *fq, enum qman_fq_state *state, u32 *flags);
  *
  * The @opts parameter comes from the low-level portal API. Select
  * QMAN_INITFQ_FLAG_SCHED in @flags to cause the frame queue to be scheduled
- * rather than parked. Select QMAN_INITFQ_FLAG_NULL in @flags to configure a
- * frame queue that will not demux to a 'struct qman_fq' object when dequeued
- * frames or messages arrive at a software portal, but which will instead
- * trigger the portal's 'null_cb' callbacks (see qman_create_portal()). NB,
- * @opts can be NULL.
+ * rather than parked. NB, @opts can be NULL.
  *
  * Note that some fields and options within @opts may be ignored or overwritten
  * by the driver;
@@ -1450,8 +1428,6 @@ void qman_fq_state(struct qman_fq *fq, enum qman_fq_state *state, u32 *flags);
  * affects one frame queue: @fq).
  * 2. the QM_INITFQ_WE_CONTEXTB option of the 'we_mask' field and the associated
  * 'fqd' structure's 'context_b' field are sometimes overwritten;
- *   - if @flags contains QMAN_INITFQ_FLAG_NULL, then context_b is initialised
- *     to zero by the driver,
  *   - if @fq was not created with QMAN_FQ_FLAG_TO_DCPORTAL, then context_b is
  *     initialised to a value used by the driver for demux.
  *   - if context_b is initialised for demux, so is context_a in case stashing
-- 
1.7.9.7

