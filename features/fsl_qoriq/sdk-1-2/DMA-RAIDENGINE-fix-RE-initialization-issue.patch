From 262955221eae26590722eafe2c07f45b18a59934 Mon Sep 17 00:00:00 2001
From: Xuelin Shi <b29237@freescale.com>
Date: Sat, 5 May 2012 13:50:13 +0000
Subject: [PATCH 117/121] DMA/RAIDENGINE: fix RE initialization issue.

RM says the default value for GFM CFG polynomial register is 0x4d.
Anyway, this value is not correct to generate Q parity.
Debugged with hardware guy and found correct value should be 0x1d.

The GenQQ cmd has requirement of 32bit alignment for GFM_Q1 and GFMQ2.
The alignment rule like below:
        src_cnt<=4, GFM_Q1 occupy 4 bytes
	src_cnt<=8, GFM_Q1 occupy 8 bytes
	src_cnt<=12, GFM_Q1 occupy 12 bytes
	src_cnt<=16, GFM_Q1 occupy 16 bytes
GFM-Q2 also follow this rule and there is no padding between these two
arrays.

This patch programs the GFM CFG polynomial register as 0x1d and enforce
GFM_Q aligment rules.

Signed-off-by: Xuelin Shi <b29237@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/dma/fsl_raid.c |   42 ++++++++++++++++++++----------------------
 drivers/dma/fsl_raid.h |    1 +
 2 files changed, 21 insertions(+), 22 deletions(-)

diff --git a/drivers/dma/fsl_raid.c b/drivers/dma/fsl_raid.c
index 3a3b391..a61453b 100644
--- a/drivers/dma/fsl_raid.c
+++ b/drivers/dma/fsl_raid.c
@@ -550,9 +550,8 @@ static struct dma_async_tx_descriptor *re_jr_prep_pq(
 	struct pq_cdb *pq = NULL;
 	u8 cfs_reqd = src_cnt + 3; /* CDB+P+Q+src_cnt */
 	struct cmpnd_frame *cf;
-	u8 i = 0;
-	u8 j = 0;
-	int ret = 0;
+	u8 *p;
+	int ret = 0, gfmq_len, i, j;
 
 	if (len > MAX_DATA_LENGTH) {
 		pr_err("%s: Length greater than %d not supported\n",
@@ -625,28 +624,22 @@ static struct dma_async_tx_descriptor *re_jr_prep_pq(
 	pq->dpi = ENABLE_DPI;
 	pq->nrcs = (src_cnt - 1);
 
-	for (i = 0; i < src_cnt; i++) {
-		pq->gfm_q1[i] = 1;
-		pq->gfm_q2[i] = scf[i];
-		pq->dpi_src_spec[i].apps_mthd = 0x0;
-		pq->dpi_src_spec[i].ref_mthd = 0x0;
-		pq->dpi_src_spec[i].guard_mthd = 0x0;
-		pq->dpi_src_spec[i].dpi_attr = 0x0;
-		pq->dpi_src_spec[i].meta_tag = 0x0;
-		pq->dpi_src_spec[i].ref_tag = 0x0;
-	}
+	p = pq->gfm_q1;
+	/* Init gfm_q1[] */
+	for (i = 0; i < src_cnt; i++)
+		p[i] = 1;
 
-	for (j = 0; j < 2; j++) {
-		pq->dpi_dest_spec[j].apps_mthd = 0x0;
-		pq->dpi_dest_spec[j].ref_mthd = 0x0;
-		pq->dpi_dest_spec[j].guard_mthd = 0x0;
-		pq->dpi_dest_spec[j].dpi_attr = 0x0;
-		pq->dpi_dest_spec[j].meta_tag = 0x0;
-		pq->dpi_dest_spec[j].ref_tag = 0x0;
-	}
+	/* Align gfm[] to 32bit */
+	gfmq_len = ((src_cnt+3)/4)*4;
+
+	/* Init gfm_q2[] */
+	p += gfmq_len;
+	for (i = 0; i < src_cnt; i++)
+		p[i] = scf[i];
 
 	/* Filling frame 0 of compound frame descriptor with CDB */
-	ret = fill_cfd_frame_with_cdb(cf, jr, pq, sizeof(struct pq_cdb));
+	ret = fill_cfd_frame_with_cdb(cf, jr, pq,
+			sizeof(struct pq_cdb)-32+2*gfmq_len);
 	if (ret < 0) {
 		pr_err("%s: Can't map pq_cdb\n", __func__);
 		ret = -EIO;
@@ -1035,6 +1028,11 @@ static int __devinit raide_probe(struct platform_device *ofdev)
 	dev_info(dev, "%s:RE mode is %x\n", __func__,
 			in_be32(&repriv->re_regs->global_config));
 
+	/* Program Galois Field polymomial */
+	out_be32(&repriv->re_regs->galois_field_config, RE_GFM_POLY);
+	dev_info(dev, "%s:Galois Field Polymomial is %x\n", __func__,
+			in_be32(&repriv->re_regs->galois_field_config));
+
 	dma_dev = &repriv->dma_dev;
 	dma_dev->dev = dev;
 	INIT_LIST_HEAD(&dma_dev->channels);
diff --git a/drivers/dma/fsl_raid.h b/drivers/dma/fsl_raid.h
index d6f8537..29ca6b9 100644
--- a/drivers/dma/fsl_raid.h
+++ b/drivers/dma/fsl_raid.h
@@ -40,6 +40,7 @@
 
 #define RE_DPAA_MODE		(1 << 30)
 #define RE_NON_DPAA_MODE	(1 << 31)
+#define RE_GFM_POLY		(0x1d000000)
 #define RE_JR_INB_JOB_ADD	(1 << 16)
 #define RE_JR_OUB_JOB_REMOVE	(1 << 16)
 #define RE_JR_CFG1_CBSI		0x08000000
-- 
1.7.9.7

