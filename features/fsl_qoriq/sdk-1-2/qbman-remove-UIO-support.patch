From 846729573a28096387e7ab44f0d90330507fb869 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 14 Mar 2012 04:49:38 +0000
Subject: [PATCH 072/121] qbman: remove UIO support

As with recovery support, UIO too needs to be pulled out in order to
transition the portal initialisation usage to a more dynamic and
modular form. UIO support will be added back in in a way that better
suits the less statically-assigned model we're moving to.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin:  Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image. Remove the mods for
the specific board's dts.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/Kconfig       |    8 --
 drivers/staging/fsl_qbman/Makefile      |    3 -
 drivers/staging/fsl_qbman/bman_driver.c |   26 ----
 drivers/staging/fsl_qbman/dpa_sys.h     |   26 ----
 drivers/staging/fsl_qbman/dpa_uio.c     |  200 -------------------------------
 drivers/staging/fsl_qbman/qman_driver.c |   24 ----
 6 files changed, 287 deletions(-)
 delete mode 100644 drivers/staging/fsl_qbman/dpa_uio.c

diff --git a/drivers/staging/fsl_qbman/Kconfig b/drivers/staging/fsl_qbman/Kconfig
index af3a776..a35aeeb0 100644
--- a/drivers/staging/fsl_qbman/Kconfig
+++ b/drivers/staging/fsl_qbman/Kconfig
@@ -34,14 +34,6 @@ config FSL_DPA_PORTAL_SHARE
 	bool
 	default y
 
-config FSL_DPA_UIO
-	tristate "Export USDPAA portals via UIO"
-	depends on UIO
-	default y
-	---help---
-	  Portals are exported as UIO devices for use by USDPAA (User
-	  Space DataPath Acceleration Architecture) applications.
-
 config FSL_BMAN
 	bool "Freescale Buffer Manager support"
 	default y
diff --git a/drivers/staging/fsl_qbman/Makefile b/drivers/staging/fsl_qbman/Makefile
index 334055f..f740092 100644
--- a/drivers/staging/fsl_qbman/Makefile
+++ b/drivers/staging/fsl_qbman/Makefile
@@ -18,6 +18,3 @@ qman_tester-y			 = qman_test.o qman_test_hotpotato.o \
 qman_tester-$(CONFIG_FSL_QMAN_TEST_ERRATA) += qman_test_errata.o
 obj-$(CONFIG_FSL_QMAN_DEBUGFS) += qman_debugfs_interface.o
 qman_debugfs_interface-y	= qman_debugfs.o
-
-# USDPAA
-obj-$(CONFIG_FSL_DPA_UIO)	+= dpa_uio.o
diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 7116a53..085aa42 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -58,16 +58,6 @@ static u8 num_pools;
 static DEFINE_SPINLOCK(pools_lock);
 static int explicit_allocator;
 
-static struct dpa_uio_class bman_uio = {
-	.list = LIST_HEAD_INIT(bman_uio.list),
-	.dev_prefix = "bman-uio-"
-};
-const struct dpa_uio_class *dpa_uio_bman(void)
-{
-	return &bman_uio;
-}
-EXPORT_SYMBOL(dpa_uio_bman);
-
 static int __bm_pool_add(u32 bpid, u32 *cfg, int triplets)
 {
 	u64 total = 0;
@@ -241,20 +231,6 @@ static struct bm_portal_config * __init fsl_bman_portal_init(
 	pcfg->public_cfg.index = *index;
 	bman_depletion_fill(&pcfg->public_cfg.mask);
 
-	if (of_get_property(node, "fsl,usdpaa-portal", &ret)) {
-		struct dpa_uio_portal *u = kmalloc(sizeof(*u), GFP_KERNEL);
-		if (!u)
-			goto err;
-		u->type = dpa_uio_portal_bman;
-		u->bm_cfg = pcfg;
-		list_add_tail(&u->node, &bman_uio.list);
-		/* Return NULL, otherwise the kernel may share it on CPUs that
-		 * don't have their own portals, which would be ... *bad*. */
-		return NULL;
-	}
-
-	/* Map the portals now we know they aren't for UIO (the UIO code doesn't
-	 * need the CE mapping, and so will do its own CI-only mapping). */
 	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_prot(
 				pcfg->addr_phys[DPA_PORTAL_CE].start,
 				resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]),
@@ -457,8 +433,6 @@ static __init int bman_init(void)
 			continue;
 		pcfg = fsl_bman_portal_init(dn);
 		if (pcfg)
-			/* No kernel portal support, so if USDPAA didn't consume
-			 * the portal, we've no other use for it. */
 			fsl_bman_portal_destroy(pcfg);
 	}
 #endif
diff --git a/drivers/staging/fsl_qbman/dpa_sys.h b/drivers/staging/fsl_qbman/dpa_sys.h
index 73cb7b1..a32fa1f 100644
--- a/drivers/staging/fsl_qbman/dpa_sys.h
+++ b/drivers/staging/fsl_qbman/dpa_sys.h
@@ -54,7 +54,6 @@
 #include <linux/debugfs.h>
 #include <linux/seq_file.h>
 #include <linux/device.h>
-#include <linux/uio_driver.h>
 #include <asm/smp.h>
 #include <sysdev/fsl_soc.h>
 #include <linux/fsl_hypervisor.h>
@@ -91,31 +90,6 @@ done:
 	return cpu;
 }
 
-/* Handle portals destined for USDPAA (user-space).
- *
- * The UIO layer is mostly Qman/Bman-agnostic, however the rest of the driver is
- * separated along interface and implementation lines. So each Qman/Bman driver
- * instantiates a dpa_uio_class and links dpa_uio_portal objects into it. If
- * the dpa_uio driver module is built, it queries these two classes and creates
- * the UIO devices accordingly.
- */
-struct dpa_uio_class {
-	struct list_head list;
-	const char *dev_prefix;
-};
-struct dpa_uio_portal {
-	enum {
-		dpa_uio_portal_bman,
-		dpa_uio_portal_qman,
-	} type;
-	union {
-		const struct bm_portal_config *bm_cfg;
-		const struct qm_portal_config *qm_cfg;
-	};
-	struct list_head node;
-};
-const struct dpa_uio_class *dpa_uio_bman(void);
-const struct dpa_uio_class *dpa_uio_qman(void);
 /* For 2-element tables related to cache-inhibited and cache-enabled mappings */
 #define DPA_PORTAL_CE 0
 #define DPA_PORTAL_CI 1
diff --git a/drivers/staging/fsl_qbman/dpa_uio.c b/drivers/staging/fsl_qbman/dpa_uio.c
deleted file mode 100644
index 19360f2..0000000
--- a/drivers/staging/fsl_qbman/dpa_uio.c
+++ /dev/null
@@ -1,200 +0,0 @@
-/* Copyright 2011 Freescale Semiconductor, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "bman_private.h"
-#include "qman_private.h"
-
-static const char dpa_uio_version[] = "USDPAA UIO portal driver v0.2";
-
-static LIST_HEAD(uio_portal_list);
-
-struct dpa_uio_info {
-	atomic_t ref; /* exclusive, only one open() at a time */
-	struct uio_info uio;
-	void *addr_ci;
-	char name[16]; /* big enough for "qman-uio-xx" */
-	struct platform_device *pdev;
-	struct list_head node;
-};
-
-static int dpa_uio_open(struct uio_info *info, struct inode *inode)
-{
-	struct dpa_uio_info *i = container_of(info, struct dpa_uio_info, uio);
-	if (!atomic_dec_and_test(&i->ref)) {
-		atomic_inc(&i->ref);
-		return -EBUSY;
-	}
-	return 0;
-}
-
-static int dpa_uio_release(struct uio_info *info, struct inode *inode)
-{
-	struct dpa_uio_info *i = container_of(info, struct dpa_uio_info, uio);
-	atomic_inc(&i->ref);
-	return 0;
-}
-
-static pgprot_t dpa_uio_pgprot(struct uio_info *info, unsigned int mem_idx,
-				   pgprot_t prot)
-{
-	if (mem_idx == DPA_PORTAL_CE)
-		/* It's the cache-enabled portal region. NB, we shouldn't use
-		 * pgprot_cached() here because it includes _PAGE_COHERENT. The
-		 * region is cachable but *not* coherent - stashing (if enabled)
-		 * leads to "coherent-like" behaviour, otherwise the driver
-		 * explicitly invalidates/prefetches. */
-		return pgprot_cached_noncoherent(prot);
-	/* Otherwise it's the cache-inhibited portal region */
-	return pgprot_noncached(prot);
-}
-
-static irqreturn_t dpa_uio_irq_handler(int irq, struct uio_info *info)
-{
-	struct dpa_uio_info *i = container_of(info, struct dpa_uio_info, uio);
-	/* This is the only code outside the regular portal driver that
-	 * manipulates any portal register, so rather than breaking that
-	 * encapsulation I am simply hard-coding the offset to the inhibit
-	 * register here. */
-	out_be32(i->addr_ci + 0xe0c, ~(u32)0);
-	return IRQ_HANDLED;
-}
-
-static void __init dpa_uio_portal_init(struct dpa_uio_portal *p,
-				const struct dpa_uio_class *c)
-{
-	struct dpa_uio_info *info;
-	const struct resource *res;
-	u32 index;
-	int irq, ret;
-
-	/* allocate 'info' */
-	info = kzalloc(sizeof(*info), GFP_KERNEL);
-	if (!info)
-		return;
-	atomic_set(&info->ref, 1);
-	if (p->type == dpa_uio_portal_bman) {
-		res = &p->bm_cfg->addr_phys[0];
-		index = p->bm_cfg->public_cfg.index;
-		irq = p->bm_cfg->public_cfg.irq;
-	} else {
-		res = &p->qm_cfg->addr_phys[0];
-		index = p->qm_cfg->public_cfg.index;
-		irq = p->qm_cfg->public_cfg.irq;
-	}
-	/* We need to map the cache-inhibited region in the kernel for
-	 * interrupt-handling purposes. */
-	info->addr_ci = ioremap_prot(res[DPA_PORTAL_CI].start,
-				resource_size(&res[DPA_PORTAL_CI]),
-				_PAGE_GUARDED | _PAGE_NO_CACHE);
-	/* Name the UIO device according to the cell-index. It's supposed to be
-	 * unique for each device class (Qman/Bman), and is also a convenient
-	 * way for user-space to find the UIO device that corresponds to a given
-	 * portal device-tree node. */
-	sprintf(info->name, "%s%x", c->dev_prefix, index);
-	info->pdev = platform_device_alloc(info->name, -1);
-	if (!info->pdev) {
-		iounmap(info->addr_ci);
-		kfree(info);
-		pr_err("dpa_uio_portal: platform_device_alloc() failed\n");
-		return;
-	}
-	ret = platform_device_add(info->pdev);
-	if (ret) {
-		platform_device_put(info->pdev);
-		iounmap(info->addr_ci);
-		kfree(info);
-		pr_err("dpa_uio_portal: platform_device_add() failed\n");
-		return;
-	}
-	info->uio.name = info->name;
-	info->uio.version = dpa_uio_version;
-	info->uio.mem[DPA_PORTAL_CE].name = "cena";
-	info->uio.mem[DPA_PORTAL_CE].addr = res[DPA_PORTAL_CE].start;
-	info->uio.mem[DPA_PORTAL_CE].size = resource_size(&res[DPA_PORTAL_CE]);
-	info->uio.mem[DPA_PORTAL_CE].memtype = UIO_MEM_PHYS;
-	info->uio.mem[DPA_PORTAL_CI].name = "cinh";
-	info->uio.mem[DPA_PORTAL_CI].addr = res[DPA_PORTAL_CI].start;
-	info->uio.mem[DPA_PORTAL_CI].size = resource_size(&res[DPA_PORTAL_CI]);
-	info->uio.mem[DPA_PORTAL_CI].memtype = UIO_MEM_PHYS;
-	info->uio.irq = irq;
-	info->uio.handler = dpa_uio_irq_handler;
-	info->uio.set_pgprot = dpa_uio_pgprot;
-	info->uio.open = dpa_uio_open;
-	info->uio.release = dpa_uio_release;
-	ret = uio_register_device(&info->pdev->dev, &info->uio);
-	if (ret) {
-		platform_device_del(info->pdev);
-		platform_device_put(info->pdev);
-		iounmap(info->addr_ci);
-		kfree(info);
-		pr_err("dpa_uio_portal: UIO registration failed\n");
-		return;
-	}
-	list_add_tail(&info->node, &uio_portal_list);
-	pr_info("USDPAA portal initialised, %s\n", info->name);
-}
-
-static int __init dpa_uio_init(void)
-{
-	const struct dpa_uio_class *classes[3], **c = classes;
-	classes[0] = dpa_uio_bman();
-	classes[1] = dpa_uio_qman();
-	classes[2] = NULL;
-	while (*c) {
-		struct dpa_uio_portal *p;
-		list_for_each_entry(p, &(*c)->list, node)
-			dpa_uio_portal_init(p, *c);
-		c++;
-	}
-	pr_info("USDPAA portal layer loaded\n");
-	return 0;
-}
-
-static void __exit dpa_uio_exit(void)
-{
-	struct dpa_uio_info *info, *tmp;
-	list_for_each_entry_safe(info, tmp, &uio_portal_list, node) {
-		list_del(&info->node);
-		uio_unregister_device(&info->uio);
-		platform_device_del(info->pdev);
-		platform_device_put(info->pdev);
-		iounmap(info->addr_ci);
-		pr_info("USDPAA portal removed, %s\n", info->name);
-		kfree(info);
-	}
-	pr_info("USDPAA portal layer unloaded\n");
-}
-
-
-module_init(dpa_uio_init)
-module_exit(dpa_uio_exit)
-MODULE_LICENSE("GPL");
-
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 9119e2d..18e220f 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -41,16 +41,6 @@ EXPORT_SYMBOL(qman_ip_rev);
 static u32 fqd_size = (PAGE_SIZE << CONFIG_FSL_QMAN_FQD_SZ);
 #endif
 
-static struct dpa_uio_class qman_uio = {
-	.list = LIST_HEAD_INIT(qman_uio.list),
-	.dev_prefix = "qman-uio-"
-};
-const struct dpa_uio_class *dpa_uio_qman(void)
-{
-	return &qman_uio;
-}
-EXPORT_SYMBOL(dpa_uio_qman);
-
 #ifdef CONFIG_FSL_QMAN_PORTAL
 static __init struct qman_portal *init_affine_portal(
 					struct qm_portal_config *pconfig,
@@ -198,20 +188,6 @@ static __init struct qm_portal_config *fsl_qman_portal_init(
 	qman_liodn_fixup(pcfg->public_cfg.channel);
 #endif
 
-	if (of_get_property(node, "fsl,usdpaa-portal", &ret)) {
-		struct dpa_uio_portal *u = kmalloc(sizeof(*u), GFP_KERNEL);
-		if (!u)
-			goto err;
-		u->type = dpa_uio_portal_qman;
-		u->qm_cfg = pcfg;
-		list_add_tail(&u->node, &qman_uio.list);
-		/* Return NULL, otherwise the kernel may share it on CPUs that
-		 * don't have their own portals, which would be ... *bad*. */
-		 return NULL;
-	}
-
-	/* Map the portals now we know they aren't for UIO (the UIO code doesn't
-	 * need the CE mapping, and so will do its own CI-only mapping). */
 	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_prot(
 				pcfg->addr_phys[DPA_PORTAL_CE].start,
 				resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]),
-- 
1.7.9.7

