From 02929613b99642586995f7d81ca866b4f60d47f0 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 14 Mar 2012 04:49:51 +0000
Subject: [PATCH 085/121] qbman/dpaa_eth/usdpaa: dynamic pool-channel/CGR
 allocation

Pool-channels are now described via a range node+property (specifying the
range of channel IDs) rather than a separate node for each pool containing
a channel ID property. The set of valid CGR IDs are also specified via a
range node+property. Allocator APIs are added for both type of object
(in-kernel as well as for USDPAA).

Consequently, the dpaa_eth "ethernet" nodes no longer link to the pool
channel they are to use, the driver is modified to instead dynamically
allocate a single pool-channel for all its interfaces.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image. Remove the mods
for the specific board's dts.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
Integrated-by: Yongli He <yongli.he@windriver.com>
---
 arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi     |    8 ++
 arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi     |    8 ++
 arch/powerpc/boot/dts/fsl/qoriq-qman1-portals.dtsi |   92 +--------------
 arch/powerpc/boot/dts/p4080ds-usdpaa.dts           |    9 --
 arch/powerpc/boot/dts/p4080ds.dts                  |   10 --
 arch/powerpc/boot/dts/p5020ds-usdpaa.dts           |    6 -
 arch/powerpc/boot/dts/p5020ds.dts                  |    6 -
 drivers/misc/fsl_usdpaa.c                          |   12 ++
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |   31 +++--
 drivers/staging/fsl_qbman/dpa_alloc.c              |   82 ++++++++++++-
 drivers/staging/fsl_qbman/qman_driver.c            |  122 ++++++++++++++++----
 include/linux/fsl_qman.h                           |   67 +++++++++++
 include/linux/fsl_usdpaa.h                         |    4 +-
 13 files changed, 289 insertions(+), 168 deletions(-)

diff --git a/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi b/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi
index dd7fe62..09ddb81 100644
--- a/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi
+++ b/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res1.dtsi
@@ -69,4 +69,12 @@
 		compatible = "fsl,fqid-range";
 		fsl,fqid-range = <256 256>;
 	};
+	qman-pools@0 {
+		compatible = "fsl,pool-channel-range";
+		fsl,pool-channel-range = <0x21 0xf>;
+	};
+	qman-cgrids@0 {
+		compatible = "fsl,cgrid-range";
+		fsl,cgrid-range = <0 256>;
+	};
 };
diff --git a/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi b/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi
index 4646d16..71875d8 100644
--- a/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi
+++ b/arch/powerpc/boot/dts/fsl/qoriq-dpaa-res2.dtsi
@@ -48,4 +48,12 @@
 		compatible = "fsl,fqid-range";
 		fsl,fqid-range = <256 256>;
 	};
+	qman-pools@0 {
+		compatible = "fsl,pool-channel-range";
+		fsl,pool-channel-range = <0x21 0x3>;
+	};
+	qman-cgrids@0 {
+		compatible = "fsl,cgrid-range";
+		fsl,cgrid-range = <0 64>;
+	};
 };
diff --git a/arch/powerpc/boot/dts/fsl/qoriq-qman1-portals.dtsi b/arch/powerpc/boot/dts/fsl/qoriq-qman1-portals.dtsi
index a7929d8..8476b32 100644
--- a/arch/powerpc/boot/dts/fsl/qoriq-qman1-portals.dtsi
+++ b/arch/powerpc/boot/dts/fsl/qoriq-qman1-portals.dtsi
@@ -1,7 +1,7 @@
 /*
  * QorIQ QMan Portal device tree stub for 10 portals & 15 pool channels
  *
- * Copyright 2011 Freescale Semiconductor Inc.
+ * Copyright 2011-2012 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -114,93 +114,3 @@ qportal9: qman-portal@24000 {
 	interrupts = <122 0x2 0 0>;
 	fsl,qman-channel-id = <0x9>;
 };
-
-qpool1: qman-pool@1 {
-	cell-index = <1>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x21>;
-};
-
-qpool2: qman-pool@2 {
-	cell-index = <2>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x22>;
-};
-
-qpool3: qman-pool@3 {
-	cell-index = <3>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x23>;
-};
-
-qpool4: qman-pool@4 {
-	cell-index = <4>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x24>;
-};
-
-qpool5: qman-pool@5 {
-	cell-index = <5>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x25>;
-};
-
-qpool6: qman-pool@6 {
-	cell-index = <6>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x26>;
-};
-
-qpool7: qman-pool@7 {
-	cell-index = <7>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x27>;
-};
-
-qpool8: qman-pool@8 {
-	cell-index = <8>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x28>;
-};
-
-qpool9: qman-pool@9 {
-	cell-index = <9>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x29>;
-};
-
-qpool10: qman-pool@10 {
-	cell-index = <10>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x2a>;
-};
-
-qpool11: qman-pool@11 {
-	cell-index = <11>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x2b>;
-};
-
-qpool12: qman-pool@12 {
-	cell-index = <12>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x2c>;
-};
-
-qpool13: qman-pool@13 {
-	cell-index = <13>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x2d>;
-};
-
-qpool14: qman-pool@14 {
-	cell-index = <14>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x2e>;
-};
-
-qpool15: qman-pool@15 {
-	cell-index = <15>;
-	compatible = "fsl,qman-pool-channel";
-	fsl,qman-channel-id = <0x2f>;
-};
diff --git a/arch/powerpc/boot/dts/p4080ds-usdpaa.dts b/arch/powerpc/boot/dts/p4080ds-usdpaa.dts
index 854dd9c..a5d2be6 100644
--- a/arch/powerpc/boot/dts/p4080ds-usdpaa.dts
+++ b/arch/powerpc/boot/dts/p4080ds-usdpaa.dts
@@ -66,7 +66,6 @@
 		ethernet@0 {
 			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
 			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
 		};
@@ -78,56 +77,48 @@
 		ethernet@2 {
 			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
 			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
 		};
 		ethernet@3 {
 			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
 			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
 		};
 		ethernet@4 {
 			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
 			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
 		};
 		ethernet@5 {
 			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x5c 1 0x5d 1>;
 			fsl,qman-frame-queues-tx = <0x7c 1 0x7d 1>;
 		};
 		ethernet@6 {
 			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x5e 1 0x5f 1>;
 			fsl,qman-frame-queues-tx = <0x7e 1 0x7f 1>;
 		};
 		ethernet@7 {
 			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x60 1 0x61 1>;
 			fsl,qman-frame-queues-tx = <0x80 1 0x81 1>;
 		};
 		ethernet@8 {
 			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x62 1 0x63 1>;
 			fsl,qman-frame-queues-tx = <0x82 1 0x83 1>;
 		};
 		ethernet@9 {
 			compatible = "fsl,p4080-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x66 1 0x67 1>;
 			fsl,qman-frame-queues-tx = <0x86 1 0x87 1>;
 		};
diff --git a/arch/powerpc/boot/dts/p4080ds.dts b/arch/powerpc/boot/dts/p4080ds.dts
index 03319bf..5cc580f 100644
--- a/arch/powerpc/boot/dts/p4080ds.dts
+++ b/arch/powerpc/boot/dts/p4080ds.dts
@@ -443,52 +443,42 @@
 
 		ethernet@0 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet0>;
 		};
 		ethernet@1 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet1>;
 		};
 		ethernet@2 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet2>;
 		};
 		ethernet@3 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet3>;
 		};
 		ethernet@4 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet4>;
 		};
 		ethernet@5 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet5>;
 		};
 		ethernet@6 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet6>;
 		};
 		ethernet@7 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet7>;
 		};
 		ethernet@8 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet8>;
 		};
 		ethernet@9 {
 			compatible = "fsl,p4080-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet9>;
 		};
 	};
diff --git a/arch/powerpc/boot/dts/p5020ds-usdpaa.dts b/arch/powerpc/boot/dts/p5020ds-usdpaa.dts
index a0c5739..78952f1 100644
--- a/arch/powerpc/boot/dts/p5020ds-usdpaa.dts
+++ b/arch/powerpc/boot/dts/p5020ds-usdpaa.dts
@@ -82,42 +82,36 @@
 		ethernet@0 {
 			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x50 1 0x51 1>;
 			fsl,qman-frame-queues-tx = <0x70 1 0x71 1>;
 		};
 		ethernet@1 {
 			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x52 1 0x53 1>;
 			fsl,qman-frame-queues-tx = <0x72 1 0x73 1>;
 		};
 		ethernet@2 {
 			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x54 1 0x55 1>;
 			fsl,qman-frame-queues-tx = <0x74 1 0x75 1>;
 		};
 		ethernet@3 {
 			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x56 1 0x57 1>;
 			fsl,qman-frame-queues-tx = <0x76 1 0x77 1>;
 		};
 		ethernet@4 {
 			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x58 1 0x59 1>;
 			fsl,qman-frame-queues-tx = <0x78 1 0x79 1>;
 		};
 		ethernet@5 {
 			compatible = "fsl,p5020-dpa-ethernet-init", "fsl,dpa-ethernet-init";
 			fsl,bman-buffer-pools = <&bp7 &bp8 &bp9>;
-			fsl,qman-channel = <&qpool4>;
 			fsl,qman-frame-queues-rx = <0x5a 1 0x5b 1>;
 			fsl,qman-frame-queues-tx = <0x7a 1 0x7b 1>;
 		};
diff --git a/arch/powerpc/boot/dts/p5020ds.dts b/arch/powerpc/boot/dts/p5020ds.dts
index dedc7a1..f914600 100644
--- a/arch/powerpc/boot/dts/p5020ds.dts
+++ b/arch/powerpc/boot/dts/p5020ds.dts
@@ -420,33 +420,27 @@
 
 		ethernet@0 {
 			compatible = "fsl,p5020-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet0>;
 		};
 		ethernet@1 {
 			compatible = "fsl,p5020-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet1>;
 		};
 		ethernet@2 {
 			compatible = "fsl,p5020-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet2>;
 			status = "disabled";
 		};
 		ethernet@3 {
 			compatible = "fsl,p5020-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet3>;
 		};
 		ethernet@4 {
 			compatible = "fsl,p5020-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet4>;
 		};
 		ethernet@5 {
 			compatible = "fsl,p5020-dpa-ethernet", "fsl,dpa-ethernet";
-			fsl,qman-channel = <&qpool1>;
 			fsl,fman-mac = <&enet5>;
 		};
 	};
diff --git a/drivers/misc/fsl_usdpaa.c b/drivers/misc/fsl_usdpaa.c
index c106d1c..1ab8254 100644
--- a/drivers/misc/fsl_usdpaa.c
+++ b/drivers/misc/fsl_usdpaa.c
@@ -57,6 +57,18 @@ static const struct alloc_backend {
 		.acronym = "BPID"
 	},
 	{
+		.id_type = usdpaa_id_qpool,
+		.alloc = qman_alloc_pool_range,
+		.release = qman_release_pool_range,
+		.acronym = "QPOOL"
+	},
+	{
+		.id_type = usdpaa_id_cgrid,
+		.alloc = qman_alloc_cgrid_range,
+		.release = qman_release_cgrid_range,
+		.acronym = "CGRID"
+	},
+	{
 		/* This terminates the array */
 		.id_type = usdpaa_id_max
 	}
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 8692103..469dc9c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -2771,28 +2771,23 @@ static const struct net_device_ops dpa_shared_ops = {
 #endif
 };
 
+static u32 rx_pool_channel;
+static DEFINE_SPINLOCK(rx_pool_channel_init);
+
 static int __devinit dpa_get_channel(struct device *dev,
 					struct device_node *dpa_node)
 {
-	struct device_node *dev_node;
-	const uint32_t *channel_id;
-	int lenp;
-
-	dev_node = of_parse_phandle(dpa_node, "fsl,qman-channel", 0);
-	if (dev_node == NULL) {
-		dpaa_eth_err(dev, "Could not find fsl,qman-channel property\n");
-		return -EFAULT;
-	}
-
-	channel_id = of_get_property(dev_node, "fsl,qman-channel-id", &lenp);
-	if ((channel_id == NULL) || (lenp < sizeof(*channel_id))) {
-		dpaa_eth_err(dev, "Could not get fsl,qman-channel-id in %s\n",
-				dev_node->full_name);
-		of_node_put(dev_node);
-		return -EINVAL;
+	spin_lock(&rx_pool_channel_init);
+	if (!rx_pool_channel) {
+		u32 pool;
+		int ret = qman_alloc_pool(&pool);
+		if (!ret)
+			rx_pool_channel = pool;
 	}
-	of_node_put(dev_node);
-	return *channel_id;
+	spin_unlock(&rx_pool_channel_init);
+	if (!rx_pool_channel)
+		return -ENOMEM;
+	return rx_pool_channel;
 }
 
 struct fqid_cell {
diff --git a/drivers/staging/fsl_qbman/dpa_alloc.c b/drivers/staging/fsl_qbman/dpa_alloc.c
index 4d54064..d7752de 100644
--- a/drivers/staging/fsl_qbman/dpa_alloc.c
+++ b/drivers/staging/fsl_qbman/dpa_alloc.c
@@ -35,8 +35,10 @@
 
 /* Qman and Bman APIs are front-ends to the common code; */
 
-static DECLARE_DPA_ALLOC(bpalloc);
-static DECLARE_DPA_ALLOC(fqalloc);
+static DECLARE_DPA_ALLOC(bpalloc); /* BPID allocator */
+static DECLARE_DPA_ALLOC(fqalloc); /* FQID allocator */
+static DECLARE_DPA_ALLOC(qpalloc); /* pool-channel allocator */
+static DECLARE_DPA_ALLOC(cgralloc); /* CGR ID allocator */
 
 /* This is a sort-of-conditional dpa_alloc_free() routine. Eg. when releasing
  * FQIDs (probably from user-space), it can filter out those that aren't in the
@@ -48,7 +50,7 @@ static u32 release_id_range(struct dpa_alloc *alloc, u32 id, u32 count,
 	int valid_mode = 0;
 	u32 loop = id, total_invalid = 0;
 	while (loop < (id + count)) {
-		int isvalid = is_valid(loop);
+		int isvalid = is_valid ? is_valid(loop) : 1;
 		if (!valid_mode) {
 			/* We're looking for a valid ID to terminate an invalid
 			 * range */
@@ -79,6 +81,8 @@ static u32 release_id_range(struct dpa_alloc *alloc, u32 id, u32 count,
 	return total_invalid;
 }
 
+/* BPID allocator front-end */
+
 int bman_alloc_bpid_range(u32 *result, u32 count, u32 align, int partial)
 {
 	return dpa_alloc_new(&bpalloc, result, count, align, partial);
@@ -106,6 +110,8 @@ void bman_release_bpid_range(u32 bpid, u32 count)
 }
 EXPORT_SYMBOL(bman_release_bpid_range);
 
+/* FQID allocator front-end */
+
 int qman_alloc_fqid_range(u32 *result, u32 count, u32 align, int partial)
 {
 	return dpa_alloc_new(&fqalloc, result, count, align, partial);
@@ -131,7 +137,75 @@ void qman_release_fqid_range(u32 fqid, u32 count)
 }
 EXPORT_SYMBOL(qman_release_fqid_range);
 
-/* The rest is the common backend to the Qman and Bman allocators */
+/* Pool-channel allocator front-end */
+
+int qman_alloc_pool_range(u32 *result, u32 count, u32 align, int partial)
+{
+	return dpa_alloc_new(&qpalloc, result, count, align, partial);
+}
+EXPORT_SYMBOL(qman_alloc_pool_range);
+
+static int qp_valid(u32 qp)
+{
+	/* TBD: when resource-management improves, we may be able to find
+	 * something better than this. Currently we query all FQDs starting from
+	 * FQID 1 until we get an "invalid FQID" error, looking for non-OOS FQDs
+	 * whose destination channel is the pool-channel being released. */
+	struct qman_fq fq = {
+		.fqid = 1
+	};
+	int err;
+	do {
+		struct qm_mcr_queryfq_np np;
+		err = qman_query_fq_np(&fq, &np);
+		if (err)
+			/* FQID range exceeded, found no problems */
+			return 1;
+		if ((np.state & QM_MCR_NP_STATE_MASK) != QM_MCR_NP_STATE_OOS) {
+			struct qm_fqd fqd;
+			err = qman_query_fq(&fq, &fqd);
+			BUG_ON(err);
+			if (fqd.dest.channel == qp)
+				/* The channel is the FQ's target, can't free */
+				return 0;
+		}
+		/* Move to the next FQID */
+		fq.fqid++;
+	} while (1);
+}
+void qman_release_pool_range(u32 qp, u32 count)
+{
+	u32 total_invalid = release_id_range(&qpalloc, qp, count, qp_valid);
+	if (total_invalid) {
+		/* Pool channels are almost always used individually */
+		if (count == 1)
+			pr_err("Pool channel 0x%x had %d leaks\n",
+				qp, total_invalid);
+		else
+			pr_err("Pool channels [%d..%d] (%d) had %d leaks\n",
+				qp, qp + count - 1, count, total_invalid);
+	}
+}
+EXPORT_SYMBOL(qman_release_pool_range);
+
+/* CGR ID allocator front-end */
+
+int qman_alloc_cgrid_range(u32 *result, u32 count, u32 align, int partial)
+{
+	return dpa_alloc_new(&cgralloc, result, count, align, partial);
+}
+EXPORT_SYMBOL(qman_alloc_cgrid_range);
+
+void qman_release_cgrid_range(u32 cgrid, u32 count)
+{
+	u32 total_invalid = release_id_range(&cgralloc, cgrid, count, NULL);
+	if (total_invalid)
+		pr_err("CGRID range [%d..%d] (%d) had %d leaks\n",
+			cgrid, cgrid + count - 1, count, total_invalid);
+}
+EXPORT_SYMBOL(qman_release_cgrid_range);
+
+/* Everything else is the common backend to all the allocators */
 
 /* The allocator is a (possibly-empty) list of these; */
 struct alloc_node {
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 47fb86c..481b773 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -51,18 +51,23 @@ static int shared_portals_idx;
 /* A SDQCR mask comprising all the available/visible pool channels */
 static u32 pools_sdqcr;
 
+#define STR_ERR_NOPROP      "No '%s' property in node %s\n"
+#define STR_ERR_CELL        "'%s' is not a %d-cell range in node %s\n"
+#define STR_FQID_RANGE      "fsl,fqid-range"
+#define STR_POOL_CHAN_RANGE "fsl,pool-channel-range"
+#define STR_CGRID_RANGE      "fsl,cgrid-range"
+
+/* A "fsl,fqid-range" node; release the given range to the allocator */
 static __init int fsl_fqid_range_init(struct device_node *node)
 {
 	int ret;
-	u32 *range = (u32 *)of_get_property(node, "fsl,fqid-range", &ret);
+	const u32 *range = of_get_property(node, STR_FQID_RANGE, &ret);
 	if (!range) {
-		pr_err("No 'fsl,fqid-range' property in node %s\n",
-			node->full_name);
+		pr_err(STR_ERR_NOPROP, STR_FQID_RANGE, node->full_name);
 		return -EINVAL;
 	}
 	if (ret != 8) {
-		pr_err("'fsl,fqid-range' is not a 2-cell range in node %s\n",
-			node->full_name);
+		pr_err(STR_ERR_CELL, STR_FQID_RANGE, 2, node->full_name);
 		return -EINVAL;
 	}
 	qman_release_fqid_range(range[0], range[1]);
@@ -71,6 +76,74 @@ static __init int fsl_fqid_range_init(struct device_node *node)
 	return 0;
 }
 
+/* A "fsl,pool-channel-range" node; add to the SDQCR mask only */
+static __init int fsl_pool_channel_range_sdqcr(struct device_node *node)
+{
+	int ret;
+	const u32 *chanid = of_get_property(node, STR_POOL_CHAN_RANGE, &ret);
+	if (!chanid) {
+		pr_err(STR_ERR_NOPROP, STR_POOL_CHAN_RANGE, node->full_name);
+		return -EINVAL;
+	}
+	if (ret != 8) {
+		pr_err(STR_ERR_CELL, STR_POOL_CHAN_RANGE, 1, node->full_name);
+		return -EINVAL;
+	}
+	for (ret = 0; ret < chanid[1]; ret++)
+		pools_sdqcr |= QM_SDQCR_CHANNELS_POOL_CONV(chanid[0] + ret);
+	return 0;
+}
+
+/* A "fsl,pool-channel-range" node; release the given range to the allocator */
+static __init int fsl_pool_channel_range_init(struct device_node *node)
+{
+	int ret;
+	const u32 *chanid = of_get_property(node, STR_POOL_CHAN_RANGE, &ret);
+	if (!chanid) {
+		pr_err(STR_ERR_NOPROP, STR_POOL_CHAN_RANGE, node->full_name);
+		return -EINVAL;
+	}
+	if (ret != 8) {
+		pr_err(STR_ERR_CELL, STR_POOL_CHAN_RANGE, 1, node->full_name);
+		return -EINVAL;
+	}
+	qman_release_pool_range(chanid[0], chanid[1]);
+	pr_info("Qman: pool channel allocator includes range %d:%d\n",
+		chanid[0], chanid[1]);
+	return 0;
+}
+
+/* A "fsl,cgrid-range" node; release the given range to the allocator */
+static __init int fsl_cgrid_range_init(struct device_node *node)
+{
+	struct qman_cgr cgr;
+	int ret, errors = 0;
+	const u32 *range = of_get_property(node, STR_CGRID_RANGE, &ret);
+	if (!range) {
+		pr_err(STR_ERR_NOPROP, STR_CGRID_RANGE, node->full_name);
+		return -EINVAL;
+	}
+	if (ret != 8) {
+		pr_err(STR_ERR_CELL, STR_CGRID_RANGE, 2, node->full_name);
+		return -EINVAL;
+	}
+	qman_release_cgrid_range(range[0], range[1]);
+	pr_info("Qman: CGRID allocator includes range %d:%d\n",
+		range[0], range[1]);
+	for (cgr.cgrid = 0; cgr.cgrid < __CGR_NUM; cgr.cgrid++) {
+		ret = qman_modify_cgr(&cgr, QMAN_CGR_FLAG_USE_INIT, NULL);
+		if (ret)
+			errors++;
+	}
+	if (errors)
+		pr_err("Warning: %d error%s while initialising CGRs %d:%d\n",
+			errors, (errors > 1) ? "s" : "", range[0], range[1]);
+	return 0;
+}
+
+/* Parse a portal node, perform generic mapping duties and return the config. It
+ * is not known at this stage for what purpose (or even if) the portal will be
+ * used. */
 static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 {
 	struct qm_portal_config *pcfg;
@@ -164,6 +237,7 @@ err:
 	return NULL;
 }
 
+/* Destroy a previously-parsed portal config. */
 static void destroy_pcfg(struct qm_portal_config *pcfg)
 {
 	iounmap(pcfg->addr_virt[DPA_PORTAL_CI]);
@@ -243,10 +317,6 @@ static int qman_uio_cb_open(const struct list_head *__p)
 	set_liodns(pcfg, hard_smp_processor_id());
 	return 0;
 }
-static void qman_uio_cb_close(const struct list_head *__p)
-{
-	QMAN_UIO_PREAMBLE();
-}
 static void qman_uio_cb_interrupt(const struct list_head *__p)
 {
 	QMAN_UIO_PREAMBLE();
@@ -262,7 +332,6 @@ static const struct dpa_uio_vtable qman_uio = {
 	.init_uio = qman_uio_cb_init,
 	.destroy = qman_uio_cb_destroy,
 	.on_open = qman_uio_cb_open,
-	.on_close = qman_uio_cb_close,
 	.on_interrupt = qman_uio_cb_interrupt
 };
 
@@ -322,7 +391,6 @@ __setup("qportals=", parse_qportals);
 
 static __init int qman_init(void)
 {
-	struct qman_cgr cgr;
 	struct cpumask slave_cpus;
 	struct cpumask unshared_cpus = *cpu_none_mask;
 	struct cpumask shared_cpus = *cpu_none_mask;
@@ -341,17 +409,19 @@ static __init int qman_init(void)
 		else
 			pr_err("Qman err interrupt handler missing\n");
 	}
-	/* Parse pool channels */
-	for_each_compatible_node(dn, NULL, "fsl,qman-pool-channel") {
-		const u32 *index = of_get_property(dn, "cell-index", NULL);
-		pools_sdqcr |= QM_SDQCR_CHANNELS_POOL(*index);
-	}
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
 	/* Setup lookup table for FQ demux */
 	ret = qman_setup_fq_lookup_table(fqd_size/64);
 	if (ret)
 		return ret;
 #endif
+	/* Parse pool channels into the SDQCR mask. (Must happen before portals
+	 * are initialised.) */
+	for_each_compatible_node(dn, NULL, "fsl,pool-channel-range") {
+		ret = fsl_pool_channel_range_sdqcr(dn);
+		if (ret)
+			return ret;
+	}
 	/* Initialise portals. See bman_driver.c for comments */
 	for_each_compatible_node(dn, NULL, "fsl,qman-portal") {
 		pcfg = parse_pcfg(dn);
@@ -443,13 +513,19 @@ static __init int qman_init(void)
 		if (ret)
 			return ret;
 	}
-
-	/* This is to ensure h/w-internal CGR memory is zeroed out. Note that we
-	 * do this for all conceivable CGRIDs, not all of which are necessarily
-	 * available on the underlying hardware version. We ignore any errors
-	 * for this reason. */
-	for (cgr.cgrid = 0; cgr.cgrid < __CGR_NUM; cgr.cgrid++)
-		qman_modify_cgr(&cgr, QMAN_CGR_FLAG_USE_INIT, NULL);
+	/* Initialise CGRID allocation ranges */
+	for_each_compatible_node(dn, NULL, "fsl,cgrid-range") {
+		ret = fsl_cgrid_range_init(dn);
+		if (ret)
+			return ret;
+	}
+	/* Parse pool channels into the allocator. (Must happen after portals
+	 * are initialised.) */
+	for_each_compatible_node(dn, NULL, "fsl,pool-channel-range") {
+		ret = fsl_pool_channel_range_init(dn);
+		if (ret)
+			return ret;
+	}
 	return 0;
 }
 subsys_initcall(qman_init);
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index f9edf85..876cf7a 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1632,6 +1632,41 @@ static inline void qman_release_fqid(u32 fqid)
 	qman_release_fqid_range(fqid, 1);
 }
 
+	/* Pool-channel management */
+	/* ----------------------- */
+/**
+ * qman_alloc_pool_range - Allocate a contiguous range of pool-channel IDs
+ * @result: is set by the API to the base pool-channel ID of the allocated range
+ * @count: the number of pool-channel IDs required
+ * @align: required alignment of the allocated range
+ * @partial: non-zero if the API can return fewer than @count
+ *
+ * Returns the number of pool-channel IDs allocated, or a negative error code.
+ * If @partial is non zero, the allocation request may return a smaller range of
+ * than requested (though alignment will be as requested). If @partial is zero,
+ * the return value will either be 'count' or negative.
+ */
+int qman_alloc_pool_range(u32 *result, u32 count, u32 align, int partial);
+static inline int qman_alloc_pool(u32 *result)
+{
+	int ret = qman_alloc_pool_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+
+/**
+ * qman_release_pool_range - Release the specified range of pool-channel IDs
+ * @id: the base pool-channel ID of the range to deallocate
+ * @count: the number of pool-channel IDs in the range
+ *
+ * Returns zero for success.
+ */
+void qman_release_pool_range(u32 id, unsigned int count);
+static inline void qman_release_pool(u32 id)
+{
+	qman_release_pool_range(id, 1);
+}
+
+
 	/* CGR management */
 	/* -------------- */
 /**
@@ -1690,6 +1725,38 @@ int qman_query_cgr(struct qman_cgr *cgr, struct qm_mcr_querycgr *result);
  */
 int qman_query_congestion(struct qm_mcr_querycongestion *congestion);
 
+/**
+ * qman_alloc_cgrid_range - Allocate a contiguous range of CGR IDs
+ * @result: is set by the API to the base CGR ID of the allocated range
+ * @count: the number of CGR IDs required
+ * @align: required alignment of the allocated range
+ * @partial: non-zero if the API can return fewer than @count
+ *
+ * Returns the number of CGR IDs allocated, or a negative error code.
+ * If @partial is non zero, the allocation request may return a smaller range of
+ * than requested (though alignment will be as requested). If @partial is zero,
+ * the return value will either be 'count' or negative.
+ */
+int qman_alloc_cgrid_range(u32 *result, u32 count, u32 align, int partial);
+static inline int qman_alloc_cgrid(u32 *result)
+{
+	int ret = qman_alloc_cgrid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+
+/**
+ * qman_release_cgrid_range - Release the specified range of CGR IDs
+ * @id: the base CGR ID of the range to deallocate
+ * @count: the number of CGR IDs in the range
+ *
+ * Returns zero for success.
+ */
+void qman_release_cgrid_range(u32 id, unsigned int count);
+static inline void qman_release_cgrid(u32 id)
+{
+	qman_release_cgrid_range(id, 1);
+}
+
 	/* Helpers */
 	/* ------- */
 /**
diff --git a/include/linux/fsl_usdpaa.h b/include/linux/fsl_usdpaa.h
index 2d82b5d..3b38a89 100644
--- a/include/linux/fsl_usdpaa.h
+++ b/include/linux/fsl_usdpaa.h
@@ -1,4 +1,4 @@
-/* Copyright 2011 Freescale Semiconductor, Inc.
+/* Copyright 2011-2012 Freescale Semiconductor, Inc.
  *
  * This file is licensed under the terms of the GNU General Public License
  * version 2.  This program is licensed "as is" without any warranty of any
@@ -22,6 +22,8 @@ extern "C" {
 enum usdpaa_id_type {
 	usdpaa_id_fqid,
 	usdpaa_id_bpid,
+	usdpaa_id_qpool,
+	usdpaa_id_cgrid,
 	usdpaa_id_max /* <-- not a valid type, represents the number of types */
 };
 #define USDPAA_IOCTL_MAGIC 'u'
-- 
1.7.9.7

