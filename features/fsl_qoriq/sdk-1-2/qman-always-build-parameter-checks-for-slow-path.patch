From 55f51d8efa51a41ffa6ccdf77ab864b61966e3f8 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Fri, 13 Apr 2012 00:13:26 +0000
Subject: [PATCH 098/121] qman: always build parameter checks for slow-path.

This proved to be a problem when parking held-active FQs during
dequeue-processing. The FQ is not actually known to be parked until the
FQPN notification is processed later on. So APIs were being called that
depended on the FQ being parked, checks were not catching the race
condition that the FQ was sometimes not parked in time, and undefined
results would ensue (particularly when the FQPN *did* show up later on,
and the FQ was longer in a state to expect it).

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c |   27 +++++++++++++++++----------
 1 file changed, 17 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 33cdcb5..2bae8e4 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -1191,8 +1191,9 @@ int qman_init_fq(struct qman_fq *fq, u32 flags, struct qm_mcc_initfq *opts)
 	u8 res, myverb = (flags & QMAN_INITFQ_FLAG_SCHED) ?
 		QM_MCC_VERB_INITFQ_SCHED : QM_MCC_VERB_INITFQ_PARKED;
 
-	DPA_ASSERT((fq->state == qman_fq_state_oos) ||
-		(fq->state == qman_fq_state_parked));
+	if ((fq->state != qman_fq_state_oos) &&
+			(fq->state != qman_fq_state_parked))
+		return -EINVAL;
 #ifdef CONFIG_FSL_DPA_CHECKING
 	if (unlikely(fq_isset(fq, QMAN_FQ_FLAG_NO_MODIFY)))
 		return -EINVAL;
@@ -1291,7 +1292,8 @@ int qman_schedule_fq(struct qman_fq *fq)
 	int ret = 0;
 	u8 res;
 
-	DPA_ASSERT(fq->state == qman_fq_state_parked);
+	if (fq->state != qman_fq_state_parked)
+		return -EINVAL;
 #ifdef CONFIG_FSL_DPA_CHECKING
 	if (unlikely(fq_isset(fq, QMAN_FQ_FLAG_NO_MODIFY)))
 		return -EINVAL;
@@ -1334,8 +1336,9 @@ int qman_retire_fq(struct qman_fq *fq, u32 *flags)
 	int rval;
 	u8 res;
 
-	DPA_ASSERT((fq->state == qman_fq_state_parked) ||
-		(fq->state == qman_fq_state_sched));
+	if ((fq->state != qman_fq_state_parked) &&
+			(fq->state != qman_fq_state_sched))
+		return -EINVAL;
 #ifdef CONFIG_FSL_DPA_CHECKING
 	if (unlikely(fq_isset(fq, QMAN_FQ_FLAG_NO_MODIFY)))
 		return -EINVAL;
@@ -1421,7 +1424,8 @@ int qman_oos_fq(struct qman_fq *fq)
 	int ret = 0;
 	u8 res;
 
-	DPA_ASSERT(fq->state == qman_fq_state_retired);
+	if (fq->state != qman_fq_state_retired)
+		return -EINVAL;
 #ifdef CONFIG_FSL_DPA_CHECKING
 	if (unlikely(fq_isset(fq, QMAN_FQ_FLAG_NO_MODIFY)))
 		return -EINVAL;
@@ -1666,10 +1670,13 @@ int qman_volatile_dequeue(struct qman_fq *fq, u32 flags __maybe_unused,
 	struct qman_portal *p;
 	int ret;
 
-	DPA_ASSERT((fq->state == qman_fq_state_parked) ||
-			(fq->state == qman_fq_state_retired));
-	DPA_ASSERT(!(vdqcr & QM_VDQCR_FQID_MASK));
-	DPA_ASSERT(!fq_isset(fq, QMAN_FQ_STATE_VDQCR));
+	if ((fq->state != qman_fq_state_parked) &&
+			(fq->state != qman_fq_state_retired))
+		return -EINVAL;
+	if (vdqcr & QM_VDQCR_FQID_MASK)
+		return -EINVAL;
+	if (fq_isset(fq, QMAN_FQ_STATE_VDQCR))
+		return -EBUSY;
 	vdqcr = (vdqcr & ~QM_VDQCR_FQID_MASK) | fq->fqid;
 #ifdef CONFIG_FSL_DPA_CAN_WAIT
 	if (flags & QMAN_VOLATILE_FLAG_WAIT)
-- 
1.7.9.7

