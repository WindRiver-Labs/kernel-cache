From bd5b938b99262e37b3b6e35cdf7a8705713ea792 Mon Sep 17 00:00:00 2001
From: Andrei Pistirica <sorin.pistirica@freescale.com>
Date: Fri, 16 Mar 2012 19:52:46 +0200
Subject: [PATCH 075/128] fmd: IPR LLD fixes

Signed-off-by: Andrei Pistirica <sorin.pistirica@freescale.com>
Signed-off-by: Stefan Szabo <stefan.szabo@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       |   51 ++++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |    3 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    |  100 ++++++++++----
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |   10 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |    1 +
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |   86 ++++++------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |    7 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |  143 ++++++++------------
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |   25 ++--
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |    4 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |   14 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |   21 +--
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      |   13 +-
 13 files changed, 258 insertions(+), 220 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 9cd721b..c9cf60a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -182,8 +182,6 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle h_FmPcd, uint32_t requiredActio
         else
             h_AdTmp = PTR_MOVE(h_AdTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        if(p_CcNextEngineParamsTmp[i].shadowAction & requiredAction)
-            continue;
         switch(p_CcNextEngineParamsTmp[i].nextEngineParams.nextEngine)
         {
             case(e_FM_PCD_CC):
@@ -1948,15 +1946,12 @@ static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyI
     t_FmPcdCcNode                               *p_FmPcdCcNode = NULL;
     t_FmPcdCcTree                               *p_FmPcdCcTree;
     uint16_t                                    numOfKeys;
-    t_FmPcdCcNextEngineAndRequiredActionParams  *p_nextEngineAndRequiredAction = NULL;
+    t_FmPcdCcNextEngineAndRequiredActionParams  *p_NextEngineAndRequiredAction;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNodeOrTree,E_INVALID_HANDLE);
 
-    p_nextEngineAndRequiredAction = XX_Malloc(FM_PCD_MAX_NUM_OF_KEYS * sizeof(*p_nextEngineAndRequiredAction));
-    if(!p_nextEngineAndRequiredAction)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate memory for p_nextEngineAndRequiredAction"));
-
-    memset(p_nextEngineAndRequiredAction, 0, FM_PCD_MAX_NUM_OF_KEYS * sizeof(*p_nextEngineAndRequiredAction));
+    p_NextEngineAndRequiredAction = (t_FmPcdCcNextEngineAndRequiredActionParams  *)XX_Malloc(sizeof(t_FmPcdCcNextEngineAndRequiredActionParams)*256);
+    memset(p_NextEngineAndRequiredAction, 0, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams) * 256);
 
     if(!tree)
     {
@@ -1967,20 +1962,18 @@ static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyI
         if (!LIST_NumOfObjs(&p_FmPcdCcNode->ccPrevNodesLst) &&
             !LIST_NumOfObjs(&p_FmPcdCcNode->ccTreeIdLst))
         {
-            XX_Free(p_nextEngineAndRequiredAction);
+            XX_Free(p_NextEngineAndRequiredAction);
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be pointed by node or tree"));
         }
-
         if(!LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) ||
             (LIST_NumOfObjs(&p_FmPcdCcNode->ccTreesLst) != 1))
         {
-            XX_Free(p_nextEngineAndRequiredAction);
+            XX_Free(p_NextEngineAndRequiredAction);
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("node has to be belonging to some tree and only to one tree"));
         }
-
-        memcpy(p_nextEngineAndRequiredAction,
+        memcpy(p_NextEngineAndRequiredAction,
                p_FmPcdCcNode->nextEngineAndRequiredAction,
-               FM_PCD_MAX_NUM_OF_KEYS * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+               256 * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
 
         if(check)
         {
@@ -1988,7 +1981,7 @@ static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyI
                (p_FmPcdCcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT) ||
                (p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED))
             {
-                XX_Free(p_nextEngineAndRequiredAction);
+                XX_Free(p_NextEngineAndRequiredAction);
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_FF_IPV4TTL or CC_PC_FF_IPV6HOP_LIMIT can not be used for addKey, removeKey, modifyKey"));
             }
         }
@@ -1997,16 +1990,16 @@ static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyI
     {
         p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcNodeOrTree;
         numOfKeys = p_FmPcdCcTree->numOfEntries;
-        memcpy(p_nextEngineAndRequiredAction,
+        memcpy(p_NextEngineAndRequiredAction,
                p_FmPcdCcTree->nextEngineAndRequiredAction,
-               FM_PCD_MAX_NUM_OF_KEYS * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+               256 * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
     }
 
     p_FmPcdModifyCcKeyAdditionalParams =
         (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
     if(!p_FmPcdModifyCcKeyAdditionalParams)
     {
-        XX_Free(p_nextEngineAndRequiredAction);
+        XX_Free(p_NextEngineAndRequiredAction);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of internal data structure FAILED"));
     }
     memset(p_FmPcdModifyCcKeyAdditionalParams, 0, sizeof(t_FmPcdModifyCcKeyAdditionalParams));
@@ -2026,7 +2019,7 @@ static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyI
         }
         else
         {
-            memcpy(&p_FmPcdModifyCcKeyAdditionalParams->nextEngineAndRequiredAction[j], &p_nextEngineAndRequiredAction[i], sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+            memcpy(&p_FmPcdModifyCcKeyAdditionalParams->nextEngineAndRequiredAction[j],p_NextEngineAndRequiredAction+i, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
             i++;
             j++;
         }
@@ -2040,11 +2033,11 @@ static t_Error ModifyKeyCommonPart1(t_Handle h_FmPcdCcNodeOrTree,  uint16_t keyI
             i++;
     }
 
-    memcpy(&p_FmPcdModifyCcKeyAdditionalParams->nextEngineAndRequiredAction[j], &p_nextEngineAndRequiredAction[numOfKeys], sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+    memcpy(&p_FmPcdModifyCcKeyAdditionalParams->nextEngineAndRequiredAction[j],p_NextEngineAndRequiredAction+numOfKeys, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
 
-    XX_Free(p_nextEngineAndRequiredAction);
     *h_Params = p_FmPcdModifyCcKeyAdditionalParams;
 
+    XX_Free(p_NextEngineAndRequiredAction);
     return E_OK;
 }
 
@@ -2673,7 +2666,7 @@ t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle h_FmPcd, t_List *h_FmPcdOld
             ((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->numOfKeys    = p_CcNewModifyAdditionalParams->numOfKeys;
         if(p_CcNewModifyAdditionalParams->p_KeysMatchTableNew)
             ((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->h_KeysMatchTable    = p_CcNewModifyAdditionalParams->p_KeysMatchTableNew;
-        memcpy(((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction, &p_CcNewModifyAdditionalParams->nextEngineAndRequiredAction, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams) * (FM_PCD_MAX_NUM_OF_KEYS));
+        memcpy(((t_FmPcdCcNode *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction, &p_CcNewModifyAdditionalParams->nextEngineAndRequiredAction, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams) * (256));
     }
     else
         memcpy(&((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->nextEngineAndRequiredAction, &p_CcNewModifyAdditionalParams->nextEngineAndRequiredAction, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams) * (((t_FmPcdCcTree *)(p_CcNewModifyAdditionalParams->h_CurrentNode))->numOfEntries));
@@ -2951,7 +2944,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     p_FmPcdCcTree->ccTreeBaseAddr =
         PTR_TO_UINT(FM_MURAM_AllocMem(FmPcdGetMuramHandle(h_FmPcd),
                                       (uint32_t)( k * FM_PCD_CC_AD_ENTRY_SIZE),
-                                      FM_PCD_CC_AD_TABLE_ALIGN));
+                                      FM_PCD_CC_TREE_ADDR_ALIGN));
 
     if(!p_FmPcdCcTree->ccTreeBaseAddr)
     {
@@ -3047,6 +3040,12 @@ t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree)
     if(p_CcTree->owners)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("the tree with this ID can not be removed because this tree is occupied, first - unbind this tree"));
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    /* Delete reassembly schemes if exist */
+    if (p_CcTree->h_IpReassemblyManip)
+        FmPcdManipDeleteIpReassmSchemes(p_FmPcd, p_CcTree->h_IpReassemblyManip);
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
     for(i = 0; i <p_CcTree->numOfEntries; i++)
     {
         if(p_CcTree->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
@@ -3216,9 +3215,9 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
             p_FmPcdCcNode->userOffset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
             p_FmPcdCcNode->parseCode = GetGenParseCode(h_FmPcd, p_CcNodeParam->extractCcParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset, fromIc,icCode);
 
-            if (p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+            if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
-                if ((p_FmPcdCcNode->offset + p_FmPcdCcNode->sizeOfExtraction) > 8)
+                if((p_FmPcdCcNode->offset + p_FmPcdCcNode->sizeOfExtraction) > 8)
                 {
                      DeleteNode(p_FmPcdCcNode);
                      REPORT_ERROR(MAJOR, E_INVALID_SELECTION,("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
@@ -3553,7 +3552,7 @@ t_Error FM_PCD_CcNodeGetNextEngine(t_Handle                     h_FmPcd,
     return E_OK;
 }
 
-uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex)
+uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex)
 {
     t_FmPcdCcNode       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
     t_AdOfTypeResult    *p_AdResult = NULL;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index ba3f2fb..59416e1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -126,9 +126,10 @@
 #define CC_SIZE_ILLEGAL                     0
 
 #define FM_PCD_CC_KEYS_MATCH_TABLE_ALIGN    16
-#define FM_PCD_CC_AD_TABLE_ALIGN            256
+#define FM_PCD_CC_AD_TABLE_ALIGN            16
 #define FM_PCD_CC_AD_ENTRY_SIZE             16
 #define FM_PCD_CC_NUM_OF_KEYS               255
+#define FM_PCD_CC_TREE_ADDR_ALIGN           256
 
 #define FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE   0x00000000
 #define FM_PCD_AD_RESULT_DATA_FLOW_TYPE     0x80000000
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index c2e3054..4d88f7e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -701,8 +701,8 @@ static t_Error CreateIpReassCommonParamTable(t_FmPcdManip *p_Manip,
 
     /* Sets the Reassembly Frame Descriptors Pool and liodn offset*/
     tmpReg64 = (uint64_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl));
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
     WRITE_UINT32(p_IpReasmCommonPramTbl->liodnAndReassFrmDescPoolPtrHi, (uint32_t)(tmpReg64 >> 32));
     WRITE_UINT32(p_IpReasmCommonPramTbl->reassFrmDescPoolPtrLow, (uint32_t)tmpReg64);
 
@@ -835,8 +835,8 @@ static t_Handle CreateIpReassParamTable(t_FmPcdManip *p_Manip,  bool ipv4)
     IOMemSet32(*h_AutoLearnHashTbl, 0,  autoLearnHashTblSize);
 
     /* Sets the IP Reassembly Automatic Learning Hash Table and liodn offset */
-    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
     tmpReg64 |= XX_VirtToPhys(*h_AutoLearnHashTbl);
     WRITE_UINT32(p_IpReassParamsTblPtr->liodnAlAndAutoLearnHashTblPtrHi, (uint32_t)(tmpReg64 >> 32));
     WRITE_UINT32(p_IpReassParamsTblPtr->autoLearnHashTblPtrLow, (uint32_t)tmpReg64);
@@ -860,8 +860,8 @@ static t_Handle CreateIpReassParamTable(t_FmPcdManip *p_Manip,  bool ipv4)
     IOMemSet32(*h_AutoLearnSetLockTblPtr, 0,  (numOfSets * 4));
 
     /* sets Set Lock table pointer and liodn offset*/
-    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
-    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.dataLiodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
     tmpReg64 |= XX_VirtToPhys(*h_AutoLearnSetLockTblPtr);
     WRITE_UINT32(p_IpReassParamsTblPtr->liodnSlAndAutoLearnSetLockTblPtrHi, (uint32_t)(tmpReg64 >> 32));
     WRITE_UINT32(p_IpReassParamsTblPtr->autoLearnSetLockTblPtrLow, (uint32_t)tmpReg64);
@@ -922,10 +922,6 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
            (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) ||(p_Manip->shadowUpdateParams & HW_PORT_ID)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
-        fmPortGetSetCcParams.setCcParams.type = UPDATE_IPR_EN;
-        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
@@ -1007,9 +1003,47 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
             p_Manip->updateParams &= ~OFFSET_OF_DATA;
             p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
         }
-
-        p_Manip->updateParams &= ~HW_PORT_ID;
-        p_Manip->shadowUpdateParams |= HW_PORT_ID;
+        if(p_Manip->updateParams & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS))
+        {
+            t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+            t_IpReasmCommonTbl  *p_IpReasmCommonPramTbl;
+            uint8_t             *p_Ptr, i, totalNumOfTnums;
+            uint32_t            tmpReg32;
+
+            totalNumOfTnums = (fmPortGetSetCcParams.getCcParams.numOfTasks +
+                               fmPortGetSetCcParams.getCcParams.numOfExtraTasks);
+
+            p_Manip->ipReassmParams.internalBufferPoolAddr =
+                    PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                  totalNumOfTnums * BMI_FIFO_UNITS,
+                                                  BMI_FIFO_UNITS));
+            if (!p_Manip->ipReassmParams.internalBufferPoolAddr)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly internal buffers pool"));
+            IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr),
+                       0,
+                       totalNumOfTnums * BMI_FIFO_UNITS);
+
+            p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr =
+                    PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                  5 + totalNumOfTnums,
+                                                  4));
+            if (!p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly internal buffers management"));
+
+            p_Ptr = (uint8_t*)UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr);
+            WRITE_UINT32(*(uint32_t*)p_Ptr, (uint32_t)XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr)) - p_FmPcd->physicalMuramBase);
+            for (i=0,p_Ptr+=4;i<totalNumOfTnums;i++,p_Ptr++)
+                WRITE_UINT8(*p_Ptr, i);
+            WRITE_UINT8(*p_Ptr, 0xFF);
+
+            tmpReg32 = (4 << FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_SHIFT) |
+                       ((uint32_t)XX_VirtToPhys(UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)) - p_FmPcd->physicalMuramBase);
+            p_IpReasmCommonPramTbl = (t_IpReasmCommonTbl *)(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
+            WRITE_UINT32(p_IpReasmCommonPramTbl->internalBufferManagement, tmpReg32);
+
+            p_Manip->updateParams &= ~(NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
+            p_Manip->shadowUpdateParams |= (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
+        }
     }
     else
     {
@@ -1134,6 +1168,8 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
             XX_Free(p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr);
         if(p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr)
             XX_Free(p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr);
+        if(p_Manip->ipReassmParams.h_TimeOutTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_TimeOutTbl);
         if(p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr);
         if(p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr)
@@ -1144,12 +1180,10 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl);
         if(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl)
             XX_Free(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl);
-
-        if (p_Manip->ipReassmParams.h_Ipv4Scheme)
-            FM_PCD_KgDeleteScheme(p_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme);
-
-        if (p_Manip->ipReassmParams.h_Ipv6Scheme)
-            FM_PCD_KgDeleteScheme(p_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme);
+        if(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolManagementIndexAddr));
+        if(p_Manip->ipReassmParams.internalBufferPoolAddr)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_Manip->ipReassmParams.internalBufferPoolAddr));
     }
 #endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
     if(p_Manip->p_StatsTbl)
@@ -1898,16 +1932,14 @@ static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, t_Handle h_Ad, bool
 
     /* Sets the second Ad register (matchTblPtr) - Buffer pool ID (BPID) and Scatter/Gather table offset*/
     /* mark the Scatter/Gather table offset to be set later on when the port will be known */
-    p_Manip->updateParams = OFFSET_OF_DATA;
+    p_Manip->updateParams = (OFFSET_OF_DATA | NUM_OF_TASKS | NUM_OF_EXTRA_TASKS);
 
-    tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.bpid << 8);
+    tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.sgBpid << 8);
     WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
 
     /* Sets the third Ad register (pcAndOffsets)- liodn offset and IP Reassembly Operation Code*/
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
-    tmpReg32 |= (uint32_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << ((uint32_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT-32);
-    tmpReg32 |= (uint32_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << ((uint32_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT-32);
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
     p_Manip->reassm = TRUE;
@@ -2017,11 +2049,11 @@ static t_Error IpReassembly(t_FmPcdManipFragOrReasmParams *p_ManipParams,t_FmPcd
     p_Manip->ipReassmParams.fqidForTimeOutFrames = reassmManipParams.fqidForTimeOutFrames;
     p_Manip->ipReassmParams.numOfFramesPerHashEntry = reassmManipParams.numOfFramesPerHashEntry;
     p_Manip->ipReassmParams.timeoutThresholdForReassmProcess = reassmManipParams.timeoutThresholdForReassmProcess;
-    p_Manip->ipReassmParams.liodnOffset = reassmManipParams.liodnOffset;
     p_Manip->ipReassmParams.minFragSize[0] = reassmManipParams.minFragSize[0];
     p_Manip->ipReassmParams.minFragSize[1] = reassmManipParams.minFragSize[1];
     p_Manip->ipReassmParams.dataMemId = reassmManipParams.dataMemId;
-    p_Manip->ipReassmParams.bpid = p_ManipParams->extBufPoolIndx;
+    p_Manip->ipReassmParams.dataLiodnOffset = reassmManipParams.dataLiodnOffset;
+    p_Manip->ipReassmParams.sgBpid = reassmManipParams.sgBpid;
 
     /* Creates and initializes the IP Reassembly common parameter table */
     CreateIpReassCommonParamTable(p_Manip, p_FmPcd, p_IpReasmCommonPramTbl);
@@ -2709,7 +2741,7 @@ void setReassmSchemeParams(t_FmPcd* p_FmPcd, t_FmPcdKgSchemeParams *p_Scheme, t_
 t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint32_t groupId)
 {
     t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
-    t_FmPcdKgSchemeParams   *p_scheme;
+    t_FmPcdKgSchemeParams   *p_scheme = NULL;
 
     ASSERT_COND(p_FmPcd);
     ASSERT_COND(p_PcdGroupsParam);
@@ -2740,6 +2772,22 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_FmPcdCcTreeParams *p_P
 
     return E_OK;
 }
+
+t_Error FmPcdManipDeleteIpReassmSchemes(t_FmPcd *p_FmPcd, t_Handle h_Manip)
+{
+    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_FmPcd);
+    ASSERT_COND(p_Manip);
+
+    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+        FM_PCD_KgDeleteScheme(p_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme);
+
+    if (p_Manip->ipReassmParams.h_Ipv6Scheme)
+        FM_PCD_KgDeleteScheme(p_FmPcd, p_Manip->ipReassmParams.h_Ipv6Scheme);
+
+    return E_OK;
+}
 #endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
 t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
index 583bd4f..18e8882 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -101,6 +101,8 @@
 #define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE       64
 #define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN      8
 #define FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES              0x80000000
+#define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_MASK    0x000000FF
+#define FM_PCD_MANIP_IP_REASM_COMMON_INT_BUFFER_IDX_SHIFT   24
 
 #define FM_PCD_MANIP_IP_FRAG_DF_OFFSET                      28
 #define FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID                   24
@@ -173,8 +175,8 @@ typedef _Packed struct t_IpReasmCommonTbl{
     volatile uint32_t reassFrmDescPoolPtrLow;
     volatile uint32_t timeOutTblPtr;
     volatile uint32_t expirationDelay;
+    volatile uint32_t internalBufferManagement;
     volatile uint32_t reseervd1;
-    volatile uint32_t reseervd2;
     volatile uint32_t totalTimeOutCounter;
     volatile uint32_t totalRfdPoolBusyCounter;
     volatile uint32_t totalInternalBufferBusy;
@@ -237,11 +239,13 @@ typedef struct t_IpReassmParams
     t_Handle            h_ReassmFrmDescrIndxPoolTbl;
     t_Handle            h_ReassmFrmDescrPoolTbl;
     t_Handle            h_TimeOutTbl;
+    uintptr_t           internalBufferPoolManagementIndexAddr;
+    uintptr_t           internalBufferPoolAddr;
     uint32_t            maxNumFramesInProcess;
-    uint32_t            liodnOffset;
+    uint32_t            dataLiodnOffset;
     uint32_t            minFragSize[2];
     uint8_t             dataMemId;              /**< Memory partition ID for data buffers */
-    uint32_t            bpid;
+    uint32_t            sgBpid;
     e_FmPcdManipReassemTimeOutMode  timeOutMode;
     e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
     uint32_t                        timeoutThresholdForReassmProcess;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 2d0bbe8..0bb46d0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -550,6 +550,7 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTb
 
     bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
     tsbs = 31 - bitFor1Micro + 1;
+    tsbs = 17;//(for TimeOut check will be triggered every 1/8ms)
 
     ccIpReassmTimeoutParams.iprcpt      = (XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
     ccIpReassmTimeoutParams.tsbs        = tsbs;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 63e787b..617ce46 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -110,48 +110,48 @@ switch(exception){                                                  \
 /***********************************************************************/
 #define SW_PRS_IP_FRAG_PATCH                           \
 {                                                      \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
-    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
-    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0, \
-    0x00,0x4F,0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x53,0x2F,0x00,0x00,0x31,0x52,0x00,0xDA, \
-    0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x2F, \
-    0x00,0x00,0x1B,0x31,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
-    0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F, \
-    0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43, \
-    0x30,0x7E,0x43,0x59,0x00,0x2C,0x32,0x11,0x28,0x41, \
-    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
-    0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
-    0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
-    0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
-    0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x3C,0x00,0x03, \
-    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0, \
-    0x00,0x4F,0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
-    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
-    0x00,0x00,0x43,0x6E,0x00,0x00,0x00,0x01,0x1B,0xFE, \
-    0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00, \
-    0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
-    0x28,0x43,0x30,0x7E,0x43,0x80,0x00,0x00,0x30,0x7E, \
-    0x43,0x80,0x00,0x3C,0x1B,0x9A,0x32,0x11,0x28,0x41, \
-    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
-    0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
-    0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
-    0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
-    0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x79,0x30,0x7E, \
-    0x53,0xB0,0x00,0x2B,0x32,0x11,0x28,0x41,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
-    0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
-    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
-    0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0xC4,0x00,0x00, \
-    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x41,0x06,0x29, \
-    0x32,0x01,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
-    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
-    0x1B,0xFE,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
-    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x00,0x01, \
-    0x1B,0xFE                                          \
+        0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+        0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
+        0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
+        0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0, \
+        0x00,0x4F,0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
+        0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x53,0x2F,0x00,0x00,0x31,0x52,0x00,0xDA, \
+        0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x2F, \
+        0x00,0x00,0x1B,0x31,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
+        0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F, \
+        0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43, \
+        0x30,0x7E,0x43,0x59,0x00,0x2C,0x32,0x11,0x28,0x41, \
+        0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
+        0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
+        0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
+        0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
+        0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x3C,0x00,0x03, \
+        0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0, \
+        0x00,0x4F,0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
+        0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+        0x00,0x00,0x43,0x6E,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+        0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00, \
+        0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
+        0x28,0x43,0x30,0x7E,0x43,0x80,0x00,0x00,0x30,0x7E, \
+        0x43,0x80,0x00,0x3C,0x1B,0x9A,0x32,0x11,0x28,0x41, \
+        0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
+        0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
+        0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
+        0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
+        0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x79,0x30,0x7E, \
+        0x53,0xB0,0x00,0x2B,0x32,0x11,0x28,0x41,0x32,0x11, \
+        0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
+        0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+        0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
+        0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0xC4,0x00,0x00, \
+        0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x41,0x06,0x29, \
+        0x32,0x01,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+        0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
+        0x1B,0xFE,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
+        0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x00,0x01, \
+        0x1B,0xFE,                                         \
 };
 #endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
@@ -671,6 +671,7 @@ uint8_t     FmPcdGetNetEnvId(t_FmPcd *p_FmPcd, t_Handle h_NetEnv);
 
 #ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
 t_Error     FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint32_t groupId);
+t_Error     FmPcdManipDeleteIpReassmSchemes(t_FmPcd *p_FmPcd, t_Handle h_Manip);
 bool        FmPcdManipIsIpv4Present(t_FmPcd *p_FmPcd, uint8_t netEnvId);
 bool        FmPcdManipIsIpv6Present(t_FmPcd *p_FmPcd, uint8_t netEnvId);
 #endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
@@ -722,6 +723,7 @@ uint32_t    FmPcdManipCheckNia(t_Handle h_FmPcd, t_Handle h_Ad);
 void        FmPcdManipUpdateOwner(t_Handle h_Manip, bool add);
 t_Error     FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcdCcNode);
 
+
 static __inline__ t_Handle FmPcdGetMuramHandle(t_Handle h_FmPcd)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index e70c89f..a4b8bcc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -226,9 +226,12 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     {
         uint32_t            i, j;
         t_FmRevisionInfo    revInfo;
-        uint32_t            *p_SwPrsCode = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode, FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
+        uint32_t            *p_SwPrsCode;
         uint8_t             swPrsPatch[] = SW_PRS_IP_FRAG_PATCH;
 
+        /* To keep the compiler happy, we're initializing this here rather than at declaration! */
+        p_SwPrsCode = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode, FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
+
         ASSERT_COND(sizeof(swPrsPatch)<= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
         /* load sw parser Ip-Frag patch */
         FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
@@ -406,8 +409,6 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
     }
     if(p_SwPrs->size > FM_PCD_SW_PRS_SIZE - FM_PCD_PRS_SW_TAIL_SIZE - p_SwPrs->base*2)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size may not be larger than MAX_SW_PRS_CODE_SIZE"));
-    if(p_SwPrs->size % 4)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_SwPrs->size must be divisible by 4"));
 
     /* save sw parser labels */
     if(p_SwPrs->override)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index f74a3bd..2b6cd93 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -398,12 +398,11 @@ static uint32_t VerifyAndUpdateSizeOfFifo(t_FmPort *p_FmPort)
     }
 
     /* For O/H ports, check fifo size and update if necessary */
-    else if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-             (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+    else if((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         minFifoSizeRequired = (uint32_t)((p_FmPort->txFifoDeqPipelineDepth+4)*BMI_FIFO_UNITS);
 
     /* for all ports - update if necassary */
-    if (minFifoSizeRequired && (p_FmPort->fifoBufs.num < minFifoSizeRequired))
+    if(minFifoSizeRequired && (p_FmPort->fifoBufs.num < minFifoSizeRequired))
     {
         if(!p_FmPort->explicitUserSizeOfFifo)
             p_FmPort->fifoBufs.num = minFifoSizeRequired;
@@ -1026,14 +1025,15 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
 
             if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             {
-                t_FmRevisionInfo fmRevInfo, fmanCtrlCodeRevInfo;
+                t_FmRevisionInfo            fmRevInfo;
+                t_FmCtrlCodeRevisionInfo    fmanCtrlCodeRevInfo;
 
                 FM_GetRevision(p_FmPort->h_Fm, &fmRevInfo);
-				FM_GetFmanCtrlCodeRevision(p_FmPort->h_Fm, &fmanCtrlCodeRevInfo);
-				if ((fmanCtrlCodeRevInfo.majorRev == 106) &&
-					(fmRevInfo.majorRev < 4))
-					/* Set pop to next step nia for QMI Enqueue Frame*/
-					WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL);
+                FM_GetFmanCtrlCodeRevision(p_FmPort->h_Fm, &fmanCtrlCodeRevInfo);
+                if ((fmanCtrlCodeRevInfo.packageRev == 106) &&
+                    (fmRevInfo.majorRev < 4))
+                    /* Set pop to next step nia for QMI Enqueue Frame*/
+                    WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL);
             }
         }
 
@@ -1535,6 +1535,8 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     uint16_t                            absoluteProfileId;
     uint8_t                             physicalSchemeId;
     uint32_t                            ccTreePhysOffset;
+    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
+
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
@@ -1649,26 +1651,29 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    /* set PCD port parameter */
+    if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset, h_FmPort);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
+        p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
+    }
 
+    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    {
         if(p_PcdParams->p_KgParams->numOfSchemes == 0)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at least one scheme must be bound. "));
-        /* for each scheme */
-        for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
-        {
-            physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_PcdParams->p_KgParams->h_Schemes[i])-1);
-            /* build vector */
-            p_FmPort->schemesPerPortVector |= 1 << (31 - (uint32_t)physicalSchemeId);
-        }
 
         err = FmPcdKgSetOrBindToClsPlanGrp(p_FmPort->h_FmPcd,
-                                            p_FmPort->hardwarePortId,
-                                            p_FmPort->netEnvId,
-                                            p_FmPort->optArray,
-                                            &p_FmPort->clsPlanGrpId,
-                                            &isEmptyClsPlanGrp);
-         if(err)
+                                           p_FmPort->hardwarePortId,
+                                           p_FmPort->netEnvId,
+                                           p_FmPort->optArray,
+                                           &p_FmPort->clsPlanGrpId,
+                                           &isEmptyClsPlanGrp);
+         if (err)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
 
          p_FmPort->useClsPlan = !isEmptyClsPlanGrp;
@@ -1686,17 +1691,24 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             }
         }
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
-    }
 
-    /* set PCD port parameter */
-    if(p_FmPort->pcdEngines & FM_PCD_CC)
-    {
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset, h_FmPort);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+        schemeBind.netEnvId = p_FmPort->netEnvId;
+        schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
+        schemeBind.numOfSchemes = p_PcdParams->p_KgParams->numOfSchemes;
+        schemeBind.useClsPlan = p_FmPort->useClsPlan;
 
-        WRITE_UINT32(*p_BmiCcBase, ccTreePhysOffset);
-        p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
+        /* for each scheme */
+        for(i=0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+        {
+            physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_PcdParams->p_KgParams->h_Schemes[i])-1);
+            schemeBind.schemesIds[i] = physicalSchemeId;
+            /* build vector */
+            p_FmPort->schemesPerPortVector |= 1 << (31 - (uint32_t)physicalSchemeId);
+        }
+
+        err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
+        if (err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     /***************************/
@@ -2138,20 +2150,6 @@ pndn, pnen ... maybe were changed because of the Tree requirement*/
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
 
 #ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    if(p_FmPort->requiredAction & UPDATE_IPR_EN)
-    {
-        t_Error     err;
-
-        if(!p_FmPort->explicitUserSizeOfFifo)
-            p_FmPort->fifoBufs.num += (p_FmPort->tasks.num + p_FmPort->tasks.extra) * BMI_FIFO_UNITS;
-        else
-            p_FmPort->fifoBufs.num = MAX(p_FmPort->fifoBufs.num,
-                                         (p_FmPort->txFifoDeqPipelineDepth +
-                                          (p_FmPort->tasks.num + p_FmPort->tasks.extra) + 4) * BMI_FIFO_UNITS);
-        err = FmSetSizeOfFifo(p_FmPort->h_Fm, p_FmPort->hardwarePortId, p_FmPort->fifoBufs.num, p_FmPort->fifoBufs.extra, FALSE);
-        if(err)
-            RETURN_ERROR(MINOR, err, NO_MSG);
-    }
     if(p_FmPort->requiredAction & UPDATE_NIA_RFENE)
         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiRfene);
 #endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
@@ -2187,6 +2185,11 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         p_CcParams->getCcParams.numOfTasks = (uint8_t)p_FmPort->tasks.num;
         p_CcParams->getCcParams.type &= ~NUM_OF_TASKS;
     }
+    if(p_CcParams->getCcParams.type & NUM_OF_EXTRA_TASKS)
+    {
+        p_CcParams->getCcParams.numOfExtraTasks = (uint8_t)p_FmPort->tasks.extra;
+        p_CcParams->getCcParams.type &= ~NUM_OF_EXTRA_TASKS;
+    }
     if(p_CcParams->getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
     {
         if(p_CcParams->getCcParams.poolIndex < p_FmPort->extBufPools.numOfPoolsUsed)
@@ -2225,11 +2228,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
 
 #ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-    if(p_CcParams->setCcParams.type & UPDATE_IPR_EN)
-    {
-        p_FmPort->requiredAction |= UPDATE_IPR_EN;
-    }
-    else if((p_CcParams->setCcParams.type & UPDATE_NIA_RFENE) && !(p_FmPort->requiredAction & UPDATE_NIA_RFENE))
+    if((p_CcParams->setCcParams.type & UPDATE_NIA_RFENE) && !(p_FmPort->requiredAction & UPDATE_NIA_RFENE))
     {
         p_FmPort->savedBmiRfene = p_CcParams->setCcParams.nia;
         p_FmPort->requiredAction |= UPDATE_NIA_RFENE;
@@ -2516,6 +2515,8 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
+
+
     /************************************************************/
     /* Call FM module routine for communicating parameters      */
     /************************************************************/
@@ -2849,7 +2850,6 @@ t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmPortExtPools *p_FmPortE
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-
     if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
@@ -3301,11 +3301,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
                 --tries)
             XX_UDelay(1);
         if (!tries)
-        {
-            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
-                         GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
             RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
-        }
     }
 
     /* Disable BMI */
@@ -3320,14 +3316,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
         XX_UDelay(1);
 
     if (!tries)
-    {
-        if (!rxPort && !p_FmPort->imEn)
-			WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
-						 GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
-        WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
-
         RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
-    }
 
     p_FmPort->enabled = 0;
 
@@ -4170,7 +4159,6 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
         if(err)
             RETURN_ERROR(MAJOR, err,NO_MSG);
     }
-    /* set the port handle within the PCD policer, even if no profiles defined */
     FmPcdPortRegister(p_FmPort->h_FmPcd, h_FmPort, p_FmPort->hardwarePortId);
 
     return E_OK;
@@ -4340,8 +4328,8 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
-    /*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...
-             it has to be returned to the default state - initially*/
+/*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...
+         it has to be returned to the default state - initially*/
 
     p_FmPort->requiredAction = 0;
 
@@ -4489,9 +4477,7 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
 t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 {
     t_FmPort                                *p_FmPort = (t_FmPort*)h_FmPort;
-    t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
     t_Error                                 err = E_OK;
-    uint8_t                                 i;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -4511,33 +4497,12 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    if(p_FmPort->pcdEngines & FM_PCD_KG)
-    {
-        schemeBind.netEnvId = p_FmPort->netEnvId;
-        schemeBind.hardwarePortId = p_FmPort->hardwarePortId;
-        schemeBind.numOfSchemes = p_PcdParams->p_KgParams->numOfSchemes;
-        schemeBind.useClsPlan = p_FmPort->useClsPlan;
-        for(i = 0;i<schemeBind.numOfSchemes;i++)
-            schemeBind.schemesIds[i] = (uint8_t)(PTR_TO_UINT(p_PcdParams->p_KgParams->h_Schemes[i])-1);
-
-        err = FmPcdKgBindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
-        if(err)
-        {
-            DeletePcd(p_FmPort);
-            RELEASE_LOCK(p_FmPort->lock);
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-        }
-    }
-
     if ((p_FmPort->pcdEngines & FM_PCD_PRS) && (p_PcdParams->p_PrsParams->includeInPrsStatistics))
         FmPcdPrsIncludePortInStatistics(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, TRUE);
 
     FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
     err = FmPortAttachPCD(h_FmPort);
-    if(err)
-        DeletePcd(p_FmPort);
-
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index a75f673..d02b54d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -463,8 +463,9 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
     WRITE_UINT32(p_Iram->iready, IRAM_READY);
     XX_UDelay(1000);
 
-    DBG(INFO, ("FMan-Controller code (ver %d.%d) loaded to IRAM.",
-               ((uint8_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[5],
+    DBG(INFO, ("FMan-Controller code (ver %d.%d.%d) loaded to IRAM.",
+               ((uint16_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[2],
+               ((uint8_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[6],
                ((uint8_t *)p_Fm->p_FmDriverParam->firmware.p_Code)[7]));
 
     return E_OK;
@@ -1377,7 +1378,6 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
-
         return E_OK;
     }
 
@@ -2453,7 +2453,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM firmware code"));
             return NULL;
         }
-        memcpy(p_Fm->p_FmDriverParam->firmware.p_Code, p_FmParam->firmware.p_Code, p_Fm->p_FmDriverParam->firmware.size);
+        memcpy(p_Fm->p_FmDriverParam->firmware.p_Code, p_FmParam->firmware.p_Code ,p_Fm->p_FmDriverParam->firmware.size);
     }
 
     return p_Fm;
@@ -2708,14 +2708,14 @@ t_Error FM_Init(t_Handle h_Fm)
 
     /* configure thresholds register */
     tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.assertEmergency << DMA_THRESH_COMMQ_SHIFT) |
-                ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
-                ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
+              ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.assertEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+              ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.assertEmergency);
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmtr, tmpReg);
 
     /* configure hysteresis register */
     tmpReg = ((uint32_t)p_FmDriverParam->dmaCommQThresholds.clearEmergency << DMA_THRESH_COMMQ_SHIFT) |
-                ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
-                ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.clearEmergency);
+              ((uint32_t)p_FmDriverParam->dmaReadBufThresholds.clearEmergency << DMA_THRESH_READ_INT_BUF_SHIFT) |
+              ((uint32_t)p_FmDriverParam->dmaWriteBufThresholds.clearEmergency);
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmhy, tmpReg);
 
     /* configure emergency threshold */
@@ -3953,6 +3953,7 @@ t_Error FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
     t_FmIpcRevisionInfo ipcRevInfo;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmRevisionInfo, E_NULL_POINTER);
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -3984,10 +3985,10 @@ t_Error FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
     return E_OK;
 }
 
-t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmRevisionInfo *p_RevisionInfo)
+t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_RevisionInfo)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    t_FMIramRegs    	*p_Iram;
+    t_FMIramRegs        *p_Iram;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_RevisionInfo, E_NULL_POINTER);
@@ -3997,7 +3998,9 @@ t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmRevisionInfo *p_RevisionIn
 
     p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
     WRITE_UINT32(p_Iram->iadd, 0x4);
-    p_RevisionInfo->majorRev = ((uint8_t *)&p_Iram->idata)[1];
+    while (GET_UINT32(p_Iram->iadd) != 0x4) ;
+    p_RevisionInfo->packageRev = ((uint16_t *)&p_Iram->idata)[0];
+    p_RevisionInfo->majorRev = ((uint8_t *)&p_Iram->idata)[2];
     p_RevisionInfo->minorRev = ((uint8_t *)&p_Iram->idata)[3];
 
     return E_OK;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index 1260c81..f89b120 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -178,7 +178,7 @@ typedef struct {
 
     uint8_t     poolIdForManip;
     uint8_t     numOfTasks;
-
+    uint8_t     numOfExtraTasks;
     uint8_t     hardwarePortId;
 
 } t_GetCcParams;
@@ -231,6 +231,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define NUM_OF_TASKS                            0x10000000
 #define OFFSET_OF_DATA                          0x08000000
 #define HW_PORT_ID                              0x04000000
+#define NUM_OF_EXTRA_TASKS                      0x02000000
 
 
 #define UPDATE_NIA_PNEN                         0x80000000
@@ -238,7 +239,6 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_NIA_PNDN                         0x20000000
 #define UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY      0x10000000
 #ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
-#define UPDATE_IPR_EN                           0x08000000
 #define UPDATE_NIA_RFENE                        0x04000000
 #endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 /* @} */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index aca8a04..67ba811 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -1026,7 +1026,7 @@ typedef enum e_FmCounters {
 } e_FmCounters;
 
 /**************************************************************************//**
- @Description   structure for returning revision information
+ @Description   structure for returning FM revision information
 *//***************************************************************************/
 typedef struct t_FmRevisionInfo {
     uint8_t         majorRev;               /**< Major revision */
@@ -1034,6 +1034,15 @@ typedef struct t_FmRevisionInfo {
 } t_FmRevisionInfo;
 
 /**************************************************************************//**
+ @Description   structure for returning FM ctrl code revision information
+*//***************************************************************************/
+typedef struct t_FmCtrlCodeRevisionInfo {
+    uint16_t        packageRev;             /**< Package revision */
+    uint8_t         majorRev;               /**< Major revision */
+    uint8_t         minorRev;               /**< Minor revision */
+} t_FmCtrlCodeRevisionInfo;
+
+/**************************************************************************//**
  @Description   struct for defining DMA status
 *//***************************************************************************/
 typedef struct t_FmDmaStatus {
@@ -1159,7 +1168,7 @@ t_Error  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
-t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmRevisionInfo *p_RevisionInfo);
+t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_RevisionInfo);
 
 /**************************************************************************//**
  @Function      FM_GetCounter
@@ -1332,4 +1341,5 @@ t_Error FmDumpPortRegs(t_Handle h_Fm,uint8_t hardwarePortId);
 /** @} */ /* end of FM_lib_grp group */
 /** @} */ /* end of FM_grp group */
 
+
 #endif /* __FM_EXT */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index cc41bc6..1f1a6f8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -1457,7 +1457,7 @@ typedef struct t_FmPcdCcKeyParams {
  @Description   A structure for defining CC Keys parameters
 *//***************************************************************************/
 typedef struct t_KeysParams {
-    uint8_t                     numOfKeys;      /**< Number Of relevant Keys;
+    uint16_t                    numOfKeys;      /**< Number Of relevant Keys;
                                                      Note that in case of action = e_FM_PCD_ACTION_INDEXED_LOOKUP,
                                                      this field should be power-of-2 of the number of bits that are
                                                      set in 'icIndxMask'. */
@@ -1660,7 +1660,7 @@ typedef struct t_CapwapFragmentationParams {
  @Description   structure for defining CAPWAP Re-assembly
 *//***************************************************************************/
 typedef struct t_CapwapReassemblyParams {
-    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by Reassembly in the same time.
+    uint16_t                         maxNumFramesInProcess; /**< Number of frames which can be processed by Reassembly in the same time.
                                                                  It has to be power of 2.
                                                                  In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
                                                                  maxNumFramesInProcess has to be in the range of 4 - 512,
@@ -1710,8 +1710,9 @@ typedef struct t_IpReassemblyParams {
                                                                  Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
                                                                  the user schemes id to ensure that the reassembly's schemes will be first match.
                                                                  Rest schemes, if defined, should have higher relative scheme ID */
-    uint16_t                        liodnOffset;            /**< LIODN offset. */
+    uint8_t                         sgBpid;                 /**< Buffer pool id for the S/G frame created by the reassembly process */
     uint8_t                         dataMemId;              /**< Memory partition ID for data buffers */
+    uint16_t                        dataLiodnOffset;        /**< LIODN offset for access the IPR's external tables structure. */
     uint16_t                        minFragSize[2];         /**< Minimum frag size.
                                                                  minFragSize[0] - for ipv4
                                                                  minFragSize[1] - for ipv6 */
@@ -2026,7 +2027,7 @@ t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle                  h_FmPcd,
 *//***************************************************************************/
 t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle                  h_FmPcd,
                                       t_Handle                  h_CcNode,
-                                      uint16_t                   keyIndex,
+                                      uint16_t                  keyIndex,
                                       t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
@@ -2082,7 +2083,7 @@ t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t key
 *//***************************************************************************/
 t_Error FM_PCD_CcNodeAddKey(t_Handle            h_FmPcd,
                             t_Handle            h_CcNode,
-                            uint16_t             keyIndex,
+                            uint16_t            keyIndex,
                             uint8_t             keySize,
                             t_FmPcdCcKeyParams  *p_KeyParams);
 
@@ -2106,7 +2107,7 @@ t_Error FM_PCD_CcNodeAddKey(t_Handle            h_FmPcd,
 *//***************************************************************************/
 t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle            h_FmPcd,
                                             t_Handle            h_CcNode,
-                                            uint16_t             keyIndex,
+                                            uint16_t            keyIndex,
                                             uint8_t             keySize,
                                             t_FmPcdCcKeyParams  *p_KeyParams);
 
@@ -2130,7 +2131,7 @@ t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle            h_FmPcd,
 *//***************************************************************************/
 t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd,
                                t_Handle h_CcNode,
-                               uint16_t  keyIndex,
+                               uint16_t keyIndex,
                                uint8_t  keySize,
                                uint8_t  *p_Key,
                                uint8_t  *p_Mask);
@@ -2185,7 +2186,7 @@ t_Error FM_PCD_CcIndexedHashNodeGetBucket(t_Handle    h_FmPcd,
 *//***************************************************************************/
 t_Error FM_PCD_CcNodeGetNextEngine(t_Handle                     h_FmPcd,
                                    t_Handle                     h_CcNode,
-                                   uint16_t                      keyIndex,
+                                   uint16_t                     keyIndex,
                                    t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
@@ -2204,7 +2205,7 @@ t_Error FM_PCD_CcNodeGetNextEngine(t_Handle                     h_FmPcd,
  @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
                 relevant node but also the node that points to this node
 *//***************************************************************************/
-uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex);
+uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex);
 
 /**************************************************************************//**
  @Function      FM_PCD_PlcrSetProfile
@@ -2330,4 +2331,6 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcds
 /** @} */ /* end of FM_PCD_grp group */
 /** @} */ /* end of FM_grp group */
 
+
+
 #endif /* __FM_PCD_EXT */
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index f750006..f736ede 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -1100,7 +1100,7 @@ typedef struct ioc_fm_pcd_cc_key_params_t {
  @Description   A structure for defining CC Keys parameters
 *//***************************************************************************/
 typedef struct ioc_keys_params_t {
-    uint8_t                             num_of_keys;    /**< num Of relevant Keys  */
+    uint16_t                            num_of_keys;    /**< num Of relevant Keys  */
     uint8_t                             key_size;       /**< size of the key - in the case of the extraction of
                                                              the type FULL_FIELD keySize has to be as standard size of the relevant
                                                              key. In the another type of extraction keySize has to be as size of extraction. */
@@ -1260,7 +1260,7 @@ typedef struct ioc_fm_pcd_cc_tree_modify_next_engine_params_t {
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
     void                                *id;                /**< CC node Id to be used */
-    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
                                                                  NOTE: This parameter is IGNORED for miss-key!  */
     uint8_t                             key_size;           /**< Key size of added key */
     ioc_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
@@ -1272,7 +1272,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_next_engine_params_t {
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
     void                                *id;                /**< CC node Id to be used */
-    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
                                                                  NOTE: This parameter is IGNORED for miss-key!  */
     uint8_t                             key_size;           /**< Key size of added key */
     ioc_fm_pcd_cc_key_params_t          key_params;         /**< it's array with numOfKeys entries each entry in
@@ -1284,7 +1284,7 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t {
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
     void                                *id;                /**< CC node Id to be used */
-    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
                                                                  NOTE: This parameter is IGNORED for miss-key!  */
 } ioc_fm_pcd_cc_node_remove_key_params_t;
 
@@ -1293,7 +1293,7 @@ typedef struct ioc_fm_pcd_cc_node_remove_key_params_t {
 *//***************************************************************************/
 typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
     void                                *id;                /**< CC node Id to be used */
-    uint8_t                             key_indx;           /**< Key index for Next Engine Params modifications;
+    uint16_t                            key_indx;           /**< Key index for Next Engine Params modifications;
                                                                  NOTE: This parameter is IGNORED for miss-key!  */
     uint8_t                             key_size;           /**< Key size of added key */
     uint8_t                             *p_key;             /**< pointer to the key of the size defined in keySize */
@@ -1366,8 +1366,9 @@ typedef struct ioc_ip_fragmentation_params_t {
 
 typedef struct ioc_ip_reassembly_params_t {
     uint8_t                         relative_schemeId[2];
-    uint16_t                        liodn_offset;
+    uint8_t                         sg_bpid;
     uint8_t                         data_mem_id;
+    uint16_t                        data_liodn_offset;
     uint16_t                        min_frag_size[2];
     uint16_t                        max_num_frames_in_process;
     ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;
-- 
1.7.9.7

