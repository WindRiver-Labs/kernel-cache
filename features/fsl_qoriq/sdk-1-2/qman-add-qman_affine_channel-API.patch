From fc3881ed5d3ac3c511580f38f2f3368aba11e353 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Thu, 3 Nov 2011 13:53:03 -0500
Subject: [PATCH 069/128] qman: add qman_affine_channel() API

For driver initialisation of software-consumed frame queues, it can be
useful to know the channel ID of an affine portal without necessarily
running on the CPU to which it is affine.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c |   14 ++++++++++++++
 include/linux/fsl_qman.h              |   10 ++++++++++
 2 files changed, 24 insertions(+)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 6628361..f1a791a 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -133,6 +133,7 @@ static qman_cb_dc_ern cb_dc_ern;
 
 static cpumask_t affine_mask;
 static DEFINE_SPINLOCK(affine_mask_lock);
+static enum qm_channel affine_channels[NR_CPUS];
 static DEFINE_PER_CPU(struct qman_portal, qman_affine_portal);
 /* "raw" gets the cpu-local struct whether it's a redirect or not. */
 static inline struct qman_portal *get_raw_affine_portal(void)
@@ -531,6 +532,7 @@ drain_loop:
 	portal->config = config;
 	spin_lock(&affine_mask_lock);
 	cpumask_set_cpu(config->public_cfg.cpu, &affine_mask);
+	affine_channels[config->public_cfg.cpu] = config->public_cfg.channel;
 	spin_unlock(&affine_mask_lock);
 	qm_isr_disable_write(__p, 0);
 	/* Write a sane SDQCR */
@@ -977,6 +979,18 @@ const cpumask_t *qman_affine_cpus(void)
 }
 EXPORT_SYMBOL(qman_affine_cpus);
 
+enum qm_channel qman_affine_channel(int cpu)
+{
+	if (cpu < 0) {
+		struct qman_portal *portal = get_raw_affine_portal();
+		BUG_ON(portal->sharing_redirect);
+		cpu = portal->config->public_cfg.cpu;
+		put_affine_portal();
+	}
+	BUG_ON(!cpumask_test_cpu(cpu, &affine_mask));
+	return affine_channels[cpu];
+}
+
 int qman_poll_dqrr(unsigned int limit)
 {
 	struct qman_portal *p = get_poll_portal();
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index fab8d3b..15c7aaa 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1233,6 +1233,16 @@ int qman_irqsource_remove(u32 bits);
 const cpumask_t *qman_affine_cpus(void);
 
 /**
+ * qman_affine_channel - return the channel ID of an portal
+ * @cpu: the cpu whose affine portal is the subject of the query
+ *
+ * If @cpu is -1, the affine portal for the current CPU will be used. It is a
+ * bug to call this function for any value of @cpu (other than -1) that is not a
+ * member of the mask returned from qman_affine_cpus().
+ */
+enum qm_channel qman_affine_channel(int cpu);
+
+/**
  * qman_poll_dqrr - process DQRR (fast-path) entries
  * @limit: the maximum number of DQRR entries to process
  *
-- 
1.7.9.7

