From 5f1dd53e8b6a60235f248fc8dc12a1b10f96816d Mon Sep 17 00:00:00 2001
From: Stefan Szabo <szbs001@freescale.com>
Date: Mon, 30 Jan 2012 12:29:38 +0200
Subject: [PATCH 071/128] fmd: release 15.1

Integration of NetCommSw GA 4.4 patched for dealing with legacy ucode,
plus other NCSW-specific patches.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Signed-off-by: Andrei Pistirica <sorin.pistirica@freescale.com>
Signed-off-by: Razvan Ungureanu <rungure1@freescale.com>
Signed-off-by: Stefan Szabo <szbs001@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c |  182 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c       |  107 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h       |   26 +-
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |   65 +-
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c      |   11 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h      |   49 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |   71 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.h        |   21 +-
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c    |   29 +-
 .../NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h    |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/Makefile      |    7 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h       |  360 +++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       |  252 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |    6 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       |   61 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    | 2899 ++++++++++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |  307 +++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |  226 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |  153 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h  |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     |   16 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |   30 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    |  811 +++---
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |  112 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |    4 +-
 .../dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c      |   18 +-
 .../dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h      |    2 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |  417 +--
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.h    |    6 +-
 .../dpa/NetCommSw/Peripherals/FM/fm_ipc.h          |    3 +-
 .../dpa/NetCommSw/Peripherals/FM/fm_muram.c        |    2 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |   88 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h       |   17 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/error.c   |    2 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/list.c    |    2 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/memcpy.c  |    2 +-
 .../net/ethernet/freescale/dpa/NetCommSw/etc/mm.c  |    2 +-
 .../net/ethernet/freescale/dpa/NetCommSw/etc/mm.h  |    2 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/sprint.c  |    3 +-
 .../NetCommSw/inc/Peripherals/crc_mac_addr_ext.h   |    2 +-
 .../dpa/NetCommSw/inc/Peripherals/dpaa_ext.h       |    8 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |   80 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h     |   15 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h   |    2 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |  285 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |  248 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h     |    4 +-
 .../dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h    |    2 +-
 .../freescale/dpa/NetCommSw/inc/core_ext.h         |    2 +-
 .../freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h |    2 +-
 .../freescale/dpa/NetCommSw/inc/cores/ppc_ext.h    |    2 +-
 .../freescale/dpa/NetCommSw/inc/ctype_ext.h        |    2 +-
 .../freescale/dpa/NetCommSw/inc/debug_ext.h        |   38 +-
 .../freescale/dpa/NetCommSw/inc/endian_ext.h       |    2 +-
 .../freescale/dpa/NetCommSw/inc/enet_ext.h         |    2 +-
 .../freescale/dpa/NetCommSw/inc/error_ext.h        |    2 +-
 .../freescale/dpa/NetCommSw/inc/etc/list_ext.h     |    2 +-
 .../freescale/dpa/NetCommSw/inc/etc/mem_ext.h      |    4 +-
 .../freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h   |    2 +-
 .../freescale/dpa/NetCommSw/inc/etc/mm_ext.h       |    2 +-
 .../freescale/dpa/NetCommSw/inc/etc/sprint_ext.h   |    2 +-
 .../inc/integrations/P1023/dpaa_integration_ext.h  |   36 +-
 .../NetCommSw/inc/integrations/P1023/part_ext.h    |    3 +-
 .../inc/integrations/P1023/part_integration_ext.h  |   35 +-
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |  144 +-
 .../inc/integrations/P3040_P4080_P5020/part_ext.h  |    2 +-
 .../P3040_P4080_P5020/part_integration_ext.h       |    2 +-
 .../freescale/dpa/NetCommSw/inc/math_ext.h         |    2 +-
 .../freescale/dpa/NetCommSw/inc/ncsw_ext.h         |    3 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/net_ext.h |    2 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/std_ext.h |    2 +-
 .../freescale/dpa/NetCommSw/inc/stdarg_ext.h       |    2 +-
 .../freescale/dpa/NetCommSw/inc/stdlib_ext.h       |    2 +-
 .../freescale/dpa/NetCommSw/inc/string_ext.h       |    2 +-
 .../freescale/dpa/NetCommSw/inc/types_ext.h        |    8 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h  |    9 +-
 .../NetCommSw/integrations/P1023/module_strings.c  |    4 +-
 .../P3040_P4080_P5020/module_strings.c             |    2 +-
 .../freescale/dpa/NetCommSw/p1023_dflags.h         |    2 +-
 .../dpa/NetCommSw/p3040_4080_5020_dflags.h         |    2 +-
 .../dpa/NetCommSw/src/inc/system/sys_ext.h         |    2 +-
 .../dpa/NetCommSw/src/inc/system/sys_io_ext.h      |    2 +-
 .../freescale/dpa/NetCommSw/src/inc/types_linux.h  |    2 +-
 .../dpa/NetCommSw/src/inc/wrapper/fsl_fman.h       |    2 +-
 .../dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h  |    2 +-
 .../dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h  |    2 +-
 .../freescale/dpa/NetCommSw/src/inc/xx/xx.h        |    2 +-
 .../freescale/dpa/NetCommSw/src/system/sys_io.c    |    2 +-
 .../dpa/NetCommSw/src/wrapper/fman_test.c          |    4 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.c          |   12 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.h          |    4 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c     |  123 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c   |  438 ++-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.c          |   53 +-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.h          |   28 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.c   |   14 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.h   |    8 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c       |    2 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h       |    2 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c    |    2 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h    |    2 +-
 .../NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c   |    2 +-
 .../NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h   |    2 +-
 .../freescale/dpa/NetCommSw/src/xx/stdlib.c        |    2 +-
 .../freescale/dpa/NetCommSw/src/xx/udivdi3.c       |    2 +-
 .../freescale/dpa/NetCommSw/src/xx/xx_linux.c      |    2 +-
 include/linux/fmd/Peripherals/fm_ioctls.h          |    2 +-
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      |  306 ++-
 include/linux/fmd/Peripherals/fm_port_ioctls.h     |   16 +-
 include/linux/fmd/Peripherals/fm_test_ioctls.h     |    2 +-
 .../linux/fmd/integrations/integration_ioctls.h    |    2 +-
 include/linux/fmd/ioctls.h                         |    2 +-
 include/linux/fmd/net_ioctls.h                     |   13 +-
 114 files changed, 6576 insertions(+), 1836 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index fa9d3de..6c91ac3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -44,6 +44,16 @@
 #define HC_HCOR_OPCODE_SYNC                                     0x2
 #define HC_HCOR_OPCODE_CC                                       0x3
 #define HC_HCOR_OPCODE_CC_CAPWAP_REASSM_TIMEOUT                 0x5
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+#define HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT                     0x10
+#define HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION                0x11
+#define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT       24
+#define HC_HCOR_EXTRA_REG_IP_REASSM_TIMEOUT_TSBS_SHIFT          24
+#define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_SHIFT          16
+#define HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK           0xF
+#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_CMD_SHIFT       24
+#define HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_BPID            16
+#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
 
 #define HC_HCOR_GBL                         0x20000000
 
@@ -105,6 +115,9 @@ typedef _Packed struct t_HcFrame {
         t_FmPcdKgPortRegs                       portRegsForRead;
         volatile uint32_t                       clsPlanEntries[CLS_PLAN_NUM_PER_GRP];
         t_FmPcdCcCapwapReassmTimeoutParams      ccCapwapReassmTimeout;
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        t_FmPcdCcIpReassmTimeoutParams          ccIpReassmTimeout;
+#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
     } hcSpecificData;
 } _PackedType t_HcFrame;
 
@@ -165,7 +178,7 @@ static t_Error CcHcDoDynamicChange(t_FmHc *p_FmHc, t_Handle p_OldPointer, t_Hand
 
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC);
@@ -355,7 +368,7 @@ t_Handle FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme)
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
     {
-        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
         return NULL;
     }
 
@@ -496,7 +509,7 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
     if (!p_HcFrame)
     {
         FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     }
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
@@ -552,7 +565,7 @@ t_Error FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t re
                 if (!p_HcFrame)
                 {
                     FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
-                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
                 }
                 memset(p_HcFrame, 0, sizeof(t_HcFrame));
                 p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
@@ -609,8 +622,59 @@ t_Error FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t re
                     FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
                     RETURN_ERROR(MAJOR, err, NO_MSG);
                 }
+            }
+        }
+        if(requiredAction & UPDATE_KG_NIA_CC_WA)
+        {
+            if (FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_CC)
+            {
+                p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+                if (!p_HcFrame)
+                {
+                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
+                }
+                memset(p_HcFrame, 0, sizeof(t_HcFrame));
+                p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+                p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+                p_HcFrame->extraReg = 0xFFFFF800;
+                BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
+                if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+                {
+                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+                    XX_FreeSmart(p_HcFrame);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                /* check if this scheme is already used */
+                if (!FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
+                {
+                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+                    XX_FreeSmart(p_HcFrame);
+                    RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is already used"));
+                }
+                tmpReg32 = p_HcFrame->hcSpecificData.schemeRegs.kgse_mode;
+
+                ASSERT_COND(tmpReg32 & (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
+                tmpReg32 &= ~NIA_FM_CTL_AC_CC;
+                p_HcFrame->hcSpecificData.schemeRegs.kgse_mode =  tmpReg32 | NIA_FM_CTL_AC_PRE_CC;
+
+                p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
+                p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+                p_HcFrame->extraReg = 0x80000000;
+
+                BUILD_FD(sizeof(t_HcFrame));
+
+                if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+                {
+                    FmPcdKgReleaseSchemeLock(p_FmHc->h_FmPcd, relativeSchemeId);
+                    XX_FreeSmart(p_HcFrame);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                XX_FreeSmart(p_HcFrame);
+           }
         }
-      }
     }
 
     FmPcdKgUpatePointedOwner(p_FmHc->h_FmPcd, relativeSchemeId,TRUE);
@@ -647,7 +711,7 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
     {
-        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
         return 0;
     }
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -699,7 +763,7 @@ t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t
     /* first read scheme and check that it is valid */
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
@@ -751,7 +815,7 @@ t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_S
 
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
     {
@@ -779,10 +843,10 @@ t_Error FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t  grpId)
     t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
     t_FmPcdKgInterModuleClsPlanSet      *p_ClsPlanSet;
 
-    /* clear clsPlan entries in memory */
     p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
     if (!p_ClsPlanSet)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_ClsPlanSetd"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
+
     memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
 
     p_ClsPlanSet->baseEntry = FmPcdKgGetClsPlanGrpBase(p_FmHc->h_FmPcd, grpId);
@@ -811,7 +875,7 @@ t_Error FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeo
     intFlags = FmPcdLock(p_FmHc->h_FmPcd);
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_CAPWAP_REASSM_TIMEOUT);
     memcpy(&p_HcFrame->hcSpecificData.ccCapwapReassmTimeout, p_CcCapwapReassmTimeoutParams, sizeof(t_FmPcdCcCapwapReassmTimeoutParams));
@@ -824,6 +888,76 @@ t_Error FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeo
     return err;
 }
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+t_Error FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame                           *p_HcFrame;
+    t_DpaaFD                            fmFd;
+    t_Error                             err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
+
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
+
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+
+    p_HcFrame->opcode     = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_IP_FRAG_INITIALIZATION);
+    p_HcFrame->actionReg  = ((fill == TRUE) ? 0 : 1) << HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_CMD_SHIFT;
+    p_HcFrame->actionReg |= p_FmPcdCcFragScratchPoolCmdParams->bufferPoolId << HC_HCOR_ACTION_REG_IP_FRAG_SCRATCH_POOL_BPID;
+    if (fill == TRUE)
+    {
+        p_HcFrame->extraReg   = p_FmPcdCcFragScratchPoolCmdParams->numOfBuffers;
+    }
+    p_HcFrame->commandSequence = 0;
+
+    BUILD_FD(sizeof(t_HcFrame));
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_FreeSmart(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    p_FmPcdCcFragScratchPoolCmdParams->numOfBuffers = p_HcFrame->extraReg;
+
+    XX_FreeSmart(p_HcFrame);
+
+    return E_OK;
+}
+
+t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams *p_CcIpReassmTimeoutParams, uint8_t *p_Result)
+{
+    t_FmHc                              *p_FmHc = (t_FmHc*)h_FmHc;
+    t_HcFrame                           *p_HcFrame;
+    t_DpaaFD                            fmFd;
+    t_Error                             err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
+
+    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
+    if (!p_HcFrame)
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
+
+    memset(p_HcFrame, 0, sizeof(t_HcFrame));
+    p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT);
+    p_HcFrame->actionReg = (p_CcIpReassmTimeoutParams->activate ? 0 : 1) << HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT;
+    p_HcFrame->extraReg = (p_CcIpReassmTimeoutParams->tsbs << HC_HCOR_EXTRA_REG_IP_REASSM_TIMEOUT_TSBS_SHIFT) | p_CcIpReassmTimeoutParams->iprcpt;
+    p_HcFrame->commandSequence = 0;
+
+    BUILD_FD(sizeof(t_HcFrame));
+    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    {
+        XX_FreeSmart(p_HcFrame);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
+    *p_Result = (p_HcFrame->actionReg >> HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_SHIFT) & HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK;
+    XX_FreeSmart(p_HcFrame);
+
+   return E_OK;
+}
+#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
 
 t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, uint32_t requiredAction)
 {
@@ -854,7 +988,7 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
 
             p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
             if (!p_HcFrame)
-                RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
             /* first read scheme and check that it is valid */
             memset(p_HcFrame, 0, sizeof(t_HcFrame));
             p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
@@ -996,7 +1130,7 @@ t_Handle FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profi
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
     {
-        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
         return NULL;
     }
 
@@ -1077,7 +1211,7 @@ t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
 
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionReg(absoluteProfileId);
@@ -1116,7 +1250,7 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     /* first read scheme and check that it is valid */
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     p_HcFrame->actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
@@ -1179,7 +1313,7 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
     {
-        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
         return 0;
     }
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -1306,7 +1440,7 @@ t_Error FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_
     return E_OK;
 }
 
-t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex)
+t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_Handle    h_Params;
@@ -1346,7 +1480,7 @@ t_Error FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex)
 
 }
 
-t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_Handle    h_Params;
@@ -1386,7 +1520,7 @@ t_Error FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, ui
 }
 
 
-t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
+t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_List      h_OldPointersLst, h_NewPointersLst;
@@ -1426,7 +1560,7 @@ t_Error FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex,
     return err;
 }
 
-t_Error FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_Error     err = E_OK;
@@ -1463,7 +1597,7 @@ t_Error FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_
 }
 
 
-t_Error FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
 {
     t_FmHc      *p_FmHc = (t_FmHc*)h_FmHc;
     t_List      h_OldPointersLst, h_NewPointersLst;
@@ -1514,7 +1648,7 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
 
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     /* first read SP register */
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
@@ -1561,7 +1695,7 @@ t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
 
     p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), 0, 16);
     if (!p_HcFrame)
-        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame obj"));
+        RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     /* first read SP register */
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index f00adda..f011143 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -67,10 +67,10 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in half duplex"));
     if(p_Dtsec->p_DtsecDriverParam->halfDuplex && (p_Dtsec->p_DtsecDriverParam)->loopback)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("LoopBack is not supported in halfDuplex mode"));
-#ifdef FM_NO_RX_PREAM_ERRATA_DTSECx1
+#ifdef FM_RX_PREAM_4_ERRATA_DTSEC_A001
     if(p_Dtsec->p_DtsecDriverParam->preambleRxEn)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("preambleRxEn"));
-#endif /* FM_NO_RX_PREAM_ERRATA_DTSECx1 */
+#endif /* FM_RX_PREAM_4_ERRATA_DTSEC_A001 */
     if(((p_Dtsec->p_DtsecDriverParam)->preambleTxEn || (p_Dtsec->p_DtsecDriverParam)->preambleRxEn) &&( (p_Dtsec->p_DtsecDriverParam)->preambleLength != 0x7))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Preamble length should be 0x7 bytes"));
     if((p_Dtsec->p_DtsecDriverParam)->fifoTxWatermarkH<((p_Dtsec->p_DtsecDriverParam)->fifoTxThr+8))
@@ -97,59 +97,12 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
     /*  Set up the PHY using the MII Management Interface */
     if (p_Dtsec->p_DtsecDriverParam->tbiPhyAddr > MAX_PHYS)
         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("PHY address (should be 0-%d)", MAX_PHYS));
-    if(!p_Dtsec->f_Exception)
+    if (!p_Dtsec->f_Exception)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("uninitialized f_Exception"));
-    if(!p_Dtsec->f_Event)
+    if (!p_Dtsec->f_Event)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("uninitialized f_Event"));
-    return E_OK;
-}
-
-static uint8_t GetMiiDiv(int32_t refClk)
-{
-    uint32_t    div,tmpClk;
-    int         minRange;
 
-    div = 1;
-    minRange = (int)(refClk/40 - 1);
-
-    tmpClk = (uint32_t)ABS(refClk/60 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 2;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/60 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 3;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/80 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 4;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/100 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 5;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/140 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 6;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/280 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 7;
-        minRange = (int)tmpClk;
-    }
-
-    return (uint8_t)div;
+    return E_OK;
 }
 
 /* ........................................................................... */
@@ -165,8 +118,8 @@ static void SetDefaultParam(t_DtsecDriverParam *p_DtsecDriverParam)
 
     p_DtsecDriverParam->halfDuplex              = DEFAULT_halfDuplex;
     p_DtsecDriverParam->halfDulexFlowControlEn  = DEFAULT_halfDulexFlowControlEn;
-    p_DtsecDriverParam->txTimeStampEn           = DEFAULT_txTimeStampEn;
-    p_DtsecDriverParam->rxTimeStampEn           = DEFAULT_rxTimeStampEn;
+    p_DtsecDriverParam->txTimeStampEn           = DEFAULT_timeStampEnable;
+    p_DtsecDriverParam->rxTimeStampEn           = DEFAULT_timeStampEnable;
 
     p_DtsecDriverParam->packetAlignmentPadding = DEFAULT_packetAlignment;
     p_DtsecDriverParam->controlFrameAccept     = DEFAULT_controlFrameAccept;
@@ -178,7 +131,7 @@ static void SetDefaultParam(t_DtsecDriverParam *p_DtsecDriverParam)
 
     p_DtsecDriverParam->loopback               = DEFAULT_loopback;
     p_DtsecDriverParam->tbiPhyAddr             = DEFAULT_tbiPhyAddr;
-    p_DtsecDriverParam->actOnRxPauseFrame      = DEFAULT_actOnRxPauseFrame;
+    p_DtsecDriverParam->actOnRxPauseFrame      = !DEFAULT_rxIgnorePause;
     p_DtsecDriverParam->actOnTxPauseFrame      = DEFAULT_actOnTxPauseFrame;
 
     p_DtsecDriverParam->preambleLength         = DEFAULT_PreAmLength;
@@ -524,13 +477,13 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
     XX_UDelay(100);
 #endif /* FM_GRS_ERRATA_DTSEC_A002 */
 
-#ifdef FM_GTS_ERRATA_DTSEC_A004
+#if defined(FM_GTS_ERRATA_DTSEC_A004) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012) || defined(FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014)
     DBG(INFO, ("GTS not supported due to DTSEC_A004 errata."));
-#else  /* not FM_GTS_ERRATA_DTSEC_A004 */
+#else  /* not defined(FM_GTS_ERRATA_DTSEC_A004) ||... */
     if (mode & e_COMM_MODE_TX)
         WRITE_UINT32(p_MemMap->tctrl,
                      GET_UINT32(p_MemMap->tctrl) | TCTRL_GTS);
-#endif /* not FM_GTS_ERRATA_DTSEC_A004 */
+#endif /* defined(FM_GTS_ERRATA_DTSEC_A004) ||...  */
 
     return E_OK;
 }
@@ -758,15 +711,6 @@ static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime)
         }
 #endif /* FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003 */
 
-#ifdef FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1
-        {
-            t_FmRevisionInfo revInfo;
-            FM_GetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
-            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                pauseTime += 2;
-        }
-#endif /* FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1 */
-
         ptv = GET_UINT32(p_MemMap->ptv);
         ptv |= pauseTime;
         WRITE_UINT32(p_MemMap->ptv, ptv);
@@ -1370,10 +1314,9 @@ static t_Error DtsecSetException(t_Handle h_Dtsec, e_FmMacExceptions exception,
 
         /* warn if MIB OVFL is disabled and statistic gathering is enabled */
         if((exception == e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL) &&
-                !enable &&
-                (p_Dtsec->statisticsLevel != e_FM_MAC_NONE_STATISTICS))
-            DBG(WARNING, ("Disabled MIB counters overflow exceptions. Counters value may be inaccurate due to unregistered overflow"));
-
+            !enable &&
+            (p_Dtsec->statisticsLevel != e_FM_MAC_NONE_STATISTICS))
+            DBG(INFO, ("Disabled MIB counters overflow exceptions. Counters value may be inaccurate due to unregistered overflow"));
     }
     else
     {
@@ -1531,14 +1474,6 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
 
     /***************PTV************************/
     tmpReg32 = 0;
-#ifdef FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            p_DtsecDriverParam->pauseTime += 2;
-    }
-#endif /* FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1 */
     if (p_DtsecDriverParam->pauseTime)
         tmpReg32 |= (uint32_t)p_DtsecDriverParam->pauseTime;
 
@@ -1589,13 +1524,6 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     /* conflict with the external PHY’s Physical address   */
     WRITE_UINT32(p_DtsecMemMap->tbipa, p_DtsecDriverParam->tbiPhyAddr);
 
-    /* Reset the management interface */
-    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg, MIIMCFG_RESET_MGMT);
-    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg, ~MIIMCFG_RESET_MGMT);
-    /* Setup the MII Mgmt clock speed */
-    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg,
-                 (uint32_t)GetMiiDiv((int32_t)(((p_Dtsec->fmMacControllerDriver.clkFreq*10)/2)/8)));
-
     if(p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
     {
         uint16_t            tmpReg16;
@@ -1607,9 +1535,8 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         tmpReg16 = PHY_TBICON_CLK_SEL;
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
 
-        tmpReg16 = PHY_CR_SPEED1;
-        if(!p_DtsecDriverParam->halfDuplex)
-            tmpReg16 |= PHY_CR_FULLDUPLEX | PHY_CR_PHY_RESET | PHY_CR_ANE;
+        tmpReg16 = (PHY_CR_PHY_RESET | PHY_CR_ANE | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
+
         DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
 
         tmpReg16 = PHY_TBIANA_SGMII;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index 3bd578e..54c44b2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -148,13 +148,8 @@ typedef  uint32_t t_ErrorDisable;
 #define DTSEC_TO_MII_OFFSET             0x1120  /* number of pattern match registers (entries) */
 
 #define DEFAULT_errorDisabled           0
-#define DEFAULT_promiscuousEnable       FALSE
 #define DEFAULT_pauseExtended           0x0
-#define DEFAULT_pauseTime               0xf000
-#define DEFAULT_halfDuplex              FALSE
 #define DEFAULT_halfDulexFlowControlEn  FALSE
-#define DEFAULT_txTimeStampEn           FALSE
-#define DEFAULT_rxTimeStampEn           FALSE
 #define DEFAULT_packetAlignment         0
 #define DEFAULT_controlFrameAccept      FALSE
 #define DEFAULT_groupHashExtend         FALSE
@@ -162,22 +157,16 @@ typedef  uint32_t t_ErrorDisable;
 #define DEFAULT_rxShortFrame            TRUE
 #define DEFAULT_exactMatch              FALSE
 #define DEFAULT_debugMode               FALSE
-#define DEFAULT_loopback                FALSE
-#define DEFAULT_actOnRxPauseFrame       TRUE
+#define DEFAULT_tbiPhyAddr              5
 #define DEFAULT_actOnTxPauseFrame       TRUE
-
 #define DEFAULT_PreAmLength             0x7
 #define DEFAULT_PreAmRxEn               FALSE
 #define DEFAULT_PreAmTxEn               FALSE
-#define DEFAULT_lengthCheckEnable       FALSE
-#define DEFAULT_padAndCrcEnable         TRUE
 #define DEFAULT_crcEnable               FALSE
-
 #define DEFAULT_nonBackToBackIpg1       0x40
 #define DEFAULT_nonBackToBackIpg2       0x60
 #define DEFAULT_minIfgEnforcement       0x50
 #define DEFAULT_backToBackIpg           0x60
-
 #define DEFAULT_altBackoffVal           0x0A
 #define DEFAULT_altBackoffEnable        FALSE
 #define DEFAULT_backPressureNoBackoff   FALSE
@@ -185,15 +174,10 @@ typedef  uint32_t t_ErrorDisable;
 #define DEFAULT_excessDefer             TRUE
 #define DEFAULT_maxRetransmission       0x0F
 #define DEFAULT_collisionWindow         0x37
-
-#define DEFAULT_maxFrameLength          0x600
-
-#define DEFAULT_collisionWindow         0x37
-
 #define DEFAULT_fifoTxThr               0x10
 #define DEFAULT_fifoTxWatermarkH        0x7e
 #define DEFAULT_fifoRxWatermarkL        0x08
-#define DEFAULT_tbiPhyAddr              5
+#define DEFAULT_timeStampEnable         FALSE
 
 #define DEFAULT_exceptions              ((uint32_t)(IMASK_BREN    | \
                                                     IMASK_RXCEN   | \
@@ -455,9 +439,7 @@ typedef _Packed struct
     volatile uint32_t ipgifg;               /* 0x108 IPG/IFG */
     volatile uint32_t hafdup;               /* 0x10C Half-duplex */
     volatile uint32_t maxfrm;               /* 0x110 Maximum frame */
-    volatile uint32_t DTSEC_RESERVED7[3];   /* 0x114-0x11C register */
-    t_MiiAccessMemMap miiMemMap;
-    volatile uint32_t ifctrl;               /* 0x138 MII Mgmt:interface control */
+    volatile uint32_t DTSEC_RESERVED7[10];  /* 0x114-0x138 register */
     volatile uint32_t ifstat;               /* 0x13C Interface status */
     volatile uint32_t macstnaddr1;          /* 0x140 Station Address,part 1 */
     volatile uint32_t macstnaddr2;          /* 0x144 Station Address,part 2  */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
index be85fa2..14b53ea 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,6 +42,55 @@
 #include "dtsec.h"
 
 
+static uint8_t GetMiiDiv(int32_t refClk)
+{
+    uint32_t    div,tmpClk;
+    int         minRange;
+
+    div = 1;
+    minRange = (int)(refClk/40 - 1);
+
+    tmpClk = (uint32_t)ABS(refClk/60 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 2;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/60 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 3;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/80 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 4;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/100 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 5;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/140 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 6;
+        minRange = (int)tmpClk;
+    }
+    tmpClk = (uint32_t)ABS(refClk/280 - 1);
+    if (tmpClk < minRange)
+    {
+        div = 7;
+        minRange = (int)tmpClk;
+    }
+
+    return (uint8_t)div;
+}
+
+
 /*****************************************************************************/
 t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
                               uint8_t     phyAddr,
@@ -57,6 +106,11 @@ t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
 
     p_MiiAccess = p_Dtsec->p_MiiMemMap;
 
+    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg,
+                 (uint32_t)GetMiiDiv((int32_t)(((p_Dtsec->fmMacControllerDriver.clkFreq*10)/2)/8)));
+
+    CORE_MemoryBarrier();
+
     /* Stop the MII management read cycle */
     WRITE_UINT32(p_MiiAccess->miimcom, 0);
     /* Dummy read to make sure MIIMCOM is written */
@@ -71,6 +125,8 @@ t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
     /* Dummy read to make sure MIIMCON is written */
     tmpReg = GET_UINT32(p_MiiAccess->miimcon);
 
+    CORE_MemoryBarrier();
+
     /* Wait till MII management write is complete */
     while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
 
@@ -92,6 +148,11 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
 
     p_MiiAccess = p_Dtsec->p_MiiMemMap;
 
+    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg,
+                 (uint32_t)GetMiiDiv((int32_t)(((p_Dtsec->fmMacControllerDriver.clkFreq*10)/2)/8)));
+
+    CORE_MemoryBarrier();
+
     /* Setting up the MII Management Address Register */
     tmpReg = (uint32_t)((phyAddr << MIIMADD_PHY_ADDR_SHIFT) | reg);
     WRITE_UINT32(p_MiiAccess->miimadd, tmpReg);
@@ -101,6 +162,8 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
     /* Dummy read to make sure MIIMCOM is written */
     tmpReg = GET_UINT32(p_MiiAccess->miimcom);
 
+    CORE_MemoryBarrier();
+
     /* Wait till MII management read is complete */
     while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
index 7c529c2..6c0c449 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index 4eb3954..74dfaf5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -66,6 +66,12 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
     p_FmMacControllerDriver->macId          = p_FmMacParam->macId;
     p_FmMacControllerDriver->resetOnInit    = DEFAULT_resetOnInit;
 
+    if ((p_FmMacControllerDriver->clkFreq = FmGetClockFreq(p_FmMacControllerDriver->h_Fm)) == 0)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Can't get clock for MAC!"));
+        return NULL;
+    }
+
     return (t_Handle)p_FmMacControllerDriver;
 }
 
@@ -83,9 +89,6 @@ t_Error FM_MAC_Init (t_Handle h_FmMac)
                      p_FmMacControllerDriver->macId) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't reset MAC!"));
 
-    if ((p_FmMacControllerDriver->clkFreq = FmGetClockFreq(p_FmMacControllerDriver->h_Fm)) == 0)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Can't get clock for MAC!"));
-
     if (p_FmMacControllerDriver->f_FM_MAC_Init)
         return p_FmMacControllerDriver->f_FM_MAC_Init(h_FmMac);
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
index 9a64f14..3dfa6cd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -46,6 +46,27 @@
 
 #define __ERR_MODULE__  MODULE_FM_MAC
 
+/**************************************************************************//**
+ @Description       defaults
+*//***************************************************************************/
+
+
+#define DEFAULT_wanModeEnable               FALSE
+#define DEFAULT_promiscuousEnable           FALSE
+#define DEFAULT_rxIgnorePause               FALSE
+#define DEFAULT_maxFrameLength              0x600
+#define DEFAULT_pauseTime                   0xf000
+#define DEFAULT_halfDuplex                  FALSE
+#define DEFAULT_loopback                    FALSE
+#define DEFAULT_lengthCheckEnable           FALSE
+#define DEFAULT_padAndCrcEnable             TRUE
+
+
+
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+#define DEFAULT_skipFman11Workaround        FALSE
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+
 
 #define DEFAULT_resetOnInit                 FALSE
 
@@ -146,21 +167,25 @@ static __inline__ void FreeHashTable(t_EthHash *p_Hash)
     t_EthHashEntry  *p_HashEntry;
     int             i = 0;
 
-    if (!p_Hash || !p_Hash->p_Lsts)
-        return;
-
-    for(i=0; i<p_Hash->size; i++)
+    if (p_Hash)
     {
-        p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
-        while (p_HashEntry)
+        if  (p_Hash->p_Lsts)
         {
-            XX_Free(p_HashEntry);
-            p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
+            for(i=0; i<p_Hash->size; i++)
+            {
+                p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
+                while (p_HashEntry)
+                {
+                    XX_Free(p_HashEntry);
+                    p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
+                }
+            }
+
+            XX_Free(p_Hash->p_Lsts);
         }
-    }
 
-    XX_Free(p_Hash->p_Lsts);
-    XX_Free(p_Hash);
+        XX_Free(p_Hash);
+    }
 }
 
 /* ........................................................................... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index cbe3535..0de017d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -74,17 +74,19 @@ static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
 static void SetDefaultParam(t_TgecDriverParam *p_TgecDriverParam)
 {
     p_TgecDriverParam->wanModeEnable            = DEFAULT_wanModeEnable;
-    p_TgecDriverParam->promiscuousModeEnable    = DEFAULT_promiscuousModeEnable;
+    p_TgecDriverParam->promiscuousModeEnable    = DEFAULT_promiscuousEnable;
     p_TgecDriverParam->pauseForwardEnable       = DEFAULT_pauseForwardEnable;
-    p_TgecDriverParam->pauseIgnore              = DEFAULT_pauseIgnore;
+    p_TgecDriverParam->pauseIgnore              = DEFAULT_rxIgnorePause;
     p_TgecDriverParam->txAddrInsEnable          = DEFAULT_txAddrInsEnable;
 
-    p_TgecDriverParam->loopbackEnable           = DEFAULT_loopbackEnable;
+    p_TgecDriverParam->loopbackEnable           = DEFAULT_loopback;
     p_TgecDriverParam->cmdFrameEnable           = DEFAULT_cmdFrameEnable;
     p_TgecDriverParam->rxErrorDiscard           = DEFAULT_rxErrorDiscard;
     p_TgecDriverParam->phyTxenaOn               = DEFAULT_phyTxenaOn;
     p_TgecDriverParam->sendIdleEnable           = DEFAULT_sendIdleEnable;
-    p_TgecDriverParam->noLengthCheckEnable      = DEFAULT_noLengthCheckEnable;
+
+    p_TgecDriverParam->noLengthCheckEnable      = !DEFAULT_lengthCheckEnable;
+
     p_TgecDriverParam->lgthCheckNostdr          = DEFAULT_lgthCheckNostdr;
     p_TgecDriverParam->timeStampEnable          = DEFAULT_timeStampEnable;
     p_TgecDriverParam->rxSfdAny                 = DEFAULT_rxSfdAny;
@@ -381,7 +383,7 @@ static t_Error TgecConfigMaxFrameLength(t_Handle h_Tgec, uint16_t newVal)
 
 static t_Error TgecConfigLengthCheck(t_Handle h_Tgec, bool newVal)
 {
-#ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
+#if defined(FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010) || defined(FM_LEN_CHECK_ERRATA_FMAN_SW002)
 UNUSED(h_Tgec);
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
 
@@ -396,7 +398,7 @@ UNUSED(h_Tgec);
     p_Tgec->p_TgecDriverParam->noLengthCheckEnable = !newVal;
 
     return E_OK;
-#endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
+#endif /* FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010 */
 }
 
 /* .............................................................................. */
@@ -408,16 +410,6 @@ static t_Error TgecConfigException(t_Handle h_Tgec, e_FmMacExceptions exception,
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
-#ifdef FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
-        if((revInfo.majorRev <=2) &&
-            enable &&
-            ((exception == e_FM_MAC_EX_10G_LOC_FAULT) || (exception == e_FM_MAC_EX_10G_REM_FAULT)))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_MAC_EX_10G_LOC_FAULT and e_FM_MAC_EX_10G_REM_FAULT !"));
-    }
-#endif   /* FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001 */
 
     GET_EXCEPTION_FLAG(bitMask, exception);
     if(bitMask)
@@ -532,7 +524,6 @@ static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistic
     p_Statistics->reStatPause           = GET_UINT64(p_TgecMemMap->RXPF);
     p_Statistics->teStatPause           = GET_UINT64(p_TgecMemMap->TXPF);
 
-
 /* MIB II */
     p_Statistics->ifInOctets            = GET_UINT64(p_TgecMemMap->ROCT);
     p_Statistics->ifInMcastPkts         = GET_UINT64(p_TgecMemMap->RMCA);
@@ -546,7 +537,9 @@ static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistic
     p_Statistics->ifOutOctets           = GET_UINT64(p_TgecMemMap->TOCT);
     p_Statistics->ifOutMcastPkts        = GET_UINT64(p_TgecMemMap->TMCA);
     p_Statistics->ifOutBcastPkts        = GET_UINT64(p_TgecMemMap->TBCA);
-    p_Statistics->ifOutPkts             = GET_UINT64(p_TgecMemMap->TUCA);
+    p_Statistics->ifOutPkts             = GET_UINT64(p_TgecMemMap->TUCA)
+                                            + p_Statistics->ifOutMcastPkts
+                                            + p_Statistics->ifOutBcastPkts;
     p_Statistics->ifOutDiscards         = 0;
     p_Statistics->ifOutErrors           = GET_UINT64(p_TgecMemMap->TERR);
 
@@ -859,16 +852,6 @@ static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bo
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
 
     p_TgecMemMap = p_Tgec->p_MemMap;
-#ifdef FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
-        if((revInfo.majorRev <=2) &&
-            enable &&
-            ((exception == e_FM_MAC_EX_10G_LOC_FAULT) || (exception == e_FM_MAC_EX_10G_REM_FAULT)))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_MAC_EX_10G_LOC_FAULT and e_FM_MAC_EX_10G_REM_FAULT !"));
-    }
-#endif   /* FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001 */
 
     GET_EXCEPTION_FLAG(bitMask, exception);
     if(bitMask)
@@ -908,16 +891,20 @@ static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
 {
     t_Error err;
 
+#if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
     XX_Print("Applying 10G tx-ecc error workaround (10GMAC-A004) ...");
+#endif /* (DEBUG_ERRORS > 0) */
     /* enable and set promiscuous */
     WRITE_UINT32(p_Tgec->p_MemMap->cmd_conf_ctrl, CMD_CFG_PROMIS_EN | CMD_CFG_TX_EN | CMD_CFG_RX_EN);
     err = Fm10GTxEccWorkaround(p_Tgec->fmMacControllerDriver.h_Fm, p_Tgec->macId);
     /* disable */
     WRITE_UINT32(p_Tgec->p_MemMap->cmd_conf_ctrl, 0);
+#if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
     if (err)
         XX_Print("FAILED!\n");
     else
         XX_Print("done.\n");
+#endif /* (DEBUG_ERRORS > 0) */
     TgecResetCounters (p_Tgec);
 
     return err;
@@ -993,17 +980,10 @@ static t_Error TgecInit(t_Handle h_Tgec)
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
     if (!p_Tgec->p_TgecDriverParam->skipFman11Workaround &&
         ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
-#ifdef NCSW_LINUX
-    {
-        /* the workaround fails in simics, just report and continue initialization */
-        REPORT_ERROR(MAJOR, err, ("TgecTxEccWorkaround FAILED, skipping workaround"));
-    }
-#else
     {
         FreeInitResources(p_Tgec);
         RETURN_ERROR(MAJOR, err, ("TgecTxEccWorkaround FAILED"));
     }
-#endif
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
     CHECK_INIT_PARAMETERS(p_Tgec, CheckInitParameters);
@@ -1076,21 +1056,6 @@ static t_Error TgecInit(t_Handle h_Tgec)
         (GET_UINT32(p_Tgec->p_MemMap->tx_ipg_len) & ~TX_IPG_LENGTH_MASK) | DEFAULT_txIpgLength);
 #endif /* FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007 */
 
-    /* Configure MII */
-    tmpReg32  = GET_UINT32(p_Tgec->p_MiiMemMap->mdio_cfg_status);
-#ifdef FM_10G_MDIO_HOLD_ERRATA_XAUI3
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            tmpReg32 |= (MIIMCOM_MDIO_HOLD_4_REG_CLK << 2);
-    }
-#endif /* FM_10G_MDIO_HOLD_ERRATA_XAUI3 */
-    tmpReg32 &= ~MIIMCOM_DIV_MASK;
-     /* (one half of fm clock => 2.5Mhz) */
-    tmpReg32 |=((((p_Tgec->fmMacControllerDriver.clkFreq*10)/2)/25) << MIIMCOM_DIV_SHIFT);
-    WRITE_UINT32(p_Tgec->p_MiiMemMap->mdio_cfg_status, tmpReg32);
-
     p_Tgec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if(!p_Tgec->p_MulticastAddrHash)
     {
@@ -1106,14 +1071,14 @@ static t_Error TgecInit(t_Handle h_Tgec)
     }
 
     /* interrupts */
-#ifdef FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001
+#ifdef FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
     {
         t_FmRevisionInfo revInfo;
         FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &revInfo);
         if (revInfo.majorRev <=2)
             p_Tgec->exceptions &= ~(IMASK_REM_FAULT | IMASK_LOC_FAULT);
     }
-#endif /* FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001 */
+#endif /* FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005 */
     WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
     WRITE_UINT32(p_MemMap->imask, p_Tgec->exceptions);
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
index db22ead..68d490c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -171,36 +171,19 @@
     default: bitMask = 0;break;}
 
 
-/* Default Config Params */
-#define DEFAULT_wanModeEnable               FALSE
-#define DEFAULT_promiscuousModeEnable       FALSE
-
-
 #define DEFAULT_pauseForwardEnable          FALSE
-#define DEFAULT_pauseIgnore                 FALSE
 #define DEFAULT_txAddrInsEnable             FALSE
-
-#define DEFAULT_loopbackEnable              FALSE
 #define DEFAULT_cmdFrameEnable              FALSE
 #define DEFAULT_rxErrorDiscard              FALSE
 #define DEFAULT_phyTxenaOn                  FALSE
 #define DEFAULT_sendIdleEnable              FALSE
-#define DEFAULT_noLengthCheckEnable         TRUE
 #define DEFAULT_lgthCheckNostdr             FALSE
-#define DEFAULT_timeStampEnable             FALSE
 #define DEFAULT_rxSfdAny                    FALSE
 #define DEFAULT_rxPblFwd                    FALSE
 #define DEFAULT_txPblFwd                    FALSE
 #define DEFAULT_txIpgLength                 12
-
-#define DEFAULT_maxFrameLength              0x600
-
 #define DEFAULT_debugMode                   FALSE
-#define DEFAULT_pauseTime                   0xf000
-#define DEFAULT_imask                       0xf000
-#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-#define DEFAULT_skipFman11Workaround        FALSE
-#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+#define DEFAULT_timeStampEnable             FALSE
 
 #define DEFAULT_exceptions          ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
                                                 IMASK_REM_FAULT           |  \
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
index c9753be..229048f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,6 +37,8 @@
 #include "tgec.h"
 #include "xx_ext.h"
 
+#include "fm_common.h"
+
 
 /*****************************************************************************/
 t_Error TGEC_MII_WritePhyReg(t_Handle   h_Tgec,
@@ -46,12 +48,20 @@ t_Error TGEC_MII_WritePhyReg(t_Handle   h_Tgec,
 {
     t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
     t_TgecMiiAccessMemMap   *p_MiiAccess;
+    uint32_t                cfgStatusReg;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MiiMemMap, E_INVALID_HANDLE);
 
     p_MiiAccess = p_Tgec->p_MiiMemMap;
 
+    /* Configure MII */
+    cfgStatusReg  = GET_UINT32(p_MiiAccess->mdio_cfg_status);
+    cfgStatusReg &= ~MIIMCOM_DIV_MASK;
+     /* (one half of fm clock => 2.5Mhz) */
+    cfgStatusReg |=((((p_Tgec->fmMacControllerDriver.clkFreq*10)/2)/25) << MIIMCOM_DIV_SHIFT);
+    WRITE_UINT32(p_MiiAccess->mdio_cfg_status, cfgStatusReg);
+
     while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
         XX_UDelay (1);
 
@@ -82,13 +92,20 @@ t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,
 {
     t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
     t_TgecMiiAccessMemMap   *p_MiiAccess;
-    uint32_t                cfg_status;
+    uint32_t                cfgStatusReg;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MiiMemMap, E_INVALID_HANDLE);
 
     p_MiiAccess = p_Tgec->p_MiiMemMap;
 
+    /* Configure MII */
+    cfgStatusReg  = GET_UINT32(p_MiiAccess->mdio_cfg_status);
+    cfgStatusReg &= ~MIIMCOM_DIV_MASK;
+     /* (one half of fm clock => 2.5Mhz) */
+    cfgStatusReg |=((((p_Tgec->fmMacControllerDriver.clkFreq*10)/2)/25) << MIIMCOM_DIV_SHIFT);
+    WRITE_UINT32(p_MiiAccess->mdio_cfg_status, cfgStatusReg);
+
     while ((GET_UINT32(p_MiiAccess->mdio_cfg_status)) & MIIMIND_BUSY)
         XX_UDelay (1);
 
@@ -110,12 +127,12 @@ t_Error TGEC_MII_ReadPhyReg(t_Handle h_Tgec,
 
     *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
 
-    cfg_status  = GET_UINT32(p_MiiAccess->mdio_cfg_status);
+    cfgStatusReg  = GET_UINT32(p_MiiAccess->mdio_cfg_status);
 
-    if (cfg_status & MIIMIND_READ_ERROR)
+    if (cfgStatusReg & MIIMIND_READ_ERROR)
         RETURN_ERROR(MINOR, E_INVALID_VALUE,
-                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfg_status 0x%x",
-                      ((phyAddr & 0xe0)>>5), (phyAddr & 0x1f), reg, cfg_status));
+                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfgStatusReg 0x%x",
+                      ((phyAddr & 0xe0)>>5), (phyAddr & 0x1f), reg, cfgStatusReg));
 
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
index 81fd6ef..dfa2e6f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec_mii_acc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
index 62579cd..b74ac31 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
@@ -12,8 +12,9 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-Pcd.o
 
-fsl-ncsw-Pcd-objs	:=   fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o
-
-
+fsl-ncsw-Pcd-objs	:= fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o
 
+ifeq ($(CONFIG_FMAN_P3040_P4080_P5020),y)
+fsl-ncsw-Pcd-objs	+= fm_manip.o
+endif
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
new file mode 100644
index 0000000..f24a53c
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/crc64.h
@@ -0,0 +1,360 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/**************************************************************************//**
+ @File          crc64.h
+
+ @Description   brief This file contains the CRC64 Table, and __inline__
+                functions used for calculating crc.
+*//***************************************************************************/
+#ifndef __CRC64_H
+#define __CRC64_H
+
+#include "std_ext.h"
+
+
+#define BITS_PER_BYTE                   8
+
+#define CRC64_EXPON_ECMA_182            0xC96C5795D7870F42ULL
+#define CRC64_DEFAULT_INITVAL           0xFFFFFFFFFFFFFFFFULL
+
+#define CRC64_BYTE_MASK                 0xFF
+#define CRC64_TABLE_ENTRIES             ( 1 << BITS_PER_BYTE )
+#define CRC64_ODD_MASK                  1
+
+
+/**
+ \brief '64 bit crc' Table
+ */
+struct crc64_t {
+    uint64_t initial;                       /**< Initial seed */
+    uint64_t table[CRC64_TABLE_ENTRIES];    /**< crc table entries */
+};
+
+
+static struct crc64_t CRC64_ECMA_182 = {
+    CRC64_DEFAULT_INITVAL,
+    {
+        0x0000000000000000ULL,
+        0xb32e4cbe03a75f6fULL,
+        0xf4843657a840a05bULL,
+        0x47aa7ae9abe7ff34ULL,
+        0x7bd0c384ff8f5e33ULL,
+        0xc8fe8f3afc28015cULL,
+        0x8f54f5d357cffe68ULL,
+        0x3c7ab96d5468a107ULL,
+        0xf7a18709ff1ebc66ULL,
+        0x448fcbb7fcb9e309ULL,
+        0x0325b15e575e1c3dULL,
+        0xb00bfde054f94352ULL,
+        0x8c71448d0091e255ULL,
+        0x3f5f08330336bd3aULL,
+        0x78f572daa8d1420eULL,
+        0xcbdb3e64ab761d61ULL,
+        0x7d9ba13851336649ULL,
+        0xceb5ed8652943926ULL,
+        0x891f976ff973c612ULL,
+        0x3a31dbd1fad4997dULL,
+        0x064b62bcaebc387aULL,
+        0xb5652e02ad1b6715ULL,
+        0xf2cf54eb06fc9821ULL,
+        0x41e11855055bc74eULL,
+        0x8a3a2631ae2dda2fULL,
+        0x39146a8fad8a8540ULL,
+        0x7ebe1066066d7a74ULL,
+        0xcd905cd805ca251bULL,
+        0xf1eae5b551a2841cULL,
+        0x42c4a90b5205db73ULL,
+        0x056ed3e2f9e22447ULL,
+        0xb6409f5cfa457b28ULL,
+        0xfb374270a266cc92ULL,
+        0x48190ecea1c193fdULL,
+        0x0fb374270a266cc9ULL,
+        0xbc9d3899098133a6ULL,
+        0x80e781f45de992a1ULL,
+        0x33c9cd4a5e4ecdceULL,
+        0x7463b7a3f5a932faULL,
+        0xc74dfb1df60e6d95ULL,
+        0x0c96c5795d7870f4ULL,
+        0xbfb889c75edf2f9bULL,
+        0xf812f32ef538d0afULL,
+        0x4b3cbf90f69f8fc0ULL,
+        0x774606fda2f72ec7ULL,
+        0xc4684a43a15071a8ULL,
+        0x83c230aa0ab78e9cULL,
+        0x30ec7c140910d1f3ULL,
+        0x86ace348f355aadbULL,
+        0x3582aff6f0f2f5b4ULL,
+        0x7228d51f5b150a80ULL,
+        0xc10699a158b255efULL,
+        0xfd7c20cc0cdaf4e8ULL,
+        0x4e526c720f7dab87ULL,
+        0x09f8169ba49a54b3ULL,
+        0xbad65a25a73d0bdcULL,
+        0x710d64410c4b16bdULL,
+        0xc22328ff0fec49d2ULL,
+        0x85895216a40bb6e6ULL,
+        0x36a71ea8a7ace989ULL,
+        0x0adda7c5f3c4488eULL,
+        0xb9f3eb7bf06317e1ULL,
+        0xfe5991925b84e8d5ULL,
+        0x4d77dd2c5823b7baULL,
+        0x64b62bcaebc387a1ULL,
+        0xd7986774e864d8ceULL,
+        0x90321d9d438327faULL,
+        0x231c512340247895ULL,
+        0x1f66e84e144cd992ULL,
+        0xac48a4f017eb86fdULL,
+        0xebe2de19bc0c79c9ULL,
+        0x58cc92a7bfab26a6ULL,
+        0x9317acc314dd3bc7ULL,
+        0x2039e07d177a64a8ULL,
+        0x67939a94bc9d9b9cULL,
+        0xd4bdd62abf3ac4f3ULL,
+        0xe8c76f47eb5265f4ULL,
+        0x5be923f9e8f53a9bULL,
+        0x1c4359104312c5afULL,
+        0xaf6d15ae40b59ac0ULL,
+        0x192d8af2baf0e1e8ULL,
+        0xaa03c64cb957be87ULL,
+        0xeda9bca512b041b3ULL,
+        0x5e87f01b11171edcULL,
+        0x62fd4976457fbfdbULL,
+        0xd1d305c846d8e0b4ULL,
+        0x96797f21ed3f1f80ULL,
+        0x2557339fee9840efULL,
+        0xee8c0dfb45ee5d8eULL,
+        0x5da24145464902e1ULL,
+        0x1a083bacedaefdd5ULL,
+        0xa9267712ee09a2baULL,
+        0x955cce7fba6103bdULL,
+        0x267282c1b9c65cd2ULL,
+        0x61d8f8281221a3e6ULL,
+        0xd2f6b4961186fc89ULL,
+        0x9f8169ba49a54b33ULL,
+        0x2caf25044a02145cULL,
+        0x6b055fede1e5eb68ULL,
+        0xd82b1353e242b407ULL,
+        0xe451aa3eb62a1500ULL,
+        0x577fe680b58d4a6fULL,
+        0x10d59c691e6ab55bULL,
+        0xa3fbd0d71dcdea34ULL,
+        0x6820eeb3b6bbf755ULL,
+        0xdb0ea20db51ca83aULL,
+        0x9ca4d8e41efb570eULL,
+        0x2f8a945a1d5c0861ULL,
+        0x13f02d374934a966ULL,
+        0xa0de61894a93f609ULL,
+        0xe7741b60e174093dULL,
+        0x545a57dee2d35652ULL,
+        0xe21ac88218962d7aULL,
+        0x5134843c1b317215ULL,
+        0x169efed5b0d68d21ULL,
+        0xa5b0b26bb371d24eULL,
+        0x99ca0b06e7197349ULL,
+        0x2ae447b8e4be2c26ULL,
+        0x6d4e3d514f59d312ULL,
+        0xde6071ef4cfe8c7dULL,
+        0x15bb4f8be788911cULL,
+        0xa6950335e42fce73ULL,
+        0xe13f79dc4fc83147ULL,
+        0x521135624c6f6e28ULL,
+        0x6e6b8c0f1807cf2fULL,
+        0xdd45c0b11ba09040ULL,
+        0x9aefba58b0476f74ULL,
+        0x29c1f6e6b3e0301bULL,
+        0xc96c5795d7870f42ULL,
+        0x7a421b2bd420502dULL,
+        0x3de861c27fc7af19ULL,
+        0x8ec62d7c7c60f076ULL,
+        0xb2bc941128085171ULL,
+        0x0192d8af2baf0e1eULL,
+        0x4638a2468048f12aULL,
+        0xf516eef883efae45ULL,
+        0x3ecdd09c2899b324ULL,
+        0x8de39c222b3eec4bULL,
+        0xca49e6cb80d9137fULL,
+        0x7967aa75837e4c10ULL,
+        0x451d1318d716ed17ULL,
+        0xf6335fa6d4b1b278ULL,
+        0xb199254f7f564d4cULL,
+        0x02b769f17cf11223ULL,
+        0xb4f7f6ad86b4690bULL,
+        0x07d9ba1385133664ULL,
+        0x4073c0fa2ef4c950ULL,
+        0xf35d8c442d53963fULL,
+        0xcf273529793b3738ULL,
+        0x7c0979977a9c6857ULL,
+        0x3ba3037ed17b9763ULL,
+        0x888d4fc0d2dcc80cULL,
+        0x435671a479aad56dULL,
+        0xf0783d1a7a0d8a02ULL,
+        0xb7d247f3d1ea7536ULL,
+        0x04fc0b4dd24d2a59ULL,
+        0x3886b22086258b5eULL,
+        0x8ba8fe9e8582d431ULL,
+        0xcc0284772e652b05ULL,
+        0x7f2cc8c92dc2746aULL,
+        0x325b15e575e1c3d0ULL,
+        0x8175595b76469cbfULL,
+        0xc6df23b2dda1638bULL,
+        0x75f16f0cde063ce4ULL,
+        0x498bd6618a6e9de3ULL,
+        0xfaa59adf89c9c28cULL,
+        0xbd0fe036222e3db8ULL,
+        0x0e21ac88218962d7ULL,
+        0xc5fa92ec8aff7fb6ULL,
+        0x76d4de52895820d9ULL,
+        0x317ea4bb22bfdfedULL,
+        0x8250e80521188082ULL,
+        0xbe2a516875702185ULL,
+        0x0d041dd676d77eeaULL,
+        0x4aae673fdd3081deULL,
+        0xf9802b81de97deb1ULL,
+        0x4fc0b4dd24d2a599ULL,
+        0xfceef8632775faf6ULL,
+        0xbb44828a8c9205c2ULL,
+        0x086ace348f355aadULL,
+        0x34107759db5dfbaaULL,
+        0x873e3be7d8faa4c5ULL,
+        0xc094410e731d5bf1ULL,
+        0x73ba0db070ba049eULL,
+        0xb86133d4dbcc19ffULL,
+        0x0b4f7f6ad86b4690ULL,
+        0x4ce50583738cb9a4ULL,
+        0xffcb493d702be6cbULL,
+        0xc3b1f050244347ccULL,
+        0x709fbcee27e418a3ULL,
+        0x3735c6078c03e797ULL,
+        0x841b8ab98fa4b8f8ULL,
+        0xadda7c5f3c4488e3ULL,
+        0x1ef430e13fe3d78cULL,
+        0x595e4a08940428b8ULL,
+        0xea7006b697a377d7ULL,
+        0xd60abfdbc3cbd6d0ULL,
+        0x6524f365c06c89bfULL,
+        0x228e898c6b8b768bULL,
+        0x91a0c532682c29e4ULL,
+        0x5a7bfb56c35a3485ULL,
+        0xe955b7e8c0fd6beaULL,
+        0xaeffcd016b1a94deULL,
+        0x1dd181bf68bdcbb1ULL,
+        0x21ab38d23cd56ab6ULL,
+        0x9285746c3f7235d9ULL,
+        0xd52f0e859495caedULL,
+        0x6601423b97329582ULL,
+        0xd041dd676d77eeaaULL,
+        0x636f91d96ed0b1c5ULL,
+        0x24c5eb30c5374ef1ULL,
+        0x97eba78ec690119eULL,
+        0xab911ee392f8b099ULL,
+        0x18bf525d915feff6ULL,
+        0x5f1528b43ab810c2ULL,
+        0xec3b640a391f4fadULL,
+        0x27e05a6e926952ccULL,
+        0x94ce16d091ce0da3ULL,
+        0xd3646c393a29f297ULL,
+        0x604a2087398eadf8ULL,
+        0x5c3099ea6de60cffULL,
+        0xef1ed5546e415390ULL,
+        0xa8b4afbdc5a6aca4ULL,
+        0x1b9ae303c601f3cbULL,
+        0x56ed3e2f9e224471ULL,
+        0xe5c372919d851b1eULL,
+        0xa26908783662e42aULL,
+        0x114744c635c5bb45ULL,
+        0x2d3dfdab61ad1a42ULL,
+        0x9e13b115620a452dULL,
+        0xd9b9cbfcc9edba19ULL,
+        0x6a978742ca4ae576ULL,
+        0xa14cb926613cf817ULL,
+        0x1262f598629ba778ULL,
+        0x55c88f71c97c584cULL,
+        0xe6e6c3cfcadb0723ULL,
+        0xda9c7aa29eb3a624ULL,
+        0x69b2361c9d14f94bULL,
+        0x2e184cf536f3067fULL,
+        0x9d36004b35545910ULL,
+        0x2b769f17cf112238ULL,
+        0x9858d3a9ccb67d57ULL,
+        0xdff2a94067518263ULL,
+        0x6cdce5fe64f6dd0cULL,
+        0x50a65c93309e7c0bULL,
+        0xe388102d33392364ULL,
+        0xa4226ac498dedc50ULL,
+        0x170c267a9b79833fULL,
+        0xdcd7181e300f9e5eULL,
+        0x6ff954a033a8c131ULL,
+        0x28532e49984f3e05ULL,
+        0x9b7d62f79be8616aULL,
+        0xa707db9acf80c06dULL,
+        0x14299724cc279f02ULL,
+        0x5383edcd67c06036ULL,
+        0xe0ada17364673f59ULL
+    }
+};
+
+
+/**
+ \brief Initializes the crc seed
+ */
+static __inline__ uint64_t crc64_init(void)
+{
+    return CRC64_ECMA_182.initial;
+}
+
+/**
+ \brief Computes 64 bit the crc
+ \param[in] data Pointer to the Data in the frame
+ \param[in] len Length of the Data
+ \param[in] crc seed
+ \return calculated crc
+ */
+static __inline__ uint64_t crc64_compute(void const *data,
+                                         uint32_t   len,
+                                         uint64_t   seed)
+{
+    uint32_t i;
+    uint64_t crc = seed;
+    uint8_t *bdata = (uint8_t *) data;
+
+    for (i = 0; i < len; i++)
+        crc =
+            CRC64_ECMA_182.
+            table[(crc ^ *bdata++) & CRC64_BYTE_MASK] ^ (crc >> 8);
+
+    return crc;
+}
+
+
+#endif /* __CRC64_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 849e3c2..9cd721b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -45,9 +45,10 @@
 #include "fm_common.h"
 #include "fm_hc.h"
 #include "fm_cc.h"
+#include "crc64.h"
 
 
-#if defined(FM_CAPWAP_SUPPORT)
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 #define FM_PCD_CC_MANIP
 #endif /* defined(FM_CAPWAP_SUPPORT) || ... */
 
@@ -278,6 +279,7 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle h_FmPcd, uint32_t requiredActio
 }
 
 static t_Error CcUpdateParam(t_Handle                                   h_FmPcd,
+                             t_Handle                                   h_PcdParams,
                              t_Handle                                   h_FmPort,
                              t_FmPcdCcNextEngineAndRequiredActionParams *p_CcNextEngineParams,
                              uint16_t                                   numOfEntries,
@@ -287,14 +289,25 @@ static t_Error CcUpdateParam(t_Handle                                   h_FmPcd,
                              t_Handle                                   h_FmTree,
                              bool                                       modify)
 {
-    t_CcNodeInformation *p_CcNodeInfo;
     t_FmPcdCcNode       *p_FmPcdCcNode;
     t_Error             err;
     uint16_t            tmp = 0;
     int                 i = 0;
+#ifdef FM_PCD_CC_MANIP
+    t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
+#endif /* FM_PCD_CC_MANIP */
 
     level++;
 
+#ifdef FM_PCD_CC_MANIP
+    if(p_CcTree->h_IpReassemblyManip)
+    {
+        err = FmPcdManipUpdate(h_FmPcd, h_PcdParams, h_FmPort, p_CcTree->h_IpReassemblyManip, h_Ad, validate, level, h_FmTree, modify);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+#endif /* FM_PCD_CC_MANIP */
+
     if(numOfEntries)
     {
         for(i = 0; i < numOfEntries; i++)
@@ -308,13 +321,10 @@ static t_Error CcUpdateParam(t_Handle                                   h_FmPcd,
             {
                 p_FmPcdCcNode = p_CcNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
                 ASSERT_COND(p_FmPcdCcNode);
-                p_CcNodeInfo = FindNodeInfoInReleventLst(&p_FmPcdCcNode->ccTreesLst,h_FmTree);
-                ASSERT_COND(p_CcNodeInfo);
-                p_CcNodeInfo->index = level;
 #ifdef FM_PCD_CC_MANIP
                 if(p_CcNextEngineParams[i].nextEngineParams.h_Manip)
                 {
-                    err = FmPcdManipUpdate(h_FmPcd, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate, p_CcNodeInfo->index, h_FmTree, modify);
+                    err = FmPcdManipUpdate(h_FmPcd, NULL, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate, level, h_FmTree, modify);
                     if(err)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                 }
@@ -325,7 +335,7 @@ static t_Error CcUpdateParam(t_Handle                                   h_FmPcd,
                 else
                     tmp = p_FmPcdCcNode->numOfKeys;
 
-                err = CcUpdateParam(h_FmPcd, h_FmPort, p_FmPcdCcNode->nextEngineAndRequiredAction, tmp, p_FmPcdCcNode->h_AdTable, validate,level, h_FmTree, modify);
+                err = CcUpdateParam(h_FmPcd, h_PcdParams, h_FmPort, p_FmPcdCcNode->nextEngineAndRequiredAction, tmp, p_FmPcdCcNode->h_AdTable, validate, level, h_FmTree, modify);
                 if(err)
                     RETURN_ERROR(MAJOR, err, NO_MSG);
             }
@@ -334,7 +344,7 @@ static t_Error CcUpdateParam(t_Handle                                   h_FmPcd,
             {
                 if(p_CcNextEngineParams[i].nextEngineParams.h_Manip)
                 {
-                    err = FmPcdManipUpdate(h_FmPcd, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate, level,h_FmTree, modify);
+                    err = FmPcdManipUpdate(h_FmPcd, NULL, h_FmPort, p_CcNextEngineParams[i].nextEngineParams.h_Manip, h_Ad, validate, level, h_FmTree, modify);
                     if(err)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                 }
@@ -761,8 +771,11 @@ static t_Error ValidateNextEngineParams(t_Handle h_FmPcd, t_FmPcdCcNextEnginePar
     return err;
 }
 
-static uint8_t GetGenParseCode(e_FmPcdExtractFrom src, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset, bool fromIc, ccPrivateInfo_t icCode)
+static uint8_t GetGenParseCode(t_Handle h_FmPcd, e_FmPcdExtractFrom src, uint32_t offset, bool glblMask, uint8_t *parseArrayOffset, bool fromIc, ccPrivateInfo_t icCode)
 {
+#ifndef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
+    UNUSED(h_FmPcd);
+#endif /* !FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
     if(!fromIc)
     {
         switch(src)
@@ -1394,7 +1407,7 @@ static t_Error BuildNewNodeCommonPart(t_FmPcdCcNode                         *p_F
     return E_OK;
 }
 
-static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo, bool add)
+static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyIndex, t_FmPcdCcKeyParams  *p_KeyParams,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo, bool add)
 {
     t_Error                 err = E_OK;
     t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
@@ -1524,6 +1537,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCc
 
                 err = CcUpdateParam(p_FmPcdCcNode->h_FmPcd,
                                     NULL,
+                                    NULL,
                                     &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],
                                     1,
                                     PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
@@ -1556,7 +1570,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle h_FmPcd ,t_FmPcdCc
     return E_OK;
 }
 
-static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyIndex, t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     int         i = 0, j = 0;
     t_Handle    p_AdTableNewTmp,p_KeysMatchTableNewTmp;
@@ -1604,7 +1618,7 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIn
    return E_OK;
 }
 
-static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode *p_FmPcdCcNode, uint8_t keyIndex, uint8_t  *p_Key, uint8_t *p_Mask,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
+static t_Error BuildNewNodeModifyKey(t_FmPcdCcNode *p_FmPcdCcNode, uint16_t keyIndex, uint8_t  *p_Key, uint8_t *p_Mask,t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
     t_Error                 err = E_OK;
     t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
@@ -1771,7 +1785,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle h_FmPcd ,t_Handle h_FmPcdCc
                                                    p_Ad, 1, p_CcNodeInformation->h_CcNode);
                     if(err)
                         RETURN_ERROR(MAJOR, err, (NO_MSG));
-                     err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd, NULL, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],1, p_Ad, TRUE, p_CcNodeInformation->index, p_CcNodeInformation->h_CcNode, TRUE);
+                     err = CcUpdateParam(p_FmPcdCcNode1->h_FmPcd, NULL, NULL, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],1, p_Ad, TRUE, p_CcNodeInformation->index, p_CcNodeInformation->h_CcNode, TRUE);
                     if(err)
                         RETURN_ERROR(MAJOR, err, (NO_MSG));
             }
@@ -1784,7 +1798,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle h_FmPcd ,t_Handle h_FmPcdCc
                                        p_Ad, 1, (t_Handle)p_FmPcdCcTree);
         if(err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
-         err = CcUpdateParam(h_FmPcd, NULL, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],1, p_Ad, TRUE, 0, (t_Handle)p_FmPcdCcTree, TRUE);
+         err = CcUpdateParam(h_FmPcd, NULL, NULL, &p_AdditionalInfo->nextEngineAndRequiredAction[keyIndex],1, p_Ad, TRUE, 0, (t_Handle)p_FmPcdCcTree, TRUE);
         if(err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -2079,6 +2093,7 @@ static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_FmPcdCcNo
 #endif /* FM_PCD_CC_MANIP */
 
 static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
+                              t_Handle                         h_PcdParams,
                               t_Handle                         h_FmPort,
                               t_Handle                         h_FmTree,
                               bool                             validate)
@@ -2086,6 +2101,7 @@ static t_Error CcUpdateParams(t_Handle                         h_FmPcd,
     t_FmPcdCcTree       *p_CcTree = (t_FmPcdCcTree *) h_FmTree;
 
     return CcUpdateParam(h_FmPcd,
+                         h_PcdParams,
                          h_FmPort,
                          p_CcTree->nextEngineAndRequiredAction,
                          p_CcTree->numOfEntries,
@@ -2264,8 +2280,8 @@ static t_Error IcHashIndexedCheckParams(t_Handle h_FmPcd,
                 err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams, &requiredAction);
                 if(err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
+                p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction = requiredAction;
             }
-            p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction = requiredAction;
 #endif /* FM_PCD_CC_MANIP */
 
             memcpy(&p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].nextEngineParams,&p_KeyParams->ccNextEngineParams, sizeof(t_FmPcdCcNextEngineParams));
@@ -2318,7 +2334,7 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTre
 
 }
 
-t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
 {
 
     t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *) h_FmPcdCcNode;
@@ -2358,7 +2374,7 @@ t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIn
 
 }
 
-t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst, t_List *h_NewLst,t_Handle *h_AdditionalParams)
+t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst, t_List *h_NewLst,t_Handle *h_AdditionalParams)
 {
     t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
     t_Error                             err = E_OK;
@@ -2400,7 +2416,7 @@ t_Error FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIn
 }
 
 
-t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint8_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams)
+t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint16_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams)
 {
     t_FmPcdCcNode                   *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
     t_Error                         err = E_OK;
@@ -2457,7 +2473,7 @@ t_Error FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCc
     return E_OK;
 }
 
-t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
 {
     t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
     t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
@@ -2498,7 +2514,7 @@ t_Error FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex
     return E_OK;
 }
 
-t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
+t_Error FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams)
 {
     t_FmPcdCcNode                       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_FmPcdCcNode;
     t_FmPcdModifyCcKeyAdditionalParams  *p_ModifyKeyParams;
@@ -2583,13 +2599,13 @@ t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle h_FmPcd, t_List *h_FmPcdOld
 
      if(p_CcNewModifyAdditionalParams->h_NodeForRmv)
     {
-
         p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_CcNewModifyAdditionalParams->h_NodeForRmv;
         if(!p_CcNewModifyAdditionalParams->tree)
         {
             p_UpdateLst = &p_FmPcdCcNextNode->ccPrevNodesLst;
-            LIST_FOR_EACH(p_Pos, &p_FmPcdCcNextNode->ccTreesLst)
+            while (!LIST_IsEmpty(&p_FmPcdCcNextNode->ccTreesLst))
             {
+                p_Pos = LIST_NEXT(&p_FmPcdCcNextNode->ccTreesLst);
                 p_CcNodeInformation = CC_NODE_F_OBJECT(p_Pos);
                 ASSERT_COND(p_CcNodeInformation->h_CcNode);
                 err = FmPcdCcSetRequiredAction(h_FmPcd,
@@ -2613,7 +2629,7 @@ t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle h_FmPcd, t_List *h_FmPcdOld
         if(err)
             return err;
 
-        /*we remove from the  subtree of the removed node tree because it wasn't done in the previose stage*/
+        /*we remove from the subtree of the removed node tree because it wasn't done in the previous stage*/
         /*update ccPrevNodesLst or ccTreeIdLst of the removed node*/
         /*update of the nodeOwner*/
         p_CcNodeInformation = FindNodeInfoInReleventLst(p_UpdateLst, p_CcNewModifyAdditionalParams->h_CurrentNode);
@@ -2622,7 +2638,6 @@ t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle h_FmPcd, t_List *h_FmPcdOld
         p_CcNodeInformation->index--;
         if(p_CcNodeInformation->index == 0)
            DequeueNodeInfoFromRelevantLst(p_UpdateLst,p_CcNewModifyAdditionalParams->h_CurrentNode);
-        ASSERT_COND(LIST_NumOfObjs(&p_FmPcdCcNextNode->ccTreesLst) == 1);
         UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
     }
 
@@ -2694,7 +2709,7 @@ t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_G
     return E_OK;
 }
 
-t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *p_Offset, t_Handle h_FmPort)
+t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle  h_FmPcdCcTree,  uint32_t  *p_Offset, t_Handle h_FmPort)
 {
     t_FmPcd             *p_FmPcd = (t_FmPcd*)h_FmPcd;
     t_FmPcdCcTree       *p_FmPcdCcTree = (t_FmPcdCcTree *)h_FmPcdCcTree;
@@ -2708,7 +2723,7 @@ t_Error  FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle  h_FmPcdCcTree,  uint32_t  *
     *p_Offset = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr)) -
                            p_FmPcd->physicalMuramBase);
 
-    err = CcUpdateParams(h_FmPcd, h_FmPort, h_FmPcdCcTree, TRUE);
+    err = CcUpdateParams(h_FmPcd, h_PcdParams, h_FmPort, h_FmPcdCcTree, TRUE);
 
     return err;
 }
@@ -2771,12 +2786,16 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     uint8_t                     numOfEntries;
     t_Handle                    p_CcTreeTmp;
     t_FmPcdCcGrpParams          *p_FmPcdCcGroupParams;
-    t_FmPcdCcNextEngineAndRequiredActionParams   params[16];
+    t_FmPcdCcNextEngineAndRequiredActionParams   *p_Params, *p_NextEngineAndRequiredActionParams;
     t_NetEnvParams              netEnvParams;
     uint8_t                     lastOne = 0;
     uint32_t                    requiredAction = 0;
     t_FmPcdCcNode               *p_FmPcdCcNextNode;
     t_CcNodeInformation         ccNodeInfo, *p_CcInformation;
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    bool                        isIpv4Present = FALSE, isIpv6Present = FALSE;
+    uint8_t                     ipv4ReassmGrpNum = 0xFF, ipv6ReassmGrpNum = 0xFF;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE, NULL);
     SANITY_CHECK_RETURN_VALUE(p_PcdGroupsParam,E_INVALID_HANDLE, NULL);
@@ -2794,10 +2813,56 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         return NULL;
     }
     memset(p_FmPcdCcTree, 0, sizeof(t_FmPcdCcTree)) ;
-    memset(params, 0, 16 * sizeof(t_FmPcdCcNextEngineParams));
+    p_Params = (t_FmPcdCcNextEngineAndRequiredActionParams*)XX_Malloc(16 * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+    memset(p_Params, 0, 16 * sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
 
     INIT_LIST(&p_FmPcdCcTree->fmPortsLst);
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    if(p_PcdGroupsParam->h_IpReassemblyManip)
+    {
+        /* Check if the tree has IPv4 or IPv6 reassembly manipulation */
+        p_FmPcdCcTree->h_IpReassemblyManip = p_PcdGroupsParam->h_IpReassemblyManip;
+        isIpv4Present = FmPcdManipIsIpv4Present(h_FmPcd, (uint8_t)(PTR_TO_UINT(p_PcdGroupsParam->h_NetEnv)-1));
+        isIpv6Present = FmPcdManipIsIpv6Present(h_FmPcd, (uint8_t)(PTR_TO_UINT(p_PcdGroupsParam->h_NetEnv)-1));
+
+        if(isIpv6Present)
+        {
+            if((p_PcdGroupsParam->numOfGrps + 1) > FM_PCD_MAX_NUM_OF_CC_GROUPS)
+            {
+                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                XX_Free(p_Params);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfGrps can not be greater than 16"));
+                return NULL;
+            }
+            /* Sets IPv6 reassembly manipulation group parameters */
+            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].nextEnginePerEntriesInGrp[0].nextEngine = e_FM_PCD_DONE;
+            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].nextEnginePerEntriesInGrp[0].h_Manip = p_PcdGroupsParam->h_IpReassemblyManip;
+            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].numOfDistinctionUnits = 0;
+            ipv6ReassmGrpNum = p_PcdGroupsParam->numOfGrps;
+            /* Save and increases groups number*/
+            p_PcdGroupsParam->numOfGrps++;
+        }
+        if(isIpv4Present)
+        {
+            if((p_PcdGroupsParam->numOfGrps + 1) > FM_PCD_MAX_NUM_OF_CC_GROUPS)
+            {
+                DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                XX_Free(p_Params);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("numOfGrps can not be greater than 16"));
+                return NULL;
+            }
+            /* Sets IPv4 reassembly manipulation group parameters */
+            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].nextEnginePerEntriesInGrp[0].nextEngine = e_FM_PCD_DONE;
+            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].nextEnginePerEntriesInGrp[0].h_Manip = p_PcdGroupsParam->h_IpReassemblyManip;
+            p_PcdGroupsParam->ccGrpParams[p_PcdGroupsParam->numOfGrps].numOfDistinctionUnits = 0;
+            /* Save and increases groups number*/
+            ipv4ReassmGrpNum = p_PcdGroupsParam->numOfGrps;
+            p_PcdGroupsParam->numOfGrps++;
+        }
+    }
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
     numOfEntries = 0;
     p_FmPcdCcTree->netEnvId = (uint8_t)(PTR_TO_UINT(p_PcdGroupsParam->h_NetEnv)-1);
     for(i = 0; i < p_PcdGroupsParam->numOfGrps; i++)
@@ -2807,6 +2872,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         if (p_FmPcdCcGroupParams->numOfDistinctionUnits > FM_PCD_MAX_NUM_OF_CC_UNITS)
         {
             DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            XX_Free(p_Params);
             REPORT_ERROR(MAJOR, E_INVALID_VALUE,
                          ("numOfDistinctionUnits (group %d) should not exceed %d", i, FM_PCD_MAX_NUM_OF_CC_UNITS));
             return NULL;
@@ -2818,6 +2884,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         if(numOfEntries > 16)
         {
             DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            XX_Free(p_Params);
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("numOfEntries can not be larger than 16"));
             return NULL;
         }
@@ -2826,6 +2893,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
             if(p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
             {
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, E_CONFLICT, ("numOfEntries per group must be set in descending order"));
                 return NULL;
             }
@@ -2840,6 +2908,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         if(err)
         {
             DeleteTree(p_FmPcdCcTree,p_FmPcd);
+            XX_Free(p_Params);
             REPORT_ERROR(MAJOR, err, NO_MSG);
             return NULL;
         }
@@ -2851,6 +2920,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
             if(err)
             {
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, err, (NO_MSG));
                 return NULL;
             }
@@ -2862,15 +2932,16 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
                 if(err)
                 {
                     DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                    XX_Free(p_Params);
                     REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                     return NULL;
                 }
            }
 #endif /* FM_PCD_CC_MANIP */
-
-           memcpy(&params[k].nextEngineParams, &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], sizeof(t_FmPcdCcNextEngineParams));
+           p_NextEngineAndRequiredActionParams = p_Params+k;
+           memcpy(&p_NextEngineAndRequiredActionParams->nextEngineParams, &p_FmPcdCcGroupParams->nextEnginePerEntriesInGrp[j], sizeof(t_FmPcdCcNextEngineParams));
            requiredAction |= UPDATE_CC_WITH_TREE;
-           params[k].requiredAction = requiredAction;
+           p_NextEngineAndRequiredActionParams->requiredAction = requiredAction;
            k++;
         }
     }
@@ -2885,6 +2956,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     if(!p_FmPcdCcTree->ccTreeBaseAddr)
     {
         DeleteTree(p_FmPcdCcTree,p_FmPcd);
+        XX_Free(p_Params);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
         return NULL;
     }
@@ -2895,9 +2967,10 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     j = 0;
     for(i = 0; i < numOfEntries; i++)
     {
-        NextStepAd(p_CcTreeTmp,&params[i].nextEngineParams,p_FmPcd);
+        p_NextEngineAndRequiredActionParams = p_Params+i;
+        NextStepAd(p_CcTreeTmp,&p_NextEngineAndRequiredActionParams->nextEngineParams,p_FmPcd);
         p_CcTreeTmp = PTR_MOVE(p_CcTreeTmp, FM_PCD_CC_AD_ENTRY_SIZE);
-        memcpy(&p_FmPcdCcTree->nextEngineAndRequiredAction[i], &params[i], sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
+        memcpy(&p_FmPcdCcTree->nextEngineAndRequiredAction[i], p_NextEngineAndRequiredActionParams, sizeof(t_FmPcdCcNextEngineAndRequiredActionParams));
         if(p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->nextEngineAndRequiredAction[i].nextEngineParams.params.ccParams.h_CcNode;
@@ -2940,6 +3013,7 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
             if(err)
             {
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
+                XX_Free(p_Params);
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
                 return NULL;
             }
@@ -2947,6 +3021,15 @@ t_Handle FM_PCD_CcBuildTree(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         }
     }
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    /* Sets reassembly schemes if required */
+    if (isIpv4Present)
+        FmPcdManipBuildIpReassmScheme(p_FmPcd, p_PcdGroupsParam, p_FmPcdCcTree, p_FmPcdCcTree->h_IpReassemblyManip, TRUE, ipv4ReassmGrpNum);
+    if (isIpv6Present)
+        FmPcdManipBuildIpReassmScheme(p_FmPcd, p_PcdGroupsParam, p_FmPcdCcTree, p_FmPcdCcTree->h_IpReassemblyManip, FALSE, ipv6ReassmGrpNum);
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
+    XX_Free(p_Params);
     return p_FmPcdCcTree;
 }
 
@@ -3107,12 +3190,14 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
                     break;
                 case(e_FM_PCD_EXTRACT_FROM_HDR):
                         p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.size;
-                        p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                        p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
+                        p_FmPcdCcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromHdr.offset;
                         p_FmPcdCcNode->parseCode = GetPrParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
                                                                 p_FmPcdCcNode->offset,glblMask, &p_FmPcdCcNode->prsArrayOffset);
                         break;
                 case(e_FM_PCD_EXTRACT_FROM_FIELD):
                         p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
+                        p_FmPcdCcNode->userOffset = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.offset;
                         p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.size;
                         p_FmPcdCcNode->parseCode = GetFieldParseCode(p_CcNodeParam->extractCcParams.extractByHdr.hdr, p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fromField.field,
                                                     p_FmPcdCcNode->offset,&p_FmPcdCcNode->prsArrayOffset,
@@ -3127,12 +3212,13 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
         case(e_FM_PCD_EXTRACT_NON_HDR):
             /* get the field code for the generic extract */
             p_FmPcdCcNode->sizeOfExtraction = p_CcNodeParam->extractCcParams.extractNonHdr.size;
-            p_FmPcdCcNode->offset =  p_CcNodeParam->extractCcParams.extractNonHdr.offset;
-            p_FmPcdCcNode->parseCode = GetGenParseCode(p_CcNodeParam->extractCcParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset, fromIc,icCode);
+            p_FmPcdCcNode->offset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_FmPcdCcNode->userOffset = p_CcNodeParam->extractCcParams.extractNonHdr.offset;
+            p_FmPcdCcNode->parseCode = GetGenParseCode(h_FmPcd, p_CcNodeParam->extractCcParams.extractNonHdr.src, p_FmPcdCcNode->offset, glblMask, &p_FmPcdCcNode->prsArrayOffset, fromIc,icCode);
 
-            if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+            if (p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
-                if((p_FmPcdCcNode->offset + p_FmPcdCcNode->sizeOfExtraction) > 64)
+                if ((p_FmPcdCcNode->offset + p_FmPcdCcNode->sizeOfExtraction) > 8)
                 {
                      DeleteNode(p_FmPcdCcNode);
                      REPORT_ERROR(MAJOR, E_INVALID_SELECTION,("when node of the type CC_PC_GENERIC_IC_HASH_INDEXED offset + size can not be bigger then size of HASH 64 bits (8 bytes)"));
@@ -3289,7 +3375,7 @@ t_Handle FM_PCD_CcSetNode(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
         if(p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction)
         {
 
-             err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction, &p_FmPcdCcNode->nextEngineAndRequiredAction[tmp], p_AdTableTmp,1, NULL);
+            err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcNode->nextEngineAndRequiredAction[tmp].requiredAction, &p_FmPcdCcNode->nextEngineAndRequiredAction[tmp], p_AdTableTmp,1, NULL);
             if(err)
             {
                 FM_PCD_CcDeleteNode(h_FmPcd, (t_Handle)p_FmPcdCcNode);
@@ -3353,42 +3439,57 @@ t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode)
     return E_OK;
 }
 
-t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
+    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = ((t_FmPcdCcNode *)h_CcNode)->numOfKeys;
     return FmHcPcdCcAddKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
 }
 
-t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex)
+t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
+
+    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = ((t_FmPcdCcNode *)h_CcNode)->numOfKeys;
 
     return FmHcPcdCcRemoveKey(p_FmPcd->h_Hc, h_CcNode, keyIndex);
 }
 
-t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
+t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
+
+    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = ((t_FmPcdCcNode *)h_CcNode)->numOfKeys;
 
     return FmHcPcdCcModifyKey(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_Key, p_Mask);
 }
 
-t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
+t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
+
+    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = ((t_FmPcdCcNode *)h_CcNode)->numOfKeys;
 
     return FmHcPcdCcModifyNodeNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, p_FmPcdCcNextEngineParams);
 }
@@ -3413,7 +3514,7 @@ t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8
     return FmHcPcdCcModifyTreeNextEngine(p_FmPcd->h_Hc, h_CcTree, grpId, index, p_FmPcdCcNextEngineParams);
 }
 
-t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
+t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
 
@@ -3423,6 +3524,35 @@ t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode,
     return FmHcPcdCcModifyKeyAndNextEngine(p_FmPcd->h_Hc, h_CcNode, keyIndex, keySize, p_KeyParams);
 }
 
+t_Error FM_PCD_CcNodeGetNextEngine(t_Handle                     h_FmPcd,
+                                   t_Handle                     h_CcNode,
+                                   uint16_t                     keyIndex,
+                                   t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcNode                   *p_FmPcdCcNode  = (t_FmPcdCcNode *)h_CcNode;
+
+#ifdef DISABLE_SANITY_CHECKS
+    UNUSED(p_FmPcd);
+#endif /* DISABLE_SANITY_CHECKS */
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
+
+    if(keyIndex == FM_PCD_LAST_KEY_INDEX)
+        keyIndex = p_FmPcdCcNode->numOfKeys;
+    if(keyIndex > p_FmPcdCcNode->numOfKeys)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > numOfKeys"));
+    if(keyIndex > FM_PCD_MAX_NUM_OF_CC_NODES)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex can not be larger than 255"));
+    if(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+        if(keyIndex == p_FmPcdCcNode->numOfKeys)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This type of node doesn't have Miss"));
+
+    memcpy(p_FmPcdCcNextEngineParams, &p_FmPcdCcNode->nextEngineAndRequiredAction[keyIndex],sizeof(t_FmPcdCcNextEngineParams));
+
+    return E_OK;
+}
+
 uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex)
 {
     t_FmPcdCcNode       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
@@ -3465,3 +3595,35 @@ UNUSED(h_FmPcd);
 
     return  GET_UINT32(p_AdResult->res);
 }
+
+t_Error FM_PCD_CcIndexedHashNodeGetBucket(t_Handle    h_FmPcd,
+                                          t_Handle    h_CcNode,
+                                          uint8_t     keySize,
+                                          uint8_t     *p_Key,
+                                          uint8_t     hashShift,
+                                          t_Handle    *p_CcNodeBucketHandle,
+                                          uint8_t     *p_BucketIndex,
+                                          uint16_t    *p_LastIndex)
+{
+    t_FmPcdCcNode       *p_FmPcdCcNode = (t_FmPcdCcNode *)h_CcNode;
+    uint16_t            glblMask;
+    uint64_t            crc64 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_CcNode, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Key, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_CcNodeBucketHandle, E_NULL_POINTER);
+
+    UNUSED(h_FmPcd);
+
+    memcpy(&glblMask, PTR_MOVE(p_FmPcdCcNode->p_GlblMask, 2), 2);
+    crc64 = crc64_init();
+    crc64 = crc64_compute(p_Key, keySize, crc64);
+    crc64 >>= hashShift;
+    *p_BucketIndex = (uint8_t)(((crc64 >> (8 * (6 - p_FmPcdCcNode->userOffset))) & glblMask) >> 4);
+    *p_CcNodeBucketHandle = p_FmPcdCcNode->nextEngineAndRequiredAction[*p_BucketIndex].nextEngineParams.params.ccParams.h_CcNode;
+    *p_LastIndex = ((t_FmPcdCcNode *)*p_CcNodeBucketHandle)->numOfKeys;
+
+    return E_OK;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index a96142b..ba3f2fb 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -169,7 +169,7 @@ typedef _Packed struct {
     volatile uint32_t fqid;
     volatile uint32_t plcrProfile;
     volatile uint32_t nia;
-    volatile uint32_t  res;
+    volatile uint32_t res;
 } _PackedType t_AdOfTypeResult;
 
 typedef _Packed struct {
@@ -266,6 +266,7 @@ typedef struct {
     uint32_t    shadowAction;
     bool        modifiedState;
     uint8_t     userSizeOfExtraction;
+    uint8_t     userOffset;
 
     t_FmPcdCcNextEngineAndRequiredActionParams nextEngineAndRequiredAction[256];
 } t_FmPcdCcNode;
@@ -296,6 +297,7 @@ typedef struct {
     bool                modifiedState;
     uint32_t            requiredAction;
     t_FmPcdCcNextEngineAndRequiredActionParams nextEngineAndRequiredAction[FM_PCD_MAX_NUM_OF_KEYS];
+    t_Handle            h_IpReassemblyManip;
 } t_FmPcdCcTree;
 
 typedef struct {
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index ca93ec5..6015d4c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -172,14 +172,14 @@ static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool
             case(HEADER_TYPE_IPv4):
                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_IPV4;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IPV4_TUNNELED;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 header index"));
                 return 0;
             case(HEADER_TYPE_IPv6):
                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_IPV6;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IPV6_TUNNELED;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 header index"));
                 return 0;
@@ -224,9 +224,9 @@ static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool
                 return 0;
             case(HEADER_TYPE_IPv4):
             case(HEADER_TYPE_IPv6):
-              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_L3_NO_V;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IP2_NO_V;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
             case(HEADER_TYPE_MINENCAP):
@@ -429,28 +429,28 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                 case(NET_HEADER_FIELD_IPv4_SRC_IP):
                     if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPSRC1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPSRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
                 case(NET_HEADER_FIELD_IPv4_DST_IP):
                     if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPDST1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPDST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
                 case(NET_HEADER_FIELD_IPv4_PROTO):
                     if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_PTYPE1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
                 case(NET_HEADER_FIELD_IPv4_TOS):
                     if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPTOS_TC1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPTOS_TC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
@@ -464,28 +464,28 @@ static t_KnownFieldsMasks GetKnownProtMask(e_NetHeaderType hdr, e_FmPcdHdrIndex
                 case(NET_HEADER_FIELD_IPv6_SRC_IP):
                     if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPSRC1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPSRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
                 case(NET_HEADER_FIELD_IPv6_DST_IP):
                     if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPDST1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPDST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
                 case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
                     if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_PTYPE1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
                 case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
                     if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return (KG_SCH_KN_IPV6FL1 | KG_SCH_KN_IPTOS_TC1);
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return (KG_SCH_KN_IPV6FL2 | KG_SCH_KN_IPTOS_TC2);
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
@@ -1255,7 +1255,7 @@ void KgEnable(t_FmPcd *p_FmPcd)
     t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr,GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
+    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) | FM_PCD_KG_KGGCR_EN);
 }
 
 void KgDisable(t_FmPcd *p_FmPcd)
@@ -1263,7 +1263,7 @@ void KgDisable(t_FmPcd *p_FmPcd)
     t_FmPcdKgRegs               *p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
-    WRITE_UINT32(p_Regs->kggcr,GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
+    WRITE_UINT32(p_Regs->kggcr, GET_UINT32(p_Regs->kggcr) & ~FM_PCD_KG_KGGCR_EN);
 }
 
 void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
@@ -1724,13 +1724,13 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     {
         p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
         if (!p_ClsPlanSet)
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_ClsPlanSet"));
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
         memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
         err = FmPcdKgBuildClsPlanGrp(h_FmPcd, p_GrpParams, p_ClsPlanSet);
         if (err)
         {
             XX_Free(p_ClsPlanSet);
-            RETURN_ERROR(MINOR,err,NO_MSG);
+            RETURN_ERROR(MINOR, err, NO_MSG);
         }
         *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
 
@@ -1794,8 +1794,9 @@ t_Error FmPcdKgDeleteOrUnbindPortToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardware
             /* clear clsPlan entries in memory */
             p_ClsPlanSet = (t_FmPcdKgInterModuleClsPlanSet *)XX_Malloc(sizeof(t_FmPcdKgInterModuleClsPlanSet));
             if (!p_ClsPlanSet)
-                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("memory allocation failed for p_ClsPlanSet"));
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Classification plan set"));
             memset(p_ClsPlanSet, 0, sizeof(t_FmPcdKgInterModuleClsPlanSet));
+
             p_ClsPlanSet->baseEntry = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].baseEntry;
             p_ClsPlanSet->numOfClsPlanEntries = p_FmPcd->p_FmPcdKg->clsPlanGrps[clsPlanGrpId].sizeOfGrp;
             KgSetClsPlan(p_FmPcd, p_ClsPlanSet);
@@ -2900,6 +2901,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t req
                         WriteKgarWait(p_FmPcd, tmpKgarReg);
                         if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
                         {
+                            FmPcdUnlock(p_FmPcd, intFlags);
                             RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
                             RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
                         }
@@ -2932,6 +2934,29 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle  h_Scheme, uint32_t req
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,("in this situation the next engine after scheme can be or PLCR or ENQ_FRAME"));
             }
         }
+        if(requiredAction & UPDATE_KG_NIA_CC_WA)
+        {
+            if (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine == e_FM_PCD_CC)
+            {
+                tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
+                intFlags = FmPcdLock(p_FmPcd);
+                WriteKgarWait(p_FmPcd, tmpKgarReg);
+                if (!(GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode) & KG_SCH_MODE_EN))
+                {
+                    FmPcdUnlock(p_FmPcd, intFlags);
+                    RELEASE_LOCK(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].lock);
+                    RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is Invalid"));
+                }
+                tmpReg32 = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode);
+                ASSERT_COND(tmpReg32 & (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
+                tmpReg32 &= ~NIA_FM_CTL_AC_CC;
+                WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs.kgse_mode, tmpReg32 | NIA_FM_CTL_AC_PRE_CC);
+                /* call indirect command for scheme write */
+                tmpKgarReg = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
+                WriteKgarWait(p_FmPcd, tmpKgarReg);
+                FmPcdUnlock(p_FmPcd, intFlags);
+           }
+        }
     }
     p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].pointedOwners += 1;
     p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].requiredAction |= requiredAction;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
new file mode 100644
index 0000000..c2e3054
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -0,0 +1,2899 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_manip.c
+
+ @Description   FM PCD manip ...
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_port_ext.h"
+#include "fm_muram_ext.h"
+#include "memcpy_ext.h"
+
+#include "fm_common.h"
+#include "fm_hc.h"
+#include "fm_manip.h"
+
+
+#ifdef CORE_8BIT_ACCESS_ERRATA
+#undef WRITE_UINT16
+#undef GET_UINT16
+#undef WRITE_UINT8
+#undef GET_UINT8
+
+#define WRITE_UINT16(addr, val)  \
+    do{                             \
+            if((int)&(addr) % 4)    \
+                WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
+                        ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L)) & 0xffff0000) | (uint32_t)val));  \
+            else                    \
+                WRITE_UINT32(*(uint32_t*)&addr,                                                                         \
+                        ((GET_UINT32(*(uint32_t*)&addr) & 0x0000ffff) | (uint32_t)val<<16));                            \
+      }while(0);
+#define GET_UINT16(addr) (((uint32_t)&addr%4) ?           \
+       ((uint16_t)GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L))):  \
+       ((uint16_t)(GET_UINT32(*(uint32_t*)(uint32_t)&addr) >> 16)))
+
+#define WRITE_UINT8(addr,val) WRITE_UINT8_ERRATA(&addr,val)
+#define GET_UINT8(addr) GET_UINT8_ERRATA(&addr)
+
+
+static void WRITE_UINT8_ERRATA(uint8_t *addr, uint8_t val)
+{
+    uint32_t newAddr, newVal;
+    newAddr = (uint32_t)addr & ~0x3L;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ffffff) | (((uint32_t)val)<<24);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (1):
+         newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff00ffff) | (((uint32_t)val)<<16);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (2):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffff00ff) | (((uint32_t)val)<<8);
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    case (3):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xffffff00) | val;
+        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
+        break;
+    }
+}
+
+static uint8_t GET_UINT8_ERRATA(uint8_t *addr)
+{
+    uint32_t newAddr, newVal=0;
+    newAddr = (uint32_t)addr & ~0x3L;
+    switch ((uint32_t)addr%4)
+    {
+    case (0):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0xff000000)>>24;
+        break;
+    case (1):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x00ff0000)>>16;
+        break;
+    case (2):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x0000ff00)>>8;
+        break;
+    case (3):
+        newVal = GET_UINT32(*(uint32_t*)newAddr);
+        newVal = (newVal & 0x000000ff);
+        break;
+    }
+
+    return (uint8_t)newVal;
+}
+
+#endif /* CORE_8BIT_ACCESS_ERRATA */
+
+static t_Error GetPrOffsetByNonHeader(uint8_t *parseArrayOffset)
+{
+    /*For now - the only field in the Parse Array from the NON_BY_TYPE can be e_FM_PCD_KG_EXTRACT_FROM_CURR_END_OF_PARSE*/
+    /*Maybe extended in the future*/
+
+    *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
+
+    return E_OK;
+}
+
+static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Handle      p_Ad;
+    uint32_t      tmpReg32 = 0;
+    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+           if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+            {
+                tmpReg32 = *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
+                tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
+                *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets = tmpReg32;
+                p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
+                p_Manip->icOffset = icOffset;
+            }
+            else
+            {
+                if(p_Manip->icOffset != icOffset)
+                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
+            }
+            break;
+#ifdef FM_CAPWAP_SUPPORT
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if(p_Manip->h_Frag)
+            {
+                if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+                {
+                    p_Ad     = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+                    tmpReg32 |= GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets);
+                    tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
+                    WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets, tmpReg32);
+                    p_Manip->updateParams &= ~INTERNAL_CONTEXT_OFFSET;
+                    p_Manip->icOffset = icOffset;
+                }
+                else
+                {
+                    if(p_Manip->icOffset != icOffset)
+                            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
+                }
+            }
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+    }
+
+    return E_OK;
+}
+
+static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate)
+{
+
+    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    t_Error                 err;
+    uint32_t                tmpReg32;
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->type & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->muramAllocate, E_INVALID_STATE);
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
+           (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_PSO;
+        fmPortGetSetCcParams.setCcParams.psoSize = 16;
+
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+#ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
+        ASSERT_COND(!(fmPortGetSetCcParams.getCcParams.prOffset % 16));
+#endif
+    }
+    else if (validate)
+    {
+         if((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
+           (p_Manip->updateParams & OFFSET_OF_PR))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_PSO;
+        fmPortGetSetCcParams.setCcParams.psoSize = 16;
+
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
+
+    }
+
+   if(p_Manip->updateParams & OFFSET_OF_PR)
+   {
+        tmpReg32 = 0;
+        tmpReg32 |= fmPortGetSetCcParams.getCcParams.prOffset;
+        WRITE_UINT32(p_Ad->matchTblPtr, (GET_UINT32(p_Ad->matchTblPtr) | tmpReg32));
+        p_Manip->updateParams &= ~OFFSET_OF_PR;
+        p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+   }
+   else if (validate)
+   {
+        tmpReg32 = GET_UINT32(p_Ad->matchTblPtr);
+        if((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"););
+   }
+
+    return E_OK;
+}
+
+#ifdef FM_CAPWAP_SUPPORT
+static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate,t_Handle h_FmTree)
+{
+    t_AdOfTypeContLookup            *p_Ad         = (t_AdOfTypeContLookup *)h_Ad;
+    t_FmPcdCcSavedManipParams       *p_SavedManipParams = NULL;
+    uint32_t                        tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((p_Manip->type == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->type == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+
+    if(p_Manip->updateParams)
+    {
+
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA) &&
+           !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
+           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree, e_FM_MANIP_CAPWAP_INDX);
+        if(!p_SavedManipParams)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
+        p_Manip->fragParams.poolId = p_SavedManipParams->capwapParams.poolId;
+        p_Manip->fragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
+
+        tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
+        tmpReg32 |= ((uint32_t)p_Manip->fragParams.poolId << 8);
+        tmpReg32 |= ((uint32_t)p_Manip->fragParams.dataOffset<< 16);
+        WRITE_UINT32(p_Ad->pcAndOffsets,tmpReg32);
+
+        p_Manip->updateParams &= ~OFFSET_OF_DATA;
+        p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
+        p_Manip->shadowUpdateParams |= (OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP);
+    }
+   else if (validate)
+   {
+
+        p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree, e_FM_MANIP_CAPWAP_INDX);
+        if(!p_SavedManipParams)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
+        if((p_Manip->fragParams.poolId != p_SavedManipParams->capwapParams.poolId) ||
+           (p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
+   }
+
+    return E_OK;
+}
+
+static t_Error UpdateInitCapwapFragmentation(t_Handle h_FmPort, t_FmPcdManip *p_Manip, t_Handle h_Ad, bool validate, t_Handle h_FmTree)
+{
+    t_AdOfTypeContLookup        *p_Ad;
+    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
+    t_Error                     err;
+    uint32_t                    tmpReg32 = 0;
+    t_FmPcdCcSavedManipParams   *p_SavedManipParams;
+
+    UNUSED(h_Ad);
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((p_Manip->type == HMAN_OC_CAPWAP_FRAGMENTATION) || (p_Manip->type == HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER)), E_INVALID_STATE);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA) &&
+           !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
+           ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        /*for CAPWAP Rassembly used FMAN_CTRL2 hardcoded - so for fragmentation its better to use FMAN_CTRL1*/
+        fmPortGetSetCcParams.setCcParams.orFmanCtrl = FPM_PORT_FM_CTL1;
+
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool doe header manipulation wasn't configured previousely"));
+
+        p_SavedManipParams = (t_FmPcdCcSavedManipParams *)XX_Malloc(sizeof(t_FmPcdCcSavedManipParams));
+        p_SavedManipParams->capwapParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+        p_SavedManipParams->capwapParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
+
+#ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
+        ASSERT_COND(!(p_SavedManipParams->capwapParams.dataOffset % 16));
+#endif
+
+        FmPcdCcTreeSetSavedManipParams(h_FmTree, (t_Handle)p_SavedManipParams, e_FM_MANIP_CAPWAP_INDX);
+    }
+    else if (validate)
+    {
+        if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) &&
+            !(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)) ||
+            ((p_Manip->updateParams & OFFSET_OF_DATA) ||
+            (p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool doe header manipulation wasn't configured previousely"));
+    }
+
+    if(p_Manip->updateParams)
+    {
+        tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
+        tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.poolIdForManip << 8);
+        tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.dataOffset<< 16);
+        WRITE_UINT32(p_Ad->pcAndOffsets,tmpReg32);
+
+        p_Manip->updateParams &= ~OFFSET_OF_DATA;
+        p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
+        p_Manip->shadowUpdateParams |= (OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP);
+        p_Manip->fragParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
+        p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+    }
+    else if (validate)
+    {
+        if((p_Manip->fragParams.poolId != fmPortGetSetCcParams.getCcParams.poolIdForManip) ||
+           (p_Manip->fragParams.dataOffset != fmPortGetSetCcParams.getCcParams.dataOffset))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
+    }
+
+    return E_OK;
+}
+
+static t_Error UpdateInitCapwapReasm(t_Handle                   h_FmPcd,
+                                     t_Handle                       h_FmPort,
+                                     t_FmPcdManip                   *p_Manip,
+                                     t_Handle                       h_Ad,
+                                     bool                           validate)
+{
+    t_CapwapReasmPram  *p_ReassmTbl;
+    t_Error             err;
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    uint8_t             i = 0;
+    uint16_t            size;
+    uint32_t            tmpReg32;
+    t_FmPcd             *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdCcCapwapReassmTimeoutParams ccCapwapReassmTimeoutParams;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->type == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+
+    if(p_Manip->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("handler of PCD previously was initiated by different value"));
+
+    UNUSED(h_Ad);
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+    p_ReassmTbl  = (t_CapwapReasmPram *)p_Manip->h_Frag;
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & NUM_OF_TASKS) && !(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP) &&
+        !(p_Manip->updateParams & OFFSET_OF_DATA) && !(p_Manip->updateParams & OFFSET_OF_PR) &&
+        !(p_Manip->updateParams & HW_PORT_ID)) ||
+           ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) ||
+           (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) || (p_Manip->shadowUpdateParams & OFFSET_OF_PR)
+           ||(p_Manip->shadowUpdateParams & HW_PORT_ID)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("buffser pool id  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+#ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
+        ASSERT_COND((fmPortGetSetCcParams.getCcParams.dataOffset % 16) == 0);
+#endif
+    }
+    else if (validate)
+    {
+         if((!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) && (!(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP)) &&
+         (!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) && (!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) &&
+         (!(p_Manip->shadowUpdateParams & HW_PORT_ID))) &&
+           ((p_Manip->updateParams & NUM_OF_TASKS) ||
+           (p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP) ||
+           (p_Manip->updateParams & OFFSET_OF_DATA) || (p_Manip->updateParams & OFFSET_OF_PR)||
+            (p_Manip->updateParams & HW_PORT_ID)))
+
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Buffer pool for header manipulation wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+    }
+
+    if(p_Manip->updateParams)
+    {
+        if(p_Manip->updateParams & NUM_OF_TASKS)
+        {
+            /*recommendation of Microcode team - (maxNumFramesInProcess * 2) */
+            size = (uint16_t)(p_Manip->fragParams.maxNumFramesInProcess*2 + fmPortGetSetCcParams.getCcParams.numOfTasks);
+            if(size  > 255)
+                RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("numOfOpenReassmEntries + numOfTasks per port can not be greater than 256"));
+
+            p_Manip->fragParams.numOfTasks = fmPortGetSetCcParams.getCcParams.numOfTasks;
+
+            /*p_ReassmFrmDescrIndxPoolTbl*/
+            p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                              (uint32_t)(size + 1),
+                                              4);
+            if(!p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size + 1));
+
+            for( i = 0; i < size; i++)
+                WRITE_UINT8(*(uint8_t *)PTR_MOVE(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, i), (uint8_t)(i+1));
+
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
+
+            WRITE_UINT32(p_ReassmTbl->reasmFrmDescIndexPoolTblPtr, tmpReg32);
+
+            /*p_ReassmFrmDescrPoolTbl*/
+            p_Manip->fragParams.p_ReassmFrmDescrPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                              (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
+                                              4);
+
+           if(!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+            IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl, 0,  (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
+
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl) - p_FmPcd->physicalMuramBase);
+
+            WRITE_UINT32(p_ReassmTbl->reasmFrmDescPoolTblPtr, tmpReg32);
+
+            /*p_TimeOutTbl*/
+
+            p_Manip->fragParams.p_TimeOutTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                              (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
+                                              4);
+
+            if(!p_Manip->fragParams.p_TimeOutTbl)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+            IOMemSet32(p_Manip->fragParams.p_TimeOutTbl, 0,  (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
+
+            tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_TimeOutTbl) - p_FmPcd->physicalMuramBase);
+            WRITE_UINT32(p_ReassmTbl->timeOutTblPtr, tmpReg32);
+
+
+            p_Manip->updateParams &= ~NUM_OF_TASKS;
+            p_Manip->shadowUpdateParams |= NUM_OF_TASKS;
+       }
+
+       if(p_Manip->updateParams & BUFFER_POOL_ID_FOR_MANIP)
+       {
+
+            p_Manip->fragParams.poolId = fmPortGetSetCcParams.getCcParams.poolIdForManip;
+
+            tmpReg32 = GET_UINT32(p_ReassmTbl->bufferPoolIdAndRisc1SetIndexes);
+            tmpReg32 |= (uint32_t)p_Manip->fragParams.poolId << 16;
+            WRITE_UINT32(p_ReassmTbl->bufferPoolIdAndRisc1SetIndexes, tmpReg32);
+
+            p_Manip->updateParams &= ~BUFFER_POOL_ID_FOR_MANIP;
+            p_Manip->shadowUpdateParams |= BUFFER_POOL_ID_FOR_MANIP;
+       }
+
+        if(p_Manip->updateParams & OFFSET_OF_DATA)
+        {
+            p_Manip->fragParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+            tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
+            tmpReg32|= p_Manip->fragParams.dataOffset;
+            WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
+            p_Manip->updateParams &= ~OFFSET_OF_DATA;
+            p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
+        }
+        if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+        {
+            p_Manip->fragParams.prOffset = fmPortGetSetCcParams.getCcParams.prOffset;
+
+            tmpReg32 = GET_UINT32(p_ReassmTbl->mode);
+            tmpReg32|= FM_PCD_MANIP_CAPWAP_REASM_PR_COPY;
+            WRITE_UINT32(p_ReassmTbl->mode, tmpReg32);
+
+            tmpReg32 = GET_UINT32(p_ReassmTbl->intStatsTblPtr);
+            tmpReg32 |= (uint32_t)p_Manip->fragParams.prOffset << 24;
+            WRITE_UINT32(p_ReassmTbl->intStatsTblPtr, tmpReg32);
+           p_Manip->updateParams &= ~OFFSET_OF_PR;
+           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+       }
+       else
+       {
+           p_Manip->fragParams.prOffset = 0xff;
+           p_Manip->updateParams &= ~OFFSET_OF_PR;
+           p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
+
+       }
+
+        p_Manip->fragParams.hwPortId = fmPortGetSetCcParams.getCcParams.hardwarePortId;
+        p_Manip->updateParams &= ~HW_PORT_ID;
+        p_Manip->shadowUpdateParams |= HW_PORT_ID;
+
+        /*timeout hc */
+       ccCapwapReassmTimeoutParams.fqidForTimeOutFrames = p_Manip->fragParams.fqidForTimeOutFrames;
+       ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl = (uint32_t)p_Manip->fragParams.hwPortId << 24;
+       ccCapwapReassmTimeoutParams.portIdAndCapwapReassmTbl |= (uint32_t)((XX_VirtToPhys(p_ReassmTbl) - p_FmPcd->physicalMuramBase));
+       ccCapwapReassmTimeoutParams.timeoutRequestTime = (((uint32_t)1<<p_Manip->fragParams.bitFor1Micro) * p_Manip->fragParams.timeoutRoutineRequestTime)/2;
+       return FmHcPcdCcCapwapTimeoutReassm(p_FmPcd->h_Hc,&ccCapwapReassmTimeoutParams);
+
+    }
+    else if(validate)
+    {
+        if(fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
+        if(fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
+
+        if(fmPortGetSetCcParams.getCcParams.poolIdForManip != p_Manip->fragParams.poolId)
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("poolId for this manipulation previously was defined by another value "));
+
+        if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+        {
+            if(p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+        }
+        else
+        {
+            if(p_Manip->fragParams.prOffset != 0xff)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+        }
+        if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));
+    }
+
+    return E_OK;
+}
+#endif /* FM_CAPWAP_SUPPORT */
+
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+static t_Error CreateIpReassCommonParamTable(t_FmPcdManip *p_Manip,
+                                             t_FmPcd *p_FmPcd ,
+                                             t_IpReasmCommonTbl *p_IpReasmCommonPramTbl)
+{
+    uint32_t    tmpReg32 = 0, i;
+    uint64_t    tmpReg64, size;
+    t_Error     err = E_OK;
+
+    /* Allocation of the IP Reassembly Common Parameters table. This table is located in the
+    MURAM. Its size is 64 bytes and its base address should be 8-byte aligned.
+    It contains parameters that are common to both the IPv4 reassembly function and IPv6
+    reassembly function.*/
+    p_Manip->ipReassmParams.h_IpReassCommonParamsTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                       FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE,
+                                                       FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN);
+
+    if(!p_Manip->ipReassmParams.h_IpReassCommonParamsTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    p_IpReasmCommonPramTbl = (t_IpReasmCommonTbl *)(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
+
+    IOMemSet32(p_IpReasmCommonPramTbl, 0,  FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE);
+
+    /* Setting the TimeOut Mode.*/
+    tmpReg32 = 0;
+    if(p_Manip->ipReassmParams.timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
+        tmpReg32 |= FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES;
+
+    /* Setting TimeOut FQID - Frames that time out are enqueued to this FQID.
+    In order to cause TimeOut frames to be discarded, this queue should be configured accordingly*/
+    tmpReg32 |= p_Manip->ipReassmParams.fqidForTimeOutFrames;
+    WRITE_UINT32(p_IpReasmCommonPramTbl->timeoutModeAndFqid, tmpReg32);
+
+    /* Calculation the size of IP Reassembly Frame Descriptor - number of frames that are allowed to be reassembled simultaneously + 128.*/
+    size = p_Manip->ipReassmParams.maxNumFramesInProcess + 128;
+
+    /*Allocation of IP Reassembly Frame Descriptor Indexes Pool - This pool resides in the MURAM */
+    p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                      (uint32_t)(size * 2),
+                                      256);
+    if(!p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size * 2));
+
+    /* The entries in IP Reassembly Frame Descriptor Indexes Pool contains indexes starting with 1 up to
+    the maximum number of frames that are allowed to be reassembled simultaneously + 128.
+    The last entry in this pool must contain the index zero*/
+    for( i = 0; i < size - 1; i++)
+        WRITE_UINT16(*(uint16_t *)PTR_MOVE_16(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl, i), (uint16_t)(i+1));
+
+    /* Sets the IP Reassembly Frame Descriptor Indexes Pool offset from MURAM */
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(p_IpReasmCommonPramTbl->reassFrmDescIndexPoolTblPtr, tmpReg32);
+
+    /* Allocation of the Reassembly Frame Descriptors Pool - This pool resides in external memory.
+    The number of entries in this pool should be equal to the number of entries in IP Reassembly Frame Descriptor Indexes Pool.*/
+    p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl = (t_Handle)XX_MallocSmart((uint32_t)(size * 64), p_Manip->ipReassmParams.dataMemId, 64);
+
+    if(!p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+
+    IOMemSet32(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl, 0,  (uint32_t)(size * 32));
+
+    /* Sets the Reassembly Frame Descriptors Pool and liodn offset*/
+    tmpReg64 = (uint64_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl));
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    WRITE_UINT32(p_IpReasmCommonPramTbl->liodnAndReassFrmDescPoolPtrHi, (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32(p_IpReasmCommonPramTbl->reassFrmDescPoolPtrLow, (uint32_t)tmpReg64);
+
+    /*Allocation of the TimeOut table - This table resides in the MURAM.
+    The number of entries in this table is identical to the number of entries in the Reassembly Frame Descriptors Pool*/
+    p_Manip->ipReassmParams.h_TimeOutTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                           (uint32_t)(size  * 8),8);
+
+    if(!p_Manip->ipReassmParams.h_TimeOutTbl)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->ipReassmParams.h_TimeOutTbl, 0,  (uint16_t)(size * 8));
+
+    /* Sets the TimeOut table offset from MURAM*/
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_TimeOutTbl) - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(p_IpReasmCommonPramTbl->timeOutTblPtr, tmpReg32);
+
+    /* Sets the Expiration Delay */
+    tmpReg32 = 0;
+    tmpReg32 |= p_Manip->ipReassmParams.timeoutThresholdForReassmProcess * 256;
+    WRITE_UINT32(p_IpReasmCommonPramTbl->expirationDelay, tmpReg32);
+
+    /* Counts the number of TimeOut occurrences - Must be initialized to zero.*/
+    WRITE_UINT32(p_IpReasmCommonPramTbl->totalTimeOutCounter, 0);
+    /* Counts the number of failed attempts to allocate a Reassembly Frame Descriptor - Must be initialized to zero.*/
+    WRITE_UINT32(p_IpReasmCommonPramTbl->totalRfdPoolBusyCounter, 0);
+    /* Counts the number of times an internal buffer busy occured.*/
+    WRITE_UINT32(p_IpReasmCommonPramTbl->totalInternalBufferBusy, 0);
+    /* Counts the number of times external buffer busy occured. */
+    WRITE_UINT32(p_IpReasmCommonPramTbl->totalExternalBufferBusy, 0);
+
+    err = FmPcdRegisterReassmPort(p_FmPcd, p_IpReasmCommonPramTbl);
+    if (err != E_OK)
+    {
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_IpReasmCommonPramTbl);
+        RETURN_ERROR(MAJOR, err, ("port registration"));
+    }
+
+    return err;
+}
+
+static t_Handle CreateIpReassParamTable(t_FmPcdManip *p_Manip,  bool ipv4)
+{
+    t_FmPcd                 *p_FmPcd = p_Manip->h_FmPcd;
+    uint32_t                tmpReg32, autoLearnHashTblSize;
+    uint32_t                numOfWays, setSize, setSizeCode, tmpSetSize;
+    uint32_t                waySize, numOfSets, tmpNumOfSets, numOfEntries;
+    uint64_t                tmpReg64;
+    uint16_t                minFragSize;
+    t_Handle                *h_AutoLearnHashTbl, *h_AutoLearnSetLockTblPtr, h_IpReassParamsTblPtr;
+    t_IpReasmPram           *p_IpReassParamsTblPtr;
+
+    /* Allocates the IP Reassembly Parameters Table - This table is located in the MURAM.*/
+    h_IpReassParamsTblPtr = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                        FM_PCD_MANIP_IP_REASM_TABLE_SIZE,
+                                                        FM_PCD_MANIP_IP_REASM_TABLE_ALIGN);
+
+    if(!h_IpReassParamsTblPtr)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+        return NULL;
+    }
+
+    p_IpReassParamsTblPtr = (t_IpReasmPram *)h_IpReassParamsTblPtr;
+    memset(p_IpReassParamsTblPtr, 0, sizeof(t_IpReasmPram));
+
+    /* Sets the IP Reassembly common Parameters table offset from MURAM in the IP Reassembly Table descriptor*/
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl) - p_FmPcd->physicalMuramBase);
+    WRITE_UINT32(p_IpReassParamsTblPtr->ipReassCommonPrmTblPtr, tmpReg32);
+
+    /* Get user's requested number of ways */
+    numOfWays = p_Manip->ipReassmParams.numOfFramesPerHashEntry;
+
+    /*It is recommended that the total number of entries in this table
+    (number of sets * number of ways) will be twice the number of frames that
+     are expected to be reassembled simultaneously.*/
+    numOfEntries = (uint32_t)(p_Manip->ipReassmParams.maxNumFramesInProcess * 2);
+
+    /* sets number calculation - number of entries = number of sets * number of ways */
+    numOfSets = numOfEntries / numOfWays;
+
+    /* Calculates way size */
+    switch(p_Manip->ipReassmParams.hdr)
+    {
+        case(HEADER_TYPE_IPv6):
+            /* WaySize is rounded-up to next multiple of 8 */
+            waySize = ROUND_UP(((16 + 16 + 4) /* * numOfWays*/),8);
+            break;
+        case(HEADER_TYPE_IPv4):
+            waySize = ROUND_UP(((4 + 4 + 1 + 2)),8);
+            break;
+        default:
+            REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
+            return NULL;
+    }
+
+    /* Calculate set size (set size is rounded-up to next power of 2) */
+    LOG2(numOfWays * waySize, tmpSetSize);
+    setSize =  (uint32_t)(1 << (tmpSetSize + (POWER_OF_2(numOfWays * waySize) ? 0 : 1)));
+
+    /* Get set size code */
+    LOG2(setSize, setSizeCode);
+
+    /* Sets ways number and set size code */
+    WRITE_UINT16(p_IpReassParamsTblPtr->waysNumAndSetSize, (uint16_t)((numOfWays << 8) | setSizeCode));
+
+    /* Sets AutoLearnHashKeyMask*/
+    LOG2(numOfSets, tmpNumOfSets);
+    numOfSets = (uint32_t)(1 << (tmpNumOfSets + (POWER_OF_2(numOfSets) ? 0 : 1)));
+    WRITE_UINT16(p_IpReassParamsTblPtr->autoLearnHashKeyMask, (uint16_t)(numOfSets - 1));
+
+    /* Allocation of IP Reassembly Automatic Learning Hash Table - This table resides in external memory.
+    The size of this table is determined by the number of sets and the set size.
+    Table size = set size * number of sets
+    This table’s base address should be aligned to SetSize.*/
+    autoLearnHashTblSize = numOfSets * setSize;
+
+    if (ipv4)
+        h_AutoLearnHashTbl = &p_Manip->ipReassmParams.h_Ipv4AutoLearnHashTbl;
+    else
+        h_AutoLearnHashTbl = &p_Manip->ipReassmParams.h_Ipv6AutoLearnHashTbl;
+
+    *h_AutoLearnHashTbl = (t_Handle)XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize);
+
+    if(!*h_AutoLearnHashTbl)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+        return NULL;
+    }
+    IOMemSet32(*h_AutoLearnHashTbl, 0,  autoLearnHashTblSize);
+
+    /* Sets the IP Reassembly Automatic Learning Hash Table and liodn offset */
+    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    tmpReg64 |= XX_VirtToPhys(*h_AutoLearnHashTbl);
+    WRITE_UINT32(p_IpReassParamsTblPtr->liodnAlAndAutoLearnHashTblPtrHi, (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32(p_IpReassParamsTblPtr->autoLearnHashTblPtrLow, (uint32_t)tmpReg64);
+
+    /* Allocation of the Set Lock table - This table resides in external memory
+    The size of this table is (number of sets in the IP Reassembly Automatic Learning Hash table)*4 bytes.
+    This table resides in external memory and its base address should be 4-byte aligned */
+    if (ipv4)
+        h_AutoLearnSetLockTblPtr = &p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr;
+    else
+        h_AutoLearnSetLockTblPtr = &p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr;
+
+    *h_AutoLearnSetLockTblPtr = (t_Handle)XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4);
+
+    if(!*h_AutoLearnSetLockTblPtr)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
+        return NULL;
+    }
+
+    IOMemSet32(*h_AutoLearnSetLockTblPtr, 0,  (numOfSets * 4));
+
+    /* sets Set Lock table pointer and liodn offset*/
+    tmpReg64 = ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT);
+    tmpReg64 |= ((uint64_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << (uint64_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT);
+    tmpReg64 |= XX_VirtToPhys(*h_AutoLearnSetLockTblPtr);
+    WRITE_UINT32(p_IpReassParamsTblPtr->liodnSlAndAutoLearnSetLockTblPtrHi, (uint32_t)(tmpReg64 >> 32));
+    WRITE_UINT32(p_IpReassParamsTblPtr->autoLearnSetLockTblPtrLow, (uint32_t)tmpReg64);
+
+    /* Sets user's requested minimum fragment size (in Bytes) for First/Middle fragment */
+    minFragSize = ipv4 ? p_Manip->ipReassmParams.minFragSize[0] : p_Manip->ipReassmParams.minFragSize[1];
+    WRITE_UINT16(p_IpReassParamsTblPtr->minFragSize, minFragSize);
+
+    /* Zeroes all counters */
+    WRITE_UINT32(p_IpReassParamsTblPtr->totalSuccessfullyReasmFramesCounter, 0);
+    WRITE_UINT32(p_IpReassParamsTblPtr->totalValidFragmentCounter, 0);
+    WRITE_UINT32(p_IpReassParamsTblPtr->totalProcessedFragCounter, 0);
+    WRITE_UINT32(p_IpReassParamsTblPtr->totalMalformdFragCounter, 0);
+    WRITE_UINT32(p_IpReassParamsTblPtr->totalSetBusyCounter, 0);
+    WRITE_UINT32(p_IpReassParamsTblPtr->totalDiscardedFragsCounter, 0);
+    WRITE_UINT32(p_IpReassParamsTblPtr->totalMoreThan16FramesCounter, 0);
+
+    /* Return the pointer to the IP Reassembly table */
+    return h_IpReassParamsTblPtr;
+}
+
+static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
+                                 t_Handle       h_PcdParams,
+                                 t_Handle       h_FmPort,
+                                 t_FmPcdManip   *p_Manip,
+                                 t_Handle       h_Ad,
+                                 bool           validate)
+{
+    t_AdOfTypeContLookup        *p_Ipv4Ad = NULL, *p_Ipv6Ad = NULL;
+    t_FmPortGetSetCcParams      fmPortGetSetCcParams;
+    uint32_t                    tmpReg32;
+    t_Error                     err;
+    t_FmPortPcdParams           *p_PcdParams = (t_FmPortPcdParams *)h_PcdParams;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->frag,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Manip->type == HMAN_OC_IP_REASSEMBLY), E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcd,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Manip->updateParams || h_PcdParams,E_INVALID_HANDLE);
+
+    UNUSED(h_Ad);
+
+    if( p_Manip->ipReassmParams.h_Ipv4Ad != NULL)
+         p_Ipv4Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv4Ad;
+    if( p_Manip->ipReassmParams.h_Ipv6Ad != NULL)
+         p_Ipv6Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv6Ad;
+
+    if(p_Manip->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("handler of PCD previously was initiated by different value"));
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+
+
+    if(p_Manip->updateParams)
+    {
+        if((!(p_Manip->updateParams & OFFSET_OF_DATA) && !(p_Manip->updateParams & HW_PORT_ID)) ||
+           ((p_Manip->shadowUpdateParams & NUM_OF_TASKS) || (p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) ||
+           (p_Manip->shadowUpdateParams & OFFSET_OF_DATA) ||(p_Manip->shadowUpdateParams & HW_PORT_ID)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
+
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_IPR_EN;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_RFENE;
+        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ORDER_RESTOR);
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Num of tasks wasn't configured previously"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previously"));
+        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+
+        if(p_Manip->ipReassmParams.h_Ipv4Scheme)
+        {
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv4Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
+        }
+        if(p_Manip->ipReassmParams.h_Ipv6Scheme)
+        {
+            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv6Scheme;
+            p_PcdParams->p_KgParams->numOfSchemes++;
+        }
+    }
+    else if (validate)
+    {
+         if((!(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) &&
+         (!(p_Manip->shadowUpdateParams & OFFSET_OF_DATA)) &&
+         (!(p_Manip->shadowUpdateParams & HW_PORT_ID))) &&
+           ((p_Manip->updateParams & NUM_OF_TASKS) ||
+           (p_Manip->updateParams & OFFSET_OF_DATA) ||
+            (p_Manip->updateParams & HW_PORT_ID)))
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
+
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
+        fmPortGetSetCcParams.getCcParams.poolIndex = p_Manip->fragParams.poolIndx;
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_RFENE;
+        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_FRAG_CHECK | NIA_ORDER_RESTOR);
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+        if(fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("NumOfTasks wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("offset of the data  wasn't configured previousely"));
+        if(fmPortGetSetCcParams.getCcParams.type & HW_PORT_ID)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("hwPortId wasn't updated"));
+    }
+
+    if(p_Manip->updateParams)
+    {
+        if(p_Manip->updateParams & OFFSET_OF_DATA)
+        {
+            p_Manip->ipReassmParams.dataOffset = fmPortGetSetCcParams.getCcParams.dataOffset;
+            if (p_Ipv4Ad != NULL)
+            {
+                tmpReg32 = GET_UINT32(p_Ipv4Ad->matchTblPtr);
+                tmpReg32 |= (p_Manip->ipReassmParams.dataOffset << 16);
+                WRITE_UINT32(p_Ipv4Ad->matchTblPtr, tmpReg32);
+            }
+            if (p_Ipv6Ad != NULL)
+            {
+                tmpReg32 = GET_UINT32(p_Ipv6Ad->matchTblPtr);
+                tmpReg32 |= (p_Manip->ipReassmParams.dataOffset << 16);
+                WRITE_UINT32(p_Ipv6Ad->matchTblPtr, tmpReg32);
+            }
+
+            p_Manip->updateParams &= ~OFFSET_OF_DATA;
+            p_Manip->shadowUpdateParams |= OFFSET_OF_DATA;
+        }
+
+        p_Manip->updateParams &= ~HW_PORT_ID;
+        p_Manip->shadowUpdateParams |= HW_PORT_ID;
+    }
+    else
+    {
+        if(validate)
+        {
+            /* TODO - Handle validate..*/
+            /*if(fmPortGetSetCcParams.getCcParams.hardwarePortId != p_Manip->fragParams.hwPortId)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Reassembly manipulation previously was assigned to another port"));
+            if(fmPortGetSetCcParams.getCcParams.numOfTasks != p_Manip->fragParams.numOfTasks)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfTasks for this manipulation previously was defined by another value "));
+
+            if(fmPortGetSetCcParams.getCcParams.poolIdForManip != p_Manip->fragParams.poolId)
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("poolId for this manipulation previously was defined by another value "));
+
+            if(!(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR))
+            {
+                if(p_Manip->fragParams.prOffset != fmPortGetSetCcParams.getCcParams.prOffset)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+            }
+            else
+            {
+                if(p_Manip->fragParams.prOffset != 0xff)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Parse result offset previously was defined by another value "));
+            }
+            if(fmPortGetSetCcParams.getCcParams.dataOffset != p_Manip->fragParams.dataOffset)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Data offset previously was defined by another value "));*/
+
+        }
+    }
+
+    return E_OK;
+}
+
+t_Error FmPcdFragHcScratchPoolFill(t_Handle h_FmPcd, uint8_t scratchBpid)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcFragScratchPoolCmdParams   fmPcdCcFragScratchPoolCmdParams;
+    t_Error                             err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    memset(&fmPcdCcFragScratchPoolCmdParams, 0, sizeof(t_FmPcdCcFragScratchPoolCmdParams));
+
+    fmPcdCcFragScratchPoolCmdParams.numOfBuffers = NUM_OF_SCRATCH_POOL_BUFFERS;
+    fmPcdCcFragScratchPoolCmdParams.bufferPoolId = scratchBpid;
+    if ((err = FmHcPcdCcIpFragScratchPollCmd(p_FmPcd->h_Hc, TRUE, &fmPcdCcFragScratchPoolCmdParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if (fmPcdCcFragScratchPoolCmdParams.numOfBuffers != 0)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Fill scratch pool failed,"
+                                              "Failed to release %d buffers to the BM (missing FBPRs)", fmPcdCcFragScratchPoolCmdParams.numOfBuffers));
+    return E_OK;
+}
+
+t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid)
+{
+    t_FmPcd                             *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcFragScratchPoolCmdParams   fmPcdCcFragScratchPoolCmdParams;
+    t_Error                             err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+
+    memset(&fmPcdCcFragScratchPoolCmdParams, 0, sizeof(t_FmPcdCcFragScratchPoolCmdParams));
+
+    fmPcdCcFragScratchPoolCmdParams.bufferPoolId = scratchBpid;
+    if ((err = FmHcPcdCcIpFragScratchPollCmd(p_FmPcd->h_Hc, FALSE, &fmPcdCcFragScratchPoolCmdParams)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    if (fmPcdCcFragScratchPoolCmdParams.numOfBuffers != NUM_OF_SCRATCH_POOL_BUFFERS)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Empty scratch pool failed"));
+
+    return E_OK;
+}
+#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
+
+static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    if(p_Manip->h_Ad)
+    {
+        if(p_Manip->muramAllocate)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Ad);
+        else
+            XX_Free(p_Manip->h_Ad);
+        p_Manip->h_Ad = NULL;
+    }
+    if(p_Manip->p_Template)
+    {
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_Template);
+        p_Manip->p_Template = NULL;
+    }
+    if(p_Manip->h_Frag)
+    {
+        if(p_Manip->fragParams.p_AutoLearnHashTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_AutoLearnHashTbl);
+        if(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrPoolTbl);
+        if(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl);
+        if(p_Manip->fragParams.p_TimeOutTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_TimeOutTbl);
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Frag);
+
+    }
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    if (p_Manip->frag)
+    {
+        if (p_Manip->ipFragParams.p_Frag)
+        {
+            FmPcdFragHcScratchPoolEmpty((t_Handle)p_FmPcd, p_Manip->ipFragParams.scratchBpid);
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
+        }
+    }
+    else if (p_Manip->reassm)
+    {
+        FmPcdUnregisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
+
+        if(p_Manip->ipReassmParams.h_Ipv4AutoLearnHashTbl)
+            XX_Free(p_Manip->ipReassmParams.h_Ipv4AutoLearnHashTbl);
+        if(p_Manip->ipReassmParams.h_Ipv6AutoLearnHashTbl)
+            XX_Free(p_Manip->ipReassmParams.h_Ipv6AutoLearnHashTbl);
+        if(p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr)
+            XX_Free(p_Manip->ipReassmParams.h_Ipv4AutoLearnSetLockTblPtr);
+        if(p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr)
+            XX_Free(p_Manip->ipReassmParams.h_Ipv6AutoLearnSetLockTblPtr);
+        if(p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr);
+        if(p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr);
+        if(p_Manip->ipReassmParams.h_IpReassCommonParamsTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_IpReassCommonParamsTbl);
+        if(p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl)
+            FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipReassmParams.h_ReassmFrmDescrIndxPoolTbl);
+        if(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl)
+            XX_Free(p_Manip->ipReassmParams.h_ReassmFrmDescrPoolTbl);
+
+        if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+            FM_PCD_KgDeleteScheme(p_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme);
+
+        if (p_Manip->ipReassmParams.h_Ipv6Scheme)
+            FM_PCD_KgDeleteScheme(p_FmPcd, p_Manip->ipReassmParams.h_Ipv4Scheme);
+    }
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+    if(p_Manip->p_StatsTbl)
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_StatsTbl);
+}
+
+static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
+{
+
+    if(p_ManipParams->rmv)
+    {
+        switch(p_ManipParams->rmvParams.type)
+        {
+            case(e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION):
+                switch(p_ManipParams->rmvParams.rmvSpecificLocationParams.type)
+                {
+                    case(e_FM_PCD_MANIP_LOC_BY_HDR) :
+                        switch(p_ManipParams->rmvParams.rmvSpecificLocationParams.manipByHdr.hdr)
+                        {
+                            case(HEADER_TYPE_CAPWAP_DTLS) :
+
+                                p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+                                p_Manip->muramAllocate = TRUE;
+
+                                if(p_ManipParams->insrt)
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
+
+                                if(p_ManipParams->fragOrReasm)
+                                {
+                                    if(!p_ManipParams->fragOrReasmParams.frag)
+                                    {
+                                        switch(p_ManipParams->fragOrReasmParams.hdr)
+                                        {
+                                            case(HEADER_TYPE_CAPWAP):
+                                                p_Manip->type = HMAN_OC_CAPWAP_REASSEMBLY;
+                                                break;
+                                            default:
+                                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("unsupported header for Reassembly"));
+                                        }
+                                    }
+                                    else
+                                        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for this type of manipulation frag can not be TRUE"));
+                                }
+                            break;
+                            default:
+                                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid net header of remove location"));
+
+                        }
+                        break;
+                        default:
+                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("non valid type of remove location"));
+
+                }
+            break;
+            case(e_FM_PCD_MANIP_RMV_INT_FRAME_HDR) :
+                if(p_ManipParams->insrt || p_ManipParams->fragOrReasm)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For the type of remove e_FM_PCD_MANIP_RMV_INT_FRAME_HDR the only valid option rmv = TRUE, insrt = FALSE, fragOrReasm = FALSE"));
+                p_Manip->type = HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
+                p_Manip->muramAllocate = FALSE;
+            break;
+            case(e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION) :
+                if  (p_ManipParams->fragOrReasm ||
+                    ((p_ManipParams->insrt) && p_ManipParams->insrtParams.type != e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION the only allowed insertion type is e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR"));
+                p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                p_Manip->muramAllocate = TRUE;
+           break;
+           default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
+        }
+    }
+    else if(p_ManipParams->insrt)
+    {
+        switch(p_ManipParams->insrtParams.type)
+        {
+            case(e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE) :
+
+                p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+                p_Manip->muramAllocate = FALSE;
+
+                if(p_ManipParams->fragOrReasm)
+                {
+                    if(p_ManipParams->fragOrReasmParams.frag)
+                    {
+                           switch(p_ManipParams->fragOrReasmParams.hdr)
+                           {
+                                case(HEADER_TYPE_CAPWAP):
+                                    p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
+                                    break;
+                                break;
+                                default:
+                                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid header for fragmentation"));
+                           }
+                    }
+                    else
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,("can not reach this point"));
+                }
+            break;
+            case(e_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR) :
+                if(p_ManipParams->fragOrReasm)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of insert can not be fragOrReasm = TRUE"));
+                p_Manip->type = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+                p_Manip->muramAllocate = TRUE;
+            break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
+        }
+    }
+    else if(p_ManipParams->fragOrReasm)
+    {
+        if(p_ManipParams->fragOrReasmParams.frag)
+        {
+            switch(p_ManipParams->fragOrReasmParams.hdr)
+             {
+                 case(HEADER_TYPE_CAPWAP):
+                     p_Manip->type = HMAN_OC_CAPWAP_FRAGMENTATION;
+                     p_Manip->muramAllocate = FALSE;
+                 break;
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+                 case(HEADER_TYPE_IPv4):
+                 case(HEADER_TYPE_IPv6):
+                     p_Manip->type = HMAN_OC_IP_FRAGMENTATION;
+                     p_Manip->muramAllocate = TRUE;
+                 break;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+                 default:
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for fragmentation"));
+             }
+        }
+        else
+        {
+            switch (p_ManipParams->fragOrReasmParams.hdr)
+            {
+                case(HEADER_TYPE_CAPWAP):
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+                case(HEADER_TYPE_IPv4):
+                    p_Manip->type = HMAN_OC_IP_REASSEMBLY;
+                    p_Manip->muramAllocate = TRUE;
+                    p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv4;
+                    break;
+                case(HEADER_TYPE_IPv6):
+                    p_Manip->type = HMAN_OC_IP_REASSEMBLY;
+                    p_Manip->muramAllocate = TRUE;
+                    p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv6;
+                    break;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+                default:
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
+
+            }
+        }
+
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("User didn't ask for any manipulation"));
+
+    p_Manip->insrt = p_ManipParams->insrt;
+    p_Manip->rmv   = p_ManipParams->rmv;
+
+    return E_OK;
+}
+static t_Error UpdateIndxStats(  t_Handle                       h_FmPcd,
+                                 t_Handle                       h_FmPort,
+                                 t_FmPcdManip                   *p_Manip)
+{
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    uint32_t                tmpReg32 = 0;
+    t_AdOfTypeContLookup    *p_Ad;
+    t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Ad    = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if(p_Manip->h_FmPcd != h_FmPcd)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                     ("handler of PCD previously was initiated by different value"));
+
+    memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+
+    if(!p_Manip->p_StatsTbl)
+    {
+
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        tmpReg32 = GET_UINT32(p_Ad->ccAdBase);
+
+        p_Manip->p_StatsTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
+                                          4);
+        if(!p_Manip->p_StatsTbl)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+        IOMemSet32(p_Manip->p_StatsTbl, 0,  (uint32_t)(p_Manip->owner * 4));
+
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->p_StatsTbl) - p_FmPcd->physicalMuramBase);
+
+        if(p_Manip->cnia)
+            tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_CNIA;
+
+        tmpReg32 |=  FM_PCD_MANIP_INDEXED_STATS_DPD;
+        WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    }
+    else
+    {
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
+        err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    return E_OK;
+}
+
+static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error      err = E_OK;
+    SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
+    UNUSED(level);
+    UNUSED(h_FmPcd);
+    UNUSED(h_FmTree);
+#ifndef FM_IP_FRAG_N_REASSEM_SUPPORT
+    UNUSED(h_PcdParams);
+#endif /* not FM_IP_FRAG_N_REASSEM_SUPPORT */
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
+        break;
+#ifdef FM_CAPWAP_SUPPORT
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if(!p_Manip->h_Frag)
+                break;
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+            err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
+        break;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if(p_Manip->h_Frag)
+            {
+                err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
+            }
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        case(HMAN_OC_IP_REASSEMBLY):
+            err = UpdateInitIpReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
+            break;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
+            break;
+        default:
+            return E_OK;
+    }
+    return err;
+}
+
+static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree)
+{
+
+    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error         err = E_OK;
+    UNUSED(level);
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+
+           if(p_Manip->h_Frag)
+           {
+               if(!(p_Manip->shadowUpdateParams & NUM_OF_TASKS) && !(p_Manip->shadowUpdateParams & BUFFER_POOL_ID_FOR_MANIP) &&
+               !(p_Manip->shadowUpdateParams & OFFSET_OF_DATA) && !(p_Manip->shadowUpdateParams & OFFSET_OF_PR))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation requires manipulation be updated previousely in SetPcd function"));
+           }
+           break;
+#ifdef FM_CAPWAP_SUPPORT
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if(p_Manip->h_Frag)
+            {
+                err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
+            }
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+        default:
+            return E_OK;
+
+    }
+    return err;
+
+}
+
+static t_Error GetPrOffsetByHeaderOrField(t_FmPcdManipLocationParams *p_ManipParams, uint8_t *parseArrayOffset)
+{
+    e_NetHeaderType hdr         = p_ManipParams->manipByHdr.hdr;
+    e_FmPcdHdrIndex hdrIndex    = p_ManipParams->manipByHdr.hdrIndex;
+    bool            byField     = p_ManipParams->manipByHdr.byField;
+    t_FmPcdFields   field;
+
+    if(byField)
+        field = p_ManipParams->manipByHdr.fullField;
+
+    if(byField)
+    {
+        switch(hdr)
+        {
+            case(HEADER_TYPE_ETH):
+                switch(field.eth)
+                {
+                    case(NET_HEADER_FIELD_ETH_TYPE):
+                        *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
+                        break;
+                    default:
+                        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type Ethernet with this field not supported"));
+                }
+                break;
+            case(HEADER_TYPE_VLAN):
+                switch(field.vlan)
+                {
+                    case(NET_HEADER_FIELD_VLAN_TCI) :
+                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                            *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
+                        else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                             *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
+                        break;
+                    default:
+                       RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type VLAN with this field not supported"));
+                }
+                break;
+           default:
+               RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header by field not supported"));
+        }
+    }
+    else
+    {
+        switch(hdr){
+             case(HEADER_TYPE_ETH):
+                 *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
+                break;
+            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
+                break;
+            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
+                break;
+            /* TODO - to take care about SHIM3
+            case(HEADER_TYPE_USER_DEFINED_SHIM3):
+                *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM3_OFFSET;
+                break;
+            */
+            case(HEADER_TYPE_LLC_SNAP):
+                *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
+                break;
+            case(HEADER_TYPE_PPPoE):
+                *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
+                break;
+            case(HEADER_TYPE_MPLS):
+                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
+                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
+                break;
+            case(HEADER_TYPE_IPv4):
+            case(HEADER_TYPE_IPv6):
+              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
+              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                    *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
+                break;
+            case(HEADER_TYPE_MINENCAP):
+                *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
+                break;
+            case(HEADER_TYPE_GRE):
+                *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
+                break;
+            case(HEADER_TYPE_TCP):
+            case(HEADER_TYPE_UDP):
+            case(HEADER_TYPE_IPSEC_AH):
+            case(HEADER_TYPE_IPSEC_ESP):
+            case(HEADER_TYPE_DCCP):
+            case(HEADER_TYPE_SCTP):
+                *parseArrayOffset = CC_PC_PR_L4_OFFSET;
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of this header is not supported"));
+     }
+    }
+    return E_OK;
+}
+
+static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipRmvParams  *p_ManipParams, t_FmPcdManip *p_Manip)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+    uint8_t                 prsArrayOffset = 0;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if(p_Manip->rmv)
+    {
+        switch(p_ManipParams->rmvSpecificLocationParams.type)
+        {
+            case(e_FM_PCD_MANIP_LOC_BY_HDR) :
+                err = GetPrOffsetByHeaderOrField(&p_ManipParams->rmvSpecificLocationParams, &prsArrayOffset);
+                break;
+            case(e_FM_PCD_MANIP_LOC_NON_HDR) :
+                err = GetPrOffsetByNonHeader(&prsArrayOffset);
+                break;
+            default :
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid type of location header manipulation of type Remove"));
+        }
+        if(err)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        tmpReg32 |= (uint32_t)prsArrayOffset << 24;
+        tmpReg32 |= HMAN_RMV_HDR;
+    }
+
+    if(p_Manip->insrt)
+        tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
+
+    tmpReg32 |= (uint32_t)HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
+
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return E_OK;
+}
+
+static t_Error MvIntFrameHeaderFromFrameToBufferPrefix(t_FmPcdManip *p_Manip, bool caamUsed)
+{
+    t_AdOfTypeContLookup    *p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    uint32_t                tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Ad,E_INVALID_HANDLE);
+
+    p_Manip->updateParams |= OFFSET_OF_PR | INTERNAL_CONTEXT_OFFSET;
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    *(uint32_t *)&p_Ad->ccAdBase = tmpReg32;
+
+    /*TODO - update offsetInBufferPrefixForIntFrameHdr when port connected to tree
+    tmpReg32 = 0;
+    tmpReg32 |= offsetInBufferPrefixForIntFrameHdr;
+    *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;*/
+
+    tmpReg32 = 0;
+    tmpReg32 |= HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX;
+    tmpReg32 |= (uint32_t)0x16 << 16;
+    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+
+    if (caamUsed)
+        *(uint32_t *)&p_Ad->gmask = 0xf0000000;
+
+    return E_OK;
+}
+
+#ifdef FM_CAPWAP_SUPPORT
+static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+    t_Error                 err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+
+
+    if(p_Manip->h_Frag)
+    {
+        p_Manip->updateParams |= INTERNAL_CONTEXT_OFFSET;
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
+    }
+
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return err;
+}
+
+static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd, uint8_t poolIndex)
+{
+    t_Handle    p_Table;
+    uint32_t    tmpReg32 = 0;
+    int         i = 0;
+    uint8_t     log2Num;
+    uint8_t     numOfSets;
+    uint32_t    j = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+
+    if(!p_FmPcd->h_Hc)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("hc port has to be initialized in this mode"));
+    if (!POWER_OF_2(p_ManipParams->timeoutRoutineRequestTime))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeoutRoutineRequestTime has to be power of 2"));
+    if(!POWER_OF_2(p_ManipParams->maxNumFramesInProcess))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("maxNumFramesInProcess has to be power of 2"));
+    if(!p_ManipParams->timeoutRoutineRequestTime && p_ManipParams->timeoutThresholdForReassmProcess)
+        DBG(WARNING, ("if timeoutRoutineRequestTime 0,  timeoutThresholdForReassmProcess is uselessly"));
+    if(p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH)
+    {
+        if((p_ManipParams->maxNumFramesInProcess < 4) ||
+            (p_ManipParams->maxNumFramesInProcess > 512))
+            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_EIGHT_WAYS_HASH maxNumFramesInProcess has to be in the range 4-512"));
+    }
+    else
+    {
+        if((p_ManipParams->maxNumFramesInProcess < 8) ||
+            (p_ManipParams->maxNumFramesInProcess > 2048))
+            RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"));
+    }
+
+    p_Manip->updateParams |= (NUM_OF_TASKS | BUFFER_POOL_ID_FOR_MANIP | OFFSET_OF_PR | OFFSET_OF_DATA | HW_PORT_ID);
+
+    p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
+                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+    if(!p_Manip->h_Frag)
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
+
+    p_Table         = (t_CapwapReasmPram *)p_Manip->h_Frag;
+
+    p_Manip->fragParams.p_AutoLearnHashTbl = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE),
+                                          FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
+
+    IOMemSet32(p_Manip->fragParams.p_AutoLearnHashTbl, 0,  (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
+
+
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_AutoLearnHashTbl) - p_FmPcd->physicalMuramBase);
+
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->autoLearnHashTblPtr, tmpReg32);
+
+    tmpReg32 = 0;
+    if(p_ManipParams->timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES;
+    if(p_ManipParams->haltOnDuplicationFrag)
+        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
+    if(p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH)
+    {
+        i = 8;
+        tmpReg32  |= FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS;
+    }
+    else
+        i = 4;
+
+    numOfSets = (uint8_t)((p_ManipParams->maxNumFramesInProcess * 2) / i);
+    LOG2(numOfSets, log2Num);
+    tmpReg32 |= (uint32_t)(log2Num - 1) << 24;
+
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
+
+    for(j = 0; j < p_ManipParams->maxNumFramesInProcess * 2; j++)
+    {
+        if(((j / i)  % 2)== 0)
+        {
+            WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->fragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
+        }
+    }
+
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->bufferPoolIdAndRisc1SetIndexes, 0x00008000);
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc23SetIndexes, 0x80008000);
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->risc4SetIndexesAndExtendedStatsTblPtr, 0x80000000);
+
+    p_Manip->fragParams.maxNumFramesInProcess = p_ManipParams->maxNumFramesInProcess;
+
+    p_Manip->fragParams.poolIndx =  poolIndex;
+
+    p_Manip->fragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
+    p_Manip->fragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
+    /*TODO  - to take care about this function FmGetTimeStampScale - it return t_Error
+     now we have problems with all calls to this fucntion*/
+    p_Manip->fragParams.bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+
+    tmpReg32 = 0;
+    tmpReg32 |= (((uint32_t)1<<p_Manip->fragParams.bitFor1Micro) * p_ManipParams->timeoutThresholdForReassmProcess);
+    WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->expirationDelay, tmpReg32);
+
+    return E_OK;
+
+}
+
+static t_Error CapwapFragmentation(t_CapwapFragmentationParams *p_ManipParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd, uint8_t poolIndex)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    p_Manip->updateParams |= OFFSET_OF_DATA | BUFFER_POOL_ID_FOR_MANIP;
+
+    p_Manip->frag = TRUE;
+
+    p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                          FM_PCD_CC_AD_ENTRY_SIZE,
+                                          FM_PCD_CC_AD_TABLE_ALIGN);
+    if(!p_Manip->h_Frag)
+         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
+
+    if(p_ManipParams->headerOptionsCompr)
+        tmpReg32 = FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+
+    p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
+    p_Manip->fragParams.poolIndx = poolIndex;
+
+    return E_OK;
+}
+#endif /* FM_CAPWAP_SUPPORT */
+
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+static t_Error IpFragmentation(t_IpFragmentationParams *p_ManipParams,t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+    t_Error                 err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+
+    /* Host Command module must be initialized when using IP Fragmentation manipulation */
+    if (!p_FmPcd->h_Hc)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("hc port has to be initialized in this mode"));
+
+    /* Allocation of fragmentation Action Descriptor */
+    p_Manip->ipFragParams.p_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                               FM_PCD_CC_AD_ENTRY_SIZE,
+                                                               FM_PCD_CC_AD_TABLE_ALIGN);
+
+    if(!p_Manip->ipFragParams.p_Frag)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+    IOMemSet32( p_Manip->ipFragParams.p_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipFragParams.p_Frag;
+
+    /* Sets the third Ad register (pcAndOffsets)- OperationCode */
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_IP_FRAGMENTATION;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    /* Sets the first Ad register (ccAdBase) - Don't frag action and Action descriptor type*/
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32 |= (p_ManipParams->dontFragAction << FM_PCD_MANIP_IP_FRAG_DF_OFFSET);
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    /* Saves user's fragmentation manipulation parameters */
+    p_Manip->ipFragParams.scratchBpid = p_ManipParams->scratchBpid;
+    p_Manip->sizeForFragmentation = p_ManipParams->sizeForFragmentation;
+    p_Manip->frag = TRUE;
+
+    /* Sets the first Ad register (gmask) - scratch buffer pool id and Pointer to fragment ID */
+    tmpReg32 = (uint32_t)(XX_VirtToPhys(p_FmPcd->h_FragIdPtr) - p_FmPcd->physicalMuramBase);
+    tmpReg32 |= p_ManipParams->scratchBpid << FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID;
+    WRITE_UINT32(p_Ad->gmask, tmpReg32);
+
+    /* scratch buffer pool initialization */
+    if ((err = FmPcdFragHcScratchPoolFill((t_Handle)p_FmPcd, p_ManipParams->scratchBpid)) != E_OK)
+    {
+        FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->ipFragParams.p_Frag);
+        p_Manip->ipFragParams.p_Frag = NULL;
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+    return E_OK;
+}
+
+static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, t_Handle h_Ad, bool ipv4)
+{
+    t_AdOfTypeContLookup *p_Ad;
+    t_FmPcd              *p_FmPcd   = (t_FmPcd *)p_Manip->h_FmPcd;
+    uint32_t             tmpReg32;
+    t_Error              err = E_OK;
+    t_Handle             h_IpReassParamsTblPtr;
+
+    /* Gets the required Action descriptor table pointer */
+    if (ipv4)
+        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv4Ad;
+    else
+        p_Ad = (t_AdOfTypeContLookup *)p_Manip->ipReassmParams.h_Ipv6Ad;
+
+    /* Sets the first Ad register (ccAdBase) - Action Descriptor Type and Pointer to the IP Reassembly Parameters Table offset from MURAM*/
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+
+    /* Creates the IP Reassembly Parameters table. It contains parameters that are specific to either the IPv4 reassembly
+     function or to the IPv6 reassembly function. If both IPv4 reassembly and IPv6 reassembly are required, then
+     two separate IP Reassembly Parameter tables are required.*/
+    if (ipv4)
+    {
+        p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr = CreateIpReassParamTable(p_Manip, ipv4);;
+        h_IpReassParamsTblPtr = p_Manip->ipReassmParams.h_Ipv4ReassParamsTblPtr;
+    }
+    else
+    {
+        p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr = CreateIpReassParamTable(p_Manip, ipv4);
+        h_IpReassParamsTblPtr = p_Manip->ipReassmParams.h_Ipv6ReassParamsTblPtr;
+    }
+
+    /* Gets the IP Reassemly parameter table offset from MURAM */
+    if (h_IpReassParamsTblPtr != NULL)
+        tmpReg32 |= (uint32_t)(XX_VirtToPhys(h_IpReassParamsTblPtr) - (p_FmPcd->physicalMuramBase));
+    else
+        return err;
+
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    /* Sets the second Ad register (matchTblPtr) - Buffer pool ID (BPID) and Scatter/Gather table offset*/
+    /* mark the Scatter/Gather table offset to be set later on when the port will be known */
+    p_Manip->updateParams = OFFSET_OF_DATA;
+
+    tmpReg32 = (uint32_t)(p_Manip->ipReassmParams.bpid << 8);
+    WRITE_UINT32(p_Ad->matchTblPtr, tmpReg32);
+
+    /* Sets the third Ad register (pcAndOffsets)- liodn offset and IP Reassembly Operation Code*/
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
+    tmpReg32 |= (uint32_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_LIODN_MASK) << ((uint32_t)FM_PCD_MANIP_IP_REASM_LIODN_SHIFT-32);
+    tmpReg32 |= (uint32_t)(p_Manip->ipReassmParams.liodnOffset & FM_PCD_MANIP_IP_REASM_ELIODN_MASK) << ((uint32_t)FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT-32);
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    p_Manip->reassm = TRUE;
+
+    return E_OK;
+}
+
+static t_Error SetIpv4ReassmManip(t_FmPcdManip *p_Manip)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+
+    /* Allocation if IPv4 Action descriptor */
+    if(p_Manip->muramAllocate)
+    {
+        p_Manip->ipReassmParams.h_Ipv4Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+        if(!p_Manip->ipReassmParams.h_Ipv4Ad)
+        {
+           ReleaseManipHandler(p_Manip, p_FmPcd);
+           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+        }
+
+        IOMemSet32(p_Manip->ipReassmParams.h_Ipv4Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+    else
+    {
+        p_Manip->ipReassmParams.h_Ipv4Ad = (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t), p_Manip->ipReassmParams.dataMemId, 0);
+        if(!p_Manip->ipReassmParams.h_Ipv4Ad)
+        {
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+        }
+
+        memset(p_Manip->ipReassmParams.h_Ipv4Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    }
+
+    /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
+    FillReassmManipParams(p_Manip, p_Manip->ipReassmParams.h_Ipv4Ad, TRUE);
+
+    return E_OK;
+}
+
+static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
+{
+    t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
+
+    /* Allocation if IPv6 Action descriptor */
+    if(p_Manip->muramAllocate)
+    {
+        p_Manip->ipReassmParams.h_Ipv6Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+        if(!p_Manip->ipReassmParams.h_Ipv6Ad)
+        {
+           ReleaseManipHandler(p_Manip, p_FmPcd);
+           RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+        }
+
+        IOMemSet32(p_Manip->ipReassmParams.h_Ipv6Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+    else
+    {
+         p_Manip->ipReassmParams.h_Ipv6Ad = (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t), p_Manip->ipReassmParams.dataMemId, 0);
+         if(!p_Manip->ipReassmParams.h_Ipv6Ad)
+         {
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+         }
+
+        memset(p_Manip->ipReassmParams.h_Ipv6Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    }
+
+    /* Fill reassembly manipulation parameter in the IP Reassembly Action Descriptor */
+    FillReassmManipParams(p_Manip, p_Manip->ipReassmParams.h_Ipv6Ad, FALSE);
+
+    return E_OK;
+}
+
+
+static t_Error IpReassembly(t_FmPcdManipFragOrReasmParams *p_ManipParams,t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    uint32_t                    maxSetNumber = 10000;
+    t_IpReasmCommonTbl          *p_IpReasmCommonPramTbl = NULL;
+    t_IpReassemblyParams        reassmManipParams = p_ManipParams->ipReasmParams;
+    t_Error                     res;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc,E_INVALID_HANDLE);
+
+    /* Check validation of user's parameter.*/
+    if ((reassmManipParams.timeoutThresholdForReassmProcess < 1000) || (reassmManipParams.timeoutThresholdForReassmProcess > 8000000))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("timeoutThresholdForReassmProcess should be 1msec - 8sec"));
+    /* It is recommended that the total number of entries in this table (number of sets * number of ways)
+       will be twice the number of frames that are expected to be reassembled simultaneously.*/
+    if (reassmManipParams.maxNumFramesInProcess > (reassmManipParams.maxNumFramesInProcess * maxSetNumber / 2))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumFramesInProcess has to be less than (maximun set number * number of ways / 2)"));
+
+    if ((p_ManipParams->hdr == HEADER_TYPE_IPv6) &&
+        (reassmManipParams.minFragSize[1] < 256))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("minFragSize[1] must be >= 256"));
+
+    /* Saves user's reassembly manipulation parameters */
+    p_Manip->ipReassmParams.relativeSchemeId[0] = p_ManipParams->ipReasmParams.relativeSchemeId[0];
+    p_Manip->ipReassmParams.relativeSchemeId[1] = p_ManipParams->ipReasmParams.relativeSchemeId[1];
+    p_Manip->ipReassmParams.maxNumFramesInProcess = reassmManipParams.maxNumFramesInProcess;
+    p_Manip->ipReassmParams.timeOutMode = reassmManipParams.timeOutMode;
+    p_Manip->ipReassmParams.fqidForTimeOutFrames = reassmManipParams.fqidForTimeOutFrames;
+    p_Manip->ipReassmParams.numOfFramesPerHashEntry = reassmManipParams.numOfFramesPerHashEntry;
+    p_Manip->ipReassmParams.timeoutThresholdForReassmProcess = reassmManipParams.timeoutThresholdForReassmProcess;
+    p_Manip->ipReassmParams.liodnOffset = reassmManipParams.liodnOffset;
+    p_Manip->ipReassmParams.minFragSize[0] = reassmManipParams.minFragSize[0];
+    p_Manip->ipReassmParams.minFragSize[1] = reassmManipParams.minFragSize[1];
+    p_Manip->ipReassmParams.dataMemId = reassmManipParams.dataMemId;
+    p_Manip->ipReassmParams.bpid = p_ManipParams->extBufPoolIndx;
+
+    /* Creates and initializes the IP Reassembly common parameter table */
+    CreateIpReassCommonParamTable(p_Manip, p_FmPcd, p_IpReasmCommonPramTbl);
+
+    /* Creation of IPv4 reassembly manipulation */
+    if ((p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6) || (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4))
+    {
+        res = SetIpv4ReassmManip(p_Manip);
+        if (res != E_OK)
+            return res;
+    }
+
+    /* Creation of IPv6 reassembly manipulation */
+    if (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6)
+    {
+        res = SetIpv6ReassmManip(p_Manip);
+        if (res != E_OK)
+            return res;
+    }
+
+    return E_OK;
+}
+
+bool FmPcdManipIsIpv4Present(t_FmPcd *p_FmPcd, uint8_t netEnvId)
+{
+    uint8_t         res;
+
+    ASSERT_COND(p_FmPcd);
+
+    res = FmPcdNetEnvGetUnitId(p_FmPcd, netEnvId, HEADER_TYPE_IPv4, FALSE, IPV4_FRAG_1);
+    if (res == HEADER_TYPE_USER_DEFINED_SHIM2)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+bool FmPcdManipIsIpv6Present(t_FmPcd *p_FmPcd, uint8_t netEnvId)
+{
+    uint8_t         res;
+
+    ASSERT_COND(p_FmPcd);
+
+    res = FmPcdNetEnvGetUnitId(p_FmPcd, netEnvId, HEADER_TYPE_IPv6, FALSE, IPV6_FRAG_1);
+    if (res == HEADER_TYPE_USER_DEFINED_SHIM2)
+        return TRUE;
+    else
+        return FALSE;
+}
+
+#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
+
+static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip,t_FmPcd *p_FmPcd)
+{
+    t_AdOfTypeContLookup    *p_Ad;
+    uint32_t                tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+
+    UNUSED(p_FmPcd);
+
+    p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    tmpReg32 = 0;
+    tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_INDEXED_STATS;
+    if(p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
+        tmpReg32 |= (uint32_t)0x16 << 16;
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+
+    tmpReg32 = 0;
+    tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
+
+    return E_OK;
+}
+
+#ifdef FM_CAPWAP_SUPPORT
+static t_Error InsrtHdrByTempl(t_FmPcdManipInsrtParams  *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+    t_FmPcdManipInsrtByTemplateParams   *p_InsrtByTemplate = &p_ManipParams->insrtByTemplateParams;
+    uint8_t                             tmpReg8 = 0xff;
+    t_AdOfTypeContLookup                *p_Ad;
+    bool                                ipModify = FALSE;
+    uint32_t                            tmpReg32 = 0, tmpRegNia = 0;
+    uint16_t                            tmpReg16 = 0;
+    t_Error                             err = E_OK;
+    uint8_t                             extraAddedBytes = 0, blockSize = 0, extraAddedBytesAlignedToBlockSize = 0;
+    uint8_t                             *p_Template = NULL;
+
+    SANITY_CHECK_RETURN_ERROR(p_ManipParams,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_NULL_POINTER);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+    if(p_Manip->insrt)
+    {
+        if((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
+             (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
+             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
+
+         if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
+             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
+
+         if(p_InsrtByTemplate->size > 128)
+             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
+
+         if(p_InsrtByTemplate->size)
+         {
+             p_Manip->p_Template = (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                                p_InsrtByTemplate->size,
+                                                FM_PCD_CC_AD_TABLE_ALIGN);
+             if(!p_Manip->p_Template)
+                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+
+             tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
+             tmpReg32 |= (uint32_t)p_InsrtByTemplate->size << 24;
+             *(uint32_t *)&p_Ad->matchTblPtr = tmpReg32;
+         }
+
+         tmpReg32 = 0;
+
+        p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
+
+        if(!p_Template)
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+
+        memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
+
+
+         if(p_InsrtByTemplate->modifyOuterIp)
+         {
+             ipModify = TRUE;
+
+             tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
+
+             if((tmpReg8 & 0xf0) == 0x40)
+                 tmpReg8 = 4;
+             else if((tmpReg8 & 0xf0) == 0x60)
+                 tmpReg8 = 6;
+             else
+                 tmpReg8 = 0xff;
+
+             if(tmpReg8 == 4)
+             {
+                 if((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
+
+                 if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
+
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
+
+                 if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
+                 {
+
+                     if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
+                            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
+                     extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
+                     blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
+                     extraAddedBytesAlignedToBlockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize;
+                     /*IP header template - IP totalLength -
+                     (1 byte) extraByteForIp = headerTemplateSize - ipOffset + insertedBytesAfterThisStage ,
+                     in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
+                     second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
+                 }
+                 if(blockSize)
+                 {
+                     if (!POWER_OF_2(blockSize))
+                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
+                     blockSize -= 1;
+                 }
+
+                 if((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
+                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP] = (uint8_t)(p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes);
+
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_ID_FIELD_OFFSET_FROM_IP] = 0x00;
+                p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_ID_FIELD_OFFSET_FROM_IP + 1] = extraAddedBytesAlignedToBlockSize;
+
+
+                 /*IP header template - relevant only for ipv4 CheckSum = 0*/
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP] = 0x00;
+                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + 1] = 0x00;
+
+
+                 /*UDP checksum has to be 0*/
+                 if(p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                 {
+                     if((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
+
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
+                    p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + 1] = 0x00;
+
+                 }
+
+                 if(p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
+                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
+
+                 tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
+             }
+             else
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("IP version supported only IPV4"));
+         }
+
+         tmpReg32 = tmpReg16 = tmpReg8 = 0;
+         /*TODO - check it*/
+         if(p_InsrtByTemplate->modifyOuterVlan)
+         {
+             if(p_InsrtByTemplate->modifyOuterVlanParams.vpri & ~0x07)
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but VPRI more than 3 bits"));
+
+             memcpy(&tmpReg16, &p_Template[VLAN_TAG_FIELD_OFFSET_FROM_ETH], 2*(sizeof(uint8_t)));
+             if((tmpReg16  != 0x9100) && (tmpReg16!= 0x9200) && (tmpReg16 != 0x8100))
+                 RETURN_ERROR(MAJOR, E_INVALID_STATE,("Inconsistent parameters : user asked for VLAN modifications but Tag Protocol identifier is not VLAN "));
+
+             memcpy(&tmpReg8, &p_Template[14],1*(sizeof(uint8_t)));
+             tmpReg8 &= 0x1f;
+             tmpReg8 |= (uint8_t)(p_InsrtByTemplate->modifyOuterVlanParams.vpri << 5);
+
+             p_Template[14] = tmpReg8;
+         }
+
+        Mem2IOCpy32(p_Manip->p_Template, p_Template, p_InsrtByTemplate->size);
+
+        XX_Free(p_Template);
+    }
+
+    tmpReg32 = 0;
+    if(p_Manip->h_Frag)
+    {
+        tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
+        tmpReg32 |= (uint32_t)p_Manip->sizeForFragmentation << 16;
+    }
+    else
+          tmpReg32 = 0xffff0000;
+
+    if(ipModify)
+        tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
+    else
+        tmpReg32 |= (uint32_t)0x0000ff00;
+
+    tmpReg32 |= (uint32_t)HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+    *(uint32_t *)&p_Ad->pcAndOffsets = tmpReg32;
+
+    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    *(uint32_t *)&p_Ad->ccAdBase = tmpRegNia;
+
+    return err;
+}
+#endif /* FM_CAPWAP_SUPPORT */
+
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+static t_Error IPManip(t_FmPcdManipParams *p_ManipParams, t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
+{
+
+    t_Error                     err = E_OK;
+    t_AdOfTypeContLookup        *p_Ad;
+    uint32_t                    tmpReg32 = 0, tmpRegNia = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_INVALID_HANDLE);
+
+    p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
+
+    if(p_Manip->frag == TRUE)
+    {
+        tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->ipFragParams.p_Frag) - (p_FmPcd->physicalMuramBase));
+        tmpReg32  = (uint32_t)p_Manip->sizeForFragmentation << FM_PCD_MANIP_IP_FRAG_MTU_OFFSET;
+    }
+    else
+          tmpReg32 = FM_PCD_MANIP_IP_FRAG_NO_FRAGMETATION;
+
+    tmpRegNia |= FM_PCD_AD_CONT_LOOKUP_TYPE;
+    tmpReg32  |= HMAN_OC_IP_MANIP;
+
+    WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
+    WRITE_UINT32(p_Ad->ccAdBase, tmpRegNia);
+    WRITE_UINT32(p_Ad->gmask, 0); /* Total frame counter - MUST be initialized to zero.*/
+
+/*
+    TODO - Fill the following:
+         - Over write OuterTos
+         - SaveInnerTos
+         - support in CNIA
+*/
+
+    return err;
+}
+#endif /* (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || ... */
+
+static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsParams *p_StatsParams)
+{
+
+    switch(p_StatsParams->type)
+    {
+        case(e_FM_PCD_STATS_PER_FLOWID):
+            p_Manip->type = HMAN_OC_CAPWAP_INDEXED_STATS;
+            p_Manip->muramAllocate = TRUE;
+        break;
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported statistics type"));
+    }
+
+    return E_OK;
+}
+
+static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool stats)
+{
+    t_FmPcdManip                *p_Manip;
+    t_Error                     err;
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+
+    p_Manip = (t_FmPcdManip*)XX_Malloc(sizeof(t_FmPcdManip));
+    if(!p_Manip)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_Manip, 0, sizeof(t_FmPcdManip));
+
+    if(!stats)
+    {
+        err = CheckManipParamsAndSetType(p_Manip, (t_FmPcdManipParams *)p_Params);
+    }
+    else
+    {
+        err = CheckStatsParamsAndSetType(p_Manip, (t_FmPcdStatsParams *)p_Params);
+    }
+
+    if(err)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("INVALID HEADER MANIPULATION TYPE"));
+        ReleaseManipHandler(p_Manip, p_FmPcd);
+        XX_Free(p_Manip);
+        return NULL;
+    }
+
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    if(p_Manip->type != HMAN_OC_IP_REASSEMBLY)
+    {
+        /* In Case of IP reassembly manipulation the IPv4/IPv6 reassembly action descriptor will
+           be defines later on */
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+    if(p_Manip->muramAllocate)
+    {
+        p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+         if(!p_Manip->h_Ad)
+         {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            XX_Free(p_Manip);
+            return NULL;
+         }
+
+        IOMemSet32(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
+    }
+    else
+    {
+        p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+         if(!p_Manip->h_Ad)
+         {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+            ReleaseManipHandler(p_Manip, p_FmPcd);
+            XX_Free(p_Manip);
+            return NULL;
+         }
+
+        memset(p_Manip->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
+    }
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    }
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+    p_Manip->h_FmPcd = h_FmPcd;
+
+    return p_Manip;
+}
+
+
+t_Error FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree, bool modify)
+{
+    t_Error err;
+
+    if(!modify)
+    {
+        err = FmPcdManipInitUpdate(h_FmPcd, h_PcdParams, h_FmPort, h_Manip, h_Ad, validate, level, h_FmTree);
+    }
+    else
+    {
+        err = FmPcdManipModifyUpdate(h_Manip, h_Ad, validate, level, h_FmTree);
+    }
+    return err;
+}
+
+uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(h_Manip);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            return UPDATE_NIA_ENQ_WITHOUT_DMA;
+        default:
+            return 0;
+    }
+}
+
+void FmPcdManipUpdateOwner(t_Handle h_Manip, bool add)
+{
+
+    if(add)
+        ((t_FmPcdManip *)h_Manip)->owner++;
+    else
+    {
+        ASSERT_COND(((t_FmPcdManip *)h_Manip)->owner);
+        ((t_FmPcdManip *)h_Manip)->owner--;
+    }
+}
+
+t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, uint32_t *requiredAction)
+{
+    t_FmPcdManip             *p_Manip;
+    t_Error                   err;
+
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip, E_NULL_POINTER);
+
+    p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
+    *requiredAction = 0;
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+            if(p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+               p_Manip->cnia = TRUE;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+            p_Manip->ownerTmp++;
+        break;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) && !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
+            p_Manip->ownerTmp++;
+        break;
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            if((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
+               (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
+            err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip, FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
+            if(err)
+                RETURN_ERROR(MAJOR, err, NO_MSG);
+            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+        break;
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        case(HMAN_OC_IP_MANIP):
+
+            if((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE) &&
+               !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+               p_Manip->cnia = FALSE;
+            else
+               p_Manip->cnia = TRUE;
+            if(!p_Manip->h_Frag)
+            {
+                p_Manip->ownerTmp++;
+                break;
+            }
+        case(HMAN_OC_IP_FRAGMENTATION):
+            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+            p_Manip->ownerTmp++;
+        break;
+        case(HMAN_OC_IP_REASSEMBLY):
+            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+            p_Manip->ownerTmp++;
+        break;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_STATE,("invalid type of header manipulation for this state"));
+    }
+
+    return E_OK;
+}
+
+t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcdCcNode)
+{
+    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNode, E_INVALID_HANDLE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
+        break;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if(p_Manip->h_Frag)
+            {
+                if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"));
+                err = UpdateManipIc(h_Manip, FmPcdCcGetOffset(h_FmPcdCcNode));
+                if(err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+            }
+            break;
+        default:
+            break;
+    }
+    return err;
+}
+
+void FmPcdManipUpdateAdResultForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew)
+{
+    t_FmPcdManip             *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+
+    FmPcdManipUpdateOwner(h_Manip, TRUE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            *p_AdNew = p_Manip->h_Ad;
+            break;
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        case(HMAN_OC_IP_FRAGMENTATION):
+            *p_AdNew = p_Manip->h_Ad;
+            break;
+        case(HMAN_OC_IP_REASSEMBLY):
+            if (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv4)
+            {
+                *p_AdNew = p_Manip->ipReassmParams.h_Ipv4Ad;
+            }
+            if (p_Manip->ipReassmParams.hdr == HEADER_TYPE_IPv6)
+            {
+                if (!p_Manip->ipReassmParams.ipv6Assigned)
+                {
+                    *p_AdNew = p_Manip->ipReassmParams.h_Ipv6Ad;
+                    p_Manip->ipReassmParams.ipv6Assigned = TRUE;
+                }
+                else
+                    *p_AdNew = p_Manip->ipReassmParams.h_Ipv4Ad;
+            }
+            break;
+        case(HMAN_OC_IP_MANIP):
+            if (p_Manip->cnia)
+                *p_AdNew = p_Manip->h_Ad;
+            else
+            {
+                WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
+                WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
+                WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
+                *p_AdNew = NULL;
+            }
+            break;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
+            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
+            WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
+            *p_AdNew = NULL;
+            break;
+        default:
+            break;
+    }
+}
+
+void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle *p_AdNew, uint32_t adTableOffset)
+{
+    t_FmPcdManip             *p_Manip = (t_FmPcdManip *)h_Manip;
+
+    ASSERT_COND(p_Manip);
+
+    FmPcdManipUpdateOwner(h_Manip, TRUE);
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,   ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,  ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->gmask,         ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->gmask);
+            WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      (GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase) | adTableOffset));
+            *p_AdNew = NULL;
+            break;
+        default:
+            break;
+    }
+}
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+void setReassmSchemeParams(t_FmPcd* p_FmPcd, t_FmPcdKgSchemeParams *p_Scheme, t_Handle h_CcTree, bool ipv4, uint32_t groupId)
+{
+    uint32_t    j;
+    uint8_t     res;
+
+    /* Configures scheme's network environment parameters */
+    p_Scheme->netEnvParams.numOfDistinctionUnits = 2;
+    if (ipv4)
+        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_FmPcd, p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv4, FALSE, 0);
+    else
+        res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_FmPcd, p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_IPv6, FALSE, 0);
+    ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    p_Scheme->netEnvParams.unitIds[0] = res;
+
+    res = FmPcdNetEnvGetUnitId(p_FmPcd, FmPcdGetNetEnvId(p_FmPcd, p_Scheme->netEnvParams.h_NetEnv), HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0);
+    ASSERT_COND(res != FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS);
+    p_Scheme->netEnvParams.unitIds[1] = res;
+
+    /* Configures scheme's next engine parameters*/
+    p_Scheme->nextEngine = e_FM_PCD_CC;
+    p_Scheme->kgNextEngineParams.cc.h_CcTree = h_CcTree;
+    p_Scheme->kgNextEngineParams.cc.grpId = groupId;
+    p_Scheme->useHash = TRUE;
+
+    /* Configures scheme's key*/
+    if (ipv4 == TRUE)
+    {
+        p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 4;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv4 ;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_DST_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_SRC_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fullField.ipv4 = NET_HEADER_FIELD_IPv4_PROTO;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.hdr = HEADER_TYPE_IPv4;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.ignoreProtocolValidation = FALSE;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.size = 2;
+        p_Scheme->keyExtractAndHashParams.extractArray[3].extractByHdr.extractByHdrType.fromHdr.offset = 4;
+    }
+    else /* IPv6 */
+    {
+        p_Scheme->keyExtractAndHashParams.numOfUsedExtracts = 3;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.hdr = HEADER_TYPE_IPv6 ;
+        p_Scheme->keyExtractAndHashParams.extractArray[0].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_DST_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.type = e_FM_PCD_EXTRACT_FULL_FIELD;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.hdr = HEADER_TYPE_IPv6;
+        p_Scheme->keyExtractAndHashParams.extractArray[1].extractByHdr.extractByHdrType.fullField.ipv6 = NET_HEADER_FIELD_IPv6_SRC_IP;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].type = e_FM_PCD_EXTRACT_BY_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.size  = 4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.extractByHdrType.fromHdr.offset = 4;
+        p_Scheme->keyExtractAndHashParams.extractArray[2].extractByHdr.ignoreProtocolValidation = TRUE;
+    }
+
+    p_Scheme->keyExtractAndHashParams.privateDflt0 = 0x01020304;
+    p_Scheme->keyExtractAndHashParams.privateDflt1 = 0x11121314;
+    p_Scheme->keyExtractAndHashParams.numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
+    for(j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
+    {
+        p_Scheme->keyExtractAndHashParams.dflts[j].type = (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
+        p_Scheme->keyExtractAndHashParams.dflts[j].dfltSelect = e_FM_PCD_KG_DFLT_GBL_0;
+    }
+
+    return;
+}
+
+t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint32_t groupId)
+{
+    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdKgSchemeParams   *p_scheme;
+
+    ASSERT_COND(p_FmPcd);
+    ASSERT_COND(p_PcdGroupsParam);
+    ASSERT_COND(p_Manip);
+
+    p_scheme = XX_Malloc(sizeof(t_FmPcdKgSchemeParams));
+
+    if(!p_scheme)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("XX_Malloc allocation FAILED"));
+
+    /* Configures the IPv4 or IPv6 scheme*/
+    memset(p_scheme, 0, sizeof(*p_scheme));
+    p_scheme->netEnvParams.h_NetEnv = p_PcdGroupsParam->h_NetEnv;
+    p_scheme->id.relativeSchemeId = (isIpv4 == TRUE) ?  p_Manip->ipReassmParams.relativeSchemeId[0] : p_Manip->ipReassmParams.relativeSchemeId[1];
+    p_scheme->schemeCounter.update = TRUE;
+    p_scheme->baseFqid = 0xFFFFFF; /*TODO- baseFqid*/
+    p_scheme->keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+
+    setReassmSchemeParams(p_FmPcd, p_scheme, h_CcTree, isIpv4, groupId);
+
+    /* Sets the new scheme */
+    if (isIpv4)
+        p_Manip->ipReassmParams.h_Ipv4Scheme = FM_PCD_KgSetScheme(p_FmPcd, p_scheme);
+    else
+        p_Manip->ipReassmParams.h_Ipv6Scheme = FM_PCD_KgSetScheme(p_FmPcd, p_scheme);
+
+    XX_Free(p_scheme);
+
+    return E_OK;
+}
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
+t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip                *p_Manip;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
+    SANITY_CHECK_RETURN_VALUE(p_ManipParams,E_INVALID_HANDLE,NULL);
+
+    p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
+    if(!p_Manip)
+        return NULL;
+
+    switch(p_Manip->type)
+    {
+        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+            /* HmanType1 */
+            err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->rmvParams, p_Manip);
+            break;
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        case(HMAN_OC_IP_REASSEMBLY):
+            /* IpReassembly */
+            err = IpReassembly(&p_ManipParams->fragOrReasmParams, p_Manip, p_FmPcd);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+            break;
+       case(HMAN_OC_IP_FRAGMENTATION):
+            /* IpFragmentation */
+            err = IpFragmentation(&p_ManipParams->fragOrReasmParams.ipFragParams ,p_Manip, p_FmPcd);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        case(HMAN_OC_IP_MANIP) :
+            err = IPManip(p_ManipParams, p_Manip, p_FmPcd);
+            break;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+#ifdef FM_CAPWAP_SUPPORT
+        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+            /* CapwapFragmentation */
+            err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.capwapFragParams ,p_Manip, p_FmPcd, p_ManipParams->fragOrReasmParams.extBufPoolIndx);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+            if(p_Manip->insrt)
+                p_Manip->type = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
+        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
+            err = InsrtHdrByTempl(&p_ManipParams->insrtParams, p_Manip, p_FmPcd);
+            break;
+        case(HMAN_OC_CAPWAP_REASSEMBLY) :
+            /*CAPWAP Reassembly*/
+            err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.capwapReasmParams,p_Manip, p_FmPcd, p_ManipParams->fragOrReasmParams.extBufPoolIndx);
+            if(err)
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+            }
+            if(p_Manip->rmv)
+                p_Manip->type = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
+        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            /*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
+            err = CapwapRmvDtlsHdr(p_FmPcd, p_Manip);
+            break;
+#endif /* FM_CAPWAP_SUPPORT */
+       case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+            /*Application Specific type 1*/
+            err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, (bool)(p_ManipParams->treatFdStatusFieldsAsErrors ? TRUE : FALSE));
+            break;
+       default:
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+    }
+    if(err)
+     {
+         REPORT_ERROR(MAJOR, err, NO_MSG);
+         ReleaseManipHandler(p_Manip, p_FmPcd);
+         XX_Free(p_Manip);
+         return NULL;
+     }
+     return p_Manip;
+}
+
+t_Error FM_PCD_ManipDeleteNode(t_Handle h_FmPcd, t_Handle h_ManipNode)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_ManipNode;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
+
+    if(p_Manip->owner)
+        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
+
+    ReleaseManipHandler(p_Manip,p_FmPcd);
+
+    XX_Free(h_ManipNode);
+
+    return E_OK;
+}
+
+
+t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsParams)
+{
+    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip                *p_Manip;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
+    SANITY_CHECK_RETURN_VALUE(p_StatsParams,E_INVALID_HANDLE,NULL);
+
+    p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_StatsParams, TRUE);
+    if(!p_Manip)
+        return NULL;
+
+     switch(p_Manip->type)
+    {
+        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+            /* Indexed statistics */
+            err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
+            break;
+       default:
+                REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED Statistics type"));
+                ReleaseManipHandler(p_Manip, p_FmPcd);
+                XX_Free(p_Manip);
+                return NULL;
+
+    }
+     if(err)
+     {
+         REPORT_ERROR(MAJOR, err, NO_MSG);
+         ReleaseManipHandler(p_Manip, p_FmPcd);
+         XX_Free(p_Manip);
+         return NULL;
+     }
+     return p_Manip;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
new file mode 100644
index 0000000..583bd4f
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -0,0 +1,307 @@
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_manip.h
+
+ @Description   FM PCD manip...
+*//***************************************************************************/
+#ifndef __FM_MANIP_H
+#define __FM_MANIP_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+
+#include "fm_cc.h"
+
+
+/***********************************************************************/
+/*          Header manipulations defines                              */
+/***********************************************************************/
+
+#define HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR                      0x2e
+#define HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER              0x31
+#define HMAN_OC_CAPWAP_FRAGMENTATION                            0x33
+#define HMAN_OC_IP_MANIP                                        0x34
+#define HMAN_OC_IP_FRAGMENTATION                                0x74
+#define HMAN_OC_IP_REASSEMBLY                                   0xB4
+#define HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX     0x2f
+#define HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST                        0x30
+#define HMAN_OC_CAPWAP_REASSEMBLY                               0x11 /* dummy */
+#define HMAN_OC_CAPWAP_INDEXED_STATS                            0x32 /* dummy */
+
+#define HMAN_RMV_HDR                               0x80000000
+#define HMAN_INSRT_INT_FRM_HDR                     0x40000000
+
+#define UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP        6
+#define UDP_UDPCHECKSUM_FIELD_SIZE                  2
+
+#define IP_DSCECN_FIELD_OFFSET_FROM_IP              1
+#define IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP         2
+#define IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP         10
+#define VLAN_TAG_FIELD_OFFSET_FROM_ETH              12
+#define IP_ID_FIELD_OFFSET_FROM_IP                  4
+
+#define FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE               0x80
+#define FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN              8
+#define FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE                 32
+#define FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE 4
+#define FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE      8
+
+
+#define FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES          0x40000000
+#define FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG           0x10000000
+#define FM_PCD_MANIP_CAPWAP_REASM_AUTOMATIC_LEARNIN_HASH_8_WAYS    0x08000000
+#define FM_PCD_MANIP_CAPWAP_REASM_PR_COPY                          0x00800000
+
+#define FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN             0x80000000
+
+#define FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE               4
+#define FM_PCD_MANIP_INDEXED_STATS_CNIA                     0x20000000
+#define FM_PCD_MANIP_INDEXED_STATS_DPD                      0x10000000
+
+#define FM_PCD_MANIP_IPSEC_CALC_UDP_LENGTH                  0x01000000
+#define FM_PCD_MANIP_IPSEC_CNIA                             0x20000000
+
+#define e_FM_MANIP_CAPWAP_INDX                              0
+
+#define FM_PCD_MANIP_IP_REASM_TABLE_SIZE                    0x40
+#define FM_PCD_MANIP_IP_REASM_TABLE_ALIGN                   8
+
+#define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_SIZE       64
+#define FM_PCD_MANIP_IP_REASM_COMMON_PARAM_TABLE_ALIGN      8
+#define FM_PCD_MANIP_IP_REASM_TIME_OUT_BETWEEN_FRAMES              0x80000000
+
+#define FM_PCD_MANIP_IP_FRAG_DF_OFFSET                      28
+#define FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID                   24
+#define FM_PCD_MANIP_IP_FRAG_MTU_OFFSET                     16
+#define FM_PCD_MANIP_IP_FRAG_NO_FRAGMETATION                0xFFFF0000
+
+#define e_FM_MANIP_IP_INDX                                  1
+#define FM_PCD_MANIP_IP_REASM_LIODN_MASK                    0x0000003F
+#define FM_PCD_MANIP_IP_REASM_LIODN_SHIFT                   56
+#define FM_PCD_MANIP_IP_REASM_ELIODN_MASK                   0x000003c0
+#define FM_PCD_MANIP_IP_REASM_ELIODN_SHIFT                  38
+
+/***********************************************************************/
+/*          Memory map                                                 */
+/***********************************************************************/
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+typedef _Packed struct {
+    volatile uint32_t mode;
+    volatile uint32_t autoLearnHashTblPtr;
+    volatile uint32_t intStatsTblPtr;
+    volatile uint32_t reasmFrmDescPoolTblPtr;
+    volatile uint32_t reasmFrmDescIndexPoolTblPtr;
+    volatile uint32_t timeOutTblPtr;
+    volatile uint32_t bufferPoolIdAndRisc1SetIndexes;
+    volatile uint32_t risc23SetIndexes;
+    volatile uint32_t risc4SetIndexesAndExtendedStatsTblPtr;
+    volatile uint32_t extendedStatsTblPtr;
+    volatile uint32_t expirationDelay;
+    volatile uint32_t totalProcessedFragCounter;
+    volatile uint32_t totalUnsuccessfulReasmFramesCounter;
+    volatile uint32_t totalDuplicatedFragCounter;
+    volatile uint32_t totalMalformdFragCounter;
+    volatile uint32_t totalTimeOutCounter;
+    volatile uint32_t totalSetBusyCounter;
+    volatile uint32_t totalRfdPoolBusyCounter;
+    volatile uint32_t totalDiscardedFragsCounter;
+    volatile uint32_t totalMoreThan16FramesCounter;
+    volatile uint32_t internalBufferBusy;
+    volatile uint32_t externalBufferBusy;
+    volatile uint8_t res[16];
+} _PackedType t_CapwapReasmPram;
+
+typedef _Packed struct t_IpReasmPram{
+    volatile uint16_t waysNumAndSetSize;
+    volatile uint16_t autoLearnHashKeyMask;
+    volatile uint32_t ipReassCommonPrmTblPtr;
+    volatile uint32_t liodnAlAndAutoLearnHashTblPtrHi;
+    volatile uint32_t autoLearnHashTblPtrLow;
+    volatile uint32_t liodnSlAndAutoLearnSetLockTblPtrHi;
+    volatile uint32_t autoLearnSetLockTblPtrLow;
+    volatile uint16_t minFragSize;
+    volatile uint16_t reserved1;
+    volatile uint32_t totalSuccessfullyReasmFramesCounter;
+    volatile uint32_t totalValidFragmentCounter;
+    volatile uint32_t totalProcessedFragCounter;
+    volatile uint32_t totalMalformdFragCounter;
+    volatile uint32_t totalSetBusyCounter;
+    volatile uint32_t totalDiscardedFragsCounter;
+    volatile uint32_t totalMoreThan16FramesCounter;
+    volatile uint32_t reserved2[2];
+} _PackedType t_IpReasmPram;
+
+typedef _Packed struct t_IpReasmCommonTbl{
+    volatile uint32_t timeoutModeAndFqid;
+    volatile uint32_t reassFrmDescIndexPoolTblPtr;
+    volatile uint32_t liodnAndReassFrmDescPoolPtrHi;
+    volatile uint32_t reassFrmDescPoolPtrLow;
+    volatile uint32_t timeOutTblPtr;
+    volatile uint32_t expirationDelay;
+    volatile uint32_t reseervd1;
+    volatile uint32_t reseervd2;
+    volatile uint32_t totalTimeOutCounter;
+    volatile uint32_t totalRfdPoolBusyCounter;
+    volatile uint32_t totalInternalBufferBusy;
+    volatile uint32_t totalExternalBufferBusy;
+    volatile uint32_t reserved3[4];
+} _PackedType t_IpReasmCommonTbl;
+
+#define MEM_MAP_END
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/***********************************************************************/
+/*  Driver's internal structures                                       */
+/***********************************************************************/
+
+typedef struct
+{
+    t_Handle p_AutoLearnHashTbl;
+    t_Handle p_ReassmFrmDescrPoolTbl;
+    t_Handle p_ReassmFrmDescrIndxPoolTbl;
+    t_Handle p_TimeOutTbl;
+    uint16_t  maxNumFramesInProcess;
+    uint8_t  numOfTasks;
+    uint8_t  poolId;
+    uint8_t  prOffset;
+    uint16_t dataOffset;
+    uint8_t  poolIndx;
+    uint8_t  hwPortId;
+    uint32_t fqidForTimeOutFrames;
+    uint32_t timeoutRoutineRequestTime;
+    uint32_t bitFor1Micro;
+} t_FragParams;
+
+typedef struct
+{
+    void     *p_Frag;
+    uint8_t  poolId;
+    uint16_t dataOffset;
+    uint8_t  poolIndx;
+    uint8_t  scratchBpid;
+}t_IpFragParams;
+
+typedef struct t_IpReassmParams
+{
+    t_Handle            h_Ipv4Ad;
+    t_Handle            h_Ipv6Ad;
+    bool                ipv6Assigned;
+    e_NetHeaderType     hdr;                /**< Header selection */
+    uint32_t            fqidForTimeOutFrames;
+    uint16_t            dataOffset;
+    t_Handle            h_IpReassCommonParamsTbl;
+    t_Handle            h_Ipv4ReassParamsTblPtr;
+    t_Handle            h_Ipv6ReassParamsTblPtr;
+    t_Handle            h_Ipv4AutoLearnHashTbl;
+    t_Handle            h_Ipv6AutoLearnHashTbl;
+    t_Handle            h_Ipv4AutoLearnSetLockTblPtr;
+    t_Handle            h_Ipv6AutoLearnSetLockTblPtr;
+    t_Handle            h_ReassmFrmDescrIndxPoolTbl;
+    t_Handle            h_ReassmFrmDescrPoolTbl;
+    t_Handle            h_TimeOutTbl;
+    uint32_t            maxNumFramesInProcess;
+    uint32_t            liodnOffset;
+    uint32_t            minFragSize[2];
+    uint8_t             dataMemId;              /**< Memory partition ID for data buffers */
+    uint32_t            bpid;
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;
+    uint32_t                        timeoutThresholdForReassmProcess;
+    uint8_t              relativeSchemeId[2];
+    t_Handle             h_Ipv4Scheme;
+    t_Handle             h_Ipv6Scheme;
+}t_IpReassmParams;
+
+typedef struct t_IpCommonReassmParams
+{
+    uint8_t             numOfTasks;
+    uint32_t            bitFor1Micro;
+    t_Handle            h_ReassmFrmDescrPoolTbl;
+    t_Handle            h_ReassmFrmDescrIndxPoolTbl;
+    t_Handle            h_TimeOutTbl;
+}t_IpCommonReassmParams;
+
+typedef struct{
+    bool                muramAllocate;
+    t_Handle            h_Ad;
+    uint32_t            type;
+    bool                rmv;
+    bool                insrt;
+    uint8_t             *p_Template;
+    t_Handle            h_Frag;
+    bool                frag;
+    bool                reassm;
+    uint16_t            sizeForFragmentation;
+    uint8_t             owner;
+    uint32_t            updateParams;
+    uint32_t            shadowUpdateParams;
+    t_FragParams        fragParams;
+    union {
+        t_IpReassmParams    ipReassmParams;
+        t_IpFragParams      ipFragParams;
+    };
+    uint8_t             icOffset;
+    uint16_t            ownerTmp;
+    bool                cnia;
+    t_Handle            p_StatsTbl;
+    t_Handle            h_FmPcd;
+} t_FmPcdManip;
+
+typedef struct t_FmPcdCcSavedManipParams
+{
+    union
+    {
+        struct
+        {
+            uint16_t    dataOffset;
+            uint8_t     poolId;
+        }capwapParams;
+        struct
+        {
+            uint16_t    dataOffset;
+            uint8_t     poolId;
+        }ipParams;
+    };
+
+} t_FmPcdCcSavedManipParams;
+
+
+#endif /* __FM_MANIP_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index e3af876..2d0bbe8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,7 +49,7 @@
 #include "fm_pcd.h"
 #include "fm_pcd_ipc.h"
 #include "fm_hc.h"
-
+#include "fm_muram_ext.h"
 
 static t_Error CheckFmPcdParameters(t_FmPcd *p_FmPcd)
 {
@@ -416,6 +416,12 @@ t_Error PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt
         return E_OK;
 }
 
+uint8_t FmPcdGetNetEnvId(t_FmPcd *p_FmPcd, t_Handle h_NetEnv)
+{
+    UNUSED(p_FmPcd);
+    return (uint8_t)(PTR_TO_UINT(h_NetEnv)-1);
+}
+
 t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
 {
     int                     i;
@@ -472,7 +478,7 @@ bool  FmPcdNetEnvIsHdrExist(t_Handle h_FmPcd, uint8_t netEnvId, e_NetHeaderType
             if (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr == hdr)
                 return TRUE;
     }
-    for (i=0; ((i < FM_PCD_MAX_NUM_OF_PRIVATE_HDRS) &&
+    for (i=0; ((i < FM_PCD_MAX_NUM_OF_ALIAS_HDRS) &&
               (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr != HEADER_TYPE_NONE)); i++)
     {
         if (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr == hdr)
@@ -482,13 +488,136 @@ bool  FmPcdNetEnvIsHdrExist(t_Handle h_FmPcd, uint8_t netEnvId, e_NetHeaderType
     return FALSE;
 }
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+uint8_t  FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr, bool interchangable, protocolOpt_t opt)
+{
+    int         i, k;
+
+    ASSERT_COND(p_FmPcd);
+
+    if (interchangable)
+    {
+        for(i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
+                 (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
+        {
+            for(k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS) &&
+                     (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
+            {
+                if((p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr == hdr) &&
+                    (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt == opt))
+
+                return i;
+            }
+        }
+    }
+    else
+    {
+        for(i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
+                 (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
+            if ((p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr == hdr) &&
+                (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].opt == opt) &&
+                (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[1].hdr == HEADER_TYPE_NONE))
+                    return i;
+
+        for(i=0; (i < FM_PCD_MAX_NUM_OF_ALIAS_HDRS) &&
+                 (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr != HEADER_TYPE_NONE); i++)
+            if ((p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr == hdr) &&
+                (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].opt == opt))
+                return p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].aliasHdr;
+    }
+
+    return FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS;
+}
+
+bool  FmPcdIsIpFrag(t_Handle h_FmPcd, uint8_t netEnvId)
+{
+    if(FmPcdNetEnvGetUnitId(h_FmPcd, netEnvId, HEADER_TYPE_USER_DEFINED_SHIM2, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+        return FALSE;
+    else
+        return TRUE;
+}
+
+t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcIpReassmTimeoutParams  ccIpReassmTimeoutParams = {0};
+    t_Error                         err = E_OK;
+    uint8_t                         result;
+    uint32_t                        bitFor1Micro, tsbs;
+
+    ASSERT_COND(p_FmPcd);
+    ASSERT_COND(h_IpReasmCommonPramTbl);
+
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    tsbs = 31 - bitFor1Micro + 1;
+
+    ccIpReassmTimeoutParams.iprcpt      = (XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccIpReassmTimeoutParams.tsbs        = tsbs;
+    ccIpReassmTimeoutParams.activate    = TRUE;
+    if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    switch (result)
+    {
+        case (0):
+            return E_OK;
+        case (1):
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate TNUM"));
+        case (2):
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer"));
+        case (3):
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("\"Disable Timeout Task\" with invalid IPRCPT"));
+        case (4):
+            RETURN_ERROR(MAJOR, E_FULL, ("too many timeout tasks"));
+        case (5):
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("invalid sub command"));
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+    }
+    return E_OK;
+}
+
+t_Error FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcIpReassmTimeoutParams  ccIpReassmTimeoutParams = {0};
+    uint8_t                         result;
+    t_Error                         err = E_OK;
+
+    ASSERT_COND(p_FmPcd);
+    ASSERT_COND(h_IpReasmCommonPramTbl);
+
+    ccIpReassmTimeoutParams.iprcpt   = (XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccIpReassmTimeoutParams.activate = FALSE; /*Disable Timeout Task*/
+
+    if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    switch (result)
+    {
+        case (0):
+            return E_OK;
+        case (1):
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, (""));
+        case (2):
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, (""));
+        case (3):
+            RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("Disable Timeout Task with invalid IPRCPT"));
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+    }
+
+    return E_OK;
+}
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
 e_NetHeaderType FmPcdGetAliasHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr)
 {
     int         i;
 
     ASSERT_COND(p_FmPcd);
 
-    for (i=0; (i < FM_PCD_MAX_NUM_OF_PRIVATE_HDRS)
+    for (i=0; (i < FM_PCD_MAX_NUM_OF_ALIAS_HDRS)
         && (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr != HEADER_TYPE_NONE); i++)
     {
         if (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr == hdr)
@@ -654,6 +783,17 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     p_FmPcd->f_FmPcdIndexedException    = p_FmPcdParams->f_ExceptionId;
     p_FmPcd->h_App                      = p_FmPcdParams->h_App;
 
+    /*p_ReassmFrmDescrPoolTbl*/
+    p_FmPcd->h_FragIdPtr = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)4, (uint32_t)4);
+    if(!p_FmPcd->h_FragIdPtr)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation in MURAM FAILED"));
+        FM_PCD_Free(p_FmPcd);
+        return NULL;
+    }
+
+    IOMemSet32(p_FmPcd->h_FragIdPtr, 0,  4);
+
     return p_FmPcd;
 }
 
@@ -757,9 +897,6 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     if(p_FmPcd->enabled)
         FM_PCD_Disable(p_FmPcd);
 
-    if (p_FmPcd->h_Spinlock)
-        XX_FreeSpinlock(p_FmPcd->h_Spinlock);
-
     if(p_FmPcd->p_FmPcdDriverParam)
     {
         XX_Free(p_FmPcd->p_FmPcdDriverParam);
@@ -795,6 +932,9 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
         p_FmPcd->h_Hc = NULL;
     }
 
+    if (p_FmPcd->h_Spinlock)
+        XX_FreeSpinlock(p_FmPcd->h_Spinlock);
+
     XX_IpcUnregisterMsgHandler(p_FmPcd->fmPcdModuleName);
 
     FmUnregisterPcd(p_FmPcd->h_Fm);
@@ -940,7 +1080,7 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
 
     /* clear from previous use */
     memset(&p_FmPcd->netEnvs[netEnvCurrId].units, 0, FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS * sizeof(t_FmPcdIntDistinctionUnit));
-    memset(&p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs, 0, FM_PCD_MAX_NUM_OF_PRIVATE_HDRS * sizeof(t_FmPcdNetEnvAliases));
+    memset(&p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs, 0, FM_PCD_MAX_NUM_OF_ALIAS_HDRS * sizeof(t_FmPcdNetEnvAliases));
     memcpy(&p_FmPcd->netEnvs[netEnvCurrId].units, p_NetEnvParams->units, p_NetEnvParams->numOfDistinctionUnits*sizeof(t_FmPcdIntDistinctionUnit));
     p_FmPcd->netEnvs[netEnvCurrId].clsPlanGrpId = ILLEGAL_CLS_PLAN;
 
@@ -957,6 +1097,7 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             {
                 for (j=0; (j < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr != HEADER_TYPE_NONE); j++)
+                {
                     if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
                         !p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].opt)
                     {
@@ -964,12 +1105,12 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                         RELEASE_LOCK(p_FmPcd->netEnvs[netEnvCurrId].lock);
                         return NULL;
                     }
+                }
             }
         }
     }
 
-    /* IPSEC_AH and IPSEC_SPI can't be 2 units,  */
-    /* check that header with opt is not interchanged with the same header */
+    /* Specific headers checking  */
     for(i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
     {
@@ -978,6 +1119,8 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
         {
             /* Some headers pairs may not be defined on different units as the parser
             doesn't distinguish */
+            /* IPSEC_AH and IPSEC_SPI can't be 2 units,  */
+            /* check that header with opt is not interchanged with the same header */
             if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPSEC_AH)
             {
                 if (ipsecEspExists && (ipsecEspUnit != i))
@@ -1006,6 +1149,7 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     ipsecEspExists = TRUE;
                 }
             }
+            /* ENCAP_ESP  */
             if(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_UDP_ENCAP_ESP)
             {
                 /* TODO - general coding. choose the free shim header */
@@ -1014,6 +1158,68 @@ t_Handle FM_PCD_SetNetEnvCharacteristics(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM1;
                 p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
             }
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+            /* IP FRAG  */
+            if(k==0)
+                if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv4) &&
+                    (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV4_FRAG_1))
+                {
+                    /* If IPv4+Frag, we need to set 2 units - SHIM 2 and IPv4. We first set SHIM2, and than check if
+                     * IPv4 exists. If so we don't need to set an extra unit
+                     * We consider as "having IPv4" any IPv4 without interchangable headers
+                     * but including any options.  */
+                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv4;
+                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV4_FRAG_1;
+                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                    p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                    p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
+
+                    /* check if IPv4 header exists by itself */
+                    if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv4, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+                    {
+                        p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv4;
+                        p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
+                    }
+                }
+                if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr == HEADER_TYPE_IPv6) &&
+                        (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt == IPV6_FRAG_1))
+                {
+                    /* If IPv6+Frag, we need to set 2 units - SHIM 2 and IPv6. We first set SHIM2, and than check if
+                     * IPv4 exists. If so we don't need to set an extra unit
+                     * We consider as "having IPv6" any IPv6 without interchangable headers
+                     * but including any options.  */
+                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].hdr = HEADER_TYPE_IPv6;
+                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits].opt = IPV6_FRAG_1;
+                    p_FmPcd->netEnvs[netEnvCurrId].aliasHdrs[specialUnits++].aliasHdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+
+                    for(j=0; (j < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
+                             (p_FmPcd->netEnvs[netEnvCurrId].units[j].hdrs[0].hdr != HEADER_TYPE_USER_DEFINED_SHIM2); j++);
+                    if (j == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+                    {
+                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr = HEADER_TYPE_USER_DEFINED_SHIM2;
+                        p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].opt = 0;
+                        /* check if IPv6 header exists by itself */
+                        if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+                        {
+                            p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits].hdrs[0].hdr = HEADER_TYPE_IPv6;
+                            p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits++].hdrs[0].opt = 0;
+                        }
+                    }
+                    else
+                    {
+                        if (FmPcdNetEnvGetUnitId(p_FmPcd, netEnvCurrId, HEADER_TYPE_IPv6, FALSE, 0) == FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS)
+                        {
+                            p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = HEADER_TYPE_IPv6;
+                            p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = 0;
+                        }
+                        else
+                        {
+                            p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].hdr;
+                            p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].opt = p_FmPcd->netEnvs[netEnvCurrId].units[p_NetEnvParams->numOfDistinctionUnits-1].hdrs[0].opt;
+                        }
+                    }
+                }
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
         }
     }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index 55ae47a..63e787b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -67,6 +67,9 @@
 /****************************/
 #define ILLEGAL_CLS_PLAN    0xff
 #define ILLEGAL_NETENV      0xff
+
+#define FM_PCD_MAX_NUM_OF_ALIAS_HDRS    3
+
 /****************************/
 /* Error defines           */
 /****************************/
@@ -101,29 +104,56 @@ switch(exception){                                                  \
         bitMask = FM_PCD_EX_PRS_SINGLE_ECC; break;                  \
     default: bitMask = 0;break;}
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
 /***********************************************************************/
-/*          SW parser L4 shells patch                                  */
+/*          SW parser IP_FRAG patch                                    */
 /***********************************************************************/
-#ifdef FM_PRS_L4_SHELL_ERRATA_FMANb
-#define SW_PRS_L4_PATCH                         \
-{   0x31,0x92,0x02,0x1f,0x00,0x32,0x00,0x78,    \
-    0x00,0x34,0x32,0xf0,0x00,0x50,0x00,0x0c,    \
-    0x28,0x5e,0x83,0x8e,0x29,0x32,0xaf,0x8e,    \
-    0x31,0xb2,0x9f,0xff,0x00,0x06,0xaf,0xbf,    \
-    0x00,0x06,0x29,0x36,0x00,0x01,0x1b,0xff,    \
-    0x32,0xf0,0x00,0x50,0x00,0x08,0x28,0x5e,    \
-    0x08,0x99,0x00,0x00,0x9f,0x8e,0x31,0xb2,    \
-    0x9f,0xff,0x00,0x06,0x29,0x36,0x00,0x01,    \
-    0x1b,0xff,0x32,0xf0,0x00,0x50,0x00,0x04,    \
-    0x28,0x5e,0x8f,0x9e,0x29,0x32,0x31,0xb2,    \
-    0x8f,0xbf,0x00,0x06,0x29,0x36,0x00,0x01,    \
-    0x1b,0xff,0x32,0xf0,0x00,0x50,0x00,0x04,    \
-    0x28,0x5e,0x8f,0x9e,0x29,0x32,0x31,0xb2,    \
-    0x8f,0xbf,0x00,0x06,0x29,0x36,0x00,0x01,    \
-    0x1b,0xff,0x00,0x00,0x00,0x00,0x00,0x00};
-
-#define SW_PRS_L4_PATCH_SIZE                120
-#endif /* FM_PRS_L4_SHELL_ERRATA_FMANb */
+#define SW_PRS_IP_FRAG_PATCH                           \
+{                                                      \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x0A,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x00,0x00,0x99,0x00,0x53,0x13,0x00,0x00,0x00,0x00, \
+    0x9F,0x98,0x53,0x13,0x00,0x00,0x1B,0x1C,0x00,0x03, \
+    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x53,0x2F,0x00,0x00,0x31,0x52,0x00,0xDA, \
+    0x00,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x2F, \
+    0x00,0x00,0x1B,0x31,0x00,0x01,0x1B,0xFE,0x32,0xC1, \
+    0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00,0x9B,0x8F, \
+    0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43, \
+    0x30,0x7E,0x43,0x59,0x00,0x2C,0x32,0x11,0x28,0x41, \
+    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
+    0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
+    0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
+    0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x3C,0x00,0x03, \
+    0x00,0x02,0x00,0x00,0x00,0x01,0x32,0xF1,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x1F,0xFF,0x00,0x01,0x1B,0xFE, \
+    0x31,0x52,0x00,0xDA,0x02,0x08,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x43,0x6E,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00, \
+    0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x43,0x30,0x7E,0x43,0x80,0x00,0x00,0x30,0x7E, \
+    0x43,0x80,0x00,0x3C,0x1B,0x9A,0x32,0x11,0x28,0x41, \
+    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
+    0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
+    0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
+    0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x79,0x30,0x7E, \
+    0x53,0xB0,0x00,0x2B,0x32,0x11,0x28,0x41,0x32,0x11, \
+    0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
+    0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
+    0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0xC4,0x00,0x00, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x41,0x06,0x29, \
+    0x32,0x01,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
+    0x1B,0xFE,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x00,0x01, \
+    0x1B,0xFE                                          \
+};
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
 /****************************/
 /* Parser defines           */
@@ -175,15 +205,6 @@ switch(exception){                                                  \
 #define KG_MAX_PROFILE                          255
 #define SCHEME_ALWAYS_DIRECT                    0xFFFFFFFF
 
-typedef struct {
-    bool        known;
-    uint8_t     id;
-} t_FmPcdKgSchemesExtractsEntry;
-
-typedef struct {
-    t_FmPcdKgSchemesExtractsEntry extractsArray[FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
-} t_FmPcdKgSchemesExtracts;
-
 /***********************************************************************/
 /*          Policer defines                                            */
 /***********************************************************************/
@@ -461,6 +482,15 @@ typedef _Packed struct {
 /***********************************************************************/
 
 typedef struct {
+    bool        known;
+    uint8_t     id;
+} t_FmPcdKgSchemesExtractsEntry;
+
+typedef struct {
+    t_FmPcdKgSchemesExtractsEntry extractsArray[FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+} t_FmPcdKgSchemesExtracts;
+
+typedef struct {
     t_Handle        h_Manip;
     bool            keepRes;
     e_FmPcdEngine   nextEngine;
@@ -472,10 +502,10 @@ typedef struct {
                 between the port and PCD regarding the KG scheme.
 *//***************************************************************************/
 typedef struct {
-    uint8_t                     netEnvId;    /* in */
-    uint8_t                     numOfDistinctionUnits; /* in */
-    uint8_t                     unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /* in */
-    uint32_t                    vector; /* out */
+    uint8_t             netEnvId;    /* in */
+    uint8_t             numOfDistinctionUnits; /* in */
+    uint8_t             unitIds[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS]; /* in */
+    uint32_t            vector; /* out */
 } t_NetEnvParams;
 
 typedef struct {
@@ -510,21 +540,21 @@ typedef struct {
 } t_FmPcdKgScheme;
 
 typedef struct {
-    bool    allocated;
-    uint8_t ownerId;    /* guestId for KG in multi-partition only,
-                           portId for PLCR in any environment */
+    bool            allocated;
+    uint8_t         ownerId; /* guestId for KG in multi-partition only,
+                                portId for PLCR in any environment */
 } t_FmPcdAllocMng;
 
 typedef struct {
-    t_FmPcdKgRegs                   *p_FmPcdKgRegs;
-    uint32_t                        schemeExceptionsBitMask;
-    uint8_t                         numOfSchemes;
-    uint8_t                         schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
-    t_FmPcdKgScheme                 schemes[FM_PCD_KG_NUM_OF_SCHEMES];
-    t_FmPcdKgClsPlanGrp             clsPlanGrps[FM_MAX_NUM_OF_PORTS];
-    uint8_t                         emptyClsPlanGrpId;
-    t_FmPcdAllocMng                 schemesMng[FM_PCD_KG_NUM_OF_SCHEMES]; /* only for MASTER ! */
-    t_FmPcdAllocMng                 clsPlanBlocksMng[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
+    t_FmPcdKgRegs       *p_FmPcdKgRegs;
+    uint32_t            schemeExceptionsBitMask;
+    uint8_t             numOfSchemes;
+    uint8_t             schemesIds[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdKgScheme     schemes[FM_PCD_KG_NUM_OF_SCHEMES];
+    t_FmPcdKgClsPlanGrp clsPlanGrps[FM_MAX_NUM_OF_PORTS];
+    uint8_t             emptyClsPlanGrpId;
+    t_FmPcdAllocMng     schemesMng[FM_PCD_KG_NUM_OF_SCHEMES]; /* only for MASTER ! */
+    t_FmPcdAllocMng     clsPlanBlocksMng[FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP];
 } t_FmPcdKg;
 
 typedef struct {
@@ -575,6 +605,7 @@ typedef struct {
 
 typedef struct {
     e_NetHeaderType             hdr;
+    protocolOpt_t               opt; /* only one option !! */
     e_NetHeaderType             aliasHdr;
 } t_FmPcdNetEnvAliases;
 
@@ -587,12 +618,11 @@ typedef struct {
     uint32_t                    unitsVectors[FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS];
     uint32_t                    lcvs[FM_PCD_PRS_NUM_OF_HDRS];
     uint32_t                    macsecVector;
-    t_FmPcdNetEnvAliases        aliasHdrs[FM_PCD_MAX_NUM_OF_PRIVATE_HDRS];
+    t_FmPcdNetEnvAliases        aliasHdrs[FM_PCD_MAX_NUM_OF_ALIAS_HDRS];
 } t_FmPcdNetEnv;
 
 typedef struct {
     bool                        plcrAutoRefresh;
-
     uint16_t                    prsMaxParseCycleLimit;
 } t_FmPcdDriverParam;
 
@@ -619,6 +649,7 @@ typedef struct {
     t_FmPcdExceptionCallback    *f_Exception;
     t_FmPcdIdExceptionCallback  *f_FmPcdIndexedException;
     t_Handle                    h_App;
+    t_Handle                    h_FragIdPtr;
 
     t_FmPcdDriverParam          *p_FmPcdDriverParam;
 } t_FmPcd;
@@ -628,27 +659,21 @@ typedef struct {
 /*  PCD internal routines                                              */
 /***********************************************************************/
 
-/**************************************************************************//**
-
- @Group         FM_PCD_InterModule_grp FM PCD Inter-Module Unit
-
- @Description   FM PCD Inter Module functions -
-                These are not User API routines but routines that may be called
-                from other modules. This will be the case in a single core environment,
-                where instead of useing the XX messeging mechanism, the routines may be
-                called from other modules. In a multicore environment, the other modules may
-                be run by other cores and therefor these routines may not be called directly.
-
- @{
-*//***************************************************************************/
-
 t_Error     PcdGetVectorForOpt(t_FmPcd *p_FmPcd, uint8_t netEnvId, protocolOpt_t opt, uint32_t *p_Vector);
 t_Error     PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params);
 bool        PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t unitVector);
 t_Error     PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpParams *p_GrpParams);
 void        FmPcdSetClsPlanGrpId(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint8_t clsPlanGrpId);
 e_NetHeaderType FmPcdGetAliasHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
-uint8_t     FmPcdNetEnvGetUnitIdForSingleHdr(t_Handle h_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
+uint8_t     FmPcdNetEnvGetUnitIdForSingleHdr(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
+uint8_t     FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr, bool interchangable, protocolOpt_t opt);
+uint8_t     FmPcdGetNetEnvId(t_FmPcd *p_FmPcd, t_Handle h_NetEnv);
+
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+t_Error     FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsParam, t_Handle h_CcTree, t_Handle h_Manip, bool isIpv4, uint32_t groupId);
+bool        FmPcdManipIsIpv4Present(t_FmPcd *p_FmPcd, uint8_t netEnvId);
+bool        FmPcdManipIsIpv6Present(t_FmPcd *p_FmPcd, uint8_t netEnvId);
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
 t_Handle    KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams);
 t_Error     KgInit(t_FmPcd *p_FmPcd);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
index 800a72b..57f3764 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd_ipc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index b9f5128..478a064 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -65,7 +65,7 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
 {
     uint32_t    nia;
     uint16_t    absoluteProfileId = (uint16_t)(PTR_TO_UINT(p_NextEngineParams->h_Profile)-1);
-    uint8_t     relativeSchemeId, physicatSchemeId;
+    uint8_t     relativeSchemeId, physicalSchemeId;
 
     nia = FM_PCD_PLCR_NIA_VALID;
 
@@ -85,15 +85,15 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
             }
             break;
         case e_FM_PCD_KG:
-            physicatSchemeId = (uint8_t)(PTR_TO_UINT(p_NextEngineParams->h_DirectScheme)-1);
-            relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicatSchemeId);
-            if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+            physicalSchemeId = (uint8_t)(PTR_TO_UINT(p_NextEngineParams->h_DirectScheme)-1);
+            relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
+            if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
             if (!FmPcdKgIsSchemeValidSw(p_FmPcd, relativeSchemeId))
-                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
             if(!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Policer Profile may point only to a scheme that is always direct."));
-            nia |= NIA_ENG_KG | NIA_KG_DIRECT | physicatSchemeId;
+            nia |= NIA_ENG_KG | NIA_KG_DIRECT | physicalSchemeId;
             break;
         case e_FM_PCD_PLCR:
              if(!FmPcdPlcrIsProfileShared(p_FmPcd, absoluteProfileId))
@@ -251,7 +251,6 @@ static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
     WRITE_UINT32(p_FmPcdPlcrRegs->fmpl_par, par);
 
     while(GET_UINT32(p_FmPcdPlcrRegs->fmpl_par) & FM_PCD_PLCR_PAR_GO) ;
-
 }
 
 /*********************************************/
@@ -280,7 +279,6 @@ static void PcdPlcrException(t_Handle h_FmPcd)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
     if(event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
-
 }
 
 /* ..... */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index 2191c12..e70c89f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -222,36 +222,36 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->ppsc, p_FmPcd->p_FmPcdPrs->fmPcdPrsPortIdStatistics);
     /**********************PPCS******************/
 
-#ifdef FM_PRS_L4_SHELL_ERRATA_FMANb
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
     {
         uint32_t            i, j;
         t_FmRevisionInfo    revInfo;
-        uint8_t             swPrsL4Patch[] = SW_PRS_L4_PATCH;
+        uint32_t            *p_SwPrsCode = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode, FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
+        uint8_t             swPrsPatch[] = SW_PRS_IP_FRAG_PATCH;
 
+        ASSERT_COND(sizeof(swPrsPatch)<= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
+        /* load sw parser Ip-Frag patch */
         FM_GetRevision(p_FmPcd->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
+        if ((revInfo.majorRev == 2) || (revInfo.majorRev == 3))
         {
-            /* load sw parser L4 patch */
-            for(i=0;i<sizeof(swPrsL4Patch)/4;i++)
+            for(i=0;i<sizeof(swPrsPatch)/4;i++)
             {
                tmpReg = 0;
                for(j =0;j<4;j++)
                {
                   tmpReg <<= 8;
-                  tmpReg |= swPrsL4Patch[i*4+j];
-
+                  tmpReg |= swPrsPatch[i*4+j];
                }
-                WRITE_UINT32(*(p_FmPcd->p_FmPcdPrs->p_SwPrsCode+ FM_PCD_PRS_SW_OFFSET/4 + i), tmpReg);
+               WRITE_UINT32(*(p_SwPrsCode + i), tmpReg);
             }
-            p_FmPcd->p_FmPcdPrs->p_CurrSwPrs = FM_PCD_PRS_SW_OFFSET/4 + p_FmPcd->p_FmPcdPrs->p_SwPrsCode+sizeof(swPrsL4Patch)/4;
         }
     }
-#endif /* FM_PRS_L4_SHELL_ERRATA_FMANb */
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     return E_OK;
 }
 
-void PrsFree(t_FmPcd *p_FmPcd )
+void PrsFree(t_FmPcd *p_FmPcd)
 {
     ASSERT_COND(p_FmPcd->guestId == NCSW_MASTER_ID);
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_ERR);
@@ -259,7 +259,7 @@ void PrsFree(t_FmPcd *p_FmPcd )
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_PRS, 0, e_FM_INTR_TYPE_NORMAL);
 }
 
-void PrsEnable(t_FmPcd *p_FmPcd )
+void PrsEnable(t_FmPcd *p_FmPcd)
 {
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
 
@@ -267,7 +267,7 @@ void PrsEnable(t_FmPcd *p_FmPcd )
     WRITE_UINT32(p_Regs->rpimac, GET_UINT32(p_Regs->rpimac) | FM_PCD_PRS_RPIMAC_EN);
 }
 
-void PrsDisable(t_FmPcd *p_FmPcd )
+void PrsDisable(t_FmPcd *p_FmPcd)
 {
     t_FmPcdPrsRegs      *p_Regs = p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
 
@@ -325,6 +325,7 @@ t_Error FmPcdPrsIncludePortInStatistics(t_Handle h_FmPcd, uint8_t hardwarePortId
             RETURN_ERROR(MAJOR, err, NO_MSG);
         return E_OK;
     }
+
     return PrsIncludePortInStatistics(p_FmPcd, hardwarePortId, include);
 }
 
@@ -381,7 +382,6 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
         WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, FM_PCD_PRS_PPSC_ALL_PORTS);
     else
         WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->ppsc, 0);
-
 }
 
 t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index a2e21c6..f74a3bd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -195,7 +195,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufMargins.endMargins can't be larger than %d", MAX_EXT_BUFFER_OFFSET));
 
         /* extra FIFO size (allowed only to Rx ports) */
-        if(p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS)
+        if(p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
 
         if(p_Params->bufPoolDepletion.numberOfPoolsModeEnable &&
@@ -214,22 +214,22 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
             }
         }
 #endif /* FM_CSI_CFED_LIMIT */
-
     }
 
     /****************************************/
     /*   Non Rx ports                       */
     /****************************************/
-    else
-        /* extra FIFO size (allowed only to Rx ports) */
-        if(p_FmPort->fifoBufs.extra)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No fifoBufs.extra for non Rx ports"));
+    /* extra FIFO size (allowed only to Rx ports) */
+    else if (p_FmPort->fifoBufs.extra)
+         RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No fifoBufs.extra for non Rx ports"));
 
     /****************************************/
     /*   Rx & Tx                            */
     /****************************************/
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
-        (p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* Check that not larger than 16 */
         if(p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
@@ -239,7 +239,8 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /****************************************/
     /*   Tx only                            */
     /****************************************/
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
         /* Check that divisible by 256 and not larger than 256 */
         if(p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
@@ -258,29 +259,28 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
             if(p_FmPort->txFifoDeqPipelineDepth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoDeqPipelineDepth for !G can't be larger than 2"));
     }
-    else
     /****************************************/
     /*   Non Tx Ports                       */
     /****************************************/
-    {
-        /* If discard override was selected , no frames may be discarded. */
-        if(p_Params->frmDiscardOverride && p_Params->errorsToDiscard)
-            RETURN_ERROR(MAJOR, E_CONFLICT, ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
-    }
+    /* If discard override was selected , no frames may be discarded. */
+    else if (p_Params->frmDiscardOverride && p_Params->errorsToDiscard)
+        RETURN_ERROR(MAJOR, E_CONFLICT,
+                     ("errorsToDiscard is not empty, but frmDiscardOverride selected (all discarded frames to be enqueued to error queue)."));
 
     /****************************************/
     /*   Rx and Offline parsing             */
     /****************************************/
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-        || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             unusedMask = BMI_STATUS_OP_MASK_UNUSED;
         else
             unusedMask = BMI_STATUS_RX_MASK_UNUSED;
 
         /* Check that no common bits with BMI_STATUS_MASK_UNUSED */
-        if(p_Params->errorsToDiscard & unusedMask)
+        if (p_Params->errorsToDiscard & unusedMask)
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("errorsToDiscard contains undefined bits"));
     }
 
@@ -288,10 +288,10 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /*   All ports                          */
     /****************************************/
 
-   /* Check that divisible by 16 and not larger than 240 */
-    if(p_Params->intContext.intContextOffset >MAX_INT_OFFSET)
+    /* Check that divisible by 16 and not larger than 240 */
+    if (p_Params->intContext.intContextOffset >MAX_INT_OFFSET)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset can't be larger than %d", MAX_INT_OFFSET));
-    if(p_Params->intContext.intContextOffset % OFFSET_UNITS)
+    if (p_Params->intContext.intContextOffset % OFFSET_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.intContextOffset has to be divisible by %d", OFFSET_UNITS));
 
     /* check that ic size+ic internal offset, does not exceed ic block size */
@@ -316,14 +316,119 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
     if(p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    if(!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE))
+    if(p_FmPort->explicitUserSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-    if(p_FmPort->fifoBufs.num % BMI_FIFO_UNITS)
+    if(p_FmPort->explicitUserSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
 
     return E_OK;
 }
 
+static uint32_t VerifyAndUpdateSizeOfFifo(t_FmPort *p_FmPort)
+{
+    uint32_t                minFifoSizeRequired = 0;
+
+    /*************************/
+    /*    TX PORTS           */
+    /*************************/
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
+    {
+
+        if (p_FmPort->imEn)
+            minFifoSizeRequired = (uint32_t)((p_FmPort->maxFrameLength % BMI_FIFO_UNITS ?
+                                              (p_FmPort->maxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
+                                              p_FmPort->maxFrameLength) +
+                                                (3*BMI_FIFO_UNITS));
+        else
+            minFifoSizeRequired = (uint32_t)((p_FmPort->maxFrameLength % BMI_FIFO_UNITS ?
+                                   (p_FmPort->maxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
+                                   p_FmPort->maxFrameLength) +
+                                   (p_FmPort->txFifoDeqPipelineDepth+3)*BMI_FIFO_UNITS);
+        /* add some margin for back to back capability to improve performance
+         * allows the hardware to pipeline new frame dma while the previous
+         * frame not yet transmitted). */
+        if (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            minFifoSizeRequired += 3*BMI_FIFO_UNITS;
+        else
+            minFifoSizeRequired += 2*BMI_FIFO_UNITS;
+    }
+
+    /*************************/
+    /*    RX IM PORTS        */
+    /*************************/
+    else if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+              (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
+             p_FmPort->imEn)
+        minFifoSizeRequired = (uint32_t)(((p_FmPort->maxFrameLength % BMI_FIFO_UNITS) ?
+                                         ((p_FmPort->maxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                         p_FmPort->maxFrameLength) +
+                                         (4*BMI_FIFO_UNITS));
+
+    /*************************/
+    /*    RX non-IM PORTS    */
+    /*************************/
+    else if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+              (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)) &&
+             !p_FmPort->imEn)
+    {
+#ifdef FM_FIFO_ALLOCATION_OLD_ALG
+        t_FmRevisionInfo revInfo;
+
+        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+        if(revInfo.majorRev != 4)
+            minFifoSizeRequired = (uint32_t)(((p_FmPort->rxPoolsParams.largestBufSize % BMI_FIFO_UNITS) ?
+                                    ((p_FmPort->rxPoolsParams.largestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                    p_FmPort->rxPoolsParams.largestBufSize) + (7*BMI_FIFO_UNITS));
+        else
+#endif /* FM_FIFO_ALLOCATION_OLD_ALG */
+        {
+            if(p_FmPort->rxPoolsParams.numOfPools == 1)
+                minFifoSizeRequired = 8*BMI_FIFO_UNITS;
+            else
+                minFifoSizeRequired = (uint32_t)(((p_FmPort->rxPoolsParams.secondLargestBufSize % BMI_FIFO_UNITS) ?
+                                    ((p_FmPort->rxPoolsParams.secondLargestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
+                                    p_FmPort->rxPoolsParams.secondLargestBufSize) +
+                                    (7*BMI_FIFO_UNITS));
+        }
+        if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            minFifoSizeRequired += 12*BMI_FIFO_UNITS;
+        else
+            minFifoSizeRequired += 3*BMI_FIFO_UNITS;
+    }
+
+    /* For O/H ports, check fifo size and update if necessary */
+    else if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
+             (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
+        minFifoSizeRequired = (uint32_t)((p_FmPort->txFifoDeqPipelineDepth+4)*BMI_FIFO_UNITS);
+
+    /* for all ports - update if necassary */
+    if (minFifoSizeRequired && (p_FmPort->fifoBufs.num < minFifoSizeRequired))
+    {
+        if(!p_FmPort->explicitUserSizeOfFifo)
+            p_FmPort->fifoBufs.num = minFifoSizeRequired;
+        else
+            DBG(INFO, ("User defined FIFO size should be enlarged to %d",minFifoSizeRequired));
+
+    }
+
+    /* check if pool size is not too big */
+    /* This is a definition problem in which if the fifo for the RX port
+       is lower than the largest pool size the hardware will allocate scatter gather
+       buffers even though the frame size can fit in a single buffer. */
+    if (((p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+         (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        && !p_FmPort->imEn)
+    {
+        if (p_FmPort->rxPoolsParams.largestBufSize > p_FmPort->fifoBufs.num)
+            DBG(WARNING, ("Frame larger than port Fifo size (%u) will be split to more than a single buffer (S/G) even if shorter than largest buffer size (%u)",
+                    p_FmPort->fifoBufs.num, p_FmPort->rxPoolsParams.largestBufSize));
+
+    }
+
+    return p_FmPort->fifoBufs.num;
+}
+
 static void FmPortDriverParamFree(t_FmPort *p_FmPort)
 {
     if(p_FmPort->p_FmPortDriverParam)
@@ -347,7 +452,7 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     uint8_t                     numOfPools;
     uint16_t                    bufSize = 0, largestBufSize = 0;
     int                         i=0, j=0, k=0;
-    uint32_t                    tmpReg, vector, minFifoSizeRequired=0;
+    uint32_t                    tmpReg, vector;
 
     memset(&orderedArray, 0, sizeof(uint8_t) * FM_PORT_MAX_NUM_OF_EXT_POOLS);
     memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
@@ -429,50 +534,10 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     for(i=p_ExtBufPools->numOfPoolsUsed;i<numOfPools;i++)
         WRITE_UINT32(*(p_ExtBufRegs+i), 0);
 
+    /* save pools parameters for later use */
+    p_FmPort->rxPoolsParams.numOfPools = p_ExtBufPools->numOfPoolsUsed;
     p_FmPort->rxPoolsParams.largestBufSize = largestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-1]];
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
-    {
-#ifdef FM_FIFO_ALLOCATION_OLD_ALG
-        t_FmRevisionInfo        revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-
-        if(revInfo.majorRev != 4)
-        {
-            minFifoSizeRequired = (uint32_t)(((largestBufSize % BMI_FIFO_UNITS) ?
-                                    ((largestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
-                                    largestBufSize) +
-                                    (7*BMI_FIFO_UNITS));
-        }
-        else
-#endif /* FM_FIFO_ALLOCATION_OLD_ALG */
-        {
-            p_FmPort->rxPoolsParams.numOfPools = p_ExtBufPools->numOfPoolsUsed;
-            if(p_ExtBufPools->numOfPoolsUsed == 1)
-                minFifoSizeRequired = 8*BMI_FIFO_UNITS;
-            else
-            {
-                uint16_t secondLargestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-2]];
-                p_FmPort->rxPoolsParams.secondLargestBufSize = secondLargestBufSize;
-                minFifoSizeRequired = (uint32_t)(((secondLargestBufSize % BMI_FIFO_UNITS) ?
-                                    ((secondLargestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
-                                    secondLargestBufSize) +
-                                    (7*BMI_FIFO_UNITS));
-            }
-        }
-        if(p_FmPort->fifoBufs.num < minFifoSizeRequired)
-        {
-            p_FmPort->fifoBufs.num = minFifoSizeRequired;
-            DBG(INFO, ("FIFO size for Rx port enlarged to %d",minFifoSizeRequired));
-        }
-    }
-
-    /* check if pool size is not too big */
-    /* This is a definition problem in which if the fifo for the RX port
-       is lower than the largest pool size the hardware will allocate scatter gather
-       buffers even though the frame size can fit in a single buffer. */
-    if (largestBufSize > p_FmPort->fifoBufs.num)
-        DBG(WARNING, ("Frame larger than port Fifo size (%u) will be split to more than a single buffer (S/G) even if shorter than largest buffer size (%u)",
-                p_FmPort->fifoBufs.num, largestBufSize));
+    p_FmPort->rxPoolsParams.secondLargestBufSize = sizesArray[orderedArray[p_ExtBufPools->numOfPoolsUsed-2]];
 
     /* pool depletion */
     tmpReg = 0;
@@ -702,11 +767,6 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     errorsToEnq = (RX_ERRS_TO_ENQ & ~p_Params->errorsToDiscard);
     WRITE_UINT32(p_Regs->fmbm_rfsem, errorsToEnq);
 
-#ifdef FM_BMI_TO_RISC_ENQ_ERRATA_FMANc
-    if((GET_UINT32(p_Regs->fmbm_rfene) && NIA_ENG_MASK)== NIA_ENG_FM_CTL)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("NIA not supported at this stage"));
-#endif /* FM_BMI_TO_RISC_ENQ_ERRATA_FMANc */
-
     return E_OK;
 }
 
@@ -792,9 +852,6 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
     else
     {
         tmpReg |= BMI_CMD_ATTR_ORDER;
-        /* if we set syncReq, we may get stuck when HC command is running */
-        /*if(p_Params->syncReq)
-            tmpReg |= BMI_CMD_ATTR_SYNC;*/
         tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
     }
 
@@ -966,6 +1023,18 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
             WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
             /* define enqueue NIA */
             WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
+
+            if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            {
+                t_FmRevisionInfo fmRevInfo, fmanCtrlCodeRevInfo;
+
+                FM_GetRevision(p_FmPort->h_Fm, &fmRevInfo);
+				FM_GetFmanCtrlCodeRevision(p_FmPort->h_Fm, &fmanCtrlCodeRevInfo);
+				if ((fmanCtrlCodeRevInfo.majorRev == 106) &&
+					(fmRevInfo.majorRev < 4))
+					/* Set pop to next step nia for QMI Enqueue Frame*/
+					WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL);
+            }
         }
 
         /* configure dequeue */
@@ -1084,14 +1153,6 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
             *p_Ptr = &p_BmiRegs->fmbm_rffc;
             break;
         case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-#ifdef FM_PORT_COUNTERS_ERRATA_FMANg
-            {
-                t_FmRevisionInfo revInfo;
-                FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-                if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter is not available in rev1"));
-            }
-#endif /* FM_PORT_COUNTERS_ERRATA_FMANg */
             *p_Ptr = &p_BmiRegs->fmbm_rfldec;
             break;
         case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
@@ -1231,14 +1292,6 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
            *p_Ptr = &p_BmiRegs->fmbm_offc;
             break;
         case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-#ifdef FM_PORT_COUNTERS_ERRATA_FMANg
-        {
-            t_FmRevisionInfo revInfo;
-            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter is not available in rev1"));
-        }
-#endif /* FM_PORT_COUNTERS_ERRATA_FMANg */
           *p_Ptr = &p_BmiRegs->fmbm_ofldec;
             break;
         case(e_FM_PORT_COUNTERS_WRED_DISCARD):
@@ -1375,60 +1428,21 @@ static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
              p_FmPort->p_FmPortDriverParam->bufferPrefixContent.privDataSize);
 
     /* Translate margin and intContext params to FM parameters */
-#ifdef FM_INCORRECT_CS_ERRATA_FMAN18
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-        {
-            uint8_t mod = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign % 256;
-            if(mod)
-            {
-                p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign += (256-mod);
-                DBG(WARNING,("dataAlign modified to next 256 to conform with FMAN18 errata\n"));
-            }
-        }
-    }
-#endif /* FM_INCORRECT_CS_ERRATA_FMAN18 */
-
     /* Initialize with illegal value. Later we'll set legal values. */
     p_FmPort->bufferOffsets.prsResultOffset = (uint32_t)ILLEGAL_BASE;
     p_FmPort->bufferOffsets.timeStampOffset = (uint32_t)ILLEGAL_BASE;
     p_FmPort->bufferOffsets.hashResultOffset= (uint32_t)ILLEGAL_BASE;
     p_FmPort->bufferOffsets.pcdInfoOffset   = (uint32_t)ILLEGAL_BASE;
-#ifdef DEBUG
-    p_FmPort->bufferOffsets.debugOffset     = (uint32_t)ILLEGAL_BASE;
-#endif /* DEBUG */
 
     /* Internally the driver supports 4 options
        1. prsResult/timestamp/hashResult selection (in fact 8 options, but for simplicity we'll
           relate to it as 1).
-       2. All IC context (from AD) except debug.
-       3. Debug information only.
-       4. All IC context (from AD) including debug.
-       Note, that if user asks for prsResult/timestamp/hashResult and Debug, we give them (4) */
-
-    /* This 'if' covers options  2 & 4. We copy from beginning of context with or without debug. */
-    /* If passAllOtherPCDInfo explicitly requested, or passDebugInfo+prs/ts --> we also take passAllOtherPCDInfo */
-    if ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo)
-#ifdef DEBUG
-        || (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo &&
-         (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ||
-          p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ||
-          p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult))
-#endif /* DEBUG */
-       )
-    {
-#ifdef DEBUG
-        if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo)
-        {
-            p_FmPort->p_FmPortDriverParam->intContext.size = 240;
-            p_FmPort->bufferOffsets.debugOffset =
-                (uint32_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 128);
-        }
-        else
-#endif /* DEBUG */
-            p_FmPort->p_FmPortDriverParam->intContext.size = 128; /* must be aligned to 16 */
+       2. All IC context (from AD) not including debug.*/
+
+    /* This 'if' covers option 2. We copy from beginning of context. */
+    if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo)
+    {
+        p_FmPort->p_FmPortDriverParam->intContext.size = 128; /* must be aligned to 16 */
         /* Start copying data after 16 bytes (FD) from the beginning of the internal context */
         p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = 16;
 
@@ -1446,59 +1460,52 @@ static t_Error BuildBufferStructure(t_FmPort *p_FmPort)
     }
     else
     {
-#ifdef DEBUG
-        if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo)
-        {
-            /* This case covers option 3 */
-            p_FmPort->p_FmPortDriverParam->intContext.size = 112;
-            p_FmPort->p_FmPortDriverParam->intContext.intContextOffset = 144;
-            p_FmPort->bufferOffsets.debugOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
-        }
-        else
-#endif /* DEBUG */
-        {
-            /* This case covers the options under 1 */
-            /* Copy size must be in 16-byte granularity. */
-            p_FmPort->p_FmPortDriverParam->intContext.size =
-                (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 : 0) +
-                          ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ||
-                          p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 16 : 0));
-
-            /* Align start of internal context data to 16 byte */
-            p_FmPort->p_FmPortDriverParam->intContext.intContextOffset =
-                (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 :
-                          ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp  ||
-                           p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 64 : 0));
-
-            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult)
-                p_FmPort->bufferOffsets.prsResultOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
-            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp)
-                p_FmPort->bufferOffsets.timeStampOffset =  p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
-                                            (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult)) :
-                                            p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
-            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult)
-                /* If PR is not requested, whether TS is requested or not, IC will be copied from TS */
-                p_FmPort->bufferOffsets.hashResultOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
-                                              (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult) + 8) :
-                                              p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 8;
-        }
+        /* This case covers the options under 1 */
+        /* Copy size must be in 16-byte granularity. */
+        p_FmPort->p_FmPortDriverParam->intContext.size =
+            (uint16_t)((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 : 0) +
+                      ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp ||
+                      p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 16 : 0));
+
+        /* Align start of internal context data to 16 byte */
+        p_FmPort->p_FmPortDriverParam->intContext.intContextOffset =
+            (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ? 32 :
+                      ((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp  ||
+                       p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult) ? 64 : 0));
+
+        if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult)
+            p_FmPort->bufferOffsets.prsResultOffset = p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+        if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp)
+            p_FmPort->bufferOffsets.timeStampOffset =  p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                        (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult)) :
+                                        p_FmPort->p_FmPortDriverParam->intContext.extBufOffset;
+        if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passHashResult)
+            /* If PR is not requested, whether TS is requested or not, IC will be copied from TS */
+            p_FmPort->bufferOffsets.hashResultOffset = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passPrsResult ?
+                                          (p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + sizeof(t_FmPrsResult) + 8) :
+                                          p_FmPort->p_FmPortDriverParam->intContext.extBufOffset + 8;
     }
 
     p_FmPort->p_FmPortDriverParam->bufMargins.startMargins =
         (uint16_t)(p_FmPort->p_FmPortDriverParam->intContext.extBufOffset +
                    p_FmPort->p_FmPortDriverParam->intContext.size);
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_CAPWAP_SUPPORT))
     /* save extra space for manip in both external and internal buffers */
     if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace)
     {
-        if((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + FRAG_EXTRA_SPACE) >= 256)
+        uint8_t extraSpace;
+#ifdef FM_CAPWAP_SUPPORT
+        if((p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + CAPWAP_FRAG_EXTRA_SPACE) >= 256)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + 32 can not be equal or larger to 256"));
+        extraSpace = (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + CAPWAP_FRAG_EXTRA_SPACE);
+#else
+        extraSpace = p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace;
+#endif /* FM_CAPWAP_SUPPORT */
         p_FmPort->bufferOffsets.manipOffset = p_FmPort->p_FmPortDriverParam->bufMargins.startMargins;
-        p_FmPort->p_FmPortDriverParam->bufMargins.startMargins += (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + FRAG_EXTRA_SPACE);
-        p_FmPort->p_FmPortDriverParam->internalBufferOffset =
-            (uint8_t)(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace + FRAG_EXTRA_SPACE);
+        p_FmPort->p_FmPortDriverParam->bufMargins.startMargins += extraSpace;
+        p_FmPort->p_FmPortDriverParam->internalBufferOffset = extraSpace;
     }
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_CAPWAP_SUPPORT)) */
 
     /* align data start */
     tmp = (uint32_t)(p_FmPort->p_FmPortDriverParam->bufMargins.startMargins %
@@ -1575,6 +1582,12 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
+#if (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_IPSEC_SUPPORT))
+        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+            p_FmPort->pcdEngines |= FM_PCD_PRS;
+            p_FmPort->pcdEngines |= FM_PCD_CC;
+            break;
+#endif /* (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || ... */
         case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
@@ -1640,7 +1653,7 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     {
 
         if(p_PcdParams->p_KgParams->numOfSchemes == 0)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at lease one scheme must be bound. "));
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at least one scheme must be bound. "));
         /* for each scheme */
         for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
         {
@@ -1659,12 +1672,26 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FmPcdKgSetOrBindToClsPlanGrp failed. "));
 
          p_FmPort->useClsPlan = !isEmptyClsPlanGrp;
+#ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
+        {
+            t_FmRevisionInfo revInfo;
+
+            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
+                (CHECK_FM_CTL_AC_POST_FETCH_PCD(p_FmPort->savedBmiNia)) &&
+                (revInfo.majorRev <= 3))
+            {
+                for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                    FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PcdParams->p_KgParams->h_Schemes[i], UPDATE_KG_NIA_CC_WA);
+            }
+        }
+#endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
     }
 
     /* set PCD port parameter */
     if(p_FmPort->pcdEngines & FM_PCD_CC)
     {
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset, h_FmPort);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, p_PcdParams, p_PcdParams->p_CcParams->h_CcTree, &ccTreePhysOffset, h_FmPort);
         if(err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
@@ -1748,6 +1775,11 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
                 break;
+#if (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_IPSEC_SUPPORT))
+            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+                WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
+                break;
+#endif /* (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || ... */
             case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
                 break;
             default:
@@ -1852,25 +1884,26 @@ static t_Error SetPcd(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
 
             tmpHxs[hdrNum] |= tmpReg;
         }
-#ifdef FM_PRS_L4_SHELL_ERRATA_FMANb
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        /* check if reassembly port */
+        if(FmPcdIsIpFrag(p_FmPort->h_FmPcd, p_FmPort->netEnvId))
         {
-            t_FmRevisionInfo revInfo;
-            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            {
-               /* link to sw parser code for L4 shells - only if no other code is applied. */
-                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_SCTP)
-                if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                    tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | SCTP_SW_PATCH_START);
-                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_DCCP)
-                if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                    tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | DCCP_SW_PATCH_START);
-                GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPSEC_AH)
-                if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
-                    tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IPSEC_SW_PATCH_START);
-            }
+           /* link to sw parser code for IP Frag - only if no other code is applied. */
+            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+            if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv4);
+            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+            if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_0);
         }
-#endif /* FM_PRS_L4_SHELL_ERRATA_FMANb */
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        {
+            /* link to sw parser code for IP Frag - only if no other code is applied. */
+            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+            if(!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
+                tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | IP_FRAG_SW_PATCH_IPv6_1);
+        }
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
         for(i=0 ; i<FM_PCD_PRS_NUM_OF_HDRS ; i++)
         {
@@ -2088,8 +2121,8 @@ pndn, pnen ... maybe were changed because of the Tree requirement*/
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
     }
 
-    if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1)!= E_OK)
+    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     /* check that current NIA is BMI to BMI */
@@ -2098,12 +2131,30 @@ pndn, pnen ... maybe were changed because of the Tree requirement*/
 
     WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
 
-    if(p_FmPort->requiredAction  & UPDATE_NIA_PNEN)
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
 
-    if(p_FmPort->requiredAction  & UPDATE_NIA_PNDN)
+    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    if(p_FmPort->requiredAction & UPDATE_IPR_EN)
+    {
+        t_Error     err;
+
+        if(!p_FmPort->explicitUserSizeOfFifo)
+            p_FmPort->fifoBufs.num += (p_FmPort->tasks.num + p_FmPort->tasks.extra) * BMI_FIFO_UNITS;
+        else
+            p_FmPort->fifoBufs.num = MAX(p_FmPort->fifoBufs.num,
+                                         (p_FmPort->txFifoDeqPipelineDepth +
+                                          (p_FmPort->tasks.num + p_FmPort->tasks.extra) + 4) * BMI_FIFO_UNITS);
+        err = FmSetSizeOfFifo(p_FmPort->h_Fm, p_FmPort->hardwarePortId, p_FmPort->fifoBufs.num, p_FmPort->fifoBufs.extra, FALSE);
+        if(err)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    if(p_FmPort->requiredAction & UPDATE_NIA_RFENE)
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiRfene);
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     return E_OK;
 }
@@ -2133,7 +2184,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     if(p_CcParams->getCcParams.type & NUM_OF_TASKS)
     {
-        p_CcParams->getCcParams.numOfTasks = p_FmPort->numOfTasks;
+        p_CcParams->getCcParams.numOfTasks = (uint8_t)p_FmPort->tasks.num;
         p_CcParams->getCcParams.type &= ~NUM_OF_TASKS;
     }
     if(p_CcParams->getCcParams.type & BUFFER_POOL_ID_FOR_MANIP)
@@ -2148,6 +2199,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     if((p_CcParams->setCcParams.type & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY) && !(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY))
     {
         p_FmPort->requiredAction |= UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
+        p_FmPort->orFmanCtrl = p_CcParams->setCcParams.orFmanCtrl;
     }
 
     if((p_CcParams->setCcParams.type & UPDATE_NIA_PNEN) && !(p_FmPort->requiredAction & UPDATE_NIA_PNEN))
@@ -2172,6 +2224,22 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("pndn was defined previously different"));
     }
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    if(p_CcParams->setCcParams.type & UPDATE_IPR_EN)
+    {
+        p_FmPort->requiredAction |= UPDATE_IPR_EN;
+    }
+    else if((p_CcParams->setCcParams.type & UPDATE_NIA_RFENE) && !(p_FmPort->requiredAction & UPDATE_NIA_RFENE))
+    {
+        p_FmPort->savedBmiRfene = p_CcParams->setCcParams.nia;
+        p_FmPort->requiredAction |= UPDATE_NIA_RFENE;
+    }
+    else if (p_CcParams->setCcParams.type & UPDATE_NIA_RFENE)
+    {
+       if(p_FmPort->savedBmiRfene != p_CcParams->setCcParams.nia)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("rfene was defined previously different"));
+    }
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     if((p_CcParams->setCcParams.type & UPDATE_PSO) && !(p_FmPort->requiredAction & UPDATE_PSO))
     {
@@ -2251,9 +2319,6 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passTimeStamp= DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passAllOtherPCDInfo
                                                                     = DEFAULT_PORT_bufferPrefixContent_passTimeStamp;
-#ifdef DEBUG
-    p_FmPort->p_FmPortDriverParam->bufferPrefixContent.passDebugInfo= DEFAULT_PORT_bufferPrefixContent_debugInfo;
-#endif /* DEBUG */
     p_FmPort->p_FmPortDriverParam->bufferPrefixContent.dataAlign    = DEFAULT_PORT_bufferPrefixContent_dataAlign;
     p_FmPort->p_FmPortDriverParam->dmaSwapData                      = DEFAULT_PORT_dmaSwapData;
     p_FmPort->p_FmPortDriverParam->dmaIntContextCacheAttr           = DEFAULT_PORT_dmaIntContextCacheAttr;
@@ -2262,52 +2327,20 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize                 = DEFAULT_PORT_dmaWriteOptimize;
     p_FmPort->p_FmPortDriverParam->liodnBase                        = p_FmPortParams->liodnBase;
 
+    p_FmPort->maxFrameLength                                        = DEFAULT_PORT_maxFrameLength;
     /* resource distribution. */
-    p_FmPort->fifoBufs.num                     = DEFAULT_PORT_sizeOfFifo(p_FmPort->portType);
-    p_FmPort->fifoBufs.extra                   = DEFAULT_PORT_extraSizeOfFifo(p_FmPort->portType);
-    p_FmPort->openDmas.num                     = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
-    p_FmPort->openDmas.extra                   = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
-    p_FmPort->tasks.num                        = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
-    p_FmPort->tasks.extra                      = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
-    p_FmPort->numOfTasks = (uint8_t)p_FmPort->tasks.num;
-#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-        {
-            p_FmPort->fifoBufs.extra           = 0;
-            p_FmPort->openDmas.extra           = 0;
-            p_FmPort->tasks.extra              = 0;
-        }
-    }
-#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
+    p_FmPort->fifoBufs.num                                          = 0;
+    p_FmPort->fifoBufs.extra                                        = 0;
+    p_FmPort->openDmas.num                                          = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
+    p_FmPort->openDmas.extra                                        = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+    p_FmPort->tasks.num                                             = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+    p_FmPort->tasks.extra                                           = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
 
     p_FmPort->p_FmPortDriverParam->color                            = DEFAULT_PORT_color;
-#ifdef FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
-            (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-                p_FmPort->p_FmPortDriverParam->color              = e_FM_PORT_COLOR_OVERRIDE;
-    }
-#endif /* FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21 */
-
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
-        p_FmPort->p_FmPortDriverParam->syncReq          = DEFAULT_PORT_syncReqForHc;
+        p_FmPort->p_FmPortDriverParam->syncReq                      = DEFAULT_PORT_syncReqForHc;
     else
-        p_FmPort->p_FmPortDriverParam->syncReq          = DEFAULT_PORT_syncReq;
-
-#ifdef FM_PORT_SYNC_ERRATA_FMAN6
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
-            (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
-                p_FmPort->p_FmPortDriverParam->syncReq              = FALSE;
-    }
-#endif /* FM_PORT_SYNC_ERRATA_FMAN6 */
+        p_FmPort->p_FmPortDriverParam->syncReq                      = DEFAULT_PORT_syncReq;
 
     /* Port type specific initialization: */
     if ((p_FmPort->portType != e_FM_PORT_TYPE_TX) &&
@@ -2334,22 +2367,27 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         p_FmPort->txFifoDeqPipelineDepth                            = DEFAULT_PORT_txFifoDeqPipelineDepth_1G;
         p_FmPort->p_FmPortDriverParam->dontReleaseBuf               = FALSE;
     case(e_FM_PORT_TYPE_TX_10G):
-        if(p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
-            p_FmPort->txFifoDeqPipelineDepth                        = DEFAULT_PORT_txFifoDeqPipelineDepth_10G;
         p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore       = DEFAULT_PORT_cheksumLastBytesIgnore;
         p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
         p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
     case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
     case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority;
+        p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
         p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
 #ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption;
 #endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
-        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt;
+        p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             p_FmPort->p_FmPortDriverParam->errorsToDiscard          = DEFAULT_PORT_errorsToDiscard;
+
+        if(p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+        {
+            p_FmPort->txFifoDeqPipelineDepth                        = DEFAULT_PORT_txFifoDeqPipelineDepth_10G;
+            p_FmPort->p_FmPortDriverParam->deqHighPriority          = DEFAULT_PORT_deqHighPriority_10G;
+            p_FmPort->p_FmPortDriverParam->deqByteCnt               = DEFAULT_PORT_deqByteCnt_10G;
+        }
         break;
 
     default:
@@ -2391,14 +2429,6 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             p_FmPort->p_FmPortDriverParam->liodnOffset                  = p_FmPortParams->specificParams.rxParams.liodnOffset;
             break;
         case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-#ifdef FM_OP_PARTITION_ERRATA_FMANx8
-        {
-            t_FmRevisionInfo revInfo;
-            FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                p_FmPort->p_FmPortDriverParam->liodnOffset              = p_FmPortParams->specificParams.nonRxParams.opLiodnOffset;
-        }
-#endif /* FM_OP_PARTITION_ERRATA_FMANx8 */
         case(e_FM_PORT_TYPE_TX):
         case(e_FM_PORT_TYPE_TX_10G):
         case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
@@ -2459,7 +2489,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     t_FmPortDriverParam             *p_Params;
     t_Error                         err = E_OK;
     t_FmInterModulePortInitParams   fmParams;
-    uint32_t                        minFifoSizeRequired = 0;
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
@@ -2476,17 +2505,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     p_FmPort->p_FmPortBmiRegs     = (u_FmPortBmiRegs *)UINT_TO_PTR(p_Params->baseAddr + BMI_PORT_REGS_OFFSET);
     p_FmPort->p_FmPortPrsRegs     = (t_FmPortPrsRegs *)UINT_TO_PTR(p_Params->baseAddr + PRS_PORT_REGS_OFFSET);
 
-    /* For O/H ports, check fifo size and update if necessary */
-    if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-    {
-        minFifoSizeRequired = (uint32_t)((p_FmPort->txFifoDeqPipelineDepth+4)*BMI_FIFO_UNITS);
-        if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
-        {
-            p_FmPort->fifoBufs.num = minFifoSizeRequired;
-            DBG(WARNING, ("FIFO size enlarged to %d due to txFifoDeqPipelineDepth size", minFifoSizeRequired));
-        }
-    }
-
     /* For Rx Ports, call the external Buffer routine which also checks fifo
        size and updates it if necessary */
     if(((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
@@ -2508,7 +2526,7 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
     fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
-    fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
+    fmParams.sizeOfFifo         = VerifyAndUpdateSizeOfFifo(p_FmPort); /* will not make a change if configured by user */
     fmParams.extraSizeOfFifo    = p_FmPort->fifoBufs.extra;
     fmParams.independentMode    = p_FmPort->imEn;
     fmParams.liodnOffset        = p_Params->liodnOffset;
@@ -2533,13 +2551,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     if(err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    p_FmPort->tasks.num        = fmParams.numOfTasks;
-    p_FmPort->tasks.extra      = fmParams.numOfExtraTasks;
-    p_FmPort->openDmas.num     = fmParams.numOfOpenDmas;
-    p_FmPort->openDmas.extra   = fmParams.numOfExtraOpenDmas;
-    p_FmPort->fifoBufs.num     = fmParams.sizeOfFifo;
-    p_FmPort->fifoBufs.extra   = fmParams.extraSizeOfFifo;
-
     /* get params for use in init */
     p_Params->fmMuramPhysBaseAddr =
         (uint64_t)((uint64_t)(fmParams.fmMuramPhysBaseAddr.low) |
@@ -2613,14 +2624,14 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM_PORT_Disable FAILED"));
     }
 
+    if (p_FmPort->imEn)
+        FmPortImFree(p_FmPort);
+
     if (p_FmPort->h_Spinlock)
         XX_FreeSpinlock(p_FmPort->h_Spinlock);
 
     FmPortDriverParamFree(p_FmPort);
 
-    if (p_FmPort->imEn)
-        FmPortImFree(p_FmPort);
-
     fmParams.hardwarePortId = p_FmPort->hardwarePortId;
     fmParams.portType = (e_FmPortType)p_FmPort->portType;
 #ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
@@ -2639,6 +2650,43 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 /*       API Advanced Init unit functions        */
 /*************************************************/
 
+t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_OpenDmas)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_FmPort->openDmas, p_OpenDmas, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    memcpy(&p_FmPort->tasks, p_NumOfTasks, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
+t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->explicitUserSizeOfFifo = TRUE;
+    memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
+
+    return E_OK;
+}
+
 t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
@@ -2801,6 +2849,7 @@ t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmPortExtPools *p_FmPortE
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
     if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
@@ -2902,14 +2951,6 @@ t_Error FM_PORT_ConfigDfltColor(t_Handle h_FmPort, e_FmPortColor color)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-#ifdef FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDfltColor!"));
-    }
-#endif /* FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21 */
     p_FmPort->p_FmPortDriverParam->color = color;
 
     return E_OK;
@@ -2921,14 +2962,9 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-#ifdef FM_PORT_SYNC_ERRATA_FMAN6
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("port-sync!"));
-    }
-#endif /* FM_PORT_SYNC_ERRATA_FMAN6 */
+
+    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
 
@@ -3043,6 +3079,18 @@ t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReus
     return E_OK;
 }
 
+t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->maxFrameLength = length;
+
+    return E_OK;
+}
+
 
 /****************************************************/
 /*       PCD Advaced config API                     */
@@ -3060,16 +3108,6 @@ t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDma
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
-            (p_NumOfOpenDmas->extra))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("excessive resources"));
-    }
-#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
-
     if((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
     if(p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
@@ -3094,16 +3132,6 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for host command port where number is always 1"));
 
-#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
-            (p_NumOfTasks->extra))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("excessive resources"));
-    }
-#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
-
     if((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
     if(p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
@@ -3122,21 +3150,10 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
 {
     t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                             err;
-    t_FmInterModulePortRxPoolsParams    rxPoolsParams;
-    uint32_t                            minFifoSizeRequired;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-#ifdef FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_FmPort->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0) &&
-            (p_SizeOfFifo->extra))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("excessive resources"));
-    }
-#endif /* FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16 */
     if(!p_SizeOfFifo->num || (p_SizeOfFifo->num > BMI_MAX_FIFO_SIZE))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
     if(p_SizeOfFifo->num % BMI_FIFO_UNITS)
@@ -3151,32 +3168,16 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
         if(p_SizeOfFifo->extra)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No SizeOfFifo-extra for non Rx ports"));
 
-    /* For O/H ports, check fifo size and update if necessary */
-    if((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
-    {
-        minFifoSizeRequired = (uint32_t)((p_FmPort->txFifoDeqPipelineDepth+4)*BMI_FIFO_UNITS);
-        if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
-        {
-            p_FmPort->fifoBufs.num = minFifoSizeRequired;
-            DBG(INFO, ("FIFO size enlarged to %d", minFifoSizeRequired));
-        }
-    }
-    memcpy(&rxPoolsParams, &p_FmPort->rxPoolsParams, sizeof(rxPoolsParams));
-    err = FmSetSizeOfFifo(p_FmPort->h_Fm,
-                            p_FmPort->hardwarePortId,
-                            p_FmPort->portType,
-                            p_FmPort->imEn,
-                            &p_SizeOfFifo->num,
-                            p_SizeOfFifo->extra,
-                            p_FmPort->txFifoDeqPipelineDepth,
-                            &rxPoolsParams,
-                            FALSE);
+    memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
+
+    p_FmPort->explicitUserSizeOfFifo = TRUE;
+    /* we do not change user's parameter */
+    VerifyAndUpdateSizeOfFifo(p_FmPort);
+
+    err = FmSetSizeOfFifo(p_FmPort->h_Fm, p_FmPort->hardwarePortId, p_SizeOfFifo->num, p_SizeOfFifo->extra, FALSE);
     if(err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
-    /* update driver's structure AFTER the FM routine, as it may change by the FM. */
-    memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
-
     return E_OK;
 }
 
@@ -3203,21 +3204,6 @@ uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data)
     return (uint8_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.pcdInfoOffset);
 }
 
-#ifdef DEBUG
-uint8_t * FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data)
-{
-    t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
-
-    SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
-    SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, 0);
-
-    if(p_FmPort->bufferOffsets.debugOffset == ILLEGAL_BASE)
-        return NULL;
-
-    return (uint8_t *)PTR_MOVE(p_Data, p_FmPort->bufferOffsets.debugOffset);
-}
-#endif /* DEBUG */
-
 t_FmPrsResult * FM_PORT_GetBufferPrsResult(t_Handle h_FmPort, char *p_Data)
 {
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
@@ -3315,7 +3301,11 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
                 --tries)
             XX_UDelay(1);
         if (!tries)
+        {
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+                         GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
             RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+        }
     }
 
     /* Disable BMI */
@@ -3330,7 +3320,14 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
         XX_UDelay(1);
 
     if (!tries)
+    {
+        if (!rxPort && !p_FmPort->imEn)
+			WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc,
+						 GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) | QMI_PORT_CFG_EN);
+        WRITE_UINT32(*p_BmiCfgReg, GET_UINT32(*p_BmiCfgReg) | BMI_PORT_CFG_EN);
+
         RETURN_ERROR(MINOR, E_BUSY, ("%s: can't disable!", p_FmPort->name));
+    }
 
     p_FmPort->enabled = 0;
 
@@ -4173,6 +4170,7 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
         if(err)
             RETURN_ERROR(MAJOR, err,NO_MSG);
     }
+    /* set the port handle within the PCD policer, even if no profiles defined */
     FmPcdPortRegister(p_FmPort->h_FmPcd, h_FmPort, p_FmPort->hardwarePortId);
 
     return E_OK;
@@ -4311,7 +4309,6 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
     return E_OK;
 }
 
-
 t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 {
     t_FmPort                            *p_FmPort = (t_FmPort*)h_FmPort;
@@ -4343,8 +4340,8 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
-/*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...
-         it has to be returned to the default state - initially*/
+    /*TODO - to take care of changes due to previous tree. Maybe in the previous tree where chnged pndn, pnen ...
+             it has to be returned to the default state - initially*/
 
     p_FmPort->requiredAction = 0;
 
@@ -4365,7 +4362,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
 
         if (!TRY_LOCK(p_FmPort->h_Spinlock, &p_FmPort->lock))
             return ERROR_CODE(E_BUSY);
-        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, h_CcTree, &ccTreePhysOffset, h_FmPort);
+        err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree, &ccTreePhysOffset, h_FmPort);
         if(err)
         {
             RELEASE_LOCK(p_FmPort->lock);
@@ -4475,9 +4472,16 @@ t_Error FM_PORT_DetachPCD(t_Handle h_FmPort)
         }
     }
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    if(p_FmPort->requiredAction & UPDATE_NIA_RFENE)
+    {
+        /*TODO - check!!*/
+        WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
+    }
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
     if(p_FmPort->requiredAction  & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2)!= E_OK)
+        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
     return E_OK;
 }
@@ -4531,6 +4535,9 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParams)
     FmPcdIncNetEnvOwners(p_FmPort->h_FmPcd, p_FmPort->netEnvId);
 
     err = FmPortAttachPCD(h_FmPort);
+    if(err)
+        DeletePcd(p_FmPort);
+
     RELEASE_LOCK(p_FmPort->lock);
 
     return err;
@@ -5062,3 +5069,61 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
     return  E_OK;
 }
 
+#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+t_Error FM_PORT_SetOpWorkarounds(t_Handle h_FmPort, fmOpPortWorkaroundsSelect_t workarounds)
+{
+    t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+
+    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for OP ports only"));
+
+#ifdef FM_DISABLE_SEC_ERRORS
+    if (workarounds & FM_OP_PORT_WA_SEC_ERR)
+    {
+        t_Error                 err;
+        t_FmPortGetSetCcParams  fmPortGetSetCcParams;
+
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_NO_PCD);
+
+        memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
+        fmPortGetSetCcParams.setCcParams.nia = (NIA_FM_CTL_AC_PRE_FETCH | NIA_ENG_FM_CTL);
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+#endif /* FM_DISABLE_SEC_ERRORS */
+#ifdef FM_DISABLE_UDP_CHECKSUM_AFTER_SEC
+    if (workarounds & FM_OP_PORT_WA_DISABLE_UDP_CKSM)
+    {
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD);
+    }
+#endif /* FM_DISABLE_UDP_CHECKSUM_AFTER_SEC */
+#ifdef FM_ETH_TYPE_FIX
+    if (workarounds & FM_OP_PORT_WA_ETH_TYPE)
+    {
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD);
+    }
+#endif /* FM_ETH_TYPE_FIX */
+#ifdef FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
+    if (workarounds & FM_OP_PORT_WA_COPY_CTXB)
+    {
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD);
+    }
+#endif /* FM_NO_CTXA_COPY_ERRATA_FMAN_SW001 */
+#ifdef FM_UPDATE_UDP_LENGTH_AFTER_SEC
+    if (workarounds & FM_OP_PORT_WA_UPDATE_UDP_LEN)
+    {
+        p_FmPort->savedBmiNia &= BMI_RFNE_FDCS_MASK;
+        p_FmPort->savedBmiNia |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN);
+    }
+#endif /* FM_UPDATE_UDP_LENGTH_AFTER_SEC */
+
+    return E_OK;
+}
+#endif /* FM_IPSEC_SUPPORT  || FM_IP_FRAG_N_REASSEM_SUPPORT*/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 2e8a997..18830f8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -62,27 +62,26 @@
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
-#define DEFAULT_PORT_deqHighPriority                    TRUE
+#define DEFAULT_PORT_deqHighPriority_1G                 FALSE
+#define DEFAULT_PORT_deqHighPriority_10G                TRUE
 #define DEFAULT_PORT_deqType                            e_FM_PORT_DEQ_TYPE1
 #ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
 #define DEFAULT_PORT_deqPrefetchOption                  e_FM_PORT_DEQ_FULL_PREFETCH
 #define DEFAULT_PORT_deqPrefetchOption_HC               e_FM_PORT_DEQ_NO_PREFETCH
 #endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
-#define DEFAULT_PORT_deqByteCnt                         2000
+#define DEFAULT_PORT_deqByteCnt_10G                     0x1400
+#define DEFAULT_PORT_deqByteCnt_1G                      0x400
 #define DEFAULT_PORT_bufferPrefixContent_privDataSize   0
 #define DEFAULT_PORT_bufferPrefixContent_passPrsResult  FALSE
 #define DEFAULT_PORT_bufferPrefixContent_passTimeStamp  FALSE
 #define DEFAULT_PORT_bufferPrefixContent_allOtherPCDInfo    FALSE
-#ifdef DEBUG
-#define DEFAULT_PORT_bufferPrefixContent_debugInfo      FALSE
-#endif /* DEBUG */
 #define DEFAULT_PORT_bufferPrefixContent_dataAlign      DATA_ALIGNMENT
 #define DEFAULT_PORT_cheksumLastBytesIgnore             0
 #define DEFAULT_PORT_cutBytesFromEnd                    4
 #define DEFAULT_PORT_txFifoMinFillLevel                 0
 #define DEFAULT_PORT_txFifoDeqPipelineDepth_IM          2
-#define DEFAULT_PORT_txFifoDeqPipelineDepth_1G          2
-#define DEFAULT_PORT_txFifoDeqPipelineDepth_10G         8
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_1G          1
+#define DEFAULT_PORT_txFifoDeqPipelineDepth_10G         4
 #define DEFAULT_PORT_txFifoLowComfLevel                 (5*KILOBYTE)
 #define DEFAULT_PORT_rxFifoPriElevationLevel            BMI_MAX_FIFO_SIZE
 #define DEFAULT_PORT_rxFifoThreshold                    (BMI_MAX_FIFO_SIZE*3/4)
@@ -99,9 +98,10 @@
 #define DEFAULT_PORT_syncReqForHc                       FALSE
 #define DEFAULT_PORT_color                              e_FM_PORT_COLOR_GREEN
 #define DEFAULT_PORT_errorsToDiscard                    FM_PORT_FRM_ERR_CLS_DISCARD
-#define DEFAULT_dualRateLimitScaleDown                  e_FM_PORT_DUAL_RATE_LIMITER_NONE
-#define DEFAULT_rateLimitBurstSizeHighGranularity       FALSE
-#define DEFAULT_exception                               IM_EV_BSY
+/* #define DEFAULT_PORT_dualRateLimitScaleDown             e_FM_PORT_DUAL_RATE_LIMITER_NONE */
+/* #define DEFAULT_PORT_rateLimitBurstSizeHighGranularity  FALSE */
+#define DEFAULT_PORT_exception                          IM_EV_BSY
+#define DEFAULT_PORT_maxFrameLength                     9600
 
 /* Host command port MUST NOT be changed to more than 1 !!! */
 #define DEFAULT_PORT_numOfTasks(type)                       \
@@ -118,9 +118,9 @@
                  ((type) == e_FM_PORT_TYPE_TX) ||           \
                  ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 2 : 0))
 
-#define DEFAULT_PORT_numOfOpenDmas(type)                \
-    (uint32_t)(((type) == e_FM_PORT_TYPE_TX_10G) ? 8 :  \
-               (((type) == e_FM_PORT_TYPE_RX_10G) ? 4 : 1))
+#define DEFAULT_PORT_numOfOpenDmas(type)                  \
+    (uint32_t)((((type) == e_FM_PORT_TYPE_TX_10G) ||      \
+                ((type) == e_FM_PORT_TYPE_RX_10G)) ? 8 : 1)
 
 #define DEFAULT_PORT_extraNumOfOpenDmas(type)               \
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
@@ -129,23 +129,6 @@
                  ((type) == e_FM_PORT_TYPE_TX) ||           \
                  ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 1 : 0))
 
-#if defined(CONFIG_FMAN_RESOURCE_ALLOCATION_ALGORITHM)
-/* Let LLD to set minimum fifosize, otherwise fifosize settings will not work */
-#define DEFAULT_PORT_sizeOfFifo(type)                                   \
-    (uint32_t)(KILOBYTE) 
-#else
-#define DEFAULT_PORT_sizeOfFifo(type)                                   \
-    (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||                    \
-                ((type) == e_FM_PORT_TYPE_TX_10G)) ? (16*KILOBYTE) :    \
-               ((((type) == e_FM_PORT_TYPE_RX) ||                       \
-                 ((type) == e_FM_PORT_TYPE_TX) ||                       \
-                 ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? (4*KILOBYTE) : (1536)))
-#endif
-
-#define DEFAULT_PORT_extraSizeOfFifo(type)                          \
-    (uint32_t)(((type) == e_FM_PORT_TYPE_RX_10G) ? (8*KILOBYTE) :   \
-               (((type) == e_FM_PORT_TYPE_RX) ? (4*KILOBYTE) : (0)))
-
 #define DEFAULT_PORT_txBdRingLength                 16
 #define DEFAULT_PORT_rxBdRingLength                 128
 #define DEFAULT_PORT_ImfwExtStructsMemId            0
@@ -281,12 +264,9 @@ typedef _Packed struct
     volatile uint32_t   fmbm_orlmt;     /**< O/H Rate Limiter  */
     volatile uint32_t   reserved0a[0x21];
                                         /**< 0x07C - 0x0FF Reserved */
-    union
-    {
-        volatile uint32_t   fmbm_oebmpi[FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS];
-                                        /**< Buffer Manager Observed Pool Information */
-        volatile uint32_t   reserved0b[0x18];
-    };                                  /**< 0x100 - 0x15F Reserved */
+    volatile uint32_t   fmbm_oebmpi[2]; /**< Buffer Manager Observed Pool Information */
+    volatile uint32_t   reserved0b[0x16];
+                                        /**< 0x108 - 0x15F Reserved */
     volatile uint32_t   fmbm_ocgm;      /**< Observed Congestion Group Map */
     volatile uint32_t   reserved0c[0x7];/**< 0x164 - 0x17F Reserved */
     volatile uint32_t   fmbm_ompd;      /**< Observed BMan Pool Depletion */
@@ -462,6 +442,24 @@ typedef _Packed struct
 #define BMI_PRS_RESULT_HIGH                     0x00000000
 #define BMI_PRS_RESULT_LOW                      0xFFFFFFFF
 
+
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+#define RX_ERRS_TO_ENQ                          (FM_PORT_FRM_ERR_DMA                    | \
+                                                 FM_PORT_FRM_ERR_PHYSICAL               | \
+                                                 FM_PORT_FRM_ERR_SIZE                   | \
+                                                 FM_PORT_FRM_ERR_EXTRACTION             | \
+                                                 FM_PORT_FRM_ERR_NO_SCHEME              | \
+                                                 FM_PORT_FRM_ERR_ILL_PLCR               | \
+                                                 FM_PORT_FRM_ERR_PLCR_FRAME_LEN         | \
+                                                 FM_PORT_FRM_ERR_PRS_TIMEOUT            | \
+                                                 FM_PORT_FRM_ERR_PRS_ILL_INSTRUCT       | \
+                                                 FM_PORT_FRM_ERR_BLOCK_LIMIT_EXCEEDED   | \
+                                                 FM_PORT_FRM_ERR_PRS_HDR_ERR            | \
+                                                 FM_PORT_FRM_ERR_PROCESS_TIMEOUT        | \
+                                                 FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW       | \
+                                                 FM_PORT_FRM_ERR_IPRE                   | \
+                                                 FM_PORT_FRM_ERR_IPFE)
+#else
 #define RX_ERRS_TO_ENQ                          (FM_PORT_FRM_ERR_DMA                    | \
                                                  FM_PORT_FRM_ERR_PHYSICAL               | \
                                                  FM_PORT_FRM_ERR_SIZE                   | \
@@ -476,7 +474,8 @@ typedef _Packed struct
                                                  FM_PORT_FRM_ERR_PROCESS_TIMEOUT        | \
                                                  FM_PORT_FRM_ERR_KEYSIZE_OVERFLOW)
 
-#ifdef FM_CAPWAP_SUPPORT
+#endif
+#ifdef FM_DISABLE_SEC_ERRORS
 #define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
                                                  FM_PORT_FRM_ERR_LENGTH                 | \
                                                  FM_PORT_FRM_ERR_NON_FM                 | \
@@ -486,7 +485,7 @@ typedef _Packed struct
 #define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
                                                  FM_PORT_FRM_ERR_LENGTH                 | \
                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
-#endif /* FM_CAPWAP_SUPPORT */
+#endif /* FM_DISABLE_SEC_ERRORS */
 
 /* shifts */
 #define BMI_PORT_CFG_MS_SEL_SHIFT               16
@@ -559,7 +558,7 @@ typedef _Packed struct
 #define MAX_NUM_OF_DMAS                         16
 #define MAX_NUM_OF_EXTRA_DMAS                   8
 #define MAX_BURST_SIZE                          1024
-#define FRAG_EXTRA_SPACE                        32
+#define CAPWAP_FRAG_EXTRA_SPACE                 32
 
 /**************************************************************************//**
  @Description       QMI defines
@@ -638,8 +637,8 @@ typedef _Packed struct
 #define DCCP_SW_PATCH_START                     0x41
 
 #define IP_FRAG_SW_PATCH_IPv4                   0x300
-#define IP_FRAG_SW_PATCH_IPv6_0                 0x320
-#define IP_FRAG_SW_PATCH_IPv6_1                 0x372
+#define IP_FRAG_SW_PATCH_IPv6_0                 0x31E
+#define IP_FRAG_SW_PATCH_IPv6_1                 0x364
 
 /**************************************************************************//**
  @Description       IM defines
@@ -739,9 +738,6 @@ typedef struct {
     uint32_t      hashResultOffset;
     uint32_t      pcdInfoOffset;
     uint32_t      manipOffset;
-#ifdef DEBUG
-    uint32_t      debugOffset;
-#endif /* DEBUG */
 } t_FmPortBufferOffsets;
 
 typedef struct {
@@ -793,6 +789,15 @@ typedef struct {
     bool                                dontReleaseBuf;
 } t_FmPortDriverParam;
 
+
+typedef struct t_FmPortRxPoolsParams
+{
+    uint8_t     numOfPools;
+    uint16_t    secondLargestBufSize;
+    uint16_t    largestBufSize;
+} t_FmPortRxPoolsParams;
+
+
 typedef struct {
     t_Handle                    h_Fm;
     t_Handle                    h_FmPcd;
@@ -830,23 +835,28 @@ typedef struct {
     uint8_t                     fmanCtrlEventId;
     uint32_t                    exceptions;
     bool                        polling;
-    uint8_t                     numOfTasks;
     t_FmPortExtPools            extBufPools;
     uint32_t                    requiredAction;
     uint32_t                    savedQmiPnen;
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    uint32_t                    savedBmiRfene;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
     uint32_t                    savedNonRxQmiRegsPndn;
     int                         savedPrsStartOffset;
+    uint16_t                    maxFrameLength;
+    t_FmFmanCtrl                orFmanCtrl;
     t_FmPortRsrc                openDmas;
     t_FmPortRsrc                tasks;
     t_FmPortRsrc                fifoBufs;
-    t_FmInterModulePortRxPoolsParams rxPoolsParams;
+    t_FmPortRxPoolsParams       rxPoolsParams;
     t_FmPortDriverParam         *p_FmPortDriverParam;
+    bool                        explicitUserSizeOfFifo;
 } t_FmPort;
 
 #define CHECK_FM_CTL_AC_POST_FETCH_PCD(savedBmiNia) \
     ((((savedBmiNia) & NIA_ENG_MASK) == NIA_ENG_FM_CTL) && \
-     ((((savedBmiNia) & NIA_FM_CTL_AC_MASK) == NIA_FM_CTL_AC_POST_FETCH_PCD) || \
-      (((savedBmiNia) & NIA_FM_CTL_AC_MASK) == NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN)))
+     ((((savedBmiNia) & NIA_FM_CTL_AC_POST_FETCH_PCD) == NIA_FM_CTL_AC_POST_FETCH_PCD) || \
+      (((savedBmiNia) & NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN) == NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN)))
 
 void FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams);
 t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort);
@@ -862,6 +872,10 @@ void    FmPortSetMacsecLcv(t_Handle h_FmPort);
 void    FmPortSetMacsecCmd(t_Handle h_FmPort, uint8_t dfltSci);
 
 
+t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas);
+t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
+t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
+
 static __inline__ uint8_t * BdBufferGet (t_PhysToVirt *f_PhysToVirt, t_FmImBd *p_Bd)
 {
     uint64_t    physAddr = (uint64_t)((uint64_t)GET_UINT8(p_Bd->buff.high) << 32);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index e79a61b..607110a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -282,7 +282,7 @@ void FmPortConfigIM (t_FmPort *p_FmPort, t_FmPortParams *p_FmPortParams)
         if (p_FmPort->im.mrblr != p_FmPort->im.rxPool.bufferSize)
             DBG(WARNING, ("Max-Rx-Buffer-Length set to %d", p_FmPort->im.mrblr));
         p_FmPort->im.bdRingSize             = DEFAULT_PORT_rxBdRingLength;
-        p_FmPort->exceptions                = DEFAULT_exception;
+        p_FmPort->exceptions                = DEFAULT_PORT_exception;
         if (FmIsMaster(p_FmPort->h_Fm))
             p_FmPort->polling               = FALSE;
         else
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
index 13ac047..890b124 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -106,16 +106,6 @@ static t_Error CheckInitParameters(t_FmRtc *p_Rtc)
         }
     }
 
-#ifdef FM_1588_SRC_CLK_ERRATA_FMAN1
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(p_Rtc->h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0)&&
-           ((p_RtcDriverParam->srcClk==e_FM_RTC_SOURCE_CLOCK_SYSTEM) && p_RtcDriverParam->invertInputClkPhase))
-            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Can not use invertInputClkPhase when source clock is e_FM_RTC_SOURCE_CLOCK_SYSTEM"));
-    }
-#endif /* FM_1588_SRC_CLK_ERRATA_FMAN1 */
-
     return E_OK;
 }
 
@@ -642,7 +632,7 @@ t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_
     if (p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback)
     {
         p_Rtc->periodicPulseParams[p_FmRtcPeriodicPulseParams->periodicPulseId].f_PeriodicPulseCallback =
-                                                           p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback;
+            p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback;
 
         if(p_FmRtcPeriodicPulseParams->periodicPulseId == 0)
             tmpReg = TMR_TEVENT_PP1;
@@ -820,9 +810,7 @@ t_Error FM_RTC_GetFreqCompensation(t_Handle h_FmRtc, uint32_t *p_Compensation)
     SANITY_CHECK_RETURN_ERROR(p_Rtc, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
-    *p_Compensation = (uint32_t)
-        DIV_CEIL(ACCUMULATOR_OVERFLOW * 1000,
-                 p_Rtc->clockPeriodNanoSec * p_Rtc->srcClkFreqMhz);
+    *p_Compensation = GET_UINT32(p_Rtc->p_MemMap->tmr_add);
 
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
index f112225..a3a2f30 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index fa08ed3..a75f673 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -252,7 +252,12 @@ static void    DmaErrEvent(t_Fm *p_Fm)
         tnum = (uint8_t)((tmpReg & DMA_TRANSFER_TNUM_MASK) >> DMA_TRANSFER_TNUM_SHIFT);
         liodn = (uint16_t)(tmpReg & DMA_TRANSFER_LIODN_MASK);
         ASSERT_COND(p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] != e_FM_PORT_TYPE_DUMMY);
-        p_Fm->f_BusError(p_Fm->h_App, p_Fm->p_FmStateStruct->portsTypes[hardwarePortId], relativePortId, addr, tnum, liodn);
+        p_Fm->f_BusError(p_Fm->h_App,
+                         p_Fm->p_FmStateStruct->portsTypes[hardwarePortId],
+                         relativePortId,
+                         addr,
+                         tnum,
+                         liodn);
     }
     if(mask & DMA_MODE_ECC)
     {
@@ -610,23 +615,13 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
         }
         case (FM_SET_SIZE_OF_FIFO):
         {
-            t_FmIpcPortFifoParams               ipcPortFifoParams;
-            t_FmInterModulePortRxPoolsParams    rxPoolsParams;
-
-            memcpy((uint8_t*)&ipcPortFifoParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortFifoParams));
-            rxPoolsParams.numOfPools = ipcPortFifoParams.numOfPools;
-            rxPoolsParams.secondLargestBufSize = ipcPortFifoParams.secondLargestBufSize;
-            rxPoolsParams.largestBufSize = ipcPortFifoParams.largestBufSize;
-
-            p_IpcReply->error = (uint32_t)FmSetSizeOfFifo(h_Fm, ipcPortFifoParams.rsrcParams.hardwarePortId,
-                                                (e_FmPortType)ipcPortFifoParams.enumPortType,
-                                                (bool)ipcPortFifoParams.boolIndependentMode,
-                                                &ipcPortFifoParams.rsrcParams.val,
-                                                ipcPortFifoParams.rsrcParams.extra,
-                                                ipcPortFifoParams.deqPipelineDepth,
-                                                &rxPoolsParams,
-                                                (bool)ipcPortFifoParams.boolInitialConfig);
-            memcpy(p_IpcReply->replyBody, (uint8_t*)&ipcPortFifoParams.rsrcParams.val, sizeof(uint32_t));
+            t_FmIpcPortRsrcParams   ipcPortRsrcParams;
+
+            memcpy((uint8_t*)&ipcPortRsrcParams, p_IpcMsg->msgBody, sizeof(t_FmIpcPortRsrcParams));
+            p_IpcReply->error = (uint32_t)FmSetSizeOfFifo(h_Fm, ipcPortRsrcParams.hardwarePortId,
+                                                                ipcPortRsrcParams.val,
+                                                                ipcPortRsrcParams.extra,
+                                                               (bool)ipcPortRsrcParams.boolInitialConfig);
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
             break;
         }
@@ -859,7 +854,8 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             memcpy((uint8_t*)&ipcPortNumOfFmanCtrls, p_IpcMsg->msgBody, sizeof(t_FmIpcPortNumOfFmanCtrls));
             if ((err = FmSetNumOfRiscsPerPort(h_Fm,
                                               ipcPortNumOfFmanCtrls.hardwarePortId,
-                                              ipcPortNumOfFmanCtrls.numOfFmanCtrls)) != E_OK)
+                                              ipcPortNumOfFmanCtrls.numOfFmanCtrls,
+                                              ipcPortNumOfFmanCtrls.orFmanCtrl)) != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
             break;
         }
@@ -932,6 +928,15 @@ static void ErrorIsrCB(t_Handle h_Fm)
         else
             p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_10G_MAC0].h_SrcHandle);
     }
+#ifdef FM_MACSEC_SUPPORT
+    if(pending & ERR_INTR_EN_MACSEC_MAC0)
+    {
+       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_MACSEC_MAC0, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].h_SrcHandle);
+    }
+#endif /* FM_MACSEC_SUPPORT */
 }
 
 
@@ -1095,6 +1100,7 @@ t_Error FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId)
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
+
         if (replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
@@ -1343,7 +1349,7 @@ uint8_t FmGetId(t_Handle h_Fm)
     return p_Fm->p_FmStateStruct->fmId;
 }
 
-t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls)
+t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls, t_FmFmanCtrl orFmanCtrl)
 {
 
     t_Fm                        *p_Fm = (t_Fm*)h_Fm;
@@ -1360,6 +1366,7 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
         memset(&msg, 0, sizeof(msg));
         params.hardwarePortId = hardwarePortId;
         params.numOfFmanCtrls = numOfFmanCtrls;
+        params.orFmanCtrl = orFmanCtrl;
         msg.msgId = FM_SET_NUM_OF_FMAN_CTRL;
         memcpy(msg.msgBody, &params, sizeof(params));
         if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
@@ -1384,11 +1391,15 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
         tmpReg = FPM_PORT_FM_CTL2 | FPM_PORT_FM_CTL1;
 
     /* order restoration */
+
+    tmpReg |= (orFmanCtrl << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | orFmanCtrl;
+
+    /*
     if(hardwarePortId%2)
         tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | FPM_PORT_FM_CTL1;
     else
         tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | FPM_PORT_FM_CTL2;
-
+    */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
     XX_UnlockSpinlock(p_Fm->h_Spinlock);
 
@@ -1524,12 +1535,8 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 
     err = FmSetSizeOfFifo(p_Fm,
                             p_PortParams->hardwarePortId,
-                            p_PortParams->portType,
-                            p_PortParams->independentMode,
-                            &p_PortParams->sizeOfFifo,
+                            p_PortParams->sizeOfFifo,
                             p_PortParams->extraSizeOfFifo,
-                            p_PortParams->deqPipelineDepth,
-                            NULL,
                             TRUE);
     if(err)
     {
@@ -1606,7 +1613,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     t_FmIpcPortFreeParams   portParams;
     t_FmIpcMsg              msg;
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
         portParams.hardwarePortId = p_PortParams->hardwarePortId;
         portParams.enumPortType = (uint32_t)p_PortParams->portType;
@@ -1631,7 +1638,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     XX_LockSpinlock(p_Fm->h_Spinlock);
 
 
-    if(p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+    if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
         ASSERT_COND(p_Fm->hcPortInitialized);
         p_Fm->hcPortInitialized = FALSE;
@@ -1646,8 +1653,10 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= numOfTasks;
 
     /* free numOfOpenDmas */
-    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >= ((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
-    p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -= (((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
+    ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas >=
+        ((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
+    p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas -=
+        (((tmpReg & BMI_NUM_OF_DMAS_MASK) >> BMI_NUM_OF_DMAS_SHIFT) + 1);
 
     /* update total num of DMA's with committed number of open DMAS, and max uncommitted pool. */
     tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2) & ~BMI_CFG2_DMAS_MASK;
@@ -1666,20 +1675,9 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], 0);
     /* WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ppid[hardwarePortId-1], 0); */
 
-#ifdef FM_PORT_DISABLED_ERRATA_FMANx9
-    /* this errata means that when a port is taken down, other port may not use its
-     * resources for a while as it may still be using it (in case of reject).
-     */
-        {
-            t_FmRevisionInfo revInfo;
-            FM_GetRevision(p_Fm, &revInfo);
-            if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                XX_UDelay(100000);
-        }
-#endif /* FM_PORT_DISABLED_ERRATA_FMANx9 */
-
 #ifdef FM_QMI_DEQ_OPTIONS_SUPPORT
-    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) && (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
+    if ((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
+        (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
     {
         uint8_t     enqTh;
@@ -1696,7 +1694,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
         tmpReg |= ((uint32_t)enqTh << QMI_CFG_ENQ_SHIFT);
 
          /* p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums is now smaller,
-           so we can reduce deqTh */
+            so we can reduce deqTh */
         deqTh = (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfDeqTnums + 1);
         tmpReg &= ~QMI_CFG_DEQ_MASK;
         tmpReg |= (uint32_t)deqTh;
@@ -1706,7 +1704,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 #endif /* FM_QMI_DEQ_OPTIONS_SUPPORT */
 
 #ifdef FM_LOW_END_RESTRICTION
-    if((hardwarePortId==0x1) || (hardwarePortId==0x29))
+    if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
         p_Fm->p_FmStateStruct->lowEndRestriction = FALSE;
 #endif /* FM_LOW_END_RESTRICTION */
     XX_UnlockSpinlock(p_Fm->h_Spinlock);
@@ -2012,25 +2010,19 @@ bool FmIsMaster(t_Handle h_Fm)
     return (p_Fm->guestId == NCSW_MASTER_ID);
 }
 
-t_Error FmSetSizeOfFifo(t_Handle                            h_Fm,
-                        uint8_t                             hardwarePortId,
-                        e_FmPortType                        portType,
-                        bool                                independentMode,
-                        uint32_t                            *p_SizeOfFifo,
-                        uint32_t                            extraSizeOfFifo,
-                        uint8_t                             deqPipelineDepth,
-                        t_FmInterModulePortRxPoolsParams    *p_RxPoolsParams,
-                        bool                                initialConfig)
+t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
+                        uint8_t     hardwarePortId,
+                        uint32_t    sizeOfFifo,
+                        uint32_t    extraSizeOfFifo,
+                        bool        initialConfig)
 {
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint8_t                 relativePortId;
-    uint16_t                macMaxFrameLength = 0, oldVal;
-    uint32_t                minFifoSizeRequired = 0, sizeOfFifo, tmpReg = 0;
-    t_FmIpcPortFifoParams   fifoParams;
+    uint16_t                oldVal;
+    t_FmIpcPortRsrcParams   rsrcParams;
     t_Error                 err;
+    uint32_t                tmpReg = 0;
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    ASSERT_COND(initialConfig || p_RxPoolsParams);
 
     if(p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -2038,141 +2030,30 @@ t_Error FmSetSizeOfFifo(t_Handle                            h_Fm,
         t_FmIpcReply        reply;
         uint32_t            replyLength;
 
-        ASSERT_COND(p_RxPoolsParams);
-
-        memset(&fifoParams, 0, sizeof(fifoParams));
-        fifoParams.rsrcParams.hardwarePortId = hardwarePortId;
-        fifoParams.rsrcParams.val = *p_SizeOfFifo;
-        fifoParams.rsrcParams.extra = extraSizeOfFifo;
-        fifoParams.enumPortType = (uint32_t)portType;
-        fifoParams.boolIndependentMode = (uint8_t)independentMode;
-        fifoParams.deqPipelineDepth = deqPipelineDepth;
-        fifoParams.numOfPools = p_RxPoolsParams->numOfPools;
-        fifoParams.secondLargestBufSize = p_RxPoolsParams->secondLargestBufSize;
-        fifoParams.largestBufSize = p_RxPoolsParams->largestBufSize;
-        fifoParams.boolInitialConfig = (uint8_t)initialConfig;
+        rsrcParams.hardwarePortId = hardwarePortId;
+        rsrcParams.val = sizeOfFifo;
+        rsrcParams.extra = extraSizeOfFifo;
+        rsrcParams.boolInitialConfig = (uint8_t)initialConfig;
 
         memset(&msg, 0, sizeof(msg));
         memset(&reply, 0, sizeof(reply));
         msg.msgId = FM_SET_SIZE_OF_FIFO;
-        memcpy(msg.msgBody, &fifoParams, sizeof(fifoParams));
-        replyLength = sizeof(uint32_t) + sizeof(uint32_t);
+        memcpy(msg.msgBody, &rsrcParams, sizeof(rsrcParams));
+        replyLength = sizeof(uint32_t);
         if ((err = XX_IpcSendMessage(p_Fm->h_IpcSessions[0],
                                      (uint8_t*)&msg,
-                                     sizeof(msg.msgId) + sizeof(fifoParams),
+                                     sizeof(msg.msgId) + sizeof(rsrcParams),
                                      (uint8_t*)&reply,
                                      &replyLength,
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
-        if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
+        if (replyLength != sizeof(uint32_t))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        memcpy((uint8_t*)p_SizeOfFifo, reply.replyBody, sizeof(uint32_t));
-
         return (t_Error)(reply.error);
     }
-    sizeOfFifo = *p_SizeOfFifo;
-    /* if neseccary (cases where frame length is relevant), update sizeOfFifo field. */
-    if((portType == e_FM_PORT_TYPE_TX) || ((portType == e_FM_PORT_TYPE_RX) && independentMode))
-    {
-        HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
-        ASSERT_COND(relativePortId < FM_MAX_NUM_OF_1G_MACS);
-        macMaxFrameLength = p_Fm->p_FmStateStruct->macMaxFrameLengths1G[relativePortId];
-    }
-
-#if (defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS))
-    if((portType == e_FM_PORT_TYPE_TX_10G) || ((portType == e_FM_PORT_TYPE_RX_10G)  && independentMode))
-    {
-        HW_PORT_ID_TO_SW_PORT_ID(relativePortId, hardwarePortId);
-        ASSERT_COND(relativePortId < FM_MAX_NUM_OF_10G_MACS);
-        macMaxFrameLength = p_Fm->p_FmStateStruct->macMaxFrameLengths10G[relativePortId];
-    }
-#endif /* (defined(FM_MAX_NUM_OF_10G_MACS) && ... */
 
-    /*************************/
-    /*    TX PORTS           */
-    /*************************/
-    if((portType == e_FM_PORT_TYPE_TX) || (portType == e_FM_PORT_TYPE_TX_10G))
-    {
-        if(independentMode)
-            minFifoSizeRequired = (uint32_t)((macMaxFrameLength % BMI_FIFO_UNITS ?
-                                (macMaxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
-                                macMaxFrameLength) +
-                                (3*BMI_FIFO_UNITS));
-        else
-            minFifoSizeRequired = (uint32_t)((macMaxFrameLength % BMI_FIFO_UNITS ?
-                                   (macMaxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS :
-                                   macMaxFrameLength) +
-                                   (deqPipelineDepth+3)*BMI_FIFO_UNITS);
-    }
-    /*************************/
-    /*    RX IM PORTS        */
-    /*************************/
-    else if(((portType == e_FM_PORT_TYPE_RX) || (portType == e_FM_PORT_TYPE_RX_10G)) && independentMode)
-        minFifoSizeRequired = (uint32_t)(((macMaxFrameLength % BMI_FIFO_UNITS) ?
-                                         ((macMaxFrameLength/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
-                                         macMaxFrameLength) +
-                                         (4*BMI_FIFO_UNITS));
-
-    /* for Rx (non-Im) ports or OP, buffer pools are relevant for fifo size.
-       If this routine is called as part of the "GetSet" routine, initialConfig is TRUE
-       and these checks where done in the port routine.
-       If it is called by an explicit user request ("SetSizeOfFifo"), than these parameters
-       should be checked/updated */
-    if(!initialConfig &&
-      ((portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) ||
-      (((portType == e_FM_PORT_TYPE_RX) || (portType == e_FM_PORT_TYPE_RX_10G)) && !independentMode)))
-    {
-        if((portType == e_FM_PORT_TYPE_RX) || (portType == e_FM_PORT_TYPE_RX_10G))
-        {
-            /*************************/
-            /*    RX non-IM PORTS    */
-            /*************************/
-#ifdef FM_FIFO_ALLOCATION_OLD_ALG
-            t_FmRevisionInfo revInfo;
-
-            FM_GetRevision(p_Fm, &revInfo);
-            if(revInfo.majorRev != 4)
-                minFifoSizeRequired = (uint32_t)(((p_RxPoolsParams->largestBufSize % BMI_FIFO_UNITS) ?
-                                        ((p_RxPoolsParams->largestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
-                                        p_RxPoolsParams->largestBufSize) +
-                                        (7*BMI_FIFO_UNITS));
-            else
-#endif /* FM_FIFO_ALLOCATION_OLD_ALG */
-            {
-                if(p_RxPoolsParams->numOfPools == 1)
-                    minFifoSizeRequired = 8*BMI_FIFO_UNITS;
-                else
-                {
-                    minFifoSizeRequired = (uint32_t)(((p_RxPoolsParams->secondLargestBufSize % BMI_FIFO_UNITS) ?
-                                        ((p_RxPoolsParams->secondLargestBufSize/BMI_FIFO_UNITS + 1) * BMI_FIFO_UNITS) :
-                                        p_RxPoolsParams->secondLargestBufSize) +
-                                        (7*BMI_FIFO_UNITS));
-                    if((sizeOfFifo < minFifoSizeRequired))
-                    {
-                        DBG(WARNING, ("User set FIFO size for Rx port is not optimized. (not modified by driver)"));
-                        minFifoSizeRequired = 8*BMI_FIFO_UNITS;
-                    }
-                }
-            }
-        }
-        else
-        {
-            /*************************/
-            /*    OP PORTS           */
-            /*************************/
-            /* check if pool size is not too big */
-            if(p_RxPoolsParams->largestBufSize > sizeOfFifo )
-                RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Largest pool size is bigger than ports committed fifo size"));
-        }
-    }
-
-
-    if (minFifoSizeRequired && (sizeOfFifo < minFifoSizeRequired))
-    {
-        sizeOfFifo = minFifoSizeRequired;
-        DBG(WARNING, ("FIFO size enlarged to %d for port %#x", minFifoSizeRequired, hardwarePortId));
-    }
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
 
     if(initialConfig)
         oldVal = 0;
@@ -2205,7 +2086,6 @@ t_Error FmSetSizeOfFifo(t_Handle                            h_Fm,
                             ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
         WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], tmpReg);
     }
-    *p_SizeOfFifo = sizeOfFifo;
 
     return E_OK;
 }
@@ -2488,9 +2368,9 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->hcPortInitialized = FALSE;
     p_Fm->independentMode   = FALSE;
     p_Fm->p_FmStateStruct->ramsEccEnable     = FALSE;
-    p_Fm->p_FmStateStruct->totalNumOfTasks   = DEFAULT_totalNumOfTasks;
+    p_Fm->p_FmStateStruct->totalNumOfTasks   = BMI_MAX_NUM_OF_TASKS;
     p_Fm->p_FmStateStruct->totalFifoSize     = DEFAULT_totalFifoSize;
-    p_Fm->p_FmStateStruct->maxNumOfOpenDmas  = DEFAULT_maxNumOfOpenDmas;
+    p_Fm->p_FmStateStruct->maxNumOfOpenDmas  = BMI_MAX_NUM_OF_DMAS;
     p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
     p_Fm->p_FmStateStruct->exceptions        = DEFAULT_exceptions;
     for(i = 0;i<FM_MAX_NUM_OF_1G_MACS;i++)
@@ -2697,16 +2577,6 @@ t_Error FM_Init(t_Handle h_Fm)
         p_Fm->p_FmStateStruct->exceptions &= ~FM_EX_BMI_DISPATCH_RAM_ECC;
 #endif /* FM_NO_DISPATCH_RAM_ECC */
 
-#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
-    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-        p_Fm->p_FmStateStruct->exceptions  &= ~FM_EX_BMI_LIST_RAM_ECC;
-#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8 */
-
-#ifdef FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
-    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-        p_Fm->p_FmStateStruct->exceptions  &= ~FM_EX_BMI_PIPELINE_ECC;
-#endif /* FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9 */
-
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
     if (revInfo.majorRev == 4)
         p_Fm->p_FmStateStruct->exceptions  &= ~(FM_EX_QMI_SINGLE_ECC | FM_EX_QMI_DOUBLE_ECC);
@@ -2743,13 +2613,9 @@ t_Error FM_Init(t_Handle h_Fm)
 
         /* verify breakpoint debug status register */
         debug_reg = GET_UINT32(*(uint32_t *)UINT_TO_PTR(p_Fm->baseAddr + FM_DEBUG_STATUS_REGISTER_OFFSET));
-#ifndef NCSW_LINUX
         if(!debug_reg)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Invalid debug status register value = 0"));
-#else
-        if(!debug_reg)
-            DBG(INFO,("Invalid debug status register value = 0"));
-#endif
+
         /*************************************/
         /* Load FMan-Controller code to Iram */
         /*************************************/
@@ -2867,6 +2733,47 @@ t_Error FM_Init(t_Handle h_Fm)
 
     WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr), 0, (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*DMA_CAM_SIZEOF_ENTRY));
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    {
+        t_FmRevisionInfo revInfo;
+
+        FM_GetRevision(p_Fm, &revInfo);
+        if (revInfo.majorRev == 2)
+        {
+            FM_MURAM_FreeMem(p_Fm->h_FmMuram, UINT_TO_PTR(p_Fm->camBaseAddr));
+
+            p_Fm->camBaseAddr = PTR_TO_UINT(FM_MURAM_AllocMem(p_Fm->h_FmMuram,
+                                                              (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128),
+                                                              64));
+            if (!p_Fm->camBaseAddr)
+                RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for DMA CAM failed"));
+
+            WRITE_BLOCK(UINT_TO_PTR(p_Fm->camBaseAddr), 0, (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128));
+
+            switch(p_FmDriverParam->dmaCamNumOfEntries)
+            {
+                case(8):
+                    *(volatile uint32_t*)p_Fm->camBaseAddr = 0xff000000;
+                    break;
+                case(16):
+                    *(volatile uint32_t*)p_Fm->camBaseAddr = 0xffff0000;
+/*                    WRITE_UINT32(p_Fm->camBaseAddr, 0xffff0000); */
+                    break;
+                case(24):
+                    *(volatile uint32_t*)p_Fm->camBaseAddr = 0xffffff00;
+/*                    WRITE_UINT32(p_Fm->camBaseAddr, 0xffffff00); */
+                    break;
+                case(32):
+                    *(volatile uint32_t*)p_Fm->camBaseAddr = 0xffffffff;
+/*                    WRITE_UINT32(p_Fm->camBaseAddr, 0xffffffff); */
+                    break;
+                default:
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("wrong dmaCamNumOfEntries"));
+            }
+        }
+    }
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
     /* VirtToPhys */
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmebcr,
                  (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->camBaseAddr)) - p_Fm->fmMuramPhysBaseAddr));
@@ -2967,10 +2874,7 @@ t_Error FM_Init(t_Handle h_Fm)
                                                        p_Fm->p_FmStateStruct->totalFifoSize,
                                                        BMI_FIFO_ALIGN));
     if (!p_Fm->fifoBaseAddr)
-    {
-        FreeInitResources(p_Fm);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for FIFO failed"));
-    }
 
     tmpReg = (uint32_t)(XX_VirtToPhys(UINT_TO_PTR(p_Fm->fifoBaseAddr)) - p_Fm->fmMuramPhysBaseAddr);
     tmpReg = tmpReg / BMI_FIFO_ALIGN;
@@ -3179,18 +3083,6 @@ t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable)
 }
 
 
-t_Error FM_ConfigTotalNumOfTasks(t_Handle h_Fm, uint8_t totalNumOfTasks)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-
-    p_Fm->p_FmStateStruct->totalNumOfTasks = totalNumOfTasks;
-
-    return E_OK;
-}
-
 t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
@@ -3203,17 +3095,6 @@ t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize)
     return E_OK;
 }
 
-t_Error FM_ConfigMaxNumOfOpenDmas(t_Handle h_Fm, uint8_t maxNumOfOpenDmas)
-{
-    t_Fm *p_Fm = (t_Fm*)h_Fm;
-
-    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
-
-    p_Fm->p_FmStateStruct->maxNumOfOpenDmas = maxNumOfOpenDmas;
-
-    return E_OK;
-}
 
 t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds)
 {
@@ -3477,15 +3358,6 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
-#ifdef FM_HALT_SIG_ERRATA_GEN12
-    {
-        t_FmRevisionInfo revInfo;
-        FM_GetRevision(h_Fm, &revInfo);
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnExternalActivation!"));
-    }
-#endif /* FM_HALT_SIG_ERRATA_GEN12 */
-
     p_Fm->p_FmDriverParam->haltOnExternalActivation = enable;
 
     return E_OK;
@@ -3493,18 +3365,18 @@ t_Error FM_ConfigHaltOnExternalActivation(t_Handle h_Fm, bool enable)
 
 t_Error FM_ConfigHaltOnUnrecoverableEccError(t_Handle h_Fm, bool enable)
 {
+#ifdef FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
+#else  /* not FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
 
-#ifdef FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
-    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
-#endif /* FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
-
     p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError = enable;
 
     return E_OK;
+#endif /* not FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
 }
 
 t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
@@ -3516,26 +3388,6 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
     FM_GetRevision(p_Fm, &revInfo);
-#ifdef FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
-    if((exception == e_FM_EX_BMI_PIPELINE_ECC) && (enable))
-    {
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-        {
-            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_PIPELINE_ECC!"));
-            return E_OK;
-        }
-    }
-#endif /* FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9 */
-#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
-    if((exception == e_FM_EX_BMI_LIST_RAM_ECC) && (enable))
-    {
-        if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-        {
-            REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_LIST_RAM_ECC!"));
-            return E_OK;
-        }
-    }
-#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8 */
 #ifdef FM_QMI_NO_ECC_EXCEPTIONS
     if(((exception == e_FM_EX_QMI_SINGLE_ECC) || (exception == e_FM_EX_QMI_DOUBLE_ECC)) &&
             enable)
@@ -3704,6 +3556,15 @@ void FM_EventIsr(t_Handle h_Fm)
         else
             p_Fm->fmanCtrlIntr[3].f_Isr(p_Fm->fmanCtrlIntr[3].h_SrcHandle, event);
     }
+#ifdef FM_MACSEC_SUPPORT
+    if (pending & INTR_EN_MACSEC_MAC0)
+    {
+       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_MACSEC_MAC0].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_MACSEC_MAC0, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_MACSEC_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_MACSEC_MAC0].h_SrcHandle);
+    }
+#endif /* FM_MACSEC_SUPPORT */
 }
 
 t_Error FM_ErrorIsr(t_Handle h_Fm)
@@ -3995,18 +3856,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
              case(e_FM_EX_BMI_LIST_RAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
                 if(enable)
-                {
-#ifdef FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
-                    t_FmRevisionInfo revInfo;
-                    FM_GetRevision(p_Fm, &revInfo);
-                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                    {
-                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_LIST_RAM_ECC"));
-                       return E_OK;
-                    }
-#endif   /* FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8 */
                     tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
-                }
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
@@ -4014,18 +3864,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
              case(e_FM_EX_BMI_PIPELINE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
                 if(enable)
-                {
-#ifdef FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
-                    t_FmRevisionInfo revInfo;
-                    FM_GetRevision(p_Fm, &revInfo);
-                    if ((revInfo.majorRev == 1) && (revInfo.minorRev == 0))
-                    {
-                       REPORT_ERROR(MINOR, E_NOT_SUPPORTED, ("e_FM_EX_BMI_PIPELINE_ECCBMI_LIST_RAM_ECC"));
-                       return E_OK;
-                    }
-#endif /* FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9 */
                     tmpReg |= BMI_ERR_INTR_EN_PIPELINE_ECC;
-                }
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_PIPELINE_ECC;
                 WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier, tmpReg);
@@ -4145,6 +3984,25 @@ t_Error FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo)
     return E_OK;
 }
 
+t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmRevisionInfo *p_RevisionInfo)
+{
+    t_Fm                *p_Fm = (t_Fm*)h_Fm;
+    t_FMIramRegs    	*p_Iram;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_RevisionInfo, E_NULL_POINTER);
+
+    if (p_Fm->guestId != NCSW_MASTER_ID)
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("IPC"));
+
+    p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+    WRITE_UINT32(p_Iram->iadd, 0x4);
+    p_RevisionInfo->majorRev = ((uint8_t *)&p_Iram->idata)[1];
+    p_RevisionInfo->minorRev = ((uint8_t *)&p_Iram->idata)[3];
+
+    return E_OK;
+}
+
 uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
 {
     t_Fm                *p_Fm = (t_Fm*)h_Fm;
@@ -4544,6 +4402,7 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
 
     DUMP_TITLE(p_Fm->p_FmDmaRegs, ("p_FmDmaRegs Regs"));
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmsr);
+    DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmemsr);
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmmr);
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmtr);
     DUMP_VAR(p_Fm->p_FmDmaRegs,fmdmhy);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
index cd61d96..b281c7b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -123,9 +123,7 @@
                                             FM_EX_BMI_DISPATCH_RAM_ECC      |\
                                             FM_EX_IRAM_ECC                  |\
                                             FM_EX_NURAM_ECC                 )
-#define DEFAULT_totalNumOfTasks             (BMI_MAX_NUM_OF_TASKS*3/4)
 #define DEFAULT_totalFifoSize               (BMI_MAX_FIFO_SIZE*3/4)
-#define DEFAULT_maxNumOfOpenDmas            (BMI_MAX_NUM_OF_DMAS*3/4)
 #define DEFAULT_eccEnable                   FALSE
 #define DEFAULT_dispLimit                   0
 #define DEFAULT_prsDispTh                   16
@@ -451,8 +449,6 @@ typedef _Packed struct
 #define FPM_TS_FRACTION_MASK            0x0000FFFF
 #define FPM_TS_CTL_EN                   0x80000000
 
-#define FPM_PORT_FM_CTL1                0x00000001
-#define FPM_PORT_FM_CTL2                0x00000002
 #define FPM_PRC_REALSE_STALLED          0x00800000
 
 #define FPM_PS_STALLED                  0x00800000
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
index 7bb2e48..b2594ef 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_ipc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -190,6 +190,7 @@ typedef _Packed struct t_FmIpcRevisionInfo {
 typedef _Packed struct t_FmIpcPortNumOfFmanCtrls {
     uint8_t             hardwarePortId;         /**< IN. port Id */
     uint8_t             numOfFmanCtrls;         /**< IN. Port type */
+    t_FmFmanCtrl        orFmanCtrl;             /**< IN. fman controller for order restoration*/
 } t_FmIpcPortNumOfFmanCtrls;
 
 /**************************************************************************//**
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
index e52f233..1225144 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm_muram.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index d1aaa3d..1260c81 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -109,6 +109,29 @@ typedef _Packed struct t_FmPcdCcCapwapReassmTimeoutParams {
 #endif /* defined(__MWERKS__) && ... */
 
 
+/*for UNDER_CONSTRUCTION_FM_RMU_USE_SEC its defined in fm_ext.h*/
+typedef uint32_t t_FmFmanCtrl;
+
+#define FPM_PORT_FM_CTL1                0x00000001
+#define FPM_PORT_FM_CTL2                0x00000002
+
+
+
+
+
+#define NUM_OF_SCRATCH_POOL_BUFFERS     1000 /*TODO - Change it!!*/
+
+typedef struct t_FmPcdCcFragScratchPoolCmdParams {
+    uint32_t    numOfBuffers;
+    uint8_t     bufferPoolId;
+}t_FmPcdCcFragScratchPoolCmdParams;
+
+typedef struct t_FmPcdCcIpReassmTimeoutParams {
+    bool        activate;
+    uint8_t     tsbs;
+    uint32_t    iprcpt;
+}t_FmPcdCcIpReassmTimeoutParams;
+
 typedef struct {
     uint8_t             baseEntry;
     uint16_t            numOfClsPlanEntries;
@@ -161,10 +184,10 @@ typedef struct {
 } t_GetCcParams;
 
 typedef struct {
-    uint32_t type;
-    int      psoSize;
-    uint32_t nia;
-
+    uint32_t        type;
+    int             psoSize;
+    uint32_t        nia;
+    t_FmFmanCtrl    orFmanCtrl;
 } t_SetCcParams;
 
 typedef struct {
@@ -214,6 +237,10 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_PSO                              0x40000000
 #define UPDATE_NIA_PNDN                         0x20000000
 #define UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY      0x10000000
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+#define UPDATE_IPR_EN                           0x08000000
+#define UPDATE_NIA_RFENE                        0x04000000
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 /* @} */
 
 /**************************************************************************//**
@@ -223,6 +250,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define UPDATE_NIA_ENQ_WITHOUT_DMA              0x80000000
 #define UPDATE_CC_WITH_TREE                     0x40000000
 #define UPDATE_CC_WITH_DELETE_TREE              0x20000000
+#define UPDATE_KG_NIA_CC_WA                     0x10000000
 /* @} */
 
 /**************************************************************************//**
@@ -304,7 +332,8 @@ typedef uint32_t t_FmBlockIntrEnable;
 #define NIA_FM_CTL_AC_POST_FETCH_PCD_UDP_LEN    0x00000018
 #define NIA_FM_CTL_AC_POST_FETCH_NO_PCD         0x00000012
 #define NIA_FM_CTL_AC_FRAG_CHECK                0x00000014
-#define NIA_FM_CTL_AC_MASK                      0x0000001f
+#define NIA_FM_CTL_AC_PRE_CC                    0x00000020
+
 
 #define NIA_BMI_AC_ENQ_FRAME        0x00000002
 #define NIA_BMI_AC_TX_RELEASE       0x000002C0
@@ -707,13 +736,6 @@ typedef struct t_FmPcdKgInterModuleClsPlanGrpParams {
                                /* OUT in FmPcdGetSetClsPlanGrpParams IN in FmPcdKgBuildClsPlanGrp*/
 } t_FmPcdKgInterModuleClsPlanGrpParams;
 
-typedef struct t_FmInterModulePortRxPoolsParams
-{
-    uint8_t     numOfPools;
-    uint16_t    secondLargestBufSize;
-    uint16_t    largestBufSize;
-} t_FmInterModulePortRxPoolsParams;
-
 
 typedef t_Error (t_FmPortGetSetCcParamsCallback) (t_Handle                  h_FmPort,
                                                   t_FmPortGetSetCcParams    *p_FmPortGetSetCcParams);
@@ -730,16 +752,18 @@ uint32_t    FmPcdLock(t_Handle h_FmPcd);
 void        FmPcdUnlock(t_Handle h_FmPcd, uint32_t  intFlags);
 bool        FmPcdNetEnvIsHdrExist(t_Handle h_FmPcd, uint8_t netEnvId, e_NetHeaderType hdr);
 bool        FmPcdIsIpFrag(t_Handle h_FmPcd, uint8_t netEnvId);
-
+t_Error     FmPcdFragHcScratchPoolInit(t_Handle h_FmPcd, uint8_t scratchBpid);
+t_Error     FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl);
+t_Error     FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl);
 t_Error     FmPcdCcReleaseModifiedDataStructure(t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst, t_List *h_FmPcdNewPointersLst, uint16_t numOfGoodChanges, t_Handle *h_Params);
 uint32_t    FmPcdCcGetNodeAddrOffset(t_Handle h_FmPcd, t_Handle h_Pointer);
-t_Error     FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
-t_Error     FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPCdCcKeyParams,  t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_Params);
-t_Error     FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst,  t_List *h_NewLst, t_Handle *h_AdditionalParams);
-t_Error     FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
+t_Error     FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
+t_Error     FmPcdCcAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPCdCcKeyParams,  t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_Params);
+t_Error     FmPcdCcModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t *p_Key, uint8_t *p_Mask, t_List *h_OldLst,  t_List *h_NewLst, t_Handle *h_AdditionalParams);
+t_Error     FmPcdCcModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams *p_FmPcdCcKeyParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
 t_Error     FmPcdCcModifyMissNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams);
 t_Error     FmPcdCcModifyNextEngineParamTree(t_Handle h_FmPcd, t_Handle h_FmPcdCcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, t_List *h_OldLst, t_List *h_NewLst, t_Handle *h_AdditionalParams);
-t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint8_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams);
+t_Error     FmPcdCcModiyNextEngineParamNode(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, uint16_t keyIndex,t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams,t_List *h_OldPointer, t_List *h_NewPointer,t_Handle *h_AdditionalParams);
 uint32_t    FmPcdCcGetNodeAddrOffsetFromNodeInfo(t_Handle h_FmPcd, t_Handle h_Pointer);
 t_Error     FmPcdCcTreeTryLock(t_Handle h_FmPcdCcTree);
 t_Error     FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd,t_Handle h_FmPcdCcNode, t_List *p_List);
@@ -824,10 +848,10 @@ void        FmPcdPlcrUpdateRequiredAction(t_Handle h_FmPcd, uint16_t absolutePro
 uint8_t     FmPcdCcGetParseCode(t_Handle h_CcNode);
 uint8_t     FmPcdCcGetOffset(t_Handle h_CcNode);
 
-t_Error     FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree, bool modify);
+t_Error     FmPcdManipUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_FmPort, t_Handle h_Manip, t_Handle h_Ad, bool validate, int level, t_Handle h_FmTree, bool modify);
 t_Error     FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_FmPortGetSetCcParams);
 uint32_t    FmPcdManipGetRequiredAction (t_Handle h_Manip);
-t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_CcTree,  uint32_t  *p_Offset,t_Handle h_FmPort);
+t_Error     FmPcdCcBindTree(t_Handle h_FmPcd, t_Handle h_PcdParams, t_Handle h_CcTree,  uint32_t  *p_Offset,t_Handle h_FmPort);
 t_Error     FmPcdCcUnbindTree(t_Handle h_FmPcd, t_Handle h_CcTree);
 
 t_Error     FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx,uint32_t requiredAction);
@@ -1113,19 +1137,21 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams);
 
 /**************************************************************************//**
- @Function      FmSetPortToWorkWithOneRiscOnly
+ @Function      FmSetNumOfRiscsPerPort
 
  @Description   Used by FM-PORT driver to pass parameter between
                 PORT and FM modules for working with number of RISC..
 
  @Param[in]     h_Fm            A handle to an FM Module.
- @Param[in,out] p_PortParams    A structure of FM Port parameters.
+ @Param[in]     hardwarePortId    hardware port Id.
+ @Param[in]     numOfFmanCtrls    number of Fman Controllers.
+ @Param[in]     orFmanCtrl        Fman Controller for order restoration.
 
  @Return        None.
 
  @Cautions      Allowed only following FM_Init().
 *//***************************************************************************/
-t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls);
+t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t numOfFmanCtrls, t_FmFmanCtrl orFmanCtrl);
 
 
 void        FmRegisterPcd(t_Handle h_Fm, t_Handle h_FmPcd);
@@ -1159,15 +1185,11 @@ t_Error     FmSetNumOfTasks(t_Handle    h_Fm,
                                 uint8_t     numOfTasks,
                                 uint8_t     numOfExtraTasks,
                                 bool        initialConfig);
-t_Error     FmSetSizeOfFifo(t_Handle            h_Fm,
-                            uint8_t             hardwarePortId,
-                            e_FmPortType        portType,
-                            bool                independentMode,
-                            uint32_t            *p_SizeOfFifo,
-                            uint32_t            extraSizeOfFifo,
-                            uint8_t             deqPipelineDepth,
-                            t_FmInterModulePortRxPoolsParams    *p_RxPoolsParams,
-                            bool                initialConfig);
+t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
+                        uint8_t     hardwarePortId,
+                        uint32_t     sizeOfFifo,
+                        uint32_t     extraSizeOfFifo,
+                        bool        initialConfig);
 
 
 #endif /* __FM_COMMON_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
index bbcc83c..780fcc8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_hc.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -56,6 +56,11 @@ void        FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd);
 t_Handle    FmHcPcdKgSetScheme(t_Handle h_FmHc, t_FmPcdKgSchemeParams *p_Scheme);
 t_Error     FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme);
 t_Error     FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeoutParams *p_CcCapwapReassmTimeoutParams );
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+t_Error     FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragScratchPoolCmdParams);
+t_Error     FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams *p_CcIpReassmTimeoutParams, uint8_t *p_Result);
+uint32_t    FmHcPcdCcIpFrag(t_Handle h_FmHc, bool fill, t_FmPcdCcFragScratchPoolCmdParams *p_FmPcdCcFragCmdParams);
+#endif /*FM_IP_FRAG_N_REASSEM_SUPPORT*/
 t_Error     FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_Set);
 t_Error     FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t clsPlanGrpId);
 
@@ -63,12 +68,12 @@ t_Error     FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32
 uint32_t    FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme);
 
 t_Error     FmHcPcdCcModifyTreeNextEngine(t_Handle h_FmHc, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-t_Error     FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error     FmHcPcdCcModifyNodeNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 t_Error     FmHcPcdCcModifyNodeMissNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
-t_Error     FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex);
-t_Error     FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
-t_Error     FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
-t_Error     FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
+t_Error     FmHcPcdCcRemoveKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex);
+t_Error     FmHcPcdCcAddKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error     FmHcPcdCcModifyKeyAndNextEngine(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error     FmHcPcdCcModifyKey(t_Handle h_FmHc, t_Handle h_CcNode, uint16_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
 
 t_Handle    FmHcPcdPlcrSetProfile(t_Handle h_FmHc,t_FmPcdPlcrProfileParams *p_Profile);
 t_Error     FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
index 896722f..6909baf 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
index fd51a18..6c336f3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/list.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
index 1ed8dae..9e48fa8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
index 2a8e338..85fc292 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
index 509f614..cfcdd7c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/mm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
index 6f9bdf9..abf08ce 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/sprint.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,7 +38,6 @@
 /*------------------------------------------------------*/
 #include "string_ext.h"
 #include "stdlib_ext.h"
-#include "ctype_ext.h"
 #include "stdarg_ext.h"
 #include "sprint_ext.h"
 #include "std_ext.h"
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
index 5990f71..861f701 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/crc_mac_addr_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
index 282f415..5981fed 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -143,7 +143,7 @@ typedef _Packed struct t_DpaaSGTE {
 *//***************************************************************************/
 typedef _Packed struct t_DpaaSGT {
     t_DpaaSGTE    tableEntry[DPAA_NUM_OF_SG_TABLE_ENTRY];
-                                    /**< structure that hold the information about
+                                    /**< Structure that holds information about
                                          a single S/G entry. */
 } _PackedType t_DpaaSGT;
 
@@ -151,10 +151,10 @@ typedef _Packed struct t_DpaaSGT {
  @Description   Compound Frame Table
 *//***************************************************************************/
 typedef _Packed struct t_DpaaCompTbl {
-    t_DpaaSGTE    outputBuffInfo;   /**< structure that holds the information about
+    t_DpaaSGTE    outputBuffInfo;   /**< Structure that holds information about
                                          the compound-frame output buffer;
                                          NOTE: this may point to a S/G table */
-    t_DpaaSGTE    inputBuffInfo;    /**< structure that holds the information about
+    t_DpaaSGTE    inputBuffInfo;    /**< Structure that holds information about
                                          the compound-frame input buffer;
                                          NOTE: this may point to a S/G table */
 } _PackedType t_DpaaCompTbl;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index 9b5db04..aca8a04 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -115,8 +115,11 @@ typedef _Packed struct t_FmPrsResult {
     volatile uint8_t     cplan;              /**< Classification plan id */
     volatile uint16_t    nxthdr;             /**< Next Header  */
     volatile uint16_t    cksum;              /**< Checksum */
-    volatile uint32_t    lcv;                /**< LCV */
-    volatile uint8_t     shim_off[3];        /**< Shim offset */
+    volatile uint16_t    flags_frag_off;     /**< Flags & fragment-offset field of the last IP-header */
+    volatile uint8_t     route_type;         /**< Routing type field of a IPv6 routing extension header */
+    volatile uint8_t     rhp_ip_valid;       /**< Routing Extension Header Present; last bit is IP valid */
+    volatile uint8_t     shim_off[2];        /**< Shim offset */
+    volatile uint8_t     ip_pid_off;         /**< IP PID (last IP-proto) offset */
     volatile uint8_t     eth_off;            /**< ETH offset */
     volatile uint8_t     llc_snap_off;       /**< LLC_SNAP offset */
     volatile uint8_t     vlan_off[2];        /**< VLAN offset */
@@ -151,7 +154,8 @@ typedef _Packed struct t_FmPrsResult {
 #define FM_FD_CMD_CFQ               0x00ffffff  /**< Confirmation Frame Queue */
 
 #define FM_FD_TX_STATUS_ERR_MASK    0x07000000  /**< TX Error FD bits */
-#define FM_FD_RX_STATUS_ERR_MASK    0x070ee3f8  /**< RX Error FD bits */
+#define FM_FD_RX_STATUS_ERR_MASK    0x073ee3f8  /**< RX Error FD bits */
+#define FM_FD_RX_STATUS_ERR_NON_FM  0x00400000  /**< non Frame-Manager error */
 /* @} */
 
 /**************************************************************************//**
@@ -259,8 +263,9 @@ typedef enum e_FmExceptions {
  @Param[in]     h_App      - User's application descriptor.
  @Param[in]     exception  - The exception.
 *//***************************************************************************/
-typedef void (t_FmExceptionsCallback) (t_Handle              h_App,
-                                       e_FmExceptions        exception);
+typedef void (t_FmExceptionsCallback)(t_Handle          h_App,
+                                      e_FmExceptions    exception);
+
 
 /**************************************************************************//**
  @Function      t_FmBusErrorCallback
@@ -492,7 +497,6 @@ typedef struct t_FmThresholds {
                                                                  queued in fmCtl2 dispatch queue*/
 } t_FmThresholds;
 
-
 /**************************************************************************//**
  @Description   structure for defining DMA thresholds
 *//***************************************************************************/
@@ -520,21 +524,6 @@ typedef struct t_FmDmaThresholds {
 t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
 
 /**************************************************************************//**
- @Function      FM_ConfigTotalNumOfTasks
-
- @Description   Change the total number of tasks from its default
-                configuration [BMI_MAX_NUM_OF_TASKS]
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     totalNumOfTasks     The selected new value.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigTotalNumOfTasks(t_Handle h_Fm, uint8_t totalNumOfTasks);
-
-/**************************************************************************//**
  @Function      FM_ConfigTotalFifoSize
 
  @Description   Change the total Fifo size from its default
@@ -550,34 +539,19 @@ t_Error FM_ConfigTotalNumOfTasks(t_Handle h_Fm, uint8_t totalNumOfTasks);
 t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize);
 
 /**************************************************************************//**
- @Function      FM_ConfigMaxNumOfOpenDmas
-
- @Description   Change the maximum allowed open DMA's for this FM from its default
-                configuration [BMI_MAX_NUM_OF_DMAS]
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     maxNumOfOpenDmas    The selected new value.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Config() and before FM_Init().
-*//***************************************************************************/
-t_Error FM_ConfigMaxNumOfOpenDmas(t_Handle h_Fm, uint8_t maxNumOfOpenDmas);
-
-/**************************************************************************//**
  @Function      FM_ConfigThresholds
 
  @Description   Calling this routine changes the internal driver data base
                 from its default FM threshold configuration:
-                                          dispLimit:    [0]
-                                          prsDispTh:    [16]
-                                          plcrDispTh:   [16]
-                                          kgDispTh:     [16]
-                                          bmiDispTh:    [16]
-                                          qmiEnqDispTh: [16]
-                                          qmiDeqDispTh: [16]
-                                          fmCtl1DispTh:  [16]
-                                          fmCtl2DispTh:  [16]
+                    dispLimit:    [0]
+                    prsDispTh:    [16]
+                    plcrDispTh:   [16]
+                    kgDispTh:     [16]
+                    bmiDispTh:    [16]
+                    qmiEnqDispTh: [16]
+                    qmiDeqDispTh: [16]
+                    fmCtl1DispTh: [16]
+                    fmCtl2DispTh: [16]
 
  @Param[in]     h_Fm            A handle to an FM Module.
  @Param[in]     p_FmThresholds  A structure of threshold parameters.
@@ -1174,6 +1148,20 @@ t_Error FM_DisableRamsEcc(t_Handle h_Fm);
 t_Error  FM_GetRevision(t_Handle h_Fm, t_FmRevisionInfo *p_FmRevisionInfo);
 
 /**************************************************************************//**
+ @Function      FM_GetFmanCtrlCodeRevision
+
+ @Description   Returns the Fman controller code revision
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[out]    p_RevisionInfo      A structure of revision information parameters.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+*//***************************************************************************/
+t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmRevisionInfo *p_RevisionInfo);
+
+/**************************************************************************//**
  @Function      FM_GetCounter
 
  @Description   Reads one of the FM counters.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index 5abb600..bd5b891 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -282,7 +282,7 @@ t_Error FM_MAC_ConfigLoopback (t_Handle h_FmMac, bool enable);
 /**************************************************************************//**
  @Function      FM_MAC_ConfigMaxFrameLength
 
- @Description   Setup maximum Frame Length
+ @Description   Setup maximum Rx Frame Length (in 1G MAC, effects also Tx)
 
  @Param[in]     h_FmMac    A handle to a FM MAC Module.
  @Param[in]     newVal     MAX Frame length
@@ -338,7 +338,7 @@ t_Error FM_MAC_ConfigHalfDuplex (t_Handle h_FmMac, bool enable);
 /**************************************************************************//**
  @Function      FM_MAC_ConfigLengthCheck
 
- @Description   Configure thef frame length checking.
+ @Description   Configure the frame length checking.
 
  @Param[in]     h_FmMac    A handle to a FM MAC Module.
  @Param[in]     enable     TRUE to enable or FALSE to disable.
@@ -358,7 +358,6 @@ t_Error FM_MAC_ConfigLengthCheck (t_Handle h_FmMac, bool enable);
  @Param[in]     ex              Type of the desired exceptions
  @Param[in]     enable          TRUE to enable the specified exception, FALSE to disable it.
 
-
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_MAC_Config() and before FM_MAC_Init().
@@ -499,9 +498,9 @@ t_Error FM_MAC_SetException(t_Handle h_FmMac, e_FmMacExceptions ex, bool enable)
  @Function      FM_MAC_SetStatistics
 
  @Description   Define Statistics level.
-                                Where applicable, the routine also enables the MIB counters
-                                overflow interrupt in order to keep counters accurate
-                                and account for overflows.
+                Where applicable, the routine also enables the MIB counters
+                overflow interrupt in order to keep counters accurate
+                and account for overflows.
 
  @Param[in]     h_FmMac         A handle to a FM MAC Module.
  @Param[in]     statisticsLevel Full statistics level provides all standard counters but may
@@ -708,6 +707,4 @@ t_Error FM_MAC_DumpRegs(t_Handle h_FmMac);
 /** @} */ /* end of FM_mac_grp group */
 /** @} */ /* end of FM_grp group */
 
-
-
 #endif /* __FM_MAC_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
index 0c99ef3..0802677 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_muram_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 6de21e7..cc41bc6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -472,7 +472,6 @@ t_Error FM_PCD_Enable(t_Handle h_FmPcd);
 *//***************************************************************************/
 t_Error FM_PCD_Disable(t_Handle h_FmPcd);
 
-
 /**************************************************************************//**
  @Function      FM_PCD_GetCounter
 
@@ -741,6 +740,7 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
 #define FM_PCD_MAX_NUM_OF_KEYS              256
 #define FM_PCD_MAX_SIZE_OF_KEY              56
 #define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP 16
+#define FM_PCD_LAST_KEY_INDEX               0xffff
 /* @} */
 
 /**************************************************************************//**
@@ -764,11 +764,22 @@ typedef protocolOpt_t   ipv4ProtocolOpt_t;      /**< IPv4 protocol options. */
 #define IPV4_MULTICAST_1            0x04000000  /**< IPv4 Multicast. */
 #define IPV4_UNICAST_2              0x02000000  /**< Tunneled IPv4 - Unicast. */
 #define IPV4_MULTICAST_BROADCAST_2  0x01000000  /**< Tunneled IPv4 - Broadcast/Multicast. */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+#define IPV4_FRAG_1                 0x00000008  /**< IPV4 reassembly option.
+                                                     IPV4 Reassembly manipulation requires network
+                                                     environment with IPV4 header and IPV4_FRAG_1 option  */
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
 typedef protocolOpt_t   ipv6ProtocolOpt_t;      /**< IPv6 protocol options. */
 #define IPV6_MULTICAST_1            0x00800000  /**< IPv6 Multicast. */
 #define IPV6_UNICAST_2              0x00400000  /**< Tunneled IPv6 - Unicast. */
 #define IPV6_MULTICAST_2            0x00200000  /**< Tunneled IPv6 - Multicast. */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+#define IPV6_FRAG_1                 0x00000004  /**< IPV6 reassembly option.
+                                                     IPV6 Reassembly manipulation requires an IPV4 network
+                                                     environment unit with IPV4_FRAG_1 option  */
+
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 /* @} */
 
 /**************************************************************************//**
@@ -966,7 +977,7 @@ typedef enum e_FmPcdAction {
     e_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
 } e_FmPcdAction;
 
-#if defined(FM_CAPWAP_SUPPORT)
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
  @Description   An enum for selecting type of insert manipulation
 *//***************************************************************************/
@@ -1006,13 +1017,13 @@ typedef enum e_FmPcdManipReassemTimeOutMode {
  @Description   An enum for selecting type of WaysNumber mode
 *//***************************************************************************/
 typedef enum e_FmPcdManipReassemWaysNumber {
-    e_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< -------------- */
-    e_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< -------------- */
-    e_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< -------------- */
-    e_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< four ways hash */
-    e_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< -------------- */
-    e_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< -------------- */
-    e_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< -------------- */
+    e_FM_PCD_MANIP_ONE_WAY_HASH = 1,    /**< one way hash */
+    e_FM_PCD_MANIP_TWO_WAYS_HASH,       /**< two ways hash*/
+    e_FM_PCD_MANIP_THREE_WAYS_HASH,     /**< three ways hash */
+    e_FM_PCD_MANIP_FOUR_WAYS_HASH,      /**< four ways hash*/
+    e_FM_PCD_MANIP_FIVE_WAYS_HASH,      /**< five ways hash */
+    e_FM_PCD_MANIP_SIX_WAYS_HASH,       /**< six ways hash*/
+    e_FM_PCD_MANIP_SEVEN_WAYS_HASH,     /**< seven ways hash */
     e_FM_PCD_MANIP_EIGHT_WAYS_HASH      /**< eight ways hash*/
 } e_FmPcdManipReassemWaysNumber;
 
@@ -1023,7 +1034,19 @@ typedef enum e_FmPcdStatsType {
     e_FM_PCD_STATS_PER_FLOWID = 0   /**< type where flowId used as index for getting statistics */
 } e_FmPcdStatsType;
 
-#endif /* FM_CAPWAP_SUPPORT */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+/**************************************************************************//**
+ @Description   An enum for Don't Fragment Action. If an IP packet is larger
+                than MTU and its DF bit is set, then this enum determine
+                the action to be taken.
+*//***************************************************************************/
+typedef enum e_FmPcdManipDontFragAction {
+    e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = 0,      /**< Discard packet */
+    e_FM_PCD_MANIP_FRAGMENT_PACKECT,        /**< Fragment packet and continue normal processing */
+    e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG    /**< Continue normal processing without fragmenting the packet */
+} e_FmPcdManipDontFragAction;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
 
 
 /**************************************************************************//**
@@ -1125,8 +1148,11 @@ typedef struct t_FmPcdExtractEntry {
         struct {
             e_FmPcdExtractFrom          src;            /**< Non-header extraction source */
             e_FmPcdAction               action;         /**< Relevant for CC Only */
-            uint16_t                    icIndxMask;     /**< Relevant only for CC where
-                                                             action=e_FM_PCD_ACTION_INDEXED_LOOKUP */
+            uint16_t                    icIndxMask;     /**< Relevant only for CC when
+                                                             action = e_FM_PCD_ACTION_INDEXED_LOOKUP;
+                                                             Note that the number of bits that are set whithin
+                                                             this mask must be log2 of the CC-node 'numOfKeys'.
+                                                             Note that the mask cannot be set on the lower bits. */
             uint8_t                     offset;         /**< Byte offset */
             uint8_t                     size;           /**< Size in byte */
         } extractNonHdr;                                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
@@ -1138,9 +1164,9 @@ typedef struct t_FmPcdExtractEntry {
                 field in the key.
 *//***************************************************************************/
 typedef struct t_FmPcdKgExtractMask {
-    uint8_t                         extractArrayIndex;   /**< Index in the extraction array, as initialized by user */
-    uint8_t                         offset;              /**< Byte offset */
-    uint8_t                         mask;                /**< A byte mask (selected bits will be used) */
+    uint8_t                             extractArrayIndex;  /**< Index in the extraction array, as initialized by user */
+    uint8_t                             offset;             /**< Byte offset */
+    uint8_t                             mask;               /**< A byte mask (selected bits will be used) */
 } t_FmPcdKgExtractMask;
 
 /**************************************************************************//**
@@ -1193,7 +1219,7 @@ typedef struct t_FmPcdKgExtractedOrParams {
                                                              IP. Otherwise should be cleared.*/
             bool                    ignoreProtocolValidation;
                                                         /**< continue extraction even if protocol is not recognized */
-        } extractByHdr;
+        } extractByHdr;                                 /**< Header to extract by */
         e_FmPcdExtractFrom          src;                /**< used when type = e_FM_PCD_KG_EXTRACT_NON_HDR */
     };
     uint8_t                         extractionOffset;   /**< Offset for extraction (in bytes).  */
@@ -1264,8 +1290,8 @@ typedef struct t_FmPcdKgPlcrProfile {
                                                          offset within the port's policer profiles window or
                                                          SHARED window depends on sharedProfile */
             uint8_t     numOfProfiles;              /**< Range of profiles starting at base */
-        } indirectProfile;
-    } profileSelect;
+        } indirectProfile;                          /**< Indirect profile parameters */
+    } profileSelect;                                /**< Direct/indirect profile selection and parameters */
 } t_FmPcdKgPlcrProfile;
 
 /**************************************************************************//**
@@ -1407,7 +1433,7 @@ typedef struct t_FmPcdCcNextEngineParams {
         t_FmPcdCcNextEnqueueParams      enqueueParams; /**< Parameters in case next engine is BMI */
         t_FmPcdCcNextKgParams           kgParams;      /**< Parameters in case next engine is KG */
     } params;
-#if defined(FM_CAPWAP_SUPPORT)
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
     t_Handle                            h_Manip;       /**< Handler to headerManip.
                                                             Relevant if next engine of the type result
                                                             (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
@@ -1418,7 +1444,7 @@ typedef struct t_FmPcdCcNextEngineParams {
  @Description   A structure for defining a single CC Key parameters
 *//***************************************************************************/
 typedef struct t_FmPcdCcKeyParams {
-    uint8_t                     *p_Key;     /**< pointer to the key of the size defined in keySize*/
+    uint8_t                     *p_Key;     /**< pointer to the key of the size defined in keySize */
     uint8_t                     *p_Mask;    /**< pointer to the Mask per key  of the size defined
                                                  in keySize. p_Key and p_Mask (if defined) has to be
                                                  of the same size defined in the keySize */
@@ -1431,13 +1457,16 @@ typedef struct t_FmPcdCcKeyParams {
  @Description   A structure for defining CC Keys parameters
 *//***************************************************************************/
 typedef struct t_KeysParams {
-    uint8_t                     numOfKeys;      /**< Number Of relevant Keys  */
+    uint8_t                     numOfKeys;      /**< Number Of relevant Keys;
+                                                     Note that in case of action = e_FM_PCD_ACTION_INDEXED_LOOKUP,
+                                                     this field should be power-of-2 of the number of bits that are
+                                                     set in 'icIndxMask'. */
     uint8_t                     keySize;        /**< size of the key - in the case of the extraction of
                                                      the type FULL_FIELD keySize has to be as standard size of the relevant
                                                      key. In the another type of extraction keySize has to be as size of extraction.
                                                      In the case of action = e_FM_PCD_ACTION_INDEXED_LOOKUP the size of keySize has to be 2*/
     t_FmPcdCcKeyParams          keyParams[FM_PCD_MAX_NUM_OF_KEYS];
-                                                /**< it's array with numOfKeys entries each entry in
+                                                /**< it's array with 'numOfKeys' entries each entry in
                                                      the array of the type t_FmPcdCcKeyParams */
     t_FmPcdCcNextEngineParams   ccNextEngineParamsForMiss;
                                                 /**< parameters for the next step of
@@ -1490,6 +1519,10 @@ typedef struct t_FmPcdCcTreeParams {
                                                                              by FM_PCD_SetNetEnvCharacteristics() */
     uint8_t                 numOfGrps;                                  /**< Number of CC groups within the CC tree */
     t_FmPcdCcGrpParams      ccGrpParams[FM_PCD_MAX_NUM_OF_CC_GROUPS];   /**< Parameters for each group. */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    t_Handle                h_IpReassemblyManip;                        /**< IP Reassembly manipulation handle should be given
+                                                                             as a parameter to the tree */
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 } t_FmPcdCcTreeParams;
 
 /**************************************************************************//**
@@ -1563,7 +1596,7 @@ typedef struct t_FmPcdPlcrProfileParams {
     bool                                trapProfileOnFlowC;         /**< Trap on flow C */
 } t_FmPcdPlcrProfileParams;
 
-#if defined(FM_CAPWAP_SUPPORT)
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
  @Description   A structure for selecting the location of manipulation
 *//***************************************************************************/
@@ -1650,8 +1683,54 @@ typedef struct t_CapwapReassemblyParams {
 } t_CapwapReassemblyParams;
 #endif /* FM_CAPWAP_SUPPORT */
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+/**************************************************************************//**
+ @Description   structure for defining IP fragmentation
+*//***************************************************************************/
+typedef struct t_IpFragmentationParams {
+    uint16_t                    sizeForFragmentation;   /**< if length of the frame is greater than this value,
+                                                             IP fragmentation will be executed.*/
+    uint8_t                     scratchBpid;            /**< Absolute buffer pool id according to BM configuration.*/
+    e_FmPcdManipDontFragAction  dontFragAction;         /**< Don't Fragment Action - If an IP packet is larger
+                                                             than MTU and its DF bit is set, then this field will
+                                                             determine the action to be taken.*/
+} t_IpFragmentationParams;
+
+/**************************************************************************//**
+ @Description   structure for defining IP Re-assembly
+                This structure is a common structure for IPv4 and Ipv6 reassembly manipulation
+                together or separately. for using reassembly manipulation
+                for both IPv4 and IPv6, fill "HEADER_TYPE_IPv6" value in the hdr
+                filed at t_FmPcdManipFragOrReasmParams structure.
+*//***************************************************************************/
+typedef struct t_IpReassemblyParams {
+    uint8_t                         relativeSchemeId[2];    /**< Partition relative scheme id -
+                                                                 relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation.
+                                                                 relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation.
+                                                                 Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
+                                                                 the user schemes id to ensure that the reassembly's schemes will be first match.
+                                                                 Rest schemes, if defined, should have higher relative scheme ID */
+    uint16_t                        liodnOffset;            /**< LIODN offset. */
+    uint8_t                         dataMemId;              /**< Memory partition ID for data buffers */
+    uint16_t                        minFragSize[2];         /**< Minimum frag size.
+                                                                 minFragSize[0] - for ipv4
+                                                                 minFragSize[1] - for ipv6 */
+    uint16_t                        maxNumFramesInProcess;  /**< Number of frames which can be processed by Reassembly in the same time.
+                                                                 It has to be power of 2.
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 4 - 512,
+                                                                 In the case numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH,
+                                                                 maxNumFramesInProcess has to be in the range of 8 - 2048 */
+    e_FmPcdManipReassemTimeOutMode  timeOutMode;            /**< Expiration delay initialized by Reassembly process */
+    uint32_t                        fqidForTimeOutFrames;   /**< Fqid in which time out frames will enqueue during Time Out Process  */
+    e_FmPcdManipReassemWaysNumber   numOfFramesPerHashEntry;/**< Number of frames per hash entry needed for reassembly process */
+    uint32_t                        timeoutThresholdForReassmProcess;
+                                                            /**< Represents the time interval in microseconds which defines
+                                                                 if opened frame (at least one fragment was processed but not all the fragments)is found as too old*/
+} t_IpReassemblyParams;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
 
-#if defined(FM_CAPWAP_SUPPORT)
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
  @Description   structure for defining fragmentation/reassembly
 *//***************************************************************************/
@@ -1668,6 +1747,10 @@ typedef struct t_FmPcdManipFragOrReasmParams {
         t_CapwapFragmentationParams     capwapFragParams;   /**< Structure for CAPWAP fragmentation, relevant if frag = TRUE, hdr = HEADER_TYPE_CAPWAP */
         t_CapwapReassemblyParams        capwapReasmParams;  /**< Structure for CAPWAP reassembly, relevant if frag = FALSE, hdr = HEADER_TYPE_CAPWAP */
 #endif /* FM_CAPWAP_SUPPORT */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        t_IpFragmentationParams         ipFragParams;       /**< Structure for IP-fragmentation, relevant if frag = TRUE, hdr = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+        t_IpReassemblyParams            ipReasmParams;      /**< Structure for IP-reassembly, relevant if frag = FALSE, hdr = HEADER_TYPE_Ipv4 or HEADER_TYPE_Ipv6 */
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
     };
 } t_FmPcdManipFragOrReasmParams;
 
@@ -1808,6 +1891,7 @@ t_Handle FM_PCD_KgSetScheme (t_Handle                h_FmPcd,
  @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme
 
  @Return        E_OK on success; Error code otherwise.
+
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 t_Error     FM_PCD_KgDeleteScheme(t_Handle h_FmPcd, t_Handle h_Scheme);
@@ -1835,6 +1919,7 @@ uint32_t  FM_PCD_KgGetSchemeCounter(t_Handle h_FmPcd, t_Handle h_Scheme);
  @Param[in]     h_Scheme        scheme handle as returned by FM_PCD_KgSetScheme.
  @Param[in]     value           New scheme counter value - typically '0' for
                                 resetting the counter.
+
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PCD_Init().
@@ -1867,6 +1952,8 @@ t_Handle FM_PCD_CcBuildTree (t_Handle             h_FmPcd,
  @Param[in]     h_FmPcd         A handle to an FM PCD Module.
  @Param[in]     h_CcTree        A handle to a CC tree.
 
+ @Return        E_OK on success; Error code otherwise.
+
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 t_Error FM_PCD_CcDeleteTree(t_Handle h_FmPcd, t_Handle h_CcTree);
@@ -1896,6 +1983,8 @@ t_Handle   FM_PCD_CcSetNode(t_Handle             h_FmPcd,
  @Param[in]     h_FmPcd         A handle to an FM PCD Module.
  @Param[in]     h_CcNode        A handle to a CC node.
 
+ @Return        E_OK on success; Error code otherwise.
+
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode);
@@ -1915,7 +2004,11 @@ t_Error FM_PCD_CcDeleteNode(t_Handle h_FmPcd, t_Handle h_CcNode);
 
  @Cautions      Allowed only following FM_PCD_CcBuildTree().
 *//***************************************************************************/
-t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8_t grpId, uint8_t index, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle                  h_FmPcd,
+                                      t_Handle                  h_CcTree,
+                                      uint8_t                   grpId,
+                                      uint8_t                   index,
+                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
  @Function      FM_PCD_CcNodeModifyNextEngine
@@ -1931,7 +2024,10 @@ t_Error FM_PCD_CcTreeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcTree, uint8
 
  @Cautions      Allowed only following FM_PCD_CcSetNode().
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle                  h_FmPcd,
+                                      t_Handle                  h_CcNode,
+                                      uint16_t                   keyIndex,
+                                      t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
  @Function      FM_PCD_CcNodeModifyMissNextEngine
@@ -1946,7 +2042,9 @@ t_Error FM_PCD_CcNodeModifyNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8
 
  @Cautions      Allowed only following FM_PCD_CcSetNode().
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
+t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle                  h_FmPcd,
+                                          t_Handle                  h_CcNode,
+                                          t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
  @Function      FM_PCD_CcNodeRemoveKey
@@ -1959,65 +2057,136 @@ t_Error FM_PCD_CcNodeModifyMissNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, t
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevant node but also
-                the node that points to this node
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
+                relevant node but also the node that points to this node
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex);
+t_Error FM_PCD_CcNodeRemoveKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint16_t keyIndex);
 
 /**************************************************************************//**
  @Function      FM_PCD_CcNodeAddKey
 
- @Description   Add the key(include Next Engine Parameters of this key)in the index defined by the keyIndex .
+ @Description   Add the key(include Next Engine Parameters of this key in the
+                index defined by the keyIndex.
 
  @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcNode                    A handle to the node
  @Param[in]     keyIndex                    Key index for adding
  @Param[in]     keySize                     Key size of added key
- @Param[in]     p_KeyParams                 A pointer to the parameters includes new key with Next Engine Parameters
+ @Param[in]     p_KeyParams                 A pointer to the parameters includes
+                                            new key with Next Engine Parameters
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevant node but also
-                the node that points to this node
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
+                relevant node but also the node that points to this node
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeAddKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error FM_PCD_CcNodeAddKey(t_Handle            h_FmPcd,
+                            t_Handle            h_CcNode,
+                            uint16_t             keyIndex,
+                            uint8_t             keySize,
+                            t_FmPcdCcKeyParams  *p_KeyParams);
 
 /**************************************************************************//**
  @Function      FM_PCD_CcNodeModifyKeyAndNextEngine
 
- @Description   Modify the key and Next Engine Parameters of this key in the index defined by the keyIndex .
+ @Description   Modify the key and Next Engine Parameters of this key in the
+                index defined by the keyIndex.
 
  @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcNode                    A handle to the node
  @Param[in]     keyIndex                    Key index for adding
  @Param[in]     keySize                     Key size of added key
- @Param[in]     p_KeyParams                 A pointer to the parameters includes modified key and modified Next Engine Parameters
+ @Param[in]     p_KeyParams                 A pointer to the parameters includes
+                                            modified key and modified Next Engine Parameters
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevant node but also
-                the node that points to this node
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
+                relevant node but also the node that points to this node
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, t_FmPcdCcKeyParams  *p_KeyParams);
+t_Error FM_PCD_CcNodeModifyKeyAndNextEngine(t_Handle            h_FmPcd,
+                                            t_Handle            h_CcNode,
+                                            uint16_t             keyIndex,
+                                            uint8_t             keySize,
+                                            t_FmPcdCcKeyParams  *p_KeyParams);
 
 /**************************************************************************//**
  @Function      FM_PCD_CcNodeModifyKey
 
- @Description   Modify the key  in the index defined by the keyIndex .
+ @Description   Modify the key  in the index defined by the keyIndex.
 
  @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
  @Param[in]     h_CcNode                    A handle to the node
  @Param[in]     keyIndex                    Key index for adding
  @Param[in]     keySize                     Key size of added key
  @Param[in]     p_Key                       A pointer to the new key
- @Param[in]     p_Mask                      A pointer to the new mask if relevant, otherwise pointer to NULL
+ @Param[in]     p_Mask                      A pointer to the new mask if relevant,
+                                            otherwise pointer to NULL
 
  @Return        E_OK on success; Error code otherwise.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevant node but also
-                the node that points to this node
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
+                relevant node but also the node that points to this node
 *//***************************************************************************/
-t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex, uint8_t keySize, uint8_t  *p_Key, uint8_t *p_Mask);
+t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd,
+                               t_Handle h_CcNode,
+                               uint16_t  keyIndex,
+                               uint8_t  keySize,
+                               uint8_t  *p_Key,
+                               uint8_t  *p_Mask);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcIndexedHashNodeGetBucket
+
+ @Description   TODO
+
+ @Param[in]     h_FmPcd                 A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                A handle to the node
+ @Param[in]     kgKeySize               Key size as it was configured in the KG
+                                        scheme that leads to this hash.
+ @Param[in]     p_KgKey                 Pointer to the key; must be like the key
+                                        that the KG is generated, i.e. the same
+                                        extraction and with mask if exist.
+ @Param[in]     kgHashShift             hash-shift as it was configured in the KG
+                                        scheme that leads to this hash.
+ @Param[out]    p_CcNodeBucketHandle    Pointer to retrieve the bucket.
+ @Param[out]    p_BucketIndex           TODO
+ @Param[out]    p_LastIndex             Pointer to retrieve the last index in the bucket.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
+                relevant node but also the node that points to this node
+*//***************************************************************************/
+t_Error FM_PCD_CcIndexedHashNodeGetBucket(t_Handle    h_FmPcd,
+                                          t_Handle    h_CcNode,
+                                          uint8_t     kgKeySize,
+                                          uint8_t     *p_KgKey,
+                                          uint8_t     kgHashShift,
+                                          t_Handle    *p_CcNodeBucketHandle,
+                                          uint8_t     *p_BucketIndex,
+                                          uint16_t    *p_LastIndex);
+
+/**************************************************************************//**
+ @Function      FM_PCD_CcNodeGetNextEngine
+
+ @Description   Gets NextEngine of the relevant keyIndex.
+
+ @Param[in]     h_FmPcd                     A handle to an FM PCD Module.
+ @Param[in]     h_CcNode                    Cc Node.
+ @Param[in]     keyIndex                    keyIndex in the releavnt node.
+ @Param[out]    p_FmPcdCcNextEngineParams   here updated nextEngine parameters for
+                                            the relevant keyIndex of the Cc Node
+                                            received as parameter to this function
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+t_Error FM_PCD_CcNodeGetNextEngine(t_Handle                     h_FmPcd,
+                                   t_Handle                     h_CcNode,
+                                   uint16_t                      keyIndex,
+                                   t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
 
 /**************************************************************************//**
  @Function      FM_PCD_CcNodeGetKeyCounter
@@ -2032,8 +2201,8 @@ t_Error FM_PCD_CcNodeModifyKey(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyI
 
  @Return        The specific key counter.
 
- @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the relevant node but also
-                the node that points to this node
+ @Cautions      Allowed only following FM_PCD_CcSetNode() not only of the
+                relevant node but also the node that points to this node
 *//***************************************************************************/
 uint32_t FM_PCD_CcNodeGetKeyCounter(t_Handle h_FmPcd, t_Handle h_CcNode, uint8_t keyIndex);
 
@@ -2075,15 +2244,17 @@ t_Error FM_PCD_PlcrDeleteProfile(t_Handle h_FmPcd, t_Handle h_Profile);
  @Description   Sets an entry in the classification plan.
                 The routine overrides any existing value.
 
- @Param[in]     h_FmPcd             A handle to an FM PCD Module.
+ @Param[in]     h_FmPcd         A handle to an FM PCD Module.
  @Param[in]     h_Profile       A handle to the profile.
- @Param[in]     counter             Counter selector.
+ @Param[in]     counter         Counter selector.
 
  @Return        specific counter value.
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter);
+uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle                      h_FmPcd,
+                                      t_Handle                      h_Profile,
+                                      e_FmPcdPlcrProfileCounters    counter);
 
 /**************************************************************************//**
  @Function      FM_PCD_PlcrSetProfileCounter
@@ -2100,9 +2271,12 @@ uint32_t FM_PCD_PlcrGetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_Fm
 
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
-t_Error FM_PCD_PlcrSetProfileCounter(t_Handle h_FmPcd, t_Handle h_Profile, e_FmPcdPlcrProfileCounters counter, uint32_t value);
+t_Error FM_PCD_PlcrSetProfileCounter(t_Handle                   h_FmPcd,
+                                     t_Handle                   h_Profile,
+                                     e_FmPcdPlcrProfileCounters counter,
+                                     uint32_t                   value);
 
-#if defined(FM_CAPWAP_SUPPORT)
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
 /**************************************************************************//**
  @Function      FM_PCD_ManipSetNode
 
@@ -2127,12 +2301,13 @@ t_Handle FM_PCD_ManipSetNode(t_Handle h_FmPcd, t_FmPcdManipParams *p_FmPcdManipP
  @Param[in]     h_FmPcd         A handle to an FM PCD Module.
  @Param[in]     h_HdrManipNode  A handle to a Manip node.
 
+ @Return        E_OK on success; Error code otherwise.
+
  @Cautions      Allowed only following FM_PCD_Init().
 *//***************************************************************************/
 t_Error  FM_PCD_ManipDeleteNode(t_Handle h_FmPcd, t_Handle h_HdrManipNode);
 #endif /* defined(FM_CAPWAP_SUPPORT) || ... */
 
-
 #ifdef FM_CAPWAP_SUPPORT
 /**************************************************************************//**
  @Function      FM_PCD_StatisticsSetNode
@@ -2155,6 +2330,4 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_FmPcds
 /** @} */ /* end of FM_PCD_grp group */
 /** @} */ /* end of FM_grp group */
 
-
-
 #endif /* __FM_PCD_EXT */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index d1df4ea..443286c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -87,20 +87,22 @@
                 frame headers and payload.
 *//***************************************************************************/
 typedef enum e_FmPortPcdSupport {
-    e_FM_PORT_PCD_SUPPORT_NONE = 0,             /**< BMI to BMI, PCD is not used */
-    e_FM_PORT_PCD_SUPPORT_PRS_ONLY,             /**< Use only Parser */
-    e_FM_PORT_PCD_SUPPORT_PLCR_ONLY,            /**< Use only Policer */
-    e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR,         /**< Use Parser and Policer */
-    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG,           /**< Use Parser and Keygen */
-    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC,    /**< Use Parser, Keygen and Coarse Classification */
-    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR,
-                                                /**< Use all PCD engines */
-    e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR   /**< Use Parser, Keygen and Policer */
+      e_FM_PORT_PCD_SUPPORT_NONE = 0                /**< BMI to BMI, PCD is not used */
+    , e_FM_PORT_PCD_SUPPORT_PRS_ONLY                /**< Use only Parser */
+    , e_FM_PORT_PCD_SUPPORT_PLCR_ONLY               /**< Use only Policer */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR            /**< Use Parser and Policer */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG              /**< Use Parser and Keygen */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC       /**< Use Parser, Keygen and Coarse Classification */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR
+                                                    /**< Use all PCD engines */
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR     /**< Use Parser, Keygen and Policer */
+#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+    , e_FM_PORT_PCD_SUPPORT_PRS_AND_CC              /**< Use Parser and Coarse Classification */
+#endif /* defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
 #ifdef FM_CAPWAP_SUPPORT
-    ,
-    e_FM_PORT_PCD_SUPPORT_CC_ONLY,              /**< Use only Coarse Classification */
-    e_FM_PORT_PCD_SUPPORT_CC_AND_KG,            /**< Use Coarse Classification,and Keygen */
-    e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR    /**< Use Coarse Classification, Keygen and Policer */
+    , e_FM_PORT_PCD_SUPPORT_CC_ONLY                 /**< Use only Coarse Classification */
+    , e_FM_PORT_PCD_SUPPORT_CC_AND_KG               /**< Use Coarse Classification,and Keygen */
+    , e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR      /**< Use Coarse Classification, Keygen and Policer */
 #endif /* FM_CAPWAP_SUPPORT */
 } e_FmPortPcdSupport;
 
@@ -126,10 +128,20 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 #define FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT              0x04000000  /**< Offline parsing only! Unsupported Format */
 #define FM_PORT_FRM_ERR_LENGTH                          0x02000000  /**< Offline parsing only! Length Error */
 #define FM_PORT_FRM_ERR_DMA                             0x01000000  /**< DMA Data error */
-#ifdef FM_CAPWAP_SUPPORT
+#ifdef FM_DISABLE_SEC_ERRORS
 #define FM_PORT_FRM_ERR_NON_FM                          0x00400000  /**< non Frame-Manager error; probably come from SEC that
                                                                          was chained to FM */
+#endif /* FM_DISABLE_SEC_ERRORS */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+#define FM_PORT_FRM_ERR_IPRE                            0x00200000
+#define FM_PORT_FRM_ERR_IPFE                            0x00100000
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
+#ifdef FM_CAPWAP_SUPPORT
+#define FM_PORT_FRM_ERR_CRE                             0x00200000
+#define FM_PORT_FRM_ERR_CHE                             0x00100000
 #endif /* FM_CAPWAP_SUPPORT */
+
 #define FM_PORT_FRM_ERR_PHYSICAL                        0x00080000  /**< Rx FIFO overflow, FCS error, code error, running disparity
                                                                          error (SGMII and TBI modes), FIFO parity error. PHY
                                                                          Sequence error, PHY error control character detected. */
@@ -249,9 +261,6 @@ typedef struct t_FmPortNonRxParams {
                                                      frames. For OP - default Rx queue. */
     uint32_t                qmChannel;          /**< QM-channel dedicated to this port; will be used
                                                      by the FM for dequeue. */
-#ifdef FM_OP_PARTITION_ERRATA_FMANx8
-    uint16_t                opLiodnOffset;      /**< For Offline Parsing ports only. Port's LIODN offset. */
-#endif  /* FM_OP_PARTITION_ERRATA_FMANx8 */
 } t_FmPortNonRxParams;
 
 /**************************************************************************//**
@@ -492,10 +501,7 @@ typedef struct t_FmPortBufferPrefixContent {
     uint16_t    dataAlign;          /**< 0 to use driver's default alignment, other value
                                          for selecting a data alignment (must be a
                                          power of 2) */
-#ifdef DEBUG
-    bool        passDebugInfo;      /**< Debug-information */
-#endif /* DEBUG */
-#ifdef FM_CAPWAP_SUPPORT
+#if (defined(FM_IP_FRAG_N_REASSEM_SUPPORT) || defined(FM_CAPWAP_SUPPORT))
     uint8_t     manipExtraSpace;    /**< Maximum extra size needed (insertion-size minus removal-size) */
 #endif /* FM_CAPWAP_SUPPORT */
 } t_FmPortBufferPrefixContent;
@@ -516,11 +522,66 @@ typedef struct t_FmPortBackupBmPools {
 
 
 /**************************************************************************//**
+ @Function      FM_PORT_ConfigNumOfOpenDmas
+
+ @Description   Calling this routine changes the max number of open DMA's
+                available for this port. It changes this parameter in the
+                internal driver data base from its default configuration
+                [type]
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_OpenDmas  A pointer to a structure of parameters defining
+                            the open DMA allocation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_OpenDmas);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigNumOfTasks
+
+ @Description   Calling this routine changes the max number of tasks
+                available for this port. It changes this parameter in the
+                internal driver data base from its default configuration
+                [type]
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_OpenDmas  A pointer to a structure of parameters defining
+                            the tasks allocation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
+
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigSizeOfFifo
+
+ @Description   Calling this routine changes the max FIFO size
+                available for this port. It changes this parameter in the
+                internal driver data base from its default configuration
+                [DEFAULT_PORT_sizeOfFifo]
+
+ @Param[in]     h_FmPort    A handle to a FM Port module.
+ @Param[in]     p_OpenDmas  A pointer to a structure of parameters defining
+                            the FIFO allocation.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_ConfigSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
+
+/**************************************************************************//**
  @Function      FM_PORT_ConfigDeqHighPriority
 
  @Description   Calling this routine changes the dequeue priority in the
                 internal driver data base from its default configuration
-                [TRUE]
+                1G: [FALSE]
+                10G: [TRUE]
 
                 May be used for Non-Rx ports only
 
@@ -576,7 +637,9 @@ t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOp
  @Function      FM_PORT_ConfigDeqByteCnt
 
  @Description   Calling this routine changes the dequeue byte count parameter in
-                the internal driver data base from its default configuration [2000].
+                the internal driver data base from its default configuration
+                1G:[0x400].
+                10G:[0x1400].
 
                 May be used for Non-Rx ports only
 
@@ -613,8 +676,8 @@ t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLeve
  @Description   Calling this routine changes the fifo dequeue
                 pipeline depth parameter in the internal driver data base
 
-                from its default configuration: 1G ports: [2],
-                10G port: [8]
+                from its default configuration: 1G ports: [1],
+                10G port: [4]
 
                 May be used for Tx ports only
 
@@ -721,7 +784,8 @@ t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priEle
 
  @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
 *//***************************************************************************/
-t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle h_FmPort, t_FmPortBufferPrefixContent *p_FmPortBufferPrefixContent);
+t_Error FM_PORT_ConfigBufferPrefixContent(t_Handle                      h_FmPort,
+                                          t_FmPortBufferPrefixContent   *p_FmPortBufferPrefixContent);
 
 
 /**************************************************************************//**
@@ -854,7 +918,7 @@ t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmPortBackupBmPools *p_Fm
                 May be used for Rx and offline parsing ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
- @Param[in]     override    TRUE to override dicarding of error frames and
+ @Param[in]     override    TRUE to override discarding of error frames and
                             enqueueing them to error queue.
 
  @Return        E_OK on success; Error code otherwise.
@@ -1145,6 +1209,24 @@ t_Error  FM_PORT_ConfigIMFmanCtrlExternalStructsMemory(t_Handle h_FmPort,
 *//***************************************************************************/
 t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
 
+/**************************************************************************//**
+ @Function      FM_PORT_ConfigMaxFrameLength
+
+ @Description   Changes the definition of the max size of frame that should be
+                transmitted/received on this port from its default value [9600].
+                This parameter is used for minimum Fifo size calculations and
+                only for Tx ports or ports working in independent mode.
+
+ @Param[in]     h_FmPort        A handle to a FM Port module.
+                length          Max size of frame
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Config() and before FM_PORT_Init().
+                This routine is to be used only if Independent-Mode is enabled.
+*//***************************************************************************/
+t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
+
 /** @} */ /* end of FM_PORT_advanced_init_grp group */
 /** @} */ /* end of FM_PORT_init_grp group */
 
@@ -1198,6 +1280,24 @@ typedef struct t_FmPortCongestionGrps {
                                                              describing the groups */
 } t_FmPortCongestionGrps;
 
+#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+/**************************************************************************//**
+ @Collection   FM OP PORT Workarounds
+*//***************************************************************************/
+typedef uint32_t    fmOpPortWorkaroundsSelect_t;                    /**< typedef for defining port workarounds */
+#endif /* defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
+
+#ifdef FM_IPSEC_SUPPORT
+#define FM_OP_PORT_WA_SEC_ERR                           0x80000000  /**< TODO */
+#define FM_OP_PORT_WA_DISABLE_UDP_CKSM                  0x40000000  /**< TODO */
+#define FM_OP_PORT_WA_ETH_TYPE                          0x20000000  /**< TODO */
+#define FM_OP_PORT_WA_UPDATE_UDP_LEN                    0x08000000  /**< TODO */
+#endif /* FM_IPSEC_SUPPORT */
+#ifdef FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
+#define FM_OP_PORT_WA_COPY_CTXB                         0x10000000  /**< Offline port workaround - copy 9 bits from
+                                                                         contextB to flow-id location*/
+#endif /* FM_NO_CTXA_COPY_ERRATA_FMAN_SW001 */
+/* @} */
 
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -1237,7 +1337,7 @@ uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
  @Description   Returns the Internal Context offset from the beginning of the data buffer
 
  @Param[in]     h_FmPort - FM PORT module descriptor
- @Param[in]     p_Data      - A pointer to the data buffer.
+ @Param[in]     p_Data   - A pointer to the data buffer.
 
  @Return        Internal context info pointer on success, NULL if 'allOtherInfo' was not
                 configured for this port.
@@ -1246,23 +1346,6 @@ uint32_t FM_PORT_GetBufferDataOffset(t_Handle h_FmPort);
 *//***************************************************************************/
 uint8_t * FM_PORT_GetBufferICInfo(t_Handle h_FmPort, char *p_Data);
 
-#ifdef DEBUG
-/**************************************************************************//**
- @Function      FM_PORT_GetBufferDebugInfo
-
- @Description   Returns the debug info offset from the beginning of the data buffer
-
- @Param[in]     h_FmPort - FM PORT module descriptor
- @Param[in]     p_Data      - A pointer to the data buffer.
-
- @Return        Debug info pointer on success, NULL if 'passDebugInfo' was not
-                configured for this port.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-uint8_t * FM_PORT_GetBufferDebugInfo(t_Handle h_FmPort, char *p_Data);
-#endif /* DEBUG */
-
 /**************************************************************************//**
  @Function      FM_PORT_GetBufferPrsResult
 
@@ -1472,58 +1555,6 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
 *//***************************************************************************/
 t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort);
 
-/**************************************************************************//**
- @Function      FM_PORT_SetNumOfOpenDmas
-
- @Description   Calling this routine updates the number of open DMA requested for
-                this port.
-
-
-                May be used for all port types.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     p_NumOfOpenDmas     A structure of resource requested parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDmas);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetNumOfTasks
-
- @Description   Calling this routine updates the number of tasks requested for
-                this port.
-
-                May be used for all port types.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     p_NumOfTasks        A structure of resource requested parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
-
-/**************************************************************************//**
- @Function      FM_PORT_SetSizeOfFifo
-
- @Description   Calling this routine updates the Fifo size resource requested for
-                this port.
-
-                May be used for all port types - note that only Rx has 'extra'
-                fifo size. For other ports 'extra' field must be disabled.
-
- @Param[in]     h_FmPort            A handle to a FM Port module.
- @Param[in]     p_SizeOfFifo        A structure of resource requested parameters
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_PORT_Init().
-*//***************************************************************************/
-t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo);
 
 /**************************************************************************//**
  @Function      FM_PORT_SetAllocBufCounter
@@ -1734,6 +1765,21 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
 *//***************************************************************************/
 t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
 
+#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+/**************************************************************************//**
+ @Function      FM_PORT_SetOpWorkarounds
+
+ @Description   Calling this routine sets the required offline port workaround.
+
+ @Param[in]     h_FmPort        FM PORT module descriptor.
+ @Param[in]     workarounds)    Reuired workaround.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+t_Error FM_PORT_SetOpWorkarounds(t_Handle h_FmPort, fmOpPortWorkaroundsSelect_t workarounds);
+#endif /* defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
 
 
 /**************************************************************************//**
@@ -1752,9 +1798,9 @@ t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception,
 
 *//***************************************************************************/
 typedef struct t_FmPcdKgSchemeSelect {
-    bool        direct;                 /**< TRUE to use 'h_Scheme' directly, FALSE to use LCV.*/
-    t_Handle    h_DirectScheme;         /**< Relevant for 'direct'=TRUE only.
-                                             'h_DirectScheme' selects the scheme after parser. */
+    bool        direct;                 /**< TRUE to use 'h_Scheme' directly, FALSE to use LCV. */
+    t_Handle    h_DirectScheme;         /**< Scheme handle, selects the scheme after parser;
+                                             Relevant only when 'direct' is TRUE. */
 } t_FmPcdKgSchemeSelect;
 
 /**************************************************************************//**
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
index 8827d2a..e891df1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_rtc_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -540,7 +540,7 @@ t_Error FM_RTC_GetCurrentTime(t_Handle h_FmRtc, uint64_t *p_Ts);
  @Cautions      h_FmRtc must have been previously initialized using FM_RTC_Init().
 *//***************************************************************************/
 t_Error FM_RTC_SetCurrentTime(t_Handle h_FmRtc, uint64_t ts);
- 
+
 /**************************************************************************//**
  @Function      FM_RTC_GetFreqCompensation
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
index 5291866..6cee3a3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/mii_acc_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
index 022de2b..8130c73 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/core_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
index df545ff..26c2641 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/e500v2_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
index e045c31..bccd1b8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/cores/ppc_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
index fd9fd62..13dfb71 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ctype_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
index 37f5b83..2331a43 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -185,19 +185,20 @@
 *//***************************************************************************/
 #define DUMP_VAR(st, phrase) \
     do { \
-        void *addr = (void *)&((st)->phrase); \
+        void            *addr = (void *)&((st)->phrase); \
+        physAddress_t   physAddr = XX_VirtToPhys(addr); \
         _CREATE_DUMP_SUBSTR(phrase); \
         dumpVarSize = sizeof((st)->phrase); \
         switch (dumpVarSize) \
         { \
-            case 1:  DUMP_Print("0x%08X: 0x%02x%14s\t%s\r\n", \
-                                addr, GET_UINT8(*(uint8_t*)addr), "", dumpSubStr); break; \
-            case 2:  DUMP_Print("0x%08X: 0x%04x%12s\t%s\r\n", \
-                                addr, GET_UINT16(*(uint16_t*)addr), "", dumpSubStr); break; \
-            case 4:  DUMP_Print("0x%08X: 0x%08x%8s\t%s\r\n", \
-                                addr, GET_UINT32(*(uint32_t*)addr), "", dumpSubStr); break; \
-            case 8:  DUMP_Print("0x%08X: 0x%016llx\t%s\r\n", \
-                                addr, GET_UINT64(*(uint64_t*)addr), dumpSubStr); break; \
+            case 1:  DUMP_Print("0x%010llX: 0x%02x%14s\t%s\r\n", \
+                                physAddr, GET_UINT8(*(uint8_t*)addr), "", dumpSubStr); break; \
+            case 2:  DUMP_Print("0x%010llX: 0x%04x%12s\t%s\r\n", \
+                                physAddr, GET_UINT16(*(uint16_t*)addr), "", dumpSubStr); break; \
+            case 4:  DUMP_Print("0x%010llX: 0x%08x%8s\t%s\r\n", \
+                                physAddr, GET_UINT32(*(uint32_t*)addr), "", dumpSubStr); break; \
+            case 8:  DUMP_Print("0x%010llX: 0x%016llx\t%s\r\n", \
+                                physAddr, GET_UINT64(*(uint64_t*)addr), dumpSubStr); break; \
             default: DUMP_Print("Bad size %d (" #st "->" #phrase ")\r\n", dumpVarSize); \
         } \
     } while (0)
@@ -218,6 +219,7 @@
 *//***************************************************************************/
 #define DUMP_ARR(st, phrase) \
     do { \
+        physAddress_t physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
         _CREATE_DUMP_SUBSTR(phrase); \
         dumpArrSize = ARRAY_SIZE((st)->phrase); \
         dumpVarSize = sizeof((st)->phrase[0]); \
@@ -225,23 +227,23 @@
         { \
             case 1: \
                 for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    DUMP_Print("0x%08X: 0x%02x%14s\t%s[%d]\r\n", \
-                               &((st)->phrase[dumpArrIdx]), GET_UINT8((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                    DUMP_Print("0x%010llX: 0x%02x%14s\t%s[%d]\r\n", \
+                               physAddr, GET_UINT8((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
                 } break; \
             case 2: \
                 for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    DUMP_Print("0x%08X: 0x%04x%12s\t%s[%d]\r\n", \
-                               &((st)->phrase[dumpArrIdx]), GET_UINT16((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                    DUMP_Print("0x%010llX: 0x%04x%12s\t%s[%d]\r\n", \
+                               physAddr, GET_UINT16((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
                 } break; \
             case 4: \
                 for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    DUMP_Print("0x%08X: 0x%08x%8s\t%s[%d]\r\n", \
-                               &((st)->phrase[dumpArrIdx]), GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
+                    DUMP_Print("0x%010llX: 0x%08x%8s\t%s[%d]\r\n", \
+                               physAddr, GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
                 } break; \
             case 8: \
                 for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    DUMP_Print("0x%08X: 0x%016llx\t%s[%d]\r\n", \
-                               &((st)->phrase[dumpArrIdx]), GET_UINT64((st)->phrase[dumpArrIdx]), dumpSubStr, dumpArrIdx); \
+                    DUMP_Print("0x%010llX: 0x%016llx\t%s[%d]\r\n", \
+                               physAddr, GET_UINT64((st)->phrase[dumpArrIdx]), dumpSubStr, dumpArrIdx); \
                 } break; \
             default: DUMP_Print("Bad size %d (" #st "->" #phrase "[0])\r\n", dumpVarSize); \
         } \
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
index 7084e82..93ce535 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/endian_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
index 14f7760..d432ef1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
index 778ba30..13bad9c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
index 4418c80..cdcac00 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
index 16592d5..94a9823 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -258,7 +258,7 @@ uint32_t MEM_ComputePartitionSize(uint32_t num,
                                   uint16_t alignment);
 
 #ifdef DEBUG_MEM_LEAKS
-#if !(defined(__MWERKS__) && (__dest_os == __ppc_eabi))
+#if !((defined(__MWERKS__) || defined(__GNUC__)) && (__dest_os == __ppc_eabi))
 #error  "Memory-Leaks-Debug option is supported only for freescale CodeWarrior"
 #endif /* !(defined(__MWERKS__) && ... */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
index e50c8a9..d8ab46e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
index 030f877..01e71e6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mm_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
index 2fc5d63..09a4b4f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
index 79edb18..4ac4752 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -65,7 +65,7 @@ typedef enum {
 #define QM_MAX_NUM_OF_WQ            8
 #define QM_MAX_NUM_OF_SWP_AS        2
 #define QM_MAX_NUM_OF_CGS           64
-#define QM_MAX_NUM_OF_FQIDS           (16*MEGABYTE)
+#define QM_MAX_NUM_OF_FQIDS         (16*MEGABYTE)
 
 typedef enum {
     e_QM_FQ_CHANNEL_SWPORTAL0 = 0,
@@ -94,6 +94,12 @@ typedef enum {
 #define BM_MAX_NUM_OF_POOLS         8
 
 /*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SEC_NUM_OF_DECOS    2
+#define SEC_ALL_DECOS_MASK  0x00000003
+
+/*****************************************************************************
  FM INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
 #define INTG_MAX_NUM_OF_FM          1
@@ -111,10 +117,9 @@ typedef enum {
 #define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
 #define FM_MAX_NUM_OF_MACSECS       1
 
-#if 0
-#define FM_MACSEC_SUPPORT
-#define FM_CAPWAP_SUPPORT
-#endif
+/*#define FM_MACSEC_SUPPORT*/
+/*#define FM_CAPWAP_SUPPORT*/
+#define FM_DISABLE_SEC_ERRORS
 
 #define FM_LOW_END_RESTRICTION      /* prevents the use of TX port 1 with OP port 0 */
 
@@ -302,27 +307,14 @@ typedef enum e_FmMacsecInterModuleEvent {
 #define FM_PEDANTIC_DMA
 
 /* FM erratas */
-#define FM_NO_RX_PREAM_ERRATA_DTSECx1
-#define FM_RX_PREAM_4_ERRATA_DTSEC_A001                 FM_NO_RX_PREAM_ERRATA_DTSECx1
+#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
 #define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2      /* No implementation, Out of LLD scope */
 
-#define FM_IM_TX_SYNC_SKIP_TNUM_ERRATA_FMAN_A001        /* Implemented by ucode */
-#define FM_HC_DEF_FQID_ONLY_ERRATA_FMAN_A003            /* Implemented by ucode */
-#define FM_IM_TX_SHARED_TNUM_ERRATA_FMAN4               /* Implemented by ucode */
-#define FM_IM_GS_DEADLOCK_ERRATA_FMAN5                  /* Implemented by ucode */
-#define FM_IM_DEQ_PIPELINE_DEPTH_ERRATA_FMAN10          /* Implemented by ucode */
-#define FM_CC_GEN6_MISSMATCH_ERRATA_FMAN12              /* Implemented by ucode */
-#define FM_CC_CHANGE_SHARED_TNUM_ERRATA_FMAN13          /* Implemented by ucode */
-#define FM_IM_LARGE_MRBLR_ERRATA_FMAN15                 /* Implemented by ucode */
+#define FM_DEBUG_TRACE_FMAN_A004                        /* No implementation, Out of LLD scope */
+#define FM_INT_BUF_LEAK_FMAN_A005                       /* No implementation, Out of LLD scope. App must avoid S/G */
 
 /* #define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
 
-/* ??? */
-#define FM_GRS_ERRATA_DTSEC_A002
-#define FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
-#define FM_GTS_ERRATA_DTSEC_A004
-#define FM_TX_LOCKUP_ERRATA_DTSEC6
-
 #define FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
 
 #endif /* __FM_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_ext.h
index bb8b054..9e7c385 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
 
  @File          part_ext.h
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
index 4f92dcd..7176900 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -54,7 +54,7 @@
  @{
 *//***************************************************************************/
 
-#define INTG_MAX_NUM_OF_CORES   1
+#define INTG_MAX_NUM_OF_CORES   2
 
 
 /**************************************************************************//**
@@ -275,8 +275,10 @@ typedef enum e_P1023DeviceName
     e_SC1023_REV_1_1        = (int)0x80FC0011,  /**< SC1023 rev 1.1 */
     e_P1023_REV_1_0         = (int)0x80FE0010,  /**< P1023 rev 1.0 with security */
     e_P1023_REV_1_1         = (int)0x80FE0011,  /**< P1023 rev 1.1 with security */
+    e_P1017_REV_1_1         = (int)0x80FF0011,  /**< P1017 rev 1.1 with security */
     e_P1023_REV_1_0_NO_SEC  = (int)0x80F60010,  /**< P1023 rev 1.0 without security */
-    e_P1023_REV_1_1_NO_SEC  = (int)0x80F60011   /**< P1023 rev 1.1 without security */
+    e_P1023_REV_1_1_NO_SEC  = (int)0x80F60011,  /**< P1023 rev 1.1 without security */
+    e_P1017_REV_1_1_NO_SEC  = (int)0x80F70011   /**< P1017 rev 1.1 without security */
 } e_P1023DeviceName;
 
 /**************************************************************************//**
@@ -437,7 +439,7 @@ t_Error P1023_GetDdrType(uintptr_t gutilBase, e_DdrType *p_DdrType );
 #define MODULE_I2C              0x001d0000
 #define MODULE_ESPI             0x001e0000
 #define MODULE_PCI              0x001f0000
-#define MODULE_DPA              0x00200000
+#define MODULE_DPA_PORT         0x00200000
 #define MODULE_USB              0x00210000
 
 /*****************************************************************************
@@ -532,7 +534,7 @@ typedef enum e_PciTargetInterface
 /*****************************************************************************
  DMA INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-#define DMA_NUM_OF_CONTROLLERS      1
+#define DMA_NUM_OF_CONTROLLERS      2
 
 
 
@@ -568,29 +570,6 @@ uint32_t P1023_GetMuxControlReg(uintptr_t gutilBase);
 void P1023_SetMuxControlReg(uintptr_t gutilBase, uint32_t val);
 
 /**************************************************************************//**
- @Function      P1023_GetPowerMngClkDisableReg
-
- @Description   Returns the value of PMCDR (Power Management Clock Disable Register)
-
- @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
-
- @Return        Value of PMCDR
-*//***************************************************************************/
-uint32_t P1023_GetPowerMngClkDisableReg(uintptr_t gutilBase);
-
-/**************************************************************************//**
- @Function      P1023_SetPowerMngClkDisableReg
-
- @Description   Sets the value of PMCDR ((Power Management Clock Disable Register))
-
- @Param[in]     gutilBase   - Base address of P1023 GUTIL registers.
- @Param[in]     val         - the new value for PMCDR.
-
- @Return        None
-*//***************************************************************************/
-void P1023_SetPowerMngClkDisableReg(uintptr_t gutilBase, uint32_t val);
-
-/**************************************************************************//**
  @Function      P1023_GetDeviceDisableStatusRegister
 
  @Description   Returns the value of DEVDISR (Device Disable Register)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index 8fcf526..f18417e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -34,7 +34,7 @@
 
  @File          dpaa_integration_ext.h
 
- @Description   P4080 FM external definitions and structures.
+ @Description   P3040/P4080/P5020 FM external definitions and structures.
 *//***************************************************************************/
 #ifndef __DPAA_INTEGRATION_EXT_H
 #define __DPAA_INTEGRATION_EXT_H
@@ -71,23 +71,11 @@ typedef enum {
 /*****************************************************************************
  QMan INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-#define QMAN_PM_DCP_COUNTERS_ERRATA_QMAN1
-#define QMAN_FQD_AVOID_BLK_ERRATA_QMAN2
-#define QMAN_DBG_TRC_EV_ERRATA_QMAN3
-#define QMAN_WQ_CS_CFG_ERRATA_QMAN4
-#define QMAN_SFDR_LEAK_ERRATA_QMAN5
-#define QMAN_FQ_TD_THRESH_ERRATA_QMAN6
-#define QMAN_FQ_INIT_ON_PARKED_ERRATA_QMAN7
-#define QMAN_NESN_ORR_ERRATA_QMAN8
-#define QMAN_ERN_REJ_CODE6_ERRATA_QMAN9
-#define QMAN_ERN_MOULTI_CORE_ERRATA_QMAN10
-#define QMAN_PERFMON_FOR_DCP_FQD_ERRATA_QMAN11
-
-#define QM_MAX_NUM_OF_POOL_CHANNELS 15
-#define QM_MAX_NUM_OF_WQ            8
-#define QM_MAX_NUM_OF_SWP_AS        4
-#define QM_MAX_NUM_OF_CGS           256
-#define QM_MAX_NUM_OF_FQIDS           (16*MEGABYTE)
+#define QM_MAX_NUM_OF_POOL_CHANNELS     15      /**< Total number of channels, dedicated and pool */
+#define QM_MAX_NUM_OF_WQ                8       /**< Number of work queues per channel */
+#define QM_MAX_NUM_OF_CGS               256     /**< Congestion groups number */
+#define QM_MAX_NUM_OF_FQIDS             (16 * MEGABYTE)
+                                                /**< FQIDs range - 24 bits */
 
 /**************************************************************************//**
  @Description   Work Queue Channel assignments in QMan.
@@ -154,6 +142,8 @@ typedef enum
 
     e_QM_FQ_CHANNEL_PME = 0xA0,                 /**< Dedicated channel serviced by Direct Connect Portal 3:
                                                      connected to PME */
+    e_QM_FQ_CHANNEL_RAID = 0xC0                 /**< Dedicated channel serviced by Direct Connect Portal 4:
+                                                     connected to RAID */
 } e_QmFQChannel;
 
 /* p4080-rev1 unique features */
@@ -162,16 +152,15 @@ typedef enum
 /*****************************************************************************
  BMan INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-#define BM_MAX_NUM_OF_POOLS         64
+#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffer pools */
+
 
 /*****************************************************************************
  SEC INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
-/* SEC erratas */
-#ifdef UNDER_CONSTRUCTION_IPSEC
-#define SEC_IPV6_UDP_CHECKSUM_UPDATE
-#define SEC_UDP_LENGTH_UPDATE
-#endif /* UNDER_CONSTRUCTION_IPSEC */
+#define SEC_NUM_OF_DECOS    5
+#define SEC_ALL_DECOS_MASK  0x0000001F
+
 
 /*****************************************************************************
  FM INTEGRATION-SPECIFIC DEFINITIONS
@@ -196,9 +185,12 @@ typedef enum
 #define FM_MAX_NUM_OF_SUB_PORTALS               12
 #define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
 
-/* RAMs defines */
-#define FM_MURAM_SIZE                   (160 * KILOBYTE)
-#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
+#define FM_IPSEC_SUPPORT
+#define FM_IP_FRAG_N_REASSEM_SUPPORT
+
+/* Rams defines */
+#define FM_MURAM_SIZE                   (160*KILOBYTE)
+#define FM_IRAM_SIZE                    (64*KILOBYTE)
 
 /* PCD defines */
 #define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
@@ -228,11 +220,6 @@ typedef enum
 #define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
 #define PORT_MAX_WEIGHT                 16
 
-#ifdef UNDER_CONSTRUCTION_FRAG_REASSEMBLY
-/* Reassembly defines */
-#define FM_MAX_NUM_OF_REASSEMBLY_PORTS  4
-#endif /* UNDER_CONSTRUCTION_FRAG_REASSEMBLY */
-
 
 /**************************************************************************//**
  @Description   Enum for inter-module interrupts registration
@@ -274,10 +261,6 @@ typedef enum e_FmInterModuleEvent {
     e_FM_EV_ERR_1G_MAC3,            /**< 1G MAC 3 error event */
     e_FM_EV_ERR_1G_MAC4,            /**< 1G MAC 4 error event */
     e_FM_EV_TMR,                    /**< Timer event */
-    e_FM_EV_1G_MAC1,                /**< 1G MAC 1 event */
-    e_FM_EV_1G_MAC2,                /**< 1G MAC 2 event */
-    e_FM_EV_1G_MAC3,                /**< 1G MAC 3 event */
-    e_FM_EV_1G_MAC4,                /**< 1G MAC 3 event */
     e_FM_EV_1G_MAC0_TMR,            /**< 1G MAC 0 Timer event */
     e_FM_EV_1G_MAC1_TMR,            /**< 1G MAC 1 Timer event */
     e_FM_EV_1G_MAC2_TMR,            /**< 1G MAC 2 Timer event */
@@ -347,12 +330,9 @@ typedef enum e_FmInterModuleEvent {
 /* p4080-rev1 unique features */
 #define FM_PARTITION_ARRAY
 #define FM_PPPOE_NO_MTU_CHECK
+#define FM_NO_THRESHOLD_REG
 
 /* p4080 unique features */
-#ifdef UNDER_CONSTRUCTION_IPSEC
-#define FM_ETH_TYPE_FIX
-#define FM_DISABLE_SEC_ERRORS
-#endif /* UNDER_CONSTRUCTION_IPSEC */
 #define FM_QMI_DEQ_OPTIONS_SUPPORT
 #define FM_NO_DISPATCH_RAM_ECC
 #define FM_FIFO_ALLOCATION_OLD_ALG
@@ -365,88 +345,46 @@ typedef enum e_FmInterModuleEvent {
 #define FM_NO_OP_OBSERVED_POOLS
 #define FM_NO_ADVANCED_RATE_LIMITER
 #define FM_NO_OP_OBSERVED_CGS
+#define FM_OP_QMI_FRAG_OPTION
 
 /* FM erratas */
-#define FM_SINGLE_MDIO_ERRATA_GEN8                      /* implemented in platform */
-#define FM_HALT_SIG_ERRATA_GEN12
-
-#define FM_10G_MDIO_HOLD_ERRATA_XAUI3                   /* implemented in platform */
-#define FM_10G_PCS_ALIGNMENT_ERRATA_XAUI4               /* implemented in platform */
-
-#define FM_IEEE_BAD_TS_ERRATA_IEEE1588_A001             /* No implementation, Out of LLD scope */
 
-#define FM_FALSE_RDRP_ERRATA_10GMAC_A001                /* No implementation, Out of LLD scope */
-#define FM_RX_EXTRA_BYTES_ERRATA_10GMAC_A002            /* No implementation, Out of LLD scope */
-#define FM_TX_PAUSE_ON_ENABLE_ERRATA_10GMAC_A003        /* No implementation, Out of LLD scope */
 #define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 #define FM_TX_SHORT_FRAME_BAD_TS_ERRATA_10GMAC_A006     /* No implementation, Out of LLD scope */
 #define FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
 #define FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008
+#define FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010
 
-#define FM_TX_INVALID_ECC_ERRATA_10GMAC_A009
-
-#define FM_NO_RX_PREAM_ERRATA_DTSECx1
-#define FM_RX_PREAM_4_ERRATA_DTSEC_A001                 FM_NO_RX_PREAM_ERRATA_DTSECx1
+#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
+#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2              /* No implementation, Out of LLD scope */
 #define FM_GRS_ERRATA_DTSEC_A002
 #define FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
 #define FM_GTS_ERRATA_DTSEC_A004
-#define FM_PAUSE_BLOCK_ERRATA_DTSEC_A006                        /* do nothing */
-#define FM_RESERVED_ACCESS_TO_DISABLED_DEV_ERRATA_DTSEC_A0011   /* do nothing */
-#define FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012       FM_GTS_ERRATA_DTSEC_A004
+#define FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012
+#define FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014
 
-#define FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1
 #define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2          /* No implementation, Out of LLD scope */
-#define FM_10_100_SGMII_NO_TS_ERRATA_DTSEC3
 #define FM_TX_LOCKUP_ERRATA_DTSEC6
 
-#define FM_IM_TX_SYNC_SKIP_TNUM_ERRATA_FMAN_A001            /* Implemented by ucode */
-#define FM_RX_PIPELINE_OF_DATA_CORRUPTION_ERRATA_FMAN_A002  /* No implementation, Out of LLD scope */
 #define FM_HC_DEF_FQID_ONLY_ERRATA_FMAN_A003                /* Implemented by ucode */
-
-#define FM_1588_SRC_CLK_ERRATA_FMAN1
-#define FM_NO_RUNNING_SUM_FOR_DBG_N_SWPRS_ERRATA_FMAN2      /* No implementation, Out of LLD scope */
-#define FM_IM_TX_SHARED_TNUM_ERRATA_FMAN4                   /* Implemented by ucode */
-#define FM_IM_GS_DEADLOCK_ERRATA_FMAN5                      /* Implemented by ucode */
-#define FM_PORT_SYNC_ERRATA_FMAN6
-#define FM_RAM_LIST_ERR_IRQ_ERRATA_FMAN8
-#define FM_BMI_PIPELINE_ERR_IRQ_ERRATA_FMAN9
-#define FM_IM_DEQ_PIPELINE_DEPTH_ERRATA_FMAN10              /* Implemented by ucode */
-#define FM_CC_GEN6_MISSMATCH_ERRATA_FMAN12                  /* Implemented by ucode */
-#define FM_CC_CHANGE_SHARED_TNUM_ERRATA_FMAN13              /* Implemented by ucode */
-#define FM_IM_LARGE_MRBLR_ERRATA_FMAN15                     /* Implemented by ucode */
-#define FM_RESET_ERRATA_FMAN16                              /* No implementation, Out of LLD scope */
-#define FM_IPV4_HDRLEN0_ERRATA_FMAN17                       /* No implementation, Out of LLD scope */
-#define FM_INCORRECT_CS_ERRATA_FMAN18
-#define FM_ILLEGAL_FRM_LEN_ERRATA_FMAN20                    /* No implementation, Out of LLD scope */
-#define FM_OP_PORT_QMAN_REJECT_ERRATA_FMAN21
-
-#define FM_PRS_L4_SHELL_ERRATA_FMANb
-#define FM_BMI_TO_RISC_ENQ_ERRATA_FMANc
-#define FM_INVALID_SWPRS_DATA_ERRATA_FMANd                  /* No implementation, Out of LLD scope */
-//#define FM_PRS_L4_NO_CLEAR_ERRATA_FMANe                     /* No implementation, No patch yet */
-//#define FM_PRS_MPLS_ERROR_ERRATA_FMANf                      /* No implementation, No patch yet */
-#define FM_PORT_COUNTERS_ERRATA_FMANg
-#define FM_BAD_RX_FD_ERRATA_FMANh                           /* No implementation, Out of LLD scope */
-//#define FM_PRS_MPLS_SSA_ERRATA_FMANj                        /* No implementation, No patch yet */
-//#define FM_PRS_INITIAL_PLANID_ERRATA_FMANk                  /* No implementation, No patch yet */
-
-
-#define FM_OP_PARTITION_ERRATA_FMANx8
-#define FM_PORT_DISABLED_ERRATA_FMANx9
-#define FM_TX_PORT_IM_OR_ERRATA_FMANx11                     /* Implemented by ucode */
-#define FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
-#define FM_PORT_OTF_CHANGES_ERRATA_FMANx12                  FM_PORT_EXCESSIVE_BUDGET_ERRATA_FMANx16
-#define FM_SOFT_RESET_ERRATA_FMANx15                        /* No implementation, Out of LLD scope */
+#define FM_DEBUG_TRACE_FMAN_A004                            /* No implementation, Out of LLD scope */
 
 #define FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173
 
-#define FM_PRS_MEM_ERRATA_FMAN_SW003
 #define FM_LEN_CHECK_ERRATA_FMAN_SW002
-#define FM_10G_REM_N_LCL_FLT_EX_ERRATA_10GMAC001
-
-#ifdef UNDER_CONSTRUCTION_IPSEC
-#define FM_NO_COPY_CTXA_CTXB_ERRATA_FMAN_SW001
-#endif /* UNDER_CONSTRUCTION_IPSEC */
+#define FM_PRS_MEM_ERRATA_FMAN_SW003
+#define FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
+
+#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+#define FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
+#define FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
+#ifdef FM_IPSEC_SUPPORT
+#define FM_DISABLE_UDP_CHECKSUM_AFTER_SEC
+#define FM_UPDATE_UDP_LENGTH_AFTER_SEC
+#define FM_ETH_TYPE_FIX
+#define FM_DISABLE_SEC_ERRORS
+#endif /* FM_IPSEC_SUPPORT */
+#endif /* defined(FM_IPSEC_SUPPORT) || ... */
 
 
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h
index 21d07df..25e7b15 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
index a265f35..c7b04a2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/part_integration_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
index 95b9560..4c5515b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/math_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
index 3519b6f..a0c76c4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/ncsw_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,6 +49,7 @@
 #define UINT_TO_PTR(_val)           ((void*)(uintptr_t)(_val))
 
 #define PTR_MOVE(_ptr, _offset)     (void*)((uint8_t*)(_ptr) + (_offset))
+#define PTR_MOVE_16(_ptr, _offset)  (void*)((uint16_t*)(_ptr) + (_offset))
 
 
 #define WRITE_UINT8_UINT24(arg, data08, data24) WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
index c41b7c9..1cd804b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
index 4d2ba44..3df9957 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/std_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
index e2b2191..519c9a8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdarg_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
index f8dbaea..28d05bf 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/stdlib_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
index f598c92..1f79d51 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/string_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
index 27d9975..342bafd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/types_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -49,10 +49,10 @@
 #elif defined(NCSW_VXWORKS)
 #include "types_vxworks.h"
 
-#elif defined(__MWERKS__) && defined(__GNUC__) && defined(__cplusplus)
+#elif defined(__GNUC__) && defined(__cplusplus)
 #include "types_bb_gpp.h"
 
-#elif defined(__MWERKS__) && defined(__GNUC__)
+#elif defined(__GNUC__)
 #include "types_bb_gcc.h"
 
 #elif defined(__ghs__)
@@ -62,7 +62,6 @@
 #include "types_dflt.h"
 #endif /* defined (__ROCOO__) */
 
-
 static __inline__ void TypesChecker(void)
 {
 #if defined(__MWERKS__) && !defined(__GNUC__)
@@ -107,5 +106,4 @@ static __inline__ void TypesChecker(void)
                  GET_UINT64(*((uint64_t*)((size_t)(INT64_MIN)))));
 }
 
-
 #endif /* __TYPES_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
index d1264c0..9ffda3e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/xx_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -43,9 +43,6 @@
 #include "std_ext.h"
 #include "part_ext.h"
 
-#if defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED)
-#include "xx_integration_ext.h"
-#endif /* defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED) */
 
 
 /**************************************************************************//**
@@ -144,7 +141,6 @@ void XX_FreeSmart(void *p_Memory);
 *//***************************************************************************/
 void XX_Free(void *p_Memory);
 
-#ifndef NCSW_LINUX
 /**************************************************************************//**
  @Function      XX_GetMemPartitionBase
 
@@ -157,7 +153,6 @@ void XX_Free(void *p_Memory);
  @Return        The address of the required memory type.
 *//***************************************************************************/
 void * XX_GetMemPartitionBase(int memPartitionId);
-#endif
 
 /**************************************************************************//**
  @Function      XX_Print
@@ -225,7 +220,6 @@ t_Error XX_EnableIntr(int irq);
 *//***************************************************************************/
 t_Error XX_DisableIntr(int irq);
 
-#if !(defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED))
 /**************************************************************************//**
  @Function      XX_DisableAllIntr
 
@@ -248,7 +242,6 @@ uint32_t XX_DisableAllIntr(void);
  @Return        None.
 *//***************************************************************************/
 void XX_RestoreAllIntr(uint32_t flags);
-#endif /* !(defined(__MWERKS__) && defined(OPTIMIZED_FOR_SPEED)) */
 
 /**************************************************************************//**
  @Function      XX_Call
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
index b78df0b..8886db2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P1023/module_strings.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -66,6 +66,6 @@ const char *moduleStrings[] =
     ,"I2C"                      /* MODULE_I2C */
     ,"ESPI"                     /* MODULE_ESPI */
     ,"PCI"                      /* MODULE_PCI */
-    ,"DPA"                      /* MODULE_DPA */
+    ,"DPA-Port"                 /* MODULE_DPA_PORT */
     ,"USB"                      /* MODULE_USB */
 };
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c
index 36a4250..ecf0bfd 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/integrations/P3040_P4080_P5020/module_strings.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/p1023_dflags.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/p1023_dflags.h
index 52d8828..b946944 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/p1023_dflags.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/p1023_dflags.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/p3040_4080_5020_dflags.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/p3040_4080_5020_dflags.h
index 0ca9252..2e3b5b9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/p3040_4080_5020_dflags.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/p3040_4080_5020_dflags.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_ext.h
index 26f3944..df93d96 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_io_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_io_ext.h
index 3d9ce88..2d36aa5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_io_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/system/sys_io_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/types_linux.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/types_linux.h
index 471a919..45bfe03 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/types_linux.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/types_linux.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
index 2dd12cd..44203fb 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h
index 67a76b1..c4eac25 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/fsl_fman_test.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h
index 4967561..390eea4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/wrapper/lnxwrp_fm_ext.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/xx/xx.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/xx/xx.h
index ab05172..9d53d82 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/xx/xx.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/inc/xx/xx.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/system/sys_io.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/system/sys_io.c
index 1722415..b2f097c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/system/sys_io.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/system/sys_io.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c
index aae0774..70e5b8d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -262,7 +262,7 @@ static struct qman_fq * FqAlloc(t_FmTestPort    *p_FmTestPort,
     }
 
     p_FmtFq->fq_base.cb.dqrr = egress_dqrr;
-    p_FmtFq->fq_base.cb.ern = p_FmtFq->fq_base.cb.dc_ern = p_FmtFq->fq_base.cb.fqs = egress_ern;
+    p_FmtFq->fq_base.cb.ern = p_FmtFq->fq_base.cb.fqs = egress_ern;
     p_FmtFq->port = (void *)p_FmTestPort;
     if (fqid == 0) {
         flags |= QMAN_FQ_FLAG_DYNAMIC_FQID;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
index 07b5917..858fa6b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -802,8 +802,6 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if ((p_LnxWrpFmDev->h_Dev = FM_Config(&p_LnxWrpFmDev->fmDevSettings.param)) == NULL)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("FM"));
 
-    if (FM_ConfigMaxNumOfOpenDmas(p_LnxWrpFmDev->h_Dev,BMI_MAX_NUM_OF_DMAS) != E_OK)
-         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
 
     if (FM_ConfigResetOnInit(p_LnxWrpFmDev->h_Dev, TRUE) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
@@ -813,10 +811,6 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
 #endif
 
-    /* Use the entire amount of TNUMS, maybe performance will improve...
-    for OPEN DMAs - are all by default = 32 and fifosize = MURAM*3/4 and
-    the rest of it is for PCD */
-    FM_ConfigTotalNumOfTasks(p_LnxWrpFmDev->h_Dev, BMI_MAX_NUM_OF_TASKS);
 
 #if defined(CONFIG_FMAN_RESOURCE_ALLOCATION_ALGORITHM) && defined(CONFIG_FMAN_P3040_P4080_P5020)
     /* Enable 14g w/ jumbo frames following HW suggestion. */
@@ -919,6 +913,10 @@ static int /*__devinit*/ fm_probe(struct platform_device *of_dev)
     if (InitFmDev(p_LnxWrpFmDev) != E_OK)
         return -EIO;
 
+    /* IOCTL ABI checking */
+    LnxWrpPCDIOCTLEnumChecking();
+    LnxWrpPCDIOCTLTypeChecking();
+
     Sprint (p_LnxWrpFmDev->name, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
 
     /* Register to the /dev for IOCTL API */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
index e730ee9..9aa02aa 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -253,5 +253,7 @@ static __inline__ t_Error AllocSchemesForPort(t_LnxWrpFmDev *p_LnxWrpFmDev, uint
     return E_OK;
 }
 
+void LnxWrpPCDIOCTLTypeChecking(void);
+void LnxWrpPCDIOCTLEnumChecking(void);
 
 #endif /* __LNXWRP_FM_H__ */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
index cef74e9..61a9728 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm_port.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -122,9 +122,9 @@ static struct qman_fq *FqAlloc(t_LnxWrpFmDev * p_LnxWrpFmDev,
 		return NULL;
 	}
 
-	p_FmtFq->fq_base.cb.dqrr =
-		(QMAN_FQ_FLAG_NO_ENQUEUE ? qm_tx_conf_dqrr_cb :
-		 qm_tx_dqrr_cb);
+	p_FmtFq->fq_base.cb.dqrr = ((flags & QMAN_FQ_FLAG_NO_ENQUEUE)
+			? qm_tx_conf_dqrr_cb
+			: qm_tx_dqrr_cb);
 	p_FmtFq->fq_base.cb.ern = qm_err_cb;
 	/* p_FmtFq->fq_base.cb.fqs = qm_err_cb; */
 	/* qm_err_cb wrongly called when the FQ is parked */
@@ -309,41 +309,53 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 
 		p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.
 			qmChannel = p_LnxWrpFmPortDev->txCh;
-	} else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-tx") ||
-		 of_device_is_compatible(port_node, "fsl,fman-port-10g-tx")) {
-		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_TX_PORTS)) {
+	} else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-tx")) {
+		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_1G_TX_PORTS)) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
-				     ("of_get_property(%s, cell-index) failed",
-				      port_node->full_name));
+					("of_get_property(%s, cell-index) failed",
+					 port_node->full_name));
 			return NULL;
 		}
-		if (of_device_is_compatible
-		    (port_node, "fsl,fman-port-10g-tx"))
-			p_LnxWrpFmPortDev =
-				&p_LnxWrpFmDev->txPorts[*uint32_prop +
-						FM_MAX_NUM_OF_1G_TX_PORTS];
-		else
-			p_LnxWrpFmPortDev =
-				&p_LnxWrpFmDev->txPorts[*uint32_prop];
+		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop];
 
 		p_LnxWrpFmPortDev->id = *uint32_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
 			p_LnxWrpFmPortDev->id;
-		if (of_device_is_compatible
-		    (port_node, "fsl,fman-port-10g-tx"))
-			p_LnxWrpFmPortDev->settings.param.portType =
-				e_FM_PORT_TYPE_TX_10G;
-		else
-			p_LnxWrpFmPortDev->settings.param.portType =
-				e_FM_PORT_TYPE_TX;
+		p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_TX;
 
-		uint32_prop =
-			(uint32_t *) of_get_property(port_node,
-						     "fsl,qman-channel-id",
-						     &lenp);
+		uint32_prop = (uint32_t *) of_get_property(port_node,
+				"fsl,qman-channel-id", &lenp);
 		if (uint32_prop == NULL) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
-				     ("missing fsl,qman-channel-id"));
+					("missing fsl,qman-channel-id"));
+			return NULL;
+		}
+		if (WARN_ON(lenp != sizeof(uint32_t)))
+			return NULL;
+		p_LnxWrpFmPortDev->txCh = *uint32_prop;
+		p_LnxWrpFmPortDev->
+			settings.param.specificParams.nonRxParams.qmChannel =
+			p_LnxWrpFmPortDev->txCh;
+	} else if (of_device_is_compatible(port_node, "fsl,fman-port-10g-tx")) {
+		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_10G_TX_PORTS)) {
+			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+					("of_get_property(%s, cell-index) failed",
+					 port_node->full_name));
+			return NULL;
+		}
+		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->txPorts[*uint32_prop +
+			FM_MAX_NUM_OF_1G_TX_PORTS];
+
+		p_LnxWrpFmPortDev->id = *uint32_prop;
+		p_LnxWrpFmPortDev->settings.param.portId =
+			p_LnxWrpFmPortDev->id;
+		p_LnxWrpFmPortDev->settings.param.portType =
+			e_FM_PORT_TYPE_TX_10G;
+		uint32_prop = (uint32_t *) of_get_property(port_node,
+				"fsl,qman-channel-id", &lenp);
+		if (uint32_prop == NULL) {
+			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+					("missing fsl,qman-channel-id"));
 			return NULL;
 		}
 		if (WARN_ON(lenp != sizeof(uint32_t)))
@@ -351,34 +363,36 @@ static t_LnxWrpFmPortDev *ReadFmPortDevTreeNode(struct platform_device
 		p_LnxWrpFmPortDev->txCh = *uint32_prop;
 		p_LnxWrpFmPortDev->settings.param.specificParams.nonRxParams.
 			qmChannel = p_LnxWrpFmPortDev->txCh;
-	} else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-rx") ||
-		 of_device_is_compatible(port_node, "fsl,fman-port-10g-rx")) {
-		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_RX_PORTS)) {
+	} else if (of_device_is_compatible(port_node, "fsl,fman-port-1g-rx")) {
+		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_1G_RX_PORTS)) {
 			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
-				     ("of_get_property(%s, cell-index) failed",
-				      port_node->full_name));
+					("of_get_property(%s, cell-index) failed",
+					 port_node->full_name));
 			return NULL;
 		}
-		if (of_device_is_compatible
-		    (port_node, "fsl,fman-port-10g-rx"))
-			p_LnxWrpFmPortDev =
-				&p_LnxWrpFmDev->rxPorts[*uint32_prop +
-						FM_MAX_NUM_OF_1G_RX_PORTS];
-		else
-			p_LnxWrpFmPortDev =
-				&p_LnxWrpFmDev->rxPorts[*uint32_prop];
+		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop];
 
 		p_LnxWrpFmPortDev->id = *uint32_prop;
 		p_LnxWrpFmPortDev->settings.param.portId =
 			p_LnxWrpFmPortDev->id;
-		if (of_device_is_compatible
-		    (port_node, "fsl,fman-port-10g-rx"))
-			p_LnxWrpFmPortDev->settings.param.portType =
-				e_FM_PORT_TYPE_RX_10G;
-		else
-			p_LnxWrpFmPortDev->settings.param.portType =
-				e_FM_PORT_TYPE_RX;
+		p_LnxWrpFmPortDev->settings.param.portType = e_FM_PORT_TYPE_RX;
+		if (p_LnxWrpFmDev->pcdActive)
+			p_LnxWrpFmPortDev->defPcd = p_LnxWrpFmDev->defPcd;
+	} else if (of_device_is_compatible(port_node, "fsl,fman-port-10g-rx")) {
+		if (unlikely(*uint32_prop >= FM_MAX_NUM_OF_10G_RX_PORTS)) {
+			REPORT_ERROR(MAJOR, E_INVALID_VALUE,
+					("of_get_property(%s, cell-index) failed",
+					 port_node->full_name));
+			return NULL;
+		}
+		p_LnxWrpFmPortDev = &p_LnxWrpFmDev->rxPorts[*uint32_prop +
+			FM_MAX_NUM_OF_1G_RX_PORTS];
 
+		p_LnxWrpFmPortDev->id = *uint32_prop;
+		p_LnxWrpFmPortDev->settings.param.portId =
+			p_LnxWrpFmPortDev->id;
+		p_LnxWrpFmPortDev->settings.param.portType =
+			e_FM_PORT_TYPE_RX_10G;
 		if (p_LnxWrpFmDev->pcdActive)
 			p_LnxWrpFmPortDev->defPcd = p_LnxWrpFmDev->defPcd;
 	} else {
@@ -682,17 +696,18 @@ static t_Error InitFmPortDev(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 			i++;
 	}
 
-	if (FM_PORT_Init(p_LnxWrpFmPortDev->h_Dev) != E_OK)
-		RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 #if defined(CONFIG_FMAN_RESOURCE_ALLOCATION_ALGORITHM)
 	/* even if these functions return w/ error, do not crash kernel.
 	   Do not return anything because the container function is not
 	   linux complient (it should return -EIO). */
-	fm_set_precalculate_fifosize(p_LnxWrpFmPortDev);
-	fm_set_precalculate_open_dma(p_LnxWrpFmPortDev);
-	fm_set_precalculate_tnums(p_LnxWrpFmPortDev);
+	fm_config_precalculate_fifosize(p_LnxWrpFmPortDev);
+	fm_config_precalculate_open_dma(p_LnxWrpFmPortDev);
+	fm_config_precalculate_tnums(p_LnxWrpFmPortDev);
 #endif
 
+	if (FM_PORT_Init(p_LnxWrpFmPortDev->h_Dev) != E_OK)
+		RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+
 /* FMan Fifo sizes behind the scene":
  * Using the following formulae (*), under a set of simplifying assumptions (.):
  *  . all ports are configured in Normal Mode (rather than Independent Mode)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
index 1731de1..94a0a47 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -310,7 +310,33 @@
 
 #define ASSERT_IOC_NET_ENUM(def) ASSERT_COND((unsigned long)e_IOC_NET_##def == (unsigned long)def)
 
-static void LnxwrpAssertions(void)
+void LnxWrpPCDIOCTLTypeChecking(void)
+{
+    ASSERT_COND(sizeof(ioc_fm_pcd_prs_sw_params_t) == sizeof(t_FmPcdPrsSwParams));
+    ASSERT_COND(sizeof(t_FmPcdKgSchemeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_kg_scheme_params_t));
+    /* t_FmPcdCcNodeParams */
+    ASSERT_COND(sizeof(t_FmPcdExtractEntry) == sizeof(ioc_fm_pcd_extract_entry_t));
+    ASSERT_COND(sizeof(t_KeysParams) == sizeof(t_KeysParams));
+
+    ASSERT_COND(sizeof(t_FmPcdCcTreeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_cc_tree_params_t));
+    ASSERT_COND(sizeof(t_FmPcdPlcrProfileParams) + sizeof(void *) == sizeof(ioc_fm_pcd_plcr_profile_params_t));
+    ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_engine_params_t) == sizeof(t_FmPcdCcNextEngineParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_cc_key_params_t) == sizeof(t_FmPcdCcKeyParams));
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+    ASSERT_COND(sizeof(t_FmPcdManipRmvParams) == sizeof(ioc_fm_pcd_manip_rmv_params_t));
+    ASSERT_COND(sizeof(t_FmPcdManipInsrtParams) == sizeof(ioc_fm_pcd_manip_insrt_params_t));
+    ASSERT_COND(sizeof(t_FmPcdManipFragOrReasmParams) == sizeof(ioc_fm_pcd_manip_frag_or_reasm_params_t));
+    ASSERT_COND(sizeof(t_FmPcdManipLocationParams) == sizeof(ioc_fm_pcd_manip_location_params_t));
+    ASSERT_COND(sizeof(t_FmPcdManipInsrtByTemplateParams) == sizeof(ioc_fm_pcd_manip_insrt_by_template_params_t));
+    ASSERT_COND(sizeof(t_FmPcdStatsParams) == sizeof(ioc_fm_pcd_stats_params_t));
+#endif /* defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
+
+#ifdef FM_CAPWAP_SUPPORT
+    ASSERT_COND( sizeof(t_FmPcdStatsParams) == sizeof(ioc_fm_pcd_stats_params_t));
+#endif
+}
+
+void LnxWrpPCDIOCTLEnumChecking(void)
 {
     /* sampling checks */
     ASSERT_IOC_NET_ENUM(HEADER_TYPE_MACSEC);
@@ -350,9 +376,6 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
 {
     t_Error err = E_READ_FAILED;
 
-    /* can be moved from here */
-    LnxwrpAssertions();
-
     switch (cmd)
     {
 #if defined(CONFIG_COMPAT)
@@ -363,12 +386,12 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             ioc_fm_pcd_prs_sw_params_t *param;
             uint8_t                    *p_code;
 
-            ASSERT_COND(sizeof(ioc_fm_pcd_prs_sw_params_t) == sizeof(t_FmPcdPrsSwParams));
-
             param = (ioc_fm_pcd_prs_sw_params_t *) XX_Malloc(sizeof(ioc_fm_pcd_prs_sw_params_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_prs_sw_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -382,6 +405,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_prs_sw_params_t));
                 if (copy_from_user(compat_param,
                             (ioc_compat_fm_pcd_prs_sw_params_t *) compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_prs_sw_params_t)))
@@ -406,6 +430,12 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 }
             }
 
+            if (!param->p_code || !param->size)
+            {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
+            }
+
             p_code = (uint8_t *) XX_Malloc(param->size);
             if (!p_code)
             {
@@ -413,6 +443,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
 
+            memset(p_code, 0, param->size);
             if (copy_from_user(p_code, param->p_code, param->size)) {
                 XX_Free(p_code);
                 XX_Free(param);
@@ -422,6 +453,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             param->p_code = p_code;
 
             err = FM_PCD_PrsLoadSw(p_LnxWrpFmDev->h_PcdDev, (t_FmPcdPrsSwParams*)param);
+
             XX_Free(p_code);
             XX_Free(param);
             break;
@@ -462,6 +494,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_exception_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -484,6 +518,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             }
 
             err = FM_PCD_SetException(p_LnxWrpFmDev->h_PcdDev, param->exception, param->enable);
+
             XX_Free(param);
             break;
         }
@@ -517,6 +552,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_kg_dflt_value_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -539,6 +576,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             }
 
             err = FM_PCD_KgSetDfltValue(p_LnxWrpFmDev->h_PcdDev, param->valueId, param->value);
+
             XX_Free(param);
             break;
         }
@@ -554,6 +592,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_net_env_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -567,6 +607,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_net_env_params_t));
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_net_env_params_t *) compat_ptr(arg),
                                     sizeof(ioc_compat_fm_pcd_net_env_params_t)))
                 {
@@ -604,8 +645,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_net_env_params_t));
                 compat_copy_fm_pcd_net_env(compat_param, param, COMPAT_K_TO_US);
-
                 if (param->id && !copy_to_user((ioc_compat_fm_pcd_net_env_params_t *) compat_ptr(arg),
                             compat_param,
                             sizeof(ioc_compat_fm_pcd_net_env_params_t)))
@@ -660,11 +701,12 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         {
             ioc_fm_pcd_kg_scheme_params_t *param;
 
-            ASSERT_COND(sizeof(t_FmPcdKgSchemeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_kg_scheme_params_t));
             param = (ioc_fm_pcd_kg_scheme_params_t *) XX_Malloc(sizeof(ioc_fm_pcd_kg_scheme_params_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_kg_scheme_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -678,6 +720,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_kg_scheme_params_t));
+
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_kg_scheme_params_t *) compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_kg_scheme_params_t)))
                 {
@@ -706,7 +750,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
-                ioc_compat_fm_pcd_kg_scheme_params_t *compat_param = NULL;
+                ioc_compat_fm_pcd_kg_scheme_params_t *compat_param;
 
                 compat_param = (ioc_compat_fm_pcd_kg_scheme_params_t *) XX_Malloc(
                         sizeof(ioc_compat_fm_pcd_kg_scheme_params_t));
@@ -716,12 +760,13 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_kg_scheme_params_t));
                 compat_copy_fm_pcd_kg_scheme(compat_param, param, COMPAT_K_TO_US);
-
                 if (param->id && !copy_to_user((ioc_compat_fm_pcd_kg_scheme_params_t *)compat_ptr(arg),
                             compat_param,
                             sizeof(ioc_compat_fm_pcd_kg_scheme_params_t)))
                     err = E_OK;
+
                 XX_Free(compat_param);
             }
             else
@@ -776,8 +821,6 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             uint8_t                     *masks;
             int                         i,k;
 
-            ASSERT_COND(sizeof(t_FmPcdCcNodeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_cc_node_params_t));
-
             param = (ioc_fm_pcd_cc_node_params_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_cc_node_params_t) +
                     2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
@@ -789,7 +832,6 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
 
             keys = (uint8_t *) (param + 1);
             masks = keys + IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY;
-            memset(keys, 0, 2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -830,6 +872,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, err, NO_MSG);
                 }
             }
+
             ASSERT_COND(param->keys_params.num_of_keys <= IOC_FM_PCD_MAX_NUM_OF_KEYS);
             ASSERT_COND(param->keys_params.key_size <= IOC_FM_PCD_MAX_SIZE_OF_KEY);
 
@@ -842,15 +885,22 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                      i < param->keys_params.num_of_keys;
                      i++, k += IOC_FM_PCD_MAX_SIZE_OF_KEY)
                 {
-                    if (copy_from_user(&keys[k],
-                                param->keys_params.key_params[i].p_key,
-                                param->keys_params.key_size))
+                    if (param->keys_params.key_params[i].p_key &&
+                            param->keys_params.key_size)
                     {
-                        XX_Free(param);
-                        RETURN_ERROR(MINOR, err, NO_MSG);
-                    }
+                        if (copy_from_user(&keys[k],
+                                    param->keys_params.key_params[i].p_key,
+                                    param->keys_params.key_size))
+                        {
+                            XX_Free(param);
+                            RETURN_ERROR(MINOR, err, NO_MSG);
+                        }
 
-                    param->keys_params.key_params[i].p_key = &keys[k];
+                        param->keys_params.key_params[i].p_key = &keys[k];
+                    }
+                    /* else
+                       param->keys_params.key_params[i].p_key = NULL;
+                       was taken care of by memset(0) above */
 
                     if (param->keys_params.key_params[i].p_mask)
                     {
@@ -861,8 +911,12 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                             XX_Free(param);
                             RETURN_ERROR(MINOR, err, NO_MSG);
                         }
+
                         param->keys_params.key_params[i].p_mask = &masks[k];
                     }
+                    /* else
+                       param->keys_params.key_params[i].p_mask = NULL;
+                       was taken care of by memset(0) above */
                 }
             }
 
@@ -881,12 +935,10 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                /* setup user space structure */
                 memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_node_params_t) +
                         2 * IOC_FM_PCD_MAX_NUM_OF_KEYS * IOC_FM_PCD_MAX_SIZE_OF_KEY);
-
-                /* setup user space structure */
                 compat_copy_fm_pcd_cc_node(compat_param, param, COMPAT_K_TO_US);
-
                 compat_param->id = compat_add_ptr2id(param->id);
 
                 if (param->id && !copy_to_user((ioc_compat_fm_pcd_cc_node_params_t *)compat_ptr(arg),
@@ -944,8 +996,6 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         {
             ioc_fm_pcd_cc_tree_params_t *param;
 
-            ASSERT_COND(sizeof(t_FmPcdCcTreeParams) + sizeof(void *) == sizeof(ioc_fm_pcd_cc_tree_params_t));
-
             param = (ioc_fm_pcd_cc_tree_params_t *) XX_Malloc(sizeof(ioc_fm_pcd_cc_tree_params_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
@@ -964,8 +1014,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     XX_Free(param);
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
-                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tree_params_t));
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tree_params_t));
                 if (copy_from_user(compat_param,
                             (ioc_compat_fm_pcd_cc_tree_params_t *)compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_tree_params_t)))
@@ -1005,15 +1055,13 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 }
 
                 memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tree_params_t));
-
                 compat_add_ptr2id(param->id);
                 param->id = (void *)(uint64_t)compat_get_ptr2id(param->id);
-
                 compat_copy_fm_pcd_cc_tree(compat_param, param, COMPAT_K_TO_US);
 
                 if (param->id && !copy_to_user((ioc_compat_fm_pcd_cc_tree_params_t *)compat_ptr(arg),
-                                                compat_param,
-                                                sizeof(ioc_compat_fm_pcd_cc_tree_params_t)))
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_cc_tree_params_t)))
                     err = E_OK;
 
                 XX_Free(compat_param);
@@ -1065,13 +1113,13 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         {
             ioc_fm_pcd_plcr_profile_params_t *param;
 
-            ASSERT_COND(sizeof(t_FmPcdPlcrProfileParams) + sizeof(void *) == sizeof(ioc_fm_pcd_plcr_profile_params_t));
-
             param = (ioc_fm_pcd_plcr_profile_params_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_plcr_profile_params_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_plcr_profile_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1085,6 +1133,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_fm_pcd_plcr_profile_params_t));
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_plcr_profile_params_t *)compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_plcr_profile_params_t))) {
                     XX_Free(compat_param);
@@ -1113,13 +1162,14 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 t_Handle h_Port;
                 fm_pcd_port_params_t *port_params;
 
-                port_params = (fm_pcd_port_params_t*) XX_Malloc(sizeof(fm_pcd_port_params_t)); 
+                port_params = (fm_pcd_port_params_t*) XX_Malloc(sizeof(fm_pcd_port_params_t));
                 if (!port_params)
                 {
                     XX_Free(param);
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(port_params, 0, sizeof(fm_pcd_port_params_t));
                 if (copy_from_user(port_params, (fm_pcd_port_params_t*)((t_FmPcdPlcrProfileParams*)param)->id.newParams.h_FmPort,
                             sizeof(fm_pcd_port_params_t)))
                 {
@@ -1131,18 +1181,28 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 switch(port_params->port_type)
                 {
                     case (e_IOC_FM_PORT_TYPE_RX):
-                        h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id].h_Dev;
-                        break;
+                        if (port_params->port_id < FM_MAX_NUM_OF_1G_RX_PORTS) {
+                            h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id].h_Dev;
+                            break;
+                        }
+                        goto invalid_port_id;
+
                     case (e_IOC_FM_PORT_TYPE_RX_10G):
-                        h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
-                        break;
+                        if (port_params->port_id < FM_MAX_NUM_OF_10G_RX_PORTS) {
+                            h_Port = p_LnxWrpFmDev->rxPorts[port_params->port_id + FM_MAX_NUM_OF_1G_RX_PORTS].h_Dev;
+                            break;
+                        }
+                        goto invalid_port_id;
+
                     case (e_IOC_FM_PORT_TYPE_OFFLINE_PARSING):
-                        if (port_params->port_id)
-                        {
+                        if (port_params->port_id && port_params->port_id <= FM_MAX_NUM_OF_OH_PORTS) {
                             h_Port = p_LnxWrpFmDev->opPorts[port_params->port_id - 1].h_Dev;
                             break;
                         }
+                        goto invalid_port_id;
+
                     default:
+invalid_port_id:
                         XX_Free(port_params);
                         XX_Free(param);
                         RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
@@ -1167,8 +1227,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_plcr_profile_params_t));
                 compat_copy_fm_pcd_plcr_profile(compat_param, param, COMPAT_K_TO_US);
-
                 if (param->id && !copy_to_user((ioc_compat_fm_pcd_plcr_profile_params_t *) compat_ptr(arg),
                             compat_param,
                             sizeof(ioc_compat_fm_pcd_plcr_profile_params_t)))
@@ -1223,13 +1283,13 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         {
             ioc_fm_pcd_cc_tree_modify_next_engine_params_t *param;
 
-            ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_engine_params_t) == sizeof(t_FmPcdCcNextEngineParams));
-
             param = (ioc_fm_pcd_cc_tree_modify_next_engine_params_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_cc_tree_modify_next_engine_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1243,6 +1303,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t));
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t *) compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_tree_modify_next_engine_params_t)))
                 {
@@ -1271,10 +1332,10 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     param->grp_indx,
                     param->indx,
                     (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+
             XX_Free(param);
             break;
         }
-
 #if defined(CONFIG_COMPAT)
         case FM_PCD_IOC_CC_NODE_MODIFY_NEXT_ENGINE_COMPAT:
 #endif
@@ -1282,13 +1343,13 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         {
             ioc_fm_pcd_cc_node_modify_next_engine_params_t *param;
 
-            ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_engine_params_t) == sizeof(t_FmPcdCcNextEngineParams));
-
             param = (ioc_fm_pcd_cc_node_modify_next_engine_params_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1302,6 +1363,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t));
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *) compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)))
                 {
@@ -1329,6 +1391,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     param->id,
                     param->key_indx,
                     (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+
             XX_Free(param);
             break;
         }
@@ -1340,13 +1403,13 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         {
             ioc_fm_pcd_cc_node_modify_next_engine_params_t *param;
 
-            ASSERT_COND(sizeof(ioc_fm_pcd_cc_next_engine_params_t) == sizeof(t_FmPcdCcNextEngineParams));
-
             param = (ioc_fm_pcd_cc_node_modify_next_engine_params_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_cc_node_modify_next_engine_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1360,6 +1423,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t));
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t *) compat_ptr(arg),
                                     sizeof(ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t)))
                 {
@@ -1385,6 +1449,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
 
             err = FM_PCD_CcNodeModifyMissNextEngine(p_LnxWrpFmDev->h_PcdDev, param->id,
                     (t_FmPcdCcNextEngineParams*)(&param->cc_next_engine_params));
+
             XX_Free(param);
             break;
         }
@@ -1401,6 +1466,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_cc_node_remove_key_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1414,6 +1481,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_node_remove_key_params_t));
                 if (copy_from_user(compat_param,
                             (ioc_compat_fm_pcd_cc_node_remove_key_params_t *)compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_node_remove_key_params_t)))
@@ -1440,6 +1508,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             }
 
             err = FM_PCD_CcNodeRemoveKey(p_LnxWrpFmDev->h_PcdDev, param->id, param->key_indx);
+
             XX_Free(param);
             break;
         }
@@ -1451,13 +1520,13 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         {
             ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *param;
 
-            ASSERT_COND(sizeof(ioc_fm_pcd_cc_key_params_t) == sizeof(t_FmPcdCcKeyParams));
-
             param = (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1471,6 +1540,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
                 if (copy_from_user(compat_param,
                             (ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)))
@@ -1500,6 +1570,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     param->key_indx,
                     param->key_size,
                     (t_FmPcdCcKeyParams*)(&param->key_params));
+
             XX_Free(param);
             break;
         }
@@ -1511,13 +1582,13 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
         {
             ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *param;
 
-            ASSERT_COND(sizeof(ioc_fm_pcd_cc_key_params_t) == sizeof(t_FmPcdCcKeyParams));
-
             param = (ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t *) XX_Malloc(
                     sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1532,6 +1603,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t));
                 if (copy_from_user(compat_param,
                             (ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t *)compat_ptr(arg),
                             sizeof(ioc_compat_fm_pcd_cc_node_modify_key_and_next_engine_params_t)))
@@ -1561,6 +1633,7 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     param->key_indx,
                     param->key_size,
                     (t_FmPcdCcKeyParams*)(&param->key_params));
+
             XX_Free(param);
             break;
         }
@@ -1570,8 +1643,8 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
 #endif
         case FM_PCD_IOC_CC_NODE_MODIFY_KEY:
         {
-            ioc_fm_pcd_cc_node_modify_key_params_t  *param = NULL;
-            uint8_t                                 *key = NULL;
+            ioc_fm_pcd_cc_node_modify_key_params_t  *param;
+            uint8_t                                 *key  = NULL;
             uint8_t                                 *mask = NULL;
 
             param = (ioc_fm_pcd_cc_node_modify_key_params_t *) XX_Malloc(
@@ -1579,18 +1652,22 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_cc_node_modify_key_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
-                ioc_compat_fm_pcd_cc_node_modify_key_params_t  *compat_param = NULL;
+                ioc_compat_fm_pcd_cc_node_modify_key_params_t  *compat_param;
+
                 compat_param = (ioc_compat_fm_pcd_cc_node_modify_key_params_t *) XX_Malloc(
                         sizeof(ioc_compat_fm_pcd_cc_node_modify_key_params_t));
-                if (!param)
+                if (!compat_param)
                 {
                     XX_Free(param);
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_cc_node_modify_key_params_t));
                 if (copy_from_user(compat_param, (ioc_compat_fm_pcd_cc_node_modify_key_params_t *)compat_ptr(arg),
                                     sizeof(ioc_compat_fm_pcd_cc_node_modify_key_params_t)))
                 {
@@ -1614,46 +1691,48 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                 }
             }
 
-            if (param->p_key)
+            if (!param->p_key)
             {
-                key = (uint8_t *) XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
-                if (!key)
-                {
-                    XX_Free(param);
-                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD key"));
-                }
-                memset(key, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+                XX_Free(param);
+                RETURN_ERROR(MINOR, E_NULL_POINTER, ("IOCTL FM PCD key"));
+            }
 
-                if (copy_from_user(key, param->p_key, param->key_size))
-                {
-                    XX_Free(key);
-                    XX_Free(param);
-                    RETURN_ERROR(MINOR, err, NO_MSG);
-                }
-                param->p_key = key;
+            key = (uint8_t *) XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+            if (!key)
+            {
+                XX_Free(param);
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD key"));
+            }
+
+            memset(key, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
+            if (copy_from_user(key, param->p_key, param->key_size))
+            {
+                XX_Free(key);
+                XX_Free(param);
+                RETURN_ERROR(MINOR, err, NO_MSG);
             }
 
+            param->p_key = key;
+
             if (param->p_mask)
             {
                 mask = (uint8_t *) XX_Malloc(sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
                 if (!mask)
                 {
-                    if (key)
-                        XX_Free(key);
+                    if (key) XX_Free(key);
                     XX_Free(param);
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD mask"));
                 }
-                memset(mask, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
 
+                memset(mask, 0, sizeof(uint8_t)*IOC_FM_PCD_MAX_SIZE_OF_KEY);
                 if (copy_from_user(mask, param->p_mask, param->key_size))
                 {
-                    if (mask)
-                        XX_Free(mask);
-                    if (key)
-                        XX_Free(key);
+                    XX_Free(mask);
+                    if (key) XX_Free(key);
                     XX_Free(param);
                     RETURN_ERROR(MINOR, err, NO_MSG);
                 }
+
                 param->p_mask = mask;
             }
 
@@ -1663,13 +1742,152 @@ static t_Error LnxwrpFmPcdIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd,
                     param->key_size,
                     param->p_key,
                     param->p_mask);
-            if (mask)
-                XX_Free(mask);
-            if (key)
-                XX_Free(key);
+
+            if (mask) XX_Free(mask);
+            if (key)  XX_Free(key);
+
             XX_Free(param);
             break;
         }
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_MANIP_SET_NODE_COMPAT:
+#else
+        case FM_PCD_IOC_MANIP_SET_NODE:
+#endif
+        {
+            ioc_fm_pcd_manip_params_t *param;
+
+            param = (ioc_fm_pcd_manip_params_t *) XX_Malloc(
+                        sizeof(ioc_fm_pcd_manip_params_t));
+
+            if (!param)
+                RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+            memset(param, 0, sizeof(ioc_fm_pcd_manip_params_t));
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_manip_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_manip_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_manip_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_manip_params_t));
+                if (copy_from_user(compat_param,
+                            (ioc_compat_fm_pcd_manip_params_t *) compat_ptr(arg),
+                            sizeof(ioc_compat_fm_pcd_manip_params_t)))
+                {
+                    XX_Free(compat_param);
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+
+                compat_fm_pcd_manip_set_node(compat_param, param, COMPAT_US_TO_K);
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(param, (ioc_fm_pcd_manip_params_t *)arg,
+                                            sizeof(ioc_fm_pcd_manip_params_t)))
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, err, NO_MSG);
+                }
+            }
+
+            param->id = FM_PCD_ManipSetNode(p_LnxWrpFmDev->h_PcdDev,
+                            (t_FmPcdManipParams *)&param);
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_pcd_manip_params_t *compat_param;
+
+                compat_param = (ioc_compat_fm_pcd_manip_params_t *) XX_Malloc(
+                        sizeof(ioc_compat_fm_pcd_manip_params_t));
+                if (!compat_param)
+                {
+                    XX_Free(param);
+                    RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+                }
+
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_manip_params_t));
+
+                compat_fm_pcd_manip_set_node(compat_param, param, COMPAT_K_TO_US);
+                compat_param->id = compat_add_ptr2id(param->id);
+
+                if (param->id && !copy_to_user((ioc_compat_fm_pcd_manip_params_t *) compat_ptr(arg),
+                            compat_param,
+                            sizeof(ioc_compat_fm_pcd_manip_params_t)))
+                    err = E_OK;
+
+                XX_Free(compat_param);
+            }
+            else
+#endif
+            {
+                if (param->id && !copy_to_user((ioc_fm_pcd_manip_params_t *)arg,
+                                        param, sizeof(ioc_fm_pcd_manip_params_t)))
+                    err = E_OK;
+            }
+
+            XX_Free(param);
+        }
+        break;
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT:
+#else
+        case FM_PCD_IOC_MANIP_DELETE_NODE:
+#endif
+        {
+            ioc_fm_obj_t id;
+
+            memset(&id, 0, sizeof(ioc_fm_obj_t));
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                ioc_compat_fm_obj_t compat_id;
+
+                if (copy_from_user(&compat_id, (ioc_compat_fm_obj_t *) compat_ptr(arg), sizeof(ioc_compat_fm_obj_t)))
+                    break;
+
+                id.obj = compat_ptr(compat_id.obj);
+            }
+            else
+#endif
+            {
+                if (copy_from_user(&id, (ioc_fm_obj_t *) arg, sizeof(ioc_fm_obj_t)))
+                    break;
+            }
+
+            return FM_PCD_ManipDeleteNode(p_LnxWrpFmDev->h_PcdDev, id.obj);
+        }
+        break;
+#endif /* defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
+
+#ifdef FM_CAPWAP_SUPPORT
+#if defined(CONFIG_COMPAT)
+        case FM_PCD_IOC_STATISTICS_SET_NODE_COMPAT:
+#else
+        case FM_PCD_IOC_STATISTICS_SET_NODE:
+#endif
+        {
+            ioc_fm_pcd_stats_params_t param;
+#warning "TODO"
+            param->id = FM_PCD_StatisticsSetNode(p_LnxWrpFmDev->h_PcdDev,
+                                (t_FmPcdStatsParams *)&param);
+        }
+        break;
+#endif /* FM_CAPWAP_SUPPORT */
 
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL cmd (0x%08x):(0x%02x:0x%02x)!", cmd, _IOC_TYPE(cmd), _IOC_NR(cmd)));
@@ -1697,6 +1915,8 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_port_bandwidth_params));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1766,6 +1986,8 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_counters_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1799,6 +2021,8 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
 
+            memset(param, 0, sizeof(ioc_fm_counters_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1909,6 +2133,8 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
 
+            memset(param, 0, sizeof(ioc_fm_port_rate_limit_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -1937,7 +2163,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
         case FM_PORT_IOC_REMOVE_RATE_LIMIT:
             FM_PORT_DeleteRateLimit(p_LnxWrpFmPortDev->h_Dev);
             return E_OK;
-        
+
         case FM_PORT_IOC_ALLOC_PCD_FQIDS:
         {
             ioc_fm_port_pcd_fqids_params_t *param;
@@ -1949,6 +2175,8 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
 
+            memset(param, 0, sizeof(ioc_fm_port_pcd_fqids_params_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -2054,6 +2282,12 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             if (!port_pcd_params)
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
 
+            memset(port_pcd_params, 0,
+                    sizeof(ioc_fm_port_pcd_params_t) +
+                    sizeof(ioc_fm_port_pcd_prs_params_t) +
+                    sizeof(ioc_fm_port_pcd_cc_params_t) +
+                    sizeof(ioc_fm_port_pcd_kg_params_t) +
+                    sizeof(ioc_fm_port_pcd_plcr_params_t));
             port_pcd_prs_params  = (ioc_fm_port_pcd_prs_params_t *)  (port_pcd_params + 1);
             port_pcd_cc_params   = (ioc_fm_port_pcd_cc_params_t *)   (port_pcd_prs_params + 1);
             port_pcd_kg_params   = (ioc_fm_port_pcd_kg_params_t *)   (port_pcd_cc_params + 1);
@@ -2080,6 +2314,12 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
                 }
 
+                memset(compat_port_pcd_params, 0,
+                        sizeof(ioc_compat_fm_port_pcd_params_t) +
+                        sizeof(ioc_fm_port_pcd_prs_params_t) +
+                        sizeof(ioc_compat_fm_port_pcd_cc_params_t) +
+                        sizeof(ioc_compat_fm_port_pcd_kg_params_t) +
+                        sizeof(ioc_compat_fm_port_pcd_plcr_params_t));
                 same_port_pcd_prs_params    = (ioc_fm_port_pcd_prs_params_t *) (compat_port_pcd_params + 1);
                 compat_port_pcd_cc_params   = (ioc_compat_fm_port_pcd_cc_params_t *) (same_port_pcd_prs_params + 1);
                 compat_port_pcd_kg_params   = (ioc_compat_fm_port_pcd_kg_params_t *) (compat_port_pcd_cc_params + 1);
@@ -2227,6 +2467,8 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_kg_scheme_select_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -2239,6 +2481,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
                     RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
                 }
 
+                memset(compat_param, 0, sizeof(ioc_compat_fm_pcd_kg_scheme_select_t));
                 if (copy_from_user(compat_param,
                                    (ioc_compat_fm_pcd_kg_scheme_select_t *) compat_ptr(arg),
                                    sizeof(ioc_compat_fm_pcd_kg_scheme_select_t)))
@@ -2277,6 +2520,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             ioc_fm_obj_t id;
 
             memset(&id, 0 , sizeof(ioc_fm_obj_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat) {
                 ioc_compat_fm_obj_t compat_id;
@@ -2310,7 +2554,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
 
-            memset(&param, 0 , sizeof(ioc_fm_pcd_port_schemes_params_t));
+            memset(param, 0 , sizeof(ioc_fm_pcd_port_schemes_params_t));
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -2355,7 +2599,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
 
-            memset(&param, 0 , sizeof(ioc_fm_pcd_port_schemes_params_t));
+            memset(param, 0 , sizeof(ioc_fm_pcd_port_schemes_params_t));
 
 #if defined(CONFIG_COMPAT)
             if (compat)
@@ -2396,6 +2640,8 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             if (!param)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PORT"));
 
+            memset(param, 0, sizeof(ioc_fm_pcd_prs_start_t));
+
 #if defined(CONFIG_COMPAT)
             if (compat)
             {
@@ -2416,6 +2662,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
                     RETURN_ERROR(MAJOR, E_WRITE_FAILED, NO_MSG);
                 }
             }
+
             err = FM_PORT_PcdPrsModifyStartOffset(p_LnxWrpFmPortDev->h_Dev, (t_FmPcdPrsStart *)param);
 
             XX_Free(param);
@@ -2427,6 +2674,7 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
             uint16_t num;
             if (get_user(num, (uint16_t*) arg))
                 break;
+
             return FM_PORT_PcdPlcrAllocProfiles(p_LnxWrpFmPortDev->h_Dev, num);
         }
 
@@ -2467,7 +2715,27 @@ t_Error LnxwrpFmPortIOCTL(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev, unsigned int cmd
 
             return FM_PORT_PcdCcModifyTree(p_LnxWrpFmPortDev->h_Dev, id.obj);
         }
+#if defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+        case FM_PORT_SET_OP_WORKAROUNDS:
+        {
+            fmOpPortWorkaroundsSelect_t workarounds; /* uint32_t type */
+
+#if defined(CONFIG_COMPAT)
+            if (compat)
+            {
+                if (get_user(workarounds, (fmOpPortWorkaroundsSelect_t *) compat_ptr(arg)))
+                    break;
+            }
+            else
+#endif
+            {
+                if (get_user(workarounds, (fmOpPortWorkaroundsSelect_t *)arg))
+                    break;
+            }
 
+            return FM_PORT_SetOpWorkarounds(p_LnxWrpFmPortDev->h_Dev, workarounds);
+        }
+#endif /* defined(FM_IPSEC_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT) */
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("IOCTL cmd (0x%08x):(0x%02x:0x%02x)!", cmd, _IOC_TYPE(cmd), _IOC_NR(cmd)));
     }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
index f2920df..d07d60c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -319,8 +319,8 @@ static inline void compat_copy_fm_pcd_cc_next_engine(
                 memcpy(&param->params, &compat_param->params, sizeof(param->params));
             break;
         }
-#ifdef FM_PCD_CC_MANIP
-        param->p_manip = compat_ptr(compat_param->p_manip);
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+        param->manip = compat_ptr(compat_param->p_manip);
 #endif
     }
     else
@@ -339,9 +339,8 @@ static inline void compat_copy_fm_pcd_cc_next_engine(
                 memcpy(&compat_param->params, &param->params, sizeof(compat_param->params));
             break;
         }
-
-#ifdef FM_PCD_CC_MANIP
-        compat_param->p_manip = ptr_to_compat(param->p_manip);
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+        compat_param->p_manip = ptr_to_compat(param->manip);
 #endif
     }
 }
@@ -485,6 +484,9 @@ void compat_copy_fm_pcd_cc_tree(
                     &compat_param->fm_pcd_cc_group_params[k],
                     &param->fm_pcd_cc_group_params[k],
                     compat);
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        param->ip_reassembly_manip = compat_ptr(compat_param->ip_reassembly_manip);
+#endif
         param->id = compat_ptr(compat_param->id);
     }
     else
@@ -496,6 +498,9 @@ void compat_copy_fm_pcd_cc_tree(
                     &compat_param->fm_pcd_cc_group_params[k],
                     &param->fm_pcd_cc_group_params[k],
                     compat);
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        compat_param->ip_reassembly_manip = ptr_to_compat(param->ip_reassembly_manip);
+#endif
         compat_param->id = ptr_to_compat(param->id);
     }
 }
@@ -787,3 +792,39 @@ void compat_copy_fm_pcd_cc_node(
     }
 }
 
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+void compat_fm_pcd_manip_set_node(
+        ioc_compat_fm_pcd_manip_params_t *compat_param,
+        ioc_fm_pcd_manip_params_t *param,
+        uint8_t compat)
+{
+    if (compat) {
+	param->rmv = compat_param->rmv;
+	memcpy(&param->rmv_params, &compat_param->rmv_params, sizeof(ioc_fm_pcd_manip_rmv_params_t));
+
+	param->insrt = compat_param->insrt;
+	memcpy(&param->insrt_params, &compat_param->insrt_params, sizeof(ioc_fm_pcd_manip_insrt_params_t));
+
+	param->frag_or_reasm = compat_param->frag_or_reasm;
+	memcpy(&param->frag_or_reasm_params, &compat_param->frag_or_reasm_params, sizeof(ioc_fm_pcd_manip_frag_or_reasm_params_t));
+
+	param->treat_fd_status_fields_as_errors = compat_param->treat_fd_status_fields_as_errors;
+
+	param->id = compat_get_id2ptr(compat_param->id);
+    }
+    else {
+	compat_param->rmv = param->rmv;
+	memcpy(&compat_param->rmv_params, &param->rmv_params, sizeof(ioc_fm_pcd_manip_rmv_params_t));
+
+	compat_param->insrt = param->insrt;
+	memcpy(&compat_param->insrt_params, &param->insrt_params, sizeof(ioc_fm_pcd_manip_insrt_params_t));
+
+	compat_param->frag_or_reasm = param->frag_or_reasm;
+	memcpy(&compat_param->frag_or_reasm_params, &param->frag_or_reasm_params, sizeof(ioc_fm_pcd_manip_frag_or_reasm_params_t));
+
+	compat_param->treat_fd_status_fields_as_errors = param->treat_fd_status_fields_as_errors;
+
+	compat_param->id = ptr_to_compat(param->id);
+    }
+}
+#endif
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
index 78d9b03..ba08200 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -156,7 +156,7 @@ typedef struct ioc_compat_fm_pcd_cc_next_engine_params_t {
             ioc_fm_pcd_cc_next_enqueue_params_t        enqueue_params; /**< same structure*/
             ioc_compat_fm_pcd_cc_next_kg_params_t      kg_params;      /**< compat structure*/
     } params;
-#ifdef FM_PCD_CC_MANIP
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
     compat_uptr_t                                      p_manip;
 #endif
 } ioc_compat_fm_pcd_cc_next_engine_params_t;
@@ -175,6 +175,9 @@ typedef struct ioc_compat_fm_pcd_cc_tree_params_t {
     compat_uptr_t                   net_env_id;
     uint8_t                         num_of_groups;
     ioc_compat_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+    compat_uptr_t                   ip_reassembly_manip;
+#endif
     compat_uptr_t                   id;
 } ioc_compat_fm_pcd_cc_tree_params_t;
 
@@ -287,6 +290,20 @@ typedef struct ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t {
     uint8_t                             key_size;
     ioc_compat_fm_pcd_cc_next_engine_params_t  cc_next_engine_params;
 } ioc_compat_fm_pcd_cc_node_modify_next_engine_params_t;
+
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+typedef struct ioc_compat_fm_pcd_manip_params_t{
+    bool                                        rmv;
+    ioc_fm_pcd_manip_rmv_params_t               rmv_params;
+    bool                                        insrt;
+    ioc_fm_pcd_manip_insrt_params_t             insrt_params;
+    bool                                        frag_or_reasm;
+    ioc_fm_pcd_manip_frag_or_reasm_params_t     frag_or_reasm_params;
+    bool                                        treat_fd_status_fields_as_errors;
+    compat_uptr_t                               id;
+}ioc_compat_fm_pcd_manip_params_t;
+#endif
+
 /* } pcd compat structures */
 
 /* pcd compat functions { */
@@ -374,6 +391,11 @@ void compat_copy_fm_pcd_cc_node(
         ioc_compat_fm_pcd_cc_node_params_t *compat_param,
         ioc_fm_pcd_cc_node_params_t *param,
         uint8_t compat);
-
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+void compat_fm_pcd_manip_set_node(
+        ioc_compat_fm_pcd_manip_params_t *compat_param,
+        ioc_fm_pcd_manip_params_t *param,
+        uint8_t compat);
+#endif
 /* } pcd compat functions */
 #endif
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
index b0977a7..8a86f2d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -569,7 +569,7 @@ precalculated_fifosize_out:
 	return err;
 }
 
-int fm_set_precalculate_fifosize(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+int fm_config_precalculate_fifosize(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 {
 	t_LnxWrpFmDev *p_LnxWrpFmDev =
 		(t_LnxWrpFmDev *) p_LnxWrpFmPortDev->h_LnxWrpFmDev;
@@ -622,7 +622,7 @@ int fm_set_precalculate_fifosize(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 		portRsrc.extra = 0;
 	}
 
-	errCode = FM_PORT_SetSizeOfFifo(p_LnxWrpFmPortDev->h_Dev, &portRsrc);
+	errCode = FM_PORT_ConfigSizeOfFifo(p_LnxWrpFmPortDev->h_Dev, &portRsrc);
 	if (errCode != E_OK) {
 		printk(KERN_WARNING
 		       "FM_PORT_SetSizeOfFifo failed (errCode:0x%2x)",
@@ -881,7 +881,7 @@ precalculated_open_dma_out:
 	return err;
 }
 
-int fm_set_precalculate_open_dma(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+int fm_config_precalculate_open_dma(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 {
 	t_LnxWrpFmDev *p_LnxWrpFmDev =
 		(t_LnxWrpFmDev *) p_LnxWrpFmPortDev->h_LnxWrpFmDev;
@@ -916,7 +916,7 @@ int fm_set_precalculate_open_dma(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 
 	numOfOpenDmas.extra = fm_resource_settings_info->shared_ext_open_dma;
 
-	errCode = FM_PORT_SetNumOfOpenDmas(p_LnxWrpFmPortDev->h_Dev,
+	errCode = FM_PORT_ConfigNumOfOpenDmas(p_LnxWrpFmPortDev->h_Dev,
 					      &numOfOpenDmas);
 	if (errCode != E_OK) {
 		printk(KERN_WARNING
@@ -1125,7 +1125,7 @@ precalculated_tnums_out:
 	return err;
 }
 
-int fm_set_precalculate_tnums(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
+int fm_config_precalculate_tnums(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 {
 	t_LnxWrpFmDev *p_LnxWrpFmDev =
 		(t_LnxWrpFmDev *) p_LnxWrpFmPortDev->h_LnxWrpFmDev;
@@ -1160,7 +1160,7 @@ int fm_set_precalculate_tnums(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 
 	numOfTask.extra = fm_resource_settings_info->shared_ext_tnums;
 
-	errCode = FM_PORT_SetNumOfTasks(p_LnxWrpFmPortDev->h_Dev, &numOfTask);
+	errCode = FM_PORT_ConfigNumOfTasks(p_LnxWrpFmPortDev->h_Dev, &numOfTask);
 	if (errCode != E_OK) {
 		printk(KERN_WARNING
 		       "FM_PORT_SetNumOfTasks failed (errCode:0x%2x)",
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h
index d78dea9..47f3269 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -80,7 +80,7 @@ int fm_set_active_fman_ports(struct platform_device *of_dev,
 int fm_precalculate_fifosizes(t_LnxWrpFmDev *p_LnxWrpFmDev,
 			   int muram_fifo_size);
 
-int fm_set_precalculate_fifosize(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev);
+int fm_config_precalculate_fifosize(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev);
 
 /* Compute FMan open DMA based on total number of open DMAs and
  * number of available fman ports.
@@ -100,12 +100,12 @@ int fm_precalculate_open_dma(t_LnxWrpFmDev *p_LnxWrpFmDev,
 			  int default_rx_10g_dmas,
 			  int min_tx_10g_treshold, int min_rx_10g_treshold);
 
-int fm_set_precalculate_open_dma(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev);
+int fm_config_precalculate_open_dma(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev);
 
 /* Compute FMan tnums based on available tnums and number of ports.
  * Set defaults (minim tresholds) and then distribute leftovers.*/
 int fm_precalculate_tnums(t_LnxWrpFmDev *p_LnxWrpFmDev, int max_fm_tnums);
 
-int fm_set_precalculate_tnums(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev);
+int fm_config_precalculate_tnums(t_LnxWrpFmPortDev *p_LnxWrpFmPortDev);
 
 #endif /* LNXWRP_RESOURCES_H_ */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c
index 9adb789..210725a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h
index e26ef57..713e973 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c
index b2d6ec5..37d5e09 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h
index 9220de0..3c98ff1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c
index 28ebb66..856139c 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h
index a44c16e..8ca7ca3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_sysfs_fm_port.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/stdlib.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/stdlib.c
index 321e13f..8032753b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/stdlib.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/stdlib.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/udivdi3.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/udivdi3.c
index 9272d2a..1990f02 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/udivdi3.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/udivdi3.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
index f463273..9419e40 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/include/linux/fmd/Peripherals/fm_ioctls.h b/include/linux/fmd/Peripherals/fm_ioctls.h
index cc6b99b..ea86c14 100644
--- a/include/linux/fmd/Peripherals/fm_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index 16eb325..f750006 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -104,6 +104,9 @@
 #define IOC_FM_PCD_KG_NUM_OF_DEFAULT_GROUPS             16                  /**< Number of default value logical groups */
 
 #define IOC_FM_PCD_PRS_NUM_OF_LABELS                    32                  /**< Max number of SW parser label */
+#define IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE        128                 /**< Max possible size of insertion template for
+                                                                             insert manipulation*/
+
 /* @} */
 
 /**************************************************************************//**
@@ -122,12 +125,12 @@
                 In order to explain the programming model of the PCD driver interface
                 a few terms should be explained, and will be used below.
                   * Distinction Header - One of the 16 protocols supported by the FM parser,
-                    or one of the shim headers (1-3). May be a header with a special
+                    or one of the shim headers (1 or 2). May be a header with a special
                     option (see below).
                   * Interchangeable Headers Group- This is a group of Headers recognized
                     by either one of them. For example, if in a specific context the user
                     chooses to treat IPv4 and IPV6 in the same way, they may create an
-                    Interchangable Headers Unit consisting of these 2 headers.
+                    interchangeable Headers Unit consisting of these 2 headers.
                   * A Distinction Unit - a Distinction Header or an Interchangeable Headers
                     Group.
                   * Header with special option - applies to ethernet, mpls, vlan, ipv4 and
@@ -146,6 +149,7 @@
                 Later, when needed, the application will have to state, for some of its modules,
                 to which single environment it belongs.
 
+
  @{
 *//***************************************************************************/
 
@@ -427,13 +431,31 @@ typedef ioc_protocol_opt_t  ioc_ipv4_protocol_opt_t; /**< IPv4 protocol options.
 #define IOC_IPV4_UNICAST_2              0x02000000   /**< Tunneled IPv4 - Unicast. */
 #define IOC_IPV4_MULTICAST_BROADCAST_2  0x01000000   /**< Tunneled IPv4 - Broadcast/Multicast. */
 
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+#define IOC_IPV4_FRAG_1                 0x00000008
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
 typedef ioc_protocol_opt_t  ioc_ipv6_protocol_opt_t; /**< IPv6 protocol options. */
 #define IOC_IPV6_MULTICAST_1            0x00800000   /**< IPv6 Multicast. */
 #define IOC_IPV6_UNICAST_2              0x00400000   /**< Tunneled IPv6 - Unicast. */
 #define IOC_IPV6_MULTICAST_2            0x00200000   /**< Tunneled IPv6 - Multicast. */
+
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+#define IOC_IPV6_FRAG_1                 0x00000004
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
 /* @} */
 
 /**************************************************************************//**
+ @Description   A type used for returning the order of the key extraction.
+                each value in this array represents the index of the extraction
+                command as defined by the user in the initialization extraction array.
+                The valid size of this array is the user define number of extractions
+                required (also marked by the second '0' in this array).
+*//***************************************************************************/
+typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+
+/**************************************************************************//**
  @Description   All PCD engines
                 (must match enum e_FmPcdEngine defined in fm_pcd_ext.h)
 *//***************************************************************************/
@@ -622,14 +644,56 @@ typedef enum ioc_fm_pcd_action {
     e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP                  /**< Indexed lookup on the selected extraction*/
 } ioc_fm_pcd_action;
 
-/**************************************************************************//**
- @Description   A type used for returning the order of the key extraction.
-                each value in this array represents the index of the extraction
-                command as defined by the user in the initialization extraction array.
-                The valid size of this array is the user define number of extractions
-                required (also marked by the second '0' in this array).
-*//***************************************************************************/
-typedef    uint8_t    ioc_fm_pcd_kg_key_order_t [IOC_FM_PCD_KG_MAX_NUM_OF_EXTRACTS_PER_KEY];
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+/**************************************************************************//**
+ @Description   enums sinchronized w/ the enums from fm_pcd_ext.h
+*//***************************************************************************/
+typedef enum ioc_fm_pcd_manip_insrt {
+    e_IOC_FM_PCD_MANIP_INSRT_NONE = 0,
+    e_IOC_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_INT_FRAME_HDR,
+    e_IOC_FM_PCD_MANIP_INSRT_TO_START_OF_FRAME_TEMPLATE
+} ioc_fm_pcd_manip_insrt;
+
+typedef enum ioc_fm_pcd_manip_rmv {
+    e_IOC_FM_PCD_MANIP_RMV_NONE = 0,
+    e_IOC_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_SPECIFIC_LOCATION,
+    e_IOC_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,
+    e_IOC_FM_PCD_MANIP_RMV_INT_FRAME_HDR
+} ioc_fm_pcd_manip_rmv;
+
+typedef enum ioc_fm_pcd_manip_locate {
+    e_IOC_FM_PCD_MANIP_LOC_BY_HDR = 0,
+    e_IOC_FM_PCD_MANIP_LOC_NON_HDR
+} ioc_fm_pcd_manip_locate;
+
+typedef enum ioc_fm_pcd_manip_reassem_time_out_mode {
+    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES,
+    e_IOC_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAG
+} ioc_fm_pcd_manip_reassem_time_out_mode;
+
+typedef enum ioc_fm_pcd_manip_reassem_ways_number {
+    e_IOC_FM_PCD_MANIP_ONE_WAY_HASH = 1,
+    e_IOC_FM_PCD_MANIP_TWO_WAYS_HASH,
+    e_IOC_FM_PCD_MANIP_THREE_WAYS_HASH,
+    e_IOC_FM_PCD_MANIP_FOUR_WAYS_HASH,
+    e_IOC_FM_PCD_MANIP_FIVE_WAYS_HASH,
+    e_IOC_FM_PCD_MANIP_SIX_WAYS_HASH,
+    e_IOC_FM_PCD_MANIP_SEVEN_WAYS_HASH,
+    e_IOC_FM_PCD_MANIP_EIGHT_WAYS_HASH
+} ioc_fm_pcd_manip_reassem_ways_number;
+
+typedef enum ioc_fm_pcd_stats {
+    e_IOC_FM_PCD_STATS_PER_FLOWID = 0
+} ioc_fm_pcd_stats;
+
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+typedef enum ioc_fm_pcd_manip_dont_frag_action {
+    e_IOC_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = 0,
+    e_IOC_FM_PCD_MANIP_FRAGMENT_PACKECT,
+    e_IOC_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG
+} ioc_fm_pcd_manip_dont_frag_action;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
 
 /**************************************************************************//**
  @Description   A Union of protocol dependent special options
@@ -646,21 +710,22 @@ typedef union ioc_fm_pcd_hdr_protocol_opt_u {
  @Description   A union holding all known protocol fields
 *//***************************************************************************/
 typedef union ioc_fm_pcd_fields_u {
-    ioc_header_field_eth_t        eth;        /**< eth      */
-    ioc_header_field_vlan_t       vlan;       /**< vlan     */
-    ioc_header_field_llc_snap_t   llc_snap;   /**< llcSnap  */
-    ioc_header_field_pppoe_t      pppoe;      /**< pppoe    */
-    ioc_header_field_mpls_t       mpls;       /**< mpls     */
-    ioc_header_field_ipv4_t       ipv4;       /**< ipv4     */
-    ioc_header_field_ipv6_t       ipv6;       /**< ipv6     */
-    ioc_header_field_udp_t        udp;        /**< udp      */
-    ioc_header_field_tcp_t        tcp;        /**< tcp      */
-    ioc_header_field_sctp_t       sctp;       /**< sctp     */
-    ioc_header_field_dccp_t       dccp;       /**< dccp     */
-    ioc_header_field_gre_t        gre;        /**< gre      */
-    ioc_header_field_minencap_t   minencap;   /**< minencap */
-    ioc_header_field_ipsec_ah_t   ipsec_ah;   /**< ipsecAh  */
-    ioc_header_field_ipsec_esp_t  ipsec_esp;  /**< ipsecEsp */
+    ioc_header_field_eth_t              eth;        /**< eth      */
+    ioc_header_field_vlan_t             vlan;       /**< vlan     */
+    ioc_header_field_llc_snap_t         llc_snap;   /**< llcSnap  */
+    ioc_header_field_pppoe_t            pppoe;      /**< pppoe    */
+    ioc_header_field_mpls_t             mpls;       /**< mpls     */
+    ioc_header_field_ipv4_t             ipv4;       /**< ipv4     */
+    ioc_header_field_ipv6_t             ipv6;       /**< ipv6     */
+    ioc_header_field_udp_t              udp;        /**< udp      */
+    ioc_header_field_tcp_t              tcp;        /**< tcp      */
+    ioc_header_field_sctp_t             sctp;       /**< sctp     */
+    ioc_header_field_dccp_t             dccp;       /**< dccp     */
+    ioc_header_field_gre_t              gre;        /**< gre      */
+    ioc_header_field_minencap_t         minencap;   /**< minencap */
+    ioc_header_field_ipsec_ah_t         ipsec_ah;   /**< ipsecAh  */
+    ioc_header_field_ipsec_esp_t        ipsec_esp;  /**< ipsecEsp */
+    ioc_header_field_udp_encap_esp_t    udp_encap_esp;    /**< udpEncapEsp */
 } ioc_fm_pcd_fields_u;
 
 /**************************************************************************//**
@@ -733,7 +798,7 @@ typedef struct ioc_fm_pcd_extract_entry_t {
             ioc_fm_pcd_extract_from         src;            /**< Non-header extraction source */
             ioc_fm_pcd_action               action;         /**< Relevant for CC Only */
             uint16_t                        ic_indx_mask;   /**< Relevant only for CC where
-                                                                 action=e_FM_PCD_ACTION_INDEXED_LOOKUP */
+                                                                 action=e_IOC_FM_PCD_ACTION_INDEXED_LOOKUP */
             uint8_t                         offset;         /**< Byte offset */
             uint8_t                         size;           /**< Size in byte */
         } extract_non_hdr;
@@ -794,6 +859,7 @@ typedef struct ioc_fm_pcd_kg_extracted_or_params_t {
             ioc_fm_pcd_hdr_index            hdr_index;          /**< Relevant only for MPLS, VLAN and tunneled
                                                                      IP. Otherwise should be cleared.*/
             bool                            ignore_protocol_validation;
+
         } extract_by_hdr;
         ioc_fm_pcd_extract_from             src;                /**< used when type = e_IOC_FM_PCD_KG_EXTRACT_NON_HDR */
     } extract_params;
@@ -801,7 +867,29 @@ typedef struct ioc_fm_pcd_kg_extracted_or_params_t {
     ioc_fm_pcd_kg_extract_dflt_select       dflt_value;         /**< Select register from which extraction is taken if
                                                                      field not found */
     uint8_t                                 mask;               /**< Mask LSB byte of extraction (specified bits are ignored) */
-    uint8_t                                 bit_offset_in_fqid; /**< out of 24 bits Qid  (max offset = 16) */
+    uint8_t                         bit_offset_in_fqid;    /**< 0-31, Selects which bits of the 24 FQID bits to effect using
+                                                             the extracted byte; Assume byte is placed as the 8 MSB's in
+                                                             a 32 bit word where the lower bits
+                                                             are the FQID; i.e if bitOffsetInFqid=1 than its LSB
+                                                             will effect the FQID MSB, if bitOffsetInFqid=24 than the
+                                                             extracted byte will effect the 8 LSB's of the FQID,
+                                                             if bitOffsetInFqid=31 than the byte's MSB will effect
+                                                             the FQID's LSB; 0 means - no effect on FQID;
+                                                             Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
+    uint8_t                         bit_offset_in_plcr_profile;
+                                                        /**< 0-15, Selects which bits of the 8 policer profile id bits to
+                                                             effect using the extracted byte; Assume byte is placed
+                                                             as the 8 MSB's in a 16 bit word where the lower bits
+                                                             are the policer profile id; i.e if bitOffsetInPlcrProfile=1
+                                                             than its LSB will effect the profile MSB, if bitOffsetInFqid=8
+                                                             than the extracted byte will effect the whole policer profile id,
+                                                             if bitOffsetInFqid=15 than the byte's MSB will effect
+                                                             the Policer Profile id's LSB;
+                                                             0 means - no effect on policer profile; Note that one, and only one of
+                                                             bitOffsetInFqid or bitOffsetInPlcrProfile must be set (i.e,
+                                                             extracted byte must effect either FQID or Policer profile).*/
 } ioc_fm_pcd_kg_extracted_or_params_t;
 
 /**************************************************************************//**
@@ -876,8 +964,7 @@ typedef struct ioc_fm_pcd_kg_scheme_params_t {
     bool                                always_direct;   /**< This scheme is reached only directly, i.e.
                                                               no need for match vector. Keygen will ignore
                                                               it when matching   */
-    struct                                               /**< HL Relevant only if alwaysDirect = FALSE */
-    {
+    struct {                                             /**< HL Relevant only if alwaysDirect = FALSE */
         void                            *net_env_id;     /**< Network environment id  */
         uint8_t                         num_of_distinction_units;
                                                          /**< Number of netenv units listed in unit_ids array */
@@ -952,10 +1039,10 @@ typedef struct ioc_fm_pcd_cc_next_plcr_params_t {
 typedef struct ioc_fm_pcd_cc_next_enqueue_params_t {
     ioc_fm_pcd_done_action  action;         /**< Action - when next engine is BMI (done) */
     bool                    override_fqid;  /**< TRUE if CC override previously decided Fqid(by Keygen),
-                                                 relevant if action = e_FM_PCD_ENQ_FRAME*/
+                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
     uint32_t                new_fqid;       /**< Valid if overrideFqid=TRUE, FQID for enquing the frame
                                                  (otherwise FQID is taken from keygen),
-                                                 relevant if action = e_FM_PCD_ENQ_FRAME*/
+                                                 relevant if action = e_IOC_FM_PCD_ENQ_FRAME*/
     bool                    statistics_en;   /**< In the case of TRUE Statistic counter is
                                                  incremented for each received frame passed through
                                                  this Coarse Classification entry.*/
@@ -990,10 +1077,8 @@ typedef struct ioc_fm_pcd_cc_next_engine_params_t {
             ioc_fm_pcd_cc_next_enqueue_params_t enqueue_params; /**< Parameters in case next engine is BMI */
             ioc_fm_pcd_cc_next_kg_params_t      kg_params;      /**< Parameters in case next engine is KG */
     } params;
-#if defined(FM_CAPWAP_SUPPORT)
-    void                                        *p_manip;       /**< Handler to headerManip.
-                                                                     Relevant if next engine of the type result
-                                                                     (e_FM_PCD_PLCR, e_FM_PCD_KG, e_FM_PCD_DONE) */
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+    void                                        *manip;
 #endif /* defined(FM_CAPWAP_SUPPORT) */
 } ioc_fm_pcd_cc_next_engine_params_t;
 
@@ -1075,6 +1160,9 @@ typedef struct ioc_fm_pcd_cc_tree_params_t {
         uint8_t                         num_of_groups;  /**< Number of CC groups within the CC tree */
         ioc_fm_pcd_cc_grp_params_t      fm_pcd_cc_group_params [IOC_FM_PCD_MAX_NUM_OF_CC_GROUPS];
                                                         /**< Parameters for each group. */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        void *                          *ip_reassembly_manip;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
         void                            *id;            /**< output parameter; Returns the tree Id to be used */
 } ioc_fm_pcd_cc_tree_params_t;
 
@@ -1214,6 +1302,127 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
                                                                  of the same size defined in the keySize */
 } ioc_fm_pcd_cc_node_modify_key_params_t;
 
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+/**************************************************************************//**
+ @Description  must match the struct defined in fm_pcd_ext.h
+*//***************************************************************************/
+typedef struct ioc_fm_pcd_manip_location_params_t {
+    ioc_fm_pcd_manip_locate             type;
+    struct {
+        ioc_net_header_type             hdr;
+        ioc_fm_pcd_hdr_index            hdr_index;
+        bool                            by_field;
+        ioc_fm_pcd_fields_u             full_field;
+    } manip_by_hdr;
+} ioc_fm_pcd_manip_location_params_t;
+
+typedef struct ioc_fm_pcd_manip_insrt_by_template_params_t {
+    uint8_t         size;
+    uint8_t         hdr_template[IOC_FM_PCD_MAX_MANIP_INSRT_TEMPLATE_SIZE];
+    bool            modify_outer_ip;
+    struct {
+        uint16_t    ip_outer_offset;
+        uint16_t    dscp_ecn;
+        bool        udp_present;
+        uint8_t     udp_offset;
+        uint8_t     ip_ident_genId;
+        bool        recalculate_length;
+        struct {
+            uint8_t block_size;
+            uint8_t extra_bytes_added_aligned_to_block_size;
+            uint8_t extra_bytes_added_not_aligned_to_block_size;
+        } recalculate_length_params;
+    } modify_outer_ip_params;
+    bool            modify_outer_vlan;
+    struct {
+        uint8_t     vpri;
+    } modify_outer_vlan_params;
+} ioc_fm_pcd_manip_insrt_by_template_params_t;
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+
+#ifdef FM_CAPWAP_SUPPORT
+typedef struct ioc_capwap_fragmentation_params_t {
+    uint16_t         size_for_fragmentation;
+    bool             header_options_compr;
+} ioc_capwap_fragmentation_params_t;
+
+typedef struct ioc_capwap_reassembly_params_t {
+    uint16_t                         max_numFrames_in_process;
+    bool                             halt_on_duplication_frag;
+    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;
+    uint32_t                        fqid_for_time_out_frames;
+    uint32_t                        timeout_routine_request_time;
+    uint32_t                        timeout_threshold_for_reassm_process;
+    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry;
+} ioc_capwap_reassembly_params_t;
+#endif /* FM_CAPWAP_SUPPORT */
+
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+typedef struct ioc_ip_fragmentation_params_t {
+    uint16_t                    size_for_fragmentation;
+    uint8_t                     scratch_bpid;
+    ioc_fm_pcd_manip_dont_frag_action  dont_frag_action;
+} ioc_ip_fragmentation_params_t;
+
+typedef struct ioc_ip_reassembly_params_t {
+    uint8_t                         relative_schemeId[2];
+    uint16_t                        liodn_offset;
+    uint8_t                         data_mem_id;
+    uint16_t                        min_frag_size[2];
+    uint16_t                        max_num_frames_in_process;
+    ioc_fm_pcd_manip_reassem_time_out_mode  time_out_mode;
+
+    uint32_t                        fqid_for_time_out_frames;
+    ioc_fm_pcd_manip_reassem_ways_number   num_of_frames_per_hash_entry;
+
+    uint32_t                        timeout_threshold_for_reassm_process;
+} ioc_ip_reassembly_params_t;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+typedef struct ioc_fm_pcd_manip_frag_or_reasm_params_t {
+    bool                                frag;
+    uint8_t                             ext_buf_pool_indx;
+    ioc_net_header_type                 hdr;
+    union {
+#ifdef FM_CAPWAP_SUPPORT
+        ioc_capwap_fragmentation_params_t capwap_frag_params;
+        ioc_capwap_reassembly_params      capwapReasmParams;
+#endif /* FM_CAPWAP_SUPPORT */
+#ifdef FM_IP_FRAG_N_REASSEM_SUPPORT
+        ioc_ip_fragmentation_params_t     ip_frag_params;
+        ioc_ip_reassembly_params_t        ip_reasm_params;
+#endif /* FM_IP_FRAG_N_REASSEM_SUPPORT */
+    };
+} ioc_fm_pcd_manip_frag_or_reasm_params_t;
+
+typedef struct ioc_fm_pcd_manip_insrt_params_t {
+    ioc_fm_pcd_manip_insrt                           type;
+    union {
+        ioc_fm_pcd_manip_insrt_by_template_params_t  insrt_by_template_params;
+    };
+} ioc_fm_pcd_manip_insrt_params_t;
+
+typedef struct ioc_fm_pcd_manip_rmv_params_t {
+    ioc_fm_pcd_manip_rmv                type ;
+    ioc_fm_pcd_manip_location_params_t  rmv_specific_location_params;
+} ioc_fm_pcd_manip_rmv_params_t;
+
+typedef struct ioc_fm_pcd_manip_params_t {
+    bool                                        rmv;
+    ioc_fm_pcd_manip_rmv_params_t               rmv_params;
+    bool                                        insrt;
+    ioc_fm_pcd_manip_insrt_params_t             insrt_params;
+    bool                                        frag_or_reasm;
+    ioc_fm_pcd_manip_frag_or_reasm_params_t     frag_or_reasm_params;
+    bool                                        treat_fd_status_fields_as_errors;
+    void                                        *id;
+} ioc_fm_pcd_manip_params_t;
+
+typedef struct ioc_fm_pcd_stats_params_t {
+    ioc_fm_pcd_stats  type;
+} ioc_fm_pcd_stats_params_t;
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
 
 /**************************************************************************//**
  @Function      FM_PCD_IOC_SET_NET_ENV_CHARACTERISTICS
@@ -1532,6 +1741,31 @@ typedef struct ioc_fm_pcd_cc_node_modify_key_params_t {
 #endif
 #define FM_PCD_IOC_PLCR_DEL_PROFILE     _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(38), ioc_fm_obj_t)
 
+
+#if defined(FM_CAPWAP_SUPPORT) || defined(FM_IP_FRAG_N_REASSEM_SUPPORT)
+
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_compat_fm_pcd_manip_params_t)
+#endif
+#define FM_PCD_IOC_MANIP_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), ioc_fm_pcd_manip_params_t)
+
+
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_MANIP_DELETE_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_MANIP_DELETE_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(40), ioc_fm_obj_t)
+
+#endif /* defined(FM_CAPWAP_SUPPORT) || ... */
+
+#ifdef FM_CAPWAP_SUPPORT
+#warning "CAPWAP IOCTL not implemented"
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_STATISTICS_SET_NODE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), void *)
+#endif
+#define FM_PCD_IOC_STATISTICS_SET_NODE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(39), void *)
+
+#endif /* FM_CAPWAP_SUPPORT */
+
 #endif /* __FM_PCD_IOCTLS_H */
 /** @} */ /* end of lnx_ioctl_FM_PCD_Runtime_grp group */
 /** @} */ /* end of lnx_ioctl_FM_PCD_grp group */
diff --git a/include/linux/fmd/Peripherals/fm_port_ioctls.h b/include/linux/fmd/Peripherals/fm_port_ioctls.h
index 3228a5c..88ff8d9 100644
--- a/include/linux/fmd/Peripherals/fm_port_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_port_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -674,6 +674,20 @@ typedef struct ioc_fm_port_pcd_fqids_params_t {
 *//***************************************************************************/
 #define      FM_PORT_IOC_PCD_PRS_MODIFY_START_OFFSET _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(32), ioc_fm_pcd_prs_start_t)
 
+/**************************************************************************//**
+ @Function      FM_PORT_SET_OP_WORKAROUNDS
+
+ @Description   Calling this routine sets the required offline port workaround.
+
+ @Param[in]     h_FmPort        FM PORT module descriptor.
+ @Param[in]     workarounds)    Reuired workaround.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_PORT_Init().
+*//***************************************************************************/
+#define      FM_PORT_SET_OP_WORKAROUNDS _IOW(FM_IOC_TYPE_BASE, FM_PORT_IOC_NUM(33), uint32_t)
+
 /** @} */ /* end of lnx_ioctl_FM_PORT_pcd_runtime_control_grp group */
 /** @} */ /* end of lnx_ioctl_FM_PORT_runtime_control_grp group */
 /** @} */ /* end of lnx_ioctl_FM_PORT_grp group */
diff --git a/include/linux/fmd/Peripherals/fm_test_ioctls.h b/include/linux/fmd/Peripherals/fm_test_ioctls.h
index 7b90c2b..207ed1e 100644
--- a/include/linux/fmd/Peripherals/fm_test_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_test_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/include/linux/fmd/integrations/integration_ioctls.h b/include/linux/fmd/integrations/integration_ioctls.h
index 1642f86..02f6c61 100644
--- a/include/linux/fmd/integrations/integration_ioctls.h
+++ b/include/linux/fmd/integrations/integration_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/include/linux/fmd/ioctls.h b/include/linux/fmd/ioctls.h
index c974463..4f36cb0 100644
--- a/include/linux/fmd/ioctls.h
+++ b/include/linux/fmd/ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
diff --git a/include/linux/fmd/net_ioctls.h b/include/linux/fmd/net_ioctls.h
index afc8755..287500e 100644
--- a/include/linux/fmd/net_ioctls.h
+++ b/include/linux/fmd/net_ioctls.h
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -30,6 +30,7 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+
 /**************************************************************************//**
  @File          net_ioctls.h
 
@@ -239,6 +240,10 @@ typedef uint8_t ioc_header_field_vlan_t;
 #define IOC_NET_HEADER_FIELD_VLAN_TYPE                      (IOC_NET_HEADER_FIELD_VLAN_VPRI << 4)
 #define IOC_NET_HEADER_FIELD_VLAN_ALL_FIELDS                ((IOC_NET_HEADER_FIELD_VLAN_VPRI << 5) - 1)
 
+#define IOC_NET_HEADER_FIELD_VLAN_TCI                       (IOC_NET_HEADER_FIELD_VLAN_VPRI | \
+                                                             IOC_NET_HEADER_FIELD_VLAN_CFI | \
+                                                             IOC_NET_HEADER_FIELD_VLAN_VID)
+
 
 typedef uint8_t ioc_header_field_llc_t;
 
@@ -361,15 +366,15 @@ typedef enum {
     e_IOC_NET_HEADER_TYPE_IPSEC_AH,
     e_IOC_NET_HEADER_TYPE_IPSEC_ESP,
     e_IOC_NET_HEADER_TYPE_UDP_ENCAP_ESP, /* RFC 3948 */
-    e_IOC_NET_HEADER_TYPE_MACSEC,        /* moved */
+    e_IOC_NET_HEADER_TYPE_MACSEC,
     e_IOC_NET_HEADER_TYPE_GRE,
     e_IOC_NET_HEADER_TYPE_MINENCAP,
     e_IOC_NET_HEADER_TYPE_DCCP,
     e_IOC_NET_HEADER_TYPE_ICMP,
     e_IOC_NET_HEADER_TYPE_IGMP,
     e_IOC_NET_HEADER_TYPE_ARP,
-    e_IOC_NET_HEADER_TYPE_CAPWAP,         /* new */
-    e_IOC_NET_HEADER_TYPE_CAPWAP_DTLS,    /* new */
+    e_IOC_NET_HEADER_TYPE_CAPWAP,
+    e_IOC_NET_HEADER_TYPE_CAPWAP_DTLS,
     e_IOC_NET_HEADER_TYPE_RFC2684,
     e_IOC_NET_HEADER_TYPE_USER_DEFINED_L2,
     e_IOC_NET_HEADER_TYPE_USER_DEFINED_L3,
-- 
1.7.9.7

