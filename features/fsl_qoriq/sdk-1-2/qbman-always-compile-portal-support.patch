From 32cf9006ac81b8106aaa3eeedf100e0697f538ef Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 14 Mar 2012 04:49:39 +0000
Subject: [PATCH 073/121] qbman: always compile portal support

There is little usefulness in compiling qbman drivers without support
for portals, and supporting such configurations complicates efforts to
reorganise the portal initialisation code to support for "dynamic"
use-cases. This removes the FSL_DPA_PORTAL, FSL_BMAN_PORTAL, and
FSL_QMAN_PORTAL options and replaces the corresponding #ifdef-ery to
the effect that these options are permanently enabled. This also
removes a level of indirection in the portal setup code, which
simplifies and shortens the code.

For similar reasons of simplification, the now-pointless support for
disabling DCA support is removed. This harks back to a time when the
software was being run against simulation models that didn't support
DCA.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/Kconfig   |    2 +-
 drivers/staging/fsl_pme2/Kconfig         |    4 +-
 drivers/staging/fsl_qbman/Kconfig        |   30 +---------
 drivers/staging/fsl_qbman/Makefile       |    5 +-
 drivers/staging/fsl_qbman/bman_driver.c  |   68 +++++++----------------
 drivers/staging/fsl_qbman/qman_driver.c  |   89 ++++++++++--------------------
 drivers/staging/fsl_qbman/qman_fqalloc.c |   18 ------
 drivers/staging/fsl_qbman/qman_high.c    |   16 +-----
 8 files changed, 57 insertions(+), 175 deletions(-)

diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index 8f4a059..d756a16 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -98,7 +98,7 @@ config GIANFAR_L2SRAM
 
 config DPA
 	bool "Freescale Data Path Frame Manager Ethernet"
-	depends on FSL_SOC && FSL_BMAN_PORTAL && FSL_QMAN_PORTAL && FSL_FMAN
+	depends on FSL_SOC && FSL_BMAN && FSL_QMAN && FSL_FMAN
 	select PHYLIB
 
 config DPA_OFFLINE_PORTS
diff --git a/drivers/staging/fsl_pme2/Kconfig b/drivers/staging/fsl_pme2/Kconfig
index e28e7ad..96ef45b 100644
--- a/drivers/staging/fsl_pme2/Kconfig
+++ b/drivers/staging/fsl_pme2/Kconfig
@@ -1,6 +1,6 @@
 config FSL_PME2
 	bool "Freescale Datapath Pattern Matcher support"
-	depends on HAS_FSL_PME && FSL_QMAN_PORTAL
+	depends on HAS_FSL_PME && FSL_QMAN
 	default y
 
 menu "Freescale Datapath PME options"
@@ -148,7 +148,7 @@ config FSL_PME2_TEST_SCAN
 
 config FSL_PME2_TEST_SCAN_WITH_BPID
 	bool "PME2 scan self-test with buffer pool"
-	depends on FSL_PME2_TEST_SCAN && FSL_BMAN_PORTAL
+	depends on FSL_PME2_TEST_SCAN && FSL_BMAN
 	default y
 	---help---
 	  This uses a buffer pool id for scan test
diff --git a/drivers/staging/fsl_qbman/Kconfig b/drivers/staging/fsl_qbman/Kconfig
index a35aeeb0..8e7b367 100644
--- a/drivers/staging/fsl_qbman/Kconfig
+++ b/drivers/staging/fsl_qbman/Kconfig
@@ -40,13 +40,6 @@ config FSL_BMAN
 
 if FSL_BMAN
 
-config FSL_BMAN_PORTAL
-	bool "Bman portal support"
-	default y
-	---help---
-	  Compiles support to detect and support Bman software corenet portals
-	  (as provided by the device-tree).
-
 config FSL_BMAN_CONFIG
 	bool "Bman device management"
 	default y
@@ -57,7 +50,6 @@ config FSL_BMAN_CONFIG
 
 config FSL_BMAN_TEST
 	tristate "Bman self-tests"
-	depends on FSL_BMAN_PORTAL
 	default n
 	---help---
 	  This option compiles self-test code for Bman.
@@ -84,7 +76,7 @@ config FSL_BMAN_TEST_THRESH
 
 config FSL_BMAN_DEBUGFS
 	tristate "Bman debugfs interface"
-	depends on FSL_BMAN_PORTAL && DEBUG_FS
+	depends on DEBUG_FS
 	default y
 	---help---
 	This option compiles bman debugfs code for Bman.
@@ -97,17 +89,8 @@ config FSL_QMAN
 
 if FSL_QMAN
 
-config FSL_QMAN_PORTAL
-	bool "Qman portal support"
-	depends on FSL_PAMU
-	default y
-	---help---
-	  Compiles support to detect and support Qman software corenet portals
-	  (as provided by the device-tree).
-
 config FSL_QMAN_BUG_AND_FEATURE_REV1
 	bool "workarounds for errata and missing features in p4080 rev1"
-	depends on FSL_QMAN_PORTAL
 	default y
 	---help---
 	  If this option is selected, the driver will be compiled with
@@ -123,14 +106,6 @@ config FSL_QMAN_POLL_LIMIT
 	int
 	default 32
 
-config FSL_QMAN_PORTAL_DISABLEAUTO_DCA
-	bool "disable discrete-consumption support on cpu-affine portals"
-	default n
-	---help---
-	  By default, auto-initialised cpu-affine portals support
-	  discrete-consumption acknowledgements, but this may be unimplemented
-	  in the simulation model.
-
 config FSL_QMAN_CONFIG
 	bool "Qman device management"
 	default y
@@ -141,7 +116,6 @@ config FSL_QMAN_CONFIG
 
 config FSL_QMAN_TEST
 	tristate "Qman self-tests"
-	depends on FSL_QMAN_PORTAL
 	default n
 	---help---
 	  This option compiles self-test code for Qman.
@@ -174,7 +148,7 @@ config FSL_QMAN_TEST_ERRATA
 
 config FSL_QMAN_DEBUGFS
 	tristate "Qman debugfs interface"
-	depends on FSL_QMAN_PORTAL
+	depends on DEBUG_FS
 	default y
 	---help---
 	This option compiles qman debugfs code for Qman.
diff --git a/drivers/staging/fsl_qbman/Makefile b/drivers/staging/fsl_qbman/Makefile
index f740092..3e31900 100644
--- a/drivers/staging/fsl_qbman/Makefile
+++ b/drivers/staging/fsl_qbman/Makefile
@@ -1,6 +1,6 @@
 # Bman
+obj-$(CONFIG_FSL_BMAN)		+= bman_high.o
 obj-$(CONFIG_FSL_BMAN_CONFIG)	+= bman_config.o bman_driver.o
-obj-$(CONFIG_FSL_BMAN_PORTAL)	+= bman_high.o
 obj-$(CONFIG_FSL_BMAN_TEST)	+= bman_tester.o
 obj-$(CONFIG_FSL_BMAN_DEBUGFS)  += bman_debugfs_interface.o
 bman_tester-y			 = bman_test.o
@@ -9,9 +9,8 @@ bman_tester-$(CONFIG_FSL_BMAN_TEST_THRESH) += bman_test_thresh.o
 bman_debugfs_interface-y	 = bman_debugfs.o
 
 # Qman
-obj-$(CONFIG_FSL_QMAN)		+= qman_utility.o qman_fqalloc.o
+obj-$(CONFIG_FSL_QMAN)		+= qman_high.o qman_utility.o qman_fqalloc.o
 obj-$(CONFIG_FSL_QMAN_CONFIG)	+= qman_config.o qman_driver.o
-obj-$(CONFIG_FSL_QMAN_PORTAL)	+= qman_high.o
 obj-$(CONFIG_FSL_QMAN_TEST)	+= qman_tester.o
 qman_tester-y			 = qman_test.o qman_test_hotpotato.o \
 					qman_test_high.o
diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 085aa42..54517a3 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -62,7 +62,6 @@ static int __bm_pool_add(u32 bpid, u32 *cfg, int triplets)
 {
 	u64 total = 0;
 	BUG_ON(bpid >= bman_pool_max);
-#ifdef CONFIG_FSL_BMAN_PORTAL
 	while (triplets--) {
 		struct bman_pool_params params = {
 			.bpid = bpid,
@@ -92,7 +91,6 @@ static int __bm_pool_add(u32 bpid, u32 *cfg, int triplets)
 		bman_free_pool(pobj);
 		cfg += 6;
 	}
-#endif
 	/* Remove this pool from the allocator (by treating its declaration as
 	 * an implicit "reservation") iff the allocator is *not* being set up
 	 * explicitly defined via "bpool-range" nodes. */
@@ -138,36 +136,6 @@ void bm_pool_free(u32 bpid)
 }
 EXPORT_SYMBOL(bm_pool_free);
 
-#ifdef CONFIG_FSL_BMAN_PORTAL
-static __init struct bman_portal *init_affine_portal(
-					struct bm_portal_config *pconfig,
-					int cpu, struct bman_portal *redirect)
-{
-	struct bman_portal *portal;
-	struct cpumask oldmask = *tsk_cpus_allowed(current);
-	const struct cpumask *newmask = get_cpu_mask(cpu);
-
-	set_cpus_allowed_ptr(current, newmask);
-
-	if (redirect)
-		portal = bman_create_affine_slave(redirect);
-	else {
-		portal = bman_create_affine_portal(pconfig);
-#ifdef CONFIG_FSL_DPA_PIRQ_SLOW
-		if (portal)
-			bman_irqsource_add(BM_PIRQ_RCRI | BM_PIRQ_BSCN);
-#endif
-	}
-
-	set_cpus_allowed_ptr(current, &oldmask);
-	if (portal)
-		pr_info("Bman portal %sinitialised, cpu %d\n",
-			redirect ? "(slave) " :
-			pconfig->public_cfg.is_shared ? "(shared) " : "", cpu);
-	return portal;
-}
-#endif
-
 static struct bm_portal_config * __init fsl_bman_portal_init(
 						struct device_node *node)
 {
@@ -345,14 +313,14 @@ static int __init fsl_bpool_range_init(struct device_node *node)
 
 static __init int bman_init(void)
 {
-#ifdef CONFIG_FSL_BMAN_PORTAL
 	struct cpumask primary_cpus = *cpu_none_mask;
 	struct cpumask slave_cpus = *cpu_online_mask;
+	struct cpumask oldmask;
 	struct bman_portal *sharing_portal = NULL;
 	int sharing_cpu = -1;
-#endif
 	struct device_node *dn;
 	struct bm_portal_config *pcfg;
+	struct bman_portal *p;
 	int ret;
 	LIST_HEAD(cfg_list);
 
@@ -368,7 +336,6 @@ static __init int bman_init(void)
 		bman_depletion_fill(&pools);
 		num_pools = bman_pool_max;
 	}
-#ifdef CONFIG_FSL_BMAN_PORTAL
 	for_each_compatible_node(dn, NULL, "fsl,bman-portal") {
 		if (!of_device_is_available(dn))
 			continue;
@@ -400,7 +367,6 @@ static __init int bman_init(void)
 	/* Parsing is done and sharing decisions are made, now initialise the
 	 * portals and determine which "slave" CPUs are left over. */
 	list_for_each_entry(pcfg, &cfg_list, list) {
-		struct bman_portal *p;
 		int is_shared = (!sharing_portal && (sharing_cpu >= 0) &&
 				(pcfg->public_cfg.cpu == sharing_cpu));
 		pcfg->public_cfg.is_shared = is_shared;
@@ -409,33 +375,39 @@ static __init int bman_init(void)
 		if (pcfg->public_cfg.cpu < 0 || !cpumask_test_cpu(
 					pcfg->public_cfg.cpu, &slave_cpus))
 			continue;
-		p = init_affine_portal(pcfg, pcfg->public_cfg.cpu, NULL);
+		oldmask = *tsk_cpus_allowed(current);
+		set_cpus_allowed_ptr(current,
+				     get_cpu_mask(pcfg->public_cfg.cpu));
+		p = bman_create_affine_portal(pcfg);
 		if (p) {
+#ifdef CONFIG_FSL_DPA_PIRQ_SLOW
+			bman_irqsource_add(BM_PIRQ_RCRI | BM_PIRQ_BSCN);
+#endif
+			pr_info("Bman portal %sinitialised, cpu %d\n",
+				is_shared ? "(shared) " : "",
+				pcfg->public_cfg.cpu);
 			if (is_shared)
 				sharing_portal = p;
 			cpumask_clear_cpu(pcfg->public_cfg.cpu, &slave_cpus);
 		}
+		set_cpus_allowed_ptr(current, &oldmask);
 	}
 
 	if (sharing_portal) {
 		int loop;
 		for_each_cpu(loop, &slave_cpus) {
-			struct bman_portal *p = init_affine_portal(NULL, loop,
-					sharing_portal);
+			oldmask = *tsk_cpus_allowed(current);
+			set_cpus_allowed_ptr(current, get_cpu_mask(loop));
+			p = bman_create_affine_slave(sharing_portal);
+			set_cpus_allowed_ptr(current, &oldmask);
 			if (!p)
 				pr_err("Failed slave Bman portal for cpu %d\n",
 					loop);
+			else
+				pr_info("Bman portal %sinitialised, cpu %d\n",
+					"(slave) ", loop);
 		}
 	}
-#else
-	for_each_compatible_node(dn, NULL, "fsl,bman-portal") {
-		if (!of_device_is_available(dn))
-			continue;
-		pcfg = fsl_bman_portal_init(dn);
-		if (pcfg)
-			fsl_bman_portal_destroy(pcfg);
-	}
-#endif
 	for_each_compatible_node(dn, NULL, "fsl,bpool-range") {
 		if (!explicit_allocator) {
 			explicit_allocator = 1;
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 18e220f..49cdd5a 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -41,46 +41,6 @@ EXPORT_SYMBOL(qman_ip_rev);
 static u32 fqd_size = (PAGE_SIZE << CONFIG_FSL_QMAN_FQD_SZ);
 #endif
 
-#ifdef CONFIG_FSL_QMAN_PORTAL
-static __init struct qman_portal *init_affine_portal(
-					struct qm_portal_config *pconfig,
-					int cpu, struct qman_portal *redirect)
-{
-	struct qman_portal *portal;
-	struct cpumask oldmask = *tsk_cpus_allowed(current);
-	const struct cpumask *newmask = get_cpu_mask(cpu);
-
-	set_cpus_allowed_ptr(current, newmask);
-
-	if (redirect)
-		portal = qman_create_affine_slave(redirect);
-	else {
-		portal = qman_create_affine_portal(pconfig, NULL);
-		if (portal) {
-			u32 irq_sources = 0;
-			/* default: enable all (available) pool channels */
-			qman_static_dequeue_add(~0);
-			/* Determine what should be interrupt-vs-poll driven */
-#ifdef CONFIG_FSL_DPA_PIRQ_SLOW
-			irq_sources |= QM_PIRQ_EQCI | QM_PIRQ_EQRI |
-				QM_PIRQ_MRI | QM_PIRQ_CSCI;
-#endif
-#ifdef CONFIG_FSL_DPA_PIRQ_FAST
-			irq_sources |= QM_PIRQ_DQRI;
-#endif
-			qman_irqsource_add(irq_sources);
-		}
-	}
-
-	set_cpus_allowed_ptr(current, &oldmask);
-	if (portal)
-		pr_info("Qman portal %sinitialised, cpu %d\n",
-			redirect ? "(slave) " :
-			pconfig->public_cfg.is_shared ? "(shared) " : "", cpu);
-	return portal;
-}
-#endif
-
 /* Parses the device-tree node, extracts the configuration, and if appropriate
  * initialises the portal for use on one or more CPUs. */
 static __init struct qm_portal_config *fsl_qman_portal_init(
@@ -253,15 +213,15 @@ static __init int fsl_fqid_range_init(struct device_node *node)
 
 static __init int qman_init(void)
 {
-#ifdef CONFIG_FSL_QMAN_PORTAL
 	struct qman_cgr cgr;
 	struct cpumask primary_cpus = *cpu_none_mask;
 	struct cpumask slave_cpus = *cpu_online_mask;
+	struct cpumask oldmask;
 	struct qman_portal *sharing_portal = NULL;
 	int sharing_cpu = -1;
-#endif
 	struct device_node *dn;
 	struct qm_portal_config *pcfg;
+	struct qman_portal *p;
 	int ret, use_bpid0 = 1;
 	LIST_HEAD(cfg_list);
 
@@ -276,7 +236,6 @@ static __init int qman_init(void)
 	if (ret)
 		return ret;
 #endif
-#ifdef CONFIG_FSL_QMAN_PORTAL
 	for_each_compatible_node(dn, NULL, "fsl,qman-portal") {
 		if (!of_device_is_available(dn))
 			continue;
@@ -308,7 +267,6 @@ static __init int qman_init(void)
 	/* Parsing is done and sharing decisions are made, now initialise the
 	 * portals and determine which "slave" CPUs are left over. */
 	list_for_each_entry(pcfg, &cfg_list, list) {
-		struct qman_portal *p;
 		int is_shared = (!sharing_portal && (sharing_cpu >= 0) &&
 				(pcfg->public_cfg.cpu == sharing_cpu));
 		pcfg->public_cfg.is_shared = is_shared;
@@ -317,41 +275,53 @@ static __init int qman_init(void)
 		if (pcfg->public_cfg.cpu < 0 || !cpumask_test_cpu(
 					pcfg->public_cfg.cpu, &slave_cpus))
 			continue;
-		p = init_affine_portal(pcfg, pcfg->public_cfg.cpu, NULL);
+		oldmask = *tsk_cpus_allowed(current);
+		set_cpus_allowed_ptr(current,
+				     get_cpu_mask(pcfg->public_cfg.cpu));
+		p = qman_create_affine_portal(pcfg, NULL);
 		if (p) {
+			u32 irq_sources = 0;
+			/* default: enable all (available) pool channels */
+			qman_static_dequeue_add(~0);
+			/* Determine what should be interrupt-vs-poll driven */
+#ifdef CONFIG_FSL_DPA_PIRQ_SLOW
+			irq_sources |= QM_PIRQ_EQCI | QM_PIRQ_EQRI |
+				QM_PIRQ_MRI | QM_PIRQ_CSCI;
+#endif
+#ifdef CONFIG_FSL_DPA_PIRQ_FAST
+			irq_sources |= QM_PIRQ_DQRI;
+#endif
+			qman_irqsource_add(irq_sources);
+			pr_info("Qman portal %sinitialised, cpu %d\n",
+				is_shared ? "(shared) " : "",
+				pcfg->public_cfg.cpu);
 			if (is_shared)
 				sharing_portal = p;
 			cpumask_clear_cpu(pcfg->public_cfg.cpu, &slave_cpus);
 		}
+		set_cpus_allowed_ptr(current, &oldmask);
 	}
 	if (sharing_portal) {
 		int loop;
 		for_each_cpu(loop, &slave_cpus) {
-			struct qman_portal *p = init_affine_portal(NULL, loop,
-					sharing_portal);
+			oldmask = *tsk_cpus_allowed(current);
+			set_cpus_allowed_ptr(current, get_cpu_mask(loop));
+			p = qman_create_affine_slave(sharing_portal);
+			set_cpus_allowed_ptr(current, &oldmask);
 			if (!p)
 				pr_err("Failed slave Qman portal for cpu %d\n",
 					loop);
+			else
+				pr_info("Qman portal %sinitialised, cpu %d\n",
+					"(slave) ", loop);
 		}
 	}
-#else
-	for_each_compatible_node(dn, NULL, "fsl,qman-portal") {
-		if (!of_device_is_available(dn))
-			continue;
-		pcfg = fsl_qman_portal_init(dn);
-		if (pcfg)
-			/* No kernel portal support, so if USDPAA didn't consume
-			 * the portal, we've no other use for it. */
-			fsl_qman_portal_destroy(pcfg);
-	}
-#endif
 	for_each_compatible_node(dn, NULL, "fsl,fqid-range") {
 		use_bpid0 = 0;
 		ret = fsl_fqid_range_init(dn);
 		if (ret)
 			return ret;
 	}
-#ifdef CONFIG_FSL_QMAN_PORTAL
 	for (cgr.cgrid = 0; cgr.cgrid < __CGR_NUM; cgr.cgrid++) {
 		/* This is to ensure h/w-internal CGR memory is zeroed out. Note
 		 * that we do this for all conceivable CGRIDs, not all of which
@@ -359,7 +329,6 @@ static __init int qman_init(void)
 		 * We ignore any errors for this reason. */
 		qman_modify_cgr(&cgr, QMAN_CGR_FLAG_USE_INIT, NULL);
 	}
-#endif
 	ret = fqalloc_init(use_bpid0);
 	if (ret)
 		return ret;
diff --git a/drivers/staging/fsl_qbman/qman_fqalloc.c b/drivers/staging/fsl_qbman/qman_fqalloc.c
index e3f270e..335b96b 100644
--- a/drivers/staging/fsl_qbman/qman_fqalloc.c
+++ b/drivers/staging/fsl_qbman/qman_fqalloc.c
@@ -40,32 +40,24 @@
 /* Global flag: use BPID==0 (fq_pool), or use the range-allocator? */
 static int use_bman;
 
-#ifdef CONFIG_FSL_BMAN_PORTAL
 static struct bman_pool *fq_pool;
 static const struct bman_pool_params fq_pool_params;
-#endif
 
 __init int fqalloc_init(int __use_bman)
 {
 	use_bman = __use_bman;
-#ifdef CONFIG_FSL_BMAN_PORTAL
 	if (use_bman) {
 		fq_pool = bman_new_pool(&fq_pool_params);
 		if (!fq_pool)
 			return -ENOMEM;
 	}
-#else
-	BUG_ON(use_bman);
-#endif
 	return 0;
 }
 
 u32 qm_fq_new(void)
 {
-#ifdef CONFIG_FSL_BMAN_PORTAL
 	struct bm_buffer buf;
 	int ret;
-#endif
 
 	if (!use_bman) {
 		u32 result;
@@ -73,32 +65,25 @@ u32 qm_fq_new(void)
 			return 0;
 		return result;
 	}
-#ifdef CONFIG_FSL_BMAN_PORTAL
 	BUG_ON(!fq_pool);
 	ret = bman_acquire(fq_pool, &buf, 1, 0);
 	if (ret != 1)
 		return 0;
 	return (u32)bm_buffer_get64(&buf);
-#else
-	BUG();
-#endif
 }
 EXPORT_SYMBOL(qm_fq_new);
 
 int qm_fq_free_flags(u32 fqid, __maybe_unused u32 flags)
 {
-#ifdef CONFIG_FSL_BMAN_PORTAL
 	struct bm_buffer buf;
 	u32 bflags = 0;
 	int ret;
 	bm_buffer_set64(&buf, fqid);
-#endif
 
 	if (!use_bman) {
 		qman_release_fqid(fqid);
 		return 0;
 	}
-#ifdef CONFIG_FSL_BMAN_PORTAL
 #ifdef CONFIG_FSL_DPA_CAN_WAIT
 	if (flags & QM_FQ_FREE_WAIT) {
 		bflags |= BMAN_RELEASE_FLAG_WAIT;
@@ -110,9 +95,6 @@ int qm_fq_free_flags(u32 fqid, __maybe_unused u32 flags)
 #endif
 	ret = bman_release(fq_pool, &buf, 1, bflags);
 	return ret;
-#else
-	BUG();
-#endif
 }
 EXPORT_SYMBOL(qm_fq_free_flags);
 
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index c8580fa..fc4bc4c 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -354,13 +354,8 @@ struct qman_portal *qman_create_affine_portal(
 		pr_err("Qman EQCR initialisation failed\n");
 		goto fail_eqcr;
 	}
-#ifdef CONFIG_FSL_QMAN_PORTAL_DISABLEAUTO_DCA
-#define QM_DQRR_CMODE qm_dqrr_cci
-#else
-#define QM_DQRR_CMODE qm_dqrr_cdc
-#endif
 	if (qm_dqrr_init(__p, config, qm_dqrr_dpush, qm_dqrr_pvb,
-			QM_DQRR_CMODE, DQRR_MAXFILL)) {
+			qm_dqrr_cdc, DQRR_MAXFILL)) {
 		pr_err("Qman DQRR initialisation failed\n");
 		goto fail_dqrr;
 	}
@@ -809,20 +804,11 @@ loop:
 	 * check for HELDACTIVE to cover both. */
 	DPA_ASSERT((dq->stat & QM_DQRR_STAT_FQ_HELDACTIVE) ||
 		(res != qman_cb_dqrr_park));
-#ifdef CONFIG_FSL_QMAN_PORTAL_DISABLEAUTO_DCA
-	if (res == qman_cb_dqrr_park)
-		/* The only thing to do for non-DCA is the park-request */
-		qm_dqrr_park_current(&p->p);
-	/* Move forward */
-	qm_dqrr_next(&p->p);
-	qm_dqrr_cci_consume(&p->p, 1);
-#else
 	/* Defer just means "skip it, I'll consume it myself later on" */
 	if (res != qman_cb_dqrr_defer)
 		qm_dqrr_cdc_consume_1ptr(&p->p, dq, (res == qman_cb_dqrr_park));
 	/* Move forward */
 	qm_dqrr_next(&p->p);
-#endif
 	/* Entry processed and consumed, increment our counter. The callback can
 	 * request that we exit after consuming the entry, and we also exit if
 	 * we reach our processing limit, so loop back only if neither of these
-- 
1.7.9.7

