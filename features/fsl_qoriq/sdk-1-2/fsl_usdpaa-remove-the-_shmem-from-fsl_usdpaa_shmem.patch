From d6eea99a760799ddbe525b3db428fa84ae51e270 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 14 Mar 2012 04:49:47 +0000
Subject: [PATCH 082/121] fsl_usdpaa: remove the "_shmem" from
 "fsl_usdpaa_shmem"

The misc character device for USDPAA will soon be used for more than
just mapping DMA memory and establishing the corresponding address
conversions. It will soon be used for other process-wide (rather than
portal-wide) interaction with the kernel, most notably resource
allocation and tracking. As such, this is now a "USDPAA process device"
rather than a "USDPAA shmem device".

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image.
Include <linux/module.h> in fsl_usdpaa.c]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/mm/mem.c                    |    2 +-
 arch/powerpc/platforms/85xx/corenet_ds.c |    4 +-
 drivers/misc/Kconfig                     |   29 +++---
 drivers/misc/Makefile                    |    2 +-
 drivers/misc/fsl_usdpaa.c                |  150 +++++++++++++++++++++++++++++
 drivers/misc/fsl_usdpaa_shmem.c          |  151 ------------------------------
 include/linux/fsl_usdpaa.h               |    6 +-
 7 files changed, 173 insertions(+), 171 deletions(-)
 create mode 100644 drivers/misc/fsl_usdpaa.c
 delete mode 100644 drivers/misc/fsl_usdpaa_shmem.c

diff --git a/arch/powerpc/mm/mem.c b/arch/powerpc/mm/mem.c
index 44ba8f6..5d54c4e 100644
--- a/arch/powerpc/mm/mem.c
+++ b/arch/powerpc/mm/mem.c
@@ -523,7 +523,7 @@ void flush_icache_user_range(struct vm_area_struct *vma, struct page *page,
 }
 EXPORT_SYMBOL(flush_icache_user_range);
 
-#ifdef CONFIG_FSL_USDPAA_SHMEM
+#ifdef CONFIG_FSL_USDPAA
 /*
  * NB: this 'usdpaa' check+hack is to create a single TLB1 entry to cover the
  * buffer memory used by run-to-completion UIO-based apps ("User-Space DataPath
diff --git a/arch/powerpc/platforms/85xx/corenet_ds.c b/arch/powerpc/platforms/85xx/corenet_ds.c
index 57f4e8d..2656264 100644
--- a/arch/powerpc/platforms/85xx/corenet_ds.c
+++ b/arch/powerpc/platforms/85xx/corenet_ds.c
@@ -168,8 +168,8 @@ __init void corenet_ds_init_early(void)
 #ifdef CONFIG_FSL_PME2_CTRL
 	pme2_init_early();
 #endif
-#ifdef CONFIG_FSL_USDPAA_SHMEM
-	fsl_usdpaa_shmem_init_early();
+#ifdef CONFIG_FSL_USDPAA
+	fsl_usdpaa_init_early();
 #endif
 }
 
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 784d71d..b9a8904 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -220,19 +220,22 @@ config ENCLOSURE_SERVICES
 	  driver (SCSI/ATA) which supports enclosures
 	  or a SCSI enclosure device (SES) to use these services.
 
-config FSL_USDPAA_SHMEM
-	bool "Freescale USDPAA shared memory driver"
-	depends on PPC_85xx || PPC_E500MC
-	help
-	  This driver provides user-space access to a large contiguous
-	  memory allocation, reserved for use by Freescale USDPAA (User
-	  Space DataPath Acceleration Architecture) applications. This
-	  driver includes a private ioctl() interface for conveying the
-	  size and (DMA-)base-address of the memory region. It is also
-	  hooked by the MMU code, such that a single TLB1 mapping is
-	  created for the entire region when the first fault occurs.
-	  The intention is for this driver to be replaced by HugeTLB
-	  facilities, once they are available for USDPAA platforms.
+config FSL_USDPAA
+	bool "Freescale USDPAA process driver"
+	depends on FSL_DPA
+	default y
+	help
+	  This driver provides user-space access to kernel-managed
+	  resource interfaces for USDPAA applications, on the assumption
+	  that each process will open this device once. Specifically, this
+	  device exposes functionality that would be awkward if exposed
+	  via the portal devices - ie. this device exposes functionality
+	  that is inherently process-wide rather than portal-specific.
+	  This device is necessary for obtaining access to DMA memory and
+	  for allocation of Qman and Bman resources. In short, if you wish
+	  to use USDPAA applications, you need this.
+
+	  If unsure, say Y.
 
 config SGI_XP
 	tristate "Support communication between SGI SSIs"
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index e3bdb75..e2319bb 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -21,7 +21,7 @@ obj-$(CONFIG_SENSORS_BH1770)	+= bh1770glc.o
 obj-$(CONFIG_SENSORS_APDS990X)	+= apds990x.o
 obj-$(CONFIG_SGI_IOC4)		+= ioc4.o
 obj-$(CONFIG_ENCLOSURE_SERVICES) += enclosure.o
-obj-$(CONFIG_FSL_USDPAA_SHMEM)	+= fsl_usdpaa_shmem.o
+obj-$(CONFIG_FSL_USDPAA)	+= fsl_usdpaa.o
 obj-$(CONFIG_KGDB_TESTS)	+= kgdbts.o
 obj-$(CONFIG_SGI_XP)		+= sgi-xp/
 obj-$(CONFIG_SGI_GRU)		+= sgi-gru/
diff --git a/drivers/misc/fsl_usdpaa.c b/drivers/misc/fsl_usdpaa.c
new file mode 100644
index 0000000..34848d9
--- /dev/null
+++ b/drivers/misc/fsl_usdpaa.c
@@ -0,0 +1,150 @@
+/* Copyright (C) 2008-2011 Freescale Semiconductor, Inc.
+ * Authors: Andy Fleming <afleming@freescale.com>
+ *          Timur Tabi <timur@freescale.com>
+ *          Geoff Thorpe <Geoff.Thorpe@freescale.com>
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2.  This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#include <linux/fsl_usdpaa.h>
+
+#include <linux/miscdevice.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/mm.h>
+#include <linux/of.h>
+#include <linux/memblock.h>
+#include <linux/module.h>
+
+/* Physical address range */
+u64 usdpaa_phys_start;
+u64 usdpaa_phys_size;
+
+/* PFN versions */
+unsigned long usdpaa_pfn_start;
+unsigned long usdpaa_pfn_len;
+
+/* TLB1 index */
+unsigned int usdpaa_tlbcam_index;
+
+static int usdpaa_open(struct inode *inode, struct file *filp)
+{
+	filp->f_mapping->backing_dev_info = &directly_mappable_cdev_bdi;
+
+	return 0;
+}
+
+static int usdpaa_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	size_t size = vma->vm_end - vma->vm_start;
+	if (vma->vm_pgoff) {
+		pr_err("%s: non-zero mmap page-offset 0x%lx is invalid\n",
+			__func__, vma->vm_pgoff);
+		return -EINVAL;
+	}
+	if (size != usdpaa_phys_size) {
+		pr_err("%s: mmap size 0x%llx doesn't match region (0x%llx)\n",
+			__func__, (unsigned long long)size, usdpaa_phys_size);
+		return -EINVAL;
+	}
+	if (vma->vm_start & (usdpaa_phys_size - 1)) {
+		pr_err("%s: un-aligned mapping %llx:%llx -> %lx\n",
+			__func__, usdpaa_phys_start, usdpaa_phys_size,
+			vma->vm_start);
+		return -EINVAL;
+	}
+	if (remap_pfn_range(vma, vma->vm_start,	usdpaa_pfn_start, size,
+				vma->vm_page_prot))
+		return -EAGAIN;
+	return 0;
+}
+
+static long usdpaa_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	struct usdpaa_ioctl_get_region ret = {
+		.phys_start = usdpaa_phys_start,
+		.phys_len = usdpaa_phys_size
+	};
+	if (cmd != USDPAA_IOCTL_GET_PHYS_BASE)
+		return -EINVAL;
+	return copy_to_user((void __user *)arg, &ret, sizeof(ret));
+}
+
+static const struct file_operations usdpaa_fops = {
+	.open		= usdpaa_open,
+	.mmap		= usdpaa_mmap,
+	.unlocked_ioctl = usdpaa_ioctl,
+	.compat_ioctl = usdpaa_ioctl
+};
+
+static struct miscdevice usdpaa_miscdev = {
+	.name = "fsl-usdpaa",
+	.fops = &usdpaa_fops,
+	.minor = MISC_DYNAMIC_MINOR,
+};
+
+/* Early-boot memory allocation. The boot-arg "usdpaa_mem=<x>" is used to
+ * indicate how much memory (if any) to allocate during early boot. */
+static __init int usdpaa_mem(char *arg)
+{
+	usdpaa_phys_size = memparse(arg, &arg);
+	return 0;
+}
+early_param("usdpaa_mem", usdpaa_mem);
+
+__init void fsl_usdpaa_init_early(void)
+{
+	int log;
+	if (!usdpaa_phys_size) {
+		pr_info("No USDPAA memory, no 'usdpaa_mem' bootarg\n");
+		return;
+	}
+	/* Size must be 4^x * 4096, for some x */
+	log = ilog2(usdpaa_phys_size);
+	if ((usdpaa_phys_size & (usdpaa_phys_size - 1)) || (log < 12) ||
+			(log & 1)) {
+		pr_err("'usdpaa_mem' bootarg must be 4096*4^x\n");
+		usdpaa_phys_size = 0;
+		return;
+	}
+	usdpaa_phys_start = memblock_alloc(usdpaa_phys_size, usdpaa_phys_size);
+	if (usdpaa_phys_start) {
+		usdpaa_pfn_start = (usdpaa_phys_start >> PAGE_SHIFT);
+		usdpaa_pfn_len = (usdpaa_phys_size >> PAGE_SHIFT);
+		usdpaa_tlbcam_index = tlbcam_index++;
+		pr_info("USDPAA region at %llx:%llx\n",
+			usdpaa_phys_start, usdpaa_phys_size);
+	} else
+		pr_err("Failed to reserve USDPAA region (sz:%llx)\n",
+		       usdpaa_phys_size);
+}
+
+static int __init usdpaa_init(void)
+{
+	int ret;
+
+	pr_info("Freescale USDPAA process driver\n");
+
+	if (!usdpaa_phys_size) {
+		pr_warning("fsl-usdpaa: no region found\n");
+		return 0;
+	}
+	ret = misc_register(&usdpaa_miscdev);
+	if (ret)
+		pr_err("fsl-usdpaa: failed to register misc device\n");
+	return ret;
+}
+
+static void __exit usdpaa_exit(void)
+{
+	misc_deregister(&usdpaa_miscdev);
+}
+
+module_init(usdpaa_init);
+module_exit(usdpaa_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Freescale Semiconductor");
+MODULE_DESCRIPTION("Freescale USDPAA process driver");
diff --git a/drivers/misc/fsl_usdpaa_shmem.c b/drivers/misc/fsl_usdpaa_shmem.c
deleted file mode 100644
index e3899d0..0000000
--- a/drivers/misc/fsl_usdpaa_shmem.c
+++ /dev/null
@@ -1,151 +0,0 @@
-/* Copyright (C) 2008-2011 Freescale Semiconductor, Inc.
- * Authors: Andy Fleming <afleming@freescale.com>
- *          Timur Tabi <timur@freescale.com>
- *          Geoff Thorpe <Geoff.Thorpe@freescale.com>
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2.  This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- */
-
-#include <linux/fsl_usdpaa.h>
-
-#include <linux/miscdevice.h>
-#include <linux/fs.h>
-#include <linux/cdev.h>
-#include <linux/mm.h>
-#include <linux/of.h>
-#include <linux/memblock.h>
-#include <linux/module.h>
-
-/* Physical address range */
-u64 usdpaa_phys_start;
-u64 usdpaa_phys_size;
-
-/* PFN versions */
-unsigned long usdpaa_pfn_start;
-unsigned long usdpaa_pfn_len;
-
-/* TLB1 index */
-unsigned int usdpaa_tlbcam_index;
-
-static int usdpaa_shmem_open(struct inode *inode, struct file *filp)
-{
-	filp->f_mapping->backing_dev_info = &directly_mappable_cdev_bdi;
-
-	return 0;
-}
-
-static int usdpaa_shmem_mmap(struct file *file, struct vm_area_struct *vma)
-{
-	size_t size = vma->vm_end - vma->vm_start;
-	if (vma->vm_pgoff) {
-		pr_err("%s: non-zero mmap page-offset 0x%lx is invalid\n",
-			__func__, vma->vm_pgoff);
-		return -EINVAL;
-	}
-	if (size != usdpaa_phys_size) {
-		pr_err("%s: mmap size 0x%llx doesn't match region (0x%llx)\n",
-			__func__, (unsigned long long)size, usdpaa_phys_size);
-		return -EINVAL;
-	}
-	if (vma->vm_start & (usdpaa_phys_size - 1)) {
-		pr_err("%s: un-aligned mapping %llx:%llx -> %lx\n",
-			__func__, usdpaa_phys_start, usdpaa_phys_size,
-			vma->vm_start);
-		return -EINVAL;
-	}
-	if (remap_pfn_range(vma, vma->vm_start,	usdpaa_pfn_start, size,
-				vma->vm_page_prot))
-		return -EAGAIN;
-	return 0;
-}
-
-static long usdpaa_shmem_ioctl(struct file *fp, unsigned int cmd,
-				unsigned long arg)
-{
-	struct usdpaa_ioctl_get_region ret = {
-		.phys_start = usdpaa_phys_start,
-		.phys_len = usdpaa_phys_size
-	};
-	if (cmd != USDPAA_IOCTL_GET_PHYS_BASE)
-		return -EINVAL;
-	return copy_to_user((void __user *)arg, &ret, sizeof(ret));
-}
-
-static const struct file_operations shmem_fops = {
-	.open		= usdpaa_shmem_open,
-	.mmap		= usdpaa_shmem_mmap,
-	.unlocked_ioctl = usdpaa_shmem_ioctl,
-	.compat_ioctl = usdpaa_shmem_ioctl
-};
-
-static struct miscdevice usdpaa_shmem_miscdev = {
-	.name = "fsl-usdpaa-shmem",
-	.fops = &shmem_fops,
-	.minor = MISC_DYNAMIC_MINOR,
-};
-
-/* Early-boot memory allocation. The boot-arg "usdpaa_mem=<x>" is used to
- * indicate how much memory (if any) to allocate during early boot. */
-static __init int usdpaa_mem(char *arg)
-{
-	usdpaa_phys_size = memparse(arg, &arg);
-	return 0;
-}
-early_param("usdpaa_mem", usdpaa_mem);
-
-__init void fsl_usdpaa_shmem_init_early(void)
-{
-	int log;
-	if (!usdpaa_phys_size) {
-		pr_info("No USDPAA memory, no 'usdpaa_mem' bootarg\n");
-		return;
-	}
-	/* Size must be 4^x * 4096, for some x */
-	log = ilog2(usdpaa_phys_size);
-	if ((usdpaa_phys_size & (usdpaa_phys_size - 1)) || (log < 12) ||
-			(log & 1)) {
-		pr_err("'usdpaa_mem' bootarg must be 4096*4^x\n");
-		usdpaa_phys_size = 0;
-		return;
-	}
-	usdpaa_phys_start = memblock_alloc(usdpaa_phys_size, usdpaa_phys_size);
-	if (usdpaa_phys_start) {
-		usdpaa_pfn_start = (usdpaa_phys_start >> PAGE_SHIFT);
-		usdpaa_pfn_len = (usdpaa_phys_size >> PAGE_SHIFT);
-		usdpaa_tlbcam_index = tlbcam_index++;
-		pr_info("USDPAA region at %llx:%llx\n",
-			usdpaa_phys_start, usdpaa_phys_size);
-	} else
-		pr_err("Failed to reserve USDPAA region (sz:%llx)\n",
-		       usdpaa_phys_size);
-}
-
-static int __init usdpaa_shmem_init(void)
-{
-	int ret;
-
-	pr_info("Freescale USDPAA shared memory driver\n");
-
-	if (!usdpaa_phys_size) {
-		pr_warning("fsl-usdpaa-shmem: no region found\n");
-		return 0;
-	}
-	ret = misc_register(&usdpaa_shmem_miscdev);
-	if (ret)
-		pr_err("fsl-usdpaa-shmem: failed to register misc device\n");
-	return ret;
-}
-
-static void __exit usdpaa_shmem_exit(void)
-{
-	misc_deregister(&usdpaa_shmem_miscdev);
-}
-
-module_init(usdpaa_shmem_init);
-module_exit(usdpaa_shmem_exit);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Freescale Semiconductor");
-MODULE_DESCRIPTION("Freescale USDPAA shared memory driver");
diff --git a/include/linux/fsl_usdpaa.h b/include/linux/fsl_usdpaa.h
index dab7641..9c68cff 100644
--- a/include/linux/fsl_usdpaa.h
+++ b/include/linux/fsl_usdpaa.h
@@ -15,7 +15,7 @@ extern "C" {
 #include <linux/uaccess.h>
 #include <linux/ioctl.h>
 
-#ifdef CONFIG_FSL_USDPAA_SHMEM
+#ifdef CONFIG_FSL_USDPAA
 
 /* Character-device interface. NB: these definitions need to be duplicated in
  * user-space. It is all temporary until being replaced by HugeTLB. */
@@ -41,11 +41,11 @@ extern unsigned long usdpaa_pfn_len;
 extern unsigned int usdpaa_tlbcam_index;
 
 /* Early-boot hook */
-void __init fsl_usdpaa_shmem_init_early(void);
+void __init fsl_usdpaa_init_early(void);
 
 #endif /* __KERNEL__ */
 
-#endif /* CONFIG_FSL_USDPAA_SHMEM */
+#endif /* CONFIG_FSL_USDPAA */
 
 #ifdef __cplusplus
 }
-- 
1.7.9.7

