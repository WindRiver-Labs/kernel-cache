From 39a75f8467ba3e086dc4fa39f7c5916c011134c6 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Fri, 28 Oct 2011 14:39:15 -0500
Subject: [PATCH 060/128] qbman: use common index instead of relying on
 equality

The UIO code common to both qman and bman was using the bman-specific
indexing for cache-inhibited versus cache-enabled table entries,
relying on it being equal to the qman-specific indexing. This change
replaces them both with a common index.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/bman_driver.c  |   24 ++++++++++++------------
 drivers/staging/fsl_qbman/bman_high.c    |    4 ++--
 drivers/staging/fsl_qbman/bman_private.h |    2 --
 drivers/staging/fsl_qbman/dpa_sys.h      |    3 +++
 drivers/staging/fsl_qbman/dpa_uio.c      |   18 ++++++++++--------
 drivers/staging/fsl_qbman/qman_driver.c  |   24 ++++++++++++------------
 drivers/staging/fsl_qbman/qman_high.c    |    4 ++--
 drivers/staging/fsl_qbman/qman_private.h |    2 --
 8 files changed, 41 insertions(+), 40 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 9473bcf..cf6b8d3 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -241,14 +241,14 @@ static struct bm_portal_config * __init fsl_bman_portal_init(
 		bman_pool_max = 8;
 	}
 
-	ret = of_address_to_resource(node, BM_ADDR_CE,
-				&pcfg->addr_phys[BM_ADDR_CE]);
+	ret = of_address_to_resource(node, DPA_PORTAL_CE,
+				&pcfg->addr_phys[DPA_PORTAL_CE]);
 	if (ret) {
 		pr_err("Can't get %s property 'reg::CE'\n", node->full_name);
 		goto err;
 	}
-	ret = of_address_to_resource(node, BM_ADDR_CI,
-				&pcfg->addr_phys[BM_ADDR_CI]);
+	ret = of_address_to_resource(node, DPA_PORTAL_CI,
+				&pcfg->addr_phys[DPA_PORTAL_CI]);
 	if (ret) {
 		pr_err("Can't get %s property 'reg::CI'\n", node->full_name);
 		goto err;
@@ -296,13 +296,13 @@ static struct bm_portal_config * __init fsl_bman_portal_init(
 
 	/* Map the portals now we know they aren't for UIO (the UIO code doesn't
 	 * need the CE mapping, and so will do its own CI-only mapping). */
-	pcfg->addr_virt[BM_ADDR_CE] = ioremap_prot(
-				pcfg->addr_phys[BM_ADDR_CE].start,
-				resource_size(&pcfg->addr_phys[BM_ADDR_CE]),
+	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_prot(
+				pcfg->addr_phys[DPA_PORTAL_CE].start,
+				resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]),
 				0);
-	pcfg->addr_virt[BM_ADDR_CI] = ioremap_prot(
-				pcfg->addr_phys[BM_ADDR_CI].start,
-				resource_size(&pcfg->addr_phys[BM_ADDR_CI]),
+	pcfg->addr_virt[DPA_PORTAL_CI] = ioremap_prot(
+				pcfg->addr_phys[DPA_PORTAL_CI].start,
+				resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]),
 				_PAGE_GUARDED | _PAGE_NO_CACHE);
 	return pcfg;
 err:
@@ -312,8 +312,8 @@ err:
 
 static void __init fsl_bman_portal_destroy(struct bm_portal_config *pcfg)
 {
-	iounmap(pcfg->addr_virt[BM_ADDR_CE]);
-	iounmap(pcfg->addr_virt[BM_ADDR_CI]);
+	iounmap(pcfg->addr_virt[DPA_PORTAL_CE]);
+	iounmap(pcfg->addr_virt[DPA_PORTAL_CI]);
 	kfree(pcfg);
 }
 
diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index 453d88c..ca59fba 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -199,8 +199,8 @@ struct bman_portal *bman_create_affine_portal(
 	/* prep the low-level portal struct with the mapped addresses from the
 	 * config, everything that follows depends on it and "config" is more
 	 * for (de)reference... */
-	__p->addr.addr_ce = config->addr_virt[BM_ADDR_CE];
-	__p->addr.addr_ci = config->addr_virt[BM_ADDR_CI];
+	__p->addr.addr_ce = config->addr_virt[DPA_PORTAL_CE];
+	__p->addr.addr_ci = config->addr_virt[DPA_PORTAL_CI];
 	if (bm_rcr_init(__p, bm_rcr_pvb, bm_rcr_cce)) {
 		pr_err("Bman RCR initialisation failed\n");
 		goto fail_rcr;
diff --git a/drivers/staging/fsl_qbman/bman_private.h b/drivers/staging/fsl_qbman/bman_private.h
index 375da15..3d4d8ed 100644
--- a/drivers/staging/fsl_qbman/bman_private.h
+++ b/drivers/staging/fsl_qbman/bman_private.h
@@ -50,8 +50,6 @@ enum bm_isr_reg {
 	bm_isr_inhibit = 3
 };
 
-#define BM_ADDR_CE 0
-#define BM_ADDR_CI 1
 struct bm_portal_config {
 	/* Corenet portal addresses;
 	 * [0]==cache-enabled, [1]==cache-inhibited. */
diff --git a/drivers/staging/fsl_qbman/dpa_sys.h b/drivers/staging/fsl_qbman/dpa_sys.h
index 25c48ef..e5982d9 100644
--- a/drivers/staging/fsl_qbman/dpa_sys.h
+++ b/drivers/staging/fsl_qbman/dpa_sys.h
@@ -116,6 +116,9 @@ struct dpa_uio_portal {
 };
 const struct dpa_uio_class *dpa_uio_bman(void);
 const struct dpa_uio_class *dpa_uio_qman(void);
+/* For 2-element tables related to cache-inhibited and cache-enabled mappings */
+#define DPA_PORTAL_CE 0
+#define DPA_PORTAL_CI 1
 
 /* These stubs are re-mapped to hypervisor+failover features in kernel trees
  * that contain that support. */
diff --git a/drivers/staging/fsl_qbman/dpa_uio.c b/drivers/staging/fsl_qbman/dpa_uio.c
index a5a6345..83af1fd 100644
--- a/drivers/staging/fsl_qbman/dpa_uio.c
+++ b/drivers/staging/fsl_qbman/dpa_uio.c
@@ -143,8 +143,8 @@ static void __init dpa_uio_portal_init(struct dpa_uio_portal *p,
 	}
 	/* We need to map the cache-inhibited region in the kernel for
 	 * interrupt-handling purposes. */
-	info->addr_ci = ioremap_prot(res[BM_ADDR_CI].start,
-				resource_size(&res[BM_ADDR_CI]),
+	info->addr_ci = ioremap_prot(res[DPA_PORTAL_CI].start,
+				resource_size(&res[DPA_PORTAL_CI]),
 				_PAGE_GUARDED | _PAGE_NO_CACHE);
 	/* Name the UIO device according to the cell-index. It's supposed to be
 	 * unique for each device class (Qman/Bman), and is also a convenient
@@ -169,12 +169,14 @@ static void __init dpa_uio_portal_init(struct dpa_uio_portal *p,
 	info->uio.name = info->name;
 	info->uio.version = dpa_uio_version;
 	/* Work around the 36-bit UIO issue by bit-shifting the addresses */
-	info->uio.mem[BM_ADDR_CE].name = "cena";
-	info->uio.mem[BM_ADDR_CE].addr = res[BM_ADDR_CE].start >> PAGE_SHIFT;
-	info->uio.mem[BM_ADDR_CE].size = resource_size(&res[BM_ADDR_CE]);
-	info->uio.mem[BM_ADDR_CI].name = "cinh";
-	info->uio.mem[BM_ADDR_CI].addr = res[BM_ADDR_CI].start >> PAGE_SHIFT;
-	info->uio.mem[BM_ADDR_CI].size = resource_size(&res[BM_ADDR_CI]);
+	info->uio.mem[DPA_PORTAL_CE].name = "cena";
+	info->uio.mem[DPA_PORTAL_CE].addr =
+		res[DPA_PORTAL_CE].start >> PAGE_SHIFT;
+	info->uio.mem[DPA_PORTAL_CE].size = resource_size(&res[DPA_PORTAL_CE]);
+	info->uio.mem[DPA_PORTAL_CI].name = "cinh";
+	info->uio.mem[DPA_PORTAL_CI].addr =
+		res[DPA_PORTAL_CI].start >> PAGE_SHIFT;
+	info->uio.mem[DPA_PORTAL_CI].size = resource_size(&res[DPA_PORTAL_CI]);
 	info->uio.irq = irq;
 	info->uio.handler = dpa_uio_irq_handler;
 	info->uio.mmap = dpa_uio_mmap;
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index abce51b..f46d067 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -206,15 +206,15 @@ static __init struct qm_portal_config *fsl_qman_portal_init(
 		pr_warning("Revision=0x%04x, but portal '%s' has 0x%04x\n",
 			qman_ip_rev, node->full_name, ip_rev);
 
-	ret = of_address_to_resource(node, QM_ADDR_CE,
-				&pcfg->addr_phys[QM_ADDR_CE]);
+	ret = of_address_to_resource(node, DPA_PORTAL_CE,
+				&pcfg->addr_phys[DPA_PORTAL_CE]);
 	if (ret) {
 		pr_err("Can't get %s property '%s'\n", node->full_name,
 			"reg::CE");
 		goto err;
 	}
-	ret = of_address_to_resource(node, QM_ADDR_CI,
-				&pcfg->addr_phys[QM_ADDR_CI]);
+	ret = of_address_to_resource(node, DPA_PORTAL_CI,
+				&pcfg->addr_phys[DPA_PORTAL_CI]);
 	if (ret) {
 		pr_err("Can't get %s property '%s'\n", node->full_name,
 			"reg::CI");
@@ -299,13 +299,13 @@ static __init struct qm_portal_config *fsl_qman_portal_init(
 
 	/* Map the portals now we know they aren't for UIO (the UIO code doesn't
 	 * need the CE mapping, and so will do its own CI-only mapping). */
-	pcfg->addr_virt[QM_ADDR_CE] = ioremap_prot(
-				pcfg->addr_phys[QM_ADDR_CE].start,
-				resource_size(&pcfg->addr_phys[QM_ADDR_CE]),
+	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_prot(
+				pcfg->addr_phys[DPA_PORTAL_CE].start,
+				resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]),
 				0);
-	pcfg->addr_virt[QM_ADDR_CI] = ioremap_prot(
-				pcfg->addr_phys[QM_ADDR_CI].start,
-				resource_size(&pcfg->addr_phys[QM_ADDR_CI]),
+	pcfg->addr_virt[DPA_PORTAL_CI] = ioremap_prot(
+				pcfg->addr_phys[DPA_PORTAL_CI].start,
+				resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]),
 				_PAGE_GUARDED | _PAGE_NO_CACHE);
 
 	while (numpools--) {
@@ -333,8 +333,8 @@ err:
 
 static void __init fsl_qman_portal_destroy(struct qm_portal_config *pcfg)
 {
-	iounmap(pcfg->addr_virt[QM_ADDR_CE]);
-	iounmap(pcfg->addr_virt[QM_ADDR_CI]);
+	iounmap(pcfg->addr_virt[DPA_PORTAL_CE]);
+	iounmap(pcfg->addr_virt[DPA_PORTAL_CI]);
 	kfree(pcfg);
 }
 
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 26d93e1..7376998 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -370,8 +370,8 @@ struct qman_portal *qman_create_affine_portal(
 	/* prep the low-level portal struct with the mapped addresses from the
 	 * config, everything that follows depends on it and "config" is more
 	 * for (de)reference... */
-	__p->addr.addr_ce = config->addr_virt[QM_ADDR_CE];
-	__p->addr.addr_ci = config->addr_virt[QM_ADDR_CI];
+	__p->addr.addr_ce = config->addr_virt[DPA_PORTAL_CE];
+	__p->addr.addr_ci = config->addr_virt[DPA_PORTAL_CI];
 	if (qm_eqcr_init(__p, qm_eqcr_pvb, qm_eqcr_cce)) {
 		pr_err("Qman EQCR initialisation failed\n");
 		goto fail_eqcr;
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index fdda948..0ac0a59 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -110,8 +110,6 @@ enum qm_isr_reg {
 	qm_isr_inhibit = 3
 };
 
-#define QM_ADDR_CE 0
-#define QM_ADDR_CI 1
 struct qm_portal_config {
 	/* Corenet portal addresses;
 	 * [0]==cache-enabled, [1]==cache-inhibited. */
-- 
1.7.9.7

