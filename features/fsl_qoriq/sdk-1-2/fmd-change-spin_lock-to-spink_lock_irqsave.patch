From 53c56f0f181ea2eca25cd16967e7800d3591bb8d Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Tue, 14 Aug 2012 10:32:24 +0800
Subject: [PATCH 079/128] fmd: change spin_lock to spink_lock_irqsave

Issues are reported when running the kernel with lockdep enabled
regarding a possible deadlock related to the spin lock used in
FmGetSetPortParams().
Changed XX_LockSpinlock to XX_LockintrSpinlock and
XX_UnlockSpinlock to XX_UnlockintrSpinlock to avoid this issue.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |   26 +++++++++++---------
 1 file changed, 14 insertions(+), 12 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index d02b54d..5ab0cf1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -1358,6 +1358,7 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
     t_Error                     err;
     t_FmIpcPortNumOfFmanCtrls   params;
     t_FmIpcMsg                  msg;
+    unsigned long               flags;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((numOfFmanCtrls > 0) && (numOfFmanCtrls < 3)) , E_INVALID_HANDLE);
@@ -1381,7 +1382,7 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
         return E_OK;
     }
 
-    XX_LockSpinlock(p_Fm->h_Spinlock);
+    flags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
 
@@ -1401,7 +1402,7 @@ t_Error FmSetNumOfRiscsPerPort(t_Handle h_Fm, uint8_t hardwarePortId, uint8_t nu
         tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) | FPM_PORT_FM_CTL2;
     */
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fpmpr, tmpReg);
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
 
     return E_OK;
 }
@@ -1417,6 +1418,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     t_FmIpcMsg              msg;
     t_FmIpcReply            reply;
     uint32_t                replyLength;
+    unsigned long           flags;
 
     if(p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -1455,7 +1457,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    XX_LockSpinlock(p_Fm->h_Spinlock);
+    flags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     if(p_PortParams->independentMode)
     {
@@ -1469,7 +1471,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     {
         if(p_Fm->hcPortInitialized)
         {
-            XX_UnlockSpinlock(p_Fm->h_Spinlock);
+            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
         }
         else
@@ -1480,7 +1482,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfTasks, p_PortParams->numOfExtraTasks, TRUE);
     if(err)
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1525,7 +1527,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     {
         if(p_Fm->p_FmStateStruct->lowEndRestriction)
         {
-            XX_UnlockSpinlock(p_Fm->h_Spinlock);
+            XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
         }
         else
@@ -1540,14 +1542,14 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
                             TRUE);
     if(err)
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     err = FmSetNumOfOpenDmas(p_Fm, p_PortParams->hardwarePortId, p_PortParams->numOfOpenDmas, p_PortParams->numOfExtraOpenDmas, TRUE);
     if(err)
     {
-        XX_UnlockSpinlock(p_Fm->h_Spinlock);
+        XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1598,7 +1600,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     }
 
     FmGetPhysicalMuramBase(p_Fm, &p_PortParams->fmMuramPhysBaseAddr);
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
 
     return E_OK;
 }
@@ -1612,6 +1614,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     t_Error                 err;
     t_FmIpcPortFreeParams   portParams;
     t_FmIpcMsg              msg;
+    unsigned long           flags;
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -1635,8 +1638,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     }
 
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-    XX_LockSpinlock(p_Fm->h_Spinlock);
-
+    flags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
 
     if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
@@ -1707,7 +1709,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
         p_Fm->p_FmStateStruct->lowEndRestriction = FALSE;
 #endif /* FM_LOW_END_RESTRICTION */
-    XX_UnlockSpinlock(p_Fm->h_Spinlock);
+    XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, flags);
 }
 
 t_Error FmIsPortStalled(t_Handle h_Fm, uint8_t hardwarePortId, bool *p_IsStalled)
-- 
1.7.9.7

