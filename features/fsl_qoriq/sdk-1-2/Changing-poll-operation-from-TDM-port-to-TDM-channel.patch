From 42f498a12cca1f477ff6c146df9341b547799e61 Mon Sep 17 00:00:00 2001
From: Sandeep Singh <Sandeep@freescale.com>
Date: Thu, 10 May 2012 14:41:42 +0000
Subject: [PATCH 112/121] Changing poll operation from TDM port to TDM channel

Since all read/write operations are in TDM are channel based, polling on TDM channel
for data instead of TDM port before going for read/write.

Also corrected a faulty error leg.

Signed-off-by: Sandeep Singh <Sandeep@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/tdm/tdm-core.c |   51 +++++++++++++++---------------------------------
 include/linux/tdm.h    |    4 ++--
 2 files changed, 18 insertions(+), 37 deletions(-)

diff --git a/drivers/tdm/tdm-core.c b/drivers/tdm/tdm-core.c
index 666710a..6b508e7 100644
--- a/drivers/tdm/tdm-core.c
+++ b/drivers/tdm/tdm-core.c
@@ -88,10 +88,11 @@ static int tdm_attach_driver_adap(struct tdm_driver *driver,
 
 	if (driver->attach_adapter) {
 		ret = driver->attach_adapter(adap);
-		if (ret < 0)
+		if (ret < 0) {
 			pr_err("attach_adapter failed for driver [%s] err:%d\n"
 				, driver->name, ret);
 			return ret;
+		}
 	}
 	adap->drv_count++;
 
@@ -526,9 +527,6 @@ unsigned int tdm_port_open(struct tdm_driver *driver, void **h_port)
 		goto out;
 	}
 
-	init_waitqueue_head(&port->ch_wait_queue);
-
-
 	port->rx_max_frames = NUM_SAMPLES_PER_FRAME;
 	port->port_cfg.port_mode = e_TDM_PORT_CHANNELIZED;
 
@@ -738,53 +736,34 @@ unsigned int tdm_channel_write(void *h_port, void *h_channel,
 }
 EXPORT_SYMBOL(tdm_channel_write);
 
-wait_queue_head_t *tdm_port_get_wait_queue(void  *h_port)
-{
-	struct tdm_port *port;
-	port = (struct tdm_port *)h_port;
-
-	if (port == NULL) { /* invalid handle*/
-		pr_err("Invalid Handle");
-		return NULL;
-	}
-
-	return &port->ch_wait_queue;
-
-}
-EXPORT_SYMBOL(tdm_port_get_wait_queue);
-
-/* Driver Function for select and poll. Based on Port no, it sleeps on
+/* Driver Function for select and poll. Based on Channel, it sleeps on
  * waitqueue */
-unsigned int tdm_port_poll(void *h_port, unsigned int wait_time)
+unsigned int tdm_ch_poll(void *h_channel, unsigned int wait_time)
 {
-	struct tdm_port *port;
+	struct tdm_channel *channel;
 	unsigned long timeout = msecs_to_jiffies(wait_time);
-	port = (struct tdm_port *)h_port;
+	channel = h_channel;
 
-	if (port == NULL) { /* invalid handle*/
-		pr_err("%s: Invalid Handle\n", __func__);
-		return -ENXIO;
-	}
-	if (!port->p_port_data || !port->in_use)
+	if (!channel->p_ch_data || !channel->in_use)
 		return -EIO;
 
-	if (port->p_port_data->rx_out_data->flag) {
+	if (channel->p_ch_data->rx_out_data->flag) {
 		pr_debug("Data Available");
 		return TDM_E_OK;
 	}
 	if (timeout) {
-		wait_event_interruptible_timeout(port->ch_wait_queue,
-					  port->p_port_data->rx_out_data->flag,
+		wait_event_interruptible_timeout(channel->ch_wait_queue,
+					  channel->p_ch_data->rx_out_data->flag,
 					  timeout);
 
-		if (port->p_port_data->rx_out_data->flag) {
+		if (channel->p_ch_data->rx_out_data->flag) {
 			pr_debug("Data Available");
 			return TDM_E_OK;
 		}
 	}
 	return -EAGAIN;
 }
-EXPORT_SYMBOL(tdm_port_poll);
+EXPORT_SYMBOL(tdm_ch_poll);
 
 unsigned int tdm_port_get_stats(void *h_port, struct tdm_port_stats *portStat)
 {
@@ -890,6 +869,8 @@ static int tdm_data_rx_deinterleave(struct tdm_adapter *adap)
 						channel->p_ch_data->rx_data_fifo
 						: ch_bd+1;
 					ch_data = 1;
+					wake_up_interruptible
+						(&channel->ch_wait_queue);
 				}
 			} else {
 				port->port_stat.rx_pkt_drop_count++;
@@ -899,7 +880,6 @@ static int tdm_data_rx_deinterleave(struct tdm_adapter *adap)
 
 		if (ch_data) {
 			/*	Wake up the Port Data Poll event */
-			wake_up_interruptible(&port->ch_wait_queue);
 #ifdef	TDM_CORE_DEBUG
 			pr_info("Port RX-%d-%d\n", channel->ch_id, ch_data_len);
 			for (i = 0; i < ch_data_len; i++)
@@ -1052,7 +1032,8 @@ int tdm_channel_open(u16 chanid, u16 ch_width, struct tdm_port *port,
 		goto out;
 	}
 
-	p_ch_data = kzalloc(sizeof(struct tdm_port_data), GFP_KERNEL);
+	init_waitqueue_head(&channel->ch_wait_queue);
+	p_ch_data = kzalloc(sizeof(struct tdm_ch_data), GFP_KERNEL);
 	if (!p_ch_data) {
 		res = -ENOMEM;
 		goto outdata;
diff --git a/include/linux/tdm.h b/include/linux/tdm.h
index 8cf4ef5..06e8d73 100644
--- a/include/linux/tdm.h
+++ b/include/linux/tdm.h
@@ -172,7 +172,6 @@ struct tdm_port {
 					 TDM port statistics. */
 	struct tdm_port_data *p_port_data;	/* a structure parameters
 						defining tdm channelised data */
-	wait_queue_head_t ch_wait_queue;	/* waitQueue for RX Port Data */
 
 	struct tdm_driver *driver;	/* driver for this port */
 	struct tdm_adapter *adapter;	/* adapter for this port */
@@ -215,6 +214,7 @@ struct tdm_channel {
 	u16 in_use;			/* channel is enabled? */
 	struct tdm_ch_cfg ch_cfg;	/* channel configuration */
 	struct tdm_ch_data *p_ch_data;	/* data storage space for channel */
+	wait_queue_head_t ch_wait_queue;/* waitQueue for RX Channel Data */
 };
 
 /* tdm_adapt_algorithm is for accessing the routines of device */
@@ -326,7 +326,7 @@ extern unsigned int tdm_port_close(void *);
 extern unsigned int tdm_port_ioctl(void *, unsigned int, unsigned long);
 extern unsigned int tdm_channel_read(void *, void *, void *, u16 *);
 extern unsigned int tdm_channel_write(void *, void * , void *, u16);
-extern unsigned int tdm_port_poll(void *, unsigned int);
+extern unsigned int tdm_ch_poll(void *, unsigned int);
 
 extern int tdm_channel_open(u16, u16, struct tdm_port *, void **);
 extern int tdm_channel_close(u16, u16, struct tdm_port *,
-- 
1.7.9.7

