From 06dadcdc97b9bdce2387007302190d6ac4e71131 Mon Sep 17 00:00:00 2001
From: Timur Tabi <timur@freescale.com>
Date: Tue, 3 Apr 2012 23:52:43 +0000
Subject: [PATCH 057/121] powerpc/85xx: fsl-pamu: put the PAACT/OMT in its own
 coherence subdomain (Erratum A-004510)

Implement the work-around for erratum A-004510 in the Freescale PAMU device
driver.

Erratum A004510 says that under certain load conditions, modified
cache lines can be discarded, causing data corruption.  The work-around
involves multiple steps, one of which is to isolate the PAMU data structures
(PAACT and OMT) from the rest of the system address space before the PAMU is
enabled.

We also need to use a spinlock to ensure that only one core at a time is
reading or writing from these data structures.

The work-around is fully documented in Application Note AN4493.

Signed-off-by: Timur Tabi <timur@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/Kconfig           |   13 ++
 arch/powerpc/sysdev/fsl_pamu.c |  296 +++++++++++++++++++++++++++++++++++++++-
 2 files changed, 306 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig
index 919c532..e78d7e8 100644
--- a/arch/powerpc/Kconfig
+++ b/arch/powerpc/Kconfig
@@ -723,6 +723,19 @@ config FSL_PAMU
 	help
 	  Freescale PAMU/IOMMU support
 
+config FSL_PAMU_ERRATUM_A_004510
+	bool "Enable PAMU work-around for erratum A-004510"
+	depends on FSL_PAMU
+	# For now, enable this by default, so that we don't have to update
+	# defconfigs.  All current PAMU-enabled SOCs have the erratum.
+	default y
+	help
+	  Select this option to enable a work-around for erratum A-004510
+	  in the Freescale PAMU device driver.  Erratum A-004510 says that
+	  under certain load conditions, modified cache lines can be discarded,
+	  causing data corruption.  This option enables the PAMU portion of
+	  the work-around.
+
 config HAS_FSL_QBMAN
 	bool "Datapath Acceleration Queue and Buffer management"
 	help
diff --git a/arch/powerpc/sysdev/fsl_pamu.c b/arch/powerpc/sysdev/fsl_pamu.c
index feae293..6cc3d7b 100644
--- a/arch/powerpc/sysdev/fsl_pamu.c
+++ b/arch/powerpc/sysdev/fsl_pamu.c
@@ -438,6 +438,17 @@ int pamu_set_stash_dest(struct device_node *node, unsigned int index,
 	int liodn;
 	const u32 *prop;
 	unsigned int i;
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	/*
+	 * The work-around says that we cannot have multiple writes to the
+	 * PAACT in flight simultaneously, which could happen if multiple
+	 * cores try to update CID simultaneously.  To prevent that, we wrap
+	 * the write in a mutex, which will force the cores to perform their
+	 * updates in sequence.
+	 */
+	static DEFINE_SPINLOCK(pamu_lock);
+#endif
+
 
 	liodn = of_read_indexed_number(node, "fsl,liodn", index);
 	if (liodn < 0)
@@ -473,7 +484,16 @@ found_cpu:
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	spin_lock(&pamu_lock);
+#endif
+
 	ppaact[liodn].impl_attr.cid = be32_to_cpup(prop);
+	mb();
+
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	spin_unlock(&pamu_lock);
+#endif
 
 	return 0;
 }
@@ -750,6 +770,196 @@ static irqreturn_t pamu_av_isr(int irq, void *arg)
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+
+/*
+ * The work-around for erratum A-004510 says we need to create a coherency
+ * subdomain (CSD), which means we need to create a LAW (local access window)
+ * just for the PAACT and OMT, and then give it a unique CSD ID.  Linux
+ * normally doesn't touch the LAWs, so we define everything here.
+ */
+
+#define LAWAR_EN		0x80000000
+#define LAWAR_TARGET_MASK	0x0FF00000
+#define LAWAR_TARGET_SHIFT	20
+#define LAWAR_SIZE_MASK		0x0000003F
+#define LAWAR_CSDID_MASK	0x000FF000
+#define LAWAR_CSDID_SHIFT	12
+
+#define LAW_SIZE_4K		0xb
+
+struct ccsr_law {
+	u32	lawbarh;	/* LAWn base address high */
+	u32	lawbarl;	/* LAWn base address low */
+	u32	lawar;		/* LAWn attributes */
+	u32	reserved;
+};
+
+#define make64(high, low) (((u64)(high) << 32) | (low))
+
+/*
+ * Create a coherence subdomain for a given memory block.
+ */
+static int __init create_csd(phys_addr_t phys, size_t size, u32 csd_port_id)
+{
+	struct device_node *np;
+	const __be32 *iprop;
+	void __iomem *lac = NULL;	/* Local Access Control registers */
+	struct ccsr_law __iomem *law;
+	void __iomem *ccm = NULL;
+	u32 __iomem *csdids;
+	unsigned int i, num_laws, num_csds;
+	u32 law_target = 0;
+	u32 csd_id = 0;
+	int ret = 0;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,corenet-law");
+	if (!np)
+		return -ENODEV;
+
+	iprop = of_get_property(np, "fsl,num-laws", NULL);
+	if (!iprop) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	num_laws = be32_to_cpup(iprop);
+	if (!num_laws) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	lac = of_iomap(np, 0);
+	if (!lac) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	/* LAW registers are at offset 0xC00 */
+	law = lac + 0xC00;
+
+	of_node_put(np);
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,corenet-cf");
+	if (!np) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	iprop = of_get_property(np, "fsl,ccf-num-csdids", NULL);
+	if (!iprop) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	num_csds = be32_to_cpup(iprop);
+	if (!num_csds) {
+		ret = -ENODEV;
+		goto error;
+	}
+
+	ccm = of_iomap(np, 0);
+	if (!ccm) {
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	/* The undocumented CSDID registers are at offset 0x600 */
+	csdids = ccm + 0x600;
+
+	of_node_put(np);
+	np = NULL;
+
+	/* Find an unused coherence subdomain ID */
+	for (csd_id = 0; csd_id < num_csds; csd_id++) {
+		if (!csdids[csd_id])
+			break;
+	}
+
+	/* Store the Port ID in the (undocumented) proper CIDMRxx register */
+	csdids[csd_id] = csd_port_id;
+
+	/* Find the DDR LAW that maps to our buffer. */
+	for (i = 0; i < num_laws; i++) {
+		if (law[i].lawar & LAWAR_EN) {
+			phys_addr_t law_start, law_end;
+
+			law_start = make64(law[i].lawbarh, law[i].lawbarl);
+			law_end = law_start +
+				(1ULL << (law[i].lawar & LAWAR_SIZE_MASK));
+
+			if (law_start <= phys && phys < law_end) {
+				law_target = law[i].lawar & LAWAR_TARGET_MASK;
+				break;
+			}
+		}
+	}
+
+	if (i == 0 || i == num_laws) {
+		/* This should never happen*/
+		ret = -ENOENT;
+		goto error;
+	}
+
+	/* Find a free LAW entry */
+	while (law[--i].lawar & LAWAR_EN) {
+		if (i == 0) {
+			/* No higher priority LAW slots available */
+			ret = -ENOENT;
+			goto error;
+		}
+	}
+
+	law[i].lawbarh = upper_32_bits(phys);
+	law[i].lawbarl = lower_32_bits(phys);
+	wmb();
+	law[i].lawar = LAWAR_EN | law_target | (csd_id << LAWAR_CSDID_SHIFT) |
+		(LAW_SIZE_4K + get_order(size));
+	wmb();
+
+error:
+	if (ccm)
+		iounmap(ccm);
+
+	if (lac)
+		iounmap(lac);
+
+	if (np)
+		of_node_put(np);
+
+	return ret;
+}
+#endif
+
+/*
+ * Table of SVRs and the corresponding PORT_ID values.
+ *
+ * All future CoreNet-enabled SOCs will have this erratum fixed, so this table
+ * should never need to be updated.  SVRs are guaranteed to be unique, so
+ * there is no worry that a future SOC will inadvertently have one of these
+ * values.
+ */
+static const struct {
+	u32 svr;
+	u32 port_id;
+} port_id_map[] = {
+	{0x82100010, 0xFF000000},	/* P2040 1.0 */
+	{0x82100011, 0xFF000000},	/* P2040 1.1 */
+	{0x82100110, 0xFF000000},	/* P2041 1.0 */
+	{0x82100111, 0xFF000000},	/* P2041 1.1 */
+	{0x82110310, 0xFF000000},	/* P3041 1.0 */
+	{0x82110311, 0xFF000000},	/* P3041 1.1 */
+	{0x82010020, 0xFFF80000},	/* P4040 2.0 */
+	{0x82000020, 0xFFF80000},	/* P4080 2.0 */
+	{0x82210010, 0xFC000000},       /* P5010 1.0 */
+	{0x82210020, 0xFC000000},       /* P5010 2.0 */
+	{0x82200010, 0xFC000000},	/* P5020 1.0 */
+	{0x82050010, 0xFF800000},	/* P5021 1.0 */
+	{0x82040010, 0xFF800000},	/* P5040 1.0 */
+};
+
+#define SVR_SECURITY	0x80000	/* The Security (E) bit */
+
 static int __init fsl_pamu_probe(struct platform_device *pdev)
 {
 	void __iomem *pamu_regs = NULL;
@@ -762,6 +972,12 @@ static int __init fsl_pamu_probe(struct platform_device *pdev)
 	int ret = 0;
 	struct ome *omt = NULL;
 	int irq;
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	size_t mem_size = 0;
+	unsigned int order = 0;
+	u32 csd_port_id = 0;
+	unsigned i;
+#endif
 
 	/*
 	 * enumerate all PAMUs and allocate and setup PAMU tables
@@ -806,6 +1022,71 @@ static int __init fsl_pamu_probe(struct platform_device *pdev)
 		goto error;
 	}
 
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	/*
+	 * To simplify the allocation of a coherency domain, we allocate the
+	 * PAACT and the OMT in the same memory buffer.  Unfortunately, this
+	 * wastes more memory compared to allocating the buffers separately.
+	 */
+
+	/* Determine how much memory we need */
+	mem_size = (PAGE_SIZE << get_order(PAACT_SIZE)) +
+		(PAGE_SIZE << get_order(OMT_SIZE));
+	order = get_order(mem_size);
+
+	p = alloc_pages(GFP_KERNEL | __GFP_ZERO, order);
+	if (!p) {
+		dev_err(&pdev->dev, "unable to allocate PAACT/OMT block\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	ppaact = page_address(p);
+	ppaact_phys = page_to_phys(p);
+
+	/* Make sure the memory is naturally aligned */
+	if (ppaact_phys & ((PAGE_SIZE << order) - 1)) {
+		dev_err(&pdev->dev, "PAACT/OMT block is unaligned\n");
+		ret = -ENOMEM;
+		goto error;
+	}
+
+	/* This assumes that PAACT_SIZE is larger than OMT_SIZE */
+	omt = (void *)ppaact + (PAGE_SIZE << get_order(PAACT_SIZE));
+
+	dev_dbg(&pdev->dev, "ppaact virt=%p phys=0x%llx\n", ppaact,
+		(unsigned long long) ppaact_phys);
+
+	dev_dbg(&pdev->dev, "omt virt=%p phys=0x%llx\n", omt,
+		(unsigned long long) virt_to_phys(omt));
+
+	/* Check to see if we need to implement the work-around on this SOC */
+
+	/* Determine the Port ID for our coherence subdomain */
+	for (i = 0; i < ARRAY_SIZE(port_id_map); i++) {
+		if (port_id_map[i].svr == (mfspr(SPRN_SVR) & ~SVR_SECURITY)) {
+			csd_port_id = port_id_map[i].port_id;
+			dev_dbg(&pdev->dev, "found matching SVR %08x\n",
+				port_id_map[i].svr);
+			break;
+		}
+	}
+
+	if (csd_port_id) {
+		dev_info(&pdev->dev, "implementing work-around for erratum "
+			 "A-004510\n");
+		dev_dbg(&pdev->dev, "creating coherency subdomain at address "
+			"0x%llx, size %zu, port id 0x%08x", ppaact_phys,
+			mem_size, csd_port_id);
+
+		ret = create_csd(ppaact_phys, mem_size, csd_port_id);
+		if (ret) {
+			dev_err(&pdev->dev, "could not create coherence "
+				"subdomain\n");
+			return ret;
+		}
+	}
+#else
 	p = alloc_pages(GFP_KERNEL | __GFP_ZERO, get_order(PAACT_SIZE));
 	if (!p) {
 		dev_err(&pdev->dev, "unable to allocate PAACT table\n");
@@ -828,6 +1109,7 @@ static int __init fsl_pamu_probe(struct platform_device *pdev)
 
 	dev_dbg(&pdev->dev, "omt virt=%p phys=0x%llx\n", omt,
 		(unsigned long long) page_to_phys(p));
+#endif
 
 	pamubypenr = in_be32(&guts_regs->pamubypenr);
 
@@ -866,12 +1148,20 @@ error:
 	if (guts_regs)
 		iounmap(guts_regs);
 
-	free_pages((unsigned long)ppaact, get_order(PAACT_SIZE));
+#ifdef CONFIG_FSL_PAMU_ERRATUM_A_004510
+	if (ppaact)
+		free_pages((unsigned long)ppaact, order);
+#else
+	if (ppaact)
+		free_pages((unsigned long)ppaact, get_order(PAACT_SIZE));
+
+	if (omt)
+		free_pages((unsigned long)omt, get_order(OMT_SIZE));
+#endif
+
 	ppaact = NULL;
 	ppaact_phys = 0;
 
-	free_pages((unsigned long)omt, get_order(OMT_SIZE));
-
 	return ret;
 }
 
-- 
1.7.9.7

