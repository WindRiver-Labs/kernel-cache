From 9f2a207ee0c8e33a8b8874deeaa64c22a4142ed3 Mon Sep 17 00:00:00 2001
From: Qiang Liu <qiang.liu@freescale.com>
Date: Tue, 28 Feb 2012 18:43:03 +0000
Subject: [PATCH 002/121] SD/MMC: Add an interface to re-initialize the bounce
 buffer

Add bounce_size under /sys/block/mmcblk0/bouncesz. Support dynamic adjustment of
bounce buffer in run-time (include mounted or unmounted filesystem)

/sys/block/mmcblk0/bouncesz should be integer multiple of 512, the value should
be range from 4096 to 4194304

1. Use variable instead of MMC_QUEUE_BOUNCESZ
2. Re-initialize bounce buffer accorinding to new bounce size at run-time

Signed-off-by: Qiang Liu <qiang.liu@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image. Add variable err
for mmc_blk_probe to fix build error.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 Documentation/mmc/mmc-dev-attrs.txt |    2 +
 drivers/mmc/card/block.c            |   50 ++++++++++++++++-
 drivers/mmc/card/queue.c            |  102 ++++++++++++++++++++++++++++++++++-
 drivers/mmc/card/queue.h            |    5 ++
 4 files changed, 157 insertions(+), 2 deletions(-)

diff --git a/Documentation/mmc/mmc-dev-attrs.txt b/Documentation/mmc/mmc-dev-attrs.txt
index 22ae844..1314cab 100644
--- a/Documentation/mmc/mmc-dev-attrs.txt
+++ b/Documentation/mmc/mmc-dev-attrs.txt
@@ -7,6 +7,8 @@ SD or MMC device.
 The following attributes are read/write.
 
 	force_ro		Enforce read-only access even if write protect switch is off.
+	bouncesz		Support dynamic adjustment of bounce buffer size at runtime,
+				from 4096 to 4194304, integer multiple of 512 bytes only.
 
 SD and MMC Device Attributes
 ============================
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index dabec55..a1bf455 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -58,6 +58,9 @@ MODULE_ALIAS("mmc:block");
 #define INAND_CMD38_ARG_SECTRIM1 0x81
 #define INAND_CMD38_ARG_SECTRIM2 0x88
 
+#define MMC_MIN_QUEUE_BOUNCESZ 4096
+#define MMC_MAX_QUEUE_BOUNCESZ 4194304
+
 static DEFINE_MUTEX(block_mutex);
 
 /*
@@ -108,6 +111,7 @@ struct mmc_blk_data {
 	struct device_attribute force_ro;
 	struct device_attribute power_ro_lock;
 	int	area_type;
+	struct device_attribute bouncesz;
 };
 
 static DEFINE_MUTEX(open_lock);
@@ -1662,12 +1666,40 @@ static void mmc_blk_remove_req(struct mmc_blk_data *md)
 			del_gendisk(md->disk);
 		}
 
+		device_remove_file(disk_to_dev(md->disk), &md->bouncesz);
 		/* Then flush out any already in there */
 		mmc_cleanup_queue(&md->queue);
 		mmc_blk_put(md);
 	}
 }
 
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+static ssize_t mmc_bouncesz_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	 return sprintf(buf, "%u\n", mmc_queue_bouncesz);
+}
+
+static ssize_t mmc_bouncesz_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	unsigned int bouncesz;
+	struct mmc_blk_data *md;
+
+	if ((sscanf(buf, "%d", &bouncesz) != 1) ||
+			(bouncesz < MMC_MIN_QUEUE_BOUNCESZ) ||
+			(bouncesz > MMC_MAX_QUEUE_BOUNCESZ) ||
+			(bouncesz % 512 != 0))
+		return -EINVAL;
+
+	md = mmc_blk_get(dev_to_disk(dev));
+	mmc_reinit_bounce_queue(&md->queue, md->queue.card, bouncesz);
+	mmc_blk_put(md);
+	return mmc_queue_bouncesz;
+}
+#endif
+
 static void mmc_blk_remove_parts(struct mmc_card *card,
 				 struct mmc_blk_data *md)
 {
@@ -1773,6 +1805,7 @@ static int mmc_blk_probe(struct mmc_card *card)
 {
 	struct mmc_blk_data *md, *part_md;
 	char cap_str[10];
+	int err = 0;
 
 	/*
 	 * Check that the card supports the command class(es) we need.
@@ -1803,12 +1836,27 @@ static int mmc_blk_probe(struct mmc_card *card)
 		if (mmc_add_disk(part_md))
 			goto out;
 	}
+
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+	md->bouncesz.show = mmc_bouncesz_show;
+	md->bouncesz.store = mmc_bouncesz_store;
+	sysfs_attr_init(&md->bouncesz.attr);
+	md->bouncesz.attr.name = "bouncesz";
+	md->bouncesz.attr.mode = S_IRUGO | S_IWUSR;
+	err = device_create_file(disk_to_dev(md->disk), &md->bouncesz);
+	if (err)
+		goto out;
+#endif
+
 	return 0;
 
  out:
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+	device_remove_file(disk_to_dev(md->disk), &md->bouncesz);
+#endif
 	mmc_blk_remove_parts(card, md);
 	mmc_blk_remove_req(md);
-	return 0;
+	return err;
 }
 
 static void mmc_blk_remove(struct mmc_card *card)
diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c
index 996f8e3..e44f61d 100644
--- a/drivers/mmc/card/queue.c
+++ b/drivers/mmc/card/queue.c
@@ -22,6 +22,10 @@
 
 #define MMC_QUEUE_BOUNCESZ	65536
 
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+unsigned mmc_queue_bouncesz = MMC_QUEUE_BOUNCESZ;
+#endif
+
 #define MMC_QUEUE_SUSPENDED	(1 << 0)
 
 /*
@@ -190,7 +194,7 @@ int mmc_init_queue(struct mmc_queue *mq, struct mmc_card *card,
 	if (host->max_segs == 1) {
 		unsigned int bouncesz;
 
-		bouncesz = MMC_QUEUE_BOUNCESZ;
+		bouncesz = mmc_queue_bouncesz;
 
 		if (bouncesz > host->max_req_size)
 			bouncesz = host->max_req_size;
@@ -334,6 +338,102 @@ void mmc_cleanup_queue(struct mmc_queue *mq)
 EXPORT_SYMBOL(mmc_cleanup_queue);
 
 /**
+ * mmc_reinit_bounce_queue - re-initialise a bounce buffer.
+ * @mq: mmc queue
+ * @card: mmc card to attach this queue
+ * @bouncesz: the bounce size that need re-initializing
+ *
+ * Initialise a MMC card request queue.
+ */
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+int mmc_reinit_bounce_queue(struct mmc_queue *mq, struct mmc_card *card,
+		   unsigned int bouncesz)
+{
+	struct mmc_host *host = card->host;
+	struct mmc_queue_req *mqrq_cur = &mq->mqrq[0];
+	struct mmc_queue_req *mqrq_prev = &mq->mqrq[1];
+	int ret;
+	struct scatterlist *curr_bounce_sg, *prev_bounce_sg;
+	char *curr_bounce_buf, *prev_bounce_buf;
+
+	mmc_claim_host(card->host);
+
+	bouncesz = min(bouncesz, host->max_req_size);
+	bouncesz = min(bouncesz, host->max_seg_size);
+	bouncesz = min(bouncesz, host->max_blk_count * 512);
+
+	/* store current using addr of bounce_buf and bounce_sg */
+	curr_bounce_sg = mqrq_cur->bounce_sg;
+	prev_bounce_sg = mqrq_prev->bounce_sg;
+	curr_bounce_buf = mqrq_cur->bounce_buf;
+	prev_bounce_buf = mqrq_prev->bounce_buf;
+
+	if (host->max_segs != 1)
+		goto restore_queue;
+
+	/* realloc bounce queue use given bounce size */
+	mqrq_cur->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+	if (!mqrq_cur->bounce_buf) {
+		printk(KERN_WARNING "%s: unable to "
+			"allocate bounce cur buffer\n",
+			mmc_card_name(card));
+		ret = -ENOMEM;
+		goto restore_queue;
+	}
+
+	mqrq_prev->bounce_buf = kmalloc(bouncesz, GFP_KERNEL);
+	if (!mqrq_prev->bounce_buf) {
+		printk(KERN_WARNING "%s: unable to "
+			"allocate bounce prev buffer\n",
+			mmc_card_name(card));
+		kfree(mqrq_cur->bounce_buf);
+		mqrq_cur->bounce_buf = NULL;
+		ret = -ENOMEM;
+		goto restore_queue;
+	}
+
+	mqrq_cur->bounce_sg =
+		mmc_alloc_sg(bouncesz / 512, &ret);
+	if (ret)
+		goto cleanup_queue;
+
+	mqrq_prev->bounce_sg =
+		mmc_alloc_sg(bouncesz / 512, &ret);
+	if (ret)
+		goto cleanup_queue;
+
+	blk_queue_max_hw_sectors(mq->queue, bouncesz / 512);
+	blk_queue_max_segments(mq->queue, bouncesz / 512);
+	blk_queue_max_segment_size(mq->queue, bouncesz);
+	mmc_queue_bouncesz = bouncesz;
+
+	kfree(curr_bounce_sg);
+	kfree(prev_bounce_sg);
+	kfree(curr_bounce_buf);
+	kfree(prev_bounce_buf);
+
+	mmc_release_host(card->host);
+	return 0;
+
+cleanup_queue:
+	/* cleanup bounce queue first */
+	kfree(mqrq_cur->sg);
+	kfree(mqrq_cur->bounce_buf);
+	kfree(mqrq_prev->sg);
+	kfree(mqrq_prev->bounce_buf);
+
+restore_queue:
+	mqrq_cur->bounce_buf = curr_bounce_buf;
+	mqrq_prev->bounce_buf = prev_bounce_buf;
+	mqrq_cur->bounce_sg = curr_bounce_sg;
+	mqrq_prev->bounce_sg = prev_bounce_sg;
+
+	mmc_release_host(card->host);
+	return ret;
+}
+#endif
+
+/**
  * mmc_queue_suspend - suspend a MMC request queue
  * @mq: MMC queue to suspend
  *
diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h
index d2a1eb4..3cbc095 100644
--- a/drivers/mmc/card/queue.h
+++ b/drivers/mmc/card/queue.h
@@ -45,5 +45,10 @@ extern unsigned int mmc_queue_map_sg(struct mmc_queue *,
 				     struct mmc_queue_req *);
 extern void mmc_queue_bounce_pre(struct mmc_queue_req *);
 extern void mmc_queue_bounce_post(struct mmc_queue_req *);
+#ifdef CONFIG_MMC_BLOCK_BOUNCE
+extern int mmc_reinit_bounce_queue(struct mmc_queue *, struct mmc_card *,
+		unsigned int);
+extern unsigned mmc_queue_bouncesz;
+#endif
 
 #endif
-- 
1.7.9.7

