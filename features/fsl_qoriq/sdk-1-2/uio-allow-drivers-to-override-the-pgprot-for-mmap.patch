From c70dc2f2629f2563017c6f21fbdd9860338e720c Mon Sep 17 00:00:00 2001
From: Kumar Gala <galak@kernel.crashing.org>
Date: Wed, 14 Mar 2012 04:49:34 +0000
Subject: [PATCH 065/121] uio: allow drivers to override the pgprot for mmap

For some devices, the default behavior of pgprot_noncached() is not
appropriate for all of its mappable regions. This provides a means for
the kernel side of the UIO driver to override the flags without having
to implement its own full mmap callback.

Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Geoff Thorpe <geoff@geoffthorpe.net>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 Documentation/DocBook/uio-howto.tmpl |   12 ++++++++++++
 drivers/uio/uio.c                    |    6 +++++-
 include/linux/uio_driver.h           |    3 +++
 3 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/Documentation/DocBook/uio-howto.tmpl b/Documentation/DocBook/uio-howto.tmpl
index ac3d001..8e98e2f 100644
--- a/Documentation/DocBook/uio-howto.tmpl
+++ b/Documentation/DocBook/uio-howto.tmpl
@@ -510,6 +510,18 @@ interrupts from userspace by writing to <filename>/dev/uioX</filename>,
 you can implement this function. The parameter <varname>irq_on</varname>
 will be 0 to disable interrupts and 1 to enable them.
 </para></listitem>
+
+<listitem><para>
+<varname>pgprot_t (*set_pgprot)(struct uio_info *info, unsigned int mem_idx,
+pgprot_t prot)</varname>: Optional. If special flags are required when mapping
+certain hardware regions, then this callback can be used to specify those flags.
+The default flags are given by the host architecture's definition of
+<function>pgprot_noncached()</function> and are passed to the callback as the
+<varname>prot</varname> parameter, but the return value is what is used for the
+resulting mapping. Note that this callback is only used by the built in mapping
+logic (when the <function>mmap()</function> callback has not been set), and then
+only for UIO_MEM_PHYS regions.
+</para></listitem>
 </itemizedlist>
 
 <para>
diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index a783d53..3cdd874 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -655,7 +655,11 @@ static int uio_mmap_physical(struct vm_area_struct *vma)
 
 	vma->vm_flags |= VM_IO | VM_RESERVED;
 
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (idev->info->set_pgprot)
+		vma->vm_page_prot = idev->info->set_pgprot(idev->info, mi,
+							   vma->vm_page_prot);
+	else
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
 	return remap_pfn_range(vma,
 			       vma->vm_start,
diff --git a/include/linux/uio_driver.h b/include/linux/uio_driver.h
index 1ad4724..66af0e9 100644
--- a/include/linux/uio_driver.h
+++ b/include/linux/uio_driver.h
@@ -80,6 +80,7 @@ struct uio_device;
  * @open:		open operation for this uio device
  * @release:		release operation for this uio device
  * @irqcontrol:		disable/enable irqs when 0/1 is written to /dev/uioX
+ * @set_pgprot:		allow driver to override default(noncached) pgprot
  */
 struct uio_info {
 	struct uio_device	*uio_dev;
@@ -95,6 +96,8 @@ struct uio_info {
 	int (*open)(struct uio_info *info, struct inode *inode);
 	int (*release)(struct uio_info *info, struct inode *inode);
 	int (*irqcontrol)(struct uio_info *info, s32 irq_on);
+	pgprot_t (*set_pgprot)(struct uio_info *uio, unsigned int mem_idx,
+			       pgprot_t prot);
 };
 
 extern int __must_check
-- 
1.7.9.7

