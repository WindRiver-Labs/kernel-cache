From ed1f90f219d87f713bac89bbe35d52ce2c640bd0 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 14 Mar 2012 04:49:44 +0000
Subject: [PATCH 079/121] qman: invalidate all DQRR entries on initialisation

If a portal is reinitialised for use on a different CPU to the previous
usage of the portal, there is a possibility that a stale cache entry
could be misinterpreted as a valid entry after reinitialisation, leading
to undefined results. This can't happen if the portal is reused on the
same CPU as the previous usage, because "valid bit" polarity prevents
that happening. The recently added functionality that removes the
assumption of a static portal->cpu assignment is what creates this
theoretical possibility. The simplest solution is to forcibly invalidate
the cachelines for all DQRR entries on portal initialisation.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/qman_low.h |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index f249e81..4b339e5 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -539,6 +539,9 @@ static inline int qm_dqrr_init(struct qm_portal *portal,
 	dqrr->pmode = pmode;
 	dqrr->cmode = cmode;
 #endif
+	/* Invalidate every ring entry before beginning */
+	for (cfg = 0; cfg > QM_DQRR_SIZE; cfg++)
+		dcbi(qm_cl(dqrr->ring, cfg));
 	cfg = (qm_in(CFG) & 0xff000f00) |
 		((max_fill & (QM_DQRR_SIZE - 1)) << 20) | /* DQRR_MF */
 		((dmode & 1) << 18) |			/* DP */
-- 
1.7.9.7

