From 953018ada661a86a2b217bb1e878adbc00c72c43 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Fri, 28 Oct 2011 14:39:16 -0500
Subject: [PATCH 065/128] qman: remove support for non-stashing
 configurations.

Linux no longer needs support for portals whose stashing LIODNs aren't
configured, as there is a native PAMU driver. This commit simplifies
driver interfaces and makes upcoming features easier to implement. In
any case, if a later need for a non-coherent driver mode comes up, it
could be reintroduced in an easier manner than the current code which
is being removed.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/Kconfig       |   10 ----------
 drivers/staging/fsl_qbman/qman_driver.c |   10 ----------
 drivers/staging/fsl_qbman/qman_high.c   |   19 +++++--------------
 drivers/staging/fsl_qbman/qman_low.h    |   23 +++--------------------
 include/linux/fsl_qman.h                |    2 --
 5 files changed, 8 insertions(+), 56 deletions(-)

diff --git a/drivers/staging/fsl_qbman/Kconfig b/drivers/staging/fsl_qbman/Kconfig
index 45357bc..dd20878 100644
--- a/drivers/staging/fsl_qbman/Kconfig
+++ b/drivers/staging/fsl_qbman/Kconfig
@@ -150,16 +150,6 @@ config FSL_QMAN_NULL_FQ_DEMUX
 	  feature, but it adds a small overhead to the hottest-path in the
 	  driver, so it should be disabled unless needed.
 
-config FSL_QMAN_DQRR_PREFETCHING
-	bool "support prefetching or DQRR (if stashing disabled)"
-	default y
-	---help---
-	  Normally, portals are configured to stash DQRR entries, but if this is
-	  not the case, then s/w needs to invalidate and prefetch ring entries.
-	  Selecting this option supports both cases and chooses the best one at
-	  run-time, but introduces a small overhead in some hot paths of the
-	  driver, so disable it if you know stashing will be configured.
-
 config FSL_QMAN_CONFIG
 	bool "Qman device management"
 	default y
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 996415f..4b8b018 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -268,16 +268,6 @@ static __init struct qm_portal_config *fsl_qman_portal_init(
 	}
 	pcfg->public_cfg.irq = irq;
 	pcfg->public_cfg.index = *index;
-	if (of_get_property(node, "fsl,hv-dma-handle", &ret))
-		pcfg->public_cfg.has_stashing = 1;
-	else if (qman_ip_rev == QMAN_REV20)
-		pcfg->public_cfg.has_stashing = 1;
-	else
-#ifdef CONFIG_FSL_PAMU
-		pcfg->public_cfg.has_stashing = 1;
-#else
-		pcfg->public_cfg.has_stashing = 0;
-#endif
 	pcfg->public_cfg.pools = 0;
 	pcfg->node = node;
 #ifdef CONFIG_FSL_QMAN_CONFIG
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 3c6d1bd..f454735 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -72,7 +72,6 @@ static inline int fq_isclear(struct qman_fq *fq, u32 mask)
 	return !(fq->flags & mask);
 }
 
-#define PORTAL_BITS_CI_PREFETCH	0x00020000	/* EQCR::CI prefetched */
 #define PORTAL_BITS_RECOVERY	0x00040000	/* recovery mode */
 
 struct qman_portal {
@@ -390,10 +389,9 @@ struct qman_portal *qman_create_affine_portal(
 #else
 #define QM_DQRR_CMODE qm_dqrr_cdc
 #endif
-	/* for recovery mode, don't enable stashing yet */
 	if (qm_dqrr_init(__p, config, qm_dqrr_dpush, qm_dqrr_pvb,
 			recovery_mode ?  qm_dqrr_cci : QM_DQRR_CMODE,
-			DQRR_MAXFILL, recovery_mode)) {
+			DQRR_MAXFILL)) {
 		pr_err("Qman DQRR initialisation failed\n");
 		goto fail_dqrr;
 	}
@@ -412,7 +410,7 @@ struct qman_portal *qman_create_affine_portal(
 		qm_dqrr_sdqcr_set(__p, 0);
 		qm_dqrr_vdqcr_set(__p, 0);
 drain_loop:
-		qm_dqrr_pvb_update(__p, 0);
+		qm_dqrr_pvb_update(__p);
 		dq = qm_dqrr_current(__p);
 		qm_mr_pvb_update(__p);
 		msg = qm_mr_current(__p);
@@ -851,18 +849,11 @@ static inline unsigned int __poll_portal_fast(struct qman_portal *p,
 	const struct qm_dqrr_entry *dq;
 	struct qman_fq *fq;
 	enum qman_cb_dqrr_result res;
-#ifdef CONFIG_FSL_QMAN_DQRR_PREFETCHING
-	int coherent = (p->config->public_cfg.has_stashing);
-#endif
 	unsigned int limit = 0;
 
 	BUG_ON(p->bits & PORTAL_BITS_RECOVERY);
 loop:
-#ifdef CONFIG_FSL_QMAN_DQRR_PREFETCHING
-	qm_dqrr_pvb_update(&p->p, coherent);
-#else
-	qm_dqrr_pvb_update(&p->p, 1);
-#endif
+	qm_dqrr_pvb_update(&p->p);
 	dq = qm_dqrr_current(&p->p);
 	if (!dq)
 		goto done;
@@ -1128,7 +1119,7 @@ static unsigned int recovery_poll_dqrr(struct qman_portal *p, u32 fqid)
 	u8 empty = 0, num_fds = 0;
 
 loop:
-	qm_dqrr_pvb_update(&p->p, 0);
+	qm_dqrr_pvb_update(&p->p);
 	dq = qm_dqrr_current(&p->p);
 	if (!dq) {
 		cpu_relax();
@@ -1248,7 +1239,7 @@ void qman_recovery_exit_local(void)
 	post_recovery(p, p->config);
 	clear_bits(PORTAL_BITS_RECOVERY, &p->bits);
 	if (qm_dqrr_init(&p->p, p->config, qm_dqrr_dpush, qm_dqrr_pvb,
-			QM_DQRR_CMODE, DQRR_MAXFILL, 0))
+			QM_DQRR_CMODE, DQRR_MAXFILL))
 		panic("Qman DQRR initialisation failed, recovery broken");
 	qm_dqrr_sdqcr_set(&p->p, p->sdqcr);
 	qm_isr_status_clear(&p->p, 0xffffffff);
diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index 6caca90..f249e81 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -179,9 +179,6 @@ struct qm_dqrr {
 	const struct qm_dqrr_entry *ring, *cursor;
 	u8 pi, ci, fill, ithresh, vbit;
 #ifdef CONFIG_FSL_DPA_CHECKING
-#define QM_DQRR_FLAG_RE 0x01 /* Stash ring entries */
-#define QM_DQRR_FLAG_SE 0x02 /* Stash data */
-	u8 flags;
 	enum qm_dqrr_dmode dmode;
 	enum qm_dqrr_pmode pmode;
 	enum qm_dqrr_cmode cmode;
@@ -520,14 +517,11 @@ static inline int qm_dqrr_init(struct qm_portal *portal,
 				const struct qm_portal_config *config,
 				enum qm_dqrr_dmode dmode,
 				__maybe_unused enum qm_dqrr_pmode pmode,
-				enum qm_dqrr_cmode cmode, u8 max_fill,
-				int disable_stash)
+				enum qm_dqrr_cmode cmode, u8 max_fill)
 {
 	register struct qm_dqrr *dqrr = &portal->dqrr;
 	u32 cfg;
 
-	if ((config->public_cfg.has_stashing) && (config->public_cfg.cpu == -1))
-		return -EINVAL;
 	/* Make sure the DQRR will be idle when we enable */
 	qm_out(DQRR_SDQCR, 0);
 	qm_out(DQRR_VDQCR, 0);
@@ -544,16 +538,12 @@ static inline int qm_dqrr_init(struct qm_portal *portal,
 	dqrr->dmode = dmode;
 	dqrr->pmode = pmode;
 	dqrr->cmode = cmode;
-	dqrr->flags = 0;
-	if (!disable_stash)
-		dqrr->flags |= QM_DQRR_FLAG_RE | QM_DQRR_FLAG_SE;
 #endif
 	cfg = (qm_in(CFG) & 0xff000f00) |
 		((max_fill & (QM_DQRR_SIZE - 1)) << 20) | /* DQRR_MF */
 		((dmode & 1) << 18) |			/* DP */
 		((cmode & 3) << 16) |			/* DCM */
-		(disable_stash ? 0 :			/* RE+SE */
-			config->public_cfg.has_stashing ? 0xa0 : 0) |
+		0xa0 |					/* RE+SE */
 		(0 ? 0x40 : 0) |			/* Ignore RP */
 		(0 ? 0x10 : 0);				/* Ignore SP */
 	qm_out(CFG, cfg);
@@ -624,7 +614,7 @@ static inline u8 qm_dqrr_pce_update(struct qm_portal *portal)
 	return diff;
 }
 
-static inline void qm_dqrr_pvb_update(struct qm_portal *portal, int coherent)
+static inline void qm_dqrr_pvb_update(struct qm_portal *portal)
 {
 	register struct qm_dqrr *dqrr = &portal->dqrr;
 	const struct qm_dqrr_entry *res = qm_cl(dqrr->ring, dqrr->pi);
@@ -636,13 +626,6 @@ static inline void qm_dqrr_pvb_update(struct qm_portal *portal, int coherent)
 		if (!dqrr->pi)
 			dqrr->vbit ^= QM_DQRR_VERB_VBIT;
 		dqrr->fill++;
-		if (!coherent) {
-			DPA_ASSERT(!(dqrr->flags & QM_DQRR_FLAG_RE));
-			dcbit_ro(DQRR_INC(res));
-		}
-	} else if (!coherent) {
-		DPA_ASSERT(!(dqrr->flags & QM_DQRR_FLAG_RE));
-		dcbit_ro(res);
 	}
 }
 
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 8a95f3b..cd04f74 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1004,8 +1004,6 @@ struct qman_portal_config {
 	/* A mask of which pool channels this portal has dequeue access to
 	 * (using QM_SDQCR_CHANNELS_POOL(n) for the bitmask) */
 	u32 pools;
-	/* Is stashing available? (Depends on PAMU config) */
-	int has_stashing;
 };
 
 /* This enum, and the callback type that returns it, are used when handling
-- 
1.7.9.7

