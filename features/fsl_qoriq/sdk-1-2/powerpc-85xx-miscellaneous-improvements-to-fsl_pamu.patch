From f245de909198bb426a18cf1a056285c8bbccaa47 Mon Sep 17 00:00:00 2001
From: Timur Tabi <timur@freescale.com>
Date: Thu, 9 Feb 2012 15:13:41 -0600
Subject: [PATCH 019/128] powerpc/85xx: miscellaneous improvements to
 fsl_pamu.c

A collection of miscellaneous improvements to the Freescale PAMU driver.

1) Merge the contents of fsl_pamu.h into fsl_pamu.c and delete fsl_pamu.h,
   since no one else uses that header file.

2) Update and fix the copyright and license text

3) Add and remove some #included header files

4) Use the ccsr_guts_85xx structure to access PAMUBYPENR, instead of an
   offset from a void pointer.

5) Delete the L1, L2, and L3 macros, since they're superfluous.  Use regular
   numbers instead.

6) Use pr_xxx and dev_xxx macros instead of printk().  Improve the printed
   text in some cases.  Remove some superfluous messages.

7) Make all functions 'static'.

8) Fix miscellaneous spacing problems.

9) Use pointers instead of unsigned longs where appropriate.  It's still not
   perfect, but definitely improved.

10) Use upper_32_bits() and lower_32_bits() where appropriate.

11) Add a return value to the interrupt handler, for correctness.

12) Rename 'dev' to 'pdev', since it's a platform_device.

13) Rename fsl_of_pamu_probe to fsl_pamu_probe, since we don't have OF
    probe functions any more.

14) Improve error handling in fsl_pamu_probe().

Signed-off-by: Timur Tabi <timur@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image. Replace struct
ccsr_guts_85xx with ccsr_guts.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/sysdev/fsl_pamu.c |  576 ++++++++++++++++++++++++++++++++--------
 arch/powerpc/sysdev/fsl_pamu.h |  382 --------------------------
 2 files changed, 461 insertions(+), 497 deletions(-)
 delete mode 100644 arch/powerpc/sysdev/fsl_pamu.h

diff --git a/arch/powerpc/sysdev/fsl_pamu.c b/arch/powerpc/sysdev/fsl_pamu.c
index eab0cb1..270f6ac 100644
--- a/arch/powerpc/sysdev/fsl_pamu.c
+++ b/arch/powerpc/sysdev/fsl_pamu.c
@@ -1,4 +1,4 @@
-/* Copyright (c) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (c) 2008-2012 Freescale Semiconductor, Inc.
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -18,7 +18,7 @@
  * Foundation, either version 2 of that License or (at your option) any
  * later version.
  *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor "AS IS" AND ANY
  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
@@ -31,19 +31,351 @@
  */
 
 #include <linux/init.h>
-#include <linux/module.h>
 #include <linux/types.h>
+#include <linux/slab.h>
 #include <linux/mm.h>
 #include <linux/interrupt.h>
 #include <linux/device.h>
 #include <linux/of_platform.h>
-#include <linux/bootmem.h>
-#include <asm/io.h>
-#include <asm/bitops.h>
-
-#include "fsl_pamu.h"
+#include <linux/io.h>
+#include <asm/fsl_guts.h>
+
+/* PAMU CCSR space */
+#define PAMU_PGC 0x00000000     /* Allows all peripheral accesses */
+#define PAMU_PE 0x40000000      /* enable PAMU                    */
+
+/* PAMU_OFFSET to the next pamu space in ccsr */
+#define PAMU_OFFSET 0x1000
+
+#define PAMU_MMAP_REGS_BASE 0
+
+struct pamu_mmap_regs {
+	u32 ppbah;
+	u32 ppbal;
+	u32 pplah;
+	u32 pplal;
+	u32 spbah;
+	u32 spbal;
+	u32 splah;
+	u32 splal;
+	u32 obah;
+	u32 obal;
+	u32 olah;
+	u32 olal;
+};
 
-#define PAMUBYPENR 0x604
+/* PAMU Error Registers */
+#define PAMU_POES1	0x0040
+#define PAMU_POES2	0x0044
+#define PAMU_POEAH	0x0048
+#define PAMU_POEAL	0x004C
+#define PAMU_AVS1	0x0050
+#define PAMU_AVS1_AV	0x1
+#define PAMU_AVS1_OTV	0x6
+#define PAMU_AVS1_APV	0x78
+#define PAMU_AVS1_WAV	0x380
+#define PAMU_AVS1_LAV	0x1c00
+#define PAMU_AVS1_GCV	0x2000
+#define PAMU_AVS1_PDV	0x4000
+#define PAMU_AV_MASK	(PAMU_AVS1_AV | PAMU_AVS1_OTV | PAMU_AVS1_APV | \
+			 PAMU_AVS1_WAV | PAMU_AVS1_LAV | PAMU_AVS1_GCV | \
+			 PAMU_AVS1_PDV)
+#define PAMU_AVS1_LIODN_SHIFT 16
+#define PAMU_LAV_LIODN_NOT_IN_PPAACT 0x400
+
+#define PAMU_AVS2	0x0054
+#define PAMU_AVAH	0x0058
+#define PAMU_AVAL	0x005C
+#define PAMU_EECTL	0x0060
+#define PAMU_EEDIS	0x0064
+#define PAMU_EEINTEN	0x0068
+#define PAMU_EEDET	0x006C
+#define PAMU_EEATTR	0x0070
+#define PAMU_EEAHI	0x0074
+#define PAMU_EEALO	0x0078
+#define PAMU_EEDHI	0X007C
+#define PAMU_EEDLO	0x0080
+#define PAMU_EECC	0x0084
+
+/* PAMU Revision Registers */
+#define PAMU_PR1	0x0BF8
+#define PAMU_PR2	0x0BFC
+
+/* PAMU Capabilities Registers */
+#define PAMU_PC1	0x0C00
+#define PAMU_PC2	0x0C04
+#define PAMU_PC3	0x0C08
+#define PAMU_PC4	0x0C0C
+
+/* PAMU Control Register */
+#define PAMU_PC		0x0C10
+
+/* PAMU control defs */
+#define PAMU_CONTROL	0x0C10
+#define PAMU_PC_PGC	0x80000000 /* 1 = PAMU Gate Closed : block all
+peripheral access, 0 : may allow peripheral access */
+
+#define PAMU_PC_PE	0x40000000 /* 0 = PAMU disabled, 1 = PAMU enabled */
+#define PAMU_PC_SPCC	0x00000010 /* sPAACE cache enable */
+#define PAMU_PC_PPCC	0x00000001 /* pPAACE cache enable */
+#define PAMU_PC_OCE	0x00001000 /* OMT cache enable */
+
+#define PAMU_PFA1	0x0C14
+#define PAMU_PFA2	0x0C18
+
+/* PAMU Interrupt control and Status Register */
+#define PAMU_PICS			0x0C1C
+#define PAMU_ACCESS_VIOLATION_STAT	0x8
+#define PAMU_ACCESS_VIOLATION_ENABLE	0x4
+
+/* PAMU Debug Registers */
+#define PAMU_PD1	0x0F00
+#define PAMU_PD2	0x0F04
+#define PAMU_PD3	0x0F08
+#define PAMU_PD4	0x0F0C
+
+#define PAACE_AP_PERMS_DENIED	0x0
+#define PAACE_AP_PERMS_QUERY	0x1
+#define PAACE_AP_PERMS_UPDATE	0x2
+#define PAACE_AP_PERMS_ALL	0x3
+#define PAACE_DD_TO_HOST	0x0
+#define PAACE_DD_TO_IO		0x1
+#define PAACE_PT_PRIMARY	0x0
+#define PAACE_PT_SECONDARY	0x1
+#define PAACE_V_INVALID		0x0
+#define PAACE_V_VALID		0x1
+#define PAACE_MW_SUBWINDOWS	0x1
+
+#define PAACE_WSE_4K		0xB
+#define PAACE_WSE_8K		0xC
+#define PAACE_WSE_16K		0xD
+#define PAACE_WSE_32K		0xE
+#define PAACE_WSE_64K		0xF
+#define PAACE_WSE_128K		0x10
+#define PAACE_WSE_256K		0x11
+#define PAACE_WSE_512K		0x12
+#define PAACE_WSE_1M		0x13
+#define PAACE_WSE_2M		0x14
+#define PAACE_WSE_4M		0x15
+#define PAACE_WSE_8M		0x16
+#define PAACE_WSE_16M		0x17
+#define PAACE_WSE_32M		0x18
+#define PAACE_WSE_64M		0x19
+#define PAACE_WSE_128M		0x1A
+#define PAACE_WSE_256M		0x1B
+#define PAACE_WSE_512M		0x1C
+#define PAACE_WSE_1G		0x1D
+#define PAACE_WSE_2G		0x1E
+#define PAACE_WSE_4G		0x1F
+
+#define PAACE_DID_PCI_EXPRESS_1	0x00
+#define PAACE_DID_PCI_EXPRESS_2	0x01
+#define PAACE_DID_PCI_EXPRESS_3	0x02
+#define PAACE_DID_PCI_EXPRESS_4	0x03
+#define PAACE_DID_LOCAL_BUS	0x04
+#define PAACE_DID_SRIO		0x0C
+#define PAACE_DID_MEM_1		0x10
+#define PAACE_DID_MEM_2		0x11
+#define PAACE_DID_MEM_3		0x12
+#define PAACE_DID_MEM_4		0x13
+#define PAACE_DID_MEM_1_2	0x14
+#define PAACE_DID_MEM_3_4	0x15
+#define PAACE_DID_MEM_1_4	0x16
+#define PAACE_DID_BM_SW_PORTAL	0x18
+#define PAACE_DID_PAMU		0x1C
+#define PAACE_DID_CAAM		0x21
+#define PAACE_DID_QM_SW_PORTAL	0x3C
+#define PAACE_DID_CORE0_INST	0x80
+#define PAACE_DID_CORE0_DATA	0x81
+#define PAACE_DID_CORE1_INST	0x82
+#define PAACE_DID_CORE1_DATA	0x83
+#define PAACE_DID_CORE2_INST	0x84
+#define PAACE_DID_CORE2_DATA	0x85
+#define PAACE_DID_CORE3_INST	0x86
+#define PAACE_DID_CORE3_DATA	0x87
+#define PAACE_DID_CORE4_INST	0x88
+#define PAACE_DID_CORE4_DATA	0x89
+#define PAACE_DID_CORE5_INST	0x8A
+#define PAACE_DID_CORE5_DATA	0x8B
+#define PAACE_DID_CORE6_INST	0x8C
+#define PAACE_DID_CORE6_DATA	0x8D
+#define PAACE_DID_CORE7_INST	0x8E
+#define PAACE_DID_CORE7_DATA	0x8F
+#define PAACE_DID_BROADCAST	0xFF
+
+#define PAACE_ATM_NO_XLATE	0x00
+#define PAACE_ATM_WINDOW_XLATE	0x01
+#define PAACE_ATM_PAGE_XLATE	0x02
+#define PAACE_ATM_WIN_PG_XLATE	(PAACE_ATM_WINDOW_XLATE | PAACE_ATM_PAGE_XLATE)
+#define PAACE_OTM_NO_XLATE	0x00
+#define PAACE_OTM_IMMEDIATE	0x01
+#define PAACE_OTM_INDEXED	0x02
+#define PAACE_OTM_RESERVED	0x03
+
+#define PAACE_M_COHERENCE_REQ	0x01
+
+#define PAACE_TCEF_FORMAT0_8B	0x00
+#define PAACE_TCEF_FORMAT1_RSVD	0x01
+
+#define PAACE_NUMBER_ENTRIES	0xFF
+
+#define OME_NUMBER_ENTRIES	16   /* based on P4080 2.0 silicon plan */
+
+/* PAMU Data Structures */
+
+struct ppaace {
+	/* PAACE Offset 0x00 */
+	/* Window Base Address */
+	u32		wbah;
+	unsigned int	wbal:20;
+	/* Window Size, 2^(N+1), N must be > 10 */
+	unsigned int	wse:6;
+	/* 1 Means there are secondary windows, wce is count */
+	unsigned int	mw:1;
+	/* Permissions, see PAACE_AP_PERMS_* defines */
+	unsigned int	ap:2;
+	/*
+	 * Destination Domain, see PAACE_DD_* defines,
+	 * defines data structure reference for ingress ops into
+	 * host/coherency domain or ingress ops into I/O domain
+	 */
+	unsigned int	dd:1;
+	/* PAACE Type, see PAACE_PT_* defines */
+	unsigned int	pt:1;
+	/* PAACE Valid, 0 is invalid */
+	unsigned int	v:1;
+
+	/* PAACE Offset 0x08 */
+	/* Interpretation of first 32 bits dependent on DD above */
+	union {
+		struct {
+			/* Destination ID, see PAACE_DID_* defines */
+			u8 did;
+			/* Partition ID */
+			u8 pid;
+			/* Snoop ID */
+			u8 snpid;
+			unsigned int coherency_required:1;
+			unsigned int reserved:7;
+		} to_host;
+		struct {
+			/* Destination ID, see PAACE_DID_* defines */
+			u8 did;
+			unsigned int __reserved:24;
+		} to_io;
+	} __packed domain_attr;
+	/* Implementation attributes */
+	struct {
+		unsigned int reserved1:8;
+		unsigned int cid:8;
+		unsigned int reserved2:8;
+	} __packed impl_attr;
+	/* Window Count; 2^(N+1) sub-windows; only valid for primary PAACE */
+	unsigned int wce:4;
+	/* Address translation mode, see PAACE_ATM_* defines */
+	unsigned int atm:2;
+	/* Operation translation mode, see PAACE_OTM_* defines */
+	unsigned int otm:2;
+
+	/* PAACE Offset 0x10 */
+	/* Translated window base address */
+	u32 twbah;
+	unsigned int twbal:20;
+	/* Subwindow size encoding; 2^(N+1), N > 10 */
+	unsigned int swse:6;
+	unsigned int reserved4:6;
+
+	/* PAACE Offset 0x18 */
+	u32 fspi;
+	union {
+		struct {
+			u8 ioea;
+			u8 moea;
+			u8 ioeb;
+			u8 moeb;
+		} immed_ot;
+		struct {
+			u16 reserved;
+			u16 omi;
+		} index_ot;
+	} __packed op_encode;
+
+	/* PAACE Offset 0x20 */
+	u32 sbah;
+	unsigned int sbal:20;
+	unsigned int sse:6;
+	unsigned int reserved5:6;
+
+	/* PAACE Offset 0x28 */
+	u32 tctbah;
+	unsigned int tctbal:20;
+	unsigned int pse:6;
+	unsigned int tcef:1;
+	unsigned int reserved6:5;
+
+	/* PAACE Offset 0x30 */
+	u32 reserved7[2];
+
+	/* PAACE Offset 0x38 */
+	u32 reserved8[2];
+} __packed ppaace;
+
+/* MOE : Mapped Operation Encodings */
+#define NUM_MOE 128
+struct ome {
+	u8 moe[NUM_MOE];
+} __packed ome;
+
+#define PAACT_SIZE              (sizeof(struct ppaace) * PAACE_NUMBER_ENTRIES)
+#define OMT_SIZE                (sizeof(struct ome) * OME_NUMBER_ENTRIES)
+
+#define IOE_READ        0x00
+#define IOE_READ_IDX    0x00
+#define IOE_WRITE       0x81
+#define IOE_WRITE_IDX   0x01
+#define IOE_EREAD0      0x82    /* Enhanced read type 0 */
+#define IOE_EREAD0_IDX  0x02    /* Enhanced read type 0 */
+#define IOE_EWRITE0     0x83    /* Enhanced write type 0 */
+#define IOE_EWRITE0_IDX 0x03    /* Enhanced write type 0 */
+#define IOE_DIRECT0     0x84    /* Directive type 0 */
+#define IOE_DIRECT0_IDX 0x04    /* Directive type 0 */
+#define IOE_EREAD1      0x85    /* Enhanced read type 1 */
+#define IOE_EREAD1_IDX  0x05    /* Enhanced read type 1 */
+#define IOE_EWRITE1     0x86    /* Enhanced write type 1 */
+#define IOE_EWRITE1_IDX 0x06    /* Enhanced write type 1 */
+#define IOE_DIRECT1     0x87    /* Directive type 1 */
+#define IOE_DIRECT1_IDX 0x07    /* Directive type 1 */
+#define IOE_RAC         0x8c    /* Read with Atomic clear */
+#define IOE_RAC_IDX     0x0c    /* Read with Atomic clear */
+#define IOE_RAS         0x8d    /* Read with Atomic set */
+#define IOE_RAS_IDX     0x0d    /* Read with Atomic set */
+#define IOE_RAD         0x8e    /* Read with Atomic decrement */
+#define IOE_RAD_IDX     0x0e    /* Read with Atomic decrement */
+#define IOE_RAI         0x8f    /* Read with Atomic increment */
+#define IOE_RAI_IDX     0x0f    /* Read with Atomic increment */
+
+#define EOE_READ        0x00
+#define EOE_WRITE       0x01
+#define EOE_RAC         0x0c    /* Read with Atomic clear */
+#define EOE_RAS         0x0d    /* Read with Atomic set */
+#define EOE_RAD         0x0e    /* Read with Atomic decrement */
+#define EOE_RAI         0x0f    /* Read with Atomic increment */
+#define EOE_LDEC        0x10    /* Load external cache */
+#define EOE_LDECL       0x11    /* Load external cache with stash lock */
+#define EOE_LDECPE      0x12    /* Load ext. cache with preferred exclusive */
+#define EOE_LDECPEL     0x13    /* Load ext. cache w/ preferred excl. & lock */
+#define EOE_LDECFE      0x14    /* Load external cache with forced exclusive */
+#define EOE_LDECFEL     0x15    /* Load ext. cache w/ forced excl. & lock */
+#define EOE_RSA         0x16    /* Read with stash allocate */
+#define EOE_RSAU        0x17    /* Read with stash allocate and unlock */
+#define EOE_READI       0x18    /* Read with invalidate */
+#define EOE_RWNITC      0x19    /* Read with no intention to cache */
+#define EOE_WCI         0x1a    /* Write cache inhibited */
+#define EOE_WWSA        0x1b    /* Write with stash allocate */
+#define EOE_WWSAL       0x1c    /* Write with stash allocate and lock */
+#define EOE_WWSAO       0x1d    /* Write with stash allocate only */
+#define EOE_WWSAOL      0x1e    /* Write with stash allocate only and lock */
+#define EOE_VALID       0x80
 
 /* define indexes for each operation mapping scenario */
 #define OMI_QMAN        0x00
@@ -51,7 +383,7 @@
 #define OMI_QMAN_PRIV   0x02
 #define OMI_CAAM        0x03
 
-void setup_omt(struct ome *omt)
+static void setup_omt(struct ome *omt)
 {
 	struct ome *ome;
 
@@ -97,24 +429,22 @@ void setup_omt(struct ome *omt)
 	ome->moe[IOE_WRITE_IDX] = EOE_VALID | EOE_WRITE;
 }
 
-#define L1 1
-#define L2 2
-#define L3 3
-
-u32 get_stash_id(u32 stash_dest_hint, struct device_node *portal_dn)
+static u32 get_stash_id(unsigned int stash_dest_hint,
+	struct device_node *portal_dn)
 {
 	const u32 *prop;
 	struct device_node *node;
-	u32 cache_level;
+	unsigned int cache_level;
 
-	/* Fastpath, exit early if L3/CPC cache is target for stashing */
-	if (stash_dest_hint == L3) {
+	/* Fastpath, exit early if 3/CPC cache is target for stashing */
+	if (stash_dest_hint == 3) {
 		node = of_find_compatible_node(NULL, NULL,
 				"fsl,p4080-l3-cache-controller");
 		if (node) {
 			prop = of_get_property(node, "cache-stash-id", 0);
 			if (!prop) {
-				printk(KERN_ERR "missing cache-stash-id at %s\n", node->full_name);
+				pr_err("fsl-pamu: missing cache-stash-id in "
+				       " %s\n", node->full_name);
 				of_node_put(node);
 				return ~(u32)0;
 			}
@@ -131,28 +461,28 @@ u32 get_stash_id(u32 stash_dest_hint, struct device_node *portal_dn)
 
 	node = of_find_node_by_phandle(*prop);
 	if (!node) {
-		printk(KERN_ERR "bad cpu phandle reference in %s\n",
+		pr_err("fsl-pamu: bad cpu-handle reference in %s\n",
 				 portal_dn->full_name);
 		return ~(u32)0;
 	}
 
 	/* find the hwnode that represents the cache */
-	for (cache_level = L1; cache_level <= L3; cache_level++) {
+	for (cache_level = 1; cache_level <= 3; cache_level++) {
 		if (stash_dest_hint == cache_level) {
 			prop = of_get_property(node, "cache-stash-id", 0);
+			of_node_put(node);
 			if (!prop) {
-				printk(KERN_ERR "missing cache-stash-id at %s\n", node->full_name);
-				of_node_put(node);
+				pr_err("fsl-pamu: missing cache-stash-id in "
+				       "%s\n", node->full_name);
 				return ~(u32)0;
 			}
-			of_node_put(node);
 			return *prop;
 		}
 
 		prop = of_get_property(node, "next-level-cache", 0);
 		if (!prop) {
-			printk(KERN_ERR "can't find next-level-cache at %s\n",
-			          node->full_name);
+			pr_err("fsl-pamu: can't find next-level-cache in %s\n",
+			       node->full_name);
 			of_node_put(node);
 			return ~(u32)0;  /* can't traverse any further */
 		}
@@ -161,18 +491,19 @@ u32 get_stash_id(u32 stash_dest_hint, struct device_node *portal_dn)
 		/* advance to next node in cache hierarchy */
 		node = of_find_node_by_phandle(*prop);
 		if (!node) {
-			printk(KERN_ERR "bad cpu phandle reference in %s\n",
-			          portal_dn->full_name);
+			pr_err("fsl-pamu: bad cpu phandle reference in %s\n",
+			       portal_dn->full_name);
 			return ~(u32)0;
 		}
 	}
 
-	printk(KERN_ERR "stash dest not found for %d on %s\n",
-	          stash_dest_hint, portal_dn->full_name);
+	pr_err("fsl-pamu: stash destination not found for cache level %d "
+	       "on portal node %s\n", stash_dest_hint, portal_dn->full_name);
+
 	return ~(u32)0;
 }
 
-void setup_liodns(struct ppaace *ppaact)
+static void setup_liodns(struct ppaace *ppaact)
 {
 	int i, len;
 	struct ppaace *ppaace;
@@ -202,9 +533,8 @@ void setup_liodns(struct ppaace *ppaact)
 	 */
 
 	for_each_compatible_node(qman_portal_dn, NULL, "fsl,qman-portal") {
+		pr_debug("qman portal %s found\n", qman_portal_dn->full_name);
 
-		pr_debug("qman portal found, name = %s\n",
-					qman_portal_dn->full_name);
 		prop = of_get_property(qman_portal_dn, "fsl,liodn", &len);
 		if (prop) {
 			prop_cnt = len / sizeof(u32);
@@ -213,14 +543,14 @@ void setup_liodns(struct ppaace *ppaact)
 				ppaace = &ppaact[*prop++];
 				ppaace->otm = PAACE_OTM_INDEXED;
 				ppaace->op_encode.index_ot.omi = OMI_QMAN;
-				cache_id = get_stash_id(L1, qman_portal_dn);
+				cache_id = get_stash_id(1, qman_portal_dn);
 				pr_debug("cache_stash_id = %d\n", cache_id);
 				if (~cache_id != 0)
 					ppaace->impl_attr.cid = cache_id;
-			} while(--prop_cnt);
+			} while (--prop_cnt);
 		} else {
-			printk (KERN_ERR "missing fsl,liodn property at %s\n",
-			          qman_portal_dn->full_name);
+			pr_err("fsl-pamu: missing fsl,liodn property in %s\n",
+			       qman_portal_dn->full_name);
 		}
 	}
 
@@ -235,44 +565,42 @@ void setup_liodns(struct ppaace *ppaact)
 			ppaace = &ppaact[*prop];
 			ppaace->otm = PAACE_OTM_INDEXED;
 			ppaace->op_encode.index_ot.omi = OMI_QMAN_PRIV;
-			cache_id = get_stash_id(L3, qman_dn);
+			cache_id = get_stash_id(3, qman_dn);
 			pr_debug("cache_stash_id = %d\n", cache_id);
 			if (~cache_id != 0)
 				ppaace->impl_attr.cid = cache_id;
 		} else {
-			printk (KERN_ERR "missing fsl,liodn property at %s\n",
-			          qman_dn->full_name);
+			pr_err("fsl-pamu: missing fsl,liodn property in %s\n",
+			       qman_dn->full_name);
 		}
 		of_node_put(qman_dn);
 	}
 }
 
-int setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu_reg_size,
-			struct ppaace *ppaact, struct ome *omt)
+static int setup_one_pamu(void *pamu_reg_base, struct ppaace *ppaact,
+	struct ome *omt)
 {
-	u32 *pc;
+	struct pamu_mmap_regs *pamu_regs = pamu_reg_base + PAMU_MMAP_REGS_BASE;
 	phys_addr_t phys;
-	struct pamu_mmap_regs *pamu_regs;
-
-	pc = (u32 *) (pamu_reg_base + PAMU_PC);
-	pamu_regs = (struct pamu_mmap_regs *) 
-		(pamu_reg_base + PAMU_MMAP_REGS_BASE);
 
 	/* set up pointers to corenet control blocks */
 
 	phys = virt_to_phys(ppaact);
-	out_be32(&pamu_regs->ppbah, ((u64)phys) >> 32);
-	out_be32(&pamu_regs->ppbal, phys);
+	out_be32(&pamu_regs->ppbah, upper_32_bits(phys));
+	out_be32(&pamu_regs->ppbal, lower_32_bits(phys));
+
 	phys = virt_to_phys(ppaact + PAACE_NUMBER_ENTRIES);
-	out_be32(&pamu_regs->pplah, ((u64)phys) >> 32);
-	out_be32(&pamu_regs->pplal, phys);
+	out_be32(&pamu_regs->pplah, upper_32_bits(phys));
+	out_be32(&pamu_regs->pplal, lower_32_bits(phys));
 
 	phys = virt_to_phys(omt);
-	out_be32(&pamu_regs->obah, ((u64)phys) >> 32);
-	out_be32(&pamu_regs->obal, phys);
+	out_be32(&pamu_regs->obah, upper_32_bits(phys));
+	out_be32(&pamu_regs->obal, lower_32_bits(phys));
+
 	phys = virt_to_phys(omt + OME_NUMBER_ENTRIES);
-	out_be32(&pamu_regs->olah, ((u64)phys) >> 32);
-	out_be32(&pamu_regs->olal, phys);
+	out_be32(&pamu_regs->olah, upper_32_bits(phys));
+	out_be32(&pamu_regs->olal, lower_32_bits(phys));
+
 
 	/*
 	 * set PAMU enable bit,
@@ -280,31 +608,34 @@ int setup_one_pamu(unsigned long pamu_reg_base, unsigned long pamu_reg_size,
 	 * & enable PAMU access violation interrupts.
 	 */
 
-	out_be32((u32 *)(pamu_reg_base + PAMU_PICS),
-			PAMU_ACCESS_VIOLATION_ENABLE);
-	out_be32(pc, PAMU_PC_PE | PAMU_PC_OCE | PAMU_PC_SPCC | PAMU_PC_PPCC);
+	out_be32(pamu_reg_base + PAMU_PICS, PAMU_ACCESS_VIOLATION_ENABLE);
+	out_be32(pamu_reg_base + PAMU_PC,
+		 PAMU_PC_PE | PAMU_PC_OCE | PAMU_PC_SPCC | PAMU_PC_PPCC);
+
 	return 0;
 }
 
-irqreturn_t pamu_av_isr(int irq, void *arg)
+static irqreturn_t pamu_av_isr(int irq, void *arg)
 {
-	panic("FSL_PAMU: access violation interrupt\n");
-	/* NOTREACHED */
+	panic("fsl-pamu: access violation interrupt\n");
+
+	/* NOT REACHED */
+	return IRQ_HANDLED;
 }
 
-static int __devinit fsl_of_pamu_probe(struct platform_device *dev)
+static int __devinit fsl_pamu_probe(struct platform_device *pdev)
 {
-	void __iomem *pamu_regs, *guts_regs;
+	void __iomem *pamu_regs = NULL;
+	struct ccsr_guts __iomem *guts_regs = NULL;
 	u32 pamubypenr, pamu_counter;
-	unsigned long pamu_reg_base, pamu_reg_off;
+	unsigned long pamu_reg_off;
 	struct device_node *guts_node;
 	u64 size;
+	struct page *p;
+	int ret = 0;
 	struct ppaace *ppaact = NULL;
 	struct ome *omt = NULL;
 	int irq;
-	struct page *p;
-
-	printk(KERN_INFO "Setting Freescale static PAMU/IOMMU configuration\n");
 
 	/*
 	 * enumerate all PAMUs and allocate and setup PAMU tables
@@ -312,64 +643,70 @@ static int __devinit fsl_of_pamu_probe(struct platform_device *dev)
 	 * NOTE : All PAMUs share the same LIODN tables.
 	 */
 
-	pamu_regs = of_iomap(dev->dev.of_node, 0);
+	pamu_regs = of_iomap(pdev->dev.of_node, 0);
 	if (!pamu_regs) {
-		dev_err(&dev->dev, "ioremap failed\n");
+		dev_err(&pdev->dev, "ioremap of PAMU node failed\n");
 		return -ENOMEM;
 	}
-	of_get_address(dev->dev.of_node, 0, &size, NULL);
+	of_get_address(pdev->dev.of_node, 0, &size, NULL);
+
+	irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (irq == NO_IRQ) {
+		dev_warn(&pdev->dev, "no interrupts listed in PAMU node\n");
+		goto error;
+	}
+
+	ret = request_irq(irq, pamu_av_isr, 0, "pamu", 0);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "error %i installing ISR for irq %i\n",
+			ret, irq);
+		goto error;
+	}
 
 	guts_node = of_find_compatible_node(NULL, NULL,
 			"fsl,qoriq-device-config-1.0");
 	if (!guts_node) {
-		dev_err(&dev->dev, "%s guts devnode not found!\n",
-				dev->dev.of_node->full_name);
-		iounmap(pamu_regs);
-		return -ENODEV;
+		dev_err(&pdev->dev, "could not find GUTS node %s\n",
+			pdev->dev.of_node->full_name);
+		ret = -ENODEV;
+		goto error;
 	}
 
 	guts_regs = of_iomap(guts_node, 0);
+	of_node_put(guts_node);
 	if (!guts_regs) {
-		dev_err(&dev->dev, "guts ioremap failed\n");
-		iounmap(pamu_regs);
-		return -ENOMEM;
+		dev_err(&pdev->dev, "ioremap of GUTS node failed\n");
+		ret = -ENODEV;
+		goto error;
 	}
-	of_node_put(guts_node);
 
-	p = alloc_pages(GFP_KERNEL, get_order(PAACT_SIZE));
+	p = alloc_pages(GFP_KERNEL | __GFP_ZERO, get_order(PAACT_SIZE));
 	if (!p) {
-		printk(KERN_ERR "Unable to allocate space for PAACT table\n");
-		iounmap(pamu_regs);
-		iounmap(guts_regs);
-		return -ENOMEM;
+		dev_err(&pdev->dev, "unable to allocate PAACT table\n");
+		ret = -ENOMEM;
+		goto error;
 	}
 	ppaact = page_address(p);
-	memset(ppaact, 0, PAACT_SIZE);
 
-	pr_debug("fsl_pamu, paact_mem, v : %p, p : 0x%lx\n",
-			ppaact, virt_to_phys(ppaact));
+	dev_dbg(&pdev->dev, "ppaact virt=%p phys=0x%llx\n", ppaact,
+		(unsigned long long) page_to_phys(p));
 
-	p = alloc_pages(GFP_KERNEL, get_order(OMT_SIZE));
+	p = alloc_pages(GFP_KERNEL | __GFP_ZERO, get_order(OMT_SIZE));
 	if (!p) {
-		printk(KERN_ERR "Unable to allocate space for OMT table\n");
-		iounmap(pamu_regs);
-		iounmap(guts_regs);
-		free_pages((unsigned long)ppaact, get_order(PAACT_SIZE));
-		return -ENOMEM;
+		dev_err(&pdev->dev, "unable to allocate OMT table\n");
+		ret = -ENOMEM;
+		goto error;
 	}
 	omt = page_address(p);
-	memset(omt, 0, OMT_SIZE);
 
-	pr_debug("fsl_pamu, omt_mem, v : %p, p : 0x%lx\n", 
-			omt, virt_to_phys(omt));
+	dev_dbg(&pdev->dev, "omt virt=%p phys=0x%llx\n", omt,
+		(unsigned long long) page_to_phys(p));
 
-	pamubypenr = in_be32(guts_regs + PAMUBYPENR);
+	pamubypenr = in_be32(&guts_regs->pamubypenr);
 
 	for (pamu_reg_off = 0, pamu_counter = 0x80000000; pamu_reg_off < size;
 	     pamu_reg_off += PAMU_OFFSET, pamu_counter >>= 1) {
-
-		pamu_reg_base = (unsigned long) pamu_regs + pamu_reg_off;
-		setup_one_pamu(pamu_reg_base, pamu_reg_off, ppaact, omt);
+		setup_one_pamu(pamu_regs + pamu_reg_off, ppaact, omt);
 
 		/* Disable PAMU bypass for this PAMU */
 		pamubypenr &= ~pamu_counter;
@@ -377,17 +714,7 @@ static int __devinit fsl_of_pamu_probe(struct platform_device *dev)
 
 	setup_omt(omt);
 
-	irq = irq_of_parse_and_map(dev->dev.of_node, 0);
-	if (request_irq(irq, pamu_av_isr, IRQF_DISABLED, "pamu", 0) < 0) {
-		printk(KERN_ERR "Cannot request PAMU AV interrupt\n");
-		iounmap(pamu_regs);
-		iounmap(guts_regs);
-		free_pages((unsigned long)ppaact, get_order(PAACT_SIZE));
-		free_pages((unsigned long)omt, get_order(OMT_SIZE));
-		return -ENODEV;
-	}
-
-	/* 
+	/*
 	 * setup all LIODNS(s) to define a 1:1 mapping for the entire
 	 * 36-bit physical address space
 	 */
@@ -395,9 +722,27 @@ static int __devinit fsl_of_pamu_probe(struct platform_device *dev)
 	mb();
 
 	/* Enable all relevant PAMU(s) */
-	out_be32(guts_regs + PAMUBYPENR, pamubypenr);
+	out_be32(&guts_regs->pamubypenr, pamubypenr);
+
+	iounmap(pamu_regs);
+	iounmap(guts_regs);
 
 	return 0;
+
+error:
+	if (irq != NO_IRQ)
+		free_irq(irq, 0);
+
+	if (pamu_regs)
+		iounmap(pamu_regs);
+
+	if (guts_regs)
+		iounmap(guts_regs);
+
+	free_pages((unsigned long)ppaact, get_order(PAACT_SIZE));
+	free_pages((unsigned long)omt, get_order(OMT_SIZE));
+
+	return ret;
 }
 
 static const struct of_device_id fsl_of_pamu_ids[] = {
@@ -413,14 +758,15 @@ static const struct of_device_id fsl_of_pamu_ids[] = {
 static struct platform_driver fsl_of_pamu_driver = {
 	.driver = {
 		.name = "fsl-of-pamu",
+		.owner = THIS_MODULE,
 		.of_match_table = fsl_of_pamu_ids,
 	},
-	.probe = fsl_of_pamu_probe,
+	.probe = fsl_pamu_probe,
 };
 
-static __init int fsl_of_pamu_init(void)
+static __init int fsl_pamu_init(void)
 {
 	return platform_driver_register(&fsl_of_pamu_driver);
 }
 
-arch_initcall(fsl_of_pamu_init);
+arch_initcall(fsl_pamu_init);
diff --git a/arch/powerpc/sysdev/fsl_pamu.h b/arch/powerpc/sysdev/fsl_pamu.h
deleted file mode 100644
index 9e5f2a3..0000000
--- a/arch/powerpc/sysdev/fsl_pamu.h
+++ /dev/null
@@ -1,382 +0,0 @@
-/* Copyright (c) 2008-2010 Freescale Semiconductor, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __PAMU_H
-#define __PAMU_H
-
-/* PAMU CCSR space */
-#define PAMU_PGC 0x00000000     /* Allows all peripheral accesses */
-#define PAMU_PE 0x40000000      /* enable PAMU                    */
-
-/* PAMU_OFFSET to the next pamu space in ccsr */
-#define PAMU_OFFSET 0x1000	
-
-#define PAMU_MMAP_REGS_BASE 0
-
-struct pamu_mmap_regs {
-	u32 ppbah;
-	u32 ppbal;
-	u32 pplah;
-	u32 pplal;
-	u32 spbah;
-	u32 spbal;
-	u32 splah;
-	u32 splal;
-	u32 obah;
-	u32 obal;
-	u32 olah;
-	u32 olal;
-};
-
-/* PAMU Error Registers */
-#define PAMU_POES1 0x0040
-#define PAMU_POES2 0x0044
-#define PAMU_POEAH 0x0048
-#define PAMU_POEAL 0x004C
-#define PAMU_AVS1  0x0050
-#define PAMU_AVS1_AV    0x1
-#define PAMU_AVS1_OTV   0x6
-#define PAMU_AVS1_APV   0x78
-#define PAMU_AVS1_WAV   0x380
-#define PAMU_AVS1_LAV   0x1c00
-#define PAMU_AVS1_GCV   0x2000
-#define PAMU_AVS1_PDV   0x4000
-#define PAMU_AV_MASK    (PAMU_AVS1_AV | PAMU_AVS1_OTV | PAMU_AVS1_APV | PAMU_AVS1_WAV \
-			| PAMU_AVS1_LAV | PAMU_AVS1_GCV | PAMU_AVS1_PDV)
-#define PAMU_AVS1_LIODN_SHIFT 16
-#define PAMU_LAV_LIODN_NOT_IN_PPAACT 0x400
-
-#define PAMU_AVS2  0x0054
-#define PAMU_AVAH  0x0058
-#define PAMU_AVAL  0x005C
-#define PAMU_EECTL 0x0060
-#define PAMU_EEDIS 0x0064
-#define PAMU_EEINTEN 0x0068
-#define PAMU_EEDET 0x006C
-#define PAMU_EEATTR 0x0070
-#define PAMU_EEAHI 0x0074
-#define PAMU_EEALO 0x0078
-#define PAMU_EEDHI 0X007C
-#define PAMU_EEDLO 0x0080
-#define PAMU_EECC  0x0084
-
-/* PAMU Revision Registers */
-#define PAMU_PR1 0x0BF8
-#define PAMU_PR2 0x0BFC
-
-/* PAMU Capabilities Registers */
-#define PAMU_PC1 0x0C00
-#define PAMU_PC2 0x0C04
-#define PAMU_PC3 0x0C08
-#define PAMU_PC4 0x0C0C
-
-/* PAMU Control Register */
-#define PAMU_PC 0x0C10
-
-/* PAMU control defs */
-#define PAMU_CONTROL 0x0C10
-#define PAMU_PC_PGC 0x80000000 /* 1 = PAMU Gate Closed : block all 
-peripheral access, 0 : may allow peripheral access */
-
-#define PAMU_PC_PE   0x40000000 /* 0 = PAMU disabled, 1 = PAMU enabled */   
-#define PAMU_PC_SPCC 0x00000010 /* sPAACE cache enable */
-#define PAMU_PC_PPCC 0x00000001 /* pPAACE cache enable */
-#define PAMU_PC_OCE  0x00001000 /* OMT cache enable */
-
-#define PAMU_PFA1 0x0C14
-#define PAMU_PFA2 0x0C18
-
-/* PAMU Interrupt control and Status Register */
-#define PAMU_PICS 0x0C1C
-#define PAMU_ACCESS_VIOLATION_STAT   0x8
-#define PAMU_ACCESS_VIOLATION_ENABLE 0x4
-
-/* PAMU Debug Registers */
-#define PAMU_PD1 0x0F00
-#define PAMU_PD2 0x0F04
-#define PAMU_PD3 0x0F08
-#define PAMU_PD4 0x0F0C
-
-#define PAACE_AP_PERMS_DENIED  0x0
-#define PAACE_AP_PERMS_QUERY   0x1
-#define PAACE_AP_PERMS_UPDATE  0x2
-#define PAACE_AP_PERMS_ALL     0x3
-#define PAACE_DD_TO_HOST       0x0
-#define PAACE_DD_TO_IO         0x1
-#define PAACE_PT_PRIMARY       0x0
-#define PAACE_PT_SECONDARY     0x1
-#define PAACE_V_INVALID        0x0
-#define PAACE_V_VALID          0x1
-#define PAACE_MW_SUBWINDOWS    0x1
-
-#define PAACE_WSE_4K           0xB
-#define PAACE_WSE_8K           0xC
-#define PAACE_WSE_16K          0xD
-#define PAACE_WSE_32K          0xE
-#define PAACE_WSE_64K          0xF
-#define PAACE_WSE_128K         0x10
-#define PAACE_WSE_256K         0x11
-#define PAACE_WSE_512K         0x12
-#define PAACE_WSE_1M           0x13
-#define PAACE_WSE_2M           0x14
-#define PAACE_WSE_4M           0x15
-#define PAACE_WSE_8M           0x16
-#define PAACE_WSE_16M          0x17
-#define PAACE_WSE_32M          0x18
-#define PAACE_WSE_64M          0x19
-#define PAACE_WSE_128M         0x1A
-#define PAACE_WSE_256M         0x1B
-#define PAACE_WSE_512M         0x1C
-#define PAACE_WSE_1G           0x1D
-#define PAACE_WSE_2G           0x1E
-#define PAACE_WSE_4G           0x1F
-
-#define PAACE_DID_PCI_EXPRESS_1 0x00
-#define PAACE_DID_PCI_EXPRESS_2 0x01
-#define PAACE_DID_PCI_EXPRESS_3 0x02
-#define PAACE_DID_PCI_EXPRESS_4 0x03
-#define PAACE_DID_LOCAL_BUS     0x04
-#define PAACE_DID_SRIO          0x0C
-#define PAACE_DID_MEM_1         0x10
-#define PAACE_DID_MEM_2         0x11
-#define PAACE_DID_MEM_3         0x12
-#define PAACE_DID_MEM_4         0x13
-#define PAACE_DID_MEM_1_2       0x14
-#define PAACE_DID_MEM_3_4       0x15
-#define PAACE_DID_MEM_1_4       0x16
-#define PAACE_DID_BM_SW_PORTAL  0x18
-#define PAACE_DID_PAMU          0x1C
-#define PAACE_DID_CAAM          0x21
-#define PAACE_DID_QM_SW_PORTAL  0x3C
-#define PAACE_DID_CORE0_INST    0x80
-#define PAACE_DID_CORE0_DATA    0x81
-#define PAACE_DID_CORE1_INST    0x82
-#define PAACE_DID_CORE1_DATA    0x83
-#define PAACE_DID_CORE2_INST    0x84
-#define PAACE_DID_CORE2_DATA    0x85
-#define PAACE_DID_CORE3_INST    0x86
-#define PAACE_DID_CORE3_DATA    0x87
-#define PAACE_DID_CORE4_INST    0x88
-#define PAACE_DID_CORE4_DATA    0x89
-#define PAACE_DID_CORE5_INST    0x8A
-#define PAACE_DID_CORE5_DATA    0x8B
-#define PAACE_DID_CORE6_INST    0x8C
-#define PAACE_DID_CORE6_DATA    0x8D
-#define PAACE_DID_CORE7_INST    0x8E
-#define PAACE_DID_CORE7_DATA    0x8F
-#define PAACE_DID_BROADCAST     0xFF
-
-#define PAACE_ATM_NO_XLATE      0x00
-#define PAACE_ATM_WINDOW_XLATE  0x01
-#define PAACE_ATM_PAGE_XLATE    0x02
-#define PAACE_ATM_WIN_PG_XLATE  \
-                ( PAACE_ATM_WINDOW_XLATE | PAACE_ATM_PAGE_XLATE )
-#define PAACE_OTM_NO_XLATE      0x00
-#define PAACE_OTM_IMMEDIATE     0x01
-#define PAACE_OTM_INDEXED       0x02
-#define PAACE_OTM_RESERVED      0x03
-
-#define PAACE_M_COHERENCE_REQ   0x01
-
-#define PAACE_PID_0             0x0
-#define PAACE_PID_1             0x1
-#define PAACE_PID_2             0x2
-#define PAACE_PID_3             0x3
-#define PAACE_PID_4             0x4
-#define PAACE_PID_5             0x5
-#define PAACE_PID_6             0x6
-#define PAACE_PID_7             0x7
-
-#define PAACE_TCEF_FORMAT0_8B   0x00
-#define PAACE_TCEF_FORMAT1_RSVD 0x01
-
-#define PAACE_NUMBER_ENTRIES    0xFF
-
-#define	OME_NUMBER_ENTRIES      16   /* based on P4080 2.0 silicon plan */
-
-/* PAMU Data Structures */
-
-struct ppaace {
-	/* PAACE Offset 0x00 */
-	/* Window Base Address */
-	u32        wbah;
-	unsigned int    wbal : 20;
-	/* Window Size, 2^(N+1), N must be > 10 */
-	unsigned int    wse : 6;
-	/* 1 Means there are secondary windows, wce is count */
-	unsigned int    mw : 1;
-	/* Permissions, see PAACE_AP_PERMS_* defines */
-	unsigned int    ap : 2;
-	/* 
-	 * Destination Domain, see PAACE_DD_* defines,
-	 * defines data structure reference for ingress ops into 
-	 * host/coherency domain or ingress ops into I/O domain
-	 */
-	unsigned int    dd : 1;
-	/* PAACE Type, see PAACE_PT_* defines */
-	unsigned int    pt : 1;
-	/* PAACE Valid, 0 is invalid */
-	unsigned int    v : 1;
-
-	/* PAACE Offset 0x08 */
-	/* Interpretation of first 32 bits dependent on DD above */
-	union {
-		struct {
-			/* Destination ID, see PAACE_DID_* defines */
-			u8 did;  
-			/* Partition ID */
-			u8 pid;
-			/* Snoop ID */
-			u8 snpid;
-			unsigned int coherency_required : 1;
-			unsigned int reserved : 7;
-		} to_host;
-		struct {
-			/* Destination ID, see PAACE_DID_* defines */
-			u8 did;
-			unsigned int __reserved : 24;
-		} to_io;
-	} __attribute__ ((packed)) domain_attr;
-	/* Implementation attributes */
-	struct {
-		unsigned int reserved1 : 8;
-		unsigned int cid : 8;
-		unsigned int reserved2 : 8;
-	} __attribute__ ((packed)) impl_attr;
-	/* Window Count; 2^(N+1) sub-windows; only valid for primary PAACE */
-	unsigned int wce : 4;
-	/* Address translation mode, see PAACE_ATM_* defines */
-	unsigned int atm : 2;
-	/* Operation translation mode, see PAACE_OTM_* defines */
-	unsigned int otm : 2;
-
-	/* PAACE Offset 0x10 */
-	/* Translated window base address */
-	u32 twbah;
-	unsigned int twbal : 20;
-	/* Subwindow size encoding; 2^(N+1), N > 10 */
-	unsigned int swse : 6;
-	unsigned int reserved4 : 6;
-
-	/* PAACE Offset 0x18 */
-	u32 fspi;
-	union {
-		struct {
-			u8 ioea;
-			u8 moea;
-			u8 ioeb;
-			u8 moeb;
-		} immed_ot;
-		struct {
-			u16 reserved;
-			u16 omi;
-		} index_ot;
-	} __attribute__ ((packed)) op_encode;
-
-	/* PAACE Offset 0x20 */
-	u32 sbah;
-	unsigned int sbal : 20;
-	unsigned int sse : 6;
-	unsigned int reserved5 : 6;
-
-	/* PAACE Offset 0x28 */
-	u32 tctbah;
-	unsigned int tctbal : 20;
-	unsigned int pse : 6;
-	unsigned int tcef :1;
-	unsigned int reserved6 : 5;
-
-	/* PAACE Offset 0x30 */
-	u32 reserved7[2];
-
-	/* PAACE Offset 0x38 */
-	u32 reserved8[2];
-} __attribute__ ((packed)) ppaace;
-
-/* MOE : Mapped Operation Encodings */
-#define NUM_MOE 128
-struct ome {
-	u8 moe[NUM_MOE];
-} __attribute__((packed)) ome;
-
-#define PAACT_SIZE              (sizeof(struct ppaace) * PAACE_NUMBER_ENTRIES)
-#define OMT_SIZE                (sizeof(struct ome) * OME_NUMBER_ENTRIES)
-
-#define IOE_READ        0x00
-#define IOE_READ_IDX    0x00
-#define IOE_WRITE       0x81
-#define IOE_WRITE_IDX   0x01
-#define IOE_EREAD0      0x82    /* Enhanced read type 0 */
-#define IOE_EREAD0_IDX  0x02    /* Enhanced read type 0 */
-#define IOE_EWRITE0     0x83    /* Enhanced write type 0 */
-#define IOE_EWRITE0_IDX 0x03    /* Enhanced write type 0 */
-#define IOE_DIRECT0     0x84    /* Directive type 0 */
-#define IOE_DIRECT0_IDX 0x04    /* Directive type 0 */
-#define IOE_EREAD1      0x85    /* Enhanced read type 1 */
-#define IOE_EREAD1_IDX  0x05    /* Enhanced read type 1 */
-#define IOE_EWRITE1     0x86    /* Enhanced write type 1 */
-#define IOE_EWRITE1_IDX 0x06    /* Enhanced write type 1 */
-#define IOE_DIRECT1     0x87    /* Directive type 1 */
-#define IOE_DIRECT1_IDX 0x07    /* Directive type 1 */
-#define IOE_RAC         0x8c    /* Read with Atomic clear */
-#define IOE_RAC_IDX     0x0c    /* Read with Atomic clear */
-#define IOE_RAS         0x8d    /* Read with Atomic set */
-#define IOE_RAS_IDX     0x0d    /* Read with Atomic set */
-#define IOE_RAD         0x8e    /* Read with Atomic decrement */
-#define IOE_RAD_IDX     0x0e    /* Read with Atomic decrement */
-#define IOE_RAI         0x8f    /* Read with Atomic increment */
-#define IOE_RAI_IDX     0x0f    /* Read with Atomic increment */
-
-#define EOE_READ        0x00
-#define EOE_WRITE       0x01
-#define EOE_RAC         0x0c    /* Read with Atomic clear */
-#define EOE_RAS         0x0d    /* Read with Atomic set */
-#define EOE_RAD         0x0e    /* Read with Atomic decrement */
-#define EOE_RAI         0x0f    /* Read with Atomic increment */
-#define EOE_LDEC        0x10    /* Load external cache */
-#define EOE_LDECL       0x11    /* Load external cache with stash lock */
-#define EOE_LDECPE      0x12    /* Load external cache with preferred exclusive */
-#define EOE_LDECPEL     0x13    /* Load external cache with preferred exclusive and lock */
-#define EOE_LDECFE      0x14    /* Load external cache with forced exclusive */
-#define EOE_LDECFEL     0x15    /* Load external cache with forced exclusive and lock */
-#define EOE_RSA         0x16    /* Read with stash allocate */
-#define EOE_RSAU        0x17    /* Read with stash allocate and unlock */
-#define EOE_READI       0x18    /* Read with invalidate */
-#define EOE_RWNITC      0x19    /* Read with no intention to cache */
-#define EOE_WCI         0x1a    /* Write cache inhibited */
-#define EOE_WWSA        0x1b    /* Write with stash allocate */
-#define EOE_WWSAL       0x1c    /* Write with stash allocate and lock */
-#define EOE_WWSAO       0x1d    /* Write with stash allocate only */
-#define EOE_WWSAOL      0x1e    /* Write with stash allocate only and lock */
-#define EOE_VALID       0x80
-
-#endif  /* __PAMU_H */
-- 
1.7.9.7

