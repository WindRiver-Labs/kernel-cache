From 48ac8c557eafd3104eed79116b983a69b7f0751f Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Thu, 19 Apr 2012 00:20:29 +0000
Subject: [PATCH 099/121] qbman: bind global interrupt last in global init.

The previous change "qbman: delay CCSR-programming" had the side-effect
of binding the global error interrupts prior to CCSR-based setup, such
as QMan PFDR initialisation. This means that we would get an initial
"PFDR Enqueues Blocked Interrupt" due to their being no PFDRs.
Reordering the initialisation corrects this.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Acked-by: Haiying Wang <Haiying.Wang@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/bman_config.c |    4 ++--
 drivers/staging/fsl_qbman/qman_config.c |    8 ++++----
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index b800d68..19aac20 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -503,11 +503,11 @@ int bman_init_ccsr(struct device_node *node)
 		return 0;
 	if (node != bm_node)
 		return -EINVAL;
+	/* FBPR memory */
+	bm_set_memory(bm, fbpr_a, 0, fbpr_sz);
 	ret = __bind_irq();
 	if (ret)
 		return ret;
-	/* FBPR memory */
-	bm_set_memory(bm, fbpr_a, 0, fbpr_sz);
 	return 0;
 }
 
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index f8dc101..c8b2be1 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -749,14 +749,10 @@ static int __bind_irq(void)
 int qman_init_ccsr(struct device_node *node)
 {
 	int ret;
-	/* Initialise Error Interrupt Handler */
 	if (!qman_have_ccsr())
 		return 0;
 	if (node != qm_node)
 		return -EINVAL;
-	ret = __bind_irq();
-	if (ret)
-		return ret;
 	/* FQD memory */
 	qm_set_memory(qm, qm_memory_fqd, fqd_a, 1, 0, 0, fqd_sz);
 	/* PFDR memory */
@@ -777,6 +773,10 @@ int qman_init_ccsr(struct device_node *node)
 	/* We are not prepared to accept ERNs for hardware enqueues */
 	qm_set_dc(qm, qm_dc_portal_fman0, 1, 0);
 	qm_set_dc(qm, qm_dc_portal_fman1, 1, 0);
+	/* Initialise Error Interrupt Handler */
+	ret = __bind_irq();
+	if (ret)
+		return ret;
 	return 0;
 }
 
-- 
1.7.9.7

