From 8285ee8e6b8d6308896b2e18b8bb6c38904cda54 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 14 Mar 2012 04:49:50 +0000
Subject: [PATCH 084/121] fsl_usdpaa: user-space FQID/BPID allocation

This adds ioctl() commands to the fsl_usdpaa character device to allow
(de)allocation of FQIDs and BPIDs. Per-FD accounting is done so cleanup
is automatically performed if deallocation wasn't performed explicitly,
however non-empty pools and non-OOS FQs are intentionally leaked rather
than being deallocated to cause trouble later. (Recover logic will be
able to hook in here later on to correct this.)

Note, the per-FD accounting uses the same dpa_alloc interface to record
the allocated IDs as the qbman driver does to maintain the allocator.
However there is no common "private" header that can be used between
the misc-char driver and the qbman driver, so the definitions are moved to
fsl_usdpaa.h (but protected by __KERNEL__ against user-space use).

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image. Just minor context
mods in order to port to 3.4 kernel.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/misc/fsl_usdpaa.c           |  146 ++++++++++++++++++++++++++++++++---
 drivers/staging/fsl_qbman/dpa_sys.h |   29 +------
 include/linux/fsl_usdpaa.h          |   60 +++++++++++++-
 3 files changed, 196 insertions(+), 39 deletions(-)

diff --git a/drivers/misc/fsl_usdpaa.c b/drivers/misc/fsl_usdpaa.c
index 3bea844..c106d1c 100644
--- a/drivers/misc/fsl_usdpaa.c
+++ b/drivers/misc/fsl_usdpaa.c
@@ -1,7 +1,7 @@
-/* Copyright (C) 2008-2011 Freescale Semiconductor, Inc.
+/* Copyright (C) 2008-2012 Freescale Semiconductor, Inc.
  * Authors: Andy Fleming <afleming@freescale.com>
- *          Timur Tabi <timur@freescale.com>
- *          Geoff Thorpe <Geoff.Thorpe@freescale.com>
+ *	    Timur Tabi <timur@freescale.com>
+ *	    Geoff Thorpe <Geoff.Thorpe@freescale.com>
  *
  * This file is licensed under the terms of the GNU General Public License
  * version 2.  This program is licensed "as is" without any warranty of any
@@ -9,6 +9,8 @@
  */
 
 #include <linux/fsl_usdpaa.h>
+#include <linux/fsl_qman.h>
+#include <linux/fsl_bman.h>
 
 #include <linux/miscdevice.h>
 #include <linux/fs.h>
@@ -17,6 +19,7 @@
 #include <linux/of.h>
 #include <linux/memblock.h>
 #include <linux/module.h>
+#include <linux/slab.h>
 
 /* Physical address range */
 u64 usdpaa_phys_start;
@@ -29,13 +32,78 @@ unsigned long usdpaa_pfn_len;
 /* TLB1 index */
 unsigned int usdpaa_tlbcam_index;
 
+/* Per-FD state (which should also be per-process but we don't enforce that) */
+struct ctx {
+	struct dpa_alloc ids[usdpaa_id_max];
+};
+
+/* Different resource classes */
+static const struct alloc_backend {
+	enum usdpaa_id_type id_type;
+	int (*alloc)(u32 *, u32, u32, int);
+	void (*release)(u32 base, unsigned int count);
+	const char *acronym;
+} alloc_backends[] = {
+	{
+		.id_type = usdpaa_id_fqid,
+		.alloc = qman_alloc_fqid_range,
+		.release = qman_release_fqid_range,
+		.acronym = "FQID"
+	},
+	{
+		.id_type = usdpaa_id_bpid,
+		.alloc = bman_alloc_bpid_range,
+		.release = bman_release_bpid_range,
+		.acronym = "BPID"
+	},
+	{
+		/* This terminates the array */
+		.id_type = usdpaa_id_max
+	}
+};
+
 static int usdpaa_open(struct inode *inode, struct file *filp)
 {
+	const struct alloc_backend *backend = &alloc_backends[0];
+	struct ctx *ctx = kmalloc(sizeof(struct ctx), GFP_KERNEL);
+	if (!ctx)
+		return -ENOMEM;
+	filp->private_data = ctx;
+
+	while (backend->id_type != usdpaa_id_max) {
+		dpa_alloc_init(&ctx->ids[backend->id_type]);
+		backend++;
+	}
+
 	filp->f_mapping->backing_dev_info = &directly_mappable_cdev_bdi;
 
 	return 0;
 }
 
+static int usdpaa_release(struct inode *inode, struct file *filp)
+{
+	struct ctx *ctx = filp->private_data;
+	const struct alloc_backend *backend = &alloc_backends[0];
+	while (backend->id_type != usdpaa_id_max) {
+		int ret, leaks = 0;
+		do {
+			u32 id, num;
+			ret = dpa_alloc_pop(&ctx->ids[backend->id_type],
+					    &id, &num);
+			if (!ret) {
+				leaks += num;
+				backend->release(id, num);
+			}
+		} while (ret == 1);
+		if (leaks)
+			pr_crit("USDPAA process leaking %d %s%s\n", leaks,
+				backend->acronym, (leaks > 1) ? "s" : "");
+		backend++;
+	}
+	kfree(ctx);
+	return 0;
+}
+
 static int usdpaa_mmap(struct file *file, struct vm_area_struct *vma)
 {
 	if (remap_pfn_range(vma, vma->vm_start,	usdpaa_pfn_start,
@@ -87,23 +155,83 @@ static unsigned long usdpaa_get_unmapped_area(struct file *file,
 	return addr;
 }
 
-static long usdpaa_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+static long ioctl_get_region(void __user *arg)
 {
-	struct usdpaa_ioctl_get_region ret = {
+	struct usdpaa_ioctl_get_region i = {
 		.phys_start = usdpaa_phys_start,
 		.phys_len = usdpaa_phys_size
 	};
-	if (cmd != USDPAA_IOCTL_GET_PHYS_BASE)
+	return copy_to_user(arg, &i, sizeof(i));
+}
+
+static long ioctl_id_alloc(struct file *fp, void __user *arg)
+{
+	struct usdpaa_ioctl_id_alloc i;
+	struct ctx *ctx = fp->private_data;
+	const struct alloc_backend *backend;
+	int ret = copy_from_user(&i, arg, sizeof(i));
+	if (ret)
+		return ret;
+	if ((i.id_type >= usdpaa_id_max) || !i.num)
+		return -EINVAL;
+	backend = &alloc_backends[i.id_type];
+	/* Allocate the required resource type */
+	ret = backend->alloc(&i.base, i.num, i.align, i.partial);
+	if (ret < 0)
+		return ret;
+	i.num = ret;
+	/* Copy the result to user-space */
+	ret = copy_to_user(arg, &i, sizeof(i));
+	if (ret) {
+		backend->release(i.base, i.num);
+		return ret;
+	}
+	/* Assign the allocated range to the FD accounting */
+	dpa_alloc_free(&ctx->ids[i.id_type], i.base, i.num);
+	return 0;
+}
+
+static long ioctl_id_release(struct file *fp, void __user *arg)
+{
+	struct usdpaa_ioctl_id_release i;
+	struct ctx *ctx = fp->private_data;
+	const struct alloc_backend *backend;
+	int ret = copy_from_user(&i, arg, sizeof(i));
+	if (ret)
+		return ret;
+	if ((i.id_type >= usdpaa_id_max) || !i.num)
 		return -EINVAL;
-	return copy_to_user((void __user *)arg, &ret, sizeof(ret));
+	backend = &alloc_backends[i.id_type];
+	/* Pull the range out of the FD accounting - the range is valid iff this
+	 * succeeds. */
+	ret = dpa_alloc_reserve(&ctx->ids[i.id_type], i.base, i.num);
+	if (ret)
+		return ret;
+	/* Release the resource to the backend */
+	backend->release(i.base, i.num);
+	return 0;
+}
+static long usdpaa_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	void __user *a = (void __user *)arg;
+	switch (cmd) {
+	case USDPAA_IOCTL_GET_PHYS_BASE:
+		return ioctl_get_region(a);
+	case USDPAA_IOCTL_ID_ALLOC:
+		return ioctl_id_alloc(fp, a);
+	case USDPAA_IOCTL_ID_RELEASE:
+		return ioctl_id_release(fp, a);
+	}
+	return -EINVAL;
 }
 
 static const struct file_operations usdpaa_fops = {
 	.open		   = usdpaa_open,
+	.release	   = usdpaa_release,
 	.mmap		   = usdpaa_mmap,
 	.get_unmapped_area = usdpaa_get_unmapped_area,
-	.unlocked_ioctl    = usdpaa_ioctl,
-	.compat_ioctl      = usdpaa_ioctl
+	.unlocked_ioctl	   = usdpaa_ioctl,
+	.compat_ioctl	   = usdpaa_ioctl
 };
 
 static struct miscdevice usdpaa_miscdev = {
diff --git a/drivers/staging/fsl_qbman/dpa_sys.h b/drivers/staging/fsl_qbman/dpa_sys.h
index a11439c..5ed6d5d 100644
--- a/drivers/staging/fsl_qbman/dpa_sys.h
+++ b/drivers/staging/fsl_qbman/dpa_sys.h
@@ -61,34 +61,7 @@
 #include <linux/vmalloc.h>
 #include <linux/ctype.h>
 
-/* Kernel FQID/BPID allocation uses the common logic in dpa_alloc.c via the
- * following interface. */
-struct dpa_alloc {
-	struct list_head list;
-	spinlock_t lock;
-};
-#define DECLARE_DPA_ALLOC(name) \
-	struct dpa_alloc name = { \
-		.list = { \
-			.prev = &name.list, \
-			.next = &name.list \
-		}, \
-		.lock = __SPIN_LOCK_UNLOCKED(name.lock) \
-	}
-static inline void dpa_alloc_init(struct dpa_alloc *alloc)
-{
-	INIT_LIST_HEAD(&alloc->list);
-	spin_lock_init(&alloc->lock);
-}
-int dpa_alloc_new(struct dpa_alloc *alloc, u32 *result, u32 count, u32 align,
-		  int partial);
-void dpa_alloc_free(struct dpa_alloc *alloc, u32 base_id, u32 count);
-/* Like 'new' but specifies the desired range, returns -ENOMEM if the entire
- * desired range is not available, or 0 for success. */
-int dpa_alloc_reserve(struct dpa_alloc *alloc, u32 base_id, u32 count);
-/* Pops and returns contiguous ranges from the allocator. Returns -ENOMEM when
- * 'alloc' is empty. */
-int dpa_alloc_pop(struct dpa_alloc *alloc, u32 *result, u32 *count);
+#include <linux/fsl_usdpaa.h>
 
 /* When copying aligned words or shorts, try to avoid memcpy() */
 #define CONFIG_TRY_BETTER_MEMCPY
diff --git a/include/linux/fsl_usdpaa.h b/include/linux/fsl_usdpaa.h
index 9c68cff..2d82b5d 100644
--- a/include/linux/fsl_usdpaa.h
+++ b/include/linux/fsl_usdpaa.h
@@ -17,15 +17,37 @@ extern "C" {
 
 #ifdef CONFIG_FSL_USDPAA
 
-/* Character-device interface. NB: these definitions need to be duplicated in
- * user-space. It is all temporary until being replaced by HugeTLB. */
+/* Allocation of resource IDs uses a generic interface. This enum is used to
+ * distinguish between the type of underlying object being manipulated. */
+enum usdpaa_id_type {
+	usdpaa_id_fqid,
+	usdpaa_id_bpid,
+	usdpaa_id_max /* <-- not a valid type, represents the number of types */
+};
 #define USDPAA_IOCTL_MAGIC 'u'
 struct usdpaa_ioctl_get_region {
 	uint64_t phys_start;
 	uint64_t phys_len;
 };
+struct usdpaa_ioctl_id_alloc {
+	uint32_t base; /* Return value, the start of the allocated range */
+	enum usdpaa_id_type id_type; /* what kind of resource(s) to allocate */
+	uint32_t num; /* how many IDs to allocate (and return value) */
+	uint32_t align; /* must be a power of 2, 0 is treated like 1 */
+	int partial; /* whether to allow less than 'num' */
+};
+struct usdpaa_ioctl_id_release {
+	/* Input; */
+	enum usdpaa_id_type id_type;
+	uint32_t base;
+	uint32_t num;
+};
 #define USDPAA_IOCTL_GET_PHYS_BASE \
 	_IOR(USDPAA_IOCTL_MAGIC, 0x01, struct usdpaa_ioctl_get_region)
+#define USDPAA_IOCTL_ID_ALLOC \
+	_IOWR(USDPAA_IOCTL_MAGIC, 0x02, struct usdpaa_ioctl_id_alloc)
+#define USDPAA_IOCTL_ID_RELEASE \
+	_IOW(USDPAA_IOCTL_MAGIC, 0x03, struct usdpaa_ioctl_id_release)
 
 #ifdef __KERNEL__
 
@@ -47,6 +69,40 @@ void __init fsl_usdpaa_init_early(void);
 
 #endif /* CONFIG_FSL_USDPAA */
 
+#ifdef __KERNEL__
+/* This interface is needed in a few places and though it's not specific to
+ * USDPAA as such, creating a new header for it doesn't make any sense. The
+ * qbman kernel driver implements this interface and uses it as the backend for
+ * both the FQID and BPID allocators. The fsl_usdpaa driver also uses this
+ * interface for tracking per-process allocations handed out to user-space. */
+struct dpa_alloc {
+	struct list_head list;
+	spinlock_t lock;
+};
+#define DECLARE_DPA_ALLOC(name) \
+	struct dpa_alloc name = { \
+		.list = { \
+			.prev = &name.list, \
+			.next = &name.list \
+		}, \
+		.lock = __SPIN_LOCK_UNLOCKED(name.lock) \
+	}
+static inline void dpa_alloc_init(struct dpa_alloc *alloc)
+{
+	INIT_LIST_HEAD(&alloc->list);
+	spin_lock_init(&alloc->lock);
+}
+int dpa_alloc_new(struct dpa_alloc *alloc, u32 *result, u32 count, u32 align,
+		  int partial);
+void dpa_alloc_free(struct dpa_alloc *alloc, u32 base_id, u32 count);
+/* Like 'new' but specifies the desired range, returns -ENOMEM if the entire
+ * desired range is not available, or 0 for success. */
+int dpa_alloc_reserve(struct dpa_alloc *alloc, u32 base_id, u32 count);
+/* Pops and returns contiguous ranges from the allocator. Returns -ENOMEM when
+ * 'alloc' is empty. */
+int dpa_alloc_pop(struct dpa_alloc *alloc, u32 *result, u32 *count);
+#endif /* __KERNEL__ */
+
 #ifdef __cplusplus
 }
 #endif
-- 
1.7.9.7

