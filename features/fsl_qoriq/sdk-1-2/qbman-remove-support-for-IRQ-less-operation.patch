From 2c4a19b2d97fe45a2ca589cc99a6af2b052434b9 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Fri, 28 Oct 2011 14:39:18 -0500
Subject: [PATCH 062/128] qbman: remove support for IRQ-less operation

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/Kconfig     |    6 ------
 drivers/staging/fsl_qbman/bman_high.c |   18 ------------------
 drivers/staging/fsl_qbman/qman_high.c |   18 ------------------
 3 files changed, 42 deletions(-)

diff --git a/drivers/staging/fsl_qbman/Kconfig b/drivers/staging/fsl_qbman/Kconfig
index d938dd8..45357bc 100644
--- a/drivers/staging/fsl_qbman/Kconfig
+++ b/drivers/staging/fsl_qbman/Kconfig
@@ -14,10 +14,6 @@ config FSL_DPA_CHECKING
 	  Compiles in additional checks to sanity-check the drivers and any
 	  use of it by other code. Not recommended for performance.
 
-config FSL_DPA_HAVE_IRQ
-	bool
-	default y
-
 config FSL_DPA_CAN_WAIT
 	bool
 	default y
@@ -28,12 +24,10 @@ config FSL_DPA_CAN_WAIT_SYNC
 
 config FSL_DPA_PIRQ_FAST
 	bool
-	depends on FSL_DPA_HAVE_IRQ
 	default y
 
 config FSL_DPA_PIRQ_SLOW
 	bool
-	depends on FSL_DPA_HAVE_IRQ
 	default y
 
 config FSL_DPA_PORTAL_SHARE
diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index ca59fba..f5d6c32 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -174,7 +174,6 @@ static void depletion_unlink(struct bman_pool *pool)
 #define SLOW_POLL_BUSY 10
 static u32 __poll_portal_slow(struct bman_portal *p, u32 is);
 
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 /* Portal interrupt handler */
 static irqreturn_t portal_isr(__always_unused int irq, void *ptr)
 {
@@ -185,7 +184,6 @@ static irqreturn_t portal_isr(__always_unused int irq, void *ptr)
 	bm_isr_status_clear(&p->p, clear);
 	return IRQ_HANDLED;
 }
-#endif
 
 struct bman_portal *bman_create_affine_portal(
 			const struct bm_portal_config *config,
@@ -244,7 +242,6 @@ struct bman_portal *bman_create_affine_portal(
 	portal->irq_sources = 0;
 	bm_isr_enable_write(__p, portal->irq_sources);
 	bm_isr_status_clear(__p, 0xffffffff);
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->public_cfg.cpu);
 	if ((config->public_cfg.cpu != -1) &&
 			irq_can_set_affinity(config->public_cfg.irq) &&
@@ -261,7 +258,6 @@ struct bman_portal *bman_create_affine_portal(
 	/* Enable the bits that make sense */
 	if (!recovery_mode)
 		bm_isr_uninhibit(__p);
-#endif
 	/* Need RCR to be empty before continuing */
 	bm_isr_disable_write(__p, ~BM_PIRQ_RCRI);
 	ret = bm_rcr_get_fill(__p);
@@ -278,11 +274,9 @@ struct bman_portal *bman_create_affine_portal(
 	put_affine_portal();
 	return portal;
 fail_rcr_empty:
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 fail_affinity:
 	free_irq(config->public_cfg.irq, portal);
 fail_irq:
-#endif
 	if (portal->pools)
 		kfree(portal->pools);
 fail_pools:
@@ -328,9 +322,7 @@ const struct bm_portal_config *bman_destroy_affine_portal(void)
 	pcfg = bm->config;
 	bm_rcr_cce_update(&bm->p);
 	bm_rcr_cce_update(&bm->p);
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	free_irq(pcfg->public_cfg.irq, bm);
-#endif
 	kfree(bm->pools);
 	bm_isr_finish(&bm->p);
 	bm_mc_finish(&bm->p);
@@ -450,7 +442,6 @@ EXPORT_SYMBOL(bman_irqsource_get);
 
 int bman_irqsource_add(__maybe_unused u32 bits)
 {
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	struct bman_portal *p = get_raw_affine_portal();
 	int ret = 0;
 #ifdef CONFIG_FSL_DPA_PORTAL_SHARE
@@ -467,16 +458,11 @@ int bman_irqsource_add(__maybe_unused u32 bits)
 	}
 	put_affine_portal();
 	return ret;
-#else
-	pr_err("No Bman portal IRQ support, mustn't specify IRQ flags!");
-	return -EINVAL;
-#endif
 }
 EXPORT_SYMBOL(bman_irqsource_add);
 
 int bman_irqsource_remove(u32 bits)
 {
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	struct bman_portal *p = get_raw_affine_portal();
 	__maybe_unused unsigned long irqflags;
 	u32 ier;
@@ -505,10 +491,6 @@ int bman_irqsource_remove(u32 bits)
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	return 0;
-#else
-	pr_err("No Bman portal IRQ support, mustn't specify IRQ flags!");
-	return -EINVAL;
-#endif
 }
 EXPORT_SYMBOL(bman_irqsource_remove);
 
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 7376998..3ff15c9 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -260,7 +260,6 @@ static u32 __poll_portal_slow(struct qman_portal *p, u32 is);
 static inline unsigned int __poll_portal_fast(struct qman_portal *p,
 					unsigned int poll_limit);
 
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 /* Portal interrupt handler */
 static irqreturn_t portal_isr(__always_unused int irq, void *ptr)
 {
@@ -275,7 +274,6 @@ static irqreturn_t portal_isr(__always_unused int irq, void *ptr)
 	qm_isr_status_clear(&p->p, clear);
 	return IRQ_HANDLED;
 }
-#endif
 
 /* This inner version is used privately by qman_create_affine_portal(), as well
  * as by the exported qman_stop_dequeues(). */
@@ -491,7 +489,6 @@ drain_loop:
 	portal->irq_sources = 0;
 	qm_isr_enable_write(__p, portal->irq_sources);
 	qm_isr_status_clear(__p, 0xffffffff);
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->public_cfg.cpu);
 	if ((config->public_cfg.cpu != -1) &&
 			irq_can_set_affinity(config->public_cfg.irq) &&
@@ -511,7 +508,6 @@ drain_loop:
 		post_recovery(portal, config);
 		qm_isr_uninhibit(__p);
 	}
-#endif
 	/* Need EQCR to be empty before continuing */
 	isdr ^= QM_PIRQ_EQCI;
 	qm_isr_disable_write(__p, isdr);
@@ -544,11 +540,9 @@ drain_loop:
 	return portal;
 fail_dqrr_mr_empty:
 fail_eqcr_empty:
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 fail_affinity:
 	free_irq(config->public_cfg.irq, portal);
 fail_irq:
-#endif
 	platform_device_del(portal->pdev);
 fail_devadd:
 	platform_device_put(portal->pdev);
@@ -618,9 +612,7 @@ const struct qm_portal_config *qman_destroy_affine_portal(void)
 	 * began. */
 	qm_eqcr_cce_update(&qm->p);
 	qm_eqcr_cce_update(&qm->p);
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	free_irq(pcfg->public_cfg.irq, qm);
-#endif
 	kfree(qm->cgrs);
 	qm_isr_finish(&qm->p);
 	qm_mc_finish(&qm->p);
@@ -950,7 +942,6 @@ EXPORT_SYMBOL(qman_irqsource_get);
 
 int qman_irqsource_add(u32 bits __maybe_unused)
 {
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	struct qman_portal *p = get_raw_affine_portal();
 	int ret = 0;
 #ifdef CONFIG_FSL_DPA_PORTAL_SHARE
@@ -967,16 +958,11 @@ int qman_irqsource_add(u32 bits __maybe_unused)
 	}
 	put_affine_portal();
 	return ret;
-#else
-	pr_err("No Qman portal IRQ support, mustn't specify IRQ flags!");
-	return -EINVAL;
-#endif
 }
 EXPORT_SYMBOL(qman_irqsource_add);
 
 int qman_irqsource_remove(u32 bits)
 {
-#ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	struct qman_portal *p = get_raw_affine_portal();
 	__maybe_unused unsigned long irqflags;
 	u32 ier;
@@ -1005,10 +991,6 @@ int qman_irqsource_remove(u32 bits)
 	PORTAL_IRQ_UNLOCK(p, irqflags);
 	put_affine_portal();
 	return 0;
-#else
-	pr_err("No Qman portal IRQ support, mustn't specify IRQ flags!");
-	return -EINVAL;
-#endif
 }
 EXPORT_SYMBOL(qman_irqsource_remove);
 
-- 
1.7.9.7

