From e9137fad1fc68fa2cb6047f2ee1f05cbc0a119ec Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Wed, 18 Apr 2012 20:44:32 +0000
Subject: [PATCH 118/128] dpaa_eth: Increase FQ taildrop threshold

Raise the taildrop threshold for FQs, to avoid a large number of Tx
frames being dropped by QMan in 10G termination tests.

The new value is experimental, based on measurements from several
usecases. In the future we may want to make this a configuration option
and perhaps set different values for queues used by 1G and 10G ports.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   16 +++++++++++-----
 1 file changed, 11 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 105979b..250ab0a 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -71,6 +71,16 @@
 
 #define DPA_NAPI_WEIGHT		64
 
+/*
+ * Size in bytes of the QMan taildrop threshold.
+ * If a FQ contains a number of bytes higher than this threshold,
+ * it will drop any subsequently enqueued frame.
+ *
+ * In the future, we may want to have different values for queues
+ * belonging to 1G vs 10G ports.
+ */
+#define DPA_TAILDROP_THRESHOLD	0x100000
+
 /* S/G table requires at least 256 bytes */
 #define SGT_BUFFER_SIZE		DPA_BP_SIZE(256)
 
@@ -457,10 +467,6 @@ _dpa_fq_alloc(struct list_head *list, struct dpa_fq *dpa_fq)
 	struct device		*dev;
 	struct qman_fq		*fq;
 	struct qm_mcc_initfq	 initfq;
-	/* Set the QMan taildrop threshold high enough to accomodate
-	 * one 64k frame, plus an extra (here, 16k) for
-	 * other frames awaiting Tx. */
-	const u32		 qman_taildrop_threshold = 0x14000;
 
 	priv = netdev_priv(dpa_fq->net_dev);
 	dev = dpa_fq->net_dev->dev.parent;
@@ -482,7 +488,7 @@ _dpa_fq_alloc(struct list_head *list, struct dpa_fq *dpa_fq)
 		initfq.fqd.dest.channel	= dpa_fq->channel;
 		initfq.fqd.dest.wq = dpa_fq->wq;
 		initfq.we_mask |= QM_INITFQ_WE_TDTHRESH | QM_INITFQ_WE_FQCTRL;
-		qm_fqd_taildrop_set(&initfq.fqd.td, qman_taildrop_threshold, 1);
+		qm_fqd_taildrop_set(&initfq.fqd.td, DPA_TAILDROP_THRESHOLD, 1);
 		initfq.fqd.fq_ctrl = QM_FQCTRL_TDE | QM_FQCTRL_PREFERINCACHE;
 		if (dpa_fq->flags & QMAN_FQ_FLAG_NO_ENQUEUE) {
 			initfq.we_mask |= QM_INITFQ_WE_CONTEXTA;
-- 
1.7.9.7

