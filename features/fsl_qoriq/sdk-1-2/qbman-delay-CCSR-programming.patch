From 23fcc64fb1682cda958cfa0c8c621dea2533c34a Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Fri, 6 Apr 2012 13:57:05 -0500
Subject: [PATCH 092/121] qbman: delay CCSR-programming.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/bman_config.c  |   24 ++++++++-----
 drivers/staging/fsl_qbman/bman_driver.c  |    4 +--
 drivers/staging/fsl_qbman/bman_private.h |    2 +-
 drivers/staging/fsl_qbman/qman_config.c  |   57 +++++++++++++++++-------------
 drivers/staging/fsl_qbman/qman_driver.c  |    4 +--
 drivers/staging/fsl_qbman/qman_private.h |    2 +-
 6 files changed, 53 insertions(+), 40 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index a57b0e9..b800d68 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -252,12 +252,17 @@ static void bm_set_memory(struct bman *bm, u64 ba, int prio, u32 size)
 /* Config driver */
 /*****************/
 
+/* TODO: Kconfig these? */
+#define DEFAULT_FBPR_SZ	(PAGE_SIZE << 12)
+
 /* We support only one of these. */
 static struct bman *bm;
 static struct device_node *bm_node;
 
-/* TODO: Kconfig these? */
-#define DEFAULT_FBPR_SZ	(PAGE_SIZE << 12)
+/* And this state belongs to 'bm'. It is set during fsl_bman_init(), but used
+ * during bman_init_ccsr(). */
+static dma_addr_t fbpr_a;
+static size_t fbpr_sz = DEFAULT_FBPR_SZ;
 
 /* Parse the <name> property to extract the memory location and size and
  * memblock_reserve() it. If it isn't supplied, memblock_alloc() the default
@@ -318,8 +323,6 @@ static int __init fsl_bman_init(struct device_node *node)
 	struct resource res;
 	u32 __iomem *regs;
 	const char *s;
-	dma_addr_t fbpr_a = 0; /* gcc doesn't know this is unnecessary */
-	size_t fbpr_sz = DEFAULT_FBPR_SZ;
 	int ret, standby = 0;
 	u16 id;
 	u8 major, minor;
@@ -359,8 +362,6 @@ static int __init fsl_bman_init(struct device_node *node)
 		pr_info("  -> in standby mode\n");
 		return 0;
 	}
-	/* FBPR memory */
-	bm_set_memory(bm, fbpr_a, 0, fbpr_sz);
 	return 0;
 }
 
@@ -495,14 +496,19 @@ static int __bind_irq(void)
 	return 0;
 }
 
-/* Initialise Error Interrupt Handler */
-int bman_init_error_int(struct device_node *node)
+int bman_init_ccsr(struct device_node *node)
 {
+	int ret;
 	if (!bman_have_ccsr())
 		return 0;
 	if (node != bm_node)
 		return -EINVAL;
-	return __bind_irq();
+	ret = __bind_irq();
+	if (ret)
+		return ret;
+	/* FBPR memory */
+	bm_set_memory(bm, fbpr_a, 0, fbpr_sz);
+	return 0;
 }
 
 #ifdef CONFIG_SYSFS
diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index f16a902..8c7ec84 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -329,10 +329,10 @@ static __init int bman_init(void)
 
 	/* Initialise the Bman (CCSR) device */
 	for_each_compatible_node(dn, NULL, "fsl,bman") {
-		if (!bman_init_error_int(dn))
+		if (!bman_init_ccsr(dn))
 			pr_info("Bman err interrupt handler present\n");
 		else
-			pr_err("Bman err interrupt handler missing\n");
+			pr_err("Bman CCSR setup failed\n");
 	}
 	/* Initialise any declared buffer pools */
 	for_each_compatible_node(dn, NULL, "fsl,bpool") {
diff --git a/drivers/staging/fsl_qbman/bman_private.h b/drivers/staging/fsl_qbman/bman_private.h
index 12180c7..fcccafa 100644
--- a/drivers/staging/fsl_qbman/bman_private.h
+++ b/drivers/staging/fsl_qbman/bman_private.h
@@ -63,7 +63,7 @@ struct bm_portal_config {
 
 #ifdef CONFIG_FSL_BMAN_CONFIG
 /* Hooks from bman_driver.c to bman_config.c */
-int bman_init_error_int(struct device_node *node);
+int bman_init_ccsr(struct device_node *node);
 #endif
 
 /* Hooks from bman_driver.c in to bman_high.c */
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index a26f8c8..f8dc101 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -506,6 +506,11 @@ static int qm_init_pfdr(struct qman *qm, u32 pfdr_start, u32 num)
 static struct qman *qm;
 static struct device_node *qm_node;
 
+/* And this state belongs to 'qm'. It is set during fsl_qman_init(), but used
+ * during qman_init_ccsr(). */
+static dma_addr_t fqd_a, pfdr_a;
+static size_t fqd_sz = DEFAULT_FQD_SZ, pfdr_sz = DEFAULT_PFDR_SZ;
+
 /* Parse the <name> property to extract the memory location and size and
  * memblock_reserve() it. If it isn't supplied, memblock_alloc() the default
  * size. Also flush this memory range from data cache so that QMAN originated
@@ -570,8 +575,6 @@ static int __init fsl_qman_init(struct device_node *node)
 	struct resource res;
 	u32 __iomem *regs;
 	const char *s;
-	dma_addr_t fqd_a = 0, pfdr_a = 0;
-	size_t fqd_sz = DEFAULT_FQD_SZ, pfdr_sz = DEFAULT_PFDR_SZ;
 	int ret, standby = 0;
 	u16 id;
 	u8 major, minor;
@@ -617,26 +620,6 @@ static int __init fsl_qman_init(struct device_node *node)
 		pr_info("  -> in standby mode\n");
 		return 0;
 	}
-	/* FQD memory */
-	qm_set_memory(qm, qm_memory_fqd, fqd_a, 1, 0, 0, fqd_sz);
-	/* PFDR memory */
-	qm_set_memory(qm, qm_memory_pfdr, pfdr_a, 1, 0, 0, pfdr_sz);
-	qm_init_pfdr(qm, 8, pfdr_sz / 64 - 8);
-	/* thresholds */
-	qm_set_pfdr_threshold(qm, 512, 64);
-	qm_set_sfdr_threshold(qm, 128);
-	/* clear stale PEBI bit from interrupt status register */
-	qm_err_isr_status_clear(qm, QM_EIRQ_PEBI);
-	/* corenet initiator settings */
-	qm_set_corenet_initiator(qm);
-	/* HID settings */
-	qm_set_hid(qm);
-	/* Set scheduling weights to defaults */
-	for (ret = qm_wq_first; ret <= qm_wq_last; ret++)
-		qm_set_wq_scheduling(qm, ret, 0, 0, 0, 0, 0, 0, 0);
-	/* We are not prepared to accept ERNs for hardware enqueues */
-	qm_set_dc(qm, qm_dc_portal_fman0, 1, 0);
-	qm_set_dc(qm, qm_dc_portal_fman1, 1, 0);
 	return 0;
 }
 
@@ -763,14 +746,38 @@ static int __bind_irq(void)
 	return 0;
 }
 
-/* Initialise Error Interrupt Handler */
-int qman_init_error_int(struct device_node *node)
+int qman_init_ccsr(struct device_node *node)
 {
+	int ret;
+	/* Initialise Error Interrupt Handler */
 	if (!qman_have_ccsr())
 		return 0;
 	if (node != qm_node)
 		return -EINVAL;
-	return __bind_irq();
+	ret = __bind_irq();
+	if (ret)
+		return ret;
+	/* FQD memory */
+	qm_set_memory(qm, qm_memory_fqd, fqd_a, 1, 0, 0, fqd_sz);
+	/* PFDR memory */
+	qm_set_memory(qm, qm_memory_pfdr, pfdr_a, 1, 0, 0, pfdr_sz);
+	qm_init_pfdr(qm, 8, pfdr_sz / 64 - 8);
+	/* thresholds */
+	qm_set_pfdr_threshold(qm, 512, 64);
+	qm_set_sfdr_threshold(qm, 128);
+	/* clear stale PEBI bit from interrupt status register */
+	qm_err_isr_status_clear(qm, QM_EIRQ_PEBI);
+	/* corenet initiator settings */
+	qm_set_corenet_initiator(qm);
+	/* HID settings */
+	qm_set_hid(qm);
+	/* Set scheduling weights to defaults */
+	for (ret = qm_wq_first; ret <= qm_wq_last; ret++)
+		qm_set_wq_scheduling(qm, ret, 0, 0, 0, 0, 0, 0, 0);
+	/* We are not prepared to accept ERNs for hardware enqueues */
+	qm_set_dc(qm, qm_dc_portal_fman0, 1, 0);
+	qm_set_dc(qm, qm_dc_portal_fman1, 1, 0);
+	return 0;
 }
 
 #define PID_CFG_LIODN_MASK 0x0fff0000
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 7ded5a0..8c0313e 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -404,10 +404,10 @@ static __init int qman_init(void)
 
 	/* Initialise the Qman (CCSR) device */
 	for_each_compatible_node(dn, NULL, "fsl,qman") {
-		if (!qman_init_error_int(dn))
+		if (!qman_init_ccsr(dn))
 			pr_info("Qman err interrupt handler present\n");
 		else
-			pr_err("Qman err interrupt handler missing\n");
+			pr_err("Qman CCSR setup failed\n");
 	}
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
 	/* Setup lookup table for FQ demux */
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index 3e4347c..5ca90e8 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -131,7 +131,7 @@ extern u16 qman_ip_rev; /* 0 if uninitialised, otherwise QMAN_REVx */
 
 #ifdef CONFIG_FSL_QMAN_CONFIG
 /* Hooks from qman_driver.c to qman_config.c */
-int qman_init_error_int(struct device_node *node);
+int qman_init_ccsr(struct device_node *node);
 void qman_liodn_fixup(enum qm_channel channel);
 #endif
 
-- 
1.7.9.7

