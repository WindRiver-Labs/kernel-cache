From 5464214b16cabb4718a21b07612d11b1f46fb017 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Fri, 30 Mar 2012 18:29:09 +0300
Subject: [PATCH 106/128] dpaa_eth: Add multiple schemes of FQ-to-WQ
 assignment

The current FQ assignment scheme poses memory problems under high PCD
traffic on lots of ingress queues, because the Tx Confirm queues
(greatly outnumbered by PCD) may pile up PFDRs and eventually exhaust
QMan's memory. In certain scenarios, even the kernel memory may be
depleted.

Added alternative fq-to-wq assignment functions, chosen between at
compile-time.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/Kconfig             |   21 +++++++
 .../net/ethernet/freescale/dpa/dpaa_eth-common.h   |   12 ++++
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |   28 ++++-----
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      |   64 ++++++++++++++++++++
 4 files changed, 110 insertions(+), 15 deletions(-)

diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index 70d8087..2698970 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -133,6 +133,27 @@ config FSL_DPA_1588
 	depends on DPA
 	default n
 
+choice DPA_ETH_WQ_ASSIGN
+	prompt "WorkQueue assignment scheme for FrameQueues"
+	default DPA_ETH_WQ_MULTI
+	help
+	  Selects the FrameQueue to WorkQueue assignment scheme.
+
+	config DPA_ETH_WQ_LEGACY
+		bool "Legacy WQ assignment"
+		help
+		  Statically-defined FQIDs are round-robin assigned to all WQs (0..7). PCD queues are always
+		  in this category. Other frame queues may be those used for "MAC-less" or "shared MAC" configurations
+		  of the driver.
+		  Dynamically-defined FQIDs all go to WQ7.
+	config DPA_ETH_WQ_MULTI
+		bool "Multi-WQ assignment"
+		help
+		  Tx Confirmation FQs go to WQ1.
+		  Rx Default, Tx and PCD FQs go to WQ3.
+		  Rx Error and Tx Error FQs go to WQ2.
+endchoice
+
 config DPAA_ETH_UNIT_TESTS
 	bool "Run Unit Tests for DPAA Ethernet"
 	depends on DPA
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
index ac35729..73ea2c4 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
@@ -130,8 +130,20 @@
 	dpaa_eth_debug((net_dev)->dev.parent, "%s: " format, \
 			(net_dev)->name , ##arg)
 
+/* Simple enum of FQ types - used for array indexing */
 enum {RX, TX};
 
+/* More detailed FQ types - used for fine-grained WQ assignments */
+enum dpa_fq_type {
+	FQ_TYPE_RX_DEFAULT = 1, /* Rx Default FQs */
+	FQ_TYPE_RX_ERROR,       /* Rx Error FQs */
+	FQ_TYPE_RX_PCD,         /* User-defined PCDs */
+	FQ_TYPE_TX,             /* "Real" Tx FQs */
+	FQ_TYPE_TX_CONFIRM,     /* Tx Confirmation FQs (actually Rx FQs) */
+	FQ_TYPE_TX_ERROR,       /* Tx Error FQs (these are actually Rx FQs) */
+};
+
+
 #define DPA_PRIV_DATA_SIZE 16
 #define DPA_PARSE_RESULTS_SIZE sizeof(t_FmPrsResult)
 #define DPA_HASH_RESULTS_SIZE 16
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index d8683b6..8d7fb9f 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -146,17 +146,6 @@ static const char rtx[][3] = {
 	[TX] = "TX"
 };
 
-struct dpa_fq {
-	struct qman_fq		 fq_base;
-	struct list_head	 list;
-	struct net_device	*net_dev;
-	bool			 init;
-	uint32_t fqid;
-	uint32_t flags;
-	uint16_t channel;
-	uint8_t wq;
-};
-
 /* BM */
 
 #define DPA_BP_HEAD (DPA_PRIV_DATA_SIZE + DPA_PARSE_RESULTS_SIZE + \
@@ -2580,6 +2569,9 @@ dpa_fq_probe(struct platform_device *_of_dev, struct list_head *list,
 				err = -EINVAL;
 				goto invalid_error_queues;
 			}
+
+			dpa_fq[0].fq_type = (ptype == RX ?
+				FQ_TYPE_RX_ERROR : FQ_TYPE_TX_ERROR);
 		}
 
 		/* The second queue is the the Default queue */
@@ -2591,6 +2583,9 @@ dpa_fq_probe(struct platform_device *_of_dev, struct list_head *list,
 				err = -EINVAL;
 				goto invalid_default_queues;
 			}
+
+			dpa_fq[0].fq_type = (ptype == RX ?
+				FQ_TYPE_RX_DEFAULT : FQ_TYPE_TX_CONFIRM);
 		}
 
 		/*
@@ -2598,17 +2593,20 @@ dpa_fq_probe(struct platform_device *_of_dev, struct list_head *list,
 		 * The first 8 will be used by the private linux interface
 		 * if these are TX queues
 		 */
-		if (i == 2 || (!errq && i == 0 && fqs))
+		if (i == 2 || (!errq && i == 0 && fqs)) {
 			*fqs = dpa_fq;
 
+			for (j = 0; j < fqids[i].count; j++)
+				dpa_fq[j].fq_type = (ptype == RX ?
+					FQ_TYPE_RX_PCD : FQ_TYPE_TX);
+		}
+
 #warning We lost the 8-queue enforcement
 
-#define DPA_NUM_WQS 8
 		for (j = 0; j < fqids[i].count; j++) {
 			dpa_fq[j].fqid = fqids[i].start ?
 				fqids[i].start + j : 0;
-			dpa_fq[j].wq = dpa_fq[j].fqid ?
-				dpa_fq[j].fqid % DPA_NUM_WQS : DPA_NUM_WQS - 1;
+			_dpa_assign_wq(dpa_fq + j);
 			list_add_tail(&dpa_fq[j].list, list);
 		}
 	}
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 86a61d9..143bf76 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -59,6 +59,18 @@ struct pcd_range {
 	uint32_t			 count;
 };
 
+struct dpa_fq {
+	struct qman_fq		 fq_base;
+	struct list_head	 list;
+	struct net_device	*net_dev;
+	bool			 init;
+	uint32_t fqid;
+	uint32_t flags;
+	uint16_t channel;
+	uint8_t wq;
+	enum dpa_fq_type fq_type;
+};
+
 struct dpa_bp {
 	struct bman_pool		*pool;
 	uint8_t				bpid;
@@ -132,4 +144,56 @@ static inline int dpaa_eth_napi_schedule(struct dpa_percpu_priv_s *percpu_priv)
 	return 0;
 }
 
+#if defined CONFIG_DPA_ETH_WQ_LEGACY
+#define DPA_NUM_WQS 8
+/*
+ * Older WQ assignment: statically-defined FQIDs (such as PCDs) are assigned
+ * round-robin to all WQs available. Dynamically-allocated FQIDs go to WQ7.
+ *
+ * Not necessarily the best scheme, but worked fine so far, so we might want
+ * to keep it around for a while.
+ */
+static inline void _dpa_assign_wq(struct dpa_fq *fq)
+{
+	fq->wq = fq->fqid ? fq->fqid % DPA_NUM_WQS : DPA_NUM_WQS - 1;
+}
+#elif defined CONFIG_DPA_ETH_WQ_MULTI
+/*
+ * Use multiple WQs for FQ assignment:
+ *	- Tx Confirmation queues go to WQ1.
+ *	- Rx Default, Tx and PCD queues go to WQ3 (no differentiation between
+ *	  Rx and Tx traffic, or between Rx Default and Rx PCD frames).
+ *	- Rx Error and Tx Error queues go to WQ2 (giving them a better chance
+ *	  to be scheduled, in case there are many more FQs in WQ3).
+ * This ensures that Tx-confirmed buffers are timely released. In particular,
+ * it avoids congestion on the Tx Confirm FQs, which can pile up PFDRs if they
+ * are greatly outnumbered by other FQs in the system (usually PCDs), while
+ * dequeue scheduling is round-robin.
+ */
+static inline void _dpa_assign_wq(struct dpa_fq *fq)
+{
+	switch (fq->fq_type) {
+	case FQ_TYPE_TX_CONFIRM:
+		fq->wq = 1;
+		break;
+	case FQ_TYPE_RX_DEFAULT:
+	case FQ_TYPE_TX:
+	case FQ_TYPE_RX_PCD:
+		fq->wq = 3;
+		break;
+	case FQ_TYPE_RX_ERROR:
+	case FQ_TYPE_TX_ERROR:
+		fq->wq = 2;
+		break;
+	default:
+		WARN(1, "Invalid FQ type %d for FQID %d!\n",
+		       fq->fq_type, fq->fqid);
+	}
+}
+#else
+/* This shouldn't happen, since we've made a "default" choice in the Kconfig. */
+#error "No WQ assignment scheme chosen; Kconfig out-of-sync?"
+#endif /* CONFIG_DPA_ETH_WQ_ASSIGN_* */
+
+
 #endif	/* __DPA_H */
-- 
1.7.9.7

