From 1e66a10a0c55ce1cde069915e5f8d543404d3e8a Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Thu, 12 Apr 2012 23:53:07 +0000
Subject: [PATCH 097/121] qman: qman_volatile_dequeue() does not allow NULL
 fq.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c |    9 ++++-----
 include/linux/fsl_qman.h              |    6 ++----
 2 files changed, 6 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 68859f7..33cdcb5 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -1666,12 +1666,11 @@ int qman_volatile_dequeue(struct qman_fq *fq, u32 flags __maybe_unused,
 	struct qman_portal *p;
 	int ret;
 
-	DPA_ASSERT(!fq || (fq->state == qman_fq_state_parked) ||
+	DPA_ASSERT((fq->state == qman_fq_state_parked) ||
 			(fq->state == qman_fq_state_retired));
-	DPA_ASSERT(!fq || !(vdqcr & QM_VDQCR_FQID_MASK));
-	DPA_ASSERT(!fq || !fq_isset(fq, QMAN_FQ_STATE_VDQCR));
-	if (fq)
-		vdqcr = (vdqcr & ~QM_VDQCR_FQID_MASK) | fq->fqid;
+	DPA_ASSERT(!(vdqcr & QM_VDQCR_FQID_MASK));
+	DPA_ASSERT(!fq_isset(fq, QMAN_FQ_STATE_VDQCR));
+	vdqcr = (vdqcr & ~QM_VDQCR_FQID_MASK) | fq->fqid;
 #ifdef CONFIG_FSL_DPA_CAN_WAIT
 	if (flags & QMAN_VOLATILE_FLAG_WAIT)
 		ret = wait_vdqcr_start(&p, fq, vdqcr, flags);
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 1c9a493..0267032 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1506,7 +1506,7 @@ int qman_query_wq(u8 query_dedicated, struct qm_mcr_querywq *wq);
 
 /**
  * qman_volatile_dequeue - Issue a volatile dequeue command
- * @fq: the frame queue object to dequeue from (or NULL)
+ * @fq: the frame queue object to dequeue from
  * @flags: a bit-mask of QMAN_VOLATILE_FLAG_*** options
  * @vdqcr: bit mask of QM_VDQCR_*** options, as per qm_dqrr_vdqcr_set()
  *
@@ -1520,9 +1520,7 @@ int qman_query_wq(u8 query_dedicated, struct qm_mcr_querywq *wq);
  * presence of the QM_DQRR_STAT_UNSCHEDULED and QM_DQRR_STAT_DQCR_EXPIRED bits
  * in the "stat" field of the "struct qm_dqrr_entry" passed to the FQ's dequeue
  * callback, or by waiting for the QMAN_FQ_STATE_VDQCR bit to disappear from the
- * "flags" retrieved from qman_fq_state(). If @fq is non-NULL, the corresponding
- * FQID will be substituted in to the VDQCR command, otherwise it is assumed
- * that @vdqcr already contains the FQID to dequeue from.
+ * "flags" retrieved from qman_fq_state().
  */
 int qman_volatile_dequeue(struct qman_fq *fq, u32 flags, u32 vdqcr);
 
-- 
1.7.9.7

