From d85f910de4b1afb2680aea9b6bf25dadf21021ec Mon Sep 17 00:00:00 2001
From: Xuelin Shi <b29237@freescale.com>
Date: Sat, 5 May 2012 17:31:36 +0000
Subject: [PATCH 118/121] DMA/RAIDENGINE: support compute PQ with only one
 source or one destination.

GenQQ is the only interface we export to async layer  to generate P and Q
parity and this command needs at least two sources and two destinations.

Anyway async layer needs to use this interface to compute Q parity only
or just pass one source to compute Q parity.

If re_jr_prep_pq(...) is called with disable_p, the computation is delegated
to GenQ which computes P or Q only.

If re_jr_prep_pq(...) is called with only one source, a pseuodo source is
given to RE with associated coef all zero which has no impact on the
compuation result.

By this way, this patch mends the interface difference with async layer.

Signed-off-by: Xuelin Shi <b29237@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/dma/fsl_raid.c |   69 ++++++++++++++++++++++++++++++------------------
 1 file changed, 44 insertions(+), 25 deletions(-)

diff --git a/drivers/dma/fsl_raid.c b/drivers/dma/fsl_raid.c
index a61453b..b55654d 100644
--- a/drivers/dma/fsl_raid.c
+++ b/drivers/dma/fsl_raid.c
@@ -392,13 +392,10 @@ static int fill_cfd_frame_with_cdb(struct cmpnd_frame *cf, struct re_jr *jr,
 	return 0;
 }
 
-/*
- * Prep function for P parity calculation.In RAID Engine terminology,
- * XOR calculation is called GenQ calculation done through GenQ command
- */
-struct dma_async_tx_descriptor *re_jr_prep_dma_xor(
+static struct dma_async_tx_descriptor *re_jr_prep_genq(
 		struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,
-		unsigned int src_cnt, size_t len, unsigned long flags)
+		unsigned int src_cnt, const unsigned char *scf, size_t len,
+		unsigned long flags)
 {
 	struct re_jr *jr = NULL;
 	struct fsl_re_dma_async_tx_desc *desc = NULL;
@@ -467,23 +464,16 @@ struct dma_async_tx_descriptor *re_jr_prep_dma_xor(
 	xor->data_depend = DATA_DEPENDENCY;
 	xor->dpi = ENABLE_DPI;
 
-	for (i = 0; i < src_cnt; i++) {
-		xor->gfm[i] = 1;
-		xor->dpi_src_spec[i].apps_mthd = 0x0;
-		xor->dpi_src_spec[i].ref_mthd = 0x0;
-		xor->dpi_src_spec[i].guard_mthd = 0x0;
-		xor->dpi_src_spec[i].dpi_attr = 0x0;
-		xor->dpi_src_spec[i].meta_tag = 0x0;
-		xor->dpi_src_spec[i].ref_tag = 0x0;
+	if (scf != NULL) {
+		/* compute q = src0*coef0^src1*coef1^..., * is GF(8) mult */
+		for (i = 0; i < src_cnt; i++)
+			xor->gfm[i] = scf[i];
+	} else {
+		/* compute P, that is XOR all srcs */
+		for (i = 0; i < src_cnt; i++)
+			xor->gfm[i] = 1;
 	}
 
-	xor->dpi_dest_spec.apps_mthd = 0x0;
-	xor->dpi_dest_spec.ref_mthd = 0x0;
-	xor->dpi_dest_spec.guard_mthd = 0x0;
-	xor->dpi_dest_spec.dpi_attr = 0x0;
-	xor->dpi_dest_spec.meta_tag = 0x0;
-	xor->dpi_dest_spec.ref_tag = 0x0;
-
 	/* Filling frame 0 of compound frame descriptor with CDB */
 	ret = fill_cfd_frame_with_cdb(cf, jr, xor, sizeof(struct xor_cdb));
 	if (ret < 0) {
@@ -536,6 +526,18 @@ err_free:
 }
 
 /*
+ * Prep function for P parity calculation.In RAID Engine terminology,
+ * XOR calculation is called GenQ calculation done through GenQ command
+ */
+static struct dma_async_tx_descriptor *re_jr_prep_dma_xor(
+		struct dma_chan *chan, dma_addr_t dest, dma_addr_t *src,
+		unsigned int src_cnt, size_t len, unsigned long flags)
+{
+	/* NULL let genq init all coef as 1 */
+	return re_jr_prep_genq(chan, dest, src, src_cnt, NULL, len, flags);
+}
+
+/*
  * Prep function for P/Q parity calculation.In RAID Engine terminology,
  * P/Q calculation is called GenQQ done through GenQQ command
  */
@@ -560,19 +562,36 @@ static struct dma_async_tx_descriptor *re_jr_prep_pq(
 	}
 
 	/*
+	 * RE requires at least 2 sources, here we give RE another source
+	 * if only given one source. The other source is same as the only
+	 * source.
+	 * With only one source, P should equal source. Expect no need to
+	 * generate P with only one source.
+	 */
+	if (src_cnt == 1) {
+		dma_addr_t dma_src[2];
+		unsigned char coef[2];
+		dma_src[0] = *src;
+		coef[0] = *scf;
+		dma_src[1] = *src;
+		coef[1] = 0;
+		return re_jr_prep_genq(chan, dest[1], dma_src, 2, coef, len,
+				flags);
+	}
+
+	/*
 	 * During RAID6 array creation, Linux's MD layer gets P and Q
 	 * calculated separately in two steps. But our RAID Engine has
 	 * the capability to calculate both P and Q with a single command
 	 * Hence to merge well with MD layer, we need to provide a hook
-	 * here and call re_jq_prep_dma_xor() function
+	 * here and call re_jq_prep_genq() function
 	 */
 
 	if (flags & DMA_PREP_PQ_DISABLE_P)
-		return re_jr_prep_dma_xor(chan, dest[1], src, src_cnt,
-				len, flags);
+		return re_jr_prep_genq(chan, dest[1], src, src_cnt,
+				scf, len, flags);
 
 	jr = container_of(chan, struct re_jr, chan);
-
 	spin_lock_bh(&jr->desc_lock);
 	if (jr->soft_desc->desc_cnt) {
 		desc = container_of(jr->soft_desc->head.next,
-- 
1.7.9.7

