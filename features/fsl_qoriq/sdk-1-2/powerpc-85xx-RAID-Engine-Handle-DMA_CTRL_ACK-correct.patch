From b3fa3fb0a8a2cd520f97f95e4300f19d67dfde34 Mon Sep 17 00:00:00 2001
From: Harninder Rai <harninder.rai@freescale.com>
Date: Fri, 2 Mar 2012 11:23:38 +0000
Subject: [PATCH 115/121] powerpc/85xx: RAID Engine: Handle DMA_CTRL_ACK
 correctly

* Descriptor which has this bit cleared will probably be reused
  by the upper layer, hence don't just free it up
* Store each such descriptor in another queue
* Parse that queue in the tasklet to see if this bit is set. If yes
  just go ahead and free it up
* Additionally, free up the memory for CDB and CF unconditionally

Signed-off-by: Harninder Rai <harninder.rai@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/dma/fsl_raid.c |   30 ++++++++++++++++++++++++++----
 drivers/dma/fsl_raid.h |    3 ++-
 2 files changed, 28 insertions(+), 5 deletions(-)

diff --git a/drivers/dma/fsl_raid.c b/drivers/dma/fsl_raid.c
index 9027288..3a3b391 100644
--- a/drivers/dma/fsl_raid.c
+++ b/drivers/dma/fsl_raid.c
@@ -7,7 +7,7 @@
  *	Harninder Rai <harninder.rai@freescale.com>
  *	Naveen Burmi <naveenburmi@freescale.com>
  *
- * Copyright (c) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (c) 2010-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -130,6 +130,7 @@ static void re_jr_dequeue(unsigned long data)
 	void *callback_param;
 	unsigned int count = 0;
 	unsigned int i = 0;
+	struct fsl_re_dma_async_tx_desc *ack_desc = NULL, *_ack_desc = NULL;
 
 	spin_lock_bh(&jr->desc_lock);
 
@@ -157,9 +158,14 @@ static void re_jr_dequeue(unsigned long data)
 			out_be32(&jr->jrregs->oubring_job_rmvd,
 					RE_JR_OUB_JOB_REMOVE);
 
-			if ((desc->async_tx.flags & DMA_CTRL_ACK)) {
-				kfree(desc->cf_addr);
-				kfree(desc->cdb_addr);
+			/* Free the cf/cdb address stored in descs
+			 * unconditionally. These pointers are only
+			 * required for RE driver's housekeeping
+			 */
+			kfree(desc->cf_addr);
+			kfree(desc->cdb_addr);
+
+			if (async_tx_test_ack(&desc->async_tx)) {
 				if (jr->soft_desc->desc_cnt <
 							MAX_INITIAL_DESCS) {
 					list_add(&desc->node,
@@ -169,6 +175,12 @@ static void re_jr_dequeue(unsigned long data)
 					kfree(desc);
 				}
 			}
+			/* Add descs which has DMA_CTRL_ACK bit cleared to
+			 * ack_q list.
+			 */
+			else {
+				list_add_tail(&desc->node, &jr->ack_q);
+			}
 
 			/* Call callback of upper layer */
 			if (callback) {
@@ -177,6 +189,15 @@ static void re_jr_dequeue(unsigned long data)
 				spin_lock_bh(&jr->desc_lock);
 			}
 		}
+
+		/* To save memory, parse the ack_q and free up descs */
+		list_for_each_entry_safe(ack_desc, _ack_desc, &jr->ack_q,
+					node) {
+			if (async_tx_test_ack(&ack_desc->async_tx)) {
+				list_del(&ack_desc->node);
+				kfree(ack_desc);
+			}
+		}
 	}
 
 	spin_unlock_bh(&jr->desc_lock);
@@ -868,6 +889,7 @@ int re_jr_probe(struct platform_device *ofdev,
 	jr->chan.private = jr;
 
 	INIT_LIST_HEAD(&jr->submit_q);
+	INIT_LIST_HEAD(&jr->ack_q);
 	spin_lock_init(&jr->desc_lock);
 	spin_lock_init(&jr->submit_lock);
 
diff --git a/drivers/dma/fsl_raid.h b/drivers/dma/fsl_raid.h
index 8ad09e9..2d83aea 100644
--- a/drivers/dma/fsl_raid.h
+++ b/drivers/dma/fsl_raid.h
@@ -7,7 +7,7 @@
  *	Harninder Rai <harninder.rai@freescale.com>
  *	Naveen Burmi <naveenburmi@freescale.com>
  *
- * Copyright (c) 2010-2011 Freescale Semiconductor, Inc.
+ * Copyright (c) 2010-2012 Freescale Semiconductor, Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -243,6 +243,7 @@ struct re_jr {
 	spinlock_t desc_lock;
 	spinlock_t submit_lock;
 	struct list_head submit_q;
+	struct list_head ack_q;
 	struct device *dev;
 	struct dma_chan chan;
 	struct jr_config_regs *jrregs;
-- 
1.7.9.7

