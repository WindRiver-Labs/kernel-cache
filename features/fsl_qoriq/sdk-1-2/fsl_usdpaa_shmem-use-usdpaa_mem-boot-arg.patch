From 5c026edf5ad1eb1082a725970f521ab6c298e514 Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Wed, 14 Mar 2012 04:49:46 +0000
Subject: [PATCH 081/121] fsl_usdpaa_shmem: use "usdpaa_mem=" boot-arg

USDPAA memory allocation is no longer controlled by a Kconfig-defined
constant, but by a boot-argument, "usdpaa_mem=<x>", where <x> supports
the same syntax as other memory boot-args. Eg. "256M", "512K", etc.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/misc/Kconfig            |   21 ---------------------
 drivers/misc/fsl_usdpaa_shmem.c |   36 ++++++++++++++++++++++++++++--------
 2 files changed, 28 insertions(+), 29 deletions(-)

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index e74fa62..784d71d 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -234,27 +234,6 @@ config FSL_USDPAA_SHMEM
 	  The intention is for this driver to be replaced by HugeTLB
 	  facilities, once they are available for USDPAA platforms.
 
-config FSL_USDPAA_SHMEM_LOG4
-	int "Log4 page-order of USDPAA memory reservation"
-	depends on FSL_USDPAA_SHMEM
-	range 7 9
-	default 8
-	help
-	  This configures the size of contiguous memory reserved for
-	  the USDPAA DMA memory map. It is carved out of the physical
-	  address-space early during boot, and cannot be released or
-	  resized thereafter. Some of this memory is used for seeding
-	  Bman buffer pools, and the remainder is for ad-hoc DMA buffer
-	  allocation (eg. Qman-stashable FQ contexts). Current USDPAA
-	  defaults require ~24MB for buffers.
-
-	  This region must be a power-of-four multiple of the page
-	  size (4KB), so the minimal usable value with the current
-	  USPAA (and the default) is 256MB (setting=8).
-
-	  For memory size 'x', the required setting is 'log4(x/4096)'.
-	  Or for setting 'x', the memory size will be '4096*(4^x)'.
-
 config SGI_XP
 	tristate "Support communication between SGI SSIs"
 	depends on NET
diff --git a/drivers/misc/fsl_usdpaa_shmem.c b/drivers/misc/fsl_usdpaa_shmem.c
index 93a6813..e3899d0 100644
--- a/drivers/misc/fsl_usdpaa_shmem.c
+++ b/drivers/misc/fsl_usdpaa_shmem.c
@@ -86,20 +86,40 @@ static struct miscdevice usdpaa_shmem_miscdev = {
 	.minor = MISC_DYNAMIC_MINOR,
 };
 
+/* Early-boot memory allocation. The boot-arg "usdpaa_mem=<x>" is used to
+ * indicate how much memory (if any) to allocate during early boot. */
+static __init int usdpaa_mem(char *arg)
+{
+	usdpaa_phys_size = memparse(arg, &arg);
+	return 0;
+}
+early_param("usdpaa_mem", usdpaa_mem);
+
 __init void fsl_usdpaa_shmem_init_early(void)
 {
-	u64 sz = (u64)PAGE_SIZE << (2 * CONFIG_FSL_USDPAA_SHMEM_LOG4);
-	u64 addr = memblock_alloc(sz, sz);
-	if (addr) {
-		usdpaa_phys_start = addr;
-		usdpaa_phys_size = sz;
-		usdpaa_pfn_start = (addr >> PAGE_SHIFT);
-		usdpaa_pfn_len = (sz >> PAGE_SHIFT);
+	int log;
+	if (!usdpaa_phys_size) {
+		pr_info("No USDPAA memory, no 'usdpaa_mem' bootarg\n");
+		return;
+	}
+	/* Size must be 4^x * 4096, for some x */
+	log = ilog2(usdpaa_phys_size);
+	if ((usdpaa_phys_size & (usdpaa_phys_size - 1)) || (log < 12) ||
+			(log & 1)) {
+		pr_err("'usdpaa_mem' bootarg must be 4096*4^x\n");
+		usdpaa_phys_size = 0;
+		return;
+	}
+	usdpaa_phys_start = memblock_alloc(usdpaa_phys_size, usdpaa_phys_size);
+	if (usdpaa_phys_start) {
+		usdpaa_pfn_start = (usdpaa_phys_start >> PAGE_SHIFT);
+		usdpaa_pfn_len = (usdpaa_phys_size >> PAGE_SHIFT);
 		usdpaa_tlbcam_index = tlbcam_index++;
 		pr_info("USDPAA region at %llx:%llx\n",
 			usdpaa_phys_start, usdpaa_phys_size);
 	} else
-		pr_err("Failed to reserve USDPAA region (sz:%llx)\n", sz);
+		pr_err("Failed to reserve USDPAA region (sz:%llx)\n",
+		       usdpaa_phys_size);
 }
 
 static int __init usdpaa_shmem_init(void)
-- 
1.7.9.7

