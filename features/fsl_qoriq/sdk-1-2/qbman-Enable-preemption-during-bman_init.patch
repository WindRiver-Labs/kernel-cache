From 758a72ae0f281df3b1a1b53dfae2d87ed0dbf601 Mon Sep 17 00:00:00 2001
From: Priyanka Jain <Priyanka.Jain@freescale.com>
Date: Fri, 20 Apr 2012 11:30:13 +0530
Subject: [PATCH 095/121] qbman: Enable preemption during bman_init

As bman_create_affine_portal() is affined to a particular core
by its caller, to keep the preemption disabled is not required.
Hence enable the preempion back.
This allows furthur code in the routine to sleep(a must
feature required for RT)

Signed-off-by: Priyanka Jain <Priyanka.Jain@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/bman_high.c |    7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index 5e97b4f..ae277ab 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -200,6 +200,12 @@ struct bman_portal *bman_create_affine_portal(
 	int ret;
 	u8 bpid = 0;
 
+	/* A criteria for calling this function (from bman_driver.c) is that
+	 * we're already affine to the cpu and won't schedule onto another cpu.
+	 * This means we can put_affine_portal() and yet continue to use
+	 * "portal", which in turn means aspects of this routine can sleep. */
+	put_affine_portal();
+
 	/* prep the low-level portal struct with the mapped addresses from the
 	 * config, everything that follows depends on it and "config" is more
 	 * for (de)reference... */
@@ -269,7 +275,6 @@ struct bman_portal *bman_create_affine_portal(
 	spin_unlock(&affine_mask_lock);
 	bm_isr_disable_write(__p, 0);
 	bm_isr_uninhibit(__p);
-	put_affine_portal();
 	return portal;
 fail_rcr_empty:
 fail_affinity:
-- 
1.7.9.7

