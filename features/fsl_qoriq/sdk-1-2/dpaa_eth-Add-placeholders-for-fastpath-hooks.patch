From f8b36df4a85b9beeba2f536362822295dfe62b0b Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Fri, 30 Mar 2012 21:50:31 +0300
Subject: [PATCH 107/128] dpaa_eth: Add placeholders for fastpath hooks

Added hook points in the datapath dequeue callbacks, which other modules
can use for intercepting FDs/skbs. Actual hooks are not defined (yet),
only a registration function is exported.

This required that the fqid be explicitly passed to internal processing
functions on the datapath (_dpa_rx() and friends).

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   86 ++++++++++++++++++++-----
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h |   76 ++++++++++++++++++++++
 2 files changed, 147 insertions(+), 15 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 8d7fb9f..3ed1ada 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -146,6 +146,14 @@ static const char rtx[][3] = {
 	[TX] = "TX"
 };
 
+#if defined(CONFIG_FSL_FMAN_TEST)
+/* Defined as weak, to be implemented by fman pcd tester. */
+int dpa_alloc_pcd_fqids(struct device *, uint32_t, uint8_t, uint32_t *)
+__attribute__((weak));
+
+int dpa_free_pcd_fqids(struct device *, uint32_t) __attribute__((weak));
+#endif /* CONFIG_DPAA_FMAN_UNIT_TESTS */
+
 /* BM */
 
 #define DPA_BP_HEAD (DPA_PRIV_DATA_SIZE + DPA_PARSE_RESULTS_SIZE + \
@@ -165,6 +173,22 @@ static struct dpa_bp *dpa_bp_array[64];
 
 static struct dpa_bp *default_pool;
 
+/* A set of callbacks for hooking into the fastpath at different points. */
+static struct dpaa_eth_hooks_s dpaa_eth_hooks;
+/*
+ * This function should only be called on the probe paths, since it makes no
+ * effort to guarantee consistency of the destination hooks structure.
+ */
+void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks)
+{
+	if (hooks)
+		dpaa_eth_hooks = *hooks;
+	else
+		pr_err("NULL pointer to hooks!\n");
+}
+EXPORT_SYMBOL(fsl_dpaa_eth_set_hooks);
+
+
 static struct dpa_bp *dpa_bpid2pool(int bpid)
 {
 	return dpa_bp_array[bpid];
@@ -850,12 +874,18 @@ dpa_csum_validation(const struct dpa_priv_s	*priv,
 static void _dpa_rx_error(struct net_device *net_dev,
 		const struct dpa_priv_s	*priv,
 		struct dpa_percpu_priv_s *percpu_priv,
-		const struct qm_fd *fd)
+		const struct qm_fd *fd,
+		u32 fqid)
 {
 	if (netif_msg_hw(priv) && net_ratelimit())
 		cpu_netdev_dbg(net_dev, "FD status = 0x%08x\n",
 				fd->status & FM_FD_STAT_ERRORS);
 
+	if (dpaa_eth_hooks.rx_error &&
+		dpaa_eth_hooks.rx_error(net_dev, fd, fqid) == DPAA_ETH_STOLEN)
+		/* it's up to the hook to perform resource cleanup */
+		return;
+
 	percpu_priv->stats.rx_errors++;
 
 	if (fd->status & FM_PORT_FRM_ERR_DMA)
@@ -875,7 +905,8 @@ static void _dpa_rx_error(struct net_device *net_dev,
 static void _dpa_tx_error(struct net_device		*net_dev,
 			  const struct dpa_priv_s	*priv,
 			  struct dpa_percpu_priv_s	*percpu_priv,
-			  const struct qm_fd		*fd)
+			  const struct qm_fd		*fd,
+			  u32				 fqid)
 {
 	struct sk_buff *skb;
 
@@ -883,6 +914,11 @@ static void _dpa_tx_error(struct net_device		*net_dev,
 		cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
 				fd->status & FM_FD_STAT_ERRORS);
 
+	if (dpaa_eth_hooks.tx_error &&
+		dpaa_eth_hooks.tx_error(net_dev, fd, fqid) == DPAA_ETH_STOLEN)
+		/* now the hook must ensure proper cleanup */
+		return;
+
 	percpu_priv->stats.tx_errors++;
 
 	skb = _dpa_cleanup_tx_fd(priv, fd);
@@ -892,7 +928,8 @@ static void _dpa_tx_error(struct net_device		*net_dev,
 static void __hot _dpa_rx(struct net_device *net_dev,
 		const struct dpa_priv_s *priv,
 		struct dpa_percpu_priv_s *percpu_priv,
-		const struct qm_fd *fd)
+		const struct qm_fd *fd,
+		u32 fqid)
 {
 	struct dpa_bp *dpa_bp;
 	struct sk_buff *skb;
@@ -954,6 +991,12 @@ static void __hot _dpa_rx(struct net_device *net_dev,
 	} else
 		skb->ip_summed = CHECKSUM_NONE;
 
+	/* Execute the Rx processing hook, if it exists. */
+	if (dpaa_eth_hooks.rx_default && dpaa_eth_hooks.rx_default(skb,
+		net_dev, fqid) == DPAA_ETH_STOLEN)
+		/* won't count the rx bytes in */
+		goto skb_stolen;
+
 	if (unlikely(netif_receive_skb(skb) == NET_RX_DROP))
 		percpu_priv->stats.rx_dropped++;
 	else {
@@ -961,6 +1004,7 @@ static void __hot _dpa_rx(struct net_device *net_dev,
 		percpu_priv->stats.rx_bytes += dpa_fd_length(fd);
 	}
 
+skb_stolen:
 	net_dev->last_rx = jiffies;
 
 	return;
@@ -1030,15 +1074,11 @@ static int dpaa_eth_poll(struct napi_struct *napi, int budget)
 static void __hot _dpa_tx(struct net_device		*net_dev,
 			  const struct dpa_priv_s	*priv,
 			  struct dpa_percpu_priv_s	*percpu_priv,
-			  const struct qm_fd		*fd)
+			  const struct qm_fd		*fd,
+			  u32				 fqid)
 {
 	struct sk_buff	*skb;
 
-	/* This might not perfectly reflect the reality, if the core dequeueing
-	 * the Tx confirmation is different from the one that did the enqueue,
-	 * but at least it'll show up in the total count. */
-	percpu_priv->tx_confirm++;
-
 	if (unlikely(fd->status & FM_FD_STAT_ERRORS) != 0) {
 		if (netif_msg_hw(priv) && net_ratelimit())
 			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
@@ -1047,6 +1087,16 @@ static void __hot _dpa_tx(struct net_device		*net_dev,
 		percpu_priv->stats.tx_errors++;
 	}
 
+	if (dpaa_eth_hooks.tx_confirm && dpaa_eth_hooks.tx_confirm(net_dev,
+		fd, fqid) == DPAA_ETH_STOLEN)
+		/* it's the hook that must now perform cleanup */
+		return;
+
+	/* This might not perfectly reflect the reality, if the core dequeueing
+	 * the Tx confirmation is different from the one that did the enqueue,
+	 * but at least it'll show up in the total count. */
+	percpu_priv->tx_confirm++;
+
 	skb = _dpa_cleanup_tx_fd(priv, fd);
 
 #ifdef CONFIG_FSL_DPA_1588
@@ -1428,6 +1478,12 @@ static int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	int queue_mapping;
 	int err;
 
+	/* If there is a Tx hook, run it. */
+	if (dpaa_eth_hooks.tx &&
+		dpaa_eth_hooks.tx(skb, net_dev) == DPAA_ETH_STOLEN)
+		/* won't update any Tx stats */
+		return NETDEV_TX_OK;
+
 	priv = netdev_priv(net_dev);
 	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
 
@@ -1532,7 +1588,7 @@ ingress_rx_error_dqrr(struct qman_portal		*portal,
 		return qman_cb_dqrr_stop;
 	}
 
-	_dpa_rx_error(net_dev, priv, percpu_priv, &dq->fd);
+	_dpa_rx_error(net_dev, priv, percpu_priv, &dq->fd, fq->fqid);
 
 	return qman_cb_dqrr_consume;
 }
@@ -1644,7 +1700,7 @@ ingress_rx_default_dqrr(struct qman_portal		*portal,
 
 	prefetchw(&percpu_priv->ingress_calls);
 
-	_dpa_rx(net_dev, priv, percpu_priv, &dq->fd);
+	_dpa_rx(net_dev, priv, percpu_priv, &dq->fd, fq->fqid);
 
 	return qman_cb_dqrr_consume;
 }
@@ -1668,7 +1724,7 @@ ingress_tx_error_dqrr(struct qman_portal		*portal,
 		return qman_cb_dqrr_stop;
 	}
 
-	_dpa_tx_error(net_dev, priv, percpu_priv, &dq->fd);
+	_dpa_tx_error(net_dev, priv, percpu_priv, &dq->fd, fq->fqid);
 
 	return qman_cb_dqrr_consume;
 }
@@ -1692,7 +1748,7 @@ ingress_tx_default_dqrr(struct qman_portal		*portal,
 		return qman_cb_dqrr_stop;
 	}
 
-	_dpa_tx(net_dev, priv, percpu_priv, &dq->fd);
+	_dpa_tx(net_dev, priv, percpu_priv, &dq->fd, fq->fqid);
 
 	return qman_cb_dqrr_consume;
 }
@@ -2865,7 +2921,7 @@ static int dpa_private_netdev_init(struct device_node *dpa_node,
 	return dpa_netdev_init(dpa_node, net_dev);
 }
 
-static int dpa_alloc_pcd_fqids(struct device *dev, uint32_t num,
+int dpa_alloc_pcd_fqids(struct device *dev, uint32_t num,
 				uint8_t alignment, uint32_t *base_fqid)
 {
 	dpaa_eth_crit(dev, "callback not implemented!\n");
@@ -2874,7 +2930,7 @@ static int dpa_alloc_pcd_fqids(struct device *dev, uint32_t num,
 	return 0;
 }
 
-static int dpa_free_pcd_fqids(struct device *dev, uint32_t base_fqid)
+int dpa_free_pcd_fqids(struct device *dev, uint32_t base_fqid)
 {
 
 	dpaa_eth_crit(dev, "callback not implemented!\n");
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 143bf76..44adca0 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -54,6 +54,76 @@
 #define DPAA_ETH_TX_QUEUES	8
 #define DPAA_ETH_RX_QUEUES	128
 
+#if defined(CONFIG_DPAA_FMAN_UNIT_TESTS)
+/*TODO: temporary for fman pcd testing */
+#define FMAN_PCD_TESTS_MAX_NUM_RANGES	20
+#endif
+
+/* return codes for the dpaa-eth hooks */
+enum dpaa_eth_hook_result {
+	/* fd/skb was retained by the hook.
+	 *
+	 * On the Rx path, this means the Ethernet driver will _not_
+	 * deliver the skb to the stack. Instead, the hook implementation
+	 * is expected to properly dispose of the skb.
+	 *
+	 * On the Tx path, the Ethernet driver's dpa_tx() function will
+	 * immediately return NETDEV_TX_OK. The hook implementation is expected
+	 * to free the skb. *DO*NOT* release it to BMan, or enqueue it to FMan,
+	 * unless you know exactly what you're doing!
+	 *
+	 * On the confirmation/error paths, the Ethernet driver will _not_
+	 * perform any fd cleanup, nor update the interface statistics.
+	 */
+	DPAA_ETH_STOLEN,
+	/*
+	 * fd/skb was returned to the Ethernet driver for regular processing.
+	 * The hook is not allowed to, for instance, reallocate the skb (as if
+	 * by linearizing, copying, cloning or reallocating the headroom).
+	 */
+	DPAA_ETH_CONTINUE
+};
+
+typedef enum dpaa_eth_hook_result (*dpaa_eth_ingress_hook_t)(
+		struct sk_buff *skb, struct net_device *net_dev, u32 fqid);
+typedef enum dpaa_eth_hook_result (*dpaa_eth_egress_hook_t)(
+		struct sk_buff *skb, struct net_device *net_dev);
+typedef enum dpaa_eth_hook_result (*dpaa_eth_confirm_hook_t)(
+		struct net_device *net_dev, const struct qm_fd *fd, u32 fqid);
+
+/*
+ * Various hooks used for unit-testing and/or fastpath optimizations.
+ * Currently only one set of such hooks is supported.
+ */
+struct dpaa_eth_hooks_s {
+	/*
+	 * Invoked on the Tx private path, immediately after receiving the skb
+	 * from the stack.
+	 */
+	dpaa_eth_egress_hook_t	tx;
+
+	/*
+	 * Invoked on the Rx private path, right before passing the skb
+	 * up the stack. At that point, the packet's protocol id has already
+	 * been set. The skb's data pointer is now at the L3 header, and
+	 * skb->mac_header points to the L2 header. skb->len has been adjusted
+	 * to be the length of L3+payload (i.e., the length of the
+	 * original frame minus the L2 header len).
+	 * For more details on what the skb looks like, see eth_type_trans().
+	 */
+	dpaa_eth_ingress_hook_t	rx_default;
+
+	/* Driver hook for the Rx error private path. */
+	dpaa_eth_confirm_hook_t	rx_error;
+	/* Driver hook for the Tx confirmation private path. */
+	dpaa_eth_confirm_hook_t	tx_confirm;
+	/* Driver hook for the Tx error private path. */
+	dpaa_eth_confirm_hook_t	tx_error;
+};
+
+void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
+
+
 struct pcd_range {
 	uint32_t			 base;
 	uint32_t			 count;
@@ -126,6 +196,12 @@ struct dpa_priv_s {
 
 	uint32_t		 msg_enable;	/* net_device message level */
 	struct dpa_ptp_tsu	 *tsu;
+
+#if defined(CONFIG_DPAA_FMAN_UNIT_TESTS)
+/* TODO: this is temporary until pcd support is implemented in dpaa */
+	int			priv_pcd_num_ranges;
+	struct pcd_range	priv_pcd_ranges[FMAN_PCD_TESTS_MAX_NUM_RANGES];
+#endif
 };
 
 extern const struct ethtool_ops dpa_ethtool_ops;
-- 
1.7.9.7

