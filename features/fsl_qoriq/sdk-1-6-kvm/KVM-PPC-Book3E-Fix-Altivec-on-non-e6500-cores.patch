From 2627e0bb46a97406abdf6528f66c50b997b77b40 Mon Sep 17 00:00:00 2001
From: Mihai Caraman <mihai.caraman@freescale.com>
Date: Tue, 21 May 2013 23:21:48 +0300
Subject: [PATCH] KVM: PPC: Book3E: Fix Altivec on non e6500 cores

commit 2627e0bb46a97406abdf6528f66c50b997b77b40 git://git.freescale.com/ppc/sdk/linux.git

Check Altivec cpu feature at run time to allow KVM kernels configured with
CONFIG_ALTIVEC to run on non e6500 cores.

Signed-off-by: Mihai Caraman <mihai.caraman@freescale.com>
Change-Id: I1ad9e1574122c8ab8ebac71968255d7c5a51da84
Reviewed-on: http://git.am.freescale.net:8181/2630
Reviewed-by: Wood Scott-B07421 <scottwood@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Signed-off-by: Vu Tran <vu.tran@windriver.com>

diff --git a/arch/powerpc/kvm/booke.c b/arch/powerpc/kvm/booke.c
index d49594ce..3dd223d 100644
--- a/arch/powerpc/kvm/booke.c
+++ b/arch/powerpc/kvm/booke.c
@@ -729,7 +729,7 @@ int kvmppc_vcpu_run(struct kvm_run *kvm_run, struct kvm_vcpu *vcpu)
 #ifdef CONFIG_ALTIVEC
 	vector128 vr[32];
 	vector128 vscr;
-	int used_vr;
+	int used_vr = 0;
 #endif
 
 	if (!vcpu->arch.sane) {
@@ -768,21 +768,23 @@ int kvmppc_vcpu_run(struct kvm_run *kvm_run, struct kvm_vcpu *vcpu)
 #endif
 
 #ifdef CONFIG_ALTIVEC
-	/* Save userspace VEC state in stack */
-	enable_kernel_altivec();
-	memcpy(vr, current->thread.vr_state.vr,
-	       sizeof(current->thread.vr_state.vr));
-	vscr = current->thread.vr_state.vscr;
-	used_vr = current->thread.used_vr;
-
-	/* Restore guest VEC state to thread */
-	memcpy(current->thread.vr_state.vr, vcpu->arch.vr,
-	       sizeof(vcpu->arch.vr));
-	current->thread.vr_state.vscr = vcpu->arch.vscr;
-
-	vcpu->arch.vec_active = 1;
-
-	kvmppc_load_guest_altivec(vcpu);
+	if (cpu_has_feature(CPU_FTR_ALTIVEC)) {
+		/* Save userspace VEC state in stack */
+		enable_kernel_altivec();
+		memcpy(vr, current->thread.vr_state.vr,
+		       sizeof(current->thread.vr_state.vr));
+		vscr = current->thread.vr_state.vscr;
+		used_vr = current->thread.used_vr;
+
+		/* Restore guest VEC state to thread */
+		memcpy(current->thread.vr_state.vr, vcpu->arch.vr,
+		       sizeof(vcpu->arch.vr));
+		current->thread.vr_state.vscr = vcpu->arch.vscr;
+
+		vcpu->arch.vec_active = 1;
+
+		kvmppc_load_guest_altivec(vcpu);
+	}
 #endif
 
 	/*
@@ -822,20 +824,22 @@ int kvmppc_vcpu_run(struct kvm_run *kvm_run, struct kvm_vcpu *vcpu)
 #endif
 
 #ifdef CONFIG_ALTIVEC
-	kvmppc_save_guest_altivec(vcpu);
+	if (cpu_has_feature(CPU_FTR_ALTIVEC)) {
+		kvmppc_save_guest_altivec(vcpu);
 
-	vcpu->arch.vec_active = 0;
+		vcpu->arch.vec_active = 0;
 
-	/* Save guest VEC state from thread */
-	memcpy(vcpu->arch.vr, current->thread.vr_state.vr,
-	       sizeof(vcpu->arch.vr));
-	vcpu->arch.vscr = current->thread.vr_state.vscr;
+		/* Save guest VEC state from thread */
+		memcpy(vcpu->arch.vr, current->thread.vr_state.vr,
+		       sizeof(vcpu->arch.vr));
+		vcpu->arch.vscr = current->thread.vr_state.vscr;
 
-	/* Restore userspace VEC state from stack */
-	memcpy(current->thread.vr_state.vr, vr,
-	       sizeof(current->thread.vr_state.vr));
-	current->thread.vr_state.vscr = vscr;
-	current->thread.used_vr = used_vr;
+		/* Restore userspace VEC state from stack */
+		memcpy(current->thread.vr_state.vr, vr,
+		       sizeof(current->thread.vr_state.vr));
+		current->thread.vr_state.vscr = vscr;
+		current->thread.used_vr = used_vr;
+	}
 #endif
 
 out:
-- 
1.9.1

