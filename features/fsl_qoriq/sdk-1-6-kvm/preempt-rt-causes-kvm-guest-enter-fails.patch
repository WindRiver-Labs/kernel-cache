From 8defb06e45af04e58529722876c27f5dd8e4dca1 Mon Sep 17 00:00:00 2001
From: Vu Tran <vu.tran@windriver.com>
Date: Wed, 26 Nov 2014 10:15:48 -0500
Subject: [PATCH] preempt-rt causes kvm-guest-enter fails

Generic kvm function kvm_guest_enter() requires preemption
disabled.  When preempt-rt is turned on, this condition is
not met.  So explicitly disable preemption before
calling kvm_guest_enter() and reenable preemption after
calling kvm_guest_exit().

However, with this, the following 2 conditions some time
are not met:

   WARN_ON(local_paca->irq_happened != PACA_IRQ_HARD_DIS);
   WARN_ON(mfmsr() & MSR_EE);

and cause warning messages printed out in dmesg.  However,
it seems like that the system behave normally when these
warning messages are printed out.  For now change code
to print out these warnings just once until further
investigation to find better solution.

Signed-off-by: Vu Tran <vu.tran@windriver.com>

diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h
index e4474f8..1c4bcb1 100644
--- a/arch/powerpc/include/asm/kvm_ppc.h
+++ b/arch/powerpc/include/asm/kvm_ppc.h
@@ -408,7 +408,9 @@ static inline void kvmppc_fix_ee_before_entry(void)
 	 * To avoid races, the caller must have gone directly from having
 	 * interrupts fully-enabled to hard-disabled.
 	 */
-	WARN_ON(local_paca->irq_happened != PACA_IRQ_HARD_DIS);
+	/* TODO: investigate why this condition is true when running full preempt-rt */
+	WARN_ONCE(local_paca->irq_happened != PACA_IRQ_HARD_DIS,
+			"Warning KVM: local_paca->irq_happened != PACA_IRQ_HARD_DIS");
 
 	/* Only need to enable IRQs by hard enabling them after this */
 	local_paca->irq_happened = 0;
diff --git a/arch/powerpc/kvm/booke.c b/arch/powerpc/kvm/booke.c
index cc391aa..d8bf221 100644
--- a/arch/powerpc/kvm/booke.c
+++ b/arch/powerpc/kvm/booke.c
@@ -1010,6 +1010,7 @@ int kvmppc_handle_exit(struct kvm_run *run, struct kvm_vcpu *vcpu,
 
 	trace_kvm_exit(exit_nr, vcpu);
 	kvm_guest_exit();
+	preempt_enable();
 
 	run->exit_reason = KVM_EXIT_UNKNOWN;
 	run->ready_for_interrupt_injection = 1;
diff --git a/arch/powerpc/kvm/powerpc.c b/arch/powerpc/kvm/powerpc.c
index 832e043..cca724f 100644
--- a/arch/powerpc/kvm/powerpc.c
+++ b/arch/powerpc/kvm/powerpc.c
@@ -109,11 +109,13 @@ int kvmppc_prepare_to_enter(struct kvm_vcpu *vcpu)
 			continue;
 		}
 
+		preempt_disable();
 #ifdef CONFIG_PPC64
 		WARN_ON(lazy_irq_pending());
 #endif
 		/* Can't use irqs_disabled() because we want hard irq state */
-		WARN_ON(mfmsr() & MSR_EE);
+		/* TODO: investigate why this condition is true when running full preempt-rt */
+		WARN_ONCE(mfmsr() & MSR_EE, "Warning KVM: mfmsr() & MSR_EE");
 
 		kvm_guest_enter();
 		return r;
-- 
1.9.1

