From c43678730ed1916e7c2977ae1cbe7962a037ca8b Mon Sep 17 00:00:00 2001
From: Alison Wang <b18965@freescale.com>
Date: Wed, 7 Sep 2016 14:29:06 +0800
Subject: [PATCH 106/388] armv8: aarch32: Add SMP support for 32-bit Linux
 kernel

The patch adds SMP support for running 32-bit Linux kernel for
Layerscape platforms. Spin-table method is used for SMP support.

Signed-off-by: Alison Wang <alison.wang@nxp.com>
Signed-off-by: Chenhui Zhao <chenhui.zhao@nxp.com>
[Original patch taken from SDK-V2.0-1703]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 arch/arm/mach-imx/common.h          |  2 +-
 arch/arm/mach-imx/mach-layerscape.c |  1 +
 arch/arm/mach-imx/platsmp.c         | 49 +++++++++++++++++++++++++++++++++++++
 3 files changed, 51 insertions(+), 1 deletion(-)

diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index 0f04e30..3570ad0 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -157,5 +157,5 @@ static inline void imx_init_l2cache(void) {}
 
 extern struct smp_operations imx_smp_ops;
 extern struct smp_operations ls1021a_smp_ops;
-
+extern const struct smp_operations layerscape_smp_ops;
 #endif
diff --git a/arch/arm/mach-imx/mach-layerscape.c b/arch/arm/mach-imx/mach-layerscape.c
index acfb2a2..109d488 100644
--- a/arch/arm/mach-imx/mach-layerscape.c
+++ b/arch/arm/mach-imx/mach-layerscape.c
@@ -19,5 +19,6 @@ static const char * const layerscape_dt_compat[] __initconst = {
 };
 
 DT_MACHINE_START(LAYERSCAPE_AARCH32, "Freescale LAYERSCAPE")
+	.smp		= smp_ops(layerscape_smp_ops),
 	.dt_compat	= layerscape_dt_compat,
 MACHINE_END
diff --git a/arch/arm/mach-imx/platsmp.c b/arch/arm/mach-imx/platsmp.c
index 7f27001..cfac6de 100644
--- a/arch/arm/mach-imx/platsmp.c
+++ b/arch/arm/mach-imx/platsmp.c
@@ -14,6 +14,7 @@
 #include <linux/of_address.h>
 #include <linux/of.h>
 #include <linux/smp.h>
+#include <linux/types.h>
 
 #include <asm/cacheflush.h>
 #include <asm/page.h>
@@ -26,6 +27,8 @@
 u32 g_diag_reg;
 static void __iomem *scu_base;
 
+static u64 cpu_release_addr[NR_CPUS];
+
 static struct map_desc scu_io_desc __initdata = {
 	/* .virtual and .pfn are run-time assigned */
 	.length		= SZ_4K,
@@ -127,3 +130,49 @@ struct smp_operations  ls1021a_smp_ops __initdata = {
 	.smp_prepare_cpus	= ls1021a_smp_prepare_cpus,
 	.smp_boot_secondary	= ls1021a_boot_secondary,
 };
+
+static int layerscape_smp_boot_secondary(unsigned int cpu,
+					 struct task_struct *idle)
+{
+	u32 secondary_startup_phys;
+	__le32 __iomem *release_addr;
+
+	secondary_startup_phys = virt_to_phys(secondary_startup);
+
+	release_addr = ioremap_cache((u32)cpu_release_addr[cpu],
+				     sizeof(u64));
+	if (!release_addr)
+		return -ENOMEM;
+
+	writel_relaxed(secondary_startup_phys, release_addr);
+	writel_relaxed(0, release_addr + 1);
+	__cpuc_flush_dcache_area((__force void *)release_addr,
+				 sizeof(u64));
+
+	sev();
+
+	iounmap(release_addr);
+
+	return 0;
+}
+
+static void layerscape_smp_init_cpus(void)
+{
+	struct device_node *dnt = NULL;
+	unsigned int cpu = 0;
+
+	while ((dnt = of_find_node_by_type(dnt, "cpu"))) {
+		if (of_property_read_u64(dnt, "cpu-release-addr",
+		    &cpu_release_addr[cpu])) {
+			pr_err("CPU %d: missing or invalid cpu-release-addr property\n",
+			cpu);
+		}
+
+		cpu++;
+	}
+}
+
+const struct smp_operations layerscape_smp_ops __initconst = {
+	.smp_init_cpus		= layerscape_smp_init_cpus,
+	.smp_boot_secondary	= layerscape_smp_boot_secondary,
+};
-- 
2.9.3

