From c47c2807e12b5d8c60be20b8fcd561786e1376ab Mon Sep 17 00:00:00 2001
From: Iordache Florinel-R70177 <florinel.iordache@nxp.com>
Date: Mon, 10 Oct 2016 11:16:27 +0300
Subject: [PATCH 059/388] QLINUX-6077: A-007273: FMAN hangs at FM reset done
 with MACs clocks disabled

[Original patch taken from SDK-V2.0-1703]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 .../freescale/sdk_fman/Peripherals/FM/fm.c         | 57 ++++++++---------
 .../freescale/sdk_fman/Peripherals/FM/fm.h         |  2 +
 .../sdk_fman/Peripherals/FM/inc/fm_common.h        | 11 ++++
 .../freescale/sdk_fman/inc/Peripherals/fm_ext.h    | 26 ++++++++
 .../freescale/sdk_fman/src/wrapper/lnxwrp_fm.c     | 71 ++++++++++++++++++++++
 5 files changed, 139 insertions(+), 28 deletions(-)

diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c
index 5cd04f7..d8e1433 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.c
@@ -1920,6 +1920,19 @@ uint8_t FmGetId(t_Handle h_Fm)
     return p_Fm->p_FmStateStruct->fmId;
 }
 
+t_Error FmReset(t_Handle h_Fm)
+{
+	t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
+    CORE_MemoryBarrier();
+    XX_UDelay(100);
+
+    return E_OK;
+}
+
 t_Error FmSetNumOfRiscsPerPort(t_Handle     h_Fm,
                                uint8_t      hardwarePortId,
                                uint8_t      numOfFmanCtrls,
@@ -3429,6 +3442,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmStateStruct->extraFifoPoolSize    = 0;
     p_Fm->p_FmStateStruct->exceptions           = DEFAULT_exceptions;
     p_Fm->resetOnInit                          = DEFAULT_resetOnInit;
+    p_Fm->f_ResetOnInitOverride                = DEFAULT_resetOnInitOverrideCallback;
     p_Fm->fwVerify                             = DEFAULT_VerifyUcode;
     p_Fm->firmware.size                        = p_FmParam->firmware.size;
     if (p_Fm->firmware.size)
@@ -3567,21 +3581,9 @@ t_Error FM_Init(t_Handle h_Fm)
         if ((err = FwNotResetErratumBugzilla6173WA(p_Fm)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 #else  /* not FM_UCODE_NOT_RESET_ERRATA_BUGZILLA6173 */
-#ifndef CONFIG_FMAN_ARM
-        {
-            u32 svr = mfspr(SPRN_SVR);
-            u32 disr2 = 0;
-            struct ccsr_guts __iomem *ccsr_guts_regs = NULL;
 
-            if (((SVR_SOC_VER(svr) == SVR_T4240 && SVR_REV(svr) > 0x10)) ||
-                ((SVR_SOC_VER(svr) == SVR_T4160 && SVR_REV(svr) > 0x10)) ||
-                ((SVR_SOC_VER(svr) == SVR_T4080 && SVR_REV(svr) > 0x10)) ||
-                (SVR_SOC_VER(svr) == SVR_T1024) ||
-                (SVR_SOC_VER(svr) == SVR_T1023) ||
-                (SVR_SOC_VER(svr) == SVR_T2080) ||
-                (SVR_SOC_VER(svr) == SVR_T2081)) {
-
-		ccsr_guts_regs = Fm_GetCcsrGutsReg();
+        if (p_Fm->f_ResetOnInitOverride)
+        {
 
 		if (ccsr_guts_regs) {
 			/* Get the origin value of devdisr2. */
@@ -3591,20 +3593,6 @@ t_Error FM_Init(t_Handle h_Fm)
 		}
 	}
 
-	WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
-	CORE_MemoryBarrier();
-	XX_UDelay(100);
-
-#ifdef FM_SOFT_REST_IS_NOT_FINISHED_PROPERLY_A007273
-	if (disr2 && ccsr_guts_regs) {
-		/* Restore the value of devdisr2. */
-		iowrite32be(disr2, &ccsr_guts_regs->devdisr2);
-	}
-	if (ccsr_guts_regs)
-		iounmap(ccsr_guts_regs);
-	}
-#endif/* FM_SOFT_REST_IS_NOT_FINISHED_PROPERLY_A007273 */
-#endif /* FMAN_ARM */
         if (fman_is_qmi_halt_not_busy_state(p_Fm->p_FmQmiRegs))
         {
             fman_resume(p_Fm->p_FmFpmRegs);
@@ -3867,6 +3855,19 @@ t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable)
     return E_OK;
 }
 
+t_Error FM_ConfigResetOnInitOverrideCallback(t_Handle h_Fm, t_FmResetOnInitOverrideCallback *f_ResetOnInitOverride)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
+
+    p_Fm->f_ResetOnInitOverride = f_ResetOnInitOverride;
+
+    return E_OK;
+}
+
 t_Error FM_ConfigTotalFifoSize(t_Handle h_Fm, uint32_t totalFifoSize)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.h
index fc7662d..0bded75 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/fm.h
@@ -296,6 +296,7 @@ switch (exception){                                         \
 #define DEFAULT_catastrophicErr             e_FM_CATASTROPHIC_ERR_STALL_PORT
 #define DEFAULT_dmaErr                      e_FM_DMA_ERR_CATASTROPHIC
 #define DEFAULT_resetOnInit                 FALSE
+#define DEFAULT_resetOnInitOverrideCallback NULL
 #define DEFAULT_haltOnExternalActivation    FALSE   /* do not change! if changed, must be disabled for rev1 ! */
 #define DEFAULT_haltOnUnrecoverableEccError FALSE   /* do not change! if changed, must be disabled for rev1 ! */
 #define DEFAULT_externalEccRamsEnable       FALSE
@@ -639,6 +640,7 @@ typedef struct t_Fm
     t_FmFirmwareParams          firmware;
     bool                        fwVerify;
     bool                        resetOnInit;
+    t_FmResetOnInitOverrideCallback     *f_ResetOnInitOverride;
     uint32_t                    userSetExceptions;
 } t_Fm;
 
diff --git a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/inc/fm_common.h
index eb153d9..204840c 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/Peripherals/FM/inc/fm_common.h
@@ -1070,6 +1070,17 @@ uint16_t FmGetMacClockFreq(t_Handle h_Fm);
 uint8_t FmGetId(t_Handle h_Fm);
 
 /**************************************************************************//**
+ @Function      FmReset
+
+ @Description   Used to reset the FM
+
+ @Param[in]     h_Fm            A handle to an FM Module.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FmReset(t_Handle h_Fm);
+
+/**************************************************************************//**
  @Function      FmGetSetPortParams
 
  @Description   Used by FM-PORT driver to pass and receive parameters between
diff --git a/drivers/net/ethernet/freescale/sdk_fman/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/sdk_fman/inc/Peripherals/fm_ext.h
index efbe6d3..a8a6438 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/sdk_fman/inc/Peripherals/fm_ext.h
@@ -686,6 +686,15 @@ typedef struct t_FmDmaThresholds {
                                                                  until this value is reached (Hystheresis) */
 } t_FmDmaThresholds;
 
+/**************************************************************************//**
+ @Function      t_FmResetOnInitOverrideCallback
+
+ @Description   FMan specific reset on init user callback routine,
+                will be used to override the standard FMan reset on init procedure
+
+ @Param[in]     h_Fm  - FMan handler
+*//***************************************************************************/
+typedef void (t_FmResetOnInitOverrideCallback)(t_Handle h_Fm);
 
 /**************************************************************************//**
  @Function      FM_ConfigResetOnInit
@@ -705,6 +714,23 @@ typedef struct t_FmDmaThresholds {
 t_Error FM_ConfigResetOnInit(t_Handle h_Fm, bool enable);
 
 /**************************************************************************//**
+ @Function      FM_ConfigResetOnInitOverrideCallback
+
+ @Description   Define a special reset of FM before initialization.
+                Change the default configuration [DEFAULT_resetOnInitOverrideCallback].
+
+ @Param[in]     h_Fm                	A handle to an FM Module.
+ @Param[in]     f_ResetOnInitOverride   FM specific reset on init user callback routine.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Config() and before FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_ConfigResetOnInitOverrideCallback(t_Handle h_Fm, t_FmResetOnInitOverrideCallback *f_ResetOnInitOverride);
+
+/**************************************************************************//**
  @Function      FM_ConfigTotalFifoSize
 
  @Description   Define Total FIFO size for the whole FM.
diff --git a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
index 904bd88..c039e23 100644
--- a/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/sdk_fman/src/wrapper/lnxwrp_fm.c
@@ -63,6 +63,7 @@
 #ifndef CONFIG_FMAN_ARM
 #include <sysdev/fsl_soc.h>
 #include <linux/fsl/guts.h>
+#include <linux/fsl/svr.h>
 #endif
 #include <linux/stat.h>	   /* For file access mask */
 #include <linux/skbuff.h>
@@ -949,6 +950,60 @@ static unsigned int get_rcwsr(int regnum)
 
 	return ioread32be(&guts_regs->rcwsr[regnum]);
 }
+
+#define FMAN1_ALL_MACS_MASK	0xFCC00000
+#define FMAN2_ALL_MACS_MASK	0x000FCC00
+
+/**
+ * @Function      	ResetOnInitErrata_A007273
+ *
+ * @Description		Workaround for Errata A-007273
+ * 					This workaround is required to avoid a FMan hang during reset on initialization.
+ * 					Enable all MACs in guts.devdisr2 register,
+ * 					then perform a regular FMan reset and then restore MACs to their original state.
+ *
+ * @Param[in]     h_Fm - FM module descriptor
+ *
+ * @Return        None.
+ */
+void ResetOnInitErrata_A007273(t_Handle h_Fm)
+{
+	struct ccsr_guts __iomem *guts_regs = NULL;
+	struct device_node *guts_node;
+	u32 devdisr2, enableMacs;
+
+	/* Get guts registers */
+	guts_node = of_find_matching_node(NULL, guts_device_ids);
+	if (!guts_node) {
+		pr_err("could not find GUTS node\n");
+		return;
+	}
+	guts_regs = of_iomap(guts_node, 0);
+	of_node_put(guts_node);
+	if (!guts_regs) {
+		pr_err("ioremap of GUTS node failed\n");
+		return;
+	}
+
+	/* Read current state */
+	devdisr2 = ioread32be(&guts_regs->devdisr2);
+
+	if (FmGetId(h_Fm) == 0)
+		enableMacs = devdisr2 & ~FMAN1_ALL_MACS_MASK;
+	else
+		enableMacs = devdisr2 & ~FMAN2_ALL_MACS_MASK;
+
+	/* Enable all MACs */
+	iowrite32be(enableMacs, &guts_regs->devdisr2);
+
+	/* Perform standard FMan reset */
+	FmReset(h_Fm);
+
+	/* Restore devdisr2 value */
+	iowrite32be(devdisr2, &guts_regs->devdisr2);
+
+	iounmap(guts_regs);
+}
 #endif
 
 static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
@@ -1027,6 +1082,22 @@ static t_Error InitFmDev(t_LnxWrpFmDev  *p_LnxWrpFmDev)
     if (FM_ConfigResetOnInit(p_LnxWrpFmDev->h_Dev, TRUE) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
 
+#ifndef CONFIG_FMAN_ARM
+    u32 svr = mfspr(SPRN_SVR);
+
+    if (((SVR_SOC_VER(svr) == SVR_T4240 && SVR_REV(svr) > 0x10)) ||
+        ((SVR_SOC_VER(svr) == SVR_T4160 && SVR_REV(svr) > 0x10)) ||
+        ((SVR_SOC_VER(svr) == SVR_T4080 && SVR_REV(svr) > 0x10)) ||
+        (SVR_SOC_VER(svr) == SVR_T1024) ||
+        (SVR_SOC_VER(svr) == SVR_T1023) ||
+        (SVR_SOC_VER(svr) == SVR_T2080) ||
+        (SVR_SOC_VER(svr) == SVR_T2081))
+    {
+        if (FM_ConfigResetOnInitOverrideCallback(p_LnxWrpFmDev->h_Dev, ResetOnInitErrata_A007273) != E_OK)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
+    }
+#endif
+
 #ifdef CONFIG_FMAN_P1023
     if (FM_ConfigDmaAidOverride(p_LnxWrpFmDev->h_Dev, TRUE) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("FM"));
-- 
2.9.3

