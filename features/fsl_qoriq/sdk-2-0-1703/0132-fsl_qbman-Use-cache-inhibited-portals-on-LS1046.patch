From 94ff8c1ae56a6e51a9ecdac55beae52fc104380b Mon Sep 17 00:00:00 2001
From: Roy Pledge <roy.pledge@nxp.com>
Date: Mon, 24 Oct 2016 19:50:05 -0400
Subject: [PATCH 132/388] fsl_qbman: Use cache inhibited portals on LS1046

Use cache inhibited portal mappings for LS1046 devices

Signed-off-by: Roy Pledge <roy.pledge@nxp.com>
[Original patch taken from SDK-V2.0-1703]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl_qbman/bman_driver.c  | 35 ++++++++++++++++++++++++++++----
 drivers/staging/fsl_qbman/qman_driver.c  | 34 ++++++++++++++++++++++++++-----
 drivers/staging/fsl_qbman/qman_high.c    |  2 +-
 drivers/staging/fsl_qbman/qman_private.h |  2 ++
 4 files changed, 63 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 0e65fb6..c466876 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -32,6 +32,8 @@
 #ifdef CONFIG_HOTPLUG_CPU
 #include <linux/cpu.h>
 #endif
+#include <linux/sys_soc.h>
+
 /*
  * Global variables of the max portal/pool number this bman version supported
  */
@@ -103,13 +105,25 @@ static int __init fsl_bpid_range_init(struct device_node *node)
 	return 0;
 }
 
+#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
+static struct soc_device_attribute soc_msi_matches[] = {
+	{
+		.family = "QorIQ LS1046A",
+		.data = NULL
+	},
+	{},
+};
+#endif
+
 static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 {
 	struct bm_portal_config *pcfg;
 	const u32 *index;
 	int irq, ret;
 	resource_size_t len;
-
+#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
+	const struct soc_device_attribute *match;
+#endif
 	pcfg = kmalloc(sizeof(*pcfg), GFP_KERNEL);
 	if (!pcfg) {
 		pr_err("can't allocate portal config");
@@ -191,9 +205,22 @@ static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 		goto err;
 
 #if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
-	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_cache_ns(
-                                pcfg->addr_phys[DPA_PORTAL_CE].start,
-                                resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]));
+
+	/* Check for LS1046A device as we need to use a
+	   cache-inhibited write combine mapping for that part */
+	match = soc_device_match(soc_msi_matches);
+	if (match)
+		pcfg->addr_virt[DPA_PORTAL_CE] =
+			ioremap_wc(pcfg->addr_phys[DPA_PORTAL_CE].start,
+				   resource_size(&pcfg->
+						 addr_phys[DPA_PORTAL_CE]));
+	else
+		pcfg->addr_virt[DPA_PORTAL_CE] =
+			ioremap_cache_ns(
+					 pcfg->addr_phys[DPA_PORTAL_CE].start,
+					 resource_size(&pcfg->addr_phys
+						       [DPA_PORTAL_CE]));
+
         pcfg->addr_virt[DPA_PORTAL_CI] = ioremap(
                                 pcfg->addr_phys[DPA_PORTAL_CI].start,
                                 resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]));
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 7f90ddf..d827f79 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -30,6 +30,7 @@
  */
 
 #include "qman_private.h"
+#include <linux/sys_soc.h>
 
 #include <asm/smp.h>	/* hard_smp_processor_id() if !CONFIG_SMP */
 #ifdef CONFIG_HOTPLUG_CPU
@@ -372,6 +373,16 @@ static void qman_get_ip_revision(struct device_node *dn)
 	}
 }
 
+#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
+static struct soc_device_attribute soc_msi_matches[] = {
+	{
+		.family = "QorIQ LS1046A",
+		.data = NULL
+	},
+	{},
+};
+#endif
+
 /* Parse a portal node, perform generic mapping duties and return the config. It
  * is not known at this stage for what purpose (or even if) the portal will be
  * used. */
@@ -382,8 +393,11 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 	u32 index, channel;
 	int irq, ret;
 	resource_size_t len;
+#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
+	const struct soc_device_attribute *match;
+#endif
 
-	pcfg = kmalloc(sizeof(*pcfg), GFP_KERNEL);
+	pcfg = kzalloc(sizeof(*pcfg), GFP_KERNEL);
 	if (!pcfg) {
 		pr_err("can't allocate portal config");
 		return NULL;
@@ -460,10 +474,20 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 		goto err;
 
 #if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
-	pcfg->addr_virt[DPA_PORTAL_CE] = ioremap_cache_ns(
-                                pcfg->addr_phys[DPA_PORTAL_CE].start,
-                                resource_size(&pcfg->addr_phys[DPA_PORTAL_CE]));
-
+	/* Check for LS1046A device as we need to use a
+	   cache-inhibited write combine mapping for that part */
+	match = soc_device_match(soc_msi_matches);
+	if (match) {
+		pcfg->addr_virt[DPA_PORTAL_CE] =
+			ioremap_wc(pcfg->addr_phys[DPA_PORTAL_CE].start,
+				   resource_size(&pcfg->
+						 addr_phys[DPA_PORTAL_CE]));
+		pcfg->cache_inhibited = 1;
+	} else
+		pcfg->addr_virt[DPA_PORTAL_CE] =
+			ioremap_cache_ns(pcfg->addr_phys[DPA_PORTAL_CE].start,
+					 resource_size(&pcfg->addr_phys
+						       [DPA_PORTAL_CE]));
         pcfg->addr_virt[DPA_PORTAL_CI] = ioremap(
                                 pcfg->addr_phys[DPA_PORTAL_CI].start,
                                 resource_size(&pcfg->addr_phys[DPA_PORTAL_CI]));
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 542c4bb..fe4e326 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -601,7 +601,7 @@ struct qman_portal *qman_create_portal(
         portal->use_eqcr_ci_stashing = ((qman_ip_rev >= QMAN_REV30) ?
 					1 : 0);
 #elif defined(CONFIG_ARM) || defined(CONFIG_ARM64)
-	portal->use_eqcr_ci_stashing = 1;
+	portal->use_eqcr_ci_stashing = !config->cache_inhibited;
 #else
         portal->use_eqcr_ci_stashing = 0;
 #endif
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index ee025cf..b6493e5 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -189,6 +189,8 @@ struct qm_portal_config {
 	struct qman_portal_config public_cfg;
 	/* power management saved data */
 	u32 saved_isdr;
+	/* Set to non zero if portal is cache_inhibited mode */
+	int cache_inhibited;
 };
 
 /* Revision info (for errata and feature handling) */
-- 
2.9.3

