From dbc7d52b045de7f7f873e8dc6d66177c716897b4 Mon Sep 17 00:00:00 2001
From: Bogdan Purcareata <bogdan.purcareata@nxp.com>
Date: Wed, 21 Sep 2016 14:44:16 +0000
Subject: [PATCH 284/388] staging: fsl-mc/fsl-dpaa2: Update FLIBs to MC v10.x

Update FLIBs for DPIO, DPBP, DPCON, DPMAC.

Signed-off-by: Bogdan Purcareata <bogdan.purcareata@nxp.com>
[Original patch taken from SDK-V2.0-1703]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h      |  95 ++++++++---------
 drivers/staging/fsl-dpaa2/mac/dpmac.c          | 103 +++++++++---------
 drivers/staging/fsl-dpaa2/mac/dpmac.h          | 139 +++++++++++--------------
 drivers/staging/fsl-dpaa2/mac/mac.c            |   2 +-
 drivers/staging/fsl-mc/bus/dpbp.c              | 110 +++++++++++--------
 drivers/staging/fsl-mc/bus/dpcon.c             |  51 ++++++---
 drivers/staging/fsl-mc/bus/dpio/dpio.c         |  52 ++++++---
 drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h     |  75 +++++++------
 drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h |  63 +++++------
 drivers/staging/fsl-mc/include/dpbp-cmd.h      |  46 ++++----
 drivers/staging/fsl-mc/include/dpbp.h          |  67 ++++++------
 drivers/staging/fsl-mc/include/dpcon-cmd.h     |  51 ++++-----
 drivers/staging/fsl-mc/include/dpcon.h         |  84 ++++++++-------
 13 files changed, 510 insertions(+), 428 deletions(-)

diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h b/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h
index dc00590..02a8153 100644
--- a/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -33,36 +33,41 @@
 #define _FSL_DPMAC_CMD_H
 
 /* DPMAC Version */
-#define DPMAC_VER_MAJOR				3
+#define DPMAC_VER_MAJOR				4
 #define DPMAC_VER_MINOR				2
+#define DPMAC_CMD_BASE_VERSION			1
+#define DPMAC_CMD_ID_OFFSET			4
 
 /* Command IDs */
-#define DPMAC_CMDID_CLOSE			0x800
-#define DPMAC_CMDID_OPEN			0x80c
-#define DPMAC_CMDID_CREATE			0x90c
-#define DPMAC_CMDID_DESTROY			0x900
-
-#define DPMAC_CMDID_GET_ATTR			0x004
-#define DPMAC_CMDID_RESET			0x005
-
-#define DPMAC_CMDID_SET_IRQ			0x010
-#define DPMAC_CMDID_GET_IRQ			0x011
-#define DPMAC_CMDID_SET_IRQ_ENABLE		0x012
-#define DPMAC_CMDID_GET_IRQ_ENABLE		0x013
-#define DPMAC_CMDID_SET_IRQ_MASK		0x014
-#define DPMAC_CMDID_GET_IRQ_MASK		0x015
-#define DPMAC_CMDID_GET_IRQ_STATUS		0x016
-#define DPMAC_CMDID_CLEAR_IRQ_STATUS		0x017
-
-#define DPMAC_CMDID_MDIO_READ			0x0c0
-#define DPMAC_CMDID_MDIO_WRITE			0x0c1
-#define DPMAC_CMDID_GET_LINK_CFG		0x0c2
-#define DPMAC_CMDID_SET_LINK_STATE		0x0c3
-#define DPMAC_CMDID_GET_COUNTER			0x0c4
+#define DPMAC_CMDID_CLOSE                       ((0x800 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_OPEN                        ((0x80c << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_CREATE                      ((0x90c << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_DESTROY                     ((0x98c << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_GET_API_VERSION             ((0xa0c << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+
+#define DPMAC_CMDID_GET_ATTR                    ((0x004 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_RESET                       ((0x005 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+
+#define DPMAC_CMDID_SET_IRQ                     ((0x010 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_GET_IRQ                     ((0x011 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_SET_IRQ_ENABLE              ((0x012 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_GET_IRQ_ENABLE              ((0x013 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_SET_IRQ_MASK                ((0x014 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_GET_IRQ_MASK                ((0x015 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_GET_IRQ_STATUS              ((0x016 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_CLEAR_IRQ_STATUS            ((0x017 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+
+#define DPMAC_CMDID_MDIO_READ                   ((0x0c0 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_MDIO_WRITE                  ((0x0c1 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_GET_LINK_CFG                ((0x0c2 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_SET_LINK_STATE              ((0x0c3 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+#define DPMAC_CMDID_GET_COUNTER                 ((0x0c4 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
+
+#define DPMAC_CMDID_SET_PORT_MAC_ADDR           ((0x0c5 << DPMAC_CMD_ID_OFFSET) | DPMAC_CMD_BASE_VERSION)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPMAC_CMD_CREATE(cmd, cfg) \
-	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->mac_id)
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t,      cfg->mac_id)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPMAC_CMD_OPEN(cmd, dpmac_id) \
@@ -141,32 +146,10 @@ do { \
 /*                cmd, param, offset, width, type,	arg_name */
 #define DPMAC_RSP_GET_ATTRIBUTES(cmd, attr) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, int,			attr->phy_id);\
-	MC_RSP_OP(cmd, 0, 32, 32, int,			attr->id);\
-	MC_RSP_OP(cmd, 1, 0,  16, uint16_t,		attr->version.major);\
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t,		attr->version.minor);\
-	MC_RSP_OP(cmd, 1, 32,  8, enum dpmac_link_type,	attr->link_type);\
-	MC_RSP_OP(cmd, 1, 40,  8, enum dpmac_eth_if,	attr->eth_if);\
-	MC_RSP_OP(cmd, 2, 0,  32, uint32_t,		attr->max_rate);\
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPMAC_CMD_MDIO_READ(cmd, cfg) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->phy_addr); \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  cfg->reg); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPMAC_RSP_MDIO_READ(cmd, data) \
-	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, data)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPMAC_CMD_MDIO_WRITE(cmd, cfg) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->phy_addr); \
-	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  cfg->reg); \
-	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, cfg->data); \
+	MC_RSP_OP(cmd, 0, 0,  8,  uint8_t,		attr->eth_if);\
+	MC_RSP_OP(cmd, 0, 8,  8,  uint8_t,		attr->link_type);\
+	MC_RSP_OP(cmd, 0, 16, 16, uint16_t,		attr->id);\
+	MC_RSP_OP(cmd, 0, 32, 32, uint32_t,		attr->max_rate);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -192,4 +175,14 @@ do { \
 #define DPMAC_RSP_GET_COUNTER(cmd, counter) \
 	MC_RSP_OP(cmd, 1, 0, 64, uint64_t, counter)
 
+#define DPMAC_CMD_SET_PORT_MAC_ADDR(cmd, addr) \
+do { \
+	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  addr[5]); \
+	MC_CMD_OP(cmd, 0, 24, 8,  uint8_t,  addr[4]); \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  addr[3]); \
+	MC_CMD_OP(cmd, 0, 40, 8,  uint8_t,  addr[2]); \
+	MC_CMD_OP(cmd, 0, 48, 8,  uint8_t,  addr[1]); \
+	MC_CMD_OP(cmd, 0, 56, 8,  uint8_t,  addr[0]); \
+} while (0)
+
 #endif /* _FSL_DPMAC_CMD_H */
diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac.c b/drivers/staging/fsl-dpaa2/mac/dpmac.c
index fc23b40..8270c7a 100644
--- a/drivers/staging/fsl-dpaa2/mac/dpmac.c
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac.c
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -54,7 +54,7 @@ int dpmac_open(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*token = get_mc_cmd_hdr_token(cmd.header);
 
 	return err;
 }
@@ -73,10 +73,11 @@ int dpmac_close(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpmac_create(struct fsl_mc_io *mc_io,
-		 uint32_t cmd_flags,
-		 const struct dpmac_cfg *cfg,
-		 uint16_t *token)
+int dpmac_create(struct fsl_mc_io	*mc_io,
+		uint16_t	dprc_token,
+		uint32_t	cmd_flags,
+		const struct dpmac_cfg	*cfg,
+		uint32_t *object_id)
 {
 	struct mc_command cmd = { 0 };
 	int err;
@@ -84,7 +85,7 @@ int dpmac_create(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_CREATE,
 					  cmd_flags,
-					  0);
+					  dprc_token);
 	DPMAC_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -93,22 +94,24 @@ int dpmac_create(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*object_id = get_mc_cmd_create_object_id(&cmd);
 
 	return 0;
 }
 
 int dpmac_destroy(struct fsl_mc_io *mc_io,
-		  uint32_t cmd_flags,
-		  uint16_t token)
+		uint16_t dprc_token,
+		uint32_t cmd_flags,
+		uint32_t object_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_DESTROY,
 					  cmd_flags,
-					  token);
-
+					  dprc_token);
+	/* set object id to destroy */
+	cmd.params[0] = mc_enc(0, sizeof(object_id), object_id);
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
@@ -314,109 +317,105 @@ int dpmac_get_attributes(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpmac_mdio_read(struct fsl_mc_io *mc_io,
-		    uint32_t cmd_flags,
-		    uint16_t token,
-		    struct dpmac_mdio_cfg *cfg)
+int dpmac_get_link_cfg(struct fsl_mc_io *mc_io,
+		       uint32_t cmd_flags,
+		       uint16_t token,
+		       struct dpmac_link_cfg *cfg)
 {
 	struct mc_command cmd = { 0 };
-	int err;
+	int err = 0;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_MDIO_READ,
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_LINK_CFG,
 					  cmd_flags,
 					  token);
-	DPMAC_CMD_MDIO_READ(cmd, cfg);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
 	if (err)
 		return err;
 
-	/* retrieve response parameters */
-	DPMAC_RSP_MDIO_READ(cmd, cfg->data);
+	DPMAC_RSP_GET_LINK_CFG(cmd, cfg);
 
 	return 0;
 }
 
-int dpmac_mdio_write(struct fsl_mc_io *mc_io,
-		     uint32_t cmd_flags,
-		     uint16_t token,
-		     struct dpmac_mdio_cfg *cfg)
+int dpmac_set_link_state(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
+			 uint16_t token,
+			 struct dpmac_link_state *link_state)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_MDIO_WRITE,
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_LINK_STATE,
 					  cmd_flags,
 					  token);
-	DPMAC_CMD_MDIO_WRITE(cmd, cfg);
+	DPMAC_CMD_SET_LINK_STATE(cmd, link_state);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpmac_get_link_cfg(struct fsl_mc_io *mc_io,
-		       uint32_t cmd_flags,
-		       uint16_t token,
-		       struct dpmac_link_cfg *cfg)
+int dpmac_get_counter(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
+		      uint16_t token,
+		      enum dpmac_counter type,
+		      uint64_t *counter)
 {
 	struct mc_command cmd = { 0 };
 	int err = 0;
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_LINK_CFG,
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_COUNTER,
 					  cmd_flags,
 					  token);
+	DPMAC_CMD_GET_COUNTER(cmd, type);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
 	if (err)
 		return err;
 
-	DPMAC_RSP_GET_LINK_CFG(cmd, cfg);
+	DPMAC_RSP_GET_COUNTER(cmd, *counter);
 
 	return 0;
 }
 
-int dpmac_set_link_state(struct fsl_mc_io *mc_io,
-			 uint32_t cmd_flags,
-			 uint16_t token,
-			 struct dpmac_link_state *link_state)
+int dpmac_set_port_mac_addr(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
+		      uint16_t token,
+		      const uint8_t addr[6])
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_LINK_STATE,
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_PORT_MAC_ADDR,
 					  cmd_flags,
 					  token);
-	DPMAC_CMD_SET_LINK_STATE(cmd, link_state);
+	DPMAC_CMD_SET_PORT_MAC_ADDR(cmd, addr);
 
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpmac_get_counter(struct fsl_mc_io *mc_io,
-		      uint32_t cmd_flags,
-		      uint16_t token,
-		      enum dpmac_counter type,
-		      uint64_t *counter)
+int dpmac_get_api_version(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
+			   uint16_t *major_ver,
+			   uint16_t *minor_ver)
 {
 	struct mc_command cmd = { 0 };
-	int err = 0;
+	int err;
 
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_COUNTER,
-					  cmd_flags,
-					  token);
-	DPMAC_CMD_GET_COUNTER(cmd, type);
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_API_VERSION,
+					cmd_flags,
+					0);
 
-	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
 	if (err)
 		return err;
 
-	DPMAC_RSP_GET_COUNTER(cmd, *counter);
+	get_mc_cmd_object_api_ver(&cmd, major_ver, minor_ver);
 
 	return 0;
 }
diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac.h b/drivers/staging/fsl-dpaa2/mac/dpmac.h
index ad27772..76b3064 100644
--- a/drivers/staging/fsl-dpaa2/mac/dpmac.h
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -122,46 +122,53 @@ enum dpmac_eth_if {
  *				MAC IDs for the 2nd WRIOP: 17-32.
  */
 struct dpmac_cfg {
-	int mac_id;
+	uint16_t mac_id;
 };
 
 /**
  * dpmac_create() - Create the DPMAC object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @dprc_token: Parent container token; '0' for default container
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
- * @token:	Returned token; use in subsequent API calls
+ * @obj_id: returned object id
  *
  * Create the DPMAC object, allocate required resources and
  * perform required initialization.
  *
- * The object can be created either by declaring it in the
- * DPL file, or by calling this function.
- * This function returns a unique authentication token,
- * associated with the specific object ID and the specific MC
- * portal; this token must be used in all subsequent calls to
- * this specific object. For objects that are created using the
- * DPL file, call dpmac_open function to get an authentication
- * token first.
+ * The function accepts an authentication token of a parent
+ * container that this object should be assigned to. The token
+ * can be '0' so the object will be assigned to the default container.
+ * The newly created object can be opened with the returned
+ * object id and using the container's associated tokens and MC portals.
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpmac_create(struct fsl_mc_io	*mc_io,
-		 uint32_t		cmd_flags,
-		 const struct dpmac_cfg	*cfg,
-		 uint16_t		*token);
+		uint16_t	dprc_token,
+		uint32_t	cmd_flags,
+		const struct dpmac_cfg	*cfg,
+		uint32_t	*obj_id);
 
 /**
  * dpmac_destroy() - Destroy the DPMAC object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @dprc_token: Parent container token; '0' for default container
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPMAC object
+ * @object_id:	The object id; it must be a valid id within the container that
+ * created this object;
+ *
+ * The function accepts the authentication token of the parent container that
+ * created the object (not the one that currently owns the object). The object
+ * is searched within parent using the provided 'object_id'.
+ * All tokens to the object must be closed before calling destroy.
  *
  * Return:	'0' on Success; error code otherwise.
  */
 int dpmac_destroy(struct fsl_mc_io	*mc_io,
-		  uint32_t		cmd_flags,
-		  uint16_t		token);
+		uint16_t	dprc_token,
+		uint32_t	cmd_flags,
+		uint32_t	object_id);
 
 /**
  * DPMAC IRQ Index and Events
@@ -345,28 +352,16 @@ int dpmac_clear_irq_status(struct fsl_mc_io	*mc_io,
 
 /**
  * struct dpmac_attr - Structure representing DPMAC attributes
- * @id:		DPMAC object ID
- * @phy_id:	PHY ID
- * @link_type: link type
- * @eth_if: Ethernet interface
+ * @id: DPMAC object ID
  * @max_rate: Maximum supported rate - in Mbps
- * @version:	DPMAC version
+ * @eth_if: Ethernet interface
+ * @link_type: link type
  */
 struct dpmac_attr {
-	int			id;
-	int			phy_id;
+	uint16_t				id;
+	uint32_t				max_rate;
+	enum dpmac_eth_if		eth_if;
 	enum dpmac_link_type	link_type;
-	enum dpmac_eth_if	eth_if;
-	uint32_t		max_rate;
-	/**
-	 * struct version - Structure representing DPMAC version
-	 * @major:	DPMAC major version
-	 * @minor:	DPMAC minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
 };
 
 /**
@@ -385,47 +380,6 @@ int dpmac_get_attributes(struct fsl_mc_io	*mc_io,
 			 struct dpmac_attr	*attr);
 
 /**
- * struct dpmac_mdio_cfg - DPMAC MDIO read/write parameters
- * @phy_addr: MDIO device address
- * @reg: Address of the register within the Clause 45 PHY device from which data
- *	is to be read
- * @data: Data read/write from/to MDIO
- */
-struct dpmac_mdio_cfg {
-	uint8_t		phy_addr;
-	uint8_t		reg;
-	uint16_t	data;
-};
-
-/**
- * dpmac_mdio_read() - Perform MDIO read transaction
- * @mc_io:	Pointer to opaque I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPMAC object
- * @cfg:	Structure with MDIO transaction parameters
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpmac_mdio_read(struct fsl_mc_io		*mc_io,
-		    uint32_t			cmd_flags,
-		    uint16_t			token,
-		    struct dpmac_mdio_cfg	*cfg);
-
-/**
- * dpmac_mdio_write() - Perform MDIO write transaction
- * @mc_io:	Pointer to opaque I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPMAC object
- * @cfg:	Structure with MDIO transaction parameters
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpmac_mdio_write(struct fsl_mc_io		*mc_io,
-		     uint32_t			cmd_flags,
-		     uint16_t			token,
-		     struct dpmac_mdio_cfg	*cfg);
-
-/**
  * DPMAC link configuration/state options
  */
 
@@ -521,7 +475,7 @@ int dpmac_set_link_state(struct fsl_mc_io		*mc_io,
  *			      bytes long with a good CRC.
  * @DPMAC_CNT_ING_OVERSIZED: counts frames longer than the maximum frame length
  *			     specified, with a good frame check sequence.
- * @DPMAC_CNT_ING_VALID_PAUSE_FRAME: counts valid pause frames (regular and PFC)
+ * @DPMAC_CNT_ING_VALID_PAUSE_FRAME: counts valid pause frames (regular and PFC).
  * @DPMAC_CNT_EGR_VALID_PAUSE_FRAME: counts valid pause frames transmitted
  *				     (regular and PFC).
  * @DPMAC_CNT_ING_BYTE: counts bytes received except preamble for all valid
@@ -590,4 +544,35 @@ int dpmac_get_counter(struct fsl_mc_io		*mc_io,
 		      enum dpmac_counter	 type,
 		      uint64_t			*counter);
 
+/**
+ * dpmac_set_port_mac_addr() - Set a MAC address associated with the physical
+ *              port.  This is not used for filtering, MAC is always in
+ *              promiscuous mode, it is passed to DPNIs through DPNI API for
+ *              application used.
+ * @mc_io:	Pointer to opaque I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPMAC object
+ * @addr:	MAC address to set
+ *
+ * Return:	The requested counter; '0' otherwise.
+ */
+int dpmac_set_port_mac_addr(struct fsl_mc_io *mc_io,
+		      uint32_t cmd_flags,
+		      uint16_t token,
+		      const uint8_t addr[6]);
+
+/**
+ * dpmac_get_api_version() - Get Data Path MAC version
+ * @mc_io:  Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @major_ver:	Major version of data path mac API
+ * @minor_ver:	Minor version of data path mac API
+ *
+ * Return:  '0' on Success; Error code otherwise.
+ */
+int dpmac_get_api_version(struct fsl_mc_io *mc_io,
+			   uint32_t cmd_flags,
+			   uint16_t *major_ver,
+			   uint16_t *minor_ver);
+
 #endif /* __FSL_DPMAC_H */
diff --git a/drivers/staging/fsl-dpaa2/mac/mac.c b/drivers/staging/fsl-dpaa2/mac/mac.c
index 33cf888..1ec895b 100644
--- a/drivers/staging/fsl-dpaa2/mac/mac.c
+++ b/drivers/staging/fsl-dpaa2/mac/mac.c
@@ -455,7 +455,7 @@ static void teardown_irqs(struct fsl_mc_device *mc_dev)
 	fsl_mc_free_irqs(mc_dev);
 }
 
-static struct device_node *lookup_node(struct device *dev, int dpmac_id)
+static struct device_node *lookup_node(struct device *dev, u16 dpmac_id)
 {
 	struct device_node *dpmacs, *dpmac = NULL;
 	struct device_node *mc_node = dev->of_node;
diff --git a/drivers/staging/fsl-mc/bus/dpbp.c b/drivers/staging/fsl-mc/bus/dpbp.c
index f183121..555f380 100644
--- a/drivers/staging/fsl-mc/bus/dpbp.c
+++ b/drivers/staging/fsl-mc/bus/dpbp.c
@@ -1,34 +1,34 @@
-/* Copyright 2013-2014 Freescale Semiconductor Inc.
-*
-* Redistribution and use in source and binary forms, with or without
-* modification, are permitted provided that the following conditions are met:
-* * Redistributions of source code must retain the above copyright
-* notice, this list of conditions and the following disclaimer.
-* * Redistributions in binary form must reproduce the above copyright
-* notice, this list of conditions and the following disclaimer in the
-* documentation and/or other materials provided with the distribution.
-* * Neither the name of the above-listed copyright holders nor the
-* names of any contributors may be used to endorse or promote products
-* derived from this software without specific prior written permission.
-*
-*
-* ALTERNATIVELY, this software may be distributed under the terms of the
-* GNU General Public License ("GPL") as published by the Free Software
-* Foundation, either version 2 of that License or (at your option) any
-* later version.
-*
-* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
-* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
-* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
-* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
-* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
-* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
-* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
-* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
-* POSSIBILITY OF SUCH DAMAGE.
-*/
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
 #include "../include/mc-sys.h"
 #include "../include/mc-cmd.h"
 #include "../include/dpbp.h"
@@ -55,11 +55,10 @@ int dpbp_open(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*token = get_mc_cmd_hdr_token(cmd.header);
 
 	return err;
 }
-EXPORT_SYMBOL(dpbp_open);
 
 int dpbp_close(struct fsl_mc_io *mc_io,
 	       uint32_t cmd_flags,
@@ -74,12 +73,12 @@ int dpbp_close(struct fsl_mc_io *mc_io,
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
-EXPORT_SYMBOL(dpbp_close);
 
 int dpbp_create(struct fsl_mc_io *mc_io,
+		uint16_t dprc_token,
 		uint32_t cmd_flags,
 		const struct dpbp_cfg *cfg,
-		uint16_t *token)
+		uint32_t *object_id)
 {
 	struct mc_command cmd = { 0 };
 	int err;
@@ -89,7 +88,7 @@ int dpbp_create(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_CREATE,
 					  cmd_flags,
-					  0);
+					  dprc_token);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -97,22 +96,24 @@ int dpbp_create(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*object_id = get_mc_cmd_create_object_id(&cmd);
 
 	return 0;
 }
 
 int dpbp_destroy(struct fsl_mc_io *mc_io,
-		 uint32_t cmd_flags,
-		 uint16_t token)
+		 uint16_t dprc_token,
+		uint32_t cmd_flags,
+		uint32_t object_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPBP_CMDID_DESTROY,
 					  cmd_flags,
-					  token);
-
+					  dprc_token);
+	/* set object id to destroy */
+	cmd.params[0] = mc_enc(0, sizeof(object_id), object_id);
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
@@ -130,7 +131,6 @@ int dpbp_enable(struct fsl_mc_io *mc_io,
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
-EXPORT_SYMBOL(dpbp_enable);
 
 int dpbp_disable(struct fsl_mc_io *mc_io,
 		 uint32_t cmd_flags,
@@ -146,7 +146,6 @@ int dpbp_disable(struct fsl_mc_io *mc_io,
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
-EXPORT_SYMBOL(dpbp_disable);
 
 int dpbp_is_enabled(struct fsl_mc_io *mc_io,
 		    uint32_t cmd_flags,
@@ -398,11 +397,9 @@ int dpbp_get_attributes(struct fsl_mc_io *mc_io,
 	/* retrieve response parameters */
 	attr->bpid = (uint16_t)mc_dec(cmd.params[0], 16, 16);
 	attr->id = (int)mc_dec(cmd.params[0], 32, 32);
-	attr->version.major = (uint16_t)mc_dec(cmd.params[1], 0, 16);
-	attr->version.minor = (uint16_t)mc_dec(cmd.params[1], 16, 16);
+
 	return 0;
 }
-EXPORT_SYMBOL(dpbp_get_attributes);
 
 int dpbp_set_notifications(struct fsl_mc_io	*mc_io,
 			   uint32_t		cmd_flags,
@@ -457,3 +454,24 @@ int dpbp_get_notifications(struct fsl_mc_io	*mc_io,
 
 	return 0;
 }
+
+int dpbp_get_api_version(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
+			 uint16_t *major_ver,
+			 uint16_t *minor_ver)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	cmd.header = mc_encode_cmd_header(DPBP_CMDID_GET_API_VERSION,
+					cmd_flags,
+					0);
+
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	get_mc_cmd_object_api_ver(&cmd, major_ver, minor_ver);
+
+	return 0;
+}
diff --git a/drivers/staging/fsl-mc/bus/dpcon.c b/drivers/staging/fsl-mc/bus/dpcon.c
index 7965284..fb98593 100644
--- a/drivers/staging/fsl-mc/bus/dpcon.c
+++ b/drivers/staging/fsl-mc/bus/dpcon.c
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -54,11 +54,10 @@ int dpcon_open(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*token = get_mc_cmd_hdr_token(cmd.header);
 
 	return 0;
 }
-EXPORT_SYMBOL(dpcon_open);
 
 int dpcon_close(struct fsl_mc_io *mc_io,
 		uint32_t cmd_flags,
@@ -74,12 +73,12 @@ int dpcon_close(struct fsl_mc_io *mc_io,
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
-EXPORT_SYMBOL(dpcon_close);
 
 int dpcon_create(struct fsl_mc_io *mc_io,
-		 uint32_t cmd_flags,
-		 const struct dpcon_cfg *cfg,
-		 uint16_t *token)
+		 uint16_t dprc_token,
+		uint32_t cmd_flags,
+		const struct dpcon_cfg *cfg,
+		uint32_t *object_id)
 {
 	struct mc_command cmd = { 0 };
 	int err;
@@ -87,7 +86,7 @@ int dpcon_create(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPCON_CMDID_CREATE,
 					  cmd_flags,
-					  0);
+					  dprc_token);
 	DPCON_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -96,22 +95,24 @@ int dpcon_create(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*object_id = get_mc_cmd_create_object_id(&cmd);
 
 	return 0;
 }
 
 int dpcon_destroy(struct fsl_mc_io *mc_io,
-		  uint32_t cmd_flags,
-		  uint16_t token)
+		  uint16_t dprc_token,
+		uint32_t cmd_flags,
+		uint32_t object_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPCON_CMDID_DESTROY,
 					  cmd_flags,
-					  token);
-
+					  dprc_token);
+	/* set object id to destroy */
+	cmd.params[0] = mc_enc(0, sizeof(object_id), object_id);
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
@@ -130,7 +131,6 @@ int dpcon_enable(struct fsl_mc_io *mc_io,
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
-EXPORT_SYMBOL(dpcon_enable);
 
 int dpcon_disable(struct fsl_mc_io *mc_io,
 		  uint32_t cmd_flags,
@@ -146,7 +146,6 @@ int dpcon_disable(struct fsl_mc_io *mc_io,
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
-EXPORT_SYMBOL(dpcon_disable);
 
 int dpcon_is_enabled(struct fsl_mc_io *mc_io,
 		     uint32_t cmd_flags,
@@ -385,7 +384,6 @@ int dpcon_get_attributes(struct fsl_mc_io *mc_io,
 
 	return 0;
 }
-EXPORT_SYMBOL(dpcon_get_attributes);
 
 int dpcon_set_notification(struct fsl_mc_io *mc_io,
 			   uint32_t cmd_flags,
@@ -403,5 +401,24 @@ int dpcon_set_notification(struct fsl_mc_io *mc_io,
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
-EXPORT_SYMBOL(dpcon_set_notification);
 
+int dpcon_get_api_version(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t *major_ver,
+			  uint16_t *minor_ver)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	cmd.header = mc_encode_cmd_header(DPCON_CMDID_GET_API_VERSION,
+					cmd_flags,
+					0);
+
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	get_mc_cmd_object_api_ver(&cmd, major_ver, minor_ver);
+
+	return 0;
+}
diff --git a/drivers/staging/fsl-mc/bus/dpio/dpio.c b/drivers/staging/fsl-mc/bus/dpio/dpio.c
index b63edd6..a38f71a 100644
--- a/drivers/staging/fsl-mc/bus/dpio/dpio.c
+++ b/drivers/staging/fsl-mc/bus/dpio/dpio.c
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -54,7 +54,7 @@ int dpio_open(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*token = get_mc_cmd_hdr_token(cmd.header);
 
 	return 0;
 }
@@ -74,10 +74,11 @@ int dpio_close(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpio_create(struct fsl_mc_io *mc_io,
-		uint32_t cmd_flags,
-		const struct dpio_cfg *cfg,
-		uint16_t *token)
+int dpio_create(struct fsl_mc_io	*mc_io,
+		uint16_t	dprc_token,
+		uint32_t	cmd_flags,
+		const struct dpio_cfg	*cfg,
+		uint32_t	*object_id)
 {
 	struct mc_command cmd = { 0 };
 	int err;
@@ -85,7 +86,7 @@ int dpio_create(struct fsl_mc_io *mc_io,
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_CREATE,
 					  cmd_flags,
-					  0);
+					  dprc_token);
 	DPIO_CMD_CREATE(cmd, cfg);
 
 	/* send command to mc*/
@@ -94,22 +95,24 @@ int dpio_create(struct fsl_mc_io *mc_io,
 		return err;
 
 	/* retrieve response parameters */
-	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+	*object_id = get_mc_cmd_create_object_id(&cmd);
 
 	return 0;
 }
 
-int dpio_destroy(struct fsl_mc_io *mc_io,
-		 uint32_t cmd_flags,
-		 uint16_t token)
+int dpio_destroy(struct fsl_mc_io	*mc_io,
+		 uint16_t	dprc_token,
+		 uint32_t	cmd_flags,
+		 uint32_t	object_id)
 {
 	struct mc_command cmd = { 0 };
 
 	/* prepare command */
 	cmd.header = mc_encode_cmd_header(DPIO_CMDID_DESTROY,
-					  cmd_flags,
-					  token);
-
+			cmd_flags,
+			dprc_token);
+	/* set object id to destroy */
+	cmd.params[0] = mc_enc(0, sizeof(object_id), object_id);
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
@@ -466,3 +469,24 @@ int dpio_remove_static_dequeue_channel(struct fsl_mc_io *mc_io,
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
+
+int dpio_get_api_version(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
+			 uint16_t *major_ver,
+			 uint16_t *minor_ver)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	cmd.header = mc_encode_cmd_header(DPIO_CMDID_GET_API_VERSION,
+					cmd_flags,
+					0);
+
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	get_mc_cmd_object_api_ver(&cmd, major_ver, minor_ver);
+
+	return 0;
+}
diff --git a/drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h b/drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h
index 88a492f..668e0fa 100644
--- a/drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h
+++ b/drivers/staging/fsl-mc/bus/dpio/fsl_dpio.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -49,9 +49,9 @@ struct fsl_mc_io;
  * already created object; an object may have been declared in
  * the DPL or by calling the dpio_create() function.
  * This function returns a unique authentication token,
- * associated with the specific object ID and the specific MC
- * portal; this token must be used in all subsequent commands for
- * this specific object.
+ * associated with the specific object ID and any MC portals
+ * assigned to the parent container; this token must be used in
+ * all subsequent commands for this specific object.
  *
  * Return:	'0' on Success; Error code otherwise.
  */
@@ -92,15 +92,16 @@ enum dpio_channel_mode {
  */
 struct dpio_cfg {
 	enum dpio_channel_mode	channel_mode;
-	uint8_t		num_priorities;
+	uint8_t			num_priorities;
 };
 
 /**
  * dpio_create() - Create the DPIO object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @dprc_token:	Parent container token; '0' for default container
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
- * @token:	Returned token; use in subsequent API calls
+ * @obj_id: returned object id
  *
  * Create the DPIO object, allocate required resources and
  * perform required initialization.
@@ -108,31 +109,39 @@ struct dpio_cfg {
  * The object can be created either by declaring it in the
  * DPL file, or by calling this function.
  *
- * This function returns a unique authentication token,
- * associated with the specific object ID and the specific MC
- * portal; this token must be used in all subsequent calls to
- * this specific object. For objects that are created using the
- * DPL file, call dpio_open() function to get an authentication
- * token first.
+ * The function accepts an authentication token of a parent
+ * container that this object should be assigned to. The token
+ * can be '0' so the object will be assigned to the default container.
+ * The newly created object can be opened with the returned
+ * object id and using the container's associated tokens and MC portals.
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_create(struct fsl_mc_io	*mc_io,
+		uint16_t		dprc_token,
 		uint32_t		cmd_flags,
 		const struct dpio_cfg	*cfg,
-		uint16_t		*token);
+		uint32_t		*obj_id);
 
 /**
  * dpio_destroy() - Destroy the DPIO object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @dprc_token: Parent container token; '0' for default container
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPIO object
+ * @object_id:	The object id; it must be a valid id within the container that
+ * created this object;
+ *
+ * The function accepts the authentication token of the parent container that
+ * created the object (not the one that currently owns the object). The object
+ * is searched within parent using the provided 'object_id'.
+ * All tokens to the object must be closed before calling destroy.
  *
  * Return:	'0' on Success; Error code otherwise
  */
 int dpio_destroy(struct fsl_mc_io	*mc_io,
-		 uint32_t		cmd_flags,
-		 uint16_t		token);
+		 uint16_t		dprc_token,
+		uint32_t		cmd_flags,
+		uint32_t		object_id);
 
 /**
  * dpio_enable() - Enable the DPIO, allow I/O portal operations.
@@ -170,7 +179,7 @@ int dpio_disable(struct fsl_mc_io	*mc_io,
 int dpio_is_enabled(struct fsl_mc_io	*mc_io,
 		    uint32_t		cmd_flags,
 		    uint16_t		token,
-		    int		*en);
+		    int			*en);
 
 /**
  * dpio_reset() - Reset the DPIO, returns the object to initial state.
@@ -181,7 +190,7 @@ int dpio_is_enabled(struct fsl_mc_io	*mc_io,
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpio_reset(struct fsl_mc_io	*mc_io,
-	       uint32_t			cmd_flags,
+	       uint32_t		cmd_flags,
 	       uint16_t		token);
 
 /**
@@ -225,7 +234,7 @@ int dpio_get_stashing_destination(struct fsl_mc_io	*mc_io,
 int dpio_add_static_dequeue_channel(struct fsl_mc_io	*mc_io,
 				    uint32_t		cmd_flags,
 				    uint16_t		token,
-				    int		dpcon_id,
+				    int			dpcon_id,
 				    uint8_t		*channel_index);
 
 /**
@@ -240,7 +249,7 @@ int dpio_add_static_dequeue_channel(struct fsl_mc_io	*mc_io,
 int dpio_remove_static_dequeue_channel(struct fsl_mc_io	*mc_io,
 				       uint32_t		cmd_flags,
 				       uint16_t		token,
-				       int			dpcon_id);
+				       int		dpcon_id);
 
 /**
  * DPIO IRQ Index and Events
@@ -416,7 +425,6 @@ int dpio_clear_irq_status(struct fsl_mc_io	*mc_io,
 /**
  * struct dpio_attr - Structure representing DPIO attributes
  * @id: DPIO object ID
- * @version: DPIO version
  * @qbman_portal_ce_offset: offset of the software portal cache-enabled area
  * @qbman_portal_ci_offset: offset of the software portal cache-inhibited area
  * @qbman_portal_id: Software portal ID
@@ -427,21 +435,13 @@ int dpio_clear_irq_status(struct fsl_mc_io	*mc_io,
  */
 struct dpio_attr {
 	int			id;
-	/**
-	 * struct version - DPIO version
-	 * @major: DPIO major version
-	 * @minor: DPIO minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
 	uint64_t		qbman_portal_ce_offset;
 	uint64_t		qbman_portal_ci_offset;
 	uint16_t		qbman_portal_id;
 	enum dpio_channel_mode	channel_mode;
 	uint8_t			num_priorities;
 	uint32_t		qbman_version;
+	uint32_t		clk;
 };
 
 /**
@@ -457,4 +457,19 @@ int dpio_get_attributes(struct fsl_mc_io	*mc_io,
 			uint32_t		cmd_flags,
 			uint16_t		token,
 			struct dpio_attr	*attr);
+
+/**
+ * dpio_get_api_version() - Get Data Path I/O API version
+ * @mc_io:  Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @major_ver:	Major version of data path i/o API
+ * @minor_ver:	Minor version of data path i/o API
+ *
+ * Return:  '0' on Success; Error code otherwise.
+ */
+int dpio_get_api_version(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
+			 uint16_t *major_ver,
+			 uint16_t *minor_ver);
+
 #endif /* __FSL_DPIO_H */
diff --git a/drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h b/drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h
index f339cd6..8fd078b 100644
--- a/drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h
+++ b/drivers/staging/fsl-mc/bus/dpio/fsl_dpio_cmd.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -33,38 +33,41 @@
 #define _FSL_DPIO_CMD_H
 
 /* DPIO Version */
-#define DPIO_VER_MAJOR				3
+#define DPIO_VER_MAJOR				4
 #define DPIO_VER_MINOR				2
+#define DPIO_CMD_BASE_VERSION			1
+#define DPIO_CMD_ID_OFFSET			4
 
 /* Command IDs */
-#define DPIO_CMDID_CLOSE				0x800
-#define DPIO_CMDID_OPEN					0x803
-#define DPIO_CMDID_CREATE				0x903
-#define DPIO_CMDID_DESTROY				0x900
-
-#define DPIO_CMDID_ENABLE				0x002
-#define DPIO_CMDID_DISABLE				0x003
-#define DPIO_CMDID_GET_ATTR				0x004
-#define DPIO_CMDID_RESET				0x005
-#define DPIO_CMDID_IS_ENABLED				0x006
-
-#define DPIO_CMDID_SET_IRQ				0x010
-#define DPIO_CMDID_GET_IRQ				0x011
-#define DPIO_CMDID_SET_IRQ_ENABLE			0x012
-#define DPIO_CMDID_GET_IRQ_ENABLE			0x013
-#define DPIO_CMDID_SET_IRQ_MASK				0x014
-#define DPIO_CMDID_GET_IRQ_MASK				0x015
-#define DPIO_CMDID_GET_IRQ_STATUS			0x016
-#define DPIO_CMDID_CLEAR_IRQ_STATUS			0x017
-
-#define DPIO_CMDID_SET_STASHING_DEST		0x120
-#define DPIO_CMDID_GET_STASHING_DEST		0x121
-#define DPIO_CMDID_ADD_STATIC_DEQUEUE_CHANNEL		0x122
-#define DPIO_CMDID_REMOVE_STATIC_DEQUEUE_CHANNEL	0x123
+#define DPIO_CMDID_CLOSE                         ((0x800 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_OPEN                          ((0x803 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_CREATE                        ((0x903 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_DESTROY                       ((0x983 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_GET_API_VERSION               ((0xa03 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+
+#define DPIO_CMDID_ENABLE                        ((0x002 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_DISABLE                       ((0x003 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_GET_ATTR                      ((0x004 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_RESET                         ((0x005 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_IS_ENABLED                    ((0x006 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+
+#define DPIO_CMDID_SET_IRQ                       ((0x010 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_GET_IRQ                       ((0x011 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_SET_IRQ_ENABLE                ((0x012 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_GET_IRQ_ENABLE                ((0x013 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_SET_IRQ_MASK                  ((0x014 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_GET_IRQ_MASK                  ((0x015 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_GET_IRQ_STATUS                ((0x016 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_CLEAR_IRQ_STATUS              ((0x017 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+
+#define DPIO_CMDID_SET_STASHING_DEST             ((0x120 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_GET_STASHING_DEST             ((0x121 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_ADD_STATIC_DEQUEUE_CHANNEL    ((0x122 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
+#define DPIO_CMDID_REMOVE_STATIC_DEQUEUE_CHANNEL ((0x123 << DPIO_CMD_ID_OFFSET) | DPIO_CMD_BASE_VERSION)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPIO_CMD_OPEN(cmd, dpio_id) \
-	MC_CMD_OP(cmd, 0, 0,  32, int,     dpio_id)
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t,     dpio_id)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPIO_CMD_CREATE(cmd, cfg) \
@@ -157,9 +160,8 @@ do { \
 	MC_RSP_OP(cmd, 0, 56, 4,  enum dpio_channel_mode, attr->channel_mode);\
 	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->qbman_portal_ce_offset);\
 	MC_RSP_OP(cmd, 2, 0,  64, uint64_t, attr->qbman_portal_ci_offset);\
-	MC_RSP_OP(cmd, 3, 0,  16, uint16_t, attr->version.major);\
-	MC_RSP_OP(cmd, 3, 16, 16, uint16_t, attr->version.minor);\
-	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->qbman_version);\
+	MC_RSP_OP(cmd, 3, 0, 32, uint32_t, attr->qbman_version);\
+	MC_RSP_OP(cmd, 4, 0,  32, uint32_t, attr->clk);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -181,4 +183,5 @@ do { \
 /*                cmd, param, offset, width, type, arg_name */
 #define DPIO_CMD_REMOVE_STATIC_DEQUEUE_CHANNEL(cmd, dpcon_id) \
 	MC_CMD_OP(cmd, 0, 0,  32, int,      dpcon_id)
+
 #endif /* _FSL_DPIO_CMD_H */
diff --git a/drivers/staging/fsl-mc/include/dpbp-cmd.h b/drivers/staging/fsl-mc/include/dpbp-cmd.h
index 1ec04e4..7726800 100644
--- a/drivers/staging/fsl-mc/include/dpbp-cmd.h
+++ b/drivers/staging/fsl-mc/include/dpbp-cmd.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -33,30 +33,34 @@
 #define _FSL_DPBP_CMD_H
 
 /* DPBP Version */
-#define DPBP_VER_MAJOR				2
+#define DPBP_VER_MAJOR				3
 #define DPBP_VER_MINOR				2
+#define DPBP_CMD_BASE_VERSION			1
+#define DPBP_CMD_ID_OFFSET			4
 
 /* Command IDs */
-#define DPBP_CMDID_CLOSE				0x800
-#define DPBP_CMDID_OPEN					0x804
-#define DPBP_CMDID_CREATE				0x904
-#define DPBP_CMDID_DESTROY				0x900
+#define DPBP_CMDID_CLOSE                        ((0x800 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_OPEN                         ((0x804 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_CREATE                       ((0x904 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_DESTROY                      ((0x984 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_GET_API_VERSION              ((0xa04 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
 
-#define DPBP_CMDID_ENABLE				0x002
-#define DPBP_CMDID_DISABLE				0x003
-#define DPBP_CMDID_GET_ATTR				0x004
-#define DPBP_CMDID_RESET				0x005
-#define DPBP_CMDID_IS_ENABLED				0x006
+#define DPBP_CMDID_ENABLE                       ((0x002 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_DISABLE                      ((0x003 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_GET_ATTR                     ((0x004 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_RESET                        ((0x005 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_IS_ENABLED                   ((0x006 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
 
-#define DPBP_CMDID_SET_IRQ				0x010
-#define DPBP_CMDID_GET_IRQ				0x011
-#define DPBP_CMDID_SET_IRQ_ENABLE			0x012
-#define DPBP_CMDID_GET_IRQ_ENABLE			0x013
-#define DPBP_CMDID_SET_IRQ_MASK				0x014
-#define DPBP_CMDID_GET_IRQ_MASK				0x015
-#define DPBP_CMDID_GET_IRQ_STATUS			0x016
-#define DPBP_CMDID_CLEAR_IRQ_STATUS			0x017
+#define DPBP_CMDID_SET_IRQ                      ((0x010 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_GET_IRQ                      ((0x011 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_SET_IRQ_ENABLE               ((0x012 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_GET_IRQ_ENABLE               ((0x013 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_SET_IRQ_MASK                 ((0x014 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_GET_IRQ_MASK                 ((0x015 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_GET_IRQ_STATUS               ((0x016 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_CLEAR_IRQ_STATUS             ((0x017 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+
+#define DPBP_CMDID_SET_NOTIFICATIONS           ((0x01b0 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
+#define DPBP_CMDID_GET_NOTIFICATIONS           ((0x01b1 << DPBP_CMD_ID_OFFSET) | DPBP_CMD_BASE_VERSION)
 
-#define DPBP_CMDID_SET_NOTIFICATIONS		0x01b0
-#define DPBP_CMDID_GET_NOTIFICATIONS		0x01b1
 #endif /* _FSL_DPBP_CMD_H */
diff --git a/drivers/staging/fsl-mc/include/dpbp.h b/drivers/staging/fsl-mc/include/dpbp.h
index 9856bb8..4268b59 100644
--- a/drivers/staging/fsl-mc/include/dpbp.h
+++ b/drivers/staging/fsl-mc/include/dpbp.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -73,7 +73,7 @@ int dpbp_open(struct fsl_mc_io	*mc_io,
  */
 int dpbp_close(struct fsl_mc_io	*mc_io,
 	       uint32_t		cmd_flags,
-	       uint16_t	token);
+	       uint16_t		token);
 
 /**
  * struct dpbp_cfg - Structure representing DPBP configuration
@@ -86,40 +86,45 @@ struct dpbp_cfg {
 /**
  * dpbp_create() - Create the DPBP object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @dprc_token:	Parent container token; '0' for default container
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
- * @token:	Returned token; use in subsequent API calls
+ * @obj_id: returned object id
  *
  * Create the DPBP object, allocate required resources and
  * perform required initialization.
  *
  * The object can be created either by declaring it in the
  * DPL file, or by calling this function.
- * This function returns a unique authentication token,
- * associated with the specific object ID and the specific MC
- * portal; this token must be used in all subsequent calls to
- * this specific object. For objects that are created using the
- * DPL file, call dpbp_open function to get an authentication
- * token first.
+ *
+ * The function accepts an authentication token of a parent
+ * container that this object should be assigned to. The token
+ * can be '0' so the object will be assigned to the default container.
+ * The newly created object can be opened with the returned
+ * object id and using the container's associated tokens and MC portals.
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_create(struct fsl_mc_io	*mc_io,
+		uint16_t		dprc_token,
 		uint32_t		cmd_flags,
 		const struct dpbp_cfg	*cfg,
-		uint16_t		*token);
+		uint32_t		*obj_id);
 
 /**
  * dpbp_destroy() - Destroy the DPBP object and release all its resources.
+ * @dprc_token: Parent container token; '0' for default container
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPBP object
+ * @object_id:	The object id; it must be a valid id within the container that
+ * created this object;
  *
  * Return:	'0' on Success; error code otherwise.
  */
 int dpbp_destroy(struct fsl_mc_io	*mc_io,
+		 uint16_t		dprc_token,
 		 uint32_t		cmd_flags,
-		 uint16_t		token);
+		 uint32_t		object_id);
 
 /**
  * dpbp_enable() - Enable the DPBP.
@@ -157,7 +162,7 @@ int dpbp_disable(struct fsl_mc_io	*mc_io,
 int dpbp_is_enabled(struct fsl_mc_io	*mc_io,
 		    uint32_t		cmd_flags,
 		    uint16_t		token,
-		    int		*en);
+		    int			*en);
 
 /**
  * dpbp_reset() - Reset the DPBP, returns the object to initial state.
@@ -169,7 +174,7 @@ int dpbp_is_enabled(struct fsl_mc_io	*mc_io,
  */
 int dpbp_reset(struct fsl_mc_io	*mc_io,
 	       uint32_t		cmd_flags,
-	       uint16_t	token);
+	       uint16_t		token);
 
 /**
  * struct dpbp_irq_cfg - IRQ configuration
@@ -337,21 +342,11 @@ int dpbp_clear_irq_status(struct fsl_mc_io	*mc_io,
 /**
  * struct dpbp_attr - Structure representing DPBP attributes
  * @id:		DPBP object ID
- * @version:	DPBP version
  * @bpid:	Hardware buffer pool ID; should be used as an argument in
  *		acquire/release operations on buffers
  */
 struct dpbp_attr {
 	int id;
-	/**
-	 * struct version - Structure representing DPBP version
-	 * @major:	DPBP major version
-	 * @minor:	DPBP minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
 	uint16_t bpid;
 };
 
@@ -366,7 +361,7 @@ struct dpbp_attr {
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpbp_get_attributes(struct fsl_mc_io	*mc_io,
-			uint32_t	cmd_flags,
+			uint32_t		cmd_flags,
 			uint16_t		token,
 			struct dpbp_attr	*attr);
 
@@ -430,9 +425,23 @@ int dpbp_set_notifications(struct fsl_mc_io	*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpbp_get_notifications(struct fsl_mc_io	*mc_io,
-			   uint32_t		cmd_flags,
-			      uint16_t		token,
-			      struct dpbp_notification_cfg	*cfg);
+int dpbp_get_notifications(struct fsl_mc_io		*mc_io,
+			   uint32_t			cmd_flags,
+			   uint16_t			token,
+			   struct dpbp_notification_cfg	*cfg);
+
+/**
+ * dpbp_get_api_version() - Get buffer pool API version
+ * @mc_io:  Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @major_ver:	Major version of data path buffer pool API
+ * @minor_ver:	Minor version of data path buffer pool API
+ *
+ * Return:  '0' on Success; Error code otherwise.
+ */
+int dpbp_get_api_version(struct fsl_mc_io *mc_io,
+			 uint32_t cmd_flags,
+			 uint16_t *major_ver,
+			 uint16_t *minor_ver);
 
 #endif /* __FSL_DPBP_H */
diff --git a/drivers/staging/fsl-mc/include/dpcon-cmd.h b/drivers/staging/fsl-mc/include/dpcon-cmd.h
index ecb40d0..bf35382 100644
--- a/drivers/staging/fsl-mc/include/dpcon-cmd.h
+++ b/drivers/staging/fsl-mc/include/dpcon-cmd.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -33,31 +33,34 @@
 #define _FSL_DPCON_CMD_H
 
 /* DPCON Version */
-#define DPCON_VER_MAJOR				2
+#define DPCON_VER_MAJOR				3
 #define DPCON_VER_MINOR				2
+#define DPCON_CMD_BASE_VERSION			1
+#define DPCON_CMD_ID_OFFSET			4
 
 /* Command IDs */
-#define DPCON_CMDID_CLOSE				0x800
-#define DPCON_CMDID_OPEN				0x808
-#define DPCON_CMDID_CREATE				0x908
-#define DPCON_CMDID_DESTROY				0x900
-
-#define DPCON_CMDID_ENABLE				0x002
-#define DPCON_CMDID_DISABLE				0x003
-#define DPCON_CMDID_GET_ATTR				0x004
-#define DPCON_CMDID_RESET				0x005
-#define DPCON_CMDID_IS_ENABLED				0x006
-
-#define DPCON_CMDID_SET_IRQ				0x010
-#define DPCON_CMDID_GET_IRQ				0x011
-#define DPCON_CMDID_SET_IRQ_ENABLE			0x012
-#define DPCON_CMDID_GET_IRQ_ENABLE			0x013
-#define DPCON_CMDID_SET_IRQ_MASK			0x014
-#define DPCON_CMDID_GET_IRQ_MASK			0x015
-#define DPCON_CMDID_GET_IRQ_STATUS			0x016
-#define DPCON_CMDID_CLEAR_IRQ_STATUS			0x017
-
-#define DPCON_CMDID_SET_NOTIFICATION			0x100
+#define DPCON_CMDID_CLOSE                       ((0x800 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_OPEN                        ((0x808 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_CREATE                      ((0x908 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_DESTROY                     ((0x988 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_GET_API_VERSION             ((0xa08 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+
+#define DPCON_CMDID_ENABLE                      ((0x002 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_DISABLE                     ((0x003 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_GET_ATTR                    ((0x004 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_RESET                       ((0x005 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_IS_ENABLED                  ((0x006 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+
+#define DPCON_CMDID_SET_IRQ                     ((0x010 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_GET_IRQ                     ((0x011 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_SET_IRQ_ENABLE              ((0x012 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_GET_IRQ_ENABLE              ((0x013 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_SET_IRQ_MASK                ((0x014 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_GET_IRQ_MASK                ((0x015 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_GET_IRQ_STATUS              ((0x016 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+#define DPCON_CMDID_CLEAR_IRQ_STATUS            ((0x017 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
+
+#define DPCON_CMDID_SET_NOTIFICATION            ((0x100 << DPCON_CMD_ID_OFFSET) | DPCON_CMD_BASE_VERSION)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPCON_CMD_OPEN(cmd, dpcon_id) \
@@ -147,8 +150,6 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  32, int,	    attr->id);\
 	MC_RSP_OP(cmd, 0, 32, 16, uint16_t, attr->qbman_ch_id);\
 	MC_RSP_OP(cmd, 0, 48, 8,  uint8_t,  attr->num_priorities);\
-	MC_RSP_OP(cmd, 1, 0,  16, uint16_t, attr->version.major);\
-	MC_RSP_OP(cmd, 1, 16, 16, uint16_t, attr->version.minor);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
diff --git a/drivers/staging/fsl-mc/include/dpcon.h b/drivers/staging/fsl-mc/include/dpcon.h
index 2555be5..b81c37c 100644
--- a/drivers/staging/fsl-mc/include/dpcon.h
+++ b/drivers/staging/fsl-mc/include/dpcon.h
@@ -1,4 +1,4 @@
-/* Copyright 2013-2015 Freescale Semiconductor Inc.
+/* Copyright 2013-2016 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -63,9 +63,9 @@ struct fsl_mc_io;
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpcon_open(struct fsl_mc_io *mc_io,
-	       uint32_t	cmd_flags,
+	       uint32_t		cmd_flags,
 	       int		dpcon_id,
-	       uint16_t	*token);
+	       uint16_t		*token);
 
 /**
  * dpcon_close() - Close the control session of the object
@@ -78,9 +78,9 @@ int dpcon_open(struct fsl_mc_io *mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpcon_close(struct fsl_mc_io *mc_io,
-		uint32_t	cmd_flags,
-		uint16_t	token);
+int dpcon_close(struct fsl_mc_io	*mc_io,
+		uint32_t		cmd_flags,
+		uint16_t		token);
 
 /**
  * struct dpcon_cfg - Structure representing DPCON configuration
@@ -93,9 +93,10 @@ struct dpcon_cfg {
 /**
  * dpcon_create() - Create the DPCON object.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @dprc_token:	Parent container token; '0' for default container
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @cfg:	Configuration structure
- * @token:	Returned token; use in subsequent API calls
+ * @obj_id: returned object id
  *
  * Create the DPCON object, allocate required resources and
  * perform required initialization.
@@ -103,31 +104,39 @@ struct dpcon_cfg {
  * The object can be created either by declaring it in the
  * DPL file, or by calling this function.
  *
- * This function returns a unique authentication token,
- * associated with the specific object ID and the specific MC
- * portal; this token must be used in all subsequent calls to
- * this specific object. For objects that are created using the
- * DPL file, call dpcon_open() function to get an authentication
- * token first.
+ * The function accepts an authentication token of a parent
+ * container that this object should be assigned to. The token
+ * can be '0' so the object will be assigned to the default container.
+ * The newly created object can be opened with the returned
+ * object id and using the container's associated tokens and MC portals.
  *
  * Return:	'0' on Success; Error code otherwise.
  */
 int dpcon_create(struct fsl_mc_io	*mc_io,
-		 uint32_t		cmd_flags,
-		 const struct dpcon_cfg *cfg,
-		 uint16_t		*token);
+		 uint16_t		dprc_token,
+		uint32_t		cmd_flags,
+		const struct dpcon_cfg	*cfg,
+		uint32_t		*obj_id);
 
 /**
  * dpcon_destroy() - Destroy the DPCON object and release all its resources.
  * @mc_io:	Pointer to MC portal's I/O object
+ * @dprc_token: Parent container token; '0' for default container
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPCON object
+ * @object_id:	The object id; it must be a valid id within the container that
+ * created this object;
+ *
+ * The function accepts the authentication token of the parent container that
+ * created the object (not the one that currently owns the object). The object
+ * is searched within parent using the provided 'object_id'.
+ * All tokens to the object must be closed before calling destroy.
  *
  * Return:	'0' on Success; error code otherwise.
  */
 int dpcon_destroy(struct fsl_mc_io	*mc_io,
-		  uint32_t		cmd_flags,
-		  uint16_t		token);
+		  uint16_t		dprc_token,
+		uint32_t		cmd_flags,
+		uint32_t		object_id);
 
 /**
  * dpcon_enable() - Enable the DPCON
@@ -279,8 +288,8 @@ int dpcon_get_irq_enable(struct fsl_mc_io	*mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpcon_set_irq_mask(struct fsl_mc_io *mc_io,
-		       uint32_t	cmd_flags,
+int dpcon_set_irq_mask(struct fsl_mc_io	*mc_io,
+		       uint32_t		cmd_flags,
 		       uint16_t		token,
 		       uint8_t		irq_index,
 		       uint32_t		mask);
@@ -298,8 +307,8 @@ int dpcon_set_irq_mask(struct fsl_mc_io *mc_io,
  *
  * Return:	'0' on Success; Error code otherwise.
  */
-int dpcon_get_irq_mask(struct fsl_mc_io *mc_io,
-		       uint32_t	cmd_flags,
+int dpcon_get_irq_mask(struct fsl_mc_io	*mc_io,
+		       uint32_t		cmd_flags,
 		       uint16_t		token,
 		       uint8_t		irq_index,
 		       uint32_t		*mask);
@@ -343,21 +352,11 @@ int dpcon_clear_irq_status(struct fsl_mc_io	*mc_io,
 /**
  * struct dpcon_attr - Structure representing DPCON attributes
  * @id: DPCON object ID
- * @version: DPCON version
  * @qbman_ch_id: Channel ID to be used by dequeue operation
  * @num_priorities: Number of priorities for the DPCON channel (1-8)
  */
 struct dpcon_attr {
 	int id;
-	/**
-	 * struct version - DPCON version
-	 * @major: DPCON major version
-	 * @minor: DPCON minor version
-	 */
-	struct {
-		uint16_t major;
-		uint16_t minor;
-	} version;
 	uint16_t qbman_ch_id;
 	uint8_t num_priorities;
 };
@@ -377,7 +376,8 @@ int dpcon_get_attributes(struct fsl_mc_io	*mc_io,
 			 struct dpcon_attr	*attr);
 
 /**
- * struct dpcon_notification_cfg - Structure representing notification parameters
+ * struct dpcon_notification_cfg - Structure representing notification
+ *					parameters
  * @dpio_id:	DPIO object ID; must be configured with a notification channel;
  *	to disable notifications set it to 'DPCON_INVALID_DPIO_ID';
  * @priority:	Priority selection within the DPIO channel; valid values
@@ -386,7 +386,7 @@ int dpcon_get_attributes(struct fsl_mc_io	*mc_io,
  */
 struct dpcon_notification_cfg {
 	int		dpio_id;
-	uint8_t	priority;
+	uint8_t		priority;
 	uint64_t	user_ctx;
 };
 
@@ -404,4 +404,18 @@ int dpcon_set_notification(struct fsl_mc_io			*mc_io,
 			   uint16_t				token,
 			   struct dpcon_notification_cfg	*cfg);
 
+/**
+ * dpcon_get_api_version() - Get Data Path Concentrator API version
+ * @mc_io:  Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @major_ver:	Major version of data path concentrator API
+ * @minor_ver:	Minor version of data path concentrator API
+ *
+ * Return:  '0' on Success; Error code otherwise.
+ */
+int dpcon_get_api_version(struct fsl_mc_io *mc_io,
+			  uint32_t cmd_flags,
+			  uint16_t *major_ver,
+			  uint16_t *minor_ver);
+
 #endif /* __FSL_DPCON_H */
-- 
2.9.3

