From d7d1c7a7c3c41c5a5f602c77c588672ee179758a Mon Sep 17 00:00:00 2001
From: Varun Sethi <Varun.Sethi@freescale.com>
Date: Fri, 12 Apr 2013 12:33:19 +0530
Subject: [PATCH 144/429] iommu/fsl: PAMU driver fix for t4240.

While obtaining the stash destination from the device tree, current code
was assuming a single cpu reg property value. In case of t4240, the e6500
cpu node has two entries per reg property. Thus, for certain cpu values code
wasn't able to find a valid device tree node.

The code also lacked a check to identify if a valid cpu node (cpu node for a stash
target) had been found. Thus, resulting in a crash on null cpu node pointer access.

This patch fixes the issue, by introducing a mechanism to process all cpu
reg property values per cpu node. Also, introduced chek to identify if
cpu node corresponding to the stash vcpu has been found or not.

Additionally, added a check for l3-cache-controller compatible strings
for T4 and B4 devices.

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Change-Id: Iced2d9b85cb87a01a6cbc8cb1a592f92e9f7f704
Reviewed-on: http://git.am.freescale.net:8181/1276
Reviewed-by: Yoder Stuart-B08248 <stuart.yoder@freescale.com>
Reviewed-by: Schmitt Richard-B43082 <B43082@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/iommu/fsl_pamu.c |   33 +++++++++++++++++++++++++++------
 1 files changed, 27 insertions(+), 6 deletions(-)

diff --git a/drivers/iommu/fsl_pamu.c b/drivers/iommu/fsl_pamu.c
index 459f7a4..102ecd9 100644
--- a/drivers/iommu/fsl_pamu.c
+++ b/drivers/iommu/fsl_pamu.c
@@ -66,6 +66,22 @@ static const struct of_device_id guts_device_ids[] = {
 	{}
 };
 
+
+/*
+ * Table for matching compatible strings, for device tree
+ * L3 cache controller node.
+ * "fsl,t4240-l3-cache-controller" corresponds to T4,
+ * "fsl,b4860-l3-cache-controller" corresponds to B4 &
+ * "fsl,p4080-l3-cache-controller" corresponds to other,
+ * SOCs.
+*/
+static const struct of_device_id l3_device_ids[] = {
+	{ .compatible = "fsl,t4240-l3-cache-controller", },
+	{ .compatible = "fsl,b4860-l3-cache-controller", },
+	{ .compatible = "fsl,p4080-l3-cache-controller", },
+	{}
+};
+
 /* maximum subwindows permitted per liodn */
 static u32 max_subwindow_count;
 
@@ -521,12 +537,12 @@ u32 get_stash_id(u32 stash_dest_hint, u32 vcpu)
 	const u32 *prop;
 	struct device_node *node;
 	u32 cache_level;
-	int len;
+	int len, found = 0;
+	int i;
 
 	/* Fastpath, exit early if L3/CPC cache is target for stashing */
 	if (stash_dest_hint == IOMMU_ATTR_CACHE_L3) {
-		node = of_find_compatible_node(NULL, NULL,
-				"fsl,p4080-l3-cache-controller");
+		node = of_find_matching_node(NULL, l3_device_ids);
 		if (node) {
 			prop = of_get_property(node, "cache-stash-id", 0);
 			if (!prop) {
@@ -542,12 +558,17 @@ u32 get_stash_id(u32 stash_dest_hint, u32 vcpu)
 
 	for_each_node_by_type(node, "cpu") {
 		prop = of_get_property(node, "reg", &len);
-		if (be32_to_cpup(prop) == vcpu)
-			break;
+		for (i = 0; i < len / sizeof(u32); i++) {
+			if (be32_to_cpup(&prop[i]) == vcpu) {
+				found = 1;
+				goto found_cpu_node;
+			}
+		}
 	}
+found_cpu_node:
 
 	/* find the hwnode that represents the cache */
-	for (cache_level = IOMMU_ATTR_CACHE_L1; cache_level < IOMMU_ATTR_CACHE_L3; cache_level++) {
+	for (cache_level = IOMMU_ATTR_CACHE_L1; cache_level < IOMMU_ATTR_CACHE_L3 && found; cache_level++) {
 		if (stash_dest_hint == cache_level) {
 			prop = of_get_property(node, "cache-stash-id", 0);
 			if (!prop) {
-- 
1.7.5.4

