From 8dcd82bf01d0529bf7ffd16b199d22e2f9eb929d Mon Sep 17 00:00:00 2001
From: Haijun Zhang <Haijun.Zhang@freescale.com>
Date: Mon, 14 Oct 2013 16:37:38 +0800
Subject: [PATCH 282/429] esdhc: Workaround for eSDHC clock glitch issue

A-003980: SDHC: Glitch is generated on the card clock with software reset or
clock divider change
Description: A glitch may occur on the SDHC card clock when the software sets
the RSTA bit (software reset) in the system control register. It can also be
generated by setting the clock divider value. The glitch produced can cause
the external card to switch to an unknown state. The occurrence is not
deterministic.
Workaround:
A simple workaround is to disable the SD card clock before the software reset,
and enable it when the module resumes normal operation.
The Host and the SD card are in a master-slave relationship. The Host provides
clock and control transfer across the interface. Therefore, any existing
operation is discarded when the Host controller is reset.
The recommended flow is as follows:
1. Software disable bit[3], SDCLKEN, of the System Control Register
2. Trigger software reset and/or set clock divider
3. Check bit[3], SDSTB, of the Present State Register for stable clock
4. Enable bit[3], SDCLKEN, of the System Control Register
Using the above method, the eSDHC cannot send command or transfer data when

there is a glitch in the clock line, and the glitch does not cause any issue.
Signed-off-by: Haijun Zhang <haijun.zhang@freescale.com>
Change-Id: I1d8c3757ffdab73aff92cf1f0a6b89f82d11acfe
Reviewed-on: http://git.am.freescale.net:8181/4357
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Xie Xiaobo-R63061 <X.Xie@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/mmc/host/sdhci-esdhc.h    |   22 ++++++++++++++++++++--
 drivers/mmc/host/sdhci-of-esdhc.c |   22 +++++++++++++++++-----
 include/linux/mmc/sdhci.h         |    2 ++
 3 files changed, 39 insertions(+), 7 deletions(-)

diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index 777a418..d4e591a 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -31,6 +31,7 @@
 #define ESDHC_CLOCK_MASK	0x0000fff0
 #define ESDHC_PREDIV_SHIFT	8
 #define ESDHC_DIVIDER_SHIFT	4
+#define ESDHC_CLOCK_CRDEN	0x00000008
 #define ESDHC_CLOCK_PEREN	0x00000004
 #define ESDHC_CLOCK_HCKEN	0x00000002
 #define ESDHC_CLOCK_IPGEN	0x00000001
@@ -41,6 +42,8 @@
 /* OF-specific */
 #define ESDHC_DMA_SYSCTL	0x40c
 #define ESDHC_DMA_SNOOP		0x00000040
+#define ESDHCI_PRESENT_STATE	0x24
+#define ESDHC_CLK_STABLE	0x00000008
 
 #define ESDHC_HOST_CONTROL_RES	0x01
 #define ESDHC_VOL_SEL		0x04
@@ -51,6 +54,7 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 	int div = 1;
 	u32 temp;
 	u32 actual_clk;
+	u32 timeout;
 
 #ifdef CONFIG_MMC_SDHCI_ESDHC_IMX
 	struct esdhc_platform_data *boarddata;
@@ -63,7 +67,7 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 
 	temp = sdhci_readl(host, ESDHC_SYSTEM_CONTROL);
 	temp &= ~(ESDHC_CLOCK_IPGEN | ESDHC_CLOCK_HCKEN | ESDHC_CLOCK_PEREN
-		| ESDHC_CLOCK_MASK);
+		| ESDHC_CLOCK_MASK | ESDHC_CLOCK_CRDEN);
 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 
 	while (host->max_clk / pre_div / 16 > clock && pre_div < 256)
@@ -84,7 +88,21 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 		| (div << ESDHC_DIVIDER_SHIFT)
 		| (pre_div << ESDHC_PREDIV_SHIFT));
 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
-	mdelay(1);
+
+	/* Wait max 20 ms */
+	timeout = 20;
+	while (!(sdhci_readl(host, ESDHCI_PRESENT_STATE) & ESDHC_CLK_STABLE)) {
+		if (timeout == 0) {
+			pr_err("%s: Internal clock never stabilised.\n",
+					mmc_hostname(host->mmc));
+			return;
+		}
+		timeout--;
+		mdelay(1);
+	}
+
+	temp |= ESDHC_CLOCK_CRDEN;
+	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 
 	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK) {
 		host->timeout_clk = actual_clk / 1000;
diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c
index 56c04a2..542a210 100644
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@ -335,14 +335,26 @@ static void esdhc_of_resume(struct sdhci_host *host)
 static u32 clock;
 static void esdhc_of_platform_reset_enter(struct sdhci_host *host, u8 mask)
 {
-	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
-		clock = host->clock;
+	if ((host->quirks2 & SDHCI_QUIRK2_DISABLE_CLOCK_BEFORE_RESET) &&
+			(mask & SDHCI_RESET_ALL)) {
+		u16 clk;
+
+		clk = esdhc_readw(host, SDHCI_CLOCK_CONTROL);
+		clk &= ~ESDHC_CLOCK_CRDEN;
+		esdhc_writew(host, clk, SDHCI_CLOCK_CONTROL);
+	}
 }
 
 static void esdhc_of_platform_reset_exit(struct sdhci_host *host, u8 mask)
 {
-	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
-		host->clock = clock;
+	if ((host->quirks2 & SDHCI_QUIRK2_DISABLE_CLOCK_BEFORE_RESET) &&
+			(mask & SDHCI_RESET_ALL)) {
+		u16 clk;
+
+		clk = esdhc_readw(host, SDHCI_CLOCK_CONTROL);
+		clk |= ESDHC_CLOCK_CRDEN;
+		esdhc_writew(host, clk, SDHCI_CLOCK_CONTROL);
+	}
 }
 static void esdhc_of_platform_init(struct sdhci_host *host)
 {
@@ -370,7 +382,7 @@ static void esdhc_of_platform_init(struct sdhci_host *host)
 		((SVR_SOC_VER(svr) == SVR_P3041) && (SVR_REV(svr) == 0x10)) ||
 		((SVR_SOC_VER(svr) == SVR_P3041) && (SVR_REV(svr) == 0x20)) ||
 		((SVR_SOC_VER(svr) == SVR_P2041) && (SVR_REV(svr) <= 0x20)))
-		host->quirks2 |= SDHCI_QUIRK2_BROKEN_RESET_ALL;
+		host->quirks2 |= SDHCI_QUIRK2_DISABLE_CLOCK_BEFORE_RESET;
 }
 
 /* Return: none zero - the card is presetn; 0 - card is absent */
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 0e152bc7..540bb3a 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -109,6 +109,8 @@ struct sdhci_host {
  */
 #define SDHCI_QUIRK2_CIRCUIT_SUPPORT_VS33		(1<<5)
 #define SDHCI_QUIRK2_FORCE_CMD13_DETECT_CARD		(1<<6)
+/* Controller need to disable clock before reset all */
+#define SDHCI_QUIRK2_DISABLE_CLOCK_BEFORE_RESET		(1<<7)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
-- 
1.7.5.4

