From 389ef86121abbf1a2f854c93ec7bebe06e8ca102 Mon Sep 17 00:00:00 2001
From: Andrei Varvara <andrei.varvara@freescale.com>
Date: Thu, 24 Oct 2013 15:45:53 +0300
Subject: [PATCH 300/429] dpa_offload: Add support for getting the current SA
 Sequence Number or ESN

The requirements is needed in order to support IPSec High Availability.

Add new functions into the dpa_ipsec API:
    -dpa_ipsec_sa_request_seq_number
    -dpa_ipsec_sa_get_seq_number

Request the sequence number of an SA asynchronous - SEC will
dequeue a frame with RJD, run it and after this create an
output frame with status of user error. The frame will have always the
length of 5 bytes, first one representing the operation code that has
finished and the next 4 will determine the SA id on which the operation took
place.

The get seq number have to be called by the user when it receives
the fd with user error for this SA. The API will return the SEQ
number.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Change-Id: I154ea8ee9cfc95eae0ef24cdb3f3559a0748baf0
Reviewed-on: http://git.am.freescale.net:8181/6037
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c      |  122 ++++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h      |    2 +
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c |  118 +++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h |    1 +
 include/linux/fsl_dpa_ipsec.h                    |   34 ++++++-
 5 files changed, 275 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 3eaefec..17fbbc8 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -3380,6 +3380,7 @@ int dpa_ipsec_create_sa(int dpa_ipsec_id,
 	sa->child_sa = NULL;
 	sa->sa_rekeying_node.next = LIST_POISON1;
 	sa->sa_rekeying_node.prev = LIST_POISON2;
+	sa->read_seq_in_progress = false;
 
 	/* Copy SA params into the internal SA structure */
 	if (sa_is_outbound(sa))
@@ -5064,3 +5065,124 @@ int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm)
 	return ret;
 }
 EXPORT_SYMBOL(dpa_ipsec_sa_modify);
+int dpa_ipsec_sa_request_seq_number(int sa_id)
+{
+	struct dpa_ipsec_sa *sa;
+	dma_addr_t dma_rjobd;
+	uint32_t *rjobd;
+	struct qm_fd fd;
+	char msg[5];
+	const size_t msg_len = 5;
+	int ret;
+
+	sa = get_sa_from_sa_id(sa_id);
+	if (!sa) {
+		pr_err("Invalid SA id provided\n");
+		return -EINVAL;
+	}
+
+	ret = mutex_trylock(&sa->lock);
+	if (ret == 0) {
+		pr_err("SA %d is being used\n", sa->id);
+		return -EBUSY;
+	}
+
+	BUG_ON(!sa->dpa_ipsec);
+
+	if (sa->read_seq_in_progress) {
+		pr_err("A new request for SA %d can be done only after a get SEQ is done\n",
+			sa->id);
+		mutex_unlock(&sa->lock);
+		return -EBUSY;
+	}
+
+	msg[0] = DPA_IPSEC_SA_GET_SEQ_NUM_DONE;
+	*(u32 *)(&msg[1]) = sa->id;
+
+	ret = build_rjob_desc_seq_read(sa, msg_len);
+	if (ret < 0) {
+		pr_err("Failed to create RJOB for reading SEQ number\n");
+		mutex_unlock(&sa->lock);
+		return ret;
+	}
+
+	rjobd = sa->rjob_desc;
+
+	/* Copy completion message to the end of the RJOB */
+	memcpy(((char *)rjobd) + desc_len(rjobd) * CAAM_CMD_SZ, msg, msg_len);
+
+	dma_rjobd = dma_map_single(sa->dpa_ipsec->jrdev, rjobd,
+				   desc_len(rjobd) * CAAM_CMD_SZ + msg_len,
+				   DMA_BIDIRECTIONAL);
+	if (!dma_rjobd) {
+		pr_err("Failed DMA mapping the RJD for SA %d\n", sa->id);
+		mutex_unlock(&sa->lock);
+		return -ENXIO;
+	}
+
+	memset(&fd, 0x00, sizeof(struct qm_fd));
+	/* fill frame descriptor parameters */
+	fd.format = qm_fd_contig;
+	qm_fd_addr_set64(&fd, dma_rjobd);
+	fd.length20 = desc_len(rjobd) * sizeof(uint32_t) + msg_len;
+	fd.offset = 0;
+	fd.bpid = 0;
+	fd.cmd = FD_CMD_REPLACE_JOB_DESC;
+	ret = qman_enqueue(sa->to_sec_fq, &fd, 0);
+	if (ret != 0) {
+		pr_err("Could not enqueue frame with RJAD for SA %d\n", sa->id);
+		ret = -ETXTBSY;
+	}
+
+	/* Request has been done successfully */
+	sa->read_seq_in_progress = true;
+
+	dma_unmap_single(sa->dpa_ipsec->jrdev, dma_rjobd,
+			 desc_len(rjobd) * CAAM_CMD_SZ + msg_len,
+			 DMA_BIDIRECTIONAL);
+
+	mutex_unlock(&sa->lock);
+
+	return ret;
+}
+EXPORT_SYMBOL(dpa_ipsec_sa_request_seq_number);
+
+int dpa_ipsec_sa_get_seq_number(int sa_id, uint64_t *seq)
+{
+	struct dpa_ipsec_sa *sa;
+	int ret;
+
+	sa = get_sa_from_sa_id(sa_id);
+	if (!sa) {
+		pr_err("Invalid SA id provided\n");
+		return -EINVAL;
+	}
+
+	if (!seq) {
+		pr_err("Invalid SEQ parameter handle\n");
+		return -EINVAL;
+	}
+
+	ret = mutex_trylock(&sa->lock);
+	if (ret == 0) {
+		pr_err("SA %d is being used\n", sa_id);
+		return -EBUSY;
+	}
+
+	BUG_ON(!sa->dpa_ipsec);
+
+	if (!sa->read_seq_in_progress) {
+		pr_err("Prior to getting the SEQ number for SA %d a request must be made\n",
+			sa->id);
+		mutex_unlock(&sa->lock);
+		return -EBUSY;
+	}
+
+	*seq = sa->r_seq_num;
+	sa->read_seq_in_progress = false;
+
+	mutex_unlock(&sa->lock);
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_ipsec_sa_get_seq_number);
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 6ac903e..6868dcc 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -242,6 +242,8 @@ struct dpa_ipsec_sa {
 	bool	 sec_desc_extended; /* true if SEC descriptor is extended     */
 	uint32_t *rjob_desc_unaligned;
 	uint32_t *rjob_desc; /* replacement job descriptor address	      */
+	uint64_t r_seq_num; /* RJD will read here the SEQ number for this SA  */
+	bool	 read_seq_in_progress; /* true if a request came but a get not*/
 	uint32_t stats_offset; /* Offset of the statistics (in bytes)	      */
 	uint32_t stats_indx; /* Index of the lifetime counter in descriptor   */
 	uint32_t next_cmd_indx; /* Next command index after SHD header	      */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 7e2ec0e..2ffd4f8 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -1688,6 +1688,124 @@ int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw,
 	return 0;
 }
 
+/*
+ * The SEQ number value will be placed at the address specified by SEQ pointer
+ */
+int build_rjob_desc_seq_read(struct dpa_ipsec_sa *sa, u32 msg_len)
+{
+	uint32_t *rjobd, off_b = 0, off;
+	dma_addr_t dma_shdesc, out_addr;
+
+	/* Check input parameters */
+	BUG_ON(!sa);
+	BUG_ON(!sa->sec_desc);
+
+	/* Get DMA address for this SA shared descriptor */
+	dma_shdesc = dma_map_single(sa->dpa_ipsec->jrdev, sa->sec_desc->desc,
+				    desc_len(sa->sec_desc->desc) * sizeof(u32),
+				    DMA_BIDIRECTIONAL);
+	if (!dma_shdesc) {
+		pr_err("Failed DMA map shared descriptor for SA %d\n", sa->id);
+		return -ENXIO;
+	}
+
+	/* Get DMA address for this SA shared descriptor */
+	out_addr = dma_map_single(sa->dpa_ipsec->jrdev, &sa->r_seq_num,
+				  sizeof(sa->r_seq_num), DMA_BIDIRECTIONAL);
+	if (!out_addr) {
+		pr_err("Failed DMA map output address for SA %d\n", sa->id);
+		dma_unmap_single(sa->dpa_ipsec->jrdev, dma_shdesc,
+				 desc_len(sa->sec_desc->desc) * sizeof(u32),
+				 DMA_BIDIRECTIONAL);
+		return -ENXIO;
+	}
+
+	/* Create replacement job descriptor for SEQ/ESEQ Number update */
+	BUG_ON(!sa->rjob_desc);
+	rjobd = sa->rjob_desc;
+
+	init_job_desc(rjobd, HDR_SHARE_SERIAL | HDR_SHARED | HDR_REVERSE |
+		      (desc_len(sa->sec_desc->desc) << HDR_START_IDX_SHIFT));
+
+	/* Set DMA address of the shared descriptor */
+	append_ptr(rjobd, dma_shdesc);
+
+	/* Retrieve SEQ number from PDB in MATH 0 - offset is in bytes */
+	off_b = sa_is_inbound(sa) ?
+		offsetof(struct ipsec_decap_pdb, seq_num_ext_hi) + sizeof(u32) :
+		offsetof(struct ipsec_encap_pdb, seq_num_ext_hi) + sizeof(u32);
+
+	append_move(rjobd, MOVE_SRC_DESCBUF | MOVE_DEST_MATH0 | MOVE_WAITCOMP |
+		    (off_b << MOVE_OFFSET_SHIFT) | sizeof(u64));
+
+	/* Store SEQ number - length is in bytes */
+	append_store(rjobd, out_addr, sizeof(sa->r_seq_num),
+		     LDST_CLASS_DECO | LDST_SRCDST_WORD_DECO_MATH0);
+
+	/* wait for completion of previous operation */
+	append_jump(rjobd, JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT));
+
+	/*
+	 * Overwrite RJD immediately after the SHD pointer i.e shared descriptor
+	 * length plus 1 plus another 3 words
+	 * Offset and length are expressed in words
+	 * 3w - RJD header + SHD pointer
+	 * 5w - five instructions for doing some part of SEQ number modification
+	 * 3w - load instruction + pointer
+	 * 1w - jump calm
+	 * 1w - jump back to the remaining descriptor
+	 */
+	append_load(rjobd, virt_to_phys((void *)(rjobd + 3 + 5 + 3 + 1 + 1)),
+		    6, LDST_CLASS_DECO | LDST_SRCDST_WORD_DESCBUF |
+		    ((desc_len(sa->sec_desc->desc) + 3) << LDST_OFFSET_SHIFT));
+
+	/* wait for completion of previous operation */
+	append_jump(rjobd, JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT));
+
+	/* jump back to remaining descriptor i.e jump back 9 words */
+	off = (-9) & 0x000000FF;
+	append_jump(rjobd, (off << JUMP_OFFSET_SHIFT));
+
+	/*
+	 * The following instructions are used to copy the completion
+	 * message into the output frame
+	 */
+
+	/* ld: deco-deco-ctrl len=0 offs=8 imm -auto-nfifo-entries */
+	append_cmd(rjobd, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);
+
+	/* seqfifold: both msgdata-last2-last1-flush1 len=4 */
+	append_seq_fifo_load(rjobd, msg_len, FIFOLD_TYPE_MSG |
+			     FIFOLD_CLASS_BOTH | FIFOLD_TYPE_LAST1 |
+			     FIFOLD_TYPE_LAST2 | FIFOLD_TYPE_FLUSH1);
+
+	/* ld: deco-deco-ctrl len=0 offs=4 imm +auto-nfifo-entries */
+	append_cmd(rjobd, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);
+
+	/* copy completion message */
+	append_move(rjobd, MOVE_SRC_INFIFO | MOVE_DEST_OUTFIFO | msg_len);
+
+	/* seqfifostr: msgdata len=4 */
+	append_seq_fifo_store(rjobd, FIFOST_TYPE_MESSAGE_DATA, msg_len);
+
+	/*
+	 * Exit replacement job descriptor, halt with user error
+	 * FD status will be a special user error, generated only on request by
+	 * a descriptor command
+	 */
+	append_cmd(rjobd, 0xA1C01002);
+
+	dma_unmap_single(sa->dpa_ipsec->jrdev, dma_shdesc,
+			 desc_len(sa->sec_desc->desc) * sizeof(u32),
+			 DMA_BIDIRECTIONAL);
+
+	dma_unmap_single(sa->dpa_ipsec->jrdev, out_addr,
+			 sizeof(sa->r_seq_num),
+			 DMA_BIDIRECTIONAL);
+
+	return 0;
+}
+
 static void split_key_done(struct device *dev, u32 * desc, u32 err,
 			   void *context)
 {
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
index b0829dd..06f0727 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
@@ -92,5 +92,6 @@ int create_sec_descriptor(struct dpa_ipsec_sa *sa);
 int generate_split_key(struct auth_params *auth_param);
 int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw,
 			       u32 msg_len);
+int build_rjob_desc_seq_read(struct dpa_ipsec_sa *sa, u32 msg_len);
 
 #endif	/* _DPA_IPSEC_DESC_H_ */
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index 0fd1456..337b006 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -536,10 +536,19 @@ struct dpa_ipsec_sa_modify_prm {
 
 	/* Use to select a modify operation */
 	enum dpa_ipsec_sa_modify_type type;
+
 	union {
+		/* Anti replay window size */
 		enum dpa_ipsec_arw arw;
-		uint32_t seq;
-		uint64_t ext_seq;
+
+		/*
+		 * 32 bit or extended sequence number depending on how the
+		 * SA was created by dpa_ipsec_create_sa
+		 * Only the least significant word is used for 32 bit SEQ
+		 */
+		uint64_t seq_num;
+
+		/* New cryptographic parameters for this SA */
 		struct dpa_ipsec_sa_crypto_params crypto_params;
 	};
 };
@@ -563,6 +572,27 @@ struct dpa_ipsec_sa_modify_prm {
  *
  */
 int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm);
+
+/*
+ * Request the sequence number of an SA asynchronous
+ *
+ * SEC will dequeue a frame with RJD, run it and after this create an
+ * output frame with status of user error. The frame will have always the
+ * length of 5 bytes, first one representing the operation code that has
+ * finished and the next 4 will determine the SA id on which the operation took
+ * place.
+ *
+ *
+ * Returned error code:
+ *	0 if successful;
+ *	-EBUSY if can't acquire lock for this SA
+ *	-ENXIO if failed to DMA map Replacement Job Descriptor
+ *	-ETXTBSY if failed to enqueue to SEC the FD with RJD
+ */
+int dpa_ipsec_sa_request_seq_number(int sa_id);
+
+int dpa_ipsec_sa_get_seq_number(int sa_id, uint64_t *seq);
+
 /*
  * The dpa_ipsec_sa_modify and dpa_ipsec_sa_get_seq_number are asynchronous
  * operations.
-- 
1.7.5.4

