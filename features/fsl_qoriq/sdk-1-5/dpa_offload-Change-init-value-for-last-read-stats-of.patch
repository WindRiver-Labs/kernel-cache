From 345e043311f8fc3a2e2bb23208da085f96b701cf Mon Sep 17 00:00:00 2001
From: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Date: Tue, 22 Oct 2013 14:47:31 +0300
Subject: [PATCH 292/429] dpa_offload: Change init value for last read stats
 of a counter

When a DPA Stats counter is created the initialization value for
the 'last read statistics' should not be 0, but instead the value
read at the moment of creation. Changed this approach for all
counters both at creation and modify stage.

Change-Id: If184e564e1855c04aec6f49cc2c1fa79a67b4d18
Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/5896
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |  646 ++++++++++++++++-----------
 1 files changed, 394 insertions(+), 252 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index 2af3620..005fb96 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -56,6 +56,12 @@
 /* Global dpa_stats component */
 struct dpa_stats *gbl_dpa_stats;
 
+static void init_cnt_32bit_stats(struct stats_info *stats_info,
+				 void *stats, uint32_t idx);
+
+static void init_cnt_64bit_stats(struct stats_info *stats_info,
+				 void *stats, uint32_t idx);
+
 static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
 				      struct dpa_stats_cnt_cb *cnt_cb);
 
@@ -159,9 +165,11 @@ static int set_cnt_classif_node_retrieve_func(struct dpa_stats_cnt_cb *cnt_cb,
 	return 0;
 }
 
-static int check_tbl_cls_counter(struct dpa_stats_cnt_cb *cnt_cb,
-				 struct dpa_stats_lookup_key *entry)
+
+static int get_classif_tbl_key_stats(struct dpa_stats_cnt_cb *cnt_cb,
+				     uint32_t idx)
 {
+	struct dpa_stats_lookup_key *entry = &cnt_cb->tbl_cb.keys[idx];
 	t_FmPcdCcKeyStatistics stats;
 	int err;
 
@@ -208,13 +216,17 @@ static int check_tbl_cls_counter(struct dpa_stats_cnt_cb *cnt_cb,
 			cnt_cb->tbl_cb.type);
 		return -EINVAL;
 	}
+
+	init_cnt_32bit_stats(&cnt_cb->info, &stats, idx);
+
 	return 0;
 }
 
-static int check_ccnode_counter(struct dpa_stats_cnt_cb *cnt_cb,
+static int get_ccnode_key_stats(struct dpa_stats_cnt_cb *cnt_cb,
 				enum dpa_stats_classif_node_type ccnode_type,
-				struct dpa_offload_lookup_key *key)
+				uint32_t idx)
 {
+	struct dpa_offload_lookup_key *key = &cnt_cb->ccnode_cb.keys[idx];
 	t_FmPcdCcKeyStatistics stats;
 	int err;
 
@@ -229,7 +241,7 @@ static int check_ccnode_counter(struct dpa_stats_cnt_cb *cnt_cb,
 				"0x%p, keysize=%d, keybyte=\n", cnt_cb->id,
 				cnt_cb->ccnode_cb.cc_node, key->size);
 			dump_lookup_key(key);
-			return -EIO;
+			return -EINVAL;
 		}
 		break;
 	case DPA_STATS_CLASSIF_NODE_INDEXED:
@@ -242,7 +254,7 @@ static int check_ccnode_counter(struct dpa_stats_cnt_cb *cnt_cb,
 				", keysize=%d, keybyte=\n", cnt_cb->id,
 				cnt_cb->ccnode_cb.cc_node, key->size);
 			dump_lookup_key(key);
-			return -EIO;
+			return -EINVAL;
 		}
 		break;
 	case DPA_STATS_CLASSIF_NODE_EXACT_MATCH:
@@ -263,47 +275,104 @@ static int check_ccnode_counter(struct dpa_stats_cnt_cb *cnt_cb,
 			cnt_cb->tbl_cb.type);
 		return -EINVAL;
 	}
+
+	init_cnt_32bit_stats(&cnt_cb->info, &stats, idx);
+
 	return 0;
 }
 
-static int check_ccnode_miss_counter(void *cc_node, uint32_t id,
-				enum dpa_stats_classif_node_type ccnode_type)
+static int get_classif_tbl_miss_stats(struct dpa_stats_cnt_cb *cnt_cb,
+				      uint32_t idx)
 {
+	struct dpa_stats_lookup_key *key = &cnt_cb->tbl_cb.keys[idx];
 	t_FmPcdCcKeyStatistics stats;
 	int err;
 
-	switch (ccnode_type) {
+	switch (cnt_cb->tbl_cb.type) {
+	case DPA_CLS_TBL_HASH:
+		err = FM_PCD_HashTableGetMissStatistics(key->cc_node, &stats);
+		if (err != 0) {
+			log_err("Check failed for Classifier Table counter "
+				"id %d due to incorrect parameters: handle="
+				"0x%p\n", cnt_cb->id, key->cc_node);
+			return -EINVAL;
+		}
+		break;
+	case DPA_CLS_TBL_INDEXED:
+		err = FM_PCD_MatchTableGetMissStatistics(key->cc_node, &stats);
+		if (err != 0) {
+			log_err("Check failed for Classifier Table counter "
+				"id %d due to incorrect parameters: handle="
+				"0x%p\n", cnt_cb->id, key->cc_node);
+			return -EINVAL;
+		}
+		break;
+	case DPA_CLS_TBL_EXACT_MATCH:
+		err = FM_PCD_MatchTableGetMissStatistics(key->cc_node, &stats);
+		if (err != 0) {
+			log_err("Check failed for Classifier Table counter "
+				"id %d due to incorrect parameters: handle="
+				"0x%p\n", cnt_cb->id, key->cc_node);
+			return -EINVAL;
+		}
+		break;
+	default:
+		log_err("Unsupported Classifier Table type %d",
+				cnt_cb->tbl_cb.type);
+		return -EINVAL;
+	}
+
+	init_cnt_32bit_stats(&cnt_cb->info, &stats, idx);
+
+	return 0;
+}
+
+
+static int get_ccnode_miss_stats(struct dpa_stats_cnt_cb *cnt_cb,
+				 enum dpa_stats_classif_node_type type,
+				 uint32_t idx)
+{
+	t_FmPcdCcKeyStatistics stats;
+	int err;
+
+	switch (type) {
 	case DPA_STATS_CLASSIF_NODE_HASH:
-		err = FM_PCD_HashTableGetMissStatistics(cc_node, &stats);
+		err = FM_PCD_HashTableGetMissStatistics(
+					cnt_cb->ccnode_cb.cc_node, &stats);
 		if (err != 0) {
 			log_err("Check failed for Classification Node counter "
-				"id %d due to incorrect parameters: handle="
-				"0x%p\n", id, cc_node);
-			return -EIO;
+				"id %d due to incorrect parameters: handle=0x%p"
+				"\n", cnt_cb->id, cnt_cb->ccnode_cb.cc_node);
+			return -EINVAL;
 		}
 		break;
 	case DPA_STATS_CLASSIF_NODE_INDEXED:
-		err = FM_PCD_MatchTableGetMissStatistics(cc_node, &stats);
+		err = FM_PCD_MatchTableGetMissStatistics(
+					cnt_cb->ccnode_cb.cc_node, &stats);
 		if (err != 0) {
 			log_err("Check failed for Classification Node counter "
 				"id %d due to incorrect parameters: handle=0x%p"
-				"\n", id, cc_node);
-			return -EIO;
+				"\n", cnt_cb->id, cnt_cb->ccnode_cb.cc_node);
+			return -EINVAL;
 		}
 		break;
 	case DPA_STATS_CLASSIF_NODE_EXACT_MATCH:
-		err = FM_PCD_MatchTableGetMissStatistics(cc_node, &stats);
+		err = FM_PCD_MatchTableGetMissStatistics(
+					cnt_cb->ccnode_cb.cc_node, &stats);
 		if (err != 0) {
 			log_err("Check failed for Classification Node counter "
 				"id %d due to incorrect parameters: handle=0x%p"
-				"\n", id, cc_node);
+				"\n", cnt_cb->id, cnt_cb->ccnode_cb.cc_node);
 			return -EINVAL;
 		}
 		break;
 	default:
-		log_err("Unsupported Classification Node type %d", ccnode_type);
+		log_err("Unsupported Classification Node type %d", type);
 		return -EINVAL;
 	}
+
+	init_cnt_32bit_stats(&cnt_cb->info, &stats, idx);
+
 	return 0;
 }
 
@@ -1388,6 +1457,7 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 {
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	uint32_t cnt_sel = params->eth_params.cnt_sel;
+	t_FmMacStatistics stats;
 	t_Handle fm_mac = NULL;
 	int	 err = 0;
 
@@ -1417,6 +1487,15 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
+	cnt_cb->members_num = 1;
+
+	/* Map Ethernet counter selection to FM MAC statistics */
+	cnt_sel_to_stats(&cnt_cb->info,
+			 dpa_stats->stats_sel[DPA_STATS_CNT_ETH], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
 	/* Get FM MAC handle */
 	err = get_fm_mac(params->eth_params.src, &fm_mac);
 	if (err != 0) {
@@ -1424,16 +1503,15 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			"%d\n", cnt_cb->id);
 		return -EINVAL;
 	}
-
 	cnt_cb->gen_cb.objs[0] = fm_mac;
-	cnt_cb->members_num = 1;
 
-	/* Map Ethernet counter selection to FM MAC statistics */
-	cnt_sel_to_stats(&cnt_cb->info,
-			 dpa_stats->stats_sel[DPA_STATS_CNT_ETH], cnt_sel);
-
-	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
+	err = FM_MAC_GetStatistics(cnt_cb->gen_cb.objs[0], &stats);
+	if (err != 0) {
+		log_err("Invalid Ethernet counter source for counter id "
+			"%d\n", cnt_cb->id);
+		return -ENOENT;
+	}
+	init_cnt_64bit_stats(&cnt_cb->info, &stats, 0);
 
 	return 0;
 }
@@ -1476,14 +1554,6 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->gen_cb.objs[0] = params->reass_params.reass;
 	cnt_cb->members_num = 1;
 
-	/* Check the user-provided reassembly manip */
-	err = FM_PCD_ManipGetStatistics(params->reass_params.reass, &stats);
-	if (err < 0) {
-		log_err("Invalid Reassembly manip handle for counter id %d\n",
-			cnt_cb->id);
-		return -EINVAL;
-	}
-
 	/* Based on user option, change mask to all statistics in one group */
 	if (cnt_sel == DPA_STATS_CNT_REASS_GEN_ALL)
 		cnt_sel -= 1;
@@ -1501,6 +1571,15 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Set number of bytes that will be written by this counter */
 	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
+	/* Check the user-provided reassembly manip */
+	err = FM_PCD_ManipGetStatistics(params->reass_params.reass, &stats);
+	if (err < 0) {
+		log_err("Invalid Reassembly manip handle for counter id %d\n",
+			cnt_cb->id);
+		return -EINVAL;
+	}
+	init_cnt_32bit_stats(&cnt_cb->info, &stats, 0);
+
 	return 0;
 }
 
@@ -1534,14 +1613,6 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->gen_cb.objs[0] = params->frag_params.frag;
 	cnt_cb->members_num = 1;
 
-	/* Check the user-provided fragmentation handle */
-	err = FM_PCD_ManipGetStatistics(params->frag_params.frag, &stats);
-	if (err < 0) {
-		log_err("Invalid Fragmentation manip handle for counter id "
-			"%d\n", cnt_cb->id);
-		return -EINVAL;
-	}
-
 	/* Decrease one to obtain the mask for all statistics */
 	if (cnt_sel == DPA_STATS_CNT_FRAG_ALL)
 		cnt_sel -= 1;
@@ -1553,6 +1624,15 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Set number of bytes that will be written by this counter */
 	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
+	/* Check the user-provided fragmentation handle */
+	err = FM_PCD_ManipGetStatistics(params->frag_params.frag, &stats);
+	if (err < 0) {
+		log_err("Invalid Fragmentation manip handle for counter id "
+			"%d\n", cnt_cb->id);
+		return -EINVAL;
+	}
+	init_cnt_32bit_stats(&cnt_cb->info, &stats, 0);
+
 	return 0;
 }
 
@@ -1561,6 +1641,8 @@ static int set_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 {
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	uint32_t cnt_sel = params->plcr_params.cnt_sel;
+	uint64_t stats_val;
+	uint32_t i;
 
 	if (!dpa_stats) {
 		log_err("DPA Stats component is not initialized\n");
@@ -1595,6 +1677,14 @@ static int set_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Set number of bytes that will be written by this counter */
 	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
 
+	for (i = 0; i < cnt_cb->info.stats_num; i++) {
+		stats_val = (uint64_t)FM_PCD_PlcrProfileGetCounter(
+			cnt_cb->gen_cb.objs[0], cnt_cb->info.stats_off[i]);
+
+		/* Store the current value as the last read value */
+		cnt_cb->info.stats[0][i] = 0;
+		cnt_cb->info.last_stats[0][i] = stats_val;
+	}
 	return 0;
 }
 
@@ -1620,6 +1710,12 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Entire group of counters was selected */
 		if (cnt_sel == DPA_STATS_CNT_CLASSIF_ALL)
 			cnt_sel -= 1;
+
+		/* Map Classifier Table counter selection to CcNode stats */
+		cnt_sel_to_stats(&cnt_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+			cnt_sel >> CLASSIF_STATS_SHIFT);
+
 		frag_stats = 0;
 
 	} else if (cnt_sel >= DPA_STATS_CNT_FRAG_TOTAL_FRAMES &&
@@ -1628,6 +1724,11 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Entire group of counters was selected */
 		if (cnt_sel == DPA_STATS_CNT_FRAG_ALL)
 			cnt_sel -= 1;
+
+		/* Map Classifier Table counter selection to Frag stats */
+		cnt_sel_to_stats(&cnt_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
+
 		frag_stats = 1;
 
 	} else {
@@ -1663,6 +1764,9 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_tbl_cb->keys[0].valid = TRUE;
 	cnt_cb->members_num = 1;
 
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
 	/* Store DPA Classifier Table type */
 	cnt_tbl_cb->type = cls_tbl.type;
 
@@ -1675,9 +1779,8 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	if (!prm.key) {
 		cnt_tbl_cb->keys[0].miss_key = TRUE;
 
-		/* Check the Classifier Table counter parameters for "miss" */
-		err = check_ccnode_miss_counter(cnt_tbl_cb->keys[0].cc_node,
-				cnt_cb->id, cnt_tbl_cb->type);
+		/* Retrieve Classifier Table counter statistics for 'miss' */
+		err = get_classif_tbl_miss_stats(cnt_cb, 0);
 		if (err != 0)
 			return -EINVAL;
 	} else {
@@ -1689,10 +1792,10 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			return -EINVAL;
 		}
 
-		/* Check the Classifier Table counter */
-		err = check_tbl_cls_counter(cnt_cb, &cnt_tbl_cb->keys[0]);
+		/* Retrieve Classifier Table counter statistics for a key */
+		err = get_classif_tbl_key_stats(cnt_cb, 0);
 		if (err != 0)
-			return -EINVAL;
+			return err;
 	}
 
 	if (frag_stats) {
@@ -1702,21 +1805,9 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				" id %d\n", cnt_cb->id);
 			return -EINVAL;
 		}
-		/* Map Classifier Table counter selection to Frag stats */
-		cnt_sel_to_stats(&cnt_cb->info,
-			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
-
 		/* Change the retrieve routine */
 		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_frag_stats;
-	} else
-		/* Map Classifier Table counter selection to CcNode stats */
-		cnt_sel_to_stats(&cnt_cb->info,
-			dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
-			cnt_sel >> CLASSIF_STATS_SHIFT);
-
-	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
-
+	}
 	return 0;
 }
 
@@ -1750,6 +1841,14 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->ccnode_cb.cc_node = prm.cc_node;
 	cnt_cb->members_num = 1;
 
+	/* Map Classif Node counter selection to CcNode statistics */
+	cnt_sel_to_stats(&cnt_cb->info,
+		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+		prm.cnt_sel >> CLASSIF_STATS_SHIFT);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
 	/* Set retrieve function depending on counter type */
 	err = set_cnt_classif_node_retrieve_func(cnt_cb, prm.ccnode_type);
 	if (err != 0)
@@ -1759,11 +1858,8 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Set the key byte to NULL, to mark it for 'miss' entry */
 		cnt_cb->ccnode_cb.keys[0].byte = NULL;
 
-		/* Check the Classifier Node counter parameters for 'miss' */
-		err = check_ccnode_miss_counter(cnt_cb->ccnode_cb.cc_node,
-				cnt_cb->id, prm.ccnode_type);
-		if (err != 0)
-			return -EINVAL;
+		/* Retrieve Classifier Node counter statistics for 'miss' */
+		err = get_ccnode_miss_stats(cnt_cb, prm.ccnode_type, 0);
 	} else {
 		/* Copy the key descriptor */
 		err = copy_key_descriptor(prm.key, &cnt_cb->ccnode_cb.keys[0]);
@@ -1772,23 +1868,10 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				"parameters\n");
 			return -EINVAL;
 		}
-
-		/* Check the Classifier Node counter parameters */
-		err = check_ccnode_counter(cnt_cb, prm.ccnode_type,
-					   &cnt_cb->ccnode_cb.keys[0]);
-		if (err != 0)
-			return -EINVAL;
+		/* Retrieve Classifier Node counter statistics for key */
+		err = get_ccnode_key_stats(cnt_cb, prm.ccnode_type, 0);
 	}
-
-	/* Map Classif Node counter selection to CcNode statistics */
-	cnt_sel_to_stats(&cnt_cb->info,
-		dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
-		prm.cnt_sel >> CLASSIF_STATS_SHIFT);
-
-	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = STATS_VAL_SIZE * cnt_cb->info.stats_num;
-
-	return 0;
+	return err;
 }
 
 static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
@@ -1824,6 +1907,11 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->ipsec_cb.valid[0] = TRUE;
 	cnt_cb->members_num = 1;
 
+	/* Map IPSec counter selection to statistics */
+	err = cnt_gen_sel_to_stats(cnt_cb, params->ipsec_params.cnt_sel);
+	if (err < 0)
+		return err;
+
 	err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[0], &stats);
 	if (err < 0) {
 		log_err("Check failed for IPSec counter id %d due to incorrect "
@@ -1831,11 +1919,7 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			cnt_cb->ipsec_cb.sa_id[0]);
 		return -EINVAL;
 	}
-
-	/* Map IPSec counter selection to statistics */
-	err = cnt_gen_sel_to_stats(cnt_cb, params->ipsec_params.cnt_sel);
-	if (err < 0)
-		return err;
+	init_cnt_32bit_stats(&cnt_cb->info, &stats, 0);
 
 	return 0;
 }
@@ -1845,7 +1929,7 @@ static int set_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 {
 	uint32_t cnt_sel = params->traffic_mng_params.cnt_sel;
 	uint32_t cnt_src = params->traffic_mng_params.src;
-	u64 frames = 0, bytes = 0;
+	uint64_t stats[2];
 	int err = 0;
 	bool us_cnt = FALSE;
 
@@ -1893,7 +1977,7 @@ static int set_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		cnt_cb->f_get_cnt_stats = get_cnt_traffic_mng_cq_stats;
 		err = qman_ceetm_cq_get_dequeue_statistics(
 				params->traffic_mng_params.traffic_mng,
-				0, &frames, &bytes);
+				0, &stats[0], &stats[1]);
 		if (err < 0) {
 			log_err("Invalid Traffic Manager qm_ceetm_cq object for"
 				" counter id %d\n", cnt_cb->id);
@@ -1904,7 +1988,7 @@ static int set_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		cnt_cb->f_get_cnt_stats = get_cnt_traffic_mng_ccg_stats;
 		err = qman_ceetm_ccg_get_reject_statistics(
 				params->traffic_mng_params.traffic_mng,
-				0, &frames, &bytes);
+				0, &stats[0], &stats[1]);
 		if (err < 0) {
 			log_err("Invalid Traffic Manager qm_ceetm_ccg object "
 				"for counter id %d\n", cnt_cb->id);
@@ -1912,6 +1996,7 @@ static int set_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		}
 		break;
 	}
+	init_cnt_64bit_stats(&cnt_cb->info, &stats, 0);
 
 	return 0;
 }
@@ -1921,6 +2006,7 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 {
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	uint32_t cnt_sel = params->eth_params.cnt_sel;
+	t_FmMacStatistics stats;
 	t_Handle fm_mac = NULL;
 	uint32_t i = 0;
 	int err = 0;
@@ -1943,6 +2029,16 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	if (cnt_sel == DPA_STATS_CNT_ETH_ALL)
 		cnt_sel -= 1;
 
+	cnt_cb->members_num = params->class_members;
+
+	/* Map Ethernet counter selection to FM MAC statistics */
+	cnt_sel_to_stats(&cnt_cb->info,
+			 dpa_stats->stats_sel[DPA_STATS_CNT_ETH], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_cb->members_num *
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
 	for (i = 0; i < params->class_members; i++) {
 		/* Get FM MAC handle */
 		err = get_fm_mac(params->eth_params.src[i], &fm_mac);
@@ -1953,17 +2049,15 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		}
 
 		cnt_cb->gen_cb.objs[i] = fm_mac;
-	}
 
-	cnt_cb->members_num = params->class_members;
-
-	/* Map Ethernet counter selection to FM MAC statistics */
-	cnt_sel_to_stats(&cnt_cb->info,
-			 dpa_stats->stats_sel[DPA_STATS_CNT_ETH], cnt_sel);
-
-	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_cb->members_num *
-				STATS_VAL_SIZE * cnt_cb->info.stats_num;
+		err = FM_MAC_GetStatistics(cnt_cb->gen_cb.objs[i], &stats);
+		if (err != 0) {
+			log_err("Invalid Ethernet counter source for counter id "
+				"%d\n", cnt_cb->id);
+			return -ENOENT;
+		}
+		init_cnt_64bit_stats(&cnt_cb->info, &stats, i);
+	}
 	return 0;
 }
 
@@ -1999,23 +2093,6 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	cnt_cb->members_num = params->class_members;
 
-	for (i = 0; i < params->class_members; i++) {
-		if (!params->reass_params.reass[i]) {
-			log_err("Parameter Reassembly handle cannot be NULL for"
-				" member %d, counter id %d\n", i, cnt_cb->id);
-			return -EFAULT;
-		}
-		cnt_cb->gen_cb.objs[i] = params->reass_params.reass[i];
-
-		/* Check the user-provided reassembly manip */
-		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
-		if (err < 0) {
-			log_err("Invalid Reassembly manip handle for counter id"
-				" %d\n", cnt_cb->id);
-			return -EINVAL;
-		}
-	}
-
 	/* Based on user option, change mask to all statistics in one group */
 	if (cnt_sel == DPA_STATS_CNT_REASS_GEN_ALL)
 		cnt_sel -= 1;
@@ -2033,6 +2110,25 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Set number of bytes that will be written by this counter */
 	cnt_cb->bytes_num = cnt_cb->members_num *
 				STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
+	for (i = 0; i < params->class_members; i++) {
+		if (!params->reass_params.reass[i]) {
+			log_err("Parameter Reassembly handle cannot be NULL for"
+				" member %d, counter id %d\n", i, cnt_cb->id);
+			return -EFAULT;
+		}
+		cnt_cb->gen_cb.objs[i] = params->reass_params.reass[i];
+
+		/* Check the user-provided reassembly manip */
+		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
+		if (err < 0) {
+			log_err("Invalid Reassembly manip handle for counter id"
+				" %d\n", cnt_cb->id);
+			return -EINVAL;
+		}
+		init_cnt_32bit_stats(&cnt_cb->info, &stats, i);
+	}
+
 	return 0;
 }
 
@@ -2059,6 +2155,18 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	cnt_cb->members_num = params->class_members;
 
+	/* Decrease one to obtain the mask for all statistics */
+	if (cnt_sel == DPA_STATS_CNT_FRAG_ALL)
+		cnt_sel -= 1;
+
+	/* Map Fragmentation counter selection to Manip statistics */
+	cnt_sel_to_stats(&cnt_cb->info,
+			 dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_cb->members_num *
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
 	for (i = 0; i < params->class_members; i++) {
 		if (!params->frag_params.frag[i]) {
 			log_err("Parameter Fragmentation handle cannot be NULL "
@@ -2074,19 +2182,9 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				"id %d\n", cnt_cb->id);
 			return -EINVAL;
 		}
+		init_cnt_32bit_stats(&cnt_cb->info, &stats, i);
 	}
 
-	/* Decrease one to obtain the mask for all statistics */
-	if (cnt_sel == DPA_STATS_CNT_FRAG_ALL)
-		cnt_sel -= 1;
-
-	/* Map Fragmentation counter selection to Manip statistics */
-	cnt_sel_to_stats(&cnt_cb->info,
-			 dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
-
-	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_cb->members_num *
-				STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
@@ -2094,8 +2192,8 @@ static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			       const struct dpa_stats_cls_cnt_params *params)
 {
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
-	struct stats_info *info = &cnt_cb->info;
-	uint32_t cnt_sel = params->plcr_params.cnt_sel, i;
+	uint32_t cnt_sel = params->plcr_params.cnt_sel;
+	uint32_t i, j, stats;
 
 	if (!dpa_stats) {
 		log_err("DPA Stats component is not initialized\n");
@@ -2110,8 +2208,20 @@ static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EINVAL;
 	}
 
+	/* Decrease one to obtain the mask for all statistics */
+	if (cnt_sel == DPA_STATS_CNT_PLCR_ALL)
+		cnt_sel -= 1;
+
 	cnt_cb->members_num = params->class_members;
 
+	/* Map Policer counter selection to policer statistics */
+	cnt_sel_to_stats(&cnt_cb->info,
+			 dpa_stats->stats_sel[DPA_STATS_CNT_POLICER], cnt_sel);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_cb->members_num *
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
 	for (i = 0; i < params->class_members; i++) {
 		if (!params->plcr_params.plcr[i]) {
 			log_err("Parameter Policer handle cannot be NULL for "
@@ -2119,35 +2229,28 @@ static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			return -EFAULT;
 		}
 		cnt_cb->gen_cb.objs[i] = params->plcr_params.plcr[i];
-		/* Check the user-provided policer handle */
-		FM_PCD_PlcrProfileGetCounter(cnt_cb->gen_cb.objs[i],
-				info->stats_off[0]);
-		/*
-		 * in case of bad counter the error will be displayed at
-		 * creation time
-		 */
-	}
 
-	/* Decrease one to obtain the mask for all statistics */
-	if (cnt_sel == DPA_STATS_CNT_PLCR_ALL)
-		cnt_sel -= 1;
+		for (j = 0; j < cnt_cb->info.stats_num; j++) {
+			stats = (uint64_t)FM_PCD_PlcrProfileGetCounter(
+				cnt_cb->gen_cb.objs[i],
+				cnt_cb->info.stats_off[j]);
 
-	/* Map Policer counter selection to policer statistics */
-	cnt_sel_to_stats(&cnt_cb->info,
-			 dpa_stats->stats_sel[DPA_STATS_CNT_POLICER], cnt_sel);
+			/* Store the current value as the last read value */
+			cnt_cb->info.stats[i][j] = 0;
+			cnt_cb->info.last_stats[i][j] = stats;
+		}
+	}
 
-	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_cb->members_num *
-				STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
 static int set_cls_cnt_classif_tbl_pair(
 		struct dpa_stats_cnt_cb *cnt_cb, int td,
 		const struct dpa_offload_lookup_key_pair *pair,
-		struct dpa_stats_lookup_key *lookup_key)
+		uint32_t idx)
 {
 	struct dpa_stats_cnt_classif_tbl_cb *cnt_tbl_cb = &cnt_cb->tbl_cb;
+	struct dpa_stats_lookup_key *lookup_key = &cnt_tbl_cb->keys[idx];
 	struct dpa_cls_tbl_params cls_tbl;
 	struct dpa_offload_lookup_key tbl_key;
 	struct dpa_cls_tbl_action action;
@@ -2215,9 +2318,8 @@ static int set_cls_cnt_classif_tbl_pair(
 		/* Set as the key as "for miss" */
 		lookup_key->miss_key = TRUE;
 
-		/* Check the Classifier Table counter parameters for "miss" */
-		err = check_ccnode_miss_counter(lookup_key->cc_node,
-				cnt_cb->id, cnt_tbl_cb->type);
+		/* Retrieve Classifier Table counter statistics for 'miss' */
+		err = get_classif_tbl_miss_stats(cnt_cb, idx);
 	} else {
 		lookup_key->miss_key = FALSE;
 
@@ -2229,8 +2331,8 @@ static int set_cls_cnt_classif_tbl_pair(
 			return -EINVAL;
 		}
 
-		/* Check the Classifier Table counter */
-		err = check_tbl_cls_counter(cnt_cb, lookup_key);
+		/* Retrieve Classifier Table counter statistics for a key */
+		err = get_classif_tbl_key_stats(cnt_cb, idx);
 	}
 
 	return err;
@@ -2260,6 +2362,12 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Entire group of counters was selected */
 		if (cnt_sel == DPA_STATS_CNT_CLASSIF_ALL)
 			cnt_sel -= 1;
+
+		/* Map Classif Node counter selection to CcNode statistics */
+		cnt_sel_to_stats(&cnt_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+			cnt_sel >> CLASSIF_STATS_SHIFT);
+
 		frag_stats = 0;
 
 	} else if (cnt_sel >= DPA_STATS_CNT_FRAG_TOTAL_FRAMES &&
@@ -2268,6 +2376,11 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Entire group of counters was selected */
 		if (cnt_sel == DPA_STATS_CNT_FRAG_ALL)
 			cnt_sel -= 1;
+
+		/* Map Classif Node counter selection to fragmentation stats */
+		cnt_sel_to_stats(&cnt_cb->info,
+			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
+
 		frag_stats = 1;
 
 	} else {
@@ -2282,6 +2395,10 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	tbl_cb->td = params->classif_tbl_params.td;
 	cnt_cb->members_num = params->class_members;
 
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_cb->members_num *
+			STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
 	/* Allocate memory for key descriptors */
 	tbl_cb->keys = kcalloc(params->class_members,
 			       sizeof(*tbl_cb->keys), GFP_KERNEL);
@@ -2322,9 +2439,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				tbl_cb->keys[i].miss_key = TRUE;
 				tbl_cb->keys[i].valid = TRUE;
 
-				err = check_ccnode_miss_counter(
-						tbl_cb->keys[i].cc_node,
-						cnt_cb->id, tbl_cb->type);
+				/* Get Classif Table counter stats for 'miss' */
+				err = get_classif_tbl_miss_stats(cnt_cb, i);
 				if (err != 0)
 					return -EINVAL;
 				continue;
@@ -2345,8 +2461,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				return -EINVAL;
 			}
 
-			/* Check the Classifier Table counter */
-			err = check_tbl_cls_counter(cnt_cb, &tbl_cb->keys[i]);
+			/* Get Classifier Table counter statistics for a key */
+			err = get_classif_tbl_key_stats(cnt_cb, i);
 			if (err != 0)
 				return -EINVAL;
 
@@ -2371,8 +2487,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				}
 			}
 
-			err = set_cls_cnt_classif_tbl_pair(cnt_cb, prm.td,
-					prm.pairs[i], &tbl_cb->keys[i]);
+			err = set_cls_cnt_classif_tbl_pair(
+					cnt_cb, prm.td, prm.pairs[i], i);
 			if (err != 0) {
 				log_err("Cannot set classifier table pair key "
 					"for counter id %d\n", cnt_cb->id);
@@ -2402,22 +2518,10 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				return -EINVAL;
 			}
 		}
-
-		/* Map Classif Node counter selection to fragmentation stats */
-		cnt_sel_to_stats(&cnt_cb->info,
-			dpa_stats->stats_sel[DPA_STATS_CNT_FRAG], cnt_sel);
-
 		/* Change the retrieve routine */
 		cnt_cb->f_get_cnt_stats = get_cnt_cls_tbl_frag_stats;
-	} else
-		/* Map Classif Node counter selection to CcNode statistics */
-		cnt_sel_to_stats(&cnt_cb->info,
-			dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
-			cnt_sel >> CLASSIF_STATS_SHIFT);
+	}
 
-	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_cb->members_num *
-			STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
@@ -2457,6 +2561,15 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->ccnode_cb.cc_node = prm.cc_node;
 	cnt_cb->members_num = params->class_members;
 
+	/* Map Classif Node counter selection to CcNode statistics */
+	cnt_sel_to_stats(&cnt_cb->info,
+			 dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
+			 prm.cnt_sel >> CLASSIF_STATS_SHIFT);
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_cb->members_num *
+				STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
 	/* Set retrieve function depending on counter type */
 	err = set_cnt_classif_node_retrieve_func(cnt_cb, prm.ccnode_type);
 	if (err != 0)
@@ -2467,11 +2580,10 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			/* Set the key byte to NULL, to mark it for 'miss' */
 			cnt_cb->ccnode_cb.keys[i].byte = NULL;
 
-			/* Check the Classifier Node counter parameters */
-			err = check_ccnode_miss_counter(prm.cc_node,
-						cnt_cb->id, prm.ccnode_type);
+			/* Retrieve Classif Node counter statistics for 'miss'*/
+			err = get_ccnode_miss_stats(cnt_cb, prm.ccnode_type, i);
 			if (err != 0)
-				return -EINVAL;
+				return err;
 		} else {
 			/* Copy the key descriptor */
 			err = copy_key_descriptor(prm.keys[i],
@@ -2482,22 +2594,13 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				return -EINVAL;
 			}
 
-			/* Check the Classifier Node counter parameters */
-			err = check_ccnode_counter(cnt_cb, prm.ccnode_type,
-						   &cnt_cb->ccnode_cb.keys[i]);
+			/* Retrieve Classifier Node counter statistics for key*/
+			err = get_ccnode_key_stats(cnt_cb, prm.ccnode_type, i);
 			if (err != 0)
-				return -EINVAL;
+				return err;
 		}
 	}
 
-	/* Map Classif Node counter selection to CcNode statistics */
-	cnt_sel_to_stats(&cnt_cb->info,
-			 dpa_stats->stats_sel[DPA_STATS_CNT_CLASSIF_NODE],
-			 prm.cnt_sel >> CLASSIF_STATS_SHIFT);
-
-	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_cb->members_num *
-				STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
@@ -2507,7 +2610,7 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	struct dpa_stats_cnt_ipsec_cb *cnt_ipsec_cb = &cnt_cb->ipsec_cb;
 	struct dpa_stats *dpa_stats = cnt_cb->dpa_stats;
 	struct dpa_ipsec_sa_stats stats;
-	uint32_t cnt_sel = prm->ipsec_params.cnt_sel, i = 0;
+	uint32_t i = 0;
 	int err = 0;
 
 	if (!dpa_stats) {
@@ -2515,30 +2618,6 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -EFAULT;
 	}
 
-	/* Map IPSec counter selection to statistics */
-	if (cnt_sel == DPA_STATS_CNT_NUM_OF_BYTES) {
-		cnt_cb->info.stats_off[0] = dpa_stats->stats_sel[
-			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
-		cnt_cb->info.stats_num = 1;
-	} else if (cnt_sel  == DPA_STATS_CNT_NUM_OF_PACKETS) {
-		cnt_cb->info.stats_off[0] = dpa_stats->stats_sel[
-			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
-		cnt_cb->info.stats_num = 1;
-	} else if (cnt_sel  == DPA_STATS_CNT_NUM_ALL) {
-		cnt_cb->info.stats_off[0] = dpa_stats->stats_sel[
-			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_BYTES];
-		cnt_cb->info.stats_off[1] = dpa_stats->stats_sel[
-			DPA_STATS_CNT_IPSEC][DPA_STATS_CNT_NUM_OF_PACKETS];
-		cnt_cb->info.stats_num = 2;
-	} else {
-		log_err("Parameter cnt_sel %d must be in range (%d - %d) for "
-			"counter id %d\n", cnt_sel, DPA_STATS_CNT_NUM_OF_BYTES,
-			DPA_STATS_CNT_NUM_ALL, cnt_cb->id);
-		return -EINVAL;
-	}
-
-	cnt_cb->members_num = prm->class_members;
-
 	/* Allocate memory for array of security association ids */
 	cnt_cb->ipsec_cb.sa_id = kcalloc(cnt_cb->members_num,
 				  sizeof(*cnt_cb->ipsec_cb.sa_id), GFP_KERNEL);
@@ -2558,6 +2637,17 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		return -ENOMEM;
 	}
 
+	/* Map IPSec counter selection to statistics */
+	err = cnt_gen_sel_to_stats(cnt_cb, prm->ipsec_params.cnt_sel);
+	if (err < 0)
+		return err;
+
+	cnt_cb->members_num = prm->class_members;
+
+	/* Set number of bytes that will be written by this counter */
+	cnt_cb->bytes_num = cnt_cb->members_num *
+			STATS_VAL_SIZE * cnt_cb->info.stats_num;
+
 	for (i = 0; i < prm->class_members; i++) {
 		if (prm->ipsec_params.sa_id[i] != DPA_OFFLD_INVALID_OBJECT_ID) {
 			cnt_ipsec_cb->sa_id[i] = prm->ipsec_params.sa_id[i];
@@ -2572,14 +2662,11 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 					cnt_cb->ipsec_cb.sa_id[i]);
 				return -EINVAL;
 			}
-		} else {
+			init_cnt_32bit_stats(&cnt_cb->info, &stats, i);
+		} else
 			cnt_ipsec_cb->valid[i] = FALSE;
-		}
 	}
 
-	/* Set number of bytes that will be written by this counter */
-	cnt_cb->bytes_num = cnt_cb->members_num *
-			STATS_VAL_SIZE * cnt_cb->info.stats_num;
 	return 0;
 }
 
@@ -2588,7 +2675,7 @@ static int set_cls_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 {
 	struct dpa_stats_cls_cnt_traffic_mng prm = params->traffic_mng_params;
 	uint32_t cnt_sel = prm.cnt_sel, i;
-	u64 frames = 0, bytes = 0;
+	uint64_t stats[2];
 	int err = 0;
 	bool us_cnt = FALSE;
 
@@ -2629,12 +2716,13 @@ static int set_cls_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 			/* Check the provided Traffic Manager object */
 			err = qman_ceetm_cq_get_dequeue_statistics(
-					prm.traffic_mng[i], 0, &frames, &bytes);
+					prm.traffic_mng[i], 0, &stats[0], &stats[1]);
 			if (err < 0) {
 				log_err("Invalid traffic_mng handle for counter"
 					" id %d\n", cnt_cb->id);
 				return -EINVAL;
 			}
+			init_cnt_64bit_stats(&cnt_cb->info, &stats, i);
 			cnt_cb->gen_cb.objs[i] = prm.traffic_mng[i];
 		}
 		break;
@@ -2649,12 +2737,13 @@ static int set_cls_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 			/* Check the provided Traffic Manager object */
 			err = qman_ceetm_ccg_get_reject_statistics(
-					prm.traffic_mng[i], 0, &frames, &bytes);
+					prm.traffic_mng[i], 0, &stats[0], &stats[1]);
 			if (err < 0) {
 				log_err("Invalid traffic_mng handle for counter"
 					" id %d\n", cnt_cb->id);
 				return -EINVAL;
 			}
+			init_cnt_64bit_stats(&cnt_cb->info, &stats, i);
 			cnt_cb->gen_cb.objs[i] = prm.traffic_mng[i];
 		}
 		break;
@@ -2698,22 +2787,23 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 	kfree(tbl_cb->keys[mbr_idx].key.mask);
 	tbl_cb->keys[mbr_idx].key.mask = NULL;
 
-	/* Reset the statistics */
-	for (i = 0; i < cnt_cb->info.stats_num; i++) {
-		cnt_cb->info.stats[mbr_idx][i] = 0;
-		cnt_cb->info.last_stats[mbr_idx][i] = 0;
-	}
-
 	if (prm->type == DPA_STATS_CLS_MEMBER_SINGLE_KEY) {
 		if (!prm->key) {
 			/* Mark the key as 'miss' entry */
 			tbl_cb->keys[mbr_idx].miss_key = TRUE;
 			tbl_cb->keys[mbr_idx].valid = TRUE;
-			return 0;
+
+			/* Get Classifier Table counter statistics for 'miss' */
+			return get_classif_tbl_miss_stats(cnt_cb, mbr_idx);
 		} else if (!prm->key->byte) {
 			/* Mark the key as invalid */
 			tbl_cb->keys[mbr_idx].valid = FALSE;
 			tbl_cb->keys[mbr_idx].miss_key = FALSE;
+			/* Reset the statistics */
+			for (i = 0; i < cnt_cb->info.stats_num; i++) {
+				cnt_cb->info.stats[mbr_idx][i] = 0;
+				cnt_cb->info.last_stats[mbr_idx][i] = 0;
+			}
 			return 0;
 		} else {
 			/* Copy the key descriptor */
@@ -2724,6 +2814,11 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 					"parameters\n");
 				return -EINVAL;
 			}
+
+			/* Get Classifier Table counter statistics for a key */
+			err = get_classif_tbl_key_stats(cnt_cb, mbr_idx);
+			if (err < 0)
+				return err;
 		}
 	} else {
 		if (prm->pair)
@@ -2732,10 +2827,16 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 					/* Mark the key as invalid */
 					tbl_cb->keys[mbr_idx].valid = FALSE;
 					tbl_cb->keys[mbr_idx].miss_key = FALSE;
+
+					/* Reset the statistics */
+					for (i = 0; i < cnt_cb->info.stats_num; i++) {
+						cnt_cb->info.stats[mbr_idx][i] = 0;
+						cnt_cb->info.last_stats[mbr_idx][i] = 0;
+					}
 					return 0;
 				}
 		err = set_cls_cnt_classif_tbl_pair(cnt_cb, tbl_cb->td,
-			prm->pair, &tbl_cb->keys[mbr_idx]);
+						   prm->pair, mbr_idx);
 		if (err != 0) {
 			log_err("Cannot configure the pair key for counter id "
 				"%d of member %d\n", cnt_cb->id, mbr_idx);
@@ -2746,12 +2847,9 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 	tbl_cb->keys[mbr_idx].valid = TRUE;
 
 	if (cnt_cb->f_get_cnt_stats != get_cnt_cls_tbl_frag_stats) {
-		if (!tbl_cb->keys[mbr_idx].miss_key) {
-			err = check_tbl_cls_counter(cnt_cb,
-						    &tbl_cb->keys[mbr_idx]);
-			if (err != 0)
-				return -EINVAL;
-		}
+		if (!tbl_cb->keys[mbr_idx].miss_key)
+			/* Get Classifier Table counter statistics for a key */
+			return get_classif_tbl_key_stats(cnt_cb, mbr_idx);
 	} else{
 		err = set_frag_manip(tbl_cb->td, &tbl_cb->keys[mbr_idx]);
 		if (err < 0) {
@@ -2760,16 +2858,17 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 			return -EINVAL;
 		}
 	}
-
 	return 0;
 }
 
 int set_ipsec_member(const struct dpa_stats_cls_member_params *params,
-		     int member_idx,
+		     int mbr_idx,
 		     struct dpa_stats_cnt_cb *cnt_cb)
 {
 	struct dpa_stats_cnt_ipsec_cb *ipsec_cb = &cnt_cb->ipsec_cb;
+	struct dpa_ipsec_sa_stats stats;
 	uint32_t i = 0;
+	int err = 0;
 
 	/* Check that counter is of type IPSec */
 	if (cnt_cb->type != DPA_STATS_CNT_IPSEC) {
@@ -2780,31 +2879,75 @@ int set_ipsec_member(const struct dpa_stats_cls_member_params *params,
 	}
 
 	/* Check that member index does not exceeds class size */
-	if (member_idx < 0 || member_idx >= cnt_cb->members_num) {
+	if (mbr_idx < 0 || mbr_idx >= cnt_cb->members_num) {
 		log_err("Parameter member_index %d must be in range (0 - %d) "
-			"for counter id %d\n", member_idx,
+			"for counter id %d\n", mbr_idx,
 			cnt_cb->members_num - 1, cnt_cb->id);
 		return -EINVAL;
 	}
 
-	/* Reset the statistics */
-	for (i = 0; i < cnt_cb->info.stats_num; i++) {
-		cnt_cb->info.stats[member_idx][i] = 0;
-		cnt_cb->info.last_stats[member_idx][i] = 0;
-	}
-
 	if (params->sa_id == DPA_OFFLD_INVALID_OBJECT_ID) {
 		/* Mark that corresponding SA id as invalid */
-		ipsec_cb->valid[member_idx] = FALSE;
+		ipsec_cb->valid[mbr_idx] = FALSE;
+		/* Reset the statistics */
+		for (i = 0; i < cnt_cb->info.stats_num; i++) {
+			cnt_cb->info.stats[mbr_idx][i] = 0;
+			cnt_cb->info.last_stats[mbr_idx][i] = 0;
+		}
 	} else {
 		/* Mark the corresponding SA id as valid */
-		ipsec_cb->valid[member_idx] = TRUE;
-		ipsec_cb->sa_id[member_idx] = params->sa_id;
-	}
+		ipsec_cb->valid[mbr_idx] = TRUE;
+		ipsec_cb->sa_id[mbr_idx] = params->sa_id;
 
+		err = dpa_ipsec_sa_get_stats(
+				cnt_cb->ipsec_cb.sa_id[mbr_idx], &stats);
+		if (err < 0) {
+			log_err("Get failed for IPSec counter id %d due to "
+				"incorrect parameters: sa_id=%d\n", cnt_cb->id,
+				cnt_cb->ipsec_cb.sa_id[mbr_idx]);
+			return -EINVAL;
+		}
+		init_cnt_32bit_stats(&cnt_cb->info, &stats, 0);
+	}
 	return 0;
 }
 
+static void init_cnt_32bit_stats(struct stats_info *stats_info,
+				 void *stats, uint32_t idx)
+{
+	uint32_t j = 0;
+	uint64_t stats_val;
+
+	for (j = 0; j < stats_info->stats_num; j++) {
+		if (stats_info->stats_off[j] == UNSUPPORTED_CNT_SEL)
+			continue;
+
+		/* Get statistics value */
+		stats_val = (uint64_t)(*((uint32_t *)
+				(stats + stats_info->stats_off[j])));
+
+		/* Store the current value as the last read value */
+		stats_info->stats[idx][j] = 0;
+		stats_info->last_stats[idx][j] = stats_val;
+	}
+}
+
+static void init_cnt_64bit_stats(struct stats_info *stats_info,
+				 void *stats, uint32_t idx)
+{
+	uint32_t j = 0;
+	uint64_t stats_val;
+
+	for (j = 0; j < stats_info->stats_num; j++) {
+		/* Get statistics value */
+		stats_val = *((uint64_t *)(stats + stats_info->stats_off[j]));
+
+		/* Store the current value as the last read value */
+		stats_info->stats[idx][j] = 0;
+		stats_info->last_stats[idx][j] = stats_val;
+	}
+}
+
 static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 				       struct stats_info *stats_info,
 				       void *stats, uint32_t idx)
@@ -2813,7 +2956,6 @@ static inline void get_cnt_32bit_stats(struct dpa_stats_req_cb *req_cb,
 	uint64_t stats_val;
 
 	for (j = 0; j < stats_info->stats_num; j++) {
-
 		if (stats_info->stats_off[j] == UNSUPPORTED_CNT_SEL) {
 			/* Write the memory location */
 			memset(req_cb->request_area, 0, STATS_VAL_SIZE);
-- 
1.7.5.4

