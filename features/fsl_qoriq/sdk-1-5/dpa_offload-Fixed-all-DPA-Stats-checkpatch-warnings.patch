From 49ec938396d368f0bf7746971302a32e436e4f04 Mon Sep 17 00:00:00 2001
From: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Date: Thu, 14 Nov 2013 08:28:47 +0200
Subject: [PATCH 310/383] dpa_offload: Fixed all DPA Stats checkpatch warnings

Fixed almost all checkpatch warnings returned by the script. Most of
them were related to the fact that error/warning messages were split on
multiple lines. Still remaining 52 errors caused by FMD function names
that contain CamelCase.

Signed-off-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Change-Id: I65a73caefce52645122fc8460683c0a05340c3bc
Reviewed-on: http://git.am.freescale.net:8181/6636
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c     |  589 ++++++++++-------------
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |  139 ++----
 2 files changed, 312 insertions(+), 416 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index faeee24..4fcf1c3 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -178,10 +178,8 @@ static int get_classif_tbl_key_stats(struct dpa_stats_cnt_cb *cnt_cb,
 		err = FM_PCD_HashTableFindNGetKeyStatistics(entry->cc_node,
 				entry->key.size, entry->key.byte, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classifier Hash Table counter"
-				" id %d due to incorrect parameters: handle="
-				"0x%p, keysize=%d, keybyte=\n", cnt_cb->id,
-				entry->cc_node, entry->key.size);
+			log_err("Check failed for Classifier Hash Table counter id %d due to incorrect parameters: handle=0x%p, keysize=%d, keybyte=\n",
+				cnt_cb->id, entry->cc_node, entry->key.size);
 			dump_lookup_key(&entry->key);
 			return -EIO;
 		}
@@ -190,9 +188,7 @@ static int get_classif_tbl_key_stats(struct dpa_stats_cnt_cb *cnt_cb,
 		err = FM_PCD_MatchTableGetKeyStatistics(
 				entry->cc_node, entry->key.byte[0], &stats);
 		if (err != 0) {
-			log_err("Check failed for Classifier Indexed Table "
-				"counter id %d due to incorrect parameters: "
-				"handle=0x%p, keysize=%d keybyte=\n",
+			log_err("Check failed for Classifier Indexed Table counter id %d due to incorrect parameters: handle=0x%p, keysize=%d keybyte=\n",
 				cnt_cb->id, entry->cc_node, entry->key.size);
 			dump_lookup_key(&entry->key);
 			return -EIO;
@@ -203,9 +199,7 @@ static int get_classif_tbl_key_stats(struct dpa_stats_cnt_cb *cnt_cb,
 				entry->key.size, entry->key.byte,
 				entry->key.mask, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classifier Exact Match Table "
-				"counter id %d due to incorrect parameters: "
-				"handle=0x%p, keysize=%d, keybyte=\n",
+			log_err("Check failed for Classifier Exact Match Table counter id %d due to incorrect parameters: handle=0x%p, keysize=%d, keybyte=\n",
 				cnt_cb->id, entry->cc_node, entry->key.size);
 			dump_lookup_key(&entry->key);
 			return -EINVAL;
@@ -236,10 +230,9 @@ static int get_ccnode_key_stats(struct dpa_stats_cnt_cb *cnt_cb,
 				cnt_cb->ccnode_cb.cc_node,
 				key->size, key->byte, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classification Node counter "
-				"id %d due to incorrect parameters: handle="
-				"0x%p, keysize=%d, keybyte=\n", cnt_cb->id,
-				cnt_cb->ccnode_cb.cc_node, key->size);
+			log_err("Check failed for Classification Node counter id %d due to incorrect parameters: handle=0x%p, keysize=%d, keybyte=\n",
+				cnt_cb->id, cnt_cb->ccnode_cb.cc_node,
+				key->size);
 			dump_lookup_key(key);
 			return -EINVAL;
 		}
@@ -249,10 +242,9 @@ static int get_ccnode_key_stats(struct dpa_stats_cnt_cb *cnt_cb,
 				cnt_cb->ccnode_cb.cc_node,
 				key->byte[0], &stats);
 		if (err != 0) {
-			log_err("Check failed for Classification Node counter "
-				"id %d due to incorrect parameters: handle=0x%p"
-				", keysize=%d, keybyte=\n", cnt_cb->id,
-				cnt_cb->ccnode_cb.cc_node, key->size);
+			log_err("Check failed for Classification Node counter id %d due to incorrect parameters: handle=0x%p, keysize=%d, keybyte=\n",
+				cnt_cb->id, cnt_cb->ccnode_cb.cc_node,
+				key->size);
 			dump_lookup_key(key);
 			return -EINVAL;
 		}
@@ -262,10 +254,9 @@ static int get_ccnode_key_stats(struct dpa_stats_cnt_cb *cnt_cb,
 				cnt_cb->ccnode_cb.cc_node, key->size, key->byte,
 				key->mask, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classification Node counter "
-				"id %d due to incorrect parameters: handle=0x%p"
-				", keysize=%d, keybyte=\n", cnt_cb->id,
-				cnt_cb->ccnode_cb.cc_node, key->size);
+			log_err("Check failed for Classification Node counter id %d due to incorrect parameters: handle=0x%p, keysize=%d, keybyte=\n",
+				cnt_cb->id, cnt_cb->ccnode_cb.cc_node,
+				key->size);
 			dump_lookup_key(key);
 			return -EINVAL;
 		}
@@ -292,27 +283,24 @@ static int get_classif_tbl_miss_stats(struct dpa_stats_cnt_cb *cnt_cb,
 	case DPA_CLS_TBL_HASH:
 		err = FM_PCD_HashTableGetMissStatistics(key->cc_node, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classifier Table counter "
-				"id %d due to incorrect parameters: handle="
-				"0x%p\n", cnt_cb->id, key->cc_node);
+			log_err("Check failed for Classifier Table counter id %d due to incorrect parameters: handle=0x%p\n",
+				cnt_cb->id, key->cc_node);
 			return -EINVAL;
 		}
 		break;
 	case DPA_CLS_TBL_INDEXED:
 		err = FM_PCD_MatchTableGetMissStatistics(key->cc_node, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classifier Table counter "
-				"id %d due to incorrect parameters: handle="
-				"0x%p\n", cnt_cb->id, key->cc_node);
+			log_err("Check failed for Classifier Table counter id %d due to incorrect parameters: handle=0x%p\n",
+				cnt_cb->id, key->cc_node);
 			return -EINVAL;
 		}
 		break;
 	case DPA_CLS_TBL_EXACT_MATCH:
 		err = FM_PCD_MatchTableGetMissStatistics(key->cc_node, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classifier Table counter "
-				"id %d due to incorrect parameters: handle="
-				"0x%p\n", cnt_cb->id, key->cc_node);
+			log_err("Check failed for Classifier Table counter id %d due to incorrect parameters: handle=0x%p\n",
+				cnt_cb->id, key->cc_node);
 			return -EINVAL;
 		}
 		break;
@@ -340,9 +328,8 @@ static int get_ccnode_miss_stats(struct dpa_stats_cnt_cb *cnt_cb,
 		err = FM_PCD_HashTableGetMissStatistics(
 					cnt_cb->ccnode_cb.cc_node, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classification Node counter "
-				"id %d due to incorrect parameters: handle=0x%p"
-				"\n", cnt_cb->id, cnt_cb->ccnode_cb.cc_node);
+			log_err("Check failed for Classification Node counter id %d due to incorrect parameters: handle=0x%p\n",
+				cnt_cb->id, cnt_cb->ccnode_cb.cc_node);
 			return -EINVAL;
 		}
 		break;
@@ -350,9 +337,8 @@ static int get_ccnode_miss_stats(struct dpa_stats_cnt_cb *cnt_cb,
 		err = FM_PCD_MatchTableGetMissStatistics(
 					cnt_cb->ccnode_cb.cc_node, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classification Node counter "
-				"id %d due to incorrect parameters: handle=0x%p"
-				"\n", cnt_cb->id, cnt_cb->ccnode_cb.cc_node);
+			log_err("Check failed for Classification Node counter id %d due to incorrect parameters: handle=0x%p\n",
+				cnt_cb->id, cnt_cb->ccnode_cb.cc_node);
 			return -EINVAL;
 		}
 		break;
@@ -360,9 +346,8 @@ static int get_ccnode_miss_stats(struct dpa_stats_cnt_cb *cnt_cb,
 		err = FM_PCD_MatchTableGetMissStatistics(
 					cnt_cb->ccnode_cb.cc_node, &stats);
 		if (err != 0) {
-			log_err("Check failed for Classification Node counter "
-				"id %d due to incorrect parameters: handle=0x%p"
-				"\n", cnt_cb->id, cnt_cb->ccnode_cb.cc_node);
+			log_err("Check failed for Classification Node counter id %d due to incorrect parameters: handle=0x%p\n",
+				cnt_cb->id, cnt_cb->ccnode_cb.cc_node);
 			return -EINVAL;
 		}
 		break;
@@ -388,8 +373,7 @@ static int get_new_cnt(struct dpa_stats *dpa_stats,
 
 	/* Get an id for new Counter */
 	if (cq_get_4bytes(dpa_stats->cnt_id_cq, &id) < 0) {
-		log_err("Cannot create new counter, no more free counter ids "
-			"available\n");
+		log_err("Cannot create new counter, no more free counter ids available\n");
 		mutex_unlock(&dpa_stats->lock);
 		return -EDOM;
 	}
@@ -439,8 +423,7 @@ static int get_new_req(struct dpa_stats *dpa_stats,
 
 	/* Get an id for a new request */
 	if (cq_get_4bytes(dpa_stats->req_id_cq, &id) < 0) {
-		log_err("Cannot create new request, no more free request ids "
-			"available\n");
+		log_err("Cannot create new request, no more free request ids available\n");
 		mutex_unlock(&dpa_stats->lock);
 		return -EDOM;
 	}
@@ -585,8 +568,7 @@ static int alloc_cnt_cb(struct dpa_stats *dpa_stats,
 	cnt_cb->info.stats_off = kcalloc(MAX_NUM_OF_STATS,
 				sizeof(*cnt_cb->info.stats_off), GFP_KERNEL);
 	if (!cnt_cb->info.stats_off) {
-		log_err("Cannot allocate memory to store array of "
-			"statistics offsets\n");
+		log_err("Cannot allocate memory to store array of statistics offsets\n");
 		return -ENOMEM;
 	}
 
@@ -594,16 +576,15 @@ static int alloc_cnt_cb(struct dpa_stats *dpa_stats,
 	cnt_cb->info.stats = kcalloc(MAX_NUM_OF_MEMBERS,
 				sizeof(uint64_t *), GFP_KERNEL);
 	if (!cnt_cb->info.stats) {
-		log_err("Cannot allocate memory to store array of "
-			"statistics for all members\n");
+		log_err("Cannot allocate memory to store array of statistics for all members\n");
 		return -ENOMEM;
 	}
 	for (i = 0; i < MAX_NUM_OF_MEMBERS; i++) {
 		cnt_cb->info.stats[i] = kcalloc(MAX_NUM_OF_STATS,
 					sizeof(uint64_t), GFP_KERNEL);
 		if (!cnt_cb->info.stats[i]) {
-			log_err("Cannot allocate memory to store array of "
-				"statistics for %d member\n", i);
+			log_err("Cannot allocate memory to store array of statistics for %d member\n",
+				i);
 			return -ENOMEM;
 		}
 	}
@@ -612,16 +593,15 @@ static int alloc_cnt_cb(struct dpa_stats *dpa_stats,
 	cnt_cb->info.last_stats = kcalloc(MAX_NUM_OF_MEMBERS,
 				sizeof(uint64_t *), GFP_KERNEL);
 	if (!cnt_cb->info.last_stats) {
-		log_err("Cannot allocate memory to store array of "
-			"previous read statistics for all members\n");
+		log_err("Cannot allocate memory to store array of previous read statistics for all members\n");
 		return -ENOMEM;
 	}
 	for (i = 0; i < MAX_NUM_OF_MEMBERS; i++) {
 		cnt_cb->info.last_stats[i] = kcalloc(MAX_NUM_OF_STATS,
 					sizeof(uint64_t), GFP_KERNEL);
 		if (!cnt_cb->info.last_stats[i]) {
-			log_err("Cannot allocate memory to store array of "
-				"previous read statistics for %d member\n", i);
+			log_err("Cannot allocate memory to store array of previous read statistics for %d member\n",
+				i);
 			return -ENOMEM;
 		}
 	}
@@ -643,8 +623,7 @@ static int init_cnts_resources(struct dpa_stats *dpa_stats)
 	/* Fill the circular queue with ids */
 	for (i = 0; i < config.max_counters; i++)
 		if (cq_put_4bytes(dpa_stats->cnt_id_cq, i) < 0) {
-			log_err("Cannot fill circular queue with counter "
-				"ids\n");
+			log_err("Cannot fill circular queue with counter ids\n");
 			return -EDOM;
 		}
 
@@ -652,8 +631,8 @@ static int init_cnts_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->used_cnt_ids = kcalloc(
 			config.max_counters, sizeof(uint32_t), GFP_KERNEL);
 	if (!dpa_stats->used_cnt_ids) {
-		log_err("Cannot allocate memory to store %d \'in use\' counter "
-			"ids\n", config.max_counters);
+		log_err("Cannot allocate memory to store %d \'in use\' counter ids\n",
+			config.max_counters);
 		return -ENOMEM;
 	}
 	memset(dpa_stats->used_cnt_ids, DPA_OFFLD_INVALID_OBJECT_ID,
@@ -663,8 +642,8 @@ static int init_cnts_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->sched_cnt_ids = kcalloc(
 			config.max_counters, sizeof(bool), GFP_KERNEL);
 	if (!dpa_stats->sched_cnt_ids) {
-		log_err("Cannot allocate memory to store %d scheduled counter "
-			"ids\n", config.max_counters);
+		log_err("Cannot allocate memory to store %d scheduled counter ids\n",
+			config.max_counters);
 		return -ENOMEM;
 	}
 
@@ -672,8 +651,8 @@ static int init_cnts_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->cnts_cb = kzalloc(config.max_counters *
 			sizeof(struct dpa_stats_cnt_cb), GFP_KERNEL);
 	if (!dpa_stats->cnts_cb) {
-		log_err("Cannot allocate memory to store %d internal counter "
-			"structures\n", config.max_counters);
+		log_err("Cannot allocate memory to store %d internal counter structures\n",
+			config.max_counters);
 		return -ENOMEM;
 	}
 
@@ -758,8 +737,7 @@ static int init_reqs_resources(struct dpa_stats *dpa_stats)
 	/* Fill the circular queue with ids */
 	for (i = 0; i < DPA_STATS_MAX_NUM_OF_REQUESTS; i++)
 		if (cq_put_4bytes(dpa_stats->req_id_cq, i) < 0) {
-			log_err("Cannot fill circular queue with request "
-				"ids\n");
+			log_err("Cannot fill circular queue with request ids\n");
 			return -EDOM;
 		}
 
@@ -767,8 +745,7 @@ static int init_reqs_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->used_req_ids = kmalloc(DPA_STATS_MAX_NUM_OF_REQUESTS *
 			sizeof(uint32_t), GFP_KERNEL);
 	if (!dpa_stats->used_req_ids) {
-		log_err("Cannot allocate memory to store \'in use\' request "
-			"ids\n");
+		log_err("Cannot allocate memory to store \'in use\' request ids\n");
 		return -ENOMEM;
 	}
 	memset(dpa_stats->used_req_ids, DPA_OFFLD_INVALID_OBJECT_ID,
@@ -778,8 +755,7 @@ static int init_reqs_resources(struct dpa_stats *dpa_stats)
 	dpa_stats->reqs_cb = kzalloc(DPA_STATS_MAX_NUM_OF_REQUESTS *
 				sizeof(struct dpa_stats_req_cb), GFP_KERNEL);
 	if (!dpa_stats->reqs_cb) {
-		log_err("Cannot allocate memory to store internal requests "
-			"structure\n");
+		log_err("Cannot allocate memory to store internal requests structure\n");
 		return -ENOMEM;
 	}
 
@@ -789,8 +765,7 @@ static int init_reqs_resources(struct dpa_stats *dpa_stats)
 				kzalloc(dpa_stats->config.max_counters *
 						sizeof(int), GFP_KERNEL);
 		if (!dpa_stats->reqs_cb[i].cnts_ids) {
-			log_err("Cannot allocate memory for array of counter "
-				"ids\n");
+			log_err("Cannot allocate memory for array of counter ids\n");
 			return -ENOMEM;
 		}
 
@@ -1229,8 +1204,8 @@ static int copy_key_descriptor(const struct dpa_offload_lookup_key *src,
 
 	/* Check that key size is not zero */
 	if (src->size == 0) {
-		log_err("Lookup key descriptor size (%d) must be in range (1 - "
-			"%d) bytes\n", src->size, DPA_OFFLD_MAXENTRYKEYSIZE);
+		log_err("Lookup key descriptor size (%d) must be in range (1 - %d) bytes\n",
+			src->size, DPA_OFFLD_MAXENTRYKEYSIZE);
 		return -EINVAL;
 	}
 
@@ -1247,8 +1222,7 @@ static int copy_key_descriptor(const struct dpa_offload_lookup_key *src,
 		/* Allocate memory to store the key mask array */
 		dst->mask = kmalloc(src->size, GFP_KERNEL);
 		if (!dst->mask) {
-			log_err("No more memory for lookup key descriptor "
-				"mask\n");
+			log_err("No more memory for lookup key descriptor mask\n");
 			kfree(dst->byte);
 			return -ENOMEM;
 		}
@@ -1363,16 +1337,16 @@ static void cnt_sel_to_stats(struct stats_info *stats_info,
 			     int *stats_sel,
 			     uint32_t cnt_sel)
 {
-	uint32_t bitVal = 0, bitPos = 0, cntPos = 1;
+	uint32_t bit_val = 0, bit_pos = 0, cnt_pos = 1;
 
 	while (cnt_sel > 0) {
-		bitVal = cnt_sel & 0x00000001;
-		stats_info->stats_off[cntPos - bitVal] = stats_sel[bitPos++];
-		cntPos += bitVal;
+		bit_val = cnt_sel & 0x00000001;
+		stats_info->stats_off[cnt_pos - bit_val] = stats_sel[bit_pos++];
+		cnt_pos += bit_val;
 		cnt_sel >>= 1;
 	}
 
-	stats_info->stats_num = cntPos - 1;
+	stats_info->stats_num = cnt_pos - 1;
 }
 
 static int cnt_gen_sel_to_stats(struct dpa_stats_cnt_cb *cnt_cb,
@@ -1395,8 +1369,8 @@ static int cnt_gen_sel_to_stats(struct dpa_stats_cnt_cb *cnt_cb,
 	dpa_stats->stats_sel[cnt_cb->type][DPA_STATS_CNT_NUM_OF_PACKETS];
 		cnt_cb->info.stats_num = 2;
 	} else {
-		log_err("Parameter cnt_sel %d must be in range (%d - %d) for "
-			"counter id %d\n", cnt_sel, DPA_STATS_CNT_NUM_OF_BYTES,
+		log_err("Parameter cnt_sel %d must be in range (%d - %d) for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_NUM_OF_BYTES,
 			DPA_STATS_CNT_NUM_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
@@ -1417,22 +1391,21 @@ static int set_frag_manip(int td, struct dpa_stats_lookup_key *entry)
 	if (entry->miss_key) {
 		err = dpa_classif_get_miss_action(td, &action);
 		if (err != 0) {
-			log_err("Cannot retrieve miss action parameters from "
-				"table %d\n", td);
+			log_err("Cannot retrieve miss action parameters from table %d\n",
+				td);
 			return -EINVAL;
 		}
 	} else {
 		err = dpa_classif_table_lookup_by_key(td, &entry->key, &action);
 		if (err != 0) {
-			log_err("Cannot retrieve next action parameters from "
-				"table %d\n", td);
+			log_err("Cannot retrieve next action parameters from table %d\n",
+				td);
 			return -EINVAL;
 		}
 	}
 
 	if (action.type != DPA_CLS_TBL_ACTION_ENQ) {
-		log_err("Fragmentation statistics per flow are supported only "
-			"for action enqueue\n");
+		log_err("Fragmentation statistics per flow are supported only for action enqueue\n");
 		return -EINVAL;
 	}
 
@@ -1468,9 +1441,8 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Check Ethernet counter selection */
 	if (cnt_sel == 0 || cnt_sel > DPA_STATS_CNT_ETH_ALL) {
-		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
-			"counter id %d\n", cnt_sel, DPA_STATS_CNT_ETH_ALL,
-			cnt_cb->id);
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_ETH_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1480,10 +1452,9 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	if (params->eth_params.src.eth_id < DPA_STATS_ETH_1G_PORT0 ||
 	    params->eth_params.src.eth_id > DPA_STATS_ETH_10G_PORT1) {
-		log_err("Parameter src.eth_id %d must be in range (%d - %d) "
-			"for counter id %d\n", params->eth_params.src.eth_id,
-			DPA_STATS_ETH_1G_PORT0, DPA_STATS_ETH_10G_PORT1,
-			cnt_cb->id);
+		log_err("Parameter src.eth_id %d must be in range (%d - %d) for counter id %d\n",
+			params->eth_params.src.eth_id, DPA_STATS_ETH_1G_PORT0,
+			DPA_STATS_ETH_10G_PORT1, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -1499,16 +1470,16 @@ static int set_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Get FM MAC handle */
 	err = get_fm_mac(params->eth_params.src, &fm_mac);
 	if (err != 0) {
-		log_err("Cannot retrieve Ethernet MAC handle for counter id "
-			"%d\n", cnt_cb->id);
+		log_err("Cannot retrieve Ethernet MAC handle for counter id %d\n",
+			cnt_cb->id);
 		return -EINVAL;
 	}
 	cnt_cb->gen_cb.objs[0] = fm_mac;
 
 	err = FM_MAC_GetStatistics(cnt_cb->gen_cb.objs[0], &stats);
 	if (err != 0) {
-		log_err("Invalid Ethernet counter source for counter id "
-			"%d\n", cnt_cb->id);
+		log_err("Invalid Ethernet counter source for counter id %d\n",
+			cnt_cb->id);
 		return -ENOENT;
 	}
 	init_cnt_64bit_stats(&cnt_cb->info, &stats, 0);
@@ -1535,8 +1506,7 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		cnt_sel <= DPA_STATS_CNT_REASS_IPv4_ALL) ||
 		(cnt_sel >= DPA_STATS_CNT_REASS_IPv6_FRAMES &&
 		cnt_sel <= DPA_STATS_CNT_REASS_IPv6_ALL))) {
-		log_err("Parameter cnt_sel %d must be in one of the ranges (1 -"
-			"%d), (%d - %d), (%d - %d) for counter id %d\n",
+		log_err("Parameter cnt_sel %d must be in one of the ranges (1 -%d), (%d - %d), (%d - %d) for counter id %d\n",
 			cnt_sel, DPA_STATS_CNT_REASS_GEN_ALL,
 			DPA_STATS_CNT_REASS_IPv4_FRAMES,
 			DPA_STATS_CNT_REASS_IPv4_ALL,
@@ -1546,8 +1516,8 @@ static int set_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	}
 
 	if (!params->reass_params.reass) {
-		log_err("Parameter Reassembly handle cannot be NULL for counter"
-			" id %d\n", cnt_cb->id);
+		log_err("Parameter Reassembly handle cannot be NULL for counter id %d\n",
+			cnt_cb->id);
 		return -EFAULT;
 	}
 
@@ -1598,15 +1568,14 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Check Fragmentation counter selection */
 	if (cnt_sel == 0 || cnt_sel > DPA_STATS_CNT_FRAG_ALL) {
-		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
-			"counter id %d\n", cnt_sel, DPA_STATS_CNT_FRAG_ALL,
-			cnt_cb->id);
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_FRAG_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	if (!params->frag_params.frag) {
-		log_err("Parameter Fragmentation handle cannot be NULL for "
-			"counter id %d\n", cnt_cb->id);
+		log_err("Parameter Fragmentation handle cannot be NULL for counter id %d\n",
+			cnt_cb->id);
 		return -EFAULT;
 	}
 
@@ -1627,8 +1596,8 @@ static int set_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Check the user-provided fragmentation handle */
 	err = FM_PCD_ManipGetStatistics(params->frag_params.frag, &stats);
 	if (err < 0) {
-		log_err("Invalid Fragmentation manip handle for counter id "
-			"%d\n", cnt_cb->id);
+		log_err("Invalid Fragmentation manip handle for counter id %d\n",
+			cnt_cb->id);
 		return -EINVAL;
 	}
 	init_cnt_32bit_stats(&cnt_cb->info, &stats, 0);
@@ -1651,15 +1620,14 @@ static int set_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Check Policer counter selection */
 	if (cnt_sel == 0 || cnt_sel > DPA_STATS_CNT_PLCR_ALL) {
-		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
-			"counter id %d\n", cnt_sel, DPA_STATS_CNT_PLCR_ALL,
-			cnt_cb->id);
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_PLCR_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	if (!params->plcr_params.plcr) {
-		log_err("Parameter Policer handle cannot be NULL for counter id"
-			" %d\n", cnt_cb->id);
+		log_err("Parameter Policer handle cannot be NULL for counter id %d\n",
+			cnt_cb->id);
 		return -EFAULT;
 	}
 
@@ -1732,9 +1700,9 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		frag_stats = 1;
 
 	} else {
-		log_err("Parameter cnt_sel %d must be in one of the ranges (%d "
-			"- %d), (%d - %d), for counter id %d\n", cnt_sel,
-			DPA_STATS_CNT_CLASSIF_BYTES, DPA_STATS_CNT_CLASSIF_ALL,
+		log_err("Parameter cnt_sel %d must be in one of the ranges (%d - %d), (%d - %d), for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_CLASSIF_BYTES,
+			DPA_STATS_CNT_CLASSIF_ALL,
 			DPA_STATS_CNT_FRAG_TOTAL_FRAMES, DPA_STATS_CNT_FRAG_ALL,
 			cnt_cb->id);
 		return -EINVAL;
@@ -1754,8 +1722,8 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Allocate memory for one key descriptor */
 	cnt_tbl_cb->keys = kzalloc(sizeof(*cnt_tbl_cb->keys), GFP_KERNEL);
 	if (!cnt_tbl_cb->keys) {
-		log_err("Cannot allocate memory for key descriptor "
-			"for counter id %d\n", cnt_cb->id);
+		log_err("Cannot allocate memory for key descriptor for counter id %d\n",
+			cnt_cb->id);
 		return -ENOMEM;
 	}
 
@@ -1782,20 +1750,25 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Copy the key descriptor */
 		err = copy_key_descriptor(prm.key, &cnt_tbl_cb->keys[0].key);
 		if (err != 0) {
-			log_err("Cannot copy key descriptor from user "
-				"parameters\n");
+			log_err("Cannot copy key descriptor from user parameters\n");
 			return -EINVAL;
 		}
 	}
 
 	if (!frag_stats) {
 		if (cnt_tbl_cb->keys[0].miss_key) {
-			/* Retrieve Classifier Table counter statistics for 'miss' */
+			/*
+			 * Retrieve Classifier Table counter statistics for
+			 * 'miss'
+			 */
 			err = get_classif_tbl_miss_stats(cnt_cb, 0);
 			if (err != 0)
 				return -EINVAL;
 		} else {
-			/* Retrieve Classifier Table counter statistics for a key */
+			/*
+			 * Retrieve Classifier Table counter statistics for a
+			 * key
+			 */
 			err = get_classif_tbl_key_stats(cnt_cb, 0);
 			if (err != 0)
 				return err;
@@ -1803,8 +1776,8 @@ static int set_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	} else {
 		err = set_frag_manip(prm.td, &cnt_tbl_cb->keys[0]);
 		if (err < 0) {
-			log_err("Invalid Fragmentation manip handle for counter"
-				" id %d\n", cnt_cb->id);
+			log_err("Invalid Fragmentation manip handle for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 		/* Change the retrieve routine */
@@ -1827,15 +1800,14 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Check Classification Node counter selection */
 	if (prm.cnt_sel == 0 ||  prm.cnt_sel > DPA_STATS_CNT_CLASSIF_ALL) {
-		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
-			"counter id %d\n", prm.cnt_sel,
-			DPA_STATS_CNT_CLASSIF_ALL, cnt_cb->id);
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for counter id %d\n",
+			prm.cnt_sel, DPA_STATS_CNT_CLASSIF_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	if (!params->classif_node_params.cc_node) {
-		log_err("Parameter classification CC Node handle cannot be NULL"
-			" for counter id %d\n", cnt_cb->id);
+		log_err("Parameter classification CC Node handle cannot be NULL for counter id %d\n",
+			cnt_cb->id);
 		return -EFAULT;
 	}
 
@@ -1866,8 +1838,7 @@ static int set_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Copy the key descriptor */
 		err = copy_key_descriptor(prm.key, &cnt_cb->ccnode_cb.keys[0]);
 		if (err != 0) {
-			log_err("Cannot copy key descriptor from user "
-				"parameters\n");
+			log_err("Cannot copy key descriptor from user parameters\n");
 			return -EINVAL;
 		}
 		/* Retrieve Classifier Node counter statistics for key */
@@ -1891,8 +1862,8 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->ipsec_cb.sa_id = kzalloc(sizeof(*cnt_cb->ipsec_cb.sa_id),
 					GFP_KERNEL);
 	if (!cnt_cb->ipsec_cb.sa_id) {
-		log_err("Cannot allocate memory for security association id "
-			"for counter id %d\n", cnt_cb->id);
+		log_err("Cannot allocate memory for security association id for counter id %d\n",
+			cnt_cb->id);
 		return -ENOMEM;
 	}
 
@@ -1900,8 +1871,8 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->ipsec_cb.valid = kzalloc(sizeof(*cnt_cb->ipsec_cb.valid),
 					 GFP_KERNEL);
 	if (!cnt_cb->ipsec_cb.valid) {
-		log_err("Cannot allocate memory to store if security "
-			"association is valid for counter id %d\n", cnt_cb->id);
+		log_err("Cannot allocate memory to store if security association is valid for counter id %d\n",
+			cnt_cb->id);
 		return -ENOMEM;
 	}
 
@@ -1916,9 +1887,8 @@ static int set_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[0], &stats);
 	if (err < 0) {
-		log_err("Check failed for IPSec counter id %d due to incorrect "
-			"parameters: sa_id=%d\n", cnt_cb->id,
-			cnt_cb->ipsec_cb.sa_id[0]);
+		log_err("Check failed for IPSec counter id %d due to incorrect parameters: sa_id=%d\n",
+			cnt_cb->id, cnt_cb->ipsec_cb.sa_id[0]);
 		return -EINVAL;
 	}
 	init_cnt_32bit_stats(&cnt_cb->info, &stats, 0);
@@ -1947,15 +1917,15 @@ static int set_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	}
 
 	if (!params->traffic_mng_params.traffic_mng && !us_cnt) {
-		log_err("Parameter traffic_mng handle cannot be NULL for "
-			"counter id %d\n", cnt_cb->id);
+		log_err("Parameter traffic_mng handle cannot be NULL for counter id %d\n",
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
 	/* Check and store the counter source */
 	if (cnt_src > DPA_STATS_CNT_TRAFFIC_CG) {
-		log_err("Parameter src %d must be in range (%d - %d) for "
-			"counter id %d\n", cnt_src, DPA_STATS_CNT_TRAFFIC_CLASS,
+		log_err("Parameter src %d must be in range (%d - %d) for counter id %d\n",
+			cnt_src, DPA_STATS_CNT_TRAFFIC_CLASS,
 			DPA_STATS_CNT_TRAFFIC_CG, cnt_cb->id);
 		return -EINVAL;
 	}
@@ -1981,8 +1951,8 @@ static int set_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				params->traffic_mng_params.traffic_mng,
 				0, &stats[0], &stats[1]);
 		if (err < 0) {
-			log_err("Invalid Traffic Manager qm_ceetm_cq object for"
-				" counter id %d\n", cnt_cb->id);
+			log_err("Invalid Traffic Manager qm_ceetm_cq object for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 		break;
@@ -1992,8 +1962,8 @@ static int set_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				params->traffic_mng_params.traffic_mng,
 				0, &stats[0], &stats[1]);
 		if (err < 0) {
-			log_err("Invalid Traffic Manager qm_ceetm_ccg object "
-				"for counter id %d\n", cnt_cb->id);
+			log_err("Invalid Traffic Manager qm_ceetm_ccg object for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 		break;
@@ -2021,9 +1991,8 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	/* Check Ethernet counter selection */
 	if (params->eth_params.cnt_sel == 0 ||
 	    params->eth_params.cnt_sel > DPA_STATS_CNT_ETH_ALL) {
-		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
-			"counter id %d\n", cnt_sel, DPA_STATS_CNT_ETH_ALL,
-			cnt_cb->id);
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_ETH_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -2045,8 +2014,8 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Get FM MAC handle */
 		err = get_fm_mac(params->eth_params.src[i], &fm_mac);
 		if (err != 0) {
-			log_err("Cannot obtain Ethernet MAC handle for counter "
-				"id %d\n", cnt_cb->id);
+			log_err("Cannot obtain Ethernet MAC handle for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 
@@ -2054,8 +2023,8 @@ static int set_cls_cnt_eth_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 		err = FM_MAC_GetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err != 0) {
-			log_err("Invalid Ethernet counter source for counter id "
-				"%d\n", cnt_cb->id);
+			log_err("Invalid Ethernet counter source for counter id %d\n",
+				cnt_cb->id);
 			return -ENOENT;
 		}
 		init_cnt_64bit_stats(&cnt_cb->info, &stats, i);
@@ -2083,8 +2052,7 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	       cnt_sel <= DPA_STATS_CNT_REASS_IPv4_ALL) ||
 	      (cnt_sel >= DPA_STATS_CNT_REASS_IPv6_FRAMES &&
 	       cnt_sel <= DPA_STATS_CNT_REASS_IPv6_ALL))) {
-		log_err("Parameter cnt_sel %d must be in one of the ranges (1 -"
-			" %d), (%d - %d), (%d - %d) for counter id %d\n",
+		log_err("Parameter cnt_sel %d must be in one of the ranges (1 - %d), (%d - %d), (%d - %d) for counter id %d\n",
 			cnt_sel, DPA_STATS_CNT_REASS_GEN_ALL,
 			DPA_STATS_CNT_REASS_IPv4_FRAMES,
 			DPA_STATS_CNT_REASS_IPv4_ALL,
@@ -2115,8 +2083,8 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	for (i = 0; i < params->class_members; i++) {
 		if (!params->reass_params.reass[i]) {
-			log_err("Parameter Reassembly handle cannot be NULL for"
-				" member %d, counter id %d\n", i, cnt_cb->id);
+			log_err("Parameter Reassembly handle cannot be NULL for member %d, counter id %d\n",
+				i, cnt_cb->id);
 			return -EFAULT;
 		}
 		cnt_cb->gen_cb.objs[i] = params->reass_params.reass[i];
@@ -2124,8 +2092,8 @@ static int set_cls_cnt_reass_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Check the user-provided reassembly manip */
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
-			log_err("Invalid Reassembly manip handle for counter id"
-				" %d\n", cnt_cb->id);
+			log_err("Invalid Reassembly manip handle for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 		init_cnt_32bit_stats(&cnt_cb->info, &stats, i);
@@ -2149,9 +2117,8 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Check Fragmentation counter selection */
 	if ((cnt_sel == 0) || (cnt_sel > DPA_STATS_CNT_FRAG_ALL)) {
-		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
-			"counter id %d\n", cnt_sel, DPA_STATS_CNT_FRAG_ALL,
-			cnt_cb->id);
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_FRAG_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -2171,8 +2138,8 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	for (i = 0; i < params->class_members; i++) {
 		if (!params->frag_params.frag[i]) {
-			log_err("Parameter Fragmentation handle cannot be NULL "
-				"for member %d, counter id %d\n", i, cnt_cb->id);
+			log_err("Parameter Fragmentation handle cannot be NULL for member %d, counter id %d\n",
+				i, cnt_cb->id);
 			return -EFAULT;
 		}
 		cnt_cb->gen_cb.objs[i] = params->frag_params.frag[i];
@@ -2180,8 +2147,8 @@ static int set_cls_cnt_frag_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		/* Check the user-provided fragmentation handle */
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
-			log_err("Invalid Fragmentation manip handle for counter"
-				"id %d\n", cnt_cb->id);
+			log_err("Invalid Fragmentation manip handle for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 		init_cnt_32bit_stats(&cnt_cb->info, &stats, i);
@@ -2204,9 +2171,8 @@ static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Check Policer counter selection */
 	if (cnt_sel == 0 || cnt_sel > DPA_STATS_CNT_PLCR_ALL) {
-		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
-			"counter id %d\n", cnt_sel, DPA_STATS_CNT_PLCR_ALL,
-			cnt_cb->id);
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_PLCR_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -2226,8 +2192,8 @@ static int set_cls_cnt_plcr_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	for (i = 0; i < params->class_members; i++) {
 		if (!params->plcr_params.plcr[i]) {
-			log_err("Parameter Policer handle cannot be NULL for "
-				"member %d, counter id %d\n", i, cnt_cb->id);
+			log_err("Parameter Policer handle cannot be NULL for member %d, counter id %d\n",
+				i, cnt_cb->id);
 			return -EFAULT;
 		}
 		cnt_cb->gen_cb.objs[i] = params->plcr_params.plcr[i];
@@ -2263,23 +2229,22 @@ static int set_cls_cnt_classif_tbl_pair(
 	if ((!pair) || (pair && !pair->first_key)) {
 		err = dpa_classif_get_miss_action(td, &action);
 		if (err != 0) {
-			log_err("Cannot retrieve miss action parameters for "
-				"table descriptor %d\n", td);
+			log_err("Cannot retrieve miss action parameters for table descriptor %d\n",
+				td);
 			return -EINVAL;
 		}
 	} else {
 		/* Check that key byte is not NULL */
 		if (!pair->first_key->byte) {
-			log_err("First key descriptor byte of the user pair "
-				"cannot be NULL for table descriptor %d\n", td);
+			log_err("First key descriptor byte of the user pair cannot be NULL for table descriptor %d\n",
+				td);
 			return -EFAULT;
 		}
 
 		/* Copy first key descriptor parameters*/
 		err = copy_key_descriptor(pair->first_key, &tbl_key);
 		if (err != 0) {
-			log_err("Cannot copy second key descriptor of "
-				"the user pair\n");
+			log_err("Cannot copy second key descriptor of the user pair\n");
 			return -EINVAL;
 		}
 
@@ -2287,15 +2252,14 @@ static int set_cls_cnt_classif_tbl_pair(
 		 * table the next table connected on a "next-action" */
 		err = dpa_classif_table_lookup_by_key(td, &tbl_key, &action);
 		if (err != 0) {
-			log_err("Cannot retrieve next action parameters for "
-				"table descriptor %d\n", td);
+			log_err("Cannot retrieve next action parameters for table descriptor %d\n",
+				td);
 			return -EINVAL;
 		}
 	}
 
 	if (action.type != DPA_CLS_TBL_ACTION_NEXT_TABLE) {
-		log_err("Pair key is supported only if two tables are "
-			"connected");
+		log_err("Pair key is supported only if two tables are connected");
 		return -EINVAL;
 	}
 
@@ -2325,8 +2289,7 @@ static int set_cls_cnt_classif_tbl_pair(
 		/* Set as lookup key the second key descriptor from the pair */
 		err = copy_key_descriptor(pair->second_key, &lookup_key->key);
 		if (err != 0) {
-			log_err("Cannot copy second key descriptor of "
-				"the user pair\n");
+			log_err("Cannot copy second key descriptor of the user pair\n");
 			return -EINVAL;
 		}
 	}
@@ -2380,9 +2343,9 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		frag_stats = 1;
 
 	} else {
-		log_err("Parameter cnt_sel %d must be in one of the ranges (%d "
-			"- %d), (%d - %d), for counter id %d\n", cnt_sel,
-			DPA_STATS_CNT_CLASSIF_BYTES, DPA_STATS_CNT_CLASSIF_ALL,
+		log_err("Parameter cnt_sel %d must be in one of the ranges (%d - %d), (%d - %d), for counter id %d\n",
+			cnt_sel, DPA_STATS_CNT_CLASSIF_BYTES,
+			DPA_STATS_CNT_CLASSIF_ALL,
 			DPA_STATS_CNT_FRAG_TOTAL_FRAMES, DPA_STATS_CNT_FRAG_ALL,
 			cnt_cb->id);
 		return -EINVAL;
@@ -2399,24 +2362,24 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	tbl_cb->keys = kcalloc(params->class_members,
 			       sizeof(*tbl_cb->keys), GFP_KERNEL);
 	if (!tbl_cb->keys) {
-		log_err("Cannot allocate memory for array of key descriptors "
-			"for counter id %d\n", cnt_cb->id);
+		log_err("Cannot allocate memory for array of key descriptors for counter id %d\n",
+			cnt_cb->id);
 		return -ENOMEM;
 	}
 
 	switch (prm.key_type) {
 	case DPA_STATS_CLASSIF_SINGLE_KEY:
 		if (!prm.keys) {
-			log_err("Pointer to the array of keys cannot be NULL "
-				"for counter id %d\n", cnt_cb->id);
+			log_err("Pointer to the array of keys cannot be NULL for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 
 		/* Get CcNode from table descriptor */
 		err = dpa_classif_table_get_params(prm.td, &cls_tbl);
 		if (err != 0) {
-			log_err("Invalid table descriptor %d for counter id "
-				"%d\n", prm.td, cnt_cb->id);
+			log_err("Invalid table descriptor %d for counter id %d\n",
+				prm.td, cnt_cb->id);
 			return -EINVAL;
 		}
 
@@ -2445,8 +2408,7 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			err = copy_key_descriptor(prm.keys[i],
 						  &tbl_cb->keys[i].key);
 			if (err != 0) {
-				log_err("Cannot copy key descriptor from user "
-					"parameters\n");
+				log_err("Cannot copy key descriptor from user parameters\n");
 				return -EINVAL;
 			}
 			tbl_cb->keys[i].valid = TRUE;
@@ -2454,8 +2416,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		break;
 	case DPA_STATS_CLASSIF_PAIR_KEY:
 		if (!prm.pairs) {
-			log_err("Pointer to the array of pairs cannot be NULL "
-				"for counter id %d\n", cnt_cb->id);
+			log_err("Pointer to the array of pairs cannot be NULL for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 
@@ -2473,17 +2435,16 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			err = set_cls_cnt_classif_tbl_pair(
 					cnt_cb, prm.td, prm.pairs[i], i);
 			if (err != 0) {
-				log_err("Cannot set classifier table pair key "
-					"for counter id %d\n", cnt_cb->id);
+				log_err("Cannot set classifier table pair key for counter id %d\n",
+					cnt_cb->id);
 				return -EINVAL;
 			}
 			tbl_cb->keys[i].valid = TRUE;
 		}
 		break;
 	default:
-		log_err("Parameter key_type %d must be in range (%d - %d) for "
-			"counter id %d\n", prm.key_type,
-			DPA_STATS_CLASSIF_SINGLE_KEY,
+		log_err("Parameter key_type %d must be in range (%d - %d) for counter id %d\n",
+			prm.key_type, DPA_STATS_CLASSIF_SINGLE_KEY,
 			DPA_STATS_CLASSIF_PAIR_KEY, cnt_cb->id);
 		return -EINVAL;
 	}
@@ -2499,7 +2460,10 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 				if (err != 0)
 					return -EINVAL;
 			} else {
-				/* Get Classifier Table counter statistics for a key */
+				/*
+				 * Get Classifier Table counter statistics for
+				 * a key
+				 */
 				err = get_classif_tbl_key_stats(cnt_cb, i);
 				if (err != 0)
 					return -EINVAL;
@@ -2513,8 +2477,8 @@ static int set_cls_cnt_classif_tbl_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 			err = set_frag_manip(prm.td, &cnt_cb->tbl_cb.keys[i]);
 			if (err < 0) {
-				log_err("Invalid Fragmentation manip handle for"
-					" counter id %d\n", cnt_cb->id);
+				log_err("Invalid Fragmentation manip handle for counter id %d\n",
+					cnt_cb->id);
 				return -EINVAL;
 			}
 		}
@@ -2540,21 +2504,20 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 
 	/* Check Classification Cc Node counter selection */
 	if (prm.cnt_sel == 0 ||  prm.cnt_sel > DPA_STATS_CNT_CLASSIF_ALL) {
-		log_err("Parameter cnt_sel %d must be in range (1 - %d) for "
-			"counter id %d\n", prm.cnt_sel,
-			DPA_STATS_CNT_CLASSIF_ALL, cnt_cb->id);
+		log_err("Parameter cnt_sel %d must be in range (1 - %d) for counter id %d\n",
+			prm.cnt_sel, DPA_STATS_CNT_CLASSIF_ALL, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	if (!params->classif_node_params.cc_node) {
-		log_err("Parameter classification CC Node handle cannot be NULL"
-			" for counter id %d\n", cnt_cb->id);
+		log_err("Parameter classification CC Node handle cannot be NULL for counter id %d\n",
+			cnt_cb->id);
 		return -EFAULT;
 	}
 
 	if (!prm.keys) {
-		log_err("Pointer to the array of keys cannot be NULL "
-			"for counter id %d\n", cnt_cb->id);
+		log_err("Pointer to the array of keys cannot be NULL for counter id %d\n",
+			cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -2589,8 +2552,7 @@ static int set_cls_cnt_ccnode_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			err = copy_key_descriptor(prm.keys[i],
 						  &cnt_cb->ccnode_cb.keys[i]);
 			if (err != 0) {
-				log_err("Cannot copy key descriptor from user "
-					"parameters\n");
+				log_err("Cannot copy key descriptor from user parameters\n");
 				return -EINVAL;
 			}
 
@@ -2622,8 +2584,8 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->ipsec_cb.sa_id = kcalloc(prm->class_members,
 				  sizeof(*cnt_cb->ipsec_cb.sa_id), GFP_KERNEL);
 	if (!cnt_cb->ipsec_cb.sa_id) {
-		log_err("Cannot allocate memory for array of security "
-			"association ids, for counter id %d\n", cnt_cb->id);
+		log_err("Cannot allocate memory for array of security association ids, for counter id %d\n",
+			cnt_cb->id);
 		return -ENOMEM;
 	}
 
@@ -2631,8 +2593,7 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 	cnt_cb->ipsec_cb.valid = kcalloc(prm->class_members,
 				  sizeof(*cnt_cb->ipsec_cb.valid), GFP_KERNEL);
 	if (!cnt_cb->ipsec_cb.valid) {
-		log_err("Cannot allocate memory for array that stores if "
-			"security association ids are valid for counter id %d\n",
+		log_err("Cannot allocate memory for array that stores if security association ids are valid for counter id %d\n",
 			cnt_cb->id);
 		return -ENOMEM;
 	}
@@ -2652,10 +2613,8 @@ static int set_cls_cnt_ipsec_cb(struct dpa_stats_cnt_cb *cnt_cb,
 			err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[i],
 					&stats);
 			if (err < 0) {
-				log_err("Check failed for IPSec counter id %d "
-					"due to incorrect parameters: sa_id=%d"
-					"\n", cnt_cb->id,
-					cnt_cb->ipsec_cb.sa_id[i]);
+				log_err("Check failed for IPSec counter id %d due to incorrect parameters: sa_id=%d\n",
+					cnt_cb->id, cnt_cb->ipsec_cb.sa_id[i]);
 				return -EINVAL;
 			}
 			init_cnt_32bit_stats(&cnt_cb->info, &stats, i);
@@ -2705,17 +2664,17 @@ static int set_cls_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		cnt_cb->f_get_cnt_stats = get_cnt_traffic_mng_cq_stats;
 		for (i = 0; i < params->class_members; i++) {
 			if (!prm.traffic_mng[i]) {
-				log_err("Parameter traffic_mng handle cannot "
-					"be NULL for member %d\n", i);
+				log_err("Parameter traffic_mng handle cannot be NULL for member %d\n",
+					i);
 				return -EFAULT;
 			}
 
 			/* Check the provided Traffic Manager object */
 			err = qman_ceetm_cq_get_dequeue_statistics(
-					prm.traffic_mng[i], 0, &stats[0], &stats[1]);
+				prm.traffic_mng[i], 0, &stats[0], &stats[1]);
 			if (err < 0) {
-				log_err("Invalid traffic_mng handle for counter"
-					" id %d\n", cnt_cb->id);
+				log_err("Invalid traffic_mng handle for counter id %d\n",
+					cnt_cb->id);
 				return -EINVAL;
 			}
 			init_cnt_64bit_stats(&cnt_cb->info, &stats, i);
@@ -2726,17 +2685,17 @@ static int set_cls_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		cnt_cb->f_get_cnt_stats = get_cnt_traffic_mng_ccg_stats;
 		for (i = 0; i < params->class_members; i++) {
 			if (!prm.traffic_mng[i])	{
-				log_err("Parameter traffic_mng handle cannot"
-					"be NULL for member %d\n", i);
+				log_err("Parameter traffic_mng handle cannot be NULL for member %d\n",
+					i);
 				return -EFAULT;
 			}
 
 			/* Check the provided Traffic Manager object */
 			err = qman_ceetm_ccg_get_reject_statistics(
-					prm.traffic_mng[i], 0, &stats[0], &stats[1]);
+				prm.traffic_mng[i], 0, &stats[0], &stats[1]);
 			if (err < 0) {
-				log_err("Invalid traffic_mng handle for counter"
-					" id %d\n", cnt_cb->id);
+				log_err("Invalid traffic_mng handle for counter id %d\n",
+					cnt_cb->id);
 				return -EINVAL;
 			}
 			init_cnt_64bit_stats(&cnt_cb->info, &stats, i);
@@ -2744,8 +2703,8 @@ static int set_cls_cnt_traffic_mng_cb(struct dpa_stats_cnt_cb *cnt_cb,
 		}
 		break;
 	default:
-		log_err("Parameter src %d must be in range (%d - %d) for "
-			"counter id %d\n", prm.src, DPA_STATS_CNT_TRAFFIC_CLASS,
+		log_err("Parameter src %d must be in range (%d - %d) for counter id %d\n",
+			prm.src, DPA_STATS_CNT_TRAFFIC_CLASS,
 			DPA_STATS_CNT_TRAFFIC_CG, cnt_cb->id);
 		return -EINVAL;
 	}
@@ -2762,17 +2721,15 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 
 	/* Check that counter is of type Classifier table */
 	if (cnt_cb->type != DPA_STATS_CNT_CLASSIF_TBL) {
-		log_err("Operation permitted only on counter type "
-			"DPA_STATS_CNT_CLASSIF_TBL %d for counter id %d\n",
+		log_err("Operation permitted only on counter type DPA_STATS_CNT_CLASSIF_TBL %d for counter id %d\n",
 			DPA_STATS_CNT_CLASSIF_TBL, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	/* Check that member index does not exceeds class size */
 	if (mbr_idx < 0 || mbr_idx >= cnt_cb->members_num) {
-		log_err("Parameter member_index %d must be in range (0 - %d) "
-			"for counter id %d\n", mbr_idx,
-			cnt_cb->members_num - 1, cnt_cb->id);
+		log_err("Parameter member_index %d must be in range (0 - %d) for counter id %d\n",
+			mbr_idx, cnt_cb->members_num - 1, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -2803,8 +2760,7 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 			err = copy_key_descriptor(prm->key,
 						  &tbl_cb->keys[mbr_idx].key);
 			if (err != 0) {
-				log_err("Cannot copy key descriptor from user "
-					"parameters\n");
+				log_err("Cannot copy key descriptor from user parameters\n");
 				return -EINVAL;
 			}
 			tbl_cb->keys[mbr_idx].miss_key = FALSE;
@@ -2828,8 +2784,8 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 		err = set_cls_cnt_classif_tbl_pair(cnt_cb, tbl_cb->td,
 						   prm->pair, mbr_idx);
 		if (err != 0) {
-			log_err("Cannot configure the pair key for counter id "
-				"%d of member %d\n", cnt_cb->id, mbr_idx);
+			log_err("Cannot configure the pair key for counter id %d of member %d\n",
+				cnt_cb->id, mbr_idx);
 			return -EINVAL;
 		}
 	}
@@ -2845,8 +2801,8 @@ int set_classif_tbl_member(const struct dpa_stats_cls_member_params *prm,
 	} else{
 		err = set_frag_manip(tbl_cb->td, &tbl_cb->keys[mbr_idx]);
 		if (err < 0) {
-			log_err("Invalid Fragmentation manip handle for"
-				" counter id %d\n", cnt_cb->id);
+			log_err("Invalid Fragmentation manip handle for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 	}
@@ -2864,17 +2820,15 @@ int set_ipsec_member(const struct dpa_stats_cls_member_params *params,
 
 	/* Check that counter is of type IPSec */
 	if (cnt_cb->type != DPA_STATS_CNT_IPSEC) {
-		log_err("Operation permitted only on counter type "
-			"DPA_STATS_CNT_IPSEC %d for counter id %d\n",
+		log_err("Operation permitted only on counter type DPA_STATS_CNT_IPSEC %d for counter id %d\n",
 			DPA_STATS_CNT_IPSEC, cnt_cb->id);
 		return -EINVAL;
 	}
 
 	/* Check that member index does not exceeds class size */
 	if (mbr_idx < 0 || mbr_idx >= cnt_cb->members_num) {
-		log_err("Parameter member_index %d must be in range (0 - %d) "
-			"for counter id %d\n", mbr_idx,
-			cnt_cb->members_num - 1, cnt_cb->id);
+		log_err("Parameter member_index %d must be in range (0 - %d) for counter id %d\n",
+			mbr_idx, cnt_cb->members_num - 1, cnt_cb->id);
 		return -EINVAL;
 	}
 
@@ -2894,9 +2848,8 @@ int set_ipsec_member(const struct dpa_stats_cls_member_params *params,
 		err = dpa_ipsec_sa_get_stats(
 				cnt_cb->ipsec_cb.sa_id[mbr_idx], &stats);
 		if (err < 0) {
-			log_err("Get failed for IPSec counter id %d due to "
-				"incorrect parameters: sa_id=%d\n", cnt_cb->id,
-				cnt_cb->ipsec_cb.sa_id[mbr_idx]);
+			log_err("Get failed for IPSec counter id %d due to incorrect parameters: sa_id=%d\n",
+				cnt_cb->id, cnt_cb->ipsec_cb.sa_id[mbr_idx]);
 			return -EINVAL;
 		}
 		init_cnt_32bit_stats(&cnt_cb->info, &stats, 0);
@@ -3030,8 +2983,8 @@ static int get_cnt_eth_stats(struct dpa_stats_req_cb *req_cb,
 	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_MAC_GetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err != 0) {
-			log_err("Cannot retrieve Ethernet statistics for "
-				"counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Ethernet statistics for counter id %d\n",
+				cnt_cb->id);
 			return -ENOENT;
 		}
 
@@ -3051,8 +3004,8 @@ static int get_cnt_reass_stats(struct dpa_stats_req_cb *req_cb,
 	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
-			log_err("Cannot retrieve Reassembly statistics for "
-				"counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Reassembly statistics for counter id %d\n",
+				cnt_cb->id);
 			return -ESRCH;
 		}
 
@@ -3073,8 +3026,8 @@ static int get_cnt_frag_stats(struct dpa_stats_req_cb *req_cb,
 	for (i = 0; i < cnt_cb->members_num; i++) {
 		err = FM_PCD_ManipGetStatistics(cnt_cb->gen_cb.objs[i], &stats);
 		if (err < 0) {
-			log_err("Cannot retrieve Fragmentation statistics for "
-				"counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Fragmentation statistics for counter id %d\n",
+				cnt_cb->id);
 			return -EINTR;
 		}
 
@@ -3156,8 +3109,8 @@ static int get_cnt_cls_tbl_match_stats(struct dpa_stats_req_cb *req_cb,
 		}
 
 		if (err != 0) {
-			log_err("Cannot retrieve Classifier Exact Match Table "
-				"statistics for counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Classifier Exact Match Table statistics for counter id %d\n",
+				cnt_cb->id);
 			return -EIO;
 		}
 		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
@@ -3196,8 +3149,8 @@ static int get_cnt_cls_tbl_hash_stats(struct dpa_stats_req_cb *req_cb,
 					&stats);
 		}
 		if (err != 0) {
-			log_err("Cannot retrieve Classifier Hash Table "
-				"statistics for counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Classifier Hash Table statistics for counter id %d\n",
+				cnt_cb->id);
 			return -EIO;
 		}
 		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
@@ -3236,8 +3189,8 @@ static int get_cnt_cls_tbl_index_stats(struct dpa_stats_req_cb *req_cb,
 		}
 
 		if (err != 0) {
-			log_err("Cannot retrieve Classifier Indexed Table "
-				"statistics for counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Classifier Indexed Table statistics for counter id %d\n",
+				cnt_cb->id);
 			return -EIO;
 		}
 		get_cnt_32bit_stats(req_cb, &cnt_cb->info, &stats, i);
@@ -3268,8 +3221,8 @@ static int get_cnt_cls_tbl_frag_stats(struct dpa_stats_req_cb *req_cb,
 		err = FM_PCD_ManipGetStatistics(
 				cnt_cb->tbl_cb.keys[i].frag, &stats);
 		if (err < 0) {
-			log_err("Cannot retrieve Fragmentation statistics for "
-				"counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Fragmentation statistics for counter id %d\n",
+				cnt_cb->id);
 			return -EINTR;
 		}
 		get_cnt_32bit_stats(req_cb,
@@ -3298,8 +3251,7 @@ static int get_cnt_ccnode_match_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->ccnode_cb.keys[i].mask, &stats);
 		}
 		if (err != 0) {
-			log_err("Cannot retrieve Classification Cc Node Exact "
-				"Match statistics for counter id %d\n",
+			log_err("Cannot retrieve Classification Cc Node Exact Match statistics for counter id %d\n",
 				cnt_cb->id);
 			return -ENXIO;
 		}
@@ -3328,8 +3280,8 @@ static int get_cnt_ccnode_hash_stats(struct dpa_stats_req_cb *req_cb,
 		}
 
 		if (err != 0) {
-			log_err("Cannot retrieve Classification Cc Node Hash "
-				"statistics for counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Classification Cc Node Hash statistics for counter id %d\n",
+				cnt_cb->id);
 			return -ENXIO;
 		}
 
@@ -3355,8 +3307,8 @@ static int get_cnt_ccnode_index_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->ccnode_cb.keys[i].byte[0], &stats);
 		}
 		if (err != 0) {
-			log_err("Cannot retrieve Classification Cc Node Index "
-				"statistics for counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Classification Cc Node Index statistics for counter id %d\n",
+				cnt_cb->id);
 			return -ENXIO;
 		}
 
@@ -3387,8 +3339,8 @@ static int get_cnt_ipsec_stats(struct dpa_stats_req_cb *req_cb,
 
 		err = dpa_ipsec_sa_get_stats(cnt_cb->ipsec_cb.sa_id[i], &stats);
 		if (err < 0) {
-			log_err("Cannot retrieve IPSec statistics for counter "
-				"id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve IPSec statistics for counter id %d\n",
+				cnt_cb->id);
 			return -E2BIG;
 		}
 
@@ -3411,8 +3363,8 @@ static int get_cnt_traffic_mng_cq_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->gen_cb.objs[i], 0,
 				&stats_val[1], &stats_val[0]);
 		if (err < 0) {
-			log_err("Cannot retrieve Traffic Manager Class Queue "
-				"statistics for counter id %d\n", cnt_cb->id);
+			log_err("Cannot retrieve Traffic Manager Class Queue statistics for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 		get_cnt_64bit_stats(req_cb, &cnt_cb->info, stats_val, i);
@@ -3432,9 +3384,8 @@ static int get_cnt_traffic_mng_ccg_stats(struct dpa_stats_req_cb *req_cb,
 				cnt_cb->gen_cb.objs[i], 0,
 				&stats_val[1], &stats_val[0]);
 		if (err < 0) {
-			log_err("Cannot retrieve Traffic Manager Class "
-				"Congestion Group statistics for counter id "
-				"%d\n", cnt_cb->id);
+			log_err("Cannot retrieve Traffic Manager Class Congestion Group statistics for counter id %d\n",
+				cnt_cb->id);
 			return -EINVAL;
 		}
 		get_cnt_64bit_stats(req_cb, &cnt_cb->info, stats_val, i);
@@ -3498,8 +3449,7 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 
 	/* Sanity checks */
 	if (gbl_dpa_stats) {
-		log_err("DPA Stats component already initialized. Multiple DPA "
-			"Stats instances are not supported.\n");
+		log_err("DPA Stats component already initialized. Multiple DPA Stats instances are not supported.\n");
 		return -EPERM;
 	}
 
@@ -3511,8 +3461,7 @@ int dpa_stats_init(const struct dpa_stats_params *params, int *dpa_stats_id)
 	/* Control block allocation */
 	dpa_stats = kzalloc(sizeof(struct dpa_stats), GFP_KERNEL);
 	if (!dpa_stats) {
-		log_err("Cannot allocate memory for internal DPA Stats "
-			"structure.\n");
+		log_err("Cannot allocate memory for internal DPA Stats structure.\n");
 		return -ENOMEM;
 	}
 
@@ -3595,8 +3544,7 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 	err = get_new_cnt(dpa_stats, &cnt_cb);
 	if (err < 0) {
-		log_err("Cannot retrieve preallocated internal counter "
-			"structure\n");
+		log_err("Cannot retrieve preallocated internal counter structure\n");
 		return err;
 	}
 
@@ -3653,8 +3601,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_classif_tbl_cb(cnt_cb, params);
 		if (err != 0) {
-			log_err("Cannot create Classifier Table counter id "
-				"%d\n", cnt_cb->id);
+			log_err("Cannot create Classifier Table counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -3663,8 +3611,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_ccnode_cb(cnt_cb, params);
 		if (err != 0) {
-			log_err("Cannot create Classification Cc Node counter "
-				"id %d\n", cnt_cb->id);
+			log_err("Cannot create Classification Cc Node counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -3684,8 +3632,8 @@ int dpa_stats_create_counter(int dpa_stats_id,
 
 		err = set_cnt_traffic_mng_cb(cnt_cb, params);
 		if (err != 0) {
-			log_err("Cannot crate Traffic Manager counter id %d"
-				"\n", cnt_cb->id);
+			log_err("Cannot crate Traffic Manager counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -3752,8 +3700,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 	}
 
 	if (params->class_members > DPA_STATS_MAX_NUM_OF_CLASS_MEMBERS) {
-		log_err("Parameter class_members %d exceeds maximum number of "
-			"class members: %d\n", params->class_members,
+		log_err("Parameter class_members %d exceeds maximum number of class members: %d\n",
+			params->class_members,
 			DPA_STATS_MAX_NUM_OF_CLASS_MEMBERS);
 		return -EINVAL;
 	}
@@ -3762,8 +3710,7 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 	err = get_new_cnt(dpa_stats, &cnt_cb);
 	if (err < 0) {
-		log_err("Cannot retrieve preallocated internal counter "
-			"structure\n");
+		log_err("Cannot retrieve preallocated internal counter structure\n");
 		return err;
 	}
 
@@ -3821,8 +3768,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_classif_tbl_cb(cnt_cb, params);
 		if (err != 0) {
-			log_err("Cannot create Classifier Table counter id "
-				"%d\n", cnt_cb->id);
+			log_err("Cannot create Classifier Table counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -3831,8 +3778,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_ccnode_cb(cnt_cb, params);
 		if (err != 0) {
-			log_err("Cannot create Classification Cc Node counter "
-				"id %d\n", cnt_cb->id);
+			log_err("Cannot create Classification Cc Node counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -3852,8 +3799,8 @@ int dpa_stats_create_class_counter(int dpa_stats_id,
 
 		err = set_cls_cnt_traffic_mng_cb(cnt_cb, params);
 		if (err != 0) {
-			log_err("Cannot create Traffic Manager counter id %d"
-				"\n", cnt_cb->id);
+			log_err("Cannot create Traffic Manager counter id %d\n",
+				cnt_cb->id);
 			goto create_counter_err;
 		}
 		break;
@@ -3908,9 +3855,8 @@ int dpa_stats_modify_class_counter(int dpa_stats_cnt_id,
 
 	if (dpa_stats_cnt_id < 0 ||
 			dpa_stats_cnt_id > dpa_stats->config.max_counters) {
-		log_err("Parameter dpa_stats_cnt_id %d must be in range (0 - %d"
-			")\n", dpa_stats_cnt_id,
-			dpa_stats->config.max_counters - 1);
+		log_err("Parameter dpa_stats_cnt_id %d must be in range (0 - %d)\n",
+			dpa_stats_cnt_id, dpa_stats->config.max_counters - 1);
 		return -EINVAL;
 	}
 
@@ -3961,8 +3907,8 @@ int dpa_stats_modify_class_counter(int dpa_stats_cnt_id,
 			return -EINVAL;
 		}
 	} else {
-		log_err("Parameter type %d for counter id %d must be in range "
-			"(%d - %d)\n", params->type, dpa_stats_cnt_id,
+		log_err("Parameter type %d for counter id %d must be in range (%d - %d)\n",
+			params->type, dpa_stats_cnt_id,
 			DPA_STATS_CLS_MEMBER_SINGLE_KEY,
 			DPA_STATS_CLS_MEMBER_SA_ID);
 		mutex_unlock(&cnt_cb->lock);
@@ -3992,9 +3938,8 @@ int dpa_stats_remove_counter(int dpa_stats_cnt_id)
 
 	if (dpa_stats_cnt_id < 0 ||
 			dpa_stats_cnt_id > dpa_stats->config.max_counters) {
-		log_err("Parameter dpa_stats_cnt_id %d must be in range (0 - %d"
-			")\n", dpa_stats_cnt_id,
-			dpa_stats->config.max_counters - 1);
+		log_err("Parameter dpa_stats_cnt_id %d must be in range (0 - %d)\n",
+			dpa_stats_cnt_id, dpa_stats->config.max_counters - 1);
 		return -EINVAL;
 	}
 
@@ -4093,9 +4038,8 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 	for (i = 0; i < params.cnts_ids_len; i++) {
 		if (params.cnts_ids[i] == DPA_OFFLD_INVALID_OBJECT_ID ||
 		    params.cnts_ids[i] > dpa_stats->config.max_counters) {
-			log_err("Counter id (cnt_ids[%d]) %d is not initialized"
-				" or is greater than maximum counters %d\n", i,
-				params.cnts_ids[i],
+			log_err("Counter id (cnt_ids[%d]) %d is not initialized or is greater than maximum counters %d\n",
+				i, params.cnts_ids[i],
 				dpa_stats->config.max_counters);
 			return -EINVAL;
 		}
@@ -4115,8 +4059,8 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 
 		/* Check if counter control block is initialized */
 		if (cnt_cb->index == DPA_OFFLD_INVALID_OBJECT_ID) {
-			log_err("Counter id (cnt_ids[%d]) %d is not initialized"
-				"\n", i, cnt_id);
+			log_err("Counter id (cnt_ids[%d]) %d is not initialized\n",
+				i, cnt_id);
 			mutex_unlock(&cnt_cb->lock);
 			unblock_sched_cnts(dpa_stats, params.cnts_ids,
 					   params.cnts_ids_len);
@@ -4130,8 +4074,7 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 	/* Check user-provided parameters */
 	if ((params.storage_area_offset + *cnts_len) >
 		dpa_stats->config.storage_area_len) {
-		log_err("Parameter storage_area_offset %d and counters length "
-			"%d exceeds configured storage_area_len %d\n",
+		log_err("Parameter storage_area_offset %d and counters length %d exceeds configured storage_area_len %d\n",
 			params.storage_area_offset, *cnts_len,
 			dpa_stats->config.storage_area_len);
 		unblock_sched_cnts(dpa_stats, params.cnts_ids,
@@ -4142,8 +4085,7 @@ int dpa_stats_get_counters(struct dpa_stats_cnt_request_params params,
 	/* Create a new request */
 	err = get_new_req(dpa_stats, &req_id, &req_cb);
 	if (err < 0) {
-		log_err("Cannot retrieve preallocated internal request "
-			"structure\n");
+		log_err("Cannot retrieve preallocated internal request structure\n");
 		/* Release counters locks */
 		unblock_sched_cnts(dpa_stats, params.cnts_ids,
 				   params.cnts_ids_len);
@@ -4212,9 +4154,8 @@ int dpa_stats_reset_counters(int *cnts_ids, unsigned int cnts_ids_len)
 	for (i = 0; i < cnts_ids_len; i++)
 		if (cnts_ids[i] == DPA_OFFLD_INVALID_OBJECT_ID ||
 		    cnts_ids[i] > dpa_stats->config.max_counters) {
-			log_err("Counter id (cnts_ids[%d]) %d is not "
-				"initialized or is greater than maximum "
-				"counters %d\n", i, cnts_ids[i],
+			log_err("Counter id (cnts_ids[%d]) %d is not initialized or is greater than maximum counters %d\n",
+				i, cnts_ids[i],
 				dpa_stats->config.max_counters - 1);
 			return -EINVAL;
 		}
@@ -4238,8 +4179,8 @@ int dpa_stats_reset_counters(int *cnts_ids, unsigned int cnts_ids_len)
 
 		/* Check if counter control block is initialized */
 		if (cnt_cb->index == DPA_OFFLD_INVALID_OBJECT_ID) {
-			log_err("Counter id (cnt_ids[%d]) %d is not initialized"
-				"\n", i, cnts_ids[i]);
+			log_err("Counter id (cnt_ids[%d]) %d is not initialized\n",
+				i, cnts_ids[i]);
 			mutex_unlock(&cnt_cb->lock);
 			unblock_sched_cnts(dpa_stats,
 					   cnts_ids, cnts_ids_len);
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 064766f..9a044f3 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -279,8 +279,7 @@ ssize_t wrp_dpa_stats_read(struct file *file,
 					 wrp_dpa_stats.k_mem +
 					 event->params.storage_area_offset,
 					 event->params.bytes_written)) {
-				log_err("Cannot copy counter values to storage "
-					"area\n");
+				log_err("Cannot copy counter values to storage area\n");
 				return -EFAULT;
 			}
 		}
@@ -344,8 +343,7 @@ ssize_t wrp_dpa_stats_read(struct file *file,
 					 wrp_dpa_stats.k_mem +
 					 event->params.storage_area_offset,
 					 event->params.bytes_written)) {
-				log_err("Cannot copy counter values to storage "
-					"area\n");
+				log_err("Cannot copy counter values to storage area\n");
 				return -EFAULT;
 			}
 		}
@@ -550,8 +548,7 @@ static long do_ioctl_stats_init(struct ioc_dpa_stats_params *prm)
 		 */
 		params.storage_area = phys_to_virt(prm->phys_stg_area);
 		if (!params.storage_area) {
-			log_err("Invalid physical memory address for storage "
-				"area\n");
+			log_err("Invalid physical memory address for storage area\n");
 			return -EINVAL;
 		}
 		wrp_dpa_stats.k_mem = NULL;
@@ -563,8 +560,7 @@ static long do_ioctl_stats_init(struct ioc_dpa_stats_params *prm)
 		params.storage_area = kzalloc(
 				prm->storage_area_len, GFP_KERNEL);
 		if (!params.storage_area) {
-			log_err("Cannot allocate memory for kernel storage "
-				"area\n");
+			log_err("Cannot allocate memory for kernel storage area\n");
 			return -ENOMEM;
 		}
 
@@ -584,8 +580,7 @@ static long do_ioctl_stats_init(struct ioc_dpa_stats_params *prm)
 	wrp_dpa_stats.async_req_group = kmalloc(DPA_STATS_MAX_NUM_OF_REQUESTS *
 				sizeof(struct list_head), GFP_KERNEL);
 	if (!wrp_dpa_stats.async_req_group) {
-		log_err("Cannot allocate memory for asynchronous requests "
-			"group\n");
+		log_err("Cannot allocate memory for asynchronous requests group\n");
 		return -ENOMEM;
 	}
 
@@ -607,8 +602,7 @@ static long do_ioctl_stats_init(struct ioc_dpa_stats_params *prm)
 				list_del(&async_req_ev->node);
 				kfree(async_req_ev);
 			}
-			log_err("Cannot allocate memory for asynchronous "
-				"request event\n");
+			log_err("Cannot allocate memory for asynchronous request event\n");
 			return -ENOMEM;
 		}
 
@@ -838,8 +832,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 		/* Allocate memory to store the sources array */
 		eth_src = kmalloc(sizeof(*eth_src) * cls_mbrs, GFP_KERNEL);
 		if (!eth_src) {
-			log_err("Cannot allocate memory for Ethernet sources "
-				"array\n");
+			log_err("Cannot allocate memory for Ethernet sources array\n");
 			return -ENOMEM;
 		}
 
@@ -900,8 +893,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 			tbl->keys = kzalloc(cls_mbrs *
 					    sizeof(**tbl->keys), GFP_KERNEL);
 			if (!tbl->keys) {
-				log_err("Cannot allocate kernel memory for "
-					"lookup keys array\n");
+				log_err("Cannot allocate kernel memory for lookup keys array\n");
 				return -ENOMEM;
 			}
 
@@ -923,8 +915,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 			tbl->pairs = kzalloc(cls_mbrs *
 					    sizeof(**tbl->pairs), GFP_KERNEL);
 			if (!tbl->pairs) {
-				log_err("Cannot allocate kernel memory for "
-					"lookup pairs array\n");
+				log_err("Cannot allocate kernel memory for lookup pairs array\n");
 				return -ENOMEM;
 			}
 
@@ -934,8 +925,7 @@ static int do_ioctl_stats_create_class_counter(void *args)
 				ret = copy_pair_descriptor(us_pairs[i],
 						&tbl->pairs[i]);
 				if (ret != 0) {
-					log_err("Could not copy the "
-					       "pair key descriptor\n");
+					log_err("Could not copy the pair key descriptor\n");
 					goto create_cls_counter_cleanup;
 				}
 			}
@@ -1330,8 +1320,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 	}
 
 	if (copy_to_user(args, &prm, sizeof(prm))) {
-		log_err("Could not write "
-		       "dpa_stats_modify_class_counter result\n");
+		log_err("Could not write dpa_stats_modify_class_counter result\n");
 		ret = -EBUSY;
 	}
 
@@ -1374,8 +1363,7 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 
 		if (copy_from_user(&pair, compat_ptr(uprm.params.pair),
 				   (sizeof(pair)))) {
-			log_err("Cannot copy from user array of "
-				"lookup pairs\n");
+			log_err("Cannot copy from user array of lookup pairs\n");
 			return -EBUSY;
 		}
 
@@ -1449,8 +1437,7 @@ static int do_ioctl_stats_get_counters(void *args)
 	cnts_ids = kzalloc(prm.req_params.cnts_ids_len *
 			   sizeof(int), GFP_KERNEL);
 	if (!cnts_ids) {
-		log_err("Cannot allocate memory for requested counter ids "
-			"array\n");
+		log_err("Cannot allocate memory for requested counter ids array\n");
 		return -ENOMEM;
 	}
 
@@ -1458,8 +1445,7 @@ static int do_ioctl_stats_get_counters(void *args)
 	if (copy_from_user(cnts_ids,
 			   prm.req_params.cnts_ids,
 			   (prm.req_params.cnts_ids_len * sizeof(int)))) {
-		log_err("Cannot copy from user array of requested counter "
-			"ids\n");
+		log_err("Cannot copy from user array of requested counter ids\n");
 		kfree(prm.req_params.cnts_ids);
 		return -EINVAL;
 	}
@@ -1488,8 +1474,7 @@ static int do_ioctl_stats_get_counters(void *args)
 					  (wrp_dpa_stats.k_mem +
 					  prm.req_params.storage_area_offset),
 					  prm.cnts_len)) {
-				log_err("Cannot copy counter values to storage "
-					"area\n");
+				log_err("Cannot copy counter values to storage area\n");
 				return -EINVAL;
 			}
 
@@ -1530,8 +1515,7 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 	kprm.req_params.cnts_ids = kzalloc(kprm.req_params.cnts_ids_len *
 					   sizeof(int), GFP_KERNEL);
 	if (!kprm.req_params.cnts_ids) {
-		log_err("Cannot allocate memory for requested counter ids "
-			"array\n");
+		log_err("Cannot allocate memory for requested counter ids array\n");
 		return -ENOMEM;
 	}
 
@@ -1539,8 +1523,7 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 	if (copy_from_user(kprm.req_params.cnts_ids,
 			   (compat_ptr)(uprm.req_params.cnts_ids),
 			   (kprm.req_params.cnts_ids_len * sizeof(int)))) {
-		log_err("Cannot copy from user the array of requested counter "
-			"ids\n");
+		log_err("Cannot copy from user the array of requested counter ids\n");
 		kfree(kprm.req_params.cnts_ids);
 		return -EINVAL;
 	}
@@ -1572,8 +1555,7 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 					(wrp_dpa_stats.k_mem +
 					kprm.req_params.storage_area_offset),
 					kprm.cnts_len)) {
-				log_err("Cannot copy counter values to storage "
-					"area\n");
+				log_err("Cannot copy counter values to storage area\n");
 				kfree(kprm.req_params.cnts_ids);
 				return -EINVAL;
 			}
@@ -1583,8 +1565,7 @@ static int do_ioctl_stats_compat_get_counters(void *args)
 		if (copy_to_user((compat_ptr)(uprm.req_params.cnts_ids),
 				kprm.req_params.cnts_ids,
 				(kprm.req_params.cnts_ids_len * sizeof(int)))) {
-			log_err("Cannot copy to user the array of requested "
-				"counter ids\n");
+			log_err("Cannot copy to user the array of requested counter ids\n");
 			kfree(kprm.req_params.cnts_ids);
 			return -EINVAL;
 		}
@@ -1624,8 +1605,7 @@ static int do_ioctl_stats_reset_counters(void *args)
 	if (copy_from_user(cnt_ids,
 			prm.cnts_ids,
 			(prm.cnts_ids_len * sizeof(int)))) {
-		log_err("Cannot copy from user array of requested counter "
-			"ids\n");
+		log_err("Cannot copy from user array of requested counter ids\n");
 		kfree(cnt_ids);
 		return -EINVAL;
 	}
@@ -1707,8 +1687,7 @@ static long wrp_dpa_stats_do_ioctl(struct file *filp,
 
 		/* Copy parameters from user-space */
 		if (copy_from_user(&kparam, (void *)args, sizeof(kparam))) {
-			log_err("Cannot copy from user dpa_stats_init "
-				"arguments\n");
+			log_err("Cannot copy from user dpa_stats_init arguments\n");
 			return -EBUSY;
 		}
 
@@ -1790,8 +1769,7 @@ static long wrp_dpa_stats_do_compat_ioctl(struct file *filp,
 
 		/* Copy parameters from user space */
 		if (copy_from_user(&uparam, (void *)args, sizeof(uparam))) {
-			log_err("Cannot copy from user dpa_stats_init "
-				"arguments\n");
+			log_err("Cannot copy from user dpa_stats_init arguments\n");
 			return -EBUSY;
 		}
 		dpa_stats_init_compatcpy(&kparam, &uparam);
@@ -1871,8 +1849,7 @@ static long store_get_cnts_async_params(
 
 	mutex_lock(&wrp_dpa_stats.async_req_lock);
 	if (list_empty(&wrp_dpa_stats.async_req_pool)) {
-		log_err("Reached maximum supported number of simultaneous "
-			"asynchronous requests\n");
+		log_err("Reached maximum supported number of simultaneous asynchronous requests\n");
 		kfree(kprm->req_params.cnts_ids);
 		mutex_unlock(&wrp_dpa_stats.async_req_lock);
 		return -EDOM;
@@ -1921,15 +1898,13 @@ static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 		/* Allocate memory to store the key byte array */
 		tmp->byte = kmalloc(src->size, GFP_KERNEL);
 		if (!tmp->byte) {
-			log_err("Cannot allocate memory for key "
-				"descriptor byte\n");
+			log_err("Cannot allocate memory for key descriptor byte\n");
 			kfree(tmp);
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(tmp->byte, src->byte, src->size)) {
-			log_err("Cannot copy from user the key "
-				"descriptor byte\n");
+			log_err("Cannot copy from user the key descriptor byte\n");
 			kfree(tmp->byte);
 			kfree(tmp);
 			return -EBUSY;
@@ -1940,16 +1915,14 @@ static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 		/* Allocate memory to store the key mask array */
 		tmp->mask = kmalloc(src->size, GFP_KERNEL);
 		if (!tmp->mask) {
-			log_err("Cannot allocate memory for key "
-				"descriptor mask\n");
+			log_err("Cannot allocate memory for key descriptor mask\n");
 			kfree(tmp->byte);
 			kfree(tmp);
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(tmp->mask, src->mask, src->size)) {
-			log_err("Cannot copy from user the "
-				"key descriptor mask\n");
+			log_err("Cannot copy from user the key descriptor mask\n");
 			kfree(tmp->byte);
 			kfree(tmp->mask);
 			kfree(tmp);
@@ -1978,7 +1951,7 @@ static int copy_pair_descriptor(struct dpa_offload_lookup_key_pair *src,
 	if (src->first_key) {
 		ret = copy_key_descriptor(src->first_key, &tmp->first_key);
 		if (ret != 0) {
-			log_err("Could not copy the first key descriptor\n");
+			log_err("Cannot copy the first key descriptor\n");
 			kfree(tmp);
 			return ret;
 		}
@@ -1987,7 +1960,7 @@ static int copy_pair_descriptor(struct dpa_offload_lookup_key_pair *src,
 	if (src->second_key) {
 		ret = copy_key_descriptor(src->second_key, &tmp->second_key);
 		if (ret != 0) {
-			log_err("Could not copy the second key descriptor\n");
+			log_err("Cannot copy the second key descriptor\n");
 			if (tmp->first_key) {
 				kfree(tmp->first_key->byte);
 				kfree(tmp->first_key->mask);
@@ -2024,16 +1997,14 @@ static int copy_key_descriptor_compatcpy(
 		/* Allocate memory to store the key byte array */
 		kparam->byte = kmalloc(key.size, GFP_KERNEL);
 		if (!kparam->byte) {
-			log_err("Cannot allocate memory for key descriptor "
-				"byte\n");
+			log_err("Cannot allocate memory for key descriptor byte\n");
 			kfree(kparam);
 			return -ENOMEM;
 		}
 
 		if (copy_from_user(kparam->byte,
 				   compat_ptr(key.byte), key.size)) {
-			log_err("Cannot copy from user the key descriptor "
-				"byte\n");
+			log_err("Cannot copy from user the key descriptor byte\n");
 			kfree(kparam->byte);
 			kfree(kparam);
 			return -EBUSY;
@@ -2044,8 +2015,7 @@ static int copy_key_descriptor_compatcpy(
 		/* Allocate memory to store the key mask array */
 		kparam->mask = kmalloc(key.size, GFP_KERNEL);
 		if (!kparam->mask) {
-			log_err("Cannot allocate memory for key descriptor "
-				"mask\n");
+			log_err("Cannot allocate memory for key descriptor mask\n");
 			kfree(kparam->byte);
 			kfree(kparam);
 			return -ENOMEM;
@@ -2053,8 +2023,7 @@ static int copy_key_descriptor_compatcpy(
 
 		if (copy_from_user(kparam->mask,
 				   compat_ptr(key.mask), key.size)) {
-			log_err("Cannot copy from user the key descriptor "
-				"mask\n");
+			log_err("Cannot copy from user the key descriptor mask\n");
 			kfree(kparam->byte);
 			kfree(kparam->mask);
 			kfree(kparam);
@@ -2200,8 +2169,7 @@ static long dpa_stats_eth_cls_compatcpy(struct dpa_stats_cls_cnt_eth *kprm,
 	/* Allocate memory to store the sources array */
 	kprm->src = kzalloc(size, GFP_KERNEL);
 	if (!kprm->src) {
-		log_err("Cannot allocate kernel memory for Ethernet sources "
-			"array\n");
+		log_err("Cannot allocate kernel memory for Ethernet sources array\n");
 		return -ENOMEM;
 	}
 
@@ -2223,8 +2191,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 	/* Allocate memory to store the array of user-space reass objects */
 	reass = kzalloc(sizeof(compat_uptr_t) * cls_members, GFP_KERNEL);
 	if (!reass) {
-		log_err("Cannot allocate memory for Reassembly objects "
-			"array\n");
+		log_err("Cannot allocate memory for Reassembly objects array\n");
 		return -ENOMEM;
 	}
 
@@ -2238,8 +2205,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 	/* Allocate memory to store the array of kernel space reass objects */
 	kprm->reass = kzalloc((sizeof(void *) * cls_members), GFP_KERNEL);
 	if (!kprm->reass) {
-		log_err("Cannot allocate kernel memory for Reassembly objects "
-			"array\n");
+		log_err("Cannot allocate kernel memory for Reassembly objects array\n");
 		kfree(reass);
 		return -ENOMEM;
 	}
@@ -2263,15 +2229,13 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 	/* Allocate memory to store the array of user-space frag objects */
 	ufrag = kzalloc(sizeof(compat_uptr_t) * cls_members, GFP_KERNEL);
 	if (!ufrag) {
-		log_err("Cannot allocate memory for Fragmentation objects "
-			"array\n");
+		log_err("Cannot allocate memory for Fragmentation objects array\n");
 		return -ENOMEM;
 	}
 
 	if (copy_from_user(ufrag, compat_ptr(uprm->frag),
 			(sizeof(compat_uptr_t) * cls_members))) {
-		log_err("Cannot copy from user array of Fragmentation "
-			"objects\n");
+		log_err("Cannot copy from user array of Fragmentation objects\n");
 		kfree(ufrag);
 		return -EBUSY;
 	}
@@ -2279,8 +2243,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 	/* Allocate memory to store the array of kernel space frag objects */
 	kprm->frag = kzalloc((sizeof(void *) * cls_members), GFP_KERNEL);
 	if (!kprm->frag) {
-		log_err("Cannot allocate kernel memory for Fragmentation "
-			"objects array\n");
+		log_err("Cannot allocate kernel memory for Fragmentation objects array\n");
 		kfree(ufrag);
 		return -ENOMEM;
 	}
@@ -2318,8 +2281,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 	/* Allocate memory to store the array of kernel space policer objects */
 	kprm->plcr = kzalloc((sizeof(void *) * cls_members), GFP_KERNEL);
 	if (!kprm->plcr) {
-		log_err("Cannot allocate kernel memory for Policer objects "
-			"array\n");
+		log_err("Cannot allocate kernel memory for Policer objects array\n");
 		kfree(uplcr);
 		return -ENOMEM;
 	}
@@ -2357,8 +2319,7 @@ static long dpa_stats_tbl_cls_compatcpy(
 	if (kprm->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
 		if (copy_from_user(us_keys, compat_ptr(uprm->keys),
 				  (sizeof(compat_uptr_t) * cls_members))) {
-			log_err("Cannot copy from user-space array of keys "
-				"descriptors\n");
+			log_err("Cannot copy from user-space array of keys descriptors\n");
 			kfree(us_keys);
 			return -EBUSY;
 		}
@@ -2367,8 +2328,7 @@ static long dpa_stats_tbl_cls_compatcpy(
 		kprm->keys = kzalloc((sizeof(*kprm->keys) * cls_members),
 				     GFP_KERNEL);
 		if (!kprm->keys) {
-			log_err("Cannot allocate kernel memory for lookup keys "
-				"array\n");
+			log_err("Cannot allocate kernel memory for lookup keys array\n");
 			kfree(us_keys);
 			return -ENOMEM;
 		}
@@ -2390,8 +2350,7 @@ static long dpa_stats_tbl_cls_compatcpy(
 	if (kprm->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
 		if (copy_from_user(us_keys, compat_ptr(uprm->pairs),
 				  (sizeof(compat_uptr_t) * cls_members))) {
-			log_err("Cannot copy from user-space array of pairs "
-				"descriptors\n");
+			log_err("Cannot copy from user-space array of pair descriptors\n");
 			kfree(us_keys);
 			return -EBUSY;
 		}
@@ -2400,8 +2359,7 @@ static long dpa_stats_tbl_cls_compatcpy(
 		kprm->pairs = kzalloc((sizeof(*kprm->pairs) * cls_members),
 				      GFP_KERNEL);
 		if (!kprm->pairs) {
-			log_err("Cannot allocate kernel memory for lookup pairs"
-				"array\n");
+			log_err("Cannot allocate kernel memory for lookup pairs array\n");
 			kfree(us_keys);
 			return -ENOMEM;
 		}
@@ -2414,8 +2372,7 @@ static long dpa_stats_tbl_cls_compatcpy(
 			kprm->pairs[i] = kzalloc(sizeof(*kprm->pairs[i]),
 						GFP_KERNEL);
 			if (!kprm->pairs[i]) {
-				log_err("Cannot allocate kernel memory for pair"
-					" descriptor\n");
+				log_err("Cannot allocate kernel memory for pair descriptor\n");
 				kfree(us_keys);
 				return -ENOMEM;
 			}
@@ -2477,8 +2434,7 @@ static long dpa_stats_ccnode_cls_compatcpy(
 
 	if (copy_from_user(us_keys, compat_ptr(uprm->keys),
 			  (sizeof(compat_uptr_t) * cls_members))) {
-		log_err("Cannot copy from user-space array of keys "
-			"descriptors\n");
+		log_err("Cannot copy from user-space array of keys descriptors\n");
 		kfree(us_keys);
 		return -EBUSY;
 	}
@@ -2486,8 +2442,7 @@ static long dpa_stats_ccnode_cls_compatcpy(
 	/* Allocate memory to store array of kernel-space keys descriptors */
 	kprm->keys = kzalloc((sizeof(*kprm->keys) * cls_members), GFP_KERNEL);
 	if (!kprm->keys) {
-		log_err("Cannot allocate kernel memory for lookup keys "
-			"array\n");
+		log_err("Cannot allocate kernel memory for lookup keys array\n");
 		kfree(us_keys);
 		return -ENOMEM;
 	}
-- 
1.7.5.4

