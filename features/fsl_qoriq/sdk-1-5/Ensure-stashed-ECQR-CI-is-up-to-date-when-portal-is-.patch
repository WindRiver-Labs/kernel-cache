From 40f8d0ddbd117ca2a90a6f9d1d627bc049d031f0 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Wed, 9 Oct 2013 10:27:26 -0400
Subject: [PATCH 228/383] Ensure stashed ECQR CI is up to date when portal is
 destroyed

QMan EQCR stashing can be configured to only stash after X
enqueue entries are consumed. When a portal is destroyed the
code must ensure that the cacheable version of the CI is up to
date.  This is acheived by setting the stash threshold to one
and rereading the cacheline.

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: I7ed456d72c1abd31c90df84b436913e8d6f02c12
Reviewed-on: http://git.am.freescale.net:8181/5634
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thorpe Geoff-R01361 <Geoff.Thorpe@freescale.com>
Reviewed-by: Haiying Wang <Haiying.Wang@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/qman_low.h |   19 +++++++++++++++++--
 1 files changed, 17 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index ea2dccc..4e264a6 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -294,8 +294,23 @@ static inline unsigned int qm_eqcr_get_ci_stashing(struct qm_portal *portal)
 static inline void qm_eqcr_finish(struct qm_portal *portal)
 {
 	register struct qm_eqcr *eqcr = &portal->eqcr;
-	u8 pi = qm_in(EQCR_PI_CINH) & (QM_EQCR_SIZE - 1);
-	u8 ci = qm_in(EQCR_CI_CINH) & (QM_EQCR_SIZE - 1);
+	u8 pi, ci;
+	u32 cfg;
+
+	/* Disable EQCI stashing because the QMan only
+	   presents the value it previously stashed to
+	   maintain coherency.  Setting the stash threshold
+	   to 0 ensures we read the real value */
+	cfg = (qm_in(CFG) & 0x00ffffff) |
+		(0 << 28); /* QCSP_CFG: EST */
+	qm_out(CFG, cfg);
+
+	pi = qm_in(EQCR_PI_CINH) & (QM_EQCR_SIZE - 1);
+	ci = qm_in(EQCR_CI_CINH) & (QM_EQCR_SIZE - 1);
+
+	/* Refresh EQCR CI cache value */
+	qm_cl_invalidate(EQCR_CI);
+	eqcr->ci = qm_cl_in(EQCR_CI) & (QM_EQCR_SIZE - 1);
 
 	DPA_ASSERT(!eqcr->busy);
 	if (pi != EQCR_PTR2IDX(eqcr->cursor))
-- 
1.7.5.4

