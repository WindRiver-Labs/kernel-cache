From a5528e75cd4e61ebc4fa5f5b7c1251619df3429e Mon Sep 17 00:00:00 2001
From: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Date: Wed, 9 Oct 2013 18:29:36 +0300
Subject: [PATCH 214/383] dpa_offload: Fix memory leaks for class counters
 copying

Fix memory leaks that occur in case copying an array of
class members fails. The user-provided array of pointers
need to be copied from user-space pointers to kernel-space
allocated memory.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Change-Id: I219e7e1bdded44f55baa6ed0a80c71f5046916ed
Reviewed-on: http://git.am.freescale.net:8181/5466
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |    9 +++++++++
 1 files changed, 9 insertions(+), 0 deletions(-)
 mode change 100644 => 100755 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
old mode 100644
new mode 100755
index 576846c..1aede24
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -2253,6 +2253,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 	if (copy_from_user(reass, compat_ptr(uprm->reass),
 			(sizeof(compat_uptr_t) * cls_members))) {
 		log_err("Cannot copy from user array of Reassembly objects\n");
+		kfree(reass);
 		return -EBUSY;
 	}
 
@@ -2261,6 +2262,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 	if (!kprm->reass) {
 		log_err("Cannot allocate kernel memory for Reassembly objects "
 			"array\n");
+		kfree(reass);
 		return -ENOMEM;
 	}
 
@@ -2269,6 +2271,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 				reass[i], FM_MAP_TYPE_PCD_NODE);
 
 	kprm->cnt_sel = uprm->cnt_sel;
+	kfree(reass);
 	return 0;
 }
 
@@ -2291,6 +2294,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 			(sizeof(compat_uptr_t) * cls_members))) {
 		log_err("Cannot copy from user array of Fragmentation "
 			"objects\n");
+		kfree(ufrag);
 		return -EBUSY;
 	}
 
@@ -2299,6 +2303,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 	if (!kprm->frag) {
 		log_err("Cannot allocate kernel memory for Fragmentation "
 			"objects array\n");
+		kfree(ufrag);
 		return -ENOMEM;
 	}
 
@@ -2307,6 +2312,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 				ufrag[i], FM_MAP_TYPE_PCD_NODE);
 
 	kprm->cnt_sel = uprm->cnt_sel;
+	kfree(ufrag);
 	return 0;
 }
 
@@ -2327,6 +2333,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 	if (copy_from_user(uplcr, compat_ptr(uprm->plcr),
 			(sizeof(compat_uptr_t) * cls_members))) {
 		log_err("Cannot copy from user array of Policer objects\n");
+		kfree(uplcr);
 		return -EBUSY;
 	}
 
@@ -2335,6 +2342,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 	if (!kprm->plcr) {
 		log_err("Cannot allocate kernel memory for Policer objects "
 			"array\n");
+		kfree(uplcr);
 		return -ENOMEM;
 	}
 
@@ -2343,6 +2351,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 				uplcr[i], FM_MAP_TYPE_PCD_NODE);
 
 	kprm->cnt_sel = uprm->cnt_sel;
+	kfree(uplcr);
 	return 0;
 }
 
-- 
1.7.5.4

