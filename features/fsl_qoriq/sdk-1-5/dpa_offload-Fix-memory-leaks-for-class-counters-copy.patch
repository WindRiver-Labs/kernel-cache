From 8c01786db9cdae994df3cbdcdbdb1841e49d70e6 Mon Sep 17 00:00:00 2001
From: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Date: Wed, 9 Oct 2013 18:29:36 +0300
Subject: [PATCH 253/429] dpa_offload: Fix memory leaks for class counters
 copying

Fix memory leaks that occur in case copying an array of
class members fails. The user-provided array of pointers
need to be copied from user-space pointers to kernel-space
allocated memory.

Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Change-Id: I219e7e1bdded44f55baa6ed0a80c71f5046916ed
Reviewed-on: http://git.am.freescale.net:8181/5466
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |    9 +++++++++
 1 files changed, 9 insertions(+), 0 deletions(-)
 mode change 100644 => 100755 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
old mode 100644
new mode 100755
index 5af06d1..cd90c08
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -2250,6 +2250,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 	if (copy_from_user(reass, compat_ptr(uprm->reass),
 			(sizeof(compat_uptr_t) * cls_members))) {
 		log_err("Cannot copy from user array of Reassembly objects\n");
+		kfree(reass);
 		return -EBUSY;
 	}
 
@@ -2258,6 +2259,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 	if (!kprm->reass) {
 		log_err("Cannot allocate kernel memory for Reassembly objects "
 			"array\n");
+		kfree(reass);
 		return -ENOMEM;
 	}
 
@@ -2266,6 +2268,7 @@ static long dpa_stats_reass_cls_compatcpy(struct dpa_stats_cls_cnt_reass *kprm,
 				reass[i], FM_MAP_TYPE_PCD_NODE);
 
 	kprm->cnt_sel = uprm->cnt_sel;
+	kfree(reass);
 	return 0;
 }
 
@@ -2288,6 +2291,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 			(sizeof(compat_uptr_t) * cls_members))) {
 		log_err("Cannot copy from user array of Fragmentation "
 			"objects\n");
+		kfree(ufrag);
 		return -EBUSY;
 	}
 
@@ -2296,6 +2300,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 	if (!kprm->frag) {
 		log_err("Cannot allocate kernel memory for Fragmentation "
 			"objects array\n");
+		kfree(ufrag);
 		return -ENOMEM;
 	}
 
@@ -2304,6 +2309,7 @@ static long dpa_stats_frag_cls_compatcpy(struct dpa_stats_cls_cnt_frag *kprm,
 				ufrag[i], FM_MAP_TYPE_PCD_NODE);
 
 	kprm->cnt_sel = uprm->cnt_sel;
+	kfree(ufrag);
 	return 0;
 }
 
@@ -2324,6 +2330,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 	if (copy_from_user(uplcr, compat_ptr(uprm->plcr),
 			(sizeof(compat_uptr_t) * cls_members))) {
 		log_err("Cannot copy from user array of Policer objects\n");
+		kfree(uplcr);
 		return -EBUSY;
 	}
 
@@ -2332,6 +2339,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 	if (!kprm->plcr) {
 		log_err("Cannot allocate kernel memory for Policer objects "
 			"array\n");
+		kfree(uplcr);
 		return -ENOMEM;
 	}
 
@@ -2340,6 +2348,7 @@ static long dpa_stats_plcr_cls_compatcpy(struct dpa_stats_cls_cnt_plcr *kprm,
 				uplcr[i], FM_MAP_TYPE_PCD_NODE);
 
 	kprm->cnt_sel = uprm->cnt_sel;
+	kfree(uplcr);
 	return 0;
 }
 
-- 
1.7.5.4

