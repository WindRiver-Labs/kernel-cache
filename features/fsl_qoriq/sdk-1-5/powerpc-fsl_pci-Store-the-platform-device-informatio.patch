From b5fc337afb6ebca60864fe35519c3e0cbcb7ecb5 Mon Sep 17 00:00:00 2001
From: Varun Sethi <Varun.Sethi@freescale.com>
Date: Mon, 18 Feb 2013 16:34:54 +0530
Subject: [PATCH 419/429] powerpc/fsl_pci: Store the platform device
 information corresponding to the pci controller.

commit 52c5affc545053d37c0b05224bbf70f5336caa20 upstream

The pci controller structure has a provision to store the device strcuture
pointer of the corresponding platform device. Currently this information is
not stored during fsl pci controller initialization. This information is
required while dealing with iommu groups for pci devices connected to the fsl
pci controller. For the case where the pci devices can't be paritioned, they
would fall under the same device group as the pci controller.

This patch stores the platform device information in the pci controller
structure during initialization.

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 arch/powerpc/sysdev/fsl_pci.c |    9 +++++++--
 arch/powerpc/sysdev/fsl_pci.h |    2 +-
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/arch/powerpc/sysdev/fsl_pci.c b/arch/powerpc/sysdev/fsl_pci.c
index 938f08b..f0cdc81 100644
--- a/arch/powerpc/sysdev/fsl_pci.c
+++ b/arch/powerpc/sysdev/fsl_pci.c
@@ -505,17 +505,20 @@ void fsl_pcibios_fixup_bus(struct pci_bus *bus)
 	}
 }
 
-int __init fsl_add_bridge(struct device_node *dev, int is_primary)
+int __init fsl_add_bridge(struct platform_device *pdev, int is_primary)
 {
 	int len;
 	struct pci_controller *hose;
 	struct resource rsrc;
 	const int *bus_range;
 	u8 hdr_type, progif;
+	struct device_node *dev;
 	struct ccsr_pci __iomem *pci;
 	u16 temp;
 	u32 svr = mfspr(SPRN_SVR);
 
+	dev = pdev->dev.of_node;
+
 	if (!of_device_is_available(dev)) {
 		pr_warning("%s: disabled\n", dev->full_name);
 		return -ENODEV;
@@ -540,6 +543,8 @@ int __init fsl_add_bridge(struct device_node *dev, int is_primary)
 	if (!hose)
 		return -ENOMEM;
 
+	/* set platform device as the parent */
+	hose->parent = &pdev->dev;
 	hose->first_busno = bus_range ? bus_range[0] : 0x0;
 	hose->last_busno = bus_range ? bus_range[1] : 0xff;
 
@@ -1209,7 +1214,7 @@ static int __devinit fsl_pci_probe(struct platform_device *pdev)
 #endif
 
 	node = pdev->dev.of_node;
-	ret = fsl_add_bridge(node, fsl_pci_primary == node);
+	ret = fsl_add_bridge(pdev, fsl_pci_primary == node);
 #ifdef CONFIG_SWIOTLB
 	if (ret == 0) {
 		hose = pci_find_hose_for_OF_device(pdev->dev.of_node);
diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 50932fd..df061c0 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -141,7 +141,7 @@ struct ccsr_pci {
 
 };
 
-extern int fsl_add_bridge(struct device_node *dev, int is_primary);
+extern int fsl_add_bridge(struct platform_device *pdev, int is_primary);
 extern void fsl_pcibios_fixup_bus(struct pci_bus *bus);
 extern int mpc83xx_add_bridge(struct device_node *dev);
 u64 fsl_pci_immrbar_base(struct pci_controller *hose);
-- 
1.7.5.4

