From 01e0423617dc2be5e3e8b3b5d92a96b5073e6fb1 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Wed, 4 Dec 2013 19:34:35 +0200
Subject: [PATCH 361/383] dpaa_eth: Put Rx FQs in a new CGR

To avoid situations where we feed a high-speed ingress port with buffers
allocated from lowmem only to have those frames piling up in the ingress
queues and eventually depleting our memory, add a per-port CGR where
every ingress FQ is placed. This CGR won't deliver congestion
notifications to the FMan port, but instead will act as an aggregated
counter for all the Rx FQs of the net device, tail-dropping excess
traffic instead of enqueueing it in indefinitely long FQs.

To avoid artificially dropping ingress frames, set the CGR's threshold
to a very high value, which we'll fine-tune over test sessions.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Change-Id: I2637a98bb1ec0e601d6803cbfbbe2087f88cf6cf
Reviewed-on: http://git.am.freescale.net:8181/7092
Reviewed-by: Cristian Bercaru <cristian.bercaru@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Reviewed-by: Ruxandra Ioana Radulescu <ruxandra.radulescu@freescale.com>
Tested-by: Richard Schmitt <B43082@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |   50 ++++++++++++++++++++
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      |    2 +
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   |   16 ++++++
 3 files changed, 68 insertions(+), 0 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 63e7b04..f95de42 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -674,6 +674,51 @@ dpa_priv_bp_probe(struct device *dev)
 	return dpa_bp;
 }
 
+/* Place all ingress FQs (Rx Default, Rx Error, PCD FQs) in a dedicated CGR.
+ * We won't be sending congestion notifications to FMan; for now, we just use
+ * this CGR to generate enqueue rejections to FMan in order to drop the frames
+ * before they reach our ingress queues and eat up memory.
+ */
+#define DPA_INGRESS_CS_THRESHOLD	0x10000000
+static int dpaa_eth_priv_ingress_cgr_init(struct dpa_priv_s *priv)
+{
+	struct qm_mcc_initcgr initcgr;
+	u32 cs_th;
+	int err;
+
+	err = qman_alloc_cgrid(&priv->ingress_cgr.cgrid);
+	if (err < 0) {
+		pr_err("Error %d allocating CGR ID\n", err);
+		goto out_error;
+	}
+
+	/* Enable CS TD, but disable Congestion State Change Notifications. */
+	initcgr.we_mask = QM_CGR_WE_CS_THRES;
+	initcgr.cgr.cscn_en = QM_CGR_EN;
+	cs_th = DPA_INGRESS_CS_THRESHOLD;
+	qm_cgr_cs_thres_set64(&initcgr.cgr.cs_thres, cs_th, 1);
+
+	initcgr.we_mask |= QM_CGR_WE_CSTD_EN;
+	initcgr.cgr.cstd_en = QM_CGR_EN;
+
+	/* This is actually a hack, because this CGR will be associated with
+	 * our affine SWP. However, we'll place our ingress FQs in it.
+	 */
+	err = qman_create_cgr(&priv->ingress_cgr, QMAN_CGR_FLAG_USE_INIT,
+		&initcgr);
+	if (err < 0) {
+		pr_err("Error %d creating ingress CGR with ID %d\n", err,
+			priv->ingress_cgr.cgrid);
+		qman_release_cgrid(priv->ingress_cgr.cgrid);
+		goto out_error;
+	}
+	pr_debug("Created ingress CGR %d for netdev with hwaddr %pM\n",
+		 priv->ingress_cgr.cgrid, priv->mac_dev->addr);
+
+out_error:
+	return err;
+}
+
 static int dpa_priv_bp_create(struct net_device *net_dev, struct dpa_bp *dpa_bp,
 		size_t count)
 {
@@ -829,6 +874,11 @@ dpaa_eth_priv_probe(struct platform_device *_of_dev)
 		dev_err(dev, "Error initializing CGR\n");
 		goto cgr_init_failed;
 	}
+	err = dpaa_eth_priv_ingress_cgr_init(priv);
+	if (err < 0) {
+		dev_err(dev, "Error initializing ingress CGR\n");
+		goto cgr_init_failed;
+	}
 
 	/* Add the FQs to the interface, and make them active */
 	list_for_each_entry_safe(dpa_fq, tmp, &priv->dpa_fq_list, list) {
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 64cee7f..80e0d20 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -395,6 +395,8 @@ struct dpa_priv_s {
 		 */
 		u32 cgr_congested_count;
 	} cgr_data;
+	/* Use a per-port CGR for ingress traffic. */
+	struct qman_cgr ingress_cgr;
 
 #ifdef CONFIG_FSL_DPAA_TS
 	bool ts_tx_en; /* Tx timestamping enabled */
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index 86514b4..1353c27 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -1298,6 +1298,22 @@ int dpa_fq_init(struct dpa_fq *dpa_fq, bool td_enable)
 		}
 #endif
 
+		/* Put all ingress queues in our "ingress CGR". */
+		if (dpa_fq->fq_type == FQ_TYPE_RX_DEFAULT ||
+				dpa_fq->fq_type == FQ_TYPE_RX_ERROR ||
+				dpa_fq->fq_type == FQ_TYPE_RX_PCD) {
+			initfq.we_mask |= QM_INITFQ_WE_CGID;
+			initfq.fqd.fq_ctrl |= QM_FQCTRL_CGE;
+			initfq.fqd.cgid = priv->ingress_cgr.cgrid;
+			/* Set a fixed overhead accounting, just like for the
+			 * egress CGR.
+			 */
+			initfq.we_mask |= QM_INITFQ_WE_OAC;
+			initfq.fqd.oac_init.oac = QM_OAC_CG;
+			initfq.fqd.oac_init.oal = min(sizeof(struct sk_buff) +
+				priv->tx_headroom, (size_t)FSL_QMAN_MAX_OAL);
+		}
+
 		/* Initialization common to all ingress queues */
 		if (dpa_fq->flags & QMAN_FQ_FLAG_NO_ENQUEUE) {
 			initfq.we_mask |= QM_INITFQ_WE_CONTEXTA;
-- 
1.7.5.4

