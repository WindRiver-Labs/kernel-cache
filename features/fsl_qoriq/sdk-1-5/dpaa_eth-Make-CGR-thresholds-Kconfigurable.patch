From ee27dfc44ed26dcf6f453b11aa1fbb014dbd982f Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Wed, 4 Dec 2013 23:45:08 +0200
Subject: [PATCH 408/429] dpaa_eth: Make CGR thresholds Kconfigurable

Move congestion thresholds (previously hard-coded) into the driver's
Kconfig. While at it, group the driver's configuration options under
a menuconfig entry.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Change-Id: Idf0aec9489871f5c976ce9956a3d93580fb29649
Reviewed-on: http://git.am.freescale.net:8181/7094
Reviewed-by: Cristian Bercaru <cristian.bercaru@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
Reviewed-by: Madalin-Cristian Bucur <madalin.bucur@freescale.com>
Reviewed-by: Ruxandra Ioana Radulescu <ruxandra.radulescu@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/Kconfig         |   37 +++++++++++++++++++-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |    2 +-
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   |   23 +-----------
 3 files changed, 39 insertions(+), 23 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/Kconfig b/drivers/net/ethernet/freescale/dpa/Kconfig
index 218eca2..d8b4cda 100644
--- a/drivers/net/ethernet/freescale/dpa/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/Kconfig
@@ -1,4 +1,4 @@
-config FSL_DPAA_ETH
+menuconfig FSL_DPAA_ETH
 	bool "DPAA Ethernet"
 	depends on FSL_SOC && FSL_BMAN && FSL_QMAN && FSL_FMAN
 	select PHYLIB
@@ -111,6 +111,41 @@ config FSL_DPAA_ETH_REFILL_THRESHOLD
 	  falls below this threshold. This must be related to DPAA_ETH_MAX_BUF_COUNT. One needn't normally
 	  modify this value unless one has very specific performance reasons.
 
+config FSL_DPAA_CS_THRESHOLD_1G
+	hex "Egress congestion threshold on 1G ports"
+	depends on FSL_DPAA_ETH
+	range 0x1000 0x10000000
+	default "0x06000000"
+	---help---
+	  The size in bytes of the egress Congestion State notification threshold on 1G ports.
+	  The 1G dTSECs can quite easily be flooded by cores doing Tx in a tight loop
+	  (e.g. by sending UDP datagrams at "while(1) speed"),
+	  and the larger the frame size, the more acute the problem.
+	  So we have to find a balance between these factors:
+	       - avoiding the device staying congested for a prolonged time (risking
+                 the netdev watchdog to fire - see also the tx_timeout module param);
+               - affecting performance of protocols such as TCP, which otherwise
+	         behave well under the congestion notification mechanism;
+	       - preventing the Tx cores from tightly-looping (as if the congestion
+	         threshold was too low to be effective);
+	       - running out of memory if the CS threshold is set too high.
+
+config FSL_DPAA_CS_THRESHOLD_10G
+	hex "Egress congestion threshold on 10G ports"
+	depends on FSL_DPAA_ETH
+	range 0x1000 0x20000000
+	default "0x10000000"
+	---help ---
+	  The size in bytes of the egress Congestion State notification threshold on 10G ports.
+
+config FSL_DPAA_INGRESS_CS_THRESHOLD
+	hex "Ingress congestion threshold on FMan ports"
+	depends on FSL_DPAA_ETH
+	default "0x10000000"
+	---help---
+	  The size in bytes of the ingress tail-drop threshold on FMan ports.
+	  Traffic piling up above this value will be rejected by QMan and discarded by FMan.
+
 config FSL_DPAA_ETH_DEBUGFS
 	tristate "DPAA Ethernet debugfs interface"
 	depends on DEBUG_FS && FSL_DPAA_ETH
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index ba0ce1a..8dc2b0f 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -709,7 +709,7 @@ static int dpaa_eth_priv_ingress_cgr_init(struct dpa_priv_s *priv)
 	/* Enable CS TD, but disable Congestion State Change Notifications. */
 	initcgr.we_mask = QM_CGR_WE_CS_THRES;
 	initcgr.cgr.cscn_en = QM_CGR_EN;
-	cs_th = DPA_INGRESS_CS_THRESHOLD;
+	cs_th = CONFIG_FSL_DPAA_INGRESS_CS_THRESHOLD;
 	qm_cgr_cs_thres_set64(&initcgr.cgr.cs_thres, cs_th, 1);
 
 	initcgr.we_mask |= QM_CGR_WE_CSTD_EN;
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index 7b5213e..76a4c22 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -987,25 +987,6 @@ static void dpaa_eth_cgscn(struct qman_portal *qm, struct qman_cgr *cgr,
 	}
 }
 
-/* Size in bytes of the Congestion State notification threshold on 10G ports */
-#define DPA_CS_THRESHOLD_10G	0x10000000
-/* Size in bytes of the Congestion State notification threshold on 1G ports.
-
- * The 1G dTSECs can quite easily be flooded by cores doing Tx in a tight loop
- * (e.g. by sending UDP datagrams at "while(1) speed"),
- * and the larger the frame size, the more acute the problem.
- *
- * So we have to find a balance between these factors:
- *	- avoiding the device staying congested for a prolonged time (risking
- *	  the netdev watchdog to fire - see also the tx_timeout module param);
- *	- affecting performance of protocols such as TCP, which otherwise
- *	  behave well under the congestion notification mechanism;
- *	- preventing the Tx cores from tightly-looping (as if the congestion
- *	  threshold was too low to be effective);
- *	- running out of memory if the CS threshold is set too high.
- */
-#define DPA_CS_THRESHOLD_1G	0x06000000
-
 int dpaa_eth_cgr_init(struct dpa_priv_s *priv)
 {
 	struct qm_mcc_initcgr initcgr;
@@ -1029,9 +1010,9 @@ int dpaa_eth_cgr_init(struct dpa_priv_s *priv)
 	 * In such cases, we ought to reconfigure the threshold, too.
 	 */
 	if (priv->mac_dev->if_support & SUPPORTED_10000baseT_Full)
-		cs_th = DPA_CS_THRESHOLD_10G;
+		cs_th = CONFIG_FSL_DPAA_CS_THRESHOLD_10G;
 	else
-		cs_th = DPA_CS_THRESHOLD_1G;
+		cs_th = CONFIG_FSL_DPAA_CS_THRESHOLD_1G;
 	qm_cgr_cs_thres_set64(&initcgr.cgr.cs_thres, cs_th, 1);
 
 	initcgr.we_mask |= QM_CGR_WE_CSTD_EN;
-- 
1.7.5.4

