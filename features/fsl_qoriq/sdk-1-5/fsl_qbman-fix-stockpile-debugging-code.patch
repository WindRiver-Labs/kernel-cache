From 75d1c68e5a83846ff4e9bd41c5f11cc380c2548d Mon Sep 17 00:00:00 2001
From: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Date: Tue, 18 Jun 2013 16:16:25 -0400
Subject: [PATCH 017/429] fsl_qbman: fix stockpile-debugging code

The check for concurrent access to unlocked stockpile state needs to
avoid running checks when stockpiling is not enabled.

Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Change-Id: Id266c29e7b4432e796c41a1dc899fbee1718336c
Reviewed-on: http://git.am.freescale.net:8181/3000
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Ladouceur Jeffrey-R11498 <Jeffrey.Ladouceur@freescale.com>
Reviewed-by: Wang Haiying-R54964 <Haiying.Wang@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/staging/fsl_qbman/bman_high.c |   20 ++++++++++----------
 1 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index 8487f98..c87eabd 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -844,16 +844,16 @@ int bman_release(struct bman_pool *pool, const struct bm_buffer *bufs, u8 num,
 		return -EINVAL;
 	if (pool->params.flags & BMAN_POOL_FLAG_NO_RELEASE)
 		return -EINVAL;
+#endif
+	/* Without stockpile, this API is a pass-through to the h/w operation */
+	if (!(pool->params.flags & BMAN_POOL_FLAG_STOCKPILE))
+		return __bman_release(pool, bufs, num, flags);
+#ifdef CONFIG_FSL_DPA_CHECKING
 	if (!atomic_dec_and_test(&pool->in_use)) {
 		pr_crit("Parallel attempts to enter bman_released() detected.");
 		panic("only one instance of bman_released/acquired allowed");
 	}
 #endif
-	/* Without stockpile, this API is a pass-through to the h/w operation */
-	if (!(pool->params.flags & BMAN_POOL_FLAG_STOCKPILE)) {
-		ret = __bman_release(pool, bufs, num, flags);
-		goto release_done;
-	}
 	/* This needs some explanation. Adding the given buffers may take the
 	 * stockpile over the threshold, but in fact the stockpile may already
 	 * *be* over the threshold if a previous release-to-hw attempt had
@@ -930,16 +930,16 @@ int bman_acquire(struct bman_pool *pool, struct bm_buffer *bufs, u8 num,
 		return -EINVAL;
 	if (pool->params.flags & BMAN_POOL_FLAG_ONLY_RELEASE)
 		return -EINVAL;
+#endif
+	/* Without stockpile, this API is a pass-through to the h/w operation */
+	if (!(pool->params.flags & BMAN_POOL_FLAG_STOCKPILE))
+		return __bman_acquire(pool, bufs, num);
+#ifdef CONFIG_FSL_DPA_CHECKING
 	if (!atomic_dec_and_test(&pool->in_use)) {
 		pr_crit("Parallel attempts to enter bman_acquire() detected.");
 		panic("only one instance of bman_released/acquired allowed");
 	}
 #endif
-	/* Without stockpile, this API is a pass-through to the h/w operation */
-	if (!(pool->params.flags & BMAN_POOL_FLAG_STOCKPILE)) {
-		ret = __bman_acquire(pool, bufs, num);
-		goto acquire_done;
-	}
 	/* Only need a h/w op if we'll hit the low-water thresh */
 	if (!(flags & BMAN_ACQUIRE_FLAG_STOCKPILE) &&
 			(pool->sp_fill <= (BMAN_STOCKPILE_LOW + num))) {
-- 
1.7.5.4

