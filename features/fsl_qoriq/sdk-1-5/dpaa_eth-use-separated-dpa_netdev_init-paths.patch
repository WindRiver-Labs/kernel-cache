From 4dc520f3ae88d70cfe6700d88d64f60ddfce44be Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Wed, 5 Jun 2013 20:17:15 +0300
Subject: [PATCH 043/429] dpaa_eth: use separated dpa_netdev_init paths

Use separated dpa_netdev_init code for MACless, shared and
private interfaces.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Change-Id: I74ef5f511a6b6ac8d76b5e9141629a284a53e31b
Reviewed-on: http://git.am.freescale.net:8181/3079
Reviewed-by: Sovaiala Cristian-Constantin-B39531 <Cristian.Sovaiala@freescale.com>
Reviewed-by: Radulescu Ruxandra Ioana-B05472 <ruxandra.radulescu@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |  191 ++++++++++++++++++-------
 1 files changed, 138 insertions(+), 53 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 1641a07..3735073 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -1051,9 +1051,6 @@ static int dpa_set_mac_address(struct net_device *net_dev, void *addr)
 		return _errno;
 	}
 
-	if (!priv->mac_dev)
-		/* MAC-less interface, so nothing more to do here */
-		return 0;
 	mac_dev = priv->mac_dev;
 
 	_errno = mac_dev->change_addr(mac_dev->get_mac_handle(mac_dev),
@@ -1069,6 +1066,25 @@ static int dpa_set_mac_address(struct net_device *net_dev, void *addr)
 	return 0;
 }
 
+static int dpa_set_macless_address(struct net_device *net_dev, void *addr)
+{
+	const struct dpa_priv_s	*priv;
+	int			 _errno;
+
+	priv = netdev_priv(net_dev);
+
+	_errno = eth_mac_addr(net_dev, addr);
+	if (_errno < 0) {
+		if (netif_msg_drv(priv))
+			netdev_err(net_dev,
+				       "eth_mac_addr() = %d\n",
+				       _errno);
+		return _errno;
+	}
+
+	return 0;
+}
+
 static void dpa_set_rx_mode(struct net_device *net_dev)
 {
 	int			 _errno;
@@ -1095,6 +1111,9 @@ static void dpa_set_rx_mode(struct net_device *net_dev)
 		netdev_err(net_dev, "mac_dev->set_multi() = %d\n", _errno);
 }
 
+static void dpa_set_macless_rx_mode(struct net_device *net_dev)
+{
+}
 #if defined(CONFIG_FSL_DPAA_1588) || defined(CONFIG_FSL_DPAA_TS)
 u64 dpa_get_timestamp_ns(const struct dpa_priv_s *priv, enum port_type rx_tx,
 			const void *data)
@@ -1259,6 +1278,10 @@ static int dpa_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	return ret;
 }
 
+static int dpa_macless_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
+{
+	return -EINVAL;
+}
 #ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 /*
  * When we put the buffer into the pool, we purposefully added
@@ -2925,9 +2948,6 @@ static int __cold dpa_start(struct net_device *net_dev)
 	priv = netdev_priv(net_dev);
 	mac_dev = priv->mac_dev;
 
-	if (!mac_dev)
-		goto no_mac;
-
 	/* Seed the global buffer pool at the first ifconfig up
 	 * of a private port. Update the percpu buffer counters
 	 * of each private interface.
@@ -2965,7 +2985,6 @@ static int __cold dpa_start(struct net_device *net_dev)
 		goto mac_start_failed;
 	}
 
-no_mac:
 	netif_tx_start_all_queues(net_dev);
 
 	return 0;
@@ -2980,6 +2999,13 @@ init_phy_failed:
 	return err;
 }
 
+static int __cold dpa_macless_start(struct net_device *net_dev)
+{
+	netif_tx_start_all_queues(net_dev);
+
+	return 0;
+}
+
 static int __cold dpa_stop(struct net_device *net_dev)
 {
 	int _errno, i;
@@ -2991,9 +3017,6 @@ static int __cold dpa_stop(struct net_device *net_dev)
 
 	netif_tx_stop_all_queues(net_dev);
 
-	if (!mac_dev)
-		return 0;
-
 	_errno = mac_dev->stop(mac_dev);
 	if (unlikely(_errno < 0))
 		if (netif_msg_ifdown(priv))
@@ -3012,6 +3035,13 @@ static int __cold dpa_stop(struct net_device *net_dev)
 	return _errno;
 }
 
+static int __cold dpa_macless_stop(struct net_device *net_dev)
+{
+	netif_tx_stop_all_queues(net_dev);
+
+	return 0;
+}
+
 static void __cold dpa_timeout(struct net_device *net_dev)
 {
 	const struct dpa_priv_s	*priv;
@@ -3291,15 +3321,30 @@ static u16 dpa_select_queue(struct net_device *net_dev, struct sk_buff *skb)
 static netdev_features_t dpa_fix_features(struct net_device *dev,
 					  netdev_features_t features)
 {
-	struct dpa_priv_s *priv = netdev_priv(dev);
 	netdev_features_t unsupported_features = 0;
 
 	/* In theory we should never be requested to enable features that
 	 * we didn't set in netdev->features and netdev->hw_features at probe
 	 * time, but double check just to be on the safe side.
+	 * We don't support enabling Rx csum through ethtool yet
 	 */
-	if (!priv->mac_dev)
-		unsupported_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+	unsupported_features |= NETIF_F_RXCSUM;
+
+	features &= ~unsupported_features;
+
+	return features;
+}
+
+static netdev_features_t dpa_macless_fix_features(struct net_device *dev,
+					  netdev_features_t features)
+{
+	netdev_features_t unsupported_features = 0;
+
+	/* In theory we should never be requested to enable features that
+	 * we didn't set in netdev->features and netdev->hw_features at probe
+	 * time, but double check just to be on the safe side.
+	 */
+	unsupported_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
 	/* We don't support enabling Rx csum through ethtool yet */
 	unsupported_features |= NETIF_F_RXCSUM;
 
@@ -3357,6 +3402,25 @@ static const struct net_device_ops dpa_shared_ops = {
 	.ndo_do_ioctl = dpa_ioctl,
 };
 
+static const struct net_device_ops dpa_macless_ops = {
+	.ndo_open = dpa_macless_start,
+	.ndo_start_xmit = dpa_shared_tx,
+	.ndo_stop = dpa_macless_stop,
+	.ndo_tx_timeout = dpa_timeout,
+	.ndo_get_stats64 = dpa_get_stats64,
+	.ndo_set_mac_address = dpa_set_macless_address,
+	.ndo_validate_addr = eth_validate_addr,
+#ifdef CONFIG_FSL_DPAA_ETH_USE_NDO_SELECT_QUEUE
+	.ndo_select_queue = dpa_select_queue,
+#endif
+	.ndo_change_mtu = dpa_change_mtu,
+	.ndo_set_rx_mode = dpa_set_macless_rx_mode,
+	.ndo_init = dpa_ndo_init,
+	.ndo_set_features = dpa_set_features,
+	.ndo_fix_features = dpa_macless_fix_features,
+	.ndo_do_ioctl = dpa_macless_ioctl,
+};
+
 static u32 rx_pool_channel;
 static DEFINE_SPINLOCK(rx_pool_channel_init);
 
@@ -3745,49 +3809,14 @@ static void dpa_fq_setup(struct dpa_priv_s *priv)
 }
 
 static int dpa_netdev_init(struct device_node *dpa_node,
-		struct net_device *net_dev)
+		struct net_device *net_dev, const uint8_t *mac_addr)
 {
 	int err;
-	const uint8_t *mac_addr;
 	struct dpa_priv_s *priv = netdev_priv(net_dev);
 	struct device *dev = net_dev->dev.parent;
 
 	net_dev->hw_features |= DPA_NETIF_FEATURES;
 
-	if (!priv->mac_dev) {
-		/* Get the MAC address */
-		mac_addr = of_get_mac_address(dpa_node);
-		if (mac_addr == NULL) {
-			if (netif_msg_probe(priv))
-				dev_err(dev, "No MAC address found!\n");
-			return -EINVAL;
-		}
-	} else {
-		net_dev->mem_start = priv->mac_dev->res->start;
-		net_dev->mem_end = priv->mac_dev->res->end;
-
-		mac_addr = priv->mac_dev->addr;
-		net_dev->hw_features |= (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-			NETIF_F_LLTX);
-
-		/*
-		 * Advertise S/G and HIGHDMA support for MAC-ful,
-		 * private interfaces
-		 */
-		if (!priv->shared) {
-#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
-			net_dev->hw_features |= NETIF_F_SG | NETIF_F_HIGHDMA;
-			/* Recent kernels enable GSO automatically, if
-			 * we declare NETIF_F_SG. For conformity, we'll
-			 * still declare GSO explicitly.
-			 */
-			net_dev->features |= NETIF_F_GSO;
-#endif
-			/* Advertise GRO support */
-			net_dev->features |= NETIF_F_GRO;
-		}
-	}
-
 	net_dev->priv_flags |= IFF_LIVE_ADDR_CHANGE;
 
 	net_dev->features |= net_dev->hw_features;
@@ -3819,12 +3848,43 @@ static int dpa_netdev_init(struct device_node *dpa_node,
 	return 0;
 }
 
+static int dpa_macless_netdev_init(struct device_node *dpa_node,
+				struct net_device *net_dev)
+{
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	struct device *dev = net_dev->dev.parent;
+	const uint8_t *mac_addr;
+
+	net_dev->netdev_ops = &dpa_macless_ops;
+
+	/* Get the MAC address */
+	mac_addr = of_get_mac_address(dpa_node);
+	if (mac_addr == NULL) {
+		if (netif_msg_probe(priv))
+			dev_err(dev, "No MAC address found!\n");
+		return -EINVAL;
+	}
+
+	return dpa_netdev_init(dpa_node, net_dev, mac_addr);
+}
+
 static int dpa_shared_netdev_init(struct device_node *dpa_node,
 				struct net_device *net_dev)
 {
+	struct dpa_priv_s *priv = netdev_priv(net_dev);
+	const uint8_t *mac_addr;
+
 	net_dev->netdev_ops = &dpa_shared_ops;
 
-	return dpa_netdev_init(dpa_node, net_dev);
+	net_dev->mem_start = priv->mac_dev->res->start;
+	net_dev->mem_end = priv->mac_dev->res->end;
+
+	mac_addr = priv->mac_dev->addr;
+
+	net_dev->hw_features |= (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+		NETIF_F_LLTX);
+
+	return dpa_netdev_init(dpa_node, net_dev, mac_addr);
 }
 
 static int dpa_private_netdev_init(struct device_node *dpa_node,
@@ -3833,6 +3893,7 @@ static int dpa_private_netdev_init(struct device_node *dpa_node,
 	int i;
 	struct dpa_priv_s *priv = netdev_priv(net_dev);
 	struct dpa_percpu_priv_s *percpu_priv;
+	const uint8_t *mac_addr;
 
 	/*
 	 * Although we access another CPU's private data here
@@ -3848,7 +3909,27 @@ static int dpa_private_netdev_init(struct device_node *dpa_node,
 
 	net_dev->netdev_ops = &dpa_private_ops;
 
-	return dpa_netdev_init(dpa_node, net_dev);
+	mac_addr = priv->mac_dev->addr;
+
+	net_dev->mem_start = priv->mac_dev->res->start;
+	net_dev->mem_end = priv->mac_dev->res->end;
+
+	net_dev->hw_features |= (NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+		NETIF_F_LLTX);
+
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
+	/* Advertise S/G and HIGHDMA support for private interfaces */
+	net_dev->hw_features |= NETIF_F_SG | NETIF_F_HIGHDMA;
+	/* Recent kernels enable GSO automatically, if
+	 * we declare NETIF_F_SG. For conformity, we'll
+	 * still declare GSO explicitly.
+	 */
+	net_dev->features |= NETIF_F_GSO;
+#endif
+	/* Advertise GRO support */
+	net_dev->features |= NETIF_F_GRO;
+
+	return dpa_netdev_init(dpa_node, net_dev, mac_addr);
 }
 
 static int dpaa_eth_add_channel(void *__arg)
@@ -4107,9 +4188,13 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		memset(percpu_priv, 0, sizeof(*percpu_priv));
 	}
 
-	if (is_shared || is_macless)
+	if (is_shared)
 		err = dpa_shared_netdev_init(dpa_node, net_dev);
-	else
+
+	if (is_macless)
+		err = dpa_macless_netdev_init(dpa_node, net_dev);
+
+	if (!is_shared && !is_macless)
 		err = dpa_private_netdev_init(dpa_node, net_dev);
 
 	if (err < 0)
-- 
1.7.5.4

