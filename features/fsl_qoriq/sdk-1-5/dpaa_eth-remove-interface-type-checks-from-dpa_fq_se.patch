From f4eb80c1b22e34400b183861c8feb9a1893e5f91 Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Thu, 13 Jun 2013 15:33:35 +0300
Subject: [PATCH 048/429] dpaa_eth: remove interface type checks from
 dpa_fq_setup()

Instead of checking if the interface type is shared or MACless
provide FQs and tx_port as function parameters.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Change-Id: I4b50dca52d8ece60b017fcf7582f42e779ce5101
Reviewed-on: http://git.am.freescale.net:8181/3084
Reviewed-by: Sovaiala Cristian-Constantin-B39531 <Cristian.Sovaiala@freescale.com>
Reviewed-by: Radulescu Ruxandra Ioana-B05472 <ruxandra.radulescu@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   87 +++++++++++--------------
 1 files changed, 38 insertions(+), 49 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index ca0399f..c532d5e 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -2603,34 +2603,30 @@ static void egress_ern(struct qman_portal	*portal,
 	dev_kfree_skb_any(skb);
 }
 
-static const struct qman_fq rx_shared_fq __devinitconst = {
-	.cb = { .dqrr = shared_rx_dqrr }
-};
-static const struct qman_fq rx_private_defq __devinitconst = {
-	.cb = { .dqrr = ingress_rx_default_dqrr }
-};
-static const struct qman_fq rx_private_errq __devinitconst = {
-	.cb = { .dqrr = ingress_rx_error_dqrr }
-};
-static const struct qman_fq tx_private_defq __devinitconst = {
-	.cb = { .dqrr = ingress_tx_default_dqrr }
-};
-static const struct qman_fq tx_private_errq __devinitconst = {
-	.cb = { .dqrr = ingress_tx_error_dqrr }
-};
-static const struct qman_fq tx_shared_defq __devinitconst = {
-	.cb = { .dqrr = shared_tx_default_dqrr }
-};
-static const struct qman_fq tx_shared_errq __devinitconst = {
-	.cb = { .dqrr = shared_tx_error_dqrr }
-};
-static const struct qman_fq private_egress_fq __devinitconst = {
-	.cb = { .ern = egress_ern }
-};
-static const struct qman_fq shared_egress_fq __devinitconst = {
-	.cb = { .ern = shared_ern }
+typedef struct dpa_fq_cbs_t {
+	struct qman_fq rx_defq;
+	struct qman_fq tx_defq;
+	struct qman_fq rx_errq;
+	struct qman_fq tx_errq;
+	struct qman_fq egress_ern;
+} dpa_fq_cbs_t;
+
+static const dpa_fq_cbs_t private_fq_cbs = {
+	.rx_defq = { .cb = { .dqrr = ingress_rx_default_dqrr } },
+	.tx_defq = { .cb = { .dqrr = ingress_tx_default_dqrr } },
+	.rx_errq = { .cb = { .dqrr = ingress_rx_error_dqrr } },
+	.tx_errq = { .cb = { .dqrr = ingress_tx_error_dqrr } },
+	.egress_ern = { .cb = { .ern = egress_ern } }
+ };
+ 
+static const dpa_fq_cbs_t shared_fq_cbs = {
+	.rx_defq = { .cb = { .dqrr = shared_rx_dqrr } },
+	.tx_defq = { .cb = { .dqrr = shared_tx_default_dqrr } },
+	.rx_errq = { .cb = { .dqrr = shared_rx_dqrr } },
+	.tx_errq = { .cb = { .dqrr = shared_tx_error_dqrr } },
+	.egress_ern = { .cb = { .ern = shared_ern } }
 };
-
+ 
 static int __cold dpa_start(struct net_device *net_dev)
 {
 	int err, i;
@@ -3399,7 +3395,8 @@ dpaa_eth_init_ports(struct mac_device *mac_dev,
 	fm_port_pcd_bind(rxport, &rx_port_pcd_param);
 }
 
-static void dpa_fq_setup(struct dpa_priv_s *priv)
+static void dpa_fq_setup(struct dpa_priv_s *priv, const dpa_fq_cbs_t *fq_cbs,
+		struct fm_port *tx_port)
 {
 	struct dpa_fq *fq;
 	int portals[NR_CPUS];
@@ -3410,7 +3407,6 @@ static void dpa_fq_setup(struct dpa_priv_s *priv)
 #ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	int recycle_cnt = 0;
 #endif
-	struct fm_port *tx_port;
 
 	/* Prepare for PCD FQs init */
 	for_each_cpu(cpu, affine_cpus)
@@ -3422,35 +3418,29 @@ static void dpa_fq_setup(struct dpa_priv_s *priv)
 	pcd_fqid = (priv->mac_dev) ?
 		DPAA_ETH_PCD_FQ_BASE(priv->mac_dev->res->start) : 0;
 
-	/* Get the Tx Fman port (needed for egress fqs) */
-	tx_port = (priv->mac_dev) ? priv->mac_dev->port_dev[TX] : NULL;
-
 	/* Initialize each FQ in the list */
 	list_for_each_entry(fq, &priv->dpa_fq_list, list) {
 		switch (fq->fq_type) {
 		case FQ_TYPE_RX_DEFAULT:
 			BUG_ON(!priv->mac_dev);
-			dpa_setup_ingress(priv, fq, (priv->shared ?
-					  &rx_shared_fq : &rx_private_defq));
+			dpa_setup_ingress(priv, fq, &fq_cbs->rx_defq);
 			break;
 		case FQ_TYPE_RX_ERROR:
 			BUG_ON(!priv->mac_dev);
-			dpa_setup_ingress(priv, fq, (priv->shared ?
-					  &rx_shared_fq : &rx_private_errq));
+			dpa_setup_ingress(priv, fq, &fq_cbs->rx_errq);
 			break;
 		case FQ_TYPE_RX_PCD:
 			/* For MACless we can't have dynamic Rx queues */
 			BUG_ON(!priv->mac_dev && !fq->fqid);
-			dpa_setup_ingress(priv, fq, (priv->shared ?
-					  &rx_shared_fq : &rx_private_defq));
+			dpa_setup_ingress(priv, fq, &fq_cbs->rx_defq);
 			if (!fq->fqid)
 				fq->fqid = pcd_fqid++;
 			fq->channel = portals[portal_cnt];
 			portal_cnt = (portal_cnt + 1) % num_portals;
 			break;
 		case FQ_TYPE_TX:
-			dpa_setup_egress(priv, fq, tx_port, (priv->shared ?
-				&shared_egress_fq : &private_egress_fq));
+			dpa_setup_egress(priv, fq, tx_port,
+					 &fq_cbs->egress_ern);
 			/* If we have more Tx queues than the number of cores,
 			 * just ignore the extra ones.
 			 */
@@ -3459,25 +3449,24 @@ static void dpa_fq_setup(struct dpa_priv_s *priv)
 			break;
 		case FQ_TYPE_TX_CONFIRM:
 			BUG_ON(!priv->mac_dev);
-			dpa_setup_ingress(priv, fq, (priv->shared ?
-					  &tx_shared_defq : &tx_private_defq));
+			dpa_setup_ingress(priv, fq, &fq_cbs->tx_defq);
 			break;
 		case FQ_TYPE_TX_CONF_MQ:
 			BUG_ON(!priv->mac_dev);
 			BUG_ON(priv->shared);
-			dpa_setup_ingress(priv, fq, &tx_private_defq);
+			dpa_setup_ingress(priv, fq, &fq_cbs->tx_defq);
 			priv->conf_fqs[conf_cnt++] = &fq->fq_base;
 			break;
 		case FQ_TYPE_TX_ERROR:
 			BUG_ON(!priv->mac_dev);
-			dpa_setup_ingress(priv, fq, (priv->shared ?
-					  &tx_shared_errq : &tx_private_errq));
+			dpa_setup_ingress(priv, fq, &fq_cbs->tx_errq);
 			break;
 #ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 		case FQ_TYPE_TX_RECYCLE:
 			BUG_ON(!priv->mac_dev);
 			BUG_ON(priv->shared);
-			dpa_setup_egress(priv, fq, tx_port, &private_egress_fq);
+			dpa_setup_egress(priv, fq, tx_port,
+					 &fq_cbs->egress_ern);
 			priv->recycle_fqs[recycle_cnt++] = &fq->fq_base;
 			break;
 #endif
@@ -3799,7 +3788,7 @@ dpaa_eth_priv_probe(struct platform_device *_of_dev)
 		goto add_channel_failed;
 	}
 
-	dpa_fq_setup(priv);
+	dpa_fq_setup(priv, &private_fq_cbs, priv->mac_dev->port_dev[TX]);
 
 	/*
 	 * Create a congestion group for this netdev, with
@@ -3984,7 +3973,7 @@ dpaa_eth_shared_probe(struct platform_device *_of_dev)
 		goto add_channel_failed;
 	}
 
-	dpa_fq_setup(priv);
+	dpa_fq_setup(priv, &shared_fq_cbs, priv->mac_dev->port_dev[TX]);
 
 	/* Create a congestion group for this netdev, with
 	 * dynamically-allocated CGR ID.
@@ -4145,7 +4134,7 @@ dpaa_eth_macless_probe(struct platform_device *_of_dev)
 		goto add_channel_failed;
 	}
 
-	dpa_fq_setup(priv);
+	dpa_fq_setup(priv, &shared_fq_cbs, NULL);
 
 	/* Add the FQs to the interface, and make them active */
 	list_for_each_entry_safe(dpa_fq, tmp, &priv->dpa_fq_list, list) {
-- 
1.7.5.4

