From c4920db976433a00303adadbf807d61d25892fde Mon Sep 17 00:00:00 2001
From: Emil Medve <Emilian.Medve@Freescale.com>
Date: Tue, 9 Apr 2013 11:34:41 -0500
Subject: [PATCH 156/429] fsl_qman: Set stashing using the IOMMU API

This is using thew new PAMU driver

This integration uses a *horrible hack* in order to provide the IOMMU/PAMU
driver with a 'struct device'. Making the QMan portal driver nice and
proper is part of the upstreaming effort

Change-Id: I5f03a3b662949162bff7ac8c7b14ad5fbc0394ce
Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
Change-Id: Ic66bb3904ffa537e497ba00c67e22d851087b435
Reviewed-on: http://git.am.freescale.net:8181/1173
Reviewed-by: Ladouceur Jeffrey-R11498 <Jeffrey.Ladouceur@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/staging/fsl_qbman/dpa_uio.c      |    2 +-
 drivers/staging/fsl_qbman/qman_driver.c  |   87 +++++++++++++++++++++++++++++-
 drivers/staging/fsl_qbman/qman_private.h |    3 +-
 3 files changed, 88 insertions(+), 4 deletions(-)

diff --git a/drivers/staging/fsl_qbman/dpa_uio.c b/drivers/staging/fsl_qbman/dpa_uio.c
index cdb78db..557be44 100644
--- a/drivers/staging/fsl_qbman/dpa_uio.c
+++ b/drivers/staging/fsl_qbman/dpa_uio.c
@@ -38,7 +38,7 @@ static LIST_HEAD(dpa_uio_list);
 
 struct dpa_uio_info {
 	const struct dpa_uio_vtable *vtable;
-	const struct list_head *pcfg;
+	struct list_head *pcfg;
 	atomic_t ref; /* exclusive, only one open() at a time */
 	struct uio_info uio;
 	struct platform_device *pdev;
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index f4dd35a..242911a 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -31,6 +31,8 @@
 
 #include "qman_private.h"
 
+#include <linux/iommu.h>
+
 #include <asm/smp.h>	/* hard_smp_processor_id() if !CONFIG_SMP */
 
 /* Global variable containing revision id (even on non-control plane systems
@@ -368,6 +370,20 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 		return NULL;
 	}
 
+	/*
+	 * This is a *horrible hack*, but the IOMMU/PAMU driver needs a
+	 * 'struct device' in order to get the PAMU stashing setup and the QMan
+	 * portal [driver] won't function at all without ring stashing
+	 *
+	 * Making the QMan portal driver nice and proper is part of the
+	 * upstreaming effort
+	 */
+	pcfg->dev.bus = &platform_bus_type;
+	pcfg->dev.of_node = node;
+#ifdef CONFIG_IOMMU_API
+	pcfg->dev.archdata.iommu_domain = NULL;
+#endif
+
 	ret = of_address_to_resource(node, DPA_PORTAL_CE,
 				&pcfg->addr_phys[DPA_PORTAL_CE]);
 	if (ret) {
@@ -410,7 +426,6 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 	}
 	pcfg->public_cfg.irq = irq;
 	pcfg->public_cfg.index = *index;
-	pcfg->node = node;
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	/* We need the same LIODN offset for all portals */
 	qman_liodn_fixup(pcfg->public_cfg.channel);
@@ -442,12 +457,79 @@ static struct qm_portal_config *get_pcfg(struct list_head *list)
 }
 
 
-static void portal_set_cpu(const struct qm_portal_config *pcfg, int cpu)
+static void portal_set_cpu(struct qm_portal_config *pcfg, int cpu)
 {
+	int ret;
+	int window_count = 1;
+	struct iommu_domain_geometry geom_attr;
+	struct iommu_stash_attribute stash_attr;
+
+	pcfg->iommu_domain = iommu_domain_alloc(&platform_bus_type);
+	if (!pcfg->iommu_domain) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_alloc() failed",
+			   __func__);
+		goto _no_iommu;
+	}
+	geom_attr.aperture_start = 0;
+	geom_attr.aperture_end =
+		((dma_addr_t)1 << min(8 * sizeof(dma_addr_t), (size_t)36)) - 1;
+	geom_attr.force_aperture = true;
+	ret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_GEOMETRY,
+				    &geom_attr);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_set_attr() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	ret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_WINDOWS,
+				    &window_count);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_set_attr() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	stash_attr.cpu = cpu;
+	stash_attr.cache = IOMMU_ATTR_CACHE_L1;
+	ret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_PAMU_STASH,
+				    &stash_attr);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_set_attr() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	ret = iommu_domain_window_enable(pcfg->iommu_domain, 0, 0, 1ULL << 36,
+					 IOMMU_READ | IOMMU_WRITE);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_window_enable() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	ret = iommu_attach_device(pcfg->iommu_domain, &pcfg->dev);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_device_attach() = %d",
+			   __func__, ret);
+		goto _iommu_domain_free;
+	}
+	ret = iommu_domain_set_attr(pcfg->iommu_domain, DOMAIN_ATTR_PAMU_ENABLE,
+				    &window_count);
+	if (ret < 0) {
+		pr_err(KBUILD_MODNAME ":%s(): iommu_domain_set_attr() = %d",
+			   __func__, ret);
+		goto _iommu_detach_device;
+	}
+
+_no_iommu:
 #ifdef CONFIG_FSL_QMAN_CONFIG
 	if (qman_set_sdest(pcfg->public_cfg.channel, cpu))
 #endif
 		pr_warning("Failed to set QMan portal's stash request queue\n");
+
+	return;
+
+_iommu_detach_device:
+	iommu_detach_device(pcfg->iommu_domain, NULL);
+_iommu_domain_free:
+	iommu_domain_free(pcfg->iommu_domain);
 }
 
 struct qm_portal_config *qm_get_unused_portal(void)
@@ -580,6 +662,7 @@ __init int qman_init(void)
 		if (ret)
 			return ret;
 	}
+
 	/* Initialise portals. See bman_driver.c for comments */
 	for_each_compatible_node(dn, NULL, "fsl,qman-portal") {
 		if (!of_device_is_available(dn))
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index 4de2f32..7f35dcf 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -175,7 +175,8 @@ struct qm_portal_config {
 	 * [0]==cache-enabled, [1]==cache-inhibited. */
 	__iomem void *addr_virt[2];
 	struct resource addr_phys[2];
-	struct device_node *node;
+	struct device dev;
+	struct iommu_domain *iommu_domain;
 	/* Allow these to be joined in lists */
 	struct list_head list;
 	/* User-visible portal configuration settings */
-- 
1.7.5.4

