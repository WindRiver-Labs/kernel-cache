From 60945b35579106f6f889084ed38e78674dce52e1 Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Tue, 15 Oct 2013 12:00:59 -0400
Subject: [PATCH 229/383] fsl_qbman: use pointer type for affine_portals

Those pointers don't need to be converted to a "numerical" form.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: Ic6ee5d3e20ae6134bbb571a832938996b3a023e7
Reviewed-on: http://git.am.freescale.net:8181/5633
Reviewed-by: Ladouceur Jeffrey-R11498 <Jeffrey.Ladouceur@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thorpe Geoff-R01361 <Geoff.Thorpe@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/bman_driver.c  |    6 +++---
 drivers/staging/fsl_qbman/qman_driver.c  |    2 +-
 drivers/staging/fsl_qbman/qman_high.c    |    8 ++++----
 drivers/staging/fsl_qbman/qman_private.h |    2 +-
 include/linux/fsl_qman.h                 |    2 +-
 5 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 2a59721..3bd5160 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -52,7 +52,7 @@ static int num_shared_portals;
 static int shared_portals_idx;
 static LIST_HEAD(unused_pcfgs);
 static DEFINE_SPINLOCK(unused_pcfgs_lock);
-static uintptr_t affine_bportals[NR_CPUS];
+static void *affine_bportals[NR_CPUS];
 
 static int __init fsl_bpool_init(struct device_node *node)
 {
@@ -252,7 +252,7 @@ static struct bman_portal *init_pcfg(struct bm_portal_config *pcfg)
 		pr_info("Bman portal %sinitialised, cpu %d\n",
 			pcfg->public_cfg.is_shared ? "(shared) " : "",
 			pcfg->public_cfg.cpu);
-		affine_bportals[pcfg->public_cfg.cpu] = (uintptr_t)p;
+		affine_bportals[pcfg->public_cfg.cpu] = p;
 	} else
 		pr_crit("Bman portal failure on cpu %d\n",
 			pcfg->public_cfg.cpu);
@@ -269,7 +269,7 @@ static void init_slave(int cpu)
 		pr_info("Bman portal %sinitialised, cpu %d\n", "(slave) ", cpu);
 	if (shared_portals_idx >= num_shared_portals)
 		shared_portals_idx = 0;
-	affine_bportals[cpu] = (uintptr_t)p;
+	affine_bportals[cpu] = p;
 }
 
 /* Bootarg "bportals=[...]" has the same syntax as "qportals=", and so the
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index eee4f3b..75031a0 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -736,7 +736,7 @@ __init int qman_init(void)
 			return ret;
 	}
 
-	memset(&affine_portals, 0, sizeof(uintptr_t) * num_possible_cpus());
+	memset(affine_portals, 0, sizeof(void *) * num_possible_cpus());
 	/* Initialise portals. See bman_driver.c for comments */
 	for_each_compatible_node(dn, NULL, "fsl,qman-portal") {
 		if (!of_device_is_available(dn))
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index a0878e4..37741a2 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -160,7 +160,7 @@ struct qman_portal *per_cpu_affine_portal(int cpu)
 	return &per_cpu(qman_affine_portal, cpu);
 }
 EXPORT_SYMBOL(per_cpu_affine_portal);
-uintptr_t affine_portals[NR_CPUS];
+void *affine_portals[NR_CPUS];
 
 /* "raw" gets the cpu-local struct whether it's a redirect or not. */
 static inline struct qman_portal *get_raw_affine_portal(void)
@@ -587,7 +587,7 @@ struct qman_portal *qman_create_affine_portal(
 		cpumask_set_cpu(config->public_cfg.cpu, &affine_mask);
 		affine_channels[config->public_cfg.cpu] =
 			config->public_cfg.channel;
-		affine_portals[config->public_cfg.cpu] = (uintptr_t)portal;
+		affine_portals[config->public_cfg.cpu] = portal;
 		spin_unlock(&affine_mask_lock);
 	}
 	return res;
@@ -610,7 +610,7 @@ struct qman_portal *qman_create_affine_slave(struct qman_portal *redirect,
 	/* These are the only elements to initialise when redirecting */
 	p->irq_sources = 0;
 	p->sharing_redirect = redirect;
-	affine_portals[cpu] = (uintptr_t)p;
+	affine_portals[cpu] = p;
 	return p;
 #else
 	BUG();
@@ -1117,7 +1117,7 @@ u16 qman_affine_channel(int cpu)
 }
 EXPORT_SYMBOL(qman_affine_channel);
 
-uintptr_t qman_get_affine_portal(int cpu)
+void *qman_get_affine_portal(int cpu)
 {
 	return affine_portals[cpu];
 }
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index dafbce1..a2229d5 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -391,7 +391,7 @@ int qman_ceetm_query_ccgr(struct qm_mcc_ceetm_ccgr_query *ccgr_query,
 int qman_ceetm_get_xsfdr(enum qm_dc_portal portal, unsigned int *num);
 
 /* Portal migration */
-extern uintptr_t affine_portals[NR_CPUS];
+extern void *affine_portals[NR_CPUS];
 int qman_portal_is_sharing_redirect(struct qman_portal *portal);
 void qman_migrate_portal(struct qman_portal *portal);
 void qman_migrate_portal_back(struct qman_portal *portal, unsigned int cpu);
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 46ada2a..5244b41 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1672,7 +1672,7 @@ u16 qman_affine_channel(int cpu);
  * @cpu: the cpu whose affine portal is the subject of the query
  *
  */
-uintptr_t qman_get_affine_portal(int cpu);
+void *qman_get_affine_portal(int cpu);
 
 /**
  * qman_poll_dqrr - process DQRR (fast-path) entries
-- 
1.7.5.4

