From 0fec7f8d0b4725a21b56e9969867b445f9d63a3b Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Thu, 28 Nov 2013 17:53:16 +0200
Subject: [PATCH 337/383] dpa_offload: Fix B4 platforms 10G port recognition
 in DPA statistics

1G ports were mistaken for 10G ports in the DPA Stats component, because
there is no way to tell between the two just by looking at the compatibility
string from their device tree node. For both types of ports, the compatibility
string reads "fsl,fman-memac". Recognition was hence improved by also
looking at the "phy-connection-type" string, which should be "xgmii" for
10G interfaces.

Change-Id: I6049dd2a6e10c2342dce9052b7737c7e3fc950c5
Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/6932
Reviewed-by: Radu-Andrei Bulie <Radu.Bulie@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_stats.c |   57 ++++++++++++++++++++-------
 1 files changed, 42 insertions(+), 15 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_stats.c b/drivers/staging/fsl_dpa_offload/dpa_stats.c
index bd2e35a..ab205e5 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_stats.c
@@ -1177,23 +1177,44 @@ static int copy_key_descriptor(const struct dpa_offload_lookup_key *src,
 
 static t_Handle get_fman_mac_handle(struct device_node *parent_dev_node,
 				    int port_id,
-				    char *mac_name)
+				    char *mac_name,
+				    bool xg_port)
 {
 	struct device_node *dev_node, *tmp_node = NULL;
-	struct mac_device  *mac_dev = NULL;
-	const uint32_t	*cell_index;
+	struct mac_device *mac_dev = NULL;
+	const uint32_t *cell_index;
+	const char *phy_connection;
+	struct platform_device *device;
 	int lenp;
 
 	while ((dev_node = of_find_compatible_node(tmp_node, NULL,
 			mac_name)) != NULL) {
-		if (parent_dev_node == of_get_parent(dev_node)) {
-			cell_index = of_get_property(
-					dev_node, "cell-index", &lenp);
-			if (*cell_index == port_id) {
-				mac_dev = dev_get_drvdata(&
-					of_find_device_by_node(dev_node)->dev);
-				return mac_dev->get_mac_handle(mac_dev);
-			}
+
+		if (parent_dev_node != of_get_parent(dev_node)) {
+			tmp_node = dev_node;
+			continue;
+		}
+
+		cell_index = of_get_property(dev_node, "cell-index", &lenp);
+		if (*cell_index != port_id) {
+			tmp_node = dev_node;
+			continue;
+		}
+
+		phy_connection = of_get_property(dev_node,
+						"phy-connection-type",
+						&lenp);
+		if (((xg_port) && (strcmp(phy_connection, "xgmii") == 0)) ||
+			((!xg_port) && (strcmp(phy_connection, "xgmii") != 0))) {
+
+			device = of_find_device_by_node(dev_node);
+			if (!device)
+				return NULL;
+			mac_dev = dev_get_drvdata(&device->dev);
+			if (!mac_dev)
+				return NULL;
+
+			return mac_dev->get_mac_handle(mac_dev);
 		}
 
 		tmp_node = dev_node;
@@ -1238,12 +1259,15 @@ static int get_fm_mac(struct dpa_stats_cnt_eth_src src, void **mac)
 		mac_name = "fsl,fman-10g-mac";
 		src.eth_id -= DPA_STATS_ETH_10G_PORT0;
 
-		fm_mac = get_fman_mac_handle(dev_node, src.eth_id, mac_name);
+		fm_mac = get_fman_mac_handle(dev_node,
+					src.eth_id,
+					mac_name,
+					true);
 		if (!fm_mac) {
 			/* Get Ethernet device node for MEMAC case 10G port */
 			mac_name = "fsl,fman-memac";
 			fm_mac = get_fman_mac_handle(
-					dev_node, src.eth_id, mac_name);
+					dev_node, src.eth_id, mac_name, true);
 			if (!fm_mac) {
 				log_err("Cannot find Ethernet device node\n");
 				return -EINVAL;
@@ -1253,12 +1277,15 @@ static int get_fm_mac(struct dpa_stats_cnt_eth_src src, void **mac)
 		/* Get Ethernet device node first for DTSEC case 1G port*/
 		mac_name = "fsl,fman-1g-mac";
 
-		fm_mac = get_fman_mac_handle(dev_node, src.eth_id, mac_name);
+		fm_mac = get_fman_mac_handle(dev_node,
+					src.eth_id,
+					mac_name,
+					false);
 		if (!fm_mac) {
 			/* Get Ethernet device node for MEMAC case 1G port*/
 			mac_name = "fsl,fman-memac";
 			fm_mac = get_fman_mac_handle(
-					dev_node, src.eth_id, mac_name);
+					dev_node, src.eth_id, mac_name, false);
 			if (!fm_mac) {
 				log_err("Cannot find Ethernet device node\n");
 				return -EINVAL;
-- 
1.7.5.4

