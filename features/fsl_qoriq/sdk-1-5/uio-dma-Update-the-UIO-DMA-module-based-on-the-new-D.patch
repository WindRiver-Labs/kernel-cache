From 00631ab86486b5a28726571acf059a1308e1f0bf Mon Sep 17 00:00:00 2001
From: Liu Gang <Gang.Liu@freescale.com>
Date: Mon, 11 Nov 2013 18:34:26 +0800
Subject: [PATCH 305/383] uio/dma: Update the UIO DMA module based on the new
 DMA dts

The updated DMA dts files added a new compatible "fsl,elo3-dma"
for some new platforms, and removed the property "cell-index".
So the code should be updated based on those changes.

Signed-off-by: Liu Gang <Gang.Liu@freescale.com>
Signed-off-by: Minghuan Lian <Minghuan.Lian@freescale.com>
Change-Id: I66603f76ca0feeb689c49b9eeb9c0621eb5c3897
Reviewed-on: http://git.am.freescale.net:8181/6555
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Tiefei Zang <roy.zang@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/uio/fsl_dma_uio.c |   33 ++++++++++-----------------------
 1 files changed, 10 insertions(+), 23 deletions(-)

diff --git a/drivers/uio/fsl_dma_uio.c b/drivers/uio/fsl_dma_uio.c
index 6eeffd2..bab3d90 100644
--- a/drivers/uio/fsl_dma_uio.c
+++ b/drivers/uio/fsl_dma_uio.c
@@ -80,7 +80,7 @@ static irqreturn_t dma_uio_irq_handler(int irq, struct uio_info *dev_info)
 	return IRQ_HANDLED;
 }
 
-static int __init dma_chan_uio_setup(struct dma_chan *dma_ch)
+static int dma_chan_uio_setup(struct dma_chan *dma_ch)
 {
 	int ret;
 	struct dma_uio_info *info;
@@ -111,7 +111,6 @@ static int __init dma_chan_uio_setup(struct dma_chan *dma_ch)
 	info->uio.open = dma_uio_open;
 	info->uio.release = dma_uio_release;
 	info->uio.priv = dma_ch;
-
 	ret = uio_register_device(dma_ch->dev, &info->uio);
 	if (ret) {
 		dev_err(dma_ch->dev, "dma_uio: UIO registration failed\n");
@@ -122,13 +121,13 @@ static int __init dma_chan_uio_setup(struct dma_chan *dma_ch)
 }
 
 static int fsl_dma_chan_probe(struct fsldma_device *fdev,
-					struct device_node *node)
+			      struct device_node *node,
+			      u32 chanid)
 {
 	struct resource regs;
 	struct dma_chan *dma_ch;
 	struct device_node *dma_node;
 	int err;
-	u32 *cell;
 	struct platform_device *dev = fdev->dev;
 
 	dma_node = node;
@@ -140,14 +139,9 @@ static int fsl_dma_chan_probe(struct fsldma_device *fdev,
 		return -ENOMEM;
 	}
 
-	cell = (u32 *)of_get_property(dma_node, "cell-index", NULL);
-	if (!cell) {
-		dev_err(&dev->dev, "Can't get property 'cell-index'\n");
-		return -EFAULT;
-	}
 
 	dma_ch->dma_id = fdev->dma_id;
-	dma_ch->ch_id = *cell;
+	dma_ch->ch_id = chanid;
 	dma_ch->dev = &dev->dev;
 
 	err = of_address_to_resource(dma_node, 0, &regs);
@@ -199,13 +193,8 @@ static int fsl_dma_uio_probe(struct platform_device *dev)
 {
 	struct device_node *child;
 	struct fsldma_device *fdev;
-	u32 *cell;
-
-	cell = (u32 *)of_get_property(dev->dev.of_node, "cell-index", NULL);
-	if (!cell) {
-		dev_err(&dev->dev, "Can't get property 'cell-index'\n");
-		return -ENODEV;
-	}
+	static u32 dmaid;
+	u32 chanid = 0;
 
 	fdev = devm_kzalloc(&dev->dev, sizeof(struct fsldma_device),
 				GFP_KERNEL);
@@ -214,15 +203,14 @@ static int fsl_dma_uio_probe(struct platform_device *dev)
 		return -ENOMEM;
 	}
 
-	fdev->dma_id = *cell;
+	fdev->dma_id = dmaid++;
 	fdev->dev = dev;
 	INIT_LIST_HEAD(&fdev->ch_list);
 	dev_set_drvdata(&dev->dev, fdev);
 
 	for_each_child_of_node(dev->dev.of_node, child)
 		if (of_device_is_compatible(child, "fsl,eloplus-dma-channel"))
-			fsl_dma_chan_probe(fdev, child);
-
+			fsl_dma_chan_probe(fdev, child, chanid++);
 	return 0;
 }
 
@@ -242,9 +230,8 @@ static int fsl_dma_uio_remove(struct platform_device *dev)
 
 
 static const struct of_device_id fsl_of_dma_match[] = {
-	{
-		.compatible = "fsl,eloplus-dma",
-	},
+	{ .compatible = "fsl,elo3-dma", },
+	{ .compatible = "fsl,eloplus-dma", },
 	{}
 };
 
-- 
1.7.5.4

