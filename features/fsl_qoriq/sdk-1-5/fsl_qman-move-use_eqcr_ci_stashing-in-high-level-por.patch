From d96812cefc5507513efe3f41061d998443702f0c Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Wed, 28 Aug 2013 13:00:58 -0400
Subject: [PATCH 166/383] fsl_qman: move use_eqcr_ci_stashing in high level
 portal structure

It was wrongly put into low level structure in commit "qman: Add
CI-stashing support for QMan rev3.0 or later".

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Change-Id: Ib0c8355750bc4195c71799f559f75979b50fca31
Reviewed-on: http://git.am.freescale.net:8181/4583
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c |    2 +-
 drivers/staging/fsl_qbman/qman_high.c  |    7 ++++---
 drivers/staging/fsl_qbman/qman_low.h   |    6 +++++-
 3 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index d0045f0..e40ef04 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -349,7 +349,7 @@ static int init_qm_portal(struct qm_portal_config *config,
 
 	/* Initialize the EQCR */
 	if (qm_eqcr_init(portal, qm_eqcr_pvb, 
-			portal->eqcr.use_eqcr_ci_stashing ? 3 : 0, 1)) {
+			qm_eqcr_get_ci_stashing(portal), 1)) {
 		pr_err("Qman EQCR initialisation failed\n");
 		return 1;
 	}
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 13e6fff9..25db3f5 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -87,6 +87,7 @@ struct qman_portal {
 	struct qm_portal p;
 	unsigned long bits; /* PORTAL_BITS_*** - dynamic, strictly internal */
 	unsigned long irq_sources;
+	u32 use_eqcr_ci_stashing;
 	u32 slowpoll;	/* only used when interrupts are off */
 	struct qman_fq *vdqcr_owned; /* only 1 volatile dequeue at a time */
 #ifdef CONFIG_FSL_DPA_CAN_WAIT_SYNC
@@ -403,7 +404,7 @@ struct qman_portal *qman_create_portal(
 
 	__p = &portal->p;
 
-	portal->p.eqcr.use_eqcr_ci_stashing = ((qman_ip_rev >= QMAN_REV30) ?
+	portal->use_eqcr_ci_stashing = ((qman_ip_rev >= QMAN_REV30) ?
 								1 : 0);
 
 	/* prep the low-level portal struct with the mapped addresses from the
@@ -416,7 +417,7 @@ struct qman_portal *qman_create_portal(
 	 * and stash with high-than-DQRR priority.
 	 */
 	if (qm_eqcr_init(__p, qm_eqcr_pvb,
-			portal->p.eqcr.use_eqcr_ci_stashing ? 3 : 0, 1)) {
+			portal->use_eqcr_ci_stashing ? 3 : 0, 1)) {
 		pr_err("Qman EQCR initialisation failed\n");
 		goto fail_eqcr;
 	}
@@ -2026,7 +2027,7 @@ static inline struct qm_eqcr_entry *try_eq_start(struct qman_portal **p,
 		(*p)->eqci_owned = fq;
 	}
 #endif
-	if ((*p)->p.eqcr.use_eqcr_ci_stashing) {
+	if ((*p)->use_eqcr_ci_stashing) {
 		/*
 		 * The stashing case is easy, only update if we need to in
 		 * order to try and liberate ring entries.
diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index 64479f0..ea2dccc 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -166,7 +166,6 @@ enum qm_mr_cmode {		/* matches QCSP_CFG::MM */
 struct qm_eqcr {
 	struct qm_eqcr_entry *ring, *cursor;
 	u8 ci, available, ithresh, vbit;
-	u32 use_eqcr_ci_stashing;
 #ifdef CONFIG_FSL_DPA_CHECKING
 	u32 busy;
 	enum qm_eqcr_pmode pmode;
@@ -287,6 +286,11 @@ static inline int qm_eqcr_init(struct qm_portal *portal,
 	return 0;
 }
 
+static inline unsigned int qm_eqcr_get_ci_stashing(struct qm_portal *portal)
+{
+	return ((qm_in(CFG) >> 28) & 0x7);
+}
+
 static inline void qm_eqcr_finish(struct qm_portal *portal)
 {
 	register struct qm_eqcr *eqcr = &portal->eqcr;
-- 
1.7.5.4

