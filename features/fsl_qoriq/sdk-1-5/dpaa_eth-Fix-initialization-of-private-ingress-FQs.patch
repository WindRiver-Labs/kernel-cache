From 8b92989601ae6cfa9cfcc3afac833b3fdcafd98f Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Mon, 9 Dec 2013 16:59:54 +0200
Subject: [PATCH 415/429] dpaa_eth: Fix initialization of private ingress FQs

The code which places the driver's ingress FQs in the "ingress CGR" must
only be run by the private DPAA Ethernet driver, which is the only one
to create that CGR.

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Change-Id: I93847078a2d23c8620fbf735db019efd3f8f90f5
Reviewed-on: http://git.am.freescale.net:8181/7183
Reviewed-by: Marian Cristian Rotariu <marian.rotariu@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
Reviewed-by: Ruxandra Ioana Radulescu <ruxandra.radulescu@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |    8 +++++++-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      |    1 +
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   |    9 +++++----
 3 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 8dc2b0f..886365f 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -693,7 +693,6 @@ dpa_priv_bp_probe(struct device *dev)
  * this CGR to generate enqueue rejections to FMan in order to drop the frames
  * before they reach our ingress queues and eat up memory.
  */
-#define DPA_INGRESS_CS_THRESHOLD	0x10000000
 static int dpaa_eth_priv_ingress_cgr_init(struct dpa_priv_s *priv)
 {
 	struct qm_mcc_initcgr initcgr;
@@ -729,6 +728,13 @@ static int dpaa_eth_priv_ingress_cgr_init(struct dpa_priv_s *priv)
 	pr_debug("Created ingress CGR %d for netdev with hwaddr %pM\n",
 		 priv->ingress_cgr.cgrid, priv->mac_dev->addr);
 
+	/* struct qman_cgr allows special cgrid values (i.e. outside the 0..255
+	 * range), but we have no common initialization path between the
+	 * different variants of the DPAA Eth driver, so we do it here rather
+	 * than modifying every other variant than "private Eth".
+	 */
+	priv->use_ingress_cgr = true;
+
 out_error:
 	return err;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 5f18750..029619c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -411,6 +411,7 @@ struct dpa_priv_s {
 		u32 cgr_congested_count;
 	} cgr_data;
 	/* Use a per-port CGR for ingress traffic. */
+	bool use_ingress_cgr;
 	struct qman_cgr ingress_cgr;
 
 #ifdef CONFIG_FSL_DPAA_TS
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index 76a4c22..a0a155e 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -1279,10 +1279,11 @@ int dpa_fq_init(struct dpa_fq *dpa_fq, bool td_enable)
 		}
 #endif
 
-		/* Put all ingress queues in our "ingress CGR". */
-		if (dpa_fq->fq_type == FQ_TYPE_RX_DEFAULT ||
-				dpa_fq->fq_type == FQ_TYPE_RX_ERROR ||
-				dpa_fq->fq_type == FQ_TYPE_RX_PCD) {
+		/* Put all *private* ingress queues in our "ingress CGR". */
+		if (priv->use_ingress_cgr &&
+				(dpa_fq->fq_type == FQ_TYPE_RX_DEFAULT ||
+				 dpa_fq->fq_type == FQ_TYPE_RX_ERROR ||
+				 dpa_fq->fq_type == FQ_TYPE_RX_PCD)) {
 			initfq.we_mask |= QM_INITFQ_WE_CGID;
 			initfq.fqd.fq_ctrl |= QM_FQCTRL_CGE;
 			initfq.fqd.cgid = priv->ingress_cgr.cgrid;
-- 
1.7.5.4

