From b93ad17f0887895de8be4cab28f8a58fb9cae3b9 Mon Sep 17 00:00:00 2001
From: Marian Chereji <marian.chereji@freescale.com>
Date: Tue, 24 Sep 2013 18:28:58 +0300
Subject: [PATCH 243/429] dpa_offload: Add support for IPSec SA extended
 statistics counters

Added the possibility to provide the following IPSec statistics:

1. total number of packets (including bad packets) selected on inbound
   for a specific SA;
2. total number of packets (including bad packets) that have entered a
   specific SA on outbound;
3. total number of packets that have missed SA selection on inbound;
4. total number of bytes that have missed SA selection on inbound;
5. total number of packets that have missed SA selection on outbound;
6. total number of bytes that have missed SA selection on outbound.

Change-Id: Ic57b65406db20760e144d50cbff7c4d5eca0c5ce
Signed-off-by: Marian Chereji <marian.chereji@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/5203
Reviewed-by: Floarea Anca Jeanina-B12569 <anca.floarea@freescale.com>
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c       |  158 ++++++++++++++++++++-
 drivers/staging/fsl_dpa_offload/dpa_ipsec.h       |    1 +
 drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h |    3 +
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c   |   34 +++++
 include/linux/fsl_dpa_ipsec.h                     |   36 +++++-
 5 files changed, 226 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index e926cf24..1198904 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -1758,7 +1758,8 @@ no_frag_or_manip:
 
 set_manipulation:
 		memset(&action, 0, sizeof(action));
-		fill_cls_action_enq(&action, FALSE,
+		fill_cls_action_enq(&action,
+				    (sa->enable_extended_stats)? TRUE: FALSE,
 				    qman_fq_fqid(sa->to_sec_fq), pol_hmd);
 
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
@@ -1913,7 +1914,8 @@ static int update_pre_sec_inbound_table(struct dpa_ipsec_sa *sa,
 
 		/* Complete the parameters for table insert function */
 		memset(&action, 0, sizeof(action));
-		fill_cls_action_enq(&action, FALSE,
+		fill_cls_action_enq(&action,
+			(sa->enable_extended_stats)? TRUE: FALSE,
 			qman_fq_fqid((sa->to_sec_fq)), sa->ipsec_hmd);
 
 		err = dpa_classif_table_insert_entry(table, &tbl_key, &action,
@@ -2459,6 +2461,7 @@ static int copy_sa_params_to_out_sa(struct dpa_ipsec_sa *sa,
 
 	sa->l2_hdr_size = sa_params->l2_hdr_size;
 	sa->enable_stats = sa_params->enable_stats;
+	sa->enable_extended_stats = sa_params->enable_extended_stats;
 #ifdef DEBUG_PARAM
 	/* Printing all the parameters */
 	print_sa_sec_param(sa);
@@ -2616,6 +2619,7 @@ static int copy_sa_params_to_in_sa(struct dpa_ipsec_sa *sa,
 	sa->policy_miss_action = sa_params->sa_in_params.policy_miss_action;
 	sa->l2_hdr_size = sa_params->l2_hdr_size;
 	sa->enable_stats = sa_params->enable_stats;
+	sa->enable_extended_stats = sa_params->enable_extended_stats;
 #ifdef DEBUG_PARAM
 	/* Printing all the parameters */
 	print_sa_sec_param(sa);
@@ -4805,6 +4809,8 @@ int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats)
 		return -EBUSY;
 	}
 
+	memset(sa_stats, 0, sizeof(*sa_stats));
+
 	if (!sa->enable_stats) {
 		pr_err("Statistics are not enabled for SA id %d\n", sa_id);
 		mutex_unlock(&sa->lock);
@@ -4820,12 +4826,158 @@ int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats)
 		sa_stats->packets_count = *(desc + sa->stats_offset / 4 + 1);
 	}
 
+	if (sa->enable_extended_stats) {
+		struct dpa_cls_tbl_entry_stats stats;
+
+		memset(&stats, 0, sizeof(stats));
+
+		if (sa_is_inbound(sa)) { /* Inbound SA */
+			ret = dpa_classif_table_get_entry_stats_by_ref(
+						sa->inbound_sa_td,
+						sa->inbound_hash_entry,
+						&stats);
+			if (ret != 0) {
+				log_err("Failed to acquire total packets "
+					"counter for inbound SA Id=%d.\n",
+					sa_id);
+				mutex_unlock(&sa->lock);
+				return -EINVAL;
+			} else
+				sa_stats->input_packets	= stats.pkts;
+		} else { /* Outbound SA */
+			struct dpa_ipsec_policy_entry *out_policy;
+			struct dpa_ipsec_policy_params *policy_params;
+			struct dpa_ipsec_pre_sec_out_params *psop;
+			int table_idx, td;
+
+			psop = &sa->dpa_ipsec->config.pre_sec_out_params;
+
+			list_for_each_entry(out_policy, &sa->policy_headlist,
+									node) {
+				policy_params = &out_policy->pol_params;
+				if (IP_ADDR_TYPE_IPV4(policy_params->dest_addr))
+					table_idx =
+						GET_POL_TABLE_IDX(
+							policy_params->protocol,
+							IPV4);
+				else
+					table_idx =
+						GET_POL_TABLE_IDX(
+							policy_params->protocol,
+							IPV6);
+				td = psop->table[table_idx].dpa_cls_td;
+				ret = dpa_classif_table_get_entry_stats_by_ref(
+							td,
+							out_policy->entry_id,
+							&stats);
+				if (ret != 0) {
+					log_err("Failed to acquire total "
+						"packets counter for outbound "
+						"SA Id=%d. Failure occured on "
+						"outbound policy table %d "
+						"(td=%d).\n", sa_id, table_idx,
+						td);
+					mutex_unlock(&sa->lock);
+					return -EINVAL;
+				} else
+					sa_stats->input_packets	+= stats.pkts;
+			}
+		}
+	}
+
 	mutex_unlock(&sa->lock);
 
-	return 0;
+	return ret;
 }
 EXPORT_SYMBOL(dpa_ipsec_sa_get_stats);
 
+int dpa_ipsec_get_stats(struct dpa_ipsec_stats *stats)
+{
+	t_FmPcdCcKeyStatistics		miss_stats;
+	struct dpa_cls_tbl_params	table_params;
+	int				i, j, td;
+	t_Error				err;
+	struct dpa_ipsec		*dpa_ipsec;
+
+	dpa_ipsec = gbl_dpa_ipsec;
+
+	if (!stats) {
+		log_err("\"stats\" cannot be NULL.\n");
+		return -EINVAL;
+	}
+
+	memset(stats, 0, sizeof(*stats));
+
+	/* On inbound add up miss counters from all inbound pre-SEC tables: */
+	for (i = 0; i < DPA_IPSEC_MAX_SA_TYPE; i++) {
+		td = dpa_ipsec->config.pre_sec_in_params.dpa_cls_td[i];
+		if (dpa_classif_table_get_params(td, &table_params)) {
+			log_err("Failed to acquire params for inbound table "
+				"type %d (td=%d).\n", i, td);
+			return -EINVAL;
+		}
+		if (table_params.type == DPA_CLS_TBL_HASH)
+			err = FM_PCD_HashTableGetMissStatistics(
+						table_params.cc_node,
+						&miss_stats);
+		else
+			err = FM_PCD_MatchTableGetMissStatistics(
+					table_params.cc_node,
+					&miss_stats);
+		if (err != E_OK) {
+			log_err("Failed to acquire miss statistics for inbound "
+				"table type %d (td=%d, Cc node handle=0x%p).\n",
+				i, td, table_params.cc_node);
+			return -EINVAL;
+		} else {
+			stats->inbound_miss_pkts += miss_stats.frameCount;
+			stats->inbound_miss_bytes += miss_stats.byteCount;
+		}
+	}
+
+	/* On outbound add up miss statistics from all outbound pre-SEC tables: */
+	for (i = 0; i < DPA_IPSEC_MAX_SUPPORTED_PROTOS; i++) {
+		td = dpa_ipsec->config.pre_sec_out_params.table[i].dpa_cls_td;
+		/* Some applications are using the same tables in more than one
+		 * role on the outbound, hence we need check to whether we
+		 * haven't already processed this table: */
+		for (j = 0; j < i; j++) {
+			if (td == dpa_ipsec->config.pre_sec_out_params.
+							table[j].dpa_cls_td)
+				break;
+		}
+
+		if (j < i)
+			continue;
+
+		if (dpa_classif_table_get_params(td, &table_params)) {
+			log_err("Failed to acquire table params for outbound "
+				"proto type #%d (td=%d).\n", i, td);
+			return -EINVAL;
+		}
+		if (table_params.type == DPA_CLS_TBL_HASH)
+			err = FM_PCD_HashTableGetMissStatistics(
+						table_params.cc_node,
+						&miss_stats);
+		else
+			err = FM_PCD_MatchTableGetMissStatistics(
+						table_params.cc_node,
+						&miss_stats);
+		if (err != E_OK) {
+			log_err("Failed to acquire miss statistics for outbound "
+				"proto type %d (td=%d, Cc node handle=0x%p).\n",
+				i, td, table_params.cc_node);
+			return -EINVAL;
+		} else {
+			stats->outbound_miss_pkts += miss_stats.frameCount;
+			stats->outbound_miss_bytes += miss_stats.byteCount;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(dpa_ipsec_get_stats);
+
 int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm)
 {
 	struct dpa_ipsec_sa *sa;
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
index 9f9956f..6ac903e 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.h
@@ -249,6 +249,7 @@ struct dpa_ipsec_sa {
 				* form the CAAM Descriptor length
 				* MAX_CAAM_DESCSIZE			      */
 	bool enable_stats; /* Enable counting packets and bytes processed     */
+	bool enable_extended_stats; /* Enable extended statistics per SA      */
 	bool dscp_copy; /* Enable DSCP propagation support		      */
 	bool ecn_copy; /* Enable DSCP propagation support		      */
 	bool enable_dpovrd; /* Enable DECO Protocol Override Register	      */
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
index 694cb71..b1d5a3d 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_ioctl.h
@@ -300,4 +300,7 @@ struct ioc_compat_dpa_ipsec_sa_modify_prm {
 	     struct ioc_compat_dpa_ipsec_sa_modify_prm)
 #endif
 
+#define DPA_IPSEC_IOC_GET_STATS \
+	_IOR(DPA_IPSEC_IOC_MAGIC, 13, struct dpa_ipsec_stats)
+
 #endif	/* __DPA_IPSEC_IOCTL_H */
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 7b51e97..7b8e37a 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -1315,6 +1315,23 @@ long wrp_dpa_ipsec_do_ioctl(struct file *filp, unsigned int cmd,
 		break;
 	}
 
+	case DPA_IPSEC_IOC_GET_STATS: {
+		struct dpa_ipsec_stats ipsec_stats;
+
+		ret = dpa_ipsec_get_stats(&ipsec_stats);
+		if (ret < 0) {
+			pr_err("Getting stats failed\n");
+			break;
+		}
+
+		if (copy_to_user((struct dpa_ipsec_stats *)args,
+				 &ipsec_stats, sizeof(ipsec_stats))) {
+			pr_err("Could not copy stats to user\n");
+			return -EINVAL;
+		}
+		break;
+	}
+
 	case DPA_IPSEC_IOC_SA_MODIFY: {
 		struct dpa_ipsec_sa_modify_prm modify_prm;
 		int sa_id, ret;
@@ -1484,6 +1501,23 @@ long wrp_dpa_ipsec_do_compat_ioctl(struct file *filp, unsigned int cmd,
 		break;
 	}
 
+	case DPA_IPSEC_IOC_GET_STATS: {
+		struct dpa_ipsec_stats ipsec_stats;
+
+		ret = dpa_ipsec_get_stats(&ipsec_stats);
+		if (ret < 0) {
+			pr_err("Getting stats failed\n");
+			break;
+		}
+
+		if (copy_to_user((struct dpa_ipsec_stats *)args,
+				 &ipsec_stats, sizeof(ipsec_stats))) {
+			pr_err("Could not copy stats to user\n");
+			return -EINVAL;
+		}
+		break;
+	}
+
 	case DPA_IPSEC_IOC_SA_MODIFY: {
 		struct dpa_ipsec_sa_modify_prm modify_prm;
 		int sa_id, ret;
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index c2bf717..ad0c62d 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -337,6 +337,12 @@ struct dpa_ipsec_sa_params {
 	uint8_t sa_bpid;	/* Buffer Pool ID to be used with this SA     */
 	uint16_t sa_bufsize;	/* Buffer Pool buffer size		      */
 	bool	enable_stats;	/* Enable counting packets and bytes processed*/
+	/*
+	 * Enable extended statistics per SA, beside counting IPSec processed
+	 * packets the dpa offload will also count the input packets that
+	 * require IPSec processing.
+	 */
+	bool  enable_extended_stats;
 	struct dpa_ipsec_sa_crypto_params crypto_params;/* IPSec crypto params*/
 	enum dpa_ipsec_direction sa_dir;  /* SA direction: Outbound/Inbound   */
 	union {
@@ -486,15 +492,39 @@ int dpa_ipsec_sa_get_policies(int sa_id,
 /* This function will remove all policies associated with the specified SA */
 int dpa_ipsec_sa_flush_policies(int sa_id);
 
-/* DPA-IPSec Statistics */
+/* DPA-IPSec SA Statistics */
 struct dpa_ipsec_sa_stats {
-	uint32_t packets_count;
-	uint32_t bytes_count;
+	uint32_t packets_count; /* Number of IPSec processed packets */
+	uint32_t bytes_count;   /* Number of IPSec processed bytes   */
+	/*
+	 * Number of packets which required IPSec processing
+	 * for inbound SA: number of packets received
+	 * for outbound SA: number of packets sent
+	 */
+	uint32_t input_packets;
+};
+
+/* DPA-IPSec Global Statistics */
+struct dpa_ipsec_stats {
+	/* Packets that missed inbound SA lookup */
+	uint32_t inbound_miss_pkts;
+
+	/* Bytes that missed inbound SA lookup */
+	uint32_t inbound_miss_bytes;
+
+	/* Packets that missed outbound policy lookup */
+	uint32_t outbound_miss_pkts;
+
+	/* Bytes that missed outbound policy lookup */
+	uint32_t outbound_miss_bytes;
 };
 
 /* This function will populate sa_stats with SEC statistics for SA with sa_id */
 int dpa_ipsec_sa_get_stats(int sa_id, struct dpa_ipsec_sa_stats *sa_stats);
 
+/* Return IPSec global statistics in the "stats" data structure */
+int dpa_ipsec_get_stats(struct dpa_ipsec_stats *stats);
+
 enum dpa_ipsec_sa_modify_type {
 	DPA_IPSEC_SA_MODIFY_ARS = 0, /* Set the anti replay window size	      */
 	DPA_IPSEC_SA_MODIFY_SEQ_NUM, /* Set the sequence number for this SA   */
-- 
1.7.5.4

