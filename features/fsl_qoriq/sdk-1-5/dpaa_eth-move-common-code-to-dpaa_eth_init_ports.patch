From be0c3464cae3645a3a4e0eaf040c9e674d0eeae3 Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Thu, 30 May 2013 15:17:03 +0300
Subject: [PATCH 037/383] dpaa_eth: move common code to dpaa_eth_init_ports()

Create a function dpaa_eth_init_ports() to be used by all
probing functions.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Change-Id: I2b713b2249bf1754a8789d7f269b0e6184a2183a
Reviewed-on: http://git.am.freescale.net:8181/3076
Reviewed-by: Sovaiala Cristian-Constantin-B39531 <Cristian.Sovaiala@freescale.com>
Reviewed-by: Radulescu Ruxandra Ioana-B05472 <ruxandra.radulescu@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |  101 ++++++++++++-------------
 1 files changed, 50 insertions(+), 51 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 7406311..c4a6f0d 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -1625,7 +1625,7 @@ static struct dpa_bp *dpa_size2pool(struct dpa_priv_s *priv, size_t size)
 	return ERR_PTR(-ENODEV);
 }
 
-static void dpa_set_buffer_layout(struct dpa_priv_s *priv, struct fm_port *port,
+static void dpa_set_buffer_layout(struct fm_port *port,
 				  struct dpa_buffer_layout_s *layout, int type)
 {
 	struct fm_port_params params;
@@ -3591,6 +3591,46 @@ dpaa_eth_init_rx_port(struct fm_port *port, struct dpa_bp *bp, size_t count,
 			   buf_layout, frag_enabled);
 }
 
+int dpa_alloc_pcd_fqids(struct device *dev, uint32_t num,
+				uint8_t alignment, uint32_t *base_fqid)
+{
+	dev_crit(dev, "callback not implemented!\n");
+	BUG();
+
+	return 0;
+}
+
+int dpa_free_pcd_fqids(struct device *dev, uint32_t base_fqid)
+{
+
+	dev_crit(dev, "callback not implemented!\n");
+	BUG();
+
+	return 0;
+}
+
+static void
+dpaa_eth_init_ports(struct mac_device *mac_dev,
+		struct dpa_bp *bp, size_t count,
+		struct fm_port_fqs *port_fqs,
+		struct dpa_buffer_layout_s *buf_layout,
+		struct device *dev)
+{
+	struct fm_port_pcd_param rx_port_pcd_param;
+	struct fm_port *rxport = mac_dev->port_dev[RX];
+	struct fm_port *txport = mac_dev->port_dev[TX];
+
+	dpaa_eth_init_tx_port(txport, port_fqs->tx_errq,
+			      port_fqs->tx_defq, &buf_layout[TX]);
+	dpaa_eth_init_rx_port(rxport, bp, count, port_fqs->rx_errq,
+			      port_fqs->rx_defq, &buf_layout[RX]);
+
+	rx_port_pcd_param.cba = dpa_alloc_pcd_fqids;
+	rx_port_pcd_param.cbf = dpa_free_pcd_fqids;
+	rx_port_pcd_param.dev = dev;
+	fm_port_pcd_bind(rxport, &rx_port_pcd_param);
+}
+
 static void dpa_fq_setup(struct dpa_priv_s *priv)
 {
 	struct dpa_fq *fq;
@@ -3801,24 +3841,6 @@ static int dpa_private_netdev_init(struct device_node *dpa_node,
 	return dpa_netdev_init(dpa_node, net_dev);
 }
 
-int dpa_alloc_pcd_fqids(struct device *dev, uint32_t num,
-				uint8_t alignment, uint32_t *base_fqid)
-{
-	dev_crit(dev, "callback not implemented!\n");
-	BUG();
-
-	return 0;
-}
-
-int dpa_free_pcd_fqids(struct device *dev, uint32_t base_fqid)
-{
-
-	dev_crit(dev, "callback not implemented!\n");
-	BUG();
-
-	return 0;
-}
-
 static int dpaa_eth_add_channel(void *__arg)
 {
 	const cpumask_t *cpus = qman_affine_cpus();
@@ -3959,8 +3981,8 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 			dev_err(dev, "devm_kzalloc() failed\n");
 			goto alloc_failed;
 		}
-		dpa_set_buffer_layout(priv, rxport, &buf_layout[RX], RX);
-		dpa_set_buffer_layout(priv, txport, &buf_layout[TX], TX);
+		dpa_set_buffer_layout(rxport, &buf_layout[RX], RX);
+		dpa_set_buffer_layout(txport, &buf_layout[TX], TX);
 	}
 
 	if (is_private) {
@@ -4064,19 +4086,9 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 	}
 
 	/* All real interfaces need their ports initialized */
-	if (!is_macless) {
-		struct fm_port_pcd_param rx_port_pcd_param;
-
-		dpaa_eth_init_tx_port(txport, port_fqs.tx_errq,
-				      port_fqs.tx_defq, &buf_layout[TX]);
-		dpaa_eth_init_rx_port(rxport, dpa_bp, count, port_fqs.rx_errq,
-				      port_fqs.rx_defq, &buf_layout[RX]);
-
-		rx_port_pcd_param.cba = dpa_alloc_pcd_fqids;
-		rx_port_pcd_param.cbf = dpa_free_pcd_fqids;
-		rx_port_pcd_param.dev = dev;
-		fm_port_pcd_bind(rxport, &rx_port_pcd_param);
-	}
+	if (!is_macless)
+		dpaa_eth_init_ports(mac_dev, dpa_bp, count, &port_fqs,
+				buf_layout, dev);
 
 	/* Now we need to initialize either a private or shared interface */
 	priv->percpu_priv = alloc_percpu(*priv->percpu_priv);
@@ -4148,7 +4160,6 @@ dpaa_eth_proxy_probe(struct platform_device *_of_dev)
 	struct dpa_bp *dpa_bp;
 	struct list_head proxy_fq_list;
 	size_t count;
-	struct dpa_priv_s *priv = NULL;
 	struct fm_port_fqs port_fqs;
 	struct fm_port *rxport = NULL;
 	struct fm_port *txport = NULL;
@@ -4183,8 +4194,8 @@ dpaa_eth_proxy_probe(struct platform_device *_of_dev)
 		dev_err(dev, "devm_kzalloc() failed\n");
 		return -ENOMEM;
 	}
-	dpa_set_buffer_layout(priv, rxport, &buf_layout[RX], RX);
-	dpa_set_buffer_layout(priv, txport, &buf_layout[TX], TX);
+	dpa_set_buffer_layout(rxport, &buf_layout[RX], RX);
+	dpa_set_buffer_layout(txport, &buf_layout[TX], TX);
 
 	INIT_LIST_HEAD(&proxy_fq_list);
 
@@ -4194,27 +4205,15 @@ dpaa_eth_proxy_probe(struct platform_device *_of_dev)
 	if (!err)
 		err = dpa_fq_probe_mac(dev, &proxy_fq_list, &port_fqs, false,
 				       TX);
-
 	if (err < 0)
 		return err;
 
 	/* Proxy initializer - Just configures the MAC on behalf of
 	 * another partition.
 	 */
+	dpaa_eth_init_ports(mac_dev, dpa_bp, count, &port_fqs,
+			buf_layout, dev);
 
-	/* All real interfaces need their ports initialized */
-	dpaa_eth_init_tx_port(txport, port_fqs.tx_errq,
-			      port_fqs.tx_defq, &buf_layout[TX]);
-	dpaa_eth_init_rx_port(rxport, dpa_bp, count, port_fqs.rx_errq,
-			      port_fqs.rx_defq, &buf_layout[RX]);
-	{
-		struct fm_port_pcd_param rx_port_pcd_param;
-
-		rx_port_pcd_param.cba = dpa_alloc_pcd_fqids;
-		rx_port_pcd_param.cbf = dpa_free_pcd_fqids;
-		rx_port_pcd_param.dev = dev;
-		fm_port_pcd_bind(rxport, &rx_port_pcd_param);
-	}
 	/* Proxy interfaces need to be started, and the allocated
 	 * memory freed
 	 */
-- 
1.7.5.4

