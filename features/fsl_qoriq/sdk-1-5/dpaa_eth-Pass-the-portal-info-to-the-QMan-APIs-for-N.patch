From 58f6a338a7aaa8162c230c2c629f8fe1e73fe3b9 Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Mon, 30 Sep 2013 13:52:29 -0400
Subject: [PATCH 251/429] dpaa_eth: Pass the portal info to the QMan APIs for
 NAPI scheduling.

Pass the portal info via callbacks in order to call the new qman apis for napi
schedule and napi poll, thus follow the portal to disable its DQRI or enable
DQRI for NAPI, regardless the portal is migrated to other cpu (in hotplug case)
or not.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: Ie79a5ba106726032837299c4c5dd3291e8a10789
Reviewed-on: http://git.am.freescale.net:8181/5454
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c |   15 +++++++++++----
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h |    3 ++-
 2 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 2cc57df..7a2193c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -286,12 +286,15 @@ void __hot _dpa_process_parse_results(const fm_prs_result_t *parse_results,
 
 static int dpaa_eth_poll(struct napi_struct *napi, int budget)
 {
-	int cleaned = qman_poll_dqrr(budget);
+	struct dpa_percpu_priv_s *percpu_priv =
+			container_of(napi, struct dpa_percpu_priv_s, napi);
+
+	int cleaned = qman_p_poll_dqrr(percpu_priv->p, budget);
 
 	if (cleaned < budget) {
 		int tmp;
 		napi_complete(napi);
-		tmp = qman_irqsource_add(QM_PIRQ_DQRI);
+		tmp = qman_p_irqsource_add(percpu_priv->p, QM_PIRQ_DQRI);
 		BUG_ON(tmp);
 	}
 
@@ -350,6 +353,7 @@ priv_rx_error_dqrr(struct qman_portal		*portal,
 	priv = netdev_priv(net_dev);
 
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
+	percpu_priv->p = portal;
 
 	if (dpaa_eth_napi_schedule(percpu_priv))
 		return qman_cb_dqrr_stop;
@@ -383,6 +387,7 @@ priv_rx_default_dqrr(struct qman_portal		*portal,
 
 	/* IRQ handler, non-migratable; safe to use __this_cpu_ptr here */
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
+	percpu_priv->p = portal;
 
 	if (unlikely(dpaa_eth_napi_schedule(percpu_priv)))
 		return qman_cb_dqrr_stop;
@@ -414,6 +419,7 @@ priv_tx_conf_error_dqrr(struct qman_portal		*portal,
 	priv = netdev_priv(net_dev);
 
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
+	percpu_priv->p = portal;
 
 	if (dpaa_eth_napi_schedule(percpu_priv))
 		return qman_cb_dqrr_stop;
@@ -441,6 +447,7 @@ priv_tx_conf_default_dqrr(struct qman_portal		*portal,
 
 	/* Non-migratable context, safe to use __this_cpu_ptr */
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
+	percpu_priv->p = portal;
 
 	if (dpaa_eth_napi_schedule(percpu_priv))
 		return qman_cb_dqrr_stop;
@@ -558,9 +565,9 @@ static void dpaa_eth_poll_controller(struct net_device *net_dev)
 		__this_cpu_ptr(priv->percpu_priv);
 	struct napi_struct napi = percpu_priv->napi;
 
-	qman_irqsource_remove(QM_PIRQ_DQRI);
+	qman_p_irqsource_remove(percpu_priv->p, QM_PIRQ_DQRI);
 	qman_poll_dqrr(napi.weight);
-	qman_irqsource_add(QM_PIRQ_DQRI);
+	qman_p_irqsource_add(percpu_priv->p, QM_PIRQ_DQRI);
 }
 #endif
 
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 3e953f0..25fa3a2 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -401,6 +401,7 @@ struct dpa_ern_cnt {
 struct dpa_percpu_priv_s {
 	struct net_device *net_dev;
 	struct napi_struct napi;
+	struct qman_portal *p;
 	u64 in_interrupt;
 	u64 tx_returned;
 	u64 tx_confirm;
@@ -525,7 +526,7 @@ static inline int dpaa_eth_napi_schedule(struct dpa_percpu_priv_s *percpu_priv)
 	 */
 	if (unlikely(in_irq() || !in_serving_softirq())) {
 		/* Disable QMan IRQ and invoke NAPI */
-		int ret = qman_irqsource_remove(QM_PIRQ_DQRI);
+		int ret = qman_p_irqsource_remove(percpu_priv->p, QM_PIRQ_DQRI);
 		if (likely(!ret)) {
 			napi_schedule(&percpu_priv->napi);
 			percpu_priv->in_interrupt++;
-- 
1.7.5.4

