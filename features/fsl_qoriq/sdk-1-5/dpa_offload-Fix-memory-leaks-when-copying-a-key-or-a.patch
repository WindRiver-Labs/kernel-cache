From 3b622fb383a18f65f4a48481c0a9d30958ba12f1 Mon Sep 17 00:00:00 2001
From: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Date: Wed, 9 Oct 2013 16:48:58 +0300
Subject: [PATCH 252/429] dpa_offload: Fix memory leaks when copying a key or
 a pair of keys

Fix the functions responsible of copying a key or a pair of keys
from user-space provided pointers to kernel allocated memory so
that they release the allocated memory in case of error.

Change-Id: I6ade94ea120667832d4ac49e39b24d17177caa24
Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/5443
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |   39 ++++++++++++++++-------
 1 files changed, 27 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 33ad20d..5af06d1 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -669,7 +669,6 @@ static int do_ioctl_stats_create_counter(void *args)
 			&prm.cnt_params.classif_node_params.key);
 		if (ret != 0) {
 			log_err("Could not copy the key descriptor\n");
-			kfree(prm.cnt_params.classif_node_params.key);
 			return ret;
 		}
 	}
@@ -684,7 +683,6 @@ static int do_ioctl_stats_create_counter(void *args)
 			&prm.cnt_params.classif_tbl_params.key);
 		if (ret != 0) {
 			log_err("Could not copy the key descriptor\n");
-			kfree(prm.cnt_params.classif_tbl_params.key);
 			return ret;
 		}
 	}
@@ -1024,6 +1022,7 @@ create_cls_counter_cleanup:
 				kfree(tbl->keys[i]->mask);
 				kfree(tbl->keys[i]);
 			}
+			kfree(tbl->keys);
 			/* Restore user-space pointers */
 			tbl->keys = us_keys;
 		}
@@ -1038,15 +1037,16 @@ create_cls_counter_cleanup:
 					kfree(tbl->pairs[i]->first_key->mask);
 					kfree(tbl->pairs[i]->first_key);
 				}
-
 				if (tbl->pairs[i]->second_key) {
 					kfree(tbl->pairs[i]->second_key->byte);
 					kfree(tbl->pairs[i]->second_key->mask);
 					kfree(tbl->pairs[i]->second_key);
 				}
+				kfree(tbl->pairs[i]);
 			}
+			kfree(tbl->pairs);
 			/* Restore user-space pointers */
-			tbl->keys = us_keys;
+			tbl->pairs = us_pairs;
 		}
 		break;
 	case DPA_STATS_CNT_CLASSIF_NODE:
@@ -1060,13 +1060,13 @@ create_cls_counter_cleanup:
 			kfree(cnode->keys[i]->mask);
 			kfree(cnode->keys[i]);
 		}
+		kfree(cnode->keys);
 		/* Restore user-space pointers */
 		cnode->keys = us_keys;
 		break;
 	case DPA_STATS_CNT_IPSEC:
 		kfree(sa_ids);
 		break;
-
 	default:
 		break;
 	}
@@ -1185,6 +1185,8 @@ compat_create_cls_counter_cleanup:
 				&kprm_cls->classif_tbl_params;
 
 		if (tbl->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
+			if (!tbl->keys)
+				break;
 			for (i = 0; i < kprm_cls->class_members; i++) {
 				if (!tbl->keys[i])
 					continue;
@@ -1195,6 +1197,8 @@ compat_create_cls_counter_cleanup:
 			kfree(tbl->keys);
 
 		} else if (tbl->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
+			if (!tbl->pairs)
+				break;
 			for (i = 0; i < kprm_cls->class_members; i++) {
 				if (!tbl->pairs[i])
 					continue;
@@ -1215,6 +1219,8 @@ compat_create_cls_counter_cleanup:
 		break;
 	}
 	case DPA_STATS_CNT_CLASSIF_NODE:
+		if (!kprm_cls->classif_node_params.keys)
+			break;
 		for (i = 0; i < kprm_cls->class_members; i++) {
 			if (!kprm_cls->classif_node_params.keys[i])
 					continue;
@@ -1261,9 +1267,8 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 		ret = copy_key_descriptor(us_key, &prm.params.key);
 		if (ret != 0) {
 			log_err("Could not copy the key descriptor\n");
-			goto modify_counter_cleanup;
+			return ret;
 		}
-
 		break;
 	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
 		if (!prm.params.pair)
@@ -1276,7 +1281,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 		ret = copy_pair_descriptor(us_pair, &prm.params.pair);
 		if (ret != 0) {
 			log_err("Could not copy the pair key descriptor\n");
-			goto modify_counter_cleanup;
+			return ret;
 		}
 		break;
 	case DPA_STATS_CLS_MEMBER_SA_ID:
@@ -1287,7 +1292,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 
 	ret = dpa_stats_modify_class_counter(prm.cnt_id,
 					     &prm.params, prm.member_index);
-modify_counter_cleanup:
+
 	switch (prm.params.type) {
 	case DPA_STATS_CLS_MEMBER_SINGLE_KEY:
 		if (prm.params.key) {
@@ -1363,7 +1368,7 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 				uprm.params.key);
 		if (ret < 0) {
 			log_err("Cannot copy the key descriptor\n");
-			goto compat_modify_counter_cleanup;
+			return ret;
 		}
 		break;
 	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
@@ -1381,10 +1386,9 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 		ret = copy_pair_descriptor_compatcpy(&kprm.params.pair, pair);
 		if (ret < 0) {
 			log_err("Cannot copy the pair key descriptor\n");
-			goto compat_modify_counter_cleanup;
+			return ret;
 		}
 		break;
-
 	case DPA_STATS_CLS_MEMBER_SA_ID:
 		kprm.params.sa_id = uprm.params.sa_id;
 		break;
@@ -1924,6 +1928,7 @@ static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 		if (!tmp->byte) {
 			log_err("Cannot allocate memory for key "
 				"descriptor byte\n");
+			kfree(tmp);
 			return -ENOMEM;
 		}
 
@@ -1988,6 +1993,10 @@ static int copy_pair_descriptor(struct dpa_offload_lookup_key_pair *src,
 		ret = copy_key_descriptor(src->second_key, &tmp->second_key);
 		if (ret != 0) {
 			log_err("Could not copy the second key descriptor\n");
+			if (tmp->first_key) {
+				kfree(tmp->first_key->byte);
+				kfree(tmp->first_key->mask);
+			}
 			kfree(tmp);
 			return ret;
 		}
@@ -2092,6 +2101,10 @@ static int copy_pair_descriptor_compatcpy(
 					&kpair->second_key, pair.second_key);
 		if (ret != 0) {
 			log_err("Cannot copy second key of the pair\n");
+			if (kpair->first_key) {
+				kfree(kpair->first_key->byte);
+				kfree(kpair->first_key->mask);
+			}
 			kfree(kpair);
 			return ret;
 		}
@@ -2413,12 +2426,14 @@ static long dpa_stats_tbl_cls_compatcpy(
 			if (!kprm->pairs[i]) {
 				log_err("Cannot allocate kernel memory for pair"
 					" descriptor\n");
+				kfree(us_keys);
 				return -ENOMEM;
 			}
 
 			if (copy_from_user(&pair, compat_ptr(us_keys[i]),
 					   (sizeof(pair)))) {
 				log_err("Cannot copy pair descriptor\n");
+				kfree(us_keys);
 				return -EBUSY;
 			}
 
-- 
1.7.5.4

