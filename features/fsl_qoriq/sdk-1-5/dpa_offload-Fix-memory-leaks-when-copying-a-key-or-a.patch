From 084d6348e8901826cc38c0c774cc831c3f487546 Mon Sep 17 00:00:00 2001
From: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Date: Wed, 9 Oct 2013 16:48:58 +0300
Subject: [PATCH 213/383] dpa_offload: Fix memory leaks when copying a key or
 a pair of keys

Fix the functions responsible of copying a key or a pair of keys
from user-space provided pointers to kernel allocated memory so
that they release the allocated memory in case of error.

Change-Id: I6ade94ea120667832d4ac49e39b24d17177caa24
Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/5443
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Aurelian Zanoschi <Aurelian.Zanoschi@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c |   39 ++++++++++++++++-------
 1 files changed, 27 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
index 6aa639f..576846c 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_stats.c
@@ -671,7 +671,6 @@ static int do_ioctl_stats_create_counter(void *args)
 			&prm.cnt_params.classif_node_params.key);
 		if (ret != 0) {
 			log_err("Could not copy the key descriptor\n");
-			kfree(prm.cnt_params.classif_node_params.key);
 			return ret;
 		}
 	}
@@ -686,7 +685,6 @@ static int do_ioctl_stats_create_counter(void *args)
 			&prm.cnt_params.classif_tbl_params.key);
 		if (ret != 0) {
 			log_err("Could not copy the key descriptor\n");
-			kfree(prm.cnt_params.classif_tbl_params.key);
 			return ret;
 		}
 	}
@@ -1026,6 +1024,7 @@ create_cls_counter_cleanup:
 				kfree(tbl->keys[i]->mask);
 				kfree(tbl->keys[i]);
 			}
+			kfree(tbl->keys);
 			/* Restore user-space pointers */
 			tbl->keys = us_keys;
 		}
@@ -1040,15 +1039,16 @@ create_cls_counter_cleanup:
 					kfree(tbl->pairs[i]->first_key->mask);
 					kfree(tbl->pairs[i]->first_key);
 				}
-
 				if (tbl->pairs[i]->second_key) {
 					kfree(tbl->pairs[i]->second_key->byte);
 					kfree(tbl->pairs[i]->second_key->mask);
 					kfree(tbl->pairs[i]->second_key);
 				}
+				kfree(tbl->pairs[i]);
 			}
+			kfree(tbl->pairs);
 			/* Restore user-space pointers */
-			tbl->keys = us_keys;
+			tbl->pairs = us_pairs;
 		}
 		break;
 	case DPA_STATS_CNT_CLASSIF_NODE:
@@ -1062,13 +1062,13 @@ create_cls_counter_cleanup:
 			kfree(cnode->keys[i]->mask);
 			kfree(cnode->keys[i]);
 		}
+		kfree(cnode->keys);
 		/* Restore user-space pointers */
 		cnode->keys = us_keys;
 		break;
 	case DPA_STATS_CNT_IPSEC:
 		kfree(sa_ids);
 		break;
-
 	default:
 		break;
 	}
@@ -1187,6 +1187,8 @@ compat_create_cls_counter_cleanup:
 				&kprm_cls->classif_tbl_params;
 
 		if (tbl->key_type == DPA_STATS_CLASSIF_SINGLE_KEY) {
+			if (!tbl->keys)
+				break;
 			for (i = 0; i < kprm_cls->class_members; i++) {
 				if (!tbl->keys[i])
 					continue;
@@ -1197,6 +1199,8 @@ compat_create_cls_counter_cleanup:
 			kfree(tbl->keys);
 
 		} else if (tbl->key_type == DPA_STATS_CLASSIF_PAIR_KEY) {
+			if (!tbl->pairs)
+				break;
 			for (i = 0; i < kprm_cls->class_members; i++) {
 				if (!tbl->pairs[i])
 					continue;
@@ -1217,6 +1221,8 @@ compat_create_cls_counter_cleanup:
 		break;
 	}
 	case DPA_STATS_CNT_CLASSIF_NODE:
+		if (!kprm_cls->classif_node_params.keys)
+			break;
 		for (i = 0; i < kprm_cls->class_members; i++) {
 			if (!kprm_cls->classif_node_params.keys[i])
 					continue;
@@ -1263,9 +1269,8 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 		ret = copy_key_descriptor(us_key, &prm.params.key);
 		if (ret != 0) {
 			log_err("Could not copy the key descriptor\n");
-			goto modify_counter_cleanup;
+			return ret;
 		}
-
 		break;
 	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
 		if (!prm.params.pair)
@@ -1278,7 +1283,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 		ret = copy_pair_descriptor(us_pair, &prm.params.pair);
 		if (ret != 0) {
 			log_err("Could not copy the pair key descriptor\n");
-			goto modify_counter_cleanup;
+			return ret;
 		}
 		break;
 	case DPA_STATS_CLS_MEMBER_SA_ID:
@@ -1289,7 +1294,7 @@ static int do_ioctl_stats_modify_class_counter(void *args)
 
 	ret = dpa_stats_modify_class_counter(prm.cnt_id,
 					     &prm.params, prm.member_index);
-modify_counter_cleanup:
+
 	switch (prm.params.type) {
 	case DPA_STATS_CLS_MEMBER_SINGLE_KEY:
 		if (prm.params.key) {
@@ -1365,7 +1370,7 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 				uprm.params.key);
 		if (ret < 0) {
 			log_err("Cannot copy the key descriptor\n");
-			goto compat_modify_counter_cleanup;
+			return ret;
 		}
 		break;
 	case DPA_STATS_CLS_MEMBER_PAIR_KEY:
@@ -1383,10 +1388,9 @@ static int do_ioctl_stats_compat_modify_class_counter(void *args)
 		ret = copy_pair_descriptor_compatcpy(&kprm.params.pair, pair);
 		if (ret < 0) {
 			log_err("Cannot copy the pair key descriptor\n");
-			goto compat_modify_counter_cleanup;
+			return ret;
 		}
 		break;
-
 	case DPA_STATS_CLS_MEMBER_SA_ID:
 		kprm.params.sa_id = uprm.params.sa_id;
 		break;
@@ -1927,6 +1931,7 @@ static int copy_key_descriptor(struct dpa_offload_lookup_key *src,
 		if (!tmp->byte) {
 			log_err("Cannot allocate memory for key "
 				"descriptor byte\n");
+			kfree(tmp);
 			return -ENOMEM;
 		}
 
@@ -1991,6 +1996,10 @@ static int copy_pair_descriptor(struct dpa_offload_lookup_key_pair *src,
 		ret = copy_key_descriptor(src->second_key, &tmp->second_key);
 		if (ret != 0) {
 			log_err("Could not copy the second key descriptor\n");
+			if (tmp->first_key) {
+				kfree(tmp->first_key->byte);
+				kfree(tmp->first_key->mask);
+			}
 			kfree(tmp);
 			return ret;
 		}
@@ -2095,6 +2104,10 @@ static int copy_pair_descriptor_compatcpy(
 					&kpair->second_key, pair.second_key);
 		if (ret != 0) {
 			log_err("Cannot copy second key of the pair\n");
+			if (kpair->first_key) {
+				kfree(kpair->first_key->byte);
+				kfree(kpair->first_key->mask);
+			}
 			kfree(kpair);
 			return ret;
 		}
@@ -2416,12 +2429,14 @@ static long dpa_stats_tbl_cls_compatcpy(
 			if (!kprm->pairs[i]) {
 				log_err("Cannot allocate kernel memory for pair"
 					" descriptor\n");
+				kfree(us_keys);
 				return -ENOMEM;
 			}
 
 			if (copy_from_user(&pair, compat_ptr(us_keys[i]),
 					   (sizeof(pair)))) {
 				log_err("Cannot copy pair descriptor\n");
+				kfree(us_keys);
 				return -EBUSY;
 			}
 
-- 
1.7.5.4

