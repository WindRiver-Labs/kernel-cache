From e2874f68c1e7987e72657cd0ebaa3b227f8a07c2 Mon Sep 17 00:00:00 2001
From: Andrei Varvara <andrei.varvara@freescale.com>
Date: Thu, 24 Oct 2013 12:28:49 +0300
Subject: [PATCH 261/383] dpa_offload: Improve completion message when Modify
 SA function is called

Before this patch the modify SA descriptor is setting only the SA id
in the output frame, this was enough when  only the Anti Replay Window
could be modified. If adding the other types of change line SEQ_NUM or
EXT_SEQ_NUM than the SA id is insufficient because the user
will not know what operation has finished on the SA with the ID specified in the frame.

Improvement: an operation code and the SA id are added inside the output FD
created by SEC engine. The code is highligting the operation
that took place on the SA with that ID.

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Change-Id: I62e5497422797257a4d5e658703658b278f553b4
Reviewed-on: http://git.am.freescale.net:8181/6036
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Marian-Cornel Chereji <marian.chereji@freescale.com>
Reviewed-by: Thomas Trefny <Tom.Trefny@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c      |   20 ++++++--
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c |   61 ++++++++++++++++-----
 drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h |    3 +-
 include/linux/fsl_dpa_ipsec.h                    |   39 ++++++++++++++
 4 files changed, 103 insertions(+), 20 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 3927e59..3eaefec 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -4979,6 +4979,8 @@ int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm)
 	dma_addr_t dma_rjobd;
 	uint32_t *rjobd;
 	struct qm_fd fd;
+	char msg[5];
+	const size_t msg_len = 5;
 	int ret;
 
 	if (!modify_prm) {
@@ -5000,9 +5002,13 @@ int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm)
 
 	BUG_ON(!sa->dpa_ipsec);
 
+	/* Set the SA id in the message that will be in the output SEC frame */
+	*(u32 *)(&msg[1]) = sa->id;
+
 	switch (modify_prm->type) {
 	case DPA_IPSEC_SA_MODIFY_ARS:
-		ret = build_rjob_desc_ars_update(sa, modify_prm->arw);
+		msg[0] = DPA_IPSEC_SA_MODIFY_ARS_DONE;
+		ret = build_rjob_desc_ars_update(sa, modify_prm->arw, msg_len);
 		if (ret < 0)
 			return ret;
 		break;
@@ -5022,11 +5028,16 @@ int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm)
 	}
 
 	rjobd = sa->rjob_desc;
+
+	/* Copy completion message to the end of the RJOB */
+	memcpy(((char *)rjobd) + desc_len(rjobd) * CAAM_CMD_SZ, msg, msg_len);
+
 	dma_rjobd = dma_map_single(sa->dpa_ipsec->jrdev, rjobd,
-				   desc_len(rjobd) * CAAM_CMD_SZ,
+				   desc_len(rjobd) * CAAM_CMD_SZ + msg_len,
 				   DMA_BIDIRECTIONAL);
 	if (!dma_rjobd) {
 		pr_err("Failed DMA mapping the RJD for SA %d\n", sa->id);
+		mutex_unlock(&sa->lock);
 		return -ENXIO;
 	}
 
@@ -5034,7 +5045,7 @@ int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm)
 	/* fill frame descriptor parameters */
 	fd.format = qm_fd_contig;
 	qm_fd_addr_set64(&fd, dma_rjobd);
-	fd.length20 = desc_len(rjobd) * sizeof(uint32_t);
+	fd.length20 = desc_len(rjobd) * sizeof(uint32_t) + msg_len;
 	fd.offset = 0;
 	fd.bpid = 0;
 	fd.cmd = FD_CMD_REPLACE_JOB_DESC;
@@ -5045,7 +5056,8 @@ int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm)
 	}
 
 	dma_unmap_single(sa->dpa_ipsec->jrdev, dma_rjobd,
-			 desc_len(rjobd) * CAAM_CMD_SZ, DMA_BIDIRECTIONAL);
+			 desc_len(rjobd) * CAAM_CMD_SZ + msg_len,
+			 DMA_BIDIRECTIONAL);
 
 	mutex_unlock(&sa->lock);
 
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
index 1ae08f9..7e2ec0e 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.c
@@ -1472,17 +1472,17 @@ done_shared_desc:
 
 /*
  * Create descriptor for updating the anti replay window size
- * [21] B0951A17       jobhdr: shrsz=21 shr share=serial reo len=23
- * [22] 00000000               sharedesc->@0x02abb5008
- * [23] 2ABB5008
+ * [21] B0951A1D       jobhdr: shrsz=21 shr share=serial reo len=29
+ * [22] 00000000               sharedesc->@0x029a9a608
+ * [23] 29A9A608
  * [24] 79340008         move: descbuf+0[00] -> math0, len=8 wait
  * [25] A82CC108         math: (0 - 1)->math1 len=8
  * [26] AC214108         math: (math1 - imm1)->math1 len=8 ifb
  * [27] 000000C0               imm1=192
  * [28] A8501008         math: (math0 & math1)->math0 len=8
  * [29] 1640180A           ld: deco-descbuf len=10 offs=24
- * [30] 00000000               ptr->@0x02abb5434
- * [31] 2ABB5434
+ * [30] 00000000               ptr->@0x02965ca34
+ * [31] 2965CA34
  * [32] A1001001         jump: jsl1 all-match[calm] offset=1 local->[33]
  * [33] A00000F7         jump: all-match[] always-jump offset=-9 local->[24]
  * [34] AC404008         math: (math0 | imm1)->math0 len=8 ifb
@@ -1490,13 +1490,23 @@ done_shared_desc:
  * [36] 79430008         move: math0 -> descbuf+0[00], len=8 wait
  * [37] 79631804         move: math2 -> descbuf+24[06], len=4 wait
  * [38] 56420107          str: deco-shrdesc+1 len=7
- * [39] A8034304         math: (math3 + imm1)->math3 len=4
- * [40] 00000000               imm1=0
- * [41] 78720008         move: math3+0 -> ofifo, len=8
- * [42] 68300008	 seqfifostr: msgdata len=8
- * [43] A1C01002         jump: jsl1 all-match[calm] halt-user status=2
+ * [39] 16401806           ld: deco-descbuf len=6 offs=24
+ * [40] 00000000               ptr->@0x02965ca5c
+ * [41] 2965CA5C
+ * [42] A1001001         jump: jsl1 all-match[calm] offset=1 local->[43]
+ * [43] A00000F7         jump: all-match[] always-jump offset=-9 local->[34]
+ * [44] 16860800           ld: deco-ctrl len=0 offs=8 imm -auto-nfifo-entries
+ * [45] 2E17000A    seqfifold: both msgdata-last2-last1-flush1 len=10
+ * [46] 16860400           ld: deco-ctrl len=0 offs=4 imm +auto-nfifo-entries
+ * [47] 7882000A         move: ififo->deco-alnblk -> ofifo, len=10
+ * [48] 6830000A   seqfifostr: msgdata len=10
+ * [49] A1C01002         jump: jsl1 all-match[calm] halt-user status=2
+ *
+ * The msg_len represent the length of the message written in the output frame
+ * in order to differentiate between modify operations
  */
-int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw)
+int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw,
+			       u32 msg_len)
 {
 	uint32_t *desc, *rjobd, off;
 	uint8_t options;
@@ -1633,13 +1643,34 @@ int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw)
 		     LDST_CLASS_DECO | (1 << LDST_OFFSET_SHIFT) |
 		     LDST_SRCDST_WORD_DESCBUF_SHARED);
 
-	append_math_add_imm_u32(rjobd, REG3, REG3, IMM, sa->id);
+	append_load(rjobd,
+		    virt_to_phys((void *)(rjobd + 3 + 5 + 3 + 1 + 1 + 10)), 6,
+		    LDST_CLASS_DECO | LDST_SRCDST_WORD_DESCBUF |
+		    ((desc_len(sa->sec_desc->desc) + 3) << LDST_OFFSET_SHIFT));
 
-	/* move: ififo->deco-alnblk -> ofifo, len=4 */
-	append_move(rjobd, MOVE_SRC_MATH3 | MOVE_DEST_OUTFIFO | 8);
+	/* wait for completion of the previous operation */
+	append_jump(rjobd, JUMP_COND_CALM | (1 << JUMP_OFFSET_SHIFT));
+
+	/* jump back to remaining descriptor i.e jump back 9 words */
+	off = (-9) & 0x000000FF;
+	append_jump(rjobd, (off << JUMP_OFFSET_SHIFT));
+
+	/* ld: deco-deco-ctrl len=0 offs=8 imm -auto-nfifo-entries */
+	append_cmd(rjobd, CMD_LOAD | DISABLE_AUTO_INFO_FIFO);
+
+	/* seqfifold: both msgdata-last2-last1-flush1 len=4 */
+	append_seq_fifo_load(rjobd, msg_len, FIFOLD_TYPE_MSG |
+			     FIFOLD_CLASS_BOTH | FIFOLD_TYPE_LAST1 |
+			     FIFOLD_TYPE_LAST2 | FIFOLD_TYPE_FLUSH1);
+
+	/* ld: deco-deco-ctrl len=0 offs=4 imm +auto-nfifo-entries */
+	append_cmd(rjobd, CMD_LOAD | ENABLE_AUTO_INFO_FIFO);
+
+	/* message "Modify anti replay window for SA n" */
+	append_move(rjobd, MOVE_SRC_INFIFO | MOVE_DEST_OUTFIFO | msg_len);
 
 	/* seqfifostr: msgdata len=4 */
-	append_seq_fifo_store(rjobd, FIFOST_TYPE_MESSAGE_DATA, 8);
+	append_seq_fifo_store(rjobd, FIFOST_TYPE_MESSAGE_DATA, msg_len);
 
 	/*
 	 * Exit replacement job descriptor, halt with user error
diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
index 16edff4..b0829dd 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec_desc.h
@@ -90,6 +90,7 @@ struct sec_descriptor {
 int get_sec_info(struct dpa_ipsec *dpa_ipsec);
 int create_sec_descriptor(struct dpa_ipsec_sa *sa);
 int generate_split_key(struct auth_params *auth_param);
-int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw);
+int build_rjob_desc_ars_update(struct dpa_ipsec_sa *sa, enum dpa_ipsec_arw arw,
+			       u32 msg_len);
 
 #endif	/* _DPA_IPSEC_DESC_H_ */
diff --git a/include/linux/fsl_dpa_ipsec.h b/include/linux/fsl_dpa_ipsec.h
index ad0c62d..0fd1456 100644
--- a/include/linux/fsl_dpa_ipsec.h
+++ b/include/linux/fsl_dpa_ipsec.h
@@ -533,6 +533,8 @@ enum dpa_ipsec_sa_modify_type {
 };
 
 struct dpa_ipsec_sa_modify_prm {
+
+	/* Use to select a modify operation */
 	enum dpa_ipsec_sa_modify_type type;
 	union {
 		enum dpa_ipsec_arw arw;
@@ -542,6 +544,43 @@ struct dpa_ipsec_sa_modify_prm {
 	};
 };
 
+/*
+ * Modify an SA asynchronous
+ *
+ * SEC will dequeue a frame with RDJ, run it and after this create an
+ * output frame with status of user error. The frame will have always the
+ * length of 5 bytes, first one representing the operation code that has
+ * finished and the next 4 will determine the SA id on which the operation took
+ * place.
+ *
+ * Returned error code:
+ *	0 if successful;
+ *	-EBUSY if can't acquire lock for this SA
+ *	-EINVAL if input parameters are wrong
+ *	-ENXIO if failed to DMA map Replacement Job Descriptor or SHD
+ *	-ETXTBSY if failed to enqueue to SEC the FD with RJD
+ *	-EALREADY if ARS is already set to the required value
+ *
+ */
 int dpa_ipsec_sa_modify(int sa_id, struct dpa_ipsec_sa_modify_prm *modify_prm);
+/*
+ * The dpa_ipsec_sa_modify and dpa_ipsec_sa_get_seq_number are asynchronous
+ * operations.
+ *
+ * When finished the frame exiting the SEC will have the status
+ * of user error and inside the frame (total length 5 bytes) the first byte will
+ * be the code of the operation that has finished followed by the SA id in the
+ * next 4 bytes.
+ *
+ * Use this enumeration to know what asynchronous operation has finished and on
+ * what SA.
+ */
+enum dpa_ipsec_sa_operation_code {
+	DPA_IPSEC_SA_MODIFY_ARS_DONE = 0,
+	DPA_IPSEC_SA_MODIFY_SEQ_NUM_DONE,
+	DPA_IPSEC_SA_MODIFY_EXT_SEQ_NUM_DONE,
+	DPA_IPSEC_SA_MODIFY_CRYPTO_DONE,
+	DPA_IPSEC_SA_GET_SEQ_NUM_DONE
+};
 
 #endif	/* __FSL_DPA_IPSEC_H */
-- 
1.7.5.4

