From 32b9fbb56d53a6e8aefe4bc6042cdc216172c504 Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Wed, 28 Aug 2013 15:26:36 +0300
Subject: [PATCH 217/429] dpaa_eth: Add Kconfig debug option

Add a Kconfig option that enables debug support in the driver.
For a start, move (most of) the BUG_ON()'s in the driver's fastpath
under this debug option.
New debug information (such as trace events, frame content dumps, etc)
can be added later under the same umbrella.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: I8023a75751cdad9e80d96957b9071f707a03e2b2
Reviewed-on: http://git.am.freescale.net:8181/4839
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[origin patch is from QorIQ-SDK-V1.5-20131219-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/Kconfig       |    7 ++++
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h    |    6 ++++
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c |   33 +++++++++++----------
 3 files changed, 30 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/Kconfig b/drivers/net/ethernet/freescale/dpa/Kconfig
index c416d5d..92506ee 100644
--- a/drivers/net/ethernet/freescale/dpa/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/Kconfig
@@ -127,3 +127,10 @@ config FSL_DPAA_ETH_DEBUGFS
 	default y
 	---help---
 	  This option compiles debugfs code for the DPAA Ethernet driver.
+
+config FSL_DPAA_ETH_DEBUG
+	bool "DPAA Ethernet Debug Support"
+	depends on FSL_DPAA_ETH
+	default n
+	---help---
+	  This option compiles debug code for the DPAA Ethernet driver.
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 1d18364..3e953f0 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -84,6 +84,12 @@ struct dpa_buffer_layout_s {
 	uint16_t	data_align;
 };
 
+#ifdef CONFIG_FSL_DPAA_ETH_DEBUG
+#define DPA_BUG_ON(cond)	BUG_ON(cond)
+#else
+#define DPA_BUG_ON(cond)
+#endif
+
 #define DPA_TX_PRIV_DATA_SIZE	16
 #define DPA_PARSE_RESULTS_SIZE sizeof(fm_prs_result_t)
 #define DPA_TIME_STAMP_SIZE 8
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 4c77d42..19be0ec 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -237,7 +237,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 		/* remaining pages were mapped with dma_map_page() */
 		for (i = 1; i < nr_frags; i++) {
-			BUG_ON(sgt[i].extension);
+			DPA_BUG_ON(sgt[i].extension);
 
 			dma_unmap_page(dpa_bp->dev, sgt[i].addr,
 					sgt[i].length, dma_dir);
@@ -342,7 +342,7 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	struct sk_buff *skb = NULL;
 
 	vaddr = phys_to_virt(addr);
-	BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
+	DPA_BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
 
 	/* do we need the timestamp for bad frames? */
 #ifdef CONFIG_FSL_DPAA_1588
@@ -363,7 +363,7 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	if (unlikely(!skb))
 		return NULL;
 
-	BUG_ON(fd_off != priv->rx_headroom);
+	DPA_BUG_ON(fd_off != priv->rx_headroom);
 	skb_reserve(skb, fd_off);
 	skb_put(skb, dpa_fd_length(fd));
 
@@ -405,7 +405,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 	int *count_ptr;
 
 	vaddr = phys_to_virt(addr);
-	BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
+	DPA_BUG_ON(!IS_ALIGNED((unsigned long)vaddr, SMP_CACHE_BYTES));
 #ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
 		dpa_ptp_store_rxstamp(priv, skb, vaddr);
@@ -420,15 +420,16 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 	sgt = vaddr + fd_off;
 	for (i = 0; i < DPA_SGT_MAX_ENTRIES; i++) {
 		/* Extension bit is not supported */
-		BUG_ON(sgt[i].extension);
+		DPA_BUG_ON(sgt[i].extension);
 
 		dpa_bp = dpa_bpid2pool(sgt[i].bpid);
-		BUG_ON(!dpa_bp);
+		DPA_BUG_ON(!dpa_bp);
 		count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 
 		sg_addr = qm_sg_addr(&sgt[i]);
 		sg_vaddr = phys_to_virt(sg_addr);
-		BUG_ON(!IS_ALIGNED((unsigned long)sg_vaddr, SMP_CACHE_BYTES));
+		DPA_BUG_ON(!IS_ALIGNED((unsigned long)sg_vaddr,
+				SMP_CACHE_BYTES));
 
 		if (i == 0) {
 			/* Tentatively access the first buffer, but don't unmap
@@ -464,7 +465,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 			/* Make sure forwarded skbs will have enough space
 			 * on Tx, if extra headers are added.
 			 */
-			BUG_ON(fd_off != priv->rx_headroom);
+			DPA_BUG_ON(fd_off != priv->rx_headroom);
 			skb_reserve(skb, fd_off);
 			skb_put(skb, sgt[i].length);
 		} else {
@@ -506,7 +507,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 
 	/* recycle the SGT fragment */
 	dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(!dpa_bp);
+	DPA_BUG_ON(!dpa_bp);
 	dpa_bp_recycle_frag(dpa_bp, (unsigned long)vaddr);
 	return skb;
 }
@@ -536,7 +537,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	}
 
 	dpa_bp = dpa_bpid2pool(fd->bpid);
-	BUG_ON(!dpa_bp);
+	DPA_BUG_ON(!dpa_bp);
 	count_ptr = __this_cpu_ptr(dpa_bp->percpu_count);
 	/* Prepare to read from the buffer, but don't unmap it until
 	 * we know the skb allocation succeeded. At this point we already
@@ -548,13 +549,12 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	/* prefetch the first 64 bytes of the frame or the SGT start */
 	prefetch(phys_to_virt(addr) + dpa_fd_offset(fd));
 
+	/* The only FD types that we may receive are contig and S/G */
+	DPA_BUG_ON((fd->format != qm_fd_contig) && (fd->format != qm_fd_sg));
 	if (likely(fd->format == qm_fd_contig))
 		skb = contig_fd_to_skb(priv, fd, &use_gro);
-	else if (fd->format == qm_fd_sg)
-		skb = sg_fd_to_skb(priv, fd, &use_gro);
 	else
-		/* The only FD types that we may receive are contig and S/G */
-		BUG();
+		skb = sg_fd_to_skb(priv, fd, &use_gro);
 	if (unlikely(!skb))
 		/* We haven't yet touched the DMA mapping or the pool count;
 		 * dpa_fd_release() will just put the buffer back in the pool
@@ -637,7 +637,7 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 		 */
 		fd->cmd |= FM_FD_CMD_FCO;
 		fd->bpid = dpa_bp->bpid;
-		BUG_ON(skb->data - buffer_start > DPA_MAX_FD_OFFSET);
+		DPA_BUG_ON(skb->data - buffer_start > DPA_MAX_FD_OFFSET);
 		fd->offset = (uint16_t)(skb->data - buffer_start);
 		dma_dir = DMA_BIDIRECTIONAL;
 	} else
@@ -748,12 +748,13 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	for (i = 1; i <= nr_frags; i++) {
 		frag = &skb_shinfo(skb)->frags[i - 1];
 		sgt[i].bpid = dpa_bp->bpid;
+
 		sgt[i].offset = 0;
 		sgt[i].length = frag->size;
 		sgt[i].extension = 0;
 		sgt[i].final = 0;
 
-		BUG_ON(!skb_frag_page(frag));
+		DPA_BUG_ON(!skb_frag_page(frag));
 		addr = skb_frag_dma_map(dpa_bp->dev, frag, 0, sgt[i].length,
 					dma_dir);
 		if (unlikely(dma_mapping_error(dpa_bp->dev, addr))) {
-- 
1.7.5.4

