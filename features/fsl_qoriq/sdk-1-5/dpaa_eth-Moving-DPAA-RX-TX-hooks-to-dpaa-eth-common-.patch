From 9ef8fb15faebfc5312769054751565eaa8e4eec5 Mon Sep 17 00:00:00 2001
From: Nikhil Agarwal <nikhil.agarwal@freescale.com>
Date: Mon, 21 Oct 2013 18:02:58 +0530
Subject: [PATCH 246/383] dpaa_eth: Moving DPAA RX TX hooks to dpaa eth common
 files.

This patch adds DPAA RX TX hooks to DPAA eth sg drivers
as well.

Change-Id: Ie744d32edcd98fc7e6a7ce356ddad58f0cb53c3d
Signed-off-by: Nikhil Agarwal <nikhil.agarwal@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/5459
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |   15 -----
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      |   60 -------------------
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   |   15 +++++
 .../net/ethernet/freescale/dpa/dpaa_eth_common.h   |   63 ++++++++++++++++++++
 .../net/ethernet/freescale/dpa/dpaa_eth_non_sg.c   |    1 -
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c   |   19 +++++-
 6 files changed, 94 insertions(+), 79 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 2e3224b..9766433 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -118,21 +118,6 @@ uint8_t dpa_priv_common_bpid;
 
 extern u16 qman_portal_max;
 
-/* A set of callbacks for hooking into the fastpath at different points. */
-struct dpaa_eth_hooks_s dpaa_eth_hooks;
-/*
- * This function should only be called on the probe paths, since it makes no
- * effort to guarantee consistency of the destination hooks structure.
- */
-void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks)
-{
-	if (hooks)
-		dpaa_eth_hooks = *hooks;
-	else
-		pr_err("NULL pointer to hooks!\n");
-}
-EXPORT_SYMBOL(fsl_dpaa_eth_set_hooks);
-
 /* Checks whether the checksum field in Parse Results array is valid
  * (equals 0xFFFF) and increments the .cse counter otherwise
  */
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 6d460ec..761ad36 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -152,66 +152,6 @@ struct dpa_buffer_layout_s {
 #define DPAA_ETH_PCD_FQ_BASE(device_addr) \
 	(((device_addr) & 0x1fffff) >> 6)
 
-/* return codes for the dpaa-eth hooks */
-enum dpaa_eth_hook_result {
-	/* fd/skb was retained by the hook.
-	 *
-	 * On the Rx path, this means the Ethernet driver will _not_
-	 * deliver the skb to the stack. Instead, the hook implementation
-	 * is expected to properly dispose of the skb.
-	 *
-	 * On the Tx path, the Ethernet driver's dpa_tx() function will
-	 * immediately return NETDEV_TX_OK. The hook implementation is expected
-	 * to free the skb. *DO*NOT* release it to BMan, or enqueue it to FMan,
-	 * unless you know exactly what you're doing!
-	 *
-	 * On the confirmation/error paths, the Ethernet driver will _not_
-	 * perform any fd cleanup, nor update the interface statistics.
-	 */
-	DPAA_ETH_STOLEN,
-	/* fd/skb was returned to the Ethernet driver for regular processing.
-	 * The hook is not allowed to, for instance, reallocate the skb (as if
-	 * by linearizing, copying, cloning or reallocating the headroom).
-	 */
-	DPAA_ETH_CONTINUE
-};
-
-typedef enum dpaa_eth_hook_result (*dpaa_eth_ingress_hook_t)(
-		struct sk_buff *skb, struct net_device *net_dev, u32 fqid);
-typedef enum dpaa_eth_hook_result (*dpaa_eth_egress_hook_t)(
-		struct sk_buff *skb, struct net_device *net_dev);
-typedef enum dpaa_eth_hook_result (*dpaa_eth_confirm_hook_t)(
-		struct net_device *net_dev, const struct qm_fd *fd, u32 fqid);
-
-/* Various hooks used for unit-testing and/or fastpath optimizations.
- * Currently only one set of such hooks is supported.
- */
-struct dpaa_eth_hooks_s {
-	/* Invoked on the Tx private path, immediately after receiving the skb
-	 * from the stack.
-	 */
-	dpaa_eth_egress_hook_t	tx;
-
-	/* Invoked on the Rx private path, right before passing the skb
-	 * up the stack. At that point, the packet's protocol id has already
-	 * been set. The skb's data pointer is now at the L3 header, and
-	 * skb->mac_header points to the L2 header. skb->len has been adjusted
-	 * to be the length of L3+payload (i.e., the length of the
-	 * original frame minus the L2 header len).
-	 * For more details on what the skb looks like, see eth_type_trans().
-	 */
-	dpaa_eth_ingress_hook_t	rx_default;
-
-	/* Driver hook for the Rx error private path. */
-	dpaa_eth_confirm_hook_t	rx_error;
-	/* Driver hook for the Tx confirmation private path. */
-	dpaa_eth_confirm_hook_t	tx_confirm;
-	/* Driver hook for the Tx error private path. */
-	dpaa_eth_confirm_hook_t	tx_error;
-};
-
-void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
-
 /* Largest value that the FQD's OAL field can hold.
  * This is DPAA-1.x specific.
  * TODO: This rather belongs in fsl_qman.h
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index 1ab1df7..320434b 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -72,6 +72,21 @@ static const char fsl_qman_frame_queues[][25] = {
 	[TX] = "fsl,qman-frame-queues-tx"
 };
 
+/* A set of callbacks for hooking into the fastpath at different points. */
+struct dpaa_eth_hooks_s dpaa_eth_hooks;
+/*
+ * This function should only be called on the probe paths, since it makes no
+ * effort to guarantee consistency of the destination hooks structure.
+ */
+void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks)
+{
+	if (hooks)
+		dpaa_eth_hooks = *hooks;
+	else
+		pr_err("NULL pointer to hooks!\n");
+}
+EXPORT_SYMBOL(fsl_dpaa_eth_set_hooks);
+
 extern const struct ethtool_ops dpa_ethtool_ops;
 
 int dpa_netdev_init(struct device_node *dpa_node,
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
index 6ee9825..4d71f5ad 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.h
@@ -52,6 +52,69 @@
 	fm_set_##type##_port_params(port, &param); \
 }
 
+/* return codes for the dpaa-eth hooks */
+enum dpaa_eth_hook_result {
+	/* fd/skb was retained by the hook.
+	 *
+	 * On the Rx path, this means the Ethernet driver will _not_
+	 * deliver the skb to the stack. Instead, the hook implementation
+	 * is expected to properly dispose of the skb.
+	 *
+	 * On the Tx path, the Ethernet driver's dpa_tx() function will
+	 * immediately return NETDEV_TX_OK. The hook implementation is expected
+	 * to free the skb. *DO*NOT* release it to BMan, or enqueue it to FMan,
+	 * unless you know exactly what you're doing!
+	 *
+	 * On the confirmation/error paths, the Ethernet driver will _not_
+	 * perform any fd cleanup, nor update the interface statistics.
+	 */
+	DPAA_ETH_STOLEN,
+	/* fd/skb was returned to the Ethernet driver for regular processing.
+	 * The hook is not allowed to, for instance, reallocate the skb (as if
+	 * by linearizing, copying, cloning or reallocating the headroom).
+	 */
+	DPAA_ETH_CONTINUE
+};
+
+typedef enum dpaa_eth_hook_result (*dpaa_eth_ingress_hook_t)(
+		struct sk_buff *skb, struct net_device *net_dev, u32 fqid);
+typedef enum dpaa_eth_hook_result (*dpaa_eth_egress_hook_t)(
+		struct sk_buff *skb, struct net_device *net_dev);
+typedef enum dpaa_eth_hook_result (*dpaa_eth_confirm_hook_t)(
+		struct net_device *net_dev, const struct qm_fd *fd, u32 fqid);
+
+/* Various hooks used for unit-testing and/or fastpath optimizations.
+ * Currently only one set of such hooks is supported.
+ */
+struct dpaa_eth_hooks_s {
+	/* Invoked on the Tx private path, immediately after receiving the skb
+	 * from the stack.
+	 */
+	dpaa_eth_egress_hook_t	tx;
+
+	/* Invoked on the Rx private path, right before passing the skb
+	 * up the stack. At that point, the packet's protocol id has already
+	 * been set. The skb's data pointer is now at the L3 header, and
+	 * skb->mac_header points to the L2 header. skb->len has been adjusted
+	 * to be the length of L3+payload (i.e., the length of the
+	 * original frame minus the L2 header len).
+	 * For more details on what the skb looks like, see eth_type_trans().
+	 */
+	dpaa_eth_ingress_hook_t	rx_default;
+
+	/* Driver hook for the Rx error private path. */
+	dpaa_eth_confirm_hook_t rx_error;
+	/* Driver hook for the Tx confirmation private path. */
+	dpaa_eth_confirm_hook_t tx_confirm;
+	/* Driver hook for the Tx error private path. */
+	dpaa_eth_confirm_hook_t tx_error;
+};
+
+void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
+
+extern struct dpaa_eth_hooks_s dpaa_eth_hooks;
+
+
 int dpa_netdev_init(struct device_node *dpa_node,
 		struct net_device *net_dev,
 		const uint8_t *mac_addr,
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c
index d608881..776418e 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c
@@ -51,7 +51,6 @@
 #define sgt_buffer_size(priv) \
 	dpa_get_buffer_size(&priv->buf_layout[TX], 256)
 
-extern struct dpaa_eth_hooks_s dpaa_eth_hooks;
 uint32_t default_buf_size;
 
 /* Allocate 8 socket buffers.
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index d116003..eb79245 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -543,9 +543,17 @@ void __hot _dpa_rx(struct net_device *net_dev,
 
 	/* The only FD types that we may receive are contig and S/G */
 	DPA_BUG_ON((fd->format != qm_fd_contig) && (fd->format != qm_fd_sg));
-	if (likely(fd->format == qm_fd_contig))
+
+	dma_unmap_single(dpa_bp->dev, addr, dpa_bp->size, DMA_BIDIRECTIONAL);
+	if (likely(fd->format == qm_fd_contig)) {
+		/* Execute the Rx processing hook, if it exists. */
+		if (dpaa_eth_hooks.rx_default &&
+			dpaa_eth_hooks.rx_default((void *)fd, net_dev, fqid)
+						== DPAA_ETH_STOLEN)
+			/* won't count the rx bytes in */
+			return;
 		skb = contig_fd_to_skb(priv, fd, &use_gro);
-	else
+	} else
 		skb = sg_fd_to_skb(priv, fd, &use_gro);
 	if (unlikely(!skb))
 		/* We haven't yet touched the DMA mapping or the pool count;
@@ -558,7 +566,6 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	 * Also, permanently unmap the buffer.
 	 */
 	(*count_ptr)--;
-	dma_unmap_single(dpa_bp->dev, addr, dpa_bp->size, DMA_BIDIRECTIONAL);
 
 	skb->protocol = eth_type_trans(skb, net_dev);
 
@@ -806,6 +813,12 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	const bool nonlinear = skb_is_nonlinear(skb);
 	int *countptr;
 
+	/* If there is a Tx hook, run it. */
+	if (dpaa_eth_hooks.tx &&
+		dpaa_eth_hooks.tx(skb, net_dev) == DPAA_ETH_STOLEN)
+		/* won't update any Tx stats */
+		return NETDEV_TX_OK;
+
 	priv = netdev_priv(net_dev);
 	/* Non-migratable context, safe to use __this_cpu_ptr */
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
-- 
1.7.5.4

