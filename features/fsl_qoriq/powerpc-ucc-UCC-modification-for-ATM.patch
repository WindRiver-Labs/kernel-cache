From 400998f57ab5aec8aa9b04d612e600f33c2f7000 Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Thu, 14 Mar 2013 16:58:13 +0800
Subject: [PATCH 07/21] powerpc/ucc: UCC modification for ATM

If UCC works as ATM, its clocks come from UPC and do not needs io pins

Signed-off-by: Liu Yu <yu.liu@freescale.com>
[Extracted from P1021MDS_20101124_ltib.iso Just some minor context
 mods in order to port to 3.4 kernel]
Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
---
 arch/powerpc/sysdev/qe_lib/ucc_fast.c |   61 ++++++++++++++++++--------------
 1 files changed, 34 insertions(+), 27 deletions(-)

diff --git a/arch/powerpc/sysdev/qe_lib/ucc_fast.c b/arch/powerpc/sysdev/qe_lib/ucc_fast.c
index 15b6189..7ead4fc 100644
--- a/arch/powerpc/sysdev/qe_lib/ucc_fast.c
+++ b/arch/powerpc/sysdev/qe_lib/ucc_fast.c
@@ -301,33 +301,39 @@ int ucc_fast_init(struct ucc_fast_info * uf_info, struct ucc_fast_private ** ucc
 	out_be32(&uf_regs->utfb, uccf->ucc_fast_tx_virtual_fifo_base_offset);
 	out_be32(&uf_regs->urfb, uccf->ucc_fast_rx_virtual_fifo_base_offset);
 
-	/* Mux clocking */
-	/* Grant Support */
-	ucc_set_qe_mux_grant(uf_info->ucc_num, uf_info->grant_support);
-	/* Breakpoint Support */
-	ucc_set_qe_mux_bkpt(uf_info->ucc_num, uf_info->brkpt_support);
-	/* Set Tsa or NMSI mode. */
-	ucc_set_qe_mux_tsa(uf_info->ucc_num, uf_info->tsa);
-	/* If NMSI (not Tsa), set Tx and Rx clock. */
-	if (!uf_info->tsa) {
-		/* Rx clock routing */
-		if ((uf_info->rx_clock != QE_CLK_NONE) &&
-		    ucc_set_qe_mux_rxtx(uf_info->ucc_num, uf_info->rx_clock,
-					COMM_DIR_RX)) {
-			printk(KERN_ERR "%s: illegal value for RX clock\n",
-			       __func__);
-			ucc_fast_free(uccf);
-			return -EINVAL;
-		}
-		/* Tx clock routing */
-		if ((uf_info->tx_clock != QE_CLK_NONE) &&
-		    ucc_set_qe_mux_rxtx(uf_info->ucc_num, uf_info->tx_clock,
-					COMM_DIR_TX)) {
-			printk(KERN_ERR "%s: illegal value for TX clock\n",
-			       __func__);
-			ucc_fast_free(uccf);
-			return -EINVAL;
-		}
+	/*
+	 * If UCC works as ATM, its clocks come from UPC
+	 * and do not needs io pins
+	 */
+	if (uf_info->mode != UCC_FAST_PROTOCOL_MODE_ATM) {
+		/* Mux clocking */
+		/* Grant Support */
+		ucc_set_qe_mux_grant(uf_info->ucc_num, uf_info->grant_support);
+		/* Breakpoint Support */
+		ucc_set_qe_mux_bkpt(uf_info->ucc_num, uf_info->brkpt_support);
+		/* Set Tsa or NMSI mode. */
+		ucc_set_qe_mux_tsa(uf_info->ucc_num, uf_info->tsa);
+		/* If NMSI (not Tsa), set Tx and Rx clock. */
+		if (!uf_info->tsa) {
+			/* Rx clock routing */
+			if ((uf_info->rx_clock != QE_CLK_NONE) &&
+				ucc_set_qe_mux_rxtx(uf_info->ucc_num,
+					uf_info->rx_clock, COMM_DIR_RX)) {
+				printk(KERN_ERR"%s: illegal value for RX clock",
+					__FUNCTION__);
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+			/* Tx clock routing */
+			if ((uf_info->tx_clock != QE_CLK_NONE) &&
+				ucc_set_qe_mux_rxtx(uf_info->ucc_num,
+					uf_info->tx_clock, COMM_DIR_TX)) {
+				printk(KERN_ERR "%s:illegal value for TX clock",
+					__FUNCTION__);
+				ucc_fast_free(uccf);
+				return -EINVAL;
+			}
+
 #ifdef CONFIG_FSL_UCC_TDM
 	} else {
 		/* tdm Rx clock routing */
@@ -366,6 +372,7 @@ int ucc_fast_init(struct ucc_fast_info * uf_info, struct ucc_fast_private ** ucc
 			return -EINVAL;
 		}
 #endif
+		}
 	}
 
 	/* Set interrupt mask register at UCC level. */
-- 
1.7.0

