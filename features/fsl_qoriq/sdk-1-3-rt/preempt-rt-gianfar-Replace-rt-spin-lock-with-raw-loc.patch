From bef2cb97c3acf78a084bf23f2edac15f7d543e05 Mon Sep 17 00:00:00 2001
From: Bin Jiang <bin.jiang@windriver.com>
Date: Mon, 26 Nov 2012 16:29:49 +0800
Subject: [PATCH] preempt-rt: gianfar: Replace rt spin lock with raw lock

rt kernel reports below BUG:
BUG: sleeping function called from invalid context at rtmutex.c:646
in_atomic(): 1, irqs_disabled(): 0, pid: 119, name: irq/36-eth1_g0_
Call Trace:
[eec59cf0] [c00094ac] show_stack+0x10c/0x1c0 (unreliable)
[eec59d40] [c0650718] dump_stack+0x24/0x34
[eec59d50] [c0078bcc] __might_sleep+0xd8/0xfc
[eec59d60] [c0648598] rt_spin_lock+0x34/0x7c
[eec59d70] [c0468178] gfar_new_skb+0x100/0x220
[eec59da0] [c0469694] gfar_clean_rx_ring+0x1c0/0x520
[eec59e10] [c0469af0] gfar_poll_rx+0xfc/0x250
[eec59e50] [c05432dc] net_rx_action+0x158/0x324
[eec59ea0] [c0049218] __do_softirq_common+0x128/0x2b4
[eec59f00] [c004a354] __do_softirq+0x20/0x30
[eec59f10] [c004a4bc] local_bh_enable+0x158/0x170
[eec59f30] [c00c48fc] irq_forced_thread_fn+0x5c/0x94
[eec59f50] [c00c45cc] irq_thread+0x12c/0x194
[eec59fa0] [c00692c4] kthread+0x90/0x94
[eec59ff0] [c000fdf4] original_kernel_thread+0x4c/0x68

Since spin_lock/unlock is sleepable in preempt_rt, replace them in
atomic context to unpreemptible raw_spin_lock/unlock primitives.

Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   14 +++++++-------
 drivers/net/ethernet/freescale/gianfar.h |    2 +-
 2 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 33e4af4..fb6f436 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -2554,7 +2554,7 @@ struct gfar_recycle_cntxt *__init gfar_init_recycle_cntxt(void)
 		goto err;
 
 	recycle_cntxt->recycle_max = GFAR_RX_RECYCLE_MAX;
-	spin_lock_init(&recycle_cntxt->recycle_lock);
+	raw_spin_lock_init(&recycle_cntxt->recycle_lock);
 	recycle_cntxt->global_recycle_q = kmalloc(sizeof(struct sk_buff_head),
 							GFP_KERNEL);
 	if (!recycle_cntxt->global_recycle_q)
@@ -3526,20 +3526,20 @@ static void gfar_free_skb(struct sk_buff *skb)
 	 * with global device recycle queue if it is empty otherwise
 	 * kfree the skb
 	 */
-	spin_lock_irqsave(&recycle_cntxt->recycle_lock, flags);
+	raw_spin_lock_irqsave(&recycle_cntxt->recycle_lock, flags);
 	if (recycle_cntxt->global_recycle_q &&
 		!skb_queue_len(recycle_cntxt->global_recycle_q)) {
 
 		temp_recycle_q  = recycle_cntxt->global_recycle_q;
 		recycle_cntxt->global_recycle_q = recycle_q;
 		recycle_cntxt->free_swap_count++;
-		spin_unlock_irqrestore(&recycle_cntxt->recycle_lock, flags);
+		raw_spin_unlock_irqrestore(&recycle_cntxt->recycle_lock, flags);
 		local->recycle_q = temp_recycle_q;
 		local->free_count++;
 		__skb_queue_head(temp_recycle_q, skb);
 		put_cpu();
 	} else {
-		spin_unlock_irqrestore(&recycle_cntxt->recycle_lock, flags);
+		raw_spin_unlock_irqrestore(&recycle_cntxt->recycle_lock, flags);
 		put_cpu();
 		dev_kfree_skb_any(skb);
 	}
@@ -3570,20 +3570,20 @@ struct sk_buff * gfar_new_skb(struct net_device *dev)
 	/* Local per cpu queue is empty. Now swap global recycle
 	 * queue (if it is full) with this empty local queue.
 	 */
-	spin_lock_irqsave(&recycle_cntxt->recycle_lock, flags);
+	raw_spin_lock_irqsave(&recycle_cntxt->recycle_lock, flags);
 	if (recycle_cntxt->global_recycle_q &&
 		skb_queue_len(recycle_cntxt->global_recycle_q)) {
 
 		temp_recycle_q = recycle_cntxt->global_recycle_q;
 		recycle_cntxt->global_recycle_q = recycle_q;
 		recycle_cntxt->alloc_swap_count++;
-		spin_unlock_irqrestore(&recycle_cntxt->recycle_lock, flags);
+		raw_spin_unlock_irqrestore(&recycle_cntxt->recycle_lock, flags);
 		local->recycle_q = temp_recycle_q;
 		local->alloc_count++;
 		skb = __skb_dequeue(temp_recycle_q);
 		put_cpu();
 	} else {
-		spin_unlock_irqrestore(&recycle_cntxt->recycle_lock, flags);
+		raw_spin_unlock_irqrestore(&recycle_cntxt->recycle_lock, flags);
 		put_cpu();
 		skb = gfar_alloc_skb(dev);
 	}
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 47f34f6..d45d034 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1254,7 +1254,7 @@ enum gfar_errata {
  *		while skb's were being returned to a recycle queue
  */
 struct gfar_recycle_cntxt {
-	spinlock_t recycle_lock;
+	raw_spinlock_t recycle_lock;
 	struct sk_buff_head *global_recycle_q;
 	unsigned int recycle_max;
 	unsigned int alloc_swap_count;
-- 
1.7.9.7

