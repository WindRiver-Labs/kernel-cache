From c09a7c29ca6e34ac8a6a008f16d9ccf837bc6d3a Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Mon, 3 Dec 2012 17:37:08 +0800
Subject: [PATCH] dpaa: Fix a call trace of dpaa on rt kernel

When activating the networking interface the following call trace is thrown:
BUG: sleeping function called from invalid context at kernel/rtmutex.c:646
in_atomic(): 0, irqs_disabled(): 1, pid: 1369, name: avahi-daemon
Call Trace:
[c0000001f9756d70] [c00000000000b074] .show_stack+0xe4/0x250 (unreliable)
[c0000001f9756e40] [c0000000008de570] .dump_stack+0x20/0x30
[c0000001f9756eb0] [c0000000000868cc] .__might_sleep+0x10c/0x160
[c0000001f9756f50] [c0000000008d35b4] .rt_spin_lock+0x34/0x90
[c0000001f9756fd0] [c00000000017c17c] .__kmalloc+0x12c/0x360
[c0000001f9757090] [c000000000661cc4] .xx_Malloc+0x44/0xa0
[c0000001f9757130] [c000000000661d40] .XX_Malloc+0x20/0x30
[c0000001f97571b0] [c0000000005d4084] .DtsecAddHashMacAddress+0xe4/0x280
[c0000001f9757270] [c0000000005dcf60] .FM_MAC_AddHashMacAddr+0x60/0x170
[c0000001f9757300] [c0000000008e99e4] .set_multi+0x134/0x28c
[c0000001f97573d0] [c0000000006639d8] .dpa_set_rx_mode+0x98/0x1a0
[c0000001f9757480] [c000000000796048] .__dev_set_rx_mode+0x98/0x100
[c0000001f9757510] [c00000000079c1c4] .__dev_mc_add+0x74/0xc0
[c0000001f97575b0] [c00000000079c27c] .dev_mc_add+0x2c/0x40
[c0000001f9757630] [c00000000081c828] .igmp_group_added+0x168/0x1b0
[c0000001f97576e0] [c00000000081ca50] .ip_mc_inc_group+0x1e0/0x330
[c0000001f9757780] [c00000000081cce4] .ip_mc_join_group+0x144/0x180
[c0000001f9757820] [c0000000007e1938] .do_ip_setsockopt.isra.10+0x558/0xf20
[c0000001f9757a80] [c0000000007e24bc] .ip_setsockopt+0x5c/0x110
[c0000001f9757b20] [c00000000080bad8] .udp_setsockopt+0x58/0x80
[c0000001f9757bd0] [c000000000777910] .sock_common_setsockopt+0x60/0x80
[c0000001f9757c70] [c000000000775fbc] .SyS_setsockopt+0xdc/0x250
[c0000001f9757d50] [c0000000007770a0] .SyS_socketcall+0x340/0x4d0
[c0000001f9757e30] [c000000000000598] syscall_exit+0x0/0x2c

Since spinlocks are sleepable on rt, it is not allowed to call them with interrupts
disabled. Therefore we use local_irq_save_nort() instead which saves flags without
disabling interrupts.

Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
---
 .../freescale/dpa/NetCommSw/src/xx/xx_linux.c      |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
index ea914fd..3607bb1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/xx/xx_linux.c
@@ -353,14 +353,14 @@ uint32_t XX_DisableAllIntr(void)
 {
     unsigned long flags;
 
-    local_irq_save(flags);
+    local_irq_save_nort(flags);
 
     return (uint32_t)flags;
 }
 
 void XX_RestoreAllIntr(uint32_t flags)
 {
-    local_irq_restore((unsigned long)flags);
+    local_irq_restore_nort((unsigned long)flags);
 }
 
 t_Error XX_Call( uint32_t qid, t_Error (* f)(t_Handle), t_Handle id, t_Handle appId, uint16_t flags )
-- 
1.7.9.7

