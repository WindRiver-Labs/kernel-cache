From 5aa41b4afa67abf5697549f7b96bb692f438a95b Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Thu, 14 Mar 2013 16:12:14 +0800
Subject: [PATCH 03/21] powerpc/QE: Add support for Timestamp timer on QE

This patch adds support for Timestamp timer on QUICC Engine.

Signed-off-by: Liu Yu <yu.liu@freescale.com>
[Extracted from P1021MDS_20101124_ltib.iso Just some minor context
 mods in order to port to 3.4 kernel]
Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
---
 arch/powerpc/include/asm/qe.h   |    4 +
 arch/powerpc/sysdev/qe_lib/qe.c |  120 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 124 insertions(+), 0 deletions(-)

diff --git a/arch/powerpc/include/asm/qe.h b/arch/powerpc/include/asm/qe.h
index 570d22d..b1a4105 100644
--- a/arch/powerpc/include/asm/qe.h
+++ b/arch/powerpc/include/asm/qe.h
@@ -454,6 +454,10 @@ enum comm_dir {
 #define QE_CR_PROTOCOL_ETHERNET		0x0C
 #define QE_CR_PROTOCOL_L2_SWITCH	0x0D
 
+/* Time stamp register */
+#define QE_CETSCR_EC	0x8000
+#define QE_CETSCR_RTE	0x0400
+
 /* BRG configuration register */
 #define QE_BRGC_ENABLE		0x00010000
 #define QE_BRGC_DIVISOR_SHIFT	1
diff --git a/arch/powerpc/sysdev/qe_lib/qe.c b/arch/powerpc/sysdev/qe_lib/qe.c
index a202fb6..7aa9d11 100644
--- a/arch/powerpc/sysdev/qe_lib/qe.c
+++ b/arch/powerpc/sysdev/qe_lib/qe.c
@@ -39,6 +39,7 @@
 
 static void qe_snums_init(void);
 static int qe_sdma_init(void);
+static int qe_time_stamp_init(void);
 
 static DEFINE_SPINLOCK(qe_lock);
 DEFINE_SPINLOCK(cmxgcr_lock);
@@ -108,6 +109,7 @@ void qe_reset(void)
 
 	if (qe_sdma_init())
 		panic("sdma init failed!");
+	qe_time_stamp_init();
 }
 
 int qe_issue_cmd(u32 cmd, u32 device, u8 mcn_protocol, u32 cmd_input)
@@ -611,6 +613,124 @@ struct qe_firmware_info *qe_get_firmware_info(void)
 }
 EXPORT_SYMBOL(qe_get_firmware_info);
 
+int qe_mux_set_time_stamp(int num, const char *clk)
+{
+	u8 shift;
+	u32 clock_bits;
+	u32 clock_mask;
+	int source, i;
+	/* Time-stamp timer clock map */
+	struct clock_map tst_clk[5] = {
+		{CLK_RTX, "clk11", 0},
+		{CLK_RTX, "clk12", 1},
+		{CLK_RTX, "clk21", 2},
+		{CLK_RTX, "brg11", 3},
+		{CLK_RTX, "rtc", 4},
+	};
+
+	if ((num < 1) || (num > 2))
+		return -EINVAL;
+
+	/* clocked by QE clock */
+	if (strcasecmp(clk, "qeclk") == 0)
+		return 0;
+
+	source = -1;
+	for (i = 0; i < 5; i++) {
+		if (strcasecmp(tst_clk[i].name, clk) == 0) {
+			source = tst_clk[i].value;
+			break;
+		}
+	}
+	if (source == -1) {
+		printk(KERN_ERR"%s: Bad combination of clock \
+			and Time-stamp timer %d\n", __FUNCTION__, num);
+		return -EINVAL;
+	}
+
+	clock_bits = source;
+	clock_mask = 0x7;
+	if (num == 1)
+		shift = 28;
+	else
+		shift = 24;
+
+	clock_bits <<= shift;
+	clock_mask <<= shift;
+
+	out_be32(&qe_immr->qmx.cmxgcr,
+			(in_be32(&qe_immr->qmx.cmxgcr) & ~clock_mask) |
+			clock_bits);
+
+	return 0;
+}
+
+int qe_enable_time_stamp(int num)
+{
+	struct device_node *qe;
+	const char *prop;
+	const u32 *bus_freq;
+	u16 cetps;
+	u8 shift;
+
+	if ((num < 0) || (num > 1))
+		return -EINVAL;
+
+	qe = of_find_node_by_type(NULL, "qe");
+	if (qe == NULL)
+		return -ENODEV;
+
+	bus_freq = of_get_property(qe, "bus-frequency", 0);
+	if (num == 1)
+		prop = of_get_property(qe, "fsl,time-stamp1-clock", NULL);
+	else
+		prop = of_get_property(qe, "fsl,time-stamp2-clock", NULL);
+	if (bus_freq == NULL || prop == NULL) {
+		printk(KERN_WARNING"Fail to configure \
+			 QE time-stamp timer %d\n", num);
+		return -EFAULT;
+	}
+
+	if (num == 1)
+		shift = 16;
+	else
+		shift = 0;
+
+	cetps = 0;
+	/* Generate 1 micro second period input clock  */
+	cetps = (*bus_freq / 1000000) - 2;
+
+	if (strcasecmp(prop, "qeclk"))
+		cetps |= QE_CETSCR_EC;
+	cetps |= QE_CETSCR_RTE;
+
+	clrbits32(&qe_immr->cp.cetscr, 0xFFFF << shift);
+	setbits32(&qe_immr->cp.cetscr, cetps << shift);
+
+	return 0;
+}
+EXPORT_SYMBOL(qe_enable_time_stamp);
+
+static int qe_time_stamp_init(void)
+{
+	struct device_node *qe;
+	const char *prop;
+
+	qe = of_find_node_by_type(NULL, "qe");
+	if (qe == NULL)
+		return -ENODEV;
+
+	prop = of_get_property(qe, "fsl,time-stamp1-clock", NULL);
+	if ((prop == NULL) || qe_mux_set_time_stamp(1, prop))
+		printk(KERN_WARNING"Bad clock source for time stamp 1\n");
+
+	prop = of_get_property(qe, "fsl,time-stamp2-clock", NULL);
+	if ((prop == NULL) || qe_mux_set_time_stamp(2, prop))
+		printk(KERN_WARNING"Bad clock source for time stamp 2\n");
+
+	return 0;
+}
+
 unsigned int qe_get_num_of_risc(void)
 {
 	struct device_node *qe;
-- 
1.7.0

