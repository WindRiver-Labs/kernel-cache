From ff1ec781c55d9f29537c1123e1c4cf791cf820d7 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Mon, 23 Apr 2012 15:05:21 +0800
Subject: [PATCH 32/38] powerpc/85xx: Add a new MDIO driver for hydra boards

Extracted from QorIQ-DPAA-SDK-v1.1-20111026-systembuilder.iso

On hydra boards (e.g. P5020 and P3041) the mdio buses are selected
through an FPGA PIXIS register instead of GPIO pins.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Signed-off-by: Timur Tabi <timur@freescale.com>
Acked-by: Andy Fleming <afleming@freescale.com>
Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
---
 arch/powerpc/platforms/85xx/Kconfig      |    7 +
 arch/powerpc/platforms/85xx/Makefile     |    1 +
 arch/powerpc/platforms/85xx/corenet_ds.c |    4 +
 arch/powerpc/platforms/85xx/hydra_mdio.c |  287 ++++++++++++++++++++++++++++++
 4 files changed, 299 insertions(+), 0 deletions(-)
 create mode 100644 arch/powerpc/platforms/85xx/hydra_mdio.c

diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 750bfbe..c22089b 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -223,6 +223,7 @@ config P3041_DS
 	select HAS_FSL_PAMU
 	select HAS_FSL_QBMAN
 	select HAS_FSL_PME
+	select FSL_HYDRA_DS_MDIO if PHYLIB
 	help
 	  This option enables support for the P3041 DS board
 
@@ -272,6 +273,7 @@ config P5020_DS
 	select HAS_FSL_PAMU
 	select HAS_FSL_QBMAN
 	select HAS_FSL_PME
+	select FSL_HYDRA_DS_MDIO if PHYLIB
 	help
 	  This option enables support for the P5020 DS board
 
@@ -282,5 +284,10 @@ config FSL_P4080_DS_MDIO
 	select VITESSE_PHY
 	depends on PHYLIB
 
+config FSL_HYDRA_DS_MDIO
+	bool
+	select VITESSE_PHY
+	depends on PHYLIB
+
 config TQM85xx
 	bool
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 19f75f1..514c9c0 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -21,6 +21,7 @@ obj-$(CONFIG_P3060_QDS)   += p3060_qds.o corenet_ds.o
 obj-$(CONFIG_P4080_DS)    += p4080_ds.o corenet_ds.o
 obj-$(CONFIG_P5020_DS)    += p5020_ds.o corenet_ds.o
 obj-$(CONFIG_FSL_P4080_DS_MDIO) += p4080_ds_mdio.o
+obj-$(CONFIG_FSL_HYDRA_DS_MDIO) += hydra_mdio.o
 obj-$(CONFIG_STX_GP3)	  += stx_gp3.o
 obj-$(CONFIG_TQM85xx)	  += tqm85xx.o
 obj-$(CONFIG_SBC8560)     += sbc8560.o
diff --git a/arch/powerpc/platforms/85xx/corenet_ds.c b/arch/powerpc/platforms/85xx/corenet_ds.c
index 9177ad5..257ce72 100644
--- a/arch/powerpc/platforms/85xx/corenet_ds.c
+++ b/arch/powerpc/platforms/85xx/corenet_ds.c
@@ -17,6 +17,7 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/memblock.h>
+#include <linux/of_platform.h>
 
 #include <asm/time.h>
 #include <asm/machdep.h>
@@ -133,6 +134,9 @@ int __init declare_of_platform_devices(void)
 	for_each_compatible_node(np, NULL, "fsl,p4080ds-xmdio")
 		of_platform_device_create(np, NULL, NULL);
 
+	for_each_compatible_node(np, NULL, "fsl,hydra-mdio")
+		of_platform_device_create(np, NULL, NULL);
+
 	return 0;
 }
 
diff --git a/arch/powerpc/platforms/85xx/hydra_mdio.c b/arch/powerpc/platforms/85xx/hydra_mdio.c
new file mode 100644
index 0000000..51b06f7
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/hydra_mdio.c
@@ -0,0 +1,287 @@
+/*
+ * Provides PIXIS based muxing for the MDIO buses on the hydra boards
+ *
+ * Hydra is the code for the P3041 DS & P5020 DS boards
+ *
+ * Copyright (c) 2010 Freescale Semiconductor, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/crc32.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/of.h>
+#include <linux/of_mdio.h>
+#include <linux/of_platform.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+
+
+#define PIXIS_BRDCFG1_OFFSET	0x9
+#define BRDCFG1_EMI1_SEL_MASK	0x70
+#define BRDCFG1_EMI1_EN		0x08
+
+
+struct hydra_mdio {
+	struct mii_bus *real_bus;
+	u8 *pixis_brdcfg1;
+	u8 value;
+	u8 mask;
+};
+
+/* Set the BRDCFG1 pixis register, and then write the MDIO regs */
+int hydra_mdio_write(struct mii_bus *bus, int port_addr, int dev_addr,
+			int regnum, u16 value)
+{
+	struct hydra_mdio *priv = bus->priv;
+
+	/* Write BRDCFG1 to select this bus */
+	clrsetbits_8(priv->pixis_brdcfg1, priv->mask, priv->value);
+
+	/* Write through to the attached MDIO bus */
+	return priv->real_bus->write(priv->real_bus, port_addr, dev_addr,
+					regnum, value);
+}
+
+/* Set the BRDCFG1 pixis register, and then read from the MDIO bus */
+int hydra_mdio_read(struct mii_bus *bus, int port_addr, int dev_addr,
+			int regnum)
+{
+	struct hydra_mdio *priv = bus->priv;
+
+	/* Write BRDCFG1 to select this bus */
+	clrsetbits_8(priv->pixis_brdcfg1, priv->mask, priv->value);
+
+	return priv->real_bus->read(priv->real_bus, port_addr, dev_addr,
+					regnum);
+}
+
+
+/* Reset the MIIM registers, and wait for the bus to free */
+static int hydra_mdio_reset(struct mii_bus *bus)
+{
+	struct hydra_mdio *priv = bus->priv;
+
+	mutex_lock(&bus->mdio_lock);
+	priv->real_bus->reset(priv->real_bus);
+	mutex_unlock(&bus->mdio_lock);
+
+	return 0;
+}
+
+static struct of_device_id hydra_pixis_match[] = {
+	{
+		.compatible = "fsl,p3041ds-fpga",
+	},
+	{
+		.compatible = "fsl,p5020ds-fpga",
+	},
+	{}
+};
+
+static int hydra_mdio_probe(struct platform_device *ofdev)
+{
+	struct device_node *np = ofdev->dev.of_node;
+	struct mii_bus *new_bus;
+	struct hydra_mdio *priv;
+	struct device_node *mdio, *pixis;
+	struct platform_device *ofmdiodev;
+	const u32 *addr;
+	const u32 *val;
+	u64 reg;
+	int i;
+	int err = 0;
+
+	new_bus = mdiobus_alloc();
+	if (NULL == new_bus)
+		return -ENOMEM;
+
+	new_bus->name = "Freescale Hydra MDIO Bus",
+	new_bus->read = &hydra_mdio_read,
+	new_bus->write = &hydra_mdio_write,
+	new_bus->reset = &hydra_mdio_reset,
+
+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		err = -ENOMEM;
+		goto err_priv_alloc;
+	}
+
+	new_bus->priv = priv;
+
+	/* Get the parent (real) mdio bus */
+	mdio = of_parse_phandle(np, "fsl,mdio-handle", 0);
+
+	if (mdio == NULL) {
+		printk(KERN_ERR "Could not find real MDIO bus for %s\n",
+			new_bus->id);
+		err = -ENODEV;
+		goto err_no_mdio_node;
+	}
+
+	ofmdiodev = of_find_device_by_node(mdio);
+
+	if (!ofmdiodev) {
+		printk(KERN_ERR "No of_device for MDIO node %s\n",
+		       mdio->full_name);
+		err = -ENODEV;
+		goto err_no_mdio_dev;
+	}
+
+	of_node_put(mdio);
+
+	priv->real_bus = dev_get_drvdata(&ofmdiodev->dev);
+
+	if (!priv->real_bus) {
+		printk(KERN_ERR "The MDIO bus has no ofdev!\n");
+		err = -ENODEV;
+		goto err_no_ofdev;
+	}
+
+	new_bus->irq = kcalloc(PHY_MAX_ADDR, sizeof(int), GFP_KERNEL);
+
+	if (NULL == new_bus->irq) {
+		err = -ENOMEM;
+		goto err_irq_alloc;
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		new_bus->irq[i] = PHY_POLL;
+
+	new_bus->parent = &ofdev->dev;
+	dev_set_drvdata(&ofdev->dev, new_bus);
+
+	/* Find the pixis node */
+	pixis = of_find_matching_node(NULL, hydra_pixis_match);
+	if (!pixis) {
+		err = -ENODEV;
+		goto err_no_pixis;
+	}
+
+	addr = of_get_address(pixis, 0, NULL, NULL);
+	if (!addr) {
+		err = -ENODEV;
+		goto err_no_pixis_addr;
+	}
+
+	reg = of_translate_address(pixis, addr);
+	of_node_put(pixis);
+
+	/* Map only the register we need to select the mdio bus (BRDCFG1) */
+	priv->pixis_brdcfg1 = ioremap(reg + PIXIS_BRDCFG1_OFFSET,
+				      sizeof(*priv->pixis_brdcfg1));
+	if (!priv->pixis_brdcfg1) {
+		err = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	val = of_get_property(np, "fsl,hydra-mdio-muxval", NULL);
+	if (!val) {
+		printk(KERN_ERR "No mux value found for %s\n", np->full_name);
+		err = -ENODEV;
+		goto err_get_muxval;
+	}
+
+	priv->mask = BRDCFG1_EMI1_SEL_MASK;
+	priv->value = BRDCFG1_EMI1_EN | *val;
+
+	sprintf(new_bus->id, "%s@%d", np->name, *val);
+
+	err = of_mdiobus_register(new_bus, np);
+
+	if (err) {
+		printk(KERN_ERR "%s: Cannot register as MDIO bus\n",
+				new_bus->name);
+		goto err_registration;
+	}
+
+	return 0;
+
+err_get_muxval:
+	iounmap(priv->pixis_brdcfg1);
+err_ioremap:
+err_no_pixis_addr:
+	of_node_put(pixis);
+err_no_pixis:
+err_registration:
+	kfree(new_bus->irq);
+err_irq_alloc:
+err_no_ofdev:
+err_no_mdio_dev:
+err_no_mdio_node:
+	kfree(priv);
+err_priv_alloc:
+	mdiobus_free(new_bus);
+
+	return err;
+}
+
+
+static int hydra_mdio_remove(struct platform_device *ofdev)
+{
+	struct device *device = &ofdev->dev;
+	struct mii_bus *bus = dev_get_drvdata(device);
+	struct hydra_mdio *priv = bus->priv;
+
+	mdiobus_unregister(bus);
+
+	dev_set_drvdata(device, NULL);
+
+	iounmap(priv->pixis_brdcfg1);
+	kfree(bus->irq);
+	kfree(bus->priv);
+
+	mdiobus_free(bus);
+
+	return 0;
+}
+
+static struct of_device_id hydra_mdio_match[] = {
+	{
+		.compatible = "fsl,hydra-mdio",
+	},
+	{}
+};
+
+static struct platform_driver hydra_mdio_driver = {
+	.driver = {
+		.name = "hydra_mdio",
+		.of_match_table = hydra_mdio_match,
+	},
+	.probe = hydra_mdio_probe,
+	.remove = hydra_mdio_remove,
+};
+
+int __init hydra_mdio_init(void)
+{
+	return platform_driver_register(&hydra_mdio_driver);
+}
+
+void hydra_mdio_exit(void)
+{
+	platform_driver_unregister(&hydra_mdio_driver);
+}
+subsys_initcall_sync(hydra_mdio_init);
+module_exit(hydra_mdio_exit);
-- 
1.7.0.4

