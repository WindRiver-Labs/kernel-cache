From be185ac0401f273ddee554246c2028578fc3b822 Mon Sep 17 00:00:00 2001
From: "J. German Rivera" <German.Rivera@freescale.com>
Date: Thu, 9 Apr 2015 18:14:22 -0500
Subject: [PATCH 0481/1429] staging: fsl-mc: Allow the MC bus driver to run
 without GIC support

If the lpi-parent property is not present in the fsl,qoriq-mc node
of the device tree, the MC bus driver will assume that the GIC is not
supported.

This change is made in order to be able to use the MC bus driver in a
KVM VM, without having GIC-ITS support in guests. Added function
fsl_mc_interrupts_supported(), which can be called from DPAA2 object
drivers.

Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
Change-Id: I881ab2c45c949e55cfafe1d281a7a31560955e5b
Reviewed-on: http://git.am.freescale.net:8181/34712
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-mc/bus/dprc-driver.c    |   31 ++++++++++++++++++--------
 drivers/staging/fsl-mc/bus/mc-allocator.c   |    4 +++
 drivers/staging/fsl-mc/bus/mc-bus.c         |   16 ++++++++++++-
 drivers/staging/fsl-mc/include/mc-private.h |    4 +++
 drivers/staging/fsl-mc/include/mc.h         |    2 +
 5 files changed, 45 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/dprc-driver.c b/drivers/staging/fsl-mc/bus/dprc-driver.c
index b84cca3..ff321c9 100644
--- a/drivers/staging/fsl-mc/bus/dprc-driver.c
+++ b/drivers/staging/fsl-mc/bus/dprc-driver.c
@@ -412,6 +412,7 @@ static int dprc_scan_container(struct fsl_mc_device *mc_bus_dev)
 	int error;
 	unsigned int irq_count;
 	struct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);
+	struct fsl_mc *mc = dev_get_drvdata(fsl_mc_bus_type.dev_root->parent);
 
 	dprc_init_all_resource_pools(mc_bus_dev);
 
@@ -424,7 +425,7 @@ static int dprc_scan_container(struct fsl_mc_device *mc_bus_dev)
 	if (error < 0)
 		goto error;
 
-	if (!mc_bus->irq_resources) {
+	if (mc->gic_supported && !mc_bus->irq_resources) {
 		irq_count += FSL_MC_IRQ_POOL_MAX_EXTRA_IRQS;
 		error = fsl_mc_populate_irq_pool(mc_bus, irq_count);
 		if (error < 0)
@@ -754,6 +755,7 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 	int error;
 	size_t region_size;
 	struct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);
+	struct fsl_mc *mc = dev_get_drvdata(fsl_mc_bus_type.dev_root->parent);
 
 	if (WARN_ON(strcmp(mc_dev->obj_desc.type, "dprc") != 0))
 		return -EINVAL;
@@ -792,12 +794,15 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 	if (error < 0)
 		goto error_cleanup_open;
 
-	/*
-	 * Configure interrupts for the DPRC object associated with this MC bus:
-	 */
-	error = dprc_setup_irqs(mc_dev);
-	if (error < 0)
-		goto error_cleanup_dprc_scan;
+	if (mc->gic_supported) {
+		/*
+		 * Configure interrupts for the DPRC object associated with
+		 * this MC bus:
+		 */
+		error = dprc_setup_irqs(mc_dev);
+		if (error < 0)
+			goto error_cleanup_dprc_scan;
+	}
 
 	dev_info(&mc_dev->dev, "DPRC device bound to driver");
 	return 0;
@@ -805,7 +810,8 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 error_cleanup_dprc_scan:
 	device_for_each_child(&mc_dev->dev, NULL, __fsl_mc_device_remove);
 	dprc_cleanup_all_resource_pools(mc_dev);
-	fsl_mc_cleanup_irq_pool(mc_bus);
+	if (mc->gic_supported)
+		fsl_mc_cleanup_irq_pool(mc_bus);
 
 error_cleanup_open:
 	(void)dprc_close(mc_dev->mc_io, mc_dev->mc_handle);
@@ -839,6 +845,7 @@ static int dprc_remove(struct fsl_mc_device *mc_dev)
 {
 	int error;
 	struct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);
+	struct fsl_mc *mc = dev_get_drvdata(fsl_mc_bus_type.dev_root->parent);
 
 	if (WARN_ON(strcmp(mc_dev->obj_desc.type, "dprc") != 0))
 		return -EINVAL;
@@ -848,14 +855,18 @@ static int dprc_remove(struct fsl_mc_device *mc_dev)
 	if (WARN_ON(!mc_bus->irq_resources))
 		return -EINVAL;
 
-	dprc_teardown_irqs(mc_dev);
+	if (mc->gic_supported)
+		dprc_teardown_irqs(mc_dev);
+
 	device_for_each_child(&mc_dev->dev, NULL, __fsl_mc_device_remove);
 	dprc_cleanup_all_resource_pools(mc_dev);
 	error = dprc_close(mc_dev->mc_io, mc_dev->mc_handle);
 	if (error < 0)
 		dev_err(&mc_dev->dev, "dprc_close() failed: %d\n", error);
 
-	fsl_mc_cleanup_irq_pool(mc_bus);
+	if (mc->gic_supported)
+		fsl_mc_cleanup_irq_pool(mc_bus);
+
 	dev_info(&mc_dev->dev, "DPRC device unbound from driver");
 	return 0;
 }
diff --git a/drivers/staging/fsl-mc/bus/mc-allocator.c b/drivers/staging/fsl-mc/bus/mc-allocator.c
index 0c5fad0..313a533 100644
--- a/drivers/staging/fsl-mc/bus/mc-allocator.c
+++ b/drivers/staging/fsl-mc/bus/mc-allocator.c
@@ -489,6 +489,10 @@ int __must_check fsl_mc_allocate_irqs(struct fsl_mc_device *mc_dev)
 	struct fsl_mc_device_irq **irqs = NULL;
 	struct fsl_mc_bus *mc_bus;
 	struct fsl_mc_resource_pool *res_pool;
+	struct fsl_mc *mc = dev_get_drvdata(fsl_mc_bus_type.dev_root->parent);
+
+	if (!mc->gic_supported)
+		return -ENOTSUPP;
 
 	if (WARN_ON(mc_dev->irqs))
 		goto error;
diff --git a/drivers/staging/fsl-mc/bus/mc-bus.c b/drivers/staging/fsl-mc/bus/mc-bus.c
index a8f29c0..98fddc7 100644
--- a/drivers/staging/fsl-mc/bus/mc-bus.c
+++ b/drivers/staging/fsl-mc/bus/mc-bus.c
@@ -287,6 +287,14 @@ void fsl_mc_driver_unregister(struct fsl_mc_driver *mc_driver)
 }
 EXPORT_SYMBOL_GPL(fsl_mc_driver_unregister);
 
+bool fsl_mc_interrupts_supported(void)
+{
+	struct fsl_mc *mc = dev_get_drvdata(fsl_mc_bus_type.dev_root->parent);
+
+	return mc->gic_supported;
+}
+EXPORT_SYMBOL_GPL(fsl_mc_interrupts_supported);
+
 static int get_dprc_icid(struct fsl_mc_io *mc_io,
 			 int container_id, uint16_t *icid)
 {
@@ -1003,8 +1011,12 @@ static int fsl_mc_bus_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, mc);
 	error = create_mc_irq_domain(pdev, &mc->irq_domain);
-	if (error < 0)
-		return error;
+	if (error < 0) {
+		dev_warn(&pdev->dev,
+			 "WARNING: MC bus driver will run without interrupt support\n");
+	} else {
+		mc->gic_supported = true;
+	}
 
 	/*
 	 * Get physical address of MC portal for the root DPRC:
diff --git a/drivers/staging/fsl-mc/include/mc-private.h b/drivers/staging/fsl-mc/include/mc-private.h
index 67ba488..0757258 100644
--- a/drivers/staging/fsl-mc/include/mc-private.h
+++ b/drivers/staging/fsl-mc/include/mc-private.h
@@ -42,11 +42,15 @@
  * struct fsl_mc - Private data of a "fsl,qoriq-mc" platform device
  * @root_mc_bus_dev: MC object device representing the root DPRC
  * @irq_domain: IRQ domain for the fsl-mc bus type
+ * @gic_supported: boolean flag that indicates if the GIC interrupt controller
+ * is supported.
+ * @num_translation_ranges: number of entries in addr_translation_ranges
  * @addr_translation_ranges: array of bus to system address translation ranges
  */
 struct fsl_mc {
 	struct fsl_mc_device *root_mc_bus_dev;
 	struct irq_domain *irq_domain;
+	bool gic_supported;
 	uint8_t num_translation_ranges;
 	struct fsl_mc_addr_translation_range *translation_ranges;
 };
diff --git a/drivers/staging/fsl-mc/include/mc.h b/drivers/staging/fsl-mc/include/mc.h
index 0a2f381d..c2a702e4 100644
--- a/drivers/staging/fsl-mc/include/mc.h
+++ b/drivers/staging/fsl-mc/include/mc.h
@@ -209,6 +209,8 @@ int __must_check __fsl_mc_driver_register(struct fsl_mc_driver *fsl_mc_driver,
 
 void fsl_mc_driver_unregister(struct fsl_mc_driver *driver);
 
+bool fsl_mc_interrupts_supported(void);
+
 int __must_check fsl_mc_portal_allocate(struct fsl_mc_device *mc_dev,
 					uint16_t mc_io_flags,
 					struct fsl_mc_io **new_mc_io);
-- 
1.7.5.4

