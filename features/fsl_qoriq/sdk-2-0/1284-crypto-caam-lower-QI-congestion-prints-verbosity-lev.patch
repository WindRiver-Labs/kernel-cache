From 65bf0828e9331a15b4edea218b7055c47e20c3b2 Mon Sep 17 00:00:00 2001
From: Alex Porosanu <alexandru.porosanu@nxp.com>
Date: Thu, 7 Apr 2016 13:39:32 +0300
Subject: [PATCH 1284/1383] crypto: caam - lower QI congestion prints verbosity
 level

Whenever congestion occurs on the SEC response FQs, a message
is printed on the console. The same happens when the congestion
no longer happens.
These prints, albeit rate limited, are detrimental to the overall
system performance.
Thus, this patch makes these prints to be shown only on the
debug error level, as well as add a new debugfs counter for
counting how many times the congestion state has occurred.
The debugfs file where this is held can be found in the
following path:
/sys/kernel/debug/<CAAM device name>/ctl/qi_congested

Signed-off-by: Alex Porosanu <alexandru.porosanu@nxp.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/crypto/caam/ctrl.c   | 42 ++++++++++++++----------------------------
 drivers/crypto/caam/intern.h | 21 +++++++++++++++++++++
 drivers/crypto/caam/qi.c     | 34 +++++++++++++++++++++++++++++-----
 3 files changed, 64 insertions(+), 33 deletions(-)

diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c
index 7ac93b9..93ea6e3 100644
--- a/drivers/crypto/caam/ctrl.c
+++ b/drivers/crypto/caam/ctrl.c
@@ -501,23 +501,6 @@ static int caam_rng_init(struct device *dev)
 	return 0;
 }
 
-#ifdef CONFIG_DEBUG_FS
-static int caam_debugfs_u64_get(void *data, u64 *val)
-{
-	*val = caam64_to_cpu(*(u64 *)data);
-	return 0;
-}
-
-static int caam_debugfs_u32_get(void *data, u64 *val)
-{
-	*val = caam32_to_cpu(*(u32 *)data);
-	return 0;
-}
-
-DEFINE_SIMPLE_ATTRIBUTE(caam_fops_u32_ro, caam_debugfs_u32_get, NULL, "%llu\n");
-DEFINE_SIMPLE_ATTRIBUTE(caam_fops_u64_ro, caam_debugfs_u64_get, NULL, "%llu\n");
-#endif
-
 /* Probe routine for CAAM top (controller) level */
 static int caam_probe(struct platform_device *pdev)
 {
@@ -701,6 +684,17 @@ static int caam_probe(struct platform_device *pdev)
 		goto iounmap_ctrl;
 	}
 
+#ifdef CONFIG_DEBUG_FS
+	/*
+	 * FIXME: needs better naming distinction, as some amalgamation of
+	 * "caam" and nprop->full_name. The OF name isn't distinctive,
+	 * but does separate instances
+	 */
+	perfmon = (struct caam_perfmon __force *)&ctrl->perfmon;
+
+	ctrlpriv->dfs_root = debugfs_create_dir(dev_name(dev), NULL);
+	ctrlpriv->ctl = debugfs_create_dir("ctl", ctrlpriv->dfs_root);
+#endif
 	ring = 0;
 	ctrlpriv->total_jobrs = 0;
 	for_each_available_child_of_node(nprop, np)
@@ -771,17 +765,6 @@ static int caam_probe(struct platform_device *pdev)
 		 ctrlpriv->total_jobrs, ctrlpriv->qi_present);
 
 #ifdef CONFIG_DEBUG_FS
-	/*
-	 * FIXME: needs better naming distinction, as some amalgamation of
-	 * "caam" and nprop->full_name. The OF name isn't distinctive,
-	 * but does separate instances
-	 */
-	perfmon = (struct caam_perfmon __force *)&ctrl->perfmon;
-
-	ctrlpriv->dfs_root = debugfs_create_dir(dev_name(dev), NULL);
-	ctrlpriv->ctl = debugfs_create_dir("ctl", ctrlpriv->dfs_root);
-
-	/* Controller-level - performance monitor counters */
 
 	ctrlpriv->ctl_rq_dequeued =
 		debugfs_create_file("rq_dequeued",
@@ -864,6 +847,9 @@ static int caam_probe(struct platform_device *pdev)
 	return 0;
 
 caam_remove:
+#ifdef CONFIG_DEBUG_FS
+	debugfs_remove_recursive(ctrlpriv->dfs_root);
+#endif
 	caam_remove(pdev);
 iounmap_ctrl:
 	iounmap(ctrl);
diff --git a/drivers/crypto/caam/intern.h b/drivers/crypto/caam/intern.h
index 8780fba..6981659 100644
--- a/drivers/crypto/caam/intern.h
+++ b/drivers/crypto/caam/intern.h
@@ -124,9 +124,30 @@ struct caam_drv_private {
 
 	struct debugfs_blob_wrapper ctl_kek_wrap, ctl_tkek_wrap, ctl_tdsk_wrap;
 	struct dentry *ctl_kek, *ctl_tkek, *ctl_tdsk;
+#ifdef CONFIG_CAAM_QI
+	struct dentry *qi_congested;
+#endif
 #endif
 };
 
 void caam_jr_algapi_init(struct device *dev);
 void caam_jr_algapi_remove(struct device *dev);
+
+#ifdef CONFIG_DEBUG_FS
+static int caam_debugfs_u64_get(void *data, u64 *val)
+{
+	*val = caam64_to_cpu(*(u64 *)data);
+	return 0;
+}
+
+static int caam_debugfs_u32_get(void *data, u64 *val)
+{
+	*val = caam32_to_cpu(*(u32 *)data);
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(caam_fops_u32_ro, caam_debugfs_u32_get, NULL, "%llu\n");
+DEFINE_SIMPLE_ATTRIBUTE(caam_fops_u64_ro, caam_debugfs_u64_get, NULL, "%llu\n");
+#endif
+
 #endif /* INTERN_H */
diff --git a/drivers/crypto/caam/qi.c b/drivers/crypto/caam/qi.c
index aa53af3..854a934 100644
--- a/drivers/crypto/caam/qi.c
+++ b/drivers/crypto/caam/qi.c
@@ -72,6 +72,14 @@ static struct caam_qi_priv qipriv ____cacheline_aligned;
  */
 static bool caam_congested __read_mostly;
 
+#ifdef CONFIG_DEBUG_FS
+/*
+ * This is a counter for the number of times the congestion group (where all
+ * the response queueus are) was congested. Incremented each time the congestion
+ * callback is called with congested == true,.
+ */
+static u64 times_congested;
+#endif
 /*
  * CPU from where the module initialised. This is required because
  * QMAN driver requires CGRs to be removed from same CPU from where
@@ -579,10 +587,15 @@ static void rsp_cgr_cb(struct qman_portal *qm, struct qman_cgr *cgr,
 {
 	caam_congested = congested;
 
-	if (congested)
-		pr_warn_ratelimited("CAAM rsp path congested\n");
-	else
-		pr_info_ratelimited("CAAM rsp path congestion state exit\n");
+	if (congested) {
+#ifdef CONFIG_DEBUG_FS
+		times_congested++;
+#endif
+		pr_debug_ratelimited("CAAM rsp path congested\n");
+
+	} else {
+		pr_debug_ratelimited("CAAM rsp path congestion state exit\n");
+	}
 }
 
 static int caam_qi_napi_schedule(struct qman_portal *p, struct caam_napi *np)
@@ -801,6 +814,11 @@ int caam_qi_init(struct platform_device *caam_pdev, struct device_node *np)
 	/* Response path cannot be congested */
 	caam_congested = false;
 
+#ifdef CONFIG_DEBUG_FS
+	/* The response path was congested 0 times */
+	times_congested = 0;
+#endif
+
 	/* kmem_cache wasn't yet allocated */
 	qi_cache = NULL;
 
@@ -852,7 +870,13 @@ int caam_qi_init(struct platform_device *caam_pdev, struct device_node *np)
 
 	/* Done with the CGRs; restore the cpus allowed mask */
 	set_cpus_allowed_ptr(current, &old_cpumask);
-
+#ifdef CONFIG_DEBUG_FS
+	ctrlpriv->qi_congested =
+			debugfs_create_file("qi_congested",
+					    S_IRUSR | S_IRGRP | S_IROTH,
+					    ctrlpriv->ctl, &times_congested,
+					    &caam_fops_u64_ro);
+#endif
 	dev_info(qidev, "Linux CAAM Queue I/F driver initialised\n");
 
 	return 0;
-- 
2.8.1

