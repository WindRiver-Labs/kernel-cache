From b55f528ceb343bc6760c17b7464f57366901007b Mon Sep 17 00:00:00 2001
From: "J. German Rivera" <German.Rivera@freescale.com>
Date: Wed, 8 Apr 2015 17:55:54 -0500
Subject: [PATCH 0480/1383] staging: fsl-mc: Do programing of MSIs outside of
 devm_request_threaded_irq()

Normally, devm_request_threaded_irq() programs the MSI physically in
the device (by invoking a device-specific callback). However, for MC
IRQs, we have to program the MSI outside of this callback, because this
callback is invoked with interrupts disabled, and we don't have a reliable
way of sending commands to the MC from atomic context. This will be even
more so, once we add mutex locking to mc_send_command(). When invoked
from atomic context, mc_send_command() will to a mutex_trylock() and
if it is not able to grab the mutex, it will return with error without
sending the command to the MC.

Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
Change-Id: I091b889f6f5056157c5e232dd633073a5dac49ca
Reviewed-on: http://git.am.freescale.net:8181/34640
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-mc/bus/dprc-driver.c | 27 ++++++++++++--
 drivers/staging/fsl-mc/bus/mc-bus.c      | 60 ++++----------------------------
 2 files changed, 31 insertions(+), 56 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/dprc-driver.c b/drivers/staging/fsl-mc/bus/dprc-driver.c
index 8315c80..b84cca3 100644
--- a/drivers/staging/fsl-mc/bus/dprc-driver.c
+++ b/drivers/staging/fsl-mc/bus/dprc-driver.c
@@ -610,9 +610,20 @@ static int register_dprc_irq_handlers(struct fsl_mc_device *mc_dev)
 	for (i = 0; i < ARRAY_SIZE(irq_handlers); i++) {
 		irq = mc_dev->irqs[i];
 
+		if (WARN_ON(irq->dev_irq_index != i)) {
+			error = -EINVAL;
+			goto error_unregister_irq_handlers;
+		}
+
 		/*
-		 * NOTE: devm_request_threaded_irq() invokes the device-specific
-		 * function that programs the MSI physically in the device
+		 * NOTE: Normally, devm_request_threaded_irq() programs the MSI
+		 * physically in the device (by invoking a device-specific
+		 * callback). However, for MC IRQs, we have to program the MSI
+		 * outside of this callback, because this callback is invoked
+		 * with interrupts disabled, and we don't have a reliable
+		 * way of sending commands to the MC from atomic context.
+		 * The MC callback just set the msi_paddr and msi_value
+		 * fields of the irq structure.
 		 */
 		error = devm_request_threaded_irq(&mc_dev->dev,
 						  irq->irq_number,
@@ -631,6 +642,18 @@ static int register_dprc_irq_handlers(struct fsl_mc_device *mc_dev)
 		}
 
 		num_irq_handlers_registered++;
+		error = dprc_set_irq(mc_dev->mc_io,
+				     mc_dev->mc_handle,
+				     i,
+				     irq->msi_paddr,
+				     irq->msi_value,
+				     irq->irq_number);
+		if (error < 0) {
+			dev_err(&mc_dev->dev,
+				"dprc_set_irq() failed for IRQ %u: %d\n",
+				i, error);
+			goto error_unregister_irq_handlers;
+		}
 	}
 
 	return 0;
diff --git a/drivers/staging/fsl-mc/bus/mc-bus.c b/drivers/staging/fsl-mc/bus/mc-bus.c
index f85007f..a8f29c0 100644
--- a/drivers/staging/fsl-mc/bus/mc-bus.c
+++ b/drivers/staging/fsl-mc/bus/mc-bus.c
@@ -649,59 +649,9 @@ static void mc_bus_unmask_msi_irq(struct irq_data *d)
 	irq_chip_unmask_parent(d);
 }
 
-static void program_msi_at_mc(struct fsl_mc_device *mc_bus_dev,
-			      struct fsl_mc_device_irq *irq)
-{
-	int error;
-	int mc_obj_index;
-	struct fsl_mc_device *owner_mc_dev = irq->mc_dev;
-
-	if (WARN_ON(!owner_mc_dev))
-		return;
-
-	if (owner_mc_dev == mc_bus_dev) {
-		/*
-		 * IRQ is for the mc_bus_dev's DPRC itself
-		 */
-		error = dprc_set_irq(mc_bus_dev->mc_io,
-				     mc_bus_dev->mc_handle,
-				     irq->dev_irq_index,
-				     irq->msi_paddr,
-				     irq->msi_value,
-				     irq->irq_number);
-		if (error < 0) {
-			dev_err(&owner_mc_dev->dev,
-				"dprc_set_irq() failed: %d\n", error);
-		}
-	} else {
-		/*
-		 * Get object index in the parent DPRC for the MC object device
-		 * that owns this IRQ
-		 *
-		 * QUESTION: Can the index of an object in the DPRC change under
-		 * us, if preceding objects are removed from the DPRC?
-		 */
-		error = dprc_lookup_object(mc_bus_dev, owner_mc_dev,
-					   &mc_obj_index);
-		if (error < 0)
-			return;
-
-		error = dprc_obj_set_irq(mc_bus_dev->mc_io,
-					 mc_bus_dev->mc_handle,
-					 mc_obj_index,
-					 irq->dev_irq_index,
-					 irq->msi_paddr,
-					 irq->msi_value,
-					 irq->irq_number);
-		if (error < 0) {
-			dev_err(&owner_mc_dev->dev,
-				"dprc_obj_set_irq() failed: %d\n", error);
-		}
-	}
-}
-
 /*
- * This function is invoked from devm_request_threaded_irq()
+ * This function is invoked from devm_request_irq(),
+ * devm_request_threaded_irq(), dev_free_irq()
  */
 static void mc_bus_msi_domain_write_msg(struct irq_data *irq_data,
 					struct msi_msg *msg)
@@ -721,9 +671,11 @@ static void mc_bus_msi_domain_write_msg(struct irq_data *irq_data,
 		irq_res->msi_value = msg->data;
 
 		/*
-		 * Program the MSI (paddr, value) pair in the device:
+		 * NOTE: We cannot do the actual programming of the MSI
+		 * in the MC, as this function is invoked in atomic context
+		 * (interrupts disabled) and we cannot reliably send MC commands
+		 * in atomic context.
 		 */
-		program_msi_at_mc(mc_bus_dev, irq_res);
 	}
 }
 
-- 
2.8.1

