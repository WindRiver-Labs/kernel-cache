From 8b5d5bdc114071ffd99dad338b637bba09f84903 Mon Sep 17 00:00:00 2001
From: "J. German Rivera" <German.Rivera@freescale.com>
Date: Wed, 1 Jul 2015 16:12:39 -0500
Subject: [PATCH 0496/1383] staging: fsl-mc: Don't use jiffies in atomic
 polling loop

Don't use jiffies to calculate timeout in MC polling loop
executed in atomic context. Since interrupts are disabled,
jiffies will not get updated and the polling will never
terminate, if the MC is not responding.

Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
Change-Id: Ib9cc0492b6f5327b3f284eb5ea0f83706109ccfd
Reviewed-on: http://git.am.freescale.net:8181/39152
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-mc/bus/mc-sys.c | 50 ++++++++++++++++++++++++++++++-------
 1 file changed, 41 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/mc-sys.c b/drivers/staging/fsl-mc/bus/mc-sys.c
index 45d24f5..b50a752 100644
--- a/drivers/staging/fsl-mc/bus/mc-sys.c
+++ b/drivers/staging/fsl-mc/bus/mc-sys.c
@@ -677,8 +677,9 @@ static int mc_completion_wait(struct fsl_mc_io *mc_io, struct mc_command *cmd,
 	return 0;
 }
 
-static int mc_polling_wait(struct fsl_mc_io *mc_io, struct mc_command *cmd,
-			   enum mc_cmd_status *mc_status)
+static int mc_polling_wait_preemptible(struct fsl_mc_io *mc_io,
+				       struct mc_command *cmd,
+				       enum mc_cmd_status *mc_status)
 {
 	enum mc_cmd_status status;
 	unsigned long jiffies_until_timeout =
@@ -689,12 +690,8 @@ static int mc_polling_wait(struct fsl_mc_io *mc_io, struct mc_command *cmd,
 		if (status != MC_CMD_STATUS_READY)
 			break;
 
-		if (preemptible()) {
-			usleep_range(MC_CMD_COMPLETION_POLLING_MIN_SLEEP_USECS,
-				     MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);
-		} else {
-			udelay(MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);
-		}
+		usleep_range(MC_CMD_COMPLETION_POLLING_MIN_SLEEP_USECS,
+			     MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);
 
 		if (time_after_eq(jiffies, jiffies_until_timeout)) {
 			pr_debug("MC command timed out (portal: %#llx, obj handle: %#x, command: %#x)\n",
@@ -712,6 +709,39 @@ static int mc_polling_wait(struct fsl_mc_io *mc_io, struct mc_command *cmd,
 	return 0;
 }
 
+static int mc_polling_wait_atomic(struct fsl_mc_io *mc_io,
+				  struct mc_command *cmd,
+				  enum mc_cmd_status *mc_status)
+{
+	enum mc_cmd_status status;
+	unsigned long timeout_usecs = MC_CMD_COMPLETION_TIMEOUT_MS * 1000;
+
+	BUILD_BUG_ON((MC_CMD_COMPLETION_TIMEOUT_MS * 1000) %
+		     MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS != 0);
+
+	for (;;) {
+		status = mc_read_response(mc_io->portal_virt_addr, cmd);
+		if (status != MC_CMD_STATUS_READY)
+			break;
+
+		udelay(MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS);
+		timeout_usecs -= MC_CMD_COMPLETION_POLLING_MAX_SLEEP_USECS;
+		if (timeout_usecs == 0) {
+			pr_debug("MC command timed out (portal: %#llx, obj handle: %#x, command: %#x)\n",
+				 mc_io->portal_phys_addr,
+				 (unsigned int)
+					MC_CMD_HDR_READ_TOKEN(cmd->header),
+				 (unsigned int)
+					MC_CMD_HDR_READ_CMDID(cmd->header));
+
+			return -ETIMEDOUT;
+		}
+	}
+
+	*mc_status = status;
+	return 0;
+}
+
 /**
  * Sends a command to the MC device using the given MC I/O object
  *
@@ -747,8 +777,10 @@ int mc_send_command(struct fsl_mc_io *mc_io, struct mc_command *cmd)
 	 */
 	if (mc_io->mc_command_done_irq_armed && !dpmcp_completion_intr_disabled)
 		error = mc_completion_wait(mc_io, cmd, &status);
+	else if (preemptible())
+		error = mc_polling_wait_preemptible(mc_io, cmd, &status);
 	else
-		error = mc_polling_wait(mc_io, cmd, &status);
+		error = mc_polling_wait_atomic(mc_io, cmd, &status);
 
 	if (error < 0)
 		goto common_exit;
-- 
2.8.1

