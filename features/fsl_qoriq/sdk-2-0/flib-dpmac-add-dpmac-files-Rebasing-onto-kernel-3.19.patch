From b16e9d3b16d65d8aef38a412960e2568a8f3d094 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Tue, 15 Sep 2015 10:27:19 -0500
Subject: [PATCH 0807/1429] flib,dpmac: add dpmac files (Rebasing onto kernel
 3.19, MC 0.6)

patches moved from 4.0 kernel

Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
[Stuart: cherry-picked patch and split it up]
Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-dpaa2/mac/Kconfig      |   32 ++
 drivers/staging/fsl-dpaa2/mac/Makefile     |   11 +
 drivers/staging/fsl-dpaa2/mac/dpmac.c      |  387 +++++++++++++++++
 drivers/staging/fsl-dpaa2/mac/fixed.c      |  362 ++++++++++++++++
 drivers/staging/fsl-dpaa2/mac/phy_proxy.c  |  642 ++++++++++++++++++++++++++++
 drivers/staging/fsl-mc/include/dpmac-cmd.h |  192 +++++++++
 drivers/staging/fsl-mc/include/dpmac.h     |  528 +++++++++++++++++++++++
 7 files changed, 2154 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/fsl-dpaa2/mac/Kconfig
 create mode 100644 drivers/staging/fsl-dpaa2/mac/Makefile
 create mode 100644 drivers/staging/fsl-dpaa2/mac/dpmac.c
 create mode 100644 drivers/staging/fsl-dpaa2/mac/fixed.c
 create mode 100644 drivers/staging/fsl-dpaa2/mac/phy_proxy.c
 create mode 100644 drivers/staging/fsl-mc/include/dpmac-cmd.h
 create mode 100644 drivers/staging/fsl-mc/include/dpmac.h

diff --git a/drivers/staging/fsl-dpaa2/mac/Kconfig b/drivers/staging/fsl-dpaa2/mac/Kconfig
new file mode 100644
index 0000000..1a2a439
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/mac/Kconfig
@@ -0,0 +1,32 @@
+config FSL_DPAA2_PHY_PROXY
+	tristate "DPAA2 PHY proxy interface"
+	depends on FSL_MC_BUS
+	depends on FSL_LDPAA_ETH
+	select FSL_DPAA2_FIXED_PHY_HACK
+	---help---
+	Prototype driver for DPAA2 PHY interface object.
+	This driver works as a proxy between phylib including phy drivers and
+	the MC firmware.  It receives updates on link state changes from PHY
+	lib and forwards them to MC and receives interrupt from MC whenever
+	a request is made to change the link state.
+
+
+config FSL_DPAA2_PPX_NETDEVS
+	bool "Expose net interfaces for PHYs"
+	default n
+	depends on FSL_DPAA2_PHY_PROXY
+	---help---
+	Exposes phyX net interfaces which allow direct control over the PHYs.
+	.
+	.
+	Leave disabled if unsure.
+
+config FSL_DPAA2_FIXED_PHY_HACK
+	bool "Hack for fixed links, to remove in v3.18"
+	default y
+	depends on FSL_DPAA2_PHY_PROXY
+	---help---
+	Temporary hack to allow registration of a fixed PHY without a device
+	tree node and actual fixed-link property or child node.
+	Plan is to remove this in kernel 3.18, it includes an updated API which
+	should make this work.
diff --git a/drivers/staging/fsl-dpaa2/mac/Makefile b/drivers/staging/fsl-dpaa2/mac/Makefile
new file mode 100644
index 0000000..47282de
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/mac/Makefile
@@ -0,0 +1,11 @@
+
+obj-$(CONFIG_FSL_DPAA2_FIXED_PHY_HACK) += fixed.o
+obj-$(CONFIG_FSL_DPAA2_PHY_PROXY) += dpaa2_ppx.o
+
+dpaa2_ppx-objs := phy_proxy.o dpmac.o
+
+all:
+	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
+
+clean:
+	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac.c b/drivers/staging/fsl-dpaa2/mac/dpmac.c
new file mode 100644
index 0000000..a8cdf99
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac.c
@@ -0,0 +1,387 @@
+/* Copyright 2013-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "../../fsl-mc/include/mc-sys.h"
+#include "../../fsl-mc/include/mc-cmd.h"
+#include "../../fsl-mc/include/dpmac.h"
+#include "../../fsl-mc/include/dpmac-cmd.h"
+
+int dpmac_open(struct fsl_mc_io *mc_io, int dpmac_id, uint16_t *token)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_OPEN,
+					  MC_CMD_PRI_LOW, 0);
+	DPMAC_CMD_OPEN(cmd, dpmac_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+
+	return err;
+}
+
+int dpmac_close(struct fsl_mc_io *mc_io, uint16_t token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_CLOSE, MC_CMD_PRI_HIGH,
+					  token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpmac_create(struct fsl_mc_io *mc_io,
+		 const struct dpmac_cfg *cfg,
+		uint16_t *token)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_CREATE,
+					  MC_CMD_PRI_LOW, 0);
+	DPMAC_CMD_CREATE(cmd, cfg);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	*token = MC_CMD_HDR_READ_TOKEN(cmd.header);
+
+	return 0;
+}
+
+int dpmac_destroy(struct fsl_mc_io *mc_io, uint16_t token)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_DESTROY,
+					  MC_CMD_PRI_LOW, token);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpmac_set_irq(struct fsl_mc_io *mc_io,
+		  uint16_t token,
+		 uint8_t irq_index,
+		 uint64_t irq_addr,
+		 uint32_t irq_val,
+		 int user_irq_id)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_IRQ,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpmac_get_irq(struct fsl_mc_io *mc_io,
+		  uint16_t token,
+		 uint8_t irq_index,
+		 int *type,
+		 uint64_t *irq_addr,
+		 uint32_t *irq_val,
+		 int *user_irq_id)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_IRQ,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_GET_IRQ(cmd, irq_index);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPMAC_RSP_GET_IRQ(cmd, *type, *irq_addr, *irq_val, *user_irq_id);
+
+	return 0;
+}
+
+int dpmac_set_irq_enable(struct fsl_mc_io *mc_io,
+			 uint16_t token,
+			uint8_t irq_index,
+			uint8_t en)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_IRQ_ENABLE,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_SET_IRQ_ENABLE(cmd, irq_index, en);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpmac_get_irq_enable(struct fsl_mc_io *mc_io,
+			 uint16_t token,
+			uint8_t irq_index,
+			uint8_t *en)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_IRQ_ENABLE,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_GET_IRQ_ENABLE(cmd, irq_index);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPMAC_RSP_GET_IRQ_ENABLE(cmd, *en);
+
+	return 0;
+}
+
+int dpmac_set_irq_mask(struct fsl_mc_io *mc_io,
+		       uint16_t token,
+		      uint8_t irq_index,
+		      uint32_t mask)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_IRQ_MASK,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_SET_IRQ_MASK(cmd, irq_index, mask);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpmac_get_irq_mask(struct fsl_mc_io *mc_io,
+		       uint16_t token,
+		      uint8_t irq_index,
+		      uint32_t *mask)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_IRQ_MASK,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_GET_IRQ_MASK(cmd, irq_index);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPMAC_RSP_GET_IRQ_MASK(cmd, *mask);
+
+	return 0;
+}
+
+int dpmac_get_irq_status(struct fsl_mc_io *mc_io,
+			 uint16_t token,
+			uint8_t irq_index,
+			uint32_t *status)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_IRQ_STATUS,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_GET_IRQ_STATUS(cmd, irq_index);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPMAC_RSP_GET_IRQ_STATUS(cmd, *status);
+
+	return 0;
+}
+
+int dpmac_clear_irq_status(struct fsl_mc_io *mc_io,
+			   uint16_t token,
+			  uint8_t irq_index,
+			  uint32_t status)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_CLEAR_IRQ_STATUS,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpmac_get_attributes(struct fsl_mc_io *mc_io,
+			 uint16_t token,
+			struct dpmac_attr *attr)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_ATTR,
+					  MC_CMD_PRI_LOW, token);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPMAC_RSP_GET_ATTRIBUTES(cmd, attr);
+
+	return 0;
+}
+
+int dpmac_mdio_read(struct fsl_mc_io *mc_io,
+		    uint16_t token,
+		    struct dpmac_mdio_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_MDIO_READ,
+					  MC_CMD_PRI_LOW,
+					  token);
+	DPMAC_CMD_MDIO_READ(cmd, cfg);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	/* retrieve response parameters */
+	DPMAC_RSP_MDIO_READ(cmd, cfg->data);
+
+	return 0;
+}
+
+int dpmac_mdio_write(struct fsl_mc_io *mc_io,
+		     uint16_t token,
+		     struct dpmac_mdio_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_MDIO_WRITE,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_MDIO_WRITE(cmd, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpmac_get_link_cfg(struct fsl_mc_io *mc_io,
+		       uint16_t token,
+		      struct dpmac_link_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+	int err = 0;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_LINK_CFG,
+					  MC_CMD_PRI_LOW, token);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	DPMAC_RSP_GET_LINK_CFG(cmd, cfg);
+
+	return 0;
+}
+
+int dpmac_set_link_state(struct fsl_mc_io *mc_io,
+			 uint16_t token,
+		      struct dpmac_link_state *link_state)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_SET_LINK_STATE,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_SET_LINK_STATE(cmd, link_state);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpmac_get_counter(struct fsl_mc_io *mc_io, uint16_t token,
+		      enum dpmac_counter type,
+			   uint64_t *counter)
+{
+	struct mc_command cmd = { 0 };
+	int err = 0;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPMAC_CMDID_GET_COUNTER,
+					  MC_CMD_PRI_LOW, token);
+	DPMAC_CMD_GET_COUNTER(cmd, type);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	DPMAC_RSP_GET_COUNTER(cmd, *counter);
+
+	return 0;
+}
diff --git a/drivers/staging/fsl-dpaa2/mac/fixed.c b/drivers/staging/fsl-dpaa2/mac/fixed.c
new file mode 100644
index 0000000..dec6cd3
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/mac/fixed.c
@@ -0,0 +1,362 @@
+/*
+ * Fixed MDIO bus (MDIO bus emulation with fixed PHYs)
+ *
+ * Author: Vitaly Bordug <vbordug@ru.mvista.com>
+ *         Anton Vorontsov <avorontsov@ru.mvista.com>
+ *
+ * Copyright (c) 2006-2007 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/list.h>
+#include <linux/mii.h>
+#include <linux/phy.h>
+#include <linux/phy_fixed.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+
+#define MII_REGS_NUM 29
+
+struct fixed_mdio_bus {
+	int irqs[PHY_MAX_ADDR];
+	struct mii_bus *mii_bus;
+	struct list_head phys;
+};
+
+struct fixed_phy {
+	int addr;
+	u16 regs[MII_REGS_NUM];
+	struct phy_device *phydev;
+	struct fixed_phy_status status;
+
+	int (*link_update)(struct net_device *, struct fixed_phy_status *);
+	struct list_head node;
+};
+
+static struct platform_device *pdev;
+static struct fixed_mdio_bus platform_fmb = {
+	.phys = LIST_HEAD_INIT(platform_fmb.phys),
+};
+
+static int fixed_phy_update_regs(struct fixed_phy *fp)
+{
+	u16 bmsr = BMSR_ANEGCAPABLE |
+		   BMSR_ESTATEN | BMSR_100FULL | BMSR_10FULL |
+		   BMSR_100HALF | BMSR_10HALF;
+	u16 bmcr = 0;
+	u16 lpagb = 0;
+	u16 lpa = 0;
+
+	if (fp->status.duplex) {
+		bmcr |= BMCR_FULLDPLX;
+
+		switch (fp->status.speed) {
+		case 1000:
+			bmcr |= BMCR_SPEED1000;
+			lpagb |= LPA_1000FULL;
+			break;
+		case 100:
+			bmcr |= BMCR_SPEED100;
+			lpa |= LPA_100FULL;
+			break;
+		case 10:
+			lpa |= LPA_10FULL;
+			break;
+		default:
+			pr_warn("fixed phy: unknown speed\n");
+			return -EINVAL;
+		}
+	} else {
+		switch (fp->status.speed) {
+		case 1000:
+			bmcr |= BMCR_SPEED1000;
+			lpagb |= LPA_1000HALF;
+			break;
+		case 100:
+			bmcr |= BMCR_SPEED100;
+			lpa |= LPA_100HALF;
+			break;
+		case 10:
+			lpa |= LPA_10HALF;
+			break;
+		default:
+			pr_warn("fixed phy: unknown speed\n");
+			return -EINVAL;
+		}
+	}
+
+	if (fp->status.link)
+		bmsr |= BMSR_LSTATUS | BMSR_ANEGCOMPLETE;
+
+	if (fp->status.pause)
+		lpa |= LPA_PAUSE_CAP;
+
+	if (fp->status.asym_pause)
+		lpa |= LPA_PAUSE_ASYM;
+
+	fp->regs[MII_PHYSID1] = 0;
+	fp->regs[MII_PHYSID2] = 0;
+
+	fp->regs[MII_BMSR] = bmsr;
+	fp->regs[MII_BMCR] = bmcr;
+	fp->regs[MII_LPA] = lpa;
+	fp->regs[MII_STAT1000] = lpagb;
+
+	fp->regs[MII_ESTATUS] = ESTATUS_1000_TFULL | ESTATUS_1000_THALF;
+
+	return 0;
+}
+
+static void fixed_phy_fix_speed(struct fixed_phy *fp, int reg_num, u16 val)
+{
+	if (reg_num != MII_BMCR)
+		return;
+
+	if (val & BMCR_ANENABLE)
+		/* this only works with aneg disabled */
+		return;
+
+	if (val & BMCR_SPEED1000)
+		fp->status.speed = 1000;
+	else if (val & BMCR_SPEED100)
+		fp->status.speed = 100;
+	else
+		fp->status.speed = 10;
+
+	if (val & BMCR_FULLDPLX)
+		fp->status.duplex = 1;
+	else
+		fp->status.duplex = 0;
+}
+
+
+static int fixed_mdio_read(struct mii_bus *bus, int phy_addr, int reg_num)
+{
+	struct fixed_mdio_bus *fmb = bus->priv;
+	struct fixed_phy *fp;
+
+	if (reg_num >= MII_REGS_NUM)
+		return -1;
+
+	list_for_each_entry(fp, &fmb->phys, node) {
+		if (fp->addr == phy_addr) {
+			/* Issue callback if user registered it. */
+			if (fp->link_update) {
+				fp->link_update(fp->phydev->attached_dev,
+						&fp->status);
+				fixed_phy_update_regs(fp);
+			}
+			return fp->regs[reg_num];
+		}
+	}
+
+	return 0xFFFF;
+}
+
+static int fixed_mdio_write(struct mii_bus *bus, int phy_addr, int reg_num,
+			    u16 val)
+{
+	struct fixed_mdio_bus *fmb = bus->priv;
+	struct fixed_phy *fp;
+
+	if (reg_num >= MII_REGS_NUM)
+		return 0;
+
+	list_for_each_entry(fp, &fmb->phys, node) {
+		if (fp->addr == phy_addr) {
+			fixed_phy_fix_speed(fp, reg_num, val);
+			fixed_phy_update_regs(fp);
+		}
+	}
+
+	return 0;
+}
+
+/* If something weird is required to be done with link/speed,
+ * network driver is able to assign a function to implement this.
+ * May be useful for PHY's that need to be software-driven.
+ */
+int fixed_phy_set_link_update2(struct phy_device *phydev,
+			       int (*link_update)(struct net_device *,
+						  struct fixed_phy_status *))
+{
+	struct fixed_mdio_bus *fmb = &platform_fmb;
+	struct fixed_phy *fp;
+
+	if (!link_update || !phydev || !phydev->bus)
+		return -EINVAL;
+
+	list_for_each_entry(fp, &fmb->phys, node) {
+		if (fp->addr == phydev->addr) {
+			fp->link_update = link_update;
+			fp->phydev = phydev;
+			return 0;
+		}
+	}
+
+	return -ENOENT;
+}
+EXPORT_SYMBOL_GPL(fixed_phy_set_link_update2);
+
+int fixed_phy_add2(unsigned int irq, int phy_addr,
+		   struct fixed_phy_status *status)
+{
+	int ret;
+	struct fixed_mdio_bus *fmb = &platform_fmb;
+	struct fixed_phy *fp;
+
+	fp = kzalloc(sizeof(*fp), GFP_KERNEL);
+	if (!fp)
+		return -ENOMEM;
+
+	memset(fp->regs, 0xFF,  sizeof(fp->regs[0]) * MII_REGS_NUM);
+
+	fmb->irqs[phy_addr] = irq;
+
+	fp->addr = phy_addr;
+	fp->status = *status;
+
+	ret = fixed_phy_update_regs(fp);
+	if (ret)
+		goto err_regs;
+
+	list_add_tail(&fp->node, &fmb->phys);
+
+	return 0;
+
+err_regs:
+	kfree(fp);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(fixed_phy_add2);
+
+void fixed_phy_del2(int phy_addr)
+{
+	struct fixed_mdio_bus *fmb = &platform_fmb;
+	struct fixed_phy *fp, *tmp;
+
+	list_for_each_entry_safe(fp, tmp, &fmb->phys, node) {
+		if (fp->addr == phy_addr) {
+			list_del(&fp->node);
+			kfree(fp);
+			return;
+		}
+	}
+}
+EXPORT_SYMBOL_GPL(fixed_phy_del2);
+
+static int phy_fixed_addr;
+static DEFINE_SPINLOCK(phy_fixed_addr_lock);
+
+struct phy_device *fixed_phy_register2(unsigned int irq,
+				       struct fixed_phy_status *status,
+				       struct device_node *np)
+{
+	struct fixed_mdio_bus *fmb = &platform_fmb;
+	struct phy_device *phy;
+	int phy_addr;
+	int ret;
+
+	/* Get the next available PHY address, up to PHY_MAX_ADDR */
+	spin_lock(&phy_fixed_addr_lock);
+	if (phy_fixed_addr == PHY_MAX_ADDR) {
+		spin_unlock(&phy_fixed_addr_lock);
+		return 0;
+	}
+	phy_addr = phy_fixed_addr++;
+	spin_unlock(&phy_fixed_addr_lock);
+
+	ret = fixed_phy_add2(PHY_POLL, phy_addr, status);
+	if (ret < 0)
+		return 0;
+
+	phy = get_phy_device(fmb->mii_bus, phy_addr, false);
+	if (!phy || IS_ERR(phy)) {
+		fixed_phy_del(phy_addr);
+		return 0;
+	}
+
+	of_node_get(np);
+	phy->dev.of_node = np;
+
+	ret = phy_device_register(phy);
+	if (ret) {
+		phy_device_free(phy);
+		of_node_put(np);
+		fixed_phy_del(phy_addr);
+		return 0;
+	}
+
+	return phy;
+}
+
+static int __init fixed_mdio_bus_init(void)
+{
+	struct fixed_mdio_bus *fmb = &platform_fmb;
+	int ret;
+
+	pr_warn("Loaded Fixed MDIO module (DPAA2 hack)!\n");
+
+	pdev = platform_device_register_simple("Fixed MDIO bus (DPAA2)",
+					       0, NULL, 0);
+	if (IS_ERR(pdev)) {
+		ret = PTR_ERR(pdev);
+		goto err_pdev;
+	}
+
+	fmb->mii_bus = mdiobus_alloc();
+	if (fmb->mii_bus == NULL) {
+		ret = -ENOMEM;
+		goto err_mdiobus_reg;
+	}
+
+	snprintf(fmb->mii_bus->id, MII_BUS_ID_SIZE, "fixed-2");
+	fmb->mii_bus->name = "Fixed MDIO Bus (DPAA2)";
+	fmb->mii_bus->priv = fmb;
+	fmb->mii_bus->parent = &pdev->dev;
+	fmb->mii_bus->read = &fixed_mdio_read;
+	fmb->mii_bus->write = &fixed_mdio_write;
+	fmb->mii_bus->irq = fmb->irqs;
+
+	ret = mdiobus_register(fmb->mii_bus);
+	if (ret)
+		goto err_mdiobus_alloc;
+
+	return 0;
+
+err_mdiobus_alloc:
+	mdiobus_free(fmb->mii_bus);
+err_mdiobus_reg:
+	platform_device_unregister(pdev);
+err_pdev:
+	return ret;
+}
+module_init(fixed_mdio_bus_init);
+
+static void __exit fixed_mdio_bus_exit(void)
+{
+	struct fixed_mdio_bus *fmb = &platform_fmb;
+	struct fixed_phy *fp, *tmp;
+
+	mdiobus_unregister(fmb->mii_bus);
+	mdiobus_free(fmb->mii_bus);
+	platform_device_unregister(pdev);
+
+	list_for_each_entry_safe(fp, tmp, &fmb->phys, node) {
+		list_del(&fp->node);
+		kfree(fp);
+	}
+}
+module_exit(fixed_mdio_bus_exit);
+
+MODULE_DESCRIPTION("Fixed MDIO bus (MDIO bus emulation with fixed PHYs) - DPAA2 hack");
+MODULE_AUTHOR("Vitaly Bordug");
+MODULE_LICENSE("GPL");
diff --git a/drivers/staging/fsl-dpaa2/mac/phy_proxy.c b/drivers/staging/fsl-dpaa2/mac/phy_proxy.c
new file mode 100644
index 0000000..b04853b
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/mac/phy_proxy.c
@@ -0,0 +1,642 @@
+
+#include <linux/module.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_vlan.h>
+
+#include <uapi/linux/if_bridge.h>
+#include <net/netlink.h>
+#include "../../fsl-mc/include/mc.h"
+#include "../../fsl-mc/include/mc-sys.h"
+
+#include <linux/of.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/phy.h>
+#include <linux/phy_fixed.h>
+
+#include "../../fsl-mc/include/dpmac.h"
+#include "../../fsl-mc/include/dpmac-cmd.h"
+
+
+/* big TODOs:
+ * mac stats
+ */
+
+struct phy_device *fixed_phy_register2(unsigned int irq,
+				       struct fixed_phy_status *status,
+				       struct device_node *np);
+
+
+struct ppx_priv {
+	struct net_device		*netdev;
+	struct fsl_mc_device		*mc_dev;
+	struct dpmac_attr		attr;
+};
+
+/* TODO: fix the 10G modes, mapping can't be right:
+ *  XGMII is paralel
+ *  XAUI is serial, using 8b/10b encoding
+ *  XFI is also serial but using 64b/66b encoding
+ * they can't all map to XGMII...
+ */
+static phy_interface_t ppx_eth_iface_mode[] __maybe_unused =  {
+	/* DPMAC_ETH_IF_MII */
+	PHY_INTERFACE_MODE_MII,
+	/* DPMAC_ETH_IF_RMII */
+	PHY_INTERFACE_MODE_RMII,
+	/* DPMAC_ETH_IF_SMII */
+	PHY_INTERFACE_MODE_SMII,
+	/* DPMAC_ETH_IF_GMII */
+	PHY_INTERFACE_MODE_GMII,
+	/* DPMAC_ETH_IF_RGMII */
+	PHY_INTERFACE_MODE_RGMII,
+	/* DPMAC_ETH_IF_SGMII */
+	PHY_INTERFACE_MODE_SGMII,
+	/* DPMAC_ETH_IF_XGMII */
+	PHY_INTERFACE_MODE_XGMII,
+	/* DPMAC_ETH_IF_QSGMII */
+	PHY_INTERFACE_MODE_QSGMII,
+	/* DPMAC_ETH_IF_XAUI */
+	PHY_INTERFACE_MODE_XGMII,
+	/* DPMAC_ETH_IF_XFI */
+	PHY_INTERFACE_MODE_XGMII,
+
+};
+
+static void ppx_link_changed(struct net_device *netdev);
+
+#ifdef CONFIG_FSL_DPAA2_PPX_NETDEVS
+static netdev_tx_t ppx_dropframe(struct sk_buff *skb, struct net_device *dev);
+static int ppx_open(struct net_device *netdev);
+static int ppx_stop(struct net_device *netdev);
+static struct rtnl_link_stats64 *ppx_get_stats(struct net_device *,
+					       struct rtnl_link_stats64 *);
+
+static int ppx_ethtool_get_settings(struct net_device *, struct ethtool_cmd *);
+static int ppx_ethtool_set_settings(struct net_device *, struct ethtool_cmd *);
+static int ppx_ethtool_get_sset_count(struct net_device *dev, int sset);
+static void ppx_ethtool_get_strings(struct net_device *, u32 stringset, u8 *);
+static void ppx_ethtool_get_stats(struct net_device *, struct ethtool_stats *,
+				  u64 *);
+
+static const struct net_device_ops ppx_ndo = {
+	.ndo_start_xmit		= &ppx_dropframe,
+	/* TODO: temporary to force fixed links up and down */
+	.ndo_open		= &ppx_open,
+	.ndo_stop		= &ppx_stop,
+	.ndo_get_stats64	= &ppx_get_stats,
+};
+
+static const struct ethtool_ops ppx_ethtool_ops = {
+	.get_settings		= &ppx_ethtool_get_settings,
+	.set_settings		= &ppx_ethtool_set_settings,
+	.get_strings		= &ppx_ethtool_get_strings,
+	.get_ethtool_stats	= &ppx_ethtool_get_stats,
+	.get_sset_count		= &ppx_ethtool_get_sset_count,
+};
+
+static netdev_tx_t ppx_dropframe(struct sk_buff *skb, struct net_device *dev)
+{
+	/* we don't support I/O for now, drop the frame */
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+static int ppx_open(struct net_device *netdev)
+{
+	/* force PHY up */
+	phy_start(netdev->phydev);
+
+	return 0;
+}
+
+static int ppx_stop(struct net_device *netdev)
+{
+	/* force PHY down */
+	phy_stop(netdev->phydev);
+
+	return 0;
+}
+
+static int ppx_ethtool_get_settings(struct net_device *netdev,
+				    struct ethtool_cmd *cmd)
+{
+	return phy_ethtool_gset(netdev->phydev, cmd);
+}
+
+static int ppx_ethtool_set_settings(struct net_device *netdev,
+				    struct ethtool_cmd *cmd)
+{
+	return phy_ethtool_sset(netdev->phydev, cmd);
+}
+
+static struct rtnl_link_stats64
+*ppx_get_stats(struct net_device *netdev, struct rtnl_link_stats64 *storage)
+{
+	struct ppx_priv		*priv = netdev_priv(netdev);
+	u64			tmp;
+	int			err;
+
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_MCAST_FRAME,
+				&storage->tx_packets);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_BCAST_FRAME, &tmp);
+	if (err)
+		goto error;
+	storage->tx_packets += tmp;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_UCAST_FRAME, &tmp);
+	if (err)
+		goto error;
+	storage->tx_packets += tmp;
+
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_UNDERSIZED, &storage->tx_dropped);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_BYTE, &storage->tx_bytes);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_ERR_FRAME, &storage->tx_errors);
+	if (err)
+		goto error;
+
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_ALL_FRAME, &storage->rx_packets);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_MCAST_FRAME, &storage->multicast);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_FRAME_DISCARD,
+				&storage->rx_dropped);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_ALIGN_ERR, &storage->rx_errors);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_OVERSIZED, &tmp);
+	if (err)
+		goto error;
+	storage->rx_errors += tmp;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_BYTE, &storage->rx_bytes);
+	if (err)
+		goto error;
+
+	return storage;
+
+error:
+	netdev_err(netdev, "dpmac_get_counter err %d\n", err);
+	return storage;
+}
+
+static struct {
+	enum dpmac_counter id;
+	char name[ETH_GSTRING_LEN];
+} ppx_ethtool_counters[] =  {
+	{DPMAC_CNT_ING_ALL_FRAME,		"rx all frames"},
+	{DPMAC_CNT_ING_GOOD_FRAME,		"rx frames ok"},
+	{DPMAC_CNT_ING_ERR_FRAME,		"rx frame errors"},
+	{DPMAC_CNT_ING_FRAME_DISCARD,		"rx frame discards"},
+	{DPMAC_CNT_ING_UCAST_FRAME,		"rx u-cast"},
+	{DPMAC_CNT_ING_BCAST_FRAME,		"rx b-cast"},
+	{DPMAC_CNT_ING_MCAST_FRAME,		"rx m-cast"},
+	{DPMAC_CNT_ING_FRAME_64,		"rx 64 bytes"},
+	{DPMAC_CNT_ING_FRAME_127,		"rx 65-127 bytes"},
+	{DPMAC_CNT_ING_FRAME_255,		"rx 128-255 bytes"},
+	{DPMAC_CNT_ING_FRAME_511,		"rx 256-511 bytes"},
+	{DPMAC_CNT_ING_FRAME_1023,		"rx 512-1023 bytes"},
+	{DPMAC_CNT_ING_FRAME_1518,		"rx 1024-1518 bytes"},
+	{DPMAC_CNT_ING_FRAME_1519_MAX,		"rx 1519-max bytes"},
+	{DPMAC_CNT_ING_FRAG,			"rx frags"},
+	{DPMAC_CNT_ING_JABBER,			"rx jabber"},
+	{DPMAC_CNT_ING_ALIGN_ERR,		"rx align errors"},
+	{DPMAC_CNT_ING_OVERSIZED,		"rx oversized"},
+	{DPMAC_CNT_ING_VALID_PAUSE_FRAME,	"rx pause"},
+	{DPMAC_CNT_ING_BYTE,			"rx bytes"},
+	{DPMAC_CNT_EGR_UCAST_FRAME,		"tx u-cast"},
+	{DPMAC_CNT_EGR_MCAST_FRAME,		"tx m-cast"},
+	{DPMAC_CNT_EGR_BCAST_FRAME,		"tx b-cast"},
+	{DPMAC_CNT_EGR_ERR_FRAME,		"tx frame errors"},
+	{DPMAC_CNT_EGR_UNDERSIZED,		"tx undersized"},
+	{DPMAC_CNT_EGR_VALID_PAUSE_FRAME,	"tx b-pause"},
+	{DPMAC_CNT_EGR_BYTE,			"tx bytes"},
+
+};
+
+static void ppx_ethtool_get_strings(struct net_device *netdev,
+				    u32 stringset, u8 *data)
+{
+	int i;
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		for (i = 0; i < ARRAY_SIZE(ppx_ethtool_counters); i++)
+			memcpy(data + i * ETH_GSTRING_LEN,
+			       ppx_ethtool_counters[i].name, ETH_GSTRING_LEN);
+		break;
+	}
+}
+
+static void ppx_ethtool_get_stats(struct net_device *netdev,
+				  struct ethtool_stats *stats,
+				  u64 *data)
+{
+	struct ppx_priv		*priv = netdev_priv(netdev);
+	int			i;
+	int			err;
+
+	for (i = 0; i < ARRAY_SIZE(ppx_ethtool_counters); i++) {
+		err = dpmac_get_counter(priv->mc_dev->mc_io,
+					priv->mc_dev->mc_handle,
+					ppx_ethtool_counters[i].id, &data[i]);
+		if (err)
+			netdev_err(netdev, "dpmac_get_counter[%s] err %d\n",
+				   ppx_ethtool_counters[i].name, err);
+	}
+}
+
+static int ppx_ethtool_get_sset_count(struct net_device *dev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(ppx_ethtool_counters);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+#endif /* CONFIG_FSL_DPAA2_PPX_NETDEVS */
+
+#ifdef CONFIG_FSL_DPAA2_FIXED_PHY_HACK
+static struct phy_device *ppx_register_fixed_link(struct net_device *netdev)
+{
+	struct fixed_phy_status status = {
+		.link = 1,
+		.speed = 100,
+		.duplex = 0,
+	};
+	struct phy_device *phy;
+	int err;
+
+	phy = fixed_phy_register2(PHY_POLL, &status, NULL);
+	if (!phy)
+		return NULL;
+	/* disable aneg to let the user fake speeds */
+	phy->autoneg = 0;
+
+	/* TODO: interface mode */
+	err = phy_connect_direct(netdev, phy, &ppx_link_changed,
+				 PHY_INTERFACE_MODE_NA);
+	if (err) {
+		netdev_err(netdev, "phy_connect_direct err %d\n", err);
+		return NULL;
+	}
+
+	return phy;
+}
+#endif /* CONFIG_FSL_DPAA2_FIXED_PHY_HACK */
+
+static void ppx_link_changed(struct net_device *netdev)
+{
+	struct phy_device	*phydev;
+	struct dpmac_link_state	state = { 0 };
+	struct ppx_priv		*priv = netdev_priv(netdev);
+	int			err;
+
+	/* the PHY just notified us of link state change */
+	/* TODO: maybe check that link state actually changed */
+	phydev = netdev->phydev;
+
+	state.up = !!phydev->link;
+	if (phydev->link) {
+		state.rate = phydev->speed;
+
+		if (!phydev->duplex)
+			state.options |= DPMAC_LINK_OPT_HALF_DUPLEX;
+		if (phydev->autoneg)
+			state.options |= DPMAC_LINK_OPT_AUTONEG;
+	}
+	/* this prints out roughly every second while polling, don't enable
+	 * unless absolutely necessary.
+	 * phy_print_status(phydev);
+	 */
+
+	err = dpmac_set_link_state(priv->mc_dev->mc_io,
+				   priv->mc_dev->mc_handle, &state);
+	if (err)
+		dev_err(&netdev->dev, "dpmac_set_link_state err %d\n", err);
+}
+
+static int ppx_configure_link(struct ppx_priv *priv, struct dpmac_link_cfg *cfg)
+{
+	struct phy_device *phydev = priv->netdev->phydev;
+
+	/* TODO: sanity checks? */
+	/* like null PHY :) ignore that error for now */
+	if (!phydev) {
+		netdev_warn(priv->netdev,
+			    "asked to change PHY settings but PHY ref is NULL, ignoring\n");
+		return 0;
+	}
+
+	phydev->speed = cfg->rate;
+	phydev->duplex  = !!(cfg->options & DPMAC_LINK_OPT_HALF_DUPLEX);
+
+	if (cfg->options & DPMAC_LINK_OPT_AUTONEG) {
+		phydev->autoneg = 1;
+		phydev->advertising |= ADVERTISED_Autoneg;
+	} else {
+		phydev->autoneg = 0;
+		phydev->advertising &= ~ADVERTISED_Autoneg;
+	}
+
+	phy_start_aneg(phydev);
+
+	return 0;
+}
+
+static irqreturn_t ppx_irq_handler(int irq_num, void *arg)
+{
+	struct device *dev = (struct device *)arg;
+	struct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);
+	struct ppx_priv *priv = dev_get_drvdata(dev);
+	struct dpmac_link_cfg link_cfg;
+	int err;
+
+	dev_dbg(dev, "DPMAC IRQ %d\n", irq_num);
+	if (mc_dev->irqs[0]->irq_number != irq_num) {
+		dev_err(dev, "received unexpected interrupt %d!\n", irq_num);
+		goto err;
+	}
+
+	err = dpmac_get_link_cfg(mc_dev->mc_io,
+				 priv->mc_dev->mc_handle, &link_cfg);
+	if (err) {
+		dev_err(dev, "dpmac_get_link_cfg err %d\n", err);
+		goto err;
+	}
+
+	err = ppx_configure_link(priv, &link_cfg);
+	if (err)
+		goto err;
+
+	err = dpmac_clear_irq_status(mc_dev->mc_io,
+				     priv->mc_dev->mc_handle,
+				     0, DPMAC_IRQ_EVENT_LINK_CFG_REQ);
+	if (err < 0) {
+		dev_err(&mc_dev->dev,
+			"dpmac_clear_irq_status() err %d\n", err);
+	}
+
+	return IRQ_HANDLED;
+
+err:
+	dev_warn(dev, "DPMAC IRQ %d was not handled!\n", irq_num);
+	return IRQ_NONE;
+}
+
+static int ppx_setup_irqs(struct fsl_mc_device *mc_dev)
+{
+	static const struct fsl_mc_irq_ops dprc_irq_ops = {
+		.mc_set_irq_enable = dpmac_set_irq_enable,
+		.mc_clear_irq_status = dpmac_clear_irq_status,
+		.mc_set_irq = dpmac_set_irq,
+		.mc_set_irq_mask = dpmac_set_irq_mask,
+	};
+
+	const struct fsl_mc_irq_config irq_config = {
+		.irq_handler = NULL,
+		.irq_handler_thread = ppx_irq_handler,
+		.irq_name = "FSL MC DPMAC irq0",
+		.irq_mask = DPMAC_IRQ_EVENT_LINK_CFG_REQ,
+		.data = &mc_dev->dev,
+	};
+	int err;
+
+	if (mc_dev->obj_desc.irq_count != 1) {
+		dev_err(&mc_dev->dev,
+			"expected one interrupt, but the device has %d!\n",
+			mc_dev->obj_desc.irq_count);
+		return -EINVAL;
+	}
+
+	err = fsl_mc_setup_irqs(mc_dev, &dprc_irq_ops);
+	if (err < 0)
+		return err;
+
+	err = fsl_mc_configure_irq(mc_dev, 0, &irq_config);
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+static int __cold
+ppx_probe(struct fsl_mc_device *mc_dev)
+{
+	struct device		*dev;
+	struct ppx_priv		*priv = NULL;
+	struct device_node	*phy_node;
+	struct net_device	*netdev;
+	/*phy_interface_t		if_mode;*/
+	int			err = 0;
+	/* HACK */
+	static char phy_name[255];
+	static int phy_cnt;
+
+	/* just being completely paranoid */
+	if (!mc_dev)
+		return -EFAULT;
+
+	dev = &mc_dev->dev;
+
+	/* prepare a net_dev structure to make the phy lib API happy */
+	netdev = alloc_etherdev(sizeof(*priv));
+	if (!netdev) {
+		dev_err(dev, "alloc_etherdev error\n");
+		err = -ENOMEM;
+		goto err_exit;
+	}
+	priv = netdev_priv(netdev);
+	priv->mc_dev = mc_dev;
+	priv->netdev = netdev;
+
+	SET_NETDEV_DEV(netdev, dev);
+	/* MDIO ID would be better, but we can do that later */
+	snprintf(netdev->name, IFNAMSIZ, "phy%d", mc_dev->obj_desc.id);
+
+	dev_set_drvdata(dev, priv);
+
+	err = fsl_mc_portal_allocate(mc_dev, FSL_MC_IO_PORTAL_SHARED,
+				     &mc_dev->mc_io);
+	if (err) {
+		dev_err(dev, "fsl_mc_portal_allocate err %d\n", err);
+		goto err_free_netdev;
+	}
+	if (!mc_dev->mc_io) {
+		dev_err(dev,
+			"fsl_mc_portal_allocate returned null handle but no error\n");
+		goto err_free_netdev;
+	}
+
+	err = dpmac_open(mc_dev->mc_io, mc_dev->obj_desc.id,
+			 &mc_dev->mc_handle);
+	if (err) {
+		dev_err(dev, "dpmac_open err %d\n", err);
+		goto err_free_mcp;
+	}
+	if (!mc_dev->mc_handle) {
+		dev_err(dev, "dpmac_open returned null handle but no error\n");
+		err = -EFAULT;
+		goto err_free_mcp;
+	}
+
+	err = dpmac_get_attributes(mc_dev->mc_io,
+				   mc_dev->mc_handle, &priv->attr);
+	if (err) {
+		dev_err(dev, "dpmac_get_attributes err %d\n", err);
+		goto err_close;
+	}
+
+	err = ppx_setup_irqs(mc_dev);
+	if (err)
+		goto err_close;
+
+#ifdef CONFIG_FSL_DPAA2_PPX_NETDEVS
+	/* OPTIONAL, register netdev just to make it visible to the user */
+	netdev->netdev_ops = &ppx_ndo;
+	netdev->ethtool_ops = &ppx_ethtool_ops;
+
+	err = register_netdev(priv->netdev);
+	if (err < 0) {
+		dev_err(dev, "register_netdev error %d\n", err);
+		goto err_free_irq;
+	}
+#endif /* CONFIG_FSL_DPAA2_PPX_NETDEVS */
+
+	/* try to connect to the PHY */
+	/* phy_node = of_find_node_by_phandle(priv->attr.phy_id); */
+	sprintf(phy_name, "mdio_phy%d", phy_cnt);
+	phy_node = of_find_node_by_name(NULL, phy_name);
+	if (!phy_node) {
+		dev_err(dev, "PHY node %s not found, trying another...\n",
+			phy_name);
+
+		sprintf(phy_name, "ethernet-phy@%d", phy_cnt);
+		phy_node = of_find_node_by_name(NULL, phy_name);
+		if (!phy_node) {
+			dev_err(dev, "PHY node %s not found, looking for phandle 0x%0x\n",
+				phy_name,
+				priv->attr.phy_id);
+			err = -EFAULT;
+			goto err_no_phy;
+		}
+	}
+	pr_info("dpmac %d -> phy %d (%s)\n", priv->attr.id, phy_cnt, phy_name);
+	phy_cnt++;
+/*
+	if (priv->attr.eth_if <
+	    sizeof(ppx_eth_iface_mode) / sizeof(ppx_eth_iface_mode[0])) {
+		if_mode = ppx_eth_iface_mode[priv->attr.eth_if];
+		dev_info(dev, "\tusing if mode %s for eth_if %d\n",
+			 phy_modes(if_mode), priv->attr.eth_if);
+	} else {
+		if_mode = PHY_INTERFACE_MODE_NA;
+		dev_warn(dev, "unexpected interface mode %d\n",
+			 priv->attr.eth_if);
+	}
+	netdev->phydev = of_phy_connect(netdev, phy_node, &ppx_link_changed,
+					0, if_mode);
+*/
+	netdev->phydev = of_phy_connect(netdev, phy_node, &ppx_link_changed,
+					0, PHY_INTERFACE_MODE_SGMII);
+	if (!netdev->phydev) {
+		dev_err(dev,
+			"ERROR: of_phy_connect returned NULL\n");
+		err = -EFAULT;
+		goto err_no_phy;
+	}
+
+	dev_info(dev, "found a PHY!\n");
+	return 0;
+
+err_no_phy:
+#ifdef CONFIG_FSL_DPAA2_FIXED_PHY_HACK
+	netdev->phydev = ppx_register_fixed_link(netdev);
+	if (!netdev->phydev) {
+		dev_err(dev, "error trying to register fixed PHY!\n");
+		err = -EFAULT;
+		goto err_free_irq;
+	}
+
+	dev_info(dev, "registered fixed PHY!\n");
+	return 0;
+#endif /* CONFIG_FSL_DPAA2_FIXED_PHY_HACK */
+
+err_free_irq:
+	fsl_mc_teardown_irqs(mc_dev);
+err_close:
+	dpmac_close(mc_dev->mc_io, mc_dev->mc_handle);
+err_free_mcp:
+	fsl_mc_portal_free(mc_dev->mc_io);
+err_free_netdev:
+	free_netdev(netdev);
+err_exit:
+	return err;
+}
+
+static int __cold
+ppx_remove(struct fsl_mc_device *devppx)
+{
+	struct device		*dev = &devppx->dev;
+	struct ppx_priv		*priv = dev_get_drvdata(dev);
+
+	unregister_netdev(priv->netdev);
+	fsl_mc_teardown_irqs(priv->mc_dev);
+	dpmac_close(priv->mc_dev->mc_io, priv->mc_dev->mc_handle);
+	fsl_mc_portal_free(priv->mc_dev->mc_io);
+	free_netdev(priv->netdev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(priv);
+
+	return 0;
+}
+
+static const struct fsl_mc_device_match_id ppx_match_id_table[] = {
+	{
+		.vendor = FSL_MC_VENDOR_FREESCALE,
+		.obj_type = "dpmac",
+		.ver_major = DPMAC_VER_MAJOR,
+		.ver_minor = DPMAC_VER_MINOR,
+	},
+	{}
+};
+
+static struct fsl_mc_driver ppx_drv = {
+	.driver = {
+		.name		= KBUILD_MODNAME,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= ppx_probe,
+	.remove		= ppx_remove,
+	.match_id_table = ppx_match_id_table,
+};
+
+module_fsl_mc_driver(ppx_drv);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("DPAA2 PHY proxy interface driver (prototype)");
diff --git a/drivers/staging/fsl-mc/include/dpmac-cmd.h b/drivers/staging/fsl-mc/include/dpmac-cmd.h
new file mode 100644
index 0000000..c123aab
--- /dev/null
+++ b/drivers/staging/fsl-mc/include/dpmac-cmd.h
@@ -0,0 +1,192 @@
+/* Copyright 2013-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _FSL_DPMAC_CMD_H
+#define _FSL_DPMAC_CMD_H
+
+/* DPMAC Version */
+#define DPMAC_VER_MAJOR				3
+#define DPMAC_VER_MINOR				0
+
+/* Command IDs */
+#define DPMAC_CMDID_CLOSE			0x800
+#define DPMAC_CMDID_OPEN			0x80c
+#define DPMAC_CMDID_CREATE			0x90c
+#define DPMAC_CMDID_DESTROY			0x900
+
+#define DPMAC_CMDID_GET_ATTR			0x004
+#define DPMAC_CMDID_RESET			0x005
+
+#define DPMAC_CMDID_SET_IRQ			0x010
+#define DPMAC_CMDID_GET_IRQ			0x011
+#define DPMAC_CMDID_SET_IRQ_ENABLE		0x012
+#define DPMAC_CMDID_GET_IRQ_ENABLE		0x013
+#define DPMAC_CMDID_SET_IRQ_MASK		0x014
+#define DPMAC_CMDID_GET_IRQ_MASK		0x015
+#define DPMAC_CMDID_GET_IRQ_STATUS		0x016
+#define DPMAC_CMDID_CLEAR_IRQ_STATUS		0x017
+
+#define DPMAC_CMDID_MDIO_READ			0x0c0
+#define DPMAC_CMDID_MDIO_WRITE			0x0c1
+#define DPMAC_CMDID_GET_LINK_CFG		0x0c2
+#define DPMAC_CMDID_SET_LINK_STATE		0x0c3
+#define DPMAC_CMDID_GET_COUNTER			0x0c4
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_CREATE(cmd, cfg) \
+	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->mac_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_OPEN(cmd, dpmac_id) \
+	MC_CMD_OP(cmd, 0, 0,  32, int,	    dpmac_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  irq_index);\
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_val);\
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_IRQ(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_IRQ(cmd, type, irq_addr, irq_val, user_irq_id) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
+	MC_RSP_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_SET_IRQ_ENABLE(cmd, irq_index, en) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  en); \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_IRQ_ENABLE(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_IRQ_ENABLE(cmd, en) \
+	MC_RSP_OP(cmd, 0, 0,  8,  uint8_t,  en)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_SET_IRQ_MASK(cmd, irq_index, mask) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, mask);\
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_IRQ_MASK(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_IRQ_MASK(cmd, mask) \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, mask)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_IRQ_STATUS(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_IRQ_STATUS(cmd, status) \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, status)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, status); \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index);\
+} while (0)
+
+/*                cmd, param, offset, width, type,	arg_name */
+#define DPMAC_RSP_GET_ATTRIBUTES(cmd, attr) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  32, int,			attr->phy_id);\
+	MC_RSP_OP(cmd, 0, 32, 32, int,			attr->id);\
+	MC_RSP_OP(cmd, 1, 0,  16, uint16_t,		attr->version.major);\
+	MC_RSP_OP(cmd, 1, 16, 16, uint16_t,		attr->version.minor);\
+	MC_RSP_OP(cmd, 1, 32,  8, enum dpmac_link_type,	attr->link_type);\
+	MC_RSP_OP(cmd, 1, 40,  8, enum dpmac_eth_if,	attr->eth_if);\
+	MC_RSP_OP(cmd, 2, 0,  32, uint32_t,		attr->max_rate);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_MDIO_READ(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->phy_addr); \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  cfg->reg); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_MDIO_READ(cmd, data) \
+	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, data)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_MDIO_WRITE(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->phy_addr); \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  cfg->reg); \
+	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, cfg->data); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_LINK_CFG(cmd, cfg) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  64, uint64_t, cfg->options); \
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, cfg->rate); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_SET_LINK_STATE(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  64, uint64_t, cfg->options); \
+	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->rate); \
+	MC_CMD_OP(cmd, 2, 0,  1,  int,      cfg->up); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_COUNTER(cmd, type) \
+	MC_CMD_OP(cmd, 0, 0,  8, enum dpmac_counter, type)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_COUNTER(cmd, counter) \
+	MC_RSP_OP(cmd, 1, 0, 64, uint64_t, counter)
+
+#endif /* _FSL_DPMAC_CMD_H */
diff --git a/drivers/staging/fsl-mc/include/dpmac.h b/drivers/staging/fsl-mc/include/dpmac.h
new file mode 100644
index 0000000..88091b5
--- /dev/null
+++ b/drivers/staging/fsl-mc/include/dpmac.h
@@ -0,0 +1,528 @@
+/* Copyright 2013-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __FSL_DPMAC_H
+#define __FSL_DPMAC_H
+
+/* Data Path MAC API
+ * Contains initialization APIs and runtime control APIs for DPMAC
+ */
+
+struct fsl_mc_io;
+
+/**
+ * dpmac_open() - Open a control session for the specified object.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @dpmac_id:	DPMAC unique ID
+ * @token:	Returned token; use in subsequent API calls
+ *
+ * This function can be used to open a control session for an
+ * already created object; an object may have been declared in
+ * the DPL or by calling the dpmac_create function.
+ * This function returns a unique authentication token,
+ * associated with the specific object ID and the specific MC
+ * portal; this token must be used in all subsequent commands for
+ * this specific object
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_open(struct fsl_mc_io *mc_io, int dpmac_id, uint16_t *token);
+
+/**
+ * dpmac_close() - Close the control session of the object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ *
+ * After this function is called, no further operations are
+ * allowed on the object without opening a new control session.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_close(struct fsl_mc_io *mc_io, uint16_t token);
+
+/**
+ * enum dpmac_link_type -  DPMAC link type
+ * @DPMAC_LINK_TYPE_NONE: No link
+ * @DPMAC_LINK_TYPE_FIXED: Link is fixed type
+ * @DPMAC_LINK_TYPE_PHY: Link by PHY ID
+ * @DPMAC_LINK_TYPE_BACKPLANE: Backplane link type
+ */
+enum dpmac_link_type {
+	DPMAC_LINK_TYPE_NONE,
+	DPMAC_LINK_TYPE_FIXED,
+	DPMAC_LINK_TYPE_PHY,
+	DPMAC_LINK_TYPE_BACKPLANE
+};
+
+/**
+ * enum dpmac_eth_if - DPMAC Ethrnet interface
+ * @DPMAC_ETH_IF_MII: MII interface
+ * @DPMAC_ETH_IF_RMII: RMII interface
+ * @DPMAC_ETH_IF_SMII: SMII interface
+ * @DPMAC_ETH_IF_GMII: GMII interface
+ * @DPMAC_ETH_IF_RGMII: RGMII interface
+ * @DPMAC_ETH_IF_SGMII: SGMII interface
+ * @DPMAC_ETH_IF_XGMII: XGMII interface
+ * @DPMAC_ETH_IF_QSGMII: QSGMII interface
+ * @DPMAC_ETH_IF_XAUI: XAUI interface
+ * @DPMAC_ETH_IF_XFI: XFI interface
+ */
+enum dpmac_eth_if {
+	DPMAC_ETH_IF_MII,
+	DPMAC_ETH_IF_RMII,
+	DPMAC_ETH_IF_SMII,
+	DPMAC_ETH_IF_GMII,
+	DPMAC_ETH_IF_RGMII,
+	DPMAC_ETH_IF_SGMII,
+	DPMAC_ETH_IF_XGMII,
+	DPMAC_ETH_IF_QSGMII,
+	DPMAC_ETH_IF_XAUI,
+	DPMAC_ETH_IF_XFI
+};
+
+/**
+ * struct dpmac_cfg() - Structure representing DPMAC configuration
+ * @mac_id:	Represents the Hardware MAC ID; in case of multiple WRIOP,
+ *		the MAC IDs are continuous.
+ *		For example:  2 WRIOPs, 16 MACs in each:
+ *				MAC IDs for the 1st WRIOP: 1-16,
+ *				MAC IDs for the 2nd WRIOP: 17-32.
+ */
+struct dpmac_cfg {
+	int mac_id;
+};
+
+/**
+ * dpmac_create() - Create the DPMAC object.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cfg:	Configuration structure
+ * @token:	Returned token; use in subsequent API calls
+ *
+ * Create the DPMAC object, allocate required resources and
+ * perform required initialization.
+ *
+ * The object can be created either by declaring it in the
+ * DPL file, or by calling this function.
+ * This function returns a unique authentication token,
+ * associated with the specific object ID and the specific MC
+ * portal; this token must be used in all subsequent calls to
+ * this specific object. For objects that are created using the
+ * DPL file, call dpmac_open function to get an authentication
+ * token first.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_create(struct fsl_mc_io	*mc_io,
+		 const struct dpmac_cfg	*cfg,
+		uint16_t		*token);
+
+/**
+ * dpmac_destroy() - Destroy the DPMAC object and release all its resources.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpmac_destroy(struct fsl_mc_io *mc_io, uint16_t token);
+
+/* DPMAC IRQ Index and Events */
+
+/* IRQ index */
+#define DPMAC_IRQ_INDEX						0
+/* IRQ event - indicates a change in link state */
+#define DPMAC_IRQ_EVENT_LINK_CFG_REQ		0x00000001
+/* irq event - Indicates that the link state changed */
+#define DPMAC_IRQ_EVENT_LINK_CHANGED		0x00000002
+
+/**
+ * dpmac_set_irq() - Set IRQ information for the DPMAC to trigger an interrupt.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	Identifies the interrupt index to configure
+ * @irq_addr:	Address that must be written to
+ *				signal a message-based interrupt
+ * @irq_val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_set_irq(struct fsl_mc_io	*mc_io,
+		  uint16_t		token,
+		 uint8_t		irq_index,
+		 uint64_t		irq_addr,
+		 uint32_t		irq_val,
+		 int			user_irq_id);
+
+/**
+ * dpmac_get_irq() - Get IRQ information from the DPMAC.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @type:	Interrupt type: 0 represents message interrupt
+ *				type (both irq_addr and irq_val are valid)
+ * @irq_addr:	Returned address that must be written to
+ *				signal the message-based interrupt
+ * @irq_val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_irq(struct fsl_mc_io	*mc_io,
+		  uint16_t		token,
+		 uint8_t		irq_index,
+		 int			*type,
+		 uint64_t		*irq_addr,
+		 uint32_t		*irq_val,
+		 int			*user_irq_id);
+
+/**
+ * dpmac_set_irq_enable() - Set overall interrupt state.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @en:	Interrupt state - enable = 1, disable = 0
+ *
+ * Allows GPP software to control when interrupts are generated.
+ * Each interrupt can have up to 32 causes.  The enable/disable control's the
+ * overall interrupt state. if the interrupt is disabled no causes will cause
+ * an interrupt.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_set_irq_enable(struct fsl_mc_io	*mc_io,
+			 uint16_t		token,
+			uint8_t			irq_index,
+			uint8_t			en);
+
+/**
+ * dpmac_get_irq_enable() - Get overall interrupt state
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @en:		Returned interrupt state - enable = 1, disable = 0
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_irq_enable(struct fsl_mc_io	*mc_io,
+			 uint16_t		token,
+			uint8_t			irq_index,
+			uint8_t			*en);
+
+/**
+ * dpmac_set_irq_mask() - Set interrupt mask.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @mask:	Event mask to trigger interrupt;
+ *			each bit:
+ *				0 = ignore event
+ *				1 = consider event for asserting IRQ
+ *
+ * Every interrupt can have up to 32 causes and the interrupt model supports
+ * masking/unmasking each cause independently
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_set_irq_mask(struct fsl_mc_io	*mc_io,
+		       uint16_t		token,
+		      uint8_t		irq_index,
+		      uint32_t		mask);
+
+/**
+ * dpmac_get_irq_mask() - Get interrupt mask.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @mask:	Returned event mask to trigger interrupt
+ *
+ * Every interrupt can have up to 32 causes and the interrupt model supports
+ * masking/unmasking each cause independently
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_irq_mask(struct fsl_mc_io	*mc_io,
+		       uint16_t		token,
+		      uint8_t		irq_index,
+		      uint32_t		*mask);
+
+/**
+ * dpmac_get_irq_status() - Get the current status of any pending interrupts.
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @status:	Returned interrupts status - one bit per cause:
+ *			0 = no interrupt pending
+ *			1 = interrupt pending
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_irq_status(struct fsl_mc_io	*mc_io,
+			 uint16_t		token,
+			uint8_t			irq_index,
+			uint32_t		*status);
+
+/**
+ * dpmac_clear_irq_status() - Clear a pending interrupt's status
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @status:	Bits to clear (W1C) - one bit per cause:
+ *					0 = don't change
+ *					1 = clear status bit
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_clear_irq_status(struct fsl_mc_io	*mc_io,
+			   uint16_t		token,
+			  uint8_t		irq_index,
+			  uint32_t		status);
+
+/**
+ * struct dpmac_attr - Structure representing DPMAC attributes
+ * @id:		DPMAC object ID
+ * @phy_id:	PHY ID
+ * @link_type: link type
+ * @eth_if: Ethernet interface
+ * @max_rate: Maximum supported rate - in Mbps
+ * @version:	DPMAC version
+ */
+struct dpmac_attr {
+	int id;
+	int phy_id;
+	enum dpmac_link_type link_type;
+	enum dpmac_eth_if eth_if;
+	uint32_t max_rate;
+	/**
+	 * struct version - Structure representing DPMAC version
+	 * @major:	DPMAC major version
+	 * @minor:	DPMAC minor version
+	 */
+	struct {
+		uint16_t major;
+		uint16_t minor;
+	} version;
+};
+
+/**
+ * dpmac_get_attributes - Retrieve DPMAC attributes.
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @attr:	Returned object's attributes
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_attributes(struct fsl_mc_io	*mc_io,
+			 uint16_t		token,
+			struct dpmac_attr	*attr);
+
+/**
+ * struct dpmac_mdio_cfg - DPMAC MDIO read/write parameters
+ * @phy_addr: MDIO device address
+ * @reg: Address of the register within the Clause 45 PHY device from which data
+ *	is to be read
+ * @data: Data read/write from/to MDIO
+ */
+struct dpmac_mdio_cfg {
+	uint8_t	phy_addr;
+	uint8_t	 reg;
+	uint16_t data;
+};
+
+/**
+ * dpmac_mdio_read() - Perform MDIO read transaction
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @cfg:	Structure with MDIO transaction parameters
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_mdio_read(struct fsl_mc_io *mc_io, uint16_t token,
+		    struct dpmac_mdio_cfg *cfg);
+
+
+/**
+ * dpmac_mdio_write() - Perform MDIO write transaction
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @cfg:	Structure with MDIO transaction parameters
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_mdio_write(struct fsl_mc_io *mc_io, uint16_t token,
+		     struct dpmac_mdio_cfg *cfg);
+
+/* DPMAC link configuration/state options */
+
+/* Enable auto-negotiation */
+#define DPMAC_LINK_OPT_AUTONEG		0x0000000000000001ULL
+/* Enable half-duplex mode */
+#define DPMAC_LINK_OPT_HALF_DUPLEX	0x0000000000000002ULL
+/* Enable pause frames */
+#define DPMAC_LINK_OPT_PAUSE		0x0000000000000004ULL
+/* Enable a-symmetric pause frames */
+#define DPMAC_LINK_OPT_ASYM_PAUSE	0x0000000000000008ULL
+
+/**
+ * struct dpmac_link_cfg - Structure representing DPMAC link configuration
+ * @rate: Link's rate - in Mbps
+ * @options: Enable/Disable DPMAC link cfg features (bitmap)
+ */
+struct dpmac_link_cfg {
+	uint32_t rate;
+	uint64_t options;
+};
+
+/**
+ * dpmac_get_link_cfg() - Get Ethernet link configuration
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @cfg:	Returned structure with the link configuration
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_link_cfg(struct fsl_mc_io *mc_io, uint16_t token,
+		       struct dpmac_link_cfg *cfg);
+
+/**
+ * struct dpmac_link_state - DPMAC link configuration request
+ * @rate: Rate in Mbps
+ * @options: Enable/Disable DPMAC link cfg features (bitmap)
+ * @up: Link state
+ */
+struct dpmac_link_state {
+	uint32_t rate;
+	uint64_t options;
+	int up;
+};
+
+/**
+ * dpmac_set_link_state() - Set the Ethernet link status
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @link_state:	Link state configuration
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_set_link_state(struct fsl_mc_io *mc_io, uint16_t token,
+			 struct dpmac_link_state *link_state);
+
+/**
+ * enum dpni_counter - DPNI counter types
+ * @DPMAC_CNT_ING_FRAME_64: counts 64-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_127: counts 65- to 127-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_255: counts 128- to 255-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_511: counts 256- to 511-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_1023: counts 512- to 1023-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_1518: counts 1024- to 1518-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_1519_MAX: counts 1519-octet frame and larger
+ *				  (up to max frame length specified),
+ *				  good or bad.
+ * @DPMAC_CNT_ING_FRAG: counts packet which is shorter than 64 octets received
+ *			with a wrong CRC
+ * @DPMAC_CNT_ING_JABBER: counts packet longer than the maximum frame length
+ *			  specified, with a bad frame check sequence.
+ * @DPMAC_CNT_ING_FRAME_DISCARD: counts dropped packet due to internal errors.
+ *				 Occurs when a receive FIFO overflows.
+ *				 Includes also packets truncated as a result of
+ *				 the receive FIFO overflow.
+ * @DPMAC_CNT_ING_ALIGN_ERR: counts frame with an alignment error
+ *			     (optional used for wrong SFD)
+ * @DPMAC_CNT_EGR_UNDERSIZED: counts packet transmitted that was less than 64
+ *			      octets long with a good CRC.
+ * @DPMAC_CNT_ING_OVERSIZED: counts packet longer than the maximum frame length
+ *			     specified, with a good frame check sequence.
+ * @DPMAC_CNT_ING_VALID_PAUSE_FRAME: counts valid pause frame (regular and PFC).
+ * @DPMAC_CNT_EGR_VALID_PAUSE_FRAME: counts valid pause frame transmitted
+ *				     (regular and PFC).
+ * @DPMAC_CNT_ING_BYTE: counts octet received except preamble for all valid
+			frames and valid pause frames.
+ * @DPMAC_CNT_ING_MCAST_FRAME: counts received multicast frame
+ * @DPMAC_CNT_ING_BCAST_FRAME: counts received broadcast frame
+ * @DPMAC_CNT_ING_ALL_FRAME: counts each good or bad packet received.
+ * @DPMAC_CNT_ING_UCAST_FRAME: counts received unicast frame
+ * @DPMAC_CNT_ING_ERR_FRAME: counts frame received with an error
+ *			     (except for undersized/fragment frame)
+ * @DPMAC_CNT_EGR_BYTE: counts octet transmitted except preamble for all valid
+ *			frames and valid pause frames transmitted.
+ * @DPMAC_CNT_EGR_MCAST_FRAME: counts transmitted multicast frame
+ * @DPMAC_CNT_EGR_BCAST_FRAME: counts transmitted broadcast frame
+ * @DPMAC_CNT_EGR_UCAST_FRAME: counts transmitted unicast frame
+ * @DPMAC_CNT_EGR_ERR_FRAME: counts frame transmitted with an error
+ * @DPMAC_CNT_ING_GOOD_FRAME: counts frame received without error, including
+ *			      pause frames.
+ */
+enum dpmac_counter {
+	DPMAC_CNT_ING_FRAME_64,
+	DPMAC_CNT_ING_FRAME_127,
+	DPMAC_CNT_ING_FRAME_255,
+	DPMAC_CNT_ING_FRAME_511,
+	DPMAC_CNT_ING_FRAME_1023,
+	DPMAC_CNT_ING_FRAME_1518,
+	DPMAC_CNT_ING_FRAME_1519_MAX,
+	DPMAC_CNT_ING_FRAG,
+	DPMAC_CNT_ING_JABBER,
+	DPMAC_CNT_ING_FRAME_DISCARD,
+	DPMAC_CNT_ING_ALIGN_ERR,
+	DPMAC_CNT_EGR_UNDERSIZED,
+	DPMAC_CNT_ING_OVERSIZED,
+	DPMAC_CNT_ING_VALID_PAUSE_FRAME,
+	DPMAC_CNT_EGR_VALID_PAUSE_FRAME,
+	DPMAC_CNT_ING_BYTE,
+	DPMAC_CNT_ING_MCAST_FRAME,
+	DPMAC_CNT_ING_BCAST_FRAME,
+	DPMAC_CNT_ING_ALL_FRAME,
+	DPMAC_CNT_ING_UCAST_FRAME,
+	DPMAC_CNT_ING_ERR_FRAME,
+	DPMAC_CNT_EGR_BYTE,
+	DPMAC_CNT_EGR_MCAST_FRAME,
+	DPMAC_CNT_EGR_BCAST_FRAME,
+	DPMAC_CNT_EGR_UCAST_FRAME,
+	DPMAC_CNT_EGR_ERR_FRAME,
+	DPMAC_CNT_ING_GOOD_FRAME
+};
+
+/**
+ * dpmac_get_counter() - Read a specific DPMAC counter
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @type:	The requested counter
+ * @counter:	Returned counter value
+ *
+ * Return:	The requested counter; '0' otherwise.
+ */
+int dpmac_get_counter(struct fsl_mc_io *mc_io, uint16_t token,
+		      enum dpmac_counter type,
+			   uint64_t *counter);
+
+#endif /* __FSL_DPMAC_H */
-- 
1.7.5.4

