From 4e01272f8d63b993efcea9f1f06fb8c42a27bba6 Mon Sep 17 00:00:00 2001
From: Zhao Qiang <qiang.zhao@nxp.com>
Date: Fri, 25 Dec 2015 16:07:47 +0800
Subject: [PATCH 0411/1383] Maxim/driver: Add driver for maxim ds26522

Add driver for maxim ds26522

Signed-off-by: Zhao Qiang <qiang.zhao@nxp.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/net/Kconfig            |   2 +
 drivers/net/Makefile           |   1 +
 drivers/net/tdm/Kconfig        |  16 ++
 drivers/net/tdm/Makefile       |   5 +
 drivers/net/tdm/slic_ds26522.c | 324 +++++++++++++++++++++++++++++++++++++++++
 drivers/net/tdm/slic_ds26522.h | 172 ++++++++++++++++++++++
 6 files changed, 520 insertions(+)
 create mode 100644 drivers/net/tdm/Kconfig
 create mode 100644 drivers/net/tdm/Makefile
 create mode 100644 drivers/net/tdm/slic_ds26522.c
 create mode 100644 drivers/net/tdm/slic_ds26522.h

diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig
index df51d60..2e6002b 100644
--- a/drivers/net/Kconfig
+++ b/drivers/net/Kconfig
@@ -324,6 +324,8 @@ source "drivers/s390/net/Kconfig"
 
 source "drivers/net/usb/Kconfig"
 
+source "drivers/net/tdm/Kconfig"
+
 source "drivers/net/wireless/Kconfig"
 
 source "drivers/net/wimax/Kconfig"
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index e25fdd7..d0e612f 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -63,6 +63,7 @@ obj-$(CONFIG_XEN_NETDEV_FRONTEND) += xen-netfront.o
 obj-$(CONFIG_XEN_NETDEV_BACKEND) += xen-netback/
 
 obj-$(CONFIG_USB_NET_DRIVERS) += usb/
+obj-$(CONFIG_TDM_NET_DRIVERS) += tdm/
 
 obj-$(CONFIG_HYPERV_NET) += hyperv/
 obj-$(CONFIG_NTB_NETDEV) += ntb_netdev.o
diff --git a/drivers/net/tdm/Kconfig b/drivers/net/tdm/Kconfig
new file mode 100644
index 0000000..5dec0cd
--- /dev/null
+++ b/drivers/net/tdm/Kconfig
@@ -0,0 +1,16 @@
+#
+# TDM Network devices configuration
+#
+menuconfig TDM_NET_DRIVERS
+	tristate "TDM Network Drivers"
+
+if TDM_NET_DRIVERS
+
+config SLIC_DS26522
+	tristate "SLIC MAXIM DS26522 CARD SUPPORT"
+	default n
+	---help---
+	  This module initializes and configures the slic maxim card
+	  in T1 or E1 mode.
+
+endif
diff --git a/drivers/net/tdm/Makefile b/drivers/net/tdm/Makefile
new file mode 100644
index 0000000..406f733
--- /dev/null
+++ b/drivers/net/tdm/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for TDM Network drivers
+#
+
+obj-$(CONFIG_SLIC_DS26522)	+= slic_ds26522.o
diff --git a/drivers/net/tdm/slic_ds26522.c b/drivers/net/tdm/slic_ds26522.c
new file mode 100644
index 0000000..50d865c
--- /dev/null
+++ b/drivers/net/tdm/slic_ds26522.c
@@ -0,0 +1,324 @@
+/*
+ * drivers/tdm/line_ctrl/slic_ds26522.c
+ *
+ * Copyright (C) 2014 Freescale Semiconductor, Inc. All rights reserved.
+ *
+ * SLIC Line Control Module for maxim SLICs.
+ * This  is a slic control and initialization module.
+ *
+ * Author:Zhao Qiang<B45475@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * This driver was created solely by Freescale, without the assistance,
+ * support or intellectual property of Maxim Semiconductor.  No maintenance
+ * or support will be provided by Maxim Semiconductor regarding this driver
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/spi/spi.h>
+#include <linux/wait.h>
+#include <linux/param.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include "slic_ds26522.h"
+
+#define DRV_DESC "FREESCALE DEVELOPED MAXIM SLIC DRIVER"
+#define DRV_NAME "ds26522"
+
+#define MAX_NUM_OF_SLICS 10
+#define SLIC_TRANS_LEN 1
+#define SLIC_TWO_LEN 2
+#define SLIC_THREE_LEN 3
+
+#define CPLD_MISCCSR	0x17
+#define SPI_CS3_SEL0	0x00
+#define SPI_CS3_SEL1	0x80
+
+#define TESTING_PRODUCT_CODE
+
+static struct spi_device *g_spi;
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Zhao Qiang<B45475@freescale.com>");
+MODULE_DESCRIPTION(DRV_DESC);
+
+static unsigned int addr_swap(unsigned int addr)
+{
+	addr = ((addr & 0x3f80) >> 7) | ((addr & 0x7F) << 7);
+	addr = ((addr & 0x3870) >> 4) | ((addr & 0x387) << 4) | (addr & 0x408);
+	addr = ((addr & 0x2244) >> 2) | ((addr & 0x891) << 2) | (addr & 0x152a);
+	return addr;
+}
+
+static unsigned char data_swap(unsigned char data)
+{
+	data = ((data & 0xF0) >> 4) | ((data & 0x0F) << 4);
+	data = ((data & 0xcc) >> 2) | ((data & 0x33) << 2);
+	data = ((data & 0xaa) >> 1) | ((data & 0x55) << 1);
+	return data;
+}
+
+static void slic_write(struct spi_device *spi, unsigned int addr,
+		       unsigned char data)
+{
+	char temp[3];
+
+	addr = addr_swap(addr);
+	data = data_swap(data);
+	temp[0] = (unsigned char)((addr >> 7) & 0x7f);
+	temp[1] = (unsigned char)((addr << 1) & 0xfe);
+	temp[2] = data;
+
+	/* write spi addr and value */
+	spi_write(spi, &temp[0], SLIC_THREE_LEN);
+}
+
+static unsigned char slic_read(struct spi_device *spi, unsigned int addr)
+{
+	int ret;
+	unsigned char temp[2];
+	unsigned char data;
+
+	addr = addr_swap(addr);
+	temp[0] = (unsigned char)(((addr >> 7) & 0x7f) | 0x80);
+	temp[1] = (unsigned char)((addr << 1) & 0xfe);
+
+	ret = spi_write_then_read(spi, &temp[0], SLIC_TWO_LEN, &data,
+				  SLIC_TRANS_LEN);
+	if (ret < 0)
+		return ret;
+
+	data = data_swap(data);
+	return data;
+}
+
+static bool get_slic_product_code(struct spi_device *spi)
+{
+	unsigned char device_id;
+
+	device_id = slic_read(spi, DS26522_IDR_ADDR);
+	if ((device_id & 0xf8) == 0x68) {
+		pr_info("The Device is DS26522.\n");
+		return true;
+	}
+
+	pr_info("The Device isn't DS26522.\n");
+	return false;
+}
+
+static void ds26522_e1_spec_config(struct spi_device *spi)
+{
+	/* Receive E1 Mode (Receive Master Mode Register - RMMR)
+	 * Framer Disabled
+	 */
+	slic_write(spi, DS26522_RMMR_ADDR, DS26522_RMMR_E1);
+	/* Transmit E1 Mode (Transmit Master Mode Register - TMMR)
+	 * Framer Disable
+	 */
+	slic_write(spi, DS26522_TMMR_ADDR, DS26522_TMMR_E1);
+	/* Receive E1 Mode Framer Enable (RMMR - Framer Enabled/E1) */
+	slic_write(spi, DS26522_RMMR_ADDR,
+		   DS26522_RMMR_FRM_EN | DS26522_RMMR_E1);
+	/* Transmit E1 Mode Framer Enable (TMMR - Framer Enabled/E1) */
+	slic_write(spi, DS26522_TMMR_ADDR,
+		   DS26522_TMMR_FRM_EN | DS26522_TMMR_E1);
+	/* RCR1, receive E1 B8zs & ESF (Receive Control Register 1 - E1 MODE) */
+	slic_write(spi, DS26522_RCR1_ADDR,
+		   DS26522_RCR1_E1_HDB3 | DS26522_RCR1_E1_CCS);
+	/* RIOCR (RSYSCLK=2.048MHz, RSYNC-Output) */
+	slic_write(spi, DS26522_RIOCR_ADDR,
+		   DS26522_RIOCR_2048KHZ | DS26522_RIOCR_RSIO_OUT);
+	/* TCR1 Transmit E1 b8zs */
+	slic_write(spi, DS26522_TCR1_ADDR, DS26522_TCR1_TB8ZS);
+	/* TIOCR (TSYSCLK=2.048MHz, TSYNC-Output) */
+	slic_write(spi, DS26522_TIOCR_ADDR,
+		   DS26522_TIOCR_2048KHZ | DS26522_TIOCR_TSIO_OUT);
+	/* Set E1TAF (Transmit Align Frame Register regsiter) */
+	slic_write(spi, DS26522_E1TAF_ADDR, DS26522_E1TAF_DEFAULT);
+	/* Set E1TNAF register (Transmit Non-Align Frame Register) */
+	slic_write(spi, DS26522_E1TNAF_ADDR, DS26522_E1TNAF_DEFAULT);
+	/* Receive E1 Mode Framer Enable & init Done (RMMR) */
+	slic_write(spi, DS26522_RMMR_ADDR,
+		   DS26522_RMMR_FRM_EN |
+		   DS26522_RMMR_INIT_DONE |
+		   DS26522_RMMR_E1);
+	/* Transmit E1 Mode Framer Enable & init Done (TMMR) */
+	slic_write(spi, DS26522_TMMR_ADDR,
+		   DS26522_TMMR_FRM_EN |
+		   DS26522_TMMR_INIT_DONE |
+		   DS26522_TMMR_E1);
+	/* Configure LIU (LIU Transmit Receive Control Register
+	 * - LTRCR. E1 mode)
+	 */
+	slic_write(spi, DS26522_LTRCR_ADDR, DS26522_LTRCR_E1);
+	/* E1 Mode default 75 ohm w/Transmit Impedance Matlinking
+	 * (LIU Transmit Impedance and Pulse Shape Selection Register - LTITSR)
+	 */
+	slic_write(spi, DS26522_LTITSR_ADDR,
+		   DS26522_LTITSR_TLIS_75OHM | DS26522_LTITSR_LBOS_75OHM);
+	/* E1 Mode default 75 ohm Long Haul w/Receive Impedance Matlinking
+	 * (LIU Receive Impedance and Sensitivity Monitor Register - LRISMR)
+	 */
+	slic_write(spi, DS26522_LRISMR_ADDR,
+		   DS26522_LRISMR_75OHM | DS26522_LRISMR_MAX);
+	/* Enable Transmit output (LIU Maintenance Control Register - LMCR) */
+	slic_write(spi, DS26522_LMCR_ADDR, DS26522_LMCR_TE);
+}
+
+static int slic_ds26522_init_configure(unsigned char *device_handle,
+				     struct spi_device *spi)
+{
+	unsigned int addr;
+
+	/* set clock */
+	slic_write(spi, DS26522_GTCCR_ADDR, DS26522_GTCCR_BPREFSEL_REFCLKIN |
+			DS26522_GTCCR_BFREQSEL_2048KHZ |
+			DS26522_GTCCR_FREQSEL_2048KHZ);
+	slic_write(spi, DS26522_GTCR2_ADDR, DS26522_GTCR2_TSSYNCOUT);
+	slic_write(spi, DS26522_GFCR_ADDR, DS26522_GFCR_BPCLK_2048KHZ);
+
+	/* set gtcr */
+	slic_write(spi, DS26522_GTCR1_ADDR, DS26522_GTCR1);
+
+	/* Global LIU Software Reset Register (GLSRR) */
+	slic_write(spi, DS26522_GLSRR_ADDR, DS26522_GLSRR_RESET);
+	/* Global Framer and BERT Software Reset Register (GFSRR) */
+	slic_write(spi, DS26522_GFSRR_ADDR, DS26522_GFSRR_RESET);
+
+	usleep_range(100, 120);
+
+	slic_write(spi, DS26522_GLSRR_ADDR, DS26522_GLSRR_NORMAL);
+	slic_write(spi, DS26522_GFSRR_ADDR, DS26522_GFSRR_NORMAL);
+
+	/* Perform RX/TX SRESET,Reset receiver (RMMR) */
+	slic_write(spi, DS26522_RMMR_ADDR, DS26522_RMMR_SFTRST);
+	/* Reset tranceiver (TMMR) */
+	slic_write(spi, DS26522_TMMR_ADDR, DS26522_TMMR_SFTRST);
+
+	usleep_range(100, 120);
+
+	/* Zero all Framer Registers */
+	for (addr = DS26522_RF_ADDR_START; addr <= DS26522_RF_ADDR_END;
+			addr++) {
+		slic_write(spi, addr, 0);
+	}
+
+	for (addr = DS26522_TF_ADDR_START; addr <= DS26522_TF_ADDR_END;
+			addr++) {
+		slic_write(spi, addr, 0);
+	}
+
+	for (addr = DS26522_LIU_ADDR_START; addr <= DS26522_LIU_ADDR_END;
+			addr++) {
+		slic_write(spi, addr, 0);
+	}
+
+	for (addr = DS26522_BERT_ADDR_START; addr <= DS26522_BERT_ADDR_END;
+			addr++) {
+		slic_write(spi, addr, 0);
+	}
+
+	/*enable loopback mode*/
+	/*slic_write(spi, DS26522_RMMR_ADDR, DS26522_RCR3_FLB);*/
+
+	/* setup ds26522 for E1 specification */
+	ds26522_e1_spec_config(spi);
+
+	slic_write(spi, DS26522_GTCR1_ADDR, 0x00);
+
+	return 0;
+}
+
+static int slic_ds26522_remove(struct spi_device *spi)
+{
+	pr_info("SLIC module uninstalled\n");
+	return 0;
+}
+
+static int slic_ds26522_probe(struct spi_device *spi)
+{
+	int ret = 0;
+	unsigned char *device_handle;
+
+	g_spi = spi;
+	spi->bits_per_word = 8;
+
+	if (!get_slic_product_code(spi))
+		return ret;
+
+	device_handle = 0x0;
+
+	ret = slic_ds26522_init_configure(device_handle, spi);
+	if (ret == 0)
+		pr_info("SLIC0 configuration success\n");
+	else
+		pr_info("%s slic0 configuration failed\n", __func__);
+
+	return ret;
+}
+
+static const struct of_device_id slic_ds26522_match[] = {
+	{
+	 .compatible = "maxim,ds26522",
+	 },
+	{},
+};
+
+static struct spi_driver slic_ds26522_driver = {
+	.driver = {
+		   .name = "ds26522",
+		   .bus = &spi_bus_type,
+		   .owner = THIS_MODULE,
+		   .of_match_table = slic_ds26522_match,
+		   },
+	.probe = slic_ds26522_probe,
+	.remove = slic_ds26522_remove,
+
+};
+
+static int __init slic_ds26522_init(void)
+{
+	int ret;
+
+	pr_info("SLIC: " DRV_DESC "\n");
+	pr_info("####################################################");
+	pr_info("\n# This driver was created solely by Freescale,   #");
+	pr_info("\n# without the assistance, support or intellectual#");
+	pr_info("\n# property of Maxim Semiconductor. No            #");
+	pr_info("\n# maintenance or support will be provided by     #");
+	pr_info("\n# Maxim  Semiconductor regarding this driver.    #");
+	pr_info("\n##################################################");
+	pr_info("\n");
+
+	ret = spi_register_driver(&slic_ds26522_driver);
+	if (ret != 0)
+		pr_info("%s spi_register_driver failed\n", __func__);
+	return ret;
+}
+
+static void __exit slic_ds26522_exit(void)
+{
+	spi_unregister_driver(&slic_ds26522_driver);
+}
+
+module_init(slic_ds26522_init);
+module_exit(slic_ds26522_exit);
diff --git a/drivers/net/tdm/slic_ds26522.h b/drivers/net/tdm/slic_ds26522.h
new file mode 100644
index 0000000..82e93f3
--- /dev/null
+++ b/drivers/net/tdm/slic_ds26522.h
@@ -0,0 +1,172 @@
+/*
+ * drivers/tdm/line_ctrl/slic_ds26522.h
+ *
+ * Copyright 2014 Freescale Semiconductor, Inc.
+ *
+ * Author: Zhao Qiang <B45475@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the  GNU General Public License along
+ * with this program; if not, write  to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define DS26522_RF_ADDR_START	0x00
+#define DS26522_RF_ADDR_END	0xef
+#define DS26522_GLB_ADDR_START	0xf0
+#define DS26522_GLB_ADDR_END	0xff
+#define DS26522_TF_ADDR_START	0x100
+#define DS26522_TF_ADDR_END	0x1ef
+#define DS26522_LIU_ADDR_START	0x1000
+#define DS26522_LIU_ADDR_END	0x101f
+#define DS26522_TEST_ADDR_START	0x1008
+#define DS26522_TEST_ADDR_END	0x101f
+#define DS26522_BERT_ADDR_START	0x1100
+#define DS26522_BERT_ADDR_END	0x110f
+
+#define DS26522_RMMR_ADDR	0x80
+#define DS26522_RCR1_ADDR	0x81
+#define DS26522_RCR3_ADDR	0x83
+#define DS26522_RIOCR_ADDR	0x84
+
+#define DS26522_GTCR1_ADDR	0xf0
+#define DS26522_GFCR_ADDR	0xf1
+#define DS26522_GTCR2_ADDR	0xf2
+#define DS26522_GTCCR_ADDR	0xf3
+#define DS26522_GLSRR_ADDR	0xf5
+#define DS26522_GFSRR_ADDR	0xf6
+#define DS26522_IDR_ADDR	0xf8
+
+#define DS26522_E1TAF_ADDR	0x164
+#define DS26522_E1TNAF_ADDR	0x165
+#define DS26522_TMMR_ADDR	0x180
+#define DS26522_TCR1_ADDR	0x181
+#define DS26522_TIOCR_ADDR	0x184
+
+#define DS26522_LTRCR_ADDR	0x1000
+#define DS26522_LTITSR_ADDR	0x1001
+#define DS26522_LMCR_ADDR	0x1002
+#define DS26522_LRISMR_ADDR	0x1007
+
+#define MAX_NUM_OF_CHANNELS	8
+#define PQ_MDS_8E1T1_BRD_REV	0x00
+#define PQ_MDS_8E1T1_PLD_REV	0x00
+
+#define DS26522_GTCCR_BPREFSEL_REFCLKIN	0xa0	/* REFCLKIO is an input */
+#define DS26522_GTCCR_BFREQSEL_1544KHZ	0x08	/* Backplane reference clock
+						   is 1.544MHz
+						*/
+#define DS26522_GTCCR_FREQSEL_1544KHZ	0x04	/* The external master clock
+						   is 1.544MHz or multiple
+						   thereof
+						*/
+#define DS26522_GTCCR_BFREQSEL_2048KHZ	0x00	/* Backplane reference clock
+						   is 2.048MHz
+						*/
+#define DS26522_GTCCR_FREQSEL_2048KHZ	0x00	/* The external master clock is
+						   2.048MHz or multiple thereof
+						*/
+
+#define DS26522_GFCR_BPCLK_2048KHZ	0x00	/* Backplane Clock Select
+						   2.048MHz
+						*/
+
+#define DS26522_GTCR2_TSSYNCOUT	0x02	/* the TSSYNCIO is an 8kHz output */
+					/* synchronous to the BPCLK */
+#define DS26522_GTCR1	0x00
+
+#define DS26522_GFSRR_RESET	0x01	/* Reset framer and BERT */
+#define DS26522_GFSRR_NORMAL	0x00	/* Normal operation */
+
+#define DS26522_GLSRR_RESET	0x01	/* Reset LIU */
+#define DS26522_GLSRR_NORMAL	0x00	/* Normal operation */
+
+#define DS26522_RMMR_SFTRST	0x02	/* Level sensitive soft reset */
+#define DS26522_RMMR_FRM_EN	0x80	/* Framer enabled—all features
+					   active
+					*/
+#define DS26522_RMMR_INIT_DONE	0x40	/* Initialization Done */
+#define DS26522_RMMR_T1		0x00	/* Receiver T1 Mode Select */
+#define DS26522_RMMR_E1		0x01	/* Receiver E1 Mode Select */
+
+#define DS26522_E1TAF_DEFAULT	0x1b	/* Transmit Align Frame Register */
+#define DS26522_E1TNAF_DEFAULT	0x40	/* Transmit Non-Align Frame Register */
+
+#define DS26522_TMMR_SFTRST	0x02	/* Level sensitive soft reset */
+#define DS26522_TMMR_FRM_EN	0x80	/* Framer enabled—all features
+					   active
+					*/
+#define DS26522_TMMR_INIT_DONE	0x40	/* Initialization Done */
+#define DS26522_TMMR_T1		0x00	/* Transmit T1 Mode Select */
+#define DS26522_TMMR_E1		0x01	/* Transmit E1 Mode Select */
+
+#define DS26522_RCR1_T1_SYNCT	0x80	/* qualify 24 bits */
+#define DS26522_RCR1_T1_RB8ZS	0x40	/* B8ZS enabled */
+#define DS26522_RCR1_T1_SYNCC	0x08	/* cross couple Ft and Fs pattern */
+
+#define DS26522_RCR1_E1_HDB3	0x40	/* Receive HDB3 enabled */
+#define DS26522_RCR1_E1_CCS	0x20	/* Receive CCS signaling mode */
+
+#define DS26522_RIOCR_1544KHZ	0x00	/* RSYSCLK Mode Select is 1.544MHz */
+#define DS26522_RIOCR_2048KHZ	0x10	/* RSYSCLK Mode Select is 2.048MHz or
+					   IBO enabled
+					*/
+#define DS26522_RIOCR_RSIO_OUT	0x00	/* RSYNC is an output */
+
+#define DS26522_RCR3_FLB	0x01	/* Framer Loopback enabled */
+
+#define DS26522_TIOCR_1544KHZ	0x00	/* TSYSCLK is 1.544MHz */
+#define DS26522_TIOCR_2048KHZ	0x10	/* TSYSCLK is 2.048/4.096/8.192MHz or
+					   IBO enabled
+					*/
+#define DS26522_TIOCR_TSIO_OUT	0x04	/* TSYNC is an output */
+
+#define DS26522_TCR1_TB8ZS	0x04	/* Transmit B8ZS Enable */
+
+#define DS26522_LTRCR_T1	0x02	/* configures the LIU for T1 */
+#define DS26522_LTRCR_E1	0x00	/* configures the LIU for E1 */
+
+#define DS26522_LTITSR_TLIS_75OHM	0x00	/* Transmit Load
+						   Impedance 75?
+						*/
+#define DS26522_LTITSR_LBOS_75OHM	0x00	/* Transmit Pulse
+						   Shape 75?
+						*/
+#define DS26522_LTITSR_TLIS_100OHM	0x10	/* Transmit Load
+						   Impedance 100?
+						*/
+#define DS26522_LTITSR_TLIS_0DB_CSU	0x00	/* DSX-1/0dB CSU,
+						   0ft–133ft ABAM 100?
+						*/
+
+#define DS26522_LRISMR_75OHM	0x00	/* Receive Impedance 75? */
+#define DS26522_LRISMR_100OHM	0x10	/* Receive Impedance 100? */
+#define DS26522_LRISMR_MAX	0x03	/* Receive Impedance 120? */
+
+#define DS26522_LMCR_TE	0x01	/* TTIP/TRING outputs enabled */
+
+enum line_rate_t {
+	LINE_RATE_T1,	/* T1 line rate (1.544 Mbps)      */
+	LINE_RATE_E1	/* E1 line rate (2.048 Mbps)     */
+};
+
+enum tdm_trans_mode_t {
+	NORMAL = 0,
+	FRAMER_LB
+};
+
+enum card_support_type {
+	LM_CARD = 0,
+	DS26522_CARD,
+	NO_CARD
+};
-- 
2.8.1

