From aeed18fb0ce7649a81f95475cd4cc97087a8d720 Mon Sep 17 00:00:00 2001
From: Ahmed Mansour <Ahmed.Mansour@freescale.com>
Date: Fri, 13 Nov 2015 12:45:08 -0500
Subject: [PATCH 0926/1383] dpaa2-dce: Add additional DCE driver support files

ENGR00369242

Signed-off-by: Ahmed Mansour <Ahmed.Mansour@freescale.com>
[Stuart: split these files into separate patch from original
submission]
Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 .../fsl-dpaa2/dce/dce-attr-encoder-decoder.h       |  124 +++
 drivers/staging/fsl-dpaa2/dce/dce-fcr.c            |  201 ++++
 drivers/staging/fsl-dpaa2/dce/dce-fcr.h            |   78 ++
 drivers/staging/fsl-dpaa2/dce/dce-fd-frc.c         |  385 +++++++
 drivers/staging/fsl-dpaa2/dce/dce-fd-frc.h         |  194 ++++
 drivers/staging/fsl-dpaa2/dce/dce-fd.c             |  608 +++++++++++
 drivers/staging/fsl-dpaa2/dce/dce-fd.h             |  113 ++
 drivers/staging/fsl-dpaa2/dce/dce-private.h        |  112 ++
 .../staging/fsl-dpaa2/dce/dce-scf-compression.c    |  891 ++++++++++++++++
 .../staging/fsl-dpaa2/dce/dce-scf-compression.h    |  229 ++++
 .../staging/fsl-dpaa2/dce/dce-scf-decompression.c  | 1094 ++++++++++++++++++++
 .../staging/fsl-dpaa2/dce/dce-scf-decompression.h  |  262 +++++
 12 files changed, 4291 insertions(+)
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-attr-encoder-decoder.h
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-fcr.c
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-fcr.h
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-fd-frc.c
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-fd-frc.h
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-fd.c
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-fd.h
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-private.h
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-scf-compression.c
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-scf-compression.h
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-scf-decompression.c
 create mode 100644 drivers/staging/fsl-dpaa2/dce/dce-scf-decompression.h

diff --git a/drivers/staging/fsl-dpaa2/dce/dce-attr-encoder-decoder.h b/drivers/staging/fsl-dpaa2/dce/dce-attr-encoder-decoder.h
new file mode 100644
index 0000000..31a5319
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-attr-encoder-decoder.h
@@ -0,0 +1,124 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LDCE_ATTR_ENCODER_DECODER_H
+#define __LDCE_ATTR_ENCODER_DECODER_H
+
+#include "dce-private.h"
+
+/* ------------- */
+/* dce_attr_code */
+/* ------------- */
+
+/* This struct locates a sub-field within a DCE attribute which
+ * is either serving as a configuration command or a query result. The
+ * representation is inherently little-endian, as the indexing of the words is
+ * itself little-endian in nature and layerscape is little endian for anything
+ * that crosses a word boundary too (64-bit fields are the obvious examples).
+ */
+struct dce_attr_code {
+	unsigned int word; /* which u32[] array member encodes the field */
+	unsigned int lsoffset; /* encoding offset from ls-bit */
+	unsigned int width; /* encoding width. (bool must be 1.) */
+};
+
+/* Macros to define codes */
+#define DCE_CODE(a, b, c) { a, b, c}
+#define DCE_CODE_NULL \
+	DCE_CODE((unsigned int)-1, (unsigned int)-1, (unsigned int)-1)
+
+/* decode a field from a cacheline */
+static inline u32 dce_attr_code_decode(const struct dce_attr_code *code,
+				      const u32 *cacheline)
+{
+	return d32_u32(code->lsoffset, code->width, cacheline[code->word]);
+}
+static inline uint64_t dce_attr_code_decode_64(const struct dce_attr_code *code,
+				      const uint64_t *cacheline)
+{
+	return cacheline[code->word / 2];
+}
+
+/* encode a field to a cacheline */
+static inline void dce_attr_code_encode(const struct dce_attr_code *code,
+				       u32 *cacheline, u32 val)
+{
+	cacheline[code->word] =
+		r32_u32(code->lsoffset, code->width, cacheline[code->word])
+		| e32_u32(code->lsoffset, code->width, val);
+}
+static inline void dce_attr_code_encode_64(const struct dce_attr_code *code,
+				       uint64_t *cacheline, uint64_t val)
+{
+	cacheline[code->word / 2] = val;
+}
+
+/* Small-width signed values (two's-complement) will decode into medium-width
+ * positives. (Eg. for an 8-bit signed field, which stores values from -128 to
+ * +127, a setting of -7 would appear to decode to the 32-bit unsigned value
+ * 249. Likewise -120 would decode as 136.) This function allows the caller to
+ * "re-sign" such fields to 32-bit signed. (Eg. -7, which was 249 with an 8-bit
+ * encoding, will become 0xfffffff9 if you cast the return value to u32).
+ */
+static inline int32_t dce_attr_code_makesigned(const struct dce_attr_code *code,
+					  u32 val)
+{
+	BUG_ON(val >= (1 << code->width));
+	/* If the high bit was set, it was encoding a negative */
+	if (val >= (1 << (code->width - 1)))
+		return (int32_t)0 - (int32_t)(((u32)1 << code->width) -
+			val);
+	/* Otherwise, it was encoding a positive */
+	return (int32_t)val;
+}
+
+/* ---------------------- */
+/* Descriptors/cachelines */
+/* ---------------------- */
+
+/* To avoid needless dynamic allocation, the driver API often gives the caller
+ * a "descriptor" type that the caller can instantiate however they like.
+ * Ultimately though, it is just a cacheline of binary storage (or something
+ * smaller when it is known that the descriptor doesn't need all 64 bytes) for
+ * holding pre-formatted pieces of hardware commands. The performance-critical
+ * code can then copy these descriptors directly into hardware command
+ * registers more efficiently than trying to construct/format commands
+ * on-the-fly. The API user sees the descriptor as an array of 32-bit words in
+ * order for the compiler to know its size, but the internal details are not
+ * exposed. The following macro is used within the driver for converting *any*
+ * descriptor pointer to a usable array pointer. The use of a macro (instead of
+ * an inline) is necessary to work with different descriptor types and to work
+ * correctly with const and non-const inputs (and similarly-qualified outputs).
+ */
+#define dce_cl(d) (&(d)->dont_manipulate_directly[0])
+#define dce_cl2(d) (&(d)->dont_manipulate_directly[16])
+
+#endif
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-fcr.c b/drivers/staging/fsl-dpaa2/dce/dce-fcr.c
new file mode 100644
index 0000000..913bb33
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-fcr.c
@@ -0,0 +1,201 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "dce-fcr.h"
+#include "dce-attr-encoder-decoder.h"
+
+/* DCE_CODE (word_offset, lsb_offset, bit_width) */
+static struct dce_attr_code code_ffdpc_lo = DCE_CODE(0, 0, 32);
+static struct dce_attr_code code_ffdpc_hi = DCE_CODE(1, 0, 32);
+static struct dce_attr_code code_bp2ac = DCE_CODE(2, 0, 32);
+static struct dce_attr_code code_bp1ac = DCE_CODE(3, 0, 32);
+static struct dce_attr_code code_bp2ac_bmt = DCE_CODE(2, 31, 1);
+static struct dce_attr_code code_bp2ac_bpid = DCE_CODE(2, 16, 14);
+static struct dce_attr_code code_bp2ac_pbs = DCE_CODE(2, 6, 10);
+static struct dce_attr_code code_bp1ac_bmt = DCE_CODE(3, 31, 1);
+static struct dce_attr_code code_bp1ac_bpid = DCE_CODE(3, 16, 14);
+static struct dce_attr_code code_bp1ac_pbs = DCE_CODE(3, 6, 10);
+static struct dce_attr_code code_next_flc_lo = DCE_CODE(4, 0, 32);
+static struct dce_attr_code code_next_flc_hi = DCE_CODE(5, 0, 32);
+
+/* fcr accessors */
+
+void fcr_clear(struct fcr *d)
+{
+	memset(d, 0, sizeof(*d));
+}
+EXPORT_SYMBOL(fcr_clear);
+
+u32 fcr_get_ffdpc_hi(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_ffdpc_hi, cl);
+}
+EXPORT_SYMBOL(fcr_get_ffdpc_hi);
+
+u32 fcr_get_ffdpc_lo(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_ffdpc_lo, cl);
+}
+EXPORT_SYMBOL(fcr_get_ffdpc_lo);
+
+u32 fcr_get_bp2ac(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac, cl);
+}
+EXPORT_SYMBOL(fcr_get_bp2ac);
+
+u32 fcr_get_bp1ac(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac, cl);
+}
+EXPORT_SYMBOL(fcr_get_bp1ac);
+
+void fcr_set_bp2ac_bmt(struct fcr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp2ac_bmt, cl, !!enable);
+}
+EXPORT_SYMBOL(fcr_set_bp2ac_bmt);
+
+int fcr_get_bp2ac_bmt(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bmt, cl);
+}
+EXPORT_SYMBOL(fcr_get_bp2ac_bmt);
+
+void fcr_set_bp2ac_bpid(struct fcr *d, u32 bpid)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp2ac_bpid, cl, bpid);
+}
+EXPORT_SYMBOL(fcr_set_bp2ac_bpid);
+
+u32 fcr_get_bp2ac_bpid(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bpid, cl);
+}
+EXPORT_SYMBOL(fcr_get_bp2ac_bpid);
+
+void fcr_set_bp2ac_pbs(struct fcr *d, u32 pbs)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp2ac_pbs, cl, pbs);
+}
+EXPORT_SYMBOL(fcr_set_bp2ac_pbs);
+
+u32 fcr_get_bp2ac_pbs(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_pbs, cl);
+}
+EXPORT_SYMBOL(fcr_get_bp2ac_pbs);
+
+void fcr_set_bp1ac_bmt(struct fcr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp1ac_bmt, cl, !!enable);
+}
+EXPORT_SYMBOL(fcr_set_bp1ac_bmt);
+
+int fcr_get_bp1ac_bmt(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bmt, cl);
+}
+EXPORT_SYMBOL(fcr_get_bp1ac_bmt);
+
+void fcr_set_bp1ac_bpid(struct fcr *d, u32 bpid)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp1ac_bpid, cl, bpid);
+}
+EXPORT_SYMBOL(fcr_set_bp1ac_bpid);
+
+u32 fcr_get_bp1ac_bpid(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bpid, cl);
+}
+EXPORT_SYMBOL(fcr_get_bp1ac_bpid);
+
+void fcr_set_bp1ac_pbs(struct fcr *d, u32 pbs)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp1ac_pbs, cl, pbs);
+}
+EXPORT_SYMBOL(fcr_set_bp1ac_pbs);
+
+u32 fcr_get_bp1ac_pbs(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_pbs, cl);
+}
+EXPORT_SYMBOL(fcr_get_bp1ac_pbs);
+
+void fcr_set_next_flc(struct fcr *d, uint64_t addr)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode_64(&code_next_flc_lo, (uint64_t *)cl, addr);
+}
+EXPORT_SYMBOL(fcr_set_next_flc);
+
+uint64_t fcr_get_next_flc(struct fcr *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_next_flc_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_next_flc_lo, cl);
+}
+EXPORT_SYMBOL(fcr_get_next_flc);
+
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-fcr.h b/drivers/staging/fsl-dpaa2/dce/dce-fcr.h
new file mode 100644
index 0000000..cefdd63
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-fcr.h
@@ -0,0 +1,78 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LDCE_FCR_H
+#define __LDCE_FCR_H
+
+#include "dce-private.h"
+
+/* DCE hw requires FCR to be 64 byte aligned */
+#define FCR_ALIGN	64
+
+/* FCR: Flow Context Record */
+struct fcr {
+	u32 dont_manipulate_directly[32];
+};
+
+/*******************************************************************************
+ *
+ * fcr APIS
+ *
+ ******************************************************************************/
+void fcr_clear(struct fcr *d);
+
+/* Storage Profile Format and Data Placement Controls */
+u32 fcr_get_ffdpc_hi(struct fcr *d);
+u32 fcr_get_ffdpc_lo(struct fcr *d);
+
+/* BP2 settings: buffer pool id, pool buffer size */
+u32 fcr_get_bp2ac(struct fcr *d);
+void fcr_set_bp2ac_bmt(struct fcr *d, int enable);
+int fcr_get_bp2ac_bmt(struct fcr *d);
+void fcr_set_bp2ac_bpid(struct fcr *d, u32 bpid);
+u32 fcr_get_bp2ac_bpid(struct fcr *d);
+void fcr_set_bp2ac_pbs(struct fcr *d, u32 pbs);
+u32 fcr_get_bp2ac_pbs(struct fcr *d);
+
+/* BP1 settings: buffer pool id, pool buffer size */
+u32 fcr_get_bp1ac(struct fcr *d);
+void fcr_set_bp1ac_bmt(struct fcr *d, int enable);
+int fcr_get_bp1ac_bmt(struct fcr *d);
+void fcr_set_bp1ac_bpid(struct fcr *d, u32 bpid);
+u32 fcr_get_bp1ac_bpid(struct fcr *d);
+void fcr_set_bp1ac_pbs(struct fcr *d, u32 pbs);
+u32 fcr_get_bp1ac_pbs(struct fcr *d);
+
+/* next_flc */
+void fcr_set_next_flc(struct fcr *d, uint64_t addr);
+uint64_t fcr_get_next_flc(struct fcr *d);
+
+#endif
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-fd-frc.c b/drivers/staging/fsl-dpaa2/dce/dce-fd-frc.c
new file mode 100644
index 0000000..d086910
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-fd-frc.c
@@ -0,0 +1,385 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "dce-fd-frc.h"
+#include "dce-attr-encoder-decoder.h"
+
+/* DCE_CODE (word_offset, lsb_offset, bit_width) */
+
+/* CMD field */
+static struct dce_attr_code code_fd_frc_cmd = DCE_CODE(4, 29, 3);
+
+/* NOP */
+static struct dce_attr_code code_fd_frc_nop_token = DCE_CODE(4, 0, 29);
+
+/* ICID Scope Flush */
+static struct dce_attr_code code_fd_frc_icid_scope_token = DCE_CODE(4, 0, 29);
+
+/* Context Invalidate */
+static struct dce_attr_code code_fd_frc_cic_token = DCE_CODE(4, 0, 29);
+
+/* FQID Scope Flush */
+static struct dce_attr_code code_fd_frc_fqflush_token = DCE_CODE(4, 0, 29);
+
+/* PROCESS Request */
+static struct dce_attr_code code_fd_frc_scus = DCE_CODE(4, 8, 2);
+static struct dce_attr_code code_fd_frc_usdc = DCE_CODE(4, 10, 1);
+static struct dce_attr_code code_fd_frc_uspc = DCE_CODE(4, 11, 1);
+static struct dce_attr_code code_fd_frc_uhc = DCE_CODE(4, 12, 1);
+static struct dce_attr_code code_fd_frc_ce = DCE_CODE(4, 13, 2);
+static struct dce_attr_code code_fd_frc_cf = DCE_CODE(4, 16, 2);
+static struct dce_attr_code code_fd_frc_b64 = DCE_CODE(4, 18, 1);
+static struct dce_attr_code code_fd_frc_rb = DCE_CODE(4, 19, 1);
+static struct dce_attr_code code_fd_frc_initial = DCE_CODE(4, 20, 1);
+static struct dce_attr_code code_fd_frc_recycle = DCE_CODE(4, 21, 1);
+static struct dce_attr_code code_fd_frc_scrf = DCE_CODE(4, 22, 1);
+static struct dce_attr_code code_fd_frc_z_flush = DCE_CODE(4, 23, 3);
+static struct dce_attr_code code_fd_frc_sf = DCE_CODE(4, 28, 1);
+
+/* PROCESS Response */
+static struct dce_attr_code code_fd_frc_status = DCE_CODE(4, 0, 8);
+static struct dce_attr_code code_fd_frc_stream_end = DCE_CODE(4, 15, 1);
+
+void fd_frc_set_cmd(struct fd_attr *d, enum dce_cmd cmd)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_cmd, cl, cmd);
+}
+EXPORT_SYMBOL(fd_frc_set_cmd);
+
+enum dce_cmd fd_frc_get_cmd(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_cmd, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_cmd);
+
+void fd_frc_set_nop_token(struct fd_attr *d, u32 token)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_nop_token, cl, token);
+
+}
+EXPORT_SYMBOL(fd_frc_set_nop_token);
+
+u32 fd_frc_get_nop_token(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_nop_token, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_nop_token);
+
+void fd_frc_set_icid_scope_token(struct fd_attr *d, u32 token)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_icid_scope_token, cl, token);
+}
+EXPORT_SYMBOL(fd_frc_set_icid_scope_token);
+
+u32 fd_frc_get_icid_scope_token(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_icid_scope_token, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_icid_scope_token);
+
+void fd_frc_set_cic_token(struct fd_attr *d, u32 token)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_cic_token, cl, token);
+}
+EXPORT_SYMBOL(fd_frc_set_cic_token);
+
+u32 fd_frc_get_cic_token(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_cic_token, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_cic_token);
+
+void fd_frc_set_fqflush_token(struct fd_attr *d, u32 token)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_fqflush_token, cl, token);
+}
+EXPORT_SYMBOL(fd_frc_set_fqflush_token);
+
+u32 fd_frc_get_fqflush_token(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_fqflush_token, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_fqflush_token);
+
+
+enum dce_status fd_frc_get_status(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_status, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_status);
+
+void fd_frc_set_scus(struct fd_attr *d, enum dce_scus scus)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_scus, cl, scus);
+}
+EXPORT_SYMBOL(fd_frc_set_scus);
+
+enum dce_scus fd_frc_get_scus(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_scus, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_scus);
+
+void fd_frc_set_usdc(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_usdc, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_usdc);
+
+int fd_frc_get_usdc(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_usdc, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_usdc);
+
+void fd_frc_set_uspc(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_uspc, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_uspc);
+
+int fd_frc_get_uspc(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_uspc, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_uspc);
+
+void fd_frc_set_uhc(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_uhc, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_uhc);
+
+int fd_frc_get_uhc(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_uhc, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_uhc);
+
+void fd_frc_set_ce(struct fd_attr *d, enum dce_comp_effort ce)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_ce, cl, ce);
+}
+EXPORT_SYMBOL(fd_frc_set_ce);
+
+enum dce_comp_effort fd_frc_get_ce(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_ce, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_ce);
+
+void fd_frc_set_cf(struct fd_attr *d, enum dce_comp_fmt cf)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_cf, cl, cf);
+}
+EXPORT_SYMBOL(fd_frc_set_cf);
+
+enum dce_comp_fmt fd_frc_get_cf(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_cf, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_cf);
+
+void fd_frc_set_b64(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_b64, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_b64);
+
+int fd_frc_get_b64(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_b64, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_b64);
+
+void fd_frc_set_rb(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_rb, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_rb);
+
+int fd_frc_get_rb(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_rb, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_rb);
+
+void fd_frc_set_initial(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_initial, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_initial);
+
+int fd_frc_get_initial(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_initial, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_initial);
+
+void fd_frc_set_recycle(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_recycle, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_recycle);
+
+int fd_frc_get_recycle(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_recycle, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_recycle);
+
+void fd_frc_set_scrf(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_scrf, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_scrf);
+
+int fd_frc_get_scrf(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_scrf, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_scrf);
+
+void fd_frc_set_z_flush(struct fd_attr *d, enum dce_z_flush flush)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_z_flush, cl, flush);
+}
+EXPORT_SYMBOL(fd_frc_set_z_flush);
+
+enum dce_z_flush fd_frc_get_z_flush(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_z_flush, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_z_flush);
+
+void fd_frc_set_sf(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_sf, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_sf);
+
+int fd_frc_get_sf(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_sf, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_sf);
+
+void fd_frc_set_se(struct fd_attr *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_fd_frc_stream_end, cl, !!enable);
+}
+EXPORT_SYMBOL(fd_frc_set_se);
+
+int fd_frc_get_se(struct fd_attr *d)
+{
+	u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_fd_frc_stream_end, cl);
+}
+EXPORT_SYMBOL(fd_frc_get_se);
+
+
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-fd-frc.h b/drivers/staging/fsl-dpaa2/dce/dce-fd-frc.h
new file mode 100644
index 0000000..55300f7
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-fd-frc.h
@@ -0,0 +1,194 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LDCE_FD_FRC_H
+#define __LDCE_FD_FRC_H
+
+#include "dce-fd.h"
+#include "dce-fd-frc.h"
+
+enum dce_cmd {
+	DCE_CMD_PROCESS			= 0,
+	DCE_CMD_FQID_SCOPE_FLUSH	= 3,
+	DCE_CMD_CTX_INVALIDATE		= 4,
+	DCE_CMD_ICID_SCOPE_FLUSH	= 6,
+	DCE_CMD_NOP			= 7
+};
+
+enum dce_z_flush {
+	DCE_Z_FLUSH_NO_FLUSH		= 0,
+	DCE_Z_FLUSH_PARTIAL_FLUSH	= 1,
+	DCE_Z_FLUSH_SYNC_FLUSH		= 2,
+	DCE_Z_FLUSH_FULL_FLUSH		= 3,
+	DCE_Z_FLUSH_FINISH		= 4,
+	DCE_Z_FLUSH_BLOCK		= 5,
+	DCE_Z_FLUSH_TREES		= 6
+};
+
+enum dce_comp_fmt {
+	DCE_CF_DEFLATE	= 0,
+	DCE_CF_ZLIB	= 1,
+	DCE_CF_GZIP	= 2
+};
+
+enum dce_comp_effort {
+	DCE_CE_NONE			= 0,
+	DCE_CE_STATIC_HUFF_STRMATCH	= 1,
+	DCE_CE_HUFF_ONLY		= 2,
+	DCE_CE_BEST_POSSIBLE		= 3,
+};
+
+enum dce_scus {
+	DCE_SCUS_NORMAL_MODE	= 0,
+	DCE_SCUS_UPDATE		= 1,
+	DCE_SCUS_UPDATE_DEBUG	= 2
+};
+
+enum dce_status {
+	FULLY_PROCESSED				= 0x00,
+	STREAM_END				= 0x01,
+	INPUT_STARVED				= 0x10,
+	MEMBER_END_SUSPENDED			= 0x11,
+	Z_BLOCK_SUSPENDED			= 0x12,
+	OUTPUT_BLOCKED_SUSPEND			= 0x14,
+	ACQUIRE_DATA_BUFFER_DENIED_SUSPEND	= 0x15,
+	ACQUIRE_TABLE_BUFFER_DENIED_SUSPEND	= 0x16,
+	OLL_REACHED_SUSPEND			= 0x17,
+	OUTPUT_BLOCKED_DISCARD			= 0x24,
+	ACQUIRE_DATA_BUFFER_DENIED_DISCARD	= 0x25,
+	ACQUIRE_TABLE_BUFFER_DENIED_DISCARD	= 0x26,
+	OLL_REACHED_DISCARD			= 0x27,
+	HCL_REACHED_DISCARD			= 0x28,
+	HCL_RELEASE_ABORTED			= 0x2F,
+	SKIPPED					= 0x30,
+	PREVIOUS_FLOW_TERMINATION		= 0x31,
+	SUSPENDED_FLOW_TERMINATION		= 0x32,
+	INVALID_FRAME_LIST			= 0x40,
+	INVALID_FRC				= 0x41,
+	UNSUPPORTED_FRAME			= 0x42,
+	FRAME_TOO_SHORT				= 0x44,
+	ZLIB_INCOMPLETE_HEADER			= 0x50,
+	ZLIB_HEADER_ERROR			= 0x51,
+	ZLIB_NEED_DICTIONARY_ERROR		= 0x52,
+	GZIP_INCOMPLETE_HEADER			= 0x60,
+	GZIP_HEADER_ERROR			= 0x61,
+	DEFLATE_INVALID_BLOCK_TYPE		= 0x70,
+	DEFLATE_INVALID_BLOCK_LENGTHS		= 0x71,
+	DEFLATE_TOO_MANY_LEN_OR_DIST_SYM	= 0x80,
+	DEFLATE_INVALID_CODE_LENGTHS_SET	= 0x81,
+	DEFLATE_INVALID_BIT_LENGTH_REPEAT	= 0x82,
+	DEFLATE_INVALID_LITERAL_LENGTHS_SET	= 0x83,
+	DEFLATE_INVALID_DISTANCES_SET		= 0x84,
+	DEFLATE_INVALID_LITERAL_LENGTH_CODE	= 0x85,
+	DEFLATE_INVALID_DISTANCE_CODE		= 0x86,
+	DEFLATE_INVALID_DISTANCE_TOO_FAR_BACK	= 0x87,
+	DEFLATE_INCORRECT_DATA_CHECK		= 0x88,
+	DEFLATE_INCORRECT_LENGTH_CHECK		= 0x89,
+	DEFLATE_INVALID_CODE			= 0x8A,
+	CXM_2BIT_ECC_ERROR			= 0xB0,
+	CBM_2BIT_ECC_ERROR			= 0xB1,
+	DHM_2BIT_ECC_ERROR			= 0xB2,
+	INVALID_BASE64_CODE			= 0xC0,
+	INVALID_BASE64_PADDING			= 0xC1,
+	SCF_SYSTEM_MEM_READ_ERROR		= 0xD5,
+	PENDING_OUTPUT_SYSTEM_MEM_READ_ERROR	= 0xD6,
+	HISTORY_WINDOW_SYSTEM_MEM_READ_ERROR	= 0xD7,
+	CTX_DATA_SYSTEM_MEM_READ_ERROR		= 0xD8,
+	FRAME_DATA_SYSTEM_READ_ERROR		= 0xD9,
+	INPUT_FRAME_TBL_SYSTEM_READ_ERROR	= 0xDA,
+	OUTPUT_FRAME_TBL_SYSTEM_READ_ERROR	= 0xDB,
+	SCF_SYSTEM_MEM_WRITE_ERROR		= 0xE5,
+	PENDING_OUTPUT_SYSTEM_MEM_WRITE_ERROR	= 0xE6,
+	HISTORY_WINDOW_SYSTEM_MEM_WRITE_ERROR	= 0xE7,
+	CTX_DATA_SYSTEM_MEM_WRITE_ERROR		= 0xE8,
+	FRAME_DATA_SYSTEM_MEM_WRITE_ERROR	= 0xE9,
+	FRAME_TBL_SYSTEM_MEM_WRITE_ERROR	= 0xEA
+};
+
+void fd_frc_set_cmd(struct fd_attr *d, enum dce_cmd cmd);
+enum dce_cmd fd_frc_get_cmd(struct fd_attr *d);
+
+void fd_frc_set_nop_token(struct fd_attr *d, u32 token);
+u32 fd_frc_get_nop_token(struct fd_attr *d);
+
+void fd_frc_set_icid_scope_token(struct fd_attr *d, u32 token);
+u32 fd_frc_get_icid_scope_token(struct fd_attr *d);
+
+void fd_frc_set_cic_token(struct fd_attr *d, u32 token);
+u32 fd_frc_get_cic_token(struct fd_attr *d);
+
+void fd_frc_set_fqflush_token(struct fd_attr *d, u32 token);
+u32 fd_frc_get_fqflush_token(struct fd_attr *d);
+
+enum dce_status fd_frc_get_status(struct fd_attr *d);
+
+void fd_frc_set_scus(struct fd_attr *d, enum dce_scus scus);
+enum dce_scus fd_frc_get_scus(struct fd_attr *d);
+
+void fd_frc_set_usdc(struct fd_attr *d, int enable);
+int fd_frc_get_usdc(struct fd_attr *d);
+
+void fd_frc_set_uspc(struct fd_attr *d, int enable);
+int fd_frc_get_uspc(struct fd_attr *d);
+
+void fd_frc_set_uhc(struct fd_attr *d, int enable);
+int fd_frc_get_uhc(struct fd_attr *d);
+
+void fd_frc_set_ce(struct fd_attr *d, enum dce_comp_effort ce);
+enum dce_comp_effort fd_frc_get_ce(struct fd_attr *d);
+
+void fd_frc_set_cf(struct fd_attr *d, enum dce_comp_fmt cf);
+enum dce_comp_fmt fd_frc_get_cf(struct fd_attr *d);
+
+void fd_frc_set_b64(struct fd_attr *d, int enable);
+int fd_frc_get_b64(struct fd_attr *d);
+
+void fd_frc_set_rb(struct fd_attr *d, int enable);
+int fd_frc_get_rb(struct fd_attr *d);
+
+void fd_frc_set_initial(struct fd_attr *d, int enable);
+int fd_frc_get_initial(struct fd_attr *d);
+
+void fd_frc_set_recycle(struct fd_attr *d, int enable);
+int fd_frc_get_recycle(struct fd_attr *d);
+
+void fd_frc_set_scrf(struct fd_attr *d, int enable);
+int fd_frc_get_scrf(struct fd_attr *d);
+
+void fd_frc_set_z_flush(struct fd_attr *d, enum dce_z_flush flush);
+enum dce_z_flush fd_frc_get_z_flush(struct fd_attr *d);
+
+void fd_frc_set_sf(struct fd_attr *d, int enable);
+int fd_frc_get_sf(struct fd_attr *d);
+
+void fd_frc_set_se(struct fd_attr *d, int enable);
+int fd_frc_get_se(struct fd_attr *d);
+#endif
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-fd.c b/drivers/staging/fsl-dpaa2/dce/dce-fd.c
new file mode 100644
index 0000000..46e9415
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-fd.c
@@ -0,0 +1,608 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "dce-fd.h"
+#include "dce-attr-encoder-decoder.h"
+
+#define ATTR32(d) (&(d)->dont_manipulate_directly[0])
+#define ATTR32_1(d) (&(d)->dont_manipulate_directly[16])
+
+static struct dce_attr_code code_fd_addr_lo = DCE_CODE(0, 0, 32);
+static struct dce_attr_code code_fd_addr_hi_17 = DCE_CODE(1, 0, 17);
+static struct dce_attr_code code_fd_addr_hi_32 = DCE_CODE(1, 0, 17);
+static struct dce_attr_code code_fd_sw_token = DCE_CODE(1, 17, 15);
+static struct dce_attr_code code_fd_data_len_18 = DCE_CODE(2, 0, 18);
+static struct dce_attr_code code_fd_data_len_32 = DCE_CODE(2, 0, 32);
+static struct dce_attr_code code_fd_mem = DCE_CODE(2, 20, 12);
+static struct dce_attr_code code_fd_bpid = DCE_CODE(3, 0, 14);
+static struct dce_attr_code code_fd_ivp = DCE_CODE(3, 14, 1);
+static struct dce_attr_code code_fd_bmt = DCE_CODE(3, 15, 1);
+static struct dce_attr_code code_fd_offset = DCE_CODE(3, 16, 12);
+static struct dce_attr_code code_fd_format = DCE_CODE(3, 28, 2);
+static struct dce_attr_code code_fd_sl = DCE_CODE(3, 30, 1);
+static struct dce_attr_code code_fd_frc = DCE_CODE(4, 0, 32);
+static struct dce_attr_code code_fd_frc_status = DCE_CODE(4, 0, 8);
+static struct dce_attr_code code_fd_err = DCE_CODE(5, 0, 8);
+static struct dce_attr_code code_fd_va = DCE_CODE(5, 14, 1);
+static struct dce_attr_code code_fd_cbmt = DCE_CODE(5, 15, 1);
+static struct dce_attr_code code_fd_asal = DCE_CODE(5, 16, 4);
+static struct dce_attr_code code_fd_ptv2 = DCE_CODE(5, 21, 1);
+static struct dce_attr_code code_fd_ptv1 = DCE_CODE(5, 22, 1);
+static struct dce_attr_code code_fd_pta = DCE_CODE(5, 23, 1);
+static struct dce_attr_code code_fd_dropp = DCE_CODE(5, 24, 3);
+static struct dce_attr_code code_fd_sc = DCE_CODE(5, 27, 1);
+static struct dce_attr_code code_fd_dd = DCE_CODE(5, 28, 4);
+static struct dce_attr_code code_fd_flc_lo = DCE_CODE(6, 0, 32);
+static struct dce_attr_code code_fd_flc_hi = DCE_CODE(7, 0, 32);
+
+/* Frame List Entry */
+static struct dce_attr_code code_fle_sw_token = DCE_CODE(1, 17, 15);
+static struct dce_attr_code code_fle_addr_lo = DCE_CODE(0, 0, 32);
+static struct dce_attr_code code_fle_addr_hi_17 = DCE_CODE(1, 0, 17);
+static struct dce_attr_code code_fle_addr_hi_32 = DCE_CODE(1, 0, 32);
+static struct dce_attr_code code_fle_data_len_18 = DCE_CODE(2, 0, 18);
+static struct dce_attr_code code_fle_data_len_32 = DCE_CODE(2, 0, 32);
+static struct dce_attr_code code_fle_mem = DCE_CODE(2, 20, 12);
+static struct dce_attr_code code_fle_bpid = DCE_CODE(3, 0, 14);
+static struct dce_attr_code code_fle_ivp = DCE_CODE(3, 14, 1);
+static struct dce_attr_code code_fle_bmt = DCE_CODE(3, 15, 1);
+static struct dce_attr_code code_fle_offset = DCE_CODE(3, 16, 12);
+static struct dce_attr_code code_fle_format = DCE_CODE(3, 28, 2);
+static struct dce_attr_code code_fle_sl = DCE_CODE(3, 30, 1);
+static struct dce_attr_code code_fle_final = DCE_CODE(3, 31, 1);
+static struct dce_attr_code code_fle_frc = DCE_CODE(4, 0, 32);
+static struct dce_attr_code code_fle_err = DCE_CODE(5, 0, 8);
+static struct dce_attr_code code_fle_fd_compat_1 = DCE_CODE(5, 14, 1);
+static struct dce_attr_code code_fle_cbmt = DCE_CODE(5, 15, 1);
+static struct dce_attr_code code_fle_asal = DCE_CODE(5, 16, 4);
+static struct dce_attr_code code_fle_ptv2 = DCE_CODE(5, 21, 1);
+static struct dce_attr_code code_fle_ptv1 = DCE_CODE(5, 22, 1);
+static struct dce_attr_code code_fle_pta = DCE_CODE(5, 23, 1);
+static struct dce_attr_code code_fle_fd_compat_8 = DCE_CODE(5, 24, 8);
+static struct dce_attr_code code_fle_flc_lo = DCE_CODE(6, 0, 32);
+static struct dce_attr_code code_fle_flc_hi = DCE_CODE(7, 0, 32);
+
+uint64_t fd_attr_get_addr_64(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_fd_addr_hi_32,
+			p) << 32) |
+			(uint64_t)dce_attr_code_decode(&code_fd_addr_lo,
+			p);
+}
+EXPORT_SYMBOL(fd_attr_get_addr_64);
+
+void fd_attr_get_addr_49(struct fd_attr *d, u32 *hi, u32 *lo)
+{
+	u32 *p = ATTR32(d);
+
+	*hi = dce_attr_code_decode(&code_fd_addr_hi_17, p);
+	*lo = dce_attr_code_decode(&code_fd_addr_lo, p);
+}
+EXPORT_SYMBOL(fd_attr_get_addr_49);
+
+void fd_attr_get_addr_64_v2(struct fd_attr *d, u32 *hi, u32 *lo)
+{
+	u32 *p = ATTR32(d);
+
+	*hi = dce_attr_code_decode(&code_fd_addr_hi_32, p);
+	*lo = dce_attr_code_decode(&code_fd_addr_lo, p);
+}
+EXPORT_SYMBOL(fd_attr_get_addr_64_v2);
+
+u32 fd_attr_get_sw_token(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_sw_token, p);
+}
+EXPORT_SYMBOL(fd_attr_get_sw_token);
+
+u32 fd_attr_get_data_len_18(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_data_len_18, p);
+}
+EXPORT_SYMBOL(fd_attr_get_data_len_18);
+
+u32 fd_attr_get_data_len_32(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_data_len_32, p);
+}
+EXPORT_SYMBOL(fd_attr_get_data_len_32);
+
+u32 fd_attr_get_mem(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_mem, p);
+}
+EXPORT_SYMBOL(fd_attr_get_mem);
+
+u32 fd_attr_get_bpid(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_bpid, p);
+}
+EXPORT_SYMBOL(fd_attr_get_bpid);
+
+u32 fd_attr_get_ivp(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_ivp, p);
+}
+EXPORT_SYMBOL(fd_attr_get_ivp);
+
+u32 fd_attr_get_bmt(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_bmt, p);
+}
+EXPORT_SYMBOL(fd_attr_get_bmt);
+
+u32 fd_attr_get_offset(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_offset, p);
+}
+EXPORT_SYMBOL(fd_attr_get_offset);
+
+u32 fd_attr_get_frame_format(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_format, p);
+}
+EXPORT_SYMBOL(fd_attr_get_frame_format);
+
+u32 fd_attr_get_sl(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_sl, p);
+}
+EXPORT_SYMBOL(fd_attr_get_sl);
+
+u32 fd_attr_get_frc(const struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_frc, p);
+}
+EXPORT_SYMBOL(fd_attr_get_frc);
+
+u32 fd_attr_get_frc_status(const struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_frc_status, p);
+}
+EXPORT_SYMBOL(fd_attr_get_frc_status);
+
+u32 fd_attr_get_err(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_err, p);
+}
+EXPORT_SYMBOL(fd_attr_get_err);
+
+u32 fd_attr_get_va(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_va, p);
+}
+EXPORT_SYMBOL(fd_attr_get_va);
+
+u32 fd_attr_get_cbmt(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_cbmt, p);
+}
+EXPORT_SYMBOL(fd_attr_get_cbmt);
+
+u32 fd_attr_get_asal(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_asal, p);
+}
+EXPORT_SYMBOL(fd_attr_get_asal);
+
+u32 fd_attr_get_ptv2(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_ptv2, p);
+}
+EXPORT_SYMBOL(fd_attr_get_ptv2);
+
+u32 fd_attr_get_ptv1(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_ptv1, p);
+}
+EXPORT_SYMBOL(fd_attr_get_ptv1);
+
+u32 fd_attr_get_pta(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_pta, p);
+}
+EXPORT_SYMBOL(fd_attr_get_pta);
+
+u32 fd_attr_get_dropp(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_dropp, p);
+}
+EXPORT_SYMBOL(fd_attr_get_dropp);
+
+u32 fd_attr_get_sc(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_sc, p);
+}
+EXPORT_SYMBOL(fd_attr_get_sc);
+
+u32 fd_attr_get_dd(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fd_dd, p);
+}
+EXPORT_SYMBOL(fd_attr_get_dd);
+
+void fd_attr_get_flc_64_v2(struct fd_attr *d, u32 *hi, u32 *lo)
+{
+	u32 *p = ATTR32(d);
+
+	*hi = dce_attr_code_decode(&code_fd_flc_hi, p);
+	*lo = dce_attr_code_decode(&code_fd_flc_lo, p);
+}
+EXPORT_SYMBOL(fd_attr_get_flc_64_v2);
+
+void fd_attr_set_flc_64(struct fd_attr *d, uint64_t addr)
+{
+	const u32 *p = ATTR32(d);
+
+	dce_attr_code_encode_64(&code_fd_flc_lo, (uint64_t *)p, addr);
+}
+EXPORT_SYMBOL(fd_attr_set_flc_64);
+
+uint64_t fd_attr_get_flc_64(struct fd_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_fd_flc_hi,
+			p) << 32) |
+			(uint64_t)dce_attr_code_decode(&code_fd_flc_lo,
+			p);
+}
+EXPORT_SYMBOL(fd_attr_get_flc_64);
+
+void pretty_print_fd(struct fd_attr *d)
+{
+	pr_info("FD is\n");
+	pr_info("  ADDR = 0x%llx\n", fd_attr_get_addr_64(d));
+	if (fd_attr_get_sl(d)) {
+		pr_info("  DATA_LENGTH_18 = %u\n", fd_attr_get_data_len_18(d));
+		pr_info("  MEM = %u\n", fd_attr_get_mem(d));
+
+	} else {
+		pr_info("  DATA_LENGTH_32 = %u\n", fd_attr_get_data_len_32(d));
+	}
+	pr_info("  BPID = %u\n", fd_attr_get_bpid(d));
+	pr_info("  IVP = %u\n", fd_attr_get_ivp(d));
+	pr_info("  BMT = %u\n", fd_attr_get_bmt(d));
+	pr_info("  OFFSET = %u\n", fd_attr_get_offset(d));
+	pr_info("  FORMAT = %u\n", fd_attr_get_frame_format(d));
+	pr_info("  SL = %u\n", fd_attr_get_sl(d));
+	pr_info("  FRC = 0x%x\n", fd_attr_get_frc(d));
+	pr_info("  ERR = %u\n", fd_attr_get_err(d));
+	pr_info("  VA = %u\n", fd_attr_get_va(d));
+	pr_info("  CBMT = %u\n", fd_attr_get_cbmt(d));
+	pr_info("  ASAL = %u\n", fd_attr_get_asal(d));
+	pr_info("  PTV2 = %u\n", fd_attr_get_ptv2(d));
+	pr_info("  PTV1 = %u\n", fd_attr_get_ptv1(d));
+	pr_info("  PTA = %u\n", fd_attr_get_pta(d));
+	pr_info("  DROPP = %u\n", fd_attr_get_dropp(d));
+	pr_info("  SC = %u\n", fd_attr_get_sc(d));
+	pr_info("  DD = %u\n", fd_attr_get_dd(d));
+	pr_info("  FLC = 0x%llx\n", fd_attr_get_flc_64(d));
+}
+EXPORT_SYMBOL(pretty_print_fd);
+
+/* FLE */
+uint64_t fle_attr_get_addr_64(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_fle_addr_hi_32,
+			p) << 32) |
+			(uint64_t)dce_attr_code_decode(&code_fle_addr_lo,
+			p);
+}
+EXPORT_SYMBOL(fle_attr_get_addr_64);
+
+u32 fle_attr_get_sw_token(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_sw_token, p);
+}
+EXPORT_SYMBOL(fle_attr_get_sw_token);
+
+void fle_attr_get_addr_49(struct fle_attr *d,  u32 *hi, u32 *lo)
+{
+	u32 *p = ATTR32(d);
+
+	*hi = dce_attr_code_decode(&code_fle_addr_hi_17, p);
+	*lo = dce_attr_code_decode(&code_fle_addr_lo, p);
+}
+EXPORT_SYMBOL(fle_attr_get_addr_49);
+
+void fle_attr_get_addr_64_v2(struct fle_attr *d,  u32 *hi, u32 *lo)
+{
+	u32 *p = ATTR32(d);
+
+	*hi = dce_attr_code_decode(&code_fle_addr_hi_32, p);
+	*lo = dce_attr_code_decode(&code_fle_addr_lo, p);
+}
+EXPORT_SYMBOL(fle_attr_get_addr_64_v2);
+
+u32 fle_attr_get_data_len_18(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_data_len_18, p);
+}
+EXPORT_SYMBOL(fle_attr_get_data_len_18);
+
+u32 fle_attr_get_data_len_32(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_data_len_32, p);
+}
+EXPORT_SYMBOL(fle_attr_get_data_len_32);
+
+u32 fle_attr_get_mem(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_mem, p);
+}
+EXPORT_SYMBOL(fle_attr_get_mem);
+
+u32 fle_attr_get_bpid(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_bpid, p);
+}
+EXPORT_SYMBOL(fle_attr_get_bpid);
+
+u32 fle_attr_get_ivp(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_ivp, p);
+}
+EXPORT_SYMBOL(fle_attr_get_ivp);
+
+u32 fle_attr_get_bmt(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_bmt, p);
+}
+EXPORT_SYMBOL(fle_attr_get_bmt);
+
+u32 fle_attr_get_offset(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_offset, p);
+}
+EXPORT_SYMBOL(fle_attr_get_offset);
+
+u32 fle_attr_get_frame_format(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_format, p);
+}
+EXPORT_SYMBOL(fle_attr_get_frame_format);
+
+u32 fle_attr_get_sl(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_sl, p);
+}
+EXPORT_SYMBOL(fle_attr_get_sl);
+
+u32 fle_attr_get_final(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_final, p);
+}
+EXPORT_SYMBOL(fle_attr_get_final);
+
+u32 fle_attr_get_frc(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_frc, p);
+}
+EXPORT_SYMBOL(fle_attr_get_frc);
+
+u32 fle_attr_get_err(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_err, p);
+}
+EXPORT_SYMBOL(fle_attr_get_err);
+
+u32 fle_attr_get_fd_compat_1(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_fd_compat_1, p);
+}
+EXPORT_SYMBOL(fle_attr_get_fd_compat_1);
+
+u32 fle_attr_get_cbmt(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_cbmt, p);
+}
+EXPORT_SYMBOL(fle_attr_get_cbmt);
+
+u32 fle_attr_get_asal(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_asal, p);
+}
+EXPORT_SYMBOL(fle_attr_get_asal);
+
+u32 fle_attr_get_ptv2(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_ptv2, p);
+}
+EXPORT_SYMBOL(fle_attr_get_ptv2);
+
+u32 fle_attr_get_ptv1(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_ptv1, p);
+}
+EXPORT_SYMBOL(fle_attr_get_ptv1);
+
+u32 fle_attr_get_pta(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_pta, p);
+}
+EXPORT_SYMBOL(fle_attr_get_pta);
+
+u32 fle_attr_get_fd_compat_8(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return dce_attr_code_decode(&code_fle_fd_compat_8, p);
+}
+EXPORT_SYMBOL(fle_attr_get_fd_compat_8);
+
+void fle_attr_set_flc_64(struct fle_attr *d, uint64_t addr)
+{
+	const u32 *p = ATTR32(d);
+
+	dce_attr_code_encode_64(&code_fle_flc_lo, (uint64_t *)p, addr);
+}
+EXPORT_SYMBOL(fle_attr_set_flc_64);
+
+uint64_t fle_attr_get_flc_64(struct fle_attr *d)
+{
+	const u32 *p = ATTR32(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_fle_flc_hi,
+			p) << 32) |
+			(uint64_t)dce_attr_code_decode(&code_fle_flc_lo,
+			p);
+}
+EXPORT_SYMBOL(fle_attr_get_flc_64);
+
+void pretty_print_fle(struct fle_attr *d)
+{
+	pr_info("  ADDR = 0x%llx\n", fle_attr_get_addr_64(d));
+	if (fle_attr_get_sl(d)) {
+		pr_info("  DATA_LENGTH_18 = %u\n", fle_attr_get_data_len_18(d));
+		pr_info("  MEM = %u\n", fle_attr_get_mem(d));
+
+	} else {
+		pr_info("  DATA_LENGTH_32 = %u\n", fle_attr_get_data_len_32(d));
+	}
+	pr_info("  BPID = %u\n", fle_attr_get_bpid(d));
+	pr_info("  IVP = %u\n", fle_attr_get_ivp(d));
+	pr_info("  BMT = %u\n", fle_attr_get_bmt(d));
+	pr_info("  OFFSET = %u\n", fle_attr_get_offset(d));
+	pr_info("  FORMAT = %u\n", fle_attr_get_frame_format(d));
+	pr_info("  SL = %u\n", fle_attr_get_sl(d));
+	pr_info("  FINAL = %u\n", fle_attr_get_final(d));
+	pr_info("  FRC = 0x%x\n", fle_attr_get_frc(d));
+	pr_info("  ERR = %u\n", fle_attr_get_err(d));
+	pr_info("  FD_COMPAT_1 = %u\n", fle_attr_get_fd_compat_1(d));
+	pr_info("  CBMT = %u\n", fle_attr_get_cbmt(d));
+	pr_info("  ASAL = %u\n", fle_attr_get_asal(d));
+	pr_info("  PTV2 = %u\n", fle_attr_get_ptv2(d));
+	pr_info("  PTV1 = %u\n", fle_attr_get_ptv1(d));
+	pr_info("  PTA = %u\n", fle_attr_get_pta(d));
+	pr_info("  FD_COMPAT_8 = %u\n", fle_attr_get_fd_compat_8(d));
+	pr_info("  FLC = 0x%llx\n", fle_attr_get_flc_64(d));
+}
+EXPORT_SYMBOL(pretty_print_fle);
+
+void pretty_print_fle_n(struct fle_attr *d, int n)
+{
+	int k;
+
+	pr_info("\n");
+	for (k = 0; k < n; k++) {
+		pr_info("FL Entry %d\n", k);
+		pretty_print_fle(d++);
+	}
+}
+EXPORT_SYMBOL(pretty_print_fle_n);
+
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-fd.h b/drivers/staging/fsl-dpaa2/dce/dce-fd.h
new file mode 100644
index 0000000..d9a83dc
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-fd.h
@@ -0,0 +1,113 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LDCE_FD_H
+#define __LDCE_FD_H
+
+#include "dce-fd.h"
+#include <linux/types.h>
+
+
+struct fd_attr {
+	u32 dont_manipulate_directly[8];
+};
+
+struct fle_attr {
+	u32 dont_manipulate_directly[8];
+};
+
+/* Frame Descriptor */
+uint64_t fd_attr_get_addr_64(struct fd_attr *d);
+void fd_attr_get_addr_49(struct fd_attr *d, u32 *hi, u32 *lo);
+void fd_attr_get_addr_64_v2(struct fd_attr *d, u32 *hi, u32 *lo);
+u32 fd_attr_get_sw_token(struct fd_attr *d);
+
+u32 fd_attr_get_data_len_18(struct fd_attr *d);
+u32 fd_attr_get_data_len_32(struct fd_attr *d);
+u32 fd_attr_get_mem(struct fd_attr *d);
+u32 fd_attr_get_bpid(struct fd_attr *d);
+u32 fd_attr_get_ivp(struct fd_attr *d);
+u32 fd_attr_get_bmt(struct fd_attr *d);
+u32 fd_attr_get_offset(struct fd_attr *d);
+u32 fd_attr_get_frame_format(struct fd_attr *d);
+u32 fd_attr_get_sl(struct fd_attr *d);
+u32 fd_attr_get_frc(const struct fd_attr *d);
+u32 fd_attr_get_frc_status(const struct fd_attr *d);
+u32 fd_attr_get_err(struct fd_attr *d);
+u32 fd_attr_get_va(struct fd_attr *d);
+u32 fd_attr_get_cbmt(struct fd_attr *d);
+u32 fd_attr_get_asal(struct fd_attr *d);
+u32 fd_attr_get_ptv2(struct fd_attr *d);
+u32 fd_attr_get_ptv1(struct fd_attr *d);
+u32 fd_attr_get_pta(struct fd_attr *d);
+u32 fd_attr_get_dropp(struct fd_attr *d);
+u32 fd_attr_get_sc(struct fd_attr *d);
+u32 fd_attr_get_dd(struct fd_attr *d);
+void pretty_print_fd(struct fd_attr *d);
+
+/* set methods */
+void fd_attr_set_flc_64(struct fd_attr *d, uint64_t addr);
+uint64_t fd_attr_get_flc_64(struct fd_attr *d);
+
+
+/*  Frame list entry (FLE) */
+uint64_t fle_attr_get_addr_64(struct fle_attr *d);
+void fle_attr_get_addr_49(struct fle_attr *d,  u32 *hi, u32 *lo);
+void fle_attr_get_addr_64_v2(struct fle_attr *d,  u32 *hi, u32 *lo);
+u32 fle_attr_get_sw_token(struct fle_attr *d);
+u32 fle_attr_get_data_len_18(struct fle_attr *d);
+u32 fle_attr_get_data_len_32(struct fle_attr *d);
+u32 fle_attr_get_mem(struct fle_attr *d);
+u32 fle_attr_get_bpid(struct fle_attr *d);
+u32 fle_attr_get_ivp(struct fle_attr *d);
+u32 fle_attr_get_bmt(struct fle_attr *d);
+u32 fle_attr_get_offset(struct fle_attr *d);
+u32 fle_attr_get_frame_format(struct fle_attr *d);
+u32 fle_attr_get_sl(struct fle_attr *d);
+u32 fle_attr_get_final(struct fle_attr *d);
+u32 fle_attr_get_frc(struct fle_attr *d);
+u32 fle_attr_get_err(struct fle_attr *d);
+u32 fle_attr_get_fd_compat_1(struct fle_attr *d);
+u32 fle_attr_get_cbmt(struct fle_attr *d);
+u32 fle_attr_get_asal(struct fle_attr *d);
+u32 fle_attr_get_ptv2(struct fle_attr *d);
+u32 fle_attr_get_ptv1(struct fle_attr *d);
+u32 fle_attr_get_pta(struct fle_attr *d);
+u32 fle_attr_get_fd_compat_8(struct fle_attr *d);
+
+void fle_attr_set_flc_64(struct fle_attr *d, uint64_t addr);
+uint64_t fle_attr_get_flc_64(struct fle_attr *d);
+void fle_attr_get_flc_64_v2(struct fle_attr *d,  u32 *hi, u32 *lo);
+
+void pretty_print_fle(struct fle_attr *d);
+void pretty_print_fle_n(struct fle_attr *d, int n);
+
+#endif
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-private.h b/drivers/staging/fsl-dpaa2/dce/dce-private.h
new file mode 100644
index 0000000..12ebbaa
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-private.h
@@ -0,0 +1,112 @@
+/* Copyright (C) 2014 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+#ifndef __LDCE_PRIVATE_H
+#define __LDCE_PRIVATE_H
+
+#include "dce-sys-decl.h"
+
+/* Perform extra checking */
+#define DCE_CHECKING
+#define MAKE_MASK32(width) (width == 32 ? 0xffffffff : \
+				 (u32)((1 << width) - 1))
+#define DECLARE_CODEC32(t) \
+static inline u32 e32_##t(u32 lsoffset, u32 width, t val) \
+{ \
+	BUG_ON(width > (sizeof(t) * 8)); \
+	return ((u32)val & MAKE_MASK32(width)) << lsoffset; \
+} \
+static inline t d32_##t(u32 lsoffset, u32 width, u32 val) \
+{ \
+	BUG_ON(width > (sizeof(t) * 8)); \
+	return (t)((val >> lsoffset) & MAKE_MASK32(width)); \
+} \
+static inline u32 i32_##t(u32 lsoffset, u32 width, \
+				u32 val) \
+{ \
+	BUG_ON(width > (sizeof(t) * 8)); \
+	return e32_##t(lsoffset, width, d32_##t(lsoffset, width, val)); \
+} \
+static inline u32 r32_##t(u32 lsoffset, u32 width, \
+				u32 val) \
+{ \
+	BUG_ON(width > (sizeof(t) * 8)); \
+	return ~(MAKE_MASK32(width) << lsoffset) & val; \
+}
+DECLARE_CODEC32(u32)
+DECLARE_CODEC32(uint16_t)
+DECLARE_CODEC32(uint8_t)
+DECLARE_CODEC32(int)
+	/*********************/
+	/* Debugging assists */
+	/*********************/
+
+static inline void __hexdump(unsigned long start, unsigned long end,
+			unsigned long p, size_t sz, const unsigned char *c)
+{
+	while (start < end) {
+		unsigned int pos = 0;
+		char buf[64];
+		int nl = 0;
+
+		pos += sprintf(buf + pos, "%08lx: ", start);
+		do {
+			if ((start < p) || (start >= (p + sz)))
+				pos += sprintf(buf + pos, "..");
+			else
+				pos += sprintf(buf + pos, "%02x", *(c++));
+			if (!(++start & 15)) {
+				buf[pos++] = '\n';
+				nl = 1;
+			} else {
+				nl = 0;
+				if (!(start & 1))
+					buf[pos++] = ' ';
+				if (!(start & 3))
+					buf[pos++] = ' ';
+			}
+		} while (start & 15);
+		if (!nl)
+			buf[pos++] = '\n';
+		buf[pos] = '\0';
+		pr_info("%s", buf);
+	}
+}
+static inline void hexdump(const void *ptr, size_t sz)
+{
+	unsigned long p = (unsigned long)ptr;
+	unsigned long start = p & ~(unsigned long)15;
+	unsigned long end = (p + sz + 15) & ~(unsigned long)15;
+	const unsigned char *c = ptr;
+
+	__hexdump(start, end, p, sz, c);
+}
+
+#endif /* LDCE_PRIVATE_H */
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-scf-compression.c b/drivers/staging/fsl-dpaa2/dce/dce-scf-compression.c
new file mode 100644
index 0000000..7c6212c
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-scf-compression.c
@@ -0,0 +1,891 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "dce-scf-compression.h"
+#include "dce-attr-encoder-decoder.h"
+
+/* DCE_CODE (word_offset, lsb_offset, bit_width) */
+static struct dce_attr_code code_ffdpc_lo = DCE_CODE(0, 0, 32);
+static struct dce_attr_code code_ffdpc_hi = DCE_CODE(1, 0, 32);
+static struct dce_attr_code code_bp2ac = DCE_CODE(2, 0, 32);
+static struct dce_attr_code code_bp1ac = DCE_CODE(3, 0, 32);
+static struct dce_attr_code code_bp2ac_bmt = DCE_CODE(2, 31, 1);
+static struct dce_attr_code code_bp2ac_bpid = DCE_CODE(2, 16, 14);
+static struct dce_attr_code code_bp2ac_pbs = DCE_CODE(2, 6, 10);
+static struct dce_attr_code code_bp1ac_bmt = DCE_CODE(3, 31, 1);
+static struct dce_attr_code code_bp1ac_bpid = DCE_CODE(3, 16, 14);
+static struct dce_attr_code code_bp1ac_pbs = DCE_CODE(3, 6, 10);
+static struct dce_attr_code code_next_flc_lo = DCE_CODE(4, 0, 32);
+static struct dce_attr_code code_next_flc_hi = DCE_CODE(5, 0, 32);
+static struct dce_attr_code code_history_len = DCE_CODE(6, 16, 16);
+static struct dce_attr_code code_extra_ptr_lo = DCE_CODE(8, 0, 32);
+static struct dce_attr_code code_extra_ptr_hi = DCE_CODE(9, 0, 32);
+static struct dce_attr_code code_pending_output_ptr_lo = DCE_CODE(10, 0, 32);
+static struct dce_attr_code code_pending_output_ptr_hi = DCE_CODE(11, 0, 32);
+static struct dce_attr_code code_history_ptr_lo = DCE_CODE(12, 6, 26);
+static struct dce_attr_code code_history_ptr_hi = DCE_CODE(13, 0, 32);
+/* the following could be in first or second 64B cache line */
+static struct dce_attr_code code_total_in = DCE_CODE(0, 0, 32);
+static struct dce_attr_code code_total_out = DCE_CODE(1, 0, 32);
+static struct dce_attr_code code_adler32 = DCE_CODE(2, 0, 32);
+static struct dce_attr_code code_b64_residue = DCE_CODE(3, 0, 24);
+static struct dce_attr_code code_b64_residue_len = DCE_CODE(3, 24, 2);
+static struct dce_attr_code code_output_phase = DCE_CODE(3, 26, 3);
+static struct dce_attr_code code_pmode = DCE_CODE(3, 31, 1);
+static struct dce_attr_code code_flg = DCE_CODE(4, 0, 8);
+static struct dce_attr_code code_cm = DCE_CODE(4, 8, 8);
+static struct dce_attr_code code_id2 = DCE_CODE(4, 16, 8);
+static struct dce_attr_code code_id1 = DCE_CODE(4, 24, 8);
+static struct dce_attr_code code_mtime = DCE_CODE(5, 0, 32);
+static struct dce_attr_code code_xlen = DCE_CODE(6, 0, 16);
+static struct dce_attr_code code_os = DCE_CODE(6, 16, 8);
+static struct dce_attr_code code_xfl = DCE_CODE(6, 24, 8);
+static struct dce_attr_code code_clen = DCE_CODE(7, 0, 16);
+static struct dce_attr_code code_nlen = DCE_CODE(7, 16, 16);
+static struct dce_attr_code code_pending_working_idx = DCE_CODE(10, 0, 16);
+static struct dce_attr_code code_pending_output_len_dbg = DCE_CODE(10, 16, 16);
+static struct dce_attr_code code_residue_data = DCE_CODE(12, 0, 23);
+static struct dce_attr_code code_residue_byte_count = DCE_CODE(12, 24, 5);
+static struct dce_attr_code code_header_remaining = DCE_CODE(14, 0, 18);
+static struct dce_attr_code code_mcplt = DCE_CODE(14, 22, 1);
+static struct dce_attr_code code_terminated = DCE_CODE(14, 29, 1);
+static struct dce_attr_code code_suspended = DCE_CODE(14, 30, 1);
+static struct dce_attr_code code_pmode_dbg = DCE_CODE(14, 31, 1);
+static struct dce_attr_code code_crc16 = DCE_CODE(15, 0, 32);
+static struct dce_attr_code code_bytes_processed = DCE_CODE(3, 0, 29);
+static struct dce_attr_code code_pending_output_len = DCE_CODE(4, 16, 16);
+
+
+/* scf_c_cfg accessors */
+
+/* TODO: FFDCP */
+
+void scf_c_cfg_clear(struct scf_c_cfg *d)
+{
+	memset(d, 0, sizeof(*d));
+}
+EXPORT_SYMBOL(scf_c_cfg_clear);
+
+void scf_c_cfg_set_bp2ac_bmt(struct scf_c_cfg *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp2ac_bmt, cl, !!enable);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_bp2ac_bmt);
+
+int scf_c_cfg_get_bp2ac_bmt(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bmt, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_bp2ac_bmt);
+
+void scf_c_cfg_set_bp2ac_bpid(struct scf_c_cfg *d, u32 bpid)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp2ac_bpid, cl, bpid);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_bp2ac_bpid);
+
+u32 scf_c_cfg_get_bp2ac_bpid(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bpid, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_bp2ac_bpid);
+
+void scf_c_cfg_set_bp2ac_pbs(struct scf_c_cfg *d, u32 pbs)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp2ac_pbs, cl, pbs);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_bp2ac_pbs);
+
+u32 scf_c_cfg_get_bp2ac_pbs(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_pbs, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_bp2ac_pbs);
+
+void scf_c_cfg_set_bp1ac_bmt(struct scf_c_cfg *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp1ac_bmt, cl, !!enable);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_bp1ac_bmt);
+
+int scf_c_cfg_get_bp1ac_bmt(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bmt, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_bp1ac_bmt);
+
+void scf_c_cfg_set_bp1ac_bpid(struct scf_c_cfg *d, u32 bpid)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp1ac_bpid, cl, bpid);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_bp1ac_bpid);
+
+u32 scf_c_cfg_get_bp1ac_bpid(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bpid, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_bp1ac_bpid);
+
+void scf_c_cfg_set_bp1ac_pbs(struct scf_c_cfg *d, u32 pbs)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp1ac_pbs, cl, pbs);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_bp1ac_pbs);
+
+u32 scf_c_cfg_get_bp1ac_pbs(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_pbs, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_bp1ac_pbs);
+
+void scf_c_cfg_set_next_flc(struct scf_c_cfg *d, uint64_t addr)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode_64(&code_next_flc_lo, (uint64_t *)cl, addr);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_next_flc);
+
+uint64_t scf_c_cfg_get_next_flc(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_next_flc_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_next_flc_lo, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_next_flc);
+
+void scf_c_cfg_set_extra_ptr(struct scf_c_cfg *d, uint64_t addr)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode_64(&code_extra_ptr_lo, (uint64_t *)cl, addr);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_extra_ptr);
+
+uint64_t scf_c_cfg_get_extra_ptr(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_extra_ptr_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_extra_ptr_lo, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_extra_ptr);
+
+void scf_c_cfg_set_pending_output_ptr(struct scf_c_cfg *d, uint64_t addr)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode_64(&code_pending_output_ptr_lo, (uint64_t *)cl,
+				addr);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_pending_output_ptr);
+
+uint64_t scf_c_cfg_get_pending_output_ptr(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(
+		&code_pending_output_ptr_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_pending_output_ptr_lo, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_pending_output_ptr);
+
+void scf_c_cfg_set_history_ptr(struct scf_c_cfg *d, uint64_t addr)
+{
+	/*
+	 * this pointer must be 64B aligned. Hardware assumes the lower
+	 * 6 bits are zero. The lower 6 bits in the structure should are
+	 * not defined and should not be interpreted.
+	 */
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_pending_output_ptr_lo, cl,
+			lower32(addr) >> 6);
+	dce_attr_code_encode(&code_history_ptr_hi, cl, upper32(addr));
+}
+EXPORT_SYMBOL(scf_c_cfg_set_history_ptr);
+
+uint64_t scf_c_cfg_get_history_ptr(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	/* see above comment about history pointer lower 6 bits */
+	return ((uint64_t)dce_attr_code_decode(
+		&code_history_ptr_hi, cl) << 32) |
+		(uint64_t)(dce_attr_code_decode(&code_history_ptr_lo, cl) << 6);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_history_ptr);
+
+void scf_c_cfg_set_total_in(struct scf_c_cfg *d, u32 byte_cnt)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_total_in, cl, byte_cnt);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_total_in);
+
+u32 scf_c_cfg_get_total_in(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_total_in, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_total_in);
+
+void scf_c_cfg_set_total_out(struct scf_c_cfg *d, u32 byte_cnt)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_total_out, cl, byte_cnt);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_total_out);
+
+u32 scf_c_cfg_get_total_out(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_total_out, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_total_out);
+
+void scf_c_cfg_set_adler32(struct scf_c_cfg *d, u32 adler32)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_adler32, cl, adler32);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_adler32);
+
+u32 scf_c_cfg_get_adler32(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_adler32, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_adler32);
+
+void scf_c_cfg_set_pmode(struct scf_c_cfg *d, int mode)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_bp2ac_bmt, cl, mode);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_pmode);
+
+int scf_c_cfg_get_pmode(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_pmode, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_pmode);
+
+void scf_c_cfg_set_flg(struct scf_c_cfg *d, u32 flg)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_flg, cl, flg);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_flg);
+
+u32 scf_c_cfg_get_flg(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_flg, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_flg);
+
+void scf_c_cfg_set_cm(struct scf_c_cfg *d, u32 cm)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_cm, cl, cm);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_cm);
+
+u32 scf_c_cfg_get_cm(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_cm, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_cm);
+
+void scf_c_cfg_set_id2(struct scf_c_cfg *d, u32 id2)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_id2, cl, id2);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_id2);
+
+u32 scf_c_cfg_get_id2(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_id2, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_id2);
+
+void scf_c_cfg_set_id1(struct scf_c_cfg *d, u32 id1)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_id1, cl, id1);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_id1);
+
+u32 scf_c_cfg_get_id1(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_id1, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_id1);
+
+void scf_c_cfg_set_mtime(struct scf_c_cfg *d, u32 mtime)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_mtime, cl, mtime);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_mtime);
+
+u32 scf_c_cfg_get_mtime(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_mtime, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_mtime);
+
+void scf_c_cfg_set_xlen(struct scf_c_cfg *d, u32 xlen)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_mtime, cl, xlen);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_xlen);
+
+u32 scf_c_cfg_get_xlen(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_xlen, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_xlen);
+
+void scf_c_cfg_set_os(struct scf_c_cfg *d, u32 os)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_os, cl, os);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_os);
+
+u32 scf_c_cfg_get_os(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_os, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_os);
+
+void scf_c_cfg_set_xfl(struct scf_c_cfg *d, u32 xfl)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_xfl, cl, xfl);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_xfl);
+
+u32 scf_c_cfg_get_xfl(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_xfl, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_xfl);
+
+void scf_c_cfg_set_clen(struct scf_c_cfg *d, u32 clen)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_clen, cl, clen);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_clen);
+
+u32 scf_c_cfg_get_clen(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_clen, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_clen);
+
+void scf_c_cfg_set_nlen(struct scf_c_cfg *d, u32 nlen)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_nlen, cl, nlen);
+}
+EXPORT_SYMBOL(scf_c_cfg_set_nlen);
+
+u32 scf_c_cfg_get_nlen(struct scf_c_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_nlen, cl);
+}
+EXPORT_SYMBOL(scf_c_cfg_get_nlen);
+
+/*******************************************************************************
+ *
+ * scf_c_result APIS
+ *
+ ******************************************************************************/
+void scf_c_result_set_total_in(struct scf_c_result *d, u32 byte_cnt)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_total_in, cl, byte_cnt);
+}
+EXPORT_SYMBOL(scf_c_result_set_total_in);
+
+u32 scf_c_result_get_total_in(struct scf_c_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_total_in, cl);
+}
+EXPORT_SYMBOL(scf_c_result_get_total_in);
+
+void scf_c_result_set_total_out(struct scf_c_result *d, u32 byte_cnt)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_total_out, cl, byte_cnt);
+}
+EXPORT_SYMBOL(scf_c_result_set_total_out);
+
+u32 scf_c_result_get_total_out(struct scf_c_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_total_out, cl);
+}
+EXPORT_SYMBOL(scf_c_result_get_total_out);
+
+void scf_c_result_set_adler32(struct scf_c_result *d, u32 adler32)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_adler32, cl, adler32);
+}
+EXPORT_SYMBOL(scf_c_result_set_adler32);
+
+u32 scf_c_result_get_adler32(struct scf_c_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_adler32, cl);
+}
+EXPORT_SYMBOL(scf_c_result_get_adler32);
+
+void scf_c_result_set_bytes_processed(struct scf_c_result *d, u32 val)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bytes_processed, cl, val);
+}
+EXPORT_SYMBOL(scf_c_result_set_bytes_processed);
+
+u32 scf_c_result_get_bytes_processed(struct scf_c_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bytes_processed, cl);
+}
+EXPORT_SYMBOL(scf_c_result_get_bytes_processed);
+
+void scf_c_result_set_pending_output_len(struct scf_c_result *d, u32 val)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_pending_output_len, cl, val);
+}
+EXPORT_SYMBOL(scf_c_result_set_pending_output_len);
+
+u32 scf_c_result_get_pending_output_len(struct scf_c_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_pending_output_len, cl);
+}
+EXPORT_SYMBOL(scf_c_result_get_pending_output_len);
+
+/*******************************************************************************
+ *
+ * scf_c_result_dbg APIS
+ *
+ ******************************************************************************/
+void scf_c_result_dbg_clear(struct scf_c_result_dbg *d)
+{
+	memset(d, 0, sizeof(*d));
+}
+EXPORT_SYMBOL(scf_c_result_dbg_clear);
+
+uint64_t scf_c_result_dbg_get_ffdpc(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_ffdpc_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_ffdpc_lo, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_ffdpc);
+
+u32 scf_c_result_dbg_get_bp2ac(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_bp2ac);
+
+int scf_c_result_dbg_get_bp2ac_bmt(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bmt, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_bp2ac_bmt);
+
+u32 scf_c_result_dbg_get_bp2ac_bpid(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bpid, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_bp2ac_bpid);
+
+u32 scf_c_result_dbg_get_bp2ac_pbs(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_pbs, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_bp2ac_pbs);
+
+u32 scf_c_result_dbg_get_bp1ac(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_bp1ac);
+
+int scf_c_result_dbg_get_bp1ac_bmt(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bmt, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_bp1ac_bmt);
+
+u32 scf_c_result_dbg_get_bp1ac_bpid(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bpid, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_bp1ac_bpid);
+
+u32 scf_c_result_dbg_get_bp1ac_pbs(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_pbs, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_bp1ac_pbs);
+
+uint64_t scf_c_result_dbg_get_next_flc(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_next_flc((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_next_flc);
+
+u32 scf_c_result_dbg_get_history_len(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_history_len, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_history_len);
+
+uint64_t scf_c_result_dbg_get_extra_ptr(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_extra_ptr_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_extra_ptr_lo, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_extra_ptr);
+
+uint64_t scf_c_result_dbg_get_pending_output_ptr(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)
+		dce_attr_code_decode(&code_pending_output_ptr_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_pending_output_ptr_lo, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_pending_output_ptr);
+
+uint64_t scf_c_result_dbg_get_history_ptr(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	/* see above comment about history pointer lower 6 bits */
+	return ((uint64_t)dce_attr_code_decode(
+		&code_history_ptr_hi, cl) << 32) |
+		(uint64_t)(dce_attr_code_decode(&code_history_ptr_lo, cl) << 6);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_history_ptr);
+
+u32 scf_c_result_dbg_get_total_in(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_total_in((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_total_in);
+
+u32 scf_c_result_dbg_get_total_out(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_total_out((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_total_out);
+
+u32 scf_c_result_dbg_get_adler32(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_adler32((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_adler32);
+
+u32 scf_c_result_dbg_get_b64_residue(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_b64_residue, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_b64_residue);
+
+u32 scf_c_result_dbg_get_b64_residue_len(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_b64_residue_len, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_b64_residue_len);
+
+u32 scf_c_result_dbg_get_output_phase(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_output_phase, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_output_phase);
+
+u32 scf_c_result_dbg_get_flg(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_flg((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_flg);
+
+u32 scf_c_result_dbg_get_cm(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_cm((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_cm);
+
+u32 scf_c_result_dbg_get_id2(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_id2((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_id2);
+
+u32 scf_c_result_dbg_get_id1(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_id1((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_id1);
+
+u32 scf_c_result_dbg_get_mtime(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_mtime((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_mtime);
+
+u32 scf_c_result_dbg_get_xlen(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_xlen((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_xlen);
+
+u32 scf_c_result_dbg_get_os(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_os((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_os);
+
+u32 scf_c_result_dbg_get_xfl(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_xfl((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_xfl);
+
+u32 scf_c_result_dbg_get_clen(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_clen((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_clen);
+
+u32 scf_c_result_dbg_get_nlen(struct scf_c_result_dbg *d)
+{
+	return scf_c_cfg_get_nlen((struct scf_c_cfg *)d);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_nlen);
+
+u32 scf_c_result_dbg_get_pending_working_idx(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_pending_working_idx, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_pending_working_idx);
+
+u32 scf_c_result_dbg_get_pending_working_len(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_pending_output_len_dbg, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_pending_working_len);
+
+u32 scf_c_result_dbg_get_residue_data(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_residue_data, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_residue_data);
+
+u32 scf_c_result_dbg_get_residue_byte_count(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_residue_byte_count, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_residue_byte_count);
+
+u32 scf_c_result_dbg_get_header_remaining(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_header_remaining, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_header_remaining);
+
+int scf_c_result_dbg_get_mcplt(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_mcplt, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_mcplt);
+
+int scf_c_result_dbg_get_terminated(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_terminated, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_terminated);
+
+int scf_c_result_dbg_get_suspended(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_suspended, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_suspended);
+
+int scf_c_result_dbg_get_pmode(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_pmode_dbg, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_pmode);
+
+u32 scf_c_result_dbg_get_crc16(struct scf_c_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_crc16, cl);
+}
+EXPORT_SYMBOL(scf_c_result_dbg_get_crc16);
+
+
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-scf-compression.h b/drivers/staging/fsl-dpaa2/dce/dce-scf-compression.h
new file mode 100644
index 0000000..8ccc064
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-scf-compression.h
@@ -0,0 +1,229 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LDCE_SCF_COMPRESSION_H
+#define __LDCE_SCF_COMPRESSION_H
+
+#include "dce-private.h"
+#define SCF_C_CFG_ALIGN	64
+
+struct scf_c_cfg {
+	u32 dont_manipulate_directly[32];
+};
+
+struct scf_c_result {
+	u32 dont_manipulate_directly[16];
+};
+
+struct scf_c_result_dbg {
+	u32 dont_manipulate_directly[32];
+};
+
+/*******************************************************************************
+ *
+ * scf_c_cfg APIS
+ *
+ ******************************************************************************/
+void scf_c_cfg_clear(struct scf_c_cfg *d);
+/* BP2 settings: buffer pool id, pool buffer size */
+void scf_c_cfg_set_bp2ac_bmt(struct scf_c_cfg *d, int enable);
+int scf_c_cfg_get_bp2ac_bmt(struct scf_c_cfg *d);
+void scf_c_cfg_set_bp2ac_bpid(struct scf_c_cfg *d, u32 bpid);
+u32 scf_c_cfg_get_bp2ac_bpid(struct scf_c_cfg *d);
+void scf_c_cfg_set_bp2ac_pbs(struct scf_c_cfg *d, u32 pbs);
+u32 scf_c_cfg_get_bp2ac_pbs(struct scf_c_cfg *d);
+
+/* BP1 settings: buffer pool id, pool buffer size */
+void scf_c_cfg_set_bp1ac_bmt(struct scf_c_cfg *d, int enable);
+int scf_c_cfg_get_bp1ac_bmt(struct scf_c_cfg *d);
+void scf_c_cfg_set_bp1ac_bpid(struct scf_c_cfg *d, u32 bpid);
+u32 scf_c_cfg_get_bp1ac_bpid(struct scf_c_cfg *d);
+void scf_c_cfg_set_bp1ac_pbs(struct scf_c_cfg *d, u32 pbs);
+u32 scf_c_cfg_get_bp1ac_pbs(struct scf_c_cfg *d);
+
+/* next_flc */
+void scf_c_cfg_set_next_flc(struct scf_c_cfg *d, uint64_t addr);
+uint64_t scf_c_cfg_get_next_flc(struct scf_c_cfg *d);
+
+/* extra ptr */
+void scf_c_cfg_set_extra_ptr(struct scf_c_cfg *d, uint64_t addr);
+uint64_t scf_c_cfg_get_extra_ptr(struct scf_c_cfg *d);
+
+/* pending output ptr */
+void scf_c_cfg_set_pending_output_ptr(struct scf_c_cfg *d, uint64_t addr);
+uint64_t scf_c_cfg_get_pending_output_ptr(struct scf_c_cfg *d);
+
+/* history ptr */
+void scf_c_cfg_set_history_ptr(struct scf_c_cfg *d, uint64_t addr);
+uint64_t scf_c_cfg_get_history_ptr(struct scf_c_cfg *d);
+
+/* total in */
+void scf_c_cfg_set_total_in(struct scf_c_cfg *d, u32 byte_cnt);
+u32 scf_c_cfg_get_total_in(struct scf_c_cfg *d);
+
+/* total out */
+void scf_c_cfg_set_total_out(struct scf_c_cfg *d, u32 byte_cnt);
+u32 scf_c_cfg_get_total_out(struct scf_c_cfg *d);
+
+void scf_c_cfg_set_adler32(struct scf_c_cfg *d, u32 adler32);
+u32 scf_c_cfg_get_adler32(struct scf_c_cfg *d);
+
+void scf_c_cfg_set_pmode(struct scf_c_cfg *d, int mode);
+int scf_c_cfg_get_pmode(struct scf_c_cfg *d);
+
+/* gzip,zlib header info */
+void scf_c_cfg_set_flg(struct scf_c_cfg *d, u32 flg);
+u32 scf_c_cfg_get_flg(struct scf_c_cfg *d);
+void scf_c_cfg_set_cm(struct scf_c_cfg *d, u32 cm);
+u32 scf_c_cfg_get_cm(struct scf_c_cfg *d);
+void scf_c_cfg_set_id2(struct scf_c_cfg *d, u32 id2);
+u32 scf_c_cfg_get_id2(struct scf_c_cfg *d);
+void scf_c_cfg_set_id1(struct scf_c_cfg *d, u32 id1);
+u32 scf_c_cfg_get_id1(struct scf_c_cfg *d);
+void scf_c_cfg_set_mtime(struct scf_c_cfg *d, u32 mtime);
+u32 scf_c_cfg_get_mtime(struct scf_c_cfg *d);
+void scf_c_cfg_set_xlen(struct scf_c_cfg *d, u32 xlen);
+u32 scf_c_cfg_get_xlen(struct scf_c_cfg *d);
+void scf_c_cfg_set_os(struct scf_c_cfg *d, u32 os);
+u32 scf_c_cfg_get_os(struct scf_c_cfg *d);
+void scf_c_cfg_set_xfl(struct scf_c_cfg *d, u32 xfl);
+u32 scf_c_cfg_get_xfl(struct scf_c_cfg *d);
+void scf_c_cfg_set_clen(struct scf_c_cfg *d, u32 clen);
+u32 scf_c_cfg_get_clen(struct scf_c_cfg *d);
+void scf_c_cfg_set_nlen(struct scf_c_cfg *d, u32 nlen);
+u32 scf_c_cfg_get_nlen(struct scf_c_cfg *d);
+
+/*******************************************************************************
+ *
+ * scf_c_result APIS
+ *
+ ******************************************************************************/
+void scf_c_result_clear(struct scf_c_result *d);
+/* total in */
+void scf_c_result_set_total_in(struct scf_c_result *d, u32 byte_cnt);
+u32 scf_c_result_get_total_in(struct scf_c_result *d);
+
+/* total out */
+void scf_c_result_set_total_out(struct scf_c_result *d, u32 byte_cnt);
+u32 scf_c_result_get_total_out(struct scf_c_result *d);
+
+/* adler32 */
+void scf_c_result_set_adler32(struct scf_c_result *d, u32 adler32);
+u32 scf_c_result_get_adler32(struct scf_c_result *d);
+
+void scf_c_result_set_bytes_processed(struct scf_c_result *d, u32 val);
+u32 scf_c_result_get_bytes_processed(struct scf_c_result *d);
+void scf_c_result_set_pending_output_len(struct scf_c_result *d, u32 val);
+u32 scf_c_result_get_pending_output_len(struct scf_c_result *d);
+
+
+/*******************************************************************************
+ *
+ * scf_c_result_dbg APIS
+ *
+ ******************************************************************************/
+void scf_c_result_dbg_clear(struct scf_c_result_dbg *d);
+/* FFDPC */
+uint64_t scf_c_result_dbg_get_ffdpc(struct scf_c_result_dbg *d);
+/* BP2 settings */
+u32 scf_c_result_dbg_get_bp2ac(struct scf_c_result_dbg *d);
+int scf_c_result_dbg_get_bp2ac_bmt(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_bp2ac_bpid(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_bp2ac_pbs(struct scf_c_result_dbg *d);
+/* BP1 settings */
+u32 scf_c_result_dbg_get_bp1ac(struct scf_c_result_dbg *d);
+int scf_c_result_dbg_get_bp1ac_bmt(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_bp1ac_bpid(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_bp1ac_pbs(struct scf_c_result_dbg *d);
+
+/* next_flc */
+uint64_t scf_c_result_dbg_get_next_flc(struct scf_c_result_dbg *d);
+
+/* history_len */
+u32 scf_c_result_dbg_get_history_len(struct scf_c_result_dbg *d);
+
+/* extra ptr */
+uint64_t scf_c_result_dbg_get_extra_ptr(struct scf_c_result_dbg *d);
+
+/* pending output ptr */
+uint64_t scf_c_result_dbg_get_pending_output_ptr(struct scf_c_result_dbg *d);
+
+/* history ptr */
+uint64_t scf_c_result_dbg_get_history_ptr(struct scf_c_result_dbg *d);
+
+/* total in */
+u32 scf_c_result_dbg_get_total_in(struct scf_c_result_dbg *d);
+
+/* total out */
+u32 scf_c_result_dbg_get_total_out(struct scf_c_result_dbg *d);
+
+/* adler32 */
+u32 scf_c_result_dbg_get_adler32(struct scf_c_result_dbg *d);
+
+/* b64_residue */
+u32 scf_c_result_dbg_get_b64_residue(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_b64_residue_len(struct scf_c_result_dbg *d);
+
+/* output phase */
+u32 scf_c_result_dbg_get_output_phase(struct scf_c_result_dbg *d);
+
+/* gzip,zlib header info */
+u32 scf_c_result_dbg_get_flg(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_cm(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_id2(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_id1(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_mtime(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_xlen(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_os(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_xfl(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_clen(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_nlen(struct scf_c_result_dbg *d);
+
+/* pending output data */
+u32 scf_c_result_dbg_get_pending_working_idx(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_pending_working_len(struct scf_c_result_dbg *d);
+
+/* residue info */
+u32 scf_c_result_dbg_get_residue_data(struct scf_c_result_dbg *d);
+u32 scf_c_result_dbg_get_residue_byte_count(struct scf_c_result_dbg *d);
+
+/* header remaining */
+u32 scf_c_result_dbg_get_header_remaining(struct scf_c_result_dbg *d);
+
+int scf_c_result_dbg_get_mcplt(struct scf_c_result_dbg *d);
+int scf_c_result_dbg_get_terminated(struct scf_c_result_dbg *d);
+int scf_c_result_dbg_get_suspended(struct scf_c_result_dbg *d);
+int scf_c_result_dbg_get_pmode(struct scf_c_result_dbg *d);
+
+/* crc16 */
+u32 scf_c_result_dbg_get_crc16(struct scf_c_result_dbg *d);
+
+#endif
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-scf-decompression.c b/drivers/staging/fsl-dpaa2/dce/dce-scf-decompression.c
new file mode 100644
index 0000000..213b07f
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-scf-decompression.c
@@ -0,0 +1,1094 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "dce-scf-decompression.h"
+#include "dce-attr-encoder-decoder.h"
+
+/* DCE_CODE (word_offset, lsb_offset, bit_width) */
+static struct dce_attr_code code_ffdpc_lo = DCE_CODE(0, 0, 32);
+static struct dce_attr_code code_ffdpc_hi = DCE_CODE(1, 0, 32);
+static struct dce_attr_code code_bp2ac = DCE_CODE(2, 0, 32);
+static struct dce_attr_code code_bp1ac = DCE_CODE(3, 0, 32);
+static struct dce_attr_code code_bp2ac_bmt = DCE_CODE(2, 31, 1);
+static struct dce_attr_code code_bp2ac_bpid = DCE_CODE(2, 16, 14);
+static struct dce_attr_code code_bp2ac_pbs = DCE_CODE(2, 6, 10);
+static struct dce_attr_code code_bp1ac_bmt = DCE_CODE(3, 31, 1);
+static struct dce_attr_code code_bp1ac_bpid = DCE_CODE(3, 16, 14);
+static struct dce_attr_code code_bp1ac_pbs = DCE_CODE(3, 6, 10);
+static struct dce_attr_code code_next_flc_lo = DCE_CODE(4, 0, 32);
+static struct dce_attr_code code_next_flc_hi = DCE_CODE(5, 0, 32);
+static struct dce_attr_code code_extra_limit = DCE_CODE(7, 0, 18);
+static struct dce_attr_code code_extra_ptr_lo = DCE_CODE(8, 0, 32);
+static struct dce_attr_code code_extra_ptr_hi = DCE_CODE(9, 0, 32);
+static struct dce_attr_code code_pending_output_ptr_lo = DCE_CODE(10, 0, 32);
+static struct dce_attr_code code_pending_output_ptr_hi = DCE_CODE(11, 0, 32);
+static struct dce_attr_code code_history_ptr_lo = DCE_CODE(12, 6, 26);
+static struct dce_attr_code code_history_ptr_hi = DCE_CODE(13, 0, 32);
+static struct dce_attr_code code_decomp_ctx_ptr_lo = DCE_CODE(14, 0, 32);
+static struct dce_attr_code code_decomp_ctx_ptr_hi = DCE_CODE(15, 0, 32);
+static struct dce_attr_code code_total_in = DCE_CODE(0, 0, 32);
+static struct dce_attr_code code_total_out = DCE_CODE(1, 0, 32);
+static struct dce_attr_code code_adler32 = DCE_CODE(2, 0, 32);
+static struct dce_attr_code code_mc = DCE_CODE(3, 30, 1);
+static struct dce_attr_code code_pmode = DCE_CODE(3, 31, 1);
+
+static struct dce_attr_code code_bytes_processed = DCE_CODE(3, 0, 29);
+static struct dce_attr_code code_co = DCE_CODE(3, 29, 1);
+static struct dce_attr_code code_no = DCE_CODE(3, 30, 1);
+static struct dce_attr_code code_xo = DCE_CODE(3, 31, 1);
+static struct dce_attr_code code_pending_output_len = DCE_CODE(4, 16, 16);
+static struct dce_attr_code code_flg = DCE_CODE(8, 0, 8);
+static struct dce_attr_code code_cm = DCE_CODE(8, 8, 8);
+static struct dce_attr_code code_id2 = DCE_CODE(8, 16, 8);
+static struct dce_attr_code code_id1 = DCE_CODE(8, 24, 8);
+static struct dce_attr_code code_mtime = DCE_CODE(9, 0, 32);
+static struct dce_attr_code code_xlen = DCE_CODE(10, 0, 16);
+static struct dce_attr_code code_os = DCE_CODE(10, 16, 8);
+static struct dce_attr_code code_xfl = DCE_CODE(10, 24, 8);
+static struct dce_attr_code code_clen = DCE_CODE(11, 0, 16);
+static struct dce_attr_code code_nlen = DCE_CODE(11, 16, 16);
+static struct dce_attr_code code_crc16 = DCE_CODE(12, 0, 32);
+
+static struct dce_attr_code code_ncbb_remaining = DCE_CODE(6, 0, 16);
+static struct dce_attr_code code_history_len = DCE_CODE(6, 16, 16);
+static struct dce_attr_code code_previous_code_len = DCE_CODE(12, 0, 4);
+
+static struct dce_attr_code code_b64_residue = DCE_CODE(3, 0, 24);
+static struct dce_attr_code code_b64_residue_len = DCE_CODE(3, 24, 2);
+static struct dce_attr_code code_output_phase = DCE_CODE(3, 26, 3);
+static struct dce_attr_code code_flg_dbg = DCE_CODE(4, 0, 8);
+static struct dce_attr_code code_cm_dbg = DCE_CODE(4, 8, 8);
+static struct dce_attr_code code_id2_dbg = DCE_CODE(4, 16, 8);
+static struct dce_attr_code code_id1_dbg = DCE_CODE(4, 24, 8);
+static struct dce_attr_code code_mtime_dbg = DCE_CODE(5, 0, 32);
+static struct dce_attr_code code_xlen_dbg = DCE_CODE(6, 0, 16);
+static struct dce_attr_code code_os_dbg = DCE_CODE(6, 16, 8);
+static struct dce_attr_code code_xfl_dbg = DCE_CODE(6, 24, 8);
+static struct dce_attr_code code_clen_dbg = DCE_CODE(7, 0, 16);
+static struct dce_attr_code code_nlen_dbg = DCE_CODE(7, 16, 16);
+/* TODO: huffman_residue */
+static struct dce_attr_code code_hclen = DCE_CODE(9, 18, 4);
+static struct dce_attr_code code_hdist = DCE_CODE(9, 22, 5);
+static struct dce_attr_code code_hlit = DCE_CODE(9, 27, 5);
+static struct dce_attr_code code_pending_working_idx = DCE_CODE(10, 0, 16);
+static struct dce_attr_code code_pending_output_len_dbg = DCE_CODE(10, 16, 16);
+static struct dce_attr_code code_num_code_len = DCE_CODE(11, 0, 9);
+static struct dce_attr_code code_frame_parse_state = DCE_CODE(11, 9, 5);
+static struct dce_attr_code code_decomp_total_out = DCE_CODE(13, 0, 32);
+static struct dce_attr_code code_header_remaining = DCE_CODE(14, 0, 18);
+static struct dce_attr_code code_btype = DCE_CODE(14, 18, 2);
+static struct dce_attr_code code_bfinal = DCE_CODE(14, 20, 1);
+static struct dce_attr_code code_mc_dbg = DCE_CODE(14, 21, 1);
+static struct dce_attr_code code_mcplt = DCE_CODE(14, 22, 1);
+static struct dce_attr_code code_huffman_rbc = DCE_CODE(14, 23, 6);
+static struct dce_attr_code code_terminated = DCE_CODE(14, 29, 1);
+static struct dce_attr_code code_suspended = DCE_CODE(14, 30, 1);
+static struct dce_attr_code code_pmode_dbg = DCE_CODE(14, 31, 1);
+static struct dce_attr_code code_crc16_dbg = DCE_CODE(15, 0, 32);
+
+/* scf_d_cfg accessors */
+void scf_d_cfg_clear(struct scf_d_cfg *d)
+{
+	memset(d, 0, sizeof(*d));
+}
+EXPORT_SYMBOL(scf_d_cfg_clear);
+
+void scf_d_cfg_set_bp2ac_bmt(struct scf_d_cfg *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp2ac_bmt, cl, !!enable);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_bp2ac_bmt);
+
+int scf_d_cfg_get_bp2ac_bmt(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bmt, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_bp2ac_bmt);
+
+void scf_d_cfg_set_bp2ac_bpid(struct scf_d_cfg *d, u32 bpid)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp2ac_bpid, cl, bpid);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_bp2ac_bpid);
+
+u32 scf_d_cfg_get_bp2ac_bpid(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bpid, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_bp2ac_bpid);
+
+void scf_d_cfg_set_bp2ac_pbs(struct scf_d_cfg *d, u32 pbs)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp2ac_pbs, cl, pbs);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_bp2ac_pbs);
+
+u32 scf_d_cfg_get_bp2ac_pbs(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_pbs, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_bp2ac_pbs);
+
+void scf_d_cfg_set_bp1ac_bmt(struct scf_d_cfg *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp1ac_bmt, cl, !!enable);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_bp1ac_bmt);
+
+int scf_d_cfg_get_bp1ac_bmt(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bmt, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_bp1ac_bmt);
+
+void scf_d_cfg_set_bp1ac_bpid(struct scf_d_cfg *d, u32 bpid)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp1ac_bpid, cl, bpid);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_bp1ac_bpid);
+
+u32 scf_d_cfg_get_bp1ac_bpid(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bpid, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_bp1ac_bpid);
+
+void scf_d_cfg_set_bp1ac_pbs(struct scf_d_cfg *d, u32 pbs)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bp1ac_pbs, cl, pbs);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_bp1ac_pbs);
+
+u32 scf_d_cfg_get_bp1ac_pbs(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_pbs, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_bp1ac_pbs);
+
+void scf_d_cfg_set_next_flc(struct scf_d_cfg *d, uint64_t addr)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode_64(&code_next_flc_lo, (uint64_t *)cl, addr);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_next_flc);
+
+uint64_t scf_d_cfg_get_next_flc(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_next_flc_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_next_flc_lo, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_next_flc);
+
+void scf_d_cfg_set_extra_ptr(struct scf_d_cfg *d, uint64_t addr)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode_64(&code_extra_ptr_lo, (uint64_t *)cl, addr);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_extra_ptr);
+
+uint64_t scf_d_cfg_get_extra_ptr(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_extra_ptr_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_extra_ptr_lo, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_extra_ptr);
+
+void scf_d_cfg_set_pending_output_ptr(struct scf_d_cfg *d, uint64_t addr)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode_64(&code_pending_output_ptr_lo, (uint64_t *)cl,
+				addr);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_pending_output_ptr);
+
+uint64_t scf_d_cfg_get_pending_output_ptr(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(
+		&code_pending_output_ptr_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_pending_output_ptr_lo, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_pending_output_ptr);
+
+void scf_d_cfg_set_history_ptr(struct scf_d_cfg *d, uint64_t addr)
+{
+	/*
+	 * this pointer must be 64B aligned. Hardware assumes the lower
+	 * 6 bits are zero. The lower 6 bits in the structure should are
+	 * not defined and should not be interpreted.
+	 */
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_pending_output_ptr_lo, cl,
+			lower32(addr) >> 6);
+	dce_attr_code_encode(&code_history_ptr_hi, cl, upper32(addr));
+}
+EXPORT_SYMBOL(scf_d_cfg_set_history_ptr);
+
+uint64_t scf_d_cfg_get_history_ptr(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	/* see above comment about history pointer lower 6 bits */
+	return ((uint64_t)dce_attr_code_decode(
+		&code_history_ptr_hi, cl) << 32) |
+		(uint64_t)(dce_attr_code_decode(&code_history_ptr_lo, cl) << 6);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_history_ptr);
+
+void scf_d_cfg_set_extra_limit(struct scf_d_cfg *d, u32 val)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_extra_limit, cl, val);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_extra_limit);
+
+u32 scf_d_cfg_get_extra_limit(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_extra_limit, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_extra_limit);
+
+void scf_d_cfg_set_decomp_ctx_ptr(struct scf_d_cfg *d, uint64_t addr)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode_64(&code_decomp_ctx_ptr_lo, (uint64_t *)cl, addr);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_decomp_ctx_ptr);
+
+uint64_t scf_d_cfg_get_decomp_ctx_ptr(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(
+			&code_decomp_ctx_ptr_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_decomp_ctx_ptr_lo, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_decomp_ctx_ptr);
+
+void scf_d_cfg_set_total_in(struct scf_d_cfg *d, u32 byte_cnt)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_total_in, cl, byte_cnt);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_total_in);
+
+u32 scf_d_cfg_get_total_in(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_total_in, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_total_in);
+
+void scf_d_cfg_set_total_out(struct scf_d_cfg *d, u32 byte_cnt)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_total_out, cl, byte_cnt);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_total_out);
+
+u32 scf_d_cfg_get_total_out(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_total_out, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_total_out);
+
+void scf_d_cfg_set_adler32(struct scf_d_cfg *d, u32 adler32)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_adler32, cl, adler32);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_adler32);
+
+u32 scf_d_cfg_get_adler32(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_adler32, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_adler32);
+
+void scf_d_cfg_set_member_continue(struct scf_d_cfg *d, int enable)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_mc, cl, !!enable);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_member_continue);
+
+int scf_d_cfg_get_member_continue(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_mc, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_member_continue);
+
+void scf_d_cfg_set_pmode(struct scf_d_cfg *d, int mode)
+{
+	u32 *cl = dce_cl2(d);
+
+	dce_attr_code_encode(&code_bp2ac_bmt, cl, mode);
+}
+EXPORT_SYMBOL(scf_d_cfg_set_pmode);
+
+int scf_d_cfg_get_pmode(struct scf_d_cfg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_pmode, cl);
+}
+EXPORT_SYMBOL(scf_d_cfg_get_pmode);
+
+/*******************************************************************************
+ *
+ * scf_d_result APIS
+ *
+ ******************************************************************************/
+void scf_d_result_clear(struct scf_d_result *d)
+{
+	memset(d, 0, sizeof(*d));
+}
+EXPORT_SYMBOL(scf_d_result_clear);
+
+void scf_d_result_set_total_in(struct scf_d_result *d, u32 byte_cnt)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_total_in, cl, byte_cnt);
+}
+EXPORT_SYMBOL(scf_d_result_set_total_in);
+
+u32 scf_d_result_get_total_in(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_total_in, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_total_in);
+
+void scf_d_result_set_total_out(struct scf_d_result *d, u32 byte_cnt)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_total_out, cl, byte_cnt);
+}
+EXPORT_SYMBOL(scf_d_result_set_total_out);
+
+u32 scf_d_result_get_total_out(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_total_out, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_total_out);
+
+void scf_d_result_set_adler32(struct scf_d_result *d, u32 adler32)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_adler32, cl, adler32);
+}
+EXPORT_SYMBOL(scf_d_result_set_adler32);
+
+u32 scf_d_result_get_adler32(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_adler32, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_adler32);
+
+void scf_d_result_set_bytes_processed(struct scf_d_result *d, u32 val)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_bytes_processed, cl, val);
+}
+EXPORT_SYMBOL(scf_d_result_set_bytes_processed);
+
+u32 scf_d_result_get_bytes_processed(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bytes_processed, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_bytes_processed);
+
+void scf_d_result_set_co(struct scf_d_result *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_co, cl, !!enable);
+}
+EXPORT_SYMBOL(scf_d_result_set_co);
+
+int scf_d_result_get_co(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_co, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_co);
+
+void scf_d_result_set_no(struct scf_d_result *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_no, cl, !!enable);
+}
+EXPORT_SYMBOL(scf_d_result_set_no);
+
+int scf_d_result_get_no(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_no, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_no);
+
+void scf_d_result_set_xo(struct scf_d_result *d, int enable)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_xo, cl, !!enable);
+}
+EXPORT_SYMBOL(scf_d_result_set_xo);
+
+int scf_d_result_get_xo(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_xo, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_xo);
+
+void scf_d_result_set_pending_output_len(struct scf_d_result *d, u32 val)
+{
+	u32 *cl = dce_cl(d);
+
+	dce_attr_code_encode(&code_pending_output_len, cl, val);
+}
+EXPORT_SYMBOL(scf_d_result_set_pending_output_len);
+
+u32 scf_d_result_get_pending_output_len(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_pending_output_len, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_pending_output_len);
+
+void scf_d_result_set_extra_limit(struct scf_d_result *d, u32 val)
+{
+	scf_d_cfg_set_extra_limit((struct scf_d_cfg *)d, val);
+}
+EXPORT_SYMBOL(scf_d_result_set_extra_limit);
+
+u32 scf_d_result_get_extra_limit(struct scf_d_result *d)
+{
+	return scf_d_cfg_get_extra_limit((struct scf_d_cfg *)d);
+}
+EXPORT_SYMBOL(scf_d_result_get_extra_limit);
+
+u32 scf_d_result_get_flg(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_flg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_flg);
+
+u32 scf_d_result_get_cm(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_cm, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_cm);
+
+u32 scf_d_result_get_id2(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_id2, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_id2);
+
+u32 scf_d_result_get_id1(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_id1, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_id1);
+
+u32 scf_d_result_get_mtime(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_mtime, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_mtime);
+
+u32 scf_d_result_get_xlen(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_xlen, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_xlen);
+
+u32 scf_d_result_get_os(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_os, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_os);
+
+u32 scf_d_result_get_xfl(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_xfl, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_xfl);
+
+u32 scf_d_result_get_clen(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_clen, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_clen);
+
+u32 scf_d_result_get_nlen(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_nlen, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_nlen);
+
+u32 scf_d_result_get_crc16(struct scf_d_result *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_crc16, cl);
+}
+EXPORT_SYMBOL(scf_d_result_get_crc16);
+
+
+/*******************************************************************************
+ *
+ * scf_d_result_dbg APIS
+ *
+ ******************************************************************************/
+void scf_d_result_dbg_clear(struct scf_d_result_dbg *d)
+{
+	memset(d, 0, sizeof(*d));
+}
+EXPORT_SYMBOL(scf_d_result_dbg_clear);
+
+uint64_t scf_d_result_dbg_get_ffdpc(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_ffdpc_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_ffdpc_lo, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_ffdpc);
+
+u32 scf_d_result_dbg_get_bp2ac(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_bp2ac);
+
+int scf_d_result_dbg_get_bp2ac_bmt(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bmt, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_bp2ac_bmt);
+
+u32 scf_d_result_dbg_get_bp2ac_bpid(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_bpid, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_bp2ac_bpid);
+
+u32 scf_d_result_dbg_get_bp2ac_pbs(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp2ac_pbs, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_bp2ac_pbs);
+
+u32 scf_d_result_dbg_get_bp1ac(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_bp1ac);
+
+int scf_d_result_dbg_get_bp1ac_bmt(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bmt, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_bp1ac_bmt);
+
+u32 scf_d_result_dbg_get_bp1ac_bpid(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_bpid, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_bp1ac_bpid);
+
+u32 scf_d_result_dbg_get_bp1ac_pbs(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_bp1ac_pbs, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_bp1ac_pbs);
+
+uint64_t scf_d_result_dbg_get_next_flc(struct scf_d_result_dbg *d)
+{
+	return scf_d_cfg_get_next_flc((struct scf_d_cfg *)d);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_next_flc);
+
+u32 scf_d_result_dbg_get_ncbb_remaining(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_ncbb_remaining, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_ncbb_remaining);
+
+u32 scf_d_result_dbg_get_history_len(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_history_len, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_history_len);
+
+u32 scf_d_result_dbg_get_extra_limit(struct scf_d_result_dbg *d)
+{
+	return scf_d_cfg_get_extra_limit((struct scf_d_cfg *)d);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_extra_limit);
+
+uint64_t scf_d_result_dbg_get_extra_ptr(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)dce_attr_code_decode(&code_extra_ptr_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_extra_ptr_lo, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_extra_ptr);
+
+uint64_t scf_d_result_dbg_get_pending_output_ptr(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return ((uint64_t)
+		dce_attr_code_decode(&code_pending_output_ptr_hi, cl) << 32) |
+		(uint64_t)dce_attr_code_decode(&code_pending_output_ptr_lo, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_pending_output_ptr);
+
+u32 scf_d_result_dbg_get_previous_code_len(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	return dce_attr_code_decode(&code_previous_code_len, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_previous_code_len);
+
+uint64_t scf_d_result_dbg_get_history_ptr(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl(d);
+
+	/* see above comment about history pointer lower 6 bits */
+	return ((uint64_t)dce_attr_code_decode(
+		&code_history_ptr_hi, cl) << 32) |
+		(uint64_t)(dce_attr_code_decode(&code_history_ptr_lo, cl) << 6);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_history_ptr);
+
+uint64_t scf_d_result_dbg_get_decomp_ctx_ptr(struct scf_d_result_dbg *d)
+{
+	return scf_d_cfg_get_decomp_ctx_ptr((struct scf_d_cfg *)d);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_decomp_ctx_ptr);
+
+/* second cache line attributes */
+
+u32 scf_d_result_dbg_get_total_in(struct scf_d_result_dbg *d)
+{
+	return scf_d_cfg_get_total_in((struct scf_d_cfg *)d);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_total_in);
+
+u32 scf_d_result_dbg_get_total_out(struct scf_d_result_dbg *d)
+{
+	return scf_d_cfg_get_total_out((struct scf_d_cfg *)d);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_total_out);
+
+u32 scf_d_result_dbg_get_adler32(struct scf_d_result_dbg *d)
+{
+	return scf_d_cfg_get_adler32((struct scf_d_cfg *)d);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_adler32);
+
+u32 scf_d_result_dbg_get_b64_residue(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_b64_residue, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_b64_residue);
+
+u32 scf_d_result_dbg_get_b64_residue_len(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_b64_residue_len, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_b64_residue_len);
+
+u32 scf_d_result_dbg_get_output_phase(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_output_phase, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_output_phase);
+
+int scf_d_result_dbg_get_co(struct scf_d_result_dbg *d)
+{
+	return scf_d_result_get_co((struct scf_d_result *)d);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_co);
+
+int scf_d_result_dbg_get_no(struct scf_d_result_dbg *d)
+{
+	return scf_d_result_get_no((struct scf_d_result *)d);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_no);
+
+int scf_d_result_dbg_get_xo(struct scf_d_result_dbg *d)
+{
+	return scf_d_result_get_xo((struct scf_d_result *)d);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_xo);
+
+u32 scf_d_result_dbg_get_flg(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_flg_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_flg);
+
+u32 scf_d_result_dbg_get_cm(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_cm_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_cm);
+
+u32 scf_d_result_dbg_get_id2(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_id2_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_id2);
+
+u32 scf_d_result_dbg_get_id1(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_id1_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_id1);
+
+u32 scf_d_result_dbg_get_mtime(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_mtime_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_mtime);
+
+u32 scf_d_result_dbg_get_xlen(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_xlen_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_xlen);
+
+u32 scf_d_result_dbg_get_os(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_os_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_os);
+
+u32 scf_d_result_dbg_get_xfl(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_xfl_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_xfl);
+
+u32 scf_d_result_dbg_get_clen(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_clen_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_clen);
+
+u32 scf_d_result_dbg_get_nlen(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_nlen_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_nlen);
+
+u32 scf_d_result_dbg_get_hclen(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_hclen, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_hclen);
+
+u32 scf_d_result_dbg_get_hdist(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_hdist, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_hdist);
+
+u32 scf_d_result_dbg_get_hlit(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_hlit, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_hlit);
+
+u32 scf_d_result_dbg_get_pending_working_idx(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_pending_working_idx, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_pending_working_idx);
+
+u32 scf_d_result_dbg_get_pending_working_len(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_pending_output_len_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_pending_working_len);
+
+u32 scf_d_result_dbg_get_num_code_len(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_num_code_len, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_num_code_len);
+
+u32 scf_d_result_dbg_get_frame_parse_state(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_frame_parse_state, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_frame_parse_state);
+
+u32 scf_d_result_dbg_get_decomp_total_out(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_decomp_total_out, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_decomp_total_out);
+
+u32 scf_d_result_dbg_get_header_remaining(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_header_remaining, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_header_remaining);
+
+u32 scf_d_result_dbg_get_btype(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_btype, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_btype);
+
+int scf_d_result_dbg_get_bfinal(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_bfinal, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_bfinal);
+
+int scf_d_result_dbg_get_mc(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_mc_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_mc);
+
+int scf_d_result_dbg_get_mcplt(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_mcplt, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_mcplt);
+
+u32 scf_d_result_dbg_get_huffman_rbc(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_huffman_rbc, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_huffman_rbc);
+
+int scf_d_result_dbg_get_terminated(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_terminated, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_terminated);
+
+int scf_d_result_dbg_get_suspended(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_suspended, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_suspended);
+
+int scf_d_result_dbg_get_pmode(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_pmode_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_pmode);
+
+u32 scf_d_result_dbg_get_crc16(struct scf_d_result_dbg *d)
+{
+	const u32 *cl = dce_cl2(d);
+
+	return dce_attr_code_decode(&code_crc16_dbg, cl);
+}
+EXPORT_SYMBOL(scf_d_result_dbg_get_crc16);
+
diff --git a/drivers/staging/fsl-dpaa2/dce/dce-scf-decompression.h b/drivers/staging/fsl-dpaa2/dce/dce-scf-decompression.h
new file mode 100644
index 0000000..b5adc24
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/dce/dce-scf-decompression.h
@@ -0,0 +1,262 @@
+/* Copyright (C) 2015 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __LDCE_SCF_DECOMPRESSION_H
+#define __LDCE_SCF_DECOMPRESSION_H
+
+#include "dce-private.h"
+
+struct scf_d_cfg {
+	u32 dont_manipulate_directly[32];
+};
+
+struct scf_d_result {
+	u32 dont_manipulate_directly[16];
+};
+
+struct scf_d_result_dbg {
+	u32 dont_manipulate_directly[32];
+};
+
+/*******************************************************************************
+ *
+ * scf_d_cfg APIS
+ *
+ ******************************************************************************/
+void scf_d_cfg_clear(struct scf_d_cfg *d);
+/* BP2 settings: buffer pool id, pool buffer size */
+void scf_d_cfg_set_bp2ac_bmt(struct scf_d_cfg *d, int enable);
+int scf_d_cfg_get_bp2ac_bmt(struct scf_d_cfg *d);
+void scf_d_cfg_set_bp2ac_bpid(struct scf_d_cfg *d, u32 bpid);
+u32 scf_d_cfg_get_bp2ac_bpid(struct scf_d_cfg *d);
+void scf_d_cfg_set_bp2ac_pbs(struct scf_d_cfg *d, u32 pbs);
+u32 scf_d_cfg_get_bp2ac_pbs(struct scf_d_cfg *d);
+
+/* BP1 settings: buffer pool id, pool buffer size */
+void scf_d_cfg_set_bp1ac_bmt(struct scf_d_cfg *d, int enable);
+int scf_d_cfg_get_bp1ac_bmt(struct scf_d_cfg *d);
+void scf_d_cfg_set_bp1ac_bpid(struct scf_d_cfg *d, u32 bpid);
+u32 scf_d_cfg_get_bp1ac_bpid(struct scf_d_cfg *d);
+void scf_d_cfg_set_bp1ac_pbs(struct scf_d_cfg *d, u32 pbs);
+u32 scf_d_cfg_get_bp1ac_pbs(struct scf_d_cfg *d);
+
+/* next_flc */
+void scf_d_cfg_set_next_flc(struct scf_d_cfg *d, uint64_t addr);
+uint64_t scf_d_cfg_get_next_flc(struct scf_d_cfg *d);
+
+/* extra limit */
+void scf_d_cfg_set_extra_limit(struct scf_d_cfg *d, u32 val);
+u32 scf_d_cfg_get_extra_limit(struct scf_d_cfg *d);
+
+/* extra ptr */
+void scf_d_cfg_set_extra_ptr(struct scf_d_cfg *d, uint64_t addr);
+uint64_t scf_d_cfg_get_extra_ptr(struct scf_d_cfg *d);
+
+/* pending output ptr */
+void scf_d_cfg_set_pending_output_ptr(struct scf_d_cfg *d, uint64_t addr);
+uint64_t scf_d_cfg_get_pending_output_ptr(struct scf_d_cfg *d);
+
+/* history ptr */
+void scf_d_cfg_set_history_ptr(struct scf_d_cfg *d, uint64_t addr);
+uint64_t scf_d_cfg_get_history_ptr(struct scf_d_cfg *d);
+
+/* decompression context ptr */
+void scf_d_cfg_set_decomp_ctx_ptr(struct scf_d_cfg *d, uint64_t addr);
+uint64_t scf_d_cfg_get_decomp_ctx_ptr(struct scf_d_cfg *d);
+
+/* total in */
+void scf_d_cfg_set_total_in(struct scf_d_cfg *d, u32 byte_cnt);
+u32 scf_d_cfg_get_total_in(struct scf_d_cfg *d);
+
+/* total out */
+void scf_d_cfg_set_total_out(struct scf_d_cfg *d, u32 byte_cnt);
+u32 scf_d_cfg_get_total_out(struct scf_d_cfg *d);
+
+/* adler32 */
+void scf_d_cfg_set_adler32(struct scf_d_cfg *d, u32 adler32);
+u32 scf_d_cfg_get_adler32(struct scf_d_cfg *d);
+
+void scf_d_cfg_set_member_continue(struct scf_d_cfg *d, int enable);
+int scf_d_cfg_get_member_continue(struct scf_d_cfg *d);
+void scf_d_cfg_set_pmode(struct scf_d_cfg *d, int mode);
+int scf_d_cfg_get_pmode(struct scf_d_cfg *d);
+
+/*******************************************************************************
+ *
+ * scf_d_result APIS
+ *
+ ******************************************************************************/
+void scf_d_result_clear(struct scf_d_result *d);
+/* total in */
+void scf_d_result_set_total_in(struct scf_d_result *d, u32 byte_cnt);
+u32 scf_d_result_get_total_in(struct scf_d_result *d);
+
+/* total out */
+void scf_d_result_set_total_out(struct scf_d_result *d, u32 byte_cnt);
+u32 scf_d_result_get_total_out(struct scf_d_result *d);
+
+/* adler32 */
+void scf_d_result_set_adler32(struct scf_d_result *d, u32 adler32);
+u32 scf_d_result_get_adler32(struct scf_d_result *d);
+
+void scf_d_result_set_bytes_processed(struct scf_d_result *d, u32 val);
+u32 scf_d_result_get_bytes_processed(struct scf_d_result *d);
+
+void scf_d_result_set_co(struct scf_d_result *d, int enable);
+int scf_d_result_get_co(struct scf_d_result *d);
+void scf_d_result_set_no(struct scf_d_result *d, int enable);
+int scf_d_result_get_no(struct scf_d_result *d);
+void scf_d_result_set_xo(struct scf_d_result *d, int enable);
+int scf_d_result_get_xo(struct scf_d_result *d);
+
+void scf_d_result_set_pending_output_len(struct scf_d_result *d, u32 val);
+u32 scf_d_result_get_pending_output_len(struct scf_d_result *d);
+void scf_d_result_set_extra_limit(struct scf_d_result *d, u32 val);
+u32 scf_d_result_get_extra_limit(struct scf_d_result *d);
+
+/* gzip,zlib header info */
+u32 scf_d_result_get_flg(struct scf_d_result *d);
+u32 scf_d_result_get_cm(struct scf_d_result *d);
+u32 scf_d_result_get_id2(struct scf_d_result *d);
+u32 scf_d_result_get_id1(struct scf_d_result *d);
+u32 scf_d_result_get_mtime(struct scf_d_result *d);
+u32 scf_d_result_get_xlen(struct scf_d_result *d);
+u32 scf_d_result_get_os(struct scf_d_result *d);
+u32 scf_d_result_get_xfl(struct scf_d_result *d);
+u32 scf_d_result_get_clen(struct scf_d_result *d);
+u32 scf_d_result_get_nlen(struct scf_d_result *d);
+u32 scf_d_result_get_crc16(struct scf_d_result *d);
+
+/*******************************************************************************
+ *
+ * scf_d_result_dbg APIS
+ *
+ ******************************************************************************/
+void scf_d_result_dbg_clear(struct scf_d_result_dbg *d);
+/* FFDPC */
+uint64_t scf_d_result_dbg_get_ffdpc(struct scf_d_result_dbg *d);
+/* BP2 settings */
+u32 scf_d_result_dbg_get_bp2ac(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_bp2ac_bmt(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_bp2ac_bpid(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_bp2ac_pbs(struct scf_d_result_dbg *d);
+/* BP1 settings */
+u32 scf_d_result_dbg_get_bp1ac(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_bp1ac_bmt(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_bp1ac_bpid(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_bp1ac_pbs(struct scf_d_result_dbg *d);
+
+/* next_flc */
+uint64_t scf_d_result_dbg_get_next_flc(struct scf_d_result_dbg *d);
+
+/* ncbb remaining */
+u32 scf_d_result_dbg_get_ncbb_remaining(struct scf_d_result_dbg *d);
+
+/* history_len */
+u32 scf_d_result_dbg_get_history_len(struct scf_d_result_dbg *d);
+
+/* extra limit */
+u32 scf_d_result_dbg_get_extra_limit(struct scf_d_result_dbg *d);
+
+/* extra ptr */
+uint64_t scf_d_result_dbg_get_extra_ptr(struct scf_d_result_dbg *d);
+
+/* pending output ptr */
+uint64_t scf_d_result_dbg_get_pending_output_ptr(struct scf_d_result_dbg *d);
+
+/* previous code len */
+u32 scf_d_result_dbg_get_previous_code_len(struct scf_d_result_dbg *d);
+
+/* history ptr */
+uint64_t scf_d_result_dbg_get_history_ptr(struct scf_d_result_dbg *d);
+
+/* decompression context ptr */
+uint64_t scf_d_result_dbg_get_decomp_ctx_ptr(struct scf_d_result_dbg *d);
+
+/* total in */
+u32 scf_d_result_dbg_get_total_in(struct scf_d_result_dbg *d);
+
+/* total out */
+u32 scf_d_result_dbg_get_total_out(struct scf_d_result_dbg *d);
+
+/* adler32 */
+u32 scf_d_result_dbg_get_adler32(struct scf_d_result_dbg *d);
+
+/* b64_residue */
+u32 scf_d_result_dbg_get_b64_residue(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_b64_residue_len(struct scf_d_result_dbg *d);
+
+/* output phase */
+u32 scf_d_result_dbg_get_output_phase(struct scf_d_result_dbg *d);
+
+int scf_d_result_dbg_get_co(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_no(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_xo(struct scf_d_result_dbg *d);
+
+/* gzip,zlib header info */
+u32 scf_d_result_dbg_get_flg(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_cm(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_id2(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_id1(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_mtime(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_xlen(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_os(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_xfl(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_clen(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_nlen(struct scf_d_result_dbg *d);
+
+u32 scf_d_result_dbg_get_hclen(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_hdist(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_hlit(struct scf_d_result_dbg *d);
+
+/* pending output data */
+u32 scf_d_result_dbg_get_pending_working_idx(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_pending_working_len(struct scf_d_result_dbg *d);
+
+u32 scf_d_result_dbg_get_num_code_len(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_frame_parse_state(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_decomp_total_out(struct scf_d_result_dbg *d);
+
+/* header remaining */
+u32 scf_d_result_dbg_get_header_remaining(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_btype(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_bfinal(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_mc(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_mcplt(struct scf_d_result_dbg *d);
+u32 scf_d_result_dbg_get_huffman_rbc(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_terminated(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_suspended(struct scf_d_result_dbg *d);
+int scf_d_result_dbg_get_pmode(struct scf_d_result_dbg *d);
+
+/* crc16 */
+u32 scf_d_result_dbg_get_crc16(struct scf_d_result_dbg *d);
+
+#endif
-- 
2.8.1

