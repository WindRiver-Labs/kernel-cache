From e82b55fd131d465899687d9ecaf9611d69d42396 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Thu, 16 Apr 2015 16:50:02 +0300
Subject: [PATCH 0808/1429] staging: fsl-dpaa2: mac: Added MAC / PHY interface
 driver.

This driver works as a proxy between phylib including phy drivers and
the MC firmware.  It receives updates on link state changes from PHY
lib and forwards them to MC and receives interrupt from MC whenever
a request is made to change the link state.

Signed-off-by: Alex Marginean <alexandru.marginean@freescale.com>
Change-Id: I8097ea69ea8effded3bddd43b9d326bbb59ba6c8
Reviewed-on: http://git.am.freescale.net:8181/35113
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 MAINTAINERS                               |    6 +
 drivers/staging/fsl-dpaa2/Kconfig         |    1 +
 drivers/staging/fsl-dpaa2/Makefile        |    1 +
 drivers/staging/fsl-dpaa2/mac/Kconfig     |   19 +-
 drivers/staging/fsl-dpaa2/mac/Makefile    |    4 +-
 drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h |  192 ++++++++
 drivers/staging/fsl-dpaa2/mac/dpmac.c     |    4 +-
 drivers/staging/fsl-dpaa2/mac/dpmac.h     |  528 +++++++++++++++++++++
 drivers/staging/fsl-dpaa2/mac/mac.c       |  731 +++++++++++++++++++++++++++++
 drivers/staging/fsl-dpaa2/mac/phy_proxy.c |  642 -------------------------
 10 files changed, 1472 insertions(+), 656 deletions(-)
 create mode 100644 drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h
 create mode 100644 drivers/staging/fsl-dpaa2/mac/dpmac.h
 create mode 100644 drivers/staging/fsl-dpaa2/mac/mac.c
 delete mode 100644 drivers/staging/fsl-dpaa2/mac/phy_proxy.c

diff --git a/MAINTAINERS b/MAINTAINERS
index f507ad8..c401c48 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -4248,6 +4248,12 @@ S:	Maintained
 F:	drivers/staging/fsl-mc/bus/mc-ioctl.h
 F:	drivers/staging/fsl-mc/bus/mc-restool.c
 
+FREESCALE DPAA2 MAC/PHY INTERFACE DRIVER
+M:	Alex Marginean <Alexandru.Marginean@freescale.com>
+L:	linux-kernel@vger.kernel.org
+S:	Maintained
+F:	drivers/staging/fsl-dpaa2/mac/
+
 FREEVXFS FILESYSTEM
 M:	Christoph Hellwig <hch@infradead.org>
 W:	ftp://ftp.openlinux.org/pub/people/hch/vxfs
diff --git a/drivers/staging/fsl-dpaa2/Kconfig b/drivers/staging/fsl-dpaa2/Kconfig
index 24dc933..3fe47bc 100644
--- a/drivers/staging/fsl-dpaa2/Kconfig
+++ b/drivers/staging/fsl-dpaa2/Kconfig
@@ -9,3 +9,4 @@ config FSL_DPAA2
 	  Build drivers for Freescale DataPath Acceleration Architecture (DPAA2) family of SoCs.
 # TODO move DPIO driver in-here?
 source "drivers/staging/fsl-dpaa2/ethernet/Kconfig"
+source "drivers/staging/fsl-dpaa2/mac/Kconfig"
diff --git a/drivers/staging/fsl-dpaa2/Makefile b/drivers/staging/fsl-dpaa2/Makefile
index dab1c21..bc687a1 100644
--- a/drivers/staging/fsl-dpaa2/Makefile
+++ b/drivers/staging/fsl-dpaa2/Makefile
@@ -3,3 +3,4 @@
 #
 
 obj-$(CONFIG_FSL_DPAA2_ETH)	+= ethernet/
+obj-$(CONFIG_FSL_DPAA2_MAC)	+= mac/
diff --git a/drivers/staging/fsl-dpaa2/mac/Kconfig b/drivers/staging/fsl-dpaa2/mac/Kconfig
index 1a2a439..af7d83e 100644
--- a/drivers/staging/fsl-dpaa2/mac/Kconfig
+++ b/drivers/staging/fsl-dpaa2/mac/Kconfig
@@ -1,30 +1,29 @@
-config FSL_DPAA2_PHY_PROXY
-	tristate "DPAA2 PHY proxy interface"
-	depends on FSL_MC_BUS
-	depends on FSL_LDPAA_ETH
+config FSL_DPAA2_MAC
+	tristate "DPAA2 MAC / PHY interface"
+	depends on FSL_MC_BUS && FSL_DPAA2
 	select FSL_DPAA2_FIXED_PHY_HACK
 	---help---
-	Prototype driver for DPAA2 PHY interface object.
+	Prototype driver for DPAA2 MAC / PHY interface object.
 	This driver works as a proxy between phylib including phy drivers and
 	the MC firmware.  It receives updates on link state changes from PHY
 	lib and forwards them to MC and receives interrupt from MC whenever
 	a request is made to change the link state.
 
 
-config FSL_DPAA2_PPX_NETDEVS
+config FSL_DPAA2_MAC_NETDEVS
 	bool "Expose net interfaces for PHYs"
 	default n
-	depends on FSL_DPAA2_PHY_PROXY
+	depends on FSL_DPAA2_MAC
 	---help---
-	Exposes phyX net interfaces which allow direct control over the PHYs.
-	.
+	Exposes macX net interfaces which allow direct control over MACs and
+	PHYs.
 	.
 	Leave disabled if unsure.
 
 config FSL_DPAA2_FIXED_PHY_HACK
 	bool "Hack for fixed links, to remove in v3.18"
 	default y
-	depends on FSL_DPAA2_PHY_PROXY
+	depends on FSL_DPAA2_MAC
 	---help---
 	Temporary hack to allow registration of a fixed PHY without a device
 	tree node and actual fixed-link property or child node.
diff --git a/drivers/staging/fsl-dpaa2/mac/Makefile b/drivers/staging/fsl-dpaa2/mac/Makefile
index 47282de..271ce0c 100644
--- a/drivers/staging/fsl-dpaa2/mac/Makefile
+++ b/drivers/staging/fsl-dpaa2/mac/Makefile
@@ -1,8 +1,8 @@
 
 obj-$(CONFIG_FSL_DPAA2_FIXED_PHY_HACK) += fixed.o
-obj-$(CONFIG_FSL_DPAA2_PHY_PROXY) += dpaa2_ppx.o
+obj-$(CONFIG_FSL_DPAA2_MAC) += dpaa2-mac.o
 
-dpaa2_ppx-objs := phy_proxy.o dpmac.o
+dpaa2-mac-objs := mac.o dpmac.o
 
 all:
 	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h b/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h
new file mode 100644
index 0000000..f5527bf
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac-cmd.h
@@ -0,0 +1,192 @@
+/* Copyright 2013-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _FSL_DPMAC_CMD_H
+#define _FSL_DPMAC_CMD_H
+
+/* DPMAC Version */
+#define DPMAC_VER_MAJOR				3
+#define DPMAC_VER_MINOR				0
+
+/* Command IDs */
+#define DPMAC_CMDID_CLOSE			0x800
+#define DPMAC_CMDID_OPEN			0x80c
+#define DPMAC_CMDID_CREATE			0x90c
+#define DPMAC_CMDID_DESTROY			0x900
+
+#define DPMAC_CMDID_GET_ATTR			0x004
+#define DPMAC_CMDID_RESET			0x005
+
+#define DPMAC_CMDID_SET_IRQ			0x010
+#define DPMAC_CMDID_GET_IRQ			0x011
+#define DPMAC_CMDID_SET_IRQ_ENABLE		0x012
+#define DPMAC_CMDID_GET_IRQ_ENABLE		0x013
+#define DPMAC_CMDID_SET_IRQ_MASK		0x014
+#define DPMAC_CMDID_GET_IRQ_MASK		0x015
+#define DPMAC_CMDID_GET_IRQ_STATUS		0x016
+#define DPMAC_CMDID_CLEAR_IRQ_STATUS		0x017
+
+#define DPMAC_CMDID_MDIO_READ			0x0c0
+#define DPMAC_CMDID_MDIO_WRITE			0x0c1
+#define DPMAC_CMDID_GET_LINK_CFG		0x0c2
+#define DPMAC_CMDID_SET_LINK_STATE		0x0c3
+#define DPMAC_CMDID_GET_COUNTER			0x0c4
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_CREATE(cmd, cfg) \
+	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->mac_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_OPEN(cmd, dpmac_id) \
+	MC_CMD_OP(cmd, 0, 0,  32, int,	    dpmac_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_SET_IRQ(cmd, irq_index, irq_addr, irq_val, user_irq_id) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  irq_index);\
+	MC_CMD_OP(cmd, 0, 32, 32, uint32_t, irq_val);\
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_IRQ(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_IRQ(cmd, type, irq_addr, irq_val, user_irq_id) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_val); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_addr); \
+	MC_RSP_OP(cmd, 2, 0,  32, int,	    user_irq_id); \
+	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_SET_IRQ_ENABLE(cmd, irq_index, en) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  en); \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_IRQ_ENABLE(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_IRQ_ENABLE(cmd, en) \
+	MC_RSP_OP(cmd, 0, 0,  8,  uint8_t,  en)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_SET_IRQ_MASK(cmd, irq_index, mask) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, mask);\
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_IRQ_MASK(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_IRQ_MASK(cmd, mask) \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, mask)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_IRQ_STATUS(cmd, irq_index) \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_IRQ_STATUS(cmd, status) \
+	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, status)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_CLEAR_IRQ_STATUS(cmd, irq_index, status) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, status); \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index);\
+} while (0)
+
+/*                cmd, param, offset, width, type,	arg_name */
+#define DPMAC_RSP_GET_ATTRIBUTES(cmd, attr) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  32, int,			attr->phy_id);\
+	MC_RSP_OP(cmd, 0, 32, 32, int,			attr->id);\
+	MC_RSP_OP(cmd, 1, 0,  16, uint16_t,		attr->version.major);\
+	MC_RSP_OP(cmd, 1, 16, 16, uint16_t,		attr->version.minor);\
+	MC_RSP_OP(cmd, 1, 32,  8, enum dpmac_link_type,	attr->link_type);\
+	MC_RSP_OP(cmd, 1, 40,  8, enum dpmac_eth_if,	attr->eth_if);\
+	MC_RSP_OP(cmd, 2, 0,  32, uint32_t,		attr->max_rate);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_MDIO_READ(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->phy_addr); \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  cfg->reg); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_MDIO_READ(cmd, data) \
+	MC_RSP_OP(cmd, 0, 16, 16, uint16_t, data)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_MDIO_WRITE(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->phy_addr); \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  cfg->reg); \
+	MC_CMD_OP(cmd, 0, 16, 16, uint16_t, cfg->data); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_LINK_CFG(cmd, cfg) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  64, uint64_t, cfg->options); \
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, cfg->rate); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_SET_LINK_STATE(cmd, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  64, uint64_t, cfg->options); \
+	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->rate); \
+	MC_CMD_OP(cmd, 2, 0,  1,  int,      cfg->up); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_CMD_GET_COUNTER(cmd, type) \
+	MC_CMD_OP(cmd, 0, 0,  8, enum dpmac_counter, type) \
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPMAC_RSP_GET_COUNTER(cmd, counter) \
+	MC_RSP_OP(cmd, 1, 0, 64, uint64_t, counter)
+
+#endif /* _FSL_DPMAC_CMD_H */
diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac.c b/drivers/staging/fsl-dpaa2/mac/dpmac.c
index a8cdf99..ad1e147 100644
--- a/drivers/staging/fsl-dpaa2/mac/dpmac.c
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac.c
@@ -31,8 +31,8 @@
  */
 #include "../../fsl-mc/include/mc-sys.h"
 #include "../../fsl-mc/include/mc-cmd.h"
-#include "../../fsl-mc/include/dpmac.h"
-#include "../../fsl-mc/include/dpmac-cmd.h"
+#include "dpmac.h"
+#include "dpmac-cmd.h"
 
 int dpmac_open(struct fsl_mc_io *mc_io, int dpmac_id, uint16_t *token)
 {
diff --git a/drivers/staging/fsl-dpaa2/mac/dpmac.h b/drivers/staging/fsl-dpaa2/mac/dpmac.h
new file mode 100644
index 0000000..88091b5
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/mac/dpmac.h
@@ -0,0 +1,528 @@
+/* Copyright 2013-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ * * Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * * Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ * * Neither the name of the above-listed copyright holders nor the
+ * names of any contributors may be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __FSL_DPMAC_H
+#define __FSL_DPMAC_H
+
+/* Data Path MAC API
+ * Contains initialization APIs and runtime control APIs for DPMAC
+ */
+
+struct fsl_mc_io;
+
+/**
+ * dpmac_open() - Open a control session for the specified object.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @dpmac_id:	DPMAC unique ID
+ * @token:	Returned token; use in subsequent API calls
+ *
+ * This function can be used to open a control session for an
+ * already created object; an object may have been declared in
+ * the DPL or by calling the dpmac_create function.
+ * This function returns a unique authentication token,
+ * associated with the specific object ID and the specific MC
+ * portal; this token must be used in all subsequent commands for
+ * this specific object
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_open(struct fsl_mc_io *mc_io, int dpmac_id, uint16_t *token);
+
+/**
+ * dpmac_close() - Close the control session of the object
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ *
+ * After this function is called, no further operations are
+ * allowed on the object without opening a new control session.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_close(struct fsl_mc_io *mc_io, uint16_t token);
+
+/**
+ * enum dpmac_link_type -  DPMAC link type
+ * @DPMAC_LINK_TYPE_NONE: No link
+ * @DPMAC_LINK_TYPE_FIXED: Link is fixed type
+ * @DPMAC_LINK_TYPE_PHY: Link by PHY ID
+ * @DPMAC_LINK_TYPE_BACKPLANE: Backplane link type
+ */
+enum dpmac_link_type {
+	DPMAC_LINK_TYPE_NONE,
+	DPMAC_LINK_TYPE_FIXED,
+	DPMAC_LINK_TYPE_PHY,
+	DPMAC_LINK_TYPE_BACKPLANE
+};
+
+/**
+ * enum dpmac_eth_if - DPMAC Ethrnet interface
+ * @DPMAC_ETH_IF_MII: MII interface
+ * @DPMAC_ETH_IF_RMII: RMII interface
+ * @DPMAC_ETH_IF_SMII: SMII interface
+ * @DPMAC_ETH_IF_GMII: GMII interface
+ * @DPMAC_ETH_IF_RGMII: RGMII interface
+ * @DPMAC_ETH_IF_SGMII: SGMII interface
+ * @DPMAC_ETH_IF_XGMII: XGMII interface
+ * @DPMAC_ETH_IF_QSGMII: QSGMII interface
+ * @DPMAC_ETH_IF_XAUI: XAUI interface
+ * @DPMAC_ETH_IF_XFI: XFI interface
+ */
+enum dpmac_eth_if {
+	DPMAC_ETH_IF_MII,
+	DPMAC_ETH_IF_RMII,
+	DPMAC_ETH_IF_SMII,
+	DPMAC_ETH_IF_GMII,
+	DPMAC_ETH_IF_RGMII,
+	DPMAC_ETH_IF_SGMII,
+	DPMAC_ETH_IF_XGMII,
+	DPMAC_ETH_IF_QSGMII,
+	DPMAC_ETH_IF_XAUI,
+	DPMAC_ETH_IF_XFI
+};
+
+/**
+ * struct dpmac_cfg() - Structure representing DPMAC configuration
+ * @mac_id:	Represents the Hardware MAC ID; in case of multiple WRIOP,
+ *		the MAC IDs are continuous.
+ *		For example:  2 WRIOPs, 16 MACs in each:
+ *				MAC IDs for the 1st WRIOP: 1-16,
+ *				MAC IDs for the 2nd WRIOP: 17-32.
+ */
+struct dpmac_cfg {
+	int mac_id;
+};
+
+/**
+ * dpmac_create() - Create the DPMAC object.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cfg:	Configuration structure
+ * @token:	Returned token; use in subsequent API calls
+ *
+ * Create the DPMAC object, allocate required resources and
+ * perform required initialization.
+ *
+ * The object can be created either by declaring it in the
+ * DPL file, or by calling this function.
+ * This function returns a unique authentication token,
+ * associated with the specific object ID and the specific MC
+ * portal; this token must be used in all subsequent calls to
+ * this specific object. For objects that are created using the
+ * DPL file, call dpmac_open function to get an authentication
+ * token first.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_create(struct fsl_mc_io	*mc_io,
+		 const struct dpmac_cfg	*cfg,
+		uint16_t		*token);
+
+/**
+ * dpmac_destroy() - Destroy the DPMAC object and release all its resources.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpmac_destroy(struct fsl_mc_io *mc_io, uint16_t token);
+
+/* DPMAC IRQ Index and Events */
+
+/* IRQ index */
+#define DPMAC_IRQ_INDEX						0
+/* IRQ event - indicates a change in link state */
+#define DPMAC_IRQ_EVENT_LINK_CFG_REQ		0x00000001
+/* irq event - Indicates that the link state changed */
+#define DPMAC_IRQ_EVENT_LINK_CHANGED		0x00000002
+
+/**
+ * dpmac_set_irq() - Set IRQ information for the DPMAC to trigger an interrupt.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	Identifies the interrupt index to configure
+ * @irq_addr:	Address that must be written to
+ *				signal a message-based interrupt
+ * @irq_val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_set_irq(struct fsl_mc_io	*mc_io,
+		  uint16_t		token,
+		 uint8_t		irq_index,
+		 uint64_t		irq_addr,
+		 uint32_t		irq_val,
+		 int			user_irq_id);
+
+/**
+ * dpmac_get_irq() - Get IRQ information from the DPMAC.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @type:	Interrupt type: 0 represents message interrupt
+ *				type (both irq_addr and irq_val are valid)
+ * @irq_addr:	Returned address that must be written to
+ *				signal the message-based interrupt
+ * @irq_val:	Value to write into irq_addr address
+ * @user_irq_id: A user defined number associated with this IRQ
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_irq(struct fsl_mc_io	*mc_io,
+		  uint16_t		token,
+		 uint8_t		irq_index,
+		 int			*type,
+		 uint64_t		*irq_addr,
+		 uint32_t		*irq_val,
+		 int			*user_irq_id);
+
+/**
+ * dpmac_set_irq_enable() - Set overall interrupt state.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @en:	Interrupt state - enable = 1, disable = 0
+ *
+ * Allows GPP software to control when interrupts are generated.
+ * Each interrupt can have up to 32 causes.  The enable/disable control's the
+ * overall interrupt state. if the interrupt is disabled no causes will cause
+ * an interrupt.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_set_irq_enable(struct fsl_mc_io	*mc_io,
+			 uint16_t		token,
+			uint8_t			irq_index,
+			uint8_t			en);
+
+/**
+ * dpmac_get_irq_enable() - Get overall interrupt state
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @en:		Returned interrupt state - enable = 1, disable = 0
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_irq_enable(struct fsl_mc_io	*mc_io,
+			 uint16_t		token,
+			uint8_t			irq_index,
+			uint8_t			*en);
+
+/**
+ * dpmac_set_irq_mask() - Set interrupt mask.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @mask:	Event mask to trigger interrupt;
+ *			each bit:
+ *				0 = ignore event
+ *				1 = consider event for asserting IRQ
+ *
+ * Every interrupt can have up to 32 causes and the interrupt model supports
+ * masking/unmasking each cause independently
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_set_irq_mask(struct fsl_mc_io	*mc_io,
+		       uint16_t		token,
+		      uint8_t		irq_index,
+		      uint32_t		mask);
+
+/**
+ * dpmac_get_irq_mask() - Get interrupt mask.
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @mask:	Returned event mask to trigger interrupt
+ *
+ * Every interrupt can have up to 32 causes and the interrupt model supports
+ * masking/unmasking each cause independently
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_irq_mask(struct fsl_mc_io	*mc_io,
+		       uint16_t		token,
+		      uint8_t		irq_index,
+		      uint32_t		*mask);
+
+/**
+ * dpmac_get_irq_status() - Get the current status of any pending interrupts.
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @status:	Returned interrupts status - one bit per cause:
+ *			0 = no interrupt pending
+ *			1 = interrupt pending
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_irq_status(struct fsl_mc_io	*mc_io,
+			 uint16_t		token,
+			uint8_t			irq_index,
+			uint32_t		*status);
+
+/**
+ * dpmac_clear_irq_status() - Clear a pending interrupt's status
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @irq_index:	The interrupt index to configure
+ * @status:	Bits to clear (W1C) - one bit per cause:
+ *					0 = don't change
+ *					1 = clear status bit
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_clear_irq_status(struct fsl_mc_io	*mc_io,
+			   uint16_t		token,
+			  uint8_t		irq_index,
+			  uint32_t		status);
+
+/**
+ * struct dpmac_attr - Structure representing DPMAC attributes
+ * @id:		DPMAC object ID
+ * @phy_id:	PHY ID
+ * @link_type: link type
+ * @eth_if: Ethernet interface
+ * @max_rate: Maximum supported rate - in Mbps
+ * @version:	DPMAC version
+ */
+struct dpmac_attr {
+	int id;
+	int phy_id;
+	enum dpmac_link_type link_type;
+	enum dpmac_eth_if eth_if;
+	uint32_t max_rate;
+	/**
+	 * struct version - Structure representing DPMAC version
+	 * @major:	DPMAC major version
+	 * @minor:	DPMAC minor version
+	 */
+	struct {
+		uint16_t major;
+		uint16_t minor;
+	} version;
+};
+
+/**
+ * dpmac_get_attributes - Retrieve DPMAC attributes.
+ *
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @token:	Token of DPMAC object
+ * @attr:	Returned object's attributes
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_attributes(struct fsl_mc_io	*mc_io,
+			 uint16_t		token,
+			struct dpmac_attr	*attr);
+
+/**
+ * struct dpmac_mdio_cfg - DPMAC MDIO read/write parameters
+ * @phy_addr: MDIO device address
+ * @reg: Address of the register within the Clause 45 PHY device from which data
+ *	is to be read
+ * @data: Data read/write from/to MDIO
+ */
+struct dpmac_mdio_cfg {
+	uint8_t	phy_addr;
+	uint8_t	 reg;
+	uint16_t data;
+};
+
+/**
+ * dpmac_mdio_read() - Perform MDIO read transaction
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @cfg:	Structure with MDIO transaction parameters
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_mdio_read(struct fsl_mc_io *mc_io, uint16_t token,
+		    struct dpmac_mdio_cfg *cfg);
+
+
+/**
+ * dpmac_mdio_write() - Perform MDIO write transaction
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @cfg:	Structure with MDIO transaction parameters
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_mdio_write(struct fsl_mc_io *mc_io, uint16_t token,
+		     struct dpmac_mdio_cfg *cfg);
+
+/* DPMAC link configuration/state options */
+
+/* Enable auto-negotiation */
+#define DPMAC_LINK_OPT_AUTONEG		0x0000000000000001ULL
+/* Enable half-duplex mode */
+#define DPMAC_LINK_OPT_HALF_DUPLEX	0x0000000000000002ULL
+/* Enable pause frames */
+#define DPMAC_LINK_OPT_PAUSE		0x0000000000000004ULL
+/* Enable a-symmetric pause frames */
+#define DPMAC_LINK_OPT_ASYM_PAUSE	0x0000000000000008ULL
+
+/**
+ * struct dpmac_link_cfg - Structure representing DPMAC link configuration
+ * @rate: Link's rate - in Mbps
+ * @options: Enable/Disable DPMAC link cfg features (bitmap)
+ */
+struct dpmac_link_cfg {
+	uint32_t rate;
+	uint64_t options;
+};
+
+/**
+ * dpmac_get_link_cfg() - Get Ethernet link configuration
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @cfg:	Returned structure with the link configuration
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_get_link_cfg(struct fsl_mc_io *mc_io, uint16_t token,
+		       struct dpmac_link_cfg *cfg);
+
+/**
+ * struct dpmac_link_state - DPMAC link configuration request
+ * @rate: Rate in Mbps
+ * @options: Enable/Disable DPMAC link cfg features (bitmap)
+ * @up: Link state
+ */
+struct dpmac_link_state {
+	uint32_t rate;
+	uint64_t options;
+	int up;
+};
+
+/**
+ * dpmac_set_link_state() - Set the Ethernet link status
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @link_state:	Link state configuration
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpmac_set_link_state(struct fsl_mc_io *mc_io, uint16_t token,
+			 struct dpmac_link_state *link_state);
+
+/**
+ * enum dpni_counter - DPNI counter types
+ * @DPMAC_CNT_ING_FRAME_64: counts 64-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_127: counts 65- to 127-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_255: counts 128- to 255-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_511: counts 256- to 511-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_1023: counts 512- to 1023-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_1518: counts 1024- to 1518-octet frame, good or bad.
+ * @DPMAC_CNT_ING_FRAME_1519_MAX: counts 1519-octet frame and larger
+ *				  (up to max frame length specified),
+ *				  good or bad.
+ * @DPMAC_CNT_ING_FRAG: counts packet which is shorter than 64 octets received
+ *			with a wrong CRC
+ * @DPMAC_CNT_ING_JABBER: counts packet longer than the maximum frame length
+ *			  specified, with a bad frame check sequence.
+ * @DPMAC_CNT_ING_FRAME_DISCARD: counts dropped packet due to internal errors.
+ *				 Occurs when a receive FIFO overflows.
+ *				 Includes also packets truncated as a result of
+ *				 the receive FIFO overflow.
+ * @DPMAC_CNT_ING_ALIGN_ERR: counts frame with an alignment error
+ *			     (optional used for wrong SFD)
+ * @DPMAC_CNT_EGR_UNDERSIZED: counts packet transmitted that was less than 64
+ *			      octets long with a good CRC.
+ * @DPMAC_CNT_ING_OVERSIZED: counts packet longer than the maximum frame length
+ *			     specified, with a good frame check sequence.
+ * @DPMAC_CNT_ING_VALID_PAUSE_FRAME: counts valid pause frame (regular and PFC).
+ * @DPMAC_CNT_EGR_VALID_PAUSE_FRAME: counts valid pause frame transmitted
+ *				     (regular and PFC).
+ * @DPMAC_CNT_ING_BYTE: counts octet received except preamble for all valid
+			frames and valid pause frames.
+ * @DPMAC_CNT_ING_MCAST_FRAME: counts received multicast frame
+ * @DPMAC_CNT_ING_BCAST_FRAME: counts received broadcast frame
+ * @DPMAC_CNT_ING_ALL_FRAME: counts each good or bad packet received.
+ * @DPMAC_CNT_ING_UCAST_FRAME: counts received unicast frame
+ * @DPMAC_CNT_ING_ERR_FRAME: counts frame received with an error
+ *			     (except for undersized/fragment frame)
+ * @DPMAC_CNT_EGR_BYTE: counts octet transmitted except preamble for all valid
+ *			frames and valid pause frames transmitted.
+ * @DPMAC_CNT_EGR_MCAST_FRAME: counts transmitted multicast frame
+ * @DPMAC_CNT_EGR_BCAST_FRAME: counts transmitted broadcast frame
+ * @DPMAC_CNT_EGR_UCAST_FRAME: counts transmitted unicast frame
+ * @DPMAC_CNT_EGR_ERR_FRAME: counts frame transmitted with an error
+ * @DPMAC_CNT_ING_GOOD_FRAME: counts frame received without error, including
+ *			      pause frames.
+ */
+enum dpmac_counter {
+	DPMAC_CNT_ING_FRAME_64,
+	DPMAC_CNT_ING_FRAME_127,
+	DPMAC_CNT_ING_FRAME_255,
+	DPMAC_CNT_ING_FRAME_511,
+	DPMAC_CNT_ING_FRAME_1023,
+	DPMAC_CNT_ING_FRAME_1518,
+	DPMAC_CNT_ING_FRAME_1519_MAX,
+	DPMAC_CNT_ING_FRAG,
+	DPMAC_CNT_ING_JABBER,
+	DPMAC_CNT_ING_FRAME_DISCARD,
+	DPMAC_CNT_ING_ALIGN_ERR,
+	DPMAC_CNT_EGR_UNDERSIZED,
+	DPMAC_CNT_ING_OVERSIZED,
+	DPMAC_CNT_ING_VALID_PAUSE_FRAME,
+	DPMAC_CNT_EGR_VALID_PAUSE_FRAME,
+	DPMAC_CNT_ING_BYTE,
+	DPMAC_CNT_ING_MCAST_FRAME,
+	DPMAC_CNT_ING_BCAST_FRAME,
+	DPMAC_CNT_ING_ALL_FRAME,
+	DPMAC_CNT_ING_UCAST_FRAME,
+	DPMAC_CNT_ING_ERR_FRAME,
+	DPMAC_CNT_EGR_BYTE,
+	DPMAC_CNT_EGR_MCAST_FRAME,
+	DPMAC_CNT_EGR_BCAST_FRAME,
+	DPMAC_CNT_EGR_UCAST_FRAME,
+	DPMAC_CNT_EGR_ERR_FRAME,
+	DPMAC_CNT_ING_GOOD_FRAME
+};
+
+/**
+ * dpmac_get_counter() - Read a specific DPMAC counter
+ * @mc_io:	Pointer to opaque I/O object
+ * @token:	Token of DPMAC object
+ * @type:	The requested counter
+ * @counter:	Returned counter value
+ *
+ * Return:	The requested counter; '0' otherwise.
+ */
+int dpmac_get_counter(struct fsl_mc_io *mc_io, uint16_t token,
+		      enum dpmac_counter type,
+			   uint64_t *counter);
+
+#endif /* __FSL_DPMAC_H */
diff --git a/drivers/staging/fsl-dpaa2/mac/mac.c b/drivers/staging/fsl-dpaa2/mac/mac.c
new file mode 100644
index 0000000..559842a
--- /dev/null
+++ b/drivers/staging/fsl-dpaa2/mac/mac.c
@@ -0,0 +1,731 @@
+/* Copyright 2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *	 notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *	 notice, this list of conditions and the following disclaimer in the
+ *	 documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *	 names of its contributors may be used to endorse or promote products
+ *	 derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/module.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <linux/if_vlan.h>
+
+#include <uapi/linux/if_bridge.h>
+#include <net/netlink.h>
+
+#include <linux/of.h>
+#include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/phy.h>
+#include <linux/phy_fixed.h>
+
+#include "../../fsl-mc/include/mc.h"
+#include "../../fsl-mc/include/mc-sys.h"
+
+#include "dpmac.h"
+#include "dpmac-cmd.h"
+
+
+/* use different err functions if the driver registers phyX netdevs */
+#ifdef FSL_DPAA2_MAC_NETDEVS
+#define ppx_err(netdev, ...)  netdev_err(netdev, __VA_ARGS__)
+#define ppx_warn(netdev, ...) netdev_err(netdev, __VA_ARGS__)
+#define ppx_info(netdev, ...) netdev_err(netdev, __VA_ARGS__)
+#else /* FSL_DPAA2_MAC_NETDEVS */
+#define ppx_err(netdev, ...)  dev_err(&netdev->dev, __VA_ARGS__)
+#define ppx_warn(netdev, ...) dev_err(&netdev->dev, __VA_ARGS__)
+#define ppx_info(netdev, ...) dev_err(&netdev->dev, __VA_ARGS__)
+#endif /* FSL_DPAA2_MAC_NETDEVS */
+
+struct phy_device *fixed_phy_register2(unsigned int irq,
+				       struct fixed_phy_status *status,
+				       struct device_node *np);
+
+
+struct ppx_priv {
+	struct net_device		*netdev;
+	struct fsl_mc_device		*mc_dev;
+	struct dpmac_attr		attr;
+#ifdef PPX_DEBUG
+	struct dpmac_link_state		old_state;
+#endif /* PPX_DEBUG */
+};
+
+/* TODO: fix the 10G modes, mapping can't be right:
+ *  XGMII is paralel
+ *  XAUI is serial, using 8b/10b encoding
+ *  XFI is also serial but using 64b/66b encoding
+ * they can't all map to XGMII...
+ */
+static phy_interface_t ppx_eth_iface_mode[] __maybe_unused =  {
+	/* DPMAC_ETH_IF_MII */
+	PHY_INTERFACE_MODE_MII,
+	/* DPMAC_ETH_IF_RMII */
+	PHY_INTERFACE_MODE_RMII,
+	/* DPMAC_ETH_IF_SMII */
+	PHY_INTERFACE_MODE_SMII,
+	/* DPMAC_ETH_IF_GMII */
+	PHY_INTERFACE_MODE_GMII,
+	/* DPMAC_ETH_IF_RGMII */
+	PHY_INTERFACE_MODE_RGMII,
+	/* DPMAC_ETH_IF_SGMII */
+	PHY_INTERFACE_MODE_SGMII,
+	/* DPMAC_ETH_IF_XGMII */
+	PHY_INTERFACE_MODE_XGMII,
+	/* DPMAC_ETH_IF_QSGMII */
+	PHY_INTERFACE_MODE_QSGMII,
+	/* DPMAC_ETH_IF_XAUI */
+	PHY_INTERFACE_MODE_XGMII,
+	/* DPMAC_ETH_IF_XFI */
+	PHY_INTERFACE_MODE_XGMII,
+
+};
+
+static void ppx_link_changed(struct net_device *netdev);
+
+#ifdef FSL_DPAA2_MAC_NETDEVS
+static netdev_tx_t ppx_dropframe(struct sk_buff *skb, struct net_device *dev);
+static int ppx_open(struct net_device *netdev);
+static int ppx_stop(struct net_device *netdev);
+static struct rtnl_link_stats64 *ppx_get_stats(struct net_device *,
+					       struct rtnl_link_stats64 *);
+
+static int ppx_ethtool_get_settings(struct net_device *, struct ethtool_cmd *);
+static int ppx_ethtool_set_settings(struct net_device *, struct ethtool_cmd *);
+static int ppx_ethtool_get_sset_count(struct net_device *dev, int sset);
+static void ppx_ethtool_get_strings(struct net_device *, u32 stringset, u8 *);
+static void ppx_ethtool_get_stats(struct net_device *, struct ethtool_stats *,
+				  u64 *);
+
+static const struct net_device_ops ppx_ndo = {
+	.ndo_start_xmit		= &ppx_dropframe,
+	/* TODO: temporary to force fixed links up and down */
+	.ndo_open		= &ppx_open,
+	.ndo_stop		= &ppx_stop,
+	.ndo_get_stats64	= &ppx_get_stats,
+};
+
+static const struct ethtool_ops ppx_ethtool_ops = {
+	.get_settings		= &ppx_ethtool_get_settings,
+	.set_settings		= &ppx_ethtool_set_settings,
+	.get_strings		= &ppx_ethtool_get_strings,
+	.get_ethtool_stats	= &ppx_ethtool_get_stats,
+	.get_sset_count		= &ppx_ethtool_get_sset_count,
+};
+
+static netdev_tx_t ppx_dropframe(struct sk_buff *skb, struct net_device *dev)
+{
+	/* we don't support I/O for now, drop the frame */
+	dev_kfree_skb_any(skb);
+	return NETDEV_TX_OK;
+}
+
+static int ppx_open(struct net_device *netdev)
+{
+	/* start PHY state machine */
+	phy_start(netdev->phydev);
+
+	return 0;
+}
+
+static int ppx_stop(struct net_device *netdev)
+{
+	/* stop PHY state machine */
+	phy_stop(netdev->phydev);
+
+	/* signal link down to firmware */
+	netdev->phydev->link = 0;
+	ppx_link_changed(netdev);
+
+	return 0;
+}
+
+static int ppx_ethtool_get_settings(struct net_device *netdev,
+				    struct ethtool_cmd *cmd)
+{
+	return phy_ethtool_gset(netdev->phydev, cmd);
+}
+
+static int ppx_ethtool_set_settings(struct net_device *netdev,
+				    struct ethtool_cmd *cmd)
+{
+	return phy_ethtool_sset(netdev->phydev, cmd);
+}
+
+static struct rtnl_link_stats64
+*ppx_get_stats(struct net_device *netdev, struct rtnl_link_stats64 *storage)
+{
+	struct ppx_priv		*priv = netdev_priv(netdev);
+	u64			tmp;
+	int			err;
+
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_MCAST_FRAME,
+				&storage->tx_packets);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_BCAST_FRAME, &tmp);
+	if (err)
+		goto error;
+	storage->tx_packets += tmp;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_UCAST_FRAME, &tmp);
+	if (err)
+		goto error;
+	storage->tx_packets += tmp;
+
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_UNDERSIZED, &storage->tx_dropped);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_BYTE, &storage->tx_bytes);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_EGR_ERR_FRAME, &storage->tx_errors);
+	if (err)
+		goto error;
+
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_ALL_FRAME, &storage->rx_packets);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_MCAST_FRAME, &storage->multicast);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_FRAME_DISCARD,
+				&storage->rx_dropped);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_ALIGN_ERR, &storage->rx_errors);
+	if (err)
+		goto error;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_OVERSIZED, &tmp);
+	if (err)
+		goto error;
+	storage->rx_errors += tmp;
+	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
+				DPMAC_CNT_ING_BYTE, &storage->rx_bytes);
+	if (err)
+		goto error;
+
+	return storage;
+
+error:
+	ppx_err(netdev, "dpmac_get_counter err %d\n", err);
+	return storage;
+}
+
+static struct {
+	enum dpmac_counter id;
+	char name[ETH_GSTRING_LEN];
+} ppx_ethtool_counters[] =  {
+	{DPMAC_CNT_ING_ALL_FRAME,		"rx all frames"},
+	{DPMAC_CNT_ING_GOOD_FRAME,		"rx frames ok"},
+	{DPMAC_CNT_ING_ERR_FRAME,		"rx frame errors"},
+	{DPMAC_CNT_ING_FRAME_DISCARD,		"rx frame discards"},
+	{DPMAC_CNT_ING_UCAST_FRAME,		"rx u-cast"},
+	{DPMAC_CNT_ING_BCAST_FRAME,		"rx b-cast"},
+	{DPMAC_CNT_ING_MCAST_FRAME,		"rx m-cast"},
+	{DPMAC_CNT_ING_FRAME_64,		"rx 64 bytes"},
+	{DPMAC_CNT_ING_FRAME_127,		"rx 65-127 bytes"},
+	{DPMAC_CNT_ING_FRAME_255,		"rx 128-255 bytes"},
+	{DPMAC_CNT_ING_FRAME_511,		"rx 256-511 bytes"},
+	{DPMAC_CNT_ING_FRAME_1023,		"rx 512-1023 bytes"},
+	{DPMAC_CNT_ING_FRAME_1518,		"rx 1024-1518 bytes"},
+	{DPMAC_CNT_ING_FRAME_1519_MAX,		"rx 1519-max bytes"},
+	{DPMAC_CNT_ING_FRAG,			"rx frags"},
+	{DPMAC_CNT_ING_JABBER,			"rx jabber"},
+	{DPMAC_CNT_ING_ALIGN_ERR,		"rx align errors"},
+	{DPMAC_CNT_ING_OVERSIZED,		"rx oversized"},
+	{DPMAC_CNT_ING_VALID_PAUSE_FRAME,	"rx pause"},
+	{DPMAC_CNT_ING_BYTE,			"rx bytes"},
+	{DPMAC_CNT_EGR_UCAST_FRAME,		"tx u-cast"},
+	{DPMAC_CNT_EGR_MCAST_FRAME,		"tx m-cast"},
+	{DPMAC_CNT_EGR_BCAST_FRAME,		"tx b-cast"},
+	{DPMAC_CNT_EGR_ERR_FRAME,		"tx frame errors"},
+	{DPMAC_CNT_EGR_UNDERSIZED,		"tx undersized"},
+	{DPMAC_CNT_EGR_VALID_PAUSE_FRAME,	"tx b-pause"},
+	{DPMAC_CNT_EGR_BYTE,			"tx bytes"},
+
+};
+
+static void ppx_ethtool_get_strings(struct net_device *netdev,
+				    u32 stringset, u8 *data)
+{
+	int i;
+
+	switch (stringset) {
+	case ETH_SS_STATS:
+		for (i = 0; i < ARRAY_SIZE(ppx_ethtool_counters); i++)
+			memcpy(data + i * ETH_GSTRING_LEN,
+			       ppx_ethtool_counters[i].name, ETH_GSTRING_LEN);
+		break;
+	}
+}
+
+static void ppx_ethtool_get_stats(struct net_device *netdev,
+				  struct ethtool_stats *stats,
+				  u64 *data)
+{
+	struct ppx_priv		*priv = netdev_priv(netdev);
+	int			i;
+	int			err;
+
+	for (i = 0; i < ARRAY_SIZE(ppx_ethtool_counters); i++) {
+		err = dpmac_get_counter(priv->mc_dev->mc_io,
+					priv->mc_dev->mc_handle,
+					ppx_ethtool_counters[i].id, &data[i]);
+		if (err)
+			ppx_err(netdev, "dpmac_get_counter[%s] err %d\n",
+				ppx_ethtool_counters[i].name, err);
+	}
+}
+
+static int ppx_ethtool_get_sset_count(struct net_device *dev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(ppx_ethtool_counters);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+#endif /* FSL_DPAA2_MAC_NETDEVS */
+
+#ifdef CONFIG_FSL_DPAA2_FIXED_PHY_HACK
+static struct phy_device *ppx_register_fixed_link(struct net_device *netdev)
+{
+	struct fixed_phy_status status = {
+		.link = 1,
+		.speed = 100,
+		.duplex = 0,
+	};
+	struct phy_device *phy;
+	int err;
+
+	phy = fixed_phy_register2(PHY_POLL, &status, NULL);
+	if (!phy)
+		return NULL;
+	/* disable aneg to let the user fake speeds */
+	phy->autoneg = 0;
+
+	/* TODO: interface mode */
+	err = phy_connect_direct(netdev, phy, &ppx_link_changed,
+				 PHY_INTERFACE_MODE_NA);
+	if (err) {
+		ppx_err(netdev, "phy_connect_direct err %d\n", err);
+		return NULL;
+	}
+
+	return phy;
+}
+#endif /* CONFIG_FSL_DPAA2_FIXED_PHY_HACK */
+
+static void ppx_link_changed(struct net_device *netdev)
+{
+	struct phy_device	*phydev;
+	struct dpmac_link_state	state = { 0 };
+	struct ppx_priv		*priv = netdev_priv(netdev);
+	int			err;
+
+	/* the PHY just notified us of link state change */
+	/* TODO: maybe check that link state actually changed */
+	phydev = netdev->phydev;
+
+	state.up = !!phydev->link;
+	if (phydev->link) {
+		state.rate = phydev->speed;
+
+		if (!phydev->duplex)
+			state.options |= DPMAC_LINK_OPT_HALF_DUPLEX;
+		if (phydev->autoneg)
+			state.options |= DPMAC_LINK_OPT_AUTONEG;
+	}
+
+#ifdef PPX_DEBUG
+	if (priv->old_state.up != state.up ||
+	    priv->old_state.rate != state.rate ||
+	    priv->old_state.options != state.options) {
+		phy_print_status(phydev);
+		priv->old_state = state;
+	}
+ #endif /* PPX_DEBUG */
+
+	/* we intentionally ignore the error here as MC will return an error
+	 * if peer L2 interface (like a DPNI) is down at this time
+	 */
+	err = dpmac_set_link_state(priv->mc_dev->mc_io,
+				   priv->mc_dev->mc_handle, &state);
+
+	if (err && err != -EACCES && err != -ENAVAIL)
+		ppx_err(netdev, "dpmac_set_link_state err %d\n", err);
+}
+
+static int ppx_configure_link(struct ppx_priv *priv, struct dpmac_link_cfg *cfg)
+{
+	struct phy_device *phydev = priv->netdev->phydev;
+
+	/* TODO: sanity checks? */
+	/* like null PHY :) ignore that error for now */
+	if (!phydev) {
+		ppx_warn(priv->netdev,
+			 "asked to change PHY settings but PHY ref is NULL, ignoring\n");
+		return 0;
+	}
+
+	phydev->speed = cfg->rate;
+	phydev->duplex  = !!(cfg->options & DPMAC_LINK_OPT_HALF_DUPLEX);
+
+	if (cfg->options & DPMAC_LINK_OPT_AUTONEG) {
+		phydev->autoneg = 1;
+		phydev->advertising |= ADVERTISED_Autoneg;
+	} else {
+		phydev->autoneg = 0;
+		phydev->advertising &= ~ADVERTISED_Autoneg;
+	}
+
+	phy_start_aneg(phydev);
+
+	return 0;
+}
+
+static irqreturn_t ppx_irq_handler(int irq_num, void *arg)
+{
+	struct device *dev = (struct device *)arg;
+	struct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);
+	struct ppx_priv *priv = dev_get_drvdata(dev);
+	struct dpmac_link_cfg link_cfg;
+	int err;
+
+	dev_dbg(dev, "DPMAC IRQ %d\n", irq_num);
+	if (mc_dev->irqs[0]->irq_number != irq_num) {
+		dev_err(dev, "received unexpected interrupt %d!\n", irq_num);
+		goto err;
+	}
+
+	err = dpmac_get_link_cfg(mc_dev->mc_io,
+				 priv->mc_dev->mc_handle, &link_cfg);
+	if (err) {
+		dev_err(dev, "dpmac_get_link_cfg err %d\n", err);
+		goto err;
+	}
+
+	err = ppx_configure_link(priv, &link_cfg);
+	if (err)
+		goto err;
+
+	err = dpmac_clear_irq_status(mc_dev->mc_io,
+				     priv->mc_dev->mc_handle,
+				     0, DPMAC_IRQ_EVENT_LINK_CFG_REQ);
+	if (err < 0) {
+		dev_err(&mc_dev->dev,
+			"dpmac_clear_irq_status() err %d\n", err);
+	}
+
+	return IRQ_HANDLED;
+
+err:
+	dev_warn(dev, "DPMAC IRQ %d was not handled!\n", irq_num);
+	return IRQ_NONE;
+}
+
+static int ppx_setup_irqs(struct fsl_mc_device *mc_dev)
+{
+	int err;
+
+	err = fsl_mc_allocate_irqs(mc_dev);
+	if (err) {
+		dev_err(&mc_dev->dev, "fsl_mc_allocate_irqs err %d\n", err);
+		return err;
+	}
+
+	err = dpmac_set_irq_enable(mc_dev->mc_io, mc_dev->mc_handle,
+				   DPMAC_IRQ_INDEX, 0);
+	if (err) {
+		dev_err(&mc_dev->dev, "dpmac_set_irq_enable err %d\n", err);
+		goto free_irq;
+	}
+
+	err = devm_request_threaded_irq(&mc_dev->dev,
+					mc_dev->irqs[0]->irq_number,
+					NULL, &ppx_irq_handler, 0,
+					dev_name(&mc_dev->dev), &mc_dev->dev);
+	if (err) {
+		dev_err(&mc_dev->dev, "devm_request_threaded_irq err %d\n",
+			err);
+		goto free_irq;
+	}
+
+	err = dpmac_set_irq(mc_dev->mc_io, mc_dev->mc_handle, DPMAC_IRQ_INDEX,
+			    mc_dev->irqs[0]->msi_paddr,
+			    mc_dev->irqs[0]->msi_value, 0 /*?*/);
+	if (err) {
+		dev_err(&mc_dev->dev, "dpmac_set_irq err %d\n", err);
+		goto unregister_irq;
+	}
+
+	err = dpmac_set_irq_enable(mc_dev->mc_io, mc_dev->mc_handle,
+				   DPMAC_IRQ_INDEX, 1);
+	if (err) {
+		dev_err(&mc_dev->dev, "dpmac_set_irq_enable err %d\n", err);
+		goto unregister_irq;
+	}
+
+	return 0;
+
+unregister_irq:
+	devm_free_irq(&mc_dev->dev, mc_dev->irqs[0]->irq_number, &mc_dev->dev);
+free_irq:
+	fsl_mc_free_irqs(mc_dev);
+
+	return err;
+}
+
+static void ppx_teardown_irqs(struct fsl_mc_device *mc_dev)
+{
+	dpmac_set_irq_enable(mc_dev->mc_io, mc_dev->mc_handle,
+			     DPMAC_IRQ_INDEX, 0);
+	devm_free_irq(&mc_dev->dev, mc_dev->irqs[0]->irq_number, &mc_dev->dev);
+	fsl_mc_free_irqs(mc_dev);
+
+}
+
+static int __cold
+ppx_probe(struct fsl_mc_device *mc_dev)
+{
+	struct device		*dev;
+	struct ppx_priv		*priv = NULL;
+	struct device_node	*phy_node;
+	struct net_device	*netdev;
+	/*phy_interface_t		if_mode;*/
+	int			err = 0;
+	/* HACK */
+	static char phy_name[255];
+	static int phy_cnt;
+
+	/* just being completely paranoid */
+	if (!mc_dev)
+		return -EFAULT;
+
+	dev = &mc_dev->dev;
+
+	/* prepare a net_dev structure to make the phy lib API happy */
+	netdev = alloc_etherdev(sizeof(*priv));
+	if (!netdev) {
+		dev_err(dev, "alloc_etherdev error\n");
+		err = -ENOMEM;
+		goto err_exit;
+	}
+	priv = netdev_priv(netdev);
+	priv->mc_dev = mc_dev;
+	priv->netdev = netdev;
+
+	SET_NETDEV_DEV(netdev, dev);
+	snprintf(netdev->name, IFNAMSIZ, "mac%d", mc_dev->obj_desc.id);
+
+	dev_set_drvdata(dev, priv);
+
+	err = fsl_mc_portal_allocate(mc_dev, 0, &mc_dev->mc_io);
+	if (err) {
+		dev_err(dev, "fsl_mc_portal_allocate err %d\n", err);
+		goto err_free_netdev;
+	}
+	if (!mc_dev->mc_io) {
+		dev_err(dev,
+			"fsl_mc_portal_allocate returned null handle but no error\n");
+		goto err_free_netdev;
+	}
+
+	err = dpmac_open(mc_dev->mc_io, mc_dev->obj_desc.id,
+			 &mc_dev->mc_handle);
+	if (err) {
+		dev_err(dev, "dpmac_open err %d\n", err);
+		goto err_free_mcp;
+	}
+	if (!mc_dev->mc_handle) {
+		dev_err(dev, "dpmac_open returned null handle but no error\n");
+		err = -EFAULT;
+		goto err_free_mcp;
+	}
+
+	err = dpmac_get_attributes(mc_dev->mc_io,
+				   mc_dev->mc_handle, &priv->attr);
+	if (err) {
+		dev_err(dev, "dpmac_get_attributes err %d\n", err);
+		goto err_close;
+	}
+
+	err = ppx_setup_irqs(mc_dev);
+	if (err)
+		goto err_close;
+
+#ifdef FSL_DPAA2_MAC_NETDEVS
+	/* OPTIONAL, register netdev just to make it visible to the user */
+	netdev->netdev_ops = &ppx_ndo;
+	netdev->ethtool_ops = &ppx_ethtool_ops;
+
+	/* phy starts up enabled so netdev should be up too */
+	netdev->flags |= IFF_UP;
+
+	err = register_netdev(priv->netdev);
+	if (err < 0) {
+		dev_err(dev, "register_netdev error %d\n", err);
+		goto err_free_irq;
+	}
+#endif /* FSL_DPAA2_MAC_NETDEVS */
+
+	/* try to connect to the PHY */
+	/* phy_node = of_find_node_by_phandle(priv->attr.phy_id); */
+	sprintf(phy_name, "mdio_phy%d", phy_cnt);
+	phy_node = of_find_node_by_name(NULL, phy_name);
+	if (!phy_node) {
+		dev_err(dev, "PHY node %s not found, trying another...\n",
+			phy_name);
+
+		sprintf(phy_name, "ethernet-phy@%d", phy_cnt);
+		phy_node = of_find_node_by_name(NULL, phy_name);
+		if (!phy_node) {
+			dev_err(dev, "PHY node %s not found, looking for phandle 0x%0x\n",
+				phy_name,
+				priv->attr.phy_id);
+			err = -EFAULT;
+			goto err_no_phy;
+		}
+	}
+	pr_info("dpmac %d -> phy %d (%s)\n", priv->attr.id, phy_cnt, phy_name);
+	phy_cnt++;
+/*
+	if (priv->attr.eth_if <
+	    sizeof(ppx_eth_iface_mode) / sizeof(ppx_eth_iface_mode[0])) {
+		if_mode = ppx_eth_iface_mode[priv->attr.eth_if];
+		dev_info(dev, "\tusing if mode %s for eth_if %d\n",
+			 phy_modes(if_mode), priv->attr.eth_if);
+	} else {
+		if_mode = PHY_INTERFACE_MODE_NA;
+		dev_warn(dev, "unexpected interface mode %d\n",
+			 priv->attr.eth_if);
+	}
+	netdev->phydev = of_phy_connect(netdev, phy_node, &ppx_link_changed,
+					0, if_mode);
+*/
+	netdev->phydev = of_phy_connect(netdev, phy_node, &ppx_link_changed,
+					0, PHY_INTERFACE_MODE_SGMII);
+	if (!netdev->phydev) {
+		dev_err(dev,
+			"ERROR: of_phy_connect returned NULL\n");
+		err = -EFAULT;
+		goto err_no_phy;
+	}
+
+	dev_info(dev, "found a PHY!\n");
+
+err_no_phy:
+#ifdef CONFIG_FSL_DPAA2_FIXED_PHY_HACK
+	if (!netdev->phydev) {
+		/* try to register a fixed link phy */
+		netdev->phydev = ppx_register_fixed_link(netdev);
+		if (!netdev->phydev) {
+			dev_err(dev, "error trying to register fixed PHY!\n");
+			err = -EFAULT;
+			goto err_free_irq;
+		}
+		dev_info(dev, "registered fixed PHY!\n");
+	}
+
+#endif /* CONFIG_FSL_DPAA2_FIXED_PHY_HACK */
+
+	/* start PHY state machine */
+#ifdef FSL_DPAA2_MAC_NETDEVS
+	ppx_open(netdev);
+#else /* FSL_DPAA2_MAC_NETDEVS */
+	phy_start(netdev->phydev);
+#endif /* FSL_DPAA2_MAC_NETDEVS */
+	return 0;
+
+err_free_irq:
+	ppx_teardown_irqs(mc_dev);
+err_close:
+	dpmac_close(mc_dev->mc_io, mc_dev->mc_handle);
+err_free_mcp:
+	fsl_mc_portal_free(mc_dev->mc_io);
+err_free_netdev:
+	free_netdev(netdev);
+err_exit:
+	return err;
+}
+
+static int __cold
+ppx_remove(struct fsl_mc_device *devppx)
+{
+	struct device		*dev = &devppx->dev;
+	struct ppx_priv		*priv = dev_get_drvdata(dev);
+
+	unregister_netdev(priv->netdev);
+	ppx_teardown_irqs(priv->mc_dev);
+	dpmac_close(priv->mc_dev->mc_io, priv->mc_dev->mc_handle);
+	fsl_mc_portal_free(priv->mc_dev->mc_io);
+	free_netdev(priv->netdev);
+
+	dev_set_drvdata(dev, NULL);
+	kfree(priv);
+
+	return 0;
+}
+
+static const struct fsl_mc_device_match_id ppx_match_id_table[] = {
+	{
+		.vendor = FSL_MC_VENDOR_FREESCALE,
+		.obj_type = "dpmac",
+		.ver_major = DPMAC_VER_MAJOR,
+		.ver_minor = DPMAC_VER_MINOR,
+	},
+	{}
+};
+
+static struct fsl_mc_driver ppx_drv = {
+	.driver = {
+		.name		= KBUILD_MODNAME,
+		.owner		= THIS_MODULE,
+	},
+	.probe		= ppx_probe,
+	.remove		= ppx_remove,
+	.match_id_table = ppx_match_id_table,
+};
+
+module_fsl_mc_driver(ppx_drv);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("DPAA2 PHY proxy interface driver (prototype)");
diff --git a/drivers/staging/fsl-dpaa2/mac/phy_proxy.c b/drivers/staging/fsl-dpaa2/mac/phy_proxy.c
deleted file mode 100644
index b04853b..0000000
--- a/drivers/staging/fsl-dpaa2/mac/phy_proxy.c
+++ /dev/null
@@ -1,642 +0,0 @@
-
-#include <linux/module.h>
-
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/rtnetlink.h>
-#include <linux/if_vlan.h>
-
-#include <uapi/linux/if_bridge.h>
-#include <net/netlink.h>
-#include "../../fsl-mc/include/mc.h"
-#include "../../fsl-mc/include/mc-sys.h"
-
-#include <linux/of.h>
-#include <linux/of_mdio.h>
-#include <linux/of_net.h>
-#include <linux/phy.h>
-#include <linux/phy_fixed.h>
-
-#include "../../fsl-mc/include/dpmac.h"
-#include "../../fsl-mc/include/dpmac-cmd.h"
-
-
-/* big TODOs:
- * mac stats
- */
-
-struct phy_device *fixed_phy_register2(unsigned int irq,
-				       struct fixed_phy_status *status,
-				       struct device_node *np);
-
-
-struct ppx_priv {
-	struct net_device		*netdev;
-	struct fsl_mc_device		*mc_dev;
-	struct dpmac_attr		attr;
-};
-
-/* TODO: fix the 10G modes, mapping can't be right:
- *  XGMII is paralel
- *  XAUI is serial, using 8b/10b encoding
- *  XFI is also serial but using 64b/66b encoding
- * they can't all map to XGMII...
- */
-static phy_interface_t ppx_eth_iface_mode[] __maybe_unused =  {
-	/* DPMAC_ETH_IF_MII */
-	PHY_INTERFACE_MODE_MII,
-	/* DPMAC_ETH_IF_RMII */
-	PHY_INTERFACE_MODE_RMII,
-	/* DPMAC_ETH_IF_SMII */
-	PHY_INTERFACE_MODE_SMII,
-	/* DPMAC_ETH_IF_GMII */
-	PHY_INTERFACE_MODE_GMII,
-	/* DPMAC_ETH_IF_RGMII */
-	PHY_INTERFACE_MODE_RGMII,
-	/* DPMAC_ETH_IF_SGMII */
-	PHY_INTERFACE_MODE_SGMII,
-	/* DPMAC_ETH_IF_XGMII */
-	PHY_INTERFACE_MODE_XGMII,
-	/* DPMAC_ETH_IF_QSGMII */
-	PHY_INTERFACE_MODE_QSGMII,
-	/* DPMAC_ETH_IF_XAUI */
-	PHY_INTERFACE_MODE_XGMII,
-	/* DPMAC_ETH_IF_XFI */
-	PHY_INTERFACE_MODE_XGMII,
-
-};
-
-static void ppx_link_changed(struct net_device *netdev);
-
-#ifdef CONFIG_FSL_DPAA2_PPX_NETDEVS
-static netdev_tx_t ppx_dropframe(struct sk_buff *skb, struct net_device *dev);
-static int ppx_open(struct net_device *netdev);
-static int ppx_stop(struct net_device *netdev);
-static struct rtnl_link_stats64 *ppx_get_stats(struct net_device *,
-					       struct rtnl_link_stats64 *);
-
-static int ppx_ethtool_get_settings(struct net_device *, struct ethtool_cmd *);
-static int ppx_ethtool_set_settings(struct net_device *, struct ethtool_cmd *);
-static int ppx_ethtool_get_sset_count(struct net_device *dev, int sset);
-static void ppx_ethtool_get_strings(struct net_device *, u32 stringset, u8 *);
-static void ppx_ethtool_get_stats(struct net_device *, struct ethtool_stats *,
-				  u64 *);
-
-static const struct net_device_ops ppx_ndo = {
-	.ndo_start_xmit		= &ppx_dropframe,
-	/* TODO: temporary to force fixed links up and down */
-	.ndo_open		= &ppx_open,
-	.ndo_stop		= &ppx_stop,
-	.ndo_get_stats64	= &ppx_get_stats,
-};
-
-static const struct ethtool_ops ppx_ethtool_ops = {
-	.get_settings		= &ppx_ethtool_get_settings,
-	.set_settings		= &ppx_ethtool_set_settings,
-	.get_strings		= &ppx_ethtool_get_strings,
-	.get_ethtool_stats	= &ppx_ethtool_get_stats,
-	.get_sset_count		= &ppx_ethtool_get_sset_count,
-};
-
-static netdev_tx_t ppx_dropframe(struct sk_buff *skb, struct net_device *dev)
-{
-	/* we don't support I/O for now, drop the frame */
-	dev_kfree_skb_any(skb);
-	return NETDEV_TX_OK;
-}
-
-static int ppx_open(struct net_device *netdev)
-{
-	/* force PHY up */
-	phy_start(netdev->phydev);
-
-	return 0;
-}
-
-static int ppx_stop(struct net_device *netdev)
-{
-	/* force PHY down */
-	phy_stop(netdev->phydev);
-
-	return 0;
-}
-
-static int ppx_ethtool_get_settings(struct net_device *netdev,
-				    struct ethtool_cmd *cmd)
-{
-	return phy_ethtool_gset(netdev->phydev, cmd);
-}
-
-static int ppx_ethtool_set_settings(struct net_device *netdev,
-				    struct ethtool_cmd *cmd)
-{
-	return phy_ethtool_sset(netdev->phydev, cmd);
-}
-
-static struct rtnl_link_stats64
-*ppx_get_stats(struct net_device *netdev, struct rtnl_link_stats64 *storage)
-{
-	struct ppx_priv		*priv = netdev_priv(netdev);
-	u64			tmp;
-	int			err;
-
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_EGR_MCAST_FRAME,
-				&storage->tx_packets);
-	if (err)
-		goto error;
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_EGR_BCAST_FRAME, &tmp);
-	if (err)
-		goto error;
-	storage->tx_packets += tmp;
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_EGR_UCAST_FRAME, &tmp);
-	if (err)
-		goto error;
-	storage->tx_packets += tmp;
-
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_EGR_UNDERSIZED, &storage->tx_dropped);
-	if (err)
-		goto error;
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_EGR_BYTE, &storage->tx_bytes);
-	if (err)
-		goto error;
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_EGR_ERR_FRAME, &storage->tx_errors);
-	if (err)
-		goto error;
-
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_ING_ALL_FRAME, &storage->rx_packets);
-	if (err)
-		goto error;
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_ING_MCAST_FRAME, &storage->multicast);
-	if (err)
-		goto error;
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_ING_FRAME_DISCARD,
-				&storage->rx_dropped);
-	if (err)
-		goto error;
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_ING_ALIGN_ERR, &storage->rx_errors);
-	if (err)
-		goto error;
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_ING_OVERSIZED, &tmp);
-	if (err)
-		goto error;
-	storage->rx_errors += tmp;
-	err = dpmac_get_counter(priv->mc_dev->mc_io, priv->mc_dev->mc_handle,
-				DPMAC_CNT_ING_BYTE, &storage->rx_bytes);
-	if (err)
-		goto error;
-
-	return storage;
-
-error:
-	netdev_err(netdev, "dpmac_get_counter err %d\n", err);
-	return storage;
-}
-
-static struct {
-	enum dpmac_counter id;
-	char name[ETH_GSTRING_LEN];
-} ppx_ethtool_counters[] =  {
-	{DPMAC_CNT_ING_ALL_FRAME,		"rx all frames"},
-	{DPMAC_CNT_ING_GOOD_FRAME,		"rx frames ok"},
-	{DPMAC_CNT_ING_ERR_FRAME,		"rx frame errors"},
-	{DPMAC_CNT_ING_FRAME_DISCARD,		"rx frame discards"},
-	{DPMAC_CNT_ING_UCAST_FRAME,		"rx u-cast"},
-	{DPMAC_CNT_ING_BCAST_FRAME,		"rx b-cast"},
-	{DPMAC_CNT_ING_MCAST_FRAME,		"rx m-cast"},
-	{DPMAC_CNT_ING_FRAME_64,		"rx 64 bytes"},
-	{DPMAC_CNT_ING_FRAME_127,		"rx 65-127 bytes"},
-	{DPMAC_CNT_ING_FRAME_255,		"rx 128-255 bytes"},
-	{DPMAC_CNT_ING_FRAME_511,		"rx 256-511 bytes"},
-	{DPMAC_CNT_ING_FRAME_1023,		"rx 512-1023 bytes"},
-	{DPMAC_CNT_ING_FRAME_1518,		"rx 1024-1518 bytes"},
-	{DPMAC_CNT_ING_FRAME_1519_MAX,		"rx 1519-max bytes"},
-	{DPMAC_CNT_ING_FRAG,			"rx frags"},
-	{DPMAC_CNT_ING_JABBER,			"rx jabber"},
-	{DPMAC_CNT_ING_ALIGN_ERR,		"rx align errors"},
-	{DPMAC_CNT_ING_OVERSIZED,		"rx oversized"},
-	{DPMAC_CNT_ING_VALID_PAUSE_FRAME,	"rx pause"},
-	{DPMAC_CNT_ING_BYTE,			"rx bytes"},
-	{DPMAC_CNT_EGR_UCAST_FRAME,		"tx u-cast"},
-	{DPMAC_CNT_EGR_MCAST_FRAME,		"tx m-cast"},
-	{DPMAC_CNT_EGR_BCAST_FRAME,		"tx b-cast"},
-	{DPMAC_CNT_EGR_ERR_FRAME,		"tx frame errors"},
-	{DPMAC_CNT_EGR_UNDERSIZED,		"tx undersized"},
-	{DPMAC_CNT_EGR_VALID_PAUSE_FRAME,	"tx b-pause"},
-	{DPMAC_CNT_EGR_BYTE,			"tx bytes"},
-
-};
-
-static void ppx_ethtool_get_strings(struct net_device *netdev,
-				    u32 stringset, u8 *data)
-{
-	int i;
-
-	switch (stringset) {
-	case ETH_SS_STATS:
-		for (i = 0; i < ARRAY_SIZE(ppx_ethtool_counters); i++)
-			memcpy(data + i * ETH_GSTRING_LEN,
-			       ppx_ethtool_counters[i].name, ETH_GSTRING_LEN);
-		break;
-	}
-}
-
-static void ppx_ethtool_get_stats(struct net_device *netdev,
-				  struct ethtool_stats *stats,
-				  u64 *data)
-{
-	struct ppx_priv		*priv = netdev_priv(netdev);
-	int			i;
-	int			err;
-
-	for (i = 0; i < ARRAY_SIZE(ppx_ethtool_counters); i++) {
-		err = dpmac_get_counter(priv->mc_dev->mc_io,
-					priv->mc_dev->mc_handle,
-					ppx_ethtool_counters[i].id, &data[i]);
-		if (err)
-			netdev_err(netdev, "dpmac_get_counter[%s] err %d\n",
-				   ppx_ethtool_counters[i].name, err);
-	}
-}
-
-static int ppx_ethtool_get_sset_count(struct net_device *dev, int sset)
-{
-	switch (sset) {
-	case ETH_SS_STATS:
-		return ARRAY_SIZE(ppx_ethtool_counters);
-	default:
-		return -EOPNOTSUPP;
-	}
-}
-#endif /* CONFIG_FSL_DPAA2_PPX_NETDEVS */
-
-#ifdef CONFIG_FSL_DPAA2_FIXED_PHY_HACK
-static struct phy_device *ppx_register_fixed_link(struct net_device *netdev)
-{
-	struct fixed_phy_status status = {
-		.link = 1,
-		.speed = 100,
-		.duplex = 0,
-	};
-	struct phy_device *phy;
-	int err;
-
-	phy = fixed_phy_register2(PHY_POLL, &status, NULL);
-	if (!phy)
-		return NULL;
-	/* disable aneg to let the user fake speeds */
-	phy->autoneg = 0;
-
-	/* TODO: interface mode */
-	err = phy_connect_direct(netdev, phy, &ppx_link_changed,
-				 PHY_INTERFACE_MODE_NA);
-	if (err) {
-		netdev_err(netdev, "phy_connect_direct err %d\n", err);
-		return NULL;
-	}
-
-	return phy;
-}
-#endif /* CONFIG_FSL_DPAA2_FIXED_PHY_HACK */
-
-static void ppx_link_changed(struct net_device *netdev)
-{
-	struct phy_device	*phydev;
-	struct dpmac_link_state	state = { 0 };
-	struct ppx_priv		*priv = netdev_priv(netdev);
-	int			err;
-
-	/* the PHY just notified us of link state change */
-	/* TODO: maybe check that link state actually changed */
-	phydev = netdev->phydev;
-
-	state.up = !!phydev->link;
-	if (phydev->link) {
-		state.rate = phydev->speed;
-
-		if (!phydev->duplex)
-			state.options |= DPMAC_LINK_OPT_HALF_DUPLEX;
-		if (phydev->autoneg)
-			state.options |= DPMAC_LINK_OPT_AUTONEG;
-	}
-	/* this prints out roughly every second while polling, don't enable
-	 * unless absolutely necessary.
-	 * phy_print_status(phydev);
-	 */
-
-	err = dpmac_set_link_state(priv->mc_dev->mc_io,
-				   priv->mc_dev->mc_handle, &state);
-	if (err)
-		dev_err(&netdev->dev, "dpmac_set_link_state err %d\n", err);
-}
-
-static int ppx_configure_link(struct ppx_priv *priv, struct dpmac_link_cfg *cfg)
-{
-	struct phy_device *phydev = priv->netdev->phydev;
-
-	/* TODO: sanity checks? */
-	/* like null PHY :) ignore that error for now */
-	if (!phydev) {
-		netdev_warn(priv->netdev,
-			    "asked to change PHY settings but PHY ref is NULL, ignoring\n");
-		return 0;
-	}
-
-	phydev->speed = cfg->rate;
-	phydev->duplex  = !!(cfg->options & DPMAC_LINK_OPT_HALF_DUPLEX);
-
-	if (cfg->options & DPMAC_LINK_OPT_AUTONEG) {
-		phydev->autoneg = 1;
-		phydev->advertising |= ADVERTISED_Autoneg;
-	} else {
-		phydev->autoneg = 0;
-		phydev->advertising &= ~ADVERTISED_Autoneg;
-	}
-
-	phy_start_aneg(phydev);
-
-	return 0;
-}
-
-static irqreturn_t ppx_irq_handler(int irq_num, void *arg)
-{
-	struct device *dev = (struct device *)arg;
-	struct fsl_mc_device *mc_dev = to_fsl_mc_device(dev);
-	struct ppx_priv *priv = dev_get_drvdata(dev);
-	struct dpmac_link_cfg link_cfg;
-	int err;
-
-	dev_dbg(dev, "DPMAC IRQ %d\n", irq_num);
-	if (mc_dev->irqs[0]->irq_number != irq_num) {
-		dev_err(dev, "received unexpected interrupt %d!\n", irq_num);
-		goto err;
-	}
-
-	err = dpmac_get_link_cfg(mc_dev->mc_io,
-				 priv->mc_dev->mc_handle, &link_cfg);
-	if (err) {
-		dev_err(dev, "dpmac_get_link_cfg err %d\n", err);
-		goto err;
-	}
-
-	err = ppx_configure_link(priv, &link_cfg);
-	if (err)
-		goto err;
-
-	err = dpmac_clear_irq_status(mc_dev->mc_io,
-				     priv->mc_dev->mc_handle,
-				     0, DPMAC_IRQ_EVENT_LINK_CFG_REQ);
-	if (err < 0) {
-		dev_err(&mc_dev->dev,
-			"dpmac_clear_irq_status() err %d\n", err);
-	}
-
-	return IRQ_HANDLED;
-
-err:
-	dev_warn(dev, "DPMAC IRQ %d was not handled!\n", irq_num);
-	return IRQ_NONE;
-}
-
-static int ppx_setup_irqs(struct fsl_mc_device *mc_dev)
-{
-	static const struct fsl_mc_irq_ops dprc_irq_ops = {
-		.mc_set_irq_enable = dpmac_set_irq_enable,
-		.mc_clear_irq_status = dpmac_clear_irq_status,
-		.mc_set_irq = dpmac_set_irq,
-		.mc_set_irq_mask = dpmac_set_irq_mask,
-	};
-
-	const struct fsl_mc_irq_config irq_config = {
-		.irq_handler = NULL,
-		.irq_handler_thread = ppx_irq_handler,
-		.irq_name = "FSL MC DPMAC irq0",
-		.irq_mask = DPMAC_IRQ_EVENT_LINK_CFG_REQ,
-		.data = &mc_dev->dev,
-	};
-	int err;
-
-	if (mc_dev->obj_desc.irq_count != 1) {
-		dev_err(&mc_dev->dev,
-			"expected one interrupt, but the device has %d!\n",
-			mc_dev->obj_desc.irq_count);
-		return -EINVAL;
-	}
-
-	err = fsl_mc_setup_irqs(mc_dev, &dprc_irq_ops);
-	if (err < 0)
-		return err;
-
-	err = fsl_mc_configure_irq(mc_dev, 0, &irq_config);
-	if (err < 0)
-		return err;
-
-	return 0;
-}
-
-static int __cold
-ppx_probe(struct fsl_mc_device *mc_dev)
-{
-	struct device		*dev;
-	struct ppx_priv		*priv = NULL;
-	struct device_node	*phy_node;
-	struct net_device	*netdev;
-	/*phy_interface_t		if_mode;*/
-	int			err = 0;
-	/* HACK */
-	static char phy_name[255];
-	static int phy_cnt;
-
-	/* just being completely paranoid */
-	if (!mc_dev)
-		return -EFAULT;
-
-	dev = &mc_dev->dev;
-
-	/* prepare a net_dev structure to make the phy lib API happy */
-	netdev = alloc_etherdev(sizeof(*priv));
-	if (!netdev) {
-		dev_err(dev, "alloc_etherdev error\n");
-		err = -ENOMEM;
-		goto err_exit;
-	}
-	priv = netdev_priv(netdev);
-	priv->mc_dev = mc_dev;
-	priv->netdev = netdev;
-
-	SET_NETDEV_DEV(netdev, dev);
-	/* MDIO ID would be better, but we can do that later */
-	snprintf(netdev->name, IFNAMSIZ, "phy%d", mc_dev->obj_desc.id);
-
-	dev_set_drvdata(dev, priv);
-
-	err = fsl_mc_portal_allocate(mc_dev, FSL_MC_IO_PORTAL_SHARED,
-				     &mc_dev->mc_io);
-	if (err) {
-		dev_err(dev, "fsl_mc_portal_allocate err %d\n", err);
-		goto err_free_netdev;
-	}
-	if (!mc_dev->mc_io) {
-		dev_err(dev,
-			"fsl_mc_portal_allocate returned null handle but no error\n");
-		goto err_free_netdev;
-	}
-
-	err = dpmac_open(mc_dev->mc_io, mc_dev->obj_desc.id,
-			 &mc_dev->mc_handle);
-	if (err) {
-		dev_err(dev, "dpmac_open err %d\n", err);
-		goto err_free_mcp;
-	}
-	if (!mc_dev->mc_handle) {
-		dev_err(dev, "dpmac_open returned null handle but no error\n");
-		err = -EFAULT;
-		goto err_free_mcp;
-	}
-
-	err = dpmac_get_attributes(mc_dev->mc_io,
-				   mc_dev->mc_handle, &priv->attr);
-	if (err) {
-		dev_err(dev, "dpmac_get_attributes err %d\n", err);
-		goto err_close;
-	}
-
-	err = ppx_setup_irqs(mc_dev);
-	if (err)
-		goto err_close;
-
-#ifdef CONFIG_FSL_DPAA2_PPX_NETDEVS
-	/* OPTIONAL, register netdev just to make it visible to the user */
-	netdev->netdev_ops = &ppx_ndo;
-	netdev->ethtool_ops = &ppx_ethtool_ops;
-
-	err = register_netdev(priv->netdev);
-	if (err < 0) {
-		dev_err(dev, "register_netdev error %d\n", err);
-		goto err_free_irq;
-	}
-#endif /* CONFIG_FSL_DPAA2_PPX_NETDEVS */
-
-	/* try to connect to the PHY */
-	/* phy_node = of_find_node_by_phandle(priv->attr.phy_id); */
-	sprintf(phy_name, "mdio_phy%d", phy_cnt);
-	phy_node = of_find_node_by_name(NULL, phy_name);
-	if (!phy_node) {
-		dev_err(dev, "PHY node %s not found, trying another...\n",
-			phy_name);
-
-		sprintf(phy_name, "ethernet-phy@%d", phy_cnt);
-		phy_node = of_find_node_by_name(NULL, phy_name);
-		if (!phy_node) {
-			dev_err(dev, "PHY node %s not found, looking for phandle 0x%0x\n",
-				phy_name,
-				priv->attr.phy_id);
-			err = -EFAULT;
-			goto err_no_phy;
-		}
-	}
-	pr_info("dpmac %d -> phy %d (%s)\n", priv->attr.id, phy_cnt, phy_name);
-	phy_cnt++;
-/*
-	if (priv->attr.eth_if <
-	    sizeof(ppx_eth_iface_mode) / sizeof(ppx_eth_iface_mode[0])) {
-		if_mode = ppx_eth_iface_mode[priv->attr.eth_if];
-		dev_info(dev, "\tusing if mode %s for eth_if %d\n",
-			 phy_modes(if_mode), priv->attr.eth_if);
-	} else {
-		if_mode = PHY_INTERFACE_MODE_NA;
-		dev_warn(dev, "unexpected interface mode %d\n",
-			 priv->attr.eth_if);
-	}
-	netdev->phydev = of_phy_connect(netdev, phy_node, &ppx_link_changed,
-					0, if_mode);
-*/
-	netdev->phydev = of_phy_connect(netdev, phy_node, &ppx_link_changed,
-					0, PHY_INTERFACE_MODE_SGMII);
-	if (!netdev->phydev) {
-		dev_err(dev,
-			"ERROR: of_phy_connect returned NULL\n");
-		err = -EFAULT;
-		goto err_no_phy;
-	}
-
-	dev_info(dev, "found a PHY!\n");
-	return 0;
-
-err_no_phy:
-#ifdef CONFIG_FSL_DPAA2_FIXED_PHY_HACK
-	netdev->phydev = ppx_register_fixed_link(netdev);
-	if (!netdev->phydev) {
-		dev_err(dev, "error trying to register fixed PHY!\n");
-		err = -EFAULT;
-		goto err_free_irq;
-	}
-
-	dev_info(dev, "registered fixed PHY!\n");
-	return 0;
-#endif /* CONFIG_FSL_DPAA2_FIXED_PHY_HACK */
-
-err_free_irq:
-	fsl_mc_teardown_irqs(mc_dev);
-err_close:
-	dpmac_close(mc_dev->mc_io, mc_dev->mc_handle);
-err_free_mcp:
-	fsl_mc_portal_free(mc_dev->mc_io);
-err_free_netdev:
-	free_netdev(netdev);
-err_exit:
-	return err;
-}
-
-static int __cold
-ppx_remove(struct fsl_mc_device *devppx)
-{
-	struct device		*dev = &devppx->dev;
-	struct ppx_priv		*priv = dev_get_drvdata(dev);
-
-	unregister_netdev(priv->netdev);
-	fsl_mc_teardown_irqs(priv->mc_dev);
-	dpmac_close(priv->mc_dev->mc_io, priv->mc_dev->mc_handle);
-	fsl_mc_portal_free(priv->mc_dev->mc_io);
-	free_netdev(priv->netdev);
-
-	dev_set_drvdata(dev, NULL);
-	kfree(priv);
-
-	return 0;
-}
-
-static const struct fsl_mc_device_match_id ppx_match_id_table[] = {
-	{
-		.vendor = FSL_MC_VENDOR_FREESCALE,
-		.obj_type = "dpmac",
-		.ver_major = DPMAC_VER_MAJOR,
-		.ver_minor = DPMAC_VER_MINOR,
-	},
-	{}
-};
-
-static struct fsl_mc_driver ppx_drv = {
-	.driver = {
-		.name		= KBUILD_MODNAME,
-		.owner		= THIS_MODULE,
-	},
-	.probe		= ppx_probe,
-	.remove		= ppx_remove,
-	.match_id_table = ppx_match_id_table,
-};
-
-module_fsl_mc_driver(ppx_drv);
-
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("DPAA2 PHY proxy interface driver (prototype)");
-- 
1.7.5.4

