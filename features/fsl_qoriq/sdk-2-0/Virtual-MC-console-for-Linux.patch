From 2276fe7abb60352fbb1e0128c2bd3dec009b7882 Mon Sep 17 00:00:00 2001
From: Stuart Yoder <stuart.yoder@freescale.com>
Date: Thu, 13 Aug 2015 16:31:20 -0500
Subject: [PATCH 0890/1429] Virtual MC console for Linux

Create a character device that makes the LS2 virtual console look
like a file.  This allows users to cat or tail /dev/fsl_mc_console
on systems that do not have an MC UART

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
(Stuart: updated config option to be ARCH_LAYERSCAPE)
Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>

Conflicts:

	drivers/soc/fsl/Kconfig.arm
	drivers/soc/fsl/Makefile
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/soc/fsl/Kconfig.arm               |    4 +
 drivers/soc/fsl/Makefile                  |    1 +
 drivers/soc/fsl/ls2-console/Kconfig       |    4 +
 drivers/soc/fsl/ls2-console/Makefile      |    1 +
 drivers/soc/fsl/ls2-console/ls2-console.c |  130 +++++++++++++++++++++++++++++
 5 files changed, 140 insertions(+), 0 deletions(-)
 create mode 100644 drivers/soc/fsl/ls2-console/Kconfig
 create mode 100644 drivers/soc/fsl/ls2-console/Makefile
 create mode 100644 drivers/soc/fsl/ls2-console/ls2-console.c

diff --git a/drivers/soc/fsl/Kconfig.arm b/drivers/soc/fsl/Kconfig.arm
index 5f2d2140..79aed5b 100644
--- a/drivers/soc/fsl/Kconfig.arm
+++ b/drivers/soc/fsl/Kconfig.arm
@@ -23,3 +23,7 @@ config LS_SOC_DRIVERS
 if LS1_SOC_DRIVERS
 	source "drivers/soc/fsl/ls1/Kconfig"
 endif
+
+if LS_SOC_DRIVERS
+	source "drivers/soc/fsl/ls2-console/Kconfig"
+endif
diff --git a/drivers/soc/fsl/Makefile b/drivers/soc/fsl/Makefile
index 5d24f05..02b5615 100644
--- a/drivers/soc/fsl/Makefile
+++ b/drivers/soc/fsl/Makefile
@@ -6,3 +6,4 @@ obj-$(CONFIG_LS1_SOC_DRIVERS)	+= ls1/
 obj-$(CONFIG_QUICC_ENGINE)	+= qe/
 obj-$(CONFIG_CPM)		+= qe/
 obj-$(CONFIG_FSL_GUTS)		+= guts.o
+obj-$(CONFIG_LS_SOC_DRIVERS) += ls2-console/
diff --git a/drivers/soc/fsl/ls2-console/Kconfig b/drivers/soc/fsl/ls2-console/Kconfig
new file mode 100644
index 0000000..1a44ab7
--- /dev/null
+++ b/drivers/soc/fsl/ls2-console/Kconfig
@@ -0,0 +1,4 @@
+config FSL_LS2_CONSOLE
+        bool "Layerscape MC and AIOP console support"
+	depends on ARCH_LAYERSCAPE
+        default y
diff --git a/drivers/soc/fsl/ls2-console/Makefile b/drivers/soc/fsl/ls2-console/Makefile
new file mode 100644
index 0000000..62b9634
--- /dev/null
+++ b/drivers/soc/fsl/ls2-console/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_FSL_LS2_CONSOLE) += ls2-console.o
diff --git a/drivers/soc/fsl/ls2-console/ls2-console.c b/drivers/soc/fsl/ls2-console/ls2-console.c
new file mode 100644
index 0000000..f2b6826
--- /dev/null
+++ b/drivers/soc/fsl/ls2-console/ls2-console.c
@@ -0,0 +1,130 @@
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/poll.h>
+#include <linux/compat.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+
+/* MC and IOP character device to read from RAM */
+
+#define MC_BASE_ADDR 0x83e0000000
+#define MC_BUFFER_SIZE (1024*1024*3)
+
+struct console_data {
+	char *start_addr; /* Start of buffer */
+	char *end_addr; /* End of buffer */
+	char *end_of_data; /* Current end of data */
+	char *last_to_console; /* Last data sent to console */
+};
+
+
+static int fsl_ls2_console_open(struct inode *node, struct file *fp)
+{
+	struct console_data *cd;
+
+	cd = kmalloc(sizeof(*cd), GFP_KERNEL);
+	if (cd == NULL)
+		return -ENOMEM;
+	fp->private_data = cd;
+	cd->start_addr = ioremap(MC_BASE_ADDR + 0x01000000, MC_BUFFER_SIZE);
+	cd->end_addr = cd->start_addr + MC_BUFFER_SIZE;
+	cd->end_of_data = cd->start_addr;
+	cd->last_to_console = cd->start_addr;
+	return 0;
+}
+
+static int fsl_ls2_console_close(struct inode *node, struct file *fp)
+{
+	struct console_data *cd = fp->private_data;
+
+	iounmap(cd->start_addr);
+	kfree(cd);
+	return 0;
+}
+
+static void adjust_end(struct console_data *cd)
+{
+	while (strncmp(cd->end_of_data, "END", 3) != 0) {
+		if (cd->end_of_data == cd->end_addr)
+			cd->end_of_data = cd->start_addr;
+		else
+			++cd->end_of_data;
+	}
+}
+
+/* Read one past the end of the buffer regardless of end */
+static char consume_next_char(struct console_data *cd)
+{
+	if (cd->last_to_console == cd->end_addr)
+		cd->last_to_console = cd->start_addr;
+	else
+		++cd->last_to_console;
+
+	return *(cd->last_to_console);
+}
+
+ssize_t fsl_ls2_console_read(struct file *fp, char __user *buf, size_t count,
+			     loff_t *f_pos)
+{
+	struct console_data *cd = fp->private_data;
+	size_t bytes = 0;
+	char data;
+
+	/* Check if we need to adjust the end of data addr */
+	adjust_end(cd);
+
+	while (count != bytes && ((cd->end_of_data-1) != cd->last_to_console)) {
+		data = consume_next_char(cd);
+		if (copy_to_user(&buf[bytes], &data, 1))
+			return -EFAULT;
+		++bytes;
+	}
+	return bytes;
+}
+
+
+static const struct file_operations fsl_ls2_console_fops = {
+	.owner          = THIS_MODULE,
+	.open           = fsl_ls2_console_open,
+	.release        = fsl_ls2_console_close,
+	.read           = fsl_ls2_console_read,
+};
+
+static struct miscdevice fsl_ls2_mc_console_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "fsl_mc_console",
+	.fops = &fsl_ls2_console_fops
+};
+
+static int __init fsl_ls2_console_init(void)
+{
+	int err = 0;
+
+	pr_info("Freescale LS2 console driver\n");
+	err = misc_register(&fsl_ls2_mc_console_dev);
+	if (err) {
+		pr_err("fsl_mc_console: cannot register device\n");
+		return err;
+	}
+	pr_info("fsl-ls2-console: device %s registered\n",
+		fsl_ls2_mc_console_dev.name);
+	return 0;
+}
+
+static void __exit fsl_ls2_console_exit(void)
+{
+	int err = misc_deregister(&fsl_ls2_mc_console_dev);
+
+	if (err)
+		pr_err("Failed to deregister device %s code %d\n",
+		       fsl_ls2_mc_console_dev.name, err);
+	pr_info("device %s deregistered\n", fsl_ls2_mc_console_dev.name);
+}
+
+module_init(fsl_ls2_console_init);
+module_exit(fsl_ls2_console_exit);
+
+MODULE_AUTHOR("Roy Pledge <roy.pledge@freescale.com>");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("Freescale LS2 console driver");
-- 
1.7.5.4

