From c1175a3d57b93d6dacf0c2a832bcc6096393aaf9 Mon Sep 17 00:00:00 2001
From: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Date: Tue, 27 Aug 2013 13:36:46 -0400
Subject: [PATCH 0982/1429] fsl_dce: Initial DCE device driver support

Add FSL DCE device creation and access to device configuration.
This device does compression and decompression.

Signed-off-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Change-Id: I6d951fe045f7638530a810c91e5dc21f29549bb1
Reviewed-on: http://git.am.freescale.net:8181/4294
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Thorpe Geoff-R01361 <Geoff.Thorpe@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>

Conflicts:

	drivers/staging/Makefile
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/Kconfig                        |    2 +
 drivers/staging/Makefile                       |    1 +
 drivers/staging/fsl_dce/Kconfig                |   25 +
 drivers/staging/fsl_dce/Makefile               |   12 +
 drivers/staging/fsl_dce/dce_debugfs.c          |  281 ++++
 drivers/staging/fsl_dce/dce_driver.c           |  345 +++++
 drivers/staging/fsl_dce/dce_sys.c              |  273 ++++
 drivers/staging/fsl_dce/dce_sys.h              |   68 +
 drivers/staging/fsl_dce/flib/bitfield_macros.h |  146 ++
 drivers/staging/fsl_dce/flib/dce_defs.h        | 1924 ++++++++++++++++++++++++
 drivers/staging/fsl_dce/flib/dce_regs.h        |  546 +++++++
 drivers/staging/fsl_dce/fsl_dce.h              |   60 +
 12 files changed, 3683 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/fsl_dce/Kconfig
 create mode 100644 drivers/staging/fsl_dce/Makefile
 create mode 100644 drivers/staging/fsl_dce/dce_debugfs.c
 create mode 100644 drivers/staging/fsl_dce/dce_driver.c
 create mode 100644 drivers/staging/fsl_dce/dce_sys.c
 create mode 100644 drivers/staging/fsl_dce/dce_sys.h
 create mode 100644 drivers/staging/fsl_dce/flib/bitfield_macros.h
 create mode 100644 drivers/staging/fsl_dce/flib/dce_defs.h
 create mode 100644 drivers/staging/fsl_dce/flib/dce_regs.h
 create mode 100644 drivers/staging/fsl_dce/fsl_dce.h

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index 9b2c849..5a0c39d 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -124,4 +124,6 @@ source "drivers/staging/lttng/Kconfig"
 
 source "drivers/staging/fsl_pme2/Kconfig"
 
+source "drivers/staging/fsl_dce/Kconfig"
+
 endif # STAGING
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index d97dc8d..6e90878 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -52,5 +52,6 @@ obj-$(CONFIG_FSL_MC_BUS)	+= fsl-mc/
 obj-$(CONFIG_FSL_RMAN_UIO)	+= fsl_rman/
 obj-$(CONFIG_FSL_DPA)           += fsl_qbman/
 obj-$(CONFIG_FSL_DPAA2)		+= fsl-dpaa2/
+obj-$(CONFIG_FSL_DCE)		+= fsl_dce/
 obj-$(CONFIG_FSL_PME2)          += fsl_pme2/
 obj-$(CONFIG_LTTNG)	+= lttng/
diff --git a/drivers/staging/fsl_dce/Kconfig b/drivers/staging/fsl_dce/Kconfig
new file mode 100644
index 0000000..0ea31d6
--- /dev/null
+++ b/drivers/staging/fsl_dce/Kconfig
@@ -0,0 +1,25 @@
+config FSL_DCE
+	tristate "Freescale Decompression Compression Engine support"
+	depends on FSL_QMAN
+	help
+	  Say Y here to include support for the Freescale DCE driver.
+	  To compile this driver as a module, choose M here: the module
+	  will be called dce
+
+if FSL_DCE
+
+config FSL_DCE_CONFIG
+	tristate "Freescale DCE device management"
+	default y
+	help
+	  Say Y here to include support for the Freescale DCE driver.
+	  To compile this driver as a module, choose M here: the module
+	  will be called dce
+
+config FSL_DCE_DEBUGFS
+	tristate "Freescale Decompression Compression Engine DebugFS interface"
+	default y
+	help
+	  Say Y here to include debugfs interface
+
+endif # FSL_DCE
diff --git a/drivers/staging/fsl_dce/Makefile b/drivers/staging/fsl_dce/Makefile
new file mode 100644
index 0000000..f75b576
--- /dev/null
+++ b/drivers/staging/fsl_dce/Makefile
@@ -0,0 +1,12 @@
+#
+# Makefile for Freesecale DCE driver
+#
+
+obj-$(CONFIG_FSL_DCE) += fsl-dce.o
+obj-$(CONFIG_FSL_DCE_CONFIG) += fsl-dce-config.o
+obj-$(CONFIG_FSL_DCE_DEBUGFS) += fsl-dce-debugfs.o
+
+fsl-dce-y := dce_sys.o
+fsl-dce-config-y := dce_driver.o
+fsl-dce-debugfs-y := dce_debugfs.o
+
diff --git a/drivers/staging/fsl_dce/dce_debugfs.c b/drivers/staging/fsl_dce/dce_debugfs.c
new file mode 100644
index 0000000..23fc1ed
--- /dev/null
+++ b/drivers/staging/fsl_dce/dce_debugfs.c
@@ -0,0 +1,281 @@
+/* Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+#include <linux/seq_file.h>
+#include <linux/uaccess.h>
+#include <linux/of.h>
+#include <linux/io.h>
+#include <linux/debugfs.h>
+#include <linux/module.h>
+
+#define DRV_VERSION "0.1"
+
+static uint64_t dce_ccsr_start;
+static uint64_t dce_ccsr_size;
+
+/* takes userspace input and converts to upper case */
+static int user_input_convert(const char __user *user_buf, size_t count,
+				unsigned long *val)
+{
+	char buf[12];
+
+	if (count > sizeof(buf) - 1)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	buf[count] = '\0';
+	if (kstrtoul(buf, 0, val))
+		return -EINVAL;
+	return 0;
+}
+
+static struct dentry *dfs_root; /* debugfs root directory */
+
+struct dce_register_s {
+	uint32_t val;
+};
+static struct dce_register_s dce_register_data;
+
+static int init_ccsrmempeek(void)
+{
+	struct device_node *dn;
+	const uint32_t *regaddr_p;
+
+	dn = of_find_compatible_node(NULL, NULL, "fsl,dce");
+	if (!dn) {
+		pr_info("No fsl,dce node\n");
+		return -ENODEV;
+	}
+	regaddr_p = of_get_address(dn, 0, &dce_ccsr_size, NULL);
+	if (!regaddr_p) {
+		of_node_put(dn);
+		return -EINVAL;
+	}
+	dce_ccsr_start = of_translate_address(dn, regaddr_p);
+	of_node_put(dn);
+	return 0;
+}
+
+/* This function provides access to DCE ccsr memory map */
+static int dce_ccsrmem_get(uint32_t *val, uint32_t offset)
+{
+	void __iomem *addr;
+	uint64_t phys_addr;
+
+	if (!dce_ccsr_start)
+		return -EINVAL;
+
+	if (offset > (dce_ccsr_size - sizeof(uint32_t)))
+		return -EINVAL;
+
+	phys_addr = dce_ccsr_start + offset;
+	addr = ioremap(phys_addr, sizeof(uint32_t));
+	if (!addr) {
+		pr_err("ccsrmem, ioremap failed\n");
+		return -EINVAL;
+	}
+	*val = in_be32(addr);
+	iounmap(addr);
+	return 0;
+}
+
+static int dce_ccsrmem_put(uint32_t val, uint32_t offset)
+{
+	void __iomem *addr;
+	uint64_t phys_addr;
+
+	if (!dce_ccsr_start)
+		return -EINVAL;
+
+	if (offset > (dce_ccsr_size - sizeof(uint32_t)))
+		return -EINVAL;
+
+	phys_addr = dce_ccsr_start + offset;
+	addr = ioremap(phys_addr, sizeof(uint32_t));
+	if (!addr) {
+		pr_err("ccsrmem, ioremap failed\n");
+		return -EINVAL;
+	}
+	iowrite32be(val, addr);
+	iounmap(addr);
+	return 0;
+}
+
+
+static int dce_ccsrmem_addr_show(struct seq_file *file, void *offset)
+{
+	seq_printf(file, "DCE register offset = 0x%x\n",
+		   dce_register_data.val);
+	return 0;
+}
+
+static int dce_ccsrmem_addr_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dce_ccsrmem_addr_show, NULL);
+}
+
+static ssize_t dce_ccsrmem_addr_write(struct file *f, const char __user *buf,
+				size_t count, loff_t *off)
+{
+	int ret;
+	unsigned long val;
+
+	ret = user_input_convert(buf, count, &val);
+	if (ret)
+		return ret;
+	/* multiple of 4 */
+	if (val > (dce_ccsr_size - sizeof(uint32_t))) {
+		pr_info("Input 0x%lx > 0x%llx\n",
+			val, (dce_ccsr_size - sizeof(uint32_t)));
+		return -EINVAL;
+	}
+	if (val & 0x3) {
+		pr_info("Input 0x%lx not multiple of 4\n", val);
+		return -EINVAL;
+	}
+	dce_register_data.val = val;
+	return count;
+}
+
+static const struct file_operations dce_ccsrmem_addr_fops = {
+	.owner          = THIS_MODULE,
+	.open		= dce_ccsrmem_addr_open,
+	.read           = seq_read,
+	.write		= dce_ccsrmem_addr_write,
+};
+
+
+static int dce_ccsrmem_rw_show(struct seq_file *file, void *offset)
+{
+	uint32_t out_val = 0;
+	int ret;
+
+	ret = dce_ccsrmem_get(&out_val, dce_register_data.val);
+	if (ret)
+		return ret;
+	seq_printf(file, "DCE register offset = 0x%x\n",
+		   dce_register_data.val);
+	seq_printf(file, "value = 0x%08x\n", out_val);
+
+	return 0;
+}
+
+static int dce_ccsrmem_rw_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, dce_ccsrmem_rw_show, NULL);
+}
+
+static ssize_t dce_ccsrmem_rw_write(struct file *f, const char __user *buf,
+				size_t count, loff_t *off)
+{
+	int ret;
+	unsigned long val;
+
+	ret = user_input_convert(buf, count, &val);
+	if (ret)
+		return ret;
+
+	ret = dce_ccsrmem_put(val, dce_register_data.val);
+
+	if (ret)
+		return ret;
+
+	return count;
+}
+
+static const struct file_operations dce_ccsrmem_rw_fops = {
+	.owner          = THIS_MODULE,
+	.open		= dce_ccsrmem_rw_open,
+	.read           = seq_read,
+	.write		= dce_ccsrmem_rw_write,
+};
+
+#define DCE_DBGFS_ENTRY(name, mode, parent, data, fops) \
+	do { \
+		d = debugfs_create_file(name, \
+			mode, parent, \
+			data, \
+			fops); \
+		if (d == NULL) { \
+			ret = -ENOMEM; \
+		} \
+	} while (0)
+
+/* dfs_root as parent */
+#define DCE_DBGFS_ENTRY_ROOT(name, mode, data, fops) \
+	DCE_DBGFS_ENTRY(name, mode, dfs_root, data, fops)
+
+static int __init dce_debugfs_module_init(void)
+{
+	int ret = 0;
+	struct dentry *d;
+
+	ret = init_ccsrmempeek();
+	if (ret)
+		goto fail_init;
+	dfs_root = debugfs_create_dir("dce", NULL);
+	if (dfs_root == NULL) {
+		ret = -ENOMEM;
+		pr_err("Cannot create dce debugfs dir\n");
+		goto fail_dce_dir;
+	}
+
+	DCE_DBGFS_ENTRY_ROOT("ccsrmem_addr", S_IRUGO | S_IWUGO,
+			NULL, &dce_ccsrmem_addr_fops);
+	if (ret)
+		goto fail_dce_dir;
+
+	DCE_DBGFS_ENTRY_ROOT("ccsrmem_rw", S_IRUGO | S_IWUGO,
+			NULL, &dce_ccsrmem_rw_fops);
+	if (ret)
+		goto fail_dce_dir;
+
+	return 0;
+
+fail_dce_dir:
+	debugfs_remove_recursive(dfs_root);
+fail_init:
+	return ret;
+}
+
+static void __exit dce_debugfs_module_exit(void)
+{
+	debugfs_remove_recursive(dfs_root);
+}
+
+module_init(dce_debugfs_module_init);
+module_exit(dce_debugfs_module_exit);
+
+MODULE_AUTHOR("Jeffrey Ladouceur");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FSL DCE debugfs accessr");
+MODULE_VERSION(DRV_VERSION);
+
diff --git a/drivers/staging/fsl_dce/dce_driver.c b/drivers/staging/fsl_dce/dce_driver.c
new file mode 100644
index 0000000..3901f91
--- /dev/null
+++ b/drivers/staging/fsl_dce/dce_driver.c
@@ -0,0 +1,345 @@
+/* Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+#include <linux/of_platform.h>
+#include <linux/kernel.h>
+#include <linux/debugfs.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include "fsl_dce.h"
+#include "flib/dce_regs.h"
+#include "flib/dce_defs.h"
+
+#define DRV_VERSION "0.1"
+
+uint16_t dce_ip_rev = DCE_REV10;
+EXPORT_SYMBOL(dce_ip_rev);
+
+/* Pointer used to represent the DCE CCSR map and its instance */
+static struct dce_regs *global_dce_regs;
+
+/*
+ * Driver-private storage for a single DCE block instance
+ */
+struct dce_drv_private {
+	struct device *dev;
+	struct platform_device *pdev;
+
+	/* Physical-presence section */
+	struct dce_regs __iomem *topregs;
+	int err_irq;		/* Error interrupt number */
+};
+
+/* Simple DCE error interrupt handler */
+static irqreturn_t dce_isr(int irq, void *st_dev)
+{
+	struct device *dev = st_dev;
+	struct dce_drv_private *ctrlpriv = dev_get_drvdata(dev);
+	static uint32_t last_isrstate;
+	uint32_t isrstate = ioread32be(&ctrlpriv->topregs->isr) ^ last_isrstate;
+
+	/* What new ISR state has been raise */
+	if (!isrstate)
+		return IRQ_NONE;
+	if (ISEQ_32FTK(isrstate, DCE_ISR_SBE, AT_LEAST_ONE))
+		dev_err(dev, "Single Bit Error detected\n");
+	if (ISEQ_32FTK(isrstate, DCE_ISR_DBE, AT_LEAST_ONE))
+		dev_err(dev, "Double Bit Error detected\n");
+	if (ISEQ_32FTK(isrstate, DCE_ISR_UWE, AT_LEAST_ONE)) {
+		uint32_t uwe_high, uwe_low;
+
+		/* print extra info registers */
+		uwe_high = ioread32be(&ctrlpriv->topregs->uwe_info_h);
+		uwe_low = ioread32be(&ctrlpriv->topregs->uwe_info_l);
+		dev_err(dev,
+		 "Unreported Write Error detected: infoh = 0x%x infol = 0x%x\n",
+			uwe_high, uwe_low);
+	}
+
+	/* Clear the ier interrupt bit */
+	last_isrstate |= isrstate;
+	iowrite32be(~last_isrstate, &ctrlpriv->topregs->ier);
+
+	return IRQ_HANDLED;
+}
+
+static int fsl_dce_remove(struct platform_device *pdev)
+{
+	struct device *ctrldev;
+	struct dce_drv_private *ctrlpriv;
+	struct dce_regs __iomem *topregs;
+	int ret = 0;
+
+	ctrldev = &pdev->dev;
+	ctrlpriv = dev_get_drvdata(ctrldev);
+	topregs = ctrlpriv->topregs;
+
+	/* Disable dce */
+	iowrite32be(DCE_CFG_EN_DISABLE, &topregs->cfg);
+
+	/* Release interrupt */
+	free_irq(ctrlpriv->err_irq, ctrldev);
+
+	/* Unmap controller region */
+	iounmap(topregs);
+	kfree(ctrlpriv);
+	global_dce_regs = NULL;
+
+	dev_info(&pdev->dev, "device full name %s removed\n",
+		pdev->dev.of_node->full_name);
+	return ret;
+}
+
+static int fsl_dce_probe(struct platform_device *pdev)
+{
+	int err;
+	struct device *dev;
+	struct device_node *nprop = NULL;
+	struct dce_regs __iomem *topregs;
+	struct dce_drv_private *ctrlpriv;
+	const char *s;
+	int ret;
+
+	/*
+	 * TODO: This standby handling won't work properly after failover, it's
+	 * just to allow bring up for now.
+	 */
+	s = of_get_property(nprop, "fsl,hv-claimable", &ret);
+	if (s && !strcmp(s, "standby"))
+		return 0;
+
+	ctrlpriv = kzalloc(sizeof(struct dce_drv_private), GFP_KERNEL);
+	if (!ctrlpriv)
+		return -ENOMEM;
+
+	dev = &pdev->dev;
+	dev_set_drvdata(dev, ctrlpriv);
+	ctrlpriv->pdev = pdev;
+	nprop = pdev->dev.of_node;
+
+	/* Get configuration properties from device tree */
+
+	/* First, get register page */
+	topregs = of_iomap(nprop, 0);
+	if (topregs == NULL) {
+		dev_err(dev, "of_iomap() failed\n");
+		err = -ENOMEM;
+		goto out_free_ctrlpriv;
+	}
+	ctrlpriv->topregs = topregs;
+	global_dce_regs = topregs;
+
+	/* Get the IRQ of the error interrupt */
+	ctrlpriv->err_irq = of_irq_to_resource(nprop, 0, NULL);
+	if (!ctrlpriv->err_irq) {
+		dev_warn(dev, "Can't get %s property '%s'\n", nprop->full_name,
+			 "interrupts");
+	} else {
+		/* Register the dce ISR handler */
+		err = request_irq(ctrlpriv->err_irq, dce_isr, IRQF_SHARED,
+					"dce-err", dev);
+		if (err) {
+			dev_err(dev, "request_irq() failed\n");
+			goto out_free_ctrlpriv;
+		}
+	}
+
+	/*
+	 * Set System Memory Cache Attribute Control Register. Set all
+	 * transactions to coherent.
+	 */
+	iowrite32be(
+		(FL_FGENTK(DCE_SMCACR_CHWC, COHERENT) |
+		FL_FGENTK(DCE_SMCACR_SCWC, COHERENT) |
+		FL_FGENTK(DCE_SMCACR_FDWC, COHERENT) |
+		FL_FGENTK(DCE_SMCACR_DHWC, COHERENT) |
+		FL_FGENTK(DCE_SMCACR_CHRC, COHERENT) |
+		FL_FGENTK(DCE_SMCACR_SCRC, COHERENT) |
+		FL_FGENTK(DCE_SMCACR_FDRC, COHERENT) |
+		FL_FGENTK(DCE_SMCACR_DHRC, COHERENT)),
+		&topregs->smcacr);
+
+	/* Enable interrupts */
+	/*iowrite32be(DCE_IER_ALL, &topregs->ier);*/
+	iowrite32be(FL_FGENTK(DCE_IER_ALL, ENABLE), &topregs->ier);
+
+	/* Enable dce */
+	iowrite32be(FL_FGENTK(DCE_CFG_EN, ENABLE), &topregs->cfg);
+
+	dev_info(&pdev->dev, "Device %s initialized ver: 0x%08x\n\n",
+		pdev->dev.of_node->full_name, ioread32be(&topregs->ip_rev_1));
+
+	return 0;
+
+out_free_ctrlpriv:
+	kfree(ctrlpriv);
+	dev_set_drvdata(dev, NULL);
+	global_dce_regs = NULL;
+	return err;
+}
+
+static struct of_device_id fsl_dce_match[] = {
+	{
+		.compatible = "fsl,dce",
+	},
+	{}
+};
+MODULE_DEVICE_TABLE(of, fsl_dce_match);
+
+static struct platform_driver fsl_dce_driver = {
+	.driver = {
+		.name = "fsl-dce",
+		.owner = THIS_MODULE,
+		.of_match_table = fsl_dce_match,
+	},
+	.probe		= fsl_dce_probe,
+	.remove		= fsl_dce_remove,
+};
+
+static int __init fsl_dce_init(void)
+{
+	int ret;
+
+	ret = platform_driver_register(&fsl_dce_driver);
+	if (ret)
+		pr_err("fsl-dce: Failed to register platform driver\n");
+
+	return ret;
+}
+
+static void __exit fsl_dce_exit(void)
+{
+	platform_driver_unregister(&fsl_dce_driver);
+}
+
+module_init(fsl_dce_init);
+module_exit(fsl_dce_exit);
+
+MODULE_AUTHOR("Jeffrey Ladouceur");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FSL DCE driver");
+MODULE_VERSION(DRV_VERSION);
+
+/*
+ * These APIs are the only functional hooks into the control driver, besides the
+ * sysfs attributes.
+ */
+
+int fsl_dce_have_control(void)
+{
+	return global_dce_regs ? 1 : 0;
+}
+EXPORT_SYMBOL(fsl_dce_have_control);
+
+int fsl_dce_get_stat(enum fsl_dce_stat_attr attr, uint64_t *val, int reset)
+{
+	if (!fsl_dce_have_control())
+		return -ENODEV;
+
+	switch (attr) {
+	case DCE_COMP_INPUT_BYTES:
+		*val = ioread32be(&global_dce_regs->cibc_h);
+		*val <<= 32;
+		*val |= ioread32be(&global_dce_regs->cibc_l);
+		if (reset) {
+			iowrite32be(0, &global_dce_regs->cibc_l);
+			iowrite32be(0, &global_dce_regs->cibc_h);
+		}
+		break;
+	case DCE_COMP_OUTPUT_BYTES:
+		*val = ioread32be(&global_dce_regs->cobc_h);
+		*val <<= 32;
+		*val |= ioread32be(&global_dce_regs->cobc_l);
+		if (reset) {
+			iowrite32be(0, &global_dce_regs->cobc_l);
+			iowrite32be(0, &global_dce_regs->cobc_h);
+		}
+		break;
+	case DCE_DECOMP_INPUT_BYTES:
+		*val = ioread32be(&global_dce_regs->dibc_h);
+		*val <<= 32;
+		*val |= ioread32be(&global_dce_regs->dibc_l);
+		if (reset) {
+			iowrite32be(0, &global_dce_regs->dibc_l);
+			iowrite32be(0, &global_dce_regs->dibc_h);
+		}
+		break;
+	case DCE_DECOMP_OUTPUT_BYTES:
+		*val = ioread32be(&global_dce_regs->dobc_h);
+		*val <<= 32;
+		*val |= ioread32be(&global_dce_regs->dobc_l);
+		if (reset) {
+			iowrite32be(0, &global_dce_regs->dobc_l);
+			iowrite32be(0, &global_dce_regs->dobc_h);
+		}
+		break;
+	default:
+		pr_err("fsl_dce: Unknown attr %u\n", attr);
+		return -EINVAL;
+	};
+	return 0;
+}
+EXPORT_SYMBOL(fsl_dce_get_stat);
+
+int fsl_dce_clear_stat(enum fsl_dce_stat_attr attr)
+{
+	if (!fsl_dce_have_control())
+		return -ENODEV;
+
+	switch (attr) {
+	case DCE_COMP_INPUT_BYTES:
+		iowrite32be(0, &global_dce_regs->cibc_l);
+		iowrite32be(0, &global_dce_regs->cibc_h);
+		break;
+	case DCE_COMP_OUTPUT_BYTES:
+		iowrite32be(0, &global_dce_regs->cobc_l);
+		iowrite32be(0, &global_dce_regs->cobc_h);
+		break;
+	case DCE_DECOMP_INPUT_BYTES:
+		iowrite32be(0, &global_dce_regs->dibc_l);
+		iowrite32be(0, &global_dce_regs->dibc_h);
+		break;
+	case DCE_DECOMP_OUTPUT_BYTES:
+		iowrite32be(0, &global_dce_regs->dobc_l);
+		iowrite32be(0, &global_dce_regs->dobc_h);
+		break;
+	default:
+		pr_err("fsl_dce: Unknown attr %u\n", attr);
+		return -EINVAL;
+	};
+	return 0;
+}
+EXPORT_SYMBOL(fsl_dce_clear_stat);
+
+
diff --git a/drivers/staging/fsl_dce/dce_sys.c b/drivers/staging/fsl_dce/dce_sys.c
new file mode 100644
index 0000000..29ad636
--- /dev/null
+++ b/drivers/staging/fsl_dce/dce_sys.c
@@ -0,0 +1,273 @@
+/* Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+#include <linux/module.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#include "flib/dce_defs.h"
+
+#define DRV_VERSION "0.1"
+
+MODULE_AUTHOR("Jeffrey Ladouceur");
+MODULE_LICENSE("Dual BSD/GPL");
+MODULE_DESCRIPTION("FSL DCE device usage");
+MODULE_VERSION(DRV_VERSION);
+
+static struct kmem_cache *slab_scr_64b;
+static struct kmem_cache *slab_scr_128b;
+static struct kmem_cache *slab_compress_history;
+static struct kmem_cache *slab_decompress_history;
+static struct kmem_cache *slab_pending_output;
+static struct kmem_cache *slab_decomp_ctxt;
+
+/*
+ * DCE hw dma memory requirements for stateful mode
+ *	compression:
+ *		scr: 64B size, 64B aligned
+ *		history: 4096B size, 64B aligned
+ *		pending_output: 8202B, 64B aligned optimal, recycle mode only.
+ *
+ *	decompression:
+ *		scr: 128B size, 64B aligned
+ *		history: 32768b, 64b aligned
+ *		pending_output: 8256b, 64b aligned optimal, recycle mode only
+ *		decomp_ctx: 256b, 64b aligned optimal
+ */
+
+/* Hack to support "dce_map()". The point of this is that dma_map_single() now
+ * requires a non-NULL device, so the idea is that address mapping must be
+ * device-sensitive. Now the PAMU IO-MMU already takes care of this, as can be
+ * seen by the device-tree structure generated by the hypervisor (each portal
+ * node has sub-nodes for each h/w end-point it provides access to, and each
+ * sub-node has its own LIODN configuration). So we just need to map cpu
+ * pointers to (guest-)physical address and the PAMU takes care of the rest, so
+ * this doesn't need to be portal-sensitive nor device-sensitive. */
+static struct platform_device *pdev;
+
+static int dce_sys_init(void)
+{
+	int ret = -ENOMEM;
+
+	slab_scr_64b = kmem_cache_create("fsl_dce_scr_64b",
+			sizeof(struct scf_64b), /* 64 byte size */
+			DCE_SCR_ALIGN, SLAB_HWCACHE_ALIGN, NULL);
+	if (!slab_scr_64b)
+		goto end;
+
+	slab_scr_128b = kmem_cache_create("fsl_dce_scr_128b",
+			sizeof(struct scf_128b), /* 128 byte size */
+			DCE_SCR_ALIGN, SLAB_HWCACHE_ALIGN, NULL);
+	if (!slab_scr_64b)
+		goto end;
+	slab_compress_history = kmem_cache_create("fsl_dce_compress_history",
+			DCE_COMP_HISTORY_SIZE,
+			DCE_COMP_HISTORY_ALIGN, SLAB_HWCACHE_ALIGN, NULL);
+	if (!slab_compress_history)
+		goto end;
+	slab_decompress_history = kmem_cache_create(
+			"fsl_dce_decompress_history",
+			DCE_DECOMP_HISTORY_SIZE,
+			DCE_DECOMP_HISTORY_ALIGN, SLAB_HWCACHE_ALIGN, NULL);
+	if (!slab_decompress_history)
+		goto end;
+	slab_pending_output = kmem_cache_create("fsl_dce_pending_output",
+			DCE_PENDING_OUTPUT_SIZE, /* 8256 size */
+			DCE_PENDING_OUTPUT_ALIGN, SLAB_HWCACHE_ALIGN, NULL);
+	if (!slab_pending_output)
+		goto end;
+	slab_decomp_ctxt = kmem_cache_create("fsl_dce_decomp_ctxt",
+			DCE_DECOMP_CTXT_SIZE, /* 256 bytes */
+			DCE_DECOMP_CTXT_ALIGN, SLAB_HWCACHE_ALIGN, NULL);
+	if (!slab_decomp_ctxt)
+		goto end;
+
+	pdev = platform_device_alloc("dce", -1);
+	if (!pdev)
+		goto end;
+	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(40)))
+		goto end;
+	if (platform_device_add(pdev))
+		goto end;
+
+	pr_info("dce_sys_init done!\n");
+	return 0;
+end:
+	if (pdev) {
+		platform_device_put(pdev);
+		pdev = NULL;
+	}
+	if (slab_scr_64b) {
+		kmem_cache_destroy(slab_scr_64b);
+		slab_scr_64b = NULL;
+	}
+	if (slab_scr_128b) {
+		kmem_cache_destroy(slab_scr_128b);
+		slab_scr_128b = NULL;
+	}
+	if (slab_compress_history) {
+		kmem_cache_destroy(slab_compress_history);
+		slab_compress_history = NULL;
+	}
+	if (slab_decompress_history) {
+		kmem_cache_destroy(slab_decompress_history);
+		slab_decompress_history = NULL;
+	}
+	if (slab_pending_output) {
+		kmem_cache_destroy(slab_pending_output);
+		slab_pending_output = NULL;
+	}
+	if (slab_decomp_ctxt) {
+		kmem_cache_destroy(slab_decomp_ctxt);
+		slab_decomp_ctxt = NULL;
+	}
+	pr_err("DCE: dce_sys_init failed\n");
+	return ret;
+}
+
+static void dce_sys_exit(void)
+{
+	platform_device_del(pdev);
+	platform_device_put(pdev);
+	pdev = NULL;
+	kmem_cache_destroy(slab_scr_64b);
+	kmem_cache_destroy(slab_scr_128b);
+	kmem_cache_destroy(slab_compress_history);
+	kmem_cache_destroy(slab_decompress_history);
+	kmem_cache_destroy(slab_pending_output);
+	kmem_cache_destroy(slab_decomp_ctxt);
+}
+
+module_init(dce_sys_init);
+module_exit(dce_sys_exit);
+
+/**************************/
+/* system level functions */
+/**************************/
+struct fsl_dce_hw_scr_64b *fsl_dce_hw_scr_64b_new(void)
+{
+	return kmem_cache_zalloc(slab_scr_64b, GFP_KERNEL);
+}
+EXPORT_SYMBOL(fsl_dce_hw_scr_64b_new);
+
+void fsl_dce_hw_scr_64b_free(struct fsl_dce_hw_scr_64b *p)
+{
+	kmem_cache_free(slab_scr_64b, p);
+}
+EXPORT_SYMBOL(fsl_dce_hw_scr_64b_free);
+
+struct fsl_dce_hw_scr_128b *fsl_dce_hw_scr_128b_new(void)
+{
+	return kmem_cache_zalloc(slab_scr_128b, GFP_KERNEL);
+}
+EXPORT_SYMBOL(fsl_dce_hw_scr_128b_new);
+
+void fsl_dce_hw_scr_128b_free(struct fsl_dce_hw_scr_128b *p)
+{
+	kmem_cache_free(slab_scr_128b, p);
+}
+EXPORT_SYMBOL(fsl_dce_hw_scr_128b_free);
+
+struct fsl_dce_hw_compress_history *fsl_dce_hw_compress_history_new(void)
+{
+	return kmem_cache_zalloc(slab_compress_history, GFP_KERNEL);
+}
+EXPORT_SYMBOL(fsl_dce_hw_compress_history_new);
+
+void fsl_dce_hw_compress_history_free(struct fsl_dce_hw_compress_history *p)
+{
+	kmem_cache_free(slab_compress_history, p);
+}
+EXPORT_SYMBOL(fsl_dce_hw_compress_history_free);
+
+struct fsl_dce_hw_decompress_history *fsl_dce_hw_decompress_history_new(void)
+{
+	return kmem_cache_zalloc(slab_decompress_history, GFP_KERNEL);
+}
+EXPORT_SYMBOL(fsl_dce_hw_decompress_history_new);
+
+void fsl_dce_hw_decompress_history_free(struct fsl_dce_hw_decompress_history *p)
+{
+	kmem_cache_free(slab_decompress_history, p);
+}
+EXPORT_SYMBOL(fsl_dce_hw_decompress_history_free);
+
+struct fsl_dce_hw_pending_output *fsl_dce_hw_pending_output_new(void)
+{
+	return kmem_cache_zalloc(slab_pending_output, GFP_KERNEL);
+}
+EXPORT_SYMBOL(fsl_dce_hw_pending_output_new);
+
+void fsl_dce_hw_pending_output_free(struct fsl_dce_hw_pending_output *p)
+{
+	kmem_cache_free(slab_pending_output, p);
+}
+EXPORT_SYMBOL(fsl_dce_hw_pending_output_free);
+
+struct fsl_dce_hw_decomp_ctxt *fsl_dce_hw_decomp_ctxt_new(void)
+{
+	return kmem_cache_zalloc(slab_decomp_ctxt, GFP_KERNEL);
+}
+EXPORT_SYMBOL(fsl_dce_hw_decomp_ctxt_new);
+
+void fsl_dce_hw_decomp_ctxt_free(struct fsl_dce_hw_decomp_ctxt *p)
+{
+	kmem_cache_free(slab_decomp_ctxt, p);
+}
+EXPORT_SYMBOL(fsl_dce_hw_decomp_ctxt_free);
+
+dma_addr_t fsl_dce_map(void *ptr)
+{
+	return dma_map_single(&pdev->dev, ptr, 1, DMA_BIDIRECTIONAL);
+}
+EXPORT_SYMBOL(fsl_dce_map);
+
+void fsl_dce_unmap(dma_addr_t handle)
+{
+	dma_unmap_single(&pdev->dev, handle, 1, DMA_BIDIRECTIONAL);
+}
+EXPORT_SYMBOL(fsl_dce_unmap);
+
+struct device *fsl_dce_get_device(void)
+{
+	if (!pdev)
+		return NULL;
+	return &pdev->dev;
+}
+EXPORT_SYMBOL(fsl_dce_get_device);
+
+int fsl_dce_map_error(dma_addr_t dma_addr)
+{
+	return dma_mapping_error(&pdev->dev, dma_addr);
+}
+EXPORT_SYMBOL(fsl_dce_map_error);
+
diff --git a/drivers/staging/fsl_dce/dce_sys.h b/drivers/staging/fsl_dce/dce_sys.h
new file mode 100644
index 0000000..b3ef730
--- /dev/null
+++ b/drivers/staging/fsl_dce/dce_sys.h
@@ -0,0 +1,68 @@
+/* Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+#ifndef DCE_SYS_H
+#define DCE_SYS_H
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/bootmem.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/of_platform.h>
+#include <linux/kthread.h>
+#include <linux/memblock.h>
+#include <linux/completion.h>
+#include <linux/log2.h>
+#include <linux/types.h>
+#include <linux/ioctl.h>
+#include <linux/miscdevice.h>
+#include <linux/uaccess.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include <linux/device.h>
+#include <linux/uio_driver.h>
+#include <linux/smp.h>
+#include <sysdev/fsl_soc.h>
+#include <linux/fsl_hypervisor.h>
+#include <linux/fsl_bman.h>
+
+dma_addr_t fsl_dce_map(void *ptr);
+void fsl_dce_unmap(dma_addr_t handle);
+int fsl_dce_map_error(dma_addr_t dma_addr);
+struct device *fsl_dce_get_device(void);
+
+#endif
diff --git a/drivers/staging/fsl_dce/flib/bitfield_macros.h b/drivers/staging/fsl_dce/flib/bitfield_macros.h
new file mode 100644
index 0000000..0a52bf1
--- /dev/null
+++ b/drivers/staging/fsl_dce/flib/bitfield_macros.h
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ */
+
+#ifndef FL_BITFIELD_MACROS_H
+#define FL_BITFIELD_MACROS_H
+
+/*
+ *  macro to generate a field. This field can be part of a register or other
+ *  defined structure
+ */
+#define FL_FGEN(field, value) \
+	(((value) << field##_SHIFT) & field##_MASK)
+
+/* macro which generates field based on a token value */
+#define FL_FGENTK(field, token) \
+	FL_FGEN(field, field##_##token)
+
+/**
+ * SET_BFXX(v, m, x) - Returns the result of setting value [x] into bit
+ * field [m] of value [v]
+ *
+ * [m] identifies the bit field and it is assumed that there exists
+ * two macros: m_MASK and m_SHIFT. The former contains the bit mask;
+ * the latter contains the number of least-significant zero bits in
+ * the mask.
+ * XX idenfies the width of the value and destination
+ *
+ * _IDX is a variant where a this idenfies an index into a array. The
+ * macros expects a define of field_XXIDX to be defined where XX is inline
+ * with the XX type (8, 16, 32, 64). This is useful when using dma stuctures.
+ */
+#define SET_BF64(dest, field, value)	\
+	(dest = \
+	((dest & ~field##_MASK) | (((uint64_t)value << field##_SHIFT) & \
+					field##_MASK)))
+
+#define SET_BF64_IDX(dest, field, value)	\
+	((*(dest+field##_64IDX)) = \
+	(((*(dest+field##_64IDX)) & ~field##_MASK) | \
+			(((value) << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF64_TK(dest, field, token)	\
+	(dest = \
+	((dest & ~field##_MASK) | ((field##_##token << field##_SHIFT) & \
+					field##_MASK)))
+
+#define SET_BF64_TK_IDX(dest, field, token)	\
+	((*(dest+field##_64IDX)) = \
+	(((*(dest+field##_64IDX)) & ~field##_MASK) | \
+			((field##_##token << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF32(dest, field, value) \
+	(dest = \
+	((dest & ~field##_MASK) | ((value << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF32_IDX(dest, field, value) \
+	((*(dest+field##_32IDX)) = \
+	(((*(dest+field##_32IDX)) & ~field##_MASK) | \
+			((value << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF32_TK(dest, field, token)	\
+	(dest = \
+	((dest & ~field##_MASK) | ((field##_##token << field##_SHIFT) & \
+			field##_MASK)))
+
+#define SET_BF32_TK_IDX(dest, field, token)	\
+	((*(dest+field##_32IDX)) = \
+	(((*(dest+field##_32IDX)) & ~field##_MASK) | \
+			((field##_##token << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF16(dest, field, value)	\
+	(dest = \
+	((dest & ~field##_MASK) | ((value << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF16_IDX(dest, field, value)	\
+	((*(dest+field##_16IDX)) = \
+	(((*(dest+field##_16IDX)) & ~field##_MASK) | \
+			((value << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF16_TK(dest, field, token)	\
+	(dest = \
+	((dest & ~field##_MASK) | ((field##_##token << field##_SHIFT) & \
+			field##_MASK)))
+
+#define SET_BF16_TK_IDX(dest, field, token)	\
+	((*(dest+field##_16IDX)) = \
+	(((*(dest+field##_16IDX)) & ~field##_MASK) | \
+			((field##_##token << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF8(dest, field, value)	\
+	(dest = \
+	((dest & ~field##_MASK) | ((value << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF8_IDX(dest, field, value)	\
+	((*(dest+field##_8IDX)) = \
+	(((*(dest+field##_8IDX)) & ~field##_MASK) | \
+			((value << field##_SHIFT) & field##_MASK)))
+
+#define SET_BF8_TK(dest, field, token)	\
+	(dest = \
+	((dest & ~field##_MASK) | ((field##_##token << field##_SHIFT) & \
+			field##_MASK)))
+
+#define SET_BF8_TK_IDX(dest, field, token)	\
+	((*(dest+field##_8IDX)) = \
+	(((*(dest+field##_8IDX)) & ~field##_MASK) | \
+			((field##_##token << field##_SHIFT) & field##_MASK)))
+
+/**
+ * GET_BF(v, m) - Gets the value in bit field [m] of expression [v]
+ *
+ * [m] identifies the bit field and it is assumed that there exists
+ * two macros: m_MASK and m_SHIFT. The former contains the bit mask;
+ * the latter contains the number of least-significant zero bits in
+ * the mask.
+ */
+#define GET_BF64(source, field)	\
+	((source & field##_MASK) >> field##_SHIFT)
+
+#define GET_BF64_IDX(source, field) \
+	(((*(source+field##_64IDX)) & field##_MASK) >> field##_SHIFT)
+
+#define GET_BF32(source, field)	\
+	((source & field##_MASK) >> field##_SHIFT)
+
+#define GET_BF32_IDX(source, field) \
+	(((*(source+field##_32IDX)) & field##_MASK) >> field##_SHIFT)
+
+#define GET_BF16(source, field)	\
+	((source & field##_MASK) >> field##_SHIFT)
+
+#define GET_BF16_IDX(source, field) \
+	(((*(source+field##_16IDX)) & field##_MASK) >> field##_SHIFT)
+
+#define GET_BF8(source, field)	\
+	((source & field##_MASK) >> field##_SHIFT)
+
+#define GET_BF8_IDX(source, field) \
+	(((*(source+field##_8IDX)) & field##_MASK) >> field##_SHIFT)
+
+/* Register field is-equal based on token (enum) */
+#define ISEQ_32FTK(source, reg_field, token) \
+	(GET_BF32((source), reg_field) == reg_field##_##token)
+
+#endif		/* FL_BITFIELD_MACROS */
diff --git a/drivers/staging/fsl_dce/flib/dce_defs.h b/drivers/staging/fsl_dce/flib/dce_defs.h
new file mode 100644
index 0000000..7ccb69d
--- /dev/null
+++ b/drivers/staging/fsl_dce/flib/dce_defs.h
@@ -0,0 +1,1924 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ */
+
+#ifndef FL_DCE_DEFS_H
+#define FL_DCE_DEFS_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#include <stdbool.h>
+#endif
+
+#include "bitfield_macros.h"
+
+/*
+ * Some interfaces depend on the revision of the DCE HW block. An external
+ * dependency has been added which requires this external variable to be
+ * set accordingly. If the variable is not set, the interfaces will behave
+ * as if the revision is DCE_DEFAULT_REV.
+ */
+extern uint16_t dce_ip_rev;
+#define DCE_REV10	0x0100
+#define DCE_REV11	0x0101
+#define DCE_DEFAULT_REV	DCE_REV10
+
+/*
+ * QMan defines the dedicated channels serviced by the DCE engine. The first
+ * channel is serviced by compression engine while the second channel is
+ * is serviced by the decompression engine.
+ */
+#define DCE_COMPRESSION_CHANNEL_OFFSET		0
+#define DCE_DECOMPRESSION_CHANNEL_OFFSET	1
+
+/**
+ * struct dce_context_a - context_a field of the qm_fqd for rx frame queue. The
+ *	rx frame queue is in the sw portal to dce hw direction.
+ *
+ * @d64: contains mask of following values:
+ *
+ * TSIZE: size of BMan buffers used to create s/g tables, each table entry
+ *	being 16 bytes in size.
+ * DEXP: Specifies the exponent part of BMan buffer size used to output data
+ *	using DBPID. All values (0x0 to 0xF) are valid. A coding of 0x0 is
+ *	treated as 0x10, so exponent values 1 to 16 are possible.
+ * DMANT: Specifies the mantissa part of BMan buffer size used to output data
+ *	using DBPID. All values (0x0 to 0xF) are valid. A coding of 0x0 is
+ *	treated as 0x10, so mantissa values 1 to 16 are possible.
+ * TBPID: Indicates which BMan buffer pool is to be used to create
+ *	scatter/gather tables. Typically this will indicate a pool of buffers
+ *	that are smaller in size than the buffers used to store Frame data.
+ * SCRP: The upper bits of a 40-bit memory pointer to the SCR
+ *	The lower bits are presumed to be 0 as the record must be device
+ *	virtual address aligned on a 64B address boundary in system memory.
+ */
+struct dce_context_a {
+	uint64_t d64;
+/* TSIZE */
+#define DCE_CONTEXT_A_TSIZE_SHIFT	60
+#define DCE_CONTEXT_A_TSIZE_MASK	(0x7ULL << DCE_CONTEXT_A_TSIZE_SHIFT)
+
+/* DEXP */
+#define DCE_CONTEXT_A_DEXP_SHIFT	56
+#define DCE_CONTEXT_A_DEXP_MASK		(0xfULL << DCE_CONTEXT_A_DEXP_SHIFT)
+
+/* DMANT*/
+#define DCE_CONTEXT_A_DMANT_SHIFT	52
+#define DCE_CONTEXT_A_DMANT_MASK	(0xfULL << DCE_CONTEXT_A_DMANT_SHIFT)
+
+/* TBPID */
+#define DCE_CONTEXT_A_TBPID_SHIFT	40
+#define DCE_CONTEXT_A_TBPID_MASK	(0xffULL << DCE_CONTEXT_A_TBPID_SHIFT)
+
+/* SCRP */
+#define DCE_CONTEXT_A_SCRP_SHIFT	6
+#define DCE_CONTEXT_A_SCRP_MASK (0x3ffffffffULL << DCE_CONTEXT_A_SCRP_SHIFT)
+};
+
+/**
+ * dce_context_a_set_scrp - Set SCRP in context_a field
+ *
+ * @ctxa: a dce_context_a structure
+ * @val: Value to set the scrp field to.
+ */
+static inline void dce_context_a_set_scrp(struct dce_context_a *ctx_a,
+						uint64_t val)
+{
+	/* lower 6 bits expected to be zero, since 64 byte aligned */
+	SET_BF64(ctx_a->d64, DCE_CONTEXT_A_SCRP,
+		(val >> DCE_CONTEXT_A_SCRP_SHIFT));
+}
+
+/**
+ * dce_context_a_get_scrp - Get SCRP in context_a field
+ *
+ * @ctxa: a dce_context_a structure
+ */
+static inline uint64_t dce_context_a_get_scrp(struct dce_context_a *ctx_a)
+{
+	/* lower 6 bits expected to be zero, since 64 byte aligned */
+	return GET_BF64(ctx_a->d64, DCE_CONTEXT_A_SCRP) <<
+		DCE_CONTEXT_A_SCRP_SHIFT;
+}
+
+/**
+ * struct dce_context_b - context_b field of the qm_fqd for tx frame queue.
+ *	contains data buffer pool id and rx fq id. The tx frame queue is in the
+ *	dce hw -> sw portal direction.
+ *
+ * @d32: contains mask of following values:
+ *
+ * DBPID: Indicates which BMan pool is to be used to create data buffers
+ *	(not scatter/gather tables) in output Frames.
+ * FQID: DCE output Frames for this Frame Queue pair (Flow) are enqueued on
+ *	this FQID
+ */
+struct dce_context_b {
+	uint32_t d32;
+/* DBPID */
+#define DCE_CONTEXT_B_DBPID_SHIFT	24
+#define DCE_CONTEXT_B_DBPID_MASK	(0xffUL << DCE_CONTEXT_B_DBPID_SHIFT)
+
+/* FQID */
+#define DCE_CONTEXT_B_FQID_SHIFT	0
+#define DCE_CONTEXT_B_FQID_MASK		(0xffffffUL << DCE_CONTEXT_B_FQID_SHIFT)
+};
+
+/**
+ * struct dce_cmd - 32-bit frame descritor "cmd/status" field, sent to DCE
+ *
+ * @d32: mask of command and associated parameters. The bit fields depend
+ *	 on the value of the CMD.
+ *
+ *	The DCE_CMD_*** field identifies the command type.
+ *		@DCE_CMD_PROCESS: invokes DCE's misison mode operation. It
+ *			indicates to DCE hardware that the provided Frame is to
+ *			be processed according to the mode of its Frame Queue
+ *			channel (compression vs decompression) and the Frame's
+ *			associated Stream Context Record, and/or a Stream
+ *			Configuration Frame.
+ *		@DCE_CMD_CTX_INVALIDATE: provides a means to invalidate a cached
+ *			copy of a Stream Context Record in the DCE hardware.
+ *			Only application on stateful stream.
+ *		@DCE_CMD_NOP: a frame with this command travel through the DCE's
+ *			pipeline without causing any system memory accesses or
+ *			other side effects.
+ *
+ * Additiona fields depend on value of DCE_CMD_***
+ * -----------------------------------------
+ *  DCE_CMD_NOP		DCE_NOP_TOKEN
+ *				The token is not processed by the DCE and is
+ *				echoed back in the returned frame.
+ *
+ *  DCE_CMD_CTX_INVALIDATE	DCE_CIC_TOKEN
+ *					The token is not processed by the DCE
+ *					and is echoed back in the returned
+ *					Frame.
+ *
+ *  DCE_CMD_PROCESS	DCE_PROCESS_OO_***
+ *				Coded value specifying the number of unused
+ *				bytes to leave at the beginning of the first
+ *				buffer of the output Frame, if it is being
+ *				created out of BMan buffers. Note that software
+ *				must ensure that non-zero offset values remain
+ *				within the size of BMan buffers being used for
+ *				the flow. A value that is greater than or equal
+ *				to the buffer size will result in an Output
+ *				Offset Too Large exception.
+ *			DCE_PROCESS_Z_***
+ *				Support for zlib flush semantics
+ *
+ *				@DCE_PROCESS_Z_NO_FLUSH: Normal value for flush
+ *				@DCE_PROCESS_Z_PARTIAL_FLUSH: Pending output is
+ *					flushed, output not aligned.
+ *				@DCE_PROCESS_Z_SYNC_FLUSH: Pending output is
+ *					flushed, output is aligned.
+ *				@DCE_PROCESS_Z_FULL_FLUSH: All output is flushed
+ *					and state reset.
+ *				@DCE_PROCESS_Z_FINISH: All pending input is
+ *					processed and all output is flushed
+ *				@DCE_PROCESS_Z_BLOCK: A compressed block is
+ *					completed and emitted, as with
+ *					DCE_PROCESS_Z_SYNC_FLUSH, but the output
+ *					is not necessarily aligned on a byte
+ *					boundary, and up to 7 bits of the
+ *					current block are held to be written as
+ *					the next byte when the next DEFLATE
+ *					block is completed
+ *				@DCE_PROCESS_Z_TREES: For decompression, the
+ *					DCE_PROCESS_Z_TREES option behaves as
+ *					DCE_PROCESS_Z_BLOCK does, but also
+ *					returns after the end of each DEFLATE
+ *					block header before any data in the
+ *					block itself is	decoded, allowing the
+ *					caller to determine the length of the
+ *					DEFLATE	block header for later use in
+ *					random	access within a DEFLATE block.
+ *			DCE_PROCESS_SCRF
+ *				When set, forces DCE to flush the updated Stream
+ *				Context Record to system memory once the Frame
+ *				is processed. DCE also invalidates its internal
+ *				copy of the Stream Context Record so that it
+ *				must be read from system memory before
+ *				processing a subsequent Frame on the same
+ *				Stream. Note that this is independent of the
+ *				Frame data flushing behavior that is controlledi
+ *				by the DCE_Z_FLUSH field.
+ *			DCE_PROCESS_RECYCLED
+ *				Indicates that this Frame is being recycled to
+ *				DCE following a previous Output Blocked Suspend
+ *				or Acquire Data Buffer Denied Suspend exception.
+ *			DCE_PROCESS_INITIAL
+ *				When set, indicates that this Frame is
+ *				considered to be the first, and possibly only,
+ *				Frame of data in the Stream. DCE will disregard
+ *				any stale Frame data pointers and residue data
+ *				values in the Stream Context Record and
+ *				initialize the Stream Context Record prior to
+ *				processing the Frame(1). The following Stream
+ *				Context Record fields are initialized as
+ *				indicated:
+ *					TOTAL_IN, TOTAL_OUT, ADLER32 zeroed (2)
+ *					XO, NO, and CO zeroed
+ *					XLEN, NLEN, and CLEN zeroed
+ *						(decompression Flows only)
+ *					PENDING_OUTPUT_LEN zeroed
+ *					HISTORY_LEN zeroed
+ *					RBC zeroed
+ *					CRC16 zeroed
+ *					HUFFMAN_RBC zeroed
+ *					B64_RESIDUE_LEN zeroed
+ *					HEADER_REMAINING zeroed
+ *				Note that a set I bit does not have any effect
+ *				on the Stream Context Record if the Flow is
+ *				suspended. A frame received with I=1 on a
+ *				suspended flow will either be skipped or
+ *				treated as a recycled frame depending on the
+ *				value of the Frame’s R bit. On stateless Flows
+ *				this flag is ignored (DCE behaves as though I=1
+ *				for every Frame).
+ *
+ *				(1) Stream Context Record initialization does
+ *				not happen when an initial (I=1) Frame is
+ *				recycled (R=1) due to a previous exception, DCE
+ *				will continue processing of the Frame based on
+ *				existing context as it would for any recycled
+ *				Frame.  Further, an Initial Frame received on a
+ *				suspended flow that does not have its recycle
+ *				bit set (R=0) will be skipped (i.e.  an I=1
+ *				Frame does not clear the SUSP bit).
+ *
+ *				(2) Unless DCE_PROCESS_USDC is also set, in
+ *				which case the DCE_PROCESS_USDC function takes
+ *				precedence over the set DCE_PROCESS_INITIAL bit.
+ *			DCE_PROCESS_RB
+ *				Specifies that the input Frame buffers are to be
+ *				released to BMan once their data bytes have been
+ *				fully processed.
+ *			DCE_PROCESS_B64
+ *				Set to indicate that data in this Frame is to be
+ *				Base64 encoded following compression, or Base64
+ *				decoded prior to decompression.
+ *			DCE_PROCESS_CF_***
+ *				Specifies the data format to be used for
+ *				compressing this Frame (compression Flow) or the
+ *				format of the compressed data present in this
+ *				Frame (decompression Flow).
+ *				This field must remain consistent (keep the same
+ *				value) across multiple Frames (chunks) of a
+ *				single file within a stateful Flow.
+ *
+ *				@DCE_DEFLATE: Format is DEFLATE as defined in
+ *					RFC 1951
+ *				@DCE_ZLIB: Format is ZLIB as defined in RFC 1950
+ *				@DCE_GZIP: Format is GXIP as defined in RFC 1952
+ *			DCE_PROCESS_CE_***
+ *				Specifies the type of compression to be
+ *				performed on this Stream. This field is ignored
+ *				on decompress Flows.
+ *				This field must remain consistent (keep the same
+ *				value) across multiple Frames (chunks) of a
+ *				single file within a stateful Flow.
+ *
+ *				@DCE_CE_NONE: No compression
+ *				@DCE_CE_STATIC_HUFF_STRMATCH: Static Huffman
+ *					coding and string matching only
+ *				@DCE_CE_HUFF_ONLY: Huffman only (static or
+ *					dynamic, but no string matching).
+ *				@DCE_CE_BEST_POSSIBLE: Best possible compression
+ *					(static or dynamic Huffman coding may
+ *					result).
+ *			DCE_PROCESS_UHC
+ *				Update Header Context
+ *				On stateful Flows, instructs the DCE to update
+ *				the Flow’s Stream Context Record’s protocol
+ *				header fields with the values found in the
+ *				dequeued Frame’s Stream Configuration Frame.
+ *				DCE will update the following Stream Context
+ *				Record header fields:
+ *					ID1, ID2
+ *					CM
+ *					FLG
+ *					MTIME
+ *					XFL
+ *					OS
+ *					XLEN
+ *					NLEN
+ *					CLEN
+ *					EXTRA_LIMIT and EXTRA_PTR
+ *				Some or all of these context fields may not be
+ *				used depending on the DCE_PROCESS_CF field
+ *				setting in the individual Frames that arrive on
+ *				the Flow, but all are updated.  On stateless
+ *				Flows, this flag is ignored and the appropriate
+ *				values from the Stream Configuration Frame are
+ *				used unconditionally according to the
+ *				DCE_PROCESS_CF field.
+ *			DCE_PROCESS_USPC
+ *				Update Stream Processing Context. Instructs the
+ *				DCE to update the following Stream Context
+ *				Record fields with the values found in the
+ *				Stream Configuration Frame, or zero them as
+ *				indicated:
+ *					XO, NO, and CO zeroed
+ *					PENDING_OUTPUT_PTR updated
+ *					PENDING_OUTPUT_LEN zeroed
+ *					HISTORY_PTR updated, HISTORY_LEN zeroed
+ *					PMODE updated
+ *					SUSP zeroed
+ *					RBC zeroed
+ *					DECOMP_CTXT_PTR updated
+ *					CRC16 zeroed
+ *					HUFFMAN_RBC zeroed
+ *					B64_RESIDUE_LEN zeroed
+ *					HEADER_REMAINING zeroed.
+ *			DCE_PROCESS_USDC
+ *				Update Stream Data Context
+ *				Instructs the DCE to update the following fields
+ *				in the Stream Context Record with the value
+ *				found in the Stream Configuration Frame prior to
+ *				processing the dequeued Frame:
+ *					TOTAL_IN
+ *					TOTAL_OUT
+ *					ADLER32
+ *				This bit is included to maintain full zlib
+ *				compatibility such that Software is able to
+ *				update/modify the incremental total_in,
+ *				total_out, and adler32 values (in the z_stream
+ *				struct) between inflate() and deflate() calls.
+ *				This bit should normally be left unset.
+ *				Software should not normally need to modify the
+ *				incremental values in these fields between
+ *				Frames of a larger entity on a stateful Flow.
+ *			DCE_PROCESS_SCUS_***
+ *				Stream Configuration Update Select
+ *				This field specifies how the DCE performs
+ *				updates (writes) to the output Stream
+ *				Configuration Frame after processing the
+ *				dequeued Frame. SCUS settings only apply when
+ *				compound Frames containing a valid (non-null)
+ *				Stream Configuration Frame member are used.
+ *				The field has no effect for simple Frames or
+ *				compound Frames in which the Stream
+ *				Configuration Frame member is null.
+ *
+ *				@DCE_PROCESS_SCUS_NORMAL_MODE:
+ *					Stream Context Recor updated, Stream
+ *					Configuration Frame not	updated except
+ *					in cases of Output Blocked Suspend or
+ *					Acquire Data Buffer Denied Suspend
+ *					exceptions3. This is the expected
+ *					mission mode setting.
+ *				@DCE_PROCESS_SCUS_UPDATE:
+ *					Stream Context Record updated, Stream
+ *					Configuration Frame updated partially.
+ *					Note that captured header information
+ *					may be partial until the entire header
+ *					has been processed.
+ *				@DCE_SCUS_UPDATE_DEBUG:
+ *					Stream Context Record updated, Stream
+ *					Configuration Frame updated with a
+ *					Stream Context Record snapshot. This
+ *					setting exposes	Stream Context Record
+ *					updates by shadowing them in the Stream
+ *					Configuration Frame, enabling debug.
+
+ *			DCE_PROCESS_STATUS
+ *				This is of type enum dce_status. This value
+ *				is set on the output fd received from the DCE.
+ */
+struct dce_cmd {
+	uint32_t d32;
+/* Common to all commands */
+#define DCE_CMD_SHIFT		29
+#define DCE_CMD_MASK		(0x7UL << DCE_CMD_SHIFT)
+/* CMD Tokens */
+#define DCE_CMD_PROCESS		0x0UL
+#define DCE_CMD_CTX_INVALIDATE	0x4UL
+#define DCE_CMD_NOP		0x7UL
+
+/* NOP Input command */
+#define DCE_NOP_TOKEN_SHIFT	0
+#define DCE_NOP_TOKEN_MASK	(0x1fffffffUL << DCE_NOP_TOKEN_SHIFT)
+
+/* Context Invalidate Command Input command */
+#define DCE_CIC_TOKEN_SHIFT	0
+#define DCE_CIC_TOKEN_MASK	(0x1fffffffUL << DCE_CIC_TOKEN_SHIFT)
+
+/* Process Input command */
+/* Output Offset */
+#define DCE_PROCESS_OO_SHIFT		26
+#define DCE_PROCESS_OO_MASK		(0x7UL << DCE_PROCESS_OO_SHIFT)
+/* Output Offset Tokens */
+#define DCE_PROCESS_OO_NONE_LONG	0x0UL
+#define DCE_PROCESS_OO_32B		0x1UL
+#define DCE_PROCESS_OO_64B		0x2UL
+#define DCE_PROCESS_OO_128B		0x3UL
+#define DCE_PROCESS_OO_256B		0x4uL
+#define DCE_PROCESS_OO_512B		0x5UL
+#define DCE_PROCESS_OO_1024B		0x6UL
+#define DCE_PROCESS_OO_NON_SHORT	0x7UL
+/* Z_FLUSH */
+#define DCE_PROCESS_Z_FLUSH_SHIFT	23
+#define DCE_PROCESS_Z_FLUSH_MASK	(0x7UL << DCE_PROCESS_Z_FLUSH_SHIFT)
+/* Z_FLUSH Tokens */
+#define DCE_PROCESS_Z_FLUSH_NO_FLUSH		0x0UL
+#define DCE_PROCESS_Z_FLUSH_PARTIAL_FLUSH	0x1UL
+#define DCE_PROCESS_Z_FLUSH_SYNC_FLUSH		0x2UL
+#define DCE_PROCESS_Z_FLUSH_FULL_FLUSH		0x3UL
+#define DCE_PROCESS_Z_FLUSH_FINISH		0x4UL
+#define DCE_PROCESS_Z_FLUSH_BLOCK		0x5UL
+#define DCE_PROCESS_Z_FLUSH_TREES		0x6UL
+
+#define DCE_PROCESS_SCRF_SHIFT		22
+#define DCE_PROCESS_SCRF_MASK		(0x1UL << DCE_PROCESS_SCRF_SHIFT)
+/* SCRF Tokens */
+#define DCE_PROCESS_SCRF_SET		0x1UL
+#define DCE_PROCESS_SCRF_CLEAR		0x0UL
+
+#define DCE_PROCESS_RECYCLED_SHIFT	21
+#define DCE_PROCESS_RECYCLED_MASK	(0x1UL << DCE_PROCESS_RECYCLED_SHIFT)
+/* Recycle Tokens */
+#define DCE_PROCESS_RECYCLED_SET	0x1UL
+#define DCE_PROCESS_RECYCLED_CLEAR	0x0UL
+
+#define DCE_PROCESS_INITIAL_SHIFT	20
+#define DCE_PROCESS_INITIAL_MASK	(0x1UL << DCE_PROCESS_INITIAL_SHIFT)
+/* Initial Tokens */
+#define DCE_PROCESS_INITIAL_SET		0x1UL
+#define DCE_PROCESS_INITIAL_CLEAR	0x0UL
+
+#define DCE_PROCESS_RB_SHIFT	19
+#define DCE_PROCESS_RB_MASK	(0x1UL << DCE_PROCESS_RB_SHIFT)
+/* Release Buffers Tokens */
+#define DCE_PROCESS_RB_YES	0x1UL
+#define DCE_PROCESS_RB_NO	0x0UL
+
+#define DCE_PROCESS_B64_SHIFT	18
+#define DCE_PROCESS_B64_MASK	(0x1UL << DCE_PROCESS_B64_SHIFT)
+/* Is Base64 encoding Tokens */
+#define DCE_PROCESS_B64_YES	0x1UL
+#define DCE_PROCESS_B64_NO	0x0UL
+
+/* Compression Format */
+#define DCE_PROCESS_CF_SHIFT		16
+#define DCE_PROCESS_CF_MASK		(0x3UL << DCE_PROCESS_CF_SHIFT)
+/* CF Tokesn */
+#define DCE_PROCESS_CF_DEFLATE		0x0UL
+#define DCE_PROCESS_CF_ZLIB		0x1UL
+#define DCE_PROCESS_CF_GZIP		0x2UL
+
+/* Compression Effort */
+#define DCE_PROCESS_CE_SHIFT			13
+#define DCE_PROCESS_CE_MASK			(0x3UL << DCE_PROCESS_CE_SHIFT)
+/* CE Tokens */
+#define DCE_PROCESS_CE_NONE			0x0UL
+#define DCE_PROCESS_CE_STATIC_HUFF_STRMATCH	0x1UL
+#define DCE_PROCESS_CE_HUFF_ONLY		0x2UL
+#define DCE_PROCESS_CE_BEST_POSSIBLE		0x3UL
+
+/* UHC, USPC, and USDC are ignored for stateless flows */
+#define DCE_PROCESS_UHC_SHIFT	12
+#define DCE_PROCESS_UHC_MASK	(0x1UL << DCE_PROCESS_UHC_SHIFT)
+/* Update Header Context Request Tokens */
+#define DCE_PROCESS_UHC_YES	0x1UL
+#define DCE_PROCESS_UHC_NO	0x0UL
+
+#define DCE_PROCESS_USPC_SHIFT	11
+#define DCE_PROCESS_USPC_MASK	(0x1UL << DCE_PROCESS_USPC_SHIFT)
+/* Update Stream Processing Context Request Tokens */
+#define DCE_PROCESS_USPC_YES	0x1UL
+#define DCE_PROCESS_USPC_NO	0x0UL
+
+#define DCE_PROCESS_USDC_SHIFT	10
+#define DCE_PROCESS_USDC_MASK	(0x1UL << DCE_PROCESS_USDC_SHIFT)
+/* Update Stream Data Context Request Tokens */
+#define DCE_PROCESS_USDC_YES	0x1UL
+#define DCE_PROCESS_USDC_NO	0x0UL
+
+/* Stream Configuration Update Select */
+#define DCE_PROCESS_SCUS_SHIFT		8
+#define DCE_PROCESS_SCUS_MASK		(0x3UL << DCE_PROCESS_SCUS_SHIFT)
+/* SCUS Tokens */
+#define DCE_PROCESS_SCUS_NORMAL_MODE	0x0UL
+#define DCE_PROCESS_SCUS_UPDATE		0x1UL
+#define DCE_PROCESS_SCUS_UPDATE_DEBUG	0x2UL
+
+/* On output there is a Command Status */
+#define DCE_PROCESS_STATUS_SHIFT	0
+#define DCE_PROCESS_STATUS_MASK		(0xffUL << DCE_PROCESS_STATUS_SHIFT)
+};
+
+/* Various dma memory size and alignment requirements */
+#define DCE_SCR_ALIGN			64
+#define DCE_COMP_HISTORY_ALIGN		64
+#define DCE_COMP_HISTORY_SIZE		4096
+#define DCE_DECOMP_HISTORY_ALIGN	64
+#define DCE_DECOMP_HISTORY_SIZE		32768
+#define DCE_PENDING_OUTPUT_SIZE		8256 /* 8202 bytes for compression */
+#define DCE_PENDING_OUTPUT_ALIGN	64
+#define DCE_DECOMP_CTXT_ALIGN		64
+#define DCE_DECOMP_CTXT_SIZE		256
+
+/* 64 bytes Stream Context Frame, must be 64 byte aligned */
+struct scf_64b {
+	union {
+		uint8_t  opaque_data8[64];
+		uint16_t opaque_data16[32];
+		uint32_t opaque_data32[16];
+		uint64_t opaque_data64[8];
+	};
+} __aligned(DCE_SCR_ALIGN);
+
+/* 128 byte Stream Context Frame (Record), must be 64 byte aligned */
+struct scf_128b {
+	union {
+		uint8_t  opaque_data8[128];
+		uint16_t opaque_data16[64];
+		uint32_t opaque_data32[32];
+		uint64_t opaque_data64[16];
+		struct scf_64b scf[2];
+	};
+} __aligned(DCE_SCR_ALIGN);
+
+/* Accessors to 64 byte Stream Configuration Frame */
+
+#define SCF_TOTAL_IN_SHIFT	0
+#define SCF_TOTAL_IN_MASK	(0xffffffffUL << SCF_TOTAL_IN_SHIFT)
+#define SCF_TOTAL_IN_32IDX	0
+/**
+ * get_total_in - Get total_in field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_total_in(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_TOTAL_IN);
+}
+
+/**
+ * set_total_in - Set total_in field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the total_in field to.
+ */
+static inline void set_total_in(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_TOTAL_IN, val);
+}
+
+#define SCF_TOTAL_OUT_SHIFT	0
+#define SCF_TOTAL_OUT_MASK	(0xffffffffUL << SCF_TOTAL_OUT_SHIFT)
+#define SCF_TOTAL_OUT_32IDX	1
+/**
+ * get_total_out - Get total_out field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_total_out(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_TOTAL_OUT);
+}
+
+/**
+ * set_total_out - Set total_out field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the total_out field to.
+ */
+static inline void set_total_out(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_TOTAL_OUT, val);
+}
+
+#define SCF_ADLER32_SHIFT	0
+#define SCF_ADLER32_MASK	(0xffffffffUL << SCF_ADLER32_SHIFT)
+#define SCF_ADLER32_32IDX	2
+/**
+ * get_adler32 - Get adler32 field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_adler32(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_ADLER32);
+}
+
+/**
+ * set_adler32 - Set adler32 field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the adler32 field to.
+ */
+static inline void set_adler32(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_ADLER32, val);
+}
+
+#define SCF_ID1_SHIFT	24
+#define SCF_ID1_MASK	(0xffUL << SCF_ID1_SHIFT)
+#define SCF_ID1_32IDX	4
+/**
+ * get_id1 - Get id1 field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_id1(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_ID1);
+}
+
+/**
+ * set_id1 - Set id1 field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the id1 field to.
+ */
+static inline void set_id1(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_ID1, val);
+}
+
+#define SCF_ID2_SHIFT	16
+#define SCF_ID2_MASK	(0xffUL << SCF_ID2_SHIFT)
+#define SCF_ID2_32IDX	4
+/**
+ * get_id2 - Get id2 field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_id2(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_ID2);
+}
+
+/**
+ * set_id2 - Set id2 field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the id2 field to.
+ */
+static inline void set_id2(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_ID2, val);
+}
+
+#define SCF_ID1_ID2_SHIFT	16
+#define SCF_ID1_ID2_MASK	(0xffffUL << SCF_ID1_ID2_SHIFT)
+#define SCF_ID1_ID2_32IDX	4
+/**
+ * get_id1id2 - Get both the id1 and id2 fields in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_id1id2(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_ID1_ID2);
+}
+
+/**
+ * set_id1id2 - Set both the id1 and id2 fields in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the id1 and id2 fields to.
+ */
+static inline void set_id1id2(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_ID1_ID2, val);
+}
+
+#define SCF_CM_SHIFT	8
+#define SCF_CM_MASK	(0xffUL << SCF_CM_SHIFT)
+#define SCF_CM_32IDX	4
+/**
+ * get_cm - Get cm field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_cm(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CM);
+}
+
+/**
+ * set_cm - Set cm field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the cm field to.
+ */
+static inline void set_cm(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_CM, val);
+}
+
+#define SCF_FLG_SHIFT	0
+#define SCF_FLG_MASK	(0xffUL << SCF_FLG_SHIFT)
+#define SCF_FLG_32IDX	4
+/**
+ * get_flg - Get flg field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_flg(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_FLG);
+}
+
+/**
+ * set_flg - Set flg field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the cm field to.
+ */
+static inline void set_flg(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_FLG, val);
+}
+
+#define SCF_CMFLG_SHIFT	0
+#define SCF_CMFLG_MASK	(0xffffUL << SCF_CMFLG_SHIFT)
+#define SCF_CMFLG_32IDX	4
+/**
+ * set_cmflg - Set cm and flg fields in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the cm and flg fields to.
+ */
+static inline void set_cmflg(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_CMFLG, val);
+}
+
+/**
+ * get_cmflg - Get the combined cm and flg fields in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_cmflg(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CMFLG);
+}
+
+#define SCF_MTIME_SHIFT	0
+#define SCF_MTIME_MASK	(0xffffffffUL << SCF_MTIME_SHIFT)
+#define SCF_MTIME_32IDX	5
+/**
+ * get_mtime - Get mtime field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_mtime(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_MTIME);
+}
+
+/**
+ * set_mtime - Set mtime field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the mtime field to.
+ */
+static inline void set_mtime(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_MTIME, val);
+}
+
+#define SCF_XFL_SHIFT	24
+#define SCF_XFL_MASK	(0xffUL << SCF_XFL_SHIFT)
+#define SCF_XFL_32IDX	6
+/**
+ * get_xfl - Get xfl field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_xfl(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_XFL);
+}
+
+/**
+ * set_xfl - Set xfl field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the xfl field to.
+ */
+static inline void set_xfl(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_XFL, val);
+}
+
+#define SCF_OS_SHIFT	16
+#define SCF_OS_MASK	(0xffUL << SCF_OS_SHIFT)
+#define SCF_OS_32IDX	6
+/**
+ * get_os - Get os field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_os(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_OS);
+}
+
+/**
+ * set_os - Set os field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the os field to.
+ */
+static inline void set_os(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_OS, val);
+}
+
+#define SCF_XLEN_SHIFT	0
+#define SCF_XLEN_MASK	(0xffffUL << SCF_XLEN_SHIFT)
+#define SCF_XLEN_32IDX	6
+/**
+ * get_xlen - Get xlen field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_xlen(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_XLEN);
+}
+
+/**
+ * set_xlen - Set xlen field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the xlen field to.
+ */
+static inline void set_xlen(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_XLEN, val);
+}
+
+#define SCF_NLEN_SHIFT	16
+#define SCF_NLEN_MASK	(0xffffUL << SCF_NLEN_SHIFT)
+#define SCF_NLEN_32IDX	7
+/**
+ * get_nlen - Get nlen field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_nlen(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_NLEN);
+}
+
+/**
+ * set_nlen - Set nlen field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the nlen field to.
+ */
+static inline void set_nlen(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_NLEN, val);
+}
+
+#define SCF_CLEN_SHIFT	0
+#define SCF_CLEN_MASK	(0xffffUL << SCF_CLEN_SHIFT)
+#define SCF_CLEN_32IDX	7
+/**
+ * get_clen - Get clen field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_clen(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CLEN);
+}
+
+/**
+ * set_clen - Set clen field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the clen field to.
+ */
+static inline void set_clen(struct scf_64b *scf, uint32_t val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_CLEN, val);
+}
+
+#define SCF_EXTRA_PTR_SHIFT	0
+#define SCF_EXTRA_PTR_MASK	(0xffffffffffULL << SCF_EXTRA_PTR_SHIFT)
+#define SCF_EXTRA_PTR_64IDX	4
+/**
+ * get_extra_ptr - Get extra_ptr field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint64_t get_extra_ptr(const struct scf_64b *scf)
+{
+	return GET_BF64_IDX(&scf->opaque_data64[0], SCF_EXTRA_PTR);
+}
+
+/**
+ * set_extra_ptr - Set extra_ptr field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the extra_ptr field to.
+ */
+static inline void set_extra_ptr(struct scf_64b *scf, uint64_t val)
+{
+	SET_BF64_IDX(&scf->opaque_data64[0], SCF_EXTRA_PTR, val);
+}
+
+#define SCF_PENDING_OUTPUT_PTR_SHIFT	0
+#define SCF_PENDING_OUTPUT_PTR_MASK	\
+		(0xffffffffffULL << SCF_PENDING_OUTPUT_PTR_SHIFT)
+#define SCF_PENDING_OUTPUT_PTR_64IDX	5
+/**
+ * get_pending_output_ptr - Get pending_output_ptr field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint64_t get_pending_output_ptr(const struct scf_64b *scf)
+{
+	return GET_BF64_IDX(&scf->opaque_data64[0], SCF_PENDING_OUTPUT_PTR);
+}
+
+/**
+ * set_pending_output_ptr - Set pending_output_ptr field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the pending_output_ptr field to.
+ */
+static inline void set_pending_output_ptr(struct scf_64b *scf, uint64_t val)
+{
+	SET_BF64_IDX(&scf->opaque_data64[0], SCF_PENDING_OUTPUT_PTR, val);
+}
+
+
+/*
+ * Rev 1.0 BG specifies is a 40bit value, but the lower 6 bits are ignored
+ * since the ptr has to be 64B aligned. Rev 1.1 specifies it as a 34 bit value
+ * but that the next 6 lowers bits are implied to be zero. No space is
+ * reserved for these 6 lower bits. The API will accept the full value
+ * and shift accordingly. It will also shift when returning the value.
+ */
+#define SCF_HISTORY_PTR_SHIFT	6
+#define SCF_HISTORY_PTR_MASK	(0x3ffffffffULL << SCF_HISTORY_PTR_SHIFT)
+#define SCF_HISTORY_PTR_64IDX	6
+/**
+ * get_history_ptr - Get history_ptr field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint64_t get_history_ptr(const struct scf_64b *scf)
+{
+	return GET_BF64_IDX(&scf->opaque_data64[0], SCF_HISTORY_PTR) <<
+		SCF_HISTORY_PTR_SHIFT;
+}
+
+/**
+ * set_history_ptr - Set history_ptr field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the history_ptr field to.
+ */
+static inline void set_history_ptr(struct scf_64b *scf, uint64_t val)
+{
+	/* lower 6 bits expected to be zero, since 64 byte aligned */
+	SET_BF64_IDX(&scf->opaque_data64[0], SCF_HISTORY_PTR,
+		val >> SCF_HISTORY_PTR_SHIFT);
+}
+
+#define SCF_PMODE_SHIFT	31
+#define SCF_PMODE_MASK	(0x1UL << SCF_PMODE_SHIFT)
+#define SCF_PMODE_32IDX	14
+/**
+ * get_pmode - Get pmode field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline bool get_pmode(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_PMODE);
+}
+
+/**
+ * set_pmode - Set pmode field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the pmode field to.
+ */
+static inline void set_pmode(struct scf_64b *scf, bool val)
+{
+	SET_BF32_IDX(&scf->opaque_data32[0], SCF_PMODE, val ? 1 : 0);
+}
+
+
+/* Compression, Output SCF attribute accessors */
+
+#define SCF_BYTES_PROCESSED_SHIFT	0
+#define SCF_BYTES_PROCESSED_MASK	\
+		(0x1fffffffUL << SCF_BYTES_PROCESSED_SHIFT)
+#define SCF_BYTES_PROCESSED_32IDX	3
+/**
+ * get_bytes_processed - Get bytes_processed field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_bytes_processed(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_BYTES_PROCESSED);
+}
+
+#define SCF_PENDING_OUTPUT_LEN_SHIFT	16
+#define SCF_PENDING_OUTPUT_LEN_MASK	\
+		(0xffffUL << SCF_PENDING_OUTPUT_LEN_SHIFT)
+#define SCF_PENDING_OUTPUT_LEN_32IDX	10
+/**
+ * get_pending_output_len - Get pending_output_len field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_pending_output_len(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_PENDING_OUTPUT_LEN);
+}
+
+/* Decompression, Input SCF attribute accessors */
+
+/* DEC Rev 1.0 */
+#define SCF_EXTRA_LIMIT_SHIFT	16
+#define SCF_EXTRA_LIMIT_MASK	(0xffffUL << SCF_EXTRA_LIMIT_SHIFT)
+#define SCF_EXTRA_LIMIT_32IDX	8
+
+/* DCE Rev 1.1 */
+#define SCF_EXTRA_LIMIT_V11_SHIFT	8
+#define SCF_EXTRA_LIMIT_V11_MASK	(0x3ffffUL << SCF_EXTRA_LIMIT_V11_SHIFT)
+#define SCF_EXTRA_LIMIT_V11_32IDX	8
+
+/**
+ * get_extra_limit - Get extra_limit field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_extra_limit(const struct scf_64b *scf)
+{
+	uint16_t local_rev = dce_ip_rev;
+
+	if (local_rev == 0)
+		local_rev = DCE_DEFAULT_REV;
+
+	if (local_rev == DCE_REV10)
+		return GET_BF32_IDX(&scf->opaque_data32[0], SCF_EXTRA_LIMIT);
+	else
+		return GET_BF32_IDX(&scf->opaque_data32[0],
+					SCF_EXTRA_LIMIT_V11);
+}
+
+/**
+ * set_extra_limit - Set extra_limit field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the extra_limit field to.
+ */
+static inline void set_extra_limit(struct scf_64b *scf, uint32_t val)
+{
+	uint16_t local_rev;
+
+	if (!dce_ip_rev)
+		local_rev = DCE_DEFAULT_REV;
+	else
+		local_rev = dce_ip_rev;
+
+	if (local_rev == DCE_REV10)
+		SET_BF32_IDX(&scf->opaque_data32[0], SCF_EXTRA_LIMIT, val);
+	else
+		SET_BF32_IDX(&scf->opaque_data32[0], SCF_EXTRA_LIMIT_V11, val);
+}
+
+#define SCF_DECOMP_CTXT_PTR_SHIFT	0
+#define SCF_DECOMP_CTXT_PTR_MASK	\
+		(0xffffffffffULL << SCF_DECOMP_CTXT_PTR_SHIFT)
+#define SCF_DECOMP_CTXT_PTR_64IDX	7
+/**
+ * get_decomp_ctxt_ptr - Get decomp_ctxt_ptr field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint64_t get_decomp_ctxt_ptr(const struct scf_64b *scf)
+{
+	return GET_BF64_IDX(&scf->opaque_data64[0], SCF_DECOMP_CTXT_PTR);
+}
+
+/**
+ * set_decomp_ctxt_ptr - Set decomp_ctxt_ptr field in SCF
+ *
+ * @scf: stream context frame
+ * @val: Value to set the decomp_ctxt_ptr field to.
+ */
+static inline void set_decomp_ctxt_ptr(struct scf_64b *scf, uint64_t val)
+{
+	SET_BF64_IDX(&scf->opaque_data64[0], SCF_DECOMP_CTXT_PTR, val);
+}
+
+
+/*
+ * Decompression, Output SCF attribute accessors. Attribute list
+ *	TOTAL_IN
+ *	TOTAL_OUT
+ *	ADLER32
+ *	XO
+ *	NO
+ *	CO
+ *	BYTES_PROCESSED
+ *	ID1
+ *	ID2
+ *	CM
+ *	FLG
+ *	MTIME
+ *	XFL
+ *	OS
+ *	XLEN
+ *	NLEN
+ *	CLEN
+ *	EXTRA_LIMIT
+ *	EXTRA_PTR
+ *	PENDING_OUTPUT_LEN
+ */
+
+#define SCF_XO_SHIFT	31
+#define SCF_XO_MASK	(0x1UL << SCF_XO_SHIFT)
+#define SCF_XO_32IDX	3
+/**
+ * get_xo - Get xo field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline bool get_xo(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_XO);
+}
+
+#define SCF_NO_SHIFT	30
+#define SCF_NO_MASK	(0x1UL << SCF_NO_SHIFT)
+#define SCF_NO_32IDX	3
+/**
+ * get_no - Get no field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline bool get_no(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_NO);
+}
+
+#define SCF_CO_SHIFT	29
+#define SCF_CO_MASK	(0x1UL << SCF_CO_SHIFT)
+#define SCF_CO_32IDX	3
+/**
+ * get_co - Get co field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_co(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CO);
+}
+
+/* This following accessors is when accessing the full stream context recort */
+
+/*
+ * Compression, Output Debug SCF attribute accessors. Attribute list
+ *	TOTAL_IN
+ *	TOTAL_OUT
+ *	ADLER32
+ *	OUTPUT_PHASE
+ *	B64_RESIDUE_LEN
+ *	B64_RESIDUE
+ *	ID1
+ *	ID2
+ *	CM
+ *	FLG
+ *	MTIME
+ *	XFL
+ *	OS
+ *	XLEN
+ *	NLEN
+ *	CLEN
+ *	RESIDUE_DATA
+ *	EXTRA_PTR
+ *	PENDING_OUTPUT_LEN
+ *	PENDING_WORKING_PTR(_H) (1.0, 1.1)
+ *	PENDING_OUTPUT_PTR
+ *	HISTORY_LEN
+ *	PENDING_WORKING_PTR_L (1.1)
+ *	HISTORY_PTR
+ *	PMODE
+ *	SUSP
+ *	TERMINATED
+ *	RBC
+ *	MCPLT (1.1)
+ *	HEADER_REMAINING
+ *	CRC16
+ */
+#define SCF_OUTPUT_PHASE_SHIFT	26
+#define SCF_OUTPUT_PHASE_MASK	(0x7UL << SCF_OUTPUT_PHASE_SHIFT)
+#define SCF_OUTPUT_PHASE_32IDX	3
+/**
+ * get_output_phase - Get output_phase field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_output_phase(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_OUTPUT_PHASE);
+}
+
+#define SCF_B64_RESIDUE_LEN_SHIFT	24
+#define SCF_B64_RESIDUE_LEN_MASK	(0x3UL << SCF_B64_RESIDUE_LEN_SHIFT)
+#define SCF_B64_RESIDUE_LEN_32IDX	3
+/**
+ * get_b64_residue_len - Get b64_residue_len field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_b64_residue_len(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_B64_RESIDUE_LEN);
+}
+
+#define SCF_B64_RESIDUE_SHIFT	0
+#define SCF_B64_RESIDUE_MASK	(0xffffffUL << SCF_B64_RESIDUE_SHIFT)
+#define SCF_B64_RESIDUE_32IDX	3
+/**
+ * get_b64_residue - Get b64_residue field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_b64_residue(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_B64_RESIDUE);
+}
+
+#define SCF_RESIDUE_DATA_SHIFT	9
+#define SCF_RESIDUE_DATA_MASK	(0x7fffffUL << SCF_RESIDUE_DATA_SHIFT)
+#define SCF_RESIDUE_DATA_32IDX	8
+/**
+ * get_residue_data - Get residue_data field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_residue_data(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_RESIDUE_DATA);
+}
+
+#define SCF_PENDING_WKG_PTR_SHIFT	8
+#define SCF_PENDING_WKG_PTR_MASK	(0xffUL << SCF_PENDING_WKG_PTR_SHIFT)
+#define SCF_PENDING_WKG_PTR_32IDX	10
+#define SCF_PENDING_WKG_L_PTR_SHIFT	8
+#define SCF_PENDING_WKG_L_PTR_MASK	(0xffUL << SCF_PENDING_WKG_L_PTR_SHIFT)
+#define SCF_PENDING_WKG_L_PTR_32IDX	12
+/* This is a Rev 1.0 field, in Rev 1.1 this is the High field */
+/*
+ * get_pending_working_ptr - Get pending_working_ptr field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_pending_working_ptr(const struct scf_64b *scf)
+{
+	uint16_t local_rev = dce_ip_rev;
+
+	if (local_rev == 0)
+		local_rev = DCE_DEFAULT_REV;
+
+	if (local_rev == DCE_REV10) {
+		return GET_BF32_IDX(&scf->opaque_data32[0],
+					SCF_PENDING_WKG_PTR);
+	} else {
+		uint32_t val = 0;
+		val = GET_BF32_IDX(&scf->opaque_data32[0], SCF_PENDING_WKG_PTR)
+				<< 8;
+		val |= GET_BF32_IDX(&scf->opaque_data32[0],
+				SCF_PENDING_WKG_L_PTR);
+		return val;
+	}
+}
+
+#define SCF_HISTORY_LEN_SHIFT	16
+#define SCF_HISTORY_LEN_MASK	(0xffffUL << SCF_HISTORY_LEN_SHIFT)
+#define SCF_HISTORY_LEN_32IDX	12
+/**
+ * get_history_len - Get history_len field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_history_len(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_HISTORY_LEN);
+}
+
+#define SCF_SUSP_SHIFT	30
+#define SCF_SUSP_MASK	(0x1UL << SCF_SUSP_SHIFT)
+#define SCF_SUSP_32IDX	14
+/**
+ * get_susp - Get susp field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_susp(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_SUSP);
+}
+
+#define SCF_TERMINATED_SHIFT	29
+#define SCF_TERMINATED_MASK	(0x1UL << SCF_TERMINATED_SHIFT)
+#define SCF_TERMINATED_32IDX	14
+/**
+ * get_terminated - Get terminated field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_terminated(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_TERMINATED);
+}
+
+#define SCF_RBC_SHIFT	24
+#define SCF_RBC_MASK	(0x1fUL << SCF_RBC_SHIFT)
+#define SCF_RBC_32IDX	14
+/**
+ * get_rbc - Get rbc field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_rbc(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_RBC);
+}
+
+#define SCF_MCPLT_SHIFT	22
+#define SCF_MCPLT_MASK	(0x1UL << SCF_MCPLT_SHIFT)
+#define SCF_MCPLT_32IDX	14
+/**
+ * get_mcplt - Get mcplt field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_mcplt(const struct scf_64b *scf)
+{
+	/* only in rev > 1.0 */
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_MCPLT);
+}
+
+
+#define SCF_HEADER_REMAINING_SHIFT	0
+#define SCF_HEADER_REMAINING_MASK	\
+			(0x3ffffUL << SCF_HEADER_REMAINING_SHIFT)
+#define SCF_HEADER_REMAINING_32IDX	14
+/**
+ * get_header_remaining - Get header_remaining field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_header_remaining(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_HEADER_REMAINING);
+}
+
+#define SCF_CRC16_SHIFT	0
+#define SCF_CRC16_MASK	(0xffffffffUL << SCF_CRC16_SHIFT)
+#define SCF_CRC16_32IDX	15
+/**
+ * get_crc16 - Get crc16 field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_crc16(const struct scf_64b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CRC16);
+}
+
+/*
+ * Deompression, Output Debug SCF attribute accessors. Attribute list
+ * IMPORTANT: This structure is 128Bytes is size.
+ *	TOTAL_IN
+ *	TOTAL_OUT
+ *	ADLER32
+ *	OUTPUT_PHASE
+ *	B64_RESIDUE_LEN
+ *	B64_RESIDUE
+ *	ID1
+ *	ID2
+ *	CM
+ *	FLG
+ *	MTIME
+ *	XFL
+ *	OS
+ *	XLEN
+ *	NLEN
+ *	CLEN
+ *	RESIDUE_DATA
+ *	EXTRA_PTR
+ *	PENDING_OUTPUT_LEN
+ *	PENDING_WORKING_PTR(_H) (1.0, 1.1)
+ *	PENDING_OUTPUT_PTR
+ *	HISTORY_LEN
+ *	PENDING_WORKING_PTR_L (1.1)
+ *	HISTORY_PTR
+ *	PMODE
+ *	SUSP
+ *	TERMINATED
+ *	RBC
+ *	MCPLT (1.1)
+ *	MC (1.1)
+ *	HEADER_REMAINING
+ *	CRC16
+ *
+ *	## second cache line ##
+ *	DECOMP_CTXT_PTR
+ *	DECOMP_TOTAL_OUT (1.1)
+ *	BFINAL
+ *	BTYPE
+ *	FRAME_PARSE_STATE
+ *	NUM_CODE_LEN
+ *	PREVIOUS_CODE_LEN (moved location, 1.0, 1.1)
+ *	NCBB_REMAINING
+ *	HLIT
+ *	HDIST
+ *	HCLEN
+ *	HUFFMAN_RBC
+ *	HUFFMAN_RESIDUE
+ */
+
+#define SCFCL2_DECOMP_CTXT_PTR_SHIFT	0
+#define SCFCL2_DECOMP_CTXT_PTR_MASK	\
+			(0xffffffffffULL << SCFCL2_DECOMP_CTXT_PTR_SHIFT)
+#define SCFCL2_DECOMP_CTXT_PTR_64IDX	8
+/**
+ * get_decomp_ctxt_ptr_cl2 - Get decomp_ctxt_ptr field in 128 byte SCF
+ *
+ * @scf: stream context frame, 128 bytes in size
+ *
+ * Returns the decomp_ctxt_ptr field in the second cache line.
+ */
+static inline uint64_t get_decomp_ctxt_ptr_cl2(const struct scf_128b *scf)
+{
+	return GET_BF64_IDX(&scf->opaque_data64[0], SCFCL2_DECOMP_CTXT_PTR);
+}
+
+#define SCFCL2_DECOMP_TOTAL_OUT_SHIFT	0
+#define SCFCL2_DECOMP_TOTAL_OUT_MASK	\
+			(0xffffffffUL << SCFCL2_DECOMP_TOTAL_OUT_SHIFT)
+#define SCFCL2_DECOMP_TOTAL_OUT_32IDX	17
+/**
+ * get_decomp_total_out_cl2 - Get decomp_total_out field in 128 byte SCF
+ *
+ * @scf: stream context frame, 128 bytes in size
+ *
+ * Returns the decomp_total_out field in the second cache line.
+ */
+static inline uint64_t get_decomp_total_out_cl2(const struct scf_128b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_DECOMP_TOTAL_OUT);
+}
+
+#define SCFCL2_PREVIOUS_CODE_LEN_SHIFT		28
+#define SCFCL2_PREVIOUS_CODE_LEN_V11_SHIFT	12
+#define SCFCL2_PREVIOUS_CODE_LEN_MASK	\
+	(0xfUL << SCFCL2_PREVIOUS_CODE_LEN_SHIFT)
+#define SCFCL2_PREVIOUS_CODE_LEN_V11_MASK	\
+	(0xfUL << SCFCL2_PREVIOUS_CODE_LEN_V11_SHIFT)
+#define SCFCL2_PREVIOUS_CODE_LEN_32IDX	18
+#define SCFCL2_PREVIOUS_CODE_LEN_V11_32IDX	20
+
+/**
+ * get_previous_code_len_cl2 - Get previous_code_len field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_previous_code_len_cl2(const struct scf_128b *scf)
+{
+	uint16_t local_rev = dce_ip_rev;
+
+	if (local_rev == 0)
+		local_rev = DCE_DEFAULT_REV;
+
+	if (local_rev == DCE_REV10)
+		return GET_BF32_IDX(&scf->opaque_data32[0],
+			SCFCL2_PREVIOUS_CODE_LEN);
+	else
+		return GET_BF32_IDX(&scf->opaque_data32[0],
+				 SCFCL2_PREVIOUS_CODE_LEN_V11);
+}
+
+#define SCFCL2_BFINAL_SHIFT	30
+#define SCFCL2_BFINAL_MASK	(0x1UL << SCFCL2_BFINAL_SHIFT)
+#define SCFCL2_BFINAL_32IDX	19
+/**
+ * get_bfinal_cl2 - Get bfinal field in SCF
+ *
+ * @scf: stream context frame, 128 bytes in size
+ */
+static inline uint32_t get_bfinal_cl2(const struct scf_128b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_BFINAL);
+}
+
+#define SCFCL2_BTYPE_SHIFT	28
+#define SCFCL2_BTYPE_MASK	(0x3UL << SCFCL2_BTYPE_SHIFT)
+#define SCFCL2_BTYPE_32IDX	19
+/**
+ * get_btype_cl2 - Get btype field in SCF
+ *
+ * @scf: stream context frame, 128 bytes in size
+ */
+static inline uint32_t get_btype_cl2(const struct scf_128b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_BTYPE);
+}
+
+#define SCFCL2_FRAME_PARSE_STATE_SHIFT	27
+#define SCFCL2_FRAME_PARSE_STATE_MASK	\
+		(0x1fUL << SCFCL2_FRAME_PARSE_STATE_SHIFT)
+#define SCFCL2_FRAME_PARSE_STATE_32IDX	20
+/**
+ * get_frame_parse_state_cl2 - Get frame_parse_state field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_frame_parse_state_cl2(const struct scf_128b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_FRAME_PARSE_STATE);
+}
+
+#define SCFCL2_NUM_CODE_LEN_SHIFT	18
+#define SCFCL2_NUM_CODE_LEN_MASK	(0x1ffUL << SCFCL2_NUM_CODE_LEN_SHIFT)
+#define SCFCL2_NUM_CODE_LEN_32IDX	20
+/**
+ * get_num_code_len_cl2 - Get num_code_len field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_num_code_len_cl2(const struct scf_128b *scf)
+{
+		return GET_BF32_IDX(&scf->opaque_data32[0],
+				SCFCL2_NUM_CODE_LEN);
+}
+
+#define SCFCL2_NCBB_REMAINING_SHIFT	16
+#define SCFCL2_NCBB_REMAINING_MASK	\
+		(0xffffUL << SCFCL2_NCBB_REMAINING_SHIFT)
+#define SCFCL2_NCBB_REMAINING_32IDX	21
+/**
+ * get_ncbb_remaining_cl2 - Get ncbb_remaining field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_ncbb_remaining_cl2(const struct scf_128b *scf)
+{
+		return GET_BF32_IDX(&scf->opaque_data32[0],
+				SCFCL2_NCBB_REMAINING);
+}
+
+#define SCFCL2_HLIT_SHIFT	11
+#define SCFCL2_HLIT_MASK	(0x1fUL << SCFCL2_HLIT_SHIFT)
+#define SCFCL2_HLIT_32IDX	21
+/**
+ * get_hlit_cl2 - Get hlit field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_hlit_cl2(const struct scf_128b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_HLIT);
+}
+
+#define SCFCL2_HDIST_SHIFT	6
+#define SCFCL2_HDIST_MASK	(0x1fUL << SCFCL2_HDIST_SHIFT)
+#define SCFCL2_HDIST_32IDX	21
+/**
+ * get_hdist_cl2 - Get hdist field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_hdist_cl2(const struct scf_128b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_HDIST);
+}
+
+#define SCFCL2_HCLEN_SHIFT	2
+#define SCFCL2_HCLEN_MASK	(0xfUL << SCFCL2_HCLEN_SHIFT)
+#define SCFCL2_HCLEN_32IDX	21
+/**
+ * get_hclen_cl2 - Get hclen field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_hclen_cl2(const struct scf_128b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_HCLEN);
+}
+
+#define SCFCL2_HUFFMAN_RBC_SHIFT	24
+#define SCFCL2_HUFFMAN_RBC_MASK	(0x3fUL << SCFCL2_HUFFMAN_RBC_SHIFT)
+#define SCFCL2_HUFFMAN_RBC_32IDX	22
+/**
+ * get_huffman_rbc_cl2 - Get huffman_rbc field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint32_t get_huffman_rbc_cl2(const struct scf_128b *scf)
+{
+	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_HUFFMAN_RBC);
+}
+
+#define SCFCL2_HUFFMAN_RESIDUE_SHIFT	0
+#define SCFCL2_HUFFMAN_RESIDUE_MASK	\
+		(0x7fffffffffffULL << SCFCL2_HUFFMAN_RESIDUE_SHIFT)
+#define SCFCL2_HUFFMAN_RESIDUE_64IDX	11
+/**
+ * get_huffman_residue_cl2 - Get huffman_residue field in SCF
+ *
+ * @scf: stream context frame
+ */
+static inline uint64_t get_huffman_residue_cl2(const struct scf_128b *scf)
+{
+	return GET_BF64_IDX(&scf->opaque_data64[0], SCFCL2_HUFFMAN_RESIDUE);
+}
+
+/**
+ * enum dce_status - This enumeration depicts all of the possible status codes
+ *	that can appear in the output frame status field.
+ *
+ * @FULLY_PROCESSED:	The work unit data was fully processed without
+ *			encountering an exception, and the work unit was not
+ *			marked as an end of Stream (no DCE_Z_FINISH parameter).
+ * @STREAM_END:		The work unit data was fully processed without
+ *			encountering an exception, and was marked as an end of
+ *			Stream with the DCE_Z_FINISH flush parameter.
+ * @INPUT_STARVED	The compressed input Frame did not contain an integral
+ *			number of compressed data blocks and/or ended before
+ *			the expected number of decompressed bytes were produced.
+ *			This exception occurs when an input Frame with
+ *			Z_FLUSH = Z_FINISH is received. It indicates a missing
+ *			end of block code;
+ *			i.e. “invalid code * missing end-of-block” in *msg
+ *			(zlib software library equivalent).
+ * @Z_BLOCK_SUSPENDED	The decompressor module halted processing of an input
+ *			Frame at the end of a compressed block (or block header
+ *			if Z_FLUSH = Z_BLOCK or Z_TREES). This code can only
+ *			occur on stateful Flows in recycling mode
+ * @OUTPUT_BLOCKED_SUSPEND	The pre-built output structure was not large
+ *			enough to contain all of the (de)compressed input Frame
+ *			data. This code can only occur on stateful Flows in
+ *			recycling mode
+ * @ACQUIRE_DATA_BUFFER_DENIED_SUSPEND	An attempt to acquire a free buffer from
+ *			BMan (DBPID) was unsuccessful. This code can only occur
+ *			on stateful Flows in recycling mode
+ * @ACQUIRE_TABLE_BUFFER_DENIED_SUSPEND	An attempt to acquire a free buffer from
+ *			BMan (TBPID) was unsuccessful. This code can only occur
+ *			on stateful Flows in recycling mode
+ * @OOL_REACHED_SUSPEND	The DCE halted processing so as not to exceed the OLL
+ *			setting. This code can only occur on stateful Flows in
+ *			recycling mode
+ * @HCL_REACHED_SUSPEND	The DCE halted processing so as not to exceed the HCL
+ *			setting. This code can only occur on stateful Flows in
+ *			recycling mode
+ * @OUTPUT_BLOCKED_DISCARD	The pre-built output structure was not large
+ *			enough to contain all of the (de)compressed input Frame
+ *			data. Some output data has been lost. This code can only
+ *			occur on stateless Flows or a stateful Flow in
+ *			truncation mode
+ * @ACQUIRE_DATA_BUFFER_DENIED_DISCARD	An attempt to acquire a free buffer from
+ *			BMan (DBPID) was unsuccessful. Some output data has been
+ *			lost. This code can only occur on stateless Flows or a
+ *			stateful Flow in truncation mode
+ *
+ * @ACQUIRE_TABLE_BUFFER_DENIED_DISCARD	An attempt to acquire a free buffer from
+ *			BMan (TBPID) was unsuccessful. Some output data has been
+ *			lost. This code can only occur on stateless Flows or a
+ *			stateful Flow in truncation mode
+ * @OLL_REACHED_DISCARD	The DCE halted processing so as not to exceed the OLL
+ *			setting. Some output data has been lost. This code can
+ *			only occur on stateless Flows or a stateful Flow in
+ *			truncation mod
+ * @HCL_REACHED_DISCARD	The DCE halted processing so as not to exceed the HCL
+ *			setting. Some output data has been lost. This code can
+ *			only occur on stateless Flows or a stateful Flow in
+ *			truncation mode
+ * @SKIPPED	The work unit was not processed due to a previous “suspend”
+ *		(i.e. Output Blocked Suspend, etc.) exception on the same
+ *		Stream. This code can only occur on stateful Flows in recycling
+ *		mode
+ * @PREVIOUS_FLOW_TERMINATION	The work unit was not processed due to a
+ *		previous exception (other than Input Starved or Output Blocked
+ *		Suspend) or completed Z_FINISH Frame on the same Stream. This
+ *		exception code will appear in Frames that follow a
+ *		non-recoverable exception on a Stream, or in Frames that follow
+ *		a Z_FINISH Frame but do not have a set I bit.
+ * @INVALID_COMPOUND_FRAME	This status code is generated if the DCE
+ *		dequeues a compound Frame that does not contain an {E=0, F=1}
+ *		pair in its third member Frame.
+ * @INVALID_STATUS_CMD	An invalid field setting was detected in the received
+ *		Frame’s STATUS/CMD field. This code results from one of the
+ *		following conditions:
+ *			Reserved setting in any of the defined fields
+ * @UNSUPPORTED_FRAME	This status code is generated if the DCE dequeues a
+ *		compound Frame that does not match the supported three member
+ *		configuration.
+ * @FRAME_TOO_SHORT	This status code is generated if DCE reaches the end of
+ *		a multi-buffer input Frame (simple or compound) and determines
+ *		that the structure contains fewer than LENGTH bytes of data.
+ * @OUTPUT_OFFSET_TOO_LARGE	This status code is generated if the OO field in
+ *		the Frame’s STATUS/CMD field specifies an offset that is
+ *		greater	than or equal to the BMan buffer size specified for the
+ *		Flow. This exception will only occur if buffer acquisition is
+ *		necessary; i.e. DCE has some output data to buffer for the
+ *		processed Frame.
+ * @ZLIB_INCOMPLETE_HEADER
+ * @ZLIB_HEADER_ERROR	An error was detected in the ZLIB header of a compressed
+ *		work unit. This code results from one of the following
+ *		conditions:
+ *			Z_FINISH Frame (plus any preceding Frames) did not
+ *				contain enough bytes to comprise a complete
+ *				header: “incorrect header check” in *msg
+ *			Compression method other than DEFLATE specified:
+ *				“unknown compression method” in *msg
+ *			Invalid window size specified: “invalid window size”
+ *				in *msg
+ *			Reserved BTYPE: “invalid block type” in *msg
+ *			LEN and NLEN fields are not 1’s complement of each
+ *				other: “invalid stored block lengths”
+ *				in *msg
+ * @ZLIB_NEED_DICTIONARY_ERROR	A compressed ZLIB Stream has the FLG.FDICT flag
+ *		set.
+ * @GZIP_INCOMPLETE_HEADER
+ * @GZIP_HEADER_ERROR	An error was detected in the header of a compressed GZIP
+ *		work unit. This code results from one of the following
+ *		conditions:
+ *			ID1/ID2 invalid
+ *			Compression method other than DEFLATE
+ *			Any of the reserved flags are set: “unknown header
+ *				flags set” in *msg.
+ *			Header CRC16 value check mismatch: “header crc
+ *				mismatch” in *msg.
+ * @DEFLATE_INVALID_BLOCK_TYPE	An error was detected in the header of a
+ *		compressed DEFLATE block: “invalid block type” in *msg.
+ * @DEFLATE_INVALID_BLOCK_LENGTHS	An error was detected in the header of a
+ *		compressed DEFLATE block: “invalid stored block lengths” in
+ *		*msg
+ * @DEFLATE_TOO_MANY_LEN_OR_DIST_SYM	“too many length or distance symbols” in
+ *		*msg.
+ * @DEFLATE_INVALID_CODE_LENGTHS_SET	“invalid code lengths set” in *msg.
+ * @DEFLATE_INVALID_BIT_LENGTH_REPEAT	“invalid bit length repeat” in *msg.
+ * @DEFLATE_INVALID_LITERAL_LENGTHS_SET “invalid literal/lengths set” in *msg.
+ * @DEFLATE_INVALID_DISTANCES_SET	“invalid distances set” in *msg.
+ * @DEFLATE_INVALID_LITERAL_LENGTH_CODE	“invalid literal/length code” in *msg.
+ * @DEFLATE_INVALID_DISTANCE_CODE	“invalid distance code” in *msg.
+ * @DEFLATE_INVALID_DISTANCE_TOO_FAR_BACK	“invalid distance too far back”
+ *		in *msg.
+ * @DEFLATE_INCORRECT_DATA_CHECK	“incorrect data check” in *msg.
+ * @DEFLATE_INCORRECT_LENGTH_CHECK	“incorrect length check” in *msg.
+ * @DEFLATE_INVALID_CODE	“invalid code * missing end of block” in *msg.
+ * @CXM_2BIT_ECC_ERROR	A double bit ECC error was detected on an access to the
+ *		CXM internal memory while processing this Frame.
+ * @CBM_2BIT_ECC_ERROR	A double bit ECC error was detected on an access to the
+ *		CBM internal memory while processing this Frame.
+ * @DHM_2BIT_ECC_ERROR	A double bit ECC error was detected on an access to the
+ *		DHM internal memory while processing this Frame.
+ * @INVALID_BASE64_CODE	An invalid Base64 code (bad byte value) was encountered.
+ * @INVALID_BASE64_PADDING	In invalid amount of padding was detected on
+ *		Base64 encoded input data.
+ * @SCF_SYSTEM_MEM_READ_ERROR	A system memory read transaction performed by
+ *		the DCE has resulted in a system memory bus error.  This code
+ *			 will occur when the error is detected on the following
+ *			 read transactions:
+ *				* Stream Configuration Frame
+ * @PENDING_OUTPUT_SYSTEM_MEM_READ_ERROR	A system memory read transaction
+ *		performed by the DCE has resulted in a system memory bus error.
+ *		This code will occur when the error is detected on the following
+ *		read transactions:
+ *			Pending Output Buffer
+ * @HISTORY_WINDOW_SYSTEM_MEM_READ_ERROR	A system memory read transaction
+ *		performed by the DCE has resulted in a system memory bus error.
+ *		This code will occur when the error is detected on the following
+ *		read transactions:
+ *			* History Window
+ * @CTX_DATA_SYSTEM_MEM_READ_ERROR	A system memory read transaction
+ *		 performed by the DCE has resulted in a system memory bus error.
+ *		 This code will occur when the error is detected on the
+ *		 following read transactions:
+ *			Stream Context Record
+ *			“Extra” data for GZIP header insertion.
+ * @FRAME_DATA_SYSTEM_READ_ERROR	A system memory read transaction
+ *		 performed by the DCE has resulted in a system memory bus error.
+ *		 This code will occur when the error is detected on the
+ *		 following read transactions:
+ *			Input Frame data buffer
+ * @INPUT_FRAME_TBL_SYSTEM_READ_ERROR	A system memory read transaction
+ *		 performed by the DCE has resulted in a system memory bus error.
+ *		 This code will occur when the error is detected on the
+ *		 following read transactions:
+ *			Input Frame scatter/gather table entry
+ * @OUTPUT_FRAME_TBL_SYSTEM_READ_ERROR	A system memory read transaction
+ *		 performed by the DCE has resulted in a system memory bus error.
+ *		 This code will occur when the error is detected on the
+ *		 following read transactions:
+ *			Output Frame scatter/gather table entry (pre-built
+ *				Frames only)
+ * @SCF_SYSTEM_MEM_WRITE_ERROR	A system memory write transaction performed by
+ *		 the DCE has resulted in a system memory bus error.  This code
+ *		 will occur when the error is detected on the following write
+ *		 transactions:
+ *			Stream Configuration Frame
+ * @PENDING_OUTPUT_SYSTEM_MEM_WRITE_ERROR	A system memory write
+ *		 transaction performed by the DCE has resulted in a system
+ *		 memory bus error.  This code will occur when the error is
+ *		 detected on the following write transactions:
+ *			Pending Output Buffer
+ * @HISTORY_WINDOW_SYSTEM_MEM_WRITE_ERROR	A system memory write
+ *		 transaction performed by the DCE has resulted in a system
+ *		 memory bus error.  This code will occur when the error is
+ *		 detected on the following write transactions:
+ *			History Window
+ * @CTX_DATA_SYSTEM_MEM_WRITE_ERROR	A system memory write transaction
+ *		 performed by the DCE has resulted in a system memory bus error.
+ *		 This code will occur when the error is detected on the
+ *		 following write transactions:
+ *			Stream Context Record
+ * @FRAME_DATA_SYSTEM_MEM_WRITE_ERROR	A system memory write transaction
+ *		 performed by the DCE has resulted in a system memory bus error.
+ *		 This code will occur when the error is detected on the
+ *		 following write transactions:
+ *			Output Frame data buffer
+ * @FRAME_TBL_SYSTEM_MEM_WRITE_ERROR	A system memory write transaction
+ *		 performed by the DCE has resulted in a system memory bus error.
+ *		 This code will occur when the error is detected on the
+ *		 following write transactions:
+ *			Output Frame scatter/gather table entry
+ *
+ * @FULLY_PROCESSED and @STREAM_END are successful return code, all other codes
+ * are operational error.
+ */
+enum dce_status {
+	FULLY_PROCESSED				= 0x00,
+	STREAM_END				= 0x01,
+	INPUT_STARVED				= 0x10,
+	Z_BLOCK_SUSPENDED			= 0x12,
+	OUTPUT_BLOCKED_SUSPEND			= 0x14,
+	ACQUIRE_DATA_BUFFER_DENIED_SUSPEND	= 0x15,
+	ACQUIRE_TABLE_BUFFER_DENIED_SUSPEND	= 0x16,
+	OOL_REACHED_SUSPEND			= 0x17,
+	HCL_REACHED_SUSPEND			= 0x18,
+	OUTPUT_BLOCKED_DISCARD			= 0x24,
+	ACQUIRE_DATA_BUFFER_DENIED_DISCARD	= 0x25,
+	ACQUIRE_TABLE_BUFFER_DENIED_DISCARD	= 0x26,
+	OLL_REACHED_DISCARD			= 0x27,
+	HCL_REACHED_DISCARD			= 0x28,
+	SKIPPED					= 0x30,
+	PREVIOUS_FLOW_TERMINATION		= 0x31,
+	INVALID_COMPOUND_FRAME			= 0x40,
+	INVALID_STATUS_CMD			= 0x41,
+	UNSUPPORTED_FRAME			= 0x42,
+	FRAME_TOO_SHORT				= 0x44,
+	OUTPUT_OFFSET_TOO_LARGE			= 0x46,
+	ZLIB_INCOMPLETE_HEADER			= 0x50,
+	ZLIB_HEADER_ERROR			= 0x51,
+	ZLIB_NEED_DICTIONARY_ERROR		= 0x52,
+	GZIP_INCOMPLETE_HEADER			= 0x60,
+	GZIP_HEADER_ERROR			= 0x61,
+	DEFLATE_INVALID_BLOCK_TYPE		= 0x70,
+	DEFLATE_INVALID_BLOCK_LENGTHS		= 0x71,
+	DEFLATE_TOO_MANY_LEN_OR_DIST_SYM	= 0x80,
+	DEFLATE_INVALID_CODE_LENGTHS_SET	= 0x81,
+	DEFLATE_INVALID_BIT_LENGTH_REPEAT	= 0x82,
+	DEFLATE_INVALID_LITERAL_LENGTHS_SET	= 0x83,
+	DEFLATE_INVALID_DISTANCES_SET		= 0x84,
+	DEFLATE_INVALID_LITERAL_LENGTH_CODE	= 0x85,
+	DEFLATE_INVALID_DISTANCE_CODE		= 0x86,
+	DEFLATE_INVALID_DISTANCE_TOO_FAR_BACK	= 0x87,
+	DEFLATE_INCORRECT_DATA_CHECK		= 0x88,
+	DEFLATE_INCORRECT_LENGTH_CHECK		= 0x89,
+	DEFLATE_INVALID_CODE			= 0x8A,
+	CXM_2BIT_ECC_ERROR			= 0xB0,
+	CBM_2BIT_ECC_ERROR			= 0xB1,
+	DHM_2BIT_ECC_ERROR			= 0xB2,
+	INVALID_BASE64_CODE			= 0xC0,
+	INVALID_BASE64_PADDING			= 0xC1,
+	SCF_SYSTEM_MEM_READ_ERROR		= 0xD5,
+	PENDING_OUTPUT_SYSTEM_MEM_READ_ERROR	= 0xD6,
+	HISTORY_WINDOW_SYSTEM_MEM_READ_ERROR	= 0xD7,
+	CTX_DATA_SYSTEM_MEM_READ_ERROR		= 0xD8,
+	FRAME_DATA_SYSTEM_READ_ERROR		= 0xD9,
+	INPUT_FRAME_TBL_SYSTEM_READ_ERROR	= 0xDA,
+	OUTPUT_FRAME_TBL_SYSTEM_READ_ERROR	= 0xDB,
+	SCF_SYSTEM_MEM_WRITE_ERROR		= 0xE5,
+	PENDING_OUTPUT_SYSTEM_MEM_WRITE_ERROR	= 0xE6,
+	HISTORY_WINDOW_SYSTEM_MEM_WRITE_ERROR	= 0xE7,
+	CTX_DATA_SYSTEM_MEM_WRITE_ERROR		= 0xE8,
+	FRAME_DATA_SYSTEM_MEM_WRITE_ERROR	= 0xE9,
+	FRAME_TBL_SYSTEM_MEM_WRITE_ERROR	= 0xEA
+};
+
+#endif /* FL_DCE_DEFS_H */
diff --git a/drivers/staging/fsl_dce/flib/dce_regs.h b/drivers/staging/fsl_dce/flib/dce_regs.h
new file mode 100644
index 0000000..201ff76
--- /dev/null
+++ b/drivers/staging/fsl_dce/flib/dce_regs.h
@@ -0,0 +1,546 @@
+/*
+ * Copyright 2013 Freescale Semiconductor, Inc.
+ */
+
+#ifndef FL_DCE_REGS_H
+#define FL_DCE_REGS_H
+
+/* Memory Mapped Registers */
+
+/** @Description struct for defining dce CCSR registes */
+struct dce_regs {
+	/* DCE Global Common Configuration */
+	uint32_t cfg;		/* DCE configuration */
+	uint8_t reserved1[0x014-0x004];
+	uint32_t oll;		/* Output Length Limit */
+	uint8_t reserved2[0x024-0x018];
+	uint32_t hcl;		/* Hop Count Limit */
+	uint8_t reserved3[0x03c-0x028];
+	uint32_t idle;		/* DCE Idle status */
+	uint8_t reserved4[0x100-0x040];
+
+	/* System Memory Configuration */
+	uint32_t liodnbr;	/* LIODN Base */
+	uint32_t srcidr;	/* Source ID Register */
+	uint32_t smcacr;	/* System Memory Cache Attribute Control */
+	uint32_t smpcr;		/* System Memory Priority Control */
+	uint32_t icir;		/* Internal Context Invalidate */
+	uint8_t reserved5[0x200-0x114];
+
+	/* Statistics */
+	uint32_t cibc_h;	/* Compressor Input Bytes count High */
+	uint32_t cibc_l;	/* Compressor Input Bytes count Low */
+	uint32_t cobc_h;	/* Compressor Output Bytes count High */
+	uint32_t cobc_l;	/* Compressor Output Bytes count Low */
+	uint32_t dibc_h;	/* Decompressor Input Bytes count High */
+	uint32_t dibc_l;	/* Decompressor Input Bytes count Low */
+	uint32_t dobc_h;	/* Decompressor Output Bytes count High */
+	uint32_t dobc_l;	/* Decompressor Output Bytes count Low */
+	uint8_t reserved6[0x3f8-0x220];
+
+	/* Block ID */
+	uint32_t ip_rev_1;	/* DCE IP Block Revision 1 */
+	uint32_t ip_rev_2;	/* DCE IP Block Revision 2 */
+
+	/* Interrupt */
+	uint32_t isr;		/* Interrupt Status */
+	uint32_t ier;		/* Interrupt Enable */
+	uint32_t isdr;		/* Interrupt Status Disable */
+	uint32_t iir;		/* Interrupt Inhibit */
+	uint32_t ifr;		/* Interrupt Force */
+	uint8_t reserved7[0x440-0x414];
+
+	/* Error status */
+	uint32_t ecc1bes;	/* ECC 1-Bit Error Status */
+	uint32_t ecc2bes;	/* ECC 2-Bit Error Status */
+	uint32_t eccaddr;	/* ECC Address */
+	uint32_t ecc1th;	/* ECC 1-Bit Threshold */
+	uint32_t dhecc1ec;	/*
+				 * Decompression History memory ECC 1-Bit Error
+				 * Count
+				 */
+	uint32_t cxecc1ec;	/*
+				 * Internal Context memory ECC 1-Bit Error
+				 * Count
+				 */
+	uint32_t cbecc1ec;	/* Internal Data memory ECC 1-Bit Error Count */
+	uint8_t reserved8[0x480-0x45C];
+	/* revision 1.1 */
+	uint32_t uwe_info_h;	/* Unreported Write Error Information High */
+	uint32_t uwe_info_l;	/* Unreported Write Error Information Low */
+	/* pad out to 4k */
+	uint8_t padding[0x1000-0x488];
+};
+
+/* masks and shifts */
+
+/* DCE Configuration definitions */
+
+/* Read Safe Behavior */
+#define DCE_CFG_RSD_SHIFT	20
+#define DCE_CFG_RSD_MASK	(0x1UL << DCE_CFG_RSD_SHIFT)
+/* RSD Tokens */
+#define DCE_CFG_RSD_ENABLE	0x0UL
+#define DCE_CFG_RSD_DISABLE	0x1UL
+
+/* Dynamic Power Management Disable */
+#define DCE_CFG_DPMD_SHIFT	17
+#define DCE_CFG_DPMD_MASK	(0x1UL << DCE_CFG_DPMD_SHIFT)
+/* DPMD Tokens */
+#define DCE_CFG_DPMD_ENABLE	0x0UL
+#define DCE_CFG_DPMD_DISABLE	0x1UL
+
+/* Enable Level */
+#define DCE_CFG_EN_SHIFT	0
+#define DCE_CFG_EN_MASK		(0x3UL << DCE_CFG_EN_SHIFT)
+
+/* Enable level Tokens */
+#define DCE_CFG_EN_DISABLE	0x0UL
+#define DCE_CFG_EN_PAUSE	0x1UL
+#define DCE_CFG_EN_RESERVED	0x2UL
+#define DCE_CFG_EN_ENABLE	0x3UL
+
+/* Output Length Limit */
+#define DCE_OLL_SHIFT		0
+#define DCE_OLL_MASK		(0xffffUL << DCE_OLL_SHIFT)
+
+/* Hop Count Limit */
+#define DCE_HCL_SHIFT		0
+#define DCE_HCL_MASK		(0x3ffUL << DCE_HCL_SHIFT)
+
+/* Idle status */
+#define DCE_IDLE_STOPPED_SHIFT	8
+#define DCE_IDLE_STOPPED_MASK	(0x1UL << DCE_IDLE_STOPPED_SHIFT)
+
+/* Stopped Tokens */
+#define DCE_IDLE_STOPPED_YES	0x1UL
+#define DCE_IDLE_STOPPED_NO	0x0UL
+/* Idle */
+#define DCE_IDLE_IDLE_SHIFT	0
+#define DCE_IDLE_IDLE_MASK	(0x1UL << DCE_IDLE_IDLE_SHIFT)
+
+/* Idle Tokens */
+#define DCE_IDLE_IDLE_YES	0x1UL
+#define DCE_IDLE_IDLE_NO	0x0UL
+
+/* DCE System memory configuration */
+
+/* LIODN Base */
+#define DCE_LIODNBR_QI_SHARED_LIODN_BASE_SHIFT	16
+#define DCE_LIODNBR_QI_SHARED_LIODN_BASE_MASK \
+		(0xfffUL << DCE_LIODNBR_QI_SHARED_LIODN_BASE_SHIFT)
+
+#define DCE_LIODNBR_QI_JOB_LIODN_BASE_SHIFT	0
+#define DCE_LIODNBR_QI_JOB_LIODN_BASE_MASK \
+		(0xfffUL << DCE_LIODNBR_QI_JOB_LIODN_BASE_SHIFT)
+
+/* Source ID */
+#define DCE_SCRID_SHIFT			0
+#define DCE_SRCID_MASK			(0xffUL << DCE_SCRID_SHIFT)
+
+/* System Memory Cache Attribute Control */
+#define DCE_SMCACR_CHWC_SHIFT		28
+#define DCE_SMCACR_CHWC_MASK		(0x3UL << DCE_SMCACR_CHWC_SHIFT)
+
+/* CHWC Tokens */
+#define DCE_SMCACR_CHWC_NON_COHERENT	0x0UL
+#define DCE_SMCACR_CHWC_COHERENT	0x1UL
+#define DCE_SMCACR_CHWC_COHERENT_STASH	0x2UL
+
+#define DCE_SMCACR_SCWC_SHIFT		24
+#define DCE_SMCACR_SCWC_MASK		(0x3UL << DCE_SMCACR_SCWC_SHIFT)
+
+/* SCWC Tokens */
+#define DCE_SMCACR_SCWC_NON_COHERENT	0x0UL
+#define DCE_SMCACR_SCWC_COHERENT	0x1UL
+#define DCE_SMCACR_SCWC_COHERENT_STASH	0x2UL
+
+#define DCE_SMCACR_FDWC_SHIFT		20
+#define DCE_SMCACR_FDWC_MASK		(0x3UL << DCE_SMCACR_FDWC_SHIFT)
+/* SMCACR Tokens */
+#define DCE_SMCACR_FDWC_NON_COHERENT	0x0UL
+#define DCE_SMCACR_FDWC_COHERENT	0x1UL
+#define DCE_SMCACR_FDWC_COHERENT_STASH	0x2UL
+
+#define DCE_SMCACR_DHWC_SHIFT		16
+#define DCE_SMCACR_DHWC_MASK		(0x3UL << DCE_SMCACR_DHWC_SHIFT)
+/* DHWC Tokens */
+#define DCE_SMCACR_DHWC_NON_COHERENT	0x0UL
+#define DCE_SMCACR_DHWC_COHERENT	0x1UL
+#define DCE_SMCACR_DHWC_COHERENT_STASH	0x2UL
+
+#define DCE_SMCACR_CHRC_SHIFT		12
+#define DCE_SMCACR_CHRC_MASK		(0x3UL << DCE_SMCACR_CHRC_SHIFT)
+/* CHRC Tokens */
+#define DCE_SMCACR_CHRC_NON_COHERENT	0x0UL
+#define DCE_SMCACR_CHRC_COHERENT	0x1UL
+#define DCE_SMCACR_CHRC_COHERENT_STASH	0x2UL
+
+#define DCE_SMCACR_SCRC_SHIFT		8
+#define DCE_SMCACR_SCRC_MASK		(0x3UL << DCE_SMCACR_SCRC_SHIFT)
+/* SCRC Tokens */
+#define DCE_SMCACR_SCRC_NON_COHERENT	0x0UL
+#define DCE_SMCACR_SCRC_COHERENT	0x1UL
+#define DCE_SMCACR_SCRC_COHERENT_STASH	0x2UL
+
+#define DCE_SMCACR_FDRC_SHIFT		4
+#define DCE_SMCACR_FDRC_MASK		(0x3UL << DCE_SMCACR_FDRC_SHIFT)
+/* FDRC Tokens */
+#define DCE_SMCACR_FDRC_NON_COHERENT	0x0
+#define DCE_SMCACR_FDRC_COHERENT	0x1
+#define DCE_SMCACR_FDRC_COHERENT_STASH	0x2
+
+#define DCE_SMCACR_DHRC_SHIFT		0
+#define DCE_SMCACR_DHRC_MASK		(0x3UL << DCE_SMCACR_DHRC_SHIFT)
+/* DHRC Tokens */
+#define DCE_SMCACR_DHRC_NON_COHERENT	0x0UL
+#define DCE_SMCACR_DHRC_COHERENT	0x1UL
+#define DCE_SMCACR_DHRC_COHERENT_STASH	0x2UL
+
+/* System Memory Priority Control */
+/* Write Priority */
+#define DCE_SMPCR_WP_SHIFT		4
+#define DCE_SMPCR_WP_MASK		(0x1UL << DCE_SMPCR_WP_SHIFT)
+/* WP Tokens */
+#define DCE_SMPCR_WP_NORMAL		0x0UL
+#define DCE_SMPCR_WP_ELEVATED		0x1UL
+/* Read Priority */
+#define DCE_SMPCR_RP_SHIFT		0
+#define DCE_SMPCR_RP_MASK		(0x1UL << DCE_SMPCR_RP_SHIFT)
+/* RP Tokens */
+#define DCE_SMPCR_RP_NORMAL		0x0UL
+#define DCE_SMPCR_RP_ELEVATED		0x1UL
+
+/* Internal Context Invalid */
+/* Invalidate Internal Context */
+#define DCE_ICIR_ICI_SHIFT		0
+#define DCE_ICIR_ICI_MASK		(0x1UL << DCE_ICIR_ICI_SHIFT)
+/* ICIR Tokens */
+#define DCE_ICIR_ICI_NO_EFFECT		0x0
+#define DCE_ICIR_ICI_INVALIDATE		0x1
+
+/* Statistics */
+/* Compressor Input Byte count High */
+#define DCE_CIBC_H_SHIFT		0
+#define DCE_CIBC_H_MASK			(0xffffffffUL << DCE_CIBC_H_SHIFT)
+/* Compressor Input Byte count Low */
+#define DCE_CIBC_L_SHIFT		0
+#define DCE_CIBC_L_MASK			(0xffffffffUL << DCE_CIBC_L_SHIFT)
+/* Compressor Output Byte count High */
+#define DCE_COBC_H_SHIFT		0
+#define DCE_COBC_H_MASK			(0xffffffffUL << DCE_COBC_H_SHIFT)
+/* Compressor Output Byte count Low */
+#define DCE_COBC_L_SHIFT		0
+#define DCE_COBC_L_MASK			(0xffffffffUL << DCE_COBC_L_SHIFT)
+
+/* Decompressor Input Byte count High */
+#define DCE_DIBC_H_SHIFT		0
+#define DCE_DIBC_H_MASK			(0xffffffffUL << DCE_DIBC_H_SHIFT)
+/* Decompressor Input Byte count Low */
+#define DCE_DIBC_L_SHIFT		0
+#define DCE_DIBC_L_MASK			(0xffffffffUL << DCE_DIBC_L_SHIFT)
+/* Decompressor Output Byte count High */
+#define DCE_DOBC_H_SHIFT		0
+#define DCE_DOBC_H_MASK			(0xffffffffUL << DCE_DOBC_H_SHIFT)
+/* Decompressor Output Byte count Low */
+#define DCE_DOBC_L_SHIFT		0
+#define DCE_DOBC_L_MASK			(0xffffffffUL << DCE_DOBC_L_SHIFT)
+
+/* Block ID */
+/* Revision 1 */
+#define DCE_IP_REV_1_IP_ID_SHIFT	16
+#define DCE_IP_REV_1_IP_ID_MASK		(0xffffUL << DCE_IP_REV_1_IP_ID_SHIFT)
+/* IP_ID Tokens */
+#define DCE_IP_REV_1_IP_ID_DCE		0xaf0UL
+/* Major */
+#define DCE_IP_REV_1_IP_MJ_SHIFT	8
+#define DCE_IP_REV_1_IP_MJ_MASK		(0xffUL << DCE_IP_REV_1_IP_MJ_SHIFT)
+/* Minor */
+#define DCE_IP_REV_1_IP_MN_SHIFT	0
+#define DCE_IP_REV_1_IP_MN_MASK		(0xffUL << DCE_IP_REV_1_IP_MN_SHIFT)
+/* Revision 2 */
+/* Integration Option */
+#define DCE_IP_REV_2_IP_INT_SHIFT	16
+#define DCE_IP_REV_2_IP_INT_MASK	(0xffUL << DCE_IP_REV_2_IP_INT_SHIFT)
+/* Errata Revision Level */
+#define DCE_IP_REV_2_IP_ERR_SHIFT	8
+#define DCE_IP_REV_2_IP_ERR_MASK	(0xffUL << DCE_IP_REV_2_IP_ERR_SHIFT)
+/* Configuration Option */
+#define DCE_IP_REV_2_IP_CFG_SHIFT	0
+#define DCE_IP_REV_2_IP_CFG_MASK	(0xffUL << DCE_IP_REV_2_IP_CFG_SHIFT)
+
+/* Interrupt */
+
+/* Interrupt Status */
+/* Unreported Write Error */
+#define DCE_ISR_UWE_SHIFT		7
+#define DCE_ISR_UWE_MASK		(0x1UL << DCE_ISR_UWE_SHIFT)
+/* ISR UWE Tokens */
+#define DCE_ISR_UWE_NONE		0x0UL
+#define DCE_ISR_UWE_AT_LEAST_ONE	0x1UL
+
+/* Single Bit Error */
+#define DCE_ISR_SBE_SHIFT		1
+#define DCE_ISR_SBE_MASK		(0x1UL << DCE_ISR_SBE_SHIFT)
+
+/* ISR SBE Tokens */
+#define DCE_ISR_SBE_NONE		0x0UL
+#define DCE_ISR_SBE_AT_LEAST_ONE	0x1UL
+
+/* Double Bit Error */
+#define DCE_ISR_DBE_SHIFT		0
+#define DCE_ISR_DBE_MASK		(0x1UL << DCE_ISR_DBE_SHIFT)
+/* ISR DBE Tokens */
+#define DCE_ISR_DBE_NONE		0x0UL
+#define DCE_ISR_DBE_AT_LEAST_ONE	0x1UL
+
+/* Interrupt Enable */
+/* Unreported Write Error */
+#define DCE_IER_UWE_SHIFT		7
+#define DCE_IER_UWE_MASK		(0x1UL << DCE_IER_UWE_SHIFT)
+
+/* IER UWE Tokens */
+#define DCE_IER_UWE_DISABLE		0x0UL
+#define DCE_IER_UWE_ENABLE		0x1UL
+
+/* Single Bit Error */
+#define DCE_IER_SBE_SHIFT		1
+#define DCE_IER_SBE_MASK		(0x1UL << DCE_IER_SBE_SHIFT)
+/* IER SBE Tokens */
+#define DCE_IER_SBE_DISABLE		0x0
+#define DCE_IER_SBE_ENABLE		0x1
+
+/* Double Bit Error */
+#define DCE_IER_DBE_SHIFT		0
+#define DCE_IER_DBE_MASK		(0x1UL << DCE_IER_DBE_SHIFT)
+/* IER DBE Tokens */
+#define DCE_IER_DBE_DISABLE		0x0
+#define DCE_IER_DBE_ENABLE		0x1
+
+/* All interrupts */
+#define DCE_IER_ALL_MASK \
+	(DCE_IER_UWE_MASK | DCE_IER_SBE_MASK | DCE_IER_DBE_MASK)
+#define DCE_IER_ALL_SHIFT		0
+/* IER ALL Tokens */
+#define DCE_IER_ALL_DISABLE		0x0UL
+#define DCE_IER_ALL_ENABLE		0x83UL
+
+/* Interrupt Status Disable */
+/* Unreported Write Error */
+#define DCE_ISDR_UWE_SHIFT		7
+#define DCE_ISDR_UWE_MASK		(0x1UL << DCE_ISDR_UWE_SHIFT)
+
+/* IER UWE Tokens */
+#define DCE_ISDR_UWE_DISABLE		0x0UL
+#define DCE_ISDR_UWE_ENABLE		0x1UL
+
+/* Single Bit Error */
+#define DCE_ISDR_SBE_SHIFT		1
+#define DCE_ISDR_SBE_MASK		(0x1UL << DCE_ISDR_SBE_SHIFT)
+/* IER SBE Tokens */
+#define DCE_ISDR_SBE_DISABLE		0x0UL
+#define DCE_ISDR_SBE_ENABLE		0x1UL
+
+/* Double Bit Error */
+#define DCE_ISDR_DBE_SHIFT		0
+#define DCE_ISDR_DBE_MASK		(0x1UL << DCE_ISDR_DBE_SHIFT)
+/* IER DBE Tokens */
+#define DCE_ISDR_DBE_DISABLE		0x0UL
+#define DCE_ISDR_DBE_ENABLE		0x1UL
+
+/* Interrupt Inhibit */
+/* Inhibit */
+#define DCE_IIR_I_SHIFT			0
+#define DCE_IIR_I_MASK			(0x1UL << DCE_IIR_I_SHIFT)
+
+/* IIR I Tokens */
+#define DCE_IIR_I_CLEAR			0x0UL
+#define DCE_IIR_I_SET			0x1UL
+
+/* Interrupt Force */
+/* Unreported Write Error */
+#define DCE_IFR_UWE_SHIFT		7
+#define DCE_IFR_UWE_MASK		(0x1UL << DCE_IFR_UWE_SHIFT)
+/* IFR UWE Tokens */
+#define DCE_IFR_UWE_SET			0x1UL
+
+/* Single Bit Error */
+#define DCE_IFR_SBE_SHIFT		1
+#define DCE_IFR_SBE_MASK		(0x1UL << DCE_IFR_SBE_SHIFT)
+/* IFR SBE Tokens */
+#define DCE_IFR_SBE_SET			0x1UL
+
+/* Double Bit Error */
+#define DCE_IFR_DBE_SHIFT		0
+#define DCE_IFR_DBE_MASK		(0x1UL << DCE_IFR_DBE_SHIFT)
+/* IFR DBE Tokens */
+#define DCE_IFR_DBE_SET			0x1
+
+/* Error Status */
+
+/* ECC 1-Bit Error Status */
+/* Compression History Memory */
+#define DCE_ECC1BES_CBM_SHIFT		2
+#define DCE_ECC1BES_CBM_MASK		(0x1UL << DCE_ECC1BES_CBM_MASK)
+
+/* CBM Tokens */
+#define DCE_ECC1BES_CBM_FALSE		0x0UL
+#define DCE_ECC1BES_CBM_TRUE		0x1UL
+#define DCE_ECC1BES_CBM_CLEAR		0x1UL
+
+/* Decompression History Memory */
+#define DCE_ECC1BES_DHM_SHIFT		1
+#define DCE_ECC1BES_DHM_MASK		(0x1UL << DCE_ECC1BES_DHM_SHIFT)
+/* DHM Tokens */
+#define DCE_ECC1BES_DHM_FALSE		0x0UL
+#define DCE_ECC1BES_DHM_TRUE		0x1UL
+#define DCE_ECC1BES_DHM_CLEAR		0x1UL
+
+/* Internal Context Memory */
+#define DCE_ECC1BES_CXM_SHIFT		0
+#define DCE_ECC1BES_CXM_MASK		(0x1UL << DCE_ECC1BES_CXM_SHIFT)
+/* CXM Tokens */
+#define DCE_ECC1BES_CXM_FALSE		0x0UL
+#define DCE_ECC1BES_CXM_TRUE		0x1UL
+#define DCE_ECC1BES_CXM_CLEAR		0x1UL
+
+/* ECC 2-Bit Error Status */
+/* Compression History Memory */
+#define DCE_ECC2BES_CBM_SHIFT		2
+#define DCE_ECC2BES_CBM_MASK		(0x1UL << DCE_ECC2BES_CBM_SHIFT)
+/* CBM Tokens */
+#define DCE_ECC2BES_CBM_FALSE		0x0UL
+#define DCE_ECC2BES_CBM_TRUE		0x1UL
+#define DCE_ECC2BES_CBM_CLEAR		0x1UL
+
+/* Decompression History Memory */
+#define DCE_ECC2BES_DHM_SHIFT		1
+#define DCE_ECC2BES_DHM_MASK		(0x1UL << DCE_ECC2BES_DHM_SHIFT)
+/* DHM Tokens */
+#define DCE_ECC2BES_DHM_FALSE		0x0UL
+#define DCE_ECC2BES_DHM_TRUE		0x1UL
+#define DCE_ECC2BES_DHM_CLEAR		0x1UL
+
+/* Internal Context Memory */
+#define DCE_ECC2BES_CXM_SHIFT		0
+#define DCE_ECC2BES_CXM_MASK		(0x1UL << DCE_ECC2BES_CXM_SHIFT)
+/* CXM Tokens */
+#define DCE_ECC2BES_CXM_FALSE		0x0UL
+#define DCE_ECC2BES_CXM_TRUE		0x1UL
+#define DCE_ECC2BES_CXM_CLEAR		0x1UL
+
+/* ECC Address */
+/* Capture Error Indication */
+#define DCE_ECCADDR_CAP_SHIFT		31
+#define DCE_ECCADDR_CAP_MASK		(0x1UL << DCE_ECCADDR_CAP_SHIFT)
+/* CAP Tokens */
+#define DCE_ECCADDR_CAP_NONE		0x0UL
+#define DCE_ECCADDR_CAP_CAPTURED	0x1UL
+#define DCE_ECCADDR_CAP_CLEAR		0x1UL
+
+/* Capture Error Type */
+#define DCE_ECCADDR_CAT_SHIFT		30
+#define DCE_ECCADDR_CAT_MASK		(0x1UL << DCE_ECCADDR_CAT_SHIFT)
+/* CAT Tokens */
+#define DCE_ECCADDR_CAT_SB_ECC		0x0UL
+#define DCE_ECCADDR_CAT_MB_ECC		0x1UL
+
+/* Memory Identifier */
+#define DCE_ECCADDR_MEM_SHIFT		16
+#define DCE_ECCADDR_MEM_MASK		(0x1fUL << DCE_ECCADDR_MEM_SHIFT)
+/* MEM Tokens */
+#define DCE_ECCADDR_MEM_DHM0		0x0UL
+#define DCE_ECCADDR_MEM_DHM1		0x1UL
+#define DCE_ECCADDR_MEM_DHM2		0x2UL
+#define DCE_ECCADDR_MEM_DHM3		0x3UL
+#define DCE_ECCADDR_MEM_DHM4		0x4UL
+#define DCE_ECCADDR_MEM_DHM5		0x5UL
+#define DCE_ECCADDR_MEM_DHM6		0x6UL
+#define DCE_ECCADDR_MEM_DHM7		0x7UL
+#define DCE_ECCADDR_MEM_CBM0		0x8UL
+#define DCE_ECCADDR_MEM_CBM1		0x9UL
+#define DCE_ECCADDR_MEM_CBM2		0xaUL
+#define DCE_ECCADDR_MEM_CBM3		0xbUL
+#define DCE_ECCADDR_MEM_CBM4		0xcUL
+#define DCE_ECCADDR_MEM_CBM5		0xdUL
+#define DCE_ECCADDR_MEM_CBM6		0xeUL
+#define DCE_ECCADDR_MEM_CBM7		0xfUL
+#define DCE_ECCADDR_MEM_CXMA0		0x10UL
+#define DCE_ECCADDR_MEM_CXMB0		0x11UL
+#define DCE_ECCADDR_MEM_CXMA1		0x12UL
+#define DCE_ECCADDR_MEM_CXMB1		0x13UL
+#define DCE_ECCADDR_MEM_CXMA2		0x14UL
+#define DCE_ECCADDR_MEM_CXMB2		0x15UL
+#define DCE_ECCADDR_MEM_CXMA3		0x16UL
+#define DCE_ECCADDR_MEM_CXMB3		0x17UL
+#define DCE_ECCADDR_MEM_CXMA4		0x18UL
+#define DCE_ECCADDR_MEM_CXMB4		0x19UL
+#define DCE_ECCADDR_MEM_CXMA5		0x1aUL
+#define DCE_ECCADDR_MEM_CXMB5		0x1bUL
+#define DCE_ECCADDR_MEM_CXMA6		0x1cUL
+#define DCE_ECCADDR_MEM_CXMB6		0x1dUL
+#define DCE_ECCADDR_MEM_CXMA7		0x1eUL
+#define DCE_ECCADDR_MEM_CXMB7		0x1fUL
+
+/* Capture the address within the memory upon which the error occurred */
+#define DCE_ECCADDR_ADDR_SHIFT		0
+#define DCE_ECCADDR_ADDR_MASK		(0xffffUL << DCE_ECCADDR_ADDR_SHIFT)
+
+/* ECC 1-Bit Threshold */
+/* Internal Data Memory */
+#define DCE_ECC1TH_DECBM_SHIFT		10
+#define DCE_ECC1TH_DECBM_MASK		(0x1UL << DCE_ECC1TH_DECBM_SHIFT)
+/* DECBM Tokens */
+#define DCE_ECC1TH_DECBM_DISABLE	0x1UL
+#define DCE_ECC1TH_DECBM_ENABLE		0x0UL
+
+/* Decompression History Memory */
+#define DCE_ECC1TH_DEDHM_SHIFT		9
+#define DCE_ECC1TH_DEDHM_MASK		(0x1UL << DCE_ECC1TH_DEDHM_SHIFT)
+/* DEDHM Tokens */
+#define DCE_ECC1TH_DEDHM_DISABLE	0x1UL
+#define DCE_ECC1TH_DEDHM_ENABLE		0x0UL
+
+/* Internal Context Memory */
+#define DCE_ECC1TH_DECXM_SHIFT		8
+#define DCE_ECC1TH_DECXM_MASK		(0x1UL << DCE_ECC1TH_DECXM_SHIFT)
+/* DECXM Tokens */
+#define DCE_ECC1TH_DECXM_DISABLE	0x1UL
+#define DCE_ECC1TH_DECXM_ENABLE		0x0UL
+
+/* Threshold value */
+#define DCE_ECC1TH_THRESH_SHIFT		0
+#define DCE_ECC1TH_THRESH_MASK		(0xffUL << DCE_ECC1TH_THRESH_SHIFT)
+
+/* Decompression History memory ECC 1-Bit Count */
+/* Count */
+#define DCE_ECC1EC_COUNT_SHIFT		0
+#define DCE_ECC1EC_COUNT_MASK		(0xffUL << DCE_ECC1EC_COUNT_SHIFT)
+
+/* Internal Context ECC 1-Bit Error Count */
+/* Count */
+#define DCE_CXECC1EC_COUNT_SHIFT	0
+#define DCE_CXECC1EC_COUNT_MASK		(0xffUL << DCE_CXECC1EC_COUNT_SHIFT)
+
+/* Internal Data ECC 1-Bit Error Count */
+/* Count */
+#define DCE_CBECC1EC_COUNT_SHIFT	0
+#define DCE_CBECC1EC_COUNT_MASK		(0xffUL << DCE_CBECC1EC_COUNT_SHIFT)
+
+/* Unreported Write Error Information High */
+/* LIODN */
+#define DCE_UWE_INFO_H_LIODN_SHIFT	16
+#define DCE_UWE_INFO_H_LIODN_MASK	(0xfffUL << DCE_UWE_INFO_H_LIODN_SHIFT)
+/* SCRP */
+#define DCE_UWE_INFO_H_SCRP_SHIFT	0
+#define DCE_UWE_INFO_H_SCRP_MASK (0xffUL << DCE_UWE_INFO_H_SCRP_SHIFT)
+
+/* Unreported Write Error Information Low */
+#define DCE_UWE_INFO_L_SCRP_SHIFT	6
+#define DCE_UWE_INFO_L_SCRP_MASK (0x3ffffffUL << DCE_UWE_INFO_L_SCRP_SHIFT)
+
+/* helper to get combine and shift SCRPH and L */
+#define DCE_GEN_SCRP(scrp_h, scrp_l) \
+	(((uint64_t)scrp_h << 32 | scrp_l) << DCE_UWE_INFO_L_SCRP_SHIFT)
+
+#endif /* FL_DCE_REGS_H */
diff --git a/drivers/staging/fsl_dce/fsl_dce.h b/drivers/staging/fsl_dce/fsl_dce.h
new file mode 100644
index 0000000..8df4316
--- /dev/null
+++ b/drivers/staging/fsl_dce/fsl_dce.h
@@ -0,0 +1,60 @@
+/* Copyright 2013 Freescale Semiconductor, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the names of its
+ *       contributors may be used to endorse or promote products derived from
+ *       this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * This software is provided by Freescale Semiconductor "as is" and any
+ * express or implied warranties, including, but not limited to, the implied
+ * warranties of merchantability and fitness for a particular purpose are
+ * disclaimed. In no event shall Freescale Semiconductor be liable for any
+ * direct, indirect, incidental, special, exemplary, or consequential damages
+ * (including, but not limited to, procurement of substitute goods or services;
+ * loss of use, data, or profits; or business interruption) however caused and
+ * on any theory of liability, whether in contract, strict liability, or tort
+ * (including negligence or otherwise) arising in any way out of the use of
+ * this software, even if advised of the possibility of such damage.
+ */
+
+#ifndef FSL_DCE_H
+#define FSL_DCE_H
+
+/****************/
+/* KERNEL SPACE */
+/****************/
+
+#ifdef __KERNEL__
+
+/* Does dce have access to ccsr */
+int fsl_dce_have_control(void);
+
+/**************************/
+/* control-plane only API */
+/**************************/
+
+enum fsl_dce_stat_attr {
+	DCE_COMP_INPUT_BYTES,
+	DCE_COMP_OUTPUT_BYTES,
+	DCE_DECOMP_INPUT_BYTES,
+	DCE_DECOMP_OUTPUT_BYTES
+};
+
+int fsl_dce_get_stat(enum fsl_dce_stat_attr attr, uint64_t *val, int reset);
+int fsl_dce_clear_stat(enum fsl_dce_stat_attr attr);
+
+#endif /* __KERNEL__ */
+
+#endif /* FSL_DCE_H */
-- 
1.7.5.4

