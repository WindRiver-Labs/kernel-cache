From 27fe3386d2771340c43edf31a01cf5a29eb1f2db Mon Sep 17 00:00:00 2001
From: "J. German Rivera" <German.Rivera@freescale.com>
Date: Tue, 21 Apr 2015 11:33:02 -0500
Subject: [PATCH 0486/1383] staging: fsl-mc: Fix missing cases for for
 interrupts not supported

When DPMCP interrupt support was added, I forgot to consider cases
in which support without interrupts is needed.

Signed-off-by: J. German Rivera <German.Rivera@freescale.com>
Change-Id: I2575daba67c76a2a1d6cc495cbaf94d03acf470d
Reviewed-on: http://git.am.freescale.net:8181/35383
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bharat Bhushan <Bharat.Bhushan@freescale.com>
Reviewed-by: Stuart Yoder <stuart.yoder@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-mc/bus/dprc-driver.c  | 65 ++++++++++++++++---------------
 drivers/staging/fsl-mc/bus/mc-allocator.c |  6 +++
 drivers/staging/fsl-mc/bus/mc-bus.c       |  8 +++-
 drivers/staging/fsl-mc/bus/mc-sys.c       | 11 +++++-
 4 files changed, 55 insertions(+), 35 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/dprc-driver.c b/drivers/staging/fsl-mc/bus/dprc-driver.c
index 114869b..0fb065c 100644
--- a/drivers/staging/fsl-mc/bus/dprc-driver.c
+++ b/drivers/staging/fsl-mc/bus/dprc-driver.c
@@ -362,7 +362,6 @@ static int dprc_scan_container(struct fsl_mc_device *mc_bus_dev)
 	int error;
 	unsigned int irq_count;
 	struct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_bus_dev);
-	struct fsl_mc *mc = dev_get_drvdata(fsl_mc_bus_type.dev_root->parent);
 
 	dprc_init_all_resource_pools(mc_bus_dev);
 
@@ -375,7 +374,7 @@ static int dprc_scan_container(struct fsl_mc_device *mc_bus_dev)
 	if (error < 0)
 		goto error;
 
-	if (mc->gic_supported && !mc_bus->irq_resources) {
+	if (fsl_mc_interrupts_supported() && !mc_bus->irq_resources) {
 		irq_count += FSL_MC_IRQ_POOL_MAX_EXTRA_IRQS;
 		error = fsl_mc_populate_irq_pool(mc_bus, irq_count);
 		if (error < 0)
@@ -800,7 +799,6 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 	int error;
 	size_t region_size;
 	struct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);
-	struct fsl_mc *mc = dev_get_drvdata(fsl_mc_bus_type.dev_root->parent);
 	bool mc_io_created = false;
 
 	if (WARN_ON(strcmp(mc_dev->obj_desc.type, "dprc") != 0))
@@ -841,12 +839,14 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 		goto error_cleanup_open;
 	}
 
-	/*
-	 * Create DPMCP for the DPRC's built-in portal:
-	 */
-	error = dprc_create_dpmcp(mc_dev);
-	if (error < 0)
-		goto error_cleanup_open;
+	if (fsl_mc_interrupts_supported()) {
+		/*
+		 * Create DPMCP for the DPRC's built-in portal:
+		 */
+		error = dprc_create_dpmcp(mc_dev);
+		if (error < 0)
+			goto error_cleanup_open;
+	}
 
 	mutex_init(&mc_bus->scan_mutex);
 
@@ -857,27 +857,29 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 	if (error < 0)
 		goto error_destroy_dpmcp;
 
-	/*
-	 * The fsl_mc_device object associated with the DPMCP object created
-	 * above was created as part of the dprc_scan_container() call above:
-	 */
-	if (WARN_ON(!mc_dev->mc_io->dpmcp_dev)) {
-		error = -EINVAL;
-		goto error_cleanup_dprc_scan;
-	}
+	if (fsl_mc_interrupts_supported()) {
+		/*
+		 * The fsl_mc_device object associated with the DPMCP object
+		 * created above was created as part of the
+		 * dprc_scan_container() call above:
+		 */
+		if (WARN_ON(!mc_dev->mc_io->dpmcp_dev)) {
+			error = -EINVAL;
+			goto error_cleanup_dprc_scan;
+		}
 
-	/*
-	 * Configure interrupt for the DPMCP object associated with the
-	 * DPRC object's built-in portal:
-	 *
-	 * NOTE: We have to do this after calling dprc_scan_container(), since
-	 * dprc_scan_container() will populate the IRQ pool for this DPRC.
-	 */
-	error = fsl_mc_io_setup_dpmcp_irq(mc_dev->mc_io);
-	if (error < 0)
-		goto error_cleanup_dprc_scan;
+		/*
+		 * Configure interrupt for the DPMCP object associated with the
+		 * DPRC object's built-in portal:
+		 *
+		 * NOTE: We have to do this after calling dprc_scan_container(),
+		 * since dprc_scan_container() will populate the IRQ pool for
+		 * this DPRC.
+		 */
+		error = fsl_mc_io_setup_dpmcp_irq(mc_dev->mc_io);
+		if (error < 0)
+			goto error_cleanup_dprc_scan;
 
-	if (mc->gic_supported) {
 		/*
 		 * Configure interrupts for the DPRC object associated with
 		 * this MC bus:
@@ -894,7 +896,7 @@ error_cleanup_dprc_scan:
 	fsl_mc_io_unset_dpmcp(mc_dev->mc_io);
 	device_for_each_child(&mc_dev->dev, NULL, __fsl_mc_device_remove);
 	dprc_cleanup_all_resource_pools(mc_dev);
-	if (mc->gic_supported)
+	if (fsl_mc_interrupts_supported())
 		fsl_mc_cleanup_irq_pool(mc_bus);
 
 error_destroy_dpmcp:
@@ -935,7 +937,6 @@ static int dprc_remove(struct fsl_mc_device *mc_dev)
 {
 	int error;
 	struct fsl_mc_bus *mc_bus = to_fsl_mc_bus(mc_dev);
-	struct fsl_mc *mc = dev_get_drvdata(fsl_mc_bus_type.dev_root->parent);
 
 	if (WARN_ON(strcmp(mc_dev->obj_desc.type, "dprc") != 0))
 		return -EINVAL;
@@ -945,7 +946,7 @@ static int dprc_remove(struct fsl_mc_device *mc_dev)
 	if (WARN_ON(!mc_bus->irq_resources))
 		return -EINVAL;
 
-	if (mc->gic_supported)
+	if (fsl_mc_interrupts_supported())
 		dprc_teardown_irqs(mc_dev);
 
 	fsl_mc_io_unset_dpmcp(mc_dev->mc_io);
@@ -956,7 +957,7 @@ static int dprc_remove(struct fsl_mc_device *mc_dev)
 	if (error < 0)
 		dev_err(&mc_dev->dev, "dprc_close() failed: %d\n", error);
 
-	if (mc->gic_supported)
+	if (fsl_mc_interrupts_supported())
 		fsl_mc_cleanup_irq_pool(mc_bus);
 
 	dev_info(&mc_dev->dev, "DPRC device unbound from driver");
diff --git a/drivers/staging/fsl-mc/bus/mc-allocator.c b/drivers/staging/fsl-mc/bus/mc-allocator.c
index a29bb5f..d1bfa3a 100644
--- a/drivers/staging/fsl-mc/bus/mc-allocator.c
+++ b/drivers/staging/fsl-mc/bus/mc-allocator.c
@@ -347,7 +347,13 @@ void fsl_mc_portal_free(struct fsl_mc_io *mc_io)
 	struct fsl_mc_device *dpmcp_dev;
 	struct fsl_mc_resource *resource;
 
+	/*
+	 * Every mc_io obtained by calling fsl_mc_portal_allocate() is supposed
+	 * to have a DPMCP object associated with.
+	 */
 	dpmcp_dev = mc_io->dpmcp_dev;
+	if (WARN_ON(!dpmcp_dev))
+		return;
 	if (WARN_ON(strcmp(dpmcp_dev->obj_desc.type, "dpmcp") != 0))
 		return;
 	if (WARN_ON(dpmcp_dev->mc_io != mc_io))
diff --git a/drivers/staging/fsl-mc/bus/mc-bus.c b/drivers/staging/fsl-mc/bus/mc-bus.c
index eb76caa9..012b71d 100644
--- a/drivers/staging/fsl-mc/bus/mc-bus.c
+++ b/drivers/staging/fsl-mc/bus/mc-bus.c
@@ -1101,7 +1101,9 @@ error_cleanup_mc_io:
 	fsl_destroy_mc_io(mc_io);
 
 error_cleanup_irq_domain:
-	irq_domain_remove(mc->irq_domain);
+	if (mc->gic_supported)
+		irq_domain_remove(mc->irq_domain);
+
 	return error;
 }
 
@@ -1116,7 +1118,9 @@ static int fsl_mc_bus_remove(struct platform_device *pdev)
 	if (WARN_ON(&mc->root_mc_bus_dev->dev != fsl_mc_bus_type.dev_root))
 		return -EINVAL;
 
-	irq_domain_remove(mc->irq_domain);
+	if (mc->gic_supported)
+		irq_domain_remove(mc->irq_domain);
+
 	fsl_mc_device_remove(mc->root_mc_bus_dev);
 	dev_info(&pdev->dev, "Root MC bus device removed");
 	return 0;
diff --git a/drivers/staging/fsl-mc/bus/mc-sys.c b/drivers/staging/fsl-mc/bus/mc-sys.c
index a3df1d9..4628746 100644
--- a/drivers/staging/fsl-mc/bus/mc-sys.c
+++ b/drivers/staging/fsl-mc/bus/mc-sys.c
@@ -223,6 +223,9 @@ int fsl_mc_io_setup_dpmcp_irq(struct fsl_mc_io *mc_io)
 	if (WARN_ON(!dpmcp_dev))
 		return -EINVAL;
 
+	if (WARN_ON(!fsl_mc_interrupts_supported()))
+		return -EINVAL;
+
 	if (WARN_ON(dpmcp_dev->obj_desc.irq_count != 1))
 		return -EINVAL;
 
@@ -267,6 +270,8 @@ static void teardown_dpmcp_irq(struct fsl_mc_io *mc_io)
 
 	if (WARN_ON(!dpmcp_dev))
 		return;
+	if (WARN_ON(!fsl_mc_interrupts_supported()))
+		return;
 	if (WARN_ON(!dpmcp_dev->irqs))
 		return;
 
@@ -343,7 +348,8 @@ int __must_check fsl_create_mc_io(struct device *dev,
 		if (error < 0)
 			goto error_destroy_mc_io;
 
-		if (!(flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL)) {
+		if (!(flags & FSL_MC_IO_ATOMIC_CONTEXT_PORTAL) &&
+		    fsl_mc_interrupts_supported()) {
 			error = fsl_mc_io_setup_dpmcp_irq(mc_io);
 			if (error < 0)
 				goto error_destroy_mc_io;
@@ -387,6 +393,9 @@ int fsl_mc_io_set_dpmcp(struct fsl_mc_io *mc_io,
 {
 	int error;
 
+	if (WARN_ON(!dpmcp_dev))
+		return -EINVAL;
+
 	if (WARN_ON(mc_io->dpmcp_dev))
 		return -EINVAL;
 
-- 
2.8.1

