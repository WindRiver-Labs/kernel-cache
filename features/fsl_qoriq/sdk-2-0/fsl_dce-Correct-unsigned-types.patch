From ba84a65403070110be75f7187b0dda161b85d1ab Mon Sep 17 00:00:00 2001
From: Ahmed Mansour <Ahmed.Mansour@freescale.com>
Date: Tue, 26 Jan 2016 16:13:22 -0500
Subject: [PATCH 1228/1429] fsl_dce: Correct unsigned types

Replaced uintx_t with the corresponding Linux types. e.g. uint32_t is
replaced with u32.

Corrected typo `lenght' to be `length' in tests

Signed-off-by: Ahmed Mansour <Ahmed.Mansour@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl_dce/dce_debugfs.c              |   30 ++--
 drivers/staging/fsl_dce/dce_driver.c               |   10 +-
 drivers/staging/fsl_dce/flib/bitfield_macros.h     |    2 +-
 drivers/staging/fsl_dce/flib/dce_defs.h            |  174 ++++++++++----------
 drivers/staging/fsl_dce/flib/dce_flow.c            |   32 ++--
 drivers/staging/fsl_dce/flib/dce_flow.h            |   44 +++---
 drivers/staging/fsl_dce/flib/dce_helper.h          |   12 +-
 drivers/staging/fsl_dce/flib/dce_regs.h            |   86 +++++-----
 drivers/staging/fsl_dce/fsl_dce.h                  |    2 +-
 drivers/staging/fsl_dce/fsl_dce_chunk.c            |   14 +-
 drivers/staging/fsl_dce/fsl_dce_chunk.h            |   16 +-
 drivers/staging/fsl_dce/fsl_dce_stream.c           |   18 +-
 drivers/staging/fsl_dce/fsl_dce_stream.h           |   22 ++--
 .../chunk_comp_def_cf/dce_chunk_comp_def_cf_test.c |    2 +-
 .../fsl_dce/tests/common/test_frame_helpers.c      |    6 +-
 .../tests/performance_simple/dce_perf_simple.c     |   46 +++---
 .../tests/performance_simple/dce_sf_perf_simple.c  |   58 ++++----
 17 files changed, 287 insertions(+), 287 deletions(-)

diff --git a/drivers/staging/fsl_dce/dce_debugfs.c b/drivers/staging/fsl_dce/dce_debugfs.c
index 34ba589..d291c59 100644
--- a/drivers/staging/fsl_dce/dce_debugfs.c
+++ b/drivers/staging/fsl_dce/dce_debugfs.c
@@ -39,8 +39,8 @@
 
 #define DRV_VERSION "0.1"
 
-static uint64_t dce_ccsr_start;
-static uint64_t dce_ccsr_size;
+static u64 dce_ccsr_start;
+static u64 dce_ccsr_size;
 
 /* takes userspace input and converts to upper case */
 static int user_input_convert(const char __user *user_buf, size_t count,
@@ -61,14 +61,14 @@ static int user_input_convert(const char __user *user_buf, size_t count,
 static struct dentry *dfs_root; /* debugfs root directory */
 
 struct dce_register_s {
-	uint32_t val;
+	u32 val;
 };
 static struct dce_register_s dce_register_data;
 
 static int init_ccsrmempeek(void)
 {
 	struct device_node *dn;
-	const uint32_t *regaddr_p;
+	const u32 *regaddr_p;
 
 	dn = of_find_compatible_node(NULL, NULL, "fsl,dce");
 	if (!dn) {
@@ -86,19 +86,19 @@ static int init_ccsrmempeek(void)
 }
 
 /* This function provides access to DCE ccsr memory map */
-static int dce_ccsrmem_get(uint32_t *val, uint32_t offset)
+static int dce_ccsrmem_get(u32 *val, u32 offset)
 {
 	void __iomem *addr;
-	uint64_t phys_addr;
+	u64 phys_addr;
 
 	if (!dce_ccsr_start)
 		return -EINVAL;
 
-	if (offset > (dce_ccsr_size - sizeof(uint32_t)))
+	if (offset > (dce_ccsr_size - sizeof(u32)))
 		return -EINVAL;
 
 	phys_addr = dce_ccsr_start + offset;
-	addr = ioremap(phys_addr, sizeof(uint32_t));
+	addr = ioremap(phys_addr, sizeof(u32));
 	if (!addr) {
 		pr_err("ccsrmem, ioremap failed\n");
 		return -EINVAL;
@@ -108,19 +108,19 @@ static int dce_ccsrmem_get(uint32_t *val, uint32_t offset)
 	return 0;
 }
 
-static int dce_ccsrmem_put(uint32_t val, uint32_t offset)
+static int dce_ccsrmem_put(u32 val, u32 offset)
 {
 	void __iomem *addr;
-	uint64_t phys_addr;
+	u64 phys_addr;
 
 	if (!dce_ccsr_start)
 		return -EINVAL;
 
-	if (offset > (dce_ccsr_size - sizeof(uint32_t)))
+	if (offset > (dce_ccsr_size - sizeof(u32)))
 		return -EINVAL;
 
 	phys_addr = dce_ccsr_start + offset;
-	addr = ioremap(phys_addr, sizeof(uint32_t));
+	addr = ioremap(phys_addr, sizeof(u32));
 	if (!addr) {
 		pr_err("ccsrmem, ioremap failed\n");
 		return -EINVAL;
@@ -153,9 +153,9 @@ static ssize_t dce_ccsrmem_addr_write(struct file *f, const char __user *buf,
 	if (ret)
 		return ret;
 	/* multiple of 4 */
-	if (val > (dce_ccsr_size - sizeof(uint32_t))) {
+	if (val > (dce_ccsr_size - sizeof(u32))) {
 		pr_info("Input 0x%lx > 0x%llx\n",
-			val, (dce_ccsr_size - sizeof(uint32_t)));
+			val, (dce_ccsr_size - sizeof(u32)));
 		return -EINVAL;
 	}
 	if (val & 0x3) {
@@ -176,7 +176,7 @@ static const struct file_operations dce_ccsrmem_addr_fops = {
 
 static int dce_ccsrmem_rw_show(struct seq_file *file, void *offset)
 {
-	uint32_t out_val = 0;
+	u32 out_val = 0;
 	int ret;
 
 	ret = dce_ccsrmem_get(&out_val, dce_register_data.val);
diff --git a/drivers/staging/fsl_dce/dce_driver.c b/drivers/staging/fsl_dce/dce_driver.c
index 07ccb0d..3bcd752 100644
--- a/drivers/staging/fsl_dce/dce_driver.c
+++ b/drivers/staging/fsl_dce/dce_driver.c
@@ -45,7 +45,7 @@
 
 #define DRV_VERSION "0.1"
 
-uint16_t dce_ip_rev = DCE_REV10;
+u16 dce_ip_rev = DCE_REV10;
 EXPORT_SYMBOL(dce_ip_rev);
 
 /* Pointer used to represent the DCE CCSR map and its instance */
@@ -68,8 +68,8 @@ static irqreturn_t dce_isr(int irq, void *st_dev)
 {
 	struct device *dev = st_dev;
 	struct dce_drv_private *ctrlpriv = dev_get_drvdata(dev);
-	static uint32_t last_isrstate;
-	uint32_t isrstate = ioread32be(&ctrlpriv->topregs->isr) ^ last_isrstate;
+	static u32 last_isrstate;
+	u32 isrstate = ioread32be(&ctrlpriv->topregs->isr) ^ last_isrstate;
 
 	/* What new ISR state has been raise */
 	if (!isrstate)
@@ -79,7 +79,7 @@ static irqreturn_t dce_isr(int irq, void *st_dev)
 	if (ISEQ_32FTK(isrstate, DCE_ISR_DBE, AT_LEAST_ONE))
 		dev_err(dev, "Double Bit Error detected\n");
 	if (ISEQ_32FTK(isrstate, DCE_ISR_UWE, AT_LEAST_ONE)) {
-		uint32_t uwe_high, uwe_low;
+		u32 uwe_high, uwe_low;
 
 		/* print extra info registers */
 		uwe_high = ioread32be(&ctrlpriv->topregs->uwe_info_h);
@@ -264,7 +264,7 @@ int fsl_dce_have_control(void)
 }
 EXPORT_SYMBOL(fsl_dce_have_control);
 
-int fsl_dce_get_stat(enum fsl_dce_stat_attr attr, uint64_t *val, int reset)
+int fsl_dce_get_stat(enum fsl_dce_stat_attr attr, u64 *val, int reset)
 {
 	if (!fsl_dce_have_control())
 		return -ENODEV;
diff --git a/drivers/staging/fsl_dce/flib/bitfield_macros.h b/drivers/staging/fsl_dce/flib/bitfield_macros.h
index 5df3b8bf..9dbf1ac 100644
--- a/drivers/staging/fsl_dce/flib/bitfield_macros.h
+++ b/drivers/staging/fsl_dce/flib/bitfield_macros.h
@@ -32,7 +32,7 @@
  */
 #define SET_BF64(dest, field, value)	\
 	(dest = \
-	((dest & ~field##_MASK) | ((((uint64_t)value) << field##_SHIFT) & \
+	((dest & ~field##_MASK) | ((((u64)value) << field##_SHIFT) & \
 					field##_MASK)))
 
 #define SET_BF64_IDX(dest, field, value)	\
diff --git a/drivers/staging/fsl_dce/flib/dce_defs.h b/drivers/staging/fsl_dce/flib/dce_defs.h
index 7ccb69d..7e641f3 100644
--- a/drivers/staging/fsl_dce/flib/dce_defs.h
+++ b/drivers/staging/fsl_dce/flib/dce_defs.h
@@ -20,7 +20,7 @@
  * set accordingly. If the variable is not set, the interfaces will behave
  * as if the revision is DCE_DEFAULT_REV.
  */
-extern uint16_t dce_ip_rev;
+extern u16 dce_ip_rev;
 #define DCE_REV10	0x0100
 #define DCE_REV11	0x0101
 #define DCE_DEFAULT_REV	DCE_REV10
@@ -55,7 +55,7 @@ extern uint16_t dce_ip_rev;
  *	virtual address aligned on a 64B address boundary in system memory.
  */
 struct dce_context_a {
-	uint64_t d64;
+	u64 d64;
 /* TSIZE */
 #define DCE_CONTEXT_A_TSIZE_SHIFT	60
 #define DCE_CONTEXT_A_TSIZE_MASK	(0x7ULL << DCE_CONTEXT_A_TSIZE_SHIFT)
@@ -84,7 +84,7 @@ struct dce_context_a {
  * @val: Value to set the scrp field to.
  */
 static inline void dce_context_a_set_scrp(struct dce_context_a *ctx_a,
-						uint64_t val)
+						u64 val)
 {
 	/* lower 6 bits expected to be zero, since 64 byte aligned */
 	SET_BF64(ctx_a->d64, DCE_CONTEXT_A_SCRP,
@@ -96,7 +96,7 @@ static inline void dce_context_a_set_scrp(struct dce_context_a *ctx_a,
  *
  * @ctxa: a dce_context_a structure
  */
-static inline uint64_t dce_context_a_get_scrp(struct dce_context_a *ctx_a)
+static inline u64 dce_context_a_get_scrp(struct dce_context_a *ctx_a)
 {
 	/* lower 6 bits expected to be zero, since 64 byte aligned */
 	return GET_BF64(ctx_a->d64, DCE_CONTEXT_A_SCRP) <<
@@ -116,7 +116,7 @@ static inline uint64_t dce_context_a_get_scrp(struct dce_context_a *ctx_a)
  *	this FQID
  */
 struct dce_context_b {
-	uint32_t d32;
+	u32 d32;
 /* DBPID */
 #define DCE_CONTEXT_B_DBPID_SHIFT	24
 #define DCE_CONTEXT_B_DBPID_MASK	(0xffUL << DCE_CONTEXT_B_DBPID_SHIFT)
@@ -390,7 +390,7 @@ struct dce_context_b {
  *				is set on the output fd received from the DCE.
  */
 struct dce_cmd {
-	uint32_t d32;
+	u32 d32;
 /* Common to all commands */
 #define DCE_CMD_SHIFT		29
 #define DCE_CMD_MASK		(0x7UL << DCE_CMD_SHIFT)
@@ -525,20 +525,20 @@ struct dce_cmd {
 /* 64 bytes Stream Context Frame, must be 64 byte aligned */
 struct scf_64b {
 	union {
-		uint8_t  opaque_data8[64];
-		uint16_t opaque_data16[32];
-		uint32_t opaque_data32[16];
-		uint64_t opaque_data64[8];
+		u8  opaque_data8[64];
+		u16 opaque_data16[32];
+		u32 opaque_data32[16];
+		u64 opaque_data64[8];
 	};
 } __aligned(DCE_SCR_ALIGN);
 
 /* 128 byte Stream Context Frame (Record), must be 64 byte aligned */
 struct scf_128b {
 	union {
-		uint8_t  opaque_data8[128];
-		uint16_t opaque_data16[64];
-		uint32_t opaque_data32[32];
-		uint64_t opaque_data64[16];
+		u8  opaque_data8[128];
+		u16 opaque_data16[64];
+		u32 opaque_data32[32];
+		u64 opaque_data64[16];
 		struct scf_64b scf[2];
 	};
 } __aligned(DCE_SCR_ALIGN);
@@ -553,7 +553,7 @@ struct scf_128b {
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_total_in(const struct scf_64b *scf)
+static inline u32 get_total_in(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_TOTAL_IN);
 }
@@ -564,7 +564,7 @@ static inline uint32_t get_total_in(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the total_in field to.
  */
-static inline void set_total_in(struct scf_64b *scf, uint32_t val)
+static inline void set_total_in(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_TOTAL_IN, val);
 }
@@ -577,7 +577,7 @@ static inline void set_total_in(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_total_out(const struct scf_64b *scf)
+static inline u32 get_total_out(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_TOTAL_OUT);
 }
@@ -588,7 +588,7 @@ static inline uint32_t get_total_out(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the total_out field to.
  */
-static inline void set_total_out(struct scf_64b *scf, uint32_t val)
+static inline void set_total_out(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_TOTAL_OUT, val);
 }
@@ -601,7 +601,7 @@ static inline void set_total_out(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_adler32(const struct scf_64b *scf)
+static inline u32 get_adler32(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_ADLER32);
 }
@@ -612,7 +612,7 @@ static inline uint32_t get_adler32(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the adler32 field to.
  */
-static inline void set_adler32(struct scf_64b *scf, uint32_t val)
+static inline void set_adler32(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_ADLER32, val);
 }
@@ -625,7 +625,7 @@ static inline void set_adler32(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_id1(const struct scf_64b *scf)
+static inline u32 get_id1(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_ID1);
 }
@@ -636,7 +636,7 @@ static inline uint32_t get_id1(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the id1 field to.
  */
-static inline void set_id1(struct scf_64b *scf, uint32_t val)
+static inline void set_id1(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_ID1, val);
 }
@@ -649,7 +649,7 @@ static inline void set_id1(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_id2(const struct scf_64b *scf)
+static inline u32 get_id2(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_ID2);
 }
@@ -660,7 +660,7 @@ static inline uint32_t get_id2(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the id2 field to.
  */
-static inline void set_id2(struct scf_64b *scf, uint32_t val)
+static inline void set_id2(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_ID2, val);
 }
@@ -673,7 +673,7 @@ static inline void set_id2(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_id1id2(const struct scf_64b *scf)
+static inline u32 get_id1id2(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_ID1_ID2);
 }
@@ -684,7 +684,7 @@ static inline uint32_t get_id1id2(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the id1 and id2 fields to.
  */
-static inline void set_id1id2(struct scf_64b *scf, uint32_t val)
+static inline void set_id1id2(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_ID1_ID2, val);
 }
@@ -697,7 +697,7 @@ static inline void set_id1id2(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_cm(const struct scf_64b *scf)
+static inline u32 get_cm(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CM);
 }
@@ -708,7 +708,7 @@ static inline uint32_t get_cm(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the cm field to.
  */
-static inline void set_cm(struct scf_64b *scf, uint32_t val)
+static inline void set_cm(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_CM, val);
 }
@@ -721,7 +721,7 @@ static inline void set_cm(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_flg(const struct scf_64b *scf)
+static inline u32 get_flg(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_FLG);
 }
@@ -732,7 +732,7 @@ static inline uint32_t get_flg(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the cm field to.
  */
-static inline void set_flg(struct scf_64b *scf, uint32_t val)
+static inline void set_flg(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_FLG, val);
 }
@@ -746,7 +746,7 @@ static inline void set_flg(struct scf_64b *scf, uint32_t val)
  * @scf: stream context frame
  * @val: Value to set the cm and flg fields to.
  */
-static inline void set_cmflg(struct scf_64b *scf, uint32_t val)
+static inline void set_cmflg(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_CMFLG, val);
 }
@@ -756,7 +756,7 @@ static inline void set_cmflg(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_cmflg(const struct scf_64b *scf)
+static inline u32 get_cmflg(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CMFLG);
 }
@@ -769,7 +769,7 @@ static inline uint32_t get_cmflg(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_mtime(const struct scf_64b *scf)
+static inline u32 get_mtime(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_MTIME);
 }
@@ -780,7 +780,7 @@ static inline uint32_t get_mtime(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the mtime field to.
  */
-static inline void set_mtime(struct scf_64b *scf, uint32_t val)
+static inline void set_mtime(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_MTIME, val);
 }
@@ -793,7 +793,7 @@ static inline void set_mtime(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_xfl(const struct scf_64b *scf)
+static inline u32 get_xfl(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_XFL);
 }
@@ -804,7 +804,7 @@ static inline uint32_t get_xfl(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the xfl field to.
  */
-static inline void set_xfl(struct scf_64b *scf, uint32_t val)
+static inline void set_xfl(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_XFL, val);
 }
@@ -817,7 +817,7 @@ static inline void set_xfl(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_os(const struct scf_64b *scf)
+static inline u32 get_os(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_OS);
 }
@@ -828,7 +828,7 @@ static inline uint32_t get_os(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the os field to.
  */
-static inline void set_os(struct scf_64b *scf, uint32_t val)
+static inline void set_os(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_OS, val);
 }
@@ -841,7 +841,7 @@ static inline void set_os(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_xlen(const struct scf_64b *scf)
+static inline u32 get_xlen(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_XLEN);
 }
@@ -852,7 +852,7 @@ static inline uint32_t get_xlen(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the xlen field to.
  */
-static inline void set_xlen(struct scf_64b *scf, uint32_t val)
+static inline void set_xlen(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_XLEN, val);
 }
@@ -865,7 +865,7 @@ static inline void set_xlen(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_nlen(const struct scf_64b *scf)
+static inline u32 get_nlen(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_NLEN);
 }
@@ -876,7 +876,7 @@ static inline uint32_t get_nlen(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the nlen field to.
  */
-static inline void set_nlen(struct scf_64b *scf, uint32_t val)
+static inline void set_nlen(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_NLEN, val);
 }
@@ -889,7 +889,7 @@ static inline void set_nlen(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_clen(const struct scf_64b *scf)
+static inline u32 get_clen(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CLEN);
 }
@@ -900,7 +900,7 @@ static inline uint32_t get_clen(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the clen field to.
  */
-static inline void set_clen(struct scf_64b *scf, uint32_t val)
+static inline void set_clen(struct scf_64b *scf, u32 val)
 {
 	SET_BF32_IDX(&scf->opaque_data32[0], SCF_CLEN, val);
 }
@@ -913,7 +913,7 @@ static inline void set_clen(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint64_t get_extra_ptr(const struct scf_64b *scf)
+static inline u64 get_extra_ptr(const struct scf_64b *scf)
 {
 	return GET_BF64_IDX(&scf->opaque_data64[0], SCF_EXTRA_PTR);
 }
@@ -924,7 +924,7 @@ static inline uint64_t get_extra_ptr(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the extra_ptr field to.
  */
-static inline void set_extra_ptr(struct scf_64b *scf, uint64_t val)
+static inline void set_extra_ptr(struct scf_64b *scf, u64 val)
 {
 	SET_BF64_IDX(&scf->opaque_data64[0], SCF_EXTRA_PTR, val);
 }
@@ -938,7 +938,7 @@ static inline void set_extra_ptr(struct scf_64b *scf, uint64_t val)
  *
  * @scf: stream context frame
  */
-static inline uint64_t get_pending_output_ptr(const struct scf_64b *scf)
+static inline u64 get_pending_output_ptr(const struct scf_64b *scf)
 {
 	return GET_BF64_IDX(&scf->opaque_data64[0], SCF_PENDING_OUTPUT_PTR);
 }
@@ -949,7 +949,7 @@ static inline uint64_t get_pending_output_ptr(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the pending_output_ptr field to.
  */
-static inline void set_pending_output_ptr(struct scf_64b *scf, uint64_t val)
+static inline void set_pending_output_ptr(struct scf_64b *scf, u64 val)
 {
 	SET_BF64_IDX(&scf->opaque_data64[0], SCF_PENDING_OUTPUT_PTR, val);
 }
@@ -970,7 +970,7 @@ static inline void set_pending_output_ptr(struct scf_64b *scf, uint64_t val)
  *
  * @scf: stream context frame
  */
-static inline uint64_t get_history_ptr(const struct scf_64b *scf)
+static inline u64 get_history_ptr(const struct scf_64b *scf)
 {
 	return GET_BF64_IDX(&scf->opaque_data64[0], SCF_HISTORY_PTR) <<
 		SCF_HISTORY_PTR_SHIFT;
@@ -982,7 +982,7 @@ static inline uint64_t get_history_ptr(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the history_ptr field to.
  */
-static inline void set_history_ptr(struct scf_64b *scf, uint64_t val)
+static inline void set_history_ptr(struct scf_64b *scf, u64 val)
 {
 	/* lower 6 bits expected to be zero, since 64 byte aligned */
 	SET_BF64_IDX(&scf->opaque_data64[0], SCF_HISTORY_PTR,
@@ -1025,7 +1025,7 @@ static inline void set_pmode(struct scf_64b *scf, bool val)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_bytes_processed(const struct scf_64b *scf)
+static inline u32 get_bytes_processed(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_BYTES_PROCESSED);
 }
@@ -1039,7 +1039,7 @@ static inline uint32_t get_bytes_processed(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_pending_output_len(const struct scf_64b *scf)
+static inline u32 get_pending_output_len(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_PENDING_OUTPUT_LEN);
 }
@@ -1061,9 +1061,9 @@ static inline uint32_t get_pending_output_len(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_extra_limit(const struct scf_64b *scf)
+static inline u32 get_extra_limit(const struct scf_64b *scf)
 {
-	uint16_t local_rev = dce_ip_rev;
+	u16 local_rev = dce_ip_rev;
 
 	if (local_rev == 0)
 		local_rev = DCE_DEFAULT_REV;
@@ -1081,9 +1081,9 @@ static inline uint32_t get_extra_limit(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the extra_limit field to.
  */
-static inline void set_extra_limit(struct scf_64b *scf, uint32_t val)
+static inline void set_extra_limit(struct scf_64b *scf, u32 val)
 {
-	uint16_t local_rev;
+	u16 local_rev;
 
 	if (!dce_ip_rev)
 		local_rev = DCE_DEFAULT_REV;
@@ -1105,7 +1105,7 @@ static inline void set_extra_limit(struct scf_64b *scf, uint32_t val)
  *
  * @scf: stream context frame
  */
-static inline uint64_t get_decomp_ctxt_ptr(const struct scf_64b *scf)
+static inline u64 get_decomp_ctxt_ptr(const struct scf_64b *scf)
 {
 	return GET_BF64_IDX(&scf->opaque_data64[0], SCF_DECOMP_CTXT_PTR);
 }
@@ -1116,7 +1116,7 @@ static inline uint64_t get_decomp_ctxt_ptr(const struct scf_64b *scf)
  * @scf: stream context frame
  * @val: Value to set the decomp_ctxt_ptr field to.
  */
-static inline void set_decomp_ctxt_ptr(struct scf_64b *scf, uint64_t val)
+static inline void set_decomp_ctxt_ptr(struct scf_64b *scf, u64 val)
 {
 	SET_BF64_IDX(&scf->opaque_data64[0], SCF_DECOMP_CTXT_PTR, val);
 }
@@ -1180,7 +1180,7 @@ static inline bool get_no(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_co(const struct scf_64b *scf)
+static inline u32 get_co(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CO);
 }
@@ -1229,7 +1229,7 @@ static inline uint32_t get_co(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_output_phase(const struct scf_64b *scf)
+static inline u32 get_output_phase(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_OUTPUT_PHASE);
 }
@@ -1242,7 +1242,7 @@ static inline uint32_t get_output_phase(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_b64_residue_len(const struct scf_64b *scf)
+static inline u32 get_b64_residue_len(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_B64_RESIDUE_LEN);
 }
@@ -1255,7 +1255,7 @@ static inline uint32_t get_b64_residue_len(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_b64_residue(const struct scf_64b *scf)
+static inline u32 get_b64_residue(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_B64_RESIDUE);
 }
@@ -1268,7 +1268,7 @@ static inline uint32_t get_b64_residue(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_residue_data(const struct scf_64b *scf)
+static inline u32 get_residue_data(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_RESIDUE_DATA);
 }
@@ -1285,9 +1285,9 @@ static inline uint32_t get_residue_data(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_pending_working_ptr(const struct scf_64b *scf)
+static inline u32 get_pending_working_ptr(const struct scf_64b *scf)
 {
-	uint16_t local_rev = dce_ip_rev;
+	u16 local_rev = dce_ip_rev;
 
 	if (local_rev == 0)
 		local_rev = DCE_DEFAULT_REV;
@@ -1296,7 +1296,7 @@ static inline uint32_t get_pending_working_ptr(const struct scf_64b *scf)
 		return GET_BF32_IDX(&scf->opaque_data32[0],
 					SCF_PENDING_WKG_PTR);
 	} else {
-		uint32_t val = 0;
+		u32 val = 0;
 		val = GET_BF32_IDX(&scf->opaque_data32[0], SCF_PENDING_WKG_PTR)
 				<< 8;
 		val |= GET_BF32_IDX(&scf->opaque_data32[0],
@@ -1313,7 +1313,7 @@ static inline uint32_t get_pending_working_ptr(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_history_len(const struct scf_64b *scf)
+static inline u32 get_history_len(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_HISTORY_LEN);
 }
@@ -1326,7 +1326,7 @@ static inline uint32_t get_history_len(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_susp(const struct scf_64b *scf)
+static inline u32 get_susp(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_SUSP);
 }
@@ -1339,7 +1339,7 @@ static inline uint32_t get_susp(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_terminated(const struct scf_64b *scf)
+static inline u32 get_terminated(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_TERMINATED);
 }
@@ -1352,7 +1352,7 @@ static inline uint32_t get_terminated(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_rbc(const struct scf_64b *scf)
+static inline u32 get_rbc(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_RBC);
 }
@@ -1365,7 +1365,7 @@ static inline uint32_t get_rbc(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_mcplt(const struct scf_64b *scf)
+static inline u32 get_mcplt(const struct scf_64b *scf)
 {
 	/* only in rev > 1.0 */
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_MCPLT);
@@ -1381,7 +1381,7 @@ static inline uint32_t get_mcplt(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_header_remaining(const struct scf_64b *scf)
+static inline u32 get_header_remaining(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_HEADER_REMAINING);
 }
@@ -1394,7 +1394,7 @@ static inline uint32_t get_header_remaining(const struct scf_64b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_crc16(const struct scf_64b *scf)
+static inline u32 get_crc16(const struct scf_64b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCF_CRC16);
 }
@@ -1462,7 +1462,7 @@ static inline uint32_t get_crc16(const struct scf_64b *scf)
  *
  * Returns the decomp_ctxt_ptr field in the second cache line.
  */
-static inline uint64_t get_decomp_ctxt_ptr_cl2(const struct scf_128b *scf)
+static inline u64 get_decomp_ctxt_ptr_cl2(const struct scf_128b *scf)
 {
 	return GET_BF64_IDX(&scf->opaque_data64[0], SCFCL2_DECOMP_CTXT_PTR);
 }
@@ -1478,7 +1478,7 @@ static inline uint64_t get_decomp_ctxt_ptr_cl2(const struct scf_128b *scf)
  *
  * Returns the decomp_total_out field in the second cache line.
  */
-static inline uint64_t get_decomp_total_out_cl2(const struct scf_128b *scf)
+static inline u64 get_decomp_total_out_cl2(const struct scf_128b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_DECOMP_TOTAL_OUT);
 }
@@ -1497,9 +1497,9 @@ static inline uint64_t get_decomp_total_out_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_previous_code_len_cl2(const struct scf_128b *scf)
+static inline u32 get_previous_code_len_cl2(const struct scf_128b *scf)
 {
-	uint16_t local_rev = dce_ip_rev;
+	u16 local_rev = dce_ip_rev;
 
 	if (local_rev == 0)
 		local_rev = DCE_DEFAULT_REV;
@@ -1520,7 +1520,7 @@ static inline uint32_t get_previous_code_len_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame, 128 bytes in size
  */
-static inline uint32_t get_bfinal_cl2(const struct scf_128b *scf)
+static inline u32 get_bfinal_cl2(const struct scf_128b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_BFINAL);
 }
@@ -1533,7 +1533,7 @@ static inline uint32_t get_bfinal_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame, 128 bytes in size
  */
-static inline uint32_t get_btype_cl2(const struct scf_128b *scf)
+static inline u32 get_btype_cl2(const struct scf_128b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_BTYPE);
 }
@@ -1547,7 +1547,7 @@ static inline uint32_t get_btype_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_frame_parse_state_cl2(const struct scf_128b *scf)
+static inline u32 get_frame_parse_state_cl2(const struct scf_128b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_FRAME_PARSE_STATE);
 }
@@ -1560,7 +1560,7 @@ static inline uint32_t get_frame_parse_state_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_num_code_len_cl2(const struct scf_128b *scf)
+static inline u32 get_num_code_len_cl2(const struct scf_128b *scf)
 {
 		return GET_BF32_IDX(&scf->opaque_data32[0],
 				SCFCL2_NUM_CODE_LEN);
@@ -1575,7 +1575,7 @@ static inline uint32_t get_num_code_len_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_ncbb_remaining_cl2(const struct scf_128b *scf)
+static inline u32 get_ncbb_remaining_cl2(const struct scf_128b *scf)
 {
 		return GET_BF32_IDX(&scf->opaque_data32[0],
 				SCFCL2_NCBB_REMAINING);
@@ -1589,7 +1589,7 @@ static inline uint32_t get_ncbb_remaining_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_hlit_cl2(const struct scf_128b *scf)
+static inline u32 get_hlit_cl2(const struct scf_128b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_HLIT);
 }
@@ -1602,7 +1602,7 @@ static inline uint32_t get_hlit_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_hdist_cl2(const struct scf_128b *scf)
+static inline u32 get_hdist_cl2(const struct scf_128b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_HDIST);
 }
@@ -1615,7 +1615,7 @@ static inline uint32_t get_hdist_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_hclen_cl2(const struct scf_128b *scf)
+static inline u32 get_hclen_cl2(const struct scf_128b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_HCLEN);
 }
@@ -1628,7 +1628,7 @@ static inline uint32_t get_hclen_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint32_t get_huffman_rbc_cl2(const struct scf_128b *scf)
+static inline u32 get_huffman_rbc_cl2(const struct scf_128b *scf)
 {
 	return GET_BF32_IDX(&scf->opaque_data32[0], SCFCL2_HUFFMAN_RBC);
 }
@@ -1642,7 +1642,7 @@ static inline uint32_t get_huffman_rbc_cl2(const struct scf_128b *scf)
  *
  * @scf: stream context frame
  */
-static inline uint64_t get_huffman_residue_cl2(const struct scf_128b *scf)
+static inline u64 get_huffman_residue_cl2(const struct scf_128b *scf)
 {
 	return GET_BF64_IDX(&scf->opaque_data64[0], SCFCL2_HUFFMAN_RESIDUE);
 }
diff --git a/drivers/staging/fsl_dce/flib/dce_flow.c b/drivers/staging/fsl_dce/flib/dce_flow.c
index b10ed30..ec11090 100644
--- a/drivers/staging/fsl_dce/flib/dce_flow.c
+++ b/drivers/staging/fsl_dce/flib/dce_flow.c
@@ -44,7 +44,7 @@ static const struct qman_fq_cb dce_fq_base_tx = {
 static int park(struct qman_fq *fq, struct qm_mcc_initfq *initfq)
 {
 	int ret;
-	uint32_t flags;
+	u32 flags;
 
 	ret = qman_retire_fq(fq, &flags);
 	if (ret)
@@ -67,10 +67,10 @@ static int park(struct qman_fq *fq, struct qm_mcc_initfq *initfq)
 }
 
 static int configure_tx(struct fsl_dce_flow *flow, bool use_specified_txfq_dest,
-			uint16_t dest_qm_channel)
+			u16 dest_qm_channel)
 {
 	struct qm_mcc_initfq initfq;
-	uint32_t qinit_flags = QMAN_INITFQ_FLAG_SCHED;
+	u32 qinit_flags = QMAN_INITFQ_FLAG_SCHED;
 	int ret;
 
 	initfq.we_mask = QM_INITFQ_WE_DESTWQ | QM_INITFQ_WE_FQCTRL;
@@ -146,12 +146,12 @@ static int configure_rx(struct fsl_dce_flow *flow, struct dce_bman_cfg *bcfg,
 	return ret;
 }
 
-void fsl_dce_flow_setopt_fqtx_id(struct fsl_dce_flow *flow, uint32_t id)
+void fsl_dce_flow_setopt_fqtx_id(struct fsl_dce_flow *flow, u32 id)
 {
 	flow->fqtx_id = id;
 }
 
-void fsl_dce_flow_setopt_fqrx_id(struct fsl_dce_flow *flow, uint32_t id)
+void fsl_dce_flow_setopt_fqrx_id(struct fsl_dce_flow *flow, u32 id)
 {
 	flow->fqrx_id = id;
 }
@@ -162,19 +162,19 @@ void fsl_dce_flow_setopt_bcfg(struct fsl_dce_flow *flow,
 	flow->bcfg = bcfg;
 }
 
-int fsl_dce_flow_setopt_txfqdest(struct fsl_dce_flow *flow, uint32_t dest)
+int fsl_dce_flow_setopt_txfqdest(struct fsl_dce_flow *flow, u32 dest)
 {
 	if (dest == 0xffffffff) {
 		flow->use_specified_txfq_dest = false;
 	} else {
 		flow->use_specified_txfq_dest = true;
-		flow->txfq_dest = (uint32_t)dest;
+		flow->txfq_dest = (u32)dest;
 	}
 
 	return 0;
 }
 
-int fsl_dce_flow_setopt_outputoffset(struct fsl_dce_flow *flow, uint32_t val)
+int fsl_dce_flow_setopt_outputoffset(struct fsl_dce_flow *flow, u32 val)
 {
 	switch (val) {
 	case DCE_PROCESS_OO_NONE_LONG:
@@ -193,7 +193,7 @@ int fsl_dce_flow_setopt_outputoffset(struct fsl_dce_flow *flow, uint32_t val)
 }
 
 int fsl_dce_flow_setopt_compression_effort(struct fsl_dce_flow *flow,
-					uint32_t val)
+					u32 val)
 {
 	switch (val) {
 	case DCE_PROCESS_CE_NONE:
@@ -339,7 +339,7 @@ int fsl_dce_flow_fifo_len(struct fsl_dce_flow *flow)
 	return kfifo_len(&flow->fifo);
 }
 
-int fsl_dce_flow_finish(struct fsl_dce_flow *flow, uint32_t flags)
+int fsl_dce_flow_finish(struct fsl_dce_flow *flow, u32 flags)
 {
 	int ret = 0;
 	struct qm_mcc_initfq initfq;
@@ -379,7 +379,7 @@ int fsl_dce_flow_finish(struct fsl_dce_flow *flow, uint32_t flags)
  * QMAN "wait" flags have been aligned so that the below conversion should
  * compile with good straight-line speed.
  */
-static inline uint32_t ctrl2eq(uint32_t flags)
+static inline u32 ctrl2eq(u32 flags)
 {
 #ifdef CONFIG_FSL_DPA_CAN_WAIT
 	return flags & (QMAN_ENQUEUE_FLAG_WAIT | QMAN_ENQUEUE_FLAG_WAIT_INT);
@@ -406,7 +406,7 @@ static int _pre_commit_cb(void *arg)
 	return 0;
 }
 
-static inline int submit_job(struct fsl_dce_flow *flow, uint32_t flags,
+static inline int submit_job(struct fsl_dce_flow *flow, u32 flags,
 			struct qm_fd *fd, struct fsl_dce_cmd_token *token)
 {
 	int ret = 0;
@@ -424,7 +424,7 @@ static inline int submit_job(struct fsl_dce_flow *flow, uint32_t flags,
 	return ret;
 }
 
-int fsl_dce_nop(struct fsl_dce_flow *flow, uint32_t flags, void *callback_tag)
+int fsl_dce_nop(struct fsl_dce_flow *flow, u32 flags, void *callback_tag)
 {
 	struct qm_fd fd;
 	struct fsl_dce_cmd_token token;
@@ -436,7 +436,7 @@ int fsl_dce_nop(struct fsl_dce_flow *flow, uint32_t flags, void *callback_tag)
 	return submit_job(flow, flags, &fd, &token);
 }
 
-int fsl_dce_process(struct fsl_dce_flow *flow, uint32_t flags, struct qm_fd *fd,
+int fsl_dce_process(struct fsl_dce_flow *flow, u32 flags, struct qm_fd *fd,
 		void *callback_tag)
 {
 	struct fsl_dce_cmd_token token;
@@ -449,7 +449,7 @@ int fsl_dce_process(struct fsl_dce_flow *flow, uint32_t flags, struct qm_fd *fd,
 	return submit_job(flow, flags, fd, &token);
 }
 
-int fsl_dce_scr_invalidate(struct fsl_dce_flow *flow, uint32_t flags,
+int fsl_dce_scr_invalidate(struct fsl_dce_flow *flow, u32 flags,
 			void *callback_tag)
 {
 	struct qm_fd fd;
@@ -501,7 +501,7 @@ static void cb_fqs(__always_unused struct qman_portal *portal,
 			__always_unused struct qman_fq *fq,
 			const struct qm_mr_entry *mr)
 {
-	uint8_t verb = mr->verb & QM_MR_VERB_TYPE_MASK;
+	u8 verb = mr->verb & QM_MR_VERB_TYPE_MASK;
 
 	if (verb == QM_MR_VERB_FQRNI)
 		return;
diff --git a/drivers/staging/fsl_dce/flib/dce_flow.h b/drivers/staging/fsl_dce/flib/dce_flow.h
index cf16092..1ce0440 100644
--- a/drivers/staging/fsl_dce/flib/dce_flow.h
+++ b/drivers/staging/fsl_dce/flib/dce_flow.h
@@ -127,11 +127,11 @@ enum dce_compression_format {
 struct dce_bman_cfg {
 	/* scatter gather entries size */
 	enum dce_tsize_coding tsize;
-	uint32_t tbpid;
+	u32 tbpid;
 	/* data buffer configuration */
-	uint32_t dmant; /* range 1..16, gets translated internally */
-	uint32_t dexp; /* range 7..22, gets translated internally */
-	uint32_t dbpid;
+	u32 dmant; /* range 1..16, gets translated internally */
+	u32 dexp; /* range 7..22, gets translated internally */
+	u32 dbpid;
 };
 
 /* predeclaration of structure */
@@ -168,7 +168,7 @@ struct fsl_dce_flow_cbs {
  */
 struct fsl_dce_cmd_token {
 	void *callback_tag;
-	uint32_t flags;
+	u32 flags;
 };
 
 /**
@@ -197,26 +197,26 @@ struct fsl_dce_flow {
 	struct fsl_dce_flow_cbs cbs;
 	enum dce_mode mode;
 	struct dce_bman_cfg bcfg;
-	uint16_t actual_fifo_depth;
-	uint16_t wanted_fifo_depth;
+	u16 actual_fifo_depth;
+	u16 wanted_fifo_depth;
 	DECLARE_KFIFO_PTR(fifo, struct fsl_dce_cmd_token);
-	uint32_t fqtx_id;
-	uint32_t fqrx_id;
+	u32 fqtx_id;
+	u32 fqrx_id;
 	bool use_specified_txfq_dest;
-	uint32_t txfq_dest;
-	uint32_t flags;
-	uint32_t proc_flags;
+	u32 txfq_dest;
+	u32 flags;
+	u32 proc_flags;
 };
 
-void fsl_dce_flow_setopt_fqtx_id(struct fsl_dce_flow *flow, uint32_t id);
-void fsl_dce_flow_setopt_fqrx_id(struct fsl_dce_flow *flow, uint32_t id);
+void fsl_dce_flow_setopt_fqtx_id(struct fsl_dce_flow *flow, u32 id);
+void fsl_dce_flow_setopt_fqrx_id(struct fsl_dce_flow *flow, u32 id);
 void fsl_dce_flow_setopt_bcfg(struct fsl_dce_flow *flow,
 				struct dce_bman_cfg bcfg);
-int fsl_dce_flow_setopt_txfqdest(struct fsl_dce_flow *flow, uint32_t dest);
+int fsl_dce_flow_setopt_txfqdest(struct fsl_dce_flow *flow, u32 dest);
 int fsl_dce_flow_setopt_outputoffset(struct fsl_dce_flow *flow,
-				uint32_t val); /* DCE_PROCESS_OO_*** value */
+				u32 val); /* DCE_PROCESS_OO_*** value */
 int fsl_dce_flow_setopt_compression_effort(struct fsl_dce_flow *flow,
-				uint32_t val); /* DCE_PROCESS_CE_*** value */
+				u32 val); /* DCE_PROCESS_CE_*** value */
 int fsl_dce_flow_setopt_release_input(struct fsl_dce_flow *flow, bool val);
 int fsl_dce_flow_setopt_base64(struct fsl_dce_flow *flow, bool val);
 
@@ -242,7 +242,7 @@ struct fsl_dce_flow_init_params {
 	enum dce_mode mode;
 	enum dce_state_config state_config;
 	enum dce_processing_mode p_mode;
-	uint16_t fifo_depth;
+	u16 fifo_depth;
 	fsl_dce_base_cb base_cb;
 	fsl_dce_process_cb process_cb;
 	fsl_dce_nop_cb nop_cb;
@@ -304,7 +304,7 @@ int fsl_dce_flow_fifo_len(struct fsl_dce_flow *flow);
  *
  * The QMan frame queues will be put out-of-service and destroyed.
  */
-int fsl_dce_flow_finish(struct fsl_dce_flow *flow, uint32_t flags);
+int fsl_dce_flow_finish(struct fsl_dce_flow *flow, u32 flags);
 
 /* Flags for operations */
 #ifdef CONFIG_FSL_DPA_CAN_WAIT
@@ -401,7 +401,7 @@ int fsl_dce_flow_finish(struct fsl_dce_flow *flow, uint32_t flags);
  * supports the same set of flush parameters as zlib inflate() and deflate()
  * calls do.
  */
-int fsl_dce_process(struct fsl_dce_flow *flow, uint32_t flags,
+int fsl_dce_process(struct fsl_dce_flow *flow, u32 flags,
 		struct qm_fd *fd, void *callback_tag);
 
 /**
@@ -419,7 +419,7 @@ int fsl_dce_process(struct fsl_dce_flow *flow, uint32_t flags,
  * fully processed, without needing to send a compress or decompress command
  * through the DCE.
  */
-int fsl_dce_nop(struct fsl_dce_flow *flow, uint32_t flags, void *callback_tag);
+int fsl_dce_nop(struct fsl_dce_flow *flow, u32 flags, void *callback_tag);
 
 /**
  * fsl_dce_scr_invalidate - send a DCE Context Invalidate request
@@ -440,7 +440,7 @@ int fsl_dce_nop(struct fsl_dce_flow *flow, uint32_t flags, void *callback_tag);
  * command is only useful when processed on a stateful Flow. If it is received
  * on a stateless Frame Queue it has no effect.
  */
-int fsl_dce_scr_invalidate(struct fsl_dce_flow *flow, uint32_t flags,
+int fsl_dce_scr_invalidate(struct fsl_dce_flow *flow, u32 flags,
 			void *callback_tag);
 
 #endif /* DCE_FLOW_H */
diff --git a/drivers/staging/fsl_dce/flib/dce_helper.h b/drivers/staging/fsl_dce/flib/dce_helper.h
index d6fe3d0..c8d6a16 100644
--- a/drivers/staging/fsl_dce/flib/dce_helper.h
+++ b/drivers/staging/fsl_dce/flib/dce_helper.h
@@ -11,7 +11,7 @@
  * get_dce_status - returns lowest 8 bits
  * @fd_status:  frame descriptor 32bit field
  */
-static inline enum dce_status fsl_dce_get_status(uint32_t fd_status)
+static inline enum dce_status fsl_dce_get_status(u32 fd_status)
 {
 	return (enum dce_status)
 		GET_BF32(fd_status, DCE_PROCESS_STATUS);
@@ -81,27 +81,27 @@ static inline void fsl_dce_statefull_compression_dma(struct scf_64b *scf,
 }
 
 /* DCE input command helpers */
-static inline void fsl_dce_cmd_set_process(uint32_t *cmd)
+static inline void fsl_dce_cmd_set_process(u32 *cmd)
 {
 	SET_BF32_TK(*cmd, DCE_CMD, PROCESS);
 }
 
-static inline void fsl_dce_cmd_set_ctx_invalidate(uint32_t *cmd)
+static inline void fsl_dce_cmd_set_ctx_invalidate(u32 *cmd)
 {
 	SET_BF32_TK(*cmd, DCE_CMD, CTX_INVALIDATE);
 }
 
-static inline void fsl_dce_cmd_set_nop(uint32_t *cmd)
+static inline void fsl_dce_cmd_set_nop(u32 *cmd)
 {
 	SET_BF32_TK(*cmd, DCE_CMD, NOP);
 }
 
 /* DCE process command helpers */
-static inline void fsl_dce_cmd_set_compression_effort_none(uint32_t *cmd)
+static inline void fsl_dce_cmd_set_compression_effort_none(u32 *cmd)
 {
 	SET_BF32_TK(*cmd, DCE_PROCESS_CE, NONE);
 }
-static inline void fsl_dce_cmd_set_compression_effort_statichuff(uint32_t *cmd)
+static inline void fsl_dce_cmd_set_compression_effort_statichuff(u32 *cmd)
 
 {
 	SET_BF32_TK(*cmd, DCE_PROCESS_CE, STATIC_HUFF_STRMATCH);
diff --git a/drivers/staging/fsl_dce/flib/dce_regs.h b/drivers/staging/fsl_dce/flib/dce_regs.h
index 201ff76..1d4804e 100644
--- a/drivers/staging/fsl_dce/flib/dce_regs.h
+++ b/drivers/staging/fsl_dce/flib/dce_regs.h
@@ -10,66 +10,66 @@
 /** @Description struct for defining dce CCSR registes */
 struct dce_regs {
 	/* DCE Global Common Configuration */
-	uint32_t cfg;		/* DCE configuration */
-	uint8_t reserved1[0x014-0x004];
-	uint32_t oll;		/* Output Length Limit */
-	uint8_t reserved2[0x024-0x018];
-	uint32_t hcl;		/* Hop Count Limit */
-	uint8_t reserved3[0x03c-0x028];
-	uint32_t idle;		/* DCE Idle status */
-	uint8_t reserved4[0x100-0x040];
+	u32 cfg;		/* DCE configuration */
+	u8 reserved1[0x014-0x004];
+	u32 oll;		/* Output Length Limit */
+	u8 reserved2[0x024-0x018];
+	u32 hcl;		/* Hop Count Limit */
+	u8 reserved3[0x03c-0x028];
+	u32 idle;		/* DCE Idle status */
+	u8 reserved4[0x100-0x040];
 
 	/* System Memory Configuration */
-	uint32_t liodnbr;	/* LIODN Base */
-	uint32_t srcidr;	/* Source ID Register */
-	uint32_t smcacr;	/* System Memory Cache Attribute Control */
-	uint32_t smpcr;		/* System Memory Priority Control */
-	uint32_t icir;		/* Internal Context Invalidate */
-	uint8_t reserved5[0x200-0x114];
+	u32 liodnbr;	/* LIODN Base */
+	u32 srcidr;	/* Source ID Register */
+	u32 smcacr;	/* System Memory Cache Attribute Control */
+	u32 smpcr;		/* System Memory Priority Control */
+	u32 icir;		/* Internal Context Invalidate */
+	u8 reserved5[0x200-0x114];
 
 	/* Statistics */
-	uint32_t cibc_h;	/* Compressor Input Bytes count High */
-	uint32_t cibc_l;	/* Compressor Input Bytes count Low */
-	uint32_t cobc_h;	/* Compressor Output Bytes count High */
-	uint32_t cobc_l;	/* Compressor Output Bytes count Low */
-	uint32_t dibc_h;	/* Decompressor Input Bytes count High */
-	uint32_t dibc_l;	/* Decompressor Input Bytes count Low */
-	uint32_t dobc_h;	/* Decompressor Output Bytes count High */
-	uint32_t dobc_l;	/* Decompressor Output Bytes count Low */
-	uint8_t reserved6[0x3f8-0x220];
+	u32 cibc_h;	/* Compressor Input Bytes count High */
+	u32 cibc_l;	/* Compressor Input Bytes count Low */
+	u32 cobc_h;	/* Compressor Output Bytes count High */
+	u32 cobc_l;	/* Compressor Output Bytes count Low */
+	u32 dibc_h;	/* Decompressor Input Bytes count High */
+	u32 dibc_l;	/* Decompressor Input Bytes count Low */
+	u32 dobc_h;	/* Decompressor Output Bytes count High */
+	u32 dobc_l;	/* Decompressor Output Bytes count Low */
+	u8 reserved6[0x3f8-0x220];
 
 	/* Block ID */
-	uint32_t ip_rev_1;	/* DCE IP Block Revision 1 */
-	uint32_t ip_rev_2;	/* DCE IP Block Revision 2 */
+	u32 ip_rev_1;	/* DCE IP Block Revision 1 */
+	u32 ip_rev_2;	/* DCE IP Block Revision 2 */
 
 	/* Interrupt */
-	uint32_t isr;		/* Interrupt Status */
-	uint32_t ier;		/* Interrupt Enable */
-	uint32_t isdr;		/* Interrupt Status Disable */
-	uint32_t iir;		/* Interrupt Inhibit */
-	uint32_t ifr;		/* Interrupt Force */
-	uint8_t reserved7[0x440-0x414];
+	u32 isr;		/* Interrupt Status */
+	u32 ier;		/* Interrupt Enable */
+	u32 isdr;		/* Interrupt Status Disable */
+	u32 iir;		/* Interrupt Inhibit */
+	u32 ifr;		/* Interrupt Force */
+	u8 reserved7[0x440-0x414];
 
 	/* Error status */
-	uint32_t ecc1bes;	/* ECC 1-Bit Error Status */
-	uint32_t ecc2bes;	/* ECC 2-Bit Error Status */
-	uint32_t eccaddr;	/* ECC Address */
-	uint32_t ecc1th;	/* ECC 1-Bit Threshold */
-	uint32_t dhecc1ec;	/*
+	u32 ecc1bes;	/* ECC 1-Bit Error Status */
+	u32 ecc2bes;	/* ECC 2-Bit Error Status */
+	u32 eccaddr;	/* ECC Address */
+	u32 ecc1th;	/* ECC 1-Bit Threshold */
+	u32 dhecc1ec;	/*
 				 * Decompression History memory ECC 1-Bit Error
 				 * Count
 				 */
-	uint32_t cxecc1ec;	/*
+	u32 cxecc1ec;	/*
 				 * Internal Context memory ECC 1-Bit Error
 				 * Count
 				 */
-	uint32_t cbecc1ec;	/* Internal Data memory ECC 1-Bit Error Count */
-	uint8_t reserved8[0x480-0x45C];
+	u32 cbecc1ec;	/* Internal Data memory ECC 1-Bit Error Count */
+	u8 reserved8[0x480-0x45C];
 	/* revision 1.1 */
-	uint32_t uwe_info_h;	/* Unreported Write Error Information High */
-	uint32_t uwe_info_l;	/* Unreported Write Error Information Low */
+	u32 uwe_info_h;	/* Unreported Write Error Information High */
+	u32 uwe_info_l;	/* Unreported Write Error Information Low */
 	/* pad out to 4k */
-	uint8_t padding[0x1000-0x488];
+	u8 padding[0x1000-0x488];
 };
 
 /* masks and shifts */
@@ -541,6 +541,6 @@ struct dce_regs {
 
 /* helper to get combine and shift SCRPH and L */
 #define DCE_GEN_SCRP(scrp_h, scrp_l) \
-	(((uint64_t)scrp_h << 32 | scrp_l) << DCE_UWE_INFO_L_SCRP_SHIFT)
+	(((u64)scrp_h << 32 | scrp_l) << DCE_UWE_INFO_L_SCRP_SHIFT)
 
 #endif /* FL_DCE_REGS_H */
diff --git a/drivers/staging/fsl_dce/fsl_dce.h b/drivers/staging/fsl_dce/fsl_dce.h
index 8df4316..9cd00e9 100644
--- a/drivers/staging/fsl_dce/fsl_dce.h
+++ b/drivers/staging/fsl_dce/fsl_dce.h
@@ -52,7 +52,7 @@ enum fsl_dce_stat_attr {
 	DCE_DECOMP_OUTPUT_BYTES
 };
 
-int fsl_dce_get_stat(enum fsl_dce_stat_attr attr, uint64_t *val, int reset);
+int fsl_dce_get_stat(enum fsl_dce_stat_attr attr, u64 *val, int reset);
 int fsl_dce_clear_stat(enum fsl_dce_stat_attr attr);
 
 #endif /* __KERNEL__ */
diff --git a/drivers/staging/fsl_dce/fsl_dce_chunk.c b/drivers/staging/fsl_dce/fsl_dce_chunk.c
index 18895b4..32449ae 100644
--- a/drivers/staging/fsl_dce/fsl_dce_chunk.c
+++ b/drivers/staging/fsl_dce/fsl_dce_chunk.c
@@ -51,7 +51,7 @@ static void chunk_base_cb(struct fsl_dce_flow *flow, const struct qm_fd *fd,
 }
 
 int fsl_dce_chunk_setup2(struct fsl_dce_chunk *chunk,
-	uint32_t flags,
+	u32 flags,
 	enum dce_mode mode,
 	enum dce_compression_format cf,
 	struct dce_bman_cfg *bcfg,
@@ -94,7 +94,7 @@ int fsl_dce_chunk_fifo_len(struct fsl_dce_chunk *chunk)
 EXPORT_SYMBOL(fsl_dce_chunk_fifo_len);
 
 
-int fsl_dce_chunk_destroy(struct fsl_dce_chunk *chunk, uint32_t flags,
+int fsl_dce_chunk_destroy(struct fsl_dce_chunk *chunk, u32 flags,
 			void *callback_tag)
 {
 	return fsl_dce_flow_finish(&chunk->flow, flags);
@@ -102,7 +102,7 @@ int fsl_dce_chunk_destroy(struct fsl_dce_chunk *chunk, uint32_t flags,
 EXPORT_SYMBOL(fsl_dce_chunk_destroy);
 
 
-int fsl_dce_chunk_process(struct fsl_dce_chunk *chunk, uint32_t flags,
+int fsl_dce_chunk_process(struct fsl_dce_chunk *chunk, u32 flags,
 			struct qm_fd *fd, void *callback_tag)
 {
 	if (chunk->cf == DCE_CF_ZLIB)
@@ -119,7 +119,7 @@ int fsl_dce_chunk_process(struct fsl_dce_chunk *chunk, uint32_t flags,
 }
 EXPORT_SYMBOL(fsl_dce_chunk_process);
 
-int fsl_dce_chunk_nop(struct fsl_dce_chunk *chunk, uint32_t flags,
+int fsl_dce_chunk_nop(struct fsl_dce_chunk *chunk, u32 flags,
 	void *callback_tag)
 {
 	return fsl_dce_nop(&chunk->flow, flags, callback_tag);
@@ -127,10 +127,10 @@ int fsl_dce_chunk_nop(struct fsl_dce_chunk *chunk, uint32_t flags,
 EXPORT_SYMBOL(fsl_dce_chunk_nop);
 
 int fsl_dce_chunk_deflate_params(struct fsl_dce_chunk *chunk,
-	uint32_t bman_output_offset,
+	u32 bman_output_offset,
 	bool bman_release_input,
 	bool base64,
-	uint32_t ce)
+	u32 ce)
 {
 	fsl_dce_flow_setopt_outputoffset(&chunk->flow, bman_output_offset);
 	fsl_dce_flow_setopt_release_input(&chunk->flow, bman_release_input);
@@ -141,7 +141,7 @@ int fsl_dce_chunk_deflate_params(struct fsl_dce_chunk *chunk,
 EXPORT_SYMBOL(fsl_dce_chunk_deflate_params);
 
 int fsl_dce_chunk_inflate_params(struct fsl_dce_chunk *chunk,
-	uint32_t bman_output_offset,
+	u32 bman_output_offset,
 	bool bman_release_input,
 	bool base64)
 {
diff --git a/drivers/staging/fsl_dce/fsl_dce_chunk.h b/drivers/staging/fsl_dce/fsl_dce_chunk.h
index 682f065..319b896 100644
--- a/drivers/staging/fsl_dce/fsl_dce_chunk.h
+++ b/drivers/staging/fsl_dce/fsl_dce_chunk.h
@@ -59,7 +59,7 @@ struct fsl_dce_chunk {
 	enum dce_compression_format cf;
 	bool use_bman_output;
 	/* internal state */
-	uint32_t flags;
+	u32 flags;
 	spinlock_t lock;
 	wait_queue_head_t queue;
 };
@@ -80,7 +80,7 @@ struct fsl_dce_chunk {
  * Returns 0 on success
  */
 int fsl_dce_chunk_setup2(struct fsl_dce_chunk *chunk,
-	uint32_t flags,
+	u32 flags,
 	enum dce_mode mode,
 	enum dce_compression_format cf,
 	struct dce_bman_cfg *bcfg,
@@ -106,7 +106,7 @@ int fsl_dce_chunk_fifo_len(struct fsl_dce_chunk *chunk);
  *
  * Returns 0 on success
  */
-int fsl_dce_chunk_destroy(struct fsl_dce_chunk *chunk, uint32_t flags,
+int fsl_dce_chunk_destroy(struct fsl_dce_chunk *chunk, u32 flags,
 			void *callback_tag);
 
 /**
@@ -121,10 +121,10 @@ int fsl_dce_chunk_destroy(struct fsl_dce_chunk *chunk, uint32_t flags,
  * Returns 0 on success
  */
 int fsl_dce_chunk_deflate_params(struct fsl_dce_chunk *chunk,
-	uint32_t bman_output_offset,
+	u32 bman_output_offset,
 	bool bman_release_input,
 	bool base64,
-	uint32_t ce);
+	u32 ce);
 
 /**
  * fsl_dce_chunk_inflate_params - set inflate options
@@ -137,7 +137,7 @@ int fsl_dce_chunk_deflate_params(struct fsl_dce_chunk *chunk,
  * Returns 0 on success
  */
 int fsl_dce_chunk_inflate_params(struct fsl_dce_chunk *chunk,
-	uint32_t bman_output_offset,
+	u32 bman_output_offset,
 	bool bman_release_input,
 	bool base64);
 
@@ -152,7 +152,7 @@ int fsl_dce_chunk_inflate_params(struct fsl_dce_chunk *chunk,
  *
  * Returns 0 on success
  */
-int fsl_dce_chunk_process(struct fsl_dce_chunk *chunk, uint32_t flags,
+int fsl_dce_chunk_process(struct fsl_dce_chunk *chunk, u32 flags,
 	struct qm_fd *fd, void *callback_tag);
 
 /**
@@ -165,7 +165,7 @@ int fsl_dce_chunk_process(struct fsl_dce_chunk *chunk, uint32_t flags,
  *
  * Returns 0 on success
  */
-int fsl_dce_chunk_nop(struct fsl_dce_chunk *chunk, uint32_t flags,
+int fsl_dce_chunk_nop(struct fsl_dce_chunk *chunk, u32 flags,
 	void *callback_tag);
 
 #endif /* FSL_DCE_CHUNK_H */
diff --git a/drivers/staging/fsl_dce/fsl_dce_stream.c b/drivers/staging/fsl_dce/fsl_dce_stream.c
index cb3fc24..6b9c678 100644
--- a/drivers/staging/fsl_dce/fsl_dce_stream.c
+++ b/drivers/staging/fsl_dce/fsl_dce_stream.c
@@ -52,7 +52,7 @@ static void stream_base_cb(struct fsl_dce_flow *flow, const struct qm_fd *fd,
 }
 
 int fsl_dce_stream_setup(struct fsl_dce_stream *stream,
-	uint32_t flags,
+	u32 flags,
 	enum dce_mode mode,
 	enum dce_compression_format cf,
 	fsl_dce_process_cb process_cb,
@@ -177,7 +177,7 @@ void fsl_dce_attach_3mbr_sgtable_2_fd(struct qm_sg_entry sg_table[3],
 EXPORT_SYMBOL(fsl_dce_attach_3mbr_sgtable_2_fd);
 
 int fsl_dce_stream_setup2(struct fsl_dce_stream *stream,
-	uint32_t flags,
+	u32 flags,
 	enum dce_mode mode,
 	enum dce_compression_format cf,
 	enum dce_processing_mode pmode,
@@ -243,7 +243,7 @@ int fsl_dce_stream_fifo_len(struct fsl_dce_stream *stream)
 }
 EXPORT_SYMBOL(fsl_dce_stream_fifo_len);
 
-int fsl_dce_stream_destroy(struct fsl_dce_stream *stream, uint32_t flags,
+int fsl_dce_stream_destroy(struct fsl_dce_stream *stream, u32 flags,
 			void *callback_tag)
 {
 	int ret;
@@ -265,7 +265,7 @@ int fsl_dce_stream_init_scr(struct fsl_dce_stream *stream, struct qm_fd *fd,
 }
 EXPORT_SYMBOL(fsl_dce_stream_init_scr);
 
-int fsl_dce_stream_process(struct fsl_dce_stream *stream, uint32_t flags,
+int fsl_dce_stream_process(struct fsl_dce_stream *stream, u32 flags,
 	struct qm_fd *fd, bool initial_frame, int z_flush, void *callback_tag)
 {
 	if (stream->cf == DCE_CF_ZLIB)
@@ -293,14 +293,14 @@ int fsl_dce_stream_process(struct fsl_dce_stream *stream, uint32_t flags,
 }
 EXPORT_SYMBOL(fsl_dce_stream_process);
 
-int fsl_dce_stream_nop(struct fsl_dce_stream *stream, uint32_t flags,
+int fsl_dce_stream_nop(struct fsl_dce_stream *stream, u32 flags,
 	void *callback_tag)
 {
 	return fsl_dce_nop(&stream->flow, flags, callback_tag);
 }
 EXPORT_SYMBOL(fsl_dce_stream_nop);
 
-int fsl_dce_stream_scr_invalidate(struct fsl_dce_stream *stream, uint32_t flags,
+int fsl_dce_stream_scr_invalidate(struct fsl_dce_stream *stream, u32 flags,
 	void *callback_tag)
 {
 	return fsl_dce_scr_invalidate(&stream->flow, flags, callback_tag);
@@ -308,10 +308,10 @@ int fsl_dce_stream_scr_invalidate(struct fsl_dce_stream *stream, uint32_t flags,
 EXPORT_SYMBOL(fsl_dce_stream_scr_invalidate);
 
 int fsl_dce_stream_deflate_params(struct fsl_dce_stream *stream,
-	uint32_t bman_output_offset,
+	u32 bman_output_offset,
 	bool bman_release_input,
 	bool base64,
-	uint32_t ce)
+	u32 ce)
 {
 	if (dce_ip_rev == DCE_REV10) {
 		/* B64 unsupported */
@@ -330,7 +330,7 @@ int fsl_dce_stream_deflate_params(struct fsl_dce_stream *stream,
 EXPORT_SYMBOL(fsl_dce_stream_deflate_params);
 
 int fsl_dce_stream_inflate_params(struct fsl_dce_stream *stream,
-	uint32_t bman_output_offset,
+	u32 bman_output_offset,
 	bool bman_release_input,
 	bool base64)
 {
diff --git a/drivers/staging/fsl_dce/fsl_dce_stream.h b/drivers/staging/fsl_dce/fsl_dce_stream.h
index fdcdb77..2e55638 100644
--- a/drivers/staging/fsl_dce/fsl_dce_stream.h
+++ b/drivers/staging/fsl_dce/fsl_dce_stream.h
@@ -100,7 +100,7 @@ struct fsl_dce_stream {
 	enum dce_processing_mode pmode;
 
 	bool use_bman_output;
-	uint32_t process_params;
+	u32 process_params;
 
 	union {
 		struct fsl_dce_hw_scr_64b *hw_comp_scr;
@@ -116,7 +116,7 @@ struct fsl_dce_stream {
 	struct fsl_dce_hw_decomp_ctxt *decomp_ctx_ptr;
 
 	/* internal state */
-	uint32_t flags;
+	u32 flags;
 	spinlock_t lock;
 	wait_queue_head_t queue;
 };
@@ -137,7 +137,7 @@ struct fsl_dce_stream {
  * Setup a @stream object for usage
  */
 int fsl_dce_stream_setup(struct fsl_dce_stream *stream,
-	uint32_t flags,
+	u32 flags,
 	enum dce_mode mode,
 	enum dce_compression_format cf,
 	fsl_dce_process_cb process_cb,
@@ -162,7 +162,7 @@ int fsl_dce_stream_setup(struct fsl_dce_stream *stream,
  * Returns 0 in success
  */
 int fsl_dce_stream_setup2(struct fsl_dce_stream *stream,
-	uint32_t flags,
+	u32 flags,
 	enum dce_mode mode,
 	enum dce_compression_format cf,
 	enum dce_processing_mode pmode,
@@ -190,7 +190,7 @@ int fsl_dce_stream_fifo_len(struct fsl_dce_stream *stream);
  *
  * Returns 0 on success
  */
-int fsl_dce_stream_destroy(struct fsl_dce_stream *stream, uint32_t flags,
+int fsl_dce_stream_destroy(struct fsl_dce_stream *stream, u32 flags,
 			void *callback_tag);
 
 /**
@@ -205,10 +205,10 @@ int fsl_dce_stream_destroy(struct fsl_dce_stream *stream, uint32_t flags,
  * Returns 0 on success
  */
 int fsl_dce_stream_deflate_params(struct fsl_dce_stream *stream,
-	uint32_t bman_output_offset,
+	u32 bman_output_offset,
 	bool bman_release_input,
 	bool base64,
-	uint32_t ce); /* DCE_PROCESS_CE_* value */
+	u32 ce); /* DCE_PROCESS_CE_* value */
 
 /**
  * fsl_dce_stream_inflate_params - set inflate options
@@ -221,7 +221,7 @@ int fsl_dce_stream_deflate_params(struct fsl_dce_stream *stream,
  * Returns 0 on success
  */
 int fsl_dce_stream_inflate_params(struct fsl_dce_stream *stream,
-	uint32_t bman_output_offset,
+	u32 bman_output_offset,
 	bool bman_release_input,
 	bool base64);
 
@@ -240,7 +240,7 @@ int fsl_dce_stream_inflate_params(struct fsl_dce_stream *stream,
  * Returns 0 on success
  */
 int fsl_dce_stream_process(struct fsl_dce_stream *stream,
-	uint32_t flags,
+	u32 flags,
 	struct qm_fd *fd,
 	bool initial_frame,
 	int z_flush,
@@ -256,11 +256,11 @@ int fsl_dce_stream_process(struct fsl_dce_stream *stream,
  *
  * Returns 0 on success
  */
-int fsl_dce_stream_nop(struct fsl_dce_stream *stream, uint32_t flags,
+int fsl_dce_stream_nop(struct fsl_dce_stream *stream, u32 flags,
 	void *callback_tag); /* optional callback tag */
 
 int fsl_dce_stream_scr_invalidate(struct fsl_dce_stream *stream,
-	uint32_t flags, void *callback_tag);
+	u32 flags, void *callback_tag);
 
 
 /* helper apis */
diff --git a/drivers/staging/fsl_dce/tests/chunk_comp_def_cf/dce_chunk_comp_def_cf_test.c b/drivers/staging/fsl_dce/tests/chunk_comp_def_cf/dce_chunk_comp_def_cf_test.c
index 0d934a5..d11cbb9 100644
--- a/drivers/staging/fsl_dce/tests/chunk_comp_def_cf/dce_chunk_comp_def_cf_test.c
+++ b/drivers/staging/fsl_dce/tests/chunk_comp_def_cf/dce_chunk_comp_def_cf_test.c
@@ -108,7 +108,7 @@ static int init_test_ctx(struct dce_test_ctx *ctx,
 		enum dce_compression_format format)
 {
 	int ret, ret_fail;
-	uint32_t flags = 0;
+	u32 flags = 0;
 
 	/* initialize a compression deflate stream */
 	ret = fsl_dce_chunk_setup2(&ctx->deflate_chunk, flags,
diff --git a/drivers/staging/fsl_dce/tests/common/test_frame_helpers.c b/drivers/staging/fsl_dce/tests/common/test_frame_helpers.c
index 2eb8f6a..0f7a025 100644
--- a/drivers/staging/fsl_dce/tests/common/test_frame_helpers.c
+++ b/drivers/staging/fsl_dce/tests/common/test_frame_helpers.c
@@ -214,10 +214,10 @@ void print_dce_fd(struct qm_fd fd)
 	pr_info("   LIODN ------------ %#x\n", fd.liodn_offset);
 	pr_info("   BPID ------------- %#x\n", fd.bpid);
 	pr_info("   ELIODN ----------- %#x\n", fd.eliodn_offset);
-	pr_info("   ADDRESS ---------- %#010llx\n", (uint64_t)fd.addr);
+	pr_info("   ADDRESS ---------- %#010llx\n", (u64)fd.addr);
 	if (fd.format == 0 || fd.format == 4)
 		pr_info("   - ADDRESS + OFFSET %#010llx\n",
-			(uint64_t)fd.addr + fd.offset);
+			(u64)fd.addr + fd.offset);
 	if (fd.format == 0)
 		pr_info("   FORMAT ----------- Short_SingleFrame\n");
 	else if (fd.format == 2)
@@ -246,7 +246,7 @@ void print_dce_sg(struct qm_sg_entry sg)
 {
 	pr_info(" Scatter/Gather Table Entry:\n");
 	pr_info("   RESERVED --------- %#06x\n", sg.__notaddress);
-	pr_info("   ADDRESS ---------- %#010llx\n", (uint64_t)sg.addr);
+	pr_info("   ADDRESS ---------- %#010llx\n", (u64)sg.addr);
 	pr_info("   E ---------------- %#x\n", sg.extension);
 	pr_info("   F ---------------- %#x\n", sg.final);
 	pr_info("   LENGTH ----------- %#x\n", sg.length);
diff --git a/drivers/staging/fsl_dce/tests/performance_simple/dce_perf_simple.c b/drivers/staging/fsl_dce/tests/performance_simple/dce_perf_simple.c
index fe1b3bc..ae3f6ff 100644
--- a/drivers/staging/fsl_dce/tests/performance_simple/dce_perf_simple.c
+++ b/drivers/staging/fsl_dce/tests/performance_simple/dce_perf_simple.c
@@ -96,7 +96,7 @@ static int b_dmant = 1;
 module_param(b_dmant, int, S_IRUGO);
 MODULE_PARM_DESC(b_dmant, "Bman dmant value, default=");
 
-static uint32_t bman_data_buff_size;
+static u32 bman_data_buff_size;
 
 static int block_size = 4096;
 module_param(block_size, int, S_IRUGO);
@@ -146,7 +146,7 @@ struct test_data_s {
 
 struct test_data_s *test_data;
 
-static uint64_t start_time, end_time;
+static u64 start_time, end_time;
 
 /* Loopback support */
 static int do_operation(void);
@@ -154,7 +154,7 @@ static int do_operation(void);
 /* Alternate Time Base */
 #define SPR_ATBL	526
 #define SPR_ATBU	527
-static inline uint64_t mfatb(void)
+static inline u64 mfatb(void)
 {
 	return mfspr(SPR_ATBL);
 }
@@ -327,10 +327,10 @@ static int copy_bman_output_to_buffer(struct qm_sg_entry *sg, size_t cpylen,
 {
 	dma_addr_t phy_addr;
 	void *cpumem;
-	uint64_t cal_total_lenght = 0;
+	u64 cal_total_length = 0;
 	char *pos = buffer;
 	struct qm_sg_entry *entry;
-	uint64_t remaining = cpylen;
+	u64 remaining = cpylen;
 
 	/*
 	 * As per DPAA:
@@ -349,14 +349,14 @@ static int copy_bman_output_to_buffer(struct qm_sg_entry *sg, size_t cpylen,
 		entry = s_entry;
 		do {
 			if (!entry->extension) {
-				uint64_t to_copy;
+				u64 to_copy;
 
 				phy_addr = (dma_addr_t)qm_sg_entry_get64(entry);
 				fsl_dce_unmap(phy_addr);
 				cpumem = phys_to_virt(phy_addr);
-				to_copy = min_t(uint64_t, entry->length,
+				to_copy = min_t(u64, entry->length,
 					remaining);
-				cal_total_lenght += to_copy;
+				cal_total_length += to_copy;
 				remaining -= to_copy;
 				memcpy(pos, cpumem, to_copy);
 				pos += to_copy;
@@ -383,13 +383,13 @@ static int copy_bman_output_to_buffer(struct qm_sg_entry *sg, size_t cpylen,
 			}
 		} while (1);
 
-		if (cpylen != cal_total_lenght) {
+		if (cpylen != cal_total_length) {
 			pr_info("total frame length != calulated length (%zu) (%llu)\n",
-				cpylen, cal_total_lenght);
+				cpylen, cal_total_length);
 		}
 	} else {
 		pr_info("output is simple frame from bman pool %u\n",
-			(uint32_t)sg->bpid);
+			(u32)sg->bpid);
 		phy_addr = (dma_addr_t)qm_sg_entry_get64(sg);
 		fsl_dce_unmap(phy_addr);
 		cpumem = phys_to_virt(phy_addr);
@@ -671,17 +671,17 @@ int dce_loopback_init(void)
 
 void dce_loopback_shutdown(void)
 {
-	uint64_t run_time_cycle;
-	uint64_t total_compress_bytes = 0;
-	uint64_t total_decompress_bytes = 0;
-	uint64_t comp_Mbps = 0;
-	uint64_t decomp_Mbps = 0;
+	u64 run_time_cycle;
+	u64 total_compress_bytes = 0;
+	u64 total_decompress_bytes = 0;
+	u64 comp_Mbps = 0;
+	u64 decomp_Mbps = 0;
 	unsigned int cpufreq = 0;
-	uint64_t run_time_usec = 0;
-	uint32_t sysfreq = 0;
-	uint64_t dce_freq = 0, dce_max_freq = 400000000;	/* Hz */
-	uint64_t scaled_val;
-	uint64_t temp;
+	u64 run_time_usec = 0;
+	u32 sysfreq = 0;
+	u64 dce_freq = 0, dce_max_freq = 400000000;	/* Hz */
+	u64 scaled_val;
+	u64 temp;
 
 	sysfreq = fsl_get_sys_freq();
 	dce_freq = sysfreq;
@@ -723,7 +723,7 @@ void dce_loopback_shutdown(void)
 
 	/* Calculate Compression Mbps */
 	if (total_compress_bytes) {
-		uint64_t estimate_Mbps;
+		u64 estimate_Mbps;
 
 		comp_Mbps = total_compress_bytes * 8;
 		do_div(comp_Mbps, run_time_usec);
@@ -741,7 +741,7 @@ void dce_loopback_shutdown(void)
 
 	/* Calculate Decompression Mbps */
 	if (total_decompress_bytes) {
-		uint64_t estimate_Mbps;
+		u64 estimate_Mbps;
 
 		decomp_Mbps = total_decompress_bytes * 8;
 		do_div(decomp_Mbps, run_time_usec);
diff --git a/drivers/staging/fsl_dce/tests/performance_simple/dce_sf_perf_simple.c b/drivers/staging/fsl_dce/tests/performance_simple/dce_sf_perf_simple.c
index 89b7d12..47d3bba 100644
--- a/drivers/staging/fsl_dce/tests/performance_simple/dce_sf_perf_simple.c
+++ b/drivers/staging/fsl_dce/tests/performance_simple/dce_sf_perf_simple.c
@@ -95,7 +95,7 @@ static int b_dmant = 1;
 module_param(b_dmant, int, S_IRUGO);
 MODULE_PARM_DESC(b_dmant, "Bman dmant value, default=1");
 
-static uint32_t bman_data_buff_size;
+static u32 bman_data_buff_size;
 
 static int block_size = 4096;
 module_param(block_size, int, S_IRUGO);
@@ -155,7 +155,7 @@ struct test_data_s {
 
 struct test_data_s *test_data;
 
-static uint64_t start_time, end_time;
+static u64 start_time, end_time;
 
 /* Loopback support */
 static int do_operation(void);
@@ -163,7 +163,7 @@ static int do_operation(void);
 /* Alternate Time Base */
 #define SPR_ATBL	526
 #define SPR_ATBU	527
-static inline uint64_t mfatb(void)
+static inline u64 mfatb(void)
 {
 	return mfspr(SPR_ATBL);
 }
@@ -328,10 +328,10 @@ static int copy_bman_output_to_buffer(struct qm_sg_entry *sg, size_t cpylen,
 {
 	dma_addr_t phy_addr;
 	void *cpumem;
-	uint64_t cal_total_lenght = 0;
+	u64 cal_total_length = 0;
 	char *pos = buffer;
 	struct qm_sg_entry *entry;
-	uint64_t remaining = cpylen;
+	u64 remaining = cpylen;
 
 	/*
 	 * As per DPAA:
@@ -350,14 +350,14 @@ static int copy_bman_output_to_buffer(struct qm_sg_entry *sg, size_t cpylen,
 		entry = s_entry;
 		do {
 			if (!entry->extension) {
-				uint64_t to_copy;
+				u64 to_copy;
 
 				phy_addr = qm_sg_addr(entry);
 				fsl_dce_unmap(phy_addr);
 				cpumem = phys_to_virt(phy_addr);
-				to_copy = min_t(uint64_t, entry->length,
+				to_copy = min_t(u64, entry->length,
 					remaining);
-				cal_total_lenght += to_copy;
+				cal_total_length += to_copy;
 				remaining -= to_copy;
 				memcpy(pos, cpumem, to_copy);
 				pos += to_copy;
@@ -390,9 +390,9 @@ static int copy_bman_output_to_buffer(struct qm_sg_entry *sg, size_t cpylen,
 			}
 		} while (1);
 
-		if (cpylen != cal_total_lenght)
+		if (cpylen != cal_total_length)
 			pr_info("total frame length != calulated length (%lu) (%llu)\n",
-				cpylen, cal_total_lenght);
+				cpylen, cal_total_length);
 	} else {
 		phy_addr = qm_sg_addr(sg);
 		if (phy_addr != 0) {
@@ -736,17 +736,17 @@ int dce_sf_performance_init(void)
 
 void dce_sf_performance_shutdown(void)
 {
-	uint64_t run_time_cycle;
-	uint64_t total_compress_bytes = 0;
-	uint64_t total_decompress_bytes = 0;
-	uint64_t comp_Mbps = 0;
-	uint64_t decomp_Mbps = 0;
+	u64 run_time_cycle;
+	u64 total_compress_bytes = 0;
+	u64 total_decompress_bytes = 0;
+	u64 comp_Mbps = 0;
+	u64 decomp_Mbps = 0;
 	unsigned int cpufreq = 0;
-	uint64_t run_time_usec = 0;
-	uint32_t sysfreq = 0, dce_freq = 0;
-	uint64_t dce_max_freq = 400000000; /* Hz */
-	uint64_t scaled_val;
-	uint64_t temp;
+	u64 run_time_usec = 0;
+	u32 sysfreq = 0, dce_freq = 0;
+	u64 dce_max_freq = 400000000; /* Hz */
+	u64 scaled_val;
+	u64 temp;
 
 	sysfreq = fsl_get_sys_freq();
 	dce_freq = sysfreq;
@@ -788,7 +788,7 @@ void dce_sf_performance_shutdown(void)
 
 	/* Calculate Compression Mbps */
 	if (total_compress_bytes) {
-		uint64_t estimate_Mbps;
+		u64 estimate_Mbps;
 
 		comp_Mbps = total_compress_bytes * 8;
 		do_div(comp_Mbps, run_time_usec);
@@ -806,7 +806,7 @@ void dce_sf_performance_shutdown(void)
 
 	/* Calculate Decompression Mbps */
 	if (total_decompress_bytes) {
-		uint64_t estimate_Mbps;
+		u64 estimate_Mbps;
 
 		decomp_Mbps = total_decompress_bytes * 8;
 		do_div(decomp_Mbps, run_time_usec);
@@ -854,7 +854,7 @@ static int do_operation(void)
 	struct dce_bman_cfg bcfg;
 	int chunk_count;
 	struct list_head *pos;
-	uint32_t total_out = 0;
+	u32 total_out = 0;
 	char *p_out;
 
 	pr_info("DCE thread on cpu %d\n", smp_processor_id());
@@ -872,11 +872,11 @@ static int do_operation(void)
 		bcfg.dexp = b_dexp;
 
 		pr_info("Bman info: tsize = %u, tbpid = %u, dbpid = %u, dmant = %u, dexp = %u\n",
-			(uint32_t)bcfg.tsize,
-			(uint32_t)bcfg.tbpid,
-			(uint32_t)bcfg.dbpid,
-			(uint32_t)bcfg.dmant,
-			(uint32_t)bcfg.dexp);
+			(u32)bcfg.tsize,
+			(u32)bcfg.tbpid,
+			(u32)bcfg.dbpid,
+			(u32)bcfg.dmant,
+			(u32)bcfg.dexp);
 	}
 
 	chunk_count = test_data->input_data_len / chunking_size;
@@ -1034,7 +1034,7 @@ static int do_operation(void)
 	i = 0;
 
 	list_for_each(pos, &test_data->request_list) {
-		uint32_t flags = 0;
+		u32 flags = 0;
 
 		def_process_req = list_entry(
 			pos, struct dce_process_cf_gzip_req, node);
-- 
1.7.5.4

