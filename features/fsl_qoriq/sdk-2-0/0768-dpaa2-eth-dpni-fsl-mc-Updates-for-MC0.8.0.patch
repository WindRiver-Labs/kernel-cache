From d0ad6b423f5ce195871af40019ffa67b6417351b Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Wed, 9 Dec 2015 17:51:12 +0200
Subject: [PATCH 0768/1383] dpaa2-eth, dpni, fsl-mc: Updates for MC0.8.0

Several changes need to be performed in sync for supporting
the newest MC version:
* Update mc-cmd.h
* Update the dpni binary interface to v6.0
* Update the DPAA2 Eth driver to account for several API changes

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c |  75 +-
 drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h |   6 +-
 drivers/staging/fsl-dpaa2/ethernet/dpkg.h      |  46 +-
 drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h  | 410 ++++++++---
 drivers/staging/fsl-dpaa2/ethernet/dpni.c      | 442 +++++++++---
 drivers/staging/fsl-dpaa2/ethernet/dpni.h      | 936 +++++++++++++++++--------
 drivers/staging/fsl-mc/include/mc-cmd.h        |   5 +-
 7 files changed, 1382 insertions(+), 538 deletions(-)

diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
index 5518615..ac6d614 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.c
@@ -1734,6 +1734,7 @@ static int __cold dpaa2_dpni_setup(struct fsl_mc_device *ls_dev)
 	struct device *dev = &ls_dev->dev;
 	struct dpaa2_eth_priv *priv;
 	struct net_device *net_dev;
+	void *dma_mem;
 	int err;
 
 	net_dev = dev_get_drvdata(dev);
@@ -1751,13 +1752,38 @@ static int __cold dpaa2_dpni_setup(struct fsl_mc_device *ls_dev)
 	/* FIXME Alex's moral compass says this must be done */
 	ls_dev->mc_io = priv->mc_io;
 	ls_dev->mc_handle = priv->mc_token;
+
+	dma_mem =  kzalloc(DPAA2_EXT_CFG_SIZE, GFP_DMA | GFP_KERNEL);
+	if (!dma_mem)
+		goto err_alloc;
+
+	priv->dpni_attrs.ext_cfg_iova = dma_map_single(dev, dma_mem,
+						       DPAA2_EXT_CFG_SIZE,
+						       DMA_FROM_DEVICE);
+	if (dma_mapping_error(dev, priv->dpni_attrs.ext_cfg_iova)) {
+		dev_err(dev, "dma mapping for dpni_ext_cfg failed\n");
+		goto err_dma_map;
+	}
+
 	err = dpni_get_attributes(priv->mc_io, 0, priv->mc_token,
 				  &priv->dpni_attrs);
 	if (err) {
 		dev_err(dev, "dpni_get_attributes() failed (err=%d)\n", err);
+		dma_unmap_single(dev, priv->dpni_attrs.ext_cfg_iova,
+				 DPAA2_EXT_CFG_SIZE, DMA_FROM_DEVICE);
 		goto err_get_attr;
 	}
 
+	dma_unmap_single(dev, priv->dpni_attrs.ext_cfg_iova,
+			 DPAA2_EXT_CFG_SIZE, DMA_FROM_DEVICE);
+
+	memset(&priv->dpni_ext_cfg, 0, sizeof(priv->dpni_ext_cfg));
+	err = dpni_extract_extended_cfg(&priv->dpni_ext_cfg, dma_mem);
+	if (err) {
+		dev_err(dev, "dpni_extract_extended_cfg() failed\n");
+		goto err_extract;
+	}
+
 	/* Configure our buffers' layout */
 	priv->buf_layout.options = DPNI_BUF_LAYOUT_OPT_PARSER_RESULT |
 				   DPNI_BUF_LAYOUT_OPT_FRAME_STATUS |
@@ -1813,13 +1839,20 @@ static int __cold dpaa2_dpni_setup(struct fsl_mc_device *ls_dev)
 	priv->cls_rule = kzalloc(sizeof(struct dpaa2_cls_rule)
 				 * DPAA2_CLASSIFIER_ENTRY_COUNT, GFP_KERNEL);
 	if (!priv->cls_rule)
-		return -ENOMEM;
+		goto err_cls_rule;
+
+	kfree(dma_mem);
 
 	return 0;
 
+err_cls_rule:
 err_data_offset:
 err_buf_layout:
+err_extract:
 err_get_attr:
+err_dma_map:
+	kfree(dma_mem);
+err_alloc:
 	dpni_close(priv->mc_io, 0, priv->mc_token);
 err_open:
 	return err;
@@ -1872,19 +1905,15 @@ static int dpaa2_rx_flow_setup(struct dpaa2_eth_priv *priv,
 static int dpaa2_tx_flow_setup(struct dpaa2_eth_priv *priv,
 			       struct dpaa2_eth_fq *fq)
 {
+
 	struct dpni_tx_flow_cfg tx_flow_cfg;
-	struct dpni_queue_cfg queue_cfg;
-	struct dpni_tx_flow_attr tx_flow_attr;
+	struct dpni_tx_conf_cfg tx_conf_cfg;
+	struct dpni_tx_conf_attr tx_conf_attr;
 	int err;
 
 	memset(&tx_flow_cfg, 0, sizeof(tx_flow_cfg));
-	tx_flow_cfg.options = DPNI_TX_FLOW_OPT_QUEUE;
-	queue_cfg.options = DPNI_QUEUE_OPT_USER_CTX | DPNI_QUEUE_OPT_DEST;
-	queue_cfg.user_ctx = (uint64_t)fq;
-	queue_cfg.dest_cfg.dest_type = DPNI_DEST_DPCON;
-	queue_cfg.dest_cfg.dest_id = fq->channel->dpcon_id;
-	queue_cfg.dest_cfg.priority = 0;
-	tx_flow_cfg.conf_err_cfg.queue_cfg = queue_cfg;
+	tx_flow_cfg.options = DPNI_TX_FLOW_OPT_TX_CONF_ERROR;
+	tx_flow_cfg.use_common_tx_conf_queue = 0;
 	err = dpni_set_tx_flow(priv->mc_io, 0, priv->mc_token,
 			       &fq->flowid, &tx_flow_cfg);
 	if (unlikely(err)) {
@@ -1892,13 +1921,29 @@ static int dpaa2_tx_flow_setup(struct dpaa2_eth_priv *priv,
 		return err;
 	}
 
-	err = dpni_get_tx_flow(priv->mc_io, 0, priv->mc_token,
-			       fq->flowid, &tx_flow_attr);
-	if (unlikely(err)) {
-		netdev_err(priv->net_dev, "dpni_get_tx_flow() failed\n");
+	tx_conf_cfg.errors_only = 0;
+	tx_conf_cfg.queue_cfg.options = DPNI_QUEUE_OPT_USER_CTX |
+					DPNI_QUEUE_OPT_DEST;
+	tx_conf_cfg.queue_cfg.user_ctx = (uint64_t)fq;
+	tx_conf_cfg.queue_cfg.dest_cfg.dest_type = DPNI_DEST_DPCON;
+	tx_conf_cfg.queue_cfg.dest_cfg.dest_id = fq->channel->dpcon_id;
+	tx_conf_cfg.queue_cfg.dest_cfg.priority = 0;
+
+	err = dpni_set_tx_conf(priv->mc_io, 0, priv->mc_token, fq->flowid,
+			       &tx_conf_cfg);
+	if (err) {
+		netdev_err(priv->net_dev, "dpni_set_tx_conf() failed\n");
+		return err;
+	}
+
+	err = dpni_get_tx_conf(priv->mc_io, 0, priv->mc_token, fq->flowid,
+			       &tx_conf_attr);
+	if (err) {
+		netdev_err(priv->net_dev, "dpni_get_tx_conf() failed\n");
 		return err;
 	}
-	fq->fqid = tx_flow_attr.conf_err_attr.queue_attr.fqid;
+
+	fq->fqid = tx_conf_attr.queue_attr.fqid;
 
 	return 0;
 }
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h
index 264a441..abce72f 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpaa2-eth.h
@@ -264,6 +264,7 @@ struct dpaa2_eth_priv {
 
 	int dpni_id;
 	struct dpni_attr dpni_attrs;
+	struct dpni_extended_cfg dpni_ext_cfg;
 	/* Insofar as the MC is concerned, we're using one layout on all 3 types
 	 * of buffers (Rx, Tx, Tx-Conf).
 	 */
@@ -325,6 +326,9 @@ struct dpaa2_eth_priv {
 /*TODO: this should be taken from DPNI attributes */
 #define DPAA2_CLASSIFIER_ENTRY_COUNT 16
 
+/* Required by struct dpni_attr::ext_cfg_iova */
+#define DPAA2_EXT_CFG_SIZE	256
+
 extern const struct ethtool_ops dpaa2_ethtool_ops;
 
 /* Set RX hash options
@@ -338,7 +342,7 @@ static inline int dpaa2_queue_count(struct dpaa2_eth_priv *priv)
 		return 1;
 
 	/* TODO: fix for multiple TCs */
-	return priv->dpni_attrs.max_dist_per_tc[0];
+	return priv->dpni_ext_cfg.tc_cfg[0].max_dist;
 }
 
 static inline int dpaa2_max_channels(struct dpaa2_eth_priv *priv)
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpkg.h b/drivers/staging/fsl-dpaa2/ethernet/dpkg.h
index f6945d9..92ec12b 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpkg.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpkg.h
@@ -39,12 +39,16 @@
  * Contains initialization APIs and runtime APIs for the Key Generator
  */
 
-/* Key Generator properties */
+/** Key Generator properties */
 
-/* Number of masks per key extraction */
+/**
+ * Number of masks per key extraction
+ */
 #define DPKG_NUM_OF_MASKS		4
-/* Number of extractions per key profile */
-#define DPKG_MAX_NUM_OF_EXTRACTS	8
+/**
+ * Number of extractions per key profile
+ */
+#define DPKG_MAX_NUM_OF_EXTRACTS	10
 
 /**
  * enum dpkg_extract_from_hdr_type - Selecting extraction by header types
@@ -61,13 +65,15 @@ enum dpkg_extract_from_hdr_type {
 /**
  * enum dpkg_extract_type - Enumeration for selecting extraction type
  * @DPKG_EXTRACT_FROM_HDR: Extract from the header
- * @DPKG_EXTRACT_FROM_DATA: Extract from data not in the header
- * @DPKG_EXTRACT_CONSTANT: Extract user-selected constant values
+ * @DPKG_EXTRACT_FROM_DATA: Extract from data not in specific header
+ * @DPKG_EXTRACT_FROM_PARSE: Extract from parser-result;
+ *	e.g. can be used to extract header existence;
+ *	please refer to 'Parse Result definition' section in the parser BG
  */
 enum dpkg_extract_type {
 	DPKG_EXTRACT_FROM_HDR = 0,
 	DPKG_EXTRACT_FROM_DATA = 1,
-	DPKG_EXTRACT_CONSTANT = 2
+	DPKG_EXTRACT_FROM_PARSE = 3
 };
 
 /**
@@ -85,7 +91,7 @@ struct dpkg_mask {
  * @type: Determines how the union below is interpreted:
  *		DPKG_EXTRACT_FROM_HDR: selects 'from_hdr';
  *		DPKG_EXTRACT_FROM_DATA: selects 'from_data';
- *		DPKG_EXTRACT_CONSTANT: selects 'constant'
+ *		DPKG_EXTRACT_FROM_PARSE: selects 'from_parse'
  * @extract: Selects extraction method
  * @num_of_byte_masks: Defines the number of valid entries in the array below;
  *		This is	also the number of bytes to be used as masks
@@ -97,7 +103,7 @@ struct dpkg_extract {
 	 * union extract - Selects extraction method
 	 * @from_hdr - Used when 'type = DPKG_EXTRACT_FROM_HDR'
 	 * @from_data - Used when 'type = DPKG_EXTRACT_FROM_DATA'
-	 * @constant - Used when 'type = DPKG_EXTRACT_CONSTANT'
+	 * @from_parse - Used when 'type = DPKG_EXTRACT_FROM_PARSE'
 	 */
 	union {
 		/**
@@ -123,9 +129,9 @@ struct dpkg_extract {
 		 */
 
 		struct {
-			enum net_prot		prot;
+			enum net_prot			prot;
 			enum dpkg_extract_from_hdr_type type;
-			uint32_t		field;
+			uint32_t			field;
 			uint8_t			size;
 			uint8_t			offset;
 			uint8_t			hdr_index;
@@ -139,20 +145,20 @@ struct dpkg_extract {
 			uint8_t size;
 			uint8_t offset;
 		} from_data;
+
 		/**
-		 * struct constant - Used when 'type = DPKG_EXTRACT_CONSTANT'
-		 * @constant - A constant value
-		 * @num_of_repeats - Number of times the constant is to be
-		 *			entered to the key
+		 * struct from_parse - Used when 'type = DPKG_EXTRACT_FROM_PARSE'
+		 * @size: Size in bytes
+		 * @offset: Byte offset
 		 */
 		struct {
-			uint8_t constant;
-			uint8_t num_of_repeats;
-		} constant;
+			uint8_t size;
+			uint8_t offset;
+		} from_parse;
 	} extract;
 
-	uint8_t num_of_byte_masks;
-	struct dpkg_mask masks[DPKG_NUM_OF_MASKS];
+	uint8_t		num_of_byte_masks;
+	struct dpkg_mask	masks[DPKG_NUM_OF_MASKS];
 };
 
 /**
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h b/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h
index ca74700..c0f8af0 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpni-cmd.h
@@ -32,12 +32,9 @@
 #ifndef _FSL_DPNI_CMD_H
 #define _FSL_DPNI_CMD_H
 
-#define DPNI_CMD_EXTRACT_EXT_PARAMS		25
-#define DPNI_CMD_EARLY_DROP_EXT_PARAMS		13
-
 /* DPNI Version */
-#define DPNI_VER_MAJOR				5
-#define DPNI_VER_MINOR				1
+#define DPNI_VER_MAJOR				6
+#define DPNI_VER_MINOR				0
 
 /* Command IDs */
 #define DPNI_CMDID_OPEN				0x801
@@ -101,7 +98,7 @@
 #define DPNI_CMDID_ADD_VLAN_ID			0x231
 #define DPNI_CMDID_REMOVE_VLAN_ID		0x232
 #define DPNI_CMDID_CLR_VLAN_FILTERS		0x233
-#define DPNI_CMDID_SET_TX_TC			0x234
+
 #define DPNI_CMDID_SET_RX_TC_DIST		0x235
 #define DPNI_CMDID_SET_TX_FLOW			0x236
 #define DPNI_CMDID_GET_TX_FLOW			0x237
@@ -109,8 +106,7 @@
 #define DPNI_CMDID_GET_RX_FLOW			0x239
 #define DPNI_CMDID_SET_RX_ERR_QUEUE		0x23A
 #define DPNI_CMDID_GET_RX_ERR_QUEUE		0x23B
-#define DPNI_CMDID_SET_TX_CONF_ERR_QUEUE	0x23C
-#define DPNI_CMDID_GET_TX_CONF_ERR_QUEUE	0x23D
+
 #define DPNI_CMDID_SET_RX_TC_POLICING		0x23E
 #define DPNI_CMDID_SET_RX_TC_EARLY_DROP		0x23F
 
@@ -127,11 +123,83 @@
 #define DPNI_CMDID_SET_IPF			0x24A
 
 #define DPNI_CMDID_SET_TX_SELECTION			0x250
+#define DPNI_CMDID_GET_RX_TC_POLICING		0x251
+#define DPNI_CMDID_GET_RX_TC_EARLY_DROP		0x252
+#define DPNI_CMDID_SET_RX_TC_CONGESTION_NOTIFICATION 0x253
+#define DPNI_CMDID_GET_RX_TC_CONGESTION_NOTIFICATION 0x254
+#define DPNI_CMDID_SET_TX_TC_CONGESTION_NOTIFICATION 0x255
+#define DPNI_CMDID_GET_TX_TC_CONGESTION_NOTIFICATION 0x256
+#define DPNI_CMDID_SET_TX_CONF						0x257
+#define DPNI_CMDID_GET_TX_CONF						0x258
+#define DPNI_CMDID_SET_TX_CONF_CONGESTION_NOTIFICATION 0x259
+#define DPNI_CMDID_GET_TX_CONF_CONGESTION_NOTIFICATION 0x25A
+#define DPNI_CMDID_SET_TX_TC_EARLY_DROP				0x25B
+#define DPNI_CMDID_GET_TX_TC_EARLY_DROP				0x25C
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_OPEN(cmd, dpni_id) \
 	MC_CMD_OP(cmd,	 0,	0,	32,	int,	dpni_id)
 
+#define DPNI_PREP_EXTENDED_CFG(ext, cfg) \
+do { \
+	MC_PREP_OP(ext, 0, 0,   16, uint16_t, cfg->tc_cfg[0].max_dist); \
+	MC_PREP_OP(ext, 0, 16,  16, uint16_t, cfg->tc_cfg[0].max_fs_entries); \
+	MC_PREP_OP(ext, 0, 32,  16, uint16_t, cfg->tc_cfg[1].max_dist); \
+	MC_PREP_OP(ext, 0, 48,  16, uint16_t, cfg->tc_cfg[1].max_fs_entries); \
+	MC_PREP_OP(ext, 1, 0,   16, uint16_t, cfg->tc_cfg[2].max_dist); \
+	MC_PREP_OP(ext, 1, 16,  16, uint16_t, cfg->tc_cfg[2].max_fs_entries); \
+	MC_PREP_OP(ext, 1, 32,  16, uint16_t, cfg->tc_cfg[3].max_dist); \
+	MC_PREP_OP(ext, 1, 48,  16, uint16_t, cfg->tc_cfg[3].max_fs_entries); \
+	MC_PREP_OP(ext, 2, 0,   16, uint16_t, cfg->tc_cfg[4].max_dist); \
+	MC_PREP_OP(ext, 2, 16,  16, uint16_t, cfg->tc_cfg[4].max_fs_entries); \
+	MC_PREP_OP(ext, 2, 32,  16, uint16_t, cfg->tc_cfg[5].max_dist); \
+	MC_PREP_OP(ext, 2, 48,  16, uint16_t, cfg->tc_cfg[5].max_fs_entries); \
+	MC_PREP_OP(ext, 3, 0,   16, uint16_t, cfg->tc_cfg[6].max_dist); \
+	MC_PREP_OP(ext, 3, 16,  16, uint16_t, cfg->tc_cfg[6].max_fs_entries); \
+	MC_PREP_OP(ext, 3, 32,  16, uint16_t, cfg->tc_cfg[7].max_dist); \
+	MC_PREP_OP(ext, 3, 48,  16, uint16_t, cfg->tc_cfg[7].max_fs_entries); \
+	MC_PREP_OP(ext, 4, 0,   16, uint16_t, \
+		   cfg->ipr_cfg.max_open_frames_ipv4); \
+	MC_PREP_OP(ext, 4, 16,  16, uint16_t, \
+		   cfg->ipr_cfg.max_open_frames_ipv6); \
+	MC_PREP_OP(ext, 4, 32,  16, uint16_t, \
+		   cfg->ipr_cfg.max_reass_frm_size); \
+	MC_PREP_OP(ext, 5, 0,   16, uint16_t, \
+		   cfg->ipr_cfg.min_frag_size_ipv4); \
+	MC_PREP_OP(ext, 5, 16,  16, uint16_t, \
+		   cfg->ipr_cfg.min_frag_size_ipv6); \
+} while (0)
+
+#define DPNI_EXT_EXTENDED_CFG(ext, cfg) \
+do { \
+	MC_EXT_OP(ext, 0, 0,   16, uint16_t, cfg->tc_cfg[0].max_dist); \
+	MC_EXT_OP(ext, 0, 16,  16, uint16_t, cfg->tc_cfg[0].max_fs_entries); \
+	MC_EXT_OP(ext, 0, 32,  16, uint16_t, cfg->tc_cfg[1].max_dist); \
+	MC_EXT_OP(ext, 0, 48,  16, uint16_t, cfg->tc_cfg[1].max_fs_entries); \
+	MC_EXT_OP(ext, 1, 0,   16, uint16_t, cfg->tc_cfg[2].max_dist); \
+	MC_EXT_OP(ext, 1, 16,  16, uint16_t, cfg->tc_cfg[2].max_fs_entries); \
+	MC_EXT_OP(ext, 1, 32,  16, uint16_t, cfg->tc_cfg[3].max_dist); \
+	MC_EXT_OP(ext, 1, 48,  16, uint16_t, cfg->tc_cfg[3].max_fs_entries); \
+	MC_EXT_OP(ext, 2, 0,   16, uint16_t, cfg->tc_cfg[4].max_dist); \
+	MC_EXT_OP(ext, 2, 16,  16, uint16_t, cfg->tc_cfg[4].max_fs_entries); \
+	MC_EXT_OP(ext, 2, 32,  16, uint16_t, cfg->tc_cfg[5].max_dist); \
+	MC_EXT_OP(ext, 2, 48,  16, uint16_t, cfg->tc_cfg[5].max_fs_entries); \
+	MC_EXT_OP(ext, 3, 0,   16, uint16_t, cfg->tc_cfg[6].max_dist); \
+	MC_EXT_OP(ext, 3, 16,  16, uint16_t, cfg->tc_cfg[6].max_fs_entries); \
+	MC_EXT_OP(ext, 3, 32,  16, uint16_t, cfg->tc_cfg[7].max_dist); \
+	MC_EXT_OP(ext, 3, 48,  16, uint16_t, cfg->tc_cfg[7].max_fs_entries); \
+	MC_EXT_OP(ext, 4, 0,   16, uint16_t, \
+		  cfg->ipr_cfg.max_open_frames_ipv4); \
+	MC_EXT_OP(ext, 4, 16,  16, uint16_t, \
+		  cfg->ipr_cfg.max_open_frames_ipv6); \
+	MC_EXT_OP(ext, 4, 32,  16, uint16_t, \
+		  cfg->ipr_cfg.max_reass_frm_size); \
+	MC_EXT_OP(ext, 5, 0,   16, uint16_t, \
+		  cfg->ipr_cfg.min_frag_size_ipv4); \
+	MC_EXT_OP(ext, 5, 16,  16, uint16_t, \
+		  cfg->ipr_cfg.min_frag_size_ipv6); \
+} while (0)
+
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_CREATE(cmd, cfg) \
 do { \
@@ -151,26 +219,9 @@ do { \
 	MC_CMD_OP(cmd, 2, 32,	8,  uint8_t,  cfg->adv.max_qos_key_size); \
 	MC_CMD_OP(cmd, 2, 48,	8,  uint8_t,  cfg->adv.max_dist_key_size); \
 	MC_CMD_OP(cmd, 2, 56,	8,  enum net_prot, cfg->adv.start_hdr); \
-	MC_CMD_OP(cmd, 3, 0,	8,  uint8_t,  cfg->adv.max_dist_per_tc[0]); \
-	MC_CMD_OP(cmd, 3, 8,	8,  uint8_t,  cfg->adv.max_dist_per_tc[1]); \
-	MC_CMD_OP(cmd, 3, 16,	8,  uint8_t,  cfg->adv.max_dist_per_tc[2]); \
-	MC_CMD_OP(cmd, 3, 24,	8,  uint8_t,  cfg->adv.max_dist_per_tc[3]); \
-	MC_CMD_OP(cmd, 3, 32,	8,  uint8_t,  cfg->adv.max_dist_per_tc[4]); \
-	MC_CMD_OP(cmd, 3, 40,	8,  uint8_t,  cfg->adv.max_dist_per_tc[5]); \
-	MC_CMD_OP(cmd, 3, 48,	8,  uint8_t,  cfg->adv.max_dist_per_tc[6]); \
-	MC_CMD_OP(cmd, 3, 56,	8,  uint8_t,  cfg->adv.max_dist_per_tc[7]); \
-	MC_CMD_OP(cmd, 4, 0,	16, uint16_t, \
-				    cfg->adv.ipr_cfg.max_reass_frm_size); \
-	MC_CMD_OP(cmd, 4, 16,	16, uint16_t, \
-				    cfg->adv.ipr_cfg.min_frag_size_ipv4); \
-	MC_CMD_OP(cmd, 4, 32,	16, uint16_t, \
-				    cfg->adv.ipr_cfg.min_frag_size_ipv6); \
 	MC_CMD_OP(cmd, 4, 48,	8,  uint8_t, cfg->adv.max_policers); \
 	MC_CMD_OP(cmd, 4, 56,	8,  uint8_t, cfg->adv.max_congestion_ctrl); \
-	MC_CMD_OP(cmd, 5, 0,	16, uint16_t, \
-				  cfg->adv.ipr_cfg.max_open_frames_ipv4); \
-	MC_CMD_OP(cmd, 5, 16,	16, uint16_t, \
-				  cfg->adv.ipr_cfg.max_open_frames_ipv6); \
+	MC_CMD_OP(cmd, 5, 0,	64, uint64_t, cfg->adv.ext_cfg_iova); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -213,7 +264,7 @@ do { \
 	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, irq_cfg->val); \
 	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index); \
 	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
-	MC_CMD_OP(cmd, 2, 0,  32, int,	    irq_cfg->user_irq_id); \
+	MC_CMD_OP(cmd, 2, 0,  32, int,	    irq_cfg->irq_num); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -225,7 +276,7 @@ do { \
 do { \
 	MC_RSP_OP(cmd, 0, 0,  32, uint32_t, irq_cfg->val); \
 	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, irq_cfg->addr); \
-	MC_RSP_OP(cmd, 2, 0,  32, int,      irq_cfg->user_irq_id); \
+	MC_RSP_OP(cmd, 2, 0,  32, int,      irq_cfg->irq_num); \
 	MC_RSP_OP(cmd, 2, 32, 32, int,	    type); \
 } while (0)
 
@@ -260,8 +311,11 @@ do { \
 	MC_RSP_OP(cmd, 0, 0,  32, uint32_t,  mask)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_GET_IRQ_STATUS(cmd, irq_index) \
-	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index)
+#define DPNI_CMD_GET_IRQ_STATUS(cmd, irq_index, status) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  32, uint32_t, status);\
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  irq_index);\
+} while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_IRQ_STATUS(cmd, status) \
@@ -275,6 +329,10 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_GET_ATTR(cmd, attr) \
+	MC_CMD_OP(cmd, 6, 0,  64, uint64_t, attr->ext_cfg_iova)
+
+/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_ATTR(cmd, attr) \
 do { \
 	MC_RSP_OP(cmd, 0, 0,  32, int,	    attr->id);\
@@ -288,26 +346,8 @@ do { \
 	MC_RSP_OP(cmd, 2, 24, 8,  uint8_t,  attr->max_qos_entries); \
 	MC_RSP_OP(cmd, 2, 32, 8,  uint8_t,  attr->max_qos_key_size); \
 	MC_RSP_OP(cmd, 2, 40, 8,  uint8_t,  attr->max_dist_key_size); \
-	MC_RSP_OP(cmd, 3, 0,  8,  uint8_t,  attr->max_dist_per_tc[0]); \
-	MC_RSP_OP(cmd, 3, 8,  8,  uint8_t,  attr->max_dist_per_tc[1]); \
-	MC_RSP_OP(cmd, 3, 16, 8,  uint8_t,  attr->max_dist_per_tc[2]); \
-	MC_RSP_OP(cmd, 3, 24, 8,  uint8_t,  attr->max_dist_per_tc[3]); \
-	MC_RSP_OP(cmd, 3, 32, 8,  uint8_t,  attr->max_dist_per_tc[4]); \
-	MC_RSP_OP(cmd, 3, 40, 8,  uint8_t,  attr->max_dist_per_tc[5]); \
-	MC_RSP_OP(cmd, 3, 48, 8,  uint8_t,  attr->max_dist_per_tc[6]); \
-	MC_RSP_OP(cmd, 3, 56, 8,  uint8_t,  attr->max_dist_per_tc[7]); \
-	MC_RSP_OP(cmd, 4, 0,	16, uint16_t, \
-				    attr->ipr_cfg.max_reass_frm_size); \
-	MC_RSP_OP(cmd, 4, 16,	16, uint16_t, \
-				    attr->ipr_cfg.min_frag_size_ipv4); \
-	MC_RSP_OP(cmd, 4, 32,	16, uint16_t, \
-				    attr->ipr_cfg.min_frag_size_ipv6);\
-	MC_RSP_OP(cmd, 4, 48,	8,  uint8_t, attr->max_policers); \
-	MC_RSP_OP(cmd, 4, 56,	8,  uint8_t, attr->max_congestion_ctrl); \
-	MC_RSP_OP(cmd, 5, 0,	16, uint16_t, \
-				  attr->ipr_cfg.max_open_frames_ipv4); \
-	MC_RSP_OP(cmd, 5, 16,	16, uint16_t, \
-				  attr->ipr_cfg.max_open_frames_ipv6); \
+	MC_RSP_OP(cmd, 4, 48, 8,  uint8_t, attr->max_policers); \
+	MC_RSP_OP(cmd, 4, 56, 8,  uint8_t, attr->max_congestion_ctrl); \
 	MC_RSP_OP(cmd, 5, 32, 16, uint16_t, attr->version.major);\
 	MC_RSP_OP(cmd, 5, 48, 16, uint16_t, attr->version.minor);\
 } while (0)
@@ -559,13 +599,6 @@ do { \
 	MC_CMD_OP(cmd, 0, 32, 16, uint16_t, vlan_id)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_TC(cmd, tc_id, cfg) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  16, uint16_t, cfg->depth_limit); \
-	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  tc_id); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_TX_SELECTION(cmd, cfg) \
 do { \
 	MC_CMD_OP(cmd, 0, 0,  16,  uint16_t, cfg->tc_sched[0].delta_bandwidth);\
@@ -597,7 +630,7 @@ do { \
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_RX_TC_DIST(cmd, tc_id, cfg) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  8,  uint8_t,  cfg->dist_size); \
+	MC_CMD_OP(cmd, 0, 0,  16, uint16_t,  cfg->dist_size); \
 	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  tc_id); \
 	MC_CMD_OP(cmd, 0, 24, 4,  enum dpni_dist_mode, cfg->dist_mode); \
 	MC_CMD_OP(cmd, 0, 28, 4,  enum dpni_fs_miss_action, \
@@ -609,25 +642,11 @@ do { \
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_TX_FLOW(cmd, flow_id, cfg) \
 do { \
-	MC_CMD_OP(cmd, 0, 0,  32, int,     \
-		cfg->conf_err_cfg.queue_cfg.dest_cfg.dest_id);\
-	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t, \
-		cfg->conf_err_cfg.queue_cfg.dest_cfg.priority);\
-	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, \
-		cfg->conf_err_cfg.queue_cfg.dest_cfg.dest_type);\
-	MC_CMD_OP(cmd, 0, 42, 1,  int,	    cfg->conf_err_cfg.errors_only);\
 	MC_CMD_OP(cmd, 0, 43, 1,  int,	    cfg->l3_chksum_gen);\
 	MC_CMD_OP(cmd, 0, 44, 1,  int,	    cfg->l4_chksum_gen);\
-	MC_CMD_OP(cmd, 0, 45, 1,  int,	    \
-		cfg->conf_err_cfg.use_default_queue);\
-	MC_CMD_OP(cmd, 0, 46, 1,  int,      \
-			cfg->conf_err_cfg.queue_cfg.order_preservation_en);\
+	MC_CMD_OP(cmd, 0, 45, 1,  int,	    cfg->use_common_tx_conf_queue);\
 	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id);\
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, \
-		cfg->conf_err_cfg.queue_cfg.user_ctx);\
 	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->options);\
-	MC_CMD_OP(cmd, 2, 32,  32, uint32_t, \
-		cfg->conf_err_cfg.queue_cfg.options);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -641,23 +660,9 @@ do { \
 /*                cmd, param, offset, width, type, arg_name */
 #define DPNI_RSP_GET_TX_FLOW(cmd, attr) \
 do { \
-	MC_RSP_OP(cmd, 0, 0,  32, int,      \
-			attr->conf_err_attr.queue_attr.dest_cfg.dest_id);\
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  \
-			attr->conf_err_attr.queue_attr.dest_cfg.priority);\
-	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, \
-			attr->conf_err_attr.queue_attr.dest_cfg.dest_type);\
-	MC_RSP_OP(cmd, 0, 42, 1,  int,	    attr->conf_err_attr.errors_only);\
 	MC_RSP_OP(cmd, 0, 43, 1,  int,	    attr->l3_chksum_gen);\
 	MC_RSP_OP(cmd, 0, 44, 1,  int,	    attr->l4_chksum_gen);\
-	MC_RSP_OP(cmd, 0, 45, 1,  int,	    \
-			attr->conf_err_attr.use_default_queue);\
-	MC_RSP_OP(cmd, 0, 46, 1,  int,      \
-			attr->conf_err_attr.queue_attr.order_preservation_en);\
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, \
-			attr->conf_err_attr.queue_attr.user_ctx);\
-	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, \
-			attr->conf_err_attr.queue_attr.fqid);\
+	MC_RSP_OP(cmd, 0, 45, 1,  int,	    attr->use_common_tx_conf_queue);\
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -678,6 +683,7 @@ do { \
 		cfg->flc_cfg.flow_context_size);\
 	MC_CMD_OP(cmd, 3, 32, 32, uint32_t, cfg->flc_cfg.options);\
 	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->flc_cfg.flow_context);\
+	MC_CMD_OP(cmd, 5, 0,  32, uint32_t, cfg->tail_drop_threshold); \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
@@ -695,6 +701,7 @@ do { \
 	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, attr->dest_cfg.dest_type); \
 	MC_RSP_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
 	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->user_ctx); \
+	MC_RSP_OP(cmd, 2, 0,  32, uint32_t, attr->tail_drop_threshold); \
 	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, attr->fqid); \
 	MC_RSP_OP(cmd, 3, 0,  4,  enum dpni_flc_type, attr->flc_cfg.flc_type); \
 	MC_RSP_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
@@ -714,6 +721,7 @@ do { \
 	MC_CMD_OP(cmd, 0, 42, 1,  int,      cfg->order_preservation_en);\
 	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->user_ctx); \
 	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->options); \
+	MC_CMD_OP(cmd, 2, 32, 32, uint32_t, cfg->tail_drop_threshold); \
 	MC_CMD_OP(cmd, 3, 0,  4,  enum dpni_flc_type, cfg->flc_cfg.flc_type); \
 	MC_CMD_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
 		cfg->flc_cfg.frame_data_size);\
@@ -731,6 +739,7 @@ do { \
 	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, attr->dest_cfg.dest_type);\
 	MC_RSP_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
 	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->user_ctx); \
+	MC_RSP_OP(cmd, 2, 0,  32, uint32_t, attr->tail_drop_threshold); \
 	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, attr->fqid); \
 	MC_RSP_OP(cmd, 3, 0,  4,  enum dpni_flc_type, attr->flc_cfg.flc_type); \
 	MC_RSP_OP(cmd, 3, 4,  4,  enum dpni_stash_size, \
@@ -742,28 +751,6 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_CMD_SET_TX_CONF_ERR_QUEUE(cmd, cfg) \
-do { \
-	MC_CMD_OP(cmd, 0, 0,  32, int,      cfg->dest_cfg.dest_id); \
-	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t,  cfg->dest_cfg.priority);\
-	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, cfg->dest_cfg.dest_type);\
-	MC_CMD_OP(cmd, 0, 42, 1,  int,      cfg->order_preservation_en);\
-	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->user_ctx); \
-	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->options); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
-#define DPNI_RSP_GET_TX_CONF_ERR_QUEUE(cmd, attr) \
-do { \
-	MC_RSP_OP(cmd, 0, 0,  32, int,      attr->dest_cfg.dest_id); \
-	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t,  attr->dest_cfg.priority);\
-	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, attr->dest_cfg.dest_type);\
-	MC_RSP_OP(cmd, 0, 42, 1,  int,      attr->order_preservation_en);\
-	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->user_ctx); \
-	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, attr->fqid); \
-} while (0)
-
-/*                cmd, param, offset, width, type, arg_name */
 #define DPNI_CMD_SET_TX_CONF_REVOKE(cmd, revoke) \
 	MC_CMD_OP(cmd, 0, 0,  1,  int,      revoke)
 
@@ -846,11 +833,46 @@ do { \
 } while (0)
 
 /*                cmd, param, offset, width, type, arg_name */
-#define DPNI_EXT_SET_RX_TC_EARLY_DROP(ext, cfg) \
+#define DPNI_CMD_GET_RX_TC_POLICING(cmd, tc_id) \
+	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  tc_id)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPNI_RSP_GET_RX_TC_POLICING(cmd, cfg) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  4, enum dpni_policer_mode, cfg->mode); \
+	MC_RSP_OP(cmd, 0, 4,  4, enum dpni_policer_color, cfg->default_color); \
+	MC_RSP_OP(cmd, 0, 8,  4, enum dpni_policer_unit, cfg->units); \
+	MC_RSP_OP(cmd, 0, 32, 32, uint32_t, cfg->options); \
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, cfg->cir); \
+	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, cfg->cbs); \
+	MC_RSP_OP(cmd, 2, 0,  32, uint32_t, cfg->eir); \
+	MC_RSP_OP(cmd, 2, 32, 32, uint32_t, cfg->ebs);\
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPNI_PREP_EARLY_DROP(ext, cfg) \
+do { \
+	MC_PREP_OP(ext, 0, 0,  2, enum dpni_early_drop_mode, cfg->mode); \
+	MC_PREP_OP(ext, 0, 2,  2, \
+		  enum dpni_congestion_unit, cfg->units); \
+	MC_PREP_OP(ext, 0, 32, 32, uint32_t, cfg->tail_drop_threshold); \
+	MC_PREP_OP(ext, 1, 0,  8,  uint8_t,  cfg->green.drop_probability); \
+	MC_PREP_OP(ext, 2, 0,  64, uint64_t, cfg->green.max_threshold); \
+	MC_PREP_OP(ext, 3, 0,  64, uint64_t, cfg->green.min_threshold); \
+	MC_PREP_OP(ext, 5, 0,  8,  uint8_t,  cfg->yellow.drop_probability);\
+	MC_PREP_OP(ext, 6, 0,  64, uint64_t, cfg->yellow.max_threshold); \
+	MC_PREP_OP(ext, 7, 0,  64, uint64_t, cfg->yellow.min_threshold); \
+	MC_PREP_OP(ext, 9, 0,  8,  uint8_t,  cfg->red.drop_probability); \
+	MC_PREP_OP(ext, 10, 0,  64, uint64_t, cfg->red.max_threshold); \
+	MC_PREP_OP(ext, 11, 0,  64, uint64_t, cfg->red.min_threshold); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPNI_EXT_EARLY_DROP(ext, cfg) \
 do { \
 	MC_EXT_OP(ext, 0, 0,  2, enum dpni_early_drop_mode, cfg->mode); \
 	MC_EXT_OP(ext, 0, 2,  2, \
-		  enum dpni_early_drop_unit, cfg->units); \
+		  enum dpni_congestion_unit, cfg->units); \
 	MC_EXT_OP(ext, 0, 32, 32, uint32_t, cfg->tail_drop_threshold); \
 	MC_EXT_OP(ext, 1, 0,  8,  uint8_t,  cfg->green.drop_probability); \
 	MC_EXT_OP(ext, 2, 0,  64, uint64_t, cfg->green.max_threshold); \
@@ -869,4 +891,168 @@ do { \
 	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
 	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, early_drop_iova); \
 } while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_GET_RX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova) \
+do { \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, early_drop_iova); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_SET_TX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova) \
+do { \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, early_drop_iova); \
+} while (0)
+
+/*                cmd, param, offset, width, type, arg_name */
+#define DPNI_CMD_GET_TX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova) \
+do { \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, early_drop_iova); \
+} while (0)
+
+#define DPNI_CMD_SET_RX_TC_CONGESTION_NOTIFICATION(cmd, tc_id, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
+	MC_CMD_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
+	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
+	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
+	MC_CMD_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
+	MC_CMD_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
+	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
+	MC_CMD_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
+	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+} while (0)
+
+#define DPNI_CMD_GET_RX_TC_CONGESTION_NOTIFICATION(cmd, tc_id) \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id)
+
+#define DPNI_RSP_GET_RX_TC_CONGESTION_NOTIFICATION(cmd, cfg) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
+	MC_RSP_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
+	MC_RSP_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
+	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
+	MC_RSP_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
+	MC_RSP_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
+	MC_RSP_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
+	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+} while (0)
+
+#define DPNI_CMD_SET_TX_TC_CONGESTION_NOTIFICATION(cmd, tc_id, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
+	MC_CMD_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id); \
+	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
+	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
+	MC_CMD_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
+	MC_CMD_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
+	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
+	MC_CMD_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
+	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+} while (0)
+
+#define DPNI_CMD_GET_TX_TC_CONGESTION_NOTIFICATION(cmd, tc_id) \
+	MC_CMD_OP(cmd, 0, 8,  8,  uint8_t,  tc_id)
+
+#define DPNI_RSP_GET_TX_TC_CONGESTION_NOTIFICATION(cmd, cfg) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
+	MC_RSP_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
+	MC_RSP_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
+	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
+	MC_RSP_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
+	MC_RSP_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
+	MC_RSP_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
+	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+} while (0)
+
+#define DPNI_CMD_SET_TX_CONF(cmd, flow_id, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 32, 8,  uint8_t, cfg->queue_cfg.dest_cfg.priority); \
+	MC_CMD_OP(cmd, 0, 40, 2,  enum dpni_dest, \
+		cfg->queue_cfg.dest_cfg.dest_type); \
+	MC_CMD_OP(cmd, 0, 42, 1,  int, cfg->errors_only); \
+	MC_CMD_OP(cmd, 0, 46, 1,  int, cfg->queue_cfg.order_preservation_en); \
+	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
+	MC_CMD_OP(cmd, 1, 0,  64, uint64_t, cfg->queue_cfg.user_ctx); \
+	MC_CMD_OP(cmd, 2, 0,  32, uint32_t, cfg->queue_cfg.options); \
+	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->queue_cfg.dest_cfg.dest_id); \
+	MC_CMD_OP(cmd, 3, 0,  32, uint32_t, \
+		cfg->queue_cfg.tail_drop_threshold); \
+	MC_CMD_OP(cmd, 4, 0,  4,  enum dpni_flc_type, \
+		cfg->queue_cfg.flc_cfg.flc_type); \
+	MC_CMD_OP(cmd, 4, 4,  4,  enum dpni_stash_size, \
+		cfg->queue_cfg.flc_cfg.frame_data_size); \
+	MC_CMD_OP(cmd, 4, 8,  4,  enum dpni_stash_size, \
+		cfg->queue_cfg.flc_cfg.flow_context_size); \
+	MC_CMD_OP(cmd, 4, 32, 32, uint32_t, cfg->queue_cfg.flc_cfg.options); \
+	MC_CMD_OP(cmd, 5, 0,  64, uint64_t, \
+		cfg->queue_cfg.flc_cfg.flow_context); \
+} while (0)
+
+#define DPNI_CMD_GET_TX_CONF(cmd, flow_id) \
+		MC_CMD_OP(cmd, 0, 48, 16, uint16_t,  flow_id)
+
+#define DPNI_RSP_GET_TX_CONF(cmd, attr) \
+do { \
+	MC_RSP_OP(cmd, 0, 32, 8,  uint8_t, \
+		  attr->queue_attr.dest_cfg.priority); \
+	MC_RSP_OP(cmd, 0, 40, 2,  enum dpni_dest, \
+		attr->queue_attr.dest_cfg.dest_type); \
+	MC_RSP_OP(cmd, 0, 42, 1,  int, attr->errors_only); \
+	MC_RSP_OP(cmd, 0, 46, 1,  int, \
+		  attr->queue_attr.order_preservation_en); \
+	MC_RSP_OP(cmd, 1, 0,  64, uint64_t, attr->queue_attr.user_ctx); \
+	MC_RSP_OP(cmd, 2, 32, 32, int,	attr->queue_attr.dest_cfg.dest_id); \
+	MC_RSP_OP(cmd, 3, 0,  32, uint32_t, \
+		attr->queue_attr.tail_drop_threshold); \
+	MC_RSP_OP(cmd, 3, 32, 32, uint32_t, attr->queue_attr.fqid); \
+	MC_RSP_OP(cmd, 4, 0,  4,  enum dpni_flc_type, \
+		attr->queue_attr.flc_cfg.flc_type); \
+	MC_RSP_OP(cmd, 4, 4,  4,  enum dpni_stash_size, \
+		attr->queue_attr.flc_cfg.frame_data_size); \
+	MC_RSP_OP(cmd, 4, 8,  4,  enum dpni_stash_size, \
+		attr->queue_attr.flc_cfg.flow_context_size); \
+	MC_RSP_OP(cmd, 4, 32, 32, uint32_t, attr->queue_attr.flc_cfg.options); \
+	MC_RSP_OP(cmd, 5, 0,  64, uint64_t, \
+		attr->queue_attr.flc_cfg.flow_context); \
+} while (0)
+
+#define DPNI_CMD_SET_TX_CONF_CONGESTION_NOTIFICATION(cmd, flow_id, cfg) \
+do { \
+	MC_CMD_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
+	MC_CMD_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
+	MC_CMD_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
+	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id); \
+	MC_CMD_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
+	MC_CMD_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
+	MC_CMD_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
+	MC_CMD_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
+	MC_CMD_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
+	MC_CMD_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+} while (0)
+
+#define DPNI_CMD_GET_TX_CONF_CONGESTION_NOTIFICATION(cmd, flow_id) \
+	MC_CMD_OP(cmd, 0, 48, 16, uint16_t, flow_id)
+
+#define DPNI_RSP_GET_TX_CONF_CONGESTION_NOTIFICATION(cmd, cfg) \
+do { \
+	MC_RSP_OP(cmd, 0, 0,  2,  enum dpni_congestion_unit, cfg->units); \
+	MC_RSP_OP(cmd, 0, 4,  4,  enum dpni_dest, cfg->dest_cfg.dest_type); \
+	MC_RSP_OP(cmd, 0, 16, 8,  uint8_t,  cfg->dest_cfg.priority); \
+	MC_RSP_OP(cmd, 1, 0,  32, uint32_t, cfg->threshold_entry); \
+	MC_RSP_OP(cmd, 1, 32, 32, uint32_t, cfg->threshold_exit); \
+	MC_RSP_OP(cmd, 2, 0,  16, uint16_t, cfg->options); \
+	MC_RSP_OP(cmd, 2, 32, 32, int,	    cfg->dest_cfg.dest_id); \
+	MC_RSP_OP(cmd, 3, 0,  64, uint64_t, cfg->message_ctx); \
+	MC_RSP_OP(cmd, 4, 0,  64, uint64_t, cfg->message_iova); \
+} while (0)
+
 #endif /* _FSL_DPNI_CMD_H */
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpni.c b/drivers/staging/fsl-dpaa2/ethernet/dpni.c
index 5a7f7ac..629fc72 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpni.c
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpni.c
@@ -34,81 +34,80 @@
 #include "dpni.h"
 #include "dpni-cmd.h"
 
-int dpni_prepare_key_cfg(struct dpkg_profile_cfg *cfg,
+int dpni_prepare_key_cfg(const struct dpkg_profile_cfg *cfg,
 			 uint8_t *key_cfg_buf)
 {
 	int i, j;
 	int offset = 0;
 	int param = 1;
 	uint64_t *params = (uint64_t *)key_cfg_buf;
-	struct {
-		uint32_t field;
-		uint8_t size;
-		uint8_t offset;
-		uint8_t hdr_index;
-		uint8_t constant;
-		uint8_t num_of_repeats;
-		enum net_prot prot;
-		enum dpkg_extract_from_hdr_type type;
-	} u_cfg[DPKG_MAX_NUM_OF_EXTRACTS] = { {0} };
 
 	if (!key_cfg_buf || !cfg)
 			return -EINVAL;
 
+	params[0] |= mc_enc(0, 8, cfg->num_extracts);
+	params[0] = cpu_to_le64(params[0]);
+
+	if (cfg->num_extracts >= DPKG_MAX_NUM_OF_EXTRACTS)
+		return -EINVAL;
+
 	for (i = 0; i < cfg->num_extracts; i++) {
 		switch (cfg->extracts[i].type) {
 		case DPKG_EXTRACT_FROM_HDR:
-			u_cfg[i].prot = cfg->extracts[i].extract.from_hdr.prot;
-			u_cfg[i].type = cfg->extracts[i].extract.from_hdr.type;
-			u_cfg[i].field =
-				cfg->extracts[i].extract.from_hdr.field;
-			u_cfg[i].size = cfg->extracts[i].extract.from_hdr.size;
-			u_cfg[i].offset =
-				cfg->extracts[i].extract.from_hdr.offset;
-			u_cfg[i].hdr_index =
-				cfg->extracts[i].extract.from_hdr.hdr_index;
+			params[param] |= mc_enc(0, 8,
+					cfg->extracts[i].extract.from_hdr.prot);
+			params[param] |= mc_enc(8, 4,
+					cfg->extracts[i].extract.from_hdr.type);
+			params[param] |= mc_enc(16, 8,
+					cfg->extracts[i].extract.from_hdr.size);
+			params[param] |= mc_enc(24, 8,
+					cfg->extracts[i].extract.
+					from_hdr.offset);
+			params[param] |= mc_enc(32, 32,
+					cfg->extracts[i].extract.
+					from_hdr.field);
+			params[param] = cpu_to_le64(params[param]);
+			param++;
+			params[param] |= mc_enc(0, 8,
+					cfg->extracts[i].extract.
+					from_hdr.hdr_index);
 			break;
 		case DPKG_EXTRACT_FROM_DATA:
-			u_cfg[i].size = cfg->extracts[i].extract.from_data.size;
-			u_cfg[i].offset =
-				cfg->extracts[i].extract.from_data.offset;
+			params[param] |= mc_enc(16, 8,
+					cfg->extracts[i].extract.
+					from_data.size);
+			params[param] |= mc_enc(24, 8,
+					cfg->extracts[i].extract.
+					from_data.offset);
+			params[param] = cpu_to_le64(params[param]);
+			param++;
 			break;
-		case DPKG_EXTRACT_CONSTANT:
-			u_cfg[i].constant =
-				cfg->extracts[i].extract.constant.constant;
-			u_cfg[i].num_of_repeats =
-			       cfg->extracts[i].extract.constant.num_of_repeats;
+		case DPKG_EXTRACT_FROM_PARSE:
+			params[param] |= mc_enc(16, 8,
+					cfg->extracts[i].extract.
+					from_parse.size);
+			params[param] |= mc_enc(24, 8,
+					cfg->extracts[i].extract.
+					from_parse.offset);
+			params[param] = cpu_to_le64(params[param]);
+			param++;
 			break;
 		default:
 			return -EINVAL;
 		}
-	}
-	params[0] |= mc_enc(0, 8, cfg->num_extracts);
-	params[0] = cpu_to_le64(params[0]);
-
-	for (i = 0; i < DPKG_MAX_NUM_OF_EXTRACTS; i++) {
-		params[param] |= mc_enc(0, 8, u_cfg[i].prot);
-		params[param] |= mc_enc(8, 4, u_cfg[i].type);
-		params[param] |= mc_enc(16, 8, u_cfg[i].size);
-		params[param] |= mc_enc(24, 8, u_cfg[i].offset);
-		params[param] |= mc_enc(32, 32, u_cfg[i].field);
-		params[param] = cpu_to_le64(params[param]);
-		param++;
-		params[param] |= mc_enc(0, 8, u_cfg[i].hdr_index);
-		params[param] |= mc_enc(8, 8, u_cfg[i].constant);
-		params[param] |= mc_enc(16, 8, u_cfg[i].num_of_repeats);
 		params[param] |= mc_enc(
 			24, 8, cfg->extracts[i].num_of_byte_masks);
 		params[param] |= mc_enc(32, 4, cfg->extracts[i].type);
 		params[param] = cpu_to_le64(params[param]);
 		param++;
-		for (j = 0; j < 4; j++) {
+		for (offset = 0, j = 0;
+			j < DPKG_NUM_OF_MASKS;
+			offset += 16, j++) {
 			params[param] |= mc_enc(
 				(offset), 8, cfg->extracts[i].masks[j].mask);
 			params[param] |= mc_enc(
 				(offset + 8), 8,
 				cfg->extracts[i].masks[j].offset);
-			offset += 16;
 		}
 		params[param] = cpu_to_le64(params[param]);
 		param++;
@@ -116,6 +115,26 @@ int dpni_prepare_key_cfg(struct dpkg_profile_cfg *cfg,
 	return 0;
 }
 
+int dpni_prepare_extended_cfg(const struct dpni_extended_cfg	*cfg,
+			      uint8_t			*ext_cfg_buf)
+{
+	uint64_t *ext_params = (uint64_t *)ext_cfg_buf;
+
+	DPNI_PREP_EXTENDED_CFG(ext_params, cfg);
+
+	return 0;
+}
+
+int dpni_extract_extended_cfg(struct dpni_extended_cfg	*cfg,
+			      const uint8_t		*ext_cfg_buf)
+{
+	uint64_t *ext_params = (uint64_t *)ext_cfg_buf;
+
+	DPNI_EXT_EXTENDED_CFG(ext_params, cfg);
+
+	return 0;
+}
+
 int dpni_open(struct fsl_mc_io *mc_io,
 	      uint32_t cmd_flags,
 	      int dpni_id,
@@ -426,7 +445,7 @@ int dpni_get_irq_status(struct fsl_mc_io *mc_io,
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_IRQ_STATUS,
 					  cmd_flags,
 					  token);
-	DPNI_CMD_GET_IRQ_STATUS(cmd, irq_index);
+	DPNI_CMD_GET_IRQ_STATUS(cmd, irq_index, *status);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -469,6 +488,7 @@ int dpni_get_attributes(struct fsl_mc_io *mc_io,
 	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_ATTR,
 					  cmd_flags,
 					  token);
+	DPNI_CMD_GET_ATTR(cmd, attr);
 
 	/* send command to mc*/
 	err = mc_send_command(mc_io, &cmd);
@@ -1200,24 +1220,6 @@ int dpni_clear_vlan_filters(struct fsl_mc_io *mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-int dpni_set_tx_tc(struct fsl_mc_io *mc_io,
-		   uint32_t cmd_flags,
-		   uint16_t token,
-		   uint8_t tc_id,
-		   const struct dpni_tx_tc_cfg *cfg)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_TC,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_TX_TC(cmd, tc_id, cfg);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
 int dpni_set_tx_selection(struct fsl_mc_io			*mc_io,
 			  uint32_t				cmd_flags,
 			  uint16_t				token,
@@ -1391,47 +1393,6 @@ int dpni_get_rx_err_queue(struct fsl_mc_io *mc_io,
 	return 0;
 }
 
-int dpni_set_tx_conf_err_queue(struct fsl_mc_io *mc_io,
-			       uint32_t cmd_flags,
-			       uint16_t token,
-			       const struct dpni_queue_cfg *cfg)
-{
-	struct mc_command cmd = { 0 };
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF_ERR_QUEUE,
-					  cmd_flags,
-					  token);
-	DPNI_CMD_SET_TX_CONF_ERR_QUEUE(cmd, cfg);
-
-	/* send command to mc*/
-	return mc_send_command(mc_io, &cmd);
-}
-
-int dpni_get_tx_conf_err_queue(struct fsl_mc_io *mc_io,
-			       uint32_t cmd_flags,
-			       uint16_t token,
-			       struct dpni_queue_attr *attr)
-{
-	struct mc_command cmd = { 0 };
-	int err;
-
-	/* prepare command */
-	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_CONF_ERR_QUEUE,
-					  cmd_flags,
-					  token);
-
-	/* send command to mc*/
-	err = mc_send_command(mc_io, &cmd);
-	if (err)
-		return err;
-
-	/* retrieve response parameters */
-	DPNI_RSP_GET_TX_CONF_ERR_QUEUE(cmd, attr);
-
-	return 0;
-}
-
 int dpni_set_tx_conf_revoke(struct fsl_mc_io	*mc_io,
 			    uint32_t		cmd_flags,
 			    uint16_t		token,
@@ -1654,12 +1615,45 @@ int dpni_set_rx_tc_policing(struct fsl_mc_io	*mc_io,
 	return mc_send_command(mc_io, &cmd);
 }
 
-void dpni_prepare_rx_tc_early_drop(const struct dpni_rx_tc_early_drop_cfg *cfg,
-				   uint8_t *early_drop_buf)
+int dpni_get_rx_tc_policing(struct fsl_mc_io			*mc_io,
+			    uint32_t				cmd_flags,
+			    uint16_t				token,
+			    uint8_t				tc_id,
+			    struct dpni_rx_tc_policing_cfg	*cfg)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_TC_POLICING,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_GET_RX_TC_POLICING(cmd, tc_id);
+
+	/* send command to mc*/
+	err =  mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	DPNI_RSP_GET_RX_TC_POLICING(cmd, cfg);
+
+	return 0;
+}
+
+void dpni_prepare_early_drop(const struct dpni_early_drop_cfg *cfg,
+			     uint8_t *early_drop_buf)
+{
+	uint64_t *ext_params = (uint64_t *)early_drop_buf;
+
+	DPNI_PREP_EARLY_DROP(ext_params, cfg);
+}
+
+void dpni_extract_early_drop(struct dpni_early_drop_cfg *cfg,
+			     const uint8_t *early_drop_buf)
 {
 	uint64_t *ext_params = (uint64_t *)early_drop_buf;
 
-	DPNI_EXT_SET_RX_TC_EARLY_DROP(ext_params, cfg);
+	DPNI_EXT_EARLY_DROP(ext_params, cfg);
 }
 
 int dpni_set_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
@@ -1679,3 +1673,235 @@ int dpni_set_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
 	/* send command to mc*/
 	return mc_send_command(mc_io, &cmd);
 }
+
+int dpni_get_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
+			      uint16_t		token,
+			      uint8_t		tc_id,
+			      uint64_t		early_drop_iova)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_RX_TC_EARLY_DROP,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_GET_RX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_set_tx_tc_early_drop(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
+			      uint16_t		token,
+			      uint8_t		tc_id,
+			      uint64_t		early_drop_iova)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_TC_EARLY_DROP,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_TX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_get_tx_tc_early_drop(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
+			      uint16_t		token,
+			      uint8_t		tc_id,
+			      uint64_t		early_drop_iova)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_TC_EARLY_DROP,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_GET_TX_TC_EARLY_DROP(cmd, tc_id, early_drop_iova);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_set_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+					   uint32_t		cmd_flags,
+					   uint16_t		token,
+					   uint8_t		tc_id,
+			const struct dpni_congestion_notification_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(
+			DPNI_CMDID_SET_RX_TC_CONGESTION_NOTIFICATION,
+			cmd_flags,
+			token);
+	DPNI_CMD_SET_RX_TC_CONGESTION_NOTIFICATION(cmd, tc_id, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_get_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+					   uint32_t		cmd_flags,
+					   uint16_t		token,
+					   uint8_t		tc_id,
+				struct dpni_congestion_notification_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(
+			DPNI_CMDID_GET_RX_TC_CONGESTION_NOTIFICATION,
+			cmd_flags,
+			token);
+	DPNI_CMD_GET_RX_TC_CONGESTION_NOTIFICATION(cmd, tc_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	DPNI_RSP_GET_RX_TC_CONGESTION_NOTIFICATION(cmd, cfg);
+
+	return 0;
+}
+
+int dpni_set_tx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+					   uint32_t		cmd_flags,
+					   uint16_t		token,
+					   uint8_t		tc_id,
+			const struct dpni_congestion_notification_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(
+			DPNI_CMDID_SET_TX_TC_CONGESTION_NOTIFICATION,
+			cmd_flags,
+			token);
+	DPNI_CMD_SET_TX_TC_CONGESTION_NOTIFICATION(cmd, tc_id, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_get_tx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+					   uint32_t		cmd_flags,
+					   uint16_t		token,
+					   uint8_t		tc_id,
+				struct dpni_congestion_notification_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(
+			DPNI_CMDID_GET_TX_TC_CONGESTION_NOTIFICATION,
+			cmd_flags,
+			token);
+	DPNI_CMD_GET_TX_TC_CONGESTION_NOTIFICATION(cmd, tc_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	DPNI_RSP_GET_TX_TC_CONGESTION_NOTIFICATION(cmd, cfg);
+
+	return 0;
+}
+
+int dpni_set_tx_conf(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
+		     uint16_t		token,
+		     uint16_t		flow_id,
+		     const struct dpni_tx_conf_cfg	*cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_SET_TX_CONF,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_SET_TX_CONF(cmd, flow_id, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_get_tx_conf(struct fsl_mc_io		*mc_io,
+		     uint32_t			cmd_flags,
+		     uint16_t			token,
+		     uint16_t			flow_id,
+		     struct dpni_tx_conf_attr	*attr)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(DPNI_CMDID_GET_TX_CONF,
+					  cmd_flags,
+					  token);
+	DPNI_CMD_GET_TX_CONF(cmd, flow_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	DPNI_RSP_GET_TX_CONF(cmd, attr);
+
+	return 0;
+}
+
+int dpni_set_tx_conf_congestion_notification(struct fsl_mc_io	*mc_io,
+					     uint32_t		cmd_flags,
+					     uint16_t		token,
+					     uint16_t		flow_id,
+			 const struct dpni_congestion_notification_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(
+			DPNI_CMDID_SET_TX_CONF_CONGESTION_NOTIFICATION,
+			cmd_flags,
+			token);
+	DPNI_CMD_SET_TX_CONF_CONGESTION_NOTIFICATION(cmd, flow_id, cfg);
+
+	/* send command to mc*/
+	return mc_send_command(mc_io, &cmd);
+}
+
+int dpni_get_tx_conf_congestion_notification(struct fsl_mc_io	*mc_io,
+					     uint32_t		cmd_flags,
+					     uint16_t		token,
+					     uint16_t		flow_id,
+				 struct dpni_congestion_notification_cfg *cfg)
+{
+	struct mc_command cmd = { 0 };
+	int err;
+
+	/* prepare command */
+	cmd.header = mc_encode_cmd_header(
+				DPNI_CMDID_GET_TX_CONF_CONGESTION_NOTIFICATION,
+				cmd_flags,
+				token);
+	DPNI_CMD_GET_TX_CONF_CONGESTION_NOTIFICATION(cmd, flow_id);
+
+	/* send command to mc*/
+	err = mc_send_command(mc_io, &cmd);
+	if (err)
+		return err;
+
+	DPNI_RSP_GET_TX_CONF_CONGESTION_NOTIFICATION(cmd, cfg);
+
+	return 0;
+}
diff --git a/drivers/staging/fsl-dpaa2/ethernet/dpni.h b/drivers/staging/fsl-dpaa2/ethernet/dpni.h
index caafe7a..fca426d 100644
--- a/drivers/staging/fsl-dpaa2/ethernet/dpni.h
+++ b/drivers/staging/fsl-dpaa2/ethernet/dpni.h
@@ -41,21 +41,35 @@ struct fsl_mc_io;
  * Contains initialization APIs and runtime control APIs for DPNI
  */
 
-/* General DPNI macros */
+/** General DPNI macros */
 
-/* Maximum number of traffic classes */
+/**
+ * Maximum number of traffic classes
+ */
 #define DPNI_MAX_TC				8
-/* Maximum number of buffer pools per DPNI */
+/**
+ * Maximum number of buffer pools per DPNI
+ */
 #define DPNI_MAX_DPBP				8
-/* Maximum number of storage-profiles per DPNI */
+/**
+ * Maximum number of storage-profiles per DPNI
+ */
 #define DPNI_MAX_SP				2
 
-/* All traffic classes considered; see dpni_set_rx_flow() */
+/**
+ * All traffic classes considered; see dpni_set_rx_flow()
+ */
 #define DPNI_ALL_TCS				(uint8_t)(-1)
-/* All flows within traffic class considered; see dpni_set_rx_flow() */
+/**
+ * All flows within traffic class considered; see dpni_set_rx_flow()
+ */
 #define DPNI_ALL_TC_FLOWS			(uint16_t)(-1)
-/* Generate new flow ID; see dpni_set_tx_flow() */
+/**
+ * Generate new flow ID; see dpni_set_tx_flow()
+ */
 #define DPNI_NEW_FLOW_ID			(uint16_t)(-1)
+/* use for common tx-conf queue; see dpni_set_tx_conf_<x>() */
+#define DPNI_COMMON_TX_CONF			(uint16_t)(-1)
 
 /**
  * dpni_open() - Open a control session for the specified object
@@ -108,7 +122,9 @@ int dpni_close(struct fsl_mc_io	*mc_io,
  */
 #define DPNI_OPT_TX_CONF_DISABLED		0x00000002
 
-/* Disable per-sender private Tx confirmation/error queue */
+/**
+ * Disable per-sender private Tx confirmation/error queue
+ */
 #define DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED	0x00000004
 
 /**
@@ -118,46 +134,98 @@ int dpni_close(struct fsl_mc_io	*mc_io,
 #define DPNI_OPT_DIST_HASH			0x00000010
 
 /**
+ * DEPRECATED - if this flag is selected and and all new 'max_fs_entries' are
+ * '0' then backward compatibility is preserved;
  * Support distribution based on flow steering;
  * allows explicit control of distribution over receive queues in a traffic
  * class
  */
 #define DPNI_OPT_DIST_FS			0x00000020
 
-/* Unicast filtering support */
+/**
+ * Unicast filtering support
+ */
 #define DPNI_OPT_UNICAST_FILTER			0x00000080
-/* Multicast filtering support */
+/**
+ * Multicast filtering support
+ */
 #define DPNI_OPT_MULTICAST_FILTER		0x00000100
-/* VLAN filtering support */
+/**
+ * VLAN filtering support
+ */
 #define DPNI_OPT_VLAN_FILTER			0x00000200
-/* Support IP reassembly on received packets */
+/**
+ * Support IP reassembly on received packets
+ */
 #define DPNI_OPT_IPR				0x00000800
-/* Support IP fragmentation on transmitted packets */
+/**
+ * Support IP fragmentation on transmitted packets
+ */
 #define DPNI_OPT_IPF				0x00001000
-/* VLAN manipulation support */
+/**
+ * VLAN manipulation support
+ */
 #define DPNI_OPT_VLAN_MANIPULATION		0x00010000
-/* Support masking of QoS lookup keys */
+/**
+ * Support masking of QoS lookup keys
+ */
 #define DPNI_OPT_QOS_MASK_SUPPORT		0x00020000
-/* Support masking of Flow Steering lookup keys */
+/**
+ * Support masking of Flow Steering lookup keys
+ */
 #define DPNI_OPT_FS_MASK_SUPPORT		0x00040000
 
 /**
- * struct dpni_ipr_cfg - Structure representing IP reassembly configuration
- * @max_reass_frm_size: Maximum size of the reassembled frame
- * @min_frag_size_ipv4: Minimum fragment size of IPv4 fragments
- * @min_frag_size_ipv6: Minimum fragment size of IPv6 fragments
- * @max_open_frames_ipv4: Maximum concurrent IPv4 packets in reassembly process
- * @max_open_frames_ipv6: Maximum concurrent IPv6 packets in reassembly process
+ * struct dpni_extended_cfg - Structure representing extended DPNI configuration
+ * @tc_cfg: TCs configuration
+ * @ipr_cfg: IP reassembly configuration
  */
-struct dpni_ipr_cfg {
-	uint16_t max_reass_frm_size;
-	uint16_t min_frag_size_ipv4;
-	uint16_t min_frag_size_ipv6;
-	uint16_t max_open_frames_ipv4;
-	uint16_t max_open_frames_ipv6;
+struct dpni_extended_cfg {
+	/**
+	 * struct tc_cfg - TC configuration
+	 * @max_dist: Maximum distribution size for Rx traffic class;
+	 *	supported values: 1,2,3,4,6,7,8,12,14,16,24,28,32,48,56,64,96,
+	 *	112,128,192,224,256,384,448,512,768,896,1024;
+	 *	value '0' will be treated as '1'.
+	 *	other unsupported values will be round down to the nearest
+	 *	supported value.
+	 * @max_fs_entries: Maximum FS entries for Rx traffic class;
+	 *	'0' means no support for this TC;
+	 */
+	struct {
+		uint16_t	max_dist;
+		uint16_t	max_fs_entries;
+	} tc_cfg[DPNI_MAX_TC];
+	/**
+	 * struct ipr_cfg - Structure representing IP reassembly configuration
+	 * @max_reass_frm_size: Maximum size of the reassembled frame
+	 * @min_frag_size_ipv4: Minimum fragment size of IPv4 fragments
+	 * @min_frag_size_ipv6: Minimum fragment size of IPv6 fragments
+	 * @max_open_frames_ipv4: Maximum concurrent IPv4 packets in reassembly
+	 *		process
+	 * @max_open_frames_ipv6: Maximum concurrent IPv6 packets in reassembly
+	 *		process
+	 */
+	struct {
+		uint16_t max_reass_frm_size;
+		uint16_t min_frag_size_ipv4;
+		uint16_t min_frag_size_ipv6;
+		uint16_t max_open_frames_ipv4;
+		uint16_t max_open_frames_ipv6;
+	} ipr_cfg;
 };
 
 /**
+ * dpni_prepare_extended_cfg() - function prepare extended parameters
+ * @cfg: extended structure
+ * @ext_cfg_buf: Zeroed 256 bytes of memory before mapping it to DMA
+ *
+ * This function has to be called before dpni_create()
+ */
+int dpni_prepare_extended_cfg(const struct dpni_extended_cfg	*cfg,
+			      uint8_t			*ext_cfg_buf);
+
+/**
  * struct dpni_cfg - Structure representing DPNI configuration
  * @mac_addr: Primary MAC address
  * @adv: Advanced parameters; default is all zeros;
@@ -176,9 +244,6 @@ struct dpni_cfg {
 	 *		'0' will be treated as '1'
 	 * @max_tcs: Maximum number of traffic classes (for both Tx and Rx);
 	 *		'0' will e treated as '1'
-	 * @max_dist_per_tc: Maximum distribution size per Rx traffic class;
-	 *			Non-power-of-2 values are rounded up to the next
-	 *			power-of-2 value as hardware demands it
 	 * @max_unicast_filters: Maximum number of unicast filters;
 	 *			'0' is treated	as '16'
 	 * @max_multicast_filters: Maximum number of multicast filters;
@@ -194,25 +259,26 @@ struct dpni_cfg {
 	 *		should be between '0' and max_tcs
 	 * @max_congestion_ctrl: Maximum number of congestion control groups
 	 *		(CGs); covers early drop and congestion notification
-	 *		requirements for traffic classes;
-	 *		should be between '0' and max_tcs
-	 * @ipr_cfg: IP reassembly configuration
+	 *		requirements;
+	 *		should be between '0' and ('max_tcs' + 'max_senders')
+	 * @ext_cfg_iova: I/O virtual address of 256 bytes DMA-able memory
+	 *		filled with the extended configuration by calling
+	 *		dpni_prepare_extended_cfg()
 	 */
 	struct {
-		uint32_t		options;
-		enum net_prot		start_hdr;
+		uint32_t	options;
+		enum net_prot	start_hdr;
 		uint8_t		max_senders;
 		uint8_t		max_tcs;
-		uint8_t		max_dist_per_tc[DPNI_MAX_TC];
 		uint8_t		max_unicast_filters;
 		uint8_t		max_multicast_filters;
-		uint8_t			max_vlan_filters;
+		uint8_t		max_vlan_filters;
 		uint8_t		max_qos_entries;
 		uint8_t		max_qos_key_size;
 		uint8_t		max_dist_key_size;
 		uint8_t		max_policers;
 		uint8_t		max_congestion_ctrl;
-		struct dpni_ipr_cfg	ipr_cfg;
+		uint64_t	ext_cfg_iova;
 	} adv;
 };
 
@@ -343,23 +409,29 @@ int dpni_reset(struct fsl_mc_io	*mc_io,
 	       uint32_t		cmd_flags,
 	       uint16_t		token);
 
-/* DPNI IRQ Index and Events */
+/**
+ * DPNI IRQ Index and Events
+ */
 
-/* IRQ index */
+/**
+ * IRQ index
+ */
 #define DPNI_IRQ_INDEX				0
-/* IRQ event - indicates a change in link state */
+/**
+ * IRQ event - indicates a change in link state
+ */
 #define DPNI_IRQ_EVENT_LINK_CHANGED		0x00000001
 
 /**
  * struct dpni_irq_cfg - IRQ configuration
  * @addr:	Address that must be written to signal a message-based interrupt
  * @val:	Value to write into irq_addr address
- * @user_irq_id: A user defined number associated with this IRQ
+ * @irq_num: A user defined number associated with this IRQ
  */
 struct dpni_irq_cfg {
 	     uint64_t		addr;
 	     uint32_t		val;
-	     int		user_irq_id;
+	     int		irq_num;
 };
 
 /**
@@ -521,8 +593,6 @@ int dpni_clear_irq_status(struct fsl_mc_io	*mc_io,
  * @max_senders: Maximum number of different senders; used as the number
  *		of dedicated Tx flows;
  * @max_tcs: Maximum number of traffic classes (for both Tx and Rx)
- * @max_dist_per_tc: Maximum distribution size per Rx traffic class;
- *			Set to the required value minus 1
  * @max_unicast_filters: Maximum number of unicast filters
  * @max_multicast_filters: Maximum number of multicast filters
  * @max_vlan_filters: Maximum number of VLAN filters
@@ -531,10 +601,11 @@ int dpni_clear_irq_status(struct fsl_mc_io	*mc_io,
  * @max_dist_key_size: Maximum key size for the distribution look-up
  * @max_policers: Maximum number of policers;
  * @max_congestion_ctrl: Maximum number of congestion control groups (CGs);
- * @ipr_cfg: IP reassembly configuration
+ * @ext_cfg_iova: I/O virtual address of 256 bytes DMA-able memory;
+ *	call dpni_extract_extended_cfg() to extract the extended configuration
  */
 struct dpni_attr {
-	int			id;
+	int		id;
 	/**
 	 * struct version - DPNI version
 	 * @major: DPNI major version
@@ -544,20 +615,19 @@ struct dpni_attr {
 		uint16_t major;
 		uint16_t minor;
 	} version;
-	enum net_prot		start_hdr;
-	uint32_t		options;
-	uint8_t			max_senders;
+	enum net_prot	start_hdr;
+	uint32_t	options;
+	uint8_t		max_senders;
 	uint8_t		max_tcs;
-	uint8_t		max_dist_per_tc[DPNI_MAX_TC];
 	uint8_t		max_unicast_filters;
 	uint8_t		max_multicast_filters;
 	uint8_t		max_vlan_filters;
 	uint8_t		max_qos_entries;
 	uint8_t		max_qos_key_size;
 	uint8_t		max_dist_key_size;
-	uint8_t			max_policers;
+	uint8_t		max_policers;
 	uint8_t		max_congestion_ctrl;
-	struct dpni_ipr_cfg	ipr_cfg;
+	uint64_t	ext_cfg_iova;
 };
 
 /**
@@ -565,7 +635,7 @@ struct dpni_attr {
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
- * @attr:	Returned object's attributes
+ * @attr:	Object's attributes
  *
  * Return:	'0' on Success; Error code otherwise.
  */
@@ -574,26 +644,50 @@ int dpni_get_attributes(struct fsl_mc_io	*mc_io,
 			uint16_t		token,
 			struct dpni_attr	*attr);
 
-/* DPNI errors */
+/**
+ * dpni_extract_extended_cfg() - extract the extended parameters
+ * @cfg: extended structure
+ * @ext_cfg_buf: 256 bytes of DMA-able memory
+ *
+ * This function has to be called after dpni_get_attributes()
+ */
+int dpni_extract_extended_cfg(struct dpni_extended_cfg	*cfg,
+			      const uint8_t		*ext_cfg_buf);
+
+/**
+ * DPNI errors
+ */
 
-/* Extract out of frame header error */
+/**
+ * Extract out of frame header error
+ */
 #define DPNI_ERROR_EOFHE	0x00020000
-/* Frame length error */
+/**
+ * Frame length error
+ */
 #define DPNI_ERROR_FLE		0x00002000
-/* Frame physical error */
+/**
+ * Frame physical error
+ */
 #define DPNI_ERROR_FPE		0x00001000
-/* Parsing header error */
+/**
+ * Parsing header error
+ */
 #define DPNI_ERROR_PHE		0x00000020
-/* Parser L3 checksum error */
+/**
+ * Parser L3 checksum error
+ */
 #define DPNI_ERROR_L3CE		0x00000004
-/* Parser L3 checksum error */
+/**
+ * Parser L3 checksum error
+ */
 #define DPNI_ERROR_L4CE		0x00000001
 
 /**
- *  enum dpni_error_action - Defines DPNI behavior for errors
- *  @DPNI_ERROR_ACTION_DISCARD: Discard the frame
- *  @DPNI_ERROR_ACTION_CONTINUE: Continue with the normal flow
- *  @DPNI_ERROR_ACTION_SEND_TO_ERROR_QUEUE: Send the frame to the error queue
+ * enum dpni_error_action - Defines DPNI behavior for errors
+ * @DPNI_ERROR_ACTION_DISCARD: Discard the frame
+ * @DPNI_ERROR_ACTION_CONTINUE: Continue with the normal flow
+ * @DPNI_ERROR_ACTION_SEND_TO_ERROR_QUEUE: Send the frame to the error queue
  */
 enum dpni_error_action {
 	DPNI_ERROR_ACTION_DISCARD = 0,
@@ -631,21 +725,37 @@ int dpni_set_errors_behavior(struct fsl_mc_io		*mc_io,
 			     uint16_t			token,
 			     struct dpni_error_cfg	*cfg);
 
-/* DPNI buffer layout modification options */
+/**
+ * DPNI buffer layout modification options
+ */
 
-/* Select to modify the time-stamp setting */
+/**
+ * Select to modify the time-stamp setting
+ */
 #define DPNI_BUF_LAYOUT_OPT_TIMESTAMP		0x00000001
-/* Select to modify the parser-result setting; not applicable for Tx */
+/**
+ * Select to modify the parser-result setting; not applicable for Tx
+ */
 #define DPNI_BUF_LAYOUT_OPT_PARSER_RESULT	0x00000002
-/* Select to modify the frame-status setting */
+/**
+ * Select to modify the frame-status setting
+ */
 #define DPNI_BUF_LAYOUT_OPT_FRAME_STATUS	0x00000004
-/* Select to modify the private-data-size setting */
+/**
+ * Select to modify the private-data-size setting
+ */
 #define DPNI_BUF_LAYOUT_OPT_PRIVATE_DATA_SIZE	0x00000008
-/* Select to modify the data-alignment setting */
+/**
+ * Select to modify the data-alignment setting
+ */
 #define DPNI_BUF_LAYOUT_OPT_DATA_ALIGN		0x00000010
-/* Select to modify the data-head-room setting */
+/**
+ * Select to modify the data-head-room setting
+ */
 #define DPNI_BUF_LAYOUT_OPT_DATA_HEAD_ROOM	0x00000020
-/*!< Select to modify the data-tail-room setting */
+/**
+ * Select to modify the data-tail-room setting
+ */
 #define DPNI_BUF_LAYOUT_OPT_DATA_TAIL_ROOM	0x00000040
 
 /**
@@ -936,13 +1046,21 @@ int dpni_set_counter(struct fsl_mc_io	*mc_io,
 		     enum dpni_counter	counter,
 		     uint64_t		value);
 
-/* Enable auto-negotiation */
+/**
+ * Enable auto-negotiation
+ */
 #define DPNI_LINK_OPT_AUTONEG		0x0000000000000001ULL
-/* Enable half-duplex mode */
+/**
+ * Enable half-duplex mode
+ */
 #define DPNI_LINK_OPT_HALF_DUPLEX	0x0000000000000002ULL
-/* Enable pause frames */
+/**
+ * Enable pause frames
+ */
 #define DPNI_LINK_OPT_PAUSE		0x0000000000000004ULL
-/* Enable a-symmetric pause frames */
+/**
+ * Enable a-symmetric pause frames
+ */
 #define DPNI_LINK_OPT_ASYM_PAUSE	0x0000000000000008ULL
 
 /**
@@ -1266,32 +1384,6 @@ int dpni_clear_vlan_filters(struct fsl_mc_io	*mc_io,
 			    uint16_t		token);
 
 /**
- * struct dpni_tx_tc_cfg - Structure representing Tx traffic class configuration
- * @depth_limit: Limit the depth of a queue to the given value; note, that this
- *		may result in frames being rejected from the queue;
- *		set to '0' to remove any limitation
- */
-struct dpni_tx_tc_cfg {
-	uint16_t depth_limit;
-};
-
-/**
- * dpni_set_tx_tc() - Set Tx traffic class configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @tc_id:	Traffic class selection (0-7)
- * @cfg:	Traffic class configuration
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_tx_tc(struct fsl_mc_io		*mc_io,
-		   uint32_t			cmd_flags,
-		   uint16_t			token,
-		   uint8_t			tc_id,
-		   const struct dpni_tx_tc_cfg	*cfg);
-
-/**
  * enum dpni_tx_schedule_mode - DPNI Tx scheduling mode
  * @DPNI_TX_SCHED_STRICT_PRIORITY: strict priority
  * @DPNI_TX_SCHED_WEIGHTED: weighted based scheduling
@@ -1383,13 +1475,14 @@ struct dpni_fs_tbl_cfg {
  *	- dpni_set_rx_tc_dist()
  *		- dpni_set_qos_table()
  */
-int dpni_prepare_key_cfg(struct dpkg_profile_cfg	*cfg,
+int dpni_prepare_key_cfg(const struct dpkg_profile_cfg	*cfg,
 			 uint8_t			*key_cfg_buf);
 
 /**
  * struct dpni_rx_tc_dist_cfg - Rx traffic class distribution configuration
- * @dist_size: Set the distribution size; Non-power-of-2 values are rounded
- *	up to the next power-of-2 value as HW demands it
+ * @dist_size: Set the distribution size;
+ *	supported values: 1,2,3,4,6,7,8,12,14,16,24,28,32,48,56,64,96,
+ *	112,128,192,224,256,384,448,512,768,896,1024
  * @dist_mode: Distribution mode
  * @key_cfg_iova: I/O virtual address of 256 bytes DMA-able memory filled with
  *		the extractions to be used for the distribution key by calling
@@ -1399,7 +1492,7 @@ int dpni_prepare_key_cfg(struct dpkg_profile_cfg	*cfg,
  *		'dist_mode = DPNI_DIST_MODE_FS'
  */
 struct dpni_rx_tc_dist_cfg {
-	uint8_t		dist_size;
+	uint16_t		dist_size;
 	enum dpni_dist_mode	dist_mode;
 	uint64_t		key_cfg_iova;
 	struct dpni_fs_tbl_cfg	fs_cfg;
@@ -1424,17 +1517,21 @@ int dpni_set_rx_tc_dist(struct fsl_mc_io			*mc_io,
 			uint8_t					tc_id,
 			const struct dpni_rx_tc_dist_cfg	*cfg);
 
-/* Set to select color aware mode (otherwise - color blind) */
+/**
+ * Set to select color aware mode (otherwise - color blind)
+ */
 #define DPNI_POLICER_OPT_COLOR_AWARE	0x00000001
-/* Set to discard frame with RED color */
+/**
+ * Set to discard frame with RED color
+ */
 #define DPNI_POLICER_OPT_DISCARD_RED	0x00000002
 
 /**
- *  enum dpni_policer_mode - selecting the policer mode
- *  @DPNI_POLICER_MODE_NONE: Policer is disabled
- *  @DPNI_POLICER_MODE_PASS_THROUGH: Policer pass through
- *  @DPNI_POLICER_MODE_RFC_2698: Policer algorithm RFC 2698
- *  @DPNI_POLICER_MODE_RFC_4115: Policer algorithm RFC 4115
+ * enum dpni_policer_mode - selecting the policer mode
+ * @DPNI_POLICER_MODE_NONE: Policer is disabled
+ * @DPNI_POLICER_MODE_PASS_THROUGH: Policer pass through
+ * @DPNI_POLICER_MODE_RFC_2698: Policer algorithm RFC 2698
+ * @DPNI_POLICER_MODE_RFC_4115: Policer algorithm RFC 4115
  */
 enum dpni_policer_mode {
 	DPNI_POLICER_MODE_NONE = 0,
@@ -1444,20 +1541,20 @@ enum dpni_policer_mode {
 };
 
 /**
- *  enum dpni_policer_unit - DPNI policer units
- *  @DPNI_POLICER_UNIT_BYTES: bytes units
- *  @DPNI_POLICER_UNIT_PACKETS: packets units
+ * enum dpni_policer_unit - DPNI policer units
+ * @DPNI_POLICER_UNIT_BYTES: bytes units
+ * @DPNI_POLICER_UNIT_FRAMES: frames units
  */
 enum dpni_policer_unit {
 	DPNI_POLICER_UNIT_BYTES = 0,
-	DPNI_POLICER_UNIT_PACKETS
+	DPNI_POLICER_UNIT_FRAMES
 };
 
 /**
- *  enum dpni_policer_color - selecting the policer color
- *  @DPNI_POLICER_COLOR_GREEN: Green color
- *  @DPNI_POLICER_COLOR_YELLOW: Yellow color
- *  @DPNI_POLICER_COLOR_RED: Red color
+ * enum dpni_policer_color - selecting the policer color
+ * @DPNI_POLICER_COLOR_GREEN: Green color
+ * @DPNI_POLICER_COLOR_YELLOW: Yellow color
+ * @DPNI_POLICER_COLOR_RED: Red color
  */
 enum dpni_policer_color {
 	DPNI_POLICER_COLOR_GREEN = 0,
@@ -1508,6 +1605,32 @@ int dpni_set_rx_tc_policing(struct fsl_mc_io			*mc_io,
 			    const struct dpni_rx_tc_policing_cfg *cfg);
 
 /**
+ * dpni_get_rx_tc_policing() - Get Rx traffic class policing configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @tc_id:	Traffic class selection (0-7)
+ * @cfg:	Traffic class policing configuration
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_get_rx_tc_policing(struct fsl_mc_io			*mc_io,
+			    uint32_t				cmd_flags,
+			    uint16_t				token,
+			    uint8_t				tc_id,
+			    struct dpni_rx_tc_policing_cfg	*cfg);
+
+/**
+ * enum dpni_congestion_unit - DPNI congestion units
+ * @DPNI_CONGESTION_UNIT_BYTES: bytes units
+ * @DPNI_CONGESTION_UNIT_FRAMES: frames units
+ */
+enum dpni_congestion_unit {
+	DPNI_CONGESTION_UNIT_BYTES = 0,
+	DPNI_CONGESTION_UNIT_FRAMES
+};
+
+/**
  * enum dpni_early_drop_mode - DPNI early drop mode
  * @DPNI_EARLY_DROP_MODE_NONE: early drop is disabled
  * @DPNI_EARLY_DROP_MODE_TAIL: early drop in taildrop mode
@@ -1520,16 +1643,6 @@ enum dpni_early_drop_mode {
 };
 
 /**
- * enum dpni_early_drop_unit - DPNI early drop units
- * @DPNI_EARLY_DROP_UNIT_BYTES: bytes units
- * @DPNI_EARLY_DROP_UNIT_FRAMES: frames units
- */
-enum dpni_early_drop_unit {
-	DPNI_EARLY_DROP_UNIT_BYTES = 0,
-	DPNI_EARLY_DROP_UNIT_FRAMES
-};
-
-/**
  * struct dpni_wred_cfg - WRED configuration
  * @max_threshold: maximum threshold that packets may be discarded. Above this
  *	  threshold all packets are discarded; must be less than 2^39;
@@ -1546,17 +1659,17 @@ struct dpni_wred_cfg {
 };
 
 /**
- * struct dpni_rx_tc_early_drop_cfg - early-drop configuration
+ * struct dpni_early_drop_cfg - early-drop configuration
  * @mode: drop mode
- * @units: untis type
+ * @units: units type
  * @green: WRED - 'green' configuration
  * @yellow: WRED - 'yellow' configuration
  * @red: WRED - 'red' configuration
  * @tail_drop_threshold: tail drop threshold
  */
-struct dpni_rx_tc_early_drop_cfg {
+struct dpni_early_drop_cfg {
 	enum dpni_early_drop_mode	mode;
-	enum dpni_early_drop_unit	units;
+	enum dpni_congestion_unit	units;
 
 	struct dpni_wred_cfg		green;
 	struct dpni_wred_cfg		yellow;
@@ -1566,15 +1679,28 @@ struct dpni_rx_tc_early_drop_cfg {
 };
 
 /**
- * dpni_prepare_rx_tc_early_drop() - prepare an early drop.
+ * dpni_prepare_early_drop() - prepare an early drop.
+ * @cfg: Early-drop configuration
+ * @early_drop_buf: Zeroed 256 bytes of memory before mapping it to DMA
+ *
+ * This function has to be called before dpni_set_rx_tc_early_drop or
+ * dpni_set_tx_tc_early_drop
+ *
+ */
+void dpni_prepare_early_drop(const struct dpni_early_drop_cfg *cfg,
+			     uint8_t	*early_drop_buf);
+
+/**
+ * dpni_extract_early_drop() - extract the early drop configuration.
  * @cfg: Early-drop configuration
  * @early_drop_buf: Zeroed 256 bytes of memory before mapping it to DMA
  *
- * This function has to be called before dpni_set_rx_tc_early_drop
+ * This function has to be called after dpni_get_rx_tc_early_drop or
+ * dpni_get_tx_tc_early_drop
  *
  */
-void dpni_prepare_rx_tc_early_drop(const struct dpni_rx_tc_early_drop_cfg *cfg,
-				   uint8_t		*early_drop_buf);
+void dpni_extract_early_drop(struct dpni_early_drop_cfg *cfg,
+			     const uint8_t *early_drop_buf);
 
 /**
  * dpni_set_rx_tc_early_drop() - Set Rx traffic class early-drop configuration
@@ -1582,10 +1708,10 @@ void dpni_prepare_rx_tc_early_drop(const struct dpni_rx_tc_early_drop_cfg *cfg,
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @tc_id:	Traffic class selection (0-7)
- * @early_drop_iova:  I/O virtual address of 64 bytes;
- * Must be cacheline-aligned and DMA-able memory
+ * @early_drop_iova:  I/O virtual address of 256 bytes DMA-able memory filled
+ *	with the early-drop configuration by calling dpni_prepare_early_drop()
  *
- * warning: Before calling this function, call dpni_prepare_rx_early_drop() to
+ * warning: Before calling this function, call dpni_prepare_early_drop() to
  *			prepare the early_drop_iova parameter
  *
  * Return:	'0' on Success; error code otherwise.
@@ -1597,6 +1723,64 @@ int dpni_set_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
 			      uint64_t		early_drop_iova);
 
 /**
+ * dpni_get_rx_tc_early_drop() - Get Rx traffic class early-drop configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @tc_id:	Traffic class selection (0-7)
+ * @early_drop_iova:  I/O virtual address of 256 bytes DMA-able memory
+ *
+ * warning: After calling this function, call dpni_extract_early_drop() to
+ *	get the early drop configuration
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_get_rx_tc_early_drop(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
+			      uint16_t		token,
+			      uint8_t		tc_id,
+			      uint64_t		early_drop_iova);
+
+/**
+ * dpni_set_tx_tc_early_drop() - Set Tx traffic class early-drop configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @tc_id:	Traffic class selection (0-7)
+ * @early_drop_iova:  I/O virtual address of 256 bytes DMA-able memory filled
+ *	with the early-drop configuration by calling dpni_prepare_early_drop()
+ *
+ * warning: Before calling this function, call dpni_prepare_early_drop() to
+ *			prepare the early_drop_iova parameter
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_set_tx_tc_early_drop(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
+			      uint16_t		token,
+			      uint8_t		tc_id,
+			      uint64_t		early_drop_iova);
+
+/**
+ * dpni_get_tx_tc_early_drop() - Get Tx traffic class early-drop configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @tc_id:	Traffic class selection (0-7)
+ * @early_drop_iova:  I/O virtual address of 256 bytes DMA-able memory
+ *
+ * warning: After calling this function, call dpni_extract_early_drop() to
+ *	get the early drop configuration
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_get_tx_tc_early_drop(struct fsl_mc_io	*mc_io,
+			      uint32_t		cmd_flags,
+			      uint16_t		token,
+			      uint8_t		tc_id,
+			      uint64_t		early_drop_iova);
+
+/**
  * enum dpni_dest - DPNI destination types
  * @DPNI_DEST_NONE: Unassigned destination; The queue is set in parked mode and
  *		does not generate FQDAN notifications; user is expected to
@@ -1629,6 +1813,134 @@ struct dpni_dest_cfg {
 	uint8_t	priority;
 };
 
+/* DPNI congestion options */
+
+/**
+ * CSCN message is written to message_iova once entering a
+ * congestion state (see 'threshold_entry')
+ */
+#define DPNI_CONG_OPT_WRITE_MEM_ON_ENTER	0x00000001
+/**
+ * CSCN message is written to message_iova once exiting a
+ * congestion state (see 'threshold_exit')
+ */
+#define DPNI_CONG_OPT_WRITE_MEM_ON_EXIT		0x00000002
+/**
+ * CSCN write will attempt to allocate into a cache (coherent write);
+ * valid only if 'DPNI_CONG_OPT_WRITE_MEM_<X>' is selected
+ */
+#define DPNI_CONG_OPT_COHERENT_WRITE		0x00000004
+/**
+ * if 'dest_cfg.dest_type != DPNI_DEST_NONE' CSCN message is sent to
+ * DPIO/DPCON's WQ channel once entering a congestion state
+ * (see 'threshold_entry')
+ */
+#define DPNI_CONG_OPT_NOTIFY_DEST_ON_ENTER	0x00000008
+/**
+ * if 'dest_cfg.dest_type != DPNI_DEST_NONE' CSCN message is sent to
+ * DPIO/DPCON's WQ channel once exiting a congestion state
+ * (see 'threshold_exit')
+ */
+#define DPNI_CONG_OPT_NOTIFY_DEST_ON_EXIT	0x00000010
+/**
+ * if 'dest_cfg.dest_type != DPNI_DEST_NONE' when the CSCN is written to the
+ * sw-portal's DQRR, the DQRI interrupt is asserted immediately (if enabled)
+ */
+#define DPNI_CONG_OPT_INTR_COALESCING_DISABLED	0x00000020
+
+/**
+ * struct dpni_congestion_notification_cfg - congestion notification
+ *		configuration
+ * @units: units type
+ * @threshold_entry: above this threshold we enter a congestion state.
+ *	set it to '0' to disable it
+ * @threshold_exit: below this threshold we exit the congestion state.
+ * @message_ctx: The context that will be part of the CSCN message
+ * @message_iova: I/O virtual address (must be in DMA-able memory),
+ *	must be 16B aligned; valid only if 'DPNI_CONG_OPT_WRITE_MEM_<X>' is
+ *	contained in 'options'
+ * @dest_cfg: CSCN can be send to either DPIO or DPCON WQ channel
+ * @options: Mask of available options; use 'DPNI_CONG_OPT_<X>' values
+ */
+
+struct dpni_congestion_notification_cfg {
+	enum dpni_congestion_unit	units;
+	uint32_t	threshold_entry;
+	uint32_t	threshold_exit;
+	uint64_t	message_ctx;
+	uint64_t	message_iova;
+	struct dpni_dest_cfg dest_cfg;
+	uint16_t	options;
+};
+
+/**
+ * dpni_set_rx_tc_congestion_notification() - Set Rx traffic class congestion
+ *	notification configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @tc_id:	Traffic class selection (0-7)
+ * @cfg:	congestion notification configuration
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_set_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+					   uint32_t		cmd_flags,
+					   uint16_t		token,
+					   uint8_t		tc_id,
+			const struct dpni_congestion_notification_cfg *cfg);
+
+/**
+ * dpni_get_rx_tc_congestion_notification() - Get Rx traffic class congestion
+ *	notification configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @tc_id:	Traffic class selection (0-7)
+ * @cfg:	congestion notification configuration
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_get_rx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+					   uint32_t		cmd_flags,
+					   uint16_t		token,
+					   uint8_t		tc_id,
+				struct dpni_congestion_notification_cfg *cfg);
+
+/**
+ * dpni_set_tx_tc_congestion_notification() - Set Tx traffic class congestion
+ *	notification configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @tc_id:	Traffic class selection (0-7)
+ * @cfg:	congestion notification configuration
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_set_tx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+					   uint32_t		cmd_flags,
+					   uint16_t		token,
+					   uint8_t		tc_id,
+			const struct dpni_congestion_notification_cfg *cfg);
+
+/**
+ * dpni_get_tx_tc_congestion_notification() - Get Tx traffic class congestion
+ *	notification configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @tc_id:	Traffic class selection (0-7)
+ * @cfg:	congestion notification configuration
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_get_tx_tc_congestion_notification(struct fsl_mc_io	*mc_io,
+					   uint32_t		cmd_flags,
+					   uint16_t		token,
+					   uint8_t		tc_id,
+				struct dpni_congestion_notification_cfg *cfg);
+
 /**
  * enum dpni_flc_type - DPNI FLC types
  * @DPNI_FLC_USER_DEFINED: select the FLC to be used for user defined value
@@ -1655,7 +1967,9 @@ enum dpni_stash_size {
 
 /* DPNI FLC stash options */
 
-/* stashes the whole annotation area (up to 192 bytes) */
+/**
+ * stashes the whole annotation area (up to 192 bytes)
+ */
 #define DPNI_FLC_STASH_FRAME_ANNOTATION	0x00000001
 
 /**
@@ -1681,18 +1995,28 @@ struct dpni_flc_cfg {
 	uint64_t		flow_context;
 };
 
-/* DPNI queue modification options */
+/**
+ * DPNI queue modification options
+ */
 
-/* Select to modify the user's context associated with the queue */
+/**
+ * Select to modify the user's context associated with the queue
+ */
 #define DPNI_QUEUE_OPT_USER_CTX		0x00000001
-/* Select to modify the queue's destination */
+/**
+ * Select to modify the queue's destination
+ */
 #define DPNI_QUEUE_OPT_DEST		0x00000002
 /** Select to modify the flow-context parameters;
  * not applicable for Tx-conf/Err queues as the FD comes from the user
  */
 #define DPNI_QUEUE_OPT_FLC		0x00000004
-/* Select to modify the queue's order preservation */
+/**
+ * Select to modify the queue's order preservation
+ */
 #define DPNI_QUEUE_OPT_ORDER_PRESERVATION 0x00000008
+/* Select to modify the queue's tail-drop threshold */
+#define DPNI_QUEUE_OPT_TAILDROP_THRESHOLD 0x00000010
 
 /**
  * struct dpni_queue_cfg - Structure representing queue configuration
@@ -1711,6 +2035,10 @@ struct dpni_flc_cfg {
  * @order_preservation_en: enable/disable order preservation;
  *		valid only if 'DPNI_QUEUE_OPT_ORDER_PRESERVATION' is contained
  *		in 'options'
+ * @tail_drop_threshold: set the queue's tail drop threshold in bytes;
+ *		'0' value disable the threshold; maximum value is 0xE000000;
+ *		valid only if 'DPNI_QUEUE_OPT_TAILDROP_THRESHOLD' is contained
+ *		in 'options'
  */
 struct dpni_queue_cfg {
 	uint32_t		options;
@@ -1718,6 +2046,7 @@ struct dpni_queue_cfg {
 	struct dpni_dest_cfg	dest_cfg;
 	struct dpni_flc_cfg	flc_cfg;
 	int			order_preservation_en;
+	uint32_t		tail_drop_threshold;
 };
 
 /**
@@ -1727,6 +2056,7 @@ struct dpni_queue_cfg {
  * @dest_cfg: Queue destination configuration
  * @flc_cfg: Flow context configuration
  * @order_preservation_en: enable/disable order preservation
+ * @tail_drop_threshold: queue's tail drop threshold in bytes;
  * @fqid: Virtual fqid value to be used for dequeue operations
  */
 struct dpni_queue_attr {
@@ -1734,61 +2064,47 @@ struct dpni_queue_attr {
 	struct dpni_dest_cfg	dest_cfg;
 	struct dpni_flc_cfg	flc_cfg;
 	int			order_preservation_en;
+	uint32_t		tail_drop_threshold;
 
 	uint32_t		fqid;
 };
 
-/* DPNI Tx flow modification options */
+/**
+ * DPNI Tx flow modification options
+ */
 
-/* Select to modify the settings for dedicate Tx confirmation/error */
+/**
+ * Select to modify the settings for dedicate Tx confirmation/error
+ */
 #define DPNI_TX_FLOW_OPT_TX_CONF_ERROR	0x00000001
-/*!< Select to modify the Tx confirmation and/or error setting */
-#define DPNI_TX_FLOW_OPT_ONLY_TX_ERROR	0x00000002
-/*!< Select to modify the queue configuration */
-#define DPNI_TX_FLOW_OPT_QUEUE		0x00000004
-/*!< Select to modify the L3 checksum generation setting */
+/**
+ * Select to modify the L3 checksum generation setting
+ */
 #define DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN	0x00000010
-/*!< Select to modify the L4 checksum generation setting */
+/**
+ * Select to modify the L4 checksum generation setting
+ */
 #define DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN	0x00000020
 
 /**
  * struct dpni_tx_flow_cfg - Structure representing Tx flow configuration
  * @options: Flags representing the suggested modifications to the Tx flow;
- *		Use any combination 'DPNI_TX_FLOW_OPT_<X>' flags
- * @conf_err_cfg: Tx confirmation and error configuration; these settings are
- *		ignored if 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' was set at
- *		DPNI creation
+ *	Use any combination 'DPNI_TX_FLOW_OPT_<X>' flags
+ * @use_common_tx_conf_queue: Set to '1' to use the common (default) Tx
+ *	confirmation and error queue; Set to '0' to use the private
+ *	Tx confirmation and error queue; valid only if
+ *	'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' wasn't set at DPNI creation
+ *	and 'DPNI_TX_FLOW_OPT_TX_CONF_ERROR' is contained in 'options'
  * @l3_chksum_gen: Set to '1' to enable L3 checksum generation; '0' to disable;
- *		valid only if 'DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN' is contained in
- *		'options'
+ *	valid only if 'DPNI_TX_FLOW_OPT_L3_CHKSUM_GEN' is contained in 'options'
  * @l4_chksum_gen: Set to '1' to enable L4 checksum generation; '0' to disable;
- *		valid only if 'DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN' is contained in
- *		'options'
+ *	valid only if 'DPNI_TX_FLOW_OPT_L4_CHKSUM_GEN' is contained in 'options'
  */
 struct dpni_tx_flow_cfg {
-	uint32_t			options;
-	/**
-	 * struct cnf_err_cfg - Tx confirmation and error configuration
-	 * @use_default_queue: Set to '1' to use the common (default) Tx
-	 *		confirmation and error queue; Set to '0' to use the
-	 *		private Tx confirmation and error queue; valid only if
-	 *		'DPNI_TX_FLOW_OPT_TX_CONF_ERROR' is contained in
-	 *		'options'
-	 * @errors_only: Set to '1' to report back only error frames;
-	 *		Set to '0' to confirm transmission/error for all
-	 *		transmitted frames;
-	 *		valid only if 'DPNI_TX_FLOW_OPT_ONLY_TX_ERROR' is
-	 *		contained in 'options' and 'use_default_queue = 0';
-	 * @queue_cfg: Queue configuration; valid only if
-	 *		'DPNI_TX_FLOW_OPT_QUEUE' is contained in 'options'
-	 */
-	struct {
-		int			use_default_queue;
-		int			errors_only;
-		struct dpni_queue_cfg	queue_cfg;
-	} conf_err_cfg;
-	int				l3_chksum_gen;
-	int				l4_chksum_gen;
+	uint32_t	options;
+	int		use_common_tx_conf_queue;
+	int		l3_chksum_gen;
+	int		l4_chksum_gen;
 };
 
 /**
@@ -1797,10 +2113,9 @@ struct dpni_tx_flow_cfg {
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @flow_id:	Provides (or returns) the sender's flow ID;
- *				for each new sender set (*flow_id) to
- *				'DPNI_NEW_FLOW_ID' to generate a new flow_id;
- *				this ID should be used as the QDBIN argument
- *				in enqueue operations
+ *	for each new sender set (*flow_id) to 'DPNI_NEW_FLOW_ID' to generate
+ *	a new flow_id;	this ID should be used as the QDBIN argument
+ *	in enqueue operations
  * @cfg:	Tx flow configuration
  *
  * Return:	'0' on Success; Error code otherwise.
@@ -1813,28 +2128,15 @@ int dpni_set_tx_flow(struct fsl_mc_io			*mc_io,
 
 /**
  * struct dpni_tx_flow_attr - Structure representing Tx flow attributes
- * @conf_err_attr: Tx confirmation and error attributes
+ * @use_common_tx_conf_queue: '1' if using common (default) Tx confirmation and
+ *	error queue; '0' if using private Tx confirmation and error queue
  * @l3_chksum_gen: '1' if L3 checksum generation is enabled; '0' if disabled
  * @l4_chksum_gen: '1' if L4 checksum generation is enabled; '0' if disabled
  */
 struct dpni_tx_flow_attr {
-	/**
-	 * struct conf_err_attr - Tx confirmation and error attributes
-	 * @use_default_queue: '1' if using common (default) Tx confirmation and
-	 *			error queue;
-	 *			'0' if using private Tx confirmation and error
-	 *			queue
-	 * @errors_only: '1' if only error frames are reported back; '0' if all
-	 *		transmitted frames are confirmed
-	 * @queue_attr: Queue attributes
-	 */
-	struct {
-		int			use_default_queue;
-		int			errors_only;
-		struct dpni_queue_attr	queue_attr;
-	} conf_err_attr;
-	int				l3_chksum_gen;
-	int				l4_chksum_gen;
+	int	use_common_tx_conf_queue;
+	int	l3_chksum_gen;
+	int	l4_chksum_gen;
 };
 
 /**
@@ -1843,7 +2145,7 @@ struct dpni_tx_flow_attr {
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
  * @token:	Token of DPNI object
  * @flow_id:	The sender's flow ID, as returned by the
- *			dpni_set_tx_flow() function
+ *	dpni_set_tx_flow() function
  * @attr:	Returned Tx flow attributes
  *
  * Return:	'0' on Success; Error code otherwise.
@@ -1855,6 +2157,148 @@ int dpni_get_tx_flow(struct fsl_mc_io		*mc_io,
 		     struct dpni_tx_flow_attr	*attr);
 
 /**
+ * struct dpni_tx_conf_cfg - Structure representing Tx conf configuration
+ * @errors_only: Set to '1' to report back only error frames;
+ *	Set to '0' to confirm transmission/error for all transmitted frames;
+ * @queue_cfg: Queue configuration
+ */
+struct dpni_tx_conf_cfg {
+	int			errors_only;
+	struct dpni_queue_cfg	queue_cfg;
+};
+
+/**
+ * dpni_set_tx_conf() - Set Tx confirmation and error queue configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @flow_id:	The sender's flow ID, as returned by the
+ *	dpni_set_tx_flow() function;
+ *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
+ * @cfg:	Queue configuration
+ *
+ * If either 'DPNI_OPT_TX_CONF_DISABLED' or
+ * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
+ * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
+ * i.e. only serve the common tx-conf-err queue;
+ * if 'DPNI_OPT_TX_CONF_DISABLED' was selected, only error frames are reported
+ * back - successfully transmitted frames are not confirmed. Otherwise, all
+ * transmitted frames are sent for confirmation.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpni_set_tx_conf(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
+		     uint16_t		token,
+		     uint16_t		flow_id,
+		     const struct dpni_tx_conf_cfg	*cfg);
+
+/**
+ * struct dpni_tx_conf_attr - Structure representing Tx conf attributes
+ * @errors_only: '1' if only error frames are reported back; '0' if all
+ *		transmitted frames are confirmed
+ * @queue_attr: Queue attributes
+ */
+struct dpni_tx_conf_attr {
+	int			errors_only;
+	struct dpni_queue_attr	queue_attr;
+};
+
+/**
+ * dpni_get_tx_conf() - Get Tx confirmation and error queue attributes
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @flow_id:	The sender's flow ID, as returned by the
+ *	dpni_set_tx_flow() function;
+ *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
+ * @attr:	Returned tx-conf attributes
+ *
+ * If either 'DPNI_OPT_TX_CONF_DISABLED' or
+ * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
+ * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
+ * i.e. only serve the common tx-conf-err queue;
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpni_get_tx_conf(struct fsl_mc_io	*mc_io,
+		     uint32_t		cmd_flags,
+		     uint16_t		token,
+		     uint16_t		flow_id,
+		     struct dpni_tx_conf_attr	*attr);
+
+/**
+ * dpni_set_tx_conf_congestion_notification() - Set Tx conf congestion
+ *	notification configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @flow_id:	The sender's flow ID, as returned by the
+ *	dpni_set_tx_flow() function;
+ *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
+ * @cfg:	congestion notification configuration
+ *
+ * If either 'DPNI_OPT_TX_CONF_DISABLED' or
+ * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
+ * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
+ * i.e. only serve the common tx-conf-err queue;
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_set_tx_conf_congestion_notification(struct fsl_mc_io	*mc_io,
+					     uint32_t		cmd_flags,
+					     uint16_t		token,
+					     uint16_t		flow_id,
+			const struct dpni_congestion_notification_cfg *cfg);
+
+/**
+ * dpni_get_tx_conf_congestion_notification() - Get Tx conf congestion
+ *	notification configuration
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @flow_id:	The sender's flow ID, as returned by the
+ *	dpni_set_tx_flow() function;
+ *	use 'DPNI_COMMON_TX_CONF' for common tx-conf
+ * @cfg:	congestion notification
+ *
+ * If either 'DPNI_OPT_TX_CONF_DISABLED' or
+ * 'DPNI_OPT_PRIVATE_TX_CONF_ERROR_DISABLED' were selected at DPNI creation,
+ * this function can ONLY be used with 'flow_id == DPNI_COMMON_TX_CONF';
+ * i.e. only serve the common tx-conf-err queue;
+ *
+ * Return:	'0' on Success; error code otherwise.
+ */
+int dpni_get_tx_conf_congestion_notification(struct fsl_mc_io	*mc_io,
+					     uint32_t		cmd_flags,
+					     uint16_t		token,
+					     uint16_t		flow_id,
+				struct dpni_congestion_notification_cfg *cfg);
+
+/**
+ * dpni_set_tx_conf_revoke() - Tx confirmation revocation
+ * @mc_io:	Pointer to MC portal's I/O object
+ * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
+ * @token:	Token of DPNI object
+ * @revoke:	revoke or not
+ *
+ * This function is useful only when 'DPNI_OPT_TX_CONF_DISABLED' is not
+ * selected at DPNI creation.
+ * Calling this function with 'revoke' set to '1' disables all transmit
+ * confirmation (including the private confirmation queues), regardless of
+ * previous settings; Note that in this case, Tx error frames are still
+ * enqueued to the general transmit errors queue.
+ * Calling this function with 'revoke' set to '0' restores the previous
+ * settings for both general and private transmit confirmation.
+ *
+ * Return:	'0' on Success; Error code otherwise.
+ */
+int dpni_set_tx_conf_revoke(struct fsl_mc_io		*mc_io,
+			    uint32_t			cmd_flags,
+			    uint16_t			token,
+			    int			revoke);
+
+/**
  * dpni_set_rx_flow() - Set Rx flow configuration
  * @mc_io:	Pointer to MC portal's I/O object
  * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
@@ -1923,76 +2367,6 @@ int dpni_get_rx_err_queue(struct fsl_mc_io		*mc_io,
 			  struct dpni_queue_attr	*attr);
 
 /**
- * dpni_set_tx_conf_err_queue() - Set Tx confirmation and error queue
- *			configuration
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @cfg:	Queue configuration
- *
- * If 'DPNI_OPT_TX_CONF_DISABLED' was selected at DPNI creation,
- * only error frames are reported back - successfully transmitted
- * frames are not confirmed. Otherwise, all transmitted frames
- * are sent for confirmation.
- *
- * If private Tx confirmation and error queues are used with this
- * DPNI, then this queue serves all Tx flows that are configured
- * with 'use_default_queue' option (see dpni_tx_flow_cfg).
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_tx_conf_err_queue(struct fsl_mc_io		*mc_io,
-			       uint32_t			cmd_flags,
-			       uint16_t				token,
-			       const struct dpni_queue_cfg	*cfg);
-
-/**
- * dpni_get_tx_conf_err_queue() - Get Tx confirmation and error queue attributes
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @attr:	Returned queue attributes
- *
- * If 'DPNI_OPT_TX_CONF_DISABLED' was selected at DPNI creation,
- * only error frames are reported back - successfully transmitted
- * frames are not confirmed. Otherwise, all transmitted frames
- * are sent for confirmation.
- *
- * If private Tx confirmation and error queues are used with this
- * DPNI, then this queue serves all Tx flows that are configured
- * with 'use_default_queue' option (see dpni_tx_flow_cfg).
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_get_tx_conf_err_queue(struct fsl_mc_io	*mc_io,
-			       uint32_t		cmd_flags,
-			       uint16_t			token,
-			       struct dpni_queue_attr	*attr);
-
-/**
- * dpni_set_tx_conf_revoke() - Tx confirmation revocation
- * @mc_io:	Pointer to MC portal's I/O object
- * @cmd_flags:	Command flags; one or more of 'MC_CMD_FLAG_'
- * @token:	Token of DPNI object
- * @revoke:	revoke or not
- *
- * This function is useful only when 'DPNI_OPT_TX_CONF_DISABLED' is not
- * selected at DPNI creation.
- * Calling this function with 'revoke' set to '1' disables all transmit
- * confirmation (including the private confirmation queues), regardless of
- * previous settings; Note that in this case, Tx error frames are still
- * enqueued to the general transmit errors queue.
- * Calling this function with 'revoke' set to '0' restores the previous
- * settings for both general and private transmit confirmation.
- *
- * Return:	'0' on Success; Error code otherwise.
- */
-int dpni_set_tx_conf_revoke(struct fsl_mc_io		*mc_io,
-			    uint32_t			cmd_flags,
-			    uint16_t			token,
-			    int			revoke);
-
-/**
  * struct dpni_qos_tbl_cfg - Structure representing QOS table configuration
  * @key_cfg_iova: I/O virtual address of 256 bytes DMA-able memory filled with
  *		key extractions to be used as the QoS criteria by calling
diff --git a/drivers/staging/fsl-mc/include/mc-cmd.h b/drivers/staging/fsl-mc/include/mc-cmd.h
index 57fefd2..f15fbca 100644
--- a/drivers/staging/fsl-mc/include/mc-cmd.h
+++ b/drivers/staging/fsl-mc/include/mc-cmd.h
@@ -101,8 +101,11 @@ integration */
 #define MC_CMD_HDR_READ_FLAGS(_hdr) \
 	((uint32_t)mc_dec((_hdr), MC_CMD_HDR_FLAGS_O, MC_CMD_HDR_FLAGS_S))
 
+#define MC_PREP_OP(_ext, _param, _offset, _width, _type, _arg) \
+	((_ext)[_param] |= cpu_to_le64(mc_enc((_offset), (_width), _arg)))
+
 #define MC_EXT_OP(_ext, _param, _offset, _width, _type, _arg) \
-	((_ext)[_param] |= mc_enc((_offset), (_width), _arg))
+	(_arg = (_type)mc_dec(cpu_to_le64(_ext[_param]), (_offset), (_width)))
 
 #define MC_CMD_OP(_cmd, _param, _offset, _width, _type, _arg) \
 	((_cmd).params[_param] |= mc_enc((_offset), (_width), _arg))
-- 
2.8.1

