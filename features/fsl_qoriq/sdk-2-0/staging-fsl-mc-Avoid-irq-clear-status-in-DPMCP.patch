From 5b8e80b4e25c7f798a5ad6e4c6cf296afc037757 Mon Sep 17 00:00:00 2001
From: Itai Katz <itai.katz@freescale.com>
Date: Wed, 2 Dec 2015 09:41:35 +0200
Subject: [PATCH 0519/1429] staging: fsl-mc: Avoid irq clear status in DPMCP

MC firmware version 9.0.0 introduced automatic clearing of irq
status for DPMCP. Thus MC bus driver should not send a command
to clear the command completion irq status. This patch removes
the code that was used to clear the DPMCP irq status.

Signed-off-by: Itai Katz <itai.katz@freescale.com>
[Original patch taken from QorIQ-SDK-V2.0-20160527-yocto]
Signed-off-by: Yanjiang Jin <yanjiang.jin@windriver.com>
---
 drivers/staging/fsl-mc/bus/dprc-driver.c |    4 +-
 drivers/staging/fsl-mc/bus/mc-sys.c      |  121 +-----------------------------
 drivers/staging/fsl-mc/include/mc-sys.h  |    5 -
 3 files changed, 3 insertions(+), 127 deletions(-)

diff --git a/drivers/staging/fsl-mc/bus/dprc-driver.c b/drivers/staging/fsl-mc/bus/dprc-driver.c
index e26c176..42df47a 100644
--- a/drivers/staging/fsl-mc/bus/dprc-driver.c
+++ b/drivers/staging/fsl-mc/bus/dprc-driver.c
@@ -860,9 +860,7 @@ static int dprc_probe(struct fsl_mc_device *mc_dev)
 
 	if (fsl_mc_interrupts_supported()) {
 		/*
-		 * Create DPMCP for the DPRC's built-in portal, to have
-		 * DPMCP completion interrupts for MC commands sent on
-		 * the DPRC's built-in portal:
+		 * Create DPMCP for the DPRC's built-in portal:
 		 */
 		error = dprc_create_dpmcp(mc_dev);
 		if (error < 0)
diff --git a/drivers/staging/fsl-mc/bus/mc-sys.c b/drivers/staging/fsl-mc/bus/mc-sys.c
index cb57a16..d3b6940 100644
--- a/drivers/staging/fsl-mc/bus/mc-sys.c
+++ b/drivers/staging/fsl-mc/bus/mc-sys.c
@@ -60,32 +60,6 @@
 	((uint16_t)mc_dec((_hdr), MC_CMD_HDR_CMDID_O, MC_CMD_HDR_CMDID_S))
 
 /**
- * Global state variables for the DPMCP Command completion ISR
- *
- * @mc_io: Pointer to MC IO object to be used to send MC commands
- * from the DPMCP completion interrupt handler.
- * @dpmcp_count: Coun of of DPMCP objects for which fsl_mc_io_setup_dpmcp_irq()
- * has been called.
- *
- * NOTE: We use a common atomic MC portal for handling DPMCP completion
- * interrupts for all DPMCPs, for scalability. Otherwise, we would need
- * to have an additional MC portal per DPMCP.
- *
- * TODO: If needed, to avoid contention between DPMCP completion interrupts
- * that fired on different CPUs (for different DPMCPs), we should have
- * one dedicated MC portal per CPU, to be used for sending MC commands from
- * the DPMCP completion ISR.
- */
-struct fsl_mc_dpmcp_isr {
-	struct fsl_mc_io *mc_io;
-	atomic_t dpmcp_count;
-};
-
-static struct fsl_mc_dpmcp_isr fsl_mc_dpmcp_isr = {
-	.dpmcp_count = ATOMIC_INIT(0),
-};
-
-/**
  * dpmcp_irq0_handler - Regular ISR for DPMCP interrupt 0
  *
  * @irq: IRQ number of the interrupt being handled
@@ -93,7 +67,6 @@ static struct fsl_mc_dpmcp_isr fsl_mc_dpmcp_isr = {
  */
 static irqreturn_t dpmcp_irq0_handler(int irq_num, void *arg)
 {
-	int error;
 	struct device *dev = (struct device *)arg;
 	struct fsl_mc_device *dpmcp_dev = to_fsl_mc_device(dev);
 	struct fsl_mc_io *mc_io = dpmcp_dev->mc_io;
@@ -107,26 +80,6 @@ static irqreturn_t dpmcp_irq0_handler(int irq_num, void *arg)
 	if (WARN_ON(!mc_io))
 		goto out;
 
-	if (WARN_ON(!fsl_mc_dpmcp_isr.mc_io))
-		goto out;
-
-	/*
-	 * Clear interrupt source at the MC:
-	 *
-	 * NOTE: We clear all DPMCP IRQ events, rather than calling
-	 * dpmcp_get_irq_status() here to save one trip to the MC
-	 */
-	error = dpmcp_clear_irq_status(fsl_mc_dpmcp_isr.mc_io,
-				       MC_CMD_FLAG_INTR_DIS | MC_CMD_FLAG_PRI,
-				       mc_io->dpmcp_isr_mc_handle,
-				       DPMCP_IRQ_INDEX, ~0x0U);
-	if (error < 0) {
-		dev_err(&dpmcp_dev->dev,
-			"dpmcp_clear_irq_status() failed: %d\n",
-			error);
-		goto out;
-	}
-
 	complete(&mc_io->mc_command_done_completion);
 out:
 	return IRQ_HANDLED;
@@ -167,20 +120,6 @@ static int disable_dpmcp_irq(struct fsl_mc_device *dpmcp_dev)
 		return error;
 	}
 
-	/*
-	 * Clear any leftover interrupts:
-	 */
-	error = dpmcp_clear_irq_status(dpmcp_dev->mc_io,
-				       MC_CMD_FLAG_INTR_DIS,
-				       dpmcp_dev->mc_handle,
-				       DPMCP_IRQ_INDEX, ~0x0U);
-	if (error < 0) {
-		dev_err(&dpmcp_dev->dev,
-			"dpmcp_clear_irq_status() failed: %d\n",
-			error);
-		return error;
-	}
-
 	return 0;
 }
 
@@ -272,31 +211,9 @@ int fsl_mc_io_setup_dpmcp_irq(struct fsl_mc_io *mc_io)
 	if (WARN_ON(dpmcp_dev->mc_io != mc_io))
 		return -EINVAL;
 
-	if (WARN_ON(mc_io == fsl_mc_dpmcp_isr.mc_io))
-		return -EINVAL;
-
-	if (WARN_ON(atomic_read(&fsl_mc_dpmcp_isr.dpmcp_count) < 0))
-		return -EINVAL;
-
-	if (atomic_add_return(1, &fsl_mc_dpmcp_isr.dpmcp_count) == 1) {
-		/*
-		 * Create mc_io to be used to send MC commands from
-		 * the DPMCP command completion ISR (i.e. to clear the
-		 * DPMCP interrupt)
-		 */
-		error = fsl_mc_portal_allocate(NULL,
-					       FSL_MC_IO_ATOMIC_CONTEXT_PORTAL,
-					       &fsl_mc_dpmcp_isr.mc_io);
-		if (error < 0)
-			goto error_dec_dpmcp_count;
-
-		pr_info("fsl-mc: Allocated dpmcp.%d to DPMCP command completion ISR\n",
-			fsl_mc_dpmcp_isr.mc_io->dpmcp_dev->obj_desc.id);
-	}
-
 	error = fsl_mc_allocate_irqs(dpmcp_dev);
 	if (error < 0)
-		goto error_dec_dpmcp_count;
+		return error;
 
 	error = disable_dpmcp_irq(dpmcp_dev);
 	if (error < 0)
@@ -306,37 +223,19 @@ int fsl_mc_io_setup_dpmcp_irq(struct fsl_mc_io *mc_io)
 	if (error < 0)
 		goto error_free_irqs;
 
-	error = dpmcp_open(fsl_mc_dpmcp_isr.mc_io,
-			   MC_CMD_FLAG_INTR_DIS,
-			   dpmcp_dev->obj_desc.id,
-			   &mc_io->dpmcp_isr_mc_handle);
-	if (error < 0)
-		goto error_unregister_irq_handler;
-
 	error = enable_dpmcp_irq(dpmcp_dev);
 	if (error < 0)
-		goto error_close_dpmcp;
+		goto error_unregister_irq_handler;
 
 	mc_io->mc_command_done_irq_armed = true;
 	return 0;
 
-error_close_dpmcp:
-	(void)dpmcp_close(fsl_mc_dpmcp_isr.mc_io,
-			  MC_CMD_FLAG_INTR_DIS,
-			  mc_io->dpmcp_isr_mc_handle);
-
 error_unregister_irq_handler:
 	unregister_dpmcp_irq_handler(dpmcp_dev);
 
 error_free_irqs:
 	fsl_mc_free_irqs(dpmcp_dev);
 
-error_dec_dpmcp_count:
-	if (atomic_sub_return(1, &fsl_mc_dpmcp_isr.dpmcp_count) == 0) {
-		fsl_mc_portal_free(fsl_mc_dpmcp_isr.mc_io);
-		fsl_mc_dpmcp_isr.mc_io = NULL;
-	}
-
 	return error;
 }
 EXPORT_SYMBOL_GPL(fsl_mc_io_setup_dpmcp_irq);
@@ -347,7 +246,6 @@ EXPORT_SYMBOL_GPL(fsl_mc_io_setup_dpmcp_irq);
  */
 static void teardown_dpmcp_irq(struct fsl_mc_io *mc_io)
 {
-	int error;
 	struct fsl_mc_device *dpmcp_dev = mc_io->dpmcp_dev;
 
 	if (WARN_ON(!dpmcp_dev))
@@ -357,25 +255,10 @@ static void teardown_dpmcp_irq(struct fsl_mc_io *mc_io)
 	if (WARN_ON(!dpmcp_dev->irqs))
 		return;
 
-	if (WARN_ON(atomic_read(&fsl_mc_dpmcp_isr.dpmcp_count) <= 0))
-		return;
-
 	mc_io->mc_command_done_irq_armed = false;
 	(void)disable_dpmcp_irq(dpmcp_dev);
 	unregister_dpmcp_irq_handler(dpmcp_dev);
 	fsl_mc_free_irqs(dpmcp_dev);
-	error = dpmcp_close(fsl_mc_dpmcp_isr.mc_io,
-			    MC_CMD_FLAG_INTR_DIS,
-			    mc_io->dpmcp_isr_mc_handle);
-	if (error < 0) {
-		dev_err(&dpmcp_dev->dev,
-			"dpmcp_close(dpmcp_isr_mc_handle) failed: %d\n", error);
-	}
-
-	if (atomic_sub_return(1, &fsl_mc_dpmcp_isr.dpmcp_count) == 0) {
-		fsl_mc_portal_free(fsl_mc_dpmcp_isr.mc_io);
-		fsl_mc_dpmcp_isr.mc_io = NULL;
-	}
 }
 
 /**
diff --git a/drivers/staging/fsl-mc/include/mc-sys.h b/drivers/staging/fsl-mc/include/mc-sys.h
index ce15c2d..b08df853 100644
--- a/drivers/staging/fsl-mc/include/mc-sys.h
+++ b/drivers/staging/fsl-mc/include/mc-sys.h
@@ -74,10 +74,6 @@ struct mc_command;
  * when a DPMCP command completion interrupts is received.
  * @mc_command_done_irq_armed: Boolean flag that indicates if interrupts have
  * been successfully configured for the corresponding DPMCP object.
- * @ dpmcp_isr_mc_handle: MC handle to be used to send the command to clear
- * DPMCP command completion interrupts. (We need as separate MC handle that
- * was opened using the portal that will be used to send the clear interrupt
- * command).
  *
  * Fields are only meaningful if the FSL_MC_IO_ATOMIC_CONTEXT_PORTAL flag is
  * set:
@@ -102,7 +98,6 @@ struct fsl_mc_io {
 			struct mutex mutex; /* serializes mc_send_command() */
 			struct completion mc_command_done_completion;
 			bool mc_command_done_irq_armed;
-			uint16_t dpmcp_isr_mc_handle;
 		};
 
 		/*
-- 
1.7.5.4

