From ff7863209537cdd0e61f8a2aa779ecdd48f618ec Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Wed, 24 Oct 2012 15:26:36 +0300
Subject: [PATCH 113/227] fmd: FMD18 integration

This introduces the FMD18 LLD changes.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c |  429 ++++---
 .../dpa/NetCommSw/Peripherals/FM/MAC/Makefile      |    4 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c       | 1277 +++++++-------------
 .../dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h       |  495 +-------
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c   |  135 +--
 .../NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h   |   38 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c      |    4 +
 .../dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h      |   18 +-
 .../dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.c  |  119 ++
 .../dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.h  |   43 +
 .../dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c  |  865 +++++++++++++
 .../Peripherals/FM/MAC/fman_dtsec_mii_acc.c        |  149 +++
 .../dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c  |  378 ++++++
 .../dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c   |  361 ++++++
 .../NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h  | 1033 ++++++++++++++++
 .../Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h    |  102 ++
 .../NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h  |  384 ++++++
 .../NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h   |  466 +++++++
 .../dpa/NetCommSw/Peripherals/FM/MAC/memac.c       |  675 +++++------
 .../dpa/NetCommSw/Peripherals/FM/MAC/memac.h       |  354 +-----
 .../NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c   |   76 +-
 .../NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h   |    1 +
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.c        |  625 +++-------
 .../dpa/NetCommSw/Peripherals/FM/MAC/tgec.h        |  455 +------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c       | 1151 +++++++++---------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h       |   16 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c       |  932 +++++++-------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h       |   48 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c    | 1095 +++++++++--------
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h    |   21 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c      |  453 ++++---
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h      |   21 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c     |   92 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c      |   16 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h      |  106 +-
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c   |   72 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.c    | 1229 +++++++++----------
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port.h    |   19 +-
 .../dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c |   42 +-
 .../dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c      |   48 +-
 .../dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c        |   40 +-
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |  708 ++++++-----
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.h    |   90 +-
 .../dpa/NetCommSw/Peripherals/FM/inc/fm_common.h   |   98 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/error.c   |   82 +-
 .../ethernet/freescale/dpa/NetCommSw/etc/memcpy.c  |   87 +-
 .../dpa/NetCommSw/inc/Peripherals/dpaa_ext.h       |    6 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_ext.h         |   69 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h     |   68 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h     |   62 +-
 .../dpa/NetCommSw/inc/Peripherals/fm_port_ext.h    |  108 +-
 .../freescale/dpa/NetCommSw/inc/debug_ext.h        |    8 +-
 .../freescale/dpa/NetCommSw/inc/enet_ext.h         |   16 +-
 .../freescale/dpa/NetCommSw/inc/error_ext.h        |  156 +--
 .../freescale/dpa/NetCommSw/inc/etc/list_ext.h     |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/mem_ext.h      |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h   |    1 +
 .../freescale/dpa/NetCommSw/inc/etc/sprint_ext.h   |    1 +
 .../NetCommSw/inc/flib/common/arch/ppc_access.h    |   37 +
 .../dpa/NetCommSw/inc/flib/common/general.h        |   51 +
 .../freescale/dpa/NetCommSw/inc/flib/fsl_enet.h    |   77 ++
 .../inc/integrations/P1023/dpaa_integration_ext.h  |    1 +
 .../inc/integrations/P1023/part_integration_ext.h  |   16 +
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |   21 +-
 .../inc/integrations/T4240/dpaa_integration_ext.h  |    7 +-
 .../inc/integrations/T4240/part_integration_ext.h  |    3 +-
 .../ethernet/freescale/dpa/NetCommSw/inc/net_ext.h |   10 +
 .../freescale/dpa/NetCommSw/ncsw_config.mk         |    1 +
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.c          |    3 -
 .../dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c   |    2 +-
 include/linux/fmd/Peripherals/fm_ioctls.h          |    2 -
 71 files changed, 9032 insertions(+), 6648 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/common/arch/ppc_access.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/common/general.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_enet.h

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
index 4897dce..f253d9b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/HC/hc.c
@@ -75,6 +75,8 @@
 #define SIZE_OF_HC_FRAME_PROFILE_CNT        (sizeof(t_HcFrame)-sizeof(t_FmPcdPlcrProfileRegs)+sizeof(uint32_t))
 #define SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC 16
 
+#define HC_CMD_POOL_SIZE                    (INTG_MAX_NUM_OF_CORES)
+
 #define BUILD_FD(len)                     \
 do {                                      \
     memset(&fmFd, 0, sizeof(t_DpaaFD));   \
@@ -120,37 +122,99 @@ typedef struct t_FmHc {
     t_Handle                    h_HcPortDev;
     t_FmPcdQmEnqueueCallback    *f_QmEnqueue;     /**< A callback for enqueuing frames to the QM */
     t_Handle                    h_QmArg;          /**< A handle to the QM module */
-    uint8_t                     padTill16;
     uint8_t                     dataMemId;        /**< Memory partition ID for data buffers */
 
     uint32_t                    seqNum;
-    volatile bool               wait[32];
+    volatile bool               busy[HC_CMD_POOL_SIZE];     /* Buffer is taken for HC */
+    volatile bool               enqueued[HC_CMD_POOL_SIZE]; /* HC is active - frame is enqueued
+                                                               and not confirmed yet */
+    t_HcFrame                   *p_Frm[HC_CMD_POOL_SIZE];
 } t_FmHc;
 
 
-static __inline__ t_Error EnQFrm(t_FmHc *p_FmHc, t_DpaaFD *p_FmFd, volatile uint32_t *p_SeqNum)
+static t_Error FillBufPool(t_FmHc *p_FmHc)
+{
+    int i;
+
+    ASSERT_COND(p_FmHc);
+
+    for (i=0; i<HC_CMD_POOL_SIZE; i++)
+    {
+#ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
+        p_FmHc->p_Frm[i] = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + (16 - (sizeof(t_FmHc) % 16))),
+                                                       p_FmHc->dataMemId,
+                                                       16);
+#else
+        p_FmHc->p_Frm[i] = (t_HcFrame *)XX_MallocSmart(sizeof(t_HcFrame),
+                                                       p_FmHc->dataMemId,
+                                                       16);
+#endif /* FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004 */
+        if (!p_FmHc->p_Frm[i])
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM HC frames!"));
+    }
+
+    return E_OK;
+}
+
+static __inline__ t_HcFrame * GetBuf(t_FmHc *p_FmHc, uint32_t *p_SeqNum)
+{
+    uint32_t    intFlags;
+    bool        noBuf = FALSE;
+
+    ASSERT_COND(p_FmHc);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+
+    *p_SeqNum = p_FmHc->seqNum;
+    if (p_FmHc->busy[*p_SeqNum])
+    {
+        noBuf = TRUE;
+    }
+    else
+    {
+        p_FmHc->busy[*p_SeqNum] = TRUE;
+        p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%HC_CMD_POOL_SIZE);
+    }
+
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+
+    if (noBuf)
+        return NULL;
+
+    return p_FmHc->p_Frm[*p_SeqNum];
+}
+
+static __inline__ void PutBuf(t_FmHc *p_FmHc, t_HcFrame *p_Buf, uint32_t seqNum)
+{
+    uint32_t    intFlags;
+
+    UNUSED(p_Buf);
+
+    intFlags = FmPcdLock(p_FmHc->h_FmPcd);
+    ASSERT_COND(p_FmHc->busy[seqNum]);
+    p_FmHc->busy[seqNum] = FALSE;
+    FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
+}
+
+static __inline__ t_Error EnQFrm(t_FmHc *p_FmHc, t_DpaaFD *p_FmFd, uint32_t seqNum)
 {
     t_Error     err = E_OK;
-    uint32_t    savedSeqNum;
     uint32_t    intFlags;
     uint32_t    timeout=100;
 
     intFlags = FmPcdLock(p_FmHc->h_FmPcd);
-    *p_SeqNum = p_FmHc->seqNum;
-    savedSeqNum = p_FmHc->seqNum;
-    p_FmHc->seqNum = (uint32_t)((p_FmHc->seqNum+1)%32);
-    ASSERT_COND(!p_FmHc->wait[savedSeqNum]);
-    p_FmHc->wait[savedSeqNum] = TRUE;
+    ASSERT_COND(!p_FmHc->enqueued[seqNum]);
+    p_FmHc->enqueued[seqNum] = TRUE;
     FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
     DBG(TRACE, ("Send Hc, SeqNum %d, buff@0x%x, fd offset 0x%x",
-                savedSeqNum,
+                seqNum,
                 DPAA_FD_GET_ADDR(p_FmFd),
                 DPAA_FD_GET_OFFSET(p_FmFd)));
     err = p_FmHc->f_QmEnqueue(p_FmHc->h_QmArg, (void *)p_FmFd);
     if (err)
         RETURN_ERROR(MINOR, err, ("HC enqueue failed"));
 
-    while (p_FmHc->wait[savedSeqNum] && --timeout)
+    while (p_FmHc->enqueued[seqNum] && --timeout)
         XX_UDelay(100);
 
     if (!timeout)
@@ -182,9 +246,6 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     if (!FmIsMaster(p_FmHcParams->h_Fm))
         return (t_Handle)p_FmHc;
 
-#ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
-    p_FmHc->padTill16 = 16 - (sizeof(t_FmHc) % 16);
-#endif /* FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004 */
     memset(&fmPortParam, 0, sizeof(fmPortParam));
     fmPortParam.baseAddr    = p_FmHcParams->params.portBaseAddr;
     fmPortParam.portType    = e_FM_PORT_TYPE_OH_HOST_COMMAND;
@@ -197,7 +258,7 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     fmPortParam.specificParams.nonRxParams.qmChannel    = p_FmHcParams->params.qmChannel;
 
     p_FmHc->h_HcPortDev = FM_PORT_Config(&fmPortParam);
-    if(!p_FmHc->h_HcPortDev)
+    if (!p_FmHc->h_HcPortDev)
     {
         REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("FM HC port!"));
         XX_Free(p_FmHc);
@@ -208,7 +269,7 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     err = FM_PORT_Init(p_FmHc->h_HcPortDev);
     if (err != E_OK)
     {
-        REPORT_ERROR(MAJOR, err, ("FM HC port!"));
+        REPORT_ERROR(MAJOR, err, ("FM HC port init!"));
         FmHcFree(p_FmHc);
         return NULL;
     }
@@ -216,7 +277,15 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
     err = FM_PORT_Enable(p_FmHc->h_HcPortDev);
     if (err != E_OK)
     {
-        REPORT_ERROR(MAJOR, err, ("FM HC port!"));
+        REPORT_ERROR(MAJOR, err, ("FM HC port enable!"));
+        FmHcFree(p_FmHc);
+        return NULL;
+    }
+
+    err = FillBufPool(p_FmHc);
+    if (err != E_OK)
+    {
+        REPORT_ERROR(MAJOR, err, NO_MSG);
         FmHcFree(p_FmHc);
         return NULL;
     }
@@ -234,10 +303,17 @@ t_Handle FmGcGetHcPortDevH(t_Handle h_FmHc)
 void FmHcFree(t_Handle h_FmHc)
 {
     t_FmHc  *p_FmHc = (t_FmHc*)h_FmHc;
+    int     i;
 
     if (!p_FmHc)
         return;
 
+    for (i=0; i<HC_CMD_POOL_SIZE; i++)
+        if (p_FmHc->p_Frm[i])
+            XX_FreeSmart(p_FmHc->p_Frm[i]);
+        else
+            break;
+
     if (p_FmHc->h_HcPortDev)
         FM_PORT_Free(p_FmHc->h_HcPortDev);
 
@@ -249,12 +325,17 @@ t_Error FmHcSetFramesDataMemory(t_Handle h_FmHc,
                                 uint8_t  memId)
 {
     t_FmHc  *p_FmHc = (t_FmHc*)h_FmHc;
+    int     i;
 
     SANITY_CHECK_RETURN_ERROR(p_FmHc, E_INVALID_HANDLE);
 
     p_FmHc->dataMemId            = memId;
 
-    return E_OK;
+    for (i=0; i<HC_CMD_POOL_SIZE; i++)
+        if (p_FmHc->p_Frm[i])
+            XX_FreeSmart(p_FmHc->p_Frm[i]);
+
+    return FillBufPool(p_FmHc);
 }
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -284,10 +365,10 @@ void FmHcTxConf(t_Handle h_FmHc, t_DpaaFD *p_Fd)
     DBG(TRACE, ("Hc Conf, SeqNum %d, FD@0x%x, fd offset 0x%x",
                 p_HcFrame->commandSequence, DPAA_FD_GET_ADDR(p_Fd), DPAA_FD_GET_OFFSET(p_Fd)));
 
-    if (!(p_FmHc->wait[p_HcFrame->commandSequence]))
+    if (!(p_FmHc->enqueued[p_HcFrame->commandSequence]))
         REPORT_ERROR(MINOR, E_INVALID_FRAME, ("Not an Host-Command frame received!"));
     else
-        p_FmHc->wait[p_HcFrame->commandSequence] = FALSE;
+        p_FmHc->enqueued[p_HcFrame->commandSequence] = FALSE;
     FmPcdUnlock(p_FmHc->h_FmPcd, intFlags);
 }
 
@@ -301,8 +382,9 @@ t_Error FmHcPcdKgSetScheme(t_Handle             h_FmHc,
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
     uint8_t                             physicalSchemeId, relativeSchemeId;
+    uint32_t                            seqNum;
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
@@ -321,16 +403,16 @@ t_Error FmHcPcdKgSetScheme(t_Handle             h_FmHc,
         p_HcFrame->hcSpecificData.schemeRegs.kgse_ccbs  = p_SchemeRegs->kgse_ccbs;
         p_HcFrame->hcSpecificData.schemeRegs.kgse_mv    = p_SchemeRegs->kgse_mv;
     }
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
+
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
 
-    XX_FreeSmart(p_HcFrame);
+    if (err != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -342,8 +424,9 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
     uint8_t     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
+    uint32_t    seqNum;
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
@@ -352,16 +435,16 @@ t_Error FmHcPcdKgDeleteScheme(t_Handle h_FmHc, t_Handle h_Scheme)
     p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, TRUE);
     p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
     memset(&p_HcFrame->hcSpecificData.schemeRegs, 0, sizeof(t_FmPcdKgSchemeRegs));
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
+
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
 
-    XX_FreeSmart(p_HcFrame);
+    if (err != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -375,6 +458,7 @@ t_Error FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t re
     uint8_t     relativeSchemeId;
     uint8_t     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
     uint32_t    tmpReg32 = 0;
+    uint32_t    seqNum;
 
     /* Scheme is locked by calling routine */
     /* WARNING - this lock will not be efficient if other HC routine will attempt to change
@@ -382,47 +466,50 @@ t_Error FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t re
      */
 
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
-    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    if ( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-    if(!FmPcdKgGetPointedOwners(p_FmHc->h_FmPcd, relativeSchemeId) ||
+    if (!FmPcdKgGetPointedOwners(p_FmHc->h_FmPcd, relativeSchemeId) ||
        !(FmPcdKgGetRequiredAction(p_FmHc->h_FmPcd, relativeSchemeId) & requiredAction))
     {
         if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) &&
             (FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_PLCR))
             {
-                if((FmPcdKgIsDirectPlcr(p_FmHc->h_FmPcd, relativeSchemeId) == FALSE) ||
+                if ((FmPcdKgIsDirectPlcr(p_FmHc->h_FmPcd, relativeSchemeId) == FALSE) ||
                     (FmPcdKgIsDistrOnPlcrProfile(p_FmHc->h_FmPcd, relativeSchemeId) == TRUE))
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
                 err = FmPcdPlcrCcGetSetParams(p_FmHc->h_FmPcd, FmPcdKgGetRelativeProfileId(p_FmHc->h_FmPcd, relativeSchemeId), requiredAction);
-                if(err)
+                if (err)
                     RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         else /* From here we deal with KG-Schemes only */
         {
             /* Pre change general code */
-            p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+            p_HcFrame = GetBuf(p_FmHc, &seqNum);
             if (!p_HcFrame)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
             memset(p_HcFrame, 0, sizeof(t_HcFrame));
             p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
             p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
             p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
+            p_HcFrame->commandSequence = seqNum;
             BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
-            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            if ((err = EnQFrm(p_FmHc, &fmFd, seqNum)) != E_OK)
             {
-                XX_FreeSmart(p_HcFrame);
+                PutBuf(p_FmHc, p_HcFrame, seqNum);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
+
             /* specific change */
             if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) &&
                 ((FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_DONE) &&
                  (FmPcdKgGetDoneAction(p_FmHc->h_FmPcd, relativeSchemeId) ==  e_FM_PCD_ENQ_FRAME)))
-                {
-                    tmpReg32 = p_HcFrame->hcSpecificData.schemeRegs.kgse_mode;
-                    ASSERT_COND(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
-                    p_HcFrame->hcSpecificData.schemeRegs.kgse_mode =  tmpReg32 | NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
-                }
+            {
+                tmpReg32 = p_HcFrame->hcSpecificData.schemeRegs.kgse_mode;
+                ASSERT_COND(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+                p_HcFrame->hcSpecificData.schemeRegs.kgse_mode =  tmpReg32 | NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
+            }
+
             if ((requiredAction & UPDATE_KG_NIA_CC_WA) &&
                 (FmPcdKgGetNextEngine(p_FmHc->h_FmPcd, relativeSchemeId) == e_FM_PCD_CC))
             {
@@ -431,29 +518,30 @@ t_Error FmHcPcdKgCcGetSetParams(t_Handle h_FmHc, t_Handle  h_Scheme, uint32_t re
                 tmpReg32 &= ~NIA_FM_CTL_AC_CC;
                 p_HcFrame->hcSpecificData.schemeRegs.kgse_mode =  tmpReg32 | NIA_FM_CTL_AC_PRE_CC;
             }
-            if(requiredAction & UPDATE_KG_OPT_MODE)
-            {
+
+            if (requiredAction & UPDATE_KG_OPT_MODE)
                 p_HcFrame->hcSpecificData.schemeRegs.kgse_om = value;
-            }
-            if(requiredAction & UPDATE_KG_NIA)
+
+            if (requiredAction & UPDATE_KG_NIA)
             {
                 tmpReg32 = p_HcFrame->hcSpecificData.schemeRegs.kgse_mode;
                 tmpReg32 &= ~(NIA_ENG_MASK | NIA_AC_MASK);
                 tmpReg32 |= value;
                 p_HcFrame->hcSpecificData.schemeRegs.kgse_mode = tmpReg32;
             }
+
             /* Post change general code */
             p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
             p_HcFrame->actionReg  = FmPcdKgBuildWriteSchemeActionReg(physicalSchemeId, FALSE);
             p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
 
             BUILD_FD(sizeof(t_HcFrame));
-            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-            {
-                XX_FreeSmart(p_HcFrame);
+            err = EnQFrm(p_FmHc, &fmFd, seqNum);
+
+            PutBuf(p_FmHc, p_HcFrame, seqNum);
+
+            if (err != E_OK)
                 RETURN_ERROR(MINOR, err, NO_MSG);
-            }
-            XX_FreeSmart(p_HcFrame);
         }
     }
 
@@ -469,16 +557,17 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
     uint32_t    retVal;
     uint8_t     relativeSchemeId;
     uint8_t     physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
+    uint32_t    seqNum;
 
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
-    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    if ( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
     {
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
         return 0;
     }
 
     /* first read scheme and check that it is valid */
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
     {
         REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
@@ -488,27 +577,27 @@ uint32_t  FmHcPcdKgGetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme)
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
     p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
     if (err != E_OK)
     {
+        PutBuf(p_FmHc, p_HcFrame, seqNum);
         REPORT_ERROR(MINOR, err, NO_MSG);
-        XX_FreeSmart(p_HcFrame);
         return 0;
     }
 
     if (!FmPcdKgHwSchemeIsValid(p_HcFrame->hcSpecificData.schemeRegs.kgse_mode))
     {
+        PutBuf(p_FmHc, p_HcFrame, seqNum);
         REPORT_ERROR(MAJOR, E_ALREADY_EXISTS, ("Scheme is invalid"));
-        XX_FreeSmart(p_HcFrame);
         return 0;
     }
 
     retVal = p_HcFrame->hcSpecificData.schemeRegs.kgse_spc;
-
-    XX_FreeSmart(p_HcFrame);
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
 
     return retVal;
 }
@@ -519,14 +608,16 @@ t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t
     t_Error     err = E_OK;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
-    uint8_t     relativeSchemeId, physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
+    uint8_t     relativeSchemeId, physicalSchemeId;
+    uint32_t    seqNum;
 
+    physicalSchemeId = FmPcdKgGetSchemeId(h_Scheme);
     relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmHc->h_FmPcd, physicalSchemeId);
-    if( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+    if ( relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
     /* first read scheme and check that it is valid */
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -535,13 +626,13 @@ t_Error  FmHcPcdKgSetSchemeCounter(t_Handle h_FmHc, t_Handle h_Scheme, uint32_t
     p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_COUNTER;
     /* write counter */
     p_HcFrame->hcSpecificData.singleRegForWrite = value;
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
 
-    err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
-
-    XX_FreeSmart(p_HcFrame);
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
 
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
     return err;
 }
 
@@ -551,32 +642,34 @@ t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_S
     t_HcFrame               *p_HcFrame;
     t_DpaaFD                fmFd;
     uint32_t                i;
+    uint32_t                seqNum;
     t_Error                 err = E_OK;
 
     ASSERT_COND(p_FmHc);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
-    for (i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    for (i = p_Set->baseEntry; i < (p_Set->baseEntry+p_Set->numOfClsPlanEntries); i+=8)
     {
         memset(p_HcFrame, 0, sizeof(t_HcFrame));
         p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
         p_HcFrame->actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
         p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
         memcpy((void*)&p_HcFrame->hcSpecificData.clsPlanEntries, (void *)&p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+        p_HcFrame->commandSequence = seqNum;
 
         BUILD_FD(sizeof(t_HcFrame));
 
-        if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+        if ((err = EnQFrm(p_FmHc, &fmFd, seqNum)) != E_OK)
         {
-            XX_FreeSmart(p_HcFrame);
+            PutBuf(p_FmHc, p_HcFrame, seqNum);
             RETURN_ERROR(MINOR, err, NO_MSG);
         }
     }
-    XX_FreeSmart(p_HcFrame);
 
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
     return err;
 }
 
@@ -610,22 +703,23 @@ t_Error FmHcPcdCcCapwapTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcCapwapReassmTimeo
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
     t_Error                             err;
+    uint32_t                            seqNum;
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_CAPWAP_REASSM_TIMEOUT);
     memcpy(&p_HcFrame->hcSpecificData.ccCapwapReassmTimeout, p_CcCapwapReassmTimeoutParams, sizeof(t_FmPcdCcCapwapReassmTimeoutParams));
+    p_HcFrame->commandSequence = seqNum;
     BUILD_FD(sizeof(t_HcFrame));
 
-    err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
-
-    XX_FreeSmart(p_HcFrame);
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
 
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
     return err;
 }
 
@@ -635,10 +729,11 @@ t_Error FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragS
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
     t_Error                             err;
+    uint32_t                            seqNum;
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
@@ -651,18 +746,18 @@ t_Error FmHcPcdCcIpFragScratchPollCmd(t_Handle h_FmHc, bool fill, t_FmPcdCcFragS
     {
         p_HcFrame->extraReg   = p_FmPcdCcFragScratchPoolCmdParams->numOfBuffers;
     }
-    p_HcFrame->commandSequence = 0;
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    if ((err = EnQFrm(p_FmHc, &fmFd, seqNum)) != E_OK)
     {
-        XX_FreeSmart(p_HcFrame);
+        PutBuf(p_FmHc, p_HcFrame, seqNum);
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
-    p_FmPcdCcFragScratchPoolCmdParams->numOfBuffers = p_HcFrame->extraReg;
 
-    XX_FreeSmart(p_HcFrame);
+    p_FmPcdCcFragScratchPoolCmdParams->numOfBuffers = p_HcFrame->extraReg;
 
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
     return E_OK;
 }
 
@@ -672,10 +767,11 @@ t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
     t_Error                             err;
+    uint32_t                            seqNum;
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
@@ -683,20 +779,20 @@ t_Error FmHcPcdCcIpTimeoutReassm(t_Handle h_FmHc, t_FmPcdCcIpReassmTimeoutParams
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_CC_IP_REASSM_TIMEOUT);
     p_HcFrame->actionReg = (uint32_t)((p_CcIpReassmTimeoutParams->activate ? 0 : 1) << HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_ACTIVE_SHIFT);
     p_HcFrame->extraReg = (p_CcIpReassmTimeoutParams->tsbs << HC_HCOR_EXTRA_REG_IP_REASSM_TIMEOUT_TSBS_SHIFT) | p_CcIpReassmTimeoutParams->iprcpt;
-    p_HcFrame->commandSequence = 0;
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    if ((err = EnQFrm(p_FmHc, &fmFd, seqNum)) != E_OK)
     {
-        XX_FreeSmart(p_HcFrame);
+        PutBuf(p_FmHc, p_HcFrame, seqNum);
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
     *p_Result = (uint8_t)
         ((p_HcFrame->actionReg >> HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_SHIFT) & HC_HCOR_ACTION_REG_IP_REASSM_TIMEOUT_RES_MASK);
-    XX_FreeSmart(p_HcFrame);
 
-   return E_OK;
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
+    return E_OK;
 }
 
 t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, uint32_t requiredAction)
@@ -707,6 +803,7 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
     t_Error             err;
     uint32_t            tmpReg32 = 0;
     uint32_t            requiredActionTmp, pointedOwnersTmp;
+    uint32_t            seqNum;
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
@@ -718,13 +815,11 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
     requiredActionTmp = FmPcdPlcrGetRequiredAction(p_FmHc->h_FmPcd, absoluteProfileId);
     pointedOwnersTmp = FmPcdPlcrGetPointedOwners(p_FmHc->h_FmPcd, absoluteProfileId);
 
-    if(!pointedOwnersTmp || !(requiredActionTmp & requiredAction))
+    if (!pointedOwnersTmp || !(requiredActionTmp & requiredAction))
     {
-
-        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        if (requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
-
-            p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+            p_HcFrame = GetBuf(p_FmHc, &seqNum);
             if (!p_HcFrame)
                 RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
             /* first read scheme and check that it is valid */
@@ -732,21 +827,24 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
             p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
             p_HcFrame->actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
             p_HcFrame->extraReg = 0x00008000;
+            p_HcFrame->commandSequence = seqNum;
 
             BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            if ((err = EnQFrm(p_FmHc, &fmFd, seqNum)) != E_OK)
             {
-                XX_FreeSmart(p_HcFrame);
+                PutBuf(p_FmHc, p_HcFrame, seqNum);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
 
             tmpReg32 = p_HcFrame->hcSpecificData.profileRegs.fmpl_pegnia;
-            if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+            if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
             {
-                XX_FreeSmart(p_HcFrame);
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
+                PutBuf(p_FmHc, p_HcFrame, seqNum);
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                             ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
             }
+
             tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
 
             p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
@@ -757,18 +855,19 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
 
             BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
 
-            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            if ((err = EnQFrm(p_FmHc, &fmFd, seqNum)) != E_OK)
             {
-                XX_FreeSmart(p_HcFrame);
+                PutBuf(p_FmHc, p_HcFrame, seqNum);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
 
             tmpReg32 = p_HcFrame->hcSpecificData.profileRegs.fmpl_peynia;
-            if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+            if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
             {
-                XX_FreeSmart(p_HcFrame);
+                PutBuf(p_FmHc, p_HcFrame, seqNum);
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
             }
+
             tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
 
             p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
@@ -779,18 +878,19 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
 
             BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
 
-            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            if ((err = EnQFrm(p_FmHc, &fmFd, seqNum)) != E_OK)
             {
-                XX_FreeSmart(p_HcFrame);
+                PutBuf(p_FmHc, p_HcFrame, seqNum);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
 
             tmpReg32 = p_HcFrame->hcSpecificData.profileRegs.fmpl_pernia;
-            if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+            if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
             {
-                XX_FreeSmart(p_HcFrame);
+                PutBuf(p_FmHc, p_HcFrame, seqNum);
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine of this policer profile has to be assigned to FM_PCD_DONE"));
             }
+
             tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
 
             p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
@@ -801,12 +901,13 @@ t_Error FmHcPcdPlcrCcGetSetParams(t_Handle h_FmHc,uint16_t absoluteProfileId, ui
 
             BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
 
-            if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+            if ((err = EnQFrm(p_FmHc, &fmFd, seqNum)) != E_OK)
             {
-                XX_FreeSmart(p_HcFrame);
+                PutBuf(p_FmHc, p_HcFrame, seqNum);
                 RETURN_ERROR(MINOR, err, NO_MSG);
             }
-            XX_FreeSmart(p_HcFrame);
+
+            PutBuf(p_FmHc, p_HcFrame, seqNum);
         }
     }
 
@@ -820,8 +921,9 @@ t_Error FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrPr
     uint16_t                            profileIndx;
     t_HcFrame                           *p_HcFrame;
     t_DpaaFD                            fmFd;
+    uint32_t                            seqNum;
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
 
@@ -832,16 +934,16 @@ t_Error FmHcPcdPlcrSetProfile(t_Handle h_FmHc, t_Handle h_Profile, t_FmPcdPlcrPr
     p_HcFrame->actionReg  = FmPcdPlcrBuildWritePlcrActionRegs(profileIndx);
     p_HcFrame->extraReg = 0x00008000;
     memcpy(&p_HcFrame->hcSpecificData.profileRegs, p_PlcrRegs, sizeof(t_FmPcdPlcrProfileRegs));
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
 
-    XX_FreeSmart(p_HcFrame);
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
+
+    if (err != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -853,8 +955,9 @@ t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
     t_Error     err = E_OK;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
+    uint32_t    seqNum;
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -863,16 +966,16 @@ t_Error FmHcPcdPlcrDeleteProfile(t_Handle h_FmHc, t_Handle h_Profile)
     p_HcFrame->actionReg  |= 0x00008000;
     p_HcFrame->extraReg = 0x00008000;
     memset(&p_HcFrame->hcSpecificData.profileRegs, 0, sizeof(t_FmPcdPlcrProfileRegs));
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
 
-    XX_FreeSmart(p_HcFrame);
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
+
+    if (err != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -885,9 +988,10 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     t_Error     err = E_OK;
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
+    uint32_t    seqNum;
 
     /* first read scheme and check that it is valid */
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -896,16 +1000,16 @@ t_Error  FmHcPcdPlcrSetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     p_HcFrame->actionReg |= FmPcdPlcrBuildCounterProfileReg(counter);
     p_HcFrame->extraReg = 0x00008000;
     p_HcFrame->hcSpecificData.singleRegForWrite = value;
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_PROFILE_CNT);
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
+
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
 
-    XX_FreeSmart(p_HcFrame);
+    if (err != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -918,11 +1022,12 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     t_HcFrame   *p_HcFrame;
     t_DpaaFD    fmFd;
     uint32_t    retVal = 0;
+    uint32_t    seqNum;
 
     SANITY_CHECK_RETURN_VALUE(h_FmHc, E_INVALID_HANDLE,0);
 
     /* first read scheme and check that it is valid */
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
     {
         REPORT_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
@@ -932,14 +1037,15 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_PLCR_PRFL);
     p_HcFrame->actionReg  = FmPcdPlcrBuildReadPlcrActionReg(absoluteProfileId);
     p_HcFrame->extraReg = 0x00008000;
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence);
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
     if (err != E_OK)
     {
+        PutBuf(p_FmHc, p_HcFrame, seqNum);
         REPORT_ERROR(MINOR, err, NO_MSG);
-        XX_FreeSmart(p_HcFrame);
         return 0;
     }
 
@@ -964,8 +1070,7 @@ uint32_t FmHcPcdPlcrGetProfileCounter(t_Handle h_FmHc, t_Handle h_Profile, e_FmP
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
     }
 
-    XX_FreeSmart(p_HcFrame);
-
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
     return retVal;
 }
 
@@ -975,10 +1080,11 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
     t_HcFrame               *p_HcFrame;
     t_DpaaFD                fmFd;
     t_Error                 err = E_OK;
+    uint32_t                seqNum;
 
     ASSERT_COND(p_FmHc);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -986,17 +1092,18 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
     p_HcFrame->opcode = (uint32_t)(HC_HCOR_GBL | HC_HCOR_OPCODE_KG_SCM);
     p_HcFrame->actionReg  = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
     p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_PORT_REGS);
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
+    if ((err = EnQFrm(p_FmHc, &fmFd, seqNum)) != E_OK)
     {
-        XX_FreeSmart(p_HcFrame);
+        PutBuf(p_FmHc, p_HcFrame, seqNum);
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
     /* spReg is the first reg, so we can use it both for read and for write */
-    if(add)
+    if (add)
         p_HcFrame->hcSpecificData.portRegsForRead.spReg |= spReg;
     else
         p_HcFrame->hcSpecificData.portRegsForRead.spReg &= ~spReg;
@@ -1005,13 +1112,12 @@ t_Error FmHcKgWriteSp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t spReg, b
 
     BUILD_FD(sizeof(t_HcFrame));
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
 
-    XX_FreeSmart(p_HcFrame);
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
+
+    if (err != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -1022,10 +1128,11 @@ t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
     t_HcFrame               *p_HcFrame;
     t_DpaaFD                fmFd;
     t_Error                 err = E_OK;
+    uint32_t                seqNum;
 
     ASSERT_COND(p_FmHc);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -1034,16 +1141,16 @@ t_Error FmHcKgWriteCpp(t_Handle h_FmHc, uint8_t hardwarePortId, uint32_t cppReg)
     p_HcFrame->actionReg  = FmPcdKgBuildWritePortClsPlanBindActionReg(hardwarePortId);
     p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
     p_HcFrame->hcSpecificData.singleRegForWrite = cppReg;
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(sizeof(t_HcFrame));
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MINOR, err, NO_MSG);
-    }
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
 
-    XX_FreeSmart(p_HcFrame);
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
+
+    if (err != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
 }
@@ -1054,10 +1161,11 @@ t_Error FmHcPcdCcDoDynamicChange(t_Handle h_FmHc, uint32_t oldAdAddrOffset, uint
     t_HcFrame               *p_HcFrame;
     t_DpaaFD                fmFd;
     t_Error                 err = E_OK;
+    uint32_t                seqNum;
 
     SANITY_CHECK_RETURN_ERROR(p_FmHc, E_INVALID_HANDLE);
 
-    p_HcFrame = (t_HcFrame *)XX_MallocSmart((sizeof(t_HcFrame) + p_FmHc->padTill16), p_FmHc->dataMemId, 16);
+    p_HcFrame = GetBuf(p_FmHc, &seqNum);
     if (!p_HcFrame)
         RETURN_ERROR(MINOR, E_NO_MEMORY, ("HC Frame object"));
     memset(p_HcFrame, 0, sizeof(t_HcFrame));
@@ -1066,16 +1174,17 @@ t_Error FmHcPcdCcDoDynamicChange(t_Handle h_FmHc, uint32_t oldAdAddrOffset, uint
     p_HcFrame->actionReg  = newAdAddrOffset;
     p_HcFrame->actionReg |= 0xc0000000;
     p_HcFrame->extraReg   = oldAdAddrOffset;
+    p_HcFrame->commandSequence = seqNum;
 
     BUILD_FD(SIZE_OF_HC_FRAME_READ_OR_CC_DYNAMIC);
 
-    if ((err = EnQFrm(p_FmHc, &fmFd, &p_HcFrame->commandSequence)) != E_OK)
-    {
-        XX_FreeSmart(p_HcFrame);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
+    err = EnQFrm(p_FmHc, &fmFd, seqNum);
 
-    XX_FreeSmart(p_HcFrame);
+    PutBuf(p_FmHc, p_HcFrame, seqNum);
+
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
+
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
index 6c02470..e7600d7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
@@ -11,7 +11,9 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 
 obj-y		+= fsl-ncsw-MAC.o
 
-fsl-ncsw-MAC-objs	:=   dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o
+fsl-ncsw-MAC-objs	:=  dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o \
+			    fman_dtsec.o fman_dtsec_mii_acc.o fman_memac.o \
+			    fman_tgec.o fman_crc32.o
 
 ifeq ($(CONFIG_FMAN_T4240),y)
 fsl-ncsw-MAC-objs	+=  memac.o memac_mii_acc.o
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
index dce1fb1..a5a8684 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.c
@@ -42,11 +42,11 @@
 #include "string_ext.h"
 #include "xx_ext.h"
 #include "endian_ext.h"
-#include "crc_mac_addr_ext.h"
 #include "debug_ext.h"
 
 #include "fm_common.h"
 #include "dtsec.h"
+#include "fsl_fman_dtsec.h"
 
 
 /*****************************************************************************/
@@ -55,47 +55,45 @@
 
 static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
 {
-    if(ENET_SPEED_FROM_MODE(p_Dtsec->enetMode) >= e_ENET_SPEED_10000)
+    if (ENET_SPEED_FROM_MODE(p_Dtsec->enetMode) >= e_ENET_SPEED_10000)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet 1G MAC driver only supports 1G or lower speeds"));
-    if(p_Dtsec->macId >= FM_MAX_NUM_OF_1G_MACS)
+    if (p_Dtsec->macId >= FM_MAX_NUM_OF_1G_MACS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("macId can not be greater than the number of 1G MACs"));
-    if(p_Dtsec->addr == 0)
+    if (p_Dtsec->addr == 0)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC Must have a valid MAC Address"));
-    if((ENET_SPEED_FROM_MODE(p_Dtsec->enetMode) >= e_ENET_SPEED_1000) &&
-        p_Dtsec->p_DtsecDriverParam->halfDuplex)
+    if ((ENET_SPEED_FROM_MODE(p_Dtsec->enetMode) >= e_ENET_SPEED_1000) &&
+        p_Dtsec->p_DtsecDriverParam->halfdup_on)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC 1G can't work in half duplex"));
-    if(p_Dtsec->p_DtsecDriverParam->halfDuplex && (p_Dtsec->p_DtsecDriverParam)->loopback)
+    if (p_Dtsec->p_DtsecDriverParam->halfdup_on && (p_Dtsec->p_DtsecDriverParam)->loopback)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("LoopBack is not supported in halfDuplex mode"));
 #ifdef FM_RX_PREAM_4_ERRATA_DTSEC_A001
-    if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev <= 6) /* fixed for rev3 */
-        if(p_Dtsec->p_DtsecDriverParam->preambleRxEn)
+    if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev <= 6) /* fixed for rev3 */
+        if (p_Dtsec->p_DtsecDriverParam->rx_preamble)
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("preambleRxEn"));
 #endif /* FM_RX_PREAM_4_ERRATA_DTSEC_A001 */
-    if(((p_Dtsec->p_DtsecDriverParam)->preambleTxEn || (p_Dtsec->p_DtsecDriverParam)->preambleRxEn) &&( (p_Dtsec->p_DtsecDriverParam)->preambleLength != 0x7))
+    if (((p_Dtsec->p_DtsecDriverParam)->tx_preamble || (p_Dtsec->p_DtsecDriverParam)->rx_preamble) &&( (p_Dtsec->p_DtsecDriverParam)->preamble_len != 0x7))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Preamble length should be 0x7 bytes"));
-    if((p_Dtsec->p_DtsecDriverParam)->fifoTxWatermarkH<((p_Dtsec->p_DtsecDriverParam)->fifoTxThr+8))
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoTxWatermarkH has to be at least 8 larger than fifoTxThr"));
-    if((p_Dtsec->p_DtsecDriverParam)->halfDuplex &&
-       (p_Dtsec->p_DtsecDriverParam->txTimeStampEn || p_Dtsec->p_DtsecDriverParam->rxTimeStampEn))
+    if ((p_Dtsec->p_DtsecDriverParam)->halfdup_on &&
+       (p_Dtsec->p_DtsecDriverParam->tx_time_stamp_en || p_Dtsec->p_DtsecDriverParam->rx_time_stamp_en))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dTSEC in half duplex mode has to be with 1588 timeStamping diable"));
-    if((p_Dtsec->p_DtsecDriverParam)->actOnRxPauseFrame && (p_Dtsec->p_DtsecDriverParam)->controlFrameAccept )
+    if ((p_Dtsec->p_DtsecDriverParam)->rx_flow && (p_Dtsec->p_DtsecDriverParam)->rx_ctrl_acc )
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Receive control frame are not passed to the system memory so it can not be accept "));
-    if((p_Dtsec->p_DtsecDriverParam)->packetAlignmentPadding  > MAX_PACKET_ALIGNMENT)
+    if ((p_Dtsec->p_DtsecDriverParam)->rx_prepend  > MAX_PACKET_ALIGNMENT)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("packetAlignmentPadding can't be greater than %d ",MAX_PACKET_ALIGNMENT ));
-    if(((p_Dtsec->p_DtsecDriverParam)->nonBackToBackIpg1  > MAX_INTER_PACKET_GAP) ||
-        ((p_Dtsec->p_DtsecDriverParam)->nonBackToBackIpg2 > MAX_INTER_PACKET_GAP) ||
-        ((p_Dtsec->p_DtsecDriverParam)->backToBackIpg > MAX_INTER_PACKET_GAP))
+    if (((p_Dtsec->p_DtsecDriverParam)->non_back_to_back_ipg1  > MAX_INTER_PACKET_GAP) ||
+        ((p_Dtsec->p_DtsecDriverParam)->non_back_to_back_ipg2 > MAX_INTER_PACKET_GAP) ||
+        ((p_Dtsec->p_DtsecDriverParam)->back_to_back_ipg > MAX_INTER_PACKET_GAP))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inter packet gap can't be greater than %d ",MAX_INTER_PACKET_GAP ));
-    if((p_Dtsec->p_DtsecDriverParam)->alternateBackoffVal > MAX_INTER_PALTERNATE_BEB)
+    if ((p_Dtsec->p_DtsecDriverParam)->halfdup_alt_backoff_val > MAX_INTER_PALTERNATE_BEB)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("alternateBackoffVal can't be greater than %d ",MAX_INTER_PALTERNATE_BEB ));
-    if((p_Dtsec->p_DtsecDriverParam)->maxRetransmission > MAX_RETRANSMISSION)
+    if ((p_Dtsec->p_DtsecDriverParam)->halfdup_retransmit > MAX_RETRANSMISSION)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("maxRetransmission can't be greater than %d ",MAX_RETRANSMISSION ));
-    if((p_Dtsec->p_DtsecDriverParam)->collisionWindow > MAX_COLLISION_WINDOW)
+    if ((p_Dtsec->p_DtsecDriverParam)->halfdup_coll_window > MAX_COLLISION_WINDOW)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("collisionWindow can't be greater than %d ",MAX_COLLISION_WINDOW ));
 
     /*  If Auto negotiation process is disabled, need to */
     /*  Set up the PHY using the MII Management Interface */
-    if (p_Dtsec->p_DtsecDriverParam->tbiPhyAddr > MAX_PHYS)
+    if (p_Dtsec->p_DtsecDriverParam->tbipa > MAX_PHYS)
         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("PHY address (should be 0-%d)", MAX_PHYS));
     if (!p_Dtsec->f_Exception)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("uninitialized f_Exception"));
@@ -103,215 +101,134 @@ static t_Error CheckInitParameters(t_Dtsec *p_Dtsec)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("uninitialized f_Event"));
 
 #ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
-    if(p_Dtsec->p_DtsecDriverParam->lengthCheckEnable)
+    if (p_Dtsec->p_DtsecDriverParam->rx_len_check)
        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
 #endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
 
     return E_OK;
 }
 
-/* ........................................................................... */
-
-static void SetDefaultParam(t_DtsecDriverParam *p_DtsecDriverParam)
-{
-    p_DtsecDriverParam->errorDisabled       = DEFAULT_errorDisabled;
-
-    p_DtsecDriverParam->promiscuousEnable   = DEFAULT_promiscuousEnable;
-
-    p_DtsecDriverParam->pauseExtended       = DEFAULT_pauseExtended;
-    p_DtsecDriverParam->pauseTime           = DEFAULT_pauseTime;
-
-    p_DtsecDriverParam->halfDuplex              = DEFAULT_halfDuplex;
-    p_DtsecDriverParam->halfDulexFlowControlEn  = DEFAULT_halfDulexFlowControlEn;
-    p_DtsecDriverParam->txTimeStampEn           = DEFAULT_timeStampEnable;
-    p_DtsecDriverParam->rxTimeStampEn           = DEFAULT_timeStampEnable;
-
-    p_DtsecDriverParam->packetAlignmentPadding = DEFAULT_packetAlignment;
-    p_DtsecDriverParam->controlFrameAccept     = DEFAULT_controlFrameAccept;
-    p_DtsecDriverParam->groupHashExtend        = DEFAULT_groupHashExtend;
-    p_DtsecDriverParam->broadcReject           = DEFAULT_broadcReject;
-    p_DtsecDriverParam->rxShortFrame           = DEFAULT_rxShortFrame;
-    p_DtsecDriverParam->exactMatch             = DEFAULT_exactMatch;
-    p_DtsecDriverParam->debugMode              = DEFAULT_debugMode;
-
-    p_DtsecDriverParam->loopback               = DEFAULT_loopback;
-    p_DtsecDriverParam->tbiPhyAddr             = DEFAULT_tbiPhyAddr;
-    p_DtsecDriverParam->actOnRxPauseFrame      = !DEFAULT_rxIgnorePause;
-    p_DtsecDriverParam->actOnTxPauseFrame      = DEFAULT_actOnTxPauseFrame;
-
-    p_DtsecDriverParam->preambleLength         = DEFAULT_PreAmLength;
-    p_DtsecDriverParam->preambleRxEn           = DEFAULT_PreAmRxEn;
-    p_DtsecDriverParam->preambleTxEn           = DEFAULT_PreAmTxEn;
-    p_DtsecDriverParam->lengthCheckEnable      = DEFAULT_lengthCheckEnable;
-    p_DtsecDriverParam->padAndCrcEnable        = DEFAULT_padAndCrcEnable;
-    p_DtsecDriverParam->crcEnable              = DEFAULT_crcEnable;
-
-    p_DtsecDriverParam->nonBackToBackIpg1      = DEFAULT_nonBackToBackIpg1;
-    p_DtsecDriverParam->nonBackToBackIpg2      = DEFAULT_nonBackToBackIpg2;
-    p_DtsecDriverParam->minIfgEnforcement      = DEFAULT_minIfgEnforcement;
-    p_DtsecDriverParam->backToBackIpg          = DEFAULT_backToBackIpg;
-
-    p_DtsecDriverParam->alternateBackoffVal    = DEFAULT_altBackoffVal;
-    p_DtsecDriverParam->alternateBackoffEnable = DEFAULT_altBackoffEnable;
-    p_DtsecDriverParam->backPressureNoBackoff  = DEFAULT_backPressureNoBackoff;
-    p_DtsecDriverParam->noBackoff              = DEFAULT_noBackoff;
-    p_DtsecDriverParam->excessDefer            = DEFAULT_excessDefer;
-    p_DtsecDriverParam->maxRetransmission      = DEFAULT_maxRetransmission;
-    p_DtsecDriverParam->collisionWindow        = DEFAULT_collisionWindow;
-
-    p_DtsecDriverParam->maxFrameLength         = DEFAULT_maxFrameLength;
-
-    p_DtsecDriverParam->fifoTxThr              = DEFAULT_fifoTxThr;
-    p_DtsecDriverParam->fifoTxWatermarkH       = DEFAULT_fifoTxWatermarkH;
-
-    p_DtsecDriverParam->fifoRxWatermarkL       = DEFAULT_fifoRxWatermarkL;
-}
-
-static void DtsecException(t_Handle h_Dtsec)
-{
-    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    uint32_t            event;
-    t_DtsecMemMap       *p_DtsecMemMap;
-
-    ASSERT_COND(p_Dtsec);
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
-    ASSERT_COND(p_DtsecMemMap);
-
-    event = GET_UINT32(p_DtsecMemMap->ievent);
-    /* handle only MDIO events */
-    event &= (IMASK_MMRDEN | IMASK_MMWREN);
-    if(event)
-    {
-        event &= GET_UINT32(p_DtsecMemMap->imask);
-
-        WRITE_UINT32(p_DtsecMemMap->ievent, event);
-
-        if(event & IMASK_MMRDEN)
-            p_Dtsec->f_Event(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET);
-        if(event & IMASK_MMWREN)
-            p_Dtsec->f_Event(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET);
-    }
-}
 
 static void UpdateStatistics(t_Dtsec *p_Dtsec)
 {
-    t_DtsecMemMap   *p_DtsecMemMap = p_Dtsec->p_MemMap;
-    uint32_t        car1 =  GET_UINT32(p_DtsecMemMap->car1);
-    uint32_t        car2 =  GET_UINT32(p_DtsecMemMap->car2);
+    uint32_t car1, car2;
+
+    dtsec_get_clear_carry_regs(p_Dtsec->p_MemMap, &car1, &car2);
 
-    if(car1)
+    if (car1)
     {
-        WRITE_UINT32(p_DtsecMemMap->car1, car1);
-        if(car1 & CAR1_TR64)
+        if (car1 & CAR1_TR64)
             p_Dtsec->internalStatistics.tr64 += VAL22BIT;
-        if(car1 & CAR1_TR127)
+        if (car1 & CAR1_TR127)
             p_Dtsec->internalStatistics.tr127 += VAL22BIT;
-        if(car1 & CAR1_TR255)
+        if (car1 & CAR1_TR255)
             p_Dtsec->internalStatistics.tr255 += VAL22BIT;
-        if(car1 & CAR1_TR511)
+        if (car1 & CAR1_TR511)
             p_Dtsec->internalStatistics.tr511 += VAL22BIT;
-        if(car1 & CAR1_TRK1)
+        if (car1 & CAR1_TRK1)
             p_Dtsec->internalStatistics.tr1k += VAL22BIT;
-        if(car1 & CAR1_TRMAX)
+        if (car1 & CAR1_TRMAX)
             p_Dtsec->internalStatistics.trmax += VAL22BIT;
-        if(car1 & CAR1_TRMGV)
+        if (car1 & CAR1_TRMGV)
             p_Dtsec->internalStatistics.trmgv += VAL22BIT;
-        if(car1 & CAR1_RBYT)
+        if (car1 & CAR1_RBYT)
             p_Dtsec->internalStatistics.rbyt += (uint64_t)VAL32BIT;
-        if(car1 & CAR1_RPKT)
+        if (car1 & CAR1_RPKT)
             p_Dtsec->internalStatistics.rpkt += VAL22BIT;
-        if(car1 & CAR1_RMCA)
+        if (car1 & CAR1_RMCA)
             p_Dtsec->internalStatistics.rmca += VAL22BIT;
-        if(car1 & CAR1_RBCA)
+        if (car1 & CAR1_RBCA)
             p_Dtsec->internalStatistics.rbca += VAL22BIT;
-        if(car1 & CAR1_RXPF)
+        if (car1 & CAR1_RXPF)
             p_Dtsec->internalStatistics.rxpf += VAL16BIT;
-        if(car1 & CAR1_RALN)
+        if (car1 & CAR1_RALN)
             p_Dtsec->internalStatistics.raln += VAL16BIT;
-        if(car1 & CAR1_RFLR)
+        if (car1 & CAR1_RFLR)
             p_Dtsec->internalStatistics.rflr += VAL16BIT;
-        if(car1 & CAR1_RCDE)
+        if (car1 & CAR1_RCDE)
             p_Dtsec->internalStatistics.rcde += VAL16BIT;
-        if(car1 & CAR1_RCSE)
+        if (car1 & CAR1_RCSE)
             p_Dtsec->internalStatistics.rcse += VAL16BIT;
-        if(car1 & CAR1_RUND)
+        if (car1 & CAR1_RUND)
             p_Dtsec->internalStatistics.rund += VAL16BIT;
-        if(car1 & CAR1_ROVR)
+        if (car1 & CAR1_ROVR)
             p_Dtsec->internalStatistics.rovr += VAL16BIT;
-        if(car1 & CAR1_RFRG)
+        if (car1 & CAR1_RFRG)
             p_Dtsec->internalStatistics.rfrg += VAL16BIT;
-        if(car1 & CAR1_RJBR)
+        if (car1 & CAR1_RJBR)
             p_Dtsec->internalStatistics.rjbr += VAL16BIT;
-        if(car1 & CAR1_RDRP)
+        if (car1 & CAR1_RDRP)
             p_Dtsec->internalStatistics.rdrp += VAL16BIT;
     }
-    if(car2)
+    if (car2)
     {
-        WRITE_UINT32(p_DtsecMemMap->car2, car2);
-        if(car2  & CAR2_TFCS)
+        if (car2  & CAR2_TFCS)
             p_Dtsec->internalStatistics.tfcs += VAL12BIT;
-        if(car2  & CAR2_TBYT)
+        if (car2  & CAR2_TBYT)
             p_Dtsec->internalStatistics.tbyt += (uint64_t)VAL32BIT;
-        if(car2  & CAR2_TPKT)
+        if (car2  & CAR2_TPKT)
             p_Dtsec->internalStatistics.tpkt += VAL22BIT;
-        if(car2  & CAR2_TMCA)
+        if (car2  & CAR2_TMCA)
             p_Dtsec->internalStatistics.tmca += VAL22BIT;
-        if(car2  & CAR2_TBCA)
+        if (car2  & CAR2_TBCA)
             p_Dtsec->internalStatistics.tbca += VAL22BIT;
-        if(car2  & CAR2_TXPF)
+        if (car2  & CAR2_TXPF)
             p_Dtsec->internalStatistics.txpf += VAL16BIT;
-        if(car2  & CAR2_TDRP)
+        if (car2  & CAR2_TDRP)
             p_Dtsec->internalStatistics.tdrp += VAL16BIT;
     }
 }
 
+
 /* .............................................................................. */
 
 static uint16_t DtsecGetMaxFrameLength(t_Handle h_Dtsec)
 {
-    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_VALUE(p_Dtsec, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE, 0);
 
-    return (uint16_t)GET_UINT32(p_Dtsec->p_MemMap->maxfrm);
+    return dtsec_get_max_frame_len(p_Dtsec->p_MemMap);
 }
 
-static void DtsecErrException(t_Handle h_Dtsec)
+/* .............................................................................. */
+
+static void DtsecIsr(t_Handle h_Dtsec)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
     uint32_t            event;
-    t_DtsecMemMap       *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    struct dtsec_regs   *p_DtsecMemMap = p_Dtsec->p_MemMap;
 
-    event = GET_UINT32(p_DtsecMemMap->ievent);
     /* do not handle MDIO events */
-    event &= ~(IMASK_MMRDEN | IMASK_MMWREN);
+    event = dtsec_get_event(p_DtsecMemMap, (uint32_t)(~(DTSEC_IMASK_MMRDEN | DTSEC_IMASK_MMWREN)));
 
-    event &= GET_UINT32(p_DtsecMemMap->imask);
+    event &= dtsec_get_interrupt_mask(p_DtsecMemMap);
 
-    WRITE_UINT32(p_DtsecMemMap->ievent, event);
+    dtsec_ack_event(p_DtsecMemMap, event);
 
-    if(event & IMASK_BREN)
+    if (event & DTSEC_IMASK_BREN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_RX);
-    if(event & IMASK_RXCEN)
+    if (event & DTSEC_IMASK_RXCEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_CTL);
-    if(event & IMASK_MSROEN)
+    if (event & DTSEC_IMASK_MSROEN)
         UpdateStatistics(p_Dtsec);
-    if(event & IMASK_GTSCEN)
+    if (event & DTSEC_IMASK_GTSCEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET);
-    if(event & IMASK_BTEN)
+    if (event & DTSEC_IMASK_BTEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_BAB_TX);
-    if(event & IMASK_TXCEN)
+    if (event & DTSEC_IMASK_TXCEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_CTL);
-    if(event & IMASK_TXEEN)
+    if (event & DTSEC_IMASK_TXEEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_ERR);
-    if(event & IMASK_LCEN)
+    if (event & DTSEC_IMASK_LCEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_LATE_COL);
-    if(event & IMASK_CRLEN)
+    if (event & DTSEC_IMASK_CRLEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_COL_RET_LMT);
-    if(event & IMASK_XFUNEN)
+    if (event & DTSEC_IMASK_XFUNEN)
     {
 #ifdef FM_TX_LOCKUP_ERRATA_DTSEC6
-        if(p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+    if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
         {
             uint32_t  tpkt1, tmpReg1, tpkt2, tmpReg2, i;
             /* a. Write 0x00E0_0C00 to DTSEC_ID */
@@ -324,7 +241,7 @@ static void DtsecErrException(t_Handle h_Dtsec)
             tmpReg1 =  GET_UINT32(*(uint32_t*)((uint8_t*)p_DtsecMemMap + 0x32c));
 
             /* d. Compare bits [9:15] to bits [25:31] of the register at address offset 0x32C. */
-            if((tmpReg1 & 0x007F0000) != (tmpReg1 & 0x0000007F))
+            if ((tmpReg1 & 0x007F0000) != (tmpReg1 & 0x0000007F))
             {
                 /* If they are not equal, save the value of this register and wait for at least
                  * MAXFRM*16 ns */
@@ -341,7 +258,7 @@ static void DtsecErrException(t_Handle h_Dtsec)
                 of bits [9:15] saved in step e. If the two registers values are unchanged, then
                 the transmit portion of the dTSEC controller is locked up and the user should
                 proceed to the recover sequence. */
-            if((tpkt1 == tpkt2) && ((tmpReg1 & 0x007F0000) == (tmpReg2 & 0x007F0000)))
+            if ((tpkt1 == tpkt2) && ((tmpReg1 & 0x007F0000) == (tmpReg2 & 0x007F0000)))
             {
                 /* recover sequence */
 
@@ -350,18 +267,17 @@ static void DtsecErrException(t_Handle h_Dtsec)
                 WRITE_UINT32(p_DtsecMemMap->rctrl, GET_UINT32(p_DtsecMemMap->rctrl) | RCTRL_GRS);
 
                 /* b.Wait until IEVENT[GRSC]=1, or at least 100 us has elapsed. */
-                for(i = 0 ; i < 100 ; i++ )
+                for (i = 0 ; i < 100 ; i++ )
                 {
-                    if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
+                    if (GET_UINT32(p_DtsecMemMap->ievent) & DTSEC_IMASK_GRSCEN)
                         break;
                     XX_UDelay(1);
                 }
-                if(GET_UINT32(p_DtsecMemMap->ievent) & IMASK_GRSCEN)
-                    WRITE_UINT32(p_DtsecMemMap->ievent, IMASK_GRSCEN);
+                if (GET_UINT32(p_DtsecMemMap->ievent) & DTSEC_IMASK_GRSCEN)
+                    WRITE_UINT32(p_DtsecMemMap->ievent, DTSEC_IMASK_GRSCEN);
                 else
                     DBG(INFO,("Rx lockup due to dTSEC Tx lockup"));
 
-
                 /* c.Write a 1 to bit n of FM_RSTC (offset 0x0CC of FPM)*/
                 FmResetMac(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G, p_Dtsec->fmMacControllerDriver.macId);
 
@@ -371,46 +287,67 @@ static void DtsecErrException(t_Handle h_Dtsec)
                 /* e.Write a 0 to bit n of FM_RSTC. */
                 /* cleared by FMAN */
             }
-            else
-            {
+//            else
+//            {
                 /* If either value has changed, the dTSEC controller is not locked up and the
                    controller should be allowed to proceed normally by writing the reset value
                    of 0x0824_0101 to DTSEC_ID. */
                 /* Register is read only */
-            }
+//            }
         }
 #endif /* FM_TX_LOCKUP_ERRATA_DTSEC6 */
 
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_FIFO_UNDRN);
     }
-    if(event & IMASK_MAGEN)
+    if (event & DTSEC_IMASK_MAGEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_MAG_PCKT);
-    if(event & IMASK_GRSCEN)
+    if (event & DTSEC_IMASK_GRSCEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET);
-    if(event & IMASK_TDPEEN)
+    if (event & DTSEC_IMASK_TDPEEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_TX_DATA_ERR);
-    if(event & IMASK_RDPEEN)
+    if (event & DTSEC_IMASK_RDPEEN)
         p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_RX_DATA_ERR);
 
     /*  - masked interrupts */
-    ASSERT_COND(!(event & IMASK_ABRTEN));
-    ASSERT_COND(!(event & IMASK_IFERREN));
+    ASSERT_COND(!(event & DTSEC_IMASK_ABRTEN));
+    ASSERT_COND(!(event & DTSEC_IMASK_IFERREN));
 }
 
-static void Dtsec1588Exception(t_Handle h_Dtsec)
+static void DtsecMdioIsr(t_Handle h_Dtsec)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
     uint32_t            event;
-    t_DtsecMemMap       *p_DtsecMemMap = p_Dtsec->p_MemMap;
+    struct dtsec_regs   *p_DtsecMemMap = p_Dtsec->p_MemMap;
+
+    event = GET_UINT32(p_DtsecMemMap->ievent);
+    /* handle only MDIO events */
+    event &= (DTSEC_IMASK_MMRDEN | DTSEC_IMASK_MMWREN);
+    if (event)
+    {
+        event &= GET_UINT32(p_DtsecMemMap->imask);
+
+        WRITE_UINT32(p_DtsecMemMap->ievent, event);
+
+        if (event & DTSEC_IMASK_MMRDEN)
+            p_Dtsec->f_Event(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET);
+        if (event & DTSEC_IMASK_MMWREN)
+            p_Dtsec->f_Event(p_Dtsec->h_App, e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET);
+    }
+}
+
+static void Dtsec1588Isr(t_Handle h_Dtsec)
+{
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t            event;
+    struct dtsec_regs   *p_DtsecMemMap = p_Dtsec->p_MemMap;
 
     if (p_Dtsec->ptpTsuEnabled)
     {
-        event = GET_UINT32(p_DtsecMemMap->tmr_pevent);
-        event &= GET_UINT32(p_DtsecMemMap->tmr_pemask);
-        if(event)
+        event = dtsec_check_and_clear_tmr_event(p_DtsecMemMap);
+
+        if (event)
         {
-            WRITE_UINT32(p_DtsecMemMap->tmr_pevent, event);
-            ASSERT_COND(event & PEMASK_TSRE);
+            ASSERT_COND(event & TMR_PEVENT_TSRE);
             p_Dtsec->f_Exception(p_Dtsec->h_App, e_FM_MAC_EX_1G_1588_TS_RX_ERR);
         }
     }
@@ -426,7 +363,6 @@ static void FreeInitResources(t_Dtsec *p_Dtsec)
         XX_DisableIntr(p_Dtsec->mdioIrq);
         XX_FreeIntr(p_Dtsec->mdioIrq);
     }
-
     FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_ERR);
     FmUnregisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Dtsec->macId, e_FM_INTR_TYPE_NORMAL);
 
@@ -441,44 +377,18 @@ static void FreeInitResources(t_Dtsec *p_Dtsec)
 
 /* ........................................................................... */
 
-static void HardwareClearAddrInPaddr(t_Dtsec *p_Dtsec, uint8_t paddrNum)
-{
-    WRITE_UINT32(((t_DtsecMemMap*)p_Dtsec->p_MemMap)->macaddr[paddrNum].exact_match1, 0x0);
-    WRITE_UINT32(((t_DtsecMemMap*)p_Dtsec->p_MemMap)->macaddr[paddrNum].exact_match2, 0x0);
-}
-
-/* ........................................................................... */
-
-static void HardwareAddAddrInPaddr(t_Dtsec *p_Dtsec, uint64_t *p_Addr, uint8_t paddrNum)
-{
-    uint32_t        tmpReg32        = 0;
-    uint64_t        addr            = *p_Addr;
-    t_DtsecMemMap   *p_DtsecMemMap  = (t_DtsecMemMap*)p_Dtsec->p_MemMap;
-
-    tmpReg32 = (uint32_t)(addr);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_DtsecMemMap->macaddr[paddrNum].exact_match1, tmpReg32);
-
-    tmpReg32 = (uint32_t)(addr>>32);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_DtsecMemMap->macaddr[paddrNum].exact_match2, tmpReg32);
-}
-
-/* ........................................................................... */
-
 static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
 {
-    t_DtsecMemMap   *p_MemMap;
+    struct dtsec_regs *p_MemMap;
 
     ASSERT_COND(p_Dtsec);
 
-    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    p_MemMap = p_Dtsec->p_MemMap;
     ASSERT_COND(p_MemMap);
 
     /* Assert the graceful transmit stop bit */
     if (mode & e_COMM_MODE_RX)
-        WRITE_UINT32(p_MemMap->rctrl,
-                     GET_UINT32(p_MemMap->rctrl) | RCTRL_GRS);
+        dtsec_stop_rx(p_MemMap);
 
 #ifdef FM_GRS_ERRATA_DTSEC_A002
     if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
@@ -495,8 +405,7 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
         (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 5))
         DBG(INFO, ("GTS not supported due to DTSEC_A0014 errata."));
 #else  /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
-        WRITE_UINT32(p_MemMap->tctrl,
-                     GET_UINT32(p_MemMap->tctrl) | TCTRL_GTS);
+        dtsec_stop_tx(p_MemMap);
 #endif /* FM_GTS_UNDERRUN_ERRATA_DTSEC_A0014 */
 #endif /* defined(FM_GTS_ERRATA_DTSEC_A004) ||...  */
 
@@ -507,21 +416,18 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
 
 static t_Error GracefulRestart(t_Dtsec *p_Dtsec, e_CommMode mode)
 {
-    t_DtsecMemMap   *p_MemMap;
+    struct dtsec_regs *p_MemMap;
 
     ASSERT_COND(p_Dtsec);
-
-    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    p_MemMap = p_Dtsec->p_MemMap;
     ASSERT_COND(p_MemMap);
 
     /* clear the graceful receive stop bit */
-    if(mode & e_COMM_MODE_TX)
-        WRITE_UINT32(p_MemMap->tctrl,
-                      GET_UINT32(p_MemMap->tctrl) & ~TCTRL_GTS);
+    if (mode & e_COMM_MODE_TX)
+        dtsec_start_tx(p_MemMap);
 
-    if(mode & e_COMM_MODE_RX)
-        WRITE_UINT32(p_MemMap->rctrl,
-                      GET_UINT32(p_MemMap->rctrl) & ~RCTRL_GRS);
+    if (mode & e_COMM_MODE_RX)
+        dtsec_start_rx(p_MemMap);
 
     return E_OK;
 }
@@ -556,7 +462,7 @@ static t_Error DtsecConfigMaxFrameLength(t_Handle h_Dtsec, uint16_t newVal)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    p_Dtsec->p_DtsecDriverParam->maxFrameLength = newVal;
+    p_Dtsec->p_DtsecDriverParam->maximum_frame = newVal;
 
     return E_OK;
 }
@@ -570,7 +476,7 @@ static t_Error DtsecConfigPadAndCrc(t_Handle h_Dtsec, bool newVal)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    p_Dtsec->p_DtsecDriverParam->padAndCrcEnable = newVal;
+    p_Dtsec->p_DtsecDriverParam->tx_pad_crc = newVal;
 
     return E_OK;
 }
@@ -584,7 +490,7 @@ static t_Error DtsecConfigHalfDuplex(t_Handle h_Dtsec, bool newVal)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    p_Dtsec->p_DtsecDriverParam->halfDuplex = newVal;
+    p_Dtsec->p_DtsecDriverParam->halfdup_on = newVal;
 
     return E_OK;
 }
@@ -598,7 +504,7 @@ static t_Error DtsecConfigTbiPhyAddr(t_Handle h_Dtsec, uint8_t newVal)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    p_Dtsec->p_DtsecDriverParam->tbiPhyAddr = newVal;
+    p_Dtsec->p_DtsecDriverParam->tbi_phy_addr = newVal;
 
     return E_OK;
 }
@@ -612,7 +518,7 @@ static t_Error DtsecConfigLengthCheck(t_Handle h_Dtsec, bool newVal)
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    p_Dtsec->p_DtsecDriverParam->lengthCheckEnable = newVal;
+    p_Dtsec->p_DtsecDriverParam->rx_len_check = newVal;
 
     return E_OK;
 }
@@ -625,10 +531,10 @@ static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exceptio
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    if(exception != e_FM_MAC_EX_1G_1588_TS_RX_ERR)
+    if (exception != e_FM_MAC_EX_1G_1588_TS_RX_ERR)
     {
         GET_EXCEPTION_FLAG(bitMask, exception);
-        if(bitMask)
+        if (bitMask)
         {
             if (enable)
                 p_Dtsec->exceptions |= bitMask;
@@ -640,11 +546,11 @@ static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exceptio
     }
     else
     {
-        if(!p_Dtsec->ptpTsuEnabled)
+        if (!p_Dtsec->ptpTsuEnabled)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
-        switch(exception){
-        case(e_FM_MAC_EX_1G_1588_TS_RX_ERR):
-            if(enable)
+        switch (exception){
+        case (e_FM_MAC_EX_1G_1588_TS_RX_ERR):
+            if (enable)
                 p_Dtsec->enTsuErrExeption = TRUE;
             else
                 p_Dtsec->enTsuErrExeption = FALSE;
@@ -663,21 +569,14 @@ static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exceptio
 
 static t_Error DtsecEnable(t_Handle h_Dtsec,  e_CommMode mode)
 {
-    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap       *p_MemMap ;
-    uint32_t            tmpReg32 = 0;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
-
-    p_MemMap= (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
-    if (mode & e_COMM_MODE_RX)
-        tmpReg32 |= MACCFG1_RX_EN;
-    if (mode & e_COMM_MODE_TX)
-        tmpReg32 |= MACCFG1_TX_EN;
-    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+    dtsec_enable(p_Dtsec->p_MemMap,
+                 (bool)!!(mode & e_COMM_MODE_RX),
+                 (bool)!!(mode & e_COMM_MODE_TX));
 
     GracefulRestart(p_Dtsec, mode);
 
@@ -688,23 +587,16 @@ static t_Error DtsecEnable(t_Handle h_Dtsec,  e_CommMode mode)
 
 static t_Error DtsecDisable (t_Handle h_Dtsec, e_CommMode mode)
 {
-    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap       *p_MemMap ;
-    uint32_t            tmpReg32 = 0;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_HANDLE);
-
-    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     GracefulStop(p_Dtsec, mode);
 
-    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
-    if (mode & e_COMM_MODE_RX)
-        tmpReg32 &= ~MACCFG1_RX_EN;
-    if (mode & e_COMM_MODE_TX)
-        tmpReg32 &= ~MACCFG1_TX_EN;
-    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+    dtsec_disable(p_Dtsec->p_MemMap,
+                  (bool)!!(mode & e_COMM_MODE_RX),
+                  (bool)!!(mode & e_COMM_MODE_TX));
 
     return E_OK;
 }
@@ -716,47 +608,28 @@ static t_Error DtsecSetTxPauseFrames(t_Handle h_Dtsec,
                                      uint16_t pauseTime,
                                      uint16_t threshTime)
 {
-    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap   *p_MemMap;
-    uint32_t        ptv = 0;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
-UNUSED(priority);UNUSED(threshTime);
+    UNUSED(priority);UNUSED(threshTime);
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
 
-    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
-
-    if (pauseTime)
-    {
 #ifdef FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003
-        if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
-            if (pauseTime <= 320)
-                RETURN_ERROR(MINOR, E_INVALID_VALUE,
-                             ("This pause-time value of %d is illegal due to errata dTSEC-A003!"
-                              " value should be greater than 320."));
+    if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+        if (pauseTime <= 320)
+            RETURN_ERROR(MINOR, E_INVALID_VALUE,
+                     ("This pause-time value of %d is illegal due to errata dTSEC-A003!"
+                      " value should be greater than 320."));
 #endif /* FM_BAD_TX_TS_IN_B_2_B_ERRATA_DTSEC_A003 */
 
-        ptv = GET_UINT32(p_MemMap->ptv);
-        ptv |= pauseTime;
-        WRITE_UINT32(p_MemMap->ptv, ptv);
-
-        /* trigger the transmission of a flow-control pause frame */
-        WRITE_UINT32(p_MemMap->maccfg1,
-                     GET_UINT32(p_MemMap->maccfg1) | MACCFG1_TX_FLOW);
-    }
-    else
-        WRITE_UINT32(p_MemMap->maccfg1,
-                     GET_UINT32(p_MemMap->maccfg1) & ~MACCFG1_TX_FLOW);
-
+    dtsec_set_tx_pause_time(p_Dtsec->p_MemMap, pauseTime);
     return E_OK;
 }
 
 /* .............................................................................. */
-
-static t_Error DtsecSetTxAutoPauseFrames(t_Handle h_Dtsec,
-                                         uint16_t pauseTime)
+/* backward compatibility. will be removed in the future. */
+static t_Error DtsecTxMacPause(t_Handle h_Dtsec, uint16_t pauseTime)
 {
     return DtsecSetTxPauseFrames(h_Dtsec, 0, pauseTime, 0);
 }
@@ -766,21 +639,12 @@ static t_Error DtsecSetTxAutoPauseFrames(t_Handle h_Dtsec,
 static t_Error DtsecRxIgnoreMacPause(t_Handle h_Dtsec, bool en)
 {
     t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap   *p_MemMap;
-    uint32_t        tmpReg32;
+    bool            accept_pause = !en;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
-
-    p_MemMap = (t_DtsecMemMap*)(p_Dtsec->p_MemMap);
 
-    tmpReg32 = GET_UINT32(p_MemMap->maccfg1);
-    if (en)
-        tmpReg32 &= ~MACCFG1_RX_FLOW;
-    else
-        tmpReg32 |= MACCFG1_RX_FLOW;
-    WRITE_UINT32(p_MemMap->maccfg1, tmpReg32);
+    dtsec_handle_rx_pause(p_Dtsec->p_MemMap, accept_pause);
 
     return E_OK;
 }
@@ -790,27 +654,26 @@ static t_Error DtsecRxIgnoreMacPause(t_Handle h_Dtsec, bool en)
 
 static t_Error DtsecEnable1588TimeStamp(t_Handle h_Dtsec)
 {
-    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
     p_Dtsec->ptpTsuEnabled = TRUE;
-    WRITE_UINT32(p_Dtsec->p_MemMap->rctrl, GET_UINT32(p_Dtsec->p_MemMap->rctrl) | RCTRL_RTSE);
-    WRITE_UINT32(p_Dtsec->p_MemMap->tctrl, GET_UINT32(p_Dtsec->p_MemMap->tctrl) | TCTRL_TTSE);
+    dtsec_set_ts(p_Dtsec->p_MemMap, TRUE);
 
     return E_OK;
 }
 
 static t_Error DtsecDisable1588TimeStamp(t_Handle h_Dtsec)
 {
-    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     p_Dtsec->ptpTsuEnabled = FALSE;
-    WRITE_UINT32(p_Dtsec->p_MemMap->rctrl, GET_UINT32(p_Dtsec->p_MemMap->rctrl) & ~RCTRL_RTSE);
-    WRITE_UINT32(p_Dtsec->p_MemMap->tctrl, GET_UINT32(p_Dtsec->p_MemMap->tctrl) & ~TCTRL_TTSE);
+    dtsec_set_ts(p_Dtsec->p_MemMap, FALSE);
 
     return E_OK;
 }
@@ -820,89 +683,82 @@ static t_Error DtsecDisable1588TimeStamp(t_Handle h_Dtsec)
 static t_Error DtsecGetStatistics(t_Handle h_Dtsec, t_FmMacStatistics *p_Statistics)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap       *p_DtsecMemMap;
+    struct dtsec_regs   *p_DtsecMemMap;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
 
+    p_DtsecMemMap = p_Dtsec->p_MemMap;
+
     if (p_Dtsec->statisticsLevel == e_FM_MAC_NONE_STATISTICS)
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Statistics disabled"));
 
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
     memset(p_Statistics, 0xff, sizeof(t_FmMacStatistics));
 
     if (p_Dtsec->statisticsLevel == e_FM_MAC_FULL_STATISTICS)
     {
-        p_Statistics->eStatPkts64           = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr64))
-                                                + p_Dtsec->internalStatistics.tr64;      /**< r-10G tr-DT 64 byte frame counter */
-        p_Statistics->eStatPkts65to127      = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr127))
-                                                + p_Dtsec->internalStatistics.tr127;     /**< r-10G 65 to 127 byte frame counter */
-        p_Statistics->eStatPkts128to255     = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr255))
-                                                + p_Dtsec->internalStatistics.tr255;     /**< r-10G 128 to 255 byte frame counter */
-        p_Statistics->eStatPkts256to511     = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr511))
-                                                + p_Dtsec->internalStatistics.tr511;     /**< r-10G 256 to 511 byte frame counter */
-        p_Statistics->eStatPkts512to1023    = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tr1k))
-                                                + p_Dtsec->internalStatistics.tr1k;      /**< r-10G 512 to 1023 byte frame counter */
-        p_Statistics->eStatPkts1024to1518   = (MASK22BIT & GET_UINT32(p_DtsecMemMap->trmax))
-                                                + p_Dtsec->internalStatistics.trmax;     /**< r-10G 1024 to 1518 byte frame counter */
-        p_Statistics->eStatPkts1519to1522   = (MASK22BIT & GET_UINT32(p_DtsecMemMap->trmgv))
-                                                + p_Dtsec->internalStatistics.trmgv;     /**< r-10G 1519 to 1522 byte good frame count */
+        p_Statistics->eStatPkts64 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR64)
+                + p_Dtsec->internalStatistics.tr64;
+        p_Statistics->eStatPkts65to127 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR127)
+                + p_Dtsec->internalStatistics.tr127;
+        p_Statistics->eStatPkts128to255 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR255)
+                + p_Dtsec->internalStatistics.tr255;
+        p_Statistics->eStatPkts256to511 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR511)
+                + p_Dtsec->internalStatistics.tr511;
+        p_Statistics->eStatPkts512to1023 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TR1K)
+                + p_Dtsec->internalStatistics.tr1k;
+        p_Statistics->eStatPkts1024to1518 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TRMAX)
+                + p_Dtsec->internalStatistics.trmax;
+        p_Statistics->eStatPkts1519to1522 = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TRMGV)
+                + p_Dtsec->internalStatistics.trmgv;
+
         /* MIB II */
-        p_Statistics->ifInOctets            = GET_UINT32(p_DtsecMemMap->rbyt)
-                                                + p_Dtsec->internalStatistics.rbyt;                  /**< Total number of byte received. */
-        p_Statistics->ifInPkts              = (MASK22BIT & GET_UINT32(p_DtsecMemMap->rpkt))
-                                                + p_Dtsec->internalStatistics.rpkt;    /**< Total number of packets received.*/
-        p_Statistics->ifInMcastPkts         = (MASK22BIT & GET_UINT32(p_DtsecMemMap->rmca))
-                                                + p_Dtsec->internalStatistics.rmca;    /**< Total number of multicast frame received*/
-        p_Statistics->ifInBcastPkts         = (MASK22BIT & GET_UINT32(p_DtsecMemMap->rbca))
-                                                + p_Dtsec->internalStatistics.rbca;    /**< Total number of broadcast frame received */
-        p_Statistics->ifOutOctets           = GET_UINT32(p_DtsecMemMap->tbyt)
-                                                + p_Dtsec->internalStatistics.tbyt;                  /**< Total number of byte sent. */
-        p_Statistics->ifOutPkts             = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tpkt))
-                                                + p_Dtsec->internalStatistics.tpkt;    /**< Total number of packets sent .*/
-        p_Statistics->ifOutMcastPkts        = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tmca))
-                                                + p_Dtsec->internalStatistics.tmca;    /**< Total number of multicast frame sent */
-        p_Statistics->ifOutBcastPkts        = (MASK22BIT & GET_UINT32(p_DtsecMemMap->tbca))
-                                                + p_Dtsec->internalStatistics.tbca;    /**< Total number of multicast frame sent */
+        p_Statistics->ifInOctets = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RBYT)
+                + p_Dtsec->internalStatistics.rbyt;
+        p_Statistics->ifInPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RPKT)
+                + p_Dtsec->internalStatistics.rpkt;
+        p_Statistics->ifInMcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RMCA)
+                + p_Dtsec->internalStatistics.rmca;
+        p_Statistics->ifInBcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RBCA)
+                + p_Dtsec->internalStatistics.rbca;
+        p_Statistics->ifOutOctets = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TBYT)
+                + p_Dtsec->internalStatistics.tbyt;
+        p_Statistics->ifOutPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TPKT)
+                + p_Dtsec->internalStatistics.tpkt;
+        p_Statistics->ifOutMcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TMCA)
+                + p_Dtsec->internalStatistics.tmca;
+        p_Statistics->ifOutBcastPkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TBCA)
+                + p_Dtsec->internalStatistics.tbca;
     }
-/* */
-    p_Statistics->eStatFragments        = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rfrg))
-                                            + p_Dtsec->internalStatistics.rfrg;      /**< Total number of packets that were less than 64 octets long with a wrong CRC.*/
-    p_Statistics->eStatJabbers          = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rjbr))
-                                            + p_Dtsec->internalStatistics.rjbr;      /**< Total number of packets longer than valid maximum length octets */
-
-    p_Statistics->eStatsDropEvents      = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rdrp))
-                                            + p_Dtsec->internalStatistics.rdrp;      /**< number of dropped packets due to internal errors of the MAC Client. */
-    p_Statistics->eStatCRCAlignErrors   = (MASK16BIT & GET_UINT32(p_DtsecMemMap->raln))
-                                            + p_Dtsec->internalStatistics.raln;      /**< Incremented when frames of correct length but with CRC error are received.*/
-
-    p_Statistics->eStatUndersizePkts    = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rund))
-                                            + p_Dtsec->internalStatistics.rund;      /**< Total number of packets that were less than 64 octets long with a good CRC.*/
-    p_Statistics->eStatOversizePkts     = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rovr))
-                                            + p_Dtsec->internalStatistics.rovr;      /**< T,B.D*/
-/* Pause */
-    p_Statistics->reStatPause           = (MASK16BIT & GET_UINT32(p_DtsecMemMap->rxpf))
-                                            + p_Dtsec->internalStatistics.rxpf;      /**< Pause MAC Control received */
-    p_Statistics->teStatPause           = (MASK16BIT & GET_UINT32(p_DtsecMemMap->txpf))
-                                            + p_Dtsec->internalStatistics.txpf;      /**< Pause MAC Control sent */
-
-    p_Statistics->ifInDiscards          = p_Statistics->eStatsDropEvents;                    /**< Frames received, but discarded due to problems within the MAC RX. */
-
-    p_Statistics->ifInErrors            = p_Statistics->eStatsDropEvents
-                                        + p_Statistics->eStatCRCAlignErrors
-                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rflr))
-                                        + p_Dtsec->internalStatistics.rflr
-                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rcde))
-                                        + p_Dtsec->internalStatistics.rcde
-                                        + (MASK16BIT & GET_UINT32(p_DtsecMemMap->rcse))
-                                        + p_Dtsec->internalStatistics.rcse;
-
-    p_Statistics->ifOutDiscards         = (MASK16BIT & GET_UINT32(p_DtsecMemMap->tdrp))
-                                            + p_Dtsec->internalStatistics.tdrp;     /**< Frames received, but discarded due to problems within the MAC TX N/A!.*/
-    p_Statistics->ifOutErrors           = p_Statistics->ifOutDiscards                                           /**< Number of frames transmitted with error: */
-                                        + (MASK12BIT & GET_UINT32(p_DtsecMemMap->tfcs))
-                                        + p_Dtsec->internalStatistics.tfcs;
+
+    p_Statistics->eStatFragments = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RFRG)
+            + p_Dtsec->internalStatistics.rfrg;
+    p_Statistics->eStatJabbers = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RJBR)
+            + p_Dtsec->internalStatistics.rjbr;
+    p_Statistics->eStatsDropEvents = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RDRP)
+            + p_Dtsec->internalStatistics.rdrp;
+    p_Statistics->eStatCRCAlignErrors = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RALN)
+            + p_Dtsec->internalStatistics.raln;
+    p_Statistics->eStatUndersizePkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RUND)
+            + p_Dtsec->internalStatistics.rund;
+    p_Statistics->eStatOversizePkts = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_ROVR)
+            + p_Dtsec->internalStatistics.rovr;
+    p_Statistics->reStatPause = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_RXPF)
+            + p_Dtsec->internalStatistics.rxpf;
+    p_Statistics->teStatPause = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TXPF)
+            + p_Dtsec->internalStatistics.txpf;
+    p_Statistics->ifInDiscards = p_Statistics->eStatsDropEvents;
+    p_Statistics->ifInErrors = p_Statistics->eStatsDropEvents + p_Statistics->eStatCRCAlignErrors
+            + dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_RFLR) + p_Dtsec->internalStatistics.rflr
+            + dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_RCDE) + p_Dtsec->internalStatistics.rcde
+            + dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_RCSE) + p_Dtsec->internalStatistics.rcse;
+
+    p_Statistics->ifOutDiscards = dtsec_get_stat_counter(p_DtsecMemMap, E_DTSEC_STAT_TDRP)
+            + p_Dtsec->internalStatistics.tdrp;
+    p_Statistics->ifOutErrors = p_Statistics->ifOutDiscards                                           /**< Number of frames transmitted with error: */
+            + dtsec_get_stat_counter(p_DtsecMemMap,E_DTSEC_STAT_TFCS)
+            + p_Dtsec->internalStatistics.tfcs;
 
     return E_OK;
 }
@@ -911,27 +767,15 @@ static t_Error DtsecGetStatistics(t_Handle h_Dtsec, t_FmMacStatistics *p_Statist
 
 static t_Error DtsecModifyMacAddress (t_Handle h_Dtsec, t_EnetAddr *p_EnetAddr)
 {
-    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap        *p_DtsecMemMap;
-    uint32_t              tmpReg32 = 0;
-    uint64_t              addr;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
     /* Initialize MAC Station Address registers (1 & 2)    */
     /* Station address have to be swapped (big endian to little endian */
-    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
-    p_Dtsec->addr = addr;
-
-    tmpReg32 = (uint32_t)(addr);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_DtsecMemMap->macstnaddr1, tmpReg32);
-
-    tmpReg32 = (uint32_t)(addr>>32);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_DtsecMemMap->macstnaddr2, tmpReg32);
+    p_Dtsec->addr = ENET_ADDR_TO_UINT64(*p_EnetAddr);
+    dtsec_set_mac_address(p_Dtsec->p_MemMap, (uint8_t *)(*p_EnetAddr));
 
     return E_OK;
 }
@@ -940,15 +784,16 @@ static t_Error DtsecModifyMacAddress (t_Handle h_Dtsec, t_EnetAddr *p_EnetAddr)
 
 static t_Error DtsecResetCounters (t_Handle h_Dtsec)
 {
-    t_Dtsec          *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     /* clear HW counters */
-    WRITE_UINT32(p_Dtsec->p_MemMap->ecntrl, GET_UINT32(p_Dtsec->p_MemMap->ecntrl) | ECNTRL_CLRCNT);
+    dtsec_reset_stat(p_Dtsec->p_MemMap);
 
     /* clear SW counters holding carries */
-    memset((char *)&p_Dtsec->internalStatistics, (char)0x0, sizeof(t_InternalStatistics));
+    memset(&p_Dtsec->internalStatistics, 0, sizeof(t_InternalStatistics));
 
     return E_OK;
 }
@@ -962,8 +807,9 @@ static t_Error DtsecAddExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthA
     uint8_t   paddrNum;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
     if (ethAddr & GROUP_ADDRESS)
         /* Multicast address has no effect in PADDR */
@@ -985,7 +831,7 @@ static t_Error DtsecAddExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthA
             p_Dtsec->paddr[paddrNum] = ethAddr;
 
             /* put in hardware */
-            HardwareAddAddrInPaddr(p_Dtsec, &ethAddr, paddrNum);
+            dtsec_add_addr_in_paddr(p_Dtsec->p_MemMap, (uint64_t)PTR_TO_UINT(&ethAddr), paddrNum);
             p_Dtsec->numOfIndAddrInRegs++;
 
             return E_OK;
@@ -1004,8 +850,9 @@ static t_Error DtsecDelExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthA
     uint8_t   paddrNum;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
     /* Find used PADDR containing this address */
     for (paddrNum = 0; paddrNum < DTSEC_NUM_OF_PADDRS; paddrNum++)
@@ -1016,7 +863,7 @@ static t_Error DtsecDelExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthA
             /* mark this PADDR as not used */
             p_Dtsec->indAddrRegUsed[paddrNum] = FALSE;
             /* clear in hardware */
-            HardwareClearAddrInPaddr(p_Dtsec, paddrNum);
+            dtsec_clear_addr_in_paddr(p_Dtsec->p_MemMap, paddrNum);
             p_Dtsec->numOfIndAddrInRegs--;
 
             return E_OK;
@@ -1031,51 +878,34 @@ static t_Error DtsecDelExactMatchMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthA
 static t_Error DtsecAddHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
 {
     t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap   *p_DtsecMemMap;
-    uint32_t        crc;
-    uint8_t         crcMirror, reg;
-    uint32_t        bitMask;
     t_EthHashEntry  *p_HashEntry;
     uint64_t        ethAddr;
+    int32_t         bucket;
+    t_Error         err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
-
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
-
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    /* CRC calculation */
-    GET_MAC_ADDR_CRC(ethAddr, crc);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
-    /* calculate the "crc mirror" */
-    crcMirror = MIRROR((uint8_t)crc);
+    err = (t_Error)dtsec_compute_bucket(p_Dtsec->p_MemMap,
+                                        (uint8_t*)(*p_EthAddr),
+                                        &bucket);
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, ("Could not compute hash bucket"));
 
-    /* 3 MSB bits define the register */
-    reg = (uint8_t)(crcMirror >> 5);
-    /* 5 LSB bits define the bit within the register */
-    bitMask =  0x80000000 >> (crcMirror & 0x1f);
+    dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, TRUE);
 
     /* Create element to be added to the driver hash table */
     p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
     p_HashEntry->addr = ethAddr;
     INIT_LIST(&p_HashEntry->node);
 
-    if (ethAddr & GROUP_ADDRESS)
-    {
+    if (ethAddr & MAC_GROUP_ADDRESS)
         /* Group Address */
-        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]));
-        /* Set the appropriate bit in GADDR0-7 */
-        WRITE_UINT32(p_DtsecMemMap->gaddr[reg],
-                     GET_UINT32(p_DtsecMemMap->gaddr[reg]) | bitMask);
-    }
+        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_MulticastAddrHash->p_Lsts[bucket]));
     else
-    {
-        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]));
-        /* Set the appropriate bit in IADDR0-7 */
-        WRITE_UINT32(p_DtsecMemMap->igaddr[reg],
-                     GET_UINT32(p_DtsecMemMap->igaddr[reg]) | bitMask);
-    }
+        LIST_AddToTail(&(p_HashEntry->node), &(p_Dtsec->p_UnicastAddrHash->p_Lsts[bucket]));
 
     return E_OK;
 }
@@ -1085,65 +915,54 @@ static t_Error DtsecAddHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
 static t_Error DtsecDelHashMacAddress(t_Handle h_Dtsec, t_EnetAddr *p_EthAddr)
 {
     t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap   *p_DtsecMemMap;
     t_List          *p_Pos;
-    uint32_t        crc;
-    uint8_t         crcMirror, reg;
-    uint32_t        bitMask;
     t_EthHashEntry  *p_HashEntry = NULL;
     uint64_t        ethAddr;
+    int32_t         bucket;
+    t_Error         err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
-
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
-
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
-
-    /* CRC calculation */
-    GET_MAC_ADDR_CRC(ethAddr, crc);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    /* calculate the "crc mirror" */
-    crcMirror = MIRROR((uint8_t)crc);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
-    /* 3 MSB bits define the register */
-    reg =(uint8_t)( crcMirror >> 5);
-    /* 5 LSB bits define the bit within the register */
-    bitMask =  0x80000000 >> (crcMirror & 0x1f);
+    err = (t_Error)dtsec_compute_bucket(p_Dtsec->p_MemMap,
+                                        (uint8_t*)(*p_EthAddr),
+                                        &bucket);
+    if (err != E_OK)
+        RETURN_ERROR(MAJOR, err, ("Could not compute hash bucket"));
 
-    if (ethAddr & GROUP_ADDRESS)
+    if (ethAddr & MAC_GROUP_ADDRESS)
     {
         /* Group Address */
-        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]))
+        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_MulticastAddrHash->p_Lsts[bucket]))
         {
             p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
-            if(p_HashEntry->addr == ethAddr)
+            if (p_HashEntry->addr == ethAddr)
             {
                 LIST_DelAndInit(&p_HashEntry->node);
                 XX_Free(p_HashEntry);
                 break;
             }
         }
-        if(LIST_IsEmpty(&p_Dtsec->p_MulticastAddrHash->p_Lsts[crcMirror]))
-            WRITE_UINT32(p_DtsecMemMap->gaddr[reg],
-                         GET_UINT32(p_DtsecMemMap->gaddr[reg]) & ~bitMask);
+        if (LIST_IsEmpty(&p_Dtsec->p_MulticastAddrHash->p_Lsts[bucket]))
+            dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, FALSE);
     }
     else
     {
         /* Individual Address */
-        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]))
+        LIST_FOR_EACH(p_Pos, &(p_Dtsec->p_UnicastAddrHash->p_Lsts[bucket]))
         {
             p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
-            if(p_HashEntry->addr == ethAddr)
+            if (p_HashEntry->addr == ethAddr)
             {
                 LIST_DelAndInit(&p_HashEntry->node);
                 XX_Free(p_HashEntry);
                 break;
             }
         }
-        if(LIST_IsEmpty(&p_Dtsec->p_UnicastAddrHash->p_Lsts[crcMirror]))
-            WRITE_UINT32(p_DtsecMemMap->igaddr[reg],
-                         GET_UINT32(p_DtsecMemMap->igaddr[reg]) & ~bitMask);
+        if (LIST_IsEmpty(&p_Dtsec->p_UnicastAddrHash->p_Lsts[bucket]))
+            dtsec_set_bucket(p_Dtsec->p_MemMap, bucket, FALSE);
     }
 
     /* address does not exist */
@@ -1159,7 +978,7 @@ void DtsecRestartTbiAN(t_Handle h_Dtsec)
     if (!p_Dtsec)
 	return;
 
-    DTSEC_MII_WritePhyReg(p_Dtsec, DEFAULT_tbiPhyAddr, 0,
+    DTSEC_MII_WritePhyReg(p_Dtsec, p_Dtsec->tbi_phy_addr, 0,
 		PHY_CR_ANE | PHY_CR_RESET_AN | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
 }
 
@@ -1167,24 +986,13 @@ void DtsecRestartTbiAN(t_Handle h_Dtsec)
 
 static t_Error DtsecSetPromiscuous(t_Handle h_Dtsec, bool newVal)
 {
-    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap   *p_DtsecMemMap;
-    uint32_t        tmpReg32;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
-
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
-
-    tmpReg32 = GET_UINT32(p_DtsecMemMap->rctrl);
-
-    if (newVal)
-        tmpReg32 |= RCTRL_PROM;
-    else
-        tmpReg32 &= ~RCTRL_PROM;
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
+    dtsec_set_uc_promisc(p_Dtsec->p_MemMap, newVal);
+    dtsec_set_mc_promisc(p_Dtsec->p_MemMap, newVal);
 
     return E_OK;
 }
@@ -1193,38 +1001,29 @@ static t_Error DtsecSetPromiscuous(t_Handle h_Dtsec, bool newVal)
 
 static t_Error DtsecSetStatistics(t_Handle h_Dtsec, e_FmMacStatisticsLevel statisticsLevel)
 {
-    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap   *p_DtsecMemMap;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_Error     err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
-
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     p_Dtsec->statisticsLevel = statisticsLevel;
 
-    switch (p_Dtsec->statisticsLevel)
+    err = (t_Error)dtsec_set_stat_level(p_Dtsec->p_MemMap,
+                                        (enum mac_stat_level)statisticsLevel);
+    if (err != E_OK)
+        return err;
+
+    switch (statisticsLevel)
     {
-        case(e_FM_MAC_NONE_STATISTICS):
-            WRITE_UINT32(p_DtsecMemMap->cam1,0xffffffff);
-            WRITE_UINT32(p_DtsecMemMap->cam2,0xffffffff);
-            WRITE_UINT32(p_DtsecMemMap->ecntrl, GET_UINT32(p_DtsecMemMap->ecntrl) & ~ECNTRL_STEN);
-            WRITE_UINT32(p_DtsecMemMap->imask, GET_UINT32(p_DtsecMemMap->imask) & ~IMASK_MSROEN);
-            p_Dtsec->exceptions &= ~IMASK_MSROEN;
+    case (e_FM_MAC_NONE_STATISTICS):
+            p_Dtsec->exceptions &= ~DTSEC_IMASK_MSROEN;
             break;
-        case(e_FM_MAC_PARTIAL_STATISTICS):
-            WRITE_UINT32(p_DtsecMemMap->cam1, CAM1_ERRORS_ONLY);
-            WRITE_UINT32(p_DtsecMemMap->cam2, CAM2_ERRORS_ONLY);
-            WRITE_UINT32(p_DtsecMemMap->ecntrl, GET_UINT32(p_DtsecMemMap->ecntrl) | ECNTRL_STEN);
-            WRITE_UINT32(p_DtsecMemMap->imask, GET_UINT32(p_DtsecMemMap->imask) | IMASK_MSROEN);
-            p_Dtsec->exceptions |= IMASK_MSROEN;
+    case (e_FM_MAC_PARTIAL_STATISTICS):
+            p_Dtsec->exceptions |= DTSEC_IMASK_MSROEN;
             break;
-        case(e_FM_MAC_FULL_STATISTICS):
-            WRITE_UINT32(p_DtsecMemMap->cam1,0);
-            WRITE_UINT32(p_DtsecMemMap->cam2,0);
-            WRITE_UINT32(p_DtsecMemMap->ecntrl, GET_UINT32(p_DtsecMemMap->ecntrl) | ECNTRL_STEN);
-            WRITE_UINT32(p_DtsecMemMap->imask, GET_UINT32(p_DtsecMemMap->imask) | IMASK_MSROEN);
-            p_Dtsec->exceptions |= IMASK_MSROEN;
+    case (e_FM_MAC_FULL_STATISTICS):
+            p_Dtsec->exceptions |= DTSEC_IMASK_MSROEN;
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
@@ -1237,50 +1036,25 @@ static t_Error DtsecSetStatistics(t_Handle h_Dtsec, e_FmMacStatisticsLevel stati
 
 static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDuplex)
 {
-    t_Dtsec         *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap   *p_DtsecMemMap;
-    uint32_t        tmpReg32;
+    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_Error             err;
+    enum enet_interface enet_interface;
+    enum enet_speed     enet_speed;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
-
-    if (!fullDuplex && (speed == e_ENET_SPEED_1000))
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Ethernet MAC 1G does not support half-duplex"));
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     p_Dtsec->enetMode = MAKE_ENET_MODE(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode), speed);
+    enet_interface = (enum enet_interface) ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode);
+    enet_speed = (enum enet_speed) ENET_SPEED_FROM_MODE(p_Dtsec->enetMode);
     p_Dtsec->halfDuplex = !fullDuplex;
 
-    tmpReg32 = GET_UINT32(p_DtsecMemMap->maccfg2);
-    if(p_Dtsec->halfDuplex)
-        tmpReg32 &= ~MACCFG2_FULL_DUPLEX;
-    else
-        tmpReg32 |= MACCFG2_FULL_DUPLEX;
-
-    tmpReg32 &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE);
-    if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
-            tmpReg32 |= MACCFG2_NIBBLE_MODE;
-    else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
-        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
-            tmpReg32 |= MACCFG2_BYTE_MODE;
-    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
-
-    tmpReg32 = GET_UINT32(p_DtsecMemMap->ecntrl);
-    if (!(tmpReg32 & ECNTRL_CFG_RO))
-    {
-        if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
-            (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
-            tmpReg32 |= ECNTRL_R100M;
-        else
-            tmpReg32 &= ~ECNTRL_R100M;
-        WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
-    }
+    err = (t_Error)dtsec_adjust_link(p_Dtsec->p_MemMap, enet_interface, enet_speed, fullDuplex);
 
-    return E_OK;
+    if (err == E_CONFLICT)
+        RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
+
+    return err;
 }
 
 /* .............................................................................. */
@@ -1291,21 +1065,24 @@ static t_Error DtsecRestartAutoneg(t_Handle h_Dtsec)
     uint16_t     tmpReg16;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    DTSEC_MII_ReadPhyReg(p_Dtsec, p_Dtsec->p_DtsecDriverParam->tbiPhyAddr, 0, &tmpReg16);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
+
+    DTSEC_MII_ReadPhyReg(p_Dtsec, p_Dtsec->tbi_phy_addr, 0, &tmpReg16);
     tmpReg16 |= (PHY_CR_RESET_AN);
-    DTSEC_MII_WritePhyReg(p_Dtsec, p_Dtsec->p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
+    DTSEC_MII_WritePhyReg(p_Dtsec, p_Dtsec->tbi_phy_addr, 0, tmpReg16);
 
     return E_OK;
 }
 
+/*************************************************************************************/
 /* .............................................................................. */
 
 static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
 {
-    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
     *macId = p_Dtsec->macId;
 
@@ -1316,15 +1093,12 @@ static t_Error DtsecGetId(t_Handle h_Dtsec, uint32_t *macId)
 
 static t_Error DtsecGetVersion(t_Handle h_Dtsec, uint32_t *macVersion)
 {
-    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecMemMap        *p_DtsecMemMap;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
-    *macVersion = GET_UINT32(p_DtsecMemMap->tsec_id1);
+    *macVersion = dtsec_get_revision(p_Dtsec->p_MemMap);
 
     return E_OK;
 }
@@ -1333,60 +1107,44 @@ static t_Error DtsecGetVersion(t_Handle h_Dtsec, uint32_t *macVersion)
 
 static t_Error DtsecSetException(t_Handle h_Dtsec, e_FmMacExceptions exception, bool enable)
 {
-    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    uint32_t            tmpReg, bitMask = 0;
-    t_DtsecMemMap       *p_DtsecMemMap;
+    t_Dtsec     *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    uint32_t    bitMask = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_NULL_POINTER);
-
-    p_DtsecMemMap = p_Dtsec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(!p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
 
-    if(exception != e_FM_MAC_EX_1G_1588_TS_RX_ERR)
+    if (exception != e_FM_MAC_EX_1G_1588_TS_RX_ERR)
     {
         GET_EXCEPTION_FLAG(bitMask, exception);
-        if(bitMask)
+        if (bitMask)
         {
             if (enable)
                 p_Dtsec->exceptions |= bitMask;
             else
                 p_Dtsec->exceptions &= ~bitMask;
-       }
+        }
         else
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
-        tmpReg = GET_UINT32(p_DtsecMemMap->imask);
-        if(enable)
-            tmpReg |= bitMask;
+        if (enable)
+            dtsec_enable_interrupt(p_Dtsec->p_MemMap, bitMask);
         else
-            tmpReg &= ~bitMask;
-        WRITE_UINT32(p_DtsecMemMap->imask, tmpReg);
-
-        /* warn if MIB OVFL is disabled and statistic gathering is enabled */
-        if((exception == e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL) &&
-            !enable &&
-            (p_Dtsec->statisticsLevel != e_FM_MAC_NONE_STATISTICS))
-            DBG(INFO, ("Disabled MIB counters overflow exceptions."
-                          " Counters value may be inaccurate due to unregistered overflow"));
-
+            dtsec_disable_interrupt(p_Dtsec->p_MemMap, bitMask);
     }
     else
     {
-        if(!p_Dtsec->ptpTsuEnabled)
+        if (!p_Dtsec->ptpTsuEnabled)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
-        tmpReg = GET_UINT32(p_DtsecMemMap->tmr_pemask);
-        switch(exception){
-        case(e_FM_MAC_EX_1G_1588_TS_RX_ERR):
-            if(enable)
+        switch (exception)
+        {
+        case (e_FM_MAC_EX_1G_1588_TS_RX_ERR):
+            if (enable)
             {
                 p_Dtsec->enTsuErrExeption = TRUE;
-                WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg | PEMASK_TSRE);
-            }
-            else
-            {
+                dtsec_enable_tmr_interrupt(p_Dtsec->p_MemMap);
+            } else {
                 p_Dtsec->enTsuErrExeption = FALSE;
-                WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg & ~PEMASK_TSRE);
+                dtsec_disable_tmr_interrupt(p_Dtsec->p_MemMap);
             }
             break;
         default:
@@ -1397,6 +1155,8 @@ static t_Error DtsecSetException(t_Handle h_Dtsec, e_FmMacExceptions exception,
     return E_OK;
 }
 
+
+
 /* ........................................................................... */
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -1410,12 +1170,11 @@ static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
     if (p_Dtsec->p_MemMap)
     {
 
-        DUMP_TITLE(p_Dtsec->p_MemMap, ("MAC %d: ", p_Dtsec->macId));
-        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id1);
+        DUMP_TITLE(p_Dtsec->p_MemMap, ("dTSEC %d: ", p_Dtsec->macId));
+        DUMP_VAR(p_Dtsec->p_MemMap, tsec_id);
         DUMP_VAR(p_Dtsec->p_MemMap, tsec_id2);
         DUMP_VAR(p_Dtsec->p_MemMap, ievent);
         DUMP_VAR(p_Dtsec->p_MemMap, imask);
-        DUMP_VAR(p_Dtsec->p_MemMap, edis);
         DUMP_VAR(p_Dtsec->p_MemMap, ecntrl);
         DUMP_VAR(p_Dtsec->p_MemMap, ptv);
         DUMP_VAR(p_Dtsec->p_MemMap, tmr_ctrl);
@@ -1437,6 +1196,8 @@ static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
             DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match1);
             DUMP_VAR(p_Dtsec->p_MemMap, macaddr[i].exact_match2);
         }
+        DUMP_VAR(p_Dtsec->p_MemMap, car1);
+        DUMP_VAR(p_Dtsec->p_MemMap, car2);
     }
 
     return E_OK;
@@ -1445,7 +1206,7 @@ static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
 
 
 /*****************************************************************************/
-/*                      FM Init & Free API                                   */
+/*                      dTSEC Init & Free API                                   */
 /*****************************************************************************/
 
 /* .............................................................................. */
@@ -1453,312 +1214,87 @@ static t_Error DtsecDumpRegs(t_Handle h_Dtsec)
 static t_Error DtsecInit(t_Handle h_Dtsec)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_DtsecDriverParam  *p_DtsecDriverParam;
-    t_DtsecMemMap       *p_DtsecMemMap;
-    int                 i;
-    uint32_t            tmpReg32;
-    uint64_t            addr;
+    struct dtsec_cfg    *p_DtsecDriverParam;
     t_Error             err;
+    uint16_t            maxFrmLn;
+    enum enet_interface enet_interface;
+    enum enet_speed     enet_speed;
+    t_EnetAddr          ethAddr;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_DtsecDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MemMap, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->fmMacControllerDriver.h_Fm, E_INVALID_HANDLE);
 
     FM_GetRevision(p_Dtsec->fmMacControllerDriver.h_Fm, &p_Dtsec->fmMacControllerDriver.fmRevInfo);
-
     CHECK_INIT_PARAMETERS(p_Dtsec, CheckInitParameters);
 
     p_DtsecDriverParam  = p_Dtsec->p_DtsecDriverParam;
-    p_Dtsec->halfDuplex = p_DtsecDriverParam->halfDuplex;
-    p_Dtsec->debugMode  = p_DtsecDriverParam->debugMode;
-    p_DtsecMemMap       = p_Dtsec->p_MemMap;
-
-    /*************dtsec_id2******************/
-    tmpReg32 =  GET_UINT32(p_DtsecMemMap->tsec_id2);
-
-    if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RMII_10) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RMII_100))
-        if(tmpReg32 & ID2_INT_REDUCED_OFF)
-        {
-             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for reduced interface in current DTSEC version"));
-        }
-
-    if ((ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)||
-        (p_Dtsec->enetMode == e_ENET_MODE_MII_10)    ||
-        (p_Dtsec->enetMode == e_ENET_MODE_MII_100))
-        if(tmpReg32 & ID2_INT_NORMAL_OFF)
-        {
-             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no support for normal interface in current DTSEC version"));
-        }
-    /*************dtsec_id2******************/
-
-    /***************EDIS************************/
-    WRITE_UINT32(p_DtsecMemMap->edis, p_DtsecDriverParam->errorDisabled);
-    /***************EDIS************************/
-
-    /***************ECNTRL************************/
-    tmpReg32 = 0;
-    if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000))
-        tmpReg32 |= ECNTRL_GMIIM;
-    if (ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)
-        tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM);
-    if (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000)
-        tmpReg32 |= (ECNTRL_SGMIIM | ECNTRL_TBIM | ECNTRL_QSGMIIM);
-    if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10)||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100))
-        tmpReg32 |= ECNTRL_RPM;
-    if ((p_Dtsec->enetMode == e_ENET_MODE_RGMII_100) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RMII_100))
-        tmpReg32 |= ECNTRL_R100M;
-    if ((p_Dtsec->enetMode == e_ENET_MODE_RMII_10) || (p_Dtsec->enetMode == e_ENET_MODE_RMII_100))
-        tmpReg32 |= ECNTRL_RMM;
-    WRITE_UINT32(p_DtsecMemMap->ecntrl, tmpReg32);
-    /***************ECNTRL************************/
-
-    /***************PTV************************/
-    tmpReg32 = 0;
-    if (p_DtsecDriverParam->pauseTime)
-        tmpReg32 |= (uint32_t)p_DtsecDriverParam->pauseTime;
-
-    if (p_DtsecDriverParam->pauseExtended)
-        tmpReg32 |= ((uint32_t)p_DtsecDriverParam->pauseExtended) << PTV_PTE_OFST;
-    WRITE_UINT32(p_DtsecMemMap->ptv, tmpReg32);
-    /***************PTV************************/
-
-    /***************TCTRL************************/
-    tmpReg32 = 0;
-    if(p_DtsecDriverParam->halfDuplex)
-    {
-        if(p_DtsecDriverParam->halfDulexFlowControlEn)
-            tmpReg32 |= TCTRL_THDF;
-    }
-    else
+    p_Dtsec->halfDuplex = p_DtsecDriverParam->halfdup_on;
+
+    enet_interface = (enum enet_interface)ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode);
+    enet_speed = (enum enet_speed)ENET_SPEED_FROM_MODE(p_Dtsec->enetMode);
+    MAKE_ENET_ADDR_FROM_UINT64(p_Dtsec->addr, ethAddr);
+
+    err = (t_Error)dtsec_init(p_Dtsec->p_MemMap,
+                              p_DtsecDriverParam,
+                              enet_interface,
+                              enet_speed,
+                              (uint8_t*)ethAddr,
+                              p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev,
+                              p_Dtsec->fmMacControllerDriver.fmRevInfo.minorRev,
+                              p_Dtsec->exceptions);
+    if (err)
     {
-        if(p_DtsecDriverParam->txTimeStampEn)
-            tmpReg32 |= TCTRL_TTSE;
+        FreeInitResources(p_Dtsec);
+        RETURN_ERROR(MAJOR, err, ("This DTSEC version does not support the required i/f mode"));
     }
-    WRITE_UINT32(p_DtsecMemMap->tctrl, tmpReg32);
-    /***************TCTRL************************/
-
-    /***************RCTRL************************/
-    tmpReg32 = 0;
-    if (p_DtsecDriverParam->packetAlignmentPadding)
-        tmpReg32 |= ((uint32_t)(0x0000001f & p_DtsecDriverParam->packetAlignmentPadding)) << 16;
-    if (p_DtsecDriverParam->controlFrameAccept)
-        tmpReg32 |= RCTRL_CFA;
-    if (p_DtsecDriverParam->groupHashExtend)
-        tmpReg32 |= RCTRL_GHTX;
-    if(p_DtsecDriverParam->rxTimeStampEn)
-        tmpReg32 |= RCTRL_RTSE;
-    if (p_DtsecDriverParam->broadcReject)
-        tmpReg32 |= RCTRL_BC_REJ;
-    if (p_DtsecDriverParam->rxShortFrame)
-        tmpReg32 |= RCTRL_RSF;
-    if (p_DtsecDriverParam->promiscuousEnable)
-        tmpReg32 |= RCTRL_PROM;
-    if (p_DtsecDriverParam->exactMatch)
-        tmpReg32 |= RCTRL_EMEN;
-
-    WRITE_UINT32(p_DtsecMemMap->rctrl, tmpReg32);
-    /***************RCTRL************************/
-
-    /* Assign a Phy Address to the TBI (TBIPA).            */
-    /* Done also in case that TBI is not selected to avoid */
-    /* conflict with the external PHYs Physical address   */
-    WRITE_UINT32(p_DtsecMemMap->tbipa, p_DtsecDriverParam->tbiPhyAddr);
-
-    if(ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)
+
+    DTSEC_MII_Init(h_Dtsec);
+
+    if (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)
     {
         uint16_t            tmpReg16;
 
         /* Configure the TBI PHY Control Register */
         tmpReg16 = PHY_TBICON_CLK_SEL | PHY_TBICON_SRESET;
 
-        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
+        DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 17, tmpReg16);
 
         tmpReg16 = PHY_TBICON_CLK_SEL;
 
-        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 17, tmpReg16);
+        DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 17, tmpReg16);
 
         tmpReg16 = (PHY_CR_PHY_RESET | PHY_CR_ANE | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
 
-        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
+
+        DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 0, tmpReg16);
 
         tmpReg16 = PHY_TBIANA_SGMII;
-        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 4, tmpReg16);
+        DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 4, tmpReg16);
 
         tmpReg16 = (PHY_CR_ANE | PHY_CR_RESET_AN | PHY_CR_FULLDUPLEX | PHY_CR_SPEED1);
 
-        DTSEC_MII_WritePhyReg(p_Dtsec, p_DtsecDriverParam->tbiPhyAddr, 0, tmpReg16);
-    }
-
-    /***************TMR_CTL************************/
-    WRITE_UINT32(p_DtsecMemMap->tmr_ctrl, 0);
-
-    if(p_Dtsec->ptpTsuEnabled)
-    {
-        tmpReg32 = 0;
-        if (p_Dtsec->enTsuErrExeption)
-            tmpReg32 |= PEMASK_TSRE;
-        WRITE_UINT32(p_DtsecMemMap->tmr_pemask, tmpReg32);
-        WRITE_UINT32(p_DtsecMemMap->tmr_pevent, tmpReg32);
+        DTSEC_MII_WritePhyReg(p_Dtsec, (uint8_t)p_DtsecDriverParam->tbipa, 0, tmpReg16);
     }
 
-    /***************DEBUG************************/
-    tmpReg32 = 0;
-    if(p_DtsecDriverParam->debugMode)
-        WRITE_UINT32(p_DtsecMemMap->tsec_id1, TSEC_ID1_DEBUG);
-    /***************DEBUG************************/
-
-    /***************MACCFG1***********************/
-    WRITE_UINT32(p_DtsecMemMap->maccfg1, MACCFG1_SOFT_RESET);
-    WRITE_UINT32(p_DtsecMemMap->maccfg1, 0);
-    tmpReg32 = 0;
-    if(p_DtsecDriverParam->loopback)
-        tmpReg32 |= MACCFG1_LOOPBACK;
-    if(p_DtsecDriverParam->actOnRxPauseFrame)
-        tmpReg32 |= MACCFG1_RX_FLOW;
-    if(p_DtsecDriverParam->actOnTxPauseFrame)
-        tmpReg32 |= MACCFG1_TX_FLOW;
-    WRITE_UINT32(p_DtsecMemMap->maccfg1, tmpReg32);
-    /***************MACCFG1***********************/
-
-    /***************MACCFG2***********************/
-    tmpReg32 = 0;
-    if( (p_Dtsec->enetMode == e_ENET_MODE_RMII_10)  ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RMII_100) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_MII_10)   ||
-        (p_Dtsec->enetMode == e_ENET_MODE_MII_100)  ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_10) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_RGMII_100)||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_10) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_100))
-            tmpReg32 |= MACCFG2_NIBBLE_MODE;
-    else if((p_Dtsec->enetMode == e_ENET_MODE_RGMII_1000) ||
-        (p_Dtsec->enetMode == e_ENET_MODE_SGMII_1000)||
-        (p_Dtsec->enetMode == e_ENET_MODE_GMII_1000)||
-        (p_Dtsec->enetMode == e_ENET_MODE_QSGMII_1000))
-            tmpReg32 |= MACCFG2_BYTE_MODE;
-
-    tmpReg32 |= (((uint32_t)p_DtsecDriverParam->preambleLength) & 0x0000000f)<< PREAMBLE_LENGTH_SHIFT;
-
-    if(p_DtsecDriverParam->preambleRxEn)
-        tmpReg32 |= MACCFG2_PRE_AM_Rx_EN;
-    if(p_DtsecDriverParam->preambleTxEn)
-        tmpReg32 |= MACCFG2_PRE_AM_Tx_EN;
-    if(p_DtsecDriverParam->lengthCheckEnable)
-        tmpReg32 |= MACCFG2_LENGTH_CHECK;
-    if(p_DtsecDriverParam->padAndCrcEnable)
-        tmpReg32 |=  MACCFG2_PAD_CRC_EN;
-    if(p_DtsecDriverParam->crcEnable)
-        tmpReg32 |= MACCFG2_CRC_EN;
-    if(!p_DtsecDriverParam->halfDuplex)
-        tmpReg32 |= MACCFG2_FULL_DUPLEX;
-    WRITE_UINT32(p_DtsecMemMap->maccfg2, tmpReg32);
-    /***************MACCFG2***********************/
-
-    /***************IPGIFG************************/
-    tmpReg32 = 0;
-    ASSERT_COND(p_DtsecDriverParam->nonBackToBackIpg1 <= p_DtsecDriverParam->nonBackToBackIpg2);
-    tmpReg32 = (uint32_t)((((uint32_t)p_DtsecDriverParam->nonBackToBackIpg1 <<
-               IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT) & IPGIFG_NON_BACK_TO_BACK_IPG_1) |
-              (((uint32_t)p_DtsecDriverParam->nonBackToBackIpg2  <<
-                IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT) & IPGIFG_NON_BACK_TO_BACK_IPG_2) |
-              (((uint32_t)p_DtsecDriverParam->minIfgEnforcement <<
-                IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT) & IPGIFG_MIN_IFG_ENFORCEMENT) |
-              ((uint32_t)p_DtsecDriverParam->backToBackIpg & IPGIFG_BACK_TO_BACK_IPG));
-    WRITE_UINT32(p_DtsecMemMap->ipgifg, tmpReg32);
-    /***************IPGIFG************************/
-
-    /***************HAFDUP************************/
-    tmpReg32 = 0;
-    if(p_DtsecDriverParam->alternateBackoffEnable)
-    {
-        tmpReg32 = (uint32_t) (HAFDUP_ALT_BEB  | (((uint32_t)p_DtsecDriverParam->alternateBackoffVal & 0x0000000f) <<
-                                    HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT));
-    }
-
-    if(p_DtsecDriverParam->backPressureNoBackoff)
-        tmpReg32 |= HAFDUP_BP_NO_BACKOFF;
-    if(p_DtsecDriverParam->noBackoff)
-        tmpReg32 |= HAFDUP_NO_BACKOFF;
-    if(p_DtsecDriverParam->excessDefer)
-        tmpReg32 |= HAFDUP_EXCESS_DEFER;
-    tmpReg32 |= (((uint32_t)p_DtsecDriverParam->maxRetransmission <<
-                HAFDUP_RETRANSMISSION_MAX_SHIFT )& HAFDUP_RETRANSMISSION_MAX);
-    tmpReg32|= ((uint32_t)p_DtsecDriverParam->collisionWindow & HAFDUP_COLLISION_WINDOW);
-
-    WRITE_UINT32(p_DtsecMemMap->hafdup, tmpReg32);
-    /***************HAFDUP************************/
-
-    /***************MAXFRM************************/
-    /* Initialize MAXFRM */
-    WRITE_UINT32(p_DtsecMemMap->maxfrm,
-                 p_DtsecDriverParam->maxFrameLength);
-    err = FmSetMacMaxFrame(p_Dtsec->fmMacControllerDriver.h_Fm,
-                           e_FM_MAC_1G,
-                           p_Dtsec->fmMacControllerDriver.macId,
-                           p_DtsecDriverParam->maxFrameLength);
-    /***************MAXFRM************************/
-
-    /***************CAM1************************/
-    WRITE_UINT32(p_DtsecMemMap->cam1,0xffffffff);
-    WRITE_UINT32(p_DtsecMemMap->cam2,0xffffffff);
-
-    /***************IMASK************************/
-    WRITE_UINT32(p_DtsecMemMap->imask, p_Dtsec->exceptions);
-    /***************IMASK************************/
-
-    /***************IEVENT************************/
-    WRITE_UINT32(p_DtsecMemMap->ievent, EVENTS_MASK);
-
-    /***************MACSTNADDR1/2*****************/
-    /*  Initialize MAC Station Address registers (1 & 2)    */
-    /*  Station address have to be swapped (big endian to little endian */
-    addr = p_Dtsec->addr;
-
-    tmpReg32 = (uint32_t)(addr);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_DtsecMemMap->macstnaddr1, tmpReg32);
-
-    tmpReg32 = (uint32_t)(addr>>32);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_DtsecMemMap->macstnaddr2, tmpReg32);
-    /***************MACSTNADDR1/2*****************/
-
-    /***************DEBUG*****************/
-    WRITE_UINT32(p_DtsecMemMap->tx_threshold,       (uint32_t)(p_DtsecDriverParam->fifoTxThr & 0x7f));
-    WRITE_UINT32(p_DtsecMemMap->tx_watermark_high,  (uint32_t)(p_DtsecDriverParam->fifoTxWatermarkH & 0x7f));
-    WRITE_UINT32(p_DtsecMemMap->rx_watermark_low,   (uint32_t)(p_DtsecDriverParam->fifoRxWatermarkL & 0x7f));
-    /***************DEBUG*****************/
-
-    /*****************HASH************************/
-    for(i=0 ; i<NUM_OF_HASH_REGS ; i++)
-    {
-        /* Initialize IADDRx */
-        WRITE_UINT32(p_DtsecMemMap->igaddr[i], 0);
-        /* Initialize GADDRx */
-        WRITE_UINT32(p_DtsecMemMap->gaddr[i], 0);
+    /* Max Frame Length */
+    maxFrmLn = dtsec_get_max_frame_len(p_Dtsec->p_MemMap);
+    err = FmSetMacMaxFrame(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G,
+            p_Dtsec->fmMacControllerDriver.macId, maxFrmLn);
+/* we consider having no IPC a non crasher... */
+/*    if (err) {
+        FreeInitResources(p_Dtsec);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
-
-    p_Dtsec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
-    if(!p_Dtsec->p_MulticastAddrHash)
-    {
+*/
+    p_Dtsec->p_MulticastAddrHash = AllocHashTable(EXTENDED_HASH_TABLE_SIZE);
+    if (!p_Dtsec->p_MulticastAddrHash) {
         FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MC hash table is FAILED"));
     }
 
     p_Dtsec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
-    if(!p_Dtsec->p_UnicastAddrHash)
+    if (!p_Dtsec->p_UnicastAddrHash)
     {
         FreeInitResources(p_Dtsec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("UC hash table is FAILED"));
@@ -1769,30 +1305,30 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
                    e_FM_MOD_1G_MAC,
                    p_Dtsec->macId,
                    e_FM_INTR_TYPE_ERR,
-                   DtsecErrException,
+                   DtsecIsr,
                    p_Dtsec);
     /* register 1588 intr handler for TMR to FPM (normal)*/
     FmRegisterIntr(p_Dtsec->fmMacControllerDriver.h_Fm,
                    e_FM_MOD_1G_MAC,
                    p_Dtsec->macId,
                    e_FM_INTR_TYPE_NORMAL,
-                   Dtsec1588Exception,
+                   Dtsec1588Isr,
                    p_Dtsec);
     /* register normal intr handler for dtsec to main interrupt controller. */
     if (p_Dtsec->mdioIrq != NO_IRQ)
     {
-        XX_SetIntr(p_Dtsec->mdioIrq, DtsecException, p_Dtsec);
+        XX_SetIntr(p_Dtsec->mdioIrq, DtsecMdioIsr, p_Dtsec);
         XX_EnableIntr(p_Dtsec->mdioIrq);
     }
 
     XX_Free(p_DtsecDriverParam);
     p_Dtsec->p_DtsecDriverParam = NULL;
 
-    err = DtsecSetStatistics(p_Dtsec, e_FM_MAC_FULL_STATISTICS);
-    if(err)
+    err = DtsecSetStatistics(h_Dtsec, e_FM_MAC_FULL_STATISTICS);
+    if (err)
     {
         FreeInitResources(p_Dtsec);
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, ("Undefined statistics level"));
     }
 
     return E_OK;
@@ -1850,7 +1386,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = DtsecEnable1588TimeStamp;
     p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = DtsecDisable1588TimeStamp;
 
-    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = DtsecSetTxAutoPauseFrames;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = DtsecTxMacPause;
     p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames          = DtsecSetTxPauseFrames;
     p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = DtsecRxIgnoreMacPause;
 
@@ -1876,7 +1412,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
 
 /*****************************************************************************/
-/*                      dTSEC Config  Main Entry                             */
+/*                      dTSEC Config Main Entry                             */
 /*****************************************************************************/
 
 /* .............................................................................. */
@@ -1884,45 +1420,41 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
 {
     t_Dtsec             *p_Dtsec;
-    t_DtsecDriverParam  *p_DtsecDriverParam;
+    struct dtsec_cfg    *p_DtsecDriverParam;
     uintptr_t           baseAddr;
-    uint8_t             i;
 
     SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
 
     baseAddr = p_FmMacParam->baseAddr;
+
     /* allocate memory for the UCC GETH data structure. */
-    p_Dtsec = (t_Dtsec *) XX_Malloc(sizeof(t_Dtsec));
+    p_Dtsec = (t_Dtsec *)XX_Malloc(sizeof(t_Dtsec));
     if (!p_Dtsec)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("dTSEC driver structure"));
         return NULL;
     }
-    /* Zero out * p_Dtsec */
     memset(p_Dtsec, 0, sizeof(t_Dtsec));
     InitFmMacControllerDriver(&p_Dtsec->fmMacControllerDriver);
 
     /* allocate memory for the dTSEC driver parameters data structure. */
-    p_DtsecDriverParam = (t_DtsecDriverParam *) XX_Malloc(sizeof(t_DtsecDriverParam));
+    p_DtsecDriverParam = (struct dtsec_cfg *) XX_Malloc(sizeof(struct dtsec_cfg));
     if (!p_DtsecDriverParam)
     {
         XX_Free(p_Dtsec);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("dTSEC driver parameters"));
         return NULL;
     }
-    /* Zero out */
-    memset(p_DtsecDriverParam, 0, sizeof(t_DtsecDriverParam));
+    memset(p_DtsecDriverParam, 0, sizeof(struct dtsec_cfg));
 
     /* Plant parameter structure pointer */
     p_Dtsec->p_DtsecDriverParam = p_DtsecDriverParam;
 
-    SetDefaultParam(p_DtsecDriverParam);
-
-   for (i=0; i < sizeof(p_FmMacParam->addr); i++)
-        p_Dtsec->addr |= ((uint64_t)p_FmMacParam->addr[i] << ((5-i) * 8));
+    dtsec_defconfig(p_DtsecDriverParam);
 
-    p_Dtsec->p_MemMap           = (t_DtsecMemMap *)UINT_TO_PTR(baseAddr);
-    p_Dtsec->p_MiiMemMap        = (t_MiiAccessMemMap *)UINT_TO_PTR(baseAddr + DTSEC_TO_MII_OFFSET);
+    p_Dtsec->p_MemMap           = (struct dtsec_regs *)UINT_TO_PTR(baseAddr);
+    p_Dtsec->p_MiiMemMap        = (struct dtsec_mii_reg *)UINT_TO_PTR(baseAddr + DTSEC_TO_MII_OFFSET);
+    p_Dtsec->addr               = ENET_ADDR_TO_UINT64(p_FmMacParam->addr);
     p_Dtsec->enetMode           = p_FmMacParam->enetMode;
     p_Dtsec->macId              = p_FmMacParam->macId;
     p_Dtsec->exceptions         = DEFAULT_exceptions;
@@ -1930,6 +1462,9 @@ t_Handle  DTSEC_Config(t_FmMacParams *p_FmMacParam)
     p_Dtsec->f_Exception        = p_FmMacParam->f_Exception;
     p_Dtsec->f_Event            = p_FmMacParam->f_Event;
     p_Dtsec->h_App              = p_FmMacParam->h_App;
+    p_Dtsec->ptpTsuEnabled      = p_Dtsec->p_DtsecDriverParam->ptp_tsu_en;
+    p_Dtsec->enTsuErrExeption   = p_Dtsec->p_DtsecDriverParam->ptp_exception_en;
+    p_Dtsec->tbi_phy_addr       = p_Dtsec->p_DtsecDriverParam->tbi_phy_addr;
 
     return p_Dtsec;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
index ddb606e..ca02ce2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec.h
@@ -42,81 +42,43 @@
 #include "std_ext.h"
 #include "error_ext.h"
 #include "list_ext.h"
+#include "enet_ext.h"
+
 #include "dtsec_mii_acc.h"
 #include "fm_mac.h"
 
 
-#define PEMASK_TSRE                 0x00010000
-
-#define IMASK_BREN                  0x80000000
-#define IMASK_RXCEN                 0x40000000
-#define IMASK_MSROEN                0x04000000
-#define IMASK_GTSCEN                0x02000000
-#define IMASK_BTEN                  0x01000000
-#define IMASK_TXCEN                 0x00800000
-#define IMASK_TXEEN                 0x00400000
-#define IMASK_LCEN                  0x00040000
-#define IMASK_CRLEN                 0x00020000
-#define IMASK_XFUNEN                0x00010000
-#define IMASK_ABRTEN                0x00008000
-#define IMASK_IFERREN               0x00004000
-#define IMASK_MAGEN                 0x00000800
-#define IMASK_MMRDEN                0x00000400
-#define IMASK_MMWREN                0x00000200
-#define IMASK_GRSCEN                0x00000100
-#define IMASK_TDPEEN                0x00000002
-#define IMASK_RDPEEN                0x00000001
-
-#define EVENTS_MASK                 ((uint32_t)(IMASK_BREN    | \
-                                                IMASK_RXCEN   | \
-                                                IMASK_MSROEN  | \
-                                                IMASK_GTSCEN  | \
-                                                IMASK_BTEN    | \
-                                                IMASK_TXCEN   | \
-                                                IMASK_TXEEN   | \
-                                                IMASK_ABRTEN  | \
-                                                IMASK_LCEN    | \
-                                                IMASK_CRLEN   | \
-                                                IMASK_XFUNEN  | \
-                                                IMASK_IFERREN | \
-                                                IMASK_MAGEN   | \
-                                                IMASK_MMRDEN  | \
-                                                IMASK_MMWREN  | \
-                                                IMASK_GRSCEN  | \
-                                                IMASK_TDPEEN  | \
-                                                IMASK_RDPEEN))
-
-#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
-    case e_FM_MAC_EX_1G_BAB_RX:                                   \
-        bitMask = IMASK_BREN; break;                              \
-    case e_FM_MAC_EX_1G_RX_CTL:                                   \
-        bitMask = IMASK_RXCEN; break;                             \
-    case e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET:                  \
-        bitMask = IMASK_GTSCEN ; break;                           \
-    case e_FM_MAC_EX_1G_BAB_TX:                                   \
-        bitMask = IMASK_BTEN   ; break;                           \
-    case e_FM_MAC_EX_1G_TX_CTL:                                   \
-        bitMask = IMASK_TXCEN  ; break;                           \
-    case e_FM_MAC_EX_1G_TX_ERR:                                   \
-        bitMask = IMASK_TXEEN  ; break;                           \
-    case e_FM_MAC_EX_1G_LATE_COL:                                 \
-        bitMask = IMASK_LCEN   ; break;                           \
-    case e_FM_MAC_EX_1G_COL_RET_LMT:                              \
-        bitMask = IMASK_CRLEN  ; break;                           \
-    case e_FM_MAC_EX_1G_TX_FIFO_UNDRN:                            \
-        bitMask = IMASK_XFUNEN ; break;                           \
-    case e_FM_MAC_EX_1G_MAG_PCKT:                                 \
-        bitMask = IMASK_MAGEN ; break;                            \
-    case e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET:                       \
-        bitMask = IMASK_MMRDEN; break;                            \
-    case e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET:                       \
-        bitMask = IMASK_MMWREN  ; break;                          \
-    case e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET:                  \
-        bitMask = IMASK_GRSCEN; break;                            \
-    case e_FM_MAC_EX_1G_TX_DATA_ERR:                              \
-        bitMask = IMASK_TDPEEN; break;                            \
-    case e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL:                          \
-        bitMask = IMASK_MSROEN ; break;                           \
+#define GET_EXCEPTION_FLAG(bitMask, exception)  switch (exception){ \
+    case e_FM_MAC_EX_1G_BAB_RX:                                     \
+        bitMask = DTSEC_IMASK_BREN; break;                          \
+    case e_FM_MAC_EX_1G_RX_CTL:                                     \
+        bitMask = DTSEC_IMASK_RXCEN; break;                         \
+    case e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET:                    \
+        bitMask = DTSEC_IMASK_GTSCEN ; break;                       \
+    case e_FM_MAC_EX_1G_BAB_TX:                                     \
+        bitMask = DTSEC_IMASK_BTEN   ; break;                       \
+    case e_FM_MAC_EX_1G_TX_CTL:                                     \
+        bitMask = DTSEC_IMASK_TXCEN  ; break;                       \
+    case e_FM_MAC_EX_1G_TX_ERR:                                     \
+        bitMask = DTSEC_IMASK_TXEEN  ; break;                       \
+    case e_FM_MAC_EX_1G_LATE_COL:                                   \
+        bitMask = DTSEC_IMASK_LCEN   ; break;                       \
+    case e_FM_MAC_EX_1G_COL_RET_LMT:                                \
+        bitMask = DTSEC_IMASK_CRLEN  ; break;                       \
+    case e_FM_MAC_EX_1G_TX_FIFO_UNDRN:                              \
+        bitMask = DTSEC_IMASK_XFUNEN ; break;                       \
+    case e_FM_MAC_EX_1G_MAG_PCKT:                                   \
+        bitMask = DTSEC_IMASK_MAGEN ; break;                        \
+    case e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET:                         \
+        bitMask = DTSEC_IMASK_MMRDEN; break;                        \
+    case e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET:                         \
+        bitMask = DTSEC_IMASK_MMWREN  ; break;                      \
+    case e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET:                    \
+        bitMask = DTSEC_IMASK_GRSCEN; break;                        \
+    case e_FM_MAC_EX_1G_TX_DATA_ERR:                                \
+        bitMask = DTSEC_IMASK_TDPEEN; break;                        \
+    case e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL:                            \
+        bitMask = DTSEC_IMASK_MSROEN ; break;                       \
     default: bitMask = 0;break;}
 
 
@@ -146,167 +108,32 @@ typedef  uint32_t t_ErrorDisable;
 
 #define HASH_TABLE_SIZE                 256 /* Hash table size (= 32 bits * 8 regs) */
 
-#define DTSEC_TO_MII_OFFSET             0x1120  /* number of pattern match registers (entries) */
+#define HASH_TABLE_SIZE                 256 /* Hash table size (32 bits * 8 regs) */
+#define EXTENDED_HASH_TABLE_SIZE        512 /* Extended Hash table size (32 bits * 16 regs) */
 
+#define DTSEC_TO_MII_OFFSET             0x1000  /* number of pattern match registers (entries) */
 
-
-#define DEFAULT_errorDisabled           0
-#define DEFAULT_pauseExtended           0x0
-#define DEFAULT_halfDulexFlowControlEn  FALSE
-#define DEFAULT_packetAlignment         0
-#define DEFAULT_controlFrameAccept      FALSE
-#define DEFAULT_groupHashExtend         FALSE
-#define DEFAULT_broadcReject            FALSE
-#define DEFAULT_rxShortFrame            TRUE
-#define DEFAULT_exactMatch              FALSE
-#define DEFAULT_debugMode               FALSE
-#define DEFAULT_tbiPhyAddr              5
-#define DEFAULT_actOnTxPauseFrame       TRUE
-#define DEFAULT_PreAmLength             0x7
-#define DEFAULT_PreAmRxEn               FALSE
-#define DEFAULT_PreAmTxEn               FALSE
-#define DEFAULT_crcEnable               FALSE
-#define DEFAULT_nonBackToBackIpg1       0x40
-#define DEFAULT_nonBackToBackIpg2       0x60
-#define DEFAULT_minIfgEnforcement       0x50
-#define DEFAULT_backToBackIpg           0x60
-#define DEFAULT_altBackoffVal           0x0A
-#define DEFAULT_altBackoffEnable        FALSE
-#define DEFAULT_backPressureNoBackoff   FALSE
-#define DEFAULT_noBackoff               FALSE
-#define DEFAULT_excessDefer             TRUE
-#define DEFAULT_maxRetransmission       0x0F
-#define DEFAULT_collisionWindow         0x37
-#define DEFAULT_fifoTxThr               0x10
-#define DEFAULT_fifoTxWatermarkH        0x7e
-#define DEFAULT_fifoRxWatermarkL        0x08
-#define DEFAULT_timeStampEnable         FALSE
-
-#define DEFAULT_exceptions              ((uint32_t)(IMASK_BREN    | \
-                                                    IMASK_RXCEN   | \
-                                                    IMASK_BTEN    | \
-                                                    IMASK_TXCEN   | \
-                                                    IMASK_TXEEN   | \
-                                                    IMASK_ABRTEN  | \
-                                                    IMASK_LCEN    | \
-                                                    IMASK_CRLEN   | \
-                                                    IMASK_XFUNEN  | \
-                                                    IMASK_IFERREN | \
-                                                    IMASK_MAGEN   | \
-                                                    IMASK_TDPEEN  | \
-                                                    IMASK_RDPEEN))
+#define DEFAULT_exceptions              ((uint32_t)(DTSEC_IMASK_BREN    | \
+                                                    DTSEC_IMASK_RXCEN   | \
+                                                    DTSEC_IMASK_BTEN    | \
+                                                    DTSEC_IMASK_TXCEN   | \
+                                                    DTSEC_IMASK_TXEEN   | \
+                                                    DTSEC_IMASK_ABRTEN  | \
+                                                    DTSEC_IMASK_LCEN    | \
+                                                    DTSEC_IMASK_CRLEN   | \
+                                                    DTSEC_IMASK_XFUNEN  | \
+                                                    DTSEC_IMASK_IFERREN | \
+                                                    DTSEC_IMASK_MAGEN   | \
+                                                    DTSEC_IMASK_TDPEEN  | \
+                                                    DTSEC_IMASK_RDPEEN))
 
 
 #define MAX_PHYS                    32 /* maximum number of phys */
 
-#define DTSEC_ID1_ID                0xffff0000
-#define DTSEC_ID1_REV_MJ            0x0000FF00
-#define DTSEC_ID1_REV_MN            0x000000ff
-
-#define ID2_INT_REDUCED_OFF         0x00010000
-#define ID2_INT_NORMAL_OFF          0x00020000
-
-#define ECNTRL_CLRCNT               0x00004000
-#define ECNTRL_AUTOZ                0x00002000
-#define ECNTRL_STEN                 0x00001000
-#define ECNTRL_CFG_RO               0x80000000
-#define ECNTRL_GMIIM                0x00000040
-#define ECNTRL_TBIM                 0x00000020
-#define ECNTRL_SGMIIM               0x00000002
-#define ECNTRL_RPM                  0x00000010
-#define ECNTRL_R100M                0x00000008
-#define ECNTRL_RMM                  0x00000004
-#define ECNTRL_QSGMIIM              0x00000001
-
-#define TCTRL_THDF                  0x00000800
-#define TCTRL_TTSE                  0x00000040
-#define TCTRL_GTS                   0x00000020
-#define TCTRL_TFC_PAUSE             0x00000010
-
-/* PTV offsets */
-#define PTV_PTE_OFST                16
-
-#define RCTRL_CFA                   0x00008000
-#define RCTRL_GHTX                  0x00000400
-#define RCTRL_RTSE                  0x00000040
-#define RCTRL_GRS                   0x00000020
-#define RCTRL_BC_REJ                0x00000010
-#define RCTRL_MPROM                 0x00000008
-#define RCTRL_RSF                   0x00000004
-#define RCTRL_EMEN                  0x00000002
-#define RCTRL_UPROM                 0x00000001
-#define RCTRL_PROM                  (RCTRL_UPROM | RCTRL_MPROM)
-
-#define TMR_CTL_ESFDP               0x00000800
-#define TMR_CTL_ESFDE               0x00000400
-
-#define TSEC_ID1_DEBUG              0x00e00c00
-#define DEBUG_ENABLE                0x80000000
-#define DPERROR_Tx_ERROR_ON_SEC     0x00400000
-#define DPERROR_Tx_ERROR_ON_WRITE   0x10000000
-#define DPERROR_Rx_ERROR_ON_SEC     0x00000040
-#define DPERROR_Rx_ERROR_ON_WRITE   0x00001000
-#define DPERROR_STT                 0x80000000
-#define DPERROR_STR                 0x00008000
-
-#define MACCFG1_SOFT_RESET          0x80000000
-#define MACCFG1_LOOPBACK            0x00000100
-#define MACCFG1_RX_FLOW             0x00000020
-#define MACCFG1_TX_FLOW             0x00000010
-#define MACCFG1_TX_EN               0x00000001
-#define MACCFG1_RX_EN               0x00000004
-#define MACCFG1_RESET_RxMC          0x00080000
-#define MACCFG1_RESET_TxMC          0x00040000
-#define MACCFG1_RESET_RxFUN         0x00020000
-#define MACCFG1_RESET_TxFUN         0x00010000
-
-#define MACCFG2_NIBBLE_MODE         0x00000100
-#define MACCFG2_BYTE_MODE           0x00000200
-#define MACCFG2_PRE_AM_Rx_EN        0x00000080
-#define MACCFG2_PRE_AM_Tx_EN        0x00000040
-#define MACCFG2_LENGTH_CHECK        0x00000010
-#define MACCFG2_MAGIC_PACKET_EN     0x00000008
-#define MACCFG2_PAD_CRC_EN          0x00000004
-#define MACCFG2_CRC_EN              0x00000002
-#define MACCFG2_FULL_DUPLEX         0x00000001
-
-#define PREAMBLE_LENGTH_SHIFT       12
-
-#define IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT    24
-#define IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT    16
-#define IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT        8
-
-#define IPGIFG_NON_BACK_TO_BACK_IPG_1    0x7F000000
-#define IPGIFG_NON_BACK_TO_BACK_IPG_2    0x007F0000
-#define IPGIFG_MIN_IFG_ENFORCEMENT       0x0000FF00
-#define IPGIFG_BACK_TO_BACK_IPG          0x0000007F
-
-#define HAFDUP_ALT_BEB                   0x00080000
-#define HAFDUP_BP_NO_BACKOFF             0x00040000
-#define HAFDUP_NO_BACKOFF                0x00020000
-#define HAFDUP_EXCESS_DEFER              0x00010000
-#define HAFDUP_COLLISION_WINDOW          0x000003ff
-
-#define HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT    20
-#define HAFDUP_RETRANSMISSION_MAX_SHIFT          12
-#define HAFDUP_RETRANSMISSION_MAX       0x0000f000
-
-#define NUM_OF_HASH_REGS     8 /* Number of hash table registers */
-
-#define DEBUG_GET_FIFO_READ_INDEX       0x007f0000
-#define DEBUG_GET_FIFO_WRITE_INDEX      0x0000007f
-/* Pause Time Value Register  */
-#define PTV_PTE_SHIFT       16
-
-#define MASK22BIT           0x003FFFFF
-#define MASK16BIT           0x0000FFFF
-#define MASK12BIT           0x00000FFF
-#define MASK8BIT            0x000000FF
-
-#define VAL32BIT            0x100000000LL
-#define VAL22BIT            0x00400000
-#define VAL16BIT            0x00010000
-#define VAL12BIT            0x00001000
+#define     VAL32BIT    0x100000000LL
+#define     VAL22BIT    0x00400000
+#define     VAL16BIT    0x00010000
+#define     VAL12BIT    0x00001000
 
 /* PHY Control Register */
 #define PHY_CR_PHY_RESET    0x8000
@@ -356,151 +183,8 @@ typedef  uint32_t t_ErrorDisable;
 #define CAR2_TXPF   0x00000200
 #define CAR2_TDRP   0x00000001
 
-#define CAM1_ERRORS_ONLY (CAR1_RXPF |   \
-                            CAR1_RALN | \
-                            CAR1_RFLR | \
-                            CAR1_RCDE | \
-                            CAR1_RCSE | \
-                            CAR1_RUND | \
-                            CAR1_ROVR | \
-                            CAR1_RFRG | \
-                            CAR1_RJBR | \
-                            CAR1_RDRP)
-
-#define CAM2_ERRORS_ONLY (CAR2_TFCS | CAR2_TXPF | CAR2_TDRP)
-
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-
-typedef struct {
-    volatile uint32_t exact_match1; /* octets 1-4 */
-    volatile uint32_t exact_match2; /* octets 5-6 */
-} macRegs;
-
-typedef struct {
-    volatile uint32_t tsec_id1;             /* 0x000 ETSEC_ID register */
-    volatile uint32_t tsec_id2;             /* 0x004 ETSEC_ID2 register */
-    volatile uint32_t ievent;               /* 0x008 Interrupt event register */
-    volatile uint32_t imask;                /* 0x00C Interrupt mask register */
-    volatile uint32_t edis;                 /* 0x010 Error disabled register */
-    volatile uint32_t ecntrl;               /* 0x014 E control register */
-    volatile uint32_t ptv;                  /* 0x018 Pause time value register */
-    volatile uint32_t tbipa;                /* 0x01C TBI PHY address register */
-    volatile uint32_t tmr_ctrl;             /* 0x020 Time-stamp Control register */
-    volatile uint32_t tmr_pevent;           /* 0x024 Time-stamp event register */
-    volatile uint32_t tmr_pemask;           /* 0x028 Timer event mask register */
-    volatile uint32_t DTSEC_RESERVED2;      /* 0x02C */
-    volatile uint32_t iobistctl;            /* 0x030 IO BIST Control register */
-    volatile uint32_t DTSEC_RESERVED3[3];   /* 0x034 */
-
-    volatile uint32_t tctrl;                /* 0x040 Transmit control register */
-    volatile uint32_t DTSEC_RESERVED4[3];   /* 0x044-0x04C */
-    volatile uint32_t rctrl;                /* 0x050 Receive control register */
-    volatile uint32_t DTSEC_RESERVED5[11];  /* 0x054- 0x07C */
-
-    volatile uint32_t igaddr[8];            /* 0x080-0x09C Individual/group address registers 0-7 */
-    volatile uint32_t gaddr[8];             /* 0x0A0-0x0BC Group address registers 0-7 */
-    volatile uint32_t ETSEC_RESERVED6[16];  /* 0x0C0-0x0FC */
-
-    volatile uint32_t maccfg1;              /* 0x100 MAC configuration #1 */
-    volatile uint32_t maccfg2;              /* 0x104 MAC configuration #2 */
-    volatile uint32_t ipgifg;               /* 0x108 IPG/IFG */
-    volatile uint32_t hafdup;               /* 0x10C Half-duplex */
-    volatile uint32_t maxfrm;               /* 0x110 Maximum frame */
-    volatile uint32_t DTSEC_RESERVED7[10];  /* 0x114-0x138 register */
-    volatile uint32_t ifstat;               /* 0x13C Interface status */
-    volatile uint32_t macstnaddr1;          /* 0x140 Station Address,part 1 */
-    volatile uint32_t macstnaddr2;          /* 0x144 Station Address,part 2  */
-    volatile macRegs  macaddr[DTSEC_NUM_OF_PADDRS]; /* 0x148-0x1BC mac exact match addresses 1-15, parts 1-2 */
-    volatile uint32_t DTSEC_RESERVED8[16];  /* 0x1C0-0x1FC register */
-
-    /*  RMON MIB REGISTERS  */
-    /*  TRANSMIT and RECEIVE COUNTERS   */
-
-    volatile uint32_t tr64;            /* 0x200 transmit and receive 64 byte frame counter */
-    volatile uint32_t tr127;           /* 0x204 transmit and receive 65 to 127 byte frame counter */
-    volatile uint32_t tr255;           /* 0x208 transmit and receive 128 to 255 byte frame counter */
-    volatile uint32_t tr511;           /* 0x20C transmit and receive 256 to 511 byte frame counter */
-    volatile uint32_t tr1k;            /* 0x210 transmit and receive 512 to 1023 byte frame counter */
-    volatile uint32_t trmax;           /* 0x214 transmit and receive 1024 to 1518 byte frame counter */
-    volatile uint32_t trmgv;           /* 0x218 transmit and receive 1519 to 1522 byte good VLAN frame count */
-
-    /* RECEIVE COUNTERS */
-    volatile uint32_t rbyt;            /* 0x21C receive byte counter */
-    volatile uint32_t rpkt;            /* 0x220 receive packet counter */
-    volatile uint32_t rfcs;            /* 0x224 receive FCS error counter */
-    volatile uint32_t rmca;            /* 0x228 RMCA receive multicast packet counter */
-    volatile uint32_t rbca;            /* 0x22C receive broadcast packet counter */
-    volatile uint32_t rxcf;            /* 0x230 receive control frame packet counter */
-    volatile uint32_t rxpf;            /* 0x234 receive PAUSE frame packet counter */
-    volatile uint32_t rxuo;            /* 0x238 receive unknown OP code counter */
-    volatile uint32_t raln;            /* 0x23C receive alignment error counter */
-    volatile uint32_t rflr;            /* 0x240 receive frame length error counter */
-    volatile uint32_t rcde;            /* 0x244 receive code error counter */
-    volatile uint32_t rcse;            /* 0x248 receive carrier sense error counter */
-    volatile uint32_t rund;            /* 0x24C receive undersize packet counter */
-    volatile uint32_t rovr;            /* 0x250 receive oversize packet counter */
-    volatile uint32_t rfrg;            /* 0x254 receive fragments counter */
-    volatile uint32_t rjbr;            /* 0x258 receive jabber counter */
-    volatile uint32_t rdrp;            /* 0x25C receive drop */
-
-    /* TRANSMIT COUNTERS */
-    volatile uint32_t tbyt;            /* 0x260 transmit byte counter */
-    volatile uint32_t tpkt;            /* 0x264 transmit packet counter */
-    volatile uint32_t tmca;            /* 0x268 transmit multicast packet counter */
-    volatile uint32_t tbca;            /* 0x26C transmit broadcast packet counter */
-    volatile uint32_t txpf;            /* 0x270 transmit PAUSE control frame counter */
-    volatile uint32_t tdfr;            /* 0x274 transmit deferral packet counter */
-    volatile uint32_t tedf;            /* 0x278 transmit excessive deferral packet counter */
-    volatile uint32_t tscl;            /* 0x27C transmit single collision packet counter */
-    volatile uint32_t tmcl;            /* 0x280 transmit multiple collision packet counter */
-    volatile uint32_t tlcl;            /* 0x284 transmit late collision packet counter */
-    volatile uint32_t txcl;            /* 0x288 transmit excessive collision packet counter */
-    volatile uint32_t tncl;            /* 0x28C transmit total collision counter */
-    volatile uint32_t DTSEC_RESERVED9; /* 0x290 */
-    volatile uint32_t tdrp;            /* 0x294 transmit drop frame counter */
-    volatile uint32_t tjbr;            /* 0x298 transmit jabber frame counter */
-    volatile uint32_t tfcs;            /* 0x29C transmit FCS error counter */
-    volatile uint32_t txcf;            /* 0x2A0 transmit control frame counter */
-    volatile uint32_t tovr;            /* 0x2A4 transmit oversize frame counter */
-    volatile uint32_t tund;            /* 0x2A8 transmit undersize frame counter */
-    volatile uint32_t tfrg;            /* 0x2AC transmit fragments frame counter */
-
-    /* GENERAL REGISTERS */
-    volatile uint32_t car1;            /* 0x2B0 carry register one register* */
-    volatile uint32_t car2;            /* 0x2B4 carry register two register* */
-    volatile uint32_t cam1;            /* 0x2B8 carry register one mask register */
-    volatile uint32_t cam2;            /* 0x2BC carry register two mask register */
-    volatile uint32_t DTSEC_RESERVED10[16]; /* 0x2C0-0x2FC */
-
-    /* Debug and Factory Test Registers */
-    volatile uint32_t debug;            /* 0x300 DEBUG - Debug Register */
-    volatile uint32_t dperror;          /* 0x304 DPERROR - Parity Error Register */
-    volatile uint32_t hwassert;         /* 0x308 HWASSERT */
-    volatile uint32_t RESERVED11;       /* 0x30C Reserved */
-    volatile uint32_t rx_fifo_ptr;      /* 0x310 RXFIFOPTR - Rx FIFO R/W Pointer Register */
-    volatile uint32_t rx_fifo_dath;     /* 0x314 RXFIFODATH - Rx FIFO Data Register */
-    volatile uint32_t rx_fifo_datl;     /* 0x318 RXFIFODATL - Rx FIFO Data Register */
-    volatile uint32_t rx_fifo_stat;     /* 0x31C RXFIFOSTAT - Rx FIFO Status Register */
-    volatile uint32_t tx_fifo_ptr;      /* 0x320 TXFIFOPTR - Tx FIFO R/W Pointer Register */
-    volatile uint32_t tx_fifo_dath;     /* 0x324 TXFIFODATH - Rx FIFO Data Register */
-    volatile uint32_t tx_fifo_datl;     /* 0x328 TXFIFODATL - Rx FIFO Data Register */
-    volatile uint32_t tx_fifo_stat;     /* 0x32C TXFIFOSTAT - Tx FIFO Status Register */
-    volatile uint32_t pkt_rcv_cnt;      /* 0x330 PKTRCVCNT - Number of packets accepted and written to Rx FIFO */
-    volatile uint32_t RESERVED12[3];    /* 0x334-0x33C Reserved */
-    volatile uint32_t tx_threshold;     /* 0x340 Transmit threshold; Number of entries (4 bytes units) before starting to transmit to the MAC */
-    volatile uint32_t tx_watermark_high;/* 0x344 Transmit watermark high; Number of entries (4 byte units) before de-asserting Ready to packet Interface */
-    volatile uint32_t rx_watermark_low; /* 0x348 Receive watermark low; Number of entries (4 byte units) before unloading to packet Interface */
-} t_DtsecMemMap;
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
-
-
-typedef struct {
+typedef struct t_InternalStatistics
+{
     uint64_t    tr64;
     uint64_t    tr127;
     uint64_t    tr255;
@@ -532,65 +216,10 @@ typedef struct {
 } t_InternalStatistics;
 
 typedef struct {
-    uint32_t    errorDisabled;
-    bool        halfDuplex;
-    uint16_t    pauseTime;
-    uint16_t    pauseExtended;
-    uint8_t     tbiPhyAddr;         /**< TBI Physical address  (1-31)     [DEFAULT_tbiPhyAddr] */
-
-    bool        autoZeroCounters;
-    bool        promiscuousEnable;
-
-    bool        halfDulexFlowControlEn;
-    bool        txTimeStampEn;
-    bool        rxTimeStampEn;
-
-    uint8_t     packetAlignmentPadding;
-    bool        controlFrameAccept;
-    bool        groupHashExtend;
-    bool        broadcReject;
-    bool        rxShortFrame;
-    bool        exactMatch;
-
-    bool        debugMode;
-
-    bool        loopback;
-    bool        actOnRxPauseFrame;
-    bool        actOnTxPauseFrame;
-
-    uint8_t     nonBackToBackIpg1;
-    uint8_t     nonBackToBackIpg2;
-    uint8_t     minIfgEnforcement;
-    uint8_t     backToBackIpg;
-
-    uint8_t     preambleLength;
-    bool        preambleRxEn;
-    bool        preambleTxEn;
-    bool        lengthCheckEnable;
-    bool        magicPacketEnable;
-    bool        padAndCrcEnable;
-    bool        crcEnable;
-
-    bool        alternateBackoffEnable;
-    uint8_t     alternateBackoffVal;
-    bool        backPressureNoBackoff;
-    bool        noBackoff;
-    bool        excessDefer;
-    uint8_t     maxRetransmission;
-    uint16_t    collisionWindow;
-
-    uint16_t    maxFrameLength;
-
-    uint8_t     fifoTxThr;
-    uint8_t     fifoTxWatermarkH;
-    uint8_t     fifoRxWatermarkL;
-} t_DtsecDriverParam;
-
-typedef struct {
     t_FmMacControllerDriver     fmMacControllerDriver;
     t_Handle                    h_App;            /**< Handle to the upper layer application              */
-    t_DtsecMemMap               *p_MemMap;        /**< pointer to dTSEC memory mapped registers.          */
-    t_MiiAccessMemMap           *p_MiiMemMap;     /**< pointer to dTSEC MII memory mapped registers.          */
+    struct dtsec_regs           *p_MemMap;        /**< pointer to dTSEC memory mapped registers.          */
+    struct dtsec_mii_reg        *p_MiiMemMap;     /**< pointer to dTSEC MII memory mapped registers.          */
     uint64_t                    addr;             /**< MAC address of device;                             */
     e_EnetMode                  enetMode;         /**< Ethernet physical interface  */
     t_FmMacExceptionCallback    *f_Exception;
@@ -599,23 +228,17 @@ typedef struct {
     bool                        indAddrRegUsed[DTSEC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
     uint64_t                    paddr[DTSEC_NUM_OF_PADDRS]; /**< MAC address for particular individual address recognition register */
     uint8_t                     numOfIndAddrInRegs; /**< Number of individual addresses in registers for this station. */
-    bool                        debugMode;
     bool                        halfDuplex;
     t_InternalStatistics        internalStatistics;
     t_EthHash                   *p_MulticastAddrHash;      /* pointer to driver's global address hash table  */
     t_EthHash                   *p_UnicastAddrHash;    /* pointer to driver's individual address hash table  */
     uint8_t                     macId;
+    uint8_t                     tbi_phy_addr;
     uint32_t                    exceptions;
     bool                        ptpTsuEnabled;
     bool                        enTsuErrExeption;
     e_FmMacStatisticsLevel      statisticsLevel;
-
-    t_DtsecDriverParam          *p_DtsecDriverParam;
+    struct dtsec_cfg            *p_DtsecDriverParam;
 } t_Dtsec;
 
-
-t_Error DTSEC_MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
-t_Error DTSEC_MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
-
-
 #endif /* __DTSEC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
index 8ae995c..371e1f9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -41,55 +41,7 @@
 #include "std_ext.h"
 #include "fm_mac.h"
 #include "dtsec.h"
-
-
-static uint8_t GetMiiDiv(int32_t refClk)
-{
-    uint32_t    div,tmpClk;
-    int         minRange;
-
-    div = 1;
-    minRange = (int)(refClk/40 - 1);
-
-    tmpClk = (uint32_t)ABS(refClk/60 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 2;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/60 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 3;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/80 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 4;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/100 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 5;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/140 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 6;
-        minRange = (int)tmpClk;
-    }
-    tmpClk = (uint32_t)ABS(refClk/280 - 1);
-    if (tmpClk < minRange)
-    {
-        div = 7;
-        minRange = (int)tmpClk;
-    }
-
-    return (uint8_t)div;
-}
+#include "fsl_fman_dtsec_mii_acc.h"
 
 
 /*****************************************************************************/
@@ -98,40 +50,18 @@ t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
                               uint8_t     reg,
                               uint16_t    data)
 {
-    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_MiiAccessMemMap   *p_MiiAccess;
-    uint32_t            tmpReg;
+    t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    struct dtsec_mii_reg *miiregs;
+    t_Error               err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
 
-    p_MiiAccess = p_Dtsec->p_MiiMemMap;
-
-    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg,
-                 (uint32_t)GetMiiDiv((int32_t)(((p_Dtsec->fmMacControllerDriver.clkFreq*10)/2)/8)));
-
-    CORE_MemoryBarrier();
-
-    /* Stop the MII management read cycle */
-    WRITE_UINT32(p_MiiAccess->miimcom, 0);
-    /* Dummy read to make sure MIIMCOM is written */
-    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+    miiregs = p_Dtsec->p_MiiMemMap;
 
-    /* Setting up MII Management Address Register */
-    tmpReg = (uint32_t)((phyAddr << MIIMADD_PHY_ADDR_SHIFT) | reg);
-    WRITE_UINT32(p_MiiAccess->miimadd, tmpReg);
+    err = (t_Error)dtsec_mii_write_reg(miiregs, phyAddr, reg, data);
 
-    /* Setting up MII Management Control Register with data */
-    WRITE_UINT32(p_MiiAccess->miimcon, (uint32_t)data);
-    /* Dummy read to make sure MIIMCON is written */
-    tmpReg = GET_UINT32(p_MiiAccess->miimcon);
-
-    CORE_MemoryBarrier();
-
-    /* Wait till MII management write is complete */
-    while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
-
-    return E_OK;
+    return err;
 }
 
 /*****************************************************************************/
@@ -140,45 +70,40 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
                              uint8_t  reg,
                              uint16_t *p_Data)
 {
-    t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_MiiAccessMemMap   *p_MiiAccess;
-    uint32_t            tmpReg;
+    t_Dtsec               *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    struct dtsec_mii_reg  *miiregs;
+    t_Error                err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
 
-    p_MiiAccess = p_Dtsec->p_MiiMemMap;
-
-    WRITE_UINT32(p_Dtsec->p_MiiMemMap->miimcfg,
-                 (uint32_t)GetMiiDiv((int32_t)(((p_Dtsec->fmMacControllerDriver.clkFreq*10)/2)/8)));
-
-    CORE_MemoryBarrier();
+    miiregs = p_Dtsec->p_MiiMemMap;
 
-    /* Setting up the MII Management Address Register */
-    tmpReg = (uint32_t)((phyAddr << MIIMADD_PHY_ADDR_SHIFT) | reg);
-    WRITE_UINT32(p_MiiAccess->miimadd, tmpReg);
+    err = (t_Error)dtsec_mii_read_reg(miiregs, phyAddr, reg, p_Data);
 
-    /* Perform an MII management read cycle */
-    WRITE_UINT32(p_MiiAccess->miimcom, MIIMCOM_READ_CYCLE);
-    /* Dummy read to make sure MIIMCOM is written */
-    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+    if (*p_Data == 0xffff)
+        RETURN_ERROR(MINOR, E_NO_DEVICE,
+                     ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x",
+                      phyAddr, reg));
+    if (err)
+        RETURN_ERROR(MINOR, err, NO_MSG);
 
-    CORE_MemoryBarrier();
+    return err;
+}
 
-    /* Wait till MII management read is complete */
-    while ((GET_UINT32(p_MiiAccess->miimind)) & MIIMIND_BUSY) ;
+t_Error DTSEC_MII_Init(t_Handle h_Dtsec)
+{
+    t_Dtsec                *p_Dtsec = (t_Dtsec *)h_Dtsec;
+    struct dtsec_mii_reg  *miiregs;
+    uint16_t dtsec_freq;
 
-    /* Read MII management status  */
-    *p_Data = (uint16_t)GET_UINT32(p_MiiAccess->miimstat);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
 
-    WRITE_UINT32(p_MiiAccess->miimcom, 0);
-    /* Dummy read to make sure MIIMCOM is written */
-    tmpReg = GET_UINT32(p_MiiAccess->miimcom);
+    miiregs = p_Dtsec->p_MiiMemMap;
+    dtsec_freq = (uint16_t)(p_Dtsec->fmMacControllerDriver.clkFreq >> 1);
 
-    if (*p_Data == 0xffff)
-        RETURN_ERROR(MINOR, E_NO_DEVICE,
-                     ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x",
-                      phyAddr, reg));
+    dtsec_mii_init(miiregs, dtsec_freq);
 
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
index d84a0ea..d5dd39a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -37,41 +37,9 @@
 #include "std_ext.h"
 
 
-/* MII Management Configuration Register */
-#define MIIMCFG_RESET_MGMT          0x80000000
-#define MIIMCFG_MGMT_CLOCK_SELECT   0x00000007
-
-/* MII  Management Command Register */
-#define MIIMCOM_READ_CYCLE          0x00000001
-#define MIIMCOM_SCAN_CYCLE          0x00000002
-
-/* MII  Management Address Register */
-#define MIIMADD_PHY_ADDR_SHIFT      8
-
-/* MII Management Indicator Register */
-#define MIIMIND_BUSY                0x00000001
-
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-
-/*----------------------------------------------------*/
-/* MII Configuration Control Memory Map Registers     */
-/*----------------------------------------------------*/
-typedef _Packed struct t_MiiAccessMemMap
-{
-    volatile uint32_t miimcfg;    /* MII Mgmt:configuration */
-    volatile uint32_t miimcom;    /* MII Mgmt:command       */
-    volatile uint32_t miimadd;    /* MII Mgmt:address       */
-    volatile uint32_t miimcon;    /* MII Mgmt:control 3     */
-    volatile uint32_t miimstat;   /* MII Mgmt:status        */
-    volatile uint32_t miimind;    /* MII Mgmt:indicators    */
-} _PackedType t_MiiAccessMemMap ;
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
+t_Error DTSEC_MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error DTSEC_MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+t_Error DTSEC_MII_Init(t_Handle h_Dtsec);
 
 
 #endif /* __DTSEC_MII_ACC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
index dca18e1..9cf829e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.c
@@ -556,6 +556,10 @@ t_Error FM_MAC_AdjustLink(t_Handle h_FmMac, e_EnetSpeed speed, bool fullDuplex)
     if (p_FmMacControllerDriver->f_FM_MAC_AdjustLink)
         return p_FmMacControllerDriver->f_FM_MAC_AdjustLink(h_FmMac, speed, fullDuplex);
 
+#if (DPAA_VERSION >= 11)
+    return E_OK;
+#endif
+
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
 }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
index 5abc1b9..94f7b09 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fm_mac.h
@@ -51,20 +51,10 @@
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
-#define DEFAULT_wanModeEnable               FALSE
-#define DEFAULT_promiscuousEnable           FALSE
-#define DEFAULT_rxIgnorePause               FALSE
-#define DEFAULT_maxFrameLength              0x600
-#define DEFAULT_pauseTime                   0xf000
-#define DEFAULT_halfDuplex                  FALSE
-#define DEFAULT_loopback                    FALSE
-#define DEFAULT_lengthCheckEnable           FALSE
-#define DEFAULT_padAndCrcEnable             TRUE
 
-#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-#define DEFAULT_skipFman11Workaround        FALSE
-#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
+#define DEFAULT_halfDuplex                  FALSE
+#define DEFAULT_padAndCrcEnable             TRUE
 #define DEFAULT_resetOnInit                 FALSE
 
 
@@ -181,7 +171,7 @@ static __inline__ void FreeHashTable(t_EthHash *p_Hash)
     {
         if  (p_Hash->p_Lsts)
         {
-            for(i=0; i<p_Hash->size; i++)
+            for (i=0; i<p_Hash->size; i++)
             {
                 p_HashEntry = DequeueAddrFromHashEntry(&p_Hash->p_Lsts[i]);
                 while (p_HashEntry)
@@ -222,7 +212,7 @@ static __inline__ t_EthHash * AllocHashTable(uint16_t size)
         return NULL;
     }
 
-    for(i=0 ; i<p_Hash->size; i++)
+    for (i=0 ; i<p_Hash->size; i++)
         INIT_LIST(&p_Hash->p_Lsts[i]);
 
     return p_Hash;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.c
new file mode 100644
index 0000000..b6a4ca2
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.c
@@ -0,0 +1,119 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "fman_crc32.h"
+#include "common/general.h"
+
+
+/* precomputed CRC values for address hashing */
+static const uint32_t crc_tbl[256] = {
+	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+	0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+	0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+	0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+	0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+};
+
+/* Get the mirrored value of a byte size number. (0x11010011 --> 0x11001011) */
+static inline uint8_t get_mirror8(uint8_t n)
+{
+	uint8_t mirror[16] = {
+		0x00, 0x08, 0x04, 0x0c, 0x02, 0x0a, 0x06, 0x0e,
+		0x01, 0x09, 0x05, 0x0d, 0x03, 0x0b, 0x07, 0x0f
+	};
+	return (uint8_t)(((mirror[n & 0x0f] << 4) | (mirror[n >> 4])));
+}
+
+static inline uint32_t get_mirror32(uint32_t n)
+{
+	return ((uint32_t)get_mirror8((uint8_t)(n))<<24) |
+		((uint32_t)get_mirror8((uint8_t)(n>>8))<<16) |
+		((uint32_t)get_mirror8((uint8_t)(n>>16))<<8) |
+		((uint32_t)get_mirror8((uint8_t)(n>>24)));
+}
+
+uint32_t get_mac_addr_crc(uint64_t _addr)
+{
+	uint32_t i;
+	uint8_t  data;
+	uint32_t crc;
+
+	/* CRC calculation */
+	crc = 0xffffffff;
+	for (i = 0; i < 6; i++) {
+		data = (uint8_t)(_addr >> ((5-i)*8));
+		crc = crc ^ data;
+		crc = crc_tbl[crc&0xff] ^ (crc>>8);
+	}
+
+	crc = get_mirror32(crc);
+	return crc;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.h
new file mode 100644
index 0000000..6e32fdc
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_crc32.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __FMAN_CRC32_H
+#define __FMAN_CRC32_H
+
+#include "common/general.h"
+
+
+uint32_t get_mac_addr_crc(uint64_t _addr);
+
+
+#endif /* __FMAN_CRC32_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c
new file mode 100644
index 0000000..ee03fa7
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec.c
@@ -0,0 +1,865 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "fsl_fman_dtsec.h"
+
+
+void dtsec_stop_rx(struct dtsec_regs *regs)
+{
+	/* Assert the graceful stop bit */
+	iowrite32be(ioread32be(&regs->rctrl) | RCTRL_GRS, &regs->rctrl);
+}
+
+void dtsec_stop_tx(struct dtsec_regs *regs)
+{
+	/* Assert the graceful stop bit */
+	iowrite32be(ioread32be(&regs->tctrl) | DTSEC_TCTRL_GTS, &regs->tctrl);
+}
+
+void dtsec_start_tx(struct dtsec_regs *regs)
+{
+	/* clear the graceful stop bit */
+	iowrite32be(ioread32be(&regs->tctrl) & ~DTSEC_TCTRL_GTS, &regs->tctrl);
+}
+
+void dtsec_start_rx(struct dtsec_regs *regs)
+{
+	/* clear the graceful stop bit */
+	iowrite32be(ioread32be(&regs->rctrl) & ~RCTRL_GRS, &regs->rctrl);
+}
+
+
+void dtsec_defconfig(struct dtsec_cfg *cfg)
+{
+	cfg->halfdup_on = FALSE;
+	cfg->halfdup_retransmit = 0xf;
+	cfg->halfdup_coll_window = 0x37;
+	cfg->halfdup_excess_defer = TRUE;
+	cfg->halfdup_no_backoff = FALSE;
+	cfg->halfdup_bp_no_backoff = FALSE;
+	cfg->halfdup_alt_backoff_val = 0x0A;
+	cfg->halfdup_alt_backoff_en = FALSE;
+
+	cfg->rx_drop_bcast = FALSE;
+	cfg->rx_short_frm = TRUE;
+	cfg->rx_len_check = FALSE;
+	cfg->tx_pad_crc = TRUE;
+	cfg->tx_crc = FALSE;
+	cfg->rx_ctrl_acc = FALSE;
+	cfg->tx_pause_time = 0xf000;
+	cfg->tbipa = 5; /* PHY address 0 is reserved (DPAA RM)*/
+
+	cfg->rx_prepend = 0;
+
+	cfg->ptp_tsu_en = TRUE;
+	cfg->ptp_exception_en = TRUE;
+
+	cfg->preamble_len = 7;
+	cfg->rx_preamble = FALSE;
+	cfg->tx_preamble = FALSE;
+
+	cfg->loopback = FALSE;
+	cfg->rx_time_stamp_en = FALSE;
+	cfg->tx_time_stamp_en = FALSE;
+	cfg->rx_flow = TRUE;
+	cfg->tx_flow = TRUE;
+	cfg->rx_group_hash_exd = FALSE;
+	cfg->tx_pause_time_extd = 0;
+	cfg->rx_promisc = FALSE;
+	cfg->non_back_to_back_ipg1 = 0x40;
+	cfg->non_back_to_back_ipg2 = 0x60;
+	cfg->min_ifg_enforcement = 0x50;
+	cfg->back_to_back_ipg = 0x60;
+	cfg->maximum_frame = 0x600;
+
+	cfg->tbi_phy_addr = 5;
+}
+
+int dtsec_init(struct dtsec_regs *regs, struct dtsec_cfg *cfg,
+		enum enet_interface iface_mode,
+		enum enet_speed iface_speed,
+		uint8_t *macaddr,
+		uint8_t fm_rev_maj,
+		uint8_t fm_rev_min,
+		uint32_t exception_mask)
+{
+	bool		is_rgmii = FALSE;
+	bool		is_sgmii = FALSE;
+	bool		is_qsgmii = FALSE;
+	int		i;
+	uint32_t	tmp;
+
+UNUSED(fm_rev_maj);UNUSED(fm_rev_min);
+
+	/* let's start with a soft reset */
+	iowrite32be(MACCFG1_SOFT_RESET, &regs->maccfg1);
+	iowrite32be(0, &regs->maccfg1);
+
+	/*************dtsec_id2******************/
+	tmp =  ioread32be(&regs->tsec_id2);
+
+	/* check RGMII support */
+	if (iface_mode == enet_if_rgmii ||
+			iface_mode == enet_if_rmii)
+		if (tmp & DTSEC_ID2_INT_REDUCED_OFF)
+			return -EINVAL;
+
+	if (iface_mode == enet_if_sgmii ||
+			iface_mode == enet_if_mii)
+		if (tmp & DTSEC_ID2_INT_REDUCED_OFF)
+			return -EINVAL;
+
+	/***************ECNTRL************************/
+
+	is_rgmii = (bool)((iface_mode == enet_if_rgmii) ? TRUE : FALSE);
+	is_sgmii = (bool)((iface_mode == enet_if_sgmii) ? TRUE : FALSE);
+	is_qsgmii = (bool)((iface_mode == enet_if_qsgmii) ? TRUE : FALSE);
+
+	tmp = 0;
+	if (is_rgmii || iface_mode == enet_if_gmii)
+		tmp |= DTSEC_ECNTRL_GMIIM;
+	if (is_sgmii)
+		tmp |= (DTSEC_ECNTRL_SGMIIM | DTSEC_ECNTRL_TBIM);
+	if (is_qsgmii)
+		tmp |= (DTSEC_ECNTRL_SGMIIM | DTSEC_ECNTRL_TBIM | DTSEC_ECNTRL_QSGMIIM);
+	if (is_rgmii)
+		tmp |= DTSEC_ECNTRL_RPM;
+	if (iface_speed == enet_speed_100)
+		tmp |= DTSEC_ECNTRL_R100M;
+
+	iowrite32be(tmp, &regs->ecntrl);
+	/***************ECNTRL************************/
+
+	/***************TCTRL************************/
+	tmp = 0;
+	if (cfg->halfdup_on)
+		tmp |= DTSEC_TCTRL_THDF;
+	if (cfg->tx_time_stamp_en)
+		tmp |= DTSEC_TCTRL_TTSE;
+
+	iowrite32be(tmp, &regs->tctrl);
+
+	/***************TCTRL************************/
+
+	/***************PTV************************/
+	tmp = 0;
+
+#ifdef FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1
+	if ((fm_rev_maj == 1) && (fm_rev_min == 0))
+		cfg->tx_pause_time += 2;
+#endif /* FM_SHORT_PAUSE_TIME_ERRATA_DTSEC1 */
+
+	if (cfg->tx_pause_time)
+		tmp |= cfg->tx_pause_time;
+	if (cfg->tx_pause_time_extd)
+		tmp |= cfg->tx_pause_time_extd << PTV_PTE_OFST;
+	iowrite32be(tmp, &regs->ptv);
+
+	/***************RCTRL************************/
+	tmp = 0;
+	tmp |= ((uint32_t)(cfg->rx_prepend & 0x0000001f)) << 16;
+	if (cfg->rx_ctrl_acc)
+		tmp |= RCTRL_CFA;
+	if (cfg->rx_group_hash_exd)
+		tmp |= RCTRL_GHTX;
+	if (cfg->rx_time_stamp_en)
+		tmp |= RCTRL_RTSE;
+	if (cfg->rx_drop_bcast)
+		tmp |= RCTRL_BC_REJ;
+	if (cfg->rx_short_frm)
+		tmp |= RCTRL_RSF;
+	if (cfg->rx_promisc)
+		tmp |= RCTRL_PROM;
+
+	iowrite32be(tmp, &regs->rctrl);
+	/***************RCTRL************************/
+
+	/*
+	 * Assign a Phy Address to the TBI (TBIPA).
+	 * Done also in cases where TBI is not selected to avoid conflict with
+	 * the external PHY's Physical address
+	 */
+	iowrite32be(cfg->tbipa, &regs->tbipa);
+
+	/***************TMR_CTL************************/
+	iowrite32be(0, &regs->tmr_ctrl);
+
+	if (cfg->ptp_tsu_en) {
+		tmp = 0;
+		tmp |= TMR_PEVENT_TSRE;
+		iowrite32be(tmp, &regs->tmr_pevent);
+
+		if (cfg->ptp_exception_en) {
+			tmp = 0;
+			tmp |= TMR_PEMASK_TSREEN;
+			iowrite32be(tmp, &regs->tmr_pemask);
+		}
+	}
+
+	/***************MACCFG1***********************/
+	tmp = 0;
+	if (cfg->loopback)
+		tmp |= MACCFG1_LOOPBACK;
+	if (cfg->rx_flow)
+		tmp |= MACCFG1_RX_FLOW;
+	if (cfg->tx_flow)
+		tmp |= MACCFG1_TX_FLOW;
+	iowrite32be(tmp, &regs->maccfg1);
+
+	/***************MACCFG1***********************/
+
+	/***************MACCFG2***********************/
+	tmp = 0;
+
+	if (iface_speed < enet_speed_1000)
+		tmp |= MACCFG2_NIBBLE_MODE;
+	else if (iface_speed == enet_speed_1000)
+		tmp |= MACCFG2_BYTE_MODE;
+
+	tmp |= ((uint32_t) cfg->preamble_len & 0x0000000f)
+		<< PREAMBLE_LENGTH_SHIFT;
+
+	if (cfg->rx_preamble)
+		tmp |= MACCFG2_PRE_AM_Rx_EN;
+	if (cfg->tx_preamble)
+		tmp |= MACCFG2_PRE_AM_Tx_EN;
+	if (cfg->rx_len_check)
+		tmp |= MACCFG2_LENGTH_CHECK;
+	if (cfg->tx_pad_crc)
+		tmp |= MACCFG2_PAD_CRC_EN;
+	if (cfg->tx_crc)
+		tmp |= MACCFG2_CRC_EN;
+	if (!cfg->halfdup_on)
+		tmp |= MACCFG2_FULL_DUPLEX;
+	iowrite32be(tmp, &regs->maccfg2);
+
+	/***************MACCFG2***********************/
+
+	/***************IPGIFG************************/
+	tmp = 0;
+	tmp = (((cfg->non_back_to_back_ipg1 <<
+		IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT)
+		& IPGIFG_NON_BACK_TO_BACK_IPG_1)
+		| ((cfg->non_back_to_back_ipg2 <<
+		IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT)
+		& IPGIFG_NON_BACK_TO_BACK_IPG_2)
+		| ((cfg->min_ifg_enforcement <<
+		IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT)
+		& IPGIFG_MIN_IFG_ENFORCEMENT)
+		| (cfg->back_to_back_ipg & IPGIFG_BACK_TO_BACK_IPG));
+	iowrite32be(tmp, &regs->ipgifg);
+
+	/***************IPGIFG************************/
+
+	/***************HAFDUP************************/
+	tmp = 0;
+
+	if (cfg->halfdup_alt_backoff_en)
+		tmp = (uint32_t)(HAFDUP_ALT_BEB |
+				((cfg->halfdup_alt_backoff_val & 0x0000000f)
+				 << HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT));
+	if (cfg->halfdup_bp_no_backoff)
+		tmp |= HAFDUP_BP_NO_BACKOFF;
+	if (cfg->halfdup_no_backoff)
+		tmp |= HAFDUP_NO_BACKOFF;
+	if (cfg->halfdup_excess_defer)
+		tmp |= HAFDUP_EXCESS_DEFER;
+	tmp |= ((cfg->halfdup_retransmit << HAFDUP_RETRANSMISSION_MAX_SHIFT)
+		& HAFDUP_RETRANSMISSION_MAX);
+	tmp |= (cfg->halfdup_coll_window & HAFDUP_COLLISION_WINDOW);
+
+	iowrite32be(tmp, &regs->hafdup);
+	/***************HAFDUP************************/
+
+	/***************MAXFRM************************/
+	/* Initialize MAXFRM */
+	iowrite32be(cfg->maximum_frame, &regs->maxfrm);
+
+	/***************MAXFRM************************/
+
+	/***************CAM1************************/
+	iowrite32be(0xffffffff, &regs->cam1);
+	iowrite32be(0xffffffff, &regs->cam2);
+
+	/***************IMASK************************/
+	iowrite32be(exception_mask, &regs->imask);
+	/***************IMASK************************/
+
+	/***************IEVENT************************/
+	iowrite32be(0xffffffff, &regs->ievent);
+
+	/***************MACSTNADDR1/2*****************/
+
+	tmp = (uint32_t)((macaddr[5] << 24) |
+			 (macaddr[4] << 16) |
+			 (macaddr[3] << 8) |
+			  macaddr[2]);
+	iowrite32be(tmp, &regs->macstnaddr1);
+
+	tmp = (uint32_t)((macaddr[1] << 24) |
+			 (macaddr[0] << 16));
+	iowrite32be(tmp, &regs->macstnaddr2);
+
+	/***************MACSTNADDR1/2*****************/
+
+	/*****************HASH************************/
+	for (i = 0; i < NUM_OF_HASH_REGS ; i++) {
+		/* Initialize IADDRx */
+		iowrite32be(0, &regs->igaddr[i]);
+		/* Initialize GADDRx */
+		iowrite32be(0, &regs->gaddr[i]);
+	}
+
+	dtsec_reset_stat(regs);
+
+	return 0;
+}
+
+uint16_t dtsec_get_max_frame_len(struct dtsec_regs *regs)
+{
+	return (uint16_t)ioread32be(&regs->maxfrm);
+}
+
+void dtsec_set_max_frame_len(struct dtsec_regs *regs, uint16_t length)
+{
+	iowrite32be(length, &regs->maxfrm);
+}
+
+void dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *adr)
+{
+	uint32_t tmp;
+
+	tmp = (uint32_t)((adr[5] << 24) |
+			 (adr[4] << 16) |
+			 (adr[3] << 8) |
+			  adr[2]);
+	iowrite32be(tmp, &regs->macstnaddr1);
+
+	tmp = (uint32_t)((adr[1] << 24) |
+			 (adr[0] << 16));
+	iowrite32be(tmp, &regs->macstnaddr2);
+}
+
+void dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr)
+{
+	uint32_t tmp1, tmp2;
+
+	tmp1 = ioread32be(&regs->macstnaddr1);
+	tmp2 = ioread32be(&regs->macstnaddr2);
+
+	macaddr[0] = (uint8_t)((tmp2 & 0x00ff0000) >> 16);
+	macaddr[1] = (uint8_t)((tmp2 & 0xff000000) >> 24);
+	macaddr[2] = (uint8_t)(tmp1 & 0x000000ff);
+	macaddr[3] = (uint8_t)((tmp1 & 0x0000ff00) >> 8);
+	macaddr[4] = (uint8_t)((tmp1 & 0x00ff0000) >> 16);
+	macaddr[5] = (uint8_t)((tmp1 & 0xff000000) >> 24);
+}
+
+int dtsec_compute_bucket(struct dtsec_regs *regs, unsigned char addr[6],
+			 int32_t *bucket)
+{
+	uint64_t _addr;
+	uint32_t crc;
+	bool ghtx;
+	bool mcast;
+
+	_addr = (*(uint64_t *)addr) >> 16;
+	ghtx = (bool)((ioread32be(&regs->rctrl) & RCTRL_GHTX) ? TRUE : FALSE);
+	mcast = (bool)((_addr & MAC_GROUP_ADDRESS) ? TRUE : FALSE);
+
+	if (ghtx && !mcast) /* Cannot handle unicast mac addr when GHTX is on */
+		return -EINVAL;
+
+
+	/* CRC calculation - returns 32 bit CRC */
+	crc = ether_crc(6, addr);
+
+	/* considering the 9 highest order bits in crc H[8:0]:
+	 * if ghtx = 0 H[8:6] (highest order 3 bits) identify the hash register
+	 * and H[5:1] (next 5 bits) identify the hash bit
+	 * if ghts = 1 H[8:5] (highest order 4 bits) identify the hash register
+	 * and H[4:0] (next 5 bits) identify the hash bit.
+	 *
+	 * In bucket index output the low 5 bits identify the hash register bit,
+	 * while the higher 4 bits identify the hash register
+	 */
+	if (ghtx)
+		*bucket = (int32_t)((crc >> 23) & 0x1ff);
+	else {
+		*bucket = (int32_t)((crc >> 24) & 0xff);
+	  /* if !ghtx and mcast the bit must be set in gaddr
+	   * instead of igaddr.
+	   */
+	  if (mcast)
+		*bucket += 0x100;
+	}
+	return 0;
+}
+
+void dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable)
+{
+	int reg_idx = (bucket >> 5) & 0xf;
+	int bit_idx = bucket & 0x1f;
+	uint32_t bit_mask = 0x80000000 >> bit_idx;
+	uint32_t *reg;
+
+	if (reg_idx > 7)
+		reg = &regs->gaddr[reg_idx-8];
+	else
+		reg = &regs->igaddr[reg_idx];
+
+	if (enable)
+		iowrite32be(ioread32be(reg) | bit_mask, reg);
+	else
+		iowrite32be(ioread32be(reg) & (~bit_mask), reg);
+}
+
+void dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast)
+{
+	int		i;
+	bool	ghtx;
+
+	ghtx = (bool)((ioread32be(&regs->rctrl) & RCTRL_GHTX) ? TRUE : FALSE);
+
+	if (ucast || (ghtx && mcast)) {
+		for (i = 0; i < NUM_OF_HASH_REGS; i++)
+			iowrite32be(0, &regs->igaddr[i]);
+	}
+	if (mcast) {
+		for (i = 0; i < NUM_OF_HASH_REGS; i++)
+			iowrite32be(0, &regs->gaddr[i]);
+	}
+}
+
+int dtsec_set_tbi_phy_addr(struct dtsec_regs *regs,
+		uint8_t addr)
+{
+	if (addr > 0 && addr < 32)
+		iowrite32be(addr, &regs->tbipa);
+	else
+		return -EINVAL;
+
+	return 0;
+}
+
+int dtsec_adjust_link(struct dtsec_regs *regs,
+		enum enet_interface iface_mode,
+		enum enet_speed speed, bool full_dx)
+{
+	uint32_t		tmp;
+
+	if ((iface_mode == enet_if_xgmii || iface_mode == enet_if_sgmii ||
+		iface_mode == enet_if_qsgmii) && !full_dx)
+		return -EINVAL;
+
+	tmp = ioread32be(&regs->maccfg2);
+	if (!full_dx)
+		tmp &= ~MACCFG2_FULL_DUPLEX;
+	else
+		tmp |= MACCFG2_FULL_DUPLEX;
+
+	tmp &= ~(MACCFG2_NIBBLE_MODE | MACCFG2_BYTE_MODE);
+	if (speed < enet_speed_1000)
+		tmp |= MACCFG2_NIBBLE_MODE;
+	else if (speed == enet_speed_1000)
+		tmp |= MACCFG2_BYTE_MODE;
+	iowrite32be(tmp, &regs->maccfg2);
+
+	tmp = ioread32be(&regs->ecntrl);
+	if (speed == enet_speed_100)
+		tmp |= DTSEC_ECNTRL_R100M;
+	else
+		tmp &= ~DTSEC_ECNTRL_R100M;
+	iowrite32be(tmp, &regs->ecntrl);
+
+	return 0;
+}
+
+void dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable)
+{
+	uint32_t		tmp;
+
+	tmp = ioread32be(&regs->rctrl);
+
+	if (enable)
+		tmp |= RCTRL_UPROM;
+	else
+		tmp &= ~RCTRL_UPROM;
+
+	iowrite32be(tmp, &regs->rctrl);
+}
+
+void dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable)
+{
+	uint32_t		tmp;
+
+	tmp = ioread32be(&regs->rctrl);
+
+	if (enable)
+		tmp |= RCTRL_MPROM;
+	else
+		tmp &= ~RCTRL_MPROM;
+
+	iowrite32be(tmp, &regs->rctrl);
+}
+
+bool dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
+				uint32_t *car1, uint32_t *car2)
+{
+	/* read carry registers */
+	*car1 = ioread32be(&regs->car1);
+	*car2 = ioread32be(&regs->car2);
+	/* clear carry registers */
+	if (*car1)
+		iowrite32be(*car1, &regs->car1);
+	if (*car2)
+		iowrite32be(*car2, &regs->car2);
+
+	return (bool)((*car1 | *car2) ? TRUE : FALSE);
+}
+
+
+void dtsec_reset_stat(struct dtsec_regs *regs)
+{
+	/* clear HW counters */
+	iowrite32be(ioread32be(&regs->ecntrl) | DTSEC_ECNTRL_CLRCNT, &regs->ecntrl);
+}
+
+int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level)
+{
+	switch (level) {
+	case mac_stat_none:
+		iowrite32be(0xffffffff, &regs->cam1);
+		iowrite32be(0xffffffff, &regs->cam2);
+		iowrite32be(ioread32be(&regs->ecntrl) & ~DTSEC_ECNTRL_STEN,
+				&regs->ecntrl);
+		iowrite32be(ioread32be(&regs->imask) & ~DTSEC_IMASK_MSROEN,
+				&regs->imask);
+		break;
+	case mac_stat_partial:
+		iowrite32be(CAM1_ERRORS_ONLY, &regs->cam1);
+		iowrite32be(CAM2_ERRORS_ONLY, &regs->cam2);
+		iowrite32be(ioread32be(&regs->ecntrl) | DTSEC_ECNTRL_STEN,
+				&regs->ecntrl);
+		iowrite32be(ioread32be(&regs->imask) | DTSEC_IMASK_MSROEN,
+				&regs->imask);
+		break;
+	case mac_stat_mib_grp1:
+		iowrite32be((uint32_t)~CAM1_MIB_GRP_1, &regs->cam1);
+		iowrite32be((uint32_t)~CAM2_MIB_GRP_1, &regs->cam2);
+		iowrite32be(ioread32be(&regs->ecntrl) | DTSEC_ECNTRL_STEN,
+				&regs->ecntrl);
+		iowrite32be(ioread32be(&regs->imask) | DTSEC_IMASK_MSROEN,
+				&regs->imask);
+		break;
+	case mac_stat_full:
+		iowrite32be(0, &regs->cam1);
+		iowrite32be(0, &regs->cam2);
+		iowrite32be(ioread32be(&regs->ecntrl) | DTSEC_ECNTRL_STEN,
+				&regs->ecntrl);
+		iowrite32be(ioread32be(&regs->imask) | DTSEC_IMASK_MSROEN,
+				&regs->imask);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+void dtsec_set_ts(struct dtsec_regs *regs, bool en)
+{
+	if (en) {
+		iowrite32be(ioread32be(&regs->rctrl) | RCTRL_RTSE,
+				&regs->rctrl);
+		iowrite32be(ioread32be(&regs->tctrl) | DTSEC_TCTRL_TTSE,
+				&regs->tctrl);
+	} else {
+		iowrite32be(ioread32be(&regs->rctrl) & ~RCTRL_RTSE,
+				&regs->rctrl);
+		iowrite32be(ioread32be(&regs->tctrl) & ~DTSEC_TCTRL_TTSE,
+				&regs->tctrl);
+	}
+}
+
+void dtsec_enable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->maccfg1);
+
+	if (apply_rx)
+		tmp |= MACCFG1_RX_EN ;
+
+	if (apply_tx)
+		tmp |= MACCFG1_TX_EN ;
+
+	iowrite32be(tmp, &regs->maccfg1);
+}
+
+void dtsec_clear_addr_in_paddr(struct dtsec_regs *regs, uint8_t paddr_num)
+{
+    iowrite32be(0, &regs->macaddr[paddr_num].exact_match1);
+    iowrite32be(0, &regs->macaddr[paddr_num].exact_match2);
+}
+
+/* ........................................................................... */
+
+void dtsec_add_addr_in_paddr(struct dtsec_regs *regs,
+                             uint64_t addr,
+                             uint8_t paddr_num)
+{
+    uint32_t tmp;
+
+    tmp = (uint32_t)(addr);
+    /* swap */
+    tmp = (((tmp & 0x000000FF) << 24) |
+           ((tmp & 0x0000FF00) <<  8) |
+           ((tmp & 0x00FF0000) >>  8) |
+           ((tmp & 0xFF000000) >> 24));
+    iowrite32be(tmp, &regs->macaddr[paddr_num].exact_match1);
+
+    tmp = (uint32_t)(addr>>32);
+    /* swap */
+    tmp = (((tmp & 0x000000FF) << 24) |
+           ((tmp & 0x0000FF00) <<  8) |
+           ((tmp & 0x00FF0000) >>  8) |
+           ((tmp & 0xFF000000) >> 24));
+    iowrite32be(tmp, &regs->macaddr[paddr_num].exact_match2);
+}
+
+/* ........................................................................... */
+
+
+void dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->maccfg1);
+
+	if (apply_rx)
+		tmp &= ~MACCFG1_RX_EN;
+
+	if (apply_tx)
+		tmp &= ~MACCFG1_TX_EN;
+
+	iowrite32be(tmp, &regs->maccfg1);
+}
+
+void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time)
+{
+	uint32_t		ptv = 0;
+
+	/* fixme: don't enable tx pause for half-duplex */
+
+	if (time) {
+		ptv = ioread32be(&regs->ptv);
+		ptv &= 0xffff0000;
+		ptv |= time & 0x0000ffff;
+		iowrite32be(ptv, &regs->ptv);
+
+		/* trigger the transmission of a flow-control pause frame */
+		iowrite32be(ioread32be(&regs->maccfg1) | MACCFG1_TX_FLOW,
+				&regs->maccfg1);
+	} else
+		iowrite32be(ioread32be(&regs->maccfg1) & ~MACCFG1_TX_FLOW,
+				&regs->maccfg1);
+}
+
+void dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en)
+{
+	uint32_t		tmp;
+
+	/* todo: check if mac is set to full-duplex */
+
+	tmp = ioread32be(&regs->maccfg1);
+	if (en)
+		tmp |= MACCFG1_RX_FLOW;
+	else
+		tmp &= ~MACCFG1_RX_FLOW;
+	iowrite32be(tmp, &regs->maccfg1);
+}
+
+uint32_t dtsec_get_revision(struct dtsec_regs *regs)
+{
+	return ioread32be(&regs->tsec_id);
+}
+
+uint32_t dtsec_get_event(struct dtsec_regs *regs, uint32_t ev_mask)
+{
+	return ioread32be(&regs->ievent) & ev_mask;
+}
+
+void dtsec_ack_event(struct dtsec_regs *regs, uint32_t ev_mask)
+{
+	iowrite32be(ev_mask, &regs->ievent);
+}
+
+uint32_t dtsec_get_interrupt_mask(struct dtsec_regs *regs)
+{
+	return ioread32be(&regs->imask);
+}
+
+uint32_t dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs)
+{
+	uint32_t event;
+
+	event = ioread32be(&regs->tmr_pevent);
+	event &= ioread32be(&regs->tmr_pemask);
+
+	if (event)
+		iowrite32be(event, &regs->tmr_pevent);
+	return event;
+}
+
+void dtsec_enable_tmr_interrupt(struct dtsec_regs *regs)
+{
+	iowrite32be(ioread32be(&regs->tmr_pemask) | TMR_PEMASK_TSREEN,
+		    &regs->tmr_pemask);
+}
+
+void dtsec_disable_tmr_interrupt(struct dtsec_regs *regs)
+{
+	iowrite32be(ioread32be(&regs->tmr_pemask) & ~TMR_PEMASK_TSREEN,
+		    &regs->tmr_pemask);
+}
+
+void dtsec_enable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask)
+{
+	iowrite32be(ioread32be(&regs->imask) | ev_mask, &regs->imask);
+}
+
+void dtsec_disable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask)
+{
+	iowrite32be(ioread32be(&regs->imask) & ~ev_mask, &regs->imask);
+}
+
+uint32_t dtsec_get_stat_counter(struct dtsec_regs *regs,
+		enum dtsec_stat_counters reg_name)
+{
+	uint32_t ret_val;
+
+	switch (reg_name) {
+	case E_DTSEC_STAT_TR64:
+		ret_val = ioread32be(&regs->tr64);
+		break;
+	case E_DTSEC_STAT_TR127:
+		ret_val = ioread32be(&regs->tr127);
+		break;
+	case E_DTSEC_STAT_TR255:
+		ret_val = ioread32be(&regs->tr255);
+		break;
+	case E_DTSEC_STAT_TR511:
+		ret_val = ioread32be(&regs->tr511);
+		break;
+	case E_DTSEC_STAT_TR1K:
+		ret_val = ioread32be(&regs->tr1k);
+		break;
+	case E_DTSEC_STAT_TRMAX:
+		ret_val = ioread32be(&regs->trmax);
+		break;
+	case E_DTSEC_STAT_TRMGV:
+		ret_val = ioread32be(&regs->trmgv);
+		break;
+	case E_DTSEC_STAT_RBYT:
+		ret_val = ioread32be(&regs->rbyt);
+		break;
+	case E_DTSEC_STAT_RPKT:
+		ret_val = ioread32be(&regs->rpkt);
+		break;
+	case E_DTSEC_STAT_RMCA:
+		ret_val = ioread32be(&regs->rmca);
+		break;
+	case E_DTSEC_STAT_RBCA:
+		ret_val = ioread32be(&regs->rbca);
+		break;
+	case E_DTSEC_STAT_RXPF:
+		ret_val = ioread32be(&regs->rxpf);
+		break;
+	case E_DTSEC_STAT_RALN:
+		ret_val = ioread32be(&regs->raln);
+		break;
+	case E_DTSEC_STAT_RFLR:
+		ret_val = ioread32be(&regs->rflr);
+		break;
+	case E_DTSEC_STAT_RCDE:
+		ret_val = ioread32be(&regs->rcde);
+		break;
+	case E_DTSEC_STAT_RCSE:
+		ret_val = ioread32be(&regs->rcse);
+		break;
+	case E_DTSEC_STAT_RUND:
+		ret_val = ioread32be(&regs->rund);
+		break;
+	case E_DTSEC_STAT_ROVR:
+		ret_val = ioread32be(&regs->rovr);
+		break;
+	case E_DTSEC_STAT_RFRG:
+		ret_val = ioread32be(&regs->rfrg);
+		break;
+	case E_DTSEC_STAT_RJBR:
+		ret_val = ioread32be(&regs->rjbr);
+		break;
+	case E_DTSEC_STAT_RDRP:
+		ret_val = ioread32be(&regs->rdrp);
+		break;
+	case E_DTSEC_STAT_TFCS:
+		ret_val = ioread32be(&regs->tfcs);
+		break;
+	case E_DTSEC_STAT_TBYT:
+		ret_val = ioread32be(&regs->tbyt);
+		break;
+	case E_DTSEC_STAT_TPKT:
+		ret_val = ioread32be(&regs->tpkt);
+		break;
+	case E_DTSEC_STAT_TMCA:
+		ret_val = ioread32be(&regs->tmca);
+		break;
+	case E_DTSEC_STAT_TBCA:
+		ret_val = ioread32be(&regs->tbca);
+		break;
+	case E_DTSEC_STAT_TXPF:
+		ret_val = ioread32be(&regs->txpf);
+		break;
+	case E_DTSEC_STAT_TNCL:
+		ret_val = ioread32be(&regs->tncl);
+		break;
+	case E_DTSEC_STAT_TDRP:
+		ret_val = ioread32be(&regs->tdrp);
+		break;
+	default:
+		ret_val = 0;
+	}
+
+	return ret_val;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
new file mode 100644
index 0000000..b1b7bae
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "common/general.h"
+#include "fsl_fman_dtsec_mii_acc.h"
+
+
+/**
+ * dtsec_mii_get_div() - calculates the value of the dtsec mii divider
+ * @dtsec_freq:		dtsec clock frequency (in Mhz)
+ *
+ * This function calculates the dtsec mii clock divider that determines
+ * the MII MDC clock. MII MDC clock can work in the range of 2.5 to 12.5 Mhz.
+ * The output of this function is the value of MIIMCFG[MgmtClk] which
+ * implicitly determines the divider value.
+ * Note: the dTSEC system clock is equal to 1/2 of the FMan clock.
+ *
+ * The table below which reflects dtsec_mii_get_div() functionality
+ * shows the relations among dtsec_freq, MgmtClk, actual divider
+ * and the MII frequency:
+ *
+ * dtsec freq   MgmtClk     div         MII freq
+ * [80..159]      0      (1/4)(1/8)   [2.5 to 5.0]
+ * [160..319]     1      (1/4)(1/8)   [5.0 to 10.0]
+ * [320..479]     2      (1/6)(1/8)   [6.7 to 10.0]
+ * [480..639]     3      (1/8)(1/8)   [7.5 to 10.0]
+ * [640..799]     4      (1/10)(1/8)  [8.0 to 10.0]
+ * [800..959]     5      (1/14)(1/8)  [7.1 to 8.5]
+ * [960..1119]    6      (1/20)(1/8)  [6.0 to 7.0]
+ * [1120..1279]   7      (1/28)(1/8)  [5.0 to 5.7]
+ * [1280..2800]   7      (1/28)(1/8)  [5.7 to 12.5]
+ *
+ * Returns: the MIIMCFG[MgmtClk] appropriate value
+ */
+
+static uint8_t dtsec_mii_get_div(uint16_t dtsec_freq)
+{
+	uint16_t mgmt_clk = (uint16_t)(dtsec_freq / 160);
+
+	if (mgmt_clk > 7)
+		mgmt_clk = 7;
+
+	return (uint8_t)mgmt_clk;
+}
+
+void dtsec_mii_reset(struct dtsec_mii_reg *regs)
+{
+	/* Reset the management interface */
+	iowrite32be(ioread32be(&regs->miimcfg) | MIIMCFG_RESET_MGMT,
+			&regs->miimcfg);
+	iowrite32be(ioread32be(&regs->miimcfg) & ~MIIMCFG_RESET_MGMT,
+			&regs->miimcfg);
+}
+
+void dtsec_mii_init(struct dtsec_mii_reg *regs, uint16_t dtsec_freq)
+{
+	/* Setup the MII Mgmt clock speed */
+	iowrite32be((uint32_t)dtsec_mii_get_div(dtsec_freq), &regs->miimcfg);
+}
+
+int dtsec_mii_write_reg(struct dtsec_mii_reg *regs, uint8_t addr,
+		uint8_t reg, uint16_t data)
+{
+	uint32_t	tmp;
+
+	/* Stop the MII management read cycle */
+	iowrite32be(0, &regs->miimcom);
+	/* Dummy read to make sure MIIMCOM is written */
+	tmp = ioread32be(&regs->miimcom);
+
+	/* Setting up MII Management Address Register */
+	tmp = (uint32_t)((addr << MIIMADD_PHY_ADDR_SHIFT) | reg);
+	iowrite32be(tmp, &regs->miimadd);
+
+	/* Setting up MII Management Control Register with data */
+	iowrite32be((uint32_t)data, &regs->miimcon);
+	/* Dummy read to make sure MIIMCON is written */
+	tmp = ioread32be(&regs->miimcon);
+
+	/* Wait untill MII management write is complete */
+	/* todo: a timeout could be useful here */
+	while ((ioread32be(&regs->miimind)) & MIIMIND_BUSY)
+		/* busy wait */;
+
+	return 0;
+}
+
+int dtsec_mii_read_reg(struct dtsec_mii_reg *regs, uint8_t  addr,
+		uint8_t reg, uint16_t *data)
+{
+	uint32_t	tmp;
+
+	/* Setting up the MII Management Address Register */
+	tmp = (uint32_t)((addr << MIIMADD_PHY_ADDR_SHIFT) | reg);
+	iowrite32be(tmp, &regs->miimadd);
+
+	/* Perform an MII management read cycle */
+	iowrite32be(MIIMCOM_READ_CYCLE, &regs->miimcom);
+	/* Dummy read to make sure MIIMCOM is written */
+	tmp = ioread32be(&regs->miimcom);
+
+	/* Wait until MII management read is complete */
+	/* todo: a timeout could be useful here */
+	while ((ioread32be(&regs->miimind)) & MIIMIND_BUSY)
+		/* busy wait */;
+
+	/* Read MII management status  */
+	*data = (uint16_t)ioread32be(&regs->miimstat);
+
+	iowrite32be(0, &regs->miimcom);
+	/* Dummy read to make sure MIIMCOM is written */
+	tmp = ioread32be(&regs->miimcom);
+
+	if (*data == 0xffff)
+		return -ENXIO;
+
+	return 0;
+}
+
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c
new file mode 100644
index 0000000..d56b987
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_memac.c
@@ -0,0 +1,378 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "fsl_fman_memac.h"
+
+
+void memac_set_promiscuous(struct memac_regs *regs, bool val)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&regs->command_config);
+
+    if (val)
+        tmp |= CMD_CFG_PROMIS_EN;
+    else
+        tmp &= ~CMD_CFG_PROMIS_EN;
+
+    iowrite32be(tmp, &regs->command_config);
+}
+
+void memac_hardware_clear_addr_in_paddr(struct memac_regs *regs, uint8_t paddr_num)
+{
+    iowrite32be(0x0, &regs->mac_addr[paddr_num].mac_addr_l);
+    iowrite32be(0x0, &regs->mac_addr[paddr_num].mac_addr_u);
+}
+
+void memac_hardware_add_addr_in_paddr(struct memac_regs *regs, uint8_t *adr, uint8_t paddr_num)
+{
+    uint32_t tmp0, tmp1;
+
+    tmp0 = (uint32_t)(adr[0] |
+            adr[1] << 8 |
+            adr[2] << 16 |
+            adr[3] << 24);
+    tmp1 = (uint32_t)(adr[4] | adr[5] << 8);
+    iowrite32be(tmp0, &regs->mac_addr[paddr_num].mac_addr_l);
+
+    iowrite32be(tmp1, &regs->mac_addr[paddr_num].mac_addr_u);
+}
+
+void memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&regs->command_config);
+
+    if (apply_rx)
+        tmp |= CMD_CFG_RX_EN ;
+
+    if (apply_tx)
+        tmp |= CMD_CFG_TX_EN ;
+
+    iowrite32be(tmp, &regs->command_config);
+}
+
+void memac_disable(struct memac_regs *regs, bool apply_rx, bool apply_tx)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&regs->command_config);
+
+    if (apply_rx)
+        tmp &= ~CMD_CFG_RX_EN ;
+
+    if (apply_tx)
+        tmp &= ~CMD_CFG_TX_EN ;
+
+    iowrite32be(tmp, &regs->command_config);
+}
+
+void memac_reset_counter(struct memac_regs *regs)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&regs->statn_config);
+
+    tmp |= STATS_CFG_CLR;
+
+    iowrite32be(tmp, &regs->statn_config);
+
+    while (ioread32be(&regs->statn_config) & STATS_CFG_CLR) ;
+}
+
+void memac_reset(struct memac_regs *regs)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&regs->command_config);
+
+    tmp |= CMD_CFG_SW_RESET;
+
+    iowrite32be(tmp, &regs->command_config);
+
+    while (ioread32be(&regs->command_config) & CMD_CFG_SW_RESET) ;
+}
+
+void memac_init(struct memac_regs *regs, struct memac_cfg *cfg,
+        enum enet_interface enet_interface, enum enet_speed enet_speed,
+        uint32_t exceptions)
+{
+    uint32_t    tmp;
+
+    /* Config */
+    tmp = 0;
+    if (cfg->wan_mode_enable)
+        tmp |= CMD_CFG_WAN_MODE;
+    if (cfg->promiscuous_mode_enable)
+        tmp |= CMD_CFG_PROMIS_EN;
+    if (cfg->pause_forward_enable)
+        tmp |= CMD_CFG_PAUSE_FWD;
+    if (cfg->pause_ignore)
+        tmp |= CMD_CFG_PAUSE_IGNORE;
+    if (cfg->tx_addr_ins_enable)
+        tmp |= CMD_CFG_TX_ADDR_INS;
+    if (cfg->loopback_enable)
+        tmp |= CMD_CFG_LOOPBACK_EN;
+    if (cfg->cmd_frame_enable)
+        tmp |= CMD_CFG_CNT_FRM_EN;
+    if (cfg->send_idle_enable)
+        tmp |= CMD_CFG_SEND_IDLE;
+    if (cfg->no_length_check_enable)
+        tmp |= CMD_CFG_NO_LEN_CHK;
+    if (cfg->rx_sfd_any)
+        tmp |= CMD_CFG_SFD_ANY;
+    if (cfg->pad_enable)
+        tmp |= CMD_CFG_TX_PAD_EN;
+    tmp |= CMD_CFG_CRC_FWD;
+
+    iowrite32be(tmp, &regs->command_config);
+
+    /* Max Frame Length */
+    iowrite32be((uint32_t)cfg->max_frame_length, &regs->maxfrm);
+
+    /* Pause Time */
+    iowrite32be(cfg->pause_quant, &regs->pause_quanta[0]);
+    iowrite32be(0, &regs->pause_thresh[0]);
+
+    /* interrupts */
+    iowrite32be(EVENTS_MASK, &regs->ievent);
+    iowrite32be(exceptions, &regs->imask);
+
+    /* IF_MODE */
+    tmp = 0;
+    if (enet_speed == enet_speed_10000)
+    {
+        tmp |= IF_MODE_XGMII;
+    }
+    else
+    {
+        tmp |= IF_MODE_GMII;
+        if (enet_interface == enet_if_rgmii)
+            tmp |= IF_MODE_RGMII | IF_MODE_RGMII_AUTO;
+    }
+    iowrite32be(tmp, &regs->if_mode);
+}
+
+void memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&regs->imask);
+    if (enable)
+       tmp |= val;
+    else
+       tmp &= ~val;
+
+    iowrite32be(tmp, &regs->imask);
+}
+
+void memac_set_hash_table(struct memac_regs *regs, uint32_t val)
+{
+    iowrite32be(val, &regs->hashtable_ctrl);
+}
+
+uint16_t memac_get_max_frame_length(struct memac_regs *regs)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&regs->maxfrm);
+
+    return(uint16_t)tmp;
+}
+
+
+void memac_set_tx_pause_frames(struct memac_regs    *regs,
+                               uint8_t              priority,
+                               uint16_t             pauseTime,
+                               uint16_t             threshTime)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&regs->command_config);
+    if (priority == 0xff) //ehud FM_MAC_NO_PFC
+    {
+       tmp &= ~CMD_CFG_PFC_MODE;
+       priority = 0;
+    }
+    else
+        tmp |= CMD_CFG_PFC_MODE;
+
+    iowrite32be(tmp, &regs->command_config);
+
+    tmp = ioread32be(&regs->pause_quanta[priority/2]);
+    tmp &= (~0xFFFF<<(16*(priority%2)));
+    tmp |= ((uint32_t)pauseTime<<(16*(priority%2)));
+    iowrite32be(tmp, &regs->pause_quanta[priority/2]);
+
+    tmp = ioread32be(&regs->pause_thresh[priority/2]);
+    tmp &= (~0xFFFF<<(16*(priority%2)));
+    tmp |= ((uint32_t)threshTime<<(16*(priority%2)));
+    iowrite32be(tmp, &regs->pause_thresh[priority/2]);
+}
+
+void memac_set_rx_ignore_pause_frames(struct memac_regs    *regs,bool enable)
+{
+    uint32_t tmp;
+
+    tmp = ioread32be(&regs->command_config);
+    if (enable)
+       tmp |= CMD_CFG_PAUSE_IGNORE;
+    else
+       tmp &= ~CMD_CFG_PAUSE_IGNORE;
+
+    iowrite32be(tmp, &regs->command_config);
+}
+
+#define GET_MEMAC_CNTR_64(bn) \
+    (((uint64_t)ioread32be(&regs->bn ## _u) << 32) | \
+            ioread32be(&regs->bn ## _l))
+
+uint64_t memac_get_counter(struct memac_regs *regs, enum memac_counters reg_name)
+{
+    uint64_t ret_val;
+
+    switch (reg_name) {
+    case E_MEMAC_COUNTER_R64:
+        ret_val = GET_MEMAC_CNTR_64(r64);
+        break;
+    case E_MEMAC_COUNTER_R127:
+        ret_val = GET_MEMAC_CNTR_64(r127);
+        break;
+    case E_MEMAC_COUNTER_R255:
+        ret_val = GET_MEMAC_CNTR_64(r255);
+        break;
+    case E_MEMAC_COUNTER_R511:
+        ret_val = GET_MEMAC_CNTR_64(r511);
+        break;
+    case E_MEMAC_COUNTER_R1023:
+        ret_val = GET_MEMAC_CNTR_64(r1023);
+        break;
+    case E_MEMAC_COUNTER_R1518:
+        ret_val = GET_MEMAC_CNTR_64(r1518);
+        break;
+    case E_MEMAC_COUNTER_R1519X:
+        ret_val = GET_MEMAC_CNTR_64(r1519x);
+        break;
+    case E_MEMAC_COUNTER_RFRG:
+        ret_val = GET_MEMAC_CNTR_64(rfrg);
+        break;
+    case E_MEMAC_COUNTER_RJBR:
+        ret_val = GET_MEMAC_CNTR_64(rjbr);
+        break;
+    case E_MEMAC_COUNTER_RDRP:
+        ret_val = GET_MEMAC_CNTR_64(rdrp);
+        break;
+    case E_MEMAC_COUNTER_RALN:
+        ret_val = GET_MEMAC_CNTR_64(raln);
+        break;
+    case E_MEMAC_COUNTER_TUND:
+        ret_val = GET_MEMAC_CNTR_64(tund);
+        break;
+    case E_MEMAC_COUNTER_ROVR:
+        ret_val = GET_MEMAC_CNTR_64(rovr);
+        break;
+    case E_MEMAC_COUNTER_RXPF:
+        ret_val = GET_MEMAC_CNTR_64(rxpf);
+        break;
+    case E_MEMAC_COUNTER_TXPF:
+        ret_val = GET_MEMAC_CNTR_64(txpf);
+        break;
+    case E_MEMAC_COUNTER_ROCT:
+        ret_val = GET_MEMAC_CNTR_64(roct);
+        break;
+    case E_MEMAC_COUNTER_RMCA:
+        ret_val = GET_MEMAC_CNTR_64(rmca);
+        break;
+    case E_MEMAC_COUNTER_RBCA:
+        ret_val = GET_MEMAC_CNTR_64(rbca);
+        break;
+    case E_MEMAC_COUNTER_RPKT:
+        ret_val = GET_MEMAC_CNTR_64(rpkt);
+        break;
+    case E_MEMAC_COUNTER_RUCA:
+        ret_val = GET_MEMAC_CNTR_64(ruca);
+        break;
+    case E_MEMAC_COUNTER_RERR:
+        ret_val = GET_MEMAC_CNTR_64(rerr);
+        break;
+    case E_MEMAC_COUNTER_TOCT:
+        ret_val = GET_MEMAC_CNTR_64(toct);
+        break;
+    case E_MEMAC_COUNTER_TMCA:
+        ret_val = GET_MEMAC_CNTR_64(tmca);
+        break;
+    case E_MEMAC_COUNTER_TBCA:
+        ret_val = GET_MEMAC_CNTR_64(tbca);
+        break;
+    case E_MEMAC_COUNTER_TUCA:
+        ret_val = GET_MEMAC_CNTR_64(tuca);
+        break;
+    case E_MEMAC_COUNTER_TERR:
+        ret_val = GET_MEMAC_CNTR_64(terr);
+        break;
+    default:
+        ret_val = 0;
+    }
+
+    return ret_val;
+}
+
+void memac_defconfig(struct memac_cfg *cfg)
+{
+    cfg->reset_on_init              = FALSE;
+    cfg->wan_mode_enable            = FALSE;
+    cfg->promiscuous_mode_enable    = FALSE;
+    cfg->pause_forward_enable       = FALSE;
+    cfg->pause_ignore               = FALSE;
+    cfg->tx_addr_ins_enable         = FALSE;
+    cfg->loopback_enable            = FALSE;
+    cfg->cmd_frame_enable           = FALSE;
+    cfg->rx_error_discard           = FALSE;
+    cfg->send_idle_enable           = FALSE;
+    cfg->no_length_check_enable     = TRUE;
+    cfg->lgth_check_nostdr          = FALSE;
+    cfg->time_stamp_enable          = FALSE;
+    cfg->tx_ipg_length              = 12;
+    cfg->max_frame_length           = 0x600;
+    cfg->pause_quant                = 0xf000;
+    cfg->pad_enable                 = TRUE;
+    cfg->phy_tx_ena_on              = FALSE;
+    cfg->rx_sfd_any                 = FALSE;
+    cfg->rxPblFwd                   = FALSE;
+    cfg->txPblFwd                   = FALSE;
+    cfg->debugMode                  = FALSE;
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    cfg->skip_fman11_workaround     = FALSE;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c
new file mode 100644
index 0000000..176fb86
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fman_tgec.c
@@ -0,0 +1,361 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "fsl_fman_tgec.h"
+
+
+void tgec_set_mac_address(struct tgec_regs *regs, uint8_t *adr)
+{
+	uint32_t tmp0, tmp1;
+
+	tmp0 = (uint32_t)(adr[0] |
+			adr[1] << 8 |
+			adr[2] << 16 |
+			adr[3] << 24);
+	tmp1 = (uint32_t)(adr[4] | adr[5] << 8);
+	iowrite32be(tmp0, &regs->mac_addr_0);
+	iowrite32be(tmp1, &regs->mac_addr_1);
+}
+
+void tgec_reset_stat(struct tgec_regs *regs)
+{
+	uint32_t command_config;
+
+	command_config = ioread32be(&regs->command_config);
+
+	command_config |= CMD_CFG_STAT_CLR;
+
+	iowrite32be(command_config, &regs->command_config);
+
+	while (ioread32be(&regs->command_config) & CMD_CFG_STAT_CLR);
+}
+
+#define GET_TGEC_CNTR_64(bn) \
+	(((uint64_t)ioread32be(&regs->bn ## _u) << 32) | \
+			ioread32be(&regs->bn ## _l))
+
+uint64_t tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name)
+{
+	uint64_t ret_val;
+
+	switch (reg_name) {
+	case E_TGEC_COUNTER_R64:
+		ret_val = GET_TGEC_CNTR_64(r64);
+		break;
+	case E_TGEC_COUNTER_R127:
+		ret_val = GET_TGEC_CNTR_64(r127);
+		break;
+	case E_TGEC_COUNTER_R255:
+		ret_val = GET_TGEC_CNTR_64(r255);
+		break;
+	case E_TGEC_COUNTER_R511:
+		ret_val = GET_TGEC_CNTR_64(r511);
+		break;
+	case E_TGEC_COUNTER_R1023:
+		ret_val = GET_TGEC_CNTR_64(r1023);
+		break;
+	case E_TGEC_COUNTER_R1518:
+		ret_val = GET_TGEC_CNTR_64(r1518);
+		break;
+	case E_TGEC_COUNTER_R1519X:
+		ret_val = GET_TGEC_CNTR_64(r1519x);
+		break;
+	case E_TGEC_COUNTER_TRFRG:
+		ret_val = GET_TGEC_CNTR_64(trfrg);
+		break;
+	case E_TGEC_COUNTER_TRJBR:
+		ret_val = GET_TGEC_CNTR_64(trjbr);
+		break;
+	case E_TGEC_COUNTER_RDRP:
+		ret_val = GET_TGEC_CNTR_64(rdrp);
+		break;
+	case E_TGEC_COUNTER_RALN:
+		ret_val = GET_TGEC_CNTR_64(raln);
+		break;
+	case E_TGEC_COUNTER_TRUND:
+		ret_val = GET_TGEC_CNTR_64(trund);
+		break;
+	case E_TGEC_COUNTER_TROVR:
+		ret_val = GET_TGEC_CNTR_64(trovr);
+		break;
+	case E_TGEC_COUNTER_RXPF:
+		ret_val = GET_TGEC_CNTR_64(rxpf);
+		break;
+	case E_TGEC_COUNTER_TXPF:
+		ret_val = GET_TGEC_CNTR_64(txpf);
+		break;
+	case E_TGEC_COUNTER_ROCT:
+		ret_val = GET_TGEC_CNTR_64(roct);
+		break;
+	case E_TGEC_COUNTER_RMCA:
+		ret_val = GET_TGEC_CNTR_64(rmca);
+		break;
+	case E_TGEC_COUNTER_RBCA:
+		ret_val = GET_TGEC_CNTR_64(rbca);
+		break;
+	case E_TGEC_COUNTER_RPKT:
+		ret_val = GET_TGEC_CNTR_64(rpkt);
+		break;
+	case E_TGEC_COUNTER_RUCA:
+		ret_val = GET_TGEC_CNTR_64(ruca);
+		break;
+	case E_TGEC_COUNTER_RERR:
+		ret_val = GET_TGEC_CNTR_64(rerr);
+		break;
+	case E_TGEC_COUNTER_TOCT:
+		ret_val = GET_TGEC_CNTR_64(toct);
+		break;
+	case E_TGEC_COUNTER_TMCA:
+		ret_val = GET_TGEC_CNTR_64(tmca);
+		break;
+	case E_TGEC_COUNTER_TBCA:
+		ret_val = GET_TGEC_CNTR_64(tbca);
+		break;
+	case E_TGEC_COUNTER_TUCA:
+		ret_val = GET_TGEC_CNTR_64(tuca);
+		break;
+	case E_TGEC_COUNTER_TERR:
+		ret_val = GET_TGEC_CNTR_64(terr);
+		break;
+	default:
+		ret_val = 0;
+	}
+
+	return ret_val;
+}
+
+void tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->command_config);
+
+	if (apply_rx)
+		tmp |= CMD_CFG_RX_EN ;
+
+	if (apply_tx)
+		tmp |= CMD_CFG_TX_EN ;
+
+	iowrite32be(tmp, &regs->command_config);
+}
+
+void tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx)
+{
+	uint32_t tmp_reg_32;
+
+	tmp_reg_32 = ioread32be(&regs->command_config);
+
+	if (apply_rx)
+		tmp_reg_32 &= ~CMD_CFG_RX_EN;
+
+	if (apply_tx)
+		tmp_reg_32 &= ~CMD_CFG_TX_EN;
+
+	iowrite32be(tmp_reg_32, &regs->command_config);
+}
+
+void tgec_set_promiscuous(struct tgec_regs *regs, bool val)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->command_config);
+
+	if (val)
+		tmp |= CMD_CFG_PROMIS_EN;
+	else
+		tmp &= ~CMD_CFG_PROMIS_EN;
+
+	iowrite32be(tmp, &regs->command_config);
+}
+
+void tgec_set_hash_table(struct tgec_regs *regs, uint32_t value)
+{
+	iowrite32be(value, &regs->hashtable_ctrl);
+}
+
+void tgec_tx_mac_pause(struct tgec_regs *regs, uint16_t pause_time)
+{
+	iowrite32be((uint32_t)pause_time, &regs->pause_quant);
+}
+
+void tgec_rx_ignore_mac_pause(struct tgec_regs *regs, bool en)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->command_config);
+	if (en)
+		tmp |= CMD_CFG_PAUSE_IGNORE;
+	else
+		tmp &= ~CMD_CFG_PAUSE_IGNORE;
+	iowrite32be(tmp, &regs->command_config);
+}
+
+void tgec_enable_1588_time_stamp(struct tgec_regs *regs, bool en)
+{
+	uint32_t tmp;
+
+	tmp = ioread32be(&regs->command_config);
+	if (en)
+		tmp |= CMD_CFG_EN_TIMESTAMP;
+	else
+		tmp &= ~CMD_CFG_EN_TIMESTAMP;
+	iowrite32be(tmp, &regs->command_config);
+}
+
+uint32_t tgec_get_event(struct tgec_regs *regs, uint32_t ev_mask)
+{
+	return ioread32be(&regs->ievent) & ev_mask;
+}
+
+void tgec_ack_event(struct tgec_regs *regs, uint32_t ev_mask)
+{
+	iowrite32be(ev_mask, &regs->ievent);
+}
+
+uint32_t tgec_get_interrupt_mask(struct tgec_regs *regs)
+{
+	return ioread32be(&regs->imask);
+}
+
+void tgec_add_addr_in_paddr(struct tgec_regs *regs, uint8_t *adr)
+{
+	uint32_t tmp0, tmp1;
+
+	tmp0 = (uint32_t)(adr[0] |
+			adr[1] << 8 |
+			adr[2] << 16 |
+			adr[3] << 24);
+	tmp1 = (uint32_t)(adr[4] | adr[5] << 8);
+	iowrite32be(tmp0, &regs->mac_addr_2);
+	iowrite32be(tmp1, &regs->mac_addr_3);
+}
+
+void tgec_clear_addr_in_paddr(struct tgec_regs *regs)
+{
+	iowrite32be(0, &regs->mac_addr_2);
+	iowrite32be(0, &regs->mac_addr_3);
+}
+
+uint32_t tgec_get_revision(struct tgec_regs *regs)
+{
+	return ioread32be(&regs->tgec_id);
+}
+
+void tgec_enable_interrupt(struct tgec_regs *regs, uint32_t ev_mask)
+{
+	iowrite32be(ioread32be(&regs->imask) | ev_mask, &regs->imask);
+}
+
+void tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask)
+{
+	iowrite32be(ioread32be(&regs->imask) & ~ev_mask, &regs->imask);
+}
+
+uint16_t tgec_get_max_frame_len(struct tgec_regs *regs)
+{
+	return (uint16_t) ioread32be(&regs->maxfrm);
+}
+
+void tgec_defconfig(struct tgec_cfg *cfg)
+{
+	cfg->wan_mode_enable = FALSE;
+	cfg->promiscuous_mode_enable = FALSE;
+	cfg->pause_forward_enable = FALSE;
+	cfg->pause_ignore = FALSE;
+	cfg->tx_addr_ins_enable = FALSE;
+	cfg->loopback_enable = FALSE;
+	cfg->cmd_frame_enable = FALSE;
+	cfg->rx_error_discard = FALSE;
+	cfg->send_idle_enable = FALSE;
+	cfg->no_length_check_enable = TRUE;
+	cfg->lgth_check_nostdr = FALSE;
+	cfg->time_stamp_enable = FALSE;
+	cfg->tx_ipg_length = 12;
+	cfg->max_frame_length = 0x600;
+	cfg->pause_quant = 0xf000;
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+	cfg->skip_fman11_workaround = FALSE;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+}
+
+int tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
+		uint32_t exception_mask)
+{
+	uint32_t tmp;
+
+	/* Config */
+	tmp = 0;
+	if (cfg->wan_mode_enable)
+		tmp |= CMD_CFG_WAN_MODE;
+	if (cfg->promiscuous_mode_enable)
+		tmp |= CMD_CFG_PROMIS_EN;
+	if (cfg->pause_forward_enable)
+		tmp |= CMD_CFG_PAUSE_FWD;
+	if (cfg->pause_ignore)
+		tmp |= CMD_CFG_PAUSE_IGNORE;
+	if (cfg->tx_addr_ins_enable)
+		tmp |= CMD_CFG_TX_ADDR_INS;
+	if (cfg->loopback_enable)
+		tmp |= CMD_CFG_LOOPBACK_EN;
+	if (cfg->cmd_frame_enable)
+		tmp |= CMD_CFG_CMD_FRM_EN;
+	if (cfg->rx_error_discard)
+		tmp |= CMD_CFG_RX_ER_DISC;
+	if (cfg->send_idle_enable)
+		tmp |= CMD_CFG_SEND_IDLE;
+	if (cfg->no_length_check_enable)
+		tmp |= CMD_CFG_NO_LEN_CHK;
+	if (cfg->time_stamp_enable)
+		tmp |= CMD_CFG_EN_TIMESTAMP;
+	tmp |= 0x40;
+	iowrite32be(tmp, &regs->command_config);
+	/* Max Frame Length */
+	iowrite32be((uint32_t)cfg->max_frame_length, &regs->maxfrm);
+	/* Pause Time */
+	iowrite32be(cfg->pause_quant, &regs->pause_quant);
+	/* 2 ERRATAs here ? */
+	iowrite32be(EVENTS_MASK, &regs->ievent);
+	iowrite32be(exception_mask, &regs->imask);
+	return 0;
+}
+
+void tgec_fm_tx_fifo_corruption_errata_10gmac_a007(struct tgec_regs *regs)
+{
+	uint32_t tmp;
+
+	/* restore the default tx ipg Length */
+	tmp = (ioread32be(&regs->tx_ipg_len) & ~TX_IPG_LENGTH_MASK) | 12;
+
+	iowrite32be(tmp, &regs->tx_ipg_len);
+
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h
new file mode 100644
index 0000000..9cf2aa1
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec.h
@@ -0,0 +1,1033 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * DOC: dTSEC
+ *
+ * This section contains description of dTSEC API available in flib.
+ */
+
+#ifndef FSL_FMAN_DTSEC_H
+#define FSL_FMAN_DTSEC_H
+
+#include "common/general.h"
+#include "fsl_enet.h"
+
+
+/**
+ * DOC: dTSEC Init sequence
+ *
+ * To prepare dTSEC block for transfer use the following call sequence:
+ *
+ * - dtsec_defconfig() - This step is optional and yet recommended. Its use is
+ * to obtain the default dTSEC configuration parameters.
+ *
+ * - Change dtsec configuration in &dtsec_cfg. This structure will be used
+ * to customize the dTSEC behavior.
+ *
+ * - dtsec_init() - Applies the configuration on dTSEC hardware.  Note that
+ * dTSEC is initialized while both Tx and Rx are disabled.
+ *
+ * - dtsec_set_mac_address() - Set the station address (mac address).
+ * This is used by dTSEC to match against received packets.
+ *
+ * - dtsec_adjust_link() - Set the link speed and duplex parameters
+ * after the PHY establishes the link.
+ *
+ * - dtsec_enable_tx() and dtsec_enable_rx() to enable transmission and
+ * reception.
+ */
+
+/**
+ * DOC: dTSEC Graceful stop
+ *
+ * To temporary stop dTSEC activity use dtsec_stop_tx() and dtsec_stop_rx().
+ * Note that these functions request dTSEC graceful stop but return before this
+ * stop is complete.  To query for graceful stop completion use
+ * dtsec_get_event() and check DTSEC_IEVENT_GTSC and DTSEC_IEVENT_GRSC bits.
+ * Alternatively the dTSEC interrupt mask can be set to enable graceful stop
+ * interrupts.
+ *
+ * To resume operation after graceful stop use dtsec_start_tx() and
+ * dtsec_start_rx().
+ */
+
+/**
+ * DOC: dTSEC interrupt handling
+ *
+ * This code does not provide an interrupt handler for dTSEC.  Instead this
+ * handler should be implemented and registered to the operating system by the
+ * caller.  Some primitives for accessing the event status and mask registers
+ * are provided.
+ *
+ * See "dTSEC Events" section for a list of events that dTSEC can generate.
+ */
+
+/**
+ * DOC: dTSEC Events
+ *
+ * Interrupt events cause dTSEC event bits to be set.  Software may poll the
+ * event register at any time to check for pending interrupts.  If an event
+ * occurs and its corresponding enable bit is set in the interrupt mask
+ * register, the event also causes a hardware interrupt at the PIC.
+ *
+ * To poll for event status use the dtsec_get_event() function.
+ * To configure the interrupt mask use dtsec_enable_interrupt() and
+ * dtsec_disable_interrupt() functions.
+ * After servicing a dTSEC interrupt use dtsec_ack_event to reset the serviced
+ * event bit.
+ *
+ * The following events may be signaled by dTSEC hardware:
+ *
+ * %DTSEC_IEVENT_BABR - Babbling receive error.  This bit indicates that
+ * a frame was received with length in excess of the MAC's maximum frame length
+ * register.
+ *
+ * %DTSEC_IEVENT_RXC - Receive control (pause frame) interrupt.  A pause
+ * control frame was received while Rx pause frame handling is enabled.
+ * Also see dtsec_handle_rx_pause().
+ *
+ * %DTSEC_IEVENT_MSRO - MIB counter overflow.  The count for one of the MIB
+ * counters has exceeded the size of its register.
+ *
+ * %DTSEC_IEVENT_GTSC - Graceful transmit stop complete.  Graceful stop is now
+ * complete. The transmitter is in a stopped state, in which only pause frames
+ * can be transmitted.
+ * Also see dtsec_stop_tx().
+ *
+ * %DTSEC_IEVENT_BABT - Babbling transmit error.  The transmitted frame length
+ * has exceeded the value in the MAC's Maximum Frame Length register.
+ *
+ * %DTSEC_IEVENT_TXC - Transmit control (pause frame) interrupt.  his bit
+ * indicates that a control frame was transmitted.
+ *
+ * %DTSEC_IEVENT_TXE - Transmit error.  This bit indicates that an error
+ * occurred on the transmitted channel.  This bit is set whenever any transmit
+ * error occurs which causes the dTSEC to discard all or part of a frame
+ * (LC, CRL, XFUN).
+ *
+ * %DTSEC_IEVENT_LC - Late collision.  This bit indicates that a collision
+ * occurred beyond the collision window (slot time) in half-duplex mode.
+ * The frame is truncated with a bad CRC and the remainder of the frame
+ * is discarded.
+ *
+ * %DTSEC_IEVENT_CRL - Collision retry limit.  is bit indicates that the number
+ * of successive transmission collisions has exceeded the MAC's half-duplex
+ * register's retransmission maximum count.  The frame is discarded without
+ * being transmitted and transmission of the next frame commences.  This only
+ * occurs while in half-duplex mode.
+ * The number of retransmit attempts can be set in
+ * &dtsec_halfdup_cfg.@retransmit before calling dtsec_init().
+ *
+ * %DTSEC_IEVENT_XFUN - Transmit FIFO underrun.  This bit indicates that the
+ * transmit FIFO became empty before the complete frame was transmitted.
+ * The frame is truncated with a bad CRC and the remainder of the frame is
+ * discarded.
+ *
+ * %DTSEC_IEVENT_MAG - TBD
+ *
+ * %DTSEC_IEVENT_MMRD - MII management read completion.
+ *
+ * %DTSEC_IEVENT_MMWR - MII management write completion.
+ *
+ * %DTSEC_IEVENT_GRSC - Graceful receive stop complete.  It allows the user to
+ * know if the system has completed the stop and it is safe to write to receive
+ * registers (status, control or configuration registers) that are used by the
+ * system during normal operation.
+ *
+ * %DTSEC_IEVENT_TDPE - Internal data error on transmit.  This bit indicates
+ * that the dTSEC has detected a parity error on its stored transmit data, which
+ * is likely to compromise the validity of recently transferred frames.
+ *
+ * %DTSEC_IEVENT_RDPE - Internal data error on receive.  This bit indicates that
+ * the dTSEC has detected a parity error on its stored receive data, which is
+ * likely to compromise the validity of recently transferred frames.
+ */
+/* Interrupt Mask Register (IMASK) */
+#define DTSEC_IMASK_BREN              0x80000000
+#define DTSEC_IMASK_RXCEN             0x40000000
+#define DTSEC_IMASK_MSROEN            0x04000000
+#define DTSEC_IMASK_GTSCEN            0x02000000
+#define DTSEC_IMASK_BTEN              0x01000000
+#define DTSEC_IMASK_TXCEN             0x00800000
+#define DTSEC_IMASK_TXEEN             0x00400000
+#define DTSEC_IMASK_LCEN              0x00040000
+#define DTSEC_IMASK_CRLEN             0x00020000
+#define DTSEC_IMASK_XFUNEN            0x00010000
+#define DTSEC_IMASK_ABRTEN            0x00008000
+#define DTSEC_IMASK_IFERREN           0x00004000
+#define DTSEC_IMASK_MAGEN             0x00000800
+#define DTSEC_IMASK_MMRDEN            0x00000400
+#define DTSEC_IMASK_MMWREN            0x00000200
+#define DTSEC_IMASK_GRSCEN            0x00000100
+#define DTSEC_IMASK_TDPEEN            0x00000002
+#define DTSEC_IMASK_RDPEEN            0x00000001
+
+/* dtsec timestamp event bits */
+#define TMR_PEMASK_TSREEN		0x00010000
+#define TMR_PEVENT_TSRE			0x00010000
+
+/* Group address bit indication */
+#define MAC_GROUP_ADDRESS		0x0000010000000000ULL
+/* size in bytes of L2 address */
+#define MAC_ADDRLEN                     6
+
+/* register related defines (bits, field offsets..) */
+#define DTSEC_ID1_ID			0xffff0000
+#define DTSEC_ID1_REV_MJ		0x0000FF00
+#define DTSEC_ID1_REV_MN		0x000000ff
+
+#define DTSEC_ID2_INT_REDUCED_OFF	0x00010000
+#define DTSEC_ID2_INT_NORMAL_OFF	0x00020000
+
+#define DTSEC_ECNTRL_CLRCNT         0x00004000
+#define DTSEC_ECNTRL_AUTOZ          0x00002000
+#define DTSEC_ECNTRL_STEN           0x00001000
+#define DTSEC_ECNTRL_CFG_RO         0x80000000
+#define DTSEC_ECNTRL_GMIIM          0x00000040
+#define DTSEC_ECNTRL_TBIM           0x00000020
+#define DTSEC_ECNTRL_SGMIIM         0x00000002
+#define DTSEC_ECNTRL_RPM            0x00000010
+#define DTSEC_ECNTRL_R100M          0x00000008
+#define DTSEC_ECNTRL_RMM            0x00000004
+#define DTSEC_ECNTRL_QSGMIIM        0x00000001
+
+#define DTSEC_TCTRL_THDF            0x00000800
+#define DTSEC_TCTRL_TTSE            0x00000040
+#define DTSEC_TCTRL_GTS             0x00000020
+#define DTSEC_TCTRL_TFC_PAUSE       0x00000010
+
+/* PTV offsets */
+#define PTV_PTE_OFST                16
+
+#define RCTRL_CFA                   0x00008000
+#define RCTRL_GHTX                  0x00000400
+#define RCTRL_RTSE                  0x00000040
+#define RCTRL_GRS                   0x00000020
+#define RCTRL_BC_REJ                0x00000010
+#define RCTRL_MPROM                 0x00000008
+#define RCTRL_RSF                   0x00000004
+#define RCTRL_UPROM                 0x00000001
+#define RCTRL_PROM                  (RCTRL_UPROM | RCTRL_MPROM)
+
+#define TMR_CTL_ESFDP               0x00000800
+#define TMR_CTL_ESFDE               0x00000400
+
+#define MACCFG1_SOFT_RESET          0x80000000
+#define MACCFG1_LOOPBACK            0x00000100
+#define MACCFG1_RX_FLOW             0x00000020
+#define MACCFG1_TX_FLOW             0x00000010
+#define MACCFG1_TX_EN               0x00000001
+#define MACCFG1_RX_EN               0x00000004
+#define MACCFG1_RESET_RxMC          0x00080000
+#define MACCFG1_RESET_TxMC          0x00040000
+#define MACCFG1_RESET_RxFUN         0x00020000
+#define MACCFG1_RESET_TxFUN         0x00010000
+
+#define MACCFG2_NIBBLE_MODE         0x00000100
+#define MACCFG2_BYTE_MODE           0x00000200
+#define MACCFG2_PRE_AM_Rx_EN        0x00000080
+#define MACCFG2_PRE_AM_Tx_EN        0x00000040
+#define MACCFG2_LENGTH_CHECK        0x00000010
+#define MACCFG2_MAGIC_PACKET_EN     0x00000008
+#define MACCFG2_PAD_CRC_EN          0x00000004
+#define MACCFG2_CRC_EN              0x00000002
+#define MACCFG2_FULL_DUPLEX         0x00000001
+
+#define PREAMBLE_LENGTH_SHIFT       12
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT    24
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2_SHIFT    16
+#define IPGIFG_MIN_IFG_ENFORCEMENT_SHIFT        8
+
+#define IPGIFG_NON_BACK_TO_BACK_IPG_1    0x7F000000
+#define IPGIFG_NON_BACK_TO_BACK_IPG_2    0x007F0000
+#define IPGIFG_MIN_IFG_ENFORCEMENT       0x0000FF00
+#define IPGIFG_BACK_TO_BACK_IPG          0x0000007F
+
+#define HAFDUP_ALT_BEB			0x00080000
+#define HAFDUP_BP_NO_BACKOFF		0x00040000
+#define HAFDUP_NO_BACKOFF		0x00020000
+#define HAFDUP_EXCESS_DEFER		0x00010000
+#define HAFDUP_COLLISION_WINDOW		0x000003ff
+
+#define HAFDUP_ALTERNATE_BEB_TRUNCATION_SHIFT	20
+#define HAFDUP_RETRANSMISSION_MAX_SHIFT		12
+#define HAFDUP_RETRANSMISSION_MAX		0x0000f000
+
+#define NUM_OF_HASH_REGS     8 /* Number of hash table registers */
+
+/* CAR1/2 bits */
+#define DTSEC_CAR1_TR64   0x80000000
+#define DTSEC_CAR1_TR127  0x40000000
+#define DTSEC_CAR1_TR255  0x20000000
+#define DTSEC_CAR1_TR511  0x10000000
+#define DTSEC_CAR1_TRK1   0x08000000
+#define DTSEC_CAR1_TRMAX  0x04000000
+#define DTSEC_CAR1_TRMGV  0x02000000
+
+#define DTSEC_CAR1_RBYT   0x00010000
+#define DTSEC_CAR1_RPKT   0x00008000
+#define DTSEC_CAR1_RFCS   0x00004000
+#define DTSEC_CAR1_RMCA   0x00002000
+#define DTSEC_CAR1_RBCA   0x00001000
+#define DTSEC_CAR1_RXCF   0x00000800
+#define DTSEC_CAR1_RXPF   0x00000400
+#define DTSEC_CAR1_RXUO   0x00000200
+#define DTSEC_CAR1_RALN   0x00000100
+#define DTSEC_CAR1_RFLR   0x00000080
+#define DTSEC_CAR1_RCDE   0x00000040
+#define DTSEC_CAR1_RCSE   0x00000020
+#define DTSEC_CAR1_RUND   0x00000010
+#define DTSEC_CAR1_ROVR   0x00000008
+#define DTSEC_CAR1_RFRG   0x00000004
+#define DTSEC_CAR1_RJBR   0x00000002
+#define DTSEC_CAR1_RDRP   0x00000001
+
+#define DTSEC_CAR2_TJBR   0x00080000
+#define DTSEC_CAR2_TFCS   0x00040000
+#define DTSEC_CAR2_TXCF   0x00020000
+#define DTSEC_CAR2_TOVR   0x00010000
+#define DTSEC_CAR2_TUND   0x00008000
+#define DTSEC_CAR2_TFRG   0x00004000
+#define DTSEC_CAR2_TBYT   0x00002000
+#define DTSEC_CAR2_TPKT   0x00001000
+#define DTSEC_CAR2_TMCA   0x00000800
+#define DTSEC_CAR2_TBCA   0x00000400
+#define DTSEC_CAR2_TXPF   0x00000200
+#define DTSEC_CAR2_TDFR   0x00000100
+#define DTSEC_CAR2_TEDF   0x00000080
+#define DTSEC_CAR2_TSCL   0x00000040
+#define DTSEC_CAR2_TMCL   0x00000020
+#define DTSEC_CAR2_TLCL   0x00000010
+#define DTSEC_CAR2_TXCL   0x00000008
+#define DTSEC_CAR2_TNCL   0x00000004
+#define DTSEC_CAR2_TDRP   0x00000001
+
+#define CAM1_ERRORS_ONLY \
+	(DTSEC_CAR1_RXPF | DTSEC_CAR1_RALN | DTSEC_CAR1_RFLR \
+	| DTSEC_CAR1_RCDE | DTSEC_CAR1_RCSE | DTSEC_CAR1_RUND \
+	| DTSEC_CAR1_ROVR | DTSEC_CAR1_RFRG | DTSEC_CAR1_RJBR \
+	| DTSEC_CAR1_RDRP)
+
+#define CAM2_ERRORS_ONLY (DTSEC_CAR2_TFCS | DTSEC_CAR2_TXPF | DTSEC_CAR2_TDRP)
+
+/*
+ * Group of dTSEC specific counters relating to the standard RMON MIB Group 1
+ * (or Ethernet) statistics.
+ */
+#define CAM1_MIB_GRP_1 \
+	(DTSEC_CAR1_RDRP | DTSEC_CAR1_RBYT | DTSEC_CAR1_RPKT | DTSEC_CAR1_RMCA\
+	| DTSEC_CAR1_RBCA | DTSEC_CAR1_RALN | DTSEC_CAR1_RUND | DTSEC_CAR1_ROVR\
+	| DTSEC_CAR1_RFRG | DTSEC_CAR1_RJBR \
+	| DTSEC_CAR1_TR64 | DTSEC_CAR1_TR127 | DTSEC_CAR1_TR255 \
+	| DTSEC_CAR1_TR511 | DTSEC_CAR1_TRMAX)
+
+#define CAM2_MIB_GRP_1 (DTSEC_CAR2_TNCL | DTSEC_CAR2_TDRP)
+
+/* memory map */
+
+struct dtsec_regs {
+	/* dTSEC General Control and Status Registers */
+	uint32_t tsec_id;	/* 0x000 ETSEC_ID register */
+	uint32_t tsec_id2;	/* 0x004 ETSEC_ID2 register */
+	uint32_t ievent;	/* 0x008 Interrupt event register */
+	uint32_t imask;		/* 0x00C Interrupt mask register */
+	uint32_t reserved0010[1];
+	uint32_t ecntrl;	/* 0x014 E control register */
+	uint32_t ptv;		/* 0x018 Pause time value register */
+	uint32_t tbipa;		/* 0x01C TBI PHY address register */
+	uint32_t tmr_ctrl;	/* 0x020 Time-stamp Control register */
+	uint32_t tmr_pevent;	/* 0x024 Time-stamp event register */
+	uint32_t tmr_pemask;	/* 0x028 Timer event mask register */
+	uint32_t reserved002c[5];
+	uint32_t tctrl;		/* 0x040 Transmit control register */
+	uint32_t reserved0044[3];
+	uint32_t rctrl;		/* 0x050 Receive control register */
+	uint32_t reserved0054[11];
+	uint32_t igaddr[8]; /* 0x080-0x09C Individual/group address registers */
+	uint32_t gaddr[8];	/* 0x0A0-0x0BC Group address registers 0-7 */
+	uint32_t reserved00c0[16];
+	uint32_t maccfg1;		/* 0x100 MAC configuration #1 */
+	uint32_t maccfg2;		/* 0x104 MAC configuration #2 */
+	uint32_t ipgifg;		/* 0x108 IPG/IFG */
+	uint32_t hafdup;		/* 0x10C Half-duplex */
+	uint32_t maxfrm;		/* 0x110 Maximum frame */
+	uint32_t reserved0114[10];
+	uint32_t ifstat;		/* 0x13C Interface status */
+	uint32_t macstnaddr1;		/* 0x140 Station Address,part 1 */
+	uint32_t macstnaddr2;		/* 0x144 Station Address,part 2  */
+	struct {
+	    uint32_t exact_match1; /* octets 1-4 */
+	    uint32_t exact_match2; /* octets 5-6 */
+	} macaddr[15]; /* 0x148-0x1BC mac exact match addresses 1-15, parts 1-2 */
+    uint32_t reserved01c0[16];
+    //	uint32_t reserved0148[61];
+	uint32_t tr64;	/* 0x200 transmit and receive 64 byte frame counter */
+	uint32_t tr127;	/* 0x204 transmit and receive 65 to 127 byte frame
+			 * counter */
+	uint32_t tr255;	/* 0x208 transmit and receive 128 to 255 byte frame
+			 * counter */
+	uint32_t tr511;	/* 0x20C transmit and receive 256 to 511 byte frame
+			 * counter */
+	uint32_t tr1k;	/* 0x210 transmit and receive 512 to 1023 byte frame
+			 * counter */
+	uint32_t trmax;	/* 0x214 transmit and receive 1024 to 1518 byte frame
+			 * counter */
+	uint32_t trmgv;	/* 0x218 transmit and receive 1519 to 1522 byte good
+			 * VLAN frame count */
+	uint32_t rbyt;	/* 0x21C receive byte counter */
+	uint32_t rpkt;	/* 0x220 receive packet counter */
+	uint32_t rfcs;	/* 0x224 receive FCS error counter */
+	uint32_t rmca;	/* 0x228 RMCA receive multicast packet counter */
+	uint32_t rbca;	/* 0x22C receive broadcast packet counter */
+	uint32_t rxcf;	/* 0x230 receive control frame packet counter */
+	uint32_t rxpf;	/* 0x234 receive pause frame packet counter */
+	uint32_t rxuo;	/* 0x238 receive unknown OP code counter */
+	uint32_t raln;	/* 0x23C receive alignment error counter */
+	uint32_t rflr;	/* 0x240 receive frame length error counter */
+	uint32_t rcde;	/* 0x244 receive code error counter */
+	uint32_t rcse;	/* 0x248 receive carrier sense error counter */
+	uint32_t rund;	/* 0x24C receive undersize packet counter */
+	uint32_t rovr;	/* 0x250 receive oversize packet counter */
+	uint32_t rfrg;	/* 0x254 receive fragments counter */
+	uint32_t rjbr;	/* 0x258 receive jabber counter */
+	uint32_t rdrp;	/* 0x25C receive drop */
+	uint32_t tbyt;	/* 0x260 transmit byte counter */
+	uint32_t tpkt;	/* 0x264 transmit packet counter */
+	uint32_t tmca;	/* 0x268 transmit multicast packet counter */
+	uint32_t tbca;	/* 0x26C transmit broadcast packet counter */
+	uint32_t txpf;	/* 0x270 transmit pause control frame counter */
+	uint32_t tdfr;	/* 0x274 transmit deferral packet counter */
+	uint32_t tedf;	/* 0x278 transmit excessive deferral packet counter */
+	uint32_t tscl;	/* 0x27C transmit single collision packet counter */
+	uint32_t tmcl;	/* 0x280 transmit multiple collision packet counter */
+	uint32_t tlcl;	/* 0x284 transmit late collision packet counter */
+	uint32_t txcl;	/* 0x288 transmit excessive collision packet counter */
+	uint32_t tncl;	/* 0x28C transmit total collision counter */
+	uint32_t reserved0290[1];
+	uint32_t tdrp;	/* 0x294 transmit drop frame counter */
+	uint32_t tjbr;	/* 0x298 transmit jabber frame counter */
+	uint32_t tfcs;	/* 0x29C transmit FCS error counter */
+	uint32_t txcf;	/* 0x2A0 transmit control frame counter */
+	uint32_t tovr;	/* 0x2A4 transmit oversize frame counter */
+	uint32_t tund;	/* 0x2A8 transmit undersize frame counter */
+	uint32_t tfrg;	/* 0x2AC transmit fragments frame counter */
+	uint32_t car1;	/* 0x2B0 carry register one register* */
+	uint32_t car2;	/* 0x2B4 carry register two register* */
+	uint32_t cam1;	/* 0x2B8 carry register one mask register */
+	uint32_t cam2;	/* 0x2BC carry register two mask register */
+	uint32_t reserved02c0[848];
+};
+
+/**
+ * struct dtsec_mib_grp_1_counters - MIB counter overflows
+ *
+ * @tr64:	Transmit and Receive 64 byte frame count.  Increment for each
+ *		good or bad frame, of any type, transmitted or received, which
+ *		is 64 bytes in length.
+ * @tr127:	Transmit and Receive 65 to 127 byte frame count.  Increments for
+ *		each good or bad frame of any type, transmitted or received,
+ *		which is 65-127 bytes in length.
+ * @tr255:	Transmit and Receive 128 to 255 byte frame count.  Increments
+ *		for each good or bad frame, of any type, transmitted or
+ *		received, which is 128-255 bytes in length.
+ * @tr511:	Transmit and Receive 256 to 511 byte frame count.  Increments
+ *		for each good or bad frame, of any type, transmitted or
+ *		received, which is 256-511 bytes in length.
+ * @tr1k:	Transmit and Receive 512 to 1023 byte frame count.  Increments
+ *		for each good or bad frame, of any type, transmitted or
+ *		received, which is 512-1023 bytes in length.
+ * @trmax:	Transmit and Receive 1024 to 1518 byte frame count.  Increments
+ *		for each good or bad frame, of any type, transmitted or
+ *		received, which is 1024-1518 bytes in length.
+ * @rfrg:	Receive fragments count.  Increments for each received frame
+ *		which is less than 64 bytes in length and contains an invalid
+ *		FCS.  This includes integral and non-integral lengths.
+ * @rjbr:	Receive jabber count.  Increments for received frames which
+ *		exceed 1518 (non VLAN) or 1522 (VLAN) bytes and contain an
+ *		invalid FCS.  This includes alignment errors.
+ * @rdrp:	Receive dropped packets count.  Increments for received frames
+ *		which are streamed to system but are later dropped due to lack
+ *		of system resources.  Does not increment for frames rejected due
+ *		to address filtering.
+ * @raln:	Receive alignment error count.  Increments for each received
+ *		frame from 64 to 1518 (non VLAN) or 1522 (VLAN) which contains
+ *		an invalid FCS and is not an integral number of bytes.
+ * @rund:	Receive undersize packet count.  Increments each time a frame is
+ *		received which is less than 64 bytes in length and contains a
+ *		valid FCS and is otherwise well formed.  This count does not
+ *		include range length errors.
+ * @rovr:	Receive oversize packet count.  Increments each time a frame is
+ *		received which exceeded 1518 (non VLAN) or 1522 (VLAN) and
+ *		contains a valid FCS and is otherwise well formed.
+ * @rbyt:	Receive byte count.  Increments by the byte count of frames
+ *		received, including those in bad packets, excluding preamble and
+ *		SFD but including FCS bytes.
+ * @rpkt:	Receive packet count.  Increments for each received frame
+ *		(including bad packets, all unicast, broadcast, and multicast
+ *		packets).
+ * @rmca:	Receive multicast packet count.  Increments for each multicast
+ *		frame with valid CRC and of lengths 64 to 1518 (non VLAN) or
+ *		1522 (VLAN), excluding broadcast frames. This count does not
+ *		include range/length errors.
+ * @rbca:	Receive broadcast packet count.  Increments for each broadcast
+ *		frame with valid CRC and of lengths 64 to 1518 (non VLAN) or
+ *		1522 (VLAN), excluding multicast frames. Does not include
+ *		range/length errors.
+ * @tdrp:	Transmit drop frame count.  Increments each time a memory error
+ *		or an underrun has occurred.
+ * @tncl:	Transmit total collision counter. Increments by the number of
+ *		collisions experienced during the transmission of a frame. Does
+ *		not increment for aborted frames.
+ *
+ * The structure contains a group of dTSEC HW specific counters relating to the
+ * standard RMON MIB Group 1 (or Ethernet statistics) counters.  This structure
+ * is counting only the carry events of the corresponding HW counters.
+ *
+ * tr64 to trmax notes: Frame sizes specified are considered excluding preamble
+ * and SFD but including FCS bytes.
+ */
+struct dtsec_mib_grp_1_counters {
+	uint64_t  rdrp;
+	uint64_t  tdrp;
+
+	uint64_t  rbyt;
+	uint64_t  rpkt;
+	uint64_t  rbca;
+	uint64_t  rmca;
+	uint64_t  raln;
+	uint64_t  rund;
+	uint64_t  rovr;
+	uint64_t  rfrg;
+	uint64_t  rjbr;
+	uint64_t  tncl;
+
+	uint64_t  tr64;
+	uint64_t  tr127;
+	uint64_t  tr255;
+	uint64_t  tr511;
+	uint64_t  tr1k;
+	uint64_t  trmax;
+};
+
+
+enum dtsec_stat_counters {
+	E_DTSEC_STAT_TR64,
+	E_DTSEC_STAT_TR127,
+	E_DTSEC_STAT_TR255,
+	E_DTSEC_STAT_TR511,
+	E_DTSEC_STAT_TR1K,
+	E_DTSEC_STAT_TRMAX,
+	E_DTSEC_STAT_TRMGV,
+	E_DTSEC_STAT_RBYT,
+	E_DTSEC_STAT_RPKT,
+	E_DTSEC_STAT_RMCA,
+	E_DTSEC_STAT_RBCA,
+	E_DTSEC_STAT_RXPF,
+	E_DTSEC_STAT_RALN,
+	E_DTSEC_STAT_RFLR,
+	E_DTSEC_STAT_RCDE,
+	E_DTSEC_STAT_RCSE,
+	E_DTSEC_STAT_RUND,
+	E_DTSEC_STAT_ROVR,
+	E_DTSEC_STAT_RFRG,
+	E_DTSEC_STAT_RJBR,
+	E_DTSEC_STAT_RDRP,
+	E_DTSEC_STAT_TFCS,
+	E_DTSEC_STAT_TBYT,
+	E_DTSEC_STAT_TPKT,
+	E_DTSEC_STAT_TMCA,
+	E_DTSEC_STAT_TBCA,
+	E_DTSEC_STAT_TXPF,
+	E_DTSEC_STAT_TNCL,
+	E_DTSEC_STAT_TDRP
+};
+
+
+/**
+ * struct dtsec_cfg - dTSEC configuration
+ *
+ * @halfdup_on:		Transmit half-duplex flow control, under software
+ *			control for 10/100-Mbps half-duplex media. If set,
+ *			back pressure is applied to media by raising carrier.
+ * @halfdup_retransmit:	Number of retransmission attempts following a collision.
+ *			If this is exceeded dTSEC aborts transmission due to
+ *			excessive collisions. The standard specifies the
+ *			attempt limit to be 15.
+ * @halfdup_coll_window:The number of bytes of the frame during which
+ *			collisions may occur. The default value of 55
+ *			corresponds to the frame byte at the end of the
+ *			standard 512-bit slot time window. If collisions are
+ *			detected after this byte, the late collision event is
+ *			asserted and transmission of current frame is aborted.
+ * @rx_drop_bcast:	Discard broadcast frames.  If set, all broadcast frames
+ *			will be discarded by dTSEC.
+ * @rx_short_frm:	Accept short frames.  If set, dTSEC will accept frames
+ *			of length 14..63 bytes.
+ * @rx_len_check:	Length check for received frames.  If set, the MAC
+ *			checks the frame's length field on receive to ensure it
+ *			matches the actual data field length. This only works
+ *			for received frames with length field less than 1500.
+ *			No check is performed for larger frames.
+ * @tx_pad_crc:		Pad and append CRC.  If set, the MAC pads all
+ *			transmitted short frames and appends a CRC to every
+ *			frame regardless of padding requirement.
+ * @tx_crc:		Transmission CRC enable.  If set, the MAC appends a CRC
+ *			to all frames.  If frames presented to the MAC have a
+ *			valid length and contain a valid CRC, @tx_crc should be
+ *			reset.
+ *			This field is ignored if @tx_pad_crc is set.
+ * @rx_ctrl_acc:	Control frame accept.  If set, this overrides 802.3
+ *			standard control frame behavior, and all Ethernet frames
+ *			that have an ethertype of 0x8808 are treated as normal
+ *			Ethernet frames and passed up to the packet interface on
+ *			a DA match.  Received pause control frames are passed to
+ *			the packet interface only if Rx flow control is also
+ *			disabled.  See dtsec_handle_rx_pause() function.
+ * @tx_pause_time:	Transmit pause time value.  This pause value is used as
+ *			part of the pause frame to be sent when a transmit pause
+ *			frame is initiated.  If set to 0 this disables
+ *			transmission of pause frames.
+ * @rx_preamble:	Receive preamble enable.  If set, the MAC recovers the
+ *			received Ethernet 7-byte preamble and passes it to the
+ *			packet interface at the start of each received frame.
+ *			This field should be reset for internal MAC loop-back
+ *			mode.
+ * @tx_preamble:	User defined preamble enable for transmitted frames.
+ *			If set, a user-defined preamble must passed to the MAC
+ *			and it is transmitted instead of the standard preamble.
+ * @preamble_len:	Length, in bytes, of the preamble field preceding each
+ *			Ethernet start-of-frame delimiter byte.  The default
+ *			value of 0x7 should be used in order to guarantee
+ *			reliable operation with IEEE 802.3 compliant hardware.
+ * @rx_prepend:		Packet alignment padding length.  The specified number
+ *			of bytes (1-31) of zero padding are inserted before the
+ *			start of each received frame.  For Ethernet, where
+ *			optional preamble extraction is enabled, the padding
+ *			appears before the preamble, otherwise the padding
+ *			precedes the layer 2 header.
+ *
+ * This structure contains basic dTSEC configuration and must be passed to
+ * dtsec_init() function.  A default set of configuration values can be obtained
+ * by calling dtsec_defconfig().
+ */
+struct dtsec_cfg {
+	bool		halfdup_on;
+	bool		halfdup_alt_backoff_en;
+	bool		halfdup_excess_defer;
+	bool		halfdup_no_backoff;
+	bool		halfdup_bp_no_backoff;
+	uint8_t		halfdup_alt_backoff_val;
+	uint16_t	halfdup_retransmit;
+	uint16_t	halfdup_coll_window;
+	bool		rx_drop_bcast;
+	bool		rx_short_frm;
+	bool		rx_len_check;
+	bool		tx_pad_crc;
+	bool		tx_crc;
+	bool		rx_ctrl_acc;
+	unsigned short	tx_pause_time;
+	unsigned short	tbipa;
+	bool		ptp_tsu_en;
+	bool		ptp_exception_en;
+	bool		rx_preamble;
+	bool		tx_preamble;
+	unsigned char	preamble_len;
+	unsigned char	rx_prepend;
+	bool		loopback;
+	bool		rx_time_stamp_en;
+	bool		tx_time_stamp_en;
+	bool		rx_flow;
+	bool		tx_flow;
+	bool		rx_group_hash_exd;
+	bool		rx_promisc;
+    uint8_t     tbi_phy_addr;
+	uint16_t	tx_pause_time_extd;
+	uint16_t	maximum_frame;
+	uint32_t	non_back_to_back_ipg1;
+	uint32_t	non_back_to_back_ipg2;
+	uint32_t	min_ifg_enforcement;
+	uint32_t	back_to_back_ipg;
+};
+
+
+/**
+ * dtsec_defconfig() - Get default dTSEC configuration
+ * @cfg:	pointer to configuration structure.
+ *
+ * Call this function to obtain a default set of configuration values for
+ * initializing dTSEC.  The user can overwrite any of the values before calling
+ * dtsec_init(), if specific configuration needs to be applied.
+ */
+void dtsec_defconfig(struct dtsec_cfg *cfg);
+
+/**
+ * dtsec_init() - Init dTSEC hardware block
+ * @regs:		Pointer to dTSEC register block
+ * @cfg:		dTSEC configuration data
+ * @iface_mode:		dTSEC interface mode, the type of MAC - PHY interface.
+ * @iface_speed:	1G or 10G
+ * @macaddr:		MAC station address to be assigned to the device
+ * @fm_rev_maj:		major rev number
+ * @fm_rev_min:		minor rev number
+ * @exceptions_mask:	initial exceptions mask
+ *
+ * This function initializes dTSEC and applies basic configuration.
+ *
+ * dTSEC initialization sequence:
+ * Before enabling Rx/Tx call dtsec_set_address() to set MAC address,
+ * dtsec_adjust_link() to configure interface speed and duplex and finally
+ * dtsec_enable_tx()/dtsec_enable_rx() to start transmission and reception.
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+int dtsec_init(struct dtsec_regs *regs, struct dtsec_cfg *cfg,
+		enum enet_interface iface_mode,
+		enum enet_speed iface_speed,
+		uint8_t *macaddr, uint8_t fm_rev_maj,
+		uint8_t fm_rev_min,
+		uint32_t exception_mask);
+
+/**
+ * dtsec_get_revision() - Get dTSEC hardware revision
+ * @regs:   Pointer to dTSEC register block
+ *
+ * Returns dtsec_id content
+ *
+ * Call this function to obtain the dTSEC hardware version.
+ */
+uint32_t dtsec_get_revision(struct dtsec_regs *regs);
+
+/**
+ * dtsec_set_uc_promisc() - Sets unicast promiscuous mode
+ * @regs:	Pointer to dTSEC register block
+ * @enable:	Enable unicast promiscuous mode
+ *
+ * Use this function to enable/disable dTSEC L2 address filtering.  If the
+ * address filtering is disabled all unicast packets are accepted.
+ * To set dTSEC in promiscuous mode call both dtsec_set_uc_promisc() and
+ * dtsec_set_mc_promisc() to disable filtering for both unicast and multicast
+ * addresses.
+ */
+void dtsec_set_uc_promisc(struct dtsec_regs *regs, bool enable);
+
+/**
+ * dtsec_adjust_link() - Adjust dTSEC speed/duplex settings
+ * @regs:	Pointer to dTSEC register block
+ * @iface_mode: dTSEC interface mode
+ * @speed:	Link speed
+ * @full_dx:	True for full-duplex, false for half-duplex.
+ *
+ * This function configures the MAC to function and the desired rates.  Use it
+ * to configure dTSEC after dtsec_init() and whenever the link speed changes
+ * (for instance following PHY auto-negociation).
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+int dtsec_adjust_link(struct dtsec_regs *regs,
+		enum enet_interface iface_mode,
+		enum enet_speed speed, bool full_dx);
+
+/**
+ * dtsec_set_tbi_phy_addr() - Updates TBI address field
+ * @regs:	Pointer to dTSEC register block
+ * @address:	Valid PHY address in the range of 1 to 31. 0 is reserved.
+ *
+ * In SGMII mode, the dTSEC's TBIPA field must contain a valid TBI PHY address
+ * so that the associated TBI PHY (i.e. the link) may be initialized.
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+int dtsec_set_tbi_phy_addr(struct dtsec_regs *regs,
+		uint8_t addr);
+
+/**
+ * dtsec_disable() - Disable dTSEC Tx and Rx
+ * @regs:	Pointer to dTSEC register block
+ * @apply_rx:	disable rx side
+ * @apply_tx:	disable tx side
+ *
+ * This function disables Tx and Rx in dTSEC.
+ */
+void dtsec_disable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
+
+/**
+ * dtsec_enable() - Enable dTSEC Tx and Tx
+ * @regs:	Pointer to dTSEC register block
+ * @apply_rx:	enable rx side
+ * @apply_tx:	enable tx side
+ *
+ * This function resets Tx and Rx graceful stop bit and enables dTSEC Tx and Rx.
+ */
+void dtsec_enable(struct dtsec_regs *regs, bool apply_rx, bool apply_tx);
+
+/**
+ * dtsec_set_mac_address() - Set MAC station address
+ * @regs:   Pointer to dTSEC register block
+ * @macaddr:    MAC address array
+ *
+ * This function sets MAC station address.  To enable unicast reception call
+ * this after dtsec_init().  While promiscuous mode is disabled dTSEC will match
+ * the destination address of received unicast frames against this address.
+ */
+void dtsec_set_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
+
+/**
+ * dtsec_get_mac_address() - Query MAC station address
+ * @regs:   Pointer to dTSEC register block
+ * @macaddr:    MAC address array
+ */
+void dtsec_get_mac_address(struct dtsec_regs *regs, uint8_t *macaddr);
+
+/**
+ * dtsec_set_max_frame_len() - Set max frame length
+ * @regs:	Pointer to dTSEC register block
+ * @length:	Max frame length.
+ *
+ * Sets maximum frame length for received and transmitted frames.  Frames that
+ * exceeds this length are truncated.
+ */
+
+void dtsec_set_max_frame_len(struct dtsec_regs *regs, uint16_t length);
+
+
+/**
+ * dtsec_get_max_frame_len() - Query max frame length
+ * @regs:	Pointer to dTSEC register block
+ *
+ * Returns: the current value of the maximum frame length.
+ */
+uint16_t dtsec_get_max_frame_len(struct dtsec_regs *regs);
+
+
+/**
+ * dtsec_handle_rx_pause() - Configure pause frame handling
+ * @regs:	Pointer to dTSEC register block
+ * @en:		Enable pause frame handling in dTSEC
+ *
+ * If enabled, dTSEC will handle pause frames internally.  This must be disabled
+ * if dTSEC is set in half-duplex mode.
+ * If pause frame handling is disabled and &dtsec_cfg.rx_ctrl_acc is set, pause
+ * frames will be transferred to the packet interface just like regular Ethernet
+ * frames.
+ */
+void dtsec_handle_rx_pause(struct dtsec_regs *regs, bool en);
+
+/**
+ * dtsec_set_tx_pause_time() - Configure Tx pause time
+ * @regs:	Pointer to dTSEC register block
+ * @time:	Time value included in pause frames
+ *
+ * Call this function to set the time value used in transmitted pause frames.
+ * If time is 0, transmission of pause frames is disabled
+ */
+void dtsec_set_tx_pause_time(struct dtsec_regs *regs, uint16_t time);
+
+/**
+ * dtsec_ack_event() - Acknowledge handled events
+ * @regs:	Pointer to dTSEC register block
+ * @ev_mask:	Events to acknowledge
+ *
+ * After handling events signaled by dTSEC in either polling or interrupt mode,
+ * call this function to reset the associated status bits in dTSEC event
+ * register.
+ */
+void dtsec_ack_event(struct dtsec_regs *regs, uint32_t ev_mask);
+
+/**
+ * dtsec_get_event() - Returns currently asserted events
+ * @regs:	Pointer to dTSEC register block
+ * @ev_mask:	Mask of relevant events
+ *
+ * Call this function to obtain a bit-mask of events that are currently asserted
+ * in dTSEC, taken from IEVENT register.
+ *
+ * Returns: a bit-mask of events asserted in dTSEC.
+ */
+uint32_t dtsec_get_event(struct dtsec_regs *regs, uint32_t ev_mask);
+/**
+ * dtsec_get_interrupt_mask() - Returns a bit-mask of enabled interrupts
+ * @regs:   Pointer to dTSEC register block
+ *
+ * Call this function to obtain a bit-mask of enabled interrupts
+ * in dTSEC, taken from IMASK register.
+ *
+ * Returns: a bit-mask of enabled interrupts in dTSEC.
+ */
+uint32_t dtsec_get_interrupt_mask(struct dtsec_regs *regs);
+
+void dtsec_clear_addr_in_paddr  (struct dtsec_regs *regs,
+                                 uint8_t paddr_num);
+
+void dtsec_add_addr_in_paddr    (struct dtsec_regs *regs,
+                                 uint64_t addr,
+                                 uint8_t paddr_num);
+
+void dtsec_enable_tmr_interrupt (struct dtsec_regs *regs);
+
+void dtsec_disable_tmr_interrupt(struct dtsec_regs *regs);
+
+/**
+ * dtsec_disable_interrupt() - Disables interrupts for the specified events
+ * @regs:	Pointer to dTSEC register block
+ * @ev_mask:	Mask of relevant events
+ *
+ * Call this function to disable interrupts in dTSEC for the specified events.
+ * To enable interrupts use dtsec_enable_interrupt().
+ */
+void dtsec_disable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
+
+/**
+ * dtsec_enable_interrupt() - Enable interrupts for the specified events
+ * @regs:	Pointer to dTSEC register block
+ * @ev_mask:	Mask of relevant events
+ *
+ * Call this function to enable interrupts in dTSEC for the specified events.
+ * To disable interrupts use dtsec_disable_interrupt().
+ */
+void dtsec_enable_interrupt(struct dtsec_regs *regs, uint32_t ev_mask);
+
+/**
+ * dtsec_set_ts() - Enables dTSEC timestamps
+ * @regs:	Pointer to dTSEC register block
+ * @en:		true to enable timestamps, false to disable them
+ *
+ * Call this function to enable/disable dTSEC timestamps.  This affects both
+ * Tx and Rx.
+ */
+void dtsec_set_ts(struct dtsec_regs *regs, bool en);
+
+/**
+ * dtsec_compute_bucket() - Get bucket index for an address
+ * @regs:	Pointer to dTSEC register block
+ * @addr:	MAC address
+ * @bucket:	pointer to hold the return value of the bucket index
+ *
+ * This function returns the bucket index associated with the specified address.
+ * This index can be used to enable/disable specific buckets.
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+int dtsec_compute_bucket(struct dtsec_regs *regs, unsigned char addr[6],
+			 int32_t *bucket);
+
+/**
+ * dtsec_set_bucket() - Enables/disables a filter bucket
+ * @regs:   Pointer to dTSEC register block
+ * @bucket: Bucket index
+ * @enable: true/false to enable/disable this bucket
+ *
+ * This function enables or disables the specified bucket.  Enabling a bucket
+ * associated with an address configures dTSEC to accept received packets
+ * with that destination address.
+ * Multiple addresses may be associated with the same bucket.  Disabling a
+ * bucket will affect all addresses associated with that bucket. A bucket that
+ * is enabled requires further filtering and verification in the upper layers
+ *
+ */
+void dtsec_set_bucket(struct dtsec_regs *regs, int bucket, bool enable);
+
+/**
+ * dtsec_reset_filter_table() - Resets the address filtering table
+ * @regs:	Pointer to dTSEC register block
+ * @mcast:	Reset multicast entries
+ * @ucast:	Reset unicast entries
+ *
+ * Resets all entries in L2 address filter table.  After calling this function
+ * all buckets enabled using dtsec_set_bucket() will be disabled.
+ * If dtsec_init_filter_table() was called with @unicast_hash set to false,
+ * @ucast argument is ignored.
+ * This does not affect the primary nor the 15 additional addresses configured
+ * using dtsec_set_address() or dtsec_set_match_address().
+ */
+void  dtsec_reset_filter_table(struct dtsec_regs *regs, bool mcast, bool ucast);
+
+/**
+ * dtsec_set_mc_promisc() - Set multicast promiscous mode
+ * @regs:	Pointer to dTSEC register block
+ * @enable:	Enable multicast promiscous mode
+ *
+ * Call this to enable/disable L2 address filtering for multicast packets.
+ */
+void dtsec_set_mc_promisc(struct dtsec_regs *regs, bool enable);
+
+/* statistics APIs */
+
+/**
+ * dtsec_set_stat_level() - Enable a group of MIB statistics counters
+ * @regs:	Pointer to dTSEC register block
+ * @level:	Specifies a certain group of dTSEC MIB HW counters or _all_,
+ *		to specify all the existing counters.
+ *		If set to _none_, it disables all the counters.
+ *
+ * Enables the MIB statistics hw counters and sets up the carry interrupt
+ * masks for the counters corresponding to the @level input parameter.
+ *
+ * Returns: error if invalid @level value given.
+ */
+int dtsec_set_stat_level(struct dtsec_regs *regs, enum mac_stat_level level);
+
+/**
+ * dtsec_reset_stat() - Completely resets all dTSEC HW counters
+ * @regs:	Pointer to dTSEC register block
+ */
+void dtsec_reset_stat(struct dtsec_regs *regs);
+
+/**
+ * dtsec_get_clear_carry_regs() - Read and clear carry bits (CAR1-2 registers)
+ * @regs:	Pointer to dTSEC register block
+ * @car1:	car1 register value
+ * @car2:	car2 register value
+ *
+ * When set, the carry bits signal that an overflow occurred on the
+ * corresponding counters.
+ * Note that the carry bits (CAR1-2 registers) will assert the
+ * %DTSEC_IEVENT_MSRO interrupt if unmasked (via CAM1-2 regs).
+ *
+ * Returns: true if overflow occurred, otherwise - false
+ */
+bool dtsec_get_clear_carry_regs(struct dtsec_regs *regs,
+				uint32_t *car1, uint32_t *car2);
+
+uint32_t dtsec_check_and_clear_tmr_event(struct dtsec_regs *regs);
+
+uint32_t dtsec_get_stat_counter(struct dtsec_regs *regs,
+				enum dtsec_stat_counters reg_name);
+
+void dtsec_start_tx(struct dtsec_regs *regs);
+void dtsec_start_rx(struct dtsec_regs *regs);
+void dtsec_stop_rx(struct dtsec_regs *regs);
+void dtsec_stop_tx(struct dtsec_regs *regs);
+
+
+#endif /* FSL_FMAN_DTSEC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h
new file mode 100644
index 0000000..2d74b6a
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h
@@ -0,0 +1,102 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __FSL_FMAN_DTSEC_MII_ACC_H
+#define __FSL_FMAN_DTSEC_MII_ACC_H
+
+#include "common/general.h"
+
+
+/* MII Management Configuration Register */
+#define MIIMCFG_RESET_MGMT		0x80000000
+#define MIIMCFG_MGNTCLK_MASK		0x00000007
+#define MIIMCFG_MGNTCLK_SHIFT		0
+
+/* MII  Management Command Register */
+#define MIIMCOM_SCAN_CYCLE		0x00000002
+#define MIIMCOM_READ_CYCLE		0x00000001
+
+/* MII  Management Address Register */
+#define MIIMADD_PHY_ADDR_SHIFT		8
+#define MIIMADD_PHY_ADDR_MASK		0x00001f00
+
+#define MIIMADD_REG_ADDR_SHIFT		0
+#define MIIMADD_REG_ADDR_MASK		0x0000001f
+
+/* MII Management Indicator Register */
+#define MIIMIND_BUSY			0x00000001
+
+
+/* PHY Control Register */
+#define PHY_CR_LOOPBACK     0x4000
+#define PHY_CR_SPEED0       0x2000
+#define PHY_CR_ANE          0x1000
+#define PHY_CR_FULLDUPLEX   0x0100
+#define PHY_CR_SPEED1       0x0040
+
+#define PHY_TBICON_SRESET   0x8000
+#define PHY_TBICON_SPEED2   0x0020
+
+/* register map */
+
+/* MII Configuration Control Memory Map Registers */
+struct dtsec_mii_reg {
+	uint32_t reserved1[72];
+	uint32_t miimcfg;	/* MII Mgmt:configuration */
+	uint32_t miimcom;	/* MII Mgmt:command       */
+	uint32_t miimadd;	/* MII Mgmt:address       */
+	uint32_t miimcon;	/* MII Mgmt:control 3     */
+	uint32_t miimstat;	/* MII Mgmt:status        */
+	uint32_t miimind;	/* MII Mgmt:indicators    */
+};
+
+/* dTSEC MII API */
+
+/* functions to access the mii registers for phy configuration.
+ * this functionality may not be available for all dtsecs in the system.
+ * consult the reference manual for details */
+void dtsec_mii_reset(struct dtsec_mii_reg *regs);
+/* frequency is in MHz.
+ * note that dtsec clock is 1/2 of fman clock */
+void dtsec_mii_init(struct dtsec_mii_reg *regs, uint16_t dtsec_freq);
+int dtsec_mii_write_reg(struct dtsec_mii_reg *regs,
+			uint8_t addr,
+			uint8_t reg,
+			uint16_t data);
+
+int dtsec_mii_read_reg(struct dtsec_mii_reg *regs,
+			uint8_t addr,
+			uint8_t reg,
+			uint16_t *data);
+
+#endif /* __FSL_FMAN_DTSEC_MII_ACC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h
new file mode 100644
index 0000000..515dbfc
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_memac.h
@@ -0,0 +1,384 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __FSL_FMAN_MEMAC_H
+#define __FSL_FMAN_MEMAC_H
+
+#include "common/general.h"
+#include "fsl_enet.h"
+
+
+#define MEMAC_NUM_OF_PADDRS         7           /* Number of additional exact match MAC address registers */
+
+typedef struct t_MacAddr
+{
+    uint32_t   mac_addr_l;         /* Lower 32 bits of 48-bit MAC address */
+    uint32_t   mac_addr_u;         /* Upper 16 bits of 48-bit MAC address */
+} t_MacAddr;
+
+/* Control and Configuration Register (COMMAND_CONFIG) */
+#define CMD_CFG_MG                  0x80000000  /* 00 Magic Packet detection */
+#define CMD_CFG_REG_LOWP_RXETY      0x01000000  /* 07 Rx low power indication */
+#define CMD_CFG_TX_LOWP_ENA         0x00800000  /* 08 Transmit Low Power Idle Enable */
+#define CMD_CFG_SFD_ANY             0x00200000  /* 10 Disable check of SFD (0xd5) character at frame start */
+#define CMD_CFG_PFC_MODE            0x00080000  /* 12 Enable Priority Flow Control (PFC) mode of operation */
+#define CMD_CFG_NO_LEN_CHK          0x00020000  /* 14 Payload length check disable */
+#define CMD_CFG_SEND_IDLE           0x00010000  /* 15 Force idle generation */
+#define CMD_CFG_CNT_FRM_EN          0x00002000  /* 18 Control frame reception enable */
+#define CMD_CFG_SW_RESET            0x00001000  /* 19 Software Reset, self clearing bit */
+#define CMD_CFG_TX_PAD_EN           0x00000800  /* 20 Enable padding of frames in transmit direction */
+#define CMD_CFG_LOOPBACK_EN         0x00000400  /* 21 XGMII/GMII loopback enable */
+#define CMD_CFG_TX_ADDR_INS         0x00000200  /* 22 Transmit source MAC address insertion */
+#define CMD_CFG_PAUSE_IGNORE        0x00000100  /* 23 Ignore Pause frame quanta */
+#define CMD_CFG_PAUSE_FWD           0x00000080  /* 24 Terminate/forward received Pause frames */
+#define CMD_CFG_CRC_FWD             0x00000040  /* 25 Terminate/forward CRC of received frames */
+#define CMD_CFG_PAD_EN              0x00000020  /* 26 Frame padding removal in receive path enable */
+#define CMD_CFG_PROMIS_EN           0x00000010  /* 27 Promiscuous operation enable */
+#define CMD_CFG_WAN_MODE            0x00000008  /* 28 WAN mode enable */
+#define CMD_CFG_RX_EN               0x00000002  /* 30 MAC receive path enable */
+#define CMD_CFG_TX_EN               0x00000001  /* 31 MAC transmit path enable */
+
+/* Interface Mode Register (IF_MODE) */
+#define IF_MODE_MASK                0x00000003  /* 30-31 Mask on interface mode bits */
+#define IF_MODE_XGMII               0x00000000  /* 30-31 XGMII (10G) interface */
+#define IF_MODE_GMII                0x00000002  /* 30-31 GMII (1G) interface */
+#define IF_MODE_RGMII               0x00000004
+#define IF_MODE_RGMII_AUTO          0x00008000
+
+/* Hash table Control Register (HASHTABLE_CTRL) */
+#define HASH_CTRL_MCAST_SHIFT       26
+#define HASH_CTRL_MCAST_EN          0x00000100  /* 23 Multicast frame reception for the hash entry */
+#define HASH_CTRL_ADDR_MASK         0x0000003F  /* 26-31 Hash table address code */
+
+#define GROUP_ADDRESS               0x0000010000000000LL /* MAC multicast address bit indication */
+#define HASH_TABLE_SIZE             64          /* Hash table size (bits 26-31 in HASHTABLE_CTRL allows for 2^6 entries) */
+
+/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
+#define TX_IPG_LENGTH_MASK          0x0000003F
+
+/* Statistics Configuration Register (STATN_CONFIG) */
+#define STATS_CFG_CLR               0x00000004  /* 29 Reset all counters */
+#define STATS_CFG_CLR_ON_RD         0x00000002  /* 30 Clear on read */
+#define STATS_CFG_SATURATE          0x00000001  /* 31 Saturate at the maximum value */
+
+/* Internal PHY Registers - SGMII */
+#define PHY_SGMII_CR_PHY_RESET      0x8000
+#define PHY_SGMII_CR_RESET_AN       0x0200
+#define PHY_SGMII_CR_DEF_VAL        0x1140
+#define PHY_SGMII_DEV_ABILITY_SGMII 0x4001
+#define PHY_SGMII_IF_MODE_AN        0x0002
+#define PHY_SGMII_IF_MODE_SGMII     0x0001
+
+/* Interrupt Mask Register (IMASK) */
+#define IMASK_PCS                   0x80000000  /* 0 PCS
+                                                 * XGMII - PCS event
+                                                 * GMII - link synchronization event
+                                                 */
+#define IMASK_AN                    0x40000000  /* 1 AN
+                                                 * XGMII - Auto-negotiation event
+                                                 * GMII - Auto-negotiation status
+                                                 */
+#define IMASK_LT                    0x20000000  /* 2 LT
+                                                 * XGMII - Link Training event
+                                                 * GMII - new page received by auto-negotiation function
+                                                 */
+#define IMASK_MGI                   0x00004000  /* 17 Magic packet detection indication event */
+#define IMASK_RX_FIFO_OVFL          0x00001000  /* 19 Receive FIFO overflow event */
+#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 Transmit FIFO underflow event */
+#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 Transmit FIFO overflow event */
+#define IMASK_TX_ECC_ER             0x00000200  /* 22 Transmit frame ECC error event */
+#define IMASK_RX_ECC_ER             0x00000100  /* 23 Receive frame ECC error event */
+#define IMASK_LI_FAULT              0x00000080  /* 24 Link Interruption fault event (XGMII) */
+#define IMASK_RX_EMPTY              0x00000040  /* 25 Receive FIFO empty event */
+#define IMASK_TX_EMPTY              0x00000020  /* 26 Transmit FIFO empty event */
+#define IMASK_RX_LOWP               0x00000010  /* 27 Low Power Idle event */
+#define IMASK_PHY_LOS               0x00000004  /* 29 Phy loss of signal event */
+#define IMASK_REM_FAULT             0x00000002  /* 30 Remote fault event (XGMII) */
+#define IMASK_LOC_FAULT             0x00000001  /* 31 Local fault event (XGMII) */
+
+#define EVENTS_MASK                 ((uint32_t)(IMASK_PCS           |  \
+                                                IMASK_AN            |  \
+                                                IMASK_LT            |  \
+                                                IMASK_MGI           |  \
+                                                IMASK_RX_FIFO_OVFL  |  \
+                                                IMASK_TX_FIFO_UNFL  |  \
+                                                IMASK_TX_FIFO_OVFL  |  \
+                                                IMASK_TX_ECC_ER     |  \
+                                                IMASK_RX_ECC_ER     |  \
+                                                IMASK_LI_FAULT      |  \
+                                                IMASK_RX_EMPTY      |  \
+                                                IMASK_TX_EMPTY      |  \
+                                                IMASK_RX_LOWP       |  \
+                                                IMASK_PHY_LOS       |  \
+                                                IMASK_REM_FAULT     |  \
+                                                IMASK_LOC_FAULT))
+
+enum memac_counters {
+    E_MEMAC_COUNTER_R64,
+    E_MEMAC_COUNTER_R127,
+    E_MEMAC_COUNTER_R255,
+    E_MEMAC_COUNTER_R511,
+    E_MEMAC_COUNTER_R1023,
+    E_MEMAC_COUNTER_R1518,
+    E_MEMAC_COUNTER_R1519X,
+    E_MEMAC_COUNTER_RFRG,
+    E_MEMAC_COUNTER_RJBR,
+    E_MEMAC_COUNTER_RDRP,
+    E_MEMAC_COUNTER_RALN,
+    E_MEMAC_COUNTER_TUND,
+    E_MEMAC_COUNTER_ROVR,
+    E_MEMAC_COUNTER_RXPF,
+    E_MEMAC_COUNTER_TXPF,
+    E_MEMAC_COUNTER_ROCT,
+    E_MEMAC_COUNTER_RMCA,
+    E_MEMAC_COUNTER_RBCA,
+    E_MEMAC_COUNTER_RPKT,
+    E_MEMAC_COUNTER_RUCA,
+    E_MEMAC_COUNTER_RERR,
+    E_MEMAC_COUNTER_TOCT,
+    E_MEMAC_COUNTER_TMCA,
+    E_MEMAC_COUNTER_TBCA,
+    E_MEMAC_COUNTER_TUCA,
+    E_MEMAC_COUNTER_TERR
+};
+
+/*
+ * memory map
+ */
+struct memac_regs {
+    /* General Control and Status */
+     uint32_t   reserved1[2];
+     uint32_t   command_config;     /* 0x008 COMMAND_CONFIG - Control and configuration register */
+     struct t_MacAddr mac_addr0;                    /* 0x00C-0x010 MAC_ADDR_0...MAC_ADDR_1 */
+     uint32_t   maxfrm;             /* 0x014 MAXFRM - Maximum frame length register */
+     uint32_t   reserved2[5];
+     uint32_t   hashtable_ctrl;     /* 0x02C HASHTABLE_CTRL - Hash table control register */
+     uint32_t   reserved3[4];
+     uint32_t   ievent;             /* 0x040 IEVENT - Interrupt event register */
+     uint32_t   tx_ipg_length;      /* 0x044 TX_IPG_LENGTH - Transmitter inter-packet-gap register */
+     uint32_t   reserved4;
+     uint32_t   imask;              /* 0x04C IMASK - Interrupt mask register */
+     uint32_t   reserved5;
+
+     uint32_t   pause_quanta[4];    /* 0x054 CL0x_PAUSE_QUANTA - CL0-7 Pause quanta register */
+     uint32_t   pause_thresh[4];    /* 0x064 CL0x_PAUSE_THRESH - CL0-7 Pause quanta threshold register */
+     uint32_t   rx_pause_status;    /* 0x074 RX_PAUSE_STATUS - Receive pause status register */
+     uint32_t   reserved6[2];
+     struct t_MacAddr mac_addr[MEMAC_NUM_OF_PADDRS]; /* 0x80-0x0B4 MAC_ADDR_2...MAC_ADDR_15 */
+     uint32_t   lpwake_timer;       /* 0x0B8 LPWAKE_TIMER - EEE Low Power Wakeup Timer register */
+     uint32_t   sleep_timer;        /* 0x0BC SLEEP_TIMER - Transmit EEE Low Power Timer register */
+     uint32_t   reserved7[8];
+     uint32_t   statn_config;       /* 0x0E0 STATN_CONFIG - Statistics configuration register */
+     uint32_t   reserved8[7];
+
+    /* Rx Statistics Counter */
+     uint32_t   reoct_l;
+     uint32_t   reoct_u;
+     uint32_t   roct_l;
+     uint32_t   roct_u;
+     uint32_t   raln_l;
+     uint32_t   raln_u;
+     uint32_t   rxpf_l;
+     uint32_t   rxpf_u;
+     uint32_t   rfrm_l;
+     uint32_t   rfrm_u;
+     uint32_t   rfcs_l;
+     uint32_t   rfcs_u;
+     uint32_t   rvlan_l;
+     uint32_t   rvlan_u;
+     uint32_t   rerr_l;
+     uint32_t   rerr_u;
+     uint32_t   ruca_l;
+     uint32_t   ruca_u;
+     uint32_t   rmca_l;
+     uint32_t   rmca_u;
+     uint32_t   rbca_l;
+     uint32_t   rbca_u;
+     uint32_t   rdrp_l;
+     uint32_t   rdrp_u;
+     uint32_t   rpkt_l;
+     uint32_t   rpkt_u;
+     uint32_t   rund_l;
+     uint32_t   rund_u;
+     uint32_t   r64_l;
+     uint32_t   r64_u;
+     uint32_t   r127_l;
+     uint32_t   r127_u;
+     uint32_t   r255_l;
+     uint32_t   r255_u;
+     uint32_t   r511_l;
+     uint32_t   r511_u;
+     uint32_t   r1023_l;
+     uint32_t   r1023_u;
+     uint32_t   r1518_l;
+     uint32_t   r1518_u;
+     uint32_t   r1519x_l;
+     uint32_t   r1519x_u;
+     uint32_t   rovr_l;
+     uint32_t   rovr_u;
+     uint32_t   rjbr_l;
+     uint32_t   rjbr_u;
+     uint32_t   rfrg_l;
+     uint32_t   rfrg_u;
+     uint32_t   rcnp_l;
+     uint32_t   rcnp_u;
+     uint32_t   rdrntp_l;
+     uint32_t   rdrntp_u;
+     uint32_t   reserved9[12];
+
+    /* Tx Statistics Counter */
+     uint32_t   teoct_l;
+     uint32_t   teoct_u;
+     uint32_t   toct_l;
+     uint32_t   toct_u;
+     uint32_t   reserved10[2];
+     uint32_t   txpf_l;
+     uint32_t   txpf_u;
+     uint32_t   tfrm_l;
+     uint32_t   tfrm_u;
+     uint32_t   tfcs_l;
+     uint32_t   tfcs_u;
+     uint32_t   tvlan_l;
+     uint32_t   tvlan_u;
+     uint32_t   terr_l;
+     uint32_t   terr_u;
+     uint32_t   tuca_l;
+     uint32_t   tuca_u;
+     uint32_t   tmca_l;
+     uint32_t   tmca_u;
+     uint32_t   tbca_l;
+     uint32_t   tbca_u;
+     uint32_t   reserved11[2];
+     uint32_t   tpkt_l;
+     uint32_t   tpkt_u;
+     uint32_t   tund_l;
+     uint32_t   tund_u;
+     uint32_t   t64_l;
+     uint32_t   t64_u;
+     uint32_t   t127_l;
+     uint32_t   t127_u;
+     uint32_t   t255_l;
+     uint32_t   t255_u;
+     uint32_t   t511_l;
+     uint32_t   t511_u;
+     uint32_t   t1023_l;
+     uint32_t   t1023_u;
+     uint32_t   t1518_l;
+     uint32_t   t1518_u;
+     uint32_t   t1519x_l;
+     uint32_t   t1519x_u;
+     uint32_t   reserved12[6];
+     uint32_t   tcnp_l;
+     uint32_t   tcnp_u;
+     uint32_t   reserved13[14];
+
+    /* Line Interface Control */
+     uint32_t   if_mode;            /* 0x300 IF_MODE - Interface Mode Control register */
+     uint32_t   if_status;          /* 0x304 IF_STATUS - Interface Status register */
+     uint32_t   reserved14[14];
+
+    /* HiGig/2 */
+     uint32_t   hg_config;          /* 0x340 HG_CONFIG - HiGig/2 Control and configuration register */
+     uint32_t   reserved15[3];
+     uint32_t   hg_pause_quanta;    /* 0x350 HG_PAUSE_QUANTA - HiGig2 Pause quanta register */
+     uint32_t   reserved16[3];
+     uint32_t   hg_pause_thresh;    /* 0x360 HG_PAUSE_THRESH - HiGig2 Pause quanta threshold register */
+     uint32_t   reserved17[3];
+     uint32_t   hgrx_pause_status;  /* 0x370 HGRX_PAUSE_STATUS - HiGig2 Receive pause status register*/
+     uint32_t   hg_fifos_status;    /* 0x374 HG_FIFOS_STATUS - HiGig2 fifos status register */
+     uint32_t   rhm;                /* 0x378 RHM - Receive HiGig2 messages counter register */
+     uint32_t   thm;                /* 0x37C THM - Transmit HiGig2 messages counter register */
+};
+
+
+struct memac_cfg {
+
+    bool        reset_on_init;
+    bool        rx_error_discard;
+    bool        pause_ignore;
+    bool        pause_forward_enable;
+    bool        no_length_check_enable;
+    bool        cmd_frame_enable;
+    bool        send_idle_enable;
+    bool        wan_mode_enable;
+    bool        promiscuous_mode_enable;
+    bool        tx_addr_ins_enable;
+    bool        loopback_enable;
+    bool        lgth_check_nostdr;
+    bool        time_stamp_enable;
+    bool        pad_enable;
+    bool        phy_tx_ena_on;
+    bool        rx_sfd_any;
+    bool        rxPblFwd;
+    bool        txPblFwd;
+    bool        debugMode;
+    uint16_t    max_frame_length;
+    uint16_t    pause_quant;
+    uint32_t    tx_ipg_length;
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    bool        skip_fman11_workaround;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+};
+
+/**
+ * memac_defconfig() - Get default MEMAC configuration
+ * @cfg:    pointer to configuration structure.
+ *
+ * Call this function to obtain a default set of configuration values for
+ * initializing MEMAC. The user can overwrite any of the values before calling
+ * memac_init(), if specific configuration needs to be applied.
+ */
+void memac_defconfig(struct memac_cfg *cfg);
+void memac_set_promiscuous(struct memac_regs *regs, bool val);
+void memac_hardware_add_addr_in_paddr(struct memac_regs *regs, uint8_t *adr, uint8_t paddr_num);
+void memac_hardware_clear_addr_in_paddr(struct memac_regs *regs, uint8_t paddr_num);
+void memac_enable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
+void memac_disable(struct memac_regs *regs, bool apply_rx, bool apply_tx);
+uint64_t memac_get_counter(struct memac_regs *regs, enum memac_counters reg_name);
+void memac_set_tx_pause_frames(struct memac_regs    *regs,
+                               uint8_t              priority,
+                               uint16_t             pauseTime,
+                               uint16_t             threshTime);
+uint16_t memac_get_max_frame_length(struct memac_regs *regs);
+void memac_init(struct memac_regs *regs, struct memac_cfg *cfg,
+        enum enet_interface enet_interface, enum enet_speed enet_speed,
+        uint32_t exceptions);
+void memac_set_exception(struct memac_regs *regs, uint32_t val, bool enable);
+void memac_reset_counter(struct memac_regs *regs);
+void memac_reset(struct memac_regs *regs);
+void memac_set_hash_table(struct memac_regs *regs, uint32_t val);
+void memac_set_rx_ignore_pause_frames(struct memac_regs  *regs,bool enable);
+void memac_reset_counter(struct memac_regs *regs);
+
+
+#endif /*__FSL_FMAN_MEMAC_H*/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h
new file mode 100644
index 0000000..5495b82
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/fsl_fman_tgec.h
@@ -0,0 +1,466 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __FSL_FMAN_TGEC_H
+#define __FSL_FMAN_TGEC_H
+
+#include "common/general.h"
+#include "fsl_enet.h"
+
+
+/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
+#define TX_IPG_LENGTH_MASK    0x000003ff
+
+enum tgec_counters {
+    E_TGEC_COUNTER_R64,
+    E_TGEC_COUNTER_R127,
+    E_TGEC_COUNTER_R255,
+    E_TGEC_COUNTER_R511,
+    E_TGEC_COUNTER_R1023,
+    E_TGEC_COUNTER_R1518,
+    E_TGEC_COUNTER_R1519X,
+    E_TGEC_COUNTER_TRFRG,
+    E_TGEC_COUNTER_TRJBR,
+    E_TGEC_COUNTER_RDRP,
+    E_TGEC_COUNTER_RALN,
+    E_TGEC_COUNTER_TRUND,
+    E_TGEC_COUNTER_TROVR,
+    E_TGEC_COUNTER_RXPF,
+    E_TGEC_COUNTER_TXPF,
+    E_TGEC_COUNTER_ROCT,
+    E_TGEC_COUNTER_RMCA,
+    E_TGEC_COUNTER_RBCA,
+    E_TGEC_COUNTER_RPKT,
+    E_TGEC_COUNTER_RUCA,
+    E_TGEC_COUNTER_RERR,
+    E_TGEC_COUNTER_TOCT,
+    E_TGEC_COUNTER_TMCA,
+    E_TGEC_COUNTER_TBCA,
+    E_TGEC_COUNTER_TUCA,
+    E_TGEC_COUNTER_TERR
+};
+
+/* Command and Configuration Register (COMMAND_CONFIG) */
+#define CMD_CFG_EN_TIMESTAMP        0x00100000
+#define CMD_CFG_TX_ADDR_INS_SEL     0x00080000
+#define CMD_CFG_NO_LEN_CHK          0x00020000
+#define CMD_CFG_SEND_IDLE           0x00010000
+#define CMD_CFG_RX_ER_DISC          0x00004000
+#define CMD_CFG_CMD_FRM_EN          0x00002000
+#define CMD_CFG_STAT_CLR            0x00001000
+#define CMD_CFG_LOOPBACK_EN         0x00000400
+#define CMD_CFG_TX_ADDR_INS         0x00000200
+#define CMD_CFG_PAUSE_IGNORE        0x00000100
+#define CMD_CFG_PAUSE_FWD           0x00000080
+#define CMD_CFG_PROMIS_EN           0x00000010
+#define CMD_CFG_WAN_MODE            0x00000008
+#define CMD_CFG_RX_EN               0x00000002
+#define CMD_CFG_TX_EN               0x00000001
+
+/* Interrupt Mask Register (IMASK) */
+#define TGEC_IMASK_MDIO_SCAN_EVENT       0x00010000
+#define TGEC_IMASK_MDIO_CMD_CMPL         0x00008000
+#define TGEC_IMASK_REM_FAULT             0x00004000
+#define TGEC_IMASK_LOC_FAULT             0x00002000
+#define TGEC_IMASK_TX_ECC_ER             0x00001000
+#define TGEC_IMASK_TX_FIFO_UNFL          0x00000800
+#define TGEC_IMASK_TX_FIFO_OVFL          0x00000400
+#define TGEC_IMASK_TX_ER                 0x00000200
+#define TGEC_IMASK_RX_FIFO_OVFL          0x00000100
+#define TGEC_IMASK_RX_ECC_ER             0x00000080
+#define TGEC_IMASK_RX_JAB_FRM            0x00000040
+#define TGEC_IMASK_RX_OVRSZ_FRM          0x00000020
+#define TGEC_IMASK_RX_RUNT_FRM           0x00000010
+#define TGEC_IMASK_RX_FRAG_FRM           0x00000008
+#define TGEC_IMASK_RX_LEN_ER             0x00000004
+#define TGEC_IMASK_RX_CRC_ER             0x00000002
+#define TGEC_IMASK_RX_ALIGN_ER           0x00000001
+
+
+#define EVENTS_MASK ((uint32_t)(TGEC_IMASK_MDIO_SCAN_EVENT    | \
+                TGEC_IMASK_MDIO_CMD_CMPL     | \
+                TGEC_IMASK_REM_FAULT         | \
+                TGEC_IMASK_LOC_FAULT         | \
+                TGEC_IMASK_TX_ECC_ER         | \
+                TGEC_IMASK_TX_FIFO_UNFL      | \
+                TGEC_IMASK_TX_FIFO_OVFL      | \
+                TGEC_IMASK_TX_ER             | \
+                TGEC_IMASK_RX_FIFO_OVFL      | \
+                TGEC_IMASK_RX_ECC_ER         | \
+                TGEC_IMASK_RX_JAB_FRM        | \
+                TGEC_IMASK_RX_OVRSZ_FRM      | \
+                TGEC_IMASK_RX_RUNT_FRM       | \
+                TGEC_IMASK_RX_FRAG_FRM       | \
+                TGEC_IMASK_RX_LEN_ER         | \
+                TGEC_IMASK_RX_CRC_ER         | \
+                TGEC_IMASK_RX_ALIGN_ER))
+
+/* Hashtable Control Register (HASHTABLE_CTRL) */
+#define TGEC_HASH_MCAST_SHIFT  23
+#define TGEC_HASH_MCAST_EN     0x00000200
+#define TGEC_HASH_ADR_MSK      0x000001ff
+
+/*
+ * 10G memory map
+ */
+struct tgec_regs {
+    uint32_t tgec_id;            /* 0x000 Controller ID */
+    uint32_t scratch;            /* 0x004  */
+    uint32_t command_config;     /* 0x008 Control and configuration */
+    uint32_t mac_addr_0;         /* 0x00c Lower 32 bits of the MAC adr */
+    uint32_t mac_addr_1;         /* 0x010 Upper 16 bits of the MAC adr */
+    uint32_t maxfrm;             /* 0x014 Maximum frame length */
+    uint32_t pause_quant;        /* 0x018 Pause quanta */
+    uint32_t rx_fifo_sections;   /* 0x01c  */
+    uint32_t tx_fifo_sections;   /* 0x020  */
+    uint32_t rx_fifo_almost_f_e; /* 0x024  */
+    uint32_t tx_fifo_almost_f_e; /* 0x028  */
+    uint32_t hashtable_ctrl;     /* 0x02c Hash table control*/
+    uint32_t mdio_cfg_status;    /* 0x030  */
+    uint32_t mdio_command;       /* 0x034  */
+    uint32_t mdio_data;          /* 0x038  */
+    uint32_t mdio_regaddr;       /* 0x03c  */
+    uint32_t status;             /* 0x040  */
+    uint32_t tx_ipg_len;         /* 0x044 Transmitter inter-packet-gap */
+    uint32_t mac_addr_2;         /* 0x048 Lower 32 bits of 2nd MAC adr */
+    uint32_t mac_addr_3;         /* 0x04c Upper 16 bits of 2nd MAC adr */
+    uint32_t rx_fifo_ptr_rd;     /* 0x050  */
+    uint32_t rx_fifo_ptr_wr;     /* 0x054  */
+    uint32_t tx_fifo_ptr_rd;     /* 0x058  */
+    uint32_t tx_fifo_ptr_wr;     /* 0x05c  */
+    uint32_t imask;              /* 0x060 Interrupt mask */
+    uint32_t ievent;             /* 0x064 Interrupt event */
+    uint32_t udp_port;           /* 0x068 Defines a UDP Port number.
+                                          When an UDP/IP frame is received with
+                                          a matching UDP destination port, the
+                                          receive status indication pin
+                                          ff_rx_ts_frm will be asserted. */
+    uint32_t type_1588v2;        /* 0x06c Type field for 1588v2 layer 2 frames.
+                                          IEEE1588 defines the type 0x88f7 for
+                                          1588 frames. */
+    uint32_t reserved070[4];     /* 0x070 */
+    /*10Ge Statistics Counter */
+    uint32_t tfrm_u;            /* 80 aFramesTransmittedOK */
+    uint32_t tfrm_l;            /* 84 aFramesTransmittedOK */
+    uint32_t rfrm_u;            /* 88 aFramesReceivedOK */
+    uint32_t rfrm_l;            /* 8c aFramesReceivedOK */
+    uint32_t rfcs_u;            /* 90 aFrameCheckSequenceErrors */
+    uint32_t rfcs_l;            /* 94 aFrameCheckSequenceErrors */
+    uint32_t raln_u;            /* 98 aAlignmentErrors */
+    uint32_t raln_l;            /* 9c aAlignmentErrors */
+    uint32_t txpf_u;            /* A0 aPAUSEMACCtrlFramesTransmitted */
+    uint32_t txpf_l;            /* A4 aPAUSEMACCtrlFramesTransmitted */
+    uint32_t rxpf_u;            /* A8 aPAUSEMACCtrlFramesReceived */
+    uint32_t rxpf_l;            /* Ac aPAUSEMACCtrlFramesReceived */
+    uint32_t rlong_u;           /* B0 aFrameTooLongErrors */
+    uint32_t rlong_l;           /* B4 aFrameTooLongErrors */
+    uint32_t rflr_u;            /* B8 aInRangeLengthErrors */
+    uint32_t rflr_l;            /* Bc aInRangeLengthErrors */
+    uint32_t tvlan_u;           /* C0 VLANTransmittedOK */
+    uint32_t tvlan_l;           /* C4 VLANTransmittedOK */
+    uint32_t rvlan_u;           /* C8 VLANReceivedOK */
+    uint32_t rvlan_l;           /* Cc VLANReceivedOK */
+    uint32_t toct_u;            /* D0 ifOutOctets */
+    uint32_t toct_l;            /* D4 ifOutOctets */
+    uint32_t roct_u;            /* D8 ifInOctets */
+    uint32_t roct_l;            /* Dc ifInOctets */
+    uint32_t ruca_u;            /* E0 ifInUcastPkts */
+    uint32_t ruca_l;            /* E4 ifInUcastPkts */
+    uint32_t rmca_u;            /* E8 ifInMulticastPkts */
+    uint32_t rmca_l;            /* Ec ifInMulticastPkts */
+    uint32_t rbca_u;            /* F0 ifInBroadcastPkts */
+    uint32_t rbca_l;            /* F4 ifInBroadcastPkts */
+    uint32_t terr_u;            /* F8 ifOutErrors */
+    uint32_t terr_l;            /* Fc ifOutErrors */
+    uint32_t reserved100[2];    /* 100-108*/
+    uint32_t tuca_u;            /* 108 ifOutUcastPkts */
+    uint32_t tuca_l;            /* 10c ifOutUcastPkts */
+    uint32_t tmca_u;            /* 110 ifOutMulticastPkts */
+    uint32_t tmca_l;            /* 114 ifOutMulticastPkts */
+    uint32_t tbca_u;            /* 118 ifOutBroadcastPkts */
+    uint32_t tbca_l;            /* 11c ifOutBroadcastPkts */
+    uint32_t rdrp_u;            /* 120 etherStatsDropEvents */
+    uint32_t rdrp_l;            /* 124 etherStatsDropEvents */
+    uint32_t reoct_u;           /* 128 etherStatsOctets */
+    uint32_t reoct_l;           /* 12c etherStatsOctets */
+    uint32_t rpkt_u;            /* 130 etherStatsPkts */
+    uint32_t rpkt_l;            /* 134 etherStatsPkts */
+    uint32_t trund_u;           /* 138 etherStatsUndersizePkts */
+    uint32_t trund_l;           /* 13c etherStatsUndersizePkts */
+    uint32_t r64_u;             /* 140 etherStatsPkts64Octets */
+    uint32_t r64_l;             /* 144 etherStatsPkts64Octets */
+    uint32_t r127_u;            /* 148 etherStatsPkts65to127Octets */
+    uint32_t r127_l;            /* 14c etherStatsPkts65to127Octets */
+    uint32_t r255_u;            /* 150 etherStatsPkts128to255Octets */
+    uint32_t r255_l;            /* 154 etherStatsPkts128to255Octets */
+    uint32_t r511_u;            /* 158 etherStatsPkts256to511Octets */
+    uint32_t r511_l;            /* 15c etherStatsPkts256to511Octets */
+    uint32_t r1023_u;           /* 160 etherStatsPkts512to1023Octets */
+    uint32_t r1023_l;           /* 164 etherStatsPkts512to1023Octets */
+    uint32_t r1518_u;           /* 168 etherStatsPkts1024to1518Octets */
+    uint32_t r1518_l;           /* 16c etherStatsPkts1024to1518Octets */
+    uint32_t r1519x_u;          /* 170 etherStatsPkts1519toX */
+    uint32_t r1519x_l;          /* 174 etherStatsPkts1519toX */
+    uint32_t trovr_u;           /* 178 etherStatsOversizePkts */
+    uint32_t trovr_l;           /* 17c etherStatsOversizePkts */
+    uint32_t trjbr_u;           /* 180 etherStatsJabbers */
+    uint32_t trjbr_l;           /* 184 etherStatsJabbers */
+    uint32_t trfrg_u;           /* 188 etherStatsFragments */
+    uint32_t trfrg_l;           /* 18C etherStatsFragments */
+    uint32_t rerr_u;            /* 190 ifInErrors */
+    uint32_t rerr_l;            /* 194 ifInErrors */
+};
+
+
+/**
+ * struct tgec_cfg - TGEC configuration
+ *
+ * @rx_error_discard:    Receive Erroneous Frame Discard Enable. When set to 1
+ *            any frame received with an error is discarded in the
+ *            Core and not forwarded to the Client interface.
+ *            When set to 0 (Reset value), erroneous Frames are
+ *            forwarded to the Client interface with ff_rx_err
+ *            asserted.
+ * @pause_ignore:    Ignore Pause Frame Quanta. If set to 1 received pause
+ *            frames are ignored by the MAC. When set to 0
+ *            (Reset value) the transmit process is stopped for the
+ *            amount of time specified in the pause quanta received
+ *            within a pause frame.
+ * @pause_forward_enable:
+ *            Terminate / Forward Pause Frames. If set to 1 pause
+ *            frames are forwarded to the user application. When set
+ *            to 0 (Reset value) pause frames are terminated and
+ *            discarded within the MAC.
+ * @no_length_check_enable:
+ *            Payload Length Check Disable. When set to 0
+ *            (Reset value), the Core checks the frame's payload
+ *            length with the Frame Length/Type field, when set to 1
+ *            the payload length check is disabled.
+ * @cmd_frame_enable:    Enables reception of all command frames. When set to 1
+ *            all Command Frames are accepted, when set to 0
+ *            (Reset Value) only Pause Frames are accepted and all
+ *            other Command Frames are rejected.
+ * @send_idle_enable:    Force Idle Generation. When set to 1, the MAC
+ *            permanently sends XGMII Idle sequences even when faults
+ *            are received.
+ * @wan_mode_enable:    WAN Mode Enable. Sets WAN mode (1) or LAN mode
+ *            (0, default) of operation.
+ * @promiscuous_mode_enable:
+ *            Enables MAC promiscuous operation. When set to 1, all
+ *            frames are received without any MAC address filtering,
+ *            when set to 0 (Reset value) Unicast Frames with a
+ *            destination address not matching the Core MAC Address
+ *            (MAC Address programmed in Registers MAC_ADDR_0 and
+ *            MAC_ADDR_1 or the MAC address programmed in Registers
+ *            MAC_ADDR_2 and MAC_ADDR_3) are rejected.
+ * @tx_addr_ins_enable:    Set Source MAC Address on Transmit. If set to 1 the
+ *            MAC overwrites the source MAC address received from the
+ *            Client Interface with one of the MAC addresses. If set
+ *            to 0 (Reset value), the source MAC address from the
+ *            Client Interface is transmitted unmodified to the line.
+ * @loopback_enable:    PHY Interface Loopback. When set to 1, the signal
+ *            loop_ena is set to '1', when set to 0 (Reset value)
+ *            the signal loop_ena is set to 0.
+ * @lgth_check_nostdr:    The Core interprets the Length/Type field differently
+ *            depending on the value of this Bit
+ * @time_stamp_enable:    This bit selects between enabling and disabling the
+ *            IEEE 1588 functionality. 1: IEEE 1588 is enabled
+ *            0: IEEE 1588 is disabled
+ * @max_frame_length:    Maximum supported received frame length.
+ *            The 10GEC MAC supports reception of any frame size up
+ *            to 16,352 bytes (0x3FE0). Typical settings are
+ *            0x05EE (1,518 bytes) for standard frames.
+ *            Default setting is 0x0600 (1,536 bytes).
+ *            Received frames that exceed this stated maximum
+ *            are truncated.
+ * @pause_quant:    Pause quanta value used with transmitted pause frames.
+ *            Each quanta represents a 512 bit-times.
+ * @tx_ipg_length:    Transmit Inter-Packet-Gap (IPG) value. A 6-bit value:
+ *            Depending on LAN or WAN mode of operation the value has
+ *            the following meaning: - LAN Mode: Number of octets in
+ *            steps of 4. Valid values are 8, 12, 16, ... 100. DIC is
+ *            fully supported (see 10.6.1 page 49) for any setting. A
+ *            default of 12 (reset value) must be set to conform to
+ *            IEEE802.3ae. Warning: When set to 8, PCS layers may not
+ *            be able to perform clock rate compensation. - WAN Mode:
+ *            Stretch factor. Valid values are 4..15. The stretch
+ *            factor is calculated as (value+1)*8. A default of 12
+ *            (reset value) must be set to conform to IEEE 802.3ae
+ *            (i.e. 13*8=104). A larger value shrinks the IPG
+ *            (increasing bandwidth).
+ *
+ * This structure contains basic TGEC configuration and must be passed to
+ * tgec_init() function.  A default set of configuration values can be obtained
+ * by calling tgec_defconfig().
+ */
+struct tgec_cfg {
+    bool        rx_error_discard;
+    bool        pause_ignore;
+    bool        pause_forward_enable;
+    bool        no_length_check_enable;
+    bool        cmd_frame_enable;
+    bool        send_idle_enable;
+    bool        wan_mode_enable;
+    bool        promiscuous_mode_enable;
+    bool        tx_addr_ins_enable;
+    bool        loopback_enable;
+    bool        lgth_check_nostdr;
+    bool        time_stamp_enable;
+    uint16_t    max_frame_length;
+    uint16_t    pause_quant;
+    uint32_t    tx_ipg_length;
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    bool        skip_fman11_workaround;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+};
+
+void tgec_set_mac_address(struct tgec_regs *regs, uint8_t *macaddr);
+
+/**
+ * tgec_reset_stat() - Completely resets all TGEC HW counters
+ * @regs:    Pointer to TGEC register block
+ */
+void tgec_reset_stat(struct tgec_regs *regs);
+
+/**
+ * tgec_get_counter() - Reads TGEC HW counters
+ * @regs:    Pointer to TGEC register block
+ * @reg_name:    Counter name according to the appropriate enum
+ *
+ * Returns:    Required counter value
+ */
+
+uint64_t tgec_get_counter(struct tgec_regs *regs, enum tgec_counters reg_name);
+
+
+void tgec_enable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
+void tgec_disable(struct tgec_regs *regs, bool apply_rx, bool apply_tx);
+void tgec_set_promiscuous(struct tgec_regs *regs, bool val);
+
+/**
+ * tgec_set_hash_table() - Sets the Hashtable Control Register
+ * @regs:    Pointer to TGEC register block
+ * @value:    Value to be written in Hashtable Control Register
+ */
+void tgec_set_hash_table(struct tgec_regs *regs, uint32_t value);
+
+/**
+ * tgec_tx_mac_pause() - Sets the Pause Quanta Register
+ * @regs:    Pointer to TGEC register block
+ * @pause_time:    Pause quanta value used with transmitted pause frames.
+ *        Each quanta represents a 512 bit-times
+ */
+
+void tgec_tx_mac_pause(struct tgec_regs *regs, uint16_t pause_time);
+
+/**
+ * tgec_rx_ignore_mac_pause() - Changes the policy WRT pause frames
+ * @regs:    Pointer to TGEC register block
+ * @en:        Ignore/Respond to pause frame quanta
+ *
+ * Sets the value of PAUSE_IGNORE field in the COMMAND_CONFIG Register
+ * 0 - MAC stops transmit process for the duration specified
+ * in the Pause frame quanta of a received Pause frame.
+ * 1 - MAC ignores received Pause frames.
+ */
+
+void tgec_rx_ignore_mac_pause(struct tgec_regs *regs, bool en);
+
+/**
+ * tgec_enable_1588_time_stamp() - change timestamp functionality
+ * @regs:    Pointer to TGEC register block
+ * @en:        enable/disable timestamp functionality
+ *
+ * Sets the value of EN_TIMESTAMP field in the COMMAND_CONFIG Register
+ * IEEE 1588 timestamp functionality control:
+ * 0 disabled, 1 enabled
+ */
+
+void tgec_enable_1588_time_stamp(struct tgec_regs *regs, bool en);
+
+uint32_t tgec_get_event(struct tgec_regs *regs, uint32_t ev_mask);
+void tgec_ack_event(struct tgec_regs *regs, uint32_t ev_mask);
+uint32_t tgec_get_interrupt_mask(struct tgec_regs *regs);
+
+
+/**
+ * tgec_add_addr_in_paddr() - Sets additional exact match MAC address
+ * @regs:    Pointer to TGEC register block
+ * @addr_ptr:    Pointer to 6-byte array containing the MAC address
+ *
+ * Sets the additional station MAC address
+ */
+
+void tgec_add_addr_in_paddr(struct tgec_regs *regs, uint8_t *addr_ptr);
+void tgec_clear_addr_in_paddr(struct tgec_regs *regs);
+uint32_t tgec_get_revision(struct tgec_regs *regs);
+void tgec_enable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
+void tgec_disable_interrupt(struct tgec_regs *regs, uint32_t ev_mask);
+
+/**
+ * tgec_get_max_frame_len() - Returns the maximum frame length value
+ * @regs:    Pointer to TGEC register block
+ */
+
+uint16_t tgec_get_max_frame_len(struct tgec_regs *regs);
+
+/**
+ * tgec_defconfig() - Initialize the main tgec configuration parameters
+ * @cfg:    Pointer to tgec_cfg structure
+ *
+ * This routine determines the values of the tgec_cfg structure members.
+ * This structure represents the initial parameters which the tgec controller
+ * will be initialized with later when calling the tgec_init function.
+ */
+
+void tgec_defconfig(struct tgec_cfg *cfg);
+
+/**
+ * tgec_init() - Init tgec hardware block
+ * @regs:        Pointer to tgec register block
+ * @cfg:        tgec configuration data
+ * @exceptions_mask:    initial exceptions mask
+ *
+ * This function initializes the tgec controller and applies its
+ * basic configuration.
+ *
+ * Returns: 0 if successful, an error code otherwise.
+ */
+
+int tgec_init(struct tgec_regs *regs, struct tgec_cfg *cfg,
+        uint32_t exception_mask);
+
+
+void tgec_fm_tx_fifo_corruption_errata_10gmac_a007(struct tgec_regs *regs);
+#endif /* __FSL_FMAN_TGEC_H */
+
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
index 41df4c0..0267b78 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
@@ -34,7 +34,7 @@
 /******************************************************************************
  @File          memac.c
 
- @Description   FM 10G MAC ...
+ @Description   FM mEMAC driver
 *//***************************************************************************/
 
 #include "std_ext.h"
@@ -42,7 +42,6 @@
 #include "error_ext.h"
 #include "xx_ext.h"
 #include "endian_ext.h"
-#include "crc_mac_addr_ext.h"
 #include "debug_ext.h"
 
 #include "fm_common.h"
@@ -52,7 +51,6 @@
 /*****************************************************************************/
 /*                      Internal routines                                    */
 /*****************************************************************************/
-
 static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
 {
     uint16_t    tmpReg16;
@@ -61,7 +59,7 @@ static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
     tmpReg16 = PHY_SGMII_IF_MODE_AN | PHY_SGMII_IF_MODE_SGMII;
     MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x14, tmpReg16);
 
-    /* Dev ability according to SGMII specification */
+    /* Device ability according to SGMII specification */
     tmpReg16 = PHY_SGMII_DEV_ABILITY_SGMII;
     MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x4, tmpReg16);
 
@@ -77,12 +75,12 @@ static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
 
 static t_Error CheckInitParameters(t_Memac *p_Memac)
 {
-    e_FmMacType     portType;
+    e_FmMacType portType;
 
     portType = ((ENET_SPEED_FROM_MODE(p_Memac->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G);
 
 #if (FM_MAX_NUM_OF_10G_MACS > 0)
-    if((portType == e_FM_MAC_10G) && (p_Memac->macId >= FM_MAX_NUM_OF_10G_MACS))
+    if ((portType == e_FM_MAC_10G) && (p_Memac->macId >= FM_MAX_NUM_OF_10G_MACS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("10G MAC ID must be less than %d", FM_MAX_NUM_OF_10G_MACS));
 #endif /* (FM_MAX_NUM_OF_10G_MACS > 0) */
 
@@ -94,70 +92,50 @@ static t_Error CheckInitParameters(t_Memac *p_Memac)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized f_Exception"));
     if (!p_Memac->f_Event)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized f_Event"));
-    return E_OK;
-
 #ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
-    if (!p_Memac->p_MemacDriverParam->noLengthCheckEnable)
+    if (!p_Memac->p_MemacDriverParam->no_length_check_enable)
        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
 #endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
-}
 
-/* .............................................................................. */
-
-static void SetDefaultParam(t_MemacDriverParam *p_MemacDriverParam)
-{
-    p_MemacDriverParam->wanModeEnable            = DEFAULT_wanModeEnable;
-    p_MemacDriverParam->promiscuousModeEnable    = DEFAULT_promiscuousEnable;
-    p_MemacDriverParam->pauseForwardEnable       = DEFAULT_pauseForwardEnable;
-    p_MemacDriverParam->pauseIgnore              = DEFAULT_rxIgnorePause;
-    p_MemacDriverParam->txAddrInsEnable          = DEFAULT_txAddrInsEnable;
-
-    p_MemacDriverParam->loopbackEnable           = DEFAULT_loopback;
-    p_MemacDriverParam->cmdFrameEnable           = DEFAULT_cmdFrameEnable;
-    p_MemacDriverParam->rxErrorDiscard           = DEFAULT_rxErrorDiscard;
-    p_MemacDriverParam->phyTxenaOn               = DEFAULT_phyTxenaOn;
-    p_MemacDriverParam->sendIdleEnable           = DEFAULT_sendIdleEnable;
-
-    p_MemacDriverParam->noLengthCheckEnable      = !DEFAULT_lengthCheckEnable;
-
-    p_MemacDriverParam->lgthCheckNostdr          = DEFAULT_lgthCheckNostdr;
-    p_MemacDriverParam->timeStampEnable          = DEFAULT_timeStampEnable;
-    p_MemacDriverParam->padAndCrcEnable          = DEFAULT_padAndCrcEnable;
-    p_MemacDriverParam->rxSfdAny                 = DEFAULT_rxSfdAny;
-    p_MemacDriverParam->rxPblFwd                 = DEFAULT_rxPblFwd;
-    p_MemacDriverParam->txPblFwd                 = DEFAULT_txPblFwd;
-
-    p_MemacDriverParam->txIpgLength              = DEFAULT_txIpgLength;
-    p_MemacDriverParam->maxFrameLength           = DEFAULT_maxFrameLength;
-
-    p_MemacDriverParam->debugMode                = DEFAULT_debugMode;
-
-    p_MemacDriverParam->pauseTime                = DEFAULT_pauseTime;
-    p_MemacDriverParam->resetOnInit              = DEFAULT_resetOnInit;
+    return E_OK;
 }
 
+
 /* ........................................................................... */
 
 static void MemacErrException(t_Handle h_Memac)
 {
-    t_Memac             *p_Memac = (t_Memac *)h_Memac;
-    uint32_t            event;
-    t_MemacMemMap        *p_MemacMemMap = p_Memac->p_MemMap;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
+    uint32_t    event;
 
-    event = GET_UINT32(p_MemacMemMap->ievent);
+    event = GET_UINT32(p_Memac->p_MemMap->ievent);
     /* do not handle MDIO events */
     //event &= ~(IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
 
-    event &= GET_UINT32(p_MemacMemMap->imask);
+    event &= GET_UINT32(p_Memac->p_MemMap->imask);
 
-    WRITE_UINT32(p_MemacMemMap->ievent, event);
+    WRITE_UINT32(p_Memac->p_MemMap->ievent, event);
 
+    if (event & IMASK_RX_FIFO_OVFL)
+        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_RX_FIFO_OVFL);
+    if (event & IMASK_TX_FIFO_UNFL)
+        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_TX_FIFO_UNFL);
+    if (event & IMASK_TX_FIFO_OVFL)
+        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_TX_FIFO_OVFL);
+    if (event & IMASK_TX_ECC_ER)
+        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_1TX_ECC_ER);
+    if (event & IMASK_RX_ECC_ER)
+        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_RX_ECC_ER);
+    if (event & IMASK_REM_FAULT)
+        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_REM_FAULT);
+    if (event & IMASK_LOC_FAULT)
+        p_Memac->f_Exception(p_Memac->h_App, e_FM_MAC_EX_10G_LOC_FAULT);
 }
 
 
 static void FreeInitResources(t_Memac *p_Memac)
 {
-    e_FmMacType             portType;
+    e_FmMacType portType;
 
     portType =
         ((ENET_SPEED_FROM_MODE(p_Memac->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G);
@@ -176,68 +154,21 @@ static void FreeInitResources(t_Memac *p_Memac)
     p_Memac->p_UnicastAddrHash =     NULL;
 }
 
-/* .............................................................................. */
-
-static void HardwareClearAddrInPaddr(t_Memac *p_Memac, uint8_t paddrNum)
-{
-    WRITE_UINT32(p_Memac->p_MemMap->mac_addr[paddrNum].mac_addr_l, 0x0);
-    WRITE_UINT32(p_Memac->p_MemMap->mac_addr[paddrNum].mac_addr_u, 0x0);
-}
-
-/* ........................................................................... */
-
-static void HardwareAddAddrInPaddr(t_Memac *p_Memac, uint64_t *p_Addr, uint8_t paddrNum)
-{
-    uint32_t        tmpReg32 = 0;
-    uint64_t        addr = *p_Addr;
-    t_MemacMemMap   *p_MemacMemMap = p_Memac->p_MemMap;
-
-    tmpReg32 = (uint32_t)(addr>>16);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_MemacMemMap->mac_addr[paddrNum].mac_addr_l, tmpReg32);
-
-    tmpReg32 = (uint32_t)(addr);
-    SwapUint32P(&tmpReg32);
-    tmpReg32 >>= 16;
-    WRITE_UINT32(p_MemacMemMap->mac_addr[paddrNum].mac_addr_u, tmpReg32);
-}
 
 /*****************************************************************************/
-/*                     10G MAC API routines                                  */
+/*                     mEMAC API routines                                    */
 /*****************************************************************************/
 
 /* .............................................................................. */
 
 static t_Error MemacEnable(t_Handle h_Memac,  e_CommMode mode)
 {
-    t_Memac *p_Memac = (t_Memac *)h_Memac;
-    t_MemacMemMap       *p_MemMap ;
-    uint32_t            tmpReg32 = 0;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
-
-    p_MemMap= (t_MemacMemMap*)(p_Memac->p_MemMap);
-
-    tmpReg32 = GET_UINT32(p_MemMap->command_config);
-
-    switch (mode)
-    {
-        case e_COMM_MODE_NONE:
-            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
-            break;
-        case e_COMM_MODE_RX :
-            tmpReg32 |= CMD_CFG_RX_EN ;
-            break;
-        case e_COMM_MODE_TX :
-            tmpReg32 |= CMD_CFG_TX_EN ;
-            break;
-        case e_COMM_MODE_RX_AND_TX:
-            tmpReg32 |= (CMD_CFG_TX_EN | CMD_CFG_RX_EN);
-            break;
-    }
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+    memac_enable(p_Memac->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
 
     return E_OK;
 }
@@ -246,31 +177,12 @@ static t_Error MemacEnable(t_Handle h_Memac,  e_CommMode mode)
 
 static t_Error MemacDisable (t_Handle h_Memac, e_CommMode mode)
 {
-    t_Memac *p_Memac = (t_Memac *)h_Memac;
-    t_MemacMemMap       *p_MemMap ;
-    uint32_t            tmpReg32 = 0;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
-
-    p_MemMap= (t_MemacMemMap*)(p_Memac->p_MemMap);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    tmpReg32 = GET_UINT32(p_MemMap->command_config);
-    switch (mode)
-    {
-        case e_COMM_MODE_RX:
-            tmpReg32 &= ~CMD_CFG_RX_EN;
-            break;
-        case e_COMM_MODE_TX:
-            tmpReg32 &= ~CMD_CFG_TX_EN;
-            break;
-        case e_COMM_MODE_RX_AND_TX:
-            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
-        break;
-        default:
-            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
-    }
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+    memac_disable(p_Memac->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
 
     return E_OK;
 }
@@ -279,24 +191,12 @@ static t_Error MemacDisable (t_Handle h_Memac, e_CommMode mode)
 
 static t_Error MemacSetPromiscuous(t_Handle h_Memac, bool newVal)
 {
-    t_Memac       *p_Memac = (t_Memac *)h_Memac;
-    t_MemacMemMap *p_MemacMemMap;
-    uint32_t     tmpReg32;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
-
-    p_MemacMemMap = p_Memac->p_MemMap;
-
-    tmpReg32 = GET_UINT32(p_MemacMemMap->command_config);
-
-    if (newVal)
-        tmpReg32 |= CMD_CFG_PROMIS_EN;
-    else
-        tmpReg32 &= ~CMD_CFG_PROMIS_EN;
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    WRITE_UINT32(p_MemacMemMap->command_config, tmpReg32);
+    memac_set_promiscuous(p_Memac->p_MemMap, newVal);
 
     return E_OK;
 }
@@ -310,12 +210,12 @@ static t_Error MemacSetPromiscuous(t_Handle h_Memac, bool newVal)
 
 static t_Error MemacConfigLoopback(t_Handle h_Memac, bool newVal)
 {
-    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    p_Memac->p_MemacDriverParam->loopbackEnable = newVal;
+    p_Memac->p_MemacDriverParam->loopback_enable = newVal;
 
     return E_OK;
 }
@@ -324,12 +224,12 @@ static t_Error MemacConfigLoopback(t_Handle h_Memac, bool newVal)
 
 static t_Error MemacConfigWan(t_Handle h_Memac, bool newVal)
 {
-    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    p_Memac->p_MemacDriverParam->wanModeEnable = newVal;
+    p_Memac->p_MemacDriverParam->wan_mode_enable = newVal;
 
     return E_OK;
 }
@@ -338,26 +238,26 @@ static t_Error MemacConfigWan(t_Handle h_Memac, bool newVal)
 
 static t_Error MemacConfigMaxFrameLength(t_Handle h_Memac, uint16_t newVal)
 {
-    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    p_Memac->p_MemacDriverParam->maxFrameLength = newVal;
+    p_Memac->p_MemacDriverParam->max_frame_length = newVal;
 
     return E_OK;
 }
 
 /* .............................................................................. */
 
-static t_Error MemacConfigPadAndCrc(t_Handle h_Memac, bool newVal)
+static t_Error MemacConfigPad(t_Handle h_Memac, bool newVal)
 {
-    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    p_Memac->p_MemacDriverParam->padAndCrcEnable = newVal;
+    p_Memac->p_MemacDriverParam->pad_enable = newVal;
 
     return E_OK;
 }
@@ -366,12 +266,36 @@ static t_Error MemacConfigPadAndCrc(t_Handle h_Memac, bool newVal)
 
 static t_Error MemacConfigLengthCheck(t_Handle h_Memac, bool newVal)
 {
-    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->no_length_check_enable = !newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacConfigException(t_Handle h_Memac, e_FmMacExceptions exception, bool enable)
+{
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
+    uint32_t    bitMask = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    p_Memac->p_MemacDriverParam->noLengthCheckEnable = !newVal;
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if (bitMask)
+    {
+        if (enable)
+            p_Memac->exceptions |= bitMask;
+        else
+            p_Memac->exceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
     return E_OK;
 }
@@ -381,12 +305,12 @@ static t_Error MemacConfigLengthCheck(t_Handle h_Memac, bool newVal)
 
 static t_Error MemacConfigResetOnInit(t_Handle h_Memac, bool enable)
 {
-    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    p_Memac->p_MemacDriverParam->resetOnInit = enable;
+    p_Memac->p_MemacDriverParam->reset_on_init = enable;
 
     return E_OK;
 }
@@ -401,36 +325,12 @@ static t_Error MemacSetTxPauseFrames(t_Handle h_Memac,
                                      uint16_t pauseTime,
                                      uint16_t threshTime)
 {
-    t_Memac          *p_Memac = (t_Memac *)h_Memac;
-    uint32_t         tmpReg32 = 0;
-    t_MemacMemMap    *p_MemMap;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_STATE);
-
-    p_MemMap = (t_MemacMemMap*)(p_Memac->p_MemMap);
 
-    tmpReg32 = GET_UINT32(p_MemMap->command_config);
-    if (priority == FM_MAC_NO_PFC)
-    {
-        tmpReg32 &= ~CMD_CFG_PFC_MODE;
-        priority = 0;
-    }
-    else
-        tmpReg32 |= CMD_CFG_PFC_MODE;
-
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
-
-    tmpReg32 =  GET_UINT32(p_MemMap->pause_quanta[priority/2]);
-    tmpReg32 &= (~0xFFFF<<(16*(priority%2)));
-    tmpReg32 |= ((uint32_t)pauseTime<<(16*(priority%2)));
-    WRITE_UINT32(p_MemMap->pause_quanta[priority/2], tmpReg32);
-
-    tmpReg32 =  GET_UINT32(p_MemMap->pause_thresh[priority/2]);
-    tmpReg32 &= (~0xFFFF<<(16*(priority%2)));
-    tmpReg32 |= ((uint32_t)threshTime<<(16*(priority%2)));
-    WRITE_UINT32(p_MemMap->pause_thresh[priority/2], tmpReg32);
+    memac_set_tx_pause_frames(p_Memac->p_MemMap, priority, pauseTime, threshTime);
 
     return E_OK;
 }
@@ -447,21 +347,12 @@ static t_Error MemacSetTxAutoPauseFrames(t_Handle h_Memac,
 
 static t_Error MemacSetRxIgnorePauseFrames(t_Handle h_Memac, bool en)
 {
-    t_Memac          *p_Memac = (t_Memac *)h_Memac;
-    t_MemacMemMap    *p_MemMap;
-    uint32_t        tmpReg32;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_STATE);
 
-    p_MemMap = (t_MemacMemMap*)(p_Memac->p_MemMap);
-    tmpReg32 = GET_UINT32(p_MemMap->command_config);
-    if (en)
-        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
-    else
-        tmpReg32 &= ~CMD_CFG_PAUSE_IGNORE;
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+    memac_set_rx_ignore_pause_frames(p_Memac->p_MemMap, en);
 
     return E_OK;
 }
@@ -471,83 +362,64 @@ static t_Error MemacSetRxIgnorePauseFrames(t_Handle h_Memac, bool en)
 
 static t_Error MemacGetStatistics(t_Handle h_Memac, t_FmMacStatistics *p_Statistics)
 {
-    t_Memac          *p_Memac = (t_Memac *)h_Memac;
-    t_MemacMemMap    *p_MemacMemMap;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
 
-    p_MemacMemMap = p_Memac->p_MemMap;
-
-    p_Statistics->eStatPkts64           = (((uint64_t)GET_UINT32(p_MemacMemMap->r64_u)<<32)|GET_UINT32(p_MemacMemMap->r64_l));
-    p_Statistics->eStatPkts65to127      = (((uint64_t)GET_UINT32(p_MemacMemMap->r127_u)<<32)|GET_UINT32(p_MemacMemMap->r127_l));
-    p_Statistics->eStatPkts128to255     = (((uint64_t)GET_UINT32(p_MemacMemMap->r255_u)<<32)|GET_UINT32(p_MemacMemMap->r255_l));
-    p_Statistics->eStatPkts256to511     = (((uint64_t)GET_UINT32(p_MemacMemMap->r511_u)<<32)|GET_UINT32(p_MemacMemMap->r511_l));
-    p_Statistics->eStatPkts512to1023    = (((uint64_t)GET_UINT32(p_MemacMemMap->r1023_u)<<32)|GET_UINT32(p_MemacMemMap->r1023_l));
-    p_Statistics->eStatPkts1024to1518   = (((uint64_t)GET_UINT32(p_MemacMemMap->r1518_u)<<32)|GET_UINT32(p_MemacMemMap->r1518_l));
-    p_Statistics->eStatPkts1519to1522   = (((uint64_t)GET_UINT32(p_MemacMemMap->r1519x_u)<<32)|GET_UINT32(p_MemacMemMap->r1519x_l));
+    p_Statistics->eStatPkts64           = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R64);
+    p_Statistics->eStatPkts65to127      = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R127);
+    p_Statistics->eStatPkts128to255     = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R255);
+    p_Statistics->eStatPkts256to511     = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R511);
+    p_Statistics->eStatPkts512to1023    = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R1023);
+    p_Statistics->eStatPkts1024to1518   = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R1518);
+    p_Statistics->eStatPkts1519to1522   = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_R1519X);
 /* */
-    p_Statistics->eStatFragments        = (((uint64_t)GET_UINT32(p_MemacMemMap->rfrg_u)<<32)|GET_UINT32(p_MemacMemMap->rfrg_l));
-    p_Statistics->eStatJabbers          = (((uint64_t)GET_UINT32(p_MemacMemMap->rjbr_u)<<32)|GET_UINT32(p_MemacMemMap->rjbr_l));
+    p_Statistics->eStatFragments        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RFRG);
+    p_Statistics->eStatJabbers          = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RJBR);
 
-    p_Statistics->eStatsDropEvents      = (((uint64_t)GET_UINT32(p_MemacMemMap->rdrp_u)<<32)|GET_UINT32(p_MemacMemMap->rdrp_l));
-    p_Statistics->eStatCRCAlignErrors   = (((uint64_t)GET_UINT32(p_MemacMemMap->raln_u)<<32)|GET_UINT32(p_MemacMemMap->raln_l));
+    p_Statistics->eStatsDropEvents      = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RDRP);
+    p_Statistics->eStatCRCAlignErrors   = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RALN);
 
-    p_Statistics->eStatUndersizePkts    = (((uint64_t)GET_UINT32(p_MemacMemMap->tund_u)<<32)|GET_UINT32(p_MemacMemMap->tund_l));
-    p_Statistics->eStatOversizePkts     = (((uint64_t)GET_UINT32(p_MemacMemMap->rovr_u)<<32)|GET_UINT32(p_MemacMemMap->rovr_l));
+    p_Statistics->eStatUndersizePkts    = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TUND);
+    p_Statistics->eStatOversizePkts     = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_ROVR);
 /* Pause */
-    p_Statistics->reStatPause           = (((uint64_t)GET_UINT32(p_MemacMemMap->rxpf_u)<<32)|GET_UINT32(p_MemacMemMap->rxpf_l));
-    p_Statistics->teStatPause           = (((uint64_t)GET_UINT32(p_MemacMemMap->txpf_u)<<32)|GET_UINT32(p_MemacMemMap->txpf_l));
+    p_Statistics->reStatPause           = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RXPF);
+    p_Statistics->teStatPause           = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TXPF);
 
 /* MIB II */
-    p_Statistics->ifInOctets            = (((uint64_t)GET_UINT32(p_MemacMemMap->roct_u)<<32)|GET_UINT32(p_MemacMemMap->roct_l));
-    p_Statistics->ifInMcastPkts         = (((uint64_t)GET_UINT32(p_MemacMemMap->rmca_u)<<32)|GET_UINT32(p_MemacMemMap->rmca_l));
-    p_Statistics->ifInBcastPkts         = (((uint64_t)GET_UINT32(p_MemacMemMap->rbca_u)<<32)|GET_UINT32(p_MemacMemMap->rbca_l));
-    p_Statistics->ifInPkts              = (((uint64_t)GET_UINT32(p_MemacMemMap->ruca_u)<<32)|GET_UINT32(p_MemacMemMap->ruca_l))
+    p_Statistics->ifInOctets            = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_ROCT);
+    p_Statistics->ifInMcastPkts         = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RMCA);
+    p_Statistics->ifInBcastPkts         = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RBCA);
+    p_Statistics->ifInPkts              = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RUCA)
                                         + p_Statistics->ifInMcastPkts
                                         + p_Statistics->ifInBcastPkts;
     p_Statistics->ifInDiscards          = 0;
-    p_Statistics->ifInErrors            = (((uint64_t)GET_UINT32(p_MemacMemMap->rerr_u)<<32)|GET_UINT32(p_MemacMemMap->rerr_l));
+    p_Statistics->ifInErrors            = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_RERR);
 
-    p_Statistics->ifOutOctets           = (((uint64_t)GET_UINT32(p_MemacMemMap->toct_u)<<32)|GET_UINT32(p_MemacMemMap->toct_l));
-    p_Statistics->ifOutMcastPkts        = (((uint64_t)GET_UINT32(p_MemacMemMap->tmca_u)<<32)|GET_UINT32(p_MemacMemMap->tmca_l));
-    p_Statistics->ifOutBcastPkts        = (((uint64_t)GET_UINT32(p_MemacMemMap->tbca_u)<<32)|GET_UINT32(p_MemacMemMap->tbca_l));
-    p_Statistics->ifOutPkts             = (((uint64_t)GET_UINT32(p_MemacMemMap->tuca_u)<<32)|GET_UINT32(p_MemacMemMap->tuca_l))
+    p_Statistics->ifOutOctets           = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TOCT);
+    p_Statistics->ifOutMcastPkts        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TMCA);
+    p_Statistics->ifOutBcastPkts        = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TBCA);
+    p_Statistics->ifOutPkts             = memac_get_counter(p_Memac->p_MemMap, E_MEMAC_COUNTER_TUCA)
                                             + p_Statistics->ifOutMcastPkts
                                             + p_Statistics->ifOutBcastPkts;
     p_Statistics->ifOutDiscards         = 0;
-    p_Statistics->ifOutErrors           = (((uint64_t)GET_UINT32(p_MemacMemMap->terr_u)<<32)|GET_UINT32(p_MemacMemMap->terr_l));
+    p_Statistics->ifOutErrors           = memac_get_counter(p_Memac->p_MemMap,  E_MEMAC_COUNTER_TERR);
 
     return E_OK;
 }
 
 
 /* .............................................................................. */
-
 static t_Error MemacModifyMacAddress (t_Handle h_Memac, t_EnetAddr *p_EnetAddr)
 {
-    t_Memac              *p_Memac = (t_Memac *)h_Memac;
-    t_MemacMemMap        *p_MemacMemMap;
-    uint32_t            tmpReg32 = 0;
-    uint64_t            addr;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
-
-    p_MemacMemMap = p_Memac->p_MemMap;
-
-    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
-    p_Memac->addr = addr;
-
-    tmpReg32 = (uint32_t)(addr>>16);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_MemacMemMap->mac_addr0.mac_addr_l, tmpReg32);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    tmpReg32 = (uint32_t)(addr);
-    SwapUint32P(&tmpReg32);
-    tmpReg32 >>= 16;
-    WRITE_UINT32(p_MemacMemMap->mac_addr0.mac_addr_u, tmpReg32);
+    memac_hardware_add_addr_in_paddr(p_Memac->p_MemMap, (uint8_t *)(*p_EnetAddr), 0);
 
     return E_OK;
 }
@@ -556,22 +428,12 @@ static t_Error MemacModifyMacAddress (t_Handle h_Memac, t_EnetAddr *p_EnetAddr)
 
 static t_Error MemacResetCounters (t_Handle h_Memac)
 {
-    t_Memac         *p_Memac = (t_Memac *)h_Memac;
-    t_MemacMemMap   *p_MemMap;
-    uint32_t        tmpReg32;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
-
-    p_MemMap = (t_MemacMemMap*)(p_Memac->p_MemMap);
-
-    tmpReg32 = GET_UINT32(p_MemMap->statn_config);
-
-    tmpReg32 |= STATS_CFG_CLR;
-
-    WRITE_UINT32(p_MemMap->statn_config, tmpReg32);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    while (GET_UINT32(p_MemMap->statn_config) & STATS_CFG_CLR) ;
+    memac_reset_counter(p_Memac->p_MemMap);
 
     return E_OK;
 }
@@ -580,13 +442,14 @@ static t_Error MemacResetCounters (t_Handle h_Memac)
 
 static t_Error MemacAddExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
-    t_Memac   *p_Memac = (t_Memac *) h_Memac;
-    uint64_t  ethAddr;
-    uint8_t   paddrNum;
+    t_Memac     *p_Memac = (t_Memac *) h_Memac;
+    uint64_t    ethAddr;
+    uint8_t     paddrNum;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
     if (ethAddr & GROUP_ADDRESS)
         /* Multicast address has no effect in PADDR */
@@ -608,7 +471,7 @@ static t_Error MemacAddExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
             p_Memac->paddr[paddrNum] = ethAddr;
 
             /* put in hardware */
-            HardwareAddAddrInPaddr(p_Memac, &ethAddr, paddrNum);
+            memac_hardware_add_addr_in_paddr(p_Memac->p_MemMap, (uint8_t*)(*p_EthAddr), paddrNum);
             p_Memac->numOfIndAddrInRegs++;
 
             return E_OK;
@@ -622,14 +485,14 @@ static t_Error MemacAddExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
 
 static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
-    t_Memac   *p_Memac = (t_Memac *) h_Memac;
-    uint64_t  ethAddr;
-    uint8_t   paddrNum;
+    t_Memac     *p_Memac = (t_Memac *) h_Memac;
+    uint64_t    ethAddr;
+    uint8_t     paddrNum;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
     /* Find used PADDR containing this address */
     for (paddrNum = 0; paddrNum < MEMAC_NUM_OF_PADDRS; paddrNum++)
@@ -640,7 +503,7 @@ static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
             /* mark this PADDR as not used */
             p_Memac->indAddrRegUsed[paddrNum] = FALSE;
             /* clear in hardware */
-            HardwareClearAddrInPaddr(p_Memac, paddrNum);
+            memac_hardware_clear_addr_in_paddr(p_Memac->p_MemMap, paddrNum);
             p_Memac->numOfIndAddrInRegs--;
 
             return E_OK;
@@ -654,26 +517,23 @@ static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
 
 static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
-    t_Memac          *p_Memac = (t_Memac *)h_Memac;
-    t_MemacMemMap    *p_MemacMemMap;
-    t_EthHashEntry  *p_HashEntry;
-    uint32_t        crc;
-    uint32_t        hash;
-    uint64_t        ethAddr;
+    t_Memac             *p_Memac = (t_Memac *)h_Memac;
+    t_EthHashEntry      *p_HashEntry;
+    uint32_t            crc;
+    uint32_t            hash;
+    uint64_t            ethAddr;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    p_MemacMemMap = p_Memac->p_MemMap;
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
     if (!(ethAddr & GROUP_ADDRESS))
         /* Unicast addresses not supported in hash */
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unicast Address"));
 
     /* CRC calculation */
-    GET_MAC_ADDR_CRC(ethAddr, crc);
-    crc = MIRROR_32(crc);
+    crc = get_mac_addr_crc(ethAddr);
 
     hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_CTRL_ADDR_MASK;        /* Take 6 MSB bits */
 
@@ -683,7 +543,7 @@ static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
     INIT_LIST(&p_HashEntry->node);
 
     LIST_AddToTail(&(p_HashEntry->node), &(p_Memac->p_MulticastAddrHash->p_Lsts[hash]));
-    WRITE_UINT32(p_MemacMemMap->hashtable_ctrl, (hash | HASH_CTRL_MCAST_EN));
+    memac_set_hash_table(p_Memac->p_MemMap, (hash | HASH_CTRL_MCAST_EN));
 
     return E_OK;
 }
@@ -692,39 +552,35 @@ static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 
 static t_Error MemacDelHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
-    t_Memac          *p_Memac = (t_Memac *)h_Memac;
-    t_MemacMemMap    *p_MemacMemMap;
-    t_EthHashEntry  *p_HashEntry = NULL;
-    t_List          *p_Pos;
-    uint32_t        crc;
-    uint32_t        hash;
-    uint64_t        ethAddr;
+    t_Memac             *p_Memac = (t_Memac *)h_Memac;
+    t_EthHashEntry      *p_HashEntry = NULL;
+    t_List              *p_Pos;
+    uint32_t            crc;
+    uint32_t            hash;
+    uint64_t            ethAddr;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
-    p_MemacMemMap = p_Memac->p_MemMap;
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
     /* CRC calculation */
-    GET_MAC_ADDR_CRC(ethAddr, crc);
-    crc = MIRROR_32(crc);
+    crc = get_mac_addr_crc(ethAddr);
 
     hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_CTRL_ADDR_MASK;        /* Take 6 MSB bits */
 
     LIST_FOR_EACH(p_Pos, &(p_Memac->p_MulticastAddrHash->p_Lsts[hash]))
     {
-
         p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
-        if(p_HashEntry->addr == ethAddr)
+        if (p_HashEntry->addr == ethAddr)
         {
             LIST_DelAndInit(&p_HashEntry->node);
             XX_Free(p_HashEntry);
             break;
         }
     }
-    if(LIST_IsEmpty(&p_Memac->p_MulticastAddrHash->p_Lsts[hash]))
-        WRITE_UINT32(p_MemacMemMap->hashtable_ctrl, (hash & ~HASH_CTRL_MCAST_EN));
+    if (LIST_IsEmpty(&p_Memac->p_MulticastAddrHash->p_Lsts[hash]))
+        memac_set_hash_table(p_Memac->p_MemMap, (hash & ~HASH_CTRL_MCAST_EN));
 
     return E_OK;
 }
@@ -733,13 +589,41 @@ static t_Error MemacDelHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 
 /* .............................................................................. */
 
+static t_Error MemacSetException(t_Handle h_Memac, e_FmMacExceptions exception, bool enable)
+{
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
+    uint32_t    bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if (bitMask)
+    {
+        if (enable)
+            p_Memac->exceptions |= bitMask;
+        else
+            p_Memac->exceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    memac_set_exception(p_Memac->p_MemMap, bitMask, enable);
+
+    return E_OK;
+}
+
+
+/* .............................................................................. */
+
 static uint16_t MemacGetMaxFrameLength(t_Handle h_Memac)
 {
-    t_Memac              *p_Memac = (t_Memac *)h_Memac;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_VALUE(p_Memac, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_Memac->p_MemacDriverParam, E_INVALID_STATE, 0);
 
-    return (uint16_t)GET_UINT32(p_Memac->p_MemMap->maxfrm);
+    return memac_get_max_frame_length(p_Memac->p_MemMap);
 }
 
 /* .............................................................................. */
@@ -747,13 +631,61 @@ static uint16_t MemacGetMaxFrameLength(t_Handle h_Memac)
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 static t_Error MemacDumpRegs(t_Handle h_Memac)
 {
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
+    int         i = 0;
+
+    DECLARE_DUMP;
+
+    if (p_Memac->p_MemMap)
+    {
+        DUMP_TITLE(p_Memac->p_MemMap, ("mEMAC %d: ", p_Memac->macId));
+        DUMP_VAR(p_Memac->p_MemMap, command_config);
+        DUMP_VAR(p_Memac->p_MemMap, mac_addr0.mac_addr_l);
+        DUMP_VAR(p_Memac->p_MemMap, mac_addr0.mac_addr_u);
+        DUMP_VAR(p_Memac->p_MemMap, maxfrm);
+        DUMP_VAR(p_Memac->p_MemMap, hashtable_ctrl);
+        DUMP_VAR(p_Memac->p_MemMap, ievent);
+        DUMP_VAR(p_Memac->p_MemMap, tx_ipg_length);
+        DUMP_VAR(p_Memac->p_MemMap, imask);
+
+        DUMP_SUBSTRUCT_ARRAY(i, 4)
+        {
+            DUMP_VAR(p_Memac->p_MemMap, pause_quanta[i]);
+        }
+        DUMP_SUBSTRUCT_ARRAY(i, 4)
+        {
+            DUMP_VAR(p_Memac->p_MemMap, pause_thresh[i]);
+        }
+
+        DUMP_VAR(p_Memac->p_MemMap, rx_pause_status);
+
+        DUMP_SUBSTRUCT_ARRAY(i, MEMAC_NUM_OF_PADDRS)
+        {
+            DUMP_VAR(p_Memac->p_MemMap, mac_addr[i].mac_addr_l);
+            DUMP_VAR(p_Memac->p_MemMap, mac_addr[i].mac_addr_u);
+        }
+
+        DUMP_VAR(p_Memac->p_MemMap, lpwake_timer);
+        DUMP_VAR(p_Memac->p_MemMap, sleep_timer);
+        DUMP_VAR(p_Memac->p_MemMap, statn_config);
+        DUMP_VAR(p_Memac->p_MemMap, if_mode);
+        DUMP_VAR(p_Memac->p_MemMap, if_status);
+        DUMP_VAR(p_Memac->p_MemMap, hg_config);
+        DUMP_VAR(p_Memac->p_MemMap, hg_pause_quanta);
+        DUMP_VAR(p_Memac->p_MemMap, hg_pause_thresh);
+        DUMP_VAR(p_Memac->p_MemMap, hgrx_pause_status);
+        DUMP_VAR(p_Memac->p_MemMap, hg_fifos_status);
+        DUMP_VAR(p_Memac->p_MemMap, rhm);
+        DUMP_VAR(p_Memac->p_MemMap, thm);
+    }
+
     return E_OK;
 }
 #endif /* (defined(DEBUG_ERRORS) && ... */
 
 
 /*****************************************************************************/
-/*                      FM Init & Free API                                   */
+/*                      mEMAC Init & Free API                                   */
 /*****************************************************************************/
 
 /* .............................................................................. */
@@ -761,17 +693,16 @@ static t_Error MemacDumpRegs(t_Handle h_Memac)
 static t_Error MemacInit(t_Handle h_Memac)
 {
     t_Memac                 *p_Memac = (t_Memac *)h_Memac;
-    t_MemacDriverParam      *p_MemacDriverParam;
-    t_MemacMemMap           *p_MemMap;
-    uint64_t                addr;
-    uint32_t                tmpReg32;
+    struct memac_cfg        *p_MemacDriverParam;
+    enum enet_interface     enet_interface;
+    enum enet_speed         enet_speed;
     uint8_t                 i, phyAddr;
+    t_EnetAddr              ethAddr;
     e_FmMacType             portType;
     t_Error                 err;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->fmMacControllerDriver.h_Fm, E_INVALID_HANDLE);
 
     /* not needed! */
@@ -780,81 +711,38 @@ static t_Error MemacInit(t_Handle h_Memac)
     CHECK_INIT_PARAMETERS(p_Memac, CheckInitParameters);
 
     p_MemacDriverParam = p_Memac->p_MemacDriverParam;
-    p_MemMap = p_Memac->p_MemMap;
 
     portType =
         ((ENET_SPEED_FROM_MODE(p_Memac->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G);
 
     /* First, reset the MAC if desired. */
-    if (p_MemacDriverParam->resetOnInit)
-    {
-        tmpReg32 = GET_UINT32(p_MemMap->command_config);
-        WRITE_UINT32(p_MemMap->command_config, tmpReg32 | CMD_CFG_SW_RESET);
-        XX_UDelay(10);
-        do
-        {
-            tmpReg32 = GET_UINT32(p_MemMap->command_config);
-        }
-        while (tmpReg32 & CMD_CFG_SW_RESET);
-    }
+    if (p_MemacDriverParam->reset_on_init)
+        memac_reset(p_Memac->p_MemMap);
 
     /* MAC Address */
-    addr = p_Memac->addr;
-    tmpReg32 = (uint32_t)(addr>>16);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_MemMap->mac_addr0.mac_addr_l, tmpReg32);
-
-    tmpReg32 = (uint32_t)(addr);
-    SwapUint32P(&tmpReg32);
-    tmpReg32 >>= 16;
-    WRITE_UINT32(p_MemMap->mac_addr0.mac_addr_u, tmpReg32);
-
-    /* Config */
-    tmpReg32 = 0;
-    if (p_MemacDriverParam->wanModeEnable)
-        tmpReg32 |= CMD_CFG_WAN_MODE;
-    if (p_MemacDriverParam->promiscuousModeEnable)
-        tmpReg32 |= CMD_CFG_PROMIS_EN;
-    if (p_MemacDriverParam->pauseForwardEnable)
-        tmpReg32 |= CMD_CFG_PAUSE_FWD;
-    if (p_MemacDriverParam->pauseIgnore)
-        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
-    if (p_MemacDriverParam->txAddrInsEnable)
-        tmpReg32 |= CMD_CFG_TX_ADDR_INS;
-    if (p_MemacDriverParam->loopbackEnable)
-        tmpReg32 |= CMD_CFG_LOOPBACK_EN;
-    if (p_MemacDriverParam->cmdFrameEnable)
-        tmpReg32 |= CMD_CFG_CNT_FRM_EN;
-    if (p_MemacDriverParam->sendIdleEnable)
-        tmpReg32 |= CMD_CFG_SEND_IDLE;
-    if (p_MemacDriverParam->noLengthCheckEnable)
-        tmpReg32 |= CMD_CFG_NO_LEN_CHK;
-    if (p_MemacDriverParam->rxSfdAny)
-        tmpReg32 |= CMD_CFG_SFD_ANY;
-    if (p_MemacDriverParam->padAndCrcEnable)
-        tmpReg32 |= CMD_CFG_TX_PAD_EN;
-    tmpReg32 |= CMD_CFG_CRC_FWD;
-
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
-
-    /* Set up interface bits */
-    tmpReg32 = GET_UINT32(p_MemMap->if_mode) & ~IF_MODE_MASK;
-    if (portType == e_FM_MAC_10G)
-        WRITE_UINT32(p_MemMap->if_mode, tmpReg32 | IF_MODE_XGMII);
-    else
-        WRITE_UINT32(p_MemMap->if_mode, tmpReg32 | IF_MODE_GMII);
+    MAKE_ENET_ADDR_FROM_UINT64(p_Memac->addr, ethAddr);
+    memac_hardware_add_addr_in_paddr(p_Memac->p_MemMap, (uint8_t*)ethAddr, 0);
+
+    enet_interface = (enum enet_interface) ENET_INTERFACE_FROM_MODE(p_Memac->enetMode);
+    enet_speed = (enum enet_speed) ENET_SPEED_FROM_MODE(p_Memac->enetMode);
+
+    memac_init(p_Memac->p_MemMap,
+               p_Memac->p_MemacDriverParam,
+               enet_interface,
+               enet_speed,
+               p_Memac->exceptions);
 
     if (ENET_INTERFACE_FROM_MODE(p_Memac->enetMode) == e_ENET_IF_SGMII)
     {
-        /* Configure internal SGMII phy */
+        /* Configure internal SGMII PHY */
         SetupSgmiiInternalPhy(p_Memac, PHY_MDIO_ADDR);
     }
     else if (ENET_INTERFACE_FROM_MODE(p_Memac->enetMode) == e_ENET_IF_QSGMII)
     {
-        /* Configure 4 internal SGMII phys */
+        /* Configure 4 internal SGMII PHYs */
         for (i = 0; i < 4; i++)
         {
-            /* QSGMII phy address occupies 3 upper bits of 5-bit
+            /* QSGMII PHY address occupies 3 upper bits of 5-bit
                phyAddress; the lower 2 bits are used to extend
                register address space and access each one of 4
                ports inside QSGMII. */
@@ -864,15 +752,10 @@ static t_Error MemacInit(t_Handle h_Memac)
     }
 
     /* Max Frame Length */
-    WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_MemacDriverParam->maxFrameLength);
     err = FmSetMacMaxFrame(p_Memac->fmMacControllerDriver.h_Fm,
                            portType,
                            p_Memac->fmMacControllerDriver.macId,
-                           p_MemacDriverParam->maxFrameLength);
-
-    /* Pause Time */
-    WRITE_UINT32(p_MemMap->pause_quanta[0], p_MemacDriverParam->pauseTime);
-    WRITE_UINT32(p_MemMap->pause_thresh[0], 0);
+                           p_MemacDriverParam->max_frame_length);
 
     p_Memac->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
     if (!p_Memac->p_MulticastAddrHash)
@@ -888,10 +771,6 @@ static t_Error MemacInit(t_Handle h_Memac)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
     }
 
-    /* interrupts */
-    WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
-    WRITE_UINT32(p_MemMap->imask, p_Memac->exceptions);
-
     if (portType == e_FM_MAC_10G)
         FmRegisterIntr(p_Memac->fmMacControllerDriver.h_Fm,
                        e_FM_MOD_10G_MAC,
@@ -906,13 +785,6 @@ static t_Error MemacInit(t_Handle h_Memac)
                        e_FM_INTR_TYPE_ERR,
                        MemacErrException,
                        p_Memac);
-    /*if ((p_Memac->mdioIrq != 0) && (p_Memac->mdioIrq != NO_IRQ))
-    {
-        XX_SetIntr(p_Memac->mdioIrq, MemacException, p_Memac);
-        XX_EnableIntr(p_Memac->mdioIrq);
-    }
-    else if (p_Memac->mdioIrq == 0)
-        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, (NO_MSG));*/
 
     XX_Free(p_MemacDriverParam);
     p_Memac->p_MemacDriverParam = NULL;
@@ -924,7 +796,7 @@ static t_Error MemacInit(t_Handle h_Memac)
 
 static t_Error MemacFree(t_Handle h_Memac)
 {
-    t_Memac       *p_Memac = (t_Memac *)h_Memac;
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
 
@@ -935,7 +807,7 @@ static t_Error MemacFree(t_Handle h_Memac)
         XX_Free(p_Memac->p_MemacDriverParam);
         p_Memac->p_MemacDriverParam = NULL;
     }
-    XX_Free (p_Memac);
+    XX_Free(p_Memac);
 
     return E_OK;
 }
@@ -953,16 +825,17 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
     p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = MemacConfigWan;
 
-    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = MemacConfigPadAndCrc;
-    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
+    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = MemacConfigPad;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is detected automatically */
     p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = MemacConfigLengthCheck;
-    p_FmMacControllerDriver->f_FM_MAC_ConfigException           = NULL; //MemacConfigException;
-    p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit         = NULL; //MemacConfigResetOnInit;
 
-    p_FmMacControllerDriver->f_FM_MAC_SetException              = NULL; //MemacSetExcpetion;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigException           = MemacConfigException;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit         = MemacConfigResetOnInit;
 
-    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = NULL; //MemacEnable1588TimeStamp;
-    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = NULL; //MemacDisable1588TimeStamp;
+    p_FmMacControllerDriver->f_FM_MAC_SetException              = MemacSetException;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = NULL; /*MemacEnable1588TimeStamp;*/
+    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = NULL; /*MemacDisable1588TimeStamp;*/
 
     p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = MemacSetPromiscuous;
     p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = NULL;
@@ -997,60 +870,56 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
 
 /*****************************************************************************/
-/*                      Memac Config  Main Entry                             */
+/*                      mEMAC Config Main Entry                             */
 /*****************************************************************************/
 
 /* .............................................................................. */
 
 t_Handle MEMAC_Config(t_FmMacParams *p_FmMacParam)
 {
-    t_Memac                 *p_Memac;
-    t_MemacDriverParam      *p_MemacDriverParam;
-    uintptr_t               baseAddr;
-    uint8_t                 i;
+    t_Memac             *p_Memac;
+    struct memac_cfg    *p_MemacDriverParam;
+    uintptr_t           baseAddr;
 
     SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
 
     baseAddr = p_FmMacParam->baseAddr;
-
     /* Allocate memory for the mEMAC data structure */
-    p_Memac = (t_Memac *) XX_Malloc(sizeof(t_Memac));
+    p_Memac = (t_Memac *)XX_Malloc(sizeof(t_Memac));
     if (!p_Memac)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("mEMAC driver structure"));
         return NULL;
     }
-    /* Zero out *p_Memac */
     memset(p_Memac, 0, sizeof(t_Memac));
     InitFmMacControllerDriver(&p_Memac->fmMacControllerDriver);
 
     /* Allocate memory for the mEMAC driver parameters data structure */
-    p_MemacDriverParam = (t_MemacDriverParam *) XX_Malloc(sizeof(t_MemacDriverParam));
+    p_MemacDriverParam = (struct memac_cfg *) XX_Malloc(sizeof(struct memac_cfg));
     if (!p_MemacDriverParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("mEMAC driver parameters"));
         MemacFree(p_Memac);
         return NULL;
     }
-    /* Zero out */
-    memset(p_MemacDriverParam, 0, sizeof(t_MemacDriverParam));
+    memset(p_MemacDriverParam, 0, sizeof(struct memac_cfg));
 
     /* Plant parameter structure pointer */
     p_Memac->p_MemacDriverParam = p_MemacDriverParam;
 
-    SetDefaultParam(p_MemacDriverParam);
+    memac_defconfig(p_MemacDriverParam);
+
+    p_Memac->addr           = ENET_ADDR_TO_UINT64(p_FmMacParam->addr);
 
-    for (i=0; i < sizeof(p_FmMacParam->addr); i++)
-        p_Memac->addr |= ((uint64_t)p_FmMacParam->addr[i] << ((5-i) * 8));
+    p_Memac->p_MemMap       = (struct memac_regs *)UINT_TO_PTR(baseAddr);
+    p_Memac->p_MiiMemMap    = (t_MemacMiiAccessMemMap *)UINT_TO_PTR(baseAddr + MEMAC_TO_MII_OFFSET);
 
-    p_Memac->p_MemMap        = (t_MemacMemMap *)UINT_TO_PTR(baseAddr);
-    p_Memac->p_MiiMemMap     = (t_MemacMiiAccessMemMap *)UINT_TO_PTR(baseAddr + MEMAC_TO_MII_OFFSET);
-    p_Memac->enetMode        = p_FmMacParam->enetMode;
-    p_Memac->macId           = p_FmMacParam->macId;
-    p_Memac->exceptions      = DEFAULT_exceptions;
-    p_Memac->f_Exception     = p_FmMacParam->f_Exception;
-    p_Memac->f_Event         = p_FmMacParam->f_Event;
-    p_Memac->h_App           = p_FmMacParam->h_App;
+    p_Memac->enetMode       = p_FmMacParam->enetMode;
+    p_Memac->macId          = p_FmMacParam->macId;
+    p_Memac->exceptions     = DEFAULT_exceptions;
+    p_Memac->f_Exception    = p_FmMacParam->f_Exception;
+    p_Memac->f_Event        = p_FmMacParam->f_Event;
+    p_Memac->h_App          = p_FmMacParam->h_App;
 
     return p_Memac;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
index 953f1c0..c5c7da0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
@@ -42,346 +42,42 @@
 #include "std_ext.h"
 #include "error_ext.h"
 #include "list_ext.h"
+
 #include "memac_mii_acc.h"
 #include "fm_mac.h"
-
-
-/* Interrupt Mask Register (IMASK) */
-#define IMASK_PCS                   0x80000000  /* 0 PCS
-                                                 * XGMII - PCS event
-                                                 * GMII - link synchronization event
-                                                 */
-#define IMASK_AN                    0x40000000  /* 1 AN
-                                                 * XGMII - Auto-negotiation event
-                                                 * GMII - Auto-negotiation status
-                                                 */
-#define IMASK_LT                    0x20000000  /* 2 LT
-                                                 * XGMII - Link Training event
-                                                 * GMII - new page received by auto-negotiation function
-                                                 */
-#define IMASK_MGI                   0x00004000  /* 17 Magic packet detection indication event */
-#define IMASK_RX_FIFO_OVFL          0x00001000  /* 19 Receive FIFO overflow event */
-#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 Transmit FIFO underflow event */
-#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 Transmit FIFO overflow event */
-#define IMASK_TX_ECC_ER             0x00000200  /* 22 Transmit frame ECC error event */
-#define IMASK_RX_ECC_ER             0x00000100  /* 23 Receive frame ECC error event */
-#define IMASK_LI_FAULT              0x00000080  /* 24 Link Interruption fault event (XGMII) */
-#define IMASK_RX_EMPTY              0x00000040  /* 25 Receive FIFO empty event */
-#define IMASK_TX_EMPTY              0x00000020  /* 26 Transmit FIFO empty event */
-#define IMASK_RX_LOWP               0x00000010  /* 27 Low Power Idle event */
-#define IMASK_PHY_LOS               0x00000004  /* 29 Phy loss of signal event */
-#define IMASK_REM_FAULT             0x00000002  /* 30 Remote fault event (XGMII) */
-#define IMASK_LOC_FAULT             0x00000001  /* 31 Local fault event (XGMII) */
-
-#define EVENTS_MASK                 ((uint32_t)(IMASK_PCS           |  \
-                                                IMASK_AN            |  \
-                                                IMASK_LT            |  \
-                                                IMASK_MGI           |  \
-                                                IMASK_RX_FIFO_OVFL  |  \
-                                                IMASK_TX_FIFO_UNFL  |  \
-                                                IMASK_TX_FIFO_OVFL  |  \
-                                                IMASK_TX_ECC_ER     |  \
-                                                IMASK_RX_ECC_ER     |  \
-                                                IMASK_LI_FAULT      |  \
-                                                IMASK_RX_EMPTY      |  \
-                                                IMASK_TX_EMPTY      |  \
-                                                IMASK_RX_LOWP       |  \
-                                                IMASK_PHY_LOS       |  \
-                                                IMASK_REM_FAULT     |  \
-                                                IMASK_LOC_FAULT))
-
-#define GET_EXCEPTION_FLAG(bitMask, exception) \
-    (bitMask = EVENTS_MASK)
-
-
-#define DEFAULT_pauseForwardEnable          FALSE
-#define DEFAULT_txAddrInsEnable             FALSE
-#define DEFAULT_cmdFrameEnable              FALSE
-#define DEFAULT_rxErrorDiscard              FALSE
-#define DEFAULT_phyTxenaOn                  FALSE
-#define DEFAULT_sendIdleEnable              FALSE
-#define DEFAULT_lgthCheckNostdr             FALSE
-#define DEFAULT_rxSfdAny                    FALSE
-#define DEFAULT_rxPblFwd                    FALSE
-#define DEFAULT_txPblFwd                    FALSE
-#define DEFAULT_txIpgLength                 12
-#define DEFAULT_debugMode                   FALSE
-#define DEFAULT_timeStampEnable             FALSE
+#include "fsl_fman_memac.h"
+
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)       switch (exception){    \
+    case e_FM_MAC_EX_10G_RX_FIFO_OVFL:                                      \
+        bitMask = IMASK_RX_FIFO_OVFL; break;                                \
+    case e_FM_MAC_EX_10G_TX_FIFO_UNFL:                                      \
+        bitMask = IMASK_TX_FIFO_UNFL; break;                                \
+    case e_FM_MAC_EX_10G_TX_FIFO_OVFL:                                      \
+        bitMask = IMASK_TX_FIFO_OVFL; break;                                \
+    case e_FM_MAC_EX_10G_1TX_ECC_ER:                                        \
+        bitMask = IMASK_TX_ECC_ER; break;                                   \
+    case e_FM_MAC_EX_10G_RX_ECC_ER:                                         \
+        bitMask = IMASK_RX_ECC_ER; break;                                   \
+    case e_FM_MAC_EX_10G_REM_FAULT:                                         \
+        bitMask = IMASK_REM_FAULT; break;                                   \
+    case e_FM_MAC_EX_10G_LOC_FAULT:                                         \
+        bitMask = IMASK_LOC_FAULT; break;                                           \
+    default: bitMask = 0;break;}
 
 #define DEFAULT_exceptions          ((uint32_t)(IMASK_RX_FIFO_OVFL  |  \
                                                 IMASK_TX_FIFO_UNFL  |  \
                                                 IMASK_TX_FIFO_OVFL  |  \
                                                 IMASK_TX_ECC_ER     |  \
                                                 IMASK_RX_ECC_ER     |  \
-                                                IMASK_RX_EMPTY      |  \
-                                                IMASK_TX_EMPTY      |  \
                                                 IMASK_REM_FAULT     |  \
                                                 IMASK_LOC_FAULT))
 
-
-/* Control and Configuration Register (COMMAND_CONFIG) */
-#define CMD_CFG_MG                  0x80000000  /* 00 Magic Packet detection */
-#define CMD_CFG_REG_LOWP_RXETY      0x01000000  /* 07 Rx low power indication */
-#define CMD_CFG_TX_LOWP_ENA         0x00800000  /* 08 Transmit Low Power Idle Enable */
-#define CMD_CFG_SFD_ANY             0x00200000  /* 10 Disable check of SFD (0xd5) character at frame start */
-#define CMD_CFG_PFC_MODE            0x00080000  /* 12 Enable Priority Flow Control (PFC) mode of operation */
-#define CMD_CFG_NO_LEN_CHK          0x00020000  /* 14 Payload length check disable */
-#define CMD_CFG_SEND_IDLE           0x00010000  /* 15 Force idle generation */
-#define CMD_CFG_CNT_FRM_EN          0x00002000  /* 18 Control frame reception enable */
-#define CMD_CFG_SW_RESET            0x00001000  /* 19 Software Reset, self clearing bit */
-#define CMD_CFG_TX_PAD_EN           0x00000800  /* 20 Enable padding of frames in transmit direction */
-#define CMD_CFG_LOOPBACK_EN         0x00000400  /* 21 XGMII/GMII loopback enable */
-#define CMD_CFG_TX_ADDR_INS         0x00000200  /* 22 Transmit source MAC address insertion */
-#define CMD_CFG_PAUSE_IGNORE        0x00000100  /* 23 Ignore Pause frame quanta */
-#define CMD_CFG_PAUSE_FWD           0x00000080  /* 24 Terminate/forward received Pause frames */
-#define CMD_CFG_CRC_FWD             0x00000040  /* 25 Terminate/forward CRC of received frames */
-#define CMD_CFG_PAD_EN              0x00000020  /* 26 Frame padding removal in receive path enable */
-#define CMD_CFG_PROMIS_EN           0x00000010  /* 27 Promiscuous operation enable */
-#define CMD_CFG_WAN_MODE            0x00000008  /* 28 WAN mode enable */
-#define CMD_CFG_RX_EN               0x00000002  /* 30 MAC receive path enable */
-#define CMD_CFG_TX_EN               0x00000001  /* 31 MAC transmit path enable */
-
-/* Interface Mode Register (IF_MODE) */
-#define IF_MODE_MASK                0x00000003  /* 30-31 Mask on interface mode bits */
-#define IF_MODE_XGMII               0x00000000  /* 30-31 XGMII (10G) interface */
-#define IF_MODE_GMII                0x00000002  /* 30-31 GMII (1G) interface */
-
-/* Hash table Control Register (HASHTABLE_CTRL) */
-#define HASH_CTRL_MCAST_SHIFT       26
-#define HASH_CTRL_MCAST_EN          0x00000100  /* 23 Multicast frame reception for the hash entry */
-#define HASH_CTRL_ADDR_MASK         0x0000003F  /* 26-31 Hash table address code */
-
-#define GROUP_ADDRESS               0x0000010000000000LL /* MAC multicast address bit indication */
-#define HASH_TABLE_SIZE             64          /* Hash table size (bits 26-31 in HASHTABLE_CTRL allows for 2^6 entries) */
-
-/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
-#define TX_IPG_LENGTH_MASK          0x0000003F
-
-/* Statistics Configuration Register (STATN_CONFIG) */
-#define STATS_CFG_CLR               0x00000004  /* 29 Reset all counters */
-#define STATS_CFG_CLR_ON_RD         0x00000002  /* 30 Clear on read */
-#define STATS_CFG_SATURATE          0x00000001  /* 31 Saturate at the maximum value */
-
-/* Internal PHY access */
-#define PHY_MDIO_ADDR               0
-/* SGMII registers */
-#define PHY_SGMII_CR_PHY_RESET      0x8000
-#define PHY_SGMII_CR_RESET_AN       0x0200
-#define PHY_SGMII_CR_DEF_VAL        0x1140
-#define PHY_SGMII_DEV_ABILITY_SGMII 0x4001
-#define PHY_SGMII_IF_MODE_AN        0x0002
-#define PHY_SGMII_IF_MODE_SGMII     0x0001
-
-
-#define MEMAC_NUM_OF_PADDRS         7           /* Number of additional exact match MAC address registers */
-typedef _Packed struct t_MacAddr
-{
-    volatile uint32_t   mac_addr_l;         /* Lower 32 bits of 48-bit MAC address */
-    volatile uint32_t   mac_addr_u;         /* Upper 16 bits of 48-bit MAC address */
-} t_MacAddr;
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-
-
-typedef _Packed struct t_MemacMemMap
-{
-    /* General Control and Status */
-    volatile uint32_t   reserved1[2];
-    volatile uint32_t   command_config;     /* 0x008 COMMAND_CONFIG - Control and configuration register */
-    t_MacAddr mac_addr0;                    /* 0x00C-0x010 MAC_ADDR_0...MAC_ADDR_1 */
-    volatile uint32_t   maxfrm;             /* 0x014 MAXFRM - Maximum frame length register */
-    volatile uint32_t   reserved2[5];
-    volatile uint32_t   hashtable_ctrl;     /* 0x02C HASHTABLE_CTRL - Hash table control register */
-    volatile uint32_t   reserved3[4];
-    volatile uint32_t   ievent;             /* 0x040 IEVENT - Interrupt event register */
-    volatile uint32_t   tx_ipg_length;      /* 0x044 TX_IPG_LENGTH - Transmitter inter-packet-gap register */
-    volatile uint32_t   reserved4;
-    volatile uint32_t   imask;              /* 0x04C IMASK - Interrupt mask register */
-    volatile uint32_t   reserved5;
-    volatile uint32_t   pause_quanta[4];    /* 0x054 CL0x_PAUSE_QUANTA - CL0-7 Pause quanta register */
-    volatile uint32_t   pause_thresh[4];    /* 0x064 CL0x_PAUSE_THRESH - CL0-7 Pause quanta threshold register */
-    volatile uint32_t   rx_pause_status;    /* 0x074 RX_PAUSE_STATUS - Receive pause status register */
-    volatile uint32_t   reserved6[2];
-    t_MacAddr mac_addr[MEMAC_NUM_OF_PADDRS]; /* 0x80-0x0B4 MAC_ADDR_2...MAC_ADDR_15 */
-    volatile uint32_t   lpwake_timer;       /* 0x0B8 LPWAKE_TIMER - EEE Low Power Wakeup Timer register */
-    volatile uint32_t   sleep_timer;        /* 0x0BC SLEEP_TIMER - Transmit EEE Low Power Timer register */
-    volatile uint32_t   reserved7[8];
-    volatile uint32_t   statn_config;       /* 0x0E0 STATN_CONFIG - Statistics configuration register */
-    volatile uint32_t   reserved8[7];
-
-    /* Rx Statistics Counter */
-    volatile uint32_t   reoct_l;
-    volatile uint32_t   reoct_u;
-    volatile uint32_t   roct_l;
-    volatile uint32_t   roct_u;
-    volatile uint32_t   raln_l;
-    volatile uint32_t   raln_u;
-    volatile uint32_t   rxpf_l;
-    volatile uint32_t   rxpf_u;
-    volatile uint32_t   rfrm_l;
-    volatile uint32_t   rfrm_u;
-    volatile uint32_t   rfcs_l;
-    volatile uint32_t   rfcs_u;
-    volatile uint32_t   rvlan_l;
-    volatile uint32_t   rvlan_u;
-    volatile uint32_t   rerr_l;
-    volatile uint32_t   rerr_u;
-    volatile uint32_t   ruca_l;
-    volatile uint32_t   ruca_u;
-    volatile uint32_t   rmca_l;
-    volatile uint32_t   rmca_u;
-    volatile uint32_t   rbca_l;
-    volatile uint32_t   rbca_u;
-    volatile uint32_t   rdrp_l;
-    volatile uint32_t   rdrp_u;
-    volatile uint32_t   rpkt_l;
-    volatile uint32_t   rpkt_u;
-    volatile uint32_t   rund_l;
-    volatile uint32_t   rund_u;
-    volatile uint32_t   r64_l;
-    volatile uint32_t   r64_u;
-    volatile uint32_t   r127_l;
-    volatile uint32_t   r127_u;
-    volatile uint32_t   r255_l;
-    volatile uint32_t   r255_u;
-    volatile uint32_t   r511_l;
-    volatile uint32_t   r511_u;
-    volatile uint32_t   r1023_l;
-    volatile uint32_t   r1023_u;
-    volatile uint32_t   r1518_l;
-    volatile uint32_t   r1518_u;
-    volatile uint32_t   r1519x_l;
-    volatile uint32_t   r1519x_u;
-    volatile uint32_t   rovr_l;
-    volatile uint32_t   rovr_u;
-    volatile uint32_t   rjbr_l;
-    volatile uint32_t   rjbr_u;
-    volatile uint32_t   rfrg_l;
-    volatile uint32_t   rfrg_u;
-    volatile uint32_t   rcnp_l;
-    volatile uint32_t   rcnp_u;
-    volatile uint32_t   rdrntp_l;
-    volatile uint32_t   rdrntp_u;
-    volatile uint32_t   reserved9[12];
-
-    /* Tx Statistics Counter */
-    volatile uint32_t   teoct_l;
-    volatile uint32_t   teoct_u;
-    volatile uint32_t   toct_l;
-    volatile uint32_t   toct_u;
-    volatile uint32_t   reserved10[2];
-    volatile uint32_t   txpf_l;
-    volatile uint32_t   txpf_u;
-    volatile uint32_t   tfrm_l;
-    volatile uint32_t   tfrm_u;
-    volatile uint32_t   tfcs_l;
-    volatile uint32_t   tfcs_u;
-    volatile uint32_t   tvlan_l;
-    volatile uint32_t   tvlan_u;
-    volatile uint32_t   terr_l;
-    volatile uint32_t   terr_u;
-    volatile uint32_t   tuca_l;
-    volatile uint32_t   tuca_u;
-    volatile uint32_t   tmca_l;
-    volatile uint32_t   tmca_u;
-    volatile uint32_t   tbca_l;
-    volatile uint32_t   tbca_u;
-    volatile uint32_t   reserved11[2];
-    volatile uint32_t   tpkt_l;
-    volatile uint32_t   tpkt_u;
-    volatile uint32_t   tund_l;
-    volatile uint32_t   tund_u;
-    volatile uint32_t   t64_l;
-    volatile uint32_t   t64_u;
-    volatile uint32_t   t127_l;
-    volatile uint32_t   t127_u;
-    volatile uint32_t   t255_l;
-    volatile uint32_t   t255_u;
-    volatile uint32_t   t511_l;
-    volatile uint32_t   t511_u;
-    volatile uint32_t   t1023_l;
-    volatile uint32_t   t1023_u;
-    volatile uint32_t   t1518_l;
-    volatile uint32_t   t1518_u;
-    volatile uint32_t   t1519x_l;
-    volatile uint32_t   t1519x_u;
-    volatile uint32_t   reserved12[6];
-    volatile uint32_t   tcnp_l;
-    volatile uint32_t   tcnp_u;
-    volatile uint32_t   reserved13[14];
-
-    /* Line Interface Control */
-    volatile uint32_t   if_mode;            /* 0x300 IF_MODE - Interface Mode Control register */
-    volatile uint32_t   if_status;          /* 0x304 IF_STATUS - Interface Status register */
-    volatile uint32_t   reserved14[14];
-
-    /* HiGig/2 */
-    volatile uint32_t   hg_config;          /* 0x340 HG_CONFIG - HiGig/2 Control and configuration register */
-    volatile uint32_t   reserved15[3];
-    volatile uint32_t   hg_pause_quanta;    /* 0x350 HG_PAUSE_QUANTA - HiGig2 Pause quanta register */
-    volatile uint32_t   reserved16[3];
-    volatile uint32_t   hg_pause_thresh;    /* 0x360 HG_PAUSE_THRESH - HiGig2 Pause quanta threshold register */
-    volatile uint32_t   reserved17[3];
-    volatile uint32_t   hgrx_pause_status;  /* 0x370 HGRX_PAUSE_STATUS - HiGig2 Receive pause status register*/
-    volatile uint32_t   hg_fifos_status;    /* 0x374 HG_FIFOS_STATUS - HiGig2 fifos status register */
-    volatile uint32_t   rhm;                /* 0x378 RHM - Receive HiGig2 messages counter register */
-    volatile uint32_t   thm;                /* 0x37C THM - Transmit HiGig2 messages counter register */
-} _PackedType t_MemacMemMap;
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
-
-
-typedef struct t_MemacDriverParam
-{
-    bool resetOnInit;
-    bool wanModeEnable;             /* WAN Mode Enable. Sets WAN mode (1) or LAN mode (0, default) of operation. */
-    bool promiscuousModeEnable;     /* Enables MAC promiscuous operation. When set to '1', all frames are received without any MAC address filtering, when set to '0' (Reset value) Unicast Frames with a destination address not matching the Core MAC Address (MAC Address programmed in Registers MAC_ADDR_0 and MAC_ADDR_1 or the MAC address programmed in Registers MAC_ADDR_2 and MAC_ADDR_3 ) are rejected. */
-    bool pauseForwardEnable;        /* Terminate / Forward Pause Frames. If set to '1' pause frames are forwarded to the user application. When set to '0' (Reset value) pause frames are terminated and discarded within the MAC. */
-    bool pauseIgnore;               /* Ignore Pause Frame Quanta. If set to '1' received pause frames are ignored by the MAC. When set to '0' (Reset value) the transmit process is stopped for the amount of time specified in the pause quanta received within a pause frame. */
-    bool txAddrInsEnable;           /* Set Source MAC Address on Transmit.
-                                        If set to '1' the MAC overwrites the source MAC address received from the Client Interface with one of the MAC addresses (Refer to section 10.4)
-                                        If set to '0' (Reset value), the source MAC address from the Client Interface is transmitted unmodified to the line. */
-    bool loopbackEnable;            /* PHY Interface Loopback. When set to '1', the signal loop_ena is set to '1', when set to '0' (Reset value) the signal loop_ena is set to '0'. */
-    bool cmdFrameEnable;            /* Enables reception of all command frames. When set to '1' all Command Frames are accepted, when set to '0' (Reset Value) only Pause Frames are accepted and all other Command Frames are rejected. */
-    bool rxErrorDiscard;            /* Receive Errored Frame Discard Enable. When set to 1, any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to 0 (Reset value), errored Frames are forwarded to the Client interface with ff_rx_err asserted. */
-    bool phyTxenaOn;                /* PHY Transmit Enable. When set to '1', the signal phy_txena is set to '1', when set to '0' (Reset value) the signal phy_txena is set to '0' */
-    bool sendIdleEnable;            /* Force Idle Generation. When set to '1', the MAC permanently sends XGMII Idle sequences even when faults are received. */
-    bool noLengthCheckEnable;       /* Payload Length Check Disable. When set to 0 (Reset value), the Core checks the frame's payload length with the Frame Length/Type field, when set to 1, the payload length check is disabled. */
-    bool lgthCheckNostdr;           /* The Core interprets the Length/Type field differently depending on the value of this Bit */
-    bool timeStampEnable;           /* This bit selects between enabling and disabling the IEEE 1588 functionality.
-                                        1: IEEE 1588 is enabled.
-                                        0: IEEE 1588 is disabled. */
-    bool padAndCrcEnable;
-    bool rxSfdAny;                  /* Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
-                                        If cleared (default) the frame is accepted only if the 8th byte of the preamble contains the SFD value 0xd5. If another value is received, the frame is discarded and the alignment error counter increments. */
-    bool rxPblFwd;                  /* Receive Preamble Forwarding (custom preamble).
-                                        If set, the first word (ff_rx_sop) of every received frame contains the preamble of the frame. The frame data starts with the 2nd word from the FIFO.
-                                        If the bit is cleared (default) the preamble is removed from the frame before it is written into the receive FIFO. */
-    bool txPblFwd;                  /* Transmit Preamble Forwarding (custom preamble).
-                                        If set, the first word written into the TX FIFO is considered as frame preamble. The MAC will not add a preamble in front of the frame. Note that bits 7:0 of the preamble word will still be overwritten with the XGMII start character upon transmission.
-                                        If cleared (default) the MAC */
-    uint32_t txIpgLength;           /*Transmit Inter-Packet-Gap (IPG) value.
-                                      A 6-bit value: Depending on LAN or WAN mode of operation (see COMMAND_CONFIG, 19.2.1 page 91) the value has the following meaning:
-                                        - LAN Mode: Number of octets in steps of 4. Valid values are 8, 12, 16, ... 100. DIC is fully supported (see 10.6.1 page 49) for any setting. A default of 12 (reset value) must be set to conform to IEEE802.3ae. Warning: When set to 8, PCS layers may not be able to perform clock rate compensation.
-                                        - WAN Mode: Stretch factor. Valid values are 4..15. The stretch factor is calculated as (value+1)*8. A default of 12 (reset value) must be set to conform to IEEE 802.3ae (i.e. 13*8=104). A larger value shrinks the IPG (increasing bandwidth). */
-/*.. */
-    uint16_t    maxFrameLength;
-    bool        debugMode;
-    uint16_t    pauseTime;
-#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    bool        skipFman11Workaround;
-#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
-} t_MemacDriverParam;
-
-typedef struct t_Memac
+typedef struct
 {
     t_FmMacControllerDriver     fmMacControllerDriver;               /**< Upper Mac control block */
     t_Handle                    h_App;                               /**< Handle to the upper layer application  */
-    t_MemacMemMap               *p_MemMap;                           /**< Pointer to MAC memory mapped registers */
+    struct memac_regs           *p_MemMap;                           /**< Pointer to MAC memory mapped registers */
     t_MemacMiiAccessMemMap      *p_MiiMemMap;                        /**< Pointer to MII memory mapped registers */
     uint64_t                    addr;                                /**< MAC address of device */
     e_EnetMode                  enetMode;                            /**< Ethernet physical interface  */
@@ -396,13 +92,15 @@ typedef struct t_Memac
     bool                        debugMode;
     uint8_t                     macId;
     uint32_t                    exceptions;
-    t_MemacDriverParam          *p_MemacDriverParam;
+    struct memac_cfg            *p_MemacDriverParam;
 } t_Memac;
+/* Internal PHY access */
+
+#define PHY_MDIO_ADDR               0
 
 #define MEMAC_TO_MII_OFFSET         0x030       /* Offset from the MEM map to the MDIO mem map */
 
 t_Error MEMAC_MII_WritePhyReg(t_Handle h_Memac, uint8_t phyAddr, uint8_t reg, uint16_t data);
 t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
 
-
 #endif /* __MEMAC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
index a278efd..23f732d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
@@ -43,21 +43,24 @@
 static void WritePhyReg10G(t_Memac   *p_Memac,
                            uint8_t   phyAddr,
                            uint8_t   reg,
-                           uint16_t  data,
-                           uint16_t  clkDiv)
+                           uint16_t  data)
 {
     t_MemacMiiAccessMemMap  *p_MiiAccess;
     uint32_t                tmpReg;
 
     p_MiiAccess = p_Memac->p_MiiMemMap;
 
-    /* Set up MDC frequency and 10G interface */
     tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
-    tmpReg &= ~MDIO_CFG_CLK_DIV_MASK;
-    tmpReg |= (clkDiv << MDIO_CFG_CLK_DIV_SHIFT);
+    /* Leave only MDIO_CLK_DIV bits set on */
+    tmpReg &= MDIO_CFG_CLK_DIV_MASK;
+    /* Set maximum MDIO_HOLD value to allow phy to see
+       change of data signal */
+    tmpReg |= MDIO_CFG_HOLD_MASK;
+    /* Add 10G interface mode */
     tmpReg |= MDIO_CFG_ENC45;
     WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
 
+    /* Wait for command completion */
     while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
         XX_UDelay(1);
 
@@ -83,21 +86,24 @@ static void WritePhyReg10G(t_Memac   *p_Memac,
 static t_Error ReadPhyReg10G(t_Memac   *p_Memac,
                              uint8_t   phyAddr,
                              uint8_t   reg,
-                             uint16_t  *p_Data,
-                             uint16_t  clkDiv)
+                             uint16_t  *p_Data)
 {
     t_MemacMiiAccessMemMap  *p_MiiAccess;
     uint32_t                tmpReg;
 
     p_MiiAccess = p_Memac->p_MiiMemMap;
 
-    /* Set up MDC frequency and 10G interface */
     tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
-    tmpReg &= ~MDIO_CFG_CLK_DIV_MASK;
-    tmpReg |= (clkDiv << MDIO_CFG_CLK_DIV_SHIFT);
+    /* Leave only MDIO_CLK_DIV bits set on */
+    tmpReg &= MDIO_CFG_CLK_DIV_MASK;
+    /* Set maximum MDIO_HOLD value to allow phy to see
+       change of data signal */
+    tmpReg |= MDIO_CFG_HOLD_MASK;
+    /* Add 10G interface mode */
     tmpReg |= MDIO_CFG_ENC45;
     WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
 
+    /* Wait for command completion */
     while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
         XX_UDelay(1);
 
@@ -123,7 +129,7 @@ static t_Error ReadPhyReg10G(t_Memac   *p_Memac,
 
     *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
 
-    /* Check error */
+    /* Check if there was an error */
     tmpReg  = GET_UINT32(p_MiiAccess->mdio_cfg);
 
     if (tmpReg & MDIO_CFG_READ_ERR)
@@ -137,21 +143,19 @@ static t_Error ReadPhyReg10G(t_Memac   *p_Memac,
 static void WritePhyReg1G(t_Memac   *p_Memac,
                           uint8_t   phyAddr,
                           uint8_t   reg,
-                          uint16_t  data,
-                          uint16_t  clkDiv)
+                          uint16_t  data)
 {
     t_MemacMiiAccessMemMap  *p_MiiAccess;
     uint32_t                tmpReg;
 
     p_MiiAccess = p_Memac->p_MiiMemMap;
 
-    /* Set up MDC frequency and 1G interface */
+    /* Leave only MDIO_CLK_DIV and MDIO_HOLD bits set on */
     tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
-    tmpReg &= ~MDIO_CFG_CLK_DIV_MASK;
-    tmpReg |= (clkDiv << MDIO_CFG_CLK_DIV_SHIFT);
-    tmpReg &= ~MDIO_CFG_ENC45;
+    tmpReg &= (MDIO_CFG_CLK_DIV_MASK | MDIO_CFG_HOLD_MASK);
     WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
 
+    /* Wait for command completion */
     while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
         XX_UDelay(1);
 
@@ -160,11 +164,14 @@ static void WritePhyReg1G(t_Memac   *p_Memac,
     tmpReg |= reg;
     WRITE_UINT32(p_MiiAccess->mdio_ctrl, tmpReg);
 
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
+        XX_UDelay(1);
+
     WRITE_UINT32(p_MiiAccess->mdio_data, data);
 
     CORE_MemoryBarrier();
 
-    /* Wait for write transaction end */
+    /* Wait for write transaction to end */
     while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
         XX_UDelay(1);
 }
@@ -172,21 +179,19 @@ static void WritePhyReg1G(t_Memac   *p_Memac,
 static t_Error ReadPhyReg1G(t_Memac   *p_Memac,
                             uint8_t   phyAddr,
                             uint8_t   reg,
-                            uint16_t  *p_Data,
-                            uint16_t  clkDiv)
+                            uint16_t  *p_Data)
 {
     t_MemacMiiAccessMemMap  *p_MiiAccess;
     uint32_t                tmpReg;
 
     p_MiiAccess = p_Memac->p_MiiMemMap;
 
-    /* Set up MDC frequency and 1G interface */
+    /* Leave only MDIO_CLK_DIV and MDIO_HOLD bits set on */
     tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
-    tmpReg &= ~MDIO_CFG_CLK_DIV_MASK;
-    tmpReg |= (clkDiv << MDIO_CFG_CLK_DIV_SHIFT);
-    tmpReg &= ~MDIO_CFG_ENC45;
+    tmpReg &= (MDIO_CFG_CLK_DIV_MASK | MDIO_CFG_HOLD_MASK);
     WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
 
+    /* Wait for command completion */
     while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
         XX_UDelay(1);
 
@@ -196,6 +201,9 @@ static t_Error ReadPhyReg1G(t_Memac   *p_Memac,
     tmpReg |= MDIO_CTL_READ;
     WRITE_UINT32(p_MiiAccess->mdio_ctrl, tmpReg);
 
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
+        XX_UDelay(1);
+
     /* Wait for data to be available */
     while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
         XX_UDelay(1);
@@ -221,7 +229,6 @@ t_Error MEMAC_MII_WritePhyReg(t_Handle  h_Memac,
 {
     t_Memac                 *p_Memac = (t_Memac *)h_Memac;
     bool                    phy10G;
-    uint16_t                clkDiv;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Memac->p_MiiMemMap, E_INVALID_HANDLE);
@@ -230,15 +237,10 @@ t_Error MEMAC_MII_WritePhyReg(t_Handle  h_Memac,
        In 10G interface both phyAddr and devAddr present. */
     phy10G = (phyAddr > 0x1F) ? TRUE : FALSE;
 
-    /* Figure out MDC frequency: the resulting clock should be 2.5 MHz.
-       MDC freq (2.5 MHz) = memacRefClk / ((2*MDIO_CLK_DIV)+1) */
-    clkDiv = DIV_CEIL((p_Memac->fmMacControllerDriver.clkFreq*10), 2*25) - 1;
-    clkDiv = DIV_CEIL(clkDiv, 2);
-
     if (phy10G)
-        WritePhyReg10G(p_Memac, phyAddr, reg, data, clkDiv);
+        WritePhyReg10G(p_Memac, phyAddr, reg, data);
     else
-        WritePhyReg1G(p_Memac, phyAddr, reg, data, clkDiv);
+        WritePhyReg1G(p_Memac, phyAddr, reg, data);
 
     return E_OK;
 }
@@ -251,7 +253,6 @@ t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,
 {
     t_Memac                 *p_Memac = (t_Memac *)h_Memac;
     bool                    phy10G;
-    uint16_t                clkDiv;
     t_Error                 errCode;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
@@ -261,15 +262,10 @@ t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,
        In 10G interface both phyAddr and devAddr present. */
     phy10G = (phyAddr > 0x1F) ? TRUE : FALSE;
 
-    /* Figure out MDC frequency: the resulting clock should be 2.5 MHz.
-       MDC freq (2.5 MHz) = memacRefClk / ((2*MDIO_CLK_DIV)+1) */
-    clkDiv = DIV_CEIL((p_Memac->fmMacControllerDriver.clkFreq*10), 2*25) - 1;
-    clkDiv = DIV_CEIL(clkDiv, 2);
-
     if (phy10G)
-        errCode = ReadPhyReg10G(p_Memac, phyAddr, reg, p_Data, clkDiv);
+        errCode = ReadPhyReg10G(p_Memac, phyAddr, reg, p_Data);
     else
-        errCode = ReadPhyReg1G(p_Memac, phyAddr, reg, p_Data, clkDiv);
+        errCode = ReadPhyReg1G(p_Memac, phyAddr, reg, p_Data);
 
     return errCode;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h
index 3179f71..dab4360 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h
@@ -40,6 +40,7 @@
 /* MII Management Registers */
 #define MDIO_CFG_CLK_DIV_MASK       0x0000ff80
 #define MDIO_CFG_CLK_DIV_SHIFT      7
+#define MDIO_CFG_HOLD_MASK          0x0000001c
 #define MDIO_CFG_ENC45              0x00000040
 #define MDIO_CFG_READ_ERR           0x00000002
 #define MDIO_CFG_BSY                0x00000001
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
index cddb0dd..3697cf8 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.c
@@ -42,10 +42,10 @@
 #include "error_ext.h"
 #include "xx_ext.h"
 #include "endian_ext.h"
-#include "crc_mac_addr_ext.h"
 #include "debug_ext.h"
 
 #include "fm_common.h"
+#include "fsl_fman_tgec.h"
 #include "tgec.h"
 
 
@@ -69,113 +69,73 @@ static t_Error CheckInitParameters(t_Tgec    *p_Tgec)
     if (!p_Tgec->f_Event)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("uninitialized f_Event"));
 #ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
-    if (!p_Tgec->p_TgecDriverParam->noLengthCheckEnable)
+    if (!p_Tgec->p_TgecDriverParam->no_length_check_enable)
        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
 #endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
-
     return E_OK;
 }
 
 /* .............................................................................. */
 
-static void SetDefaultParam(t_TgecDriverParam *p_TgecDriverParam)
-{
-    p_TgecDriverParam->wanModeEnable            = DEFAULT_wanModeEnable;
-    p_TgecDriverParam->promiscuousModeEnable    = DEFAULT_promiscuousEnable;
-    p_TgecDriverParam->pauseForwardEnable       = DEFAULT_pauseForwardEnable;
-    p_TgecDriverParam->pauseIgnore              = DEFAULT_rxIgnorePause;
-    p_TgecDriverParam->txAddrInsEnable          = DEFAULT_txAddrInsEnable;
-
-    p_TgecDriverParam->loopbackEnable           = DEFAULT_loopback;
-    p_TgecDriverParam->cmdFrameEnable           = DEFAULT_cmdFrameEnable;
-    p_TgecDriverParam->rxErrorDiscard           = DEFAULT_rxErrorDiscard;
-    p_TgecDriverParam->phyTxenaOn               = DEFAULT_phyTxenaOn;
-    p_TgecDriverParam->sendIdleEnable           = DEFAULT_sendIdleEnable;
-
-    p_TgecDriverParam->noLengthCheckEnable      = !DEFAULT_lengthCheckEnable;
-
-    p_TgecDriverParam->lgthCheckNostdr          = DEFAULT_lgthCheckNostdr;
-    p_TgecDriverParam->timeStampEnable          = DEFAULT_timeStampEnable;
-    p_TgecDriverParam->rxSfdAny                 = DEFAULT_rxSfdAny;
-    p_TgecDriverParam->rxPblFwd                 = DEFAULT_rxPblFwd;
-    p_TgecDriverParam->txPblFwd                 = DEFAULT_txPblFwd;
-
-    p_TgecDriverParam->txIpgLength              = DEFAULT_txIpgLength;
-    p_TgecDriverParam->maxFrameLength           = DEFAULT_maxFrameLength;
-
-    p_TgecDriverParam->debugMode                = DEFAULT_debugMode;
-
-    p_TgecDriverParam->pauseTime                = DEFAULT_pauseTime;
-
-#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    p_TgecDriverParam->skipFman11Workaround     = DEFAULT_skipFman11Workaround;
-#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
-}
-
-/* ........................................................................... */
-
 static void TgecErrException(t_Handle h_Tgec)
 {
-    t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
     uint32_t            event;
-    t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+    struct tgec_regs    *p_TgecMemMap = p_Tgec->p_MemMap;
 
-    event = GET_UINT32(p_TgecMemMap->ievent);
     /* do not handle MDIO events */
-    event &= ~(IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
-
-    event &= GET_UINT32(p_TgecMemMap->imask);
+    event = tgec_get_event(p_TgecMemMap, ~(TGEC_IMASK_MDIO_SCAN_EVENT | TGEC_IMASK_MDIO_CMD_CMPL));
+    event &= tgec_get_interrupt_mask(p_TgecMemMap);
 
-    WRITE_UINT32(p_TgecMemMap->ievent, event);
+    tgec_ack_event(p_TgecMemMap, event);
 
-    if (event & IMASK_REM_FAULT)
+    if (event & TGEC_IMASK_REM_FAULT)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_REM_FAULT);
-    if (event & IMASK_LOC_FAULT)
+    if (event & TGEC_IMASK_LOC_FAULT)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_LOC_FAULT);
-    if (event & IMASK_1TX_ECC_ER)
+    if (event & TGEC_IMASK_TX_ECC_ER)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_1TX_ECC_ER);
-    if (event & IMASK_TX_FIFO_UNFL)
+    if (event & TGEC_IMASK_TX_FIFO_UNFL)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_UNFL);
-    if (event & IMASK_TX_FIFO_OVFL)
+    if (event & TGEC_IMASK_TX_FIFO_OVFL)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_FIFO_OVFL);
-    if (event & IMASK_TX_ER)
+    if (event & TGEC_IMASK_TX_ER)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_TX_ER);
-    if (event & IMASK_RX_FIFO_OVFL)
+    if (event & TGEC_IMASK_RX_FIFO_OVFL)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FIFO_OVFL);
-    if (event & IMASK_RX_ECC_ER)
+    if (event & TGEC_IMASK_RX_ECC_ER)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ECC_ER);
-    if (event & IMASK_RX_JAB_FRM)
+    if (event & TGEC_IMASK_RX_JAB_FRM)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_JAB_FRM);
-    if (event & IMASK_RX_OVRSZ_FRM)
+    if (event & TGEC_IMASK_RX_OVRSZ_FRM)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_OVRSZ_FRM);
-    if (event & IMASK_RX_RUNT_FRM)
+    if (event & TGEC_IMASK_RX_RUNT_FRM)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_RUNT_FRM);
-    if (event & IMASK_RX_FRAG_FRM)
+    if (event & TGEC_IMASK_RX_FRAG_FRM)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_FRAG_FRM);
-    if (event & IMASK_RX_LEN_ER)
+    if (event & TGEC_IMASK_RX_LEN_ER)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_LEN_ER);
-    if (event & IMASK_RX_CRC_ER)
+    if (event & TGEC_IMASK_RX_CRC_ER)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_CRC_ER);
-    if (event & IMASK_RX_ALIGN_ER)
+    if (event & TGEC_IMASK_RX_ALIGN_ER)
         p_Tgec->f_Exception(p_Tgec->h_App, e_FM_MAC_EX_10G_RX_ALIGN_ER);
 }
 
 static void TgecException(t_Handle h_Tgec)
 {
-     t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
-     uint32_t            event;
-     t_TgecMemMap        *p_TgecMemMap = p_Tgec->p_MemMap;
+     t_Tgec             *p_Tgec = (t_Tgec *)h_Tgec;
+     uint32_t           event;
+     struct tgec_regs   *p_TgecMemMap = p_Tgec->p_MemMap;
 
-     event = GET_UINT32(p_TgecMemMap->ievent);
      /* handle only MDIO events */
-     event &= (IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
-     event &= GET_UINT32(p_TgecMemMap->imask);
+     event = tgec_get_event(p_TgecMemMap, (TGEC_IMASK_MDIO_SCAN_EVENT | TGEC_IMASK_MDIO_CMD_CMPL));
+     event &= tgec_get_interrupt_mask(p_TgecMemMap);
 
-     WRITE_UINT32(p_TgecMemMap->ievent, event);
+     tgec_ack_event(p_TgecMemMap, event);
 
-     if(event & IMASK_MDIO_SCAN_EVENTMDIO)
+     if (event & TGEC_IMASK_MDIO_SCAN_EVENT)
          p_Tgec->f_Event(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO);
-     if(event & IMASK_MDIO_CMD_CMPL)
+     if (event & TGEC_IMASK_MDIO_CMD_CMPL)
          p_Tgec->f_Event(p_Tgec->h_App, e_FM_MAC_EX_10G_MDIO_CMD_CMPL);
 }
 
@@ -187,7 +147,7 @@ static void FreeInitResources(t_Tgec *p_Tgec)
         XX_FreeIntr(p_Tgec->mdioIrq);
     }
     else if (p_Tgec->mdioIrq == 0)
-        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, (NO_MSG));
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
     FmUnregisterIntr(p_Tgec->fmMacControllerDriver.h_Fm, e_FM_MOD_10G_MAC, p_Tgec->macId, e_FM_INTR_TYPE_ERR);
 
     /* release the driver's group hash table */
@@ -199,37 +159,8 @@ static void FreeInitResources(t_Tgec *p_Tgec)
     p_Tgec->p_UnicastAddrHash =     NULL;
 }
 
-/* .............................................................................. */
-
-static void HardwareClearAddrInPaddr(t_Tgec   *p_Tgec, uint8_t paddrNum)
-{
-    if (paddrNum != 0)
-        return;             /* At this time MAC has only one address */
-
-    WRITE_UINT32(p_Tgec->p_MemMap->mac_addr_2, 0x0);
-    WRITE_UINT32(p_Tgec->p_MemMap->mac_addr_3, 0x0);
-}
-
 /* ........................................................................... */
 
-static void HardwareAddAddrInPaddr(t_Tgec   *p_Tgec, uint64_t *p_Addr, uint8_t paddrNum)
-{
-    uint32_t        tmpReg32 = 0;
-    uint64_t        addr = *p_Addr;
-    t_TgecMemMap    *p_TgecMemMap = p_Tgec->p_MemMap;
-
-    if (paddrNum != 0)
-        return;             /* At this time MAC has only one address */
-
-    tmpReg32 = (uint32_t)(addr>>16);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_TgecMemMap->mac_addr_2, tmpReg32);
-
-    tmpReg32 = (uint32_t)(addr);
-    SwapUint32P(&tmpReg32);
-    tmpReg32 >>= 16;
-    WRITE_UINT32(p_TgecMemMap->mac_addr_3, tmpReg32);
-}
 
 /*****************************************************************************/
 /*                     10G MAC API routines                                  */
@@ -239,34 +170,12 @@ static void HardwareAddAddrInPaddr(t_Tgec   *p_Tgec, uint64_t *p_Addr, uint8_t p
 
 static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
 {
-    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap       *p_MemMap ;
-    uint32_t            tmpReg32 = 0;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
-
-    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
-
-    tmpReg32 = GET_UINT32(p_MemMap->command_config);
-
-    switch (mode)
-    {
-        case e_COMM_MODE_NONE:
-            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
-            break;
-        case e_COMM_MODE_RX :
-            tmpReg32 |= CMD_CFG_RX_EN ;
-            break;
-        case e_COMM_MODE_TX :
-            tmpReg32 |= CMD_CFG_TX_EN ;
-            break;
-        case e_COMM_MODE_RX_AND_TX:
-            tmpReg32 |= (CMD_CFG_TX_EN | CMD_CFG_RX_EN);
-            break;
-    }
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+    tgec_enable(p_Tgec->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
 
     return E_OK;
 }
@@ -275,31 +184,12 @@ static t_Error TgecEnable(t_Handle h_Tgec,  e_CommMode mode)
 
 static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
 {
-    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap       *p_MemMap ;
-    uint32_t            tmpReg32 = 0;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
-
-    p_MemMap= (t_TgecMemMap*)(p_Tgec->p_MemMap);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    tmpReg32 = GET_UINT32(p_MemMap->command_config);
-    switch (mode)
-    {
-        case e_COMM_MODE_RX:
-            tmpReg32 &= ~CMD_CFG_RX_EN;
-            break;
-        case e_COMM_MODE_TX:
-            tmpReg32 &= ~CMD_CFG_TX_EN;
-            break;
-        case e_COMM_MODE_RX_AND_TX:
-            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
-        break;
-        default:
-            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
-    }
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+    tgec_disable(p_Tgec->p_MemMap, (mode & e_COMM_MODE_RX), (mode & e_COMM_MODE_TX));
 
     return E_OK;
 }
@@ -309,23 +199,11 @@ static t_Error TgecDisable (t_Handle h_Tgec, e_CommMode mode)
 static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
 {
     t_Tgec       *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap *p_TgecMemMap;
-    uint32_t     tmpReg32;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
-
-    p_TgecMemMap = p_Tgec->p_MemMap;
-
-    tmpReg32 = GET_UINT32(p_TgecMemMap->command_config);
-
-    if (newVal)
-        tmpReg32 |= CMD_CFG_PROMIS_EN;
-    else
-        tmpReg32 &= ~CMD_CFG_PROMIS_EN;
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    WRITE_UINT32(p_TgecMemMap->command_config, tmpReg32);
+    tgec_set_promiscuous(p_Tgec->p_MemMap, newVal);
 
     return E_OK;
 }
@@ -339,12 +217,12 @@ static t_Error TgecSetPromiscuous(t_Handle h_Tgec, bool newVal)
 
 static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
 {
-    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_Tgec->p_TgecDriverParam->loopbackEnable = newVal;
+    p_Tgec->p_TgecDriverParam->loopback_enable = newVal;
 
     return E_OK;
 }
@@ -353,12 +231,12 @@ static t_Error TgecConfigLoopback(t_Handle h_Tgec, bool newVal)
 
 static t_Error TgecConfigWan(t_Handle h_Tgec, bool newVal)
 {
-    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_Tgec->p_TgecDriverParam->wanModeEnable = newVal;
+    p_Tgec->p_TgecDriverParam->wan_mode_enable = newVal;
 
     return E_OK;
 }
@@ -367,12 +245,12 @@ static t_Error TgecConfigWan(t_Handle h_Tgec, bool newVal)
 
 static t_Error TgecConfigMaxFrameLength(t_Handle h_Tgec, uint16_t newVal)
 {
-    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_Tgec->p_TgecDriverParam->maxFrameLength = newVal;
+    p_Tgec->p_TgecDriverParam->max_frame_length = newVal;
 
     return E_OK;
 }
@@ -381,14 +259,14 @@ static t_Error TgecConfigMaxFrameLength(t_Handle h_Tgec, uint16_t newVal)
 
 static t_Error TgecConfigLengthCheck(t_Handle h_Tgec, bool newVal)
 {
-    t_Tgec *p_Tgec = (t_Tgec *)h_Tgec;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     UNUSED(newVal);
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_Tgec->p_TgecDriverParam->noLengthCheckEnable = !newVal;
+    p_Tgec->p_TgecDriverParam->no_length_check_enable = !newVal;
 
     return E_OK;
 }
@@ -404,7 +282,7 @@ static t_Error TgecConfigException(t_Handle h_Tgec, e_FmMacExceptions exception,
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
     GET_EXCEPTION_FLAG(bitMask, exception);
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_Tgec->exceptions |= bitMask;
@@ -427,7 +305,7 @@ static t_Error TgecConfigSkipFman11Workaround(t_Handle h_Tgec)
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_Tgec->p_TgecDriverParam->skipFman11Workaround     = TRUE;
+    p_Tgec->p_TgecDriverParam->skip_fman11_workaround = TRUE;
 
     return E_OK;
 }
@@ -439,114 +317,101 @@ static t_Error TgecConfigSkipFman11Workaround(t_Handle h_Tgec)
 /*****************************************************************************/
 
 /* .............................................................................. */
+/* backward compatibility. will be removed in the future. */
+static t_Error TgecTxMacPause(t_Handle h_Tgec, uint16_t pauseTime)
+{
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
+
+    SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
+
+    tgec_tx_mac_pause(p_Tgec->p_MemMap, pauseTime);
+
+    return E_OK;
+}
 
 static t_Error TgecSetTxPauseFrames(t_Handle h_Tgec,
                                     uint8_t  priority,
                                     uint16_t pauseTime,
                                     uint16_t threshTime)
 {
-    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
-    uint32_t        ptv = 0;
-    t_TgecMemMap    *p_MemMap;
-
-UNUSED(priority);UNUSED(threshTime);
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
-
-    p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
 
-    ptv = (uint32_t)pauseTime;
+    UNUSED(priority); UNUSED(threshTime);
 
-    WRITE_UINT32(p_MemMap->pause_quant, ptv);
+    tgec_tx_mac_pause(p_Tgec->p_MemMap, pauseTime);
 
     return E_OK;
 }
 
 /* .............................................................................. */
 
-static t_Error TgecSetTxAutoPauseFrames(t_Handle h_Tgec,
-                                        uint16_t pauseTime)
-{
-    return TgecSetTxPauseFrames(h_Tgec, 0, pauseTime, 0);
-}
-
-/* .............................................................................. */
-
 static t_Error TgecRxIgnoreMacPause(t_Handle h_Tgec, bool en)
 {
-    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap    *p_MemMap;
-    uint32_t        tmpReg32;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_STATE);
 
-    p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
-    tmpReg32 = GET_UINT32(p_MemMap->command_config);
-    if (en)
-        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
-    else
-        tmpReg32 &= ~CMD_CFG_PAUSE_IGNORE;
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+    tgec_rx_ignore_mac_pause(p_Tgec->p_MemMap, en);
 
     return E_OK;
 }
 
-/* Counters handling */
 /* .............................................................................. */
 
 static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistics)
 {
-    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap    *p_TgecMemMap;
+    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    struct tgec_regs    *p_TgecMemMap;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
 
     p_TgecMemMap = p_Tgec->p_MemMap;
 
-    p_Statistics->eStatPkts64           = (((uint64_t)GET_UINT32(p_TgecMemMap->r64_u)<<32)|GET_UINT32(p_TgecMemMap->r64_l));
-    p_Statistics->eStatPkts65to127      = (((uint64_t)GET_UINT32(p_TgecMemMap->r127_u)<<32)|GET_UINT32(p_TgecMemMap->r127_l));
-    p_Statistics->eStatPkts128to255     = (((uint64_t)GET_UINT32(p_TgecMemMap->r255_u)<<32)|GET_UINT32(p_TgecMemMap->r255_l));
-    p_Statistics->eStatPkts256to511     = (((uint64_t)GET_UINT32(p_TgecMemMap->r511_u)<<32)|GET_UINT32(p_TgecMemMap->r511_l));
-    p_Statistics->eStatPkts512to1023    = (((uint64_t)GET_UINT32(p_TgecMemMap->r1023_u)<<32)|GET_UINT32(p_TgecMemMap->r1023_l));
-    p_Statistics->eStatPkts1024to1518   = (((uint64_t)GET_UINT32(p_TgecMemMap->r1518_u)<<32)|GET_UINT32(p_TgecMemMap->r1518_l));
-    p_Statistics->eStatPkts1519to1522   = (((uint64_t)GET_UINT32(p_TgecMemMap->r1519x_u)<<32)|GET_UINT32(p_TgecMemMap->r1519x_l));
+    p_Statistics->eStatPkts64           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R64);
+    p_Statistics->eStatPkts65to127      = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R127);
+    p_Statistics->eStatPkts128to255     = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R255);
+    p_Statistics->eStatPkts256to511     = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R511);
+    p_Statistics->eStatPkts512to1023    = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R1023);
+    p_Statistics->eStatPkts1024to1518   = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R1518);
+    p_Statistics->eStatPkts1519to1522   = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_R1519X);
 /* */
-    p_Statistics->eStatFragments        = (((uint64_t)GET_UINT32(p_TgecMemMap->trfrg_u)<<32)|GET_UINT32(p_TgecMemMap->trfrg_l));
-    p_Statistics->eStatJabbers          = (((uint64_t)GET_UINT32(p_TgecMemMap->trjbr_u)<<32)|GET_UINT32(p_TgecMemMap->trjbr_l));
+    p_Statistics->eStatFragments        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TRFRG);
+    p_Statistics->eStatJabbers          = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TRJBR);
 
-    p_Statistics->eStatsDropEvents      = (((uint64_t)GET_UINT32(p_TgecMemMap->rdrp_u)<<32)|GET_UINT32(p_TgecMemMap->rdrp_l));
-    p_Statistics->eStatCRCAlignErrors   = (((uint64_t)GET_UINT32(p_TgecMemMap->raln_u)<<32)|GET_UINT32(p_TgecMemMap->raln_l));
+    p_Statistics->eStatsDropEvents      = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RDRP);
+    p_Statistics->eStatCRCAlignErrors   = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RALN);
 
-    p_Statistics->eStatUndersizePkts    = (((uint64_t)GET_UINT32(p_TgecMemMap->trund_u)<<32)|GET_UINT32(p_TgecMemMap->trund_l));
-    p_Statistics->eStatOversizePkts     = (((uint64_t)GET_UINT32(p_TgecMemMap->trovr_u)<<32)|GET_UINT32(p_TgecMemMap->trovr_l));
+    p_Statistics->eStatUndersizePkts    = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TRUND);
+    p_Statistics->eStatOversizePkts     = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TROVR);
 /* Pause */
-    p_Statistics->reStatPause           = (((uint64_t)GET_UINT32(p_TgecMemMap->rxpf_u)<<32)|GET_UINT32(p_TgecMemMap->rxpf_l));
-    p_Statistics->teStatPause           = (((uint64_t)GET_UINT32(p_TgecMemMap->txpf_u)<<32)|GET_UINT32(p_TgecMemMap->txpf_l));
+    p_Statistics->reStatPause           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RXPF);
+    p_Statistics->teStatPause           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TXPF);
 
 /* MIB II */
-    p_Statistics->ifInOctets            = (((uint64_t)GET_UINT32(p_TgecMemMap->roct_u)<<32)|GET_UINT32(p_TgecMemMap->roct_l));
-    p_Statistics->ifInMcastPkts         = (((uint64_t)GET_UINT32(p_TgecMemMap->rmca_u)<<32)|GET_UINT32(p_TgecMemMap->rmca_l));
-    p_Statistics->ifInBcastPkts         = (((uint64_t)GET_UINT32(p_TgecMemMap->rbca_u)<<32)|GET_UINT32(p_TgecMemMap->rbca_l));
-    p_Statistics->ifInPkts              = (((uint64_t)GET_UINT32(p_TgecMemMap->ruca_u)<<32)|GET_UINT32(p_TgecMemMap->ruca_l))
+    p_Statistics->ifInOctets            = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_ROCT);
+    p_Statistics->ifInMcastPkts         = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RMCA);
+    p_Statistics->ifInBcastPkts         = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RBCA);
+    p_Statistics->ifInPkts              = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RUCA)
                                         + p_Statistics->ifInMcastPkts
                                         + p_Statistics->ifInBcastPkts;
     p_Statistics->ifInDiscards          = 0;
-    p_Statistics->ifInErrors            = (((uint64_t)GET_UINT32(p_TgecMemMap->rerr_u)<<32)|GET_UINT32(p_TgecMemMap->rerr_l));
+    p_Statistics->ifInErrors            = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_RERR);
 
-    p_Statistics->ifOutOctets           = (((uint64_t)GET_UINT32(p_TgecMemMap->toct_u)<<32)|GET_UINT32(p_TgecMemMap->toct_l));
-    p_Statistics->ifOutMcastPkts        = (((uint64_t)GET_UINT32(p_TgecMemMap->tmca_u)<<32)|GET_UINT32(p_TgecMemMap->tmca_l));
-    p_Statistics->ifOutBcastPkts        = (((uint64_t)GET_UINT32(p_TgecMemMap->tbca_u)<<32)|GET_UINT32(p_TgecMemMap->tbca_l));
-    p_Statistics->ifOutPkts             = (((uint64_t)GET_UINT32(p_TgecMemMap->tuca_u)<<32)|GET_UINT32(p_TgecMemMap->tuca_l))
+    p_Statistics->ifOutOctets           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TOCT);
+    p_Statistics->ifOutMcastPkts        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TMCA);
+    p_Statistics->ifOutBcastPkts        = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TBCA);
+    p_Statistics->ifOutPkts             = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TUCA)
                                             + p_Statistics->ifOutMcastPkts
                                             + p_Statistics->ifOutBcastPkts;
     p_Statistics->ifOutDiscards         = 0;
-    p_Statistics->ifOutErrors           = (((uint64_t)GET_UINT32(p_TgecMemMap->terr_u)<<32)|GET_UINT32(p_TgecMemMap->terr_l));
+    p_Statistics->ifOutErrors           = tgec_get_counter(p_TgecMemMap, E_TGEC_COUNTER_TERR);
 
     return E_OK;
 }
@@ -555,16 +420,12 @@ static t_Error TgecGetStatistics(t_Handle h_Tgec, t_FmMacStatistics *p_Statistic
 
 static t_Error TgecEnable1588TimeStamp(t_Handle h_Tgec)
 {
-    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap        *p_TgecMemMap;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_TgecMemMap = p_Tgec->p_MemMap;
-    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
-
-    WRITE_UINT32(p_TgecMemMap->command_config, GET_UINT32(p_TgecMemMap->command_config) | CMD_CFG_EN_TIMESTAMP);
+    tgec_enable_1588_time_stamp(p_Tgec->p_MemMap, 1);
 
     return E_OK;
 }
@@ -573,16 +434,12 @@ static t_Error TgecEnable1588TimeStamp(t_Handle h_Tgec)
 
 static t_Error TgecDisable1588TimeStamp(t_Handle h_Tgec)
 {
-    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap        *p_TgecMemMap;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_TgecMemMap = p_Tgec->p_MemMap;
-    SANITY_CHECK_RETURN_ERROR(p_TgecMemMap, E_INVALID_HANDLE);
-
-    WRITE_UINT32(p_TgecMemMap->command_config, GET_UINT32(p_TgecMemMap->command_config) & ~CMD_CFG_EN_TIMESTAMP);
+    tgec_enable_1588_time_stamp(p_Tgec->p_MemMap, 0);
 
     return E_OK;
 }
@@ -591,30 +448,13 @@ static t_Error TgecDisable1588TimeStamp(t_Handle h_Tgec)
 
 static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
 {
-    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap        *p_TgecMemMap;
-    uint32_t            tmpReg32 = 0;
-    uint64_t            addr;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
-
-    p_TgecMemMap = p_Tgec->p_MemMap;
-
-    /*  Initialize MAC Station Address registers (1 & 2)    */
-    /*  Station address have to be swapped (big endian to little endian */
-
-    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
-    p_Tgec->addr = addr;
-
-    tmpReg32 = (uint32_t)(addr>>16);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_TgecMemMap->mac_addr_0, tmpReg32);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    tmpReg32 = (uint32_t)(addr);
-    SwapUint32P(&tmpReg32);
-    tmpReg32 >>= 16;
-    WRITE_UINT32(p_TgecMemMap->mac_addr_1, tmpReg32);
+    p_Tgec->addr = ENET_ADDR_TO_UINT64(*p_EnetAddr);
+    tgec_set_mac_address(p_Tgec->p_MemMap, (uint8_t *)(*p_EnetAddr));
 
     return E_OK;
 }
@@ -623,22 +463,12 @@ static t_Error TgecModifyMacAddress (t_Handle h_Tgec, t_EnetAddr *p_EnetAddr)
 
 static t_Error TgecResetCounters (t_Handle h_Tgec)
 {
-    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap    *p_MemMap;
-    uint32_t        tmpReg32;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
-
-    p_MemMap = (t_TgecMemMap*)(p_Tgec->p_MemMap);
-
-    tmpReg32 = GET_UINT32(p_MemMap->command_config);
-
-    tmpReg32 |= CMD_CFG_STAT_CLR;
-
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    while (GET_UINT32(p_MemMap->command_config) & CMD_CFG_STAT_CLR) ;
+    tgec_reset_stat(p_Tgec->p_MemMap);
 
     return E_OK;
 }
@@ -647,13 +477,14 @@ static t_Error TgecResetCounters (t_Handle h_Tgec)
 
 static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 {
-    t_Tgec   *p_Tgec = (t_Tgec *) h_Tgec;
-    uint64_t  ethAddr;
-    uint8_t   paddrNum;
+    t_Tgec      *p_Tgec = (t_Tgec *) h_Tgec;
+    uint64_t    ethAddr;
+    uint8_t     paddrNum;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
     if (ethAddr & GROUP_ADDRESS)
         /* Multicast address has no effect in PADDR */
@@ -667,6 +498,7 @@ static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
 
     /* Find first unused PADDR */
     for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
+    {
         if (!(p_Tgec->indAddrRegUsed[paddrNum]))
         {
             /* mark this PADDR as used */
@@ -675,11 +507,12 @@ static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
             p_Tgec->paddr[paddrNum] = ethAddr;
 
             /* put in hardware */
-            HardwareAddAddrInPaddr(p_Tgec, &ethAddr, paddrNum);
+            tgec_add_addr_in_paddr(p_Tgec->p_MemMap, (uint8_t*)(*p_EthAddr)/* , paddrNum */);
             p_Tgec->numOfIndAddrInRegs++;
 
             return E_OK;
         }
+    }
 
     /* No free PADDR */
     RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
@@ -689,14 +522,14 @@ static t_Error TgecAddExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
 
 static t_Error TgecDelExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 {
-    t_Tgec   *p_Tgec = (t_Tgec *) h_Tgec;
-    uint64_t  ethAddr;
-    uint8_t   paddrNum;
+    t_Tgec      *p_Tgec = (t_Tgec *) h_Tgec;
+    uint64_t    ethAddr;
+    uint8_t     paddrNum;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
     /* Find used PADDR containing this address */
     for (paddrNum = 0; paddrNum < TGEC_NUM_OF_PADDRS; paddrNum++)
@@ -707,7 +540,7 @@ static t_Error TgecDelExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
             /* mark this PADDR as not used */
             p_Tgec->indAddrRegUsed[paddrNum] = FALSE;
             /* clear in hardware */
-            HardwareClearAddrInPaddr(p_Tgec, paddrNum);
+            tgec_clear_addr_in_paddr(p_Tgec->p_MemMap /*, paddrNum */);
             p_Tgec->numOfIndAddrInRegs--;
 
             return E_OK;
@@ -722,27 +555,24 @@ static t_Error TgecDelExactMatchMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAdd
 static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 {
     t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap    *p_TgecMemMap;
     t_EthHashEntry  *p_HashEntry;
     uint32_t        crc;
     uint32_t        hash;
     uint64_t        ethAddr;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_TgecMemMap = p_Tgec->p_MemMap;
-    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+    ethAddr = ENET_ADDR_TO_UINT64(*p_EthAddr);
 
     if (!(ethAddr & GROUP_ADDRESS))
         /* Unicast addresses not supported in hash */
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unicast Address"));
 
     /* CRC calculation */
-    GET_MAC_ADDR_CRC(ethAddr, crc);
-    crc = MIRROR_32(crc);
+    crc = get_mac_addr_crc(ethAddr);
 
-    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_ADDR_MASK;        /* Take 9 MSB bits */
+    hash = (crc >> TGEC_HASH_MCAST_SHIFT) & TGEC_HASH_ADR_MSK;        /* Take 9 MSB bits */
 
     /* Create element to be added to the driver hash table */
     p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
@@ -750,7 +580,7 @@ static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
     INIT_LIST(&p_HashEntry->node);
 
     LIST_AddToTail(&(p_HashEntry->node), &(p_Tgec->p_MulticastAddrHash->p_Lsts[hash]));
-    WRITE_UINT32(p_TgecMemMap->hashtable_ctrl, (hash | HASH_CTRL_MCAST_EN));
+    tgec_set_hash_table(p_Tgec->p_MemMap, (hash | TGEC_HASH_MCAST_EN));
 
     return E_OK;
 }
@@ -759,39 +589,35 @@ static t_Error TgecAddHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 
 static t_Error TgecDelHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 {
-    t_Tgec          *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap    *p_TgecMemMap;
-    t_EthHashEntry  *p_HashEntry = NULL;
-    t_List          *p_Pos;
-    uint32_t        crc;
-    uint32_t        hash;
-    uint64_t        ethAddr;
+    t_Tgec           *p_Tgec = (t_Tgec *)h_Tgec;
+    t_EthHashEntry   *p_HashEntry = NULL;
+    t_List           *p_Pos;
+    uint32_t         crc;
+    uint32_t         hash;
+    uint64_t         ethAddr;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_TgecMemMap = p_Tgec->p_MemMap;
     ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
 
     /* CRC calculation */
-    GET_MAC_ADDR_CRC(ethAddr, crc);
-    crc = MIRROR_32(crc);
+    crc = get_mac_addr_crc(ethAddr);
 
-    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_ADDR_MASK;        /* Take 9 MSB bits */
+    hash = (crc >> TGEC_HASH_MCAST_SHIFT) & TGEC_HASH_ADR_MSK;        /* Take 9 MSB bits */
 
     LIST_FOR_EACH(p_Pos, &(p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
     {
-
         p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
-        if(p_HashEntry->addr == ethAddr)
+        if (p_HashEntry->addr == ethAddr)
         {
             LIST_DelAndInit(&p_HashEntry->node);
             XX_Free(p_HashEntry);
             break;
         }
     }
-    if(LIST_IsEmpty(&p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
-        WRITE_UINT32(p_TgecMemMap->hashtable_ctrl, (hash & ~HASH_CTRL_MCAST_EN));
+    if (LIST_IsEmpty(&p_Tgec->p_MulticastAddrHash->p_Lsts[hash]))
+        tgec_set_hash_table(p_Tgec->p_MemMap, (hash & ~TGEC_HASH_MCAST_EN));
 
     return E_OK;
 }
@@ -800,10 +626,10 @@ static t_Error TgecDelHashMacAddress(t_Handle h_Tgec, t_EnetAddr *p_EthAddr)
 
 static t_Error TgecGetId(t_Handle h_Tgec, uint32_t *macId)
 {
-    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
     UNUSED(p_Tgec);
     UNUSED(macId);
@@ -814,15 +640,12 @@ static t_Error TgecGetId(t_Handle h_Tgec, uint32_t *macId)
 
 static t_Error TgecGetVersion(t_Handle h_Tgec, uint32_t *macVersion)
 {
-    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecMemMap        *p_TgecMemMap;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
-    p_TgecMemMap = p_Tgec->p_MemMap;
-    *macVersion = GET_UINT32(p_TgecMemMap->tgec_id);
+    *macVersion = tgec_get_revision(p_Tgec->p_MemMap);
 
     return E_OK;
 }
@@ -831,18 +654,14 @@ static t_Error TgecGetVersion(t_Handle h_Tgec, uint32_t *macVersion)
 
 static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bool enable)
 {
-    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
-    uint32_t            bitMask = 0, tmpReg;
-    t_TgecMemMap        *p_TgecMemMap;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
+    uint32_t    bitMask = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_NULL_POINTER);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_NULL_POINTER);
-
-    p_TgecMemMap = p_Tgec->p_MemMap;
+    SANITY_CHECK_RETURN_ERROR(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
 
     GET_EXCEPTION_FLAG(bitMask, exception);
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_Tgec->exceptions |= bitMask;
@@ -852,12 +671,11 @@ static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bo
     else
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
-    tmpReg = GET_UINT32(p_TgecMemMap->imask);
-    if(enable)
-        tmpReg |= bitMask;
+    if (enable)
+        tgec_enable_interrupt(p_Tgec->p_MemMap, bitMask);
     else
-        tmpReg &= ~bitMask;
-    WRITE_UINT32(p_TgecMemMap->imask, tmpReg);
+        tgec_disable_interrupt(p_Tgec->p_MemMap, bitMask);
+
     return E_OK;
 }
 
@@ -865,11 +683,12 @@ static t_Error TgecSetExcpetion(t_Handle h_Tgec, e_FmMacExceptions exception, bo
 
 static uint16_t TgecGetMaxFrameLength(t_Handle h_Tgec)
 {
-    t_Tgec              *p_Tgec = (t_Tgec *)h_Tgec;
+    t_Tgec      *p_Tgec = (t_Tgec *)h_Tgec;
 
     SANITY_CHECK_RETURN_VALUE(p_Tgec, E_INVALID_HANDLE, 0);
+    SANITY_CHECK_RETURN_VALUE(!p_Tgec->p_TgecDriverParam, E_INVALID_STATE, 0);
 
-    return (uint16_t)GET_UINT32(p_Tgec->p_MemMap->maxfrm);
+    return tgec_get_max_frame_len(p_Tgec->p_MemMap);
 }
 
 /* .............................................................................. */
@@ -883,10 +702,12 @@ static t_Error TgecTxEccWorkaround(t_Tgec *p_Tgec)
     XX_Print("Applying 10G TX ECC workaround (10GMAC-A004) ...");
 #endif /* (DEBUG_ERRORS > 0) */
     /* enable and set promiscuous */
-    WRITE_UINT32(p_Tgec->p_MemMap->command_config, CMD_CFG_PROMIS_EN | CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+    tgec_enable(p_Tgec->p_MemMap, TRUE, TRUE);
+    tgec_set_promiscuous(p_Tgec->p_MemMap, TRUE);
     err = Fm10GTxEccWorkaround(p_Tgec->fmMacControllerDriver.h_Fm, p_Tgec->macId);
     /* disable */
-    WRITE_UINT32(p_Tgec->p_MemMap->command_config, 0);
+    tgec_set_promiscuous(p_Tgec->p_MemMap, FALSE);
+    tgec_enable(p_Tgec->p_MemMap, FALSE, FALSE);
 #if defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)
     if (err)
         XX_Print("FAILED!\n");
@@ -937,8 +758,6 @@ static t_Error TgecDumpRegs(t_Handle h_Tgec)
         DUMP_VAR(p_Tgec->p_MemMap, tx_fifo_ptr_wr);
         DUMP_VAR(p_Tgec->p_MemMap, imask);
         DUMP_VAR(p_Tgec->p_MemMap, ievent);
-        DUMP_VAR(p_Tgec->p_MemMap, udp_port);
-        DUMP_VAR(p_Tgec->p_MemMap, type_1588v2);
     }
 
     return E_OK;
@@ -955,25 +774,21 @@ static t_Error TgecDumpRegs(t_Handle h_Tgec)
 static t_Error TgecInit(t_Handle h_Tgec)
 {
     t_Tgec                  *p_Tgec = (t_Tgec *)h_Tgec;
-    t_TgecDriverParam       *p_TgecDriverParam;
-    t_TgecMemMap            *p_MemMap;
-    uint64_t                addr;
-    uint32_t                tmpReg32;
+    struct tgec_cfg         *p_TgecDriverParam;
+    t_EnetAddr              ethAddr;
     t_Error                 err;
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->p_TgecDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Tgec->p_MemMap, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Tgec->fmMacControllerDriver.h_Fm, E_INVALID_HANDLE);
 
     FM_GetRevision(p_Tgec->fmMacControllerDriver.h_Fm, &p_Tgec->fmMacControllerDriver.fmRevInfo);
-
     CHECK_INIT_PARAMETERS(p_Tgec, CheckInitParameters);
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
     if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev <= 6 /*fixed for rev3 */)
     {
-        if (!p_Tgec->p_TgecDriverParam->skipFman11Workaround &&
+        if (!p_Tgec->p_TgecDriverParam->skip_fman11_workaround &&
             ((err = TgecTxEccWorkaround(p_Tgec)) != E_OK))
         {
             FreeInitResources(p_Tgec);
@@ -983,96 +798,55 @@ static t_Error TgecInit(t_Handle h_Tgec)
 #endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
 
     p_TgecDriverParam = p_Tgec->p_TgecDriverParam;
-    p_MemMap = p_Tgec->p_MemMap;
-
-    /* MAC Address */
-    addr = p_Tgec->addr;
-    tmpReg32 = (uint32_t)(addr>>16);
-    SwapUint32P(&tmpReg32);
-    WRITE_UINT32(p_MemMap->mac_addr_0, tmpReg32);
-
-    tmpReg32 = (uint32_t)(addr);
-    SwapUint32P(&tmpReg32);
-    tmpReg32 >>= 16;
-    WRITE_UINT32(p_MemMap->mac_addr_1, tmpReg32);
-
-    /* Config */
-    tmpReg32 = 0;
-    if (p_TgecDriverParam->wanModeEnable)
-        tmpReg32 |= CMD_CFG_WAN_MODE;
-    if (p_TgecDriverParam->promiscuousModeEnable)
-        tmpReg32 |= CMD_CFG_PROMIS_EN;
-    if (p_TgecDriverParam->pauseForwardEnable)
-        tmpReg32 |= CMD_CFG_PAUSE_FWD;
-    if (p_TgecDriverParam->pauseIgnore)
-        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
-    if (p_TgecDriverParam->txAddrInsEnable)
-        tmpReg32 |= CMD_CFG_TX_ADDR_INS;
-    if (p_TgecDriverParam->loopbackEnable)
-        tmpReg32 |= CMD_CFG_LOOPBACK_EN;
-    if (p_TgecDriverParam->cmdFrameEnable)
-        tmpReg32 |= CMD_CFG_CMD_FRM_EN;
-    if (p_TgecDriverParam->rxErrorDiscard)
-        tmpReg32 |= CMD_CFG_RX_ER_DISC;
-    if (p_TgecDriverParam->phyTxenaOn)
-        tmpReg32 |= CMD_CFG_PHY_TX_EN;
-    if (p_TgecDriverParam->sendIdleEnable)
-        tmpReg32 |= CMD_CFG_SEND_IDLE;
-    if (p_TgecDriverParam->noLengthCheckEnable)
-        tmpReg32 |= CMD_CFG_NO_LEN_CHK;
-    if (p_TgecDriverParam->lgthCheckNostdr)
-        tmpReg32 |= CMD_CFG_LEN_CHK_NOSTDR;
-    if (p_TgecDriverParam->timeStampEnable)
-        tmpReg32 |= CMD_CFG_EN_TIMESTAMP;
-    if (p_TgecDriverParam->rxSfdAny)
-        tmpReg32 |= RX_SFD_ANY;
-    if (p_TgecDriverParam->rxPblFwd)
-        tmpReg32 |= CMD_CFG_RX_PBL_FWD;
-    if (p_TgecDriverParam->txPblFwd)
-        tmpReg32 |= CMD_CFG_TX_PBL_FWD;
-    tmpReg32 |= 0x40;
-    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    MAKE_ENET_ADDR_FROM_UINT64(p_Tgec->addr, ethAddr);
+    tgec_set_mac_address(p_Tgec->p_MemMap, (uint8_t *)ethAddr);
+
+    /* interrupts */
+#ifdef FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
+    {
+        if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev <=2)
+            p_Tgec->exceptions &= ~(TGEC_IMASK_REM_FAULT | TGEC_IMASK_LOC_FAULT);
+    }
+#endif /* FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005 */
+
+    err = tgec_init(p_Tgec->p_MemMap, p_TgecDriverParam, p_Tgec->exceptions);
+    if (err) {
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MAJOR, err, ("This TGEC version does not support the required i/f mode"));
+    }
 
     /* Max Frame Length */
-    WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_TgecDriverParam->maxFrameLength);
     err = FmSetMacMaxFrame(p_Tgec->fmMacControllerDriver.h_Fm,
                            e_FM_MAC_10G,
                            p_Tgec->fmMacControllerDriver.macId,
-                           p_TgecDriverParam->maxFrameLength);
-
-    /* Pause Time */
-    WRITE_UINT32(p_MemMap->pause_quant, p_TgecDriverParam->pauseTime);
-
-#ifdef FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
-    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+                           p_TgecDriverParam->max_frame_length);
+/* we consider having no IPC a non crasher... */
+/*    if (err)
     {
-        WRITE_UINT32(p_Tgec->p_MemMap->tx_ipg_len,
-            (GET_UINT32(p_Tgec->p_MemMap->tx_ipg_len) & ~TX_IPG_LENGTH_MASK) | DEFAULT_txIpgLength);
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
+*/
+#ifdef FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
+    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
+        tgec_fm_tx_fifo_corruption_errata_10gmac_a007(p_Tgec->p_MemMap);
 #endif /* FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007 */
 
     p_Tgec->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
-    if(!p_Tgec->p_MulticastAddrHash)
+    if (!p_Tgec->p_MulticastAddrHash)
     {
         FreeInitResources(p_Tgec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
     }
 
     p_Tgec->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
-    if(!p_Tgec->p_UnicastAddrHash)
+    if (!p_Tgec->p_UnicastAddrHash)
     {
         FreeInitResources(p_Tgec);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
     }
 
-    /* interrupts */
-#ifdef FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005
-    if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev <=2)
-        p_Tgec->exceptions &= ~(IMASK_REM_FAULT | IMASK_LOC_FAULT);
-#endif /* FM_10G_REM_N_LCL_FLT_EX_10GMAC_ERRATA_SW005 */
-    WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
-    WRITE_UINT32(p_MemMap->imask, p_Tgec->exceptions);
-
     FmRegisterIntr(p_Tgec->fmMacControllerDriver.h_Fm,
                    e_FM_MOD_10G_MAC,
                    p_Tgec->macId,
@@ -1148,7 +922,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_Enable                    = TgecEnable;
     p_FmMacControllerDriver->f_FM_MAC_Disable                   = TgecDisable;
 
-    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = TgecSetTxAutoPauseFrames;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = TgecTxMacPause;
     p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames          = TgecSetTxPauseFrames;
     p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = TgecRxIgnoreMacPause;
 
@@ -1181,46 +955,41 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
 
 t_Handle TGEC_Config(t_FmMacParams *p_FmMacParam)
 {
-    t_Tgec                  *p_Tgec;
-    t_TgecDriverParam       *p_TgecDriverParam;
-    uintptr_t               baseAddr;
-    uint8_t                 i;
+    t_Tgec              *p_Tgec;
+    struct tgec_cfg     *p_TgecDriverParam;
+    uintptr_t           baseAddr;
 
     SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
 
     baseAddr = p_FmMacParam->baseAddr;
     /* allocate memory for the UCC GETH data structure. */
-    p_Tgec = (t_Tgec *) XX_Malloc(sizeof(t_Tgec));
+    p_Tgec = (t_Tgec *)XX_Malloc(sizeof(t_Tgec));
     if (!p_Tgec)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver structure"));
         return NULL;
     }
-    /* Zero out * p_Tgec */
     memset(p_Tgec, 0, sizeof(t_Tgec));
     InitFmMacControllerDriver(&p_Tgec->fmMacControllerDriver);
 
     /* allocate memory for the 10G MAC driver parameters data structure. */
-    p_TgecDriverParam = (t_TgecDriverParam *) XX_Malloc(sizeof(t_TgecDriverParam));
+    p_TgecDriverParam = (struct tgec_cfg *) XX_Malloc(sizeof(struct tgec_cfg));
     if (!p_TgecDriverParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver parameters"));
         TgecFree(p_Tgec);
         return NULL;
     }
-    /* Zero out */
-    memset(p_TgecDriverParam, 0, sizeof(t_TgecDriverParam));
+    memset(p_TgecDriverParam, 0, sizeof(struct tgec_cfg));
 
     /* Plant parameter structure pointer */
     p_Tgec->p_TgecDriverParam = p_TgecDriverParam;
 
-    SetDefaultParam(p_TgecDriverParam);
-
-    for (i=0; i < sizeof(p_FmMacParam->addr); i++)
-        p_Tgec->addr |= ((uint64_t)p_FmMacParam->addr[i] << ((5-i) * 8));
+    tgec_defconfig(p_TgecDriverParam);
 
-    p_Tgec->p_MemMap        = (t_TgecMemMap *)UINT_TO_PTR(baseAddr);
+    p_Tgec->p_MemMap        = (struct tgec_regs *)UINT_TO_PTR(baseAddr);
     p_Tgec->p_MiiMemMap     = (t_TgecMiiAccessMemMap *)UINT_TO_PTR(baseAddr + TGEC_TO_MII_OFFSET);
+    p_Tgec->addr            = ENET_ADDR_TO_UINT64(p_FmMacParam->addr);
     p_Tgec->enetMode        = p_FmMacParam->enetMode;
     p_Tgec->macId           = p_FmMacParam->macId;
     p_Tgec->exceptions      = DEFAULT_exceptions;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
index 64bf754..f9bc687 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/tgec.h
@@ -42,165 +42,64 @@
 #include "std_ext.h"
 #include "error_ext.h"
 #include "list_ext.h"
+#include "enet_ext.h"
+
 #include "tgec_mii_acc.h"
 #include "fm_mac.h"
 
 
-/* Interrupt Mask Register (IMASK) */
-#define IMASK_MDIO_SCAN_EVENTMDIO   0x00010000  /* MDIO_SCAN_EVENTMDIO scan event interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_MDIO_CMD_CMPL         0x00008000  /* 16 MDIO_CMD_CMPL MDIO command completion interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_REM_FAULT             0x00004000  /* 17 REM_FAULT Remote fault interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_LOC_FAULT             0x00002000  /* 18 LOC_FAULT Local fault interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_1TX_ECC_ER            0x00001000  /* 19 TX_ECC_ER Transmit frame ECC error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 TX_FIFO_UNFL Transmit FIFO underflow interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 TX_FIFO_OVFL Transmit FIFO overflow interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_TX_ER                 0x00000200  /* 22 TX_ER Transmit frame error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_FIFO_OVFL          0x00000100  /* 23 RX_FIFO_OVFL Receive FIFO overflow interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_ECC_ER             0x00000080  /* 24 RX_ECC_ER Receive frame ECC error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_JAB_FRM            0x00000040  /* 25 RX_JAB_FRM Receive jabber frame interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_OVRSZ_FRM          0x00000020  /* 26 RX_OVRSZ_FRM Receive oversized frame interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_RUNT_FRM           0x00000010  /* 27 RX_RUNT_FRM Receive runt frame interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_FRAG_FRM           0x00000008  /* 28 RX_FRAG_FRM Receive fragment frame interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_LEN_ER             0x00000004  /* 29 RX_LEN_ER Receive payload length error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_CRC_ER             0x00000002  /* 30 RX_CRC_ER Receive CRC error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-#define IMASK_RX_ALIGN_ER           0x00000001  /* 31 RX_ALIGN_ER Receive alignment error interrupt mask.
-                                                 * 0 masked
-                                                 * 1 enabled
-                                                 */
-
-#define EVENTS_MASK                 ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
-                                                IMASK_MDIO_CMD_CMPL       |  \
-                                                IMASK_REM_FAULT           |  \
-                                                IMASK_LOC_FAULT           |  \
-                                                IMASK_1TX_ECC_ER          |  \
-                                                IMASK_TX_FIFO_UNFL        |  \
-                                                IMASK_TX_FIFO_OVFL        |  \
-                                                IMASK_TX_ER               |  \
-                                                IMASK_RX_FIFO_OVFL        |  \
-                                                IMASK_RX_ECC_ER           |  \
-                                                IMASK_RX_JAB_FRM          |  \
-                                                IMASK_RX_OVRSZ_FRM        |  \
-                                                IMASK_RX_RUNT_FRM         |  \
-                                                IMASK_RX_FRAG_FRM         |  \
-                                                IMASK_RX_LEN_ER           |  \
-                                                IMASK_RX_CRC_ER           |  \
-                                                IMASK_RX_ALIGN_ER))
-
-#define GET_EXCEPTION_FLAG(bitMask, exception)       switch(exception){ \
-    case e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO:                                    \
-        bitMask = IMASK_MDIO_SCAN_EVENTMDIO; break;                              \
-    case e_FM_MAC_EX_10G_MDIO_CMD_CMPL:                                          \
-        bitMask = IMASK_MDIO_CMD_CMPL      ; break;                              \
-    case e_FM_MAC_EX_10G_REM_FAULT:                                              \
-        bitMask = IMASK_REM_FAULT          ; break;                              \
-    case e_FM_MAC_EX_10G_LOC_FAULT:                                              \
-        bitMask = IMASK_LOC_FAULT          ; break;                              \
-    case e_FM_MAC_EX_10G_1TX_ECC_ER:                                             \
-        bitMask = IMASK_1TX_ECC_ER         ; break;                              \
-    case e_FM_MAC_EX_10G_TX_FIFO_UNFL:                                           \
-        bitMask = IMASK_TX_FIFO_UNFL       ; break;                              \
-    case e_FM_MAC_EX_10G_TX_FIFO_OVFL:                                           \
-        bitMask = IMASK_TX_FIFO_OVFL       ; break;                              \
-    case e_FM_MAC_EX_10G_TX_ER:                                                  \
-        bitMask = IMASK_TX_ER              ; break;                              \
-    case e_FM_MAC_EX_10G_RX_FIFO_OVFL:                                           \
-        bitMask = IMASK_RX_FIFO_OVFL       ; break;                              \
-    case e_FM_MAC_EX_10G_RX_ECC_ER:                                              \
-        bitMask = IMASK_RX_ECC_ER          ; break;                              \
-    case e_FM_MAC_EX_10G_RX_JAB_FRM:                                             \
-        bitMask = IMASK_RX_JAB_FRM         ; break;                              \
-    case e_FM_MAC_EX_10G_RX_OVRSZ_FRM:                                           \
-        bitMask = IMASK_RX_OVRSZ_FRM       ; break;                              \
-    case e_FM_MAC_EX_10G_RX_RUNT_FRM:                                            \
-        bitMask = IMASK_RX_RUNT_FRM        ; break;                              \
-    case e_FM_MAC_EX_10G_RX_FRAG_FRM:                                            \
-        bitMask = IMASK_RX_FRAG_FRM        ; break;                              \
-    case e_FM_MAC_EX_10G_RX_LEN_ER:                                              \
-        bitMask = IMASK_RX_LEN_ER          ; break;                              \
-    case e_FM_MAC_EX_10G_RX_CRC_ER:                                              \
-        bitMask = IMASK_RX_CRC_ER          ; break;                              \
-    case e_FM_MAC_EX_10G_RX_ALIGN_ER:                                            \
-        bitMask = IMASK_RX_ALIGN_ER        ; break;                              \
+#define GET_EXCEPTION_FLAG(bitMask, exception)      switch (exception){ \
+    case e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO:                           \
+        bitMask = TGEC_IMASK_MDIO_SCAN_EVENT    ; break;                \
+    case e_FM_MAC_EX_10G_MDIO_CMD_CMPL:                                 \
+        bitMask = TGEC_IMASK_MDIO_CMD_CMPL      ; break;                \
+    case e_FM_MAC_EX_10G_REM_FAULT:                                     \
+        bitMask = TGEC_IMASK_REM_FAULT          ; break;                \
+    case e_FM_MAC_EX_10G_LOC_FAULT:                                     \
+        bitMask = TGEC_IMASK_LOC_FAULT          ; break;                \
+    case e_FM_MAC_EX_10G_1TX_ECC_ER:                                    \
+        bitMask = TGEC_IMASK_TX_ECC_ER         ; break;                 \
+    case e_FM_MAC_EX_10G_TX_FIFO_UNFL:                                  \
+        bitMask = TGEC_IMASK_TX_FIFO_UNFL       ; break;                \
+    case e_FM_MAC_EX_10G_TX_FIFO_OVFL:                                  \
+        bitMask = TGEC_IMASK_TX_FIFO_OVFL       ; break;                \
+    case e_FM_MAC_EX_10G_TX_ER:                                         \
+        bitMask = TGEC_IMASK_TX_ER              ; break;                \
+    case e_FM_MAC_EX_10G_RX_FIFO_OVFL:                                  \
+        bitMask = TGEC_IMASK_RX_FIFO_OVFL       ; break;                \
+    case e_FM_MAC_EX_10G_RX_ECC_ER:                                     \
+        bitMask = TGEC_IMASK_RX_ECC_ER          ; break;                \
+    case e_FM_MAC_EX_10G_RX_JAB_FRM:                                    \
+        bitMask = TGEC_IMASK_RX_JAB_FRM         ; break;                \
+    case e_FM_MAC_EX_10G_RX_OVRSZ_FRM:                                  \
+        bitMask = TGEC_IMASK_RX_OVRSZ_FRM       ; break;                \
+    case e_FM_MAC_EX_10G_RX_RUNT_FRM:                                   \
+        bitMask = TGEC_IMASK_RX_RUNT_FRM        ; break;                \
+    case e_FM_MAC_EX_10G_RX_FRAG_FRM:                                   \
+        bitMask = TGEC_IMASK_RX_FRAG_FRM        ; break;                \
+    case e_FM_MAC_EX_10G_RX_LEN_ER:                                     \
+        bitMask = TGEC_IMASK_RX_LEN_ER          ; break;                \
+    case e_FM_MAC_EX_10G_RX_CRC_ER:                                     \
+        bitMask = TGEC_IMASK_RX_CRC_ER          ; break;                \
+    case e_FM_MAC_EX_10G_RX_ALIGN_ER:                                   \
+        bitMask = TGEC_IMASK_RX_ALIGN_ER        ; break;                \
     default: bitMask = 0;break;}
 
-
-#define DEFAULT_pauseForwardEnable          FALSE
-#define DEFAULT_txAddrInsEnable             FALSE
-#define DEFAULT_cmdFrameEnable              FALSE
-#define DEFAULT_rxErrorDiscard              FALSE
-#define DEFAULT_phyTxenaOn                  FALSE
-#define DEFAULT_sendIdleEnable              FALSE
-#define DEFAULT_lgthCheckNostdr             FALSE
-#define DEFAULT_rxSfdAny                    FALSE
-#define DEFAULT_rxPblFwd                    FALSE
-#define DEFAULT_txPblFwd                    FALSE
-#define DEFAULT_txIpgLength                 12
-#define DEFAULT_debugMode                   FALSE
-#define DEFAULT_timeStampEnable             FALSE
-
-#define DEFAULT_exceptions          ((uint32_t)(IMASK_MDIO_SCAN_EVENTMDIO |  \
-                                                IMASK_REM_FAULT           |  \
-                                                IMASK_LOC_FAULT           |  \
-                                                IMASK_1TX_ECC_ER          |  \
-                                                IMASK_TX_FIFO_UNFL        |  \
-                                                IMASK_TX_FIFO_OVFL        |  \
-                                                IMASK_TX_ER               |  \
-                                                IMASK_RX_FIFO_OVFL        |  \
-                                                IMASK_RX_ECC_ER           |  \
-                                                IMASK_RX_JAB_FRM          |  \
-                                                IMASK_RX_OVRSZ_FRM        |  \
-                                                IMASK_RX_RUNT_FRM         |  \
-                                                IMASK_RX_FRAG_FRM         |  \
-                                                IMASK_RX_CRC_ER           |  \
-                                                IMASK_RX_ALIGN_ER))
+#define DEFAULT_exceptions  ((uint32_t)(TGEC_IMASK_MDIO_SCAN_EVENT     |  \
+                                        TGEC_IMASK_REM_FAULT           |  \
+                                        TGEC_IMASK_LOC_FAULT           |  \
+                                        TGEC_IMASK_TX_ECC_ER           |  \
+                                        TGEC_IMASK_TX_FIFO_UNFL        |  \
+                                        TGEC_IMASK_TX_FIFO_OVFL        |  \
+                                        TGEC_IMASK_TX_ER               |  \
+                                        TGEC_IMASK_RX_FIFO_OVFL        |  \
+                                        TGEC_IMASK_RX_ECC_ER           |  \
+                                        TGEC_IMASK_RX_JAB_FRM          |  \
+                                        TGEC_IMASK_RX_OVRSZ_FRM        |  \
+                                        TGEC_IMASK_RX_RUNT_FRM         |  \
+                                        TGEC_IMASK_RX_FRAG_FRM         |  \
+                                        TGEC_IMASK_RX_CRC_ER           |  \
+                                        TGEC_IMASK_RX_ALIGN_ER))
 
 #define MAX_PACKET_ALIGNMENT        31
 #define MAX_INTER_PACKET_GAP        0x7f
@@ -221,257 +120,11 @@
 #define TGEC_ID_MAC_VERSION         0x0000FF00
 #define TGEC_ID_MAC_REV             0x000000ff
 
-/* Command and Configuration Register (COMMAND_CONFIG) */
-#define CMD_CFG_TX_PBL_FWD          0x00800000  /* 08 Transmit Preamble Forwarding (custom preamble).
-                                                 */
-#define CMD_CFG_RX_PBL_FWD          0x00400000  /* 09 Receive Preamble Forwarding (custom preamble).
-                                                 */
-#define RX_SFD_ANY                  0x00200000  /* 10 Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
-                                                 */
-#define CMD_CFG_EN_TIMESTAMP        0x00100000  /* 11 EN_TIMESTAMP IEEE 1588 timeStamp functionality control.
-                                                 * 0 disabled
-                                                 * 1 enabled
-                                                 */
-#define CMD_CFG_TX_ADDR_INS_SEL     0x00080000  /* 12 TX_ADDR_INS_SEL Transmit MAC address select
-                                                 * 0 insert using first MAC address
-                                                 * 1 insert using second MAC address
-                                                 */
-#define CMD_CFG_LEN_CHK_NOSTDR      0x00040000  /* 13 LEN_CHK_NOSTDR
-                                                 */
-#define CMD_CFG_NO_LEN_CHK          0x00020000  /* 14 NO_LEN_CHK Payload length check disable
-                                                 * 0 MAC compares the frame payload length with the frame length/type field.
-                                                 * 1 Payload length check is disabled.
-                                                 */
-#define CMD_CFG_SEND_IDLE           0x00010000  /* 15 SEND_IDLE Force idle generation
-                                                 * 0 Normal operation.
-                                                * 1 MAC permanently sends XGMII idle sequences even when faults are received.
-                                                 */
-#define CMD_CFG_PHY_TX_EN           0x00008000  /* 16 PHY_TX_EN PHY transmit enable
-                                                 * 0 PHY transmit is disabled.
-                                                 * 1 PHY transmit is enabled.
-                                                 */
-#define CMD_CFG_RX_ER_DISC          0x00004000  /* 17 RX_ER_DISC Receive error frame discard enable
-                                                 * 0 Received error frames are processed.
-                                                 * 1 Any frame received with an error is discarded.
-                                                 */
-#define CMD_CFG_CMD_FRM_EN          0x00002000  /* 18 CMD_FRM_EN Command frame reception enable
-                                                 * 0 Only Pause frames are accepted (all other command frames are rejected).
-                                                 * 1 All command frames are accepted.
-                                                 */
-#define CMD_CFG_STAT_CLR            0x00001000  /* 19 STAT_CLR Clear statistics
-                                                 * 0 Normal operations.
-                                                 * 1 All statistics counters are cleared.
-                                                 */
-#define CMD_CFG_LOOPBACK_EN         0x00000400  /* 21 LOOPBAC_EN PHY interface loopback enable
-                                                 * 0 Configure PHY for normal operation.
-                                                 * 1 Configure PHY for loopback mode.
-                                                 */
-#define CMD_CFG_TX_ADDR_INS         0x00000200  /* 22 TX_ADDR_INS Transmit source MAC address insertion
-                                                 * 0 MAC transmits the source MAC address unmodified.
-                                                 * 1 MAC overwrites the source MAC address with address specified by COMMAND_CONFIG[TX_ADDR_INS_SEL].
-                                                 */
-#define CMD_CFG_PAUSE_IGNORE        0x00000100  /* 23 PAUSE_IGNORE Ignore Pause frame quanta
-                                                 * 0 MAC stops transmit process for the duration specified in the Pause frame quanta of a received Pause frame.
-                                                 * 1 MAC ignores received Pause frames.
-                                                 */
-#define CMD_CFG_PAUSE_FWD           0x00000080  /* 24 PAUSE_FWD Terminate/forward received Pause frames
-                                                 * 0 MAC terminates and discards received Pause frames.
-                                                 * 1 MAC forwards Pause frames to the user application.
-                                                 */
-#define CMD_CFG_PROMIS_EN           0x00000010  /* 27 PROMIS_EN Promiscuous operation enable
-                                                 * 0 Unicast frames with a destination address not matching the core MAC address (defined by registers, MAC_ADDR_0 and MAC_ADDR_1) are rejected.
-                                                 * 1 All frames are received without any MAC address filtering.
-                                                 */
-#define CMD_CFG_WAN_MODE            0x00000008  /* 28 WAN_MODE WAN mode enable
-                                                 * 0 Configure MAC for LAN mode.
-                                                 * 1 Configure MAC for WAN mode.
-                                                 */
-#define CMD_CFG_RX_EN               0x00000002  /* 30 RX_EN MAC receive path enable
-                                                 * 0 MAC receive path is disabled
-                                                 * 1 MAC receive path is enabled.
-                                                 */
-#define CMD_CFG_TX_EN               0x00000001  /* 31 TX_EN MAC transmit path enable
-                                                 * 0 MAC transmit path is disabled
-                                                 * 1 MAC transmit path is enabled.
-                                                 */
-
-/* Hashtable Control Register (HASHTABLE_CTRL) */
-#define HASH_CTRL_MCAST_SHIFT       23
-
-#define HASH_CTRL_MCAST_RD          0x00000400  /* 22 MCAST_READ Entry Multicast frame reception for the hash entry.
-                                                 * 0 disabled
-                                                 * 1 enabled
-                                                 */
-#define HASH_CTRL_MCAST_EN          0x00000200  /* 22 MCAST_EN Multicast frame reception for the hash entry.
-                                                 * 0 disabled
-                                                 * 1 enabled
-                                                 */
-#define HASH_ADDR_MASK              0x000001ff  /* 23-31 HASH_ADDR Hash table address code.
-                                                 */
-
-/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
-#define TX_IPG_LENGTH_MASK          0x000003ff
-
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(push,1)
-#endif /* defined(__MWERKS__) && ... */
-
-/*
- * 10G memory map
- */
-typedef _Packed struct {
-/* 10Ge General Control and Status */
-    volatile uint32_t   tgec_id;            /* 0x000 10GEC_ID - Controller ID register */
-    volatile uint32_t   scratch;            /* 0x004  */
-    volatile uint32_t   command_config;     /* 0x008 COMMAND_CONFIG - Control and configuration register */
-    volatile uint32_t   mac_addr_0;         /* 0x00C MAC_ADDR_0 - Lower 32 bits of the first 48-bit MAC address */
-    volatile uint32_t   mac_addr_1;         /* 0x010 MAC_ADDR_1 - Upper 16 bits of the first 48-bit MAC address */
-    volatile uint32_t   maxfrm;             /* 0x014 MAXFRM - Maximum frame length register */
-    volatile uint32_t   pause_quant;        /* 0x018 PAUSE_QUANT - Pause quanta register */
-    volatile uint32_t   rx_fifo_sections;   /* 0x01c  */
-    volatile uint32_t   tx_fifo_sections;   /* 0x020  */
-    volatile uint32_t   rx_fifo_almost_f_e; /* 0x024  */
-    volatile uint32_t   tx_fifo_almost_f_e; /* 0x028  */
-    volatile uint32_t   hashtable_ctrl;     /* 0x02C HASHTABLE_CTRL - Hash table control register */
-    volatile uint32_t   mdio_cfg_status;    /* 0x030  */
-    volatile uint32_t   mdio_command;       /* 0x034  */
-    volatile uint32_t   mdio_data;          /* 0x038  */
-    volatile uint32_t   mdio_regaddr;       /* 0x03c  */
-    volatile uint32_t   status;             /* 0x040  */
-    volatile uint32_t   tx_ipg_len;         /* 0x044 TX_IPG_LENGTH - Transmitter inter-packet-gap register */
-    volatile uint32_t   mac_addr_2;         /* 0x048 MAC_ADDR_2 - Lower 32 bits of the second 48-bit MAC address */
-    volatile uint32_t   mac_addr_3;         /* 0x04C MAC_ADDR_3 - Upper 16 bits of the second 48-bit MAC address */
-    volatile uint32_t   rx_fifo_ptr_rd;     /* 0x050  */
-    volatile uint32_t   rx_fifo_ptr_wr;     /* 0x054  */
-    volatile uint32_t   tx_fifo_ptr_rd;     /* 0x058  */
-    volatile uint32_t   tx_fifo_ptr_wr;     /* 0x05c  */
-    volatile uint32_t   imask;              /* 0x060 IMASK - Interrupt mask register */
-    volatile uint32_t   ievent;             /* 0x064 IEVENT - Interrupt event register */
-    volatile uint32_t   udp_port;           /* 0x068 Defines a UDP Port number. When an UDP/IP frame is received with a matching UDP destination port, the receive status indication pin ff_rx_ts_frm will be asserted.*/
-    volatile uint32_t   type_1588v2;        /* 0x06c Type field for 1588v2 layer 2 frames. IEEE1588 defines the type 0x88f7 for 1588 frames. */
-    volatile uint32_t   reserved1[4];       /* */
-
-    /*10Ge Statistics Counter */
-    volatile uint32_t   tfrm_u;      /* 80 aFramesTransmittedOK */
-    volatile uint32_t   tfrm_l;      /* 84 aFramesTransmittedOK */
-    volatile uint32_t   rfrm_u;      /* 88 aFramesReceivedOK */
-    volatile uint32_t   rfrm_l;      /* 8c aFramesReceivedOK */
-    volatile uint32_t   rfcs_u;      /* 90 aFrameCheckSequenceErrors */
-    volatile uint32_t   rfcs_l;      /* 94 aFrameCheckSequenceErrors */
-    volatile uint32_t   raln_u;      /* 98 aAlignmentErrors */
-    volatile uint32_t   raln_l;      /* 9c aAlignmentErrors */
-    volatile uint32_t   txpf_u;      /* A0 aPAUSEMACCtrlFramesTransmitted */
-    volatile uint32_t   txpf_l;      /* A4 aPAUSEMACCtrlFramesTransmitted */
-    volatile uint32_t   rxpf_u;      /* A8 aPAUSEMACCtrlFramesReceived */
-    volatile uint32_t   rxpf_l;      /* Ac aPAUSEMACCtrlFramesReceived */
-    volatile uint32_t   rlong_u;     /* B0 aFrameTooLongErrors */
-    volatile uint32_t   rlong_l;     /* B4 aFrameTooLongErrors */
-    volatile uint32_t   rflr_u;      /* B8 aInRangeLengthErrors */
-    volatile uint32_t   rflr_l;      /* Bc aInRangeLengthErrors */
-    volatile uint32_t   tvlan_u;     /* C0 VLANTransmittedOK */
-    volatile uint32_t   tvlan_l;     /* C4 VLANTransmittedOK */
-    volatile uint32_t   rvlan_u;     /* C8 VLANReceivedOK */
-    volatile uint32_t   rvlan_l;     /* Cc VLANReceivedOK */
-    volatile uint32_t   toct_u;      /* D0 ifOutOctets */
-    volatile uint32_t   toct_l;      /* D4 ifOutOctets */
-    volatile uint32_t   roct_u;      /* D8 ifInOctets */
-    volatile uint32_t   roct_l;      /* Dc ifInOctets */
-    volatile uint32_t   ruca_u;      /* E0 ifInUcastPkts */
-    volatile uint32_t   ruca_l;      /* E4 ifInUcastPkts */
-    volatile uint32_t   rmca_u;      /* E8 ifInMulticastPkts */
-    volatile uint32_t   rmca_l;      /* Ec ifInMulticastPkts */
-    volatile uint32_t   rbca_u;      /* F0 ifInBroadcastPkts */
-    volatile uint32_t   rbca_l;      /* F4 ifInBroadcastPkts */
-    volatile uint32_t   terr_u;      /* F8 ifOutErrors */
-    volatile uint32_t   terr_l;      /* Fc ifOutErrors */
-    volatile uint32_t   reserved2[2];/* 100-108*/
-    volatile uint32_t   tuca_u;      /* 108 ifOutUcastPkts */
-    volatile uint32_t   tuca_l;      /* 10c ifOutUcastPkts */
-    volatile uint32_t   tmca_u;      /* 110 ifOutMulticastPkts */
-    volatile uint32_t   tmca_l;      /* 114 ifOutMulticastPkts */
-    volatile uint32_t   tbca_u;      /* 118 ifOutBroadcastPkts */
-    volatile uint32_t   tbca_l;      /* 11c ifOutBroadcastPkts */
-    volatile uint32_t   rdrp_u;      /* 120 etherStatsDropEvents */
-    volatile uint32_t   rdrp_l;      /* 124 etherStatsDropEvents */
-    volatile uint32_t   reoct_u;     /* 128 etherStatsOctets */
-    volatile uint32_t   reoct_l;     /* 12c etherStatsOctets */
-    volatile uint32_t   rpkt_u;      /* 130 etherStatsPkts */
-    volatile uint32_t   rpkt_l;      /* 134 etherStatsPkts */
-    volatile uint32_t   trund_u;     /* 138 etherStatsUndersizePkts */
-    volatile uint32_t   trund_l;     /* 13c etherStatsUndersizePkts */
-    volatile uint32_t   r64_u;       /* 140 etherStatsPkts64Octets */
-    volatile uint32_t   r64_l;       /* 144 etherStatsPkts64Octets */
-    volatile uint32_t   r127_u;      /* 148 etherStatsPkts65to127Octets */
-    volatile uint32_t   r127_l;      /* 14c etherStatsPkts65to127Octets */
-    volatile uint32_t   r255_u;      /* 150 etherStatsPkts128to255Octets */
-    volatile uint32_t   r255_l;      /* 154 etherStatsPkts128to255Octets */
-    volatile uint32_t   r511_u;      /* 158 etherStatsPkts256to511Octets */
-    volatile uint32_t   r511_l;      /* 15c etherStatsPkts256to511Octets */
-    volatile uint32_t   r1023_u;     /* 160 etherStatsPkts512to1023Octets */
-    volatile uint32_t   r1023_l;     /* 164 etherStatsPkts512to1023Octets */
-    volatile uint32_t   r1518_u;     /* 168 etherStatsPkts1024to1518Octets */
-    volatile uint32_t   r1518_l;     /* 16c etherStatsPkts1024to1518Octets */
-    volatile uint32_t   r1519x_u;    /* 170 etherStatsPkts1519toX */
-    volatile uint32_t   r1519x_l;    /* 174 etherStatsPkts1519toX */
-    volatile uint32_t   trovr_u;     /* 178 etherStatsOversizePkts */
-    volatile uint32_t   trovr_l;     /* 17c etherStatsOversizePkts */
-    volatile uint32_t   trjbr_u;     /* 180 etherStatsJabbers */
-    volatile uint32_t   trjbr_l;     /* 184 etherStatsJabbers */
-    volatile uint32_t   trfrg_u;     /* 188 etherStatsFragments */
-    volatile uint32_t   trfrg_l;     /* 18C etherStatsFragments */
-    volatile uint32_t   rerr_u;      /* 190 ifInErrors */
-    volatile uint32_t   rerr_l;      /* 194 ifInErrors */
-} _PackedType t_TgecMemMap;
-
-#if defined(__MWERKS__) && !defined(__GNUC__)
-#pragma pack(pop)
-#endif /* defined(__MWERKS__) && ... */
-
-
-typedef struct {
-    bool wanModeEnable;             /* WAN Mode Enable. Sets WAN mode (1) or LAN mode (0, default) of operation. */
-    bool promiscuousModeEnable;     /* Enables MAC promiscuous operation. When set to '1', all frames are received without any MAC address filtering, when set to '0' (Reset value) Unicast Frames with a destination address not matching the Core MAC Address (MAC Address programmed in Registers MAC_ADDR_0 and MAC_ADDR_1 or the MAC address programmed in Registers MAC_ADDR_2 and MAC_ADDR_3 ) are rejected. */
-    bool pauseForwardEnable;        /* Terminate / Forward Pause Frames. If set to '1' pause frames are forwarded to the user application. When set to '0' (Reset value) pause frames are terminated and discarded within the MAC. */
-    bool pauseIgnore;               /* Ignore Pause Frame Quanta. If set to '1' received pause frames are ignored by the MAC. When set to '0' (Reset value) the transmit process is stopped for the amount of time specified in the pause quanta received within a pause frame. */
-    bool txAddrInsEnable;           /* Set Source MAC Address on Transmit.
-                                        If set to '1' the MAC overwrites the source MAC address received from the Client Interface with one of the MAC addresses (Refer to section 10.4)
-                                        If set to '0' (Reset value), the source MAC address from the Client Interface is transmitted unmodified to the line. */
-    bool loopbackEnable;            /* PHY Interface Loopback. When set to '1', the signal loop_ena is set to '1', when set to '0' (Reset value) the signal loop_ena is set to '0'. */
-    bool cmdFrameEnable;            /* Enables reception of all command frames. When set to '1' all Command Frames are accepted, when set to '0' (Reset Value) only Pause Frames are accepted and all other Command Frames are rejected. */
-    bool rxErrorDiscard;            /* Receive Errored Frame Discard Enable. When set to 1, any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to 0 (Reset value), errored Frames are forwarded to the Client interface with ff_rx_err asserted. */
-    bool phyTxenaOn;                /* PHY Transmit Enable. When set to '1', the signal phy_txena is set to '1', when set to '0' (Reset value) the signal phy_txena is set to '0' */
-    bool sendIdleEnable;            /* Force Idle Generation. When set to '1', the MAC permanently sends XGMII Idle sequences even when faults are received. */
-    bool noLengthCheckEnable;       /* Payload Length Check Disable. When set to 0 (Reset value), the Core checks the frame's payload length with the Frame Length/Type field, when set to 1, the payload length check is disabled. */
-    bool lgthCheckNostdr;           /* The Core interprets the Length/Type field differently depending on the value of this Bit */
-    bool timeStampEnable;           /* This bit selects between enabling and disabling the IEEE 1588 functionality.
-                                        1: IEEE 1588 is enabled.
-                                        0: IEEE 1588 is disabled. */
-    bool rxSfdAny;                  /* Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
-                                        If cleared (default) the frame is accepted only if the 8th byte of the preamble contains the SFD value 0xd5. If another value is received, the frame is discarded and the alignment error counter increments. */
-    bool rxPblFwd;                  /* Receive Preamble Forwarding (custom preamble).
-                                        If set, the first word (ff_rx_sop) of every received frame contains the preamble of the frame. The frame data starts with the 2nd word from the FIFO.
-                                        If the bit is cleared (default) the preamble is removed from the frame before it is written into the receive FIFO. */
-    bool txPblFwd;                  /* Transmit Preamble Forwarding (custom preamble).
-                                        If set, the first word written into the TX FIFO is considered as frame preamble. The MAC will not add a preamble in front of the frame. Note that bits 7:0 of the preamble word will still be overwritten with the XGMII start character upon transmission.
-                                        If cleared (default) the MAC */
-    uint32_t txIpgLength;           /*Transmit Inter-Packet-Gap (IPG) value.
-                                      A 6-bit value: Depending on LAN or WAN mode of operation (see COMMAND_CONFIG, 19.2.1 page 91) the value has the following meaning:
-                                        - LAN Mode: Number of octets in steps of 4. Valid values are 8, 12, 16, ... 100. DIC is fully supported (see 10.6.1 page 49) for any setting. A default of 12 (reset value) must be set to conform to IEEE802.3ae. Warning: When set to 8, PCS layers may not be able to perform clock rate compensation.
-                                        - WAN Mode: Stretch factor. Valid values are 4..15. The stretch factor is calculated as (value+1)*8. A default of 12 (reset value) must be set to conform to IEEE 802.3ae (i.e. 13*8=104). A larger value shrinks the IPG (increasing bandwidth). */
-/*.. */
-    uint16_t    maxFrameLength;
-    bool        debugMode;
-    uint16_t    pauseTime;
-#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
-    bool        skipFman11Workaround;
-#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
-} t_TgecDriverParam;
 
 typedef struct {
     t_FmMacControllerDriver     fmMacControllerDriver;              /**< Upper Mac control block */
     t_Handle                    h_App;                              /**< Handle to the upper layer application  */
-    t_TgecMemMap                *p_MemMap;                          /**< pointer to 10G memory mapped registers. */
+    struct tgec_regs            *p_MemMap;                          /**< pointer to 10G memory mapped registers. */
     t_TgecMiiAccessMemMap       *p_MiiMemMap;                       /**< pointer to MII memory mapped registers.          */
     uint64_t                    addr;                               /**< MAC address of device; */
     e_EnetMode                  enetMode;                           /**< Ethernet physical interface  */
@@ -486,7 +139,7 @@ typedef struct {
     bool                        debugMode;
     uint8_t                     macId;
     uint32_t                    exceptions;
-    t_TgecDriverParam           *p_TgecDriverParam;
+    struct tgec_cfg             *p_TgecDriverParam;
 } t_Tgec;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
index 36b08aa..9b18a8a 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.c
@@ -84,7 +84,7 @@ static void  UpdateNodeOwner(t_FmPcdCcNode *p_CcNode, bool add)
 
     intFlags = XX_LockIntrSpinlock(p_CcNode->h_Spinlock);
 
-    if(add)
+    if (add)
         p_CcNode->owners++;
     else
     {
@@ -112,7 +112,7 @@ static __inline__ t_FmPcdStatsObj* DequeueStatsObj(t_List *p_List)
 }
 
 static __inline__ void EnqueueStatsObj(t_List              *p_List,
-                                     t_FmPcdStatsObj     *p_StatsObj)
+                                       t_FmPcdStatsObj     *p_StatsObj)
 {
     LIST_AddToTail(&p_StatsObj->node, p_List);
 }
@@ -218,52 +218,63 @@ static void PutStatsObj(t_FmPcdCcNode       *p_CcNode,
 static void SetStatsCounters(t_AdOfTypeStats *p_StatsAd,
                              uint32_t        statsCountersAddr)
 {
-    uint32_t tmp = (statsCountersAddr & 0x00FFFFFF);
+    uint32_t tmp = (statsCountersAddr & FM_PCD_AD_STATS_COUNTERS_ADDR_MASK);
 
     WRITE_UINT32(p_StatsAd->statsTableAddr, tmp);
 }
 
-static void UpdateStatsAd(t_AdOfTypeStats *p_StatsAd,
-                          uint32_t        statsCountersAddr,
-                          uint32_t        nextActionAddr,
-                          uint32_t        frameLengthRangesAddr)
+
+static void UpdateStatsAd(t_FmPcdCcStatsParams  *p_FmPcdCcStatsParams,
+                          t_Handle              h_Ad,
+                          uint64_t              physicalMuramBase)
 {
-    uint32_t tmp = 0;
+    t_AdOfTypeStats *p_StatsAd;
+    uint32_t        statsCountersAddr, nextActionAddr, tmp;
+#if (DPAA_VERSION >= 11)
+    uint32_t        frameLengthRangesAddr;
+#endif /* (DPAA_VERSION >= 11) */
 
-    tmp = 0x40000000;
+    p_StatsAd = (t_AdOfTypeStats *)p_FmPcdCcStatsParams->h_StatsAd;
 
-    if (frameLengthRangesAddr)
-        tmp |= (frameLengthRangesAddr & 0x00FFFFFF);
+    tmp = FM_PCD_AD_STATS_TYPE;
 
+#if (DPAA_VERSION >= 11)
+    if (p_FmPcdCcStatsParams->h_StatsFLRs)
+    {
+        frameLengthRangesAddr = (uint32_t)((XX_VirtToPhys(p_FmPcdCcStatsParams->h_StatsFLRs) - physicalMuramBase));
+        tmp |= (frameLengthRangesAddr & FM_PCD_AD_STATS_FLR_ADDR_MASK);
+    }
+#endif /* (DPAA_VERSION >= 11) */
     WRITE_UINT32(p_StatsAd->profileTableAddr, tmp);
 
+    nextActionAddr = (uint32_t)((XX_VirtToPhys(h_Ad) - physicalMuramBase));
     tmp = 0;
-    tmp |= (uint32_t)((nextActionAddr << 12) & 0xFFFF0000);
-    tmp |= (0x00008000 | 0x36);
+    tmp |= (uint32_t)((nextActionAddr << FM_PCD_AD_STATS_NEXT_ACTION_SHIFT) & FM_PCD_AD_STATS_NEXT_ACTION_MASK);
+    tmp |= (FM_PCD_AD_STATS_NAD_EN | FM_PCD_AD_STATS_OP_CODE);
 
-    if (frameLengthRangesAddr)
-        tmp |= 0x00004000;
+#if (DPAA_VERSION >= 11)
+    if (p_FmPcdCcStatsParams->h_StatsFLRs)
+        tmp |= FM_PCD_AD_STATS_FLR_EN;
+#endif /* (DPAA_VERSION >= 11) */
 
     WRITE_UINT32(p_StatsAd->nextActionIndx, tmp);
 
+    statsCountersAddr = (uint32_t)((XX_VirtToPhys(p_FmPcdCcStatsParams->h_StatsCounters) - physicalMuramBase));
     SetStatsCounters(p_StatsAd, statsCountersAddr);
 }
 
-static void FillAdOfTypeContLookup(t_Handle h_Ad,
-                                   t_Handle h_StatsAd,
-                                   t_Handle h_StatsCounters,
-                                   t_Handle h_StatsFLRs,
-                                   t_Handle h_FmPcd,
-                                   t_Handle p_CcNode,
-                                   t_Handle h_Manip,
-                                   t_Handle h_FrmReplic)
+static void FillAdOfTypeContLookup(t_Handle                 h_Ad,
+                                   t_FmPcdCcStatsParams     *p_FmPcdCcStatsParams,
+                                   t_Handle                 h_FmPcd,
+                                   t_Handle                 p_CcNode,
+                                   t_Handle                 h_Manip,
+                                   t_Handle                 h_FrmReplic)
 {
     t_FmPcdCcNode           *p_Node = (t_FmPcdCcNode *)p_CcNode;
     t_AdOfTypeContLookup    *p_AdContLookup = (t_AdOfTypeContLookup *)h_Ad;
-    t_AdOfTypeStats         *p_StatsAd = (t_AdOfTypeStats *)h_StatsAd;
     t_Handle                h_TmpAd;
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    uint32_t                tmpReg32, statsFLRsAddr = 0;
+    uint32_t                tmpReg32;
     t_Handle                p_AdNewPtr = NULL;
 
     UNUSED(h_Manip);
@@ -286,24 +297,23 @@ static void FillAdOfTypeContLookup(t_Handle h_Ad,
     p_AdNewPtr = p_AdContLookup;
 
     /* Initialize an action descriptor, if current statistics mode requires an Ad */
-    if (h_StatsAd)
+    if (p_FmPcdCcStatsParams)
     {
+        ASSERT_COND(p_FmPcdCcStatsParams->h_StatsAd);
+        ASSERT_COND(p_FmPcdCcStatsParams->h_StatsCounters);
+
         /* Swapping addresses between statistics Ad and the current lookup AD */
-        h_TmpAd = p_StatsAd;
-        p_StatsAd = h_Ad;
+        h_TmpAd = p_FmPcdCcStatsParams->h_StatsAd;
+        p_FmPcdCcStatsParams->h_StatsAd = h_Ad;
         h_Ad = h_TmpAd;
 
         p_AdNewPtr = h_Ad;
         p_AdContLookup = h_Ad;
 
-        if (h_StatsFLRs)
-            statsFLRsAddr = (uint32_t)((XX_VirtToPhys(h_StatsFLRs) - p_FmPcd->physicalMuramBase));
-
         /* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
-        UpdateStatsAd(p_StatsAd,
-                      (uint32_t)((XX_VirtToPhys(h_StatsCounters) - p_FmPcd->physicalMuramBase)),
-                      (uint32_t)((XX_VirtToPhys(h_Ad) - p_FmPcd->physicalMuramBase)),
-                      statsFLRsAddr);
+        UpdateStatsAd(p_FmPcdCcStatsParams,
+                      h_Ad,
+                      p_FmPcd->physicalMuramBase);
     }
 
 #if DPAA_VERSION >= 11
@@ -356,7 +366,7 @@ static void FillAdOfTypeContLookup(t_Handle h_Ad,
     }
 }
 
-static t_Error FmPcdCcAllocAndFillAdForContLookupManip(t_Handle h_CcNode)
+static t_Error AllocAndFillAdForContLookupManip(t_Handle h_CcNode)
 {
     t_FmPcdCcNode       *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     uint32_t            intFlags;
@@ -373,15 +383,13 @@ static t_Error FmPcdCcAllocAndFillAdForContLookupManip(t_Handle h_CcNode)
 
         XX_UnlockIntrSpinlock(p_CcNode->h_Spinlock, intFlags);
 
-        if(!p_CcNode->h_Ad)
+        if (!p_CcNode->h_Ad)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
 
         IOMemSet32(p_CcNode->h_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
         FillAdOfTypeContLookup(p_CcNode->h_Ad,
                                NULL,
-                               NULL,
-                               NULL,
                                p_CcNode->h_FmPcd,
                                p_CcNode,
                                NULL,
@@ -393,12 +401,12 @@ static t_Error FmPcdCcAllocAndFillAdForContLookupManip(t_Handle h_CcNode)
     return E_OK;
 }
 
-static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_FmPcd,
-                                        uint32_t                            requiredAction,
-                                        t_FmPcdCcKeyAndNextEngineParams     *p_CcKeyAndNextEngineParamsTmp,
-                                        t_Handle                            h_AdTmp,
-                                        uint16_t                            numOfEntries,
-                                        t_Handle                            h_Tree)
+static t_Error SetRequiredAction(t_Handle                            h_FmPcd,
+                                 uint32_t                            requiredAction,
+                                 t_FmPcdCcKeyAndNextEngineParams     *p_CcKeyAndNextEngineParamsTmp,
+                                 t_Handle                            h_AdTmp,
+                                 uint16_t                            numOfEntries,
+                                 t_Handle                            h_Tree)
 {
     t_AdOfTypeResult    *p_AdTmp = (t_AdOfTypeResult *)h_AdTmp;
     uint32_t            tmpReg32;
@@ -410,92 +418,97 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_Fm
     uint8_t             relativeSchemeId, physicalSchemeId;
     t_CcNodeInformation ccNodeInfo;
 
-     for(i = 0; i < numOfEntries; i++)
+     for (i = 0; i < numOfEntries; i++)
      {
-        if(i == 0)
+        if (i == 0)
             h_AdTmp = PTR_MOVE(h_AdTmp, i*FM_PCD_CC_AD_ENTRY_SIZE);
         else
             h_AdTmp = PTR_MOVE(h_AdTmp, FM_PCD_CC_AD_ENTRY_SIZE);
 
-        switch(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.nextEngine)
+        switch (p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.nextEngine)
         {
-            case(e_FM_PCD_CC):
-                if(requiredAction)
+            case (e_FM_PCD_CC):
+                if (requiredAction)
                 {
                     p_CcNode = p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.ccParams.h_CcNode;
                     ASSERT_COND(p_CcNode);
-                    if(p_CcNode->shadowAction == requiredAction)
+                    if (p_CcNode->shadowAction == requiredAction)
                         break;
-                    if((requiredAction & UPDATE_CC_WITH_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
+                    if ((requiredAction & UPDATE_CC_WITH_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE))
                     {
 
                         ASSERT_COND(LIST_NumOfObjs(&p_CcNode->ccTreesLst) == 0);
-                        if(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE)
+                        if (p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE)
                             p_CcNode->shadowAction &= ~UPDATE_CC_WITH_DELETE_TREE;
                         memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                         ccNodeInfo.h_CcNode = h_Tree;
                         EnqueueNodeInfoToRelevantLst(&p_CcNode->ccTreesLst, &ccNodeInfo, NULL);
                         p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_TREE;
                     }
-                    if((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
+                    if ((requiredAction & UPDATE_CC_WITH_DELETE_TREE) && !(p_CcNode->shadowAction & UPDATE_CC_WITH_DELETE_TREE))
                     {
                         ASSERT_COND(LIST_NumOfObjs(&p_CcNode->ccTreesLst) == 1);
-                        if(p_CcNode->shadowAction & UPDATE_CC_WITH_TREE)
+                        if (p_CcNode->shadowAction & UPDATE_CC_WITH_TREE)
                             p_CcNode->shadowAction &= ~UPDATE_CC_WITH_TREE;
                         DequeueNodeInfoFromRelevantLst(&p_CcNode->ccTreesLst, h_Tree, NULL);
                         p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= UPDATE_CC_WITH_DELETE_TREE;
                     }
-                    if(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
+                    if (p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine != e_FM_PCD_INVALID)
                         tmp  = (uint8_t)(p_CcNode->numOfKeys + 1);
                     else
                         tmp = p_CcNode->numOfKeys;
-                    err = FmPcdCcSetRequiredAction(h_FmPcd, requiredAction, p_CcNode->keyAndNextEngineParams, p_CcNode->h_AdTable, tmp, h_Tree);
-                    if(err != E_OK)
+                    err = SetRequiredAction(h_FmPcd,
+                                            requiredAction,
+                                            p_CcNode->keyAndNextEngineParams,
+                                            p_CcNode->h_AdTable,
+                                            tmp,
+                                            h_Tree);
+                    if (err != E_OK)
                         return err;
                     p_CcNode->shadowAction |= requiredAction;
                 }
                 break;
 
-            case(e_FM_PCD_KG):
-                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+            case (e_FM_PCD_KG):
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     physicalSchemeId = FmPcdKgGetSchemeId(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme);
                     relativeSchemeId = FmPcdKgGetRelativeSchemeId(h_FmPcd, physicalSchemeId);
-                    if(relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
+                    if (relativeSchemeId == FM_PCD_KG_NUM_OF_SCHEMES)
                         RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
                     if (!FmPcdKgIsSchemeValidSw(p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme))
                          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
-                    if(!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
+                    if (!KgIsSchemeAlwaysDirect(h_FmPcd, relativeSchemeId))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this action scheme has to be direct."));
                     err = FmPcdKgCcGetSetParams(h_FmPcd, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.kgParams.h_DirectScheme, requiredAction, 0);
-                    if(err != E_OK)
+                    if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
                 }
                 break;
 
-            case(e_FM_PCD_PLCR):
-                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+            case (e_FM_PCD_PLCR):
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
-                    if(!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
+                    if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.overrideParams)
                         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
-                    if(!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
+                    if (!p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.sharedProfile)
                         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this initialization only overrideFqid can be initialized"));
                     err =  FmPcdPlcrGetAbsoluteIdByProfileParams(h_FmPcd, e_FM_PCD_PLCR_SHARED, NULL, p_CcKeyAndNextEngineParamsTmp[i].nextEngineParams.params.plcrParams.newRelativeProfileId, &profileId);
-                    if(err!= E_OK)
+                    if (err!= E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     err = FmPcdPlcrCcGetSetParams(h_FmPcd, profileId, requiredAction);
-                    if(err != E_OK)
+                    if (err != E_OK)
                         RETURN_ERROR(MAJOR, err, NO_MSG);
                     p_CcKeyAndNextEngineParamsTmp[i].shadowAction |= requiredAction;
                 }
                 break;
 
-            case(e_FM_PCD_DONE):
-                if((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
+            case (e_FM_PCD_DONE):
+                if ((requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA) && !(p_CcKeyAndNextEngineParamsTmp[i].shadowAction & UPDATE_NIA_ENQ_WITHOUT_DMA))
                 {
                     tmpReg32 = GET_UINT32(p_AdTmp->nia);
-                    if((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)) != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
+                    if ((tmpReg32 & GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)) != GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine was previously assigned not as PCD_DONE"));
                     tmpReg32 |= NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA;
                     WRITE_UINT32(p_AdTmp->nia, tmpReg32);
@@ -511,12 +524,12 @@ static t_Error FmPcdCcSetRequiredAction(t_Handle                            h_Fm
      return E_OK;
 }
 
-static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle                            h_FmPcd,
-                                                   t_List                              *h_FmPcdOldPointersLst,
-                                                   t_List                              *h_FmPcdNewPointersLst,
-                                                   uint16_t                            numOfGoodChanges,
-                                                   t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalParams,
-                                                   bool                                useShadowStructs)
+static t_Error ReleaseModifiedDataStructure(t_Handle                            h_FmPcd,
+                                            t_List                              *h_FmPcdOldPointersLst,
+                                            t_List                              *h_FmPcdNewPointersLst,
+                                            uint16_t                            numOfGoodChanges,
+                                            t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalParams,
+                                            bool                                useShadowStructs)
 {
     t_List                  *p_Pos;
     t_Error                 err = E_OK;
@@ -560,7 +573,7 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
                                          &ccNodeInfo,
                                          p_FmPcdCcNextNode->h_Spinlock);
         }
-        if(p_AdditionalParams->h_ManipForAdd)
+        if (p_AdditionalParams->h_ManipForAdd)
         {
             p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForAdd),
                                                              p_AdditionalParams->h_CurrentNode,
@@ -595,24 +608,24 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
 
                 ASSERT_COND(p_CcNodeInformation->h_CcNode);
 
-                err = FmPcdCcSetRequiredAction(h_FmPcd,
-                                               UPDATE_CC_WITH_DELETE_TREE,
-                                               &((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
-                                               PTR_MOVE(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable, p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                               1,
-                                               p_CcNodeInformation->h_CcNode);
+                err = SetRequiredAction(h_FmPcd,
+                                        UPDATE_CC_WITH_DELETE_TREE,
+                                        &((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
+                                        PTR_MOVE(((t_FmPcdCcNode *)(p_AdditionalParams->h_CurrentNode))->h_AdTable, p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                        1,
+                                        p_CcNodeInformation->h_CcNode);
             }
         }
         else
         {
             p_UpdateLst = &p_FmPcdCcNextNode->ccTreeIdLst;
 
-            err = FmPcdCcSetRequiredAction(h_FmPcd,
-                                           UPDATE_CC_WITH_DELETE_TREE,
-                                           &((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
-                                           UINT_TO_PTR(((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->ccTreeBaseAddr + p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                           1,
-                                           p_AdditionalParams->h_CurrentNode);
+            err = SetRequiredAction(h_FmPcd,
+                                    UPDATE_CC_WITH_DELETE_TREE,
+                                    &((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->keyAndNextEngineParams[p_AdditionalParams->savedKeyIndex],
+                                    UINT_TO_PTR(((t_FmPcdCcTree *)(p_AdditionalParams->h_CurrentNode))->ccTreeBaseAddr + p_AdditionalParams->savedKeyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                    1,
+                                    p_AdditionalParams->h_CurrentNode);
         }
         if (err)
             return err;
@@ -636,7 +649,7 @@ static t_Error FmPcdCcReleaseModifiedDataStructure(t_Handle
 
         UpdateNodeOwner(p_FmPcdCcNextNode, FALSE);
 
-        if(p_AdditionalParams->h_ManipForRmv)
+        if (p_AdditionalParams->h_ManipForRmv)
         {
              p_CcNodeInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(p_AdditionalParams->h_ManipForRmv),
                                                              p_AdditionalParams->h_CurrentNode,
@@ -738,7 +751,7 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     t_FmPcdCcNode   *p_FmPcdCcNodeTmp;
 
     p_FmPcdCcNodeTmp = (t_FmPcdCcNode*)XX_Malloc(sizeof(t_FmPcdCcNode));
-    if(!p_FmPcdCcNodeTmp)
+    if (!p_FmPcdCcNodeTmp)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_FmPcdCcNodeTmp"));
         return NULL;
@@ -763,7 +776,7 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     {
         if (p_FmPcdCcNextEngineParams->h_Manip)
         {
-            if (FmPcdCcAllocAndFillAdForContLookupManip(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)!= E_OK)
+            if (AllocAndFillAdForContLookupManip(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)!= E_OK)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
                 return NULL;
@@ -771,8 +784,6 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
         }
         FillAdOfTypeContLookup(h_Ad,
                                NULL,
-                               NULL,
-                               NULL,
                                p_CcNode->h_FmPcd,
                                p_FmPcdCcNodeTmp,
                                p_FmPcdCcNextEngineParams->h_Manip,
@@ -785,8 +796,6 @@ static t_Handle BuildNewAd(t_Handle                             h_Ad,
     {
         FillAdOfTypeContLookup(h_Ad,
                                NULL,
-                               NULL,
-                               NULL,
                                p_CcNode->h_FmPcd,
                                p_FmPcdCcNodeTmp,
                                p_FmPcdCcNextEngineParams->h_Manip,
@@ -824,27 +833,27 @@ static t_Error DynamicChangeHc(t_Handle                             h_FmPcd,
     newAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd, p_PosNew);
     if (newAdAddrOffset == (uint32_t)ILLEGAL_BASE)
     {
-        FmPcdCcReleaseModifiedDataStructure(h_FmPcd,
-                                            h_OldPointersLst,
-                                            h_NewPointersLst,
-                                            0,
-                                            p_AdditionalParams,
-                                            useShadowStructs);
+        ReleaseModifiedDataStructure(h_FmPcd,
+                                     h_OldPointersLst,
+                                     h_NewPointersLst,
+                                     0,
+                                     p_AdditionalParams,
+                                     useShadowStructs);
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("New AD address"));
     }
 
-    for (i = 0; i < numOfModifiedPtr; i++)
+    for (i=0; i<numOfModifiedPtr; i++)
     {
         /* Retrieve address of current AD */
         oldAdAddrOffset = FmPcdCcGetNodeAddrOffsetFromNodeInfo(h_FmPcd, p_PosOld);
         if (oldAdAddrOffset == (uint32_t)ILLEGAL_BASE)
         {
-            FmPcdCcReleaseModifiedDataStructure(h_FmPcd,
-                                                h_OldPointersLst,
-                                                h_NewPointersLst,
-                                                i,
-                                                p_AdditionalParams,
-                                                useShadowStructs);
+            ReleaseModifiedDataStructure(h_FmPcd,
+                                         h_OldPointersLst,
+                                         h_NewPointersLst,
+                                         i,
+                                         p_AdditionalParams,
+                                         useShadowStructs);
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old AD address"));
         }
 
@@ -852,12 +861,12 @@ static t_Error DynamicChangeHc(t_Handle                             h_FmPcd,
         err = FmHcPcdCcDoDynamicChange(((t_FmPcd *)h_FmPcd)->h_Hc, oldAdAddrOffset, newAdAddrOffset);
         if (err)
         {
-            FmPcdCcReleaseModifiedDataStructure(h_FmPcd,
-                                                h_OldPointersLst,
-                                                h_NewPointersLst,
-                                                i,
-                                                p_AdditionalParams,
-                                                useShadowStructs);
+            ReleaseModifiedDataStructure(h_FmPcd,
+                                         h_OldPointersLst,
+                                         h_NewPointersLst,
+                                         i,
+                                         p_AdditionalParams,
+                                         useShadowStructs);
             RETURN_ERROR(MAJOR, err, ("For part of nodes changes are done - situation is danger"));
         }
 
@@ -934,12 +943,12 @@ static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
-    err = FmPcdCcReleaseModifiedDataStructure(h_FmPcd,
-                                              h_OldPointersLst,
-                                              h_NewPointersLst,
-                                              numOfModifiedPtr,
-                                              p_AdditionalParams,
-                                              useShadowStructs);
+    err = ReleaseModifiedDataStructure(h_FmPcd,
+                                       h_OldPointersLst,
+                                       h_NewPointersLst,
+                                       numOfModifiedPtr,
+                                       p_AdditionalParams,
+                                       useShadowStructs);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
@@ -947,7 +956,7 @@ static t_Error DoDynamicChange(t_Handle                             h_FmPcd,
 }
 
 #ifdef FM_CAPWAP_SUPPORT
-static bool FmPcdCcIsCapwapApplSpecific(t_Handle h_Node)
+static bool IsCapwapApplSpecific(t_Handle h_Node)
 {
     t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_Node;
     bool    isManipForCapwapApplSpecificBuild = FALSE;
@@ -955,9 +964,9 @@ static bool FmPcdCcIsCapwapApplSpecific(t_Handle h_Node)
 
     ASSERT_COND(h_Node);
     /* assumption that this function called only for INDEXED_FLOW_ID - so no miss*/
-    for(i = 0; i < p_CcNode->numOfKeys; i++)
+    for (i = 0; i < p_CcNode->numOfKeys; i++)
     {
-        if( p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip &&
+        if ( p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip &&
             FmPcdManipIsCapwapApplSpecific(p_CcNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip))
         {
             isManipForCapwapApplSpecificBuild = TRUE;
@@ -1005,7 +1014,7 @@ static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
 
     if (numOfEntries)
     {
-        for (i = 0; i < numOfEntries; i++)
+        for (i=0; i<numOfEntries; i++)
         {
             if (i == 0)
                 h_Ad = PTR_MOVE(h_Ad, i*FM_PCD_CC_AD_ENTRY_SIZE);
@@ -1017,7 +1026,7 @@ static t_Error CcUpdateParam(t_Handle                           h_FmPcd,
                 p_CcNode = p_CcKeyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
                 ASSERT_COND(p_CcNode);
 
-                if(p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
+                if (p_CcKeyAndNextEngineParams[i].nextEngineParams.h_Manip)
                 {
                     err = FmPcdManipUpdate(h_FmPcd,
                                            NULL,
@@ -1077,23 +1086,23 @@ static ccPrivateInfo_t IcDefineCode(t_FmPcdCcNodeParams *p_CcNodeParam)
 {
     switch (p_CcNodeParam->extractCcParams.extractNonHdr.action)
     {
-        case(e_FM_PCD_ACTION_EXACT_MATCH):
-            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+        case (e_FM_PCD_ACTION_EXACT_MATCH):
+            switch (p_CcNodeParam->extractCcParams.extractNonHdr.src)
             {
-                case(e_FM_PCD_EXTRACT_FROM_KEY):
+                case (e_FM_PCD_EXTRACT_FROM_KEY):
                     return CC_PRIVATE_INFO_IC_KEY_EXACT_MATCH;
-                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                case (e_FM_PCD_EXTRACT_FROM_HASH):
                     return CC_PRIVATE_INFO_IC_HASH_EXACT_MATCH;
                 default:
                     return CC_PRIVATE_INFO_NONE;
             }
 
-        case(e_FM_PCD_ACTION_INDEXED_LOOKUP):
-            switch(p_CcNodeParam->extractCcParams.extractNonHdr.src)
+        case (e_FM_PCD_ACTION_INDEXED_LOOKUP):
+            switch (p_CcNodeParam->extractCcParams.extractNonHdr.src)
             {
-                case(e_FM_PCD_EXTRACT_FROM_HASH):
+                case (e_FM_PCD_EXTRACT_FROM_HASH):
                     return CC_PRIVATE_INFO_IC_HASH_INDEX_LOOKUP;
-                case(e_FM_PCD_EXTRACT_FROM_FLOW_ID):
+                case (e_FM_PCD_EXTRACT_FROM_FLOW_ID):
                     return CC_PRIVATE_INFO_IC_DEQ_FQID_INDEX_LOOKUP;
                 default:
                   return  CC_PRIVATE_INFO_NONE;
@@ -1123,7 +1132,7 @@ void ReleaseLst(t_List *p_List)
 {
     t_CcNodeInformation   *p_CcNodeInfo = NULL;
 
-    if(!LIST_IsEmpty(p_List))
+    if (!LIST_IsEmpty(p_List))
     {
         p_CcNodeInfo = DequeueAdditionalInfoFromRelevantLst(p_List);
         while (p_CcNodeInfo)
@@ -1204,9 +1213,9 @@ static void DeleteNode(t_FmPcdCcNode *p_CcNode)
 
 static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
 {
-    if(p_FmPcdTree)
+    if (p_FmPcdTree)
     {
-        if(p_FmPcdTree->ccTreeBaseAddr)
+        if (p_FmPcdTree->ccTreeBaseAddr)
         {
             FM_MURAM_FreeMem(FmPcdGetMuramHandle(p_FmPcd), UINT_TO_PTR(p_FmPcdTree->ccTreeBaseAddr));
             p_FmPcdTree->ccTreeBaseAddr = 0;
@@ -1220,25 +1229,25 @@ static void DeleteTree(t_FmPcdCcTree *p_FmPcdTree, t_FmPcd *p_FmPcd)
 
 static void  GetCcExtractKeySize(uint8_t parseCodeRealSize, uint8_t *parseCodeCcSize)
 {
-    if((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
+    if ((parseCodeRealSize > 0) && (parseCodeRealSize < 2))
         *parseCodeCcSize = 1;
-    else if(parseCodeRealSize == 2)
+    else if (parseCodeRealSize == 2)
         *parseCodeCcSize = 2;
-    else if((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
+    else if ((parseCodeRealSize > 2)    && (parseCodeRealSize <= 4))
         *parseCodeCcSize = 4;
-    else if((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
+    else if ((parseCodeRealSize > 4)    && (parseCodeRealSize <= 8))
         *parseCodeCcSize = 8;
-    else if((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
+    else if ((parseCodeRealSize > 8)    && (parseCodeRealSize <= 16))
         *parseCodeCcSize = 16;
-    else if((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
+    else if ((parseCodeRealSize  > 16)  && (parseCodeRealSize <= 24))
         *parseCodeCcSize = 24;
-    else if((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
+    else if ((parseCodeRealSize  > 24)  && (parseCodeRealSize <= 32))
         *parseCodeCcSize = 32;
-    else if((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
+    else if ((parseCodeRealSize  > 32)  && (parseCodeRealSize <= 40))
         *parseCodeCcSize = 40;
-    else if((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
+    else if ((parseCodeRealSize  > 40)  && (parseCodeRealSize <= 48))
         *parseCodeCcSize = 48;
-    else if((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
+    else if ((parseCodeRealSize  > 48)  && (parseCodeRealSize <= 56))
         *parseCodeCcSize = 56;
     else
         *parseCodeCcSize = 0;
@@ -1368,10 +1377,25 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             }
             break;
 
-        case (HEADER_TYPE_GRE):
+       case (HEADER_TYPE_IP):
+           switch (field.ip)
+           {
+               case (NET_HEADER_FIELD_IP_DSCP):
+               case (NET_HEADER_FIELD_IP_PROTO):
+                   *parseCodeRealSize = 1;
+                   break;
+
+               default:
+                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported5"));
+                   *parseCodeRealSize = CC_SIZE_ILLEGAL;
+                   break;
+           }
+           break;
+
+       case (HEADER_TYPE_GRE):
             switch (field.gre)
             {
-                case( NET_HEADER_FIELD_GRE_TYPE):
+                case ( NET_HEADER_FIELD_GRE_TYPE):
                    *parseCodeRealSize = 2;
                     break;
 
@@ -1383,7 +1407,7 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
             break;
 
         case (HEADER_TYPE_MINENCAP):
-            switch(field.minencap)
+            switch (field.minencap)
             {
                 case (NET_HEADER_FIELD_MINENCAP_TYPE):
                    *parseCodeRealSize = 1;
@@ -1452,13 +1476,13 @@ static void  GetSizeHeaderField(e_NetHeaderType     hdr,
 
 t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
                                  t_FmPcdCcNextEngineParams  *p_FmPcdCcNextEngineParams,
-                                 e_FmPcdCcStatsMode         supportedStatsMode)
+                                 e_FmPcdCcStatsMode         statsMode)
 {
     uint16_t    absoluteProfileId;
     t_Error     err = E_OK;
     uint8_t     relativeSchemeId;
 
-    if ((supportedStatsMode == e_FM_PCD_CC_STATS_MODE_NONE) &&
+    if ((statsMode == e_FM_PCD_CC_STATS_MODE_NONE) &&
         (p_FmPcdCcNextEngineParams->statisticsEn))
         RETURN_ERROR(MAJOR, E_CONFLICT,
                      ("Statistics are requested for a key, but statistics mode was set"
@@ -1467,17 +1491,18 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
     switch (p_FmPcdCcNextEngineParams->nextEngine)
     {
          case (e_FM_PCD_INVALID):
-             err = E_NOT_SUPPORTED;
-             break;
+            err = E_NOT_SUPPORTED;
+            break;
 
          case (e_FM_PCD_DONE):
-             if (p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME &&
-                     p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid) {
-                 if (!p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid)
-                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("overrideFqid defined, but not newFqid."));
-                 if (p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
-                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
-             }
+            if ((p_FmPcdCcNextEngineParams->params.enqueueParams.action == e_FM_PCD_ENQ_FRAME) &&
+                p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+            {
+                if (!p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid)
+                    RETURN_ERROR(MAJOR, E_CONFLICT, ("When overrideFqid is set, newFqid must not be zero"));
+                if (p_FmPcdCcNextEngineParams->params.enqueueParams.newFqid & ~0x00FFFFFF)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidForCtrlFlow must be between 1 and 2^24-1"));
+            }
             break;
 
         case (e_FM_PCD_KG):
@@ -1491,7 +1516,7 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("CC Node may point only to a scheme that is always direct."));
             break;
 
-        case(e_FM_PCD_PLCR):
+        case (e_FM_PCD_PLCR):
             if (p_FmPcdCcNextEngineParams->params.plcrParams.overrideParams)
             {
                 /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
@@ -1507,17 +1532,11 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
                     if (!FmPcdPlcrIsProfileValid(h_FmPcd, absoluteProfileId))
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile"));
                 }
-                else
-                {
-                }
-                /* TODO - add check according to the revision of the chip.
-                if(!p_FmPcdCcNextEngineParams->params.plcrParams.newFqid ||
-                   (p_FmPcdCcNextEngineParams->params.plcrParams.newFqid & ~0x00FFFFFF))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("newFqid  must be between 1 and 2^24-1"));
-                */
             }
             break;
 
+        case (e_FM_PCD_HASH):
+            p_FmPcdCcNextEngineParams->nextEngine = e_FM_PCD_CC;
         case (e_FM_PCD_CC):
             if (!p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
                 RETURN_ERROR(MAJOR, E_NULL_POINTER, ("handler to next Node is NULL"));
@@ -1534,6 +1553,7 @@ t_Error ValidateNextEngineParams(t_Handle                   h_FmPcd,
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next engine is not correct"));
     }
 
+
     return err;
 }
 
@@ -1602,28 +1622,27 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                                      e_FmPcdHdrIndex    index,
                                      t_FmPcdFields      field)
 {
+    switch (hdr)
+    {
+        case (HEADER_TYPE_NONE):
+            ASSERT_COND(FALSE);
+            return CC_PC_ILLEGAL;
 
-      switch (hdr)
-        {
-            case(HEADER_TYPE_NONE):
-                ASSERT_COND(FALSE);
-                return CC_PC_ILLEGAL;
-
-       case (HEADER_TYPE_ETH):
-                switch(field.eth)
-                {
-                    case(NET_HEADER_FIELD_ETH_DA):
-                        return CC_PC_FF_MACDST;
-                    case(NET_HEADER_FIELD_ETH_SA):
-                         return CC_PC_FF_MACSRC;
-                    case(NET_HEADER_FIELD_ETH_TYPE):
-                         return CC_PC_FF_ETYPE;
-                    default:
-                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                        return CC_PC_ILLEGAL;
-                }
+        case (HEADER_TYPE_ETH):
+            switch (field.eth)
+            {
+                case (NET_HEADER_FIELD_ETH_DA):
+                    return CC_PC_FF_MACDST;
+                case (NET_HEADER_FIELD_ETH_SA):
+                    return CC_PC_FF_MACSRC;
+                case (NET_HEADER_FIELD_ETH_TYPE):
+                    return CC_PC_FF_ETYPE;
+                default:
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
+            }
 
-         case (HEADER_TYPE_VLAN):
+        case (HEADER_TYPE_VLAN):
             switch (field.vlan)
             {
                 case (NET_HEADER_FIELD_VLAN_TCI):
@@ -1633,10 +1652,9 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                         return CC_PC_FF_TCI2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-
                 default:
-                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                        return CC_PC_ILLEGAL;
+                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                    return CC_PC_ILLEGAL;
             }
 
         case (HEADER_TYPE_MPLS):
@@ -1649,11 +1667,10 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                         return CC_PC_FF_MPLS_LAST;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
                     return CC_PC_ILLEGAL;
-
-               default:
+                default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
-             }
+            }
 
         case (HEADER_TYPE_IPv4):
             switch (field.ipv4)
@@ -1665,7 +1682,6 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                         return CC_PC_FF_IPV4DST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-
                 case (NET_HEADER_FIELD_IPv4_TOS):
                     if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4IPTOS_TC1;
@@ -1673,15 +1689,12 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                         return CC_PC_FF_IPV4IPTOS_TC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-
                 case (NET_HEADER_FIELD_IPv4_PROTO):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4PTYPE1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV4PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-
                 case (NET_HEADER_FIELD_IPv4_SRC_IP):
                     if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4SRC1;
@@ -1689,7 +1702,6 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                         return CC_PC_FF_IPV4SRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-
                 case (NET_HEADER_FIELD_IPv4_SRC_IP | NET_HEADER_FIELD_IPv4_DST_IP):
                     if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return CC_PC_FF_IPV4SRC1_IPV4DST1;
@@ -1697,10 +1709,8 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                         return CC_PC_FF_IPV4SRC2_IPV4DST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return CC_PC_ILLEGAL;
-
                 case (NET_HEADER_FIELD_IPv4_TTL):
                     return CC_PC_FF_IPV4TTL;
-
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
@@ -1722,7 +1732,7 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                         return CC_PC_FF_IPV6PTYPE1;
                     if (index == e_FM_PCD_HDR_INDEX_2)
                         return CC_PC_FF_IPV6PTYPE2;
-                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return CC_PC_FF_IPPID;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return CC_PC_ILLEGAL;
@@ -1751,84 +1761,105 @@ static uint8_t GetFullFieldParseCode(e_NetHeaderType    hdr,
                     return CC_PC_ILLEGAL;
             }
 
-        case (HEADER_TYPE_GRE):
-            switch (field.gre)
-            {
-                case (NET_HEADER_FIELD_GRE_TYPE):
-                    return CC_PC_FF_GREPTYPE;
+       case (HEADER_TYPE_IP):
+           switch (field.ip)
+           {
+               case (NET_HEADER_FIELD_IP_DSCP):
+                   if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                       return CC_PC_FF_IPDSCP;
+                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
+                   return CC_PC_ILLEGAL;
+
+               case (NET_HEADER_FIELD_IP_PROTO):
+                   if (index == e_FM_PCD_HDR_INDEX_LAST)
+                       return CC_PC_FF_IPPID;
+                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP index"));
+                   return CC_PC_ILLEGAL;
 
-                default:
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                    return CC_PC_ILLEGAL;
+               default:
+                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                   return CC_PC_ILLEGAL;
            }
-        case (HEADER_TYPE_MINENCAP):
-            switch (field.minencap)
-            {
-                case (NET_HEADER_FIELD_MINENCAP_TYPE):
-                    return CC_PC_FF_MINENCAP_PTYPE;
 
-                case (NET_HEADER_FIELD_MINENCAP_DST_IP):
-                    return CC_PC_FF_MINENCAP_IPDST;
+       case (HEADER_TYPE_GRE):
+           switch (field.gre)
+           {
+               case (NET_HEADER_FIELD_GRE_TYPE):
+                   return CC_PC_FF_GREPTYPE;
 
-                case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
-                    return CC_PC_FF_MINENCAP_IPSRC;
+               default:
+                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                   return CC_PC_ILLEGAL;
+           }
 
-                case (NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
-                    return CC_PC_FF_MINENCAP_IPSRC_IPDST;
+       case (HEADER_TYPE_MINENCAP):
+           switch (field.minencap)
+           {
+               case (NET_HEADER_FIELD_MINENCAP_TYPE):
+                   return CC_PC_FF_MINENCAP_PTYPE;
 
-                default:
+               case (NET_HEADER_FIELD_MINENCAP_DST_IP):
+                   return CC_PC_FF_MINENCAP_IPDST;
+
+               case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                   return CC_PC_FF_MINENCAP_IPSRC;
+
+               case (NET_HEADER_FIELD_MINENCAP_SRC_IP | NET_HEADER_FIELD_MINENCAP_DST_IP):
+                   return CC_PC_FF_MINENCAP_IPSRC_IPDST;
+
+               default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return CC_PC_ILLEGAL;
            }
 
-        case (HEADER_TYPE_TCP):
-            switch (field.tcp)
-            {
-                case (NET_HEADER_FIELD_TCP_PORT_SRC):
-                    return CC_PC_FF_L4PSRC;
+       case (HEADER_TYPE_TCP):
+           switch (field.tcp)
+           {
+               case (NET_HEADER_FIELD_TCP_PORT_SRC):
+                   return CC_PC_FF_L4PSRC;
 
-                case (NET_HEADER_FIELD_TCP_PORT_DST):
-                    return CC_PC_FF_L4PDST;
+               case (NET_HEADER_FIELD_TCP_PORT_DST):
+                   return CC_PC_FF_L4PDST;
 
-                case (NET_HEADER_FIELD_TCP_PORT_DST | NET_HEADER_FIELD_TCP_PORT_SRC):
-                    return CC_PC_FF_L4PSRC_L4PDST;
+               case (NET_HEADER_FIELD_TCP_PORT_DST | NET_HEADER_FIELD_TCP_PORT_SRC):
+                   return CC_PC_FF_L4PSRC_L4PDST;
 
-                default:
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                    return CC_PC_ILLEGAL;
-            }
+               default:
+                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                   return CC_PC_ILLEGAL;
+           }
 
-        case (HEADER_TYPE_PPPoE):
-            switch (field.pppoe)
-            {
-                case (NET_HEADER_FIELD_PPPoE_PID):
-                    return CC_PC_FF_PPPPID;
+       case (HEADER_TYPE_PPPoE):
+           switch (field.pppoe)
+           {
+               case (NET_HEADER_FIELD_PPPoE_PID):
+                   return CC_PC_FF_PPPPID;
 
-                default:
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                    return CC_PC_ILLEGAL;
-            }
+               default:
+                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                   return CC_PC_ILLEGAL;
+           }
 
-        case (HEADER_TYPE_UDP):
-            switch (field.udp)
-            {
-                case (NET_HEADER_FIELD_UDP_PORT_SRC):
-                    return CC_PC_FF_L4PSRC;
+       case (HEADER_TYPE_UDP):
+           switch (field.udp)
+           {
+               case (NET_HEADER_FIELD_UDP_PORT_SRC):
+                   return CC_PC_FF_L4PSRC;
 
-                case (NET_HEADER_FIELD_UDP_PORT_DST):
-                    return CC_PC_FF_L4PDST;
+               case (NET_HEADER_FIELD_UDP_PORT_DST):
+                   return CC_PC_FF_L4PDST;
 
-                case (NET_HEADER_FIELD_UDP_PORT_DST | NET_HEADER_FIELD_UDP_PORT_SRC):
-                    return CC_PC_FF_L4PSRC_L4PDST;
+               case (NET_HEADER_FIELD_UDP_PORT_DST | NET_HEADER_FIELD_UDP_PORT_SRC):
+                   return CC_PC_FF_L4PSRC_L4PDST;
 
-                default:
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                    return CC_PC_ILLEGAL;
-            }
+               default:
+                   REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                   return CC_PC_ILLEGAL;
+           }
 
-         default:
-            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-            return CC_PC_ILLEGAL;
+        default:
+           REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+           return CC_PC_ILLEGAL;
     }
 }
 
@@ -1871,7 +1902,7 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
             *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
             break;
 
-        case(HEADER_TYPE_PPPoE):
+        case (HEADER_TYPE_PPPoE):
             *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
             break;
 
@@ -1900,20 +1931,20 @@ static uint8_t GetPrParseCode(e_NetHeaderType   hdr,
             }
             break;
 
-        case(HEADER_TYPE_MINENCAP):
+        case (HEADER_TYPE_MINENCAP):
             *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
             break;
 
-        case(HEADER_TYPE_GRE):
+        case (HEADER_TYPE_GRE):
             *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
             break;
 
-        case(HEADER_TYPE_TCP):
-        case(HEADER_TYPE_UDP):
-        case(HEADER_TYPE_IPSEC_AH):
-        case(HEADER_TYPE_IPSEC_ESP):
-        case(HEADER_TYPE_DCCP):
-        case(HEADER_TYPE_SCTP):
+        case (HEADER_TYPE_TCP):
+        case (HEADER_TYPE_UDP):
+        case (HEADER_TYPE_IPSEC_AH):
+        case (HEADER_TYPE_IPSEC_ESP):
+        case (HEADER_TYPE_DCCP):
+        case (HEADER_TYPE_SCTP):
             *parseArrayOffset = CC_PC_PR_L4_OFFSET;
             break;
 
@@ -1983,17 +2014,14 @@ static uint8_t GetFieldParseCode(e_NetHeaderType    hdr,
         return CC_PR_WITHOUT_OFFSET;
 }
 
-void FillAdOfTypeResult(t_Handle                    h_Ad,
-                        t_Handle                    h_StatsAd,
-                        t_Handle                    h_StatsCounters,
-                        t_Handle                    h_StatsFLRs,
-                        t_FmPcd                     *p_FmPcd,
-                        t_FmPcdCcNextEngineParams   *p_CcNextEngineParams)
+static void FillAdOfTypeResult(t_Handle                    h_Ad,
+                               t_FmPcdCcStatsParams        *p_FmPcdCcStatsParams,
+                               t_FmPcd                     *p_FmPcd,
+                               t_FmPcdCcNextEngineParams   *p_CcNextEngineParams)
 {
     t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult *)h_Ad;
-    t_AdOfTypeStats     *p_StatsAd = (t_AdOfTypeStats *)h_StatsAd;
     t_Handle            h_TmpAd;
-    uint32_t            tmp = 0, tmpNia = 0, statsFLRsAddr = 0;
+    uint32_t            tmp = 0, tmpNia = 0;
     uint16_t            profileId;
     t_Handle            p_AdNewPtr = NULL;
 
@@ -2017,24 +2045,23 @@ void FillAdOfTypeResult(t_Handle                    h_Ad,
     p_AdNewPtr = p_AdResult;
 
     /* Initialize an action descriptor, if current statistics mode requires an Ad */
-    if (h_StatsAd)
+    if (p_FmPcdCcStatsParams)
     {
+        ASSERT_COND(p_FmPcdCcStatsParams->h_StatsAd);
+        ASSERT_COND(p_FmPcdCcStatsParams->h_StatsCounters);
+
         /* Swapping addresses between statistics Ad and the current lookup AD addresses */
-        h_TmpAd = p_StatsAd;
-        p_StatsAd = h_Ad;
+        h_TmpAd = p_FmPcdCcStatsParams->h_StatsAd;
+        p_FmPcdCcStatsParams->h_StatsAd = h_Ad;
         h_Ad = h_TmpAd;
 
         p_AdNewPtr = h_Ad;
         p_AdResult = h_Ad;
 
-        if (h_StatsFLRs)
-            statsFLRsAddr = (uint32_t)((XX_VirtToPhys(h_StatsFLRs) - p_FmPcd->physicalMuramBase));
-
         /* Init statistics Ad and connect current lookup AD as 'next action' from statistics Ad */
-        UpdateStatsAd(p_StatsAd,
-                      (uint32_t)((XX_VirtToPhys(h_StatsCounters) - p_FmPcd->physicalMuramBase)),
-                      (uint32_t)((XX_VirtToPhys(h_Ad) - p_FmPcd->physicalMuramBase)),
-                      statsFLRsAddr);
+        UpdateStatsAd(p_FmPcdCcStatsParams,
+                      h_Ad,
+                      p_FmPcd->physicalMuramBase);
     }
 
     /* Create manip and return p_AdNewPtr to either a new descriptor or NULL */
@@ -2166,71 +2193,14 @@ static t_Error CcUpdateParams(t_Handle      h_FmPcd,
                          FALSE);
 }
 
-void NextStepAd(t_Handle                     h_Ad,
-                t_Handle                     h_StatsAd,
-                t_Handle                     h_StatsCounters,
-                t_Handle                     h_StatsFLRs,
-                t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
-                t_FmPcd                      *p_FmPcd)
-{
-    switch(p_FmPcdCcNextEngineParams->nextEngine)
-    {
-        case(e_FM_PCD_KG):
-        case(e_FM_PCD_PLCR):
-        case(e_FM_PCD_DONE):
-            /* if NIA is not CC, create a "result" type AD */
-            FillAdOfTypeResult(h_Ad,
-                               h_StatsAd,
-                               h_StatsCounters,
-                               h_StatsFLRs,
-                               p_FmPcd,
-                               p_FmPcdCcNextEngineParams);
-            break;
-#if (DPAA_VERSION >= 11)
-        case(e_FM_PCD_FR):
-            if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
-            {
-                FillAdOfTypeContLookup(h_Ad,
-                                       h_StatsAd,
-                                       h_StatsCounters,
-                                       h_StatsFLRs,
-                                       p_FmPcd,
-                                       p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-                                       p_FmPcdCcNextEngineParams->h_Manip,
-                                       p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
-                FrmReplicGroupUpdateOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
-                                          TRUE/* add */);
-            }
-            break;
-#endif /* (DPAA_VERSION >= 11) */
-
-        case(e_FM_PCD_CC):
-            /* if NIA is not CC, create a TD to continue the CC lookup */
-            FillAdOfTypeContLookup(h_Ad,
-                                   h_StatsAd,
-                                   h_StatsCounters,
-                                   h_StatsFLRs,
-                                   p_FmPcd,
-                                   p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
-                                   p_FmPcdCcNextEngineParams->h_Manip,
-                                   NULL);
-
-            UpdateNodeOwner(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode, TRUE);
-            break;
-
-         default:
-             return;
-    }
-}
-
 
 static void ReleaseNewNodeCommonPart(t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalInfo)
 {
-    if(p_AdditionalInfo->p_AdTableNew)
+    if (p_AdditionalInfo->p_AdTableNew)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
                          p_AdditionalInfo->p_AdTableNew);
 
-    if(p_AdditionalInfo->p_KeysMatchTableNew)
+    if (p_AdditionalInfo->p_KeysMatchTableNew)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(((t_FmPcdCcNode *)(p_AdditionalInfo->h_CurrentNode))->h_FmPcd),
                          p_AdditionalInfo->p_KeysMatchTableNew);
 }
@@ -2297,7 +2267,6 @@ static __inline__ t_Handle GetNewAd(t_Handle  h_FmPcdCcNodeOrTree, bool isTree)
     else
         p_FmPcd = (t_FmPcd *)(((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_FmPcd);
 
-
     if ((isTree && p_FmPcd->p_CcShadow) ||
         (!isTree && ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->maxNumOfKeys))
     {
@@ -2403,13 +2372,13 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     t_Error                 err = E_OK;
     t_Handle                p_AdTableNewTmp, p_KeysMatchTableNewTmp;
     t_Handle                p_KeysMatchTableOldTmp, p_AdTableOldTmp;
-    t_Handle                h_StatsAd, h_StatsCounters;
     int                     size;
     int                     i = 0, j = 0;
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                requiredAction = 0;
     bool                    prvLclMask;
     t_CcNodeInformation     *p_CcNodeInformation;
+    t_FmPcdCcStatsParams    statsParams = {0};
     t_List                  *p_Pos;
     t_FmPcdStatsObj         *p_StatsObj;
 
@@ -2417,7 +2386,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     err = ValidateNextEngineParams(h_FmPcd,
                                    &p_KeyParams->ccNextEngineParams,
                                    p_CcNode->statisticsMode);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     prvLclMask = p_CcNode->lclMask;
@@ -2441,7 +2410,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
     if ((p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
         && p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.h_Manip)
     {
-        err = FmPcdCcAllocAndFillAdForContLookupManip(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode);
+        err = AllocAndFillAdForContLookupManip(p_AdditionalInfo->keyAndNextEngineParams[keyIndex].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -2467,10 +2436,10 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* Check that manip is legal and what requiredAction is necessary for this manip */
-    if(p_KeyParams->ccNextEngineParams.h_Manip)
+    if (p_KeyParams->ccNextEngineParams.h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(&p_KeyParams->ccNextEngineParams,&requiredAction);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
@@ -2499,23 +2468,28 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
                 ASSERT_COND(keyIndex < CC_MAX_NUM_OF_KEYS);
                 p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
 
-                h_StatsAd = p_StatsObj->h_StatsAd;
-                h_StatsCounters = p_StatsObj->h_StatsCounters;
+                statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
+                statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
+#if (DPAA_VERSION >= 11)
+                statsParams.h_StatsFLRs = p_CcNode->h_StatsFLRs;
+
+#endif /* (DPAA_VERSION >= 11) */
+
+                /* Building action descriptor for the received new key */
+                NextStepAd(p_AdTableNewTmp,
+                           &statsParams,
+                           &p_KeyParams->ccNextEngineParams,
+                           p_FmPcd);
             }
             else
             {
-                h_StatsAd = NULL;
-                h_StatsCounters = NULL;
+                /* Building action descriptor for the received new key */
+                NextStepAd(p_AdTableNewTmp,
+                           NULL,
+                           &p_KeyParams->ccNextEngineParams,
+                           p_FmPcd);
             }
 
-            /* Building action descriptor for the received new key */
-            NextStepAd(p_AdTableNewTmp,
-                       h_StatsAd,
-                       h_StatsCounters,
-                       p_CcNode->h_StatsFLRs,
-                       &p_KeyParams->ccNextEngineParams,
-                       p_FmPcd);
-
             /* Copy the received new key into keys match table */
             p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, j*size*sizeof(uint8_t));
 
@@ -2524,7 +2498,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
             /* Update mask for the received new key */
             if (p_CcNode->lclMask)
             {
-                if(p_KeyParams->p_Mask)
+                if (p_KeyParams->p_Mask)
                 {
                     Mem2IOCpy32(PTR_MOVE(p_KeysMatchTableNewTmp,
                                 p_CcNode->ccKeySizeAccExtraction),
@@ -2610,12 +2584,12 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
             ASSERT_COND(p_CcNodeInformation->h_CcNode);
             /* Update the manipulation which has to be updated from parameters of the port */
             /* It's has to be updated with restrictions defined in the function */
-            err = FmPcdCcSetRequiredAction(p_CcNode->h_FmPcd,
-                                           p_CcNode->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
-                                           &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                           PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
-                                           1,
-                                           p_CcNodeInformation->h_CcNode);
+            err = SetRequiredAction(p_CcNode->h_FmPcd,
+                                    p_CcNode->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                                    &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                    PTR_MOVE(p_AdditionalInfo->p_AdTableNew, keyIndex*FM_PCD_CC_AD_ENTRY_SIZE),
+                                    1,
+                                    p_CcNodeInformation->h_CcNode);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
 
@@ -2659,7 +2633,9 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(t_Handle
 
         /* If statistics were previously enabled, store the old statistics object to be released */
         if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
+        {
             p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+        }
 
 #if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
@@ -2700,12 +2676,13 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNod
         }
         if (j == p_CcNode->numOfKeys)
             break;
-         p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
-         p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
-         IO2IOCpy32(p_AdTableNewTmp,p_AdTableOldTmp,  FM_PCD_CC_AD_ENTRY_SIZE);
-         p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j * size * sizeof(uint8_t));
-         p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i * size * sizeof(uint8_t));
-         IO2IOCpy32(p_KeysMatchTableNewTmp,p_KeysMatchTableOldTmp,  size * sizeof(uint8_t));
+        p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
+        p_AdTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
+        IO2IOCpy32(p_AdTableNewTmp, p_AdTableOldTmp, FM_PCD_CC_AD_ENTRY_SIZE);
+
+        p_KeysMatchTableOldTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableOld, j * size * sizeof(uint8_t));
+        p_KeysMatchTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_KeysMatchTableNew, i * size * sizeof(uint8_t));
+        IO2IOCpy32(p_KeysMatchTableNewTmp, p_KeysMatchTableOldTmp, size * sizeof(uint8_t));
     }
 
     p_AdTableNewTmp = PTR_MOVE(p_AdditionalInfo->p_AdTableNew, i * FM_PCD_CC_AD_ENTRY_SIZE);
@@ -2722,8 +2699,9 @@ static t_Error BuildNewNodeRemoveKey(t_FmPcdCcNode                      *p_CcNod
 
     /* If statistics were previously enabled, store the old statistics object to be released */
     if (p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj)
-        p_AdditionalInfo->p_StatsObjForRmv =
-            p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+    {
+        p_AdditionalInfo->p_StatsObjForRmv = p_CcNode->keyAndNextEngineParams[keyIndex].p_StatsObj;
+    }
 
 #if (DPAA_VERSION >= 11)
         if ((p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_FR) &&
@@ -2891,14 +2869,15 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
                                             t_List                              *h_NewLst,
                                             t_FmPcdModifyCcKeyAdditionalParams  *p_AdditionalInfo)
 {
-    t_Error             err = E_OK;
-    uint32_t            requiredAction = 0;
-    t_List              *p_Pos;
-    t_CcNodeInformation *p_CcNodeInformation, ccNodeInfo;
-    t_Handle            p_Ad;
-    t_FmPcdCcNode       *p_FmPcdCcNode1 = NULL;
-    t_FmPcdCcTree       *p_FmPcdCcTree = NULL;
-    t_FmPcdStatsObj     *p_StatsObj;
+    t_Error                 err = E_OK;
+    uint32_t                requiredAction = 0;
+    t_List                  *p_Pos;
+    t_CcNodeInformation     *p_CcNodeInformation, ccNodeInfo;
+    t_Handle                p_Ad;
+    t_FmPcdCcNode           *p_FmPcdCcNode1 = NULL;
+    t_FmPcdCcTree           *p_FmPcdCcTree = NULL;
+    t_FmPcdStatsObj         *p_StatsObj;
+    t_FmPcdCcStatsParams    statsParams = {0};
 
     ASSERT_COND(p_CcNextEngineParams);
 
@@ -2932,7 +2911,6 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     {
         p_FmPcdCcNode1 = (t_FmPcdCcNode *)h_FmPcdCcNodeOrTree;
         p_AdditionalInfo->numOfKeys =  p_FmPcdCcNode1->numOfKeys;
-
         p_Ad = p_FmPcdCcNode1->h_AdTable;
 
         if (p_FmPcdCcNode1->keyAndNextEngineParams[keyIndex].nextEngineParams.nextEngine == e_FM_PCD_CC)
@@ -2970,7 +2948,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_CC)
         && p_CcNextEngineParams->h_Manip)
     {
-        err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNextEngineParams->params.ccParams.h_CcNode);
+        err = AllocAndFillAdForContLookupManip(p_CcNextEngineParams->params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3008,18 +2986,22 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
         /* Store allocated statistics object */
         p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = p_StatsObj;
 
+        statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
+        statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
+
+#if (DPAA_VERSION >= 11)
+        statsParams.h_StatsFLRs = ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_StatsFLRs;
+
+#endif /* (DPAA_VERSION >= 11) */
+
         NextStepAd(p_Ad,
-                   p_StatsObj->h_StatsAd,
-                   p_StatsObj->h_StatsCounters,
-                   ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->h_StatsFLRs,
+                   &statsParams,
                    p_CcNextEngineParams,
                    h_FmPcd);
     }
     else
         NextStepAd(p_Ad,
                    NULL,
-                   NULL,
-                   NULL,
                    p_CcNextEngineParams,
                    h_FmPcd);
 
@@ -3032,7 +3014,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     if (!p_AdditionalInfo->tree)
     {
         ASSERT_COND(p_FmPcdCcNode1);
-        if(!LIST_IsEmpty(&p_FmPcdCcNode1->ccTreesLst))
+        if (!LIST_IsEmpty(&p_FmPcdCcNode1->ccTreesLst))
         {
             LIST_FOR_EACH(p_Pos, &p_FmPcdCcNode1->ccTreesLst)
             {
@@ -3042,12 +3024,12 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
                 /* Update the manipulation which has to be updated from parameters of the port
                    it's has to be updated with restrictions defined in the function */
 
-                err = FmPcdCcSetRequiredAction(p_FmPcdCcNode1->h_FmPcd,
-                                               p_FmPcdCcNode1->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
-                                               &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                               p_Ad,
-                                               1,
-                                               p_CcNodeInformation->h_CcNode);
+                err = SetRequiredAction(p_FmPcdCcNode1->h_FmPcd,
+                                        p_FmPcdCcNode1->shadowAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                                        &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                                        p_Ad,
+                                        1,
+                                        p_CcNodeInformation->h_CcNode);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
 
@@ -3070,12 +3052,12 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
     {
        ASSERT_COND(p_FmPcdCcTree);
 
-       err = FmPcdCcSetRequiredAction(h_FmPcd,
-                                      p_FmPcdCcTree->requiredAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
-                                      &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
-                                      p_Ad,
-                                      1,
-                                      (t_Handle)p_FmPcdCcTree);
+       err = SetRequiredAction(h_FmPcd,
+                               p_FmPcdCcTree->requiredAction | p_AdditionalInfo->keyAndNextEngineParams[keyIndex].requiredAction,
+                               &p_AdditionalInfo->keyAndNextEngineParams[keyIndex],
+                               p_Ad,
+                               1,
+                               (t_Handle)p_FmPcdCcTree);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
@@ -3106,6 +3088,7 @@ static t_Error BuildNewNodeModifyNextEngine(t_Handle
         p_AdditionalInfo->p_StatsObjForRmv =
                 ((t_FmPcdCcNode *)h_FmPcdCcNodeOrTree)->keyAndNextEngineParams[keyIndex].p_StatsObj;
 
+
         p_AdditionalInfo->keyAndNextEngineParams[keyIndex].p_StatsObj = NULL;
     }
 #if (DPAA_VERSION >= 11)
@@ -3137,11 +3120,11 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
         ASSERT_COND(p_NodePtrOnCurrentMdfNode);
 
         /* Search in the previous node which exact index points on this current modified node for getting AD */
-        for(i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
+        for (i = 0; i < p_NodePtrOnCurrentMdfNode->numOfKeys + 1; i++)
         {
-            if(p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if(p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
                 {
                     if (p_NodePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.h_Manip)
                         p_AdTablePtOnCrntCurrentMdfNode = p_CrntMdfNode->h_Ad;
@@ -3185,11 +3168,11 @@ static void UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(t_FmPcdCcNode
         ASSERT_COND(p_TreePtrOnCurrentMdfNode);
 
         /*search in the trees which exact index points on this current modified node for getting AD */
-        for(i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
+        for (i = 0; i < p_TreePtrOnCurrentMdfNode->numOfEntries; i++)
         {
-            if(p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if(p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
+                if (p_TreePtrOnCurrentMdfNode->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode == (t_Handle)p_CrntMdfNode)
                 {
                     p_AdTableTmp = UINT_TO_PTR(p_TreePtrOnCurrentMdfNode->ccTreeBaseAddr + i*FM_PCD_CC_AD_ENTRY_SIZE);
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
@@ -3223,13 +3206,13 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcdCcNodeOrTree, E_INVALID_HANDLE, NULL);
 
-    p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*256);
+    p_KeyAndNextEngineParams = (t_FmPcdCcKeyAndNextEngineParams *)XX_Malloc(sizeof(t_FmPcdCcKeyAndNextEngineParams)*CC_MAX_NUM_OF_KEYS);
     if (!p_KeyAndNextEngineParams)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Next engine and required action structure"));
         return NULL;
     }
-    memset(p_KeyAndNextEngineParams, 0, sizeof(t_FmPcdCcKeyAndNextEngineParams)*256);
+    memset(p_KeyAndNextEngineParams, 0, sizeof(t_FmPcdCcKeyAndNextEngineParams)*CC_MAX_NUM_OF_KEYS);
 
     if (!tree)
     {
@@ -3245,7 +3228,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
             return NULL;
         }
 
-        if(!LIST_NumOfObjs(&p_CcNode->ccTreesLst) ||
+        if (!LIST_NumOfObjs(&p_CcNode->ccTreesLst) ||
            (LIST_NumOfObjs(&p_CcNode->ccTreesLst) != 1))
         {
             XX_Free(p_KeyAndNextEngineParams);
@@ -3255,11 +3238,11 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
 
         memcpy(p_KeyAndNextEngineParams,
                p_CcNode->keyAndNextEngineParams,
-               256 * sizeof(t_FmPcdCcKeyAndNextEngineParams));
+               CC_MAX_NUM_OF_KEYS * sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
-        if(ttlCheck)
+        if (ttlCheck)
         {
-            if((p_CcNode->parseCode == CC_PC_FF_IPV4TTL) ||
+            if ((p_CcNode->parseCode == CC_PC_FF_IPV4TTL) ||
                (p_CcNode->parseCode == CC_PC_FF_IPV6HOP_LIMIT))
             {
                 XX_Free(p_KeyAndNextEngineParams);
@@ -3268,9 +3251,9 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
             }
         }
 
-        if(hashCheck)
+        if (hashCheck)
         {
-            if(p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
+            if (p_CcNode->parseCode == CC_PC_GENERIC_IC_HASH_INDEXED)
             {
                 XX_Free(p_KeyAndNextEngineParams);
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("nodeId of CC_PC_GENERIC_IC_HASH_INDEXED can not be used for this operation"));
@@ -3289,7 +3272,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
 
     p_FmPcdModifyCcKeyAdditionalParams =
         (t_FmPcdModifyCcKeyAdditionalParams *)XX_Malloc(sizeof(t_FmPcdModifyCcKeyAdditionalParams));
-    if(!p_FmPcdModifyCcKeyAdditionalParams)
+    if (!p_FmPcdModifyCcKeyAdditionalParams)
     {
         XX_Free(p_KeyAndNextEngineParams);
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of internal data structure FAILED"));
@@ -3300,13 +3283,13 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
     p_FmPcdModifyCcKeyAdditionalParams->h_CurrentNode = h_FmPcdCcNodeOrTree;
     p_FmPcdModifyCcKeyAdditionalParams->savedKeyIndex = keyIndex;
 
-    while(i < numOfKeys)
+    while (i < numOfKeys)
     {
-        if((j == keyIndex) && !wasUpdate)
+        if ((j == keyIndex) && !wasUpdate)
         {
-            if(modifyState == e_MODIFY_STATE_ADD)
+            if (modifyState == e_MODIFY_STATE_ADD)
                 j++;
-            else if(modifyState == e_MODIFY_STATE_REMOVE)
+            else if (modifyState == e_MODIFY_STATE_REMOVE)
                 i++;
             wasUpdate = TRUE;
         }
@@ -3324,7 +3307,7 @@ static t_FmPcdModifyCcKeyAdditionalParams* ModifyKeyCommonPart1(t_Handle
     {
         if (modifyState == e_MODIFY_STATE_ADD)
             j++;
-        else if(modifyState == e_MODIFY_STATE_REMOVE)
+        else if (modifyState == e_MODIFY_STATE_REMOVE)
             i++;
     }
 
@@ -3347,10 +3330,10 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode
     t_Handle                    h_NewAd;
 
     /* Building a list of all action descriptors that point to the previous node */
-    if(!LIST_IsEmpty(&p_CcNode->ccPrevNodesLst))
+    if (!LIST_IsEmpty(&p_CcNode->ccPrevNodesLst))
         UpdateAdPtrOfNodesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
 
-    if(!LIST_IsEmpty(&p_CcNode->ccTreeIdLst))
+    if (!LIST_IsEmpty(&p_CcNode->ccTreeIdLst))
         UpdateAdPtrOfTreesWhichPointsOnCrntMdfNode(p_CcNode, h_OldLst, &p_NextEngineParams);
 
     /* This node must be found as next engine of one of its previous nodes or trees*/
@@ -3358,7 +3341,7 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(t_FmPcdCcNode
 
     /* Building a new action descriptor that points to the modified node */
     h_NewAd = GetNewAd(p_CcNode, FALSE);
-    if(!h_NewAd)
+    if (!h_NewAd)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
     IOMemSet32(h_NewAd, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -3406,11 +3389,13 @@ static t_Error CheckAndSetManipParamsWithCcNodeParams(t_FmPcdCcNode *p_CcNode)
 
     return err;
 }
-static t_Error ValidateAndCalcStatsParams(e_FmPcdCcStatsMode   statisticsMode,
+static t_Error ValidateAndCalcStatsParams(t_FmPcdCcNode        *p_CcNode,
                                           t_FmPcdCcNodeParams  *p_CcNodeParam,
                                           uint32_t             *p_NumOfRanges,
                                           uint32_t             *p_CountersArraySize)
 {
+    e_FmPcdCcStatsMode   statisticsMode = p_CcNode->statisticsMode;
+
     UNUSED(p_CcNodeParam);
 
     switch (statisticsMode)
@@ -3451,8 +3436,8 @@ static t_Error ValidateAndCalcStatsParams(e_FmPcdCcStatsMode   statisticsMode,
                         break;
                 }
 
-                if (i >= FM_PCD_CC_STATS_MAX_NUM_OF_FLR ||
-                        p_FrameLengthRanges[i] != 0xFFFF)
+                if ((i >= FM_PCD_CC_STATS_MAX_NUM_OF_FLR) ||
+                    (p_FrameLengthRanges[i] != 0xFFFF))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Last Frame length range must be 0xFFFF"));
 
                 *p_NumOfRanges = i+1;
@@ -3460,6 +3445,7 @@ static t_Error ValidateAndCalcStatsParams(e_FmPcdCcStatsMode   statisticsMode,
                 /* Allocate an extra counter for byte count, as counters
                    array always begins with byte count */
                 *p_CountersArraySize = (*p_NumOfRanges + 1) * FM_PCD_CC_STATS_COUNTER_SIZE;
+
             }
             return E_OK;
 #endif /* (DPAA_VERSION >= 11) */
@@ -3480,7 +3466,7 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     uint32_t                requiredAction = 0;
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNode->statisticsMode,
+    err = ValidateAndCalcStatsParams(p_CcNode,
                                      p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
@@ -3497,7 +3483,7 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     if (p_CcNodeParam->keysParams.ccNextEngineParamsForMiss.h_Manip)
     {
         err = FmPcdManipCheckParamsForCcNextEgine(&p_CcNodeParam->keysParams.ccNextEngineParamsForMiss, &requiredAction);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
 
@@ -3510,7 +3496,7 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine == e_FM_PCD_CC)
         && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
     {
-        err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
+        err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3519,13 +3505,13 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
-        if(!p_KeyParams->p_Key)
+        if (!p_KeyParams->p_Key)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_Key is not initialized"));
 
         err = ValidateNextEngineParams(h_FmPcd,
                                        &p_KeyParams->ccNextEngineParams,
                                        p_CcNode->statisticsMode);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
 
         err = UpdateGblMask(p_CcNode,
@@ -3563,7 +3549,7 @@ static t_Error CheckParams(t_Handle             h_FmPcd,
         if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
             && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
         {
-            err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+            err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -3598,7 +3584,7 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For node of the type IPV4_TTL or IPV6_HOP_LIMIT the maximal supported 'maxNumOfKeys' is 1"));
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNode->statisticsMode,
+    err = ValidateAndCalcStatsParams(p_CcNode,
                                      p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
@@ -3627,7 +3613,7 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
     if ((p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.nextEngine == e_FM_PCD_CC)
         && p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.h_Manip)
     {
-        err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
+        err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[p_CcNode->numOfKeys].nextEngineParams.params.ccParams.h_CcNode);
         if (err)
             RETURN_ERROR(MAJOR, err, (NO_MSG));
     }
@@ -3667,7 +3653,7 @@ static t_Error Ipv4TtlOrIpv6HopLimitCheckParams(t_Handle            h_FmPcd,
         if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
             && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
         {
-            err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+            err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
             if (err)
                 RETURN_ERROR(MAJOR, err, (NO_MSG));
         }
@@ -3711,7 +3697,7 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type INDEXED 'maxNumOfKeys' should be 0 or equal 'numOfKeys'"));
 
     /* Validate statistics parameters */
-    err = ValidateAndCalcStatsParams(p_CcNode->statisticsMode,
+    err = ValidateAndCalcStatsParams(p_CcNode,
                                      p_CcNodeParam,
                                      &(p_CcNode->numOfStatsFLRs),
                                      &(p_CcNode->countersArraySize));
@@ -3721,17 +3707,17 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
     err = ValidateNextEngineParams(h_FmPcd,
                                    &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
                                    p_CcNode->statisticsMode);
-    if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+    if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
         RETURN_ERROR(MAJOR, err, ("MissNextEngineParams for the node of the type IC_INDEX_HASH has to be UnInitialized"));
 
-    for(tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
+    for (tmp = 0; tmp < p_CcNode->numOfKeys; tmp++)
     {
         p_KeyParams = &p_CcNodeParam->keysParams.keyParams[tmp];
 
-        if(p_KeyParams->p_Mask || p_KeyParams->p_Key)
+        if (p_KeyParams->p_Mask || p_KeyParams->p_Key)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Node of the type IC_HASH_INDEXED p_Key or p_Mask has to be NULL"));
 
-        if((glblMask & (tmp * 16)) == (tmp * 16))
+        if ((glblMask & (tmp * 16)) == (tmp * 16))
         {
             err = ValidateNextEngineParams(h_FmPcd,
                                            &p_KeyParams->ccNextEngineParams,
@@ -3754,7 +3740,7 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
             if ((p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.nextEngine == e_FM_PCD_CC)
                 && p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
             {
-                err = FmPcdCcAllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
+                err = AllocAndFillAdForContLookupManip(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.params.ccParams.h_CcNode);
                 if (err)
                     RETURN_ERROR(MAJOR, err, (NO_MSG));
             }
@@ -3764,7 +3750,7 @@ static t_Error IcHashIndexedCheckParams(t_Handle            h_FmPcd,
             err = ValidateNextEngineParams(h_FmPcd,
                                            &p_KeyParams->ccNextEngineParams,
                                            p_CcNode->statisticsMode);
-            if(GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
+            if (GET_ERROR_TYPE(err)!= E_NOT_SUPPORTED)
                 RETURN_ERROR(MAJOR, err, ("This index has to be UnInitialized for the node of the type IC_INDEX_HASH according to settings of GlobalMask"));
         }
     }
@@ -3927,7 +3913,7 @@ static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode  *p_CcNode,
     return E_OK;
 }
 
-static t_Error PreAllocStatsObjs(t_FmPcdCcNode *p_CcNode)
+static t_Error AllocStatsObjs(t_FmPcdCcNode *p_CcNode)
 {
     t_FmPcdStatsObj     *p_StatsObj;
     t_Handle            h_FmMuram, h_StatsAd, h_StatsCounters;
@@ -3939,7 +3925,7 @@ static t_Error PreAllocStatsObjs(t_FmPcdCcNode *p_CcNode)
 
     /* Allocate statistics ADs and statistics counter. An extra pair (AD + counters)
        will be allocated to support runtime modifications */
-    for (i=0; i<p_CcNode->maxNumOfKeys+2; i++)
+    for (i = 0; i < p_CcNode->maxNumOfKeys + 2; i++)
     {
         /* Allocate list object structure */
         p_StatsObj = XX_Malloc(sizeof(t_FmPcdStatsObj));
@@ -4039,7 +4025,7 @@ t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info,
 
         ASSERT_COND(p_CcInformation->h_CcNode);
 
-        if(p_CcInformation->h_CcNode == h_Info)
+        if (p_CcInformation->h_CcNode == h_Info)
         {
             XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
             return p_CcInformation;
@@ -4110,6 +4096,55 @@ void DequeueNodeInfoFromRelevantLst(t_List *p_List, t_Handle h_Info, t_Handle h_
         XX_UnlockIntrSpinlock(h_Spinlock, intFlags);
 }
 
+void NextStepAd(t_Handle                     h_Ad,
+                t_FmPcdCcStatsParams         *p_FmPcdCcStatsParams,
+                t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
+                t_FmPcd                      *p_FmPcd)
+{
+    switch (p_FmPcdCcNextEngineParams->nextEngine)
+    {
+        case (e_FM_PCD_KG):
+        case (e_FM_PCD_PLCR):
+        case (e_FM_PCD_DONE):
+            /* if NIA is not CC, create a "result" type AD */
+            FillAdOfTypeResult(h_Ad,
+                               p_FmPcdCcStatsParams,
+                               p_FmPcd,
+                               p_FmPcdCcNextEngineParams);
+            break;
+#if (DPAA_VERSION >= 11)
+        case (e_FM_PCD_FR):
+            if (p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic)
+            {
+                FillAdOfTypeContLookup(h_Ad,
+                                       p_FmPcdCcStatsParams,
+                                       p_FmPcd,
+                                       p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                                       p_FmPcdCcNextEngineParams->h_Manip,
+                                       p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic);
+                FrmReplicGroupUpdateOwner(p_FmPcdCcNextEngineParams->params.frParams.h_FrmReplic,
+                                          TRUE/* add */);
+            }
+            break;
+#endif /* (DPAA_VERSION >= 11) */
+
+        case (e_FM_PCD_CC):
+            /* if NIA is not CC, create a TD to continue the CC lookup */
+            FillAdOfTypeContLookup(h_Ad,
+                                   p_FmPcdCcStatsParams,
+                                   p_FmPcd,
+                                   p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode,
+                                   p_FmPcdCcNextEngineParams->h_Manip,
+                                   NULL);
+
+            UpdateNodeOwner(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode, TRUE);
+            break;
+
+         default:
+             return;
+    }
+}
+
 t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
                           t_Handle  h_FmTree,
                           t_Handle  h_NetEnv,
@@ -4181,8 +4216,6 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
 
         NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-2) * FM_PCD_CC_AD_ENTRY_SIZE),
                    NULL,
-                   NULL,
-                   NULL,
                    &nextEngineParams,
                    h_FmPcd);
     }
@@ -4209,8 +4242,6 @@ t_Error FmPcdCcTreeAddIPR(t_Handle  h_FmPcd,
 
     NextStepAd(PTR_MOVE(h_Ad, (FM_PCD_MAX_NUM_OF_CC_GROUPS-1) * FM_PCD_CC_AD_ENTRY_SIZE),
                NULL,
-               NULL,
-               NULL,
                &nextEngineParams,
                h_FmPcd);
 
@@ -4303,7 +4334,7 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
 
     p_ModifyKeyParams->tree = TRUE;
 
-    if(p_FmPcd->p_CcShadow)
+    if (p_FmPcd->p_CcShadow)
         if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
             return ERROR_CODE(E_BUSY);
 
@@ -4314,7 +4345,7 @@ t_Error FmPcdCcModifyNextEngineParamTree(t_Handle                   h_FmPcd,
                                        &h_OldPointersLst,
                                        &h_NewPointersLst,
                                        p_ModifyKeyParams);
-    if(err)
+    if (err)
     {
         XX_Free(p_ModifyKeyParams);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -4557,10 +4588,8 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
     t_Error                             err = E_OK;
 
     if (keyIndex > p_CcNode->numOfKeys)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex > previously cleared last index + 1"));
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("keyIndex > previously cleared last index + 1"));
 
-    if ((p_CcNode->numOfKeys + 1) > FM_PCD_MAX_NUM_OF_CC_NODES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys can not be larger than %d", FM_PCD_MAX_NUM_OF_CC_NODES));
 
     if (keySize != p_CcNode->userSizeOfExtraction)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keySize has to be defined as it was defined in initialization step"));
@@ -4569,8 +4598,12 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("handler to FmPcd is different from the handle provided at node initialization time"));
 
     if (p_CcNode->maxNumOfKeys)
-        if ((p_CcNode->numOfKeys + 1) > p_CcNode->maxNumOfKeys)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
+    {
+        if (p_CcNode->numOfKeys == p_CcNode->maxNumOfKeys)
+            RETURN_ERROR(MAJOR, E_FULL, ("number of keys exceeds the maximal number of keys provided at node initialization time"));
+    }
+    else if (p_CcNode->numOfKeys == FM_PCD_MAX_NUM_OF_KEYS)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("number of keys can not be larger than %d", FM_PCD_MAX_NUM_OF_KEYS));
 
     err = FindKeyIndex(h_FmPcdCcNode,
                        keySize,
@@ -4636,7 +4669,6 @@ t_Error FmPcdCcAddKey(t_Handle              h_FmPcd,
                           &h_NewPointersLst,
                           p_ModifyKeyParams,
                           useShadowStructs);
-
     if (p_CcNode->maxNumOfKeys)
         RELEASE_LOCK(p_FmPcd->shadowLock);
 
@@ -4750,7 +4782,7 @@ t_Error FmPcdCcGetGrpParams(t_Handle h_FmPcdCcTree, uint8_t grpId, uint32_t *p_G
 
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcTree, E_INVALID_HANDLE);
 
-    if(grpId >= p_FmPcdCcTree->numOfGrps)
+    if (grpId >= p_FmPcdCcTree->numOfGrps)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("grpId you asked > numOfGroup of relevant tree"));
 
     *p_GrpBits = p_FmPcdCcTree->fmPcdGroupParam[grpId].totalBitsMask;
@@ -4996,7 +5028,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     }
 
     p_FmPcdCcTree = (t_FmPcdCcTree*)XX_Malloc(sizeof(t_FmPcdCcTree));
-    if(!p_FmPcdCcTree)
+    if (!p_FmPcdCcTree)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("PCD tree structure"));
         return NULL;
@@ -5014,10 +5046,10 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
         (p_PcdGroupsParam->ccGrpParams[0].numOfDistinctionUnits == 0) &&
         (p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].nextEngine == e_FM_PCD_CC) &&
         p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode &&
-        FmPcdCcIsCapwapApplSpecific(p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode))
+        IsCapwapApplSpecific(p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].params.ccParams.h_CcNode))
     {
         p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip = FmPcdManipApplSpecificBuild();
-        if(!p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip)
+        if (!p_PcdGroupsParam->ccGrpParams[0].nextEnginePerEntriesInGrp[0].h_Manip)
         {
             DeleteTree(p_FmPcdCcTree,p_FmPcd);
             XX_Free(p_Params);
@@ -5056,7 +5088,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
 
         if (lastOne)
         {
-            if(p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
+            if (p_FmPcdCcTree->fmPcdGroupParam[i].numOfEntriesInGroup > lastOne)
             {
                 DeleteTree(p_FmPcdCcTree,p_FmPcd);
                 XX_Free(p_Params);
@@ -5117,7 +5149,7 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
             if ((p_KeyAndNextEngineParams->nextEngineParams.nextEngine == e_FM_PCD_CC)
                 && p_KeyAndNextEngineParams->nextEngineParams.h_Manip)
             {
-                err = FmPcdCcAllocAndFillAdForContLookupManip(p_KeyAndNextEngineParams->nextEngineParams.params.ccParams.h_CcNode);
+                err = AllocAndFillAdForContLookupManip(p_KeyAndNextEngineParams->nextEngineParams.params.ccParams.h_CcNode);
                 if (err)
                 {
                     DeleteTree(p_FmPcdCcTree,p_FmPcd);
@@ -5153,14 +5185,12 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
     j = 0;
-    for(i = 0; i < numOfEntries; i++)
+    for (i = 0; i < numOfEntries; i++)
     {
-        p_KeyAndNextEngineParams = p_Params+i;
+        p_KeyAndNextEngineParams = p_Params + i;
 
         NextStepAd(p_CcTreeTmp,
                    NULL,
-                   NULL,
-                   NULL,
                    &p_KeyAndNextEngineParams->nextEngineParams,
                    p_FmPcd);
 
@@ -5170,14 +5200,14 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
                p_KeyAndNextEngineParams,
                sizeof(t_FmPcdCcKeyAndNextEngineParams));
 
-        if(p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
+        if (p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.nextEngine== e_FM_PCD_CC)
         {
             p_FmPcdCcNextNode = (t_FmPcdCcNode*)p_FmPcdCcTree->keyAndNextEngineParams[i].nextEngineParams.params.ccParams.h_CcNode;
             p_CcInformation = FindNodeInfoInReleventLst(&p_FmPcdCcNextNode->ccTreeIdLst,
                                                         (t_Handle)p_FmPcdCcTree,
                                                         p_FmPcdCcNextNode->h_Spinlock);
 
-            if(!p_CcInformation)
+            if (!p_CcInformation)
             {
                 memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                 ccNodeInfo.h_CcNode = (t_Handle)p_FmPcdCcTree;
@@ -5202,13 +5232,17 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd, t_FmPcdCcTreeParams *p_PcdGroupsPa
          return NULL;
     }
 
-    for(i = 0; i < numOfEntries; i++)
+    for (i = 0; i < numOfEntries; i++)
     {
-        if(p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
+        if (p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction)
         {
-            err = FmPcdCcSetRequiredAction(h_FmPcd, p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction,
-                                            &p_FmPcdCcTree->keyAndNextEngineParams[i], p_CcTreeTmp,1, p_FmPcdCcTree);
-            if(err)
+            err = SetRequiredAction(h_FmPcd,
+                                    p_FmPcdCcTree->keyAndNextEngineParams[i].requiredAction,
+                                    &p_FmPcdCcTree->keyAndNextEngineParams[i],
+                                    p_CcTreeTmp,
+                                    1,
+                                    p_FmPcdCcTree);
+            if (err)
             {
                 FmPcdLockUnlockAll(p_FmPcd);
                 FM_PCD_CcRootDelete(p_FmPcdCcTree);
@@ -5270,7 +5304,7 @@ t_Error FM_PCD_CcRootDelete(t_Handle h_CcTree)
             (p_CcTree->fmPcdGroupParam[0].numOfEntriesInGroup == 1) &&
             (p_CcTree->keyAndNextEngineParams[0].nextEngineParams.nextEngine == e_FM_PCD_CC) &&
             p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode &&
-            FmPcdCcIsCapwapApplSpecific(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode))
+            IsCapwapApplSpecific(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.params.ccParams.h_CcNode))
         {
             if (FM_PCD_ManipNodeDelete(p_CcTree->keyAndNextEngineParams[0].nextEngineParams.h_Manip) != E_OK)
                 return E_INVALID_STATE;
@@ -5330,23 +5364,24 @@ t_Error FM_PCD_CcRootModifyNextEngine(t_Handle                  h_CcTree,
 
 t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodeParam)
 {
-    t_FmPcd             *p_FmPcd = (t_FmPcd *) h_FmPcd;
-    t_FmPcdCcNode       *p_CcNode, *p_FmPcdCcNextNode;
-    t_Error             err = E_OK;
-    uint32_t            tmp, keySize;
-    bool                glblMask = FALSE;
-    t_FmPcdCcKeyParams  *p_KeyParams;
-    t_Handle            h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
+    t_FmPcd                 *p_FmPcd = (t_FmPcd *) h_FmPcd;
+    t_FmPcdCcNode           *p_CcNode, *p_FmPcdCcNextNode;
+    t_Error                 err = E_OK;
+    uint32_t                tmp, keySize;
+    bool                    glblMask = FALSE;
+    t_FmPcdCcKeyParams      *p_KeyParams;
+    t_Handle                h_FmMuram, p_KeysMatchTblTmp, p_AdTableTmp;
 #if (DPAA_VERSION >= 11)
-    t_Handle            h_StatsFLRs;
+    t_Handle                h_StatsFLRs;
 #endif /* (DPAA_VERSION >= 11) */
-    bool                fullField = FALSE;
-    ccPrivateInfo_t     icCode = CC_PRIVATE_INFO_NONE;
-    bool                isKeyTblAlloc, fromIc = FALSE;
-    uint32_t            matchTableSize, adTableSize;
-    t_CcNodeInformation ccNodeInfo, *p_CcInformation;
-    t_FmPcdStatsObj     *p_StatsObj;
-    t_Handle            h_Manip;
+    bool                    fullField = FALSE;
+    ccPrivateInfo_t         icCode = CC_PRIVATE_INFO_NONE;
+    bool                    isKeyTblAlloc, fromIc = FALSE;
+    uint32_t                matchTableSize, adTableSize;
+    t_CcNodeInformation     ccNodeInfo, *p_CcInformation;
+    t_FmPcdStatsObj         *p_StatsObj;
+    t_FmPcdCcStatsParams    statsParams = {0};
+    t_Handle                h_Manip;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
 
@@ -5475,7 +5510,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                         (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC1) &&
                         (p_CcNode->parseCode != CC_PC_FF_IPV4IPTOS_TC2) &&
                         (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC1_IPV6FLOW1) &&
-                        (p_CcNode->parseCode !=CC_PC_FF_IPTOS1) &&
+                        (p_CcNode->parseCode != CC_PC_FF_IPDSCP) &&
                         (p_CcNode->parseCode != CC_PC_FF_IPTOS_IPV6TC2_IPV6FLOW2) &&
                         glblMask)
                     {
@@ -5613,7 +5648,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
 
         if (p_CcNode->statisticsMode != e_FM_PCD_CC_STATS_MODE_NONE)
         {
-            err = PreAllocStatsObjs(p_CcNode);
+            err = AllocStatsObjs(p_CcNode);
             if (err != E_OK)
             {
                 DeleteNode(p_CcNode);
@@ -5628,7 +5663,7 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         p_CcNode->h_Ad = (t_Handle)FM_MURAM_AllocMem(h_FmMuram,
                                                      FM_PCD_CC_AD_ENTRY_SIZE,
                                                      FM_PCD_CC_AD_TABLE_ALIGN);
-        if(!p_CcNode->h_Ad)
+        if (!p_CcNode->h_Ad)
         {
             DeleteNode(p_CcNode);
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC action descriptor"));
@@ -5642,36 +5677,41 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     }
 
 #if (DPAA_VERSION >= 11)
-    /* If RMON statistics mode requested, allocate frame length ranges array */
-    if (p_CcNode->statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
+    switch (p_CcNode->statisticsMode)
     {
-        /* First counter is always 'byte count', so ranges count is smaller by 1 */
-        p_CcNode->h_StatsFLRs =
-                FM_MURAM_AllocMem(h_FmMuram,
-                                  (uint32_t)(p_CcNode->numOfStatsFLRs) * FM_PCD_CC_STATS_FLR_SIZE,
-                                  FM_PCD_CC_AD_TABLE_ALIGN);
 
-        if (!p_CcNode->h_StatsFLRs)
-        {
-            DeleteNode(p_CcNode);
-            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC frame length ranges array"));
-            return NULL;
-        }
+        case e_FM_PCD_CC_STATS_MODE_RMON:
+            /* If RMON statistics or RMON conditional statistics modes are requested,
+               allocate frame length ranges array */
+            p_CcNode->h_StatsFLRs =
+                    FM_MURAM_AllocMem(h_FmMuram,
+                                      (uint32_t)(p_CcNode->numOfStatsFLRs) * FM_PCD_CC_STATS_FLR_SIZE,
+                                      FM_PCD_CC_AD_TABLE_ALIGN);
+
+            if (!p_CcNode->h_StatsFLRs)
+            {
+                DeleteNode(p_CcNode);
+                REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC frame length ranges array"));
+                return NULL;
+            }
 
-        /* Initialize using value received from the user */
-        for (tmp = 0; tmp < p_CcNode->numOfStatsFLRs; tmp++)
-        {
-            h_StatsFLRs = PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
+            /* Initialize using value received from the user */
+            for (tmp = 0; tmp < p_CcNode->numOfStatsFLRs; tmp++)
+            {
+                h_StatsFLRs = PTR_MOVE(p_CcNode->h_StatsFLRs, tmp * FM_PCD_CC_STATS_FLR_SIZE);
 
-            Mem2IOCpy32(h_StatsFLRs,
-                        &(p_CcNodeParam->keysParams.frameLengthRanges[tmp]),
-                        FM_PCD_CC_STATS_FLR_SIZE);
-        }
+                Mem2IOCpy32(h_StatsFLRs,
+                            &(p_CcNodeParam->keysParams.frameLengthRanges[tmp]),
+                            FM_PCD_CC_STATS_FLR_SIZE);
+            }
+            break;
+
+        default:
+            break;
     }
-#else
-    p_CcNode->h_StatsFLRs = NULL;
 #endif /* (DPAA_VERSION >= 11) */
 
+
     /* Allocate keys match table. Not required for some CC nodes, for example for IPv4 TTL
        identification, IPv6 hop count identification, etc. */
     if (isKeyTblAlloc)
@@ -5742,10 +5782,14 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
             p_StatsObj = GetStatsObj(p_CcNode);
             ASSERT_COND(p_StatsObj);
 
+            statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
+            statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
+#if (DPAA_VERSION >= 11)
+            statsParams.h_StatsFLRs = p_CcNode->h_StatsFLRs;
+
+#endif /* (DPAA_VERSION >= 11) */
             NextStepAd(p_AdTableTmp,
-                       p_StatsObj->h_StatsAd,
-                       p_StatsObj->h_StatsCounters,
-                       p_CcNode->h_StatsFLRs,
+                       &statsParams,
                        &p_KeyParams->ccNextEngineParams,
                        p_FmPcd);
 
@@ -5755,8 +5799,6 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         {
             NextStepAd(p_AdTableTmp,
                        NULL,
-                       NULL,
-                       NULL,
                        &p_KeyParams->ccNextEngineParams,
                        p_FmPcd);
 
@@ -5772,10 +5814,15 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
         p_StatsObj = GetStatsObj(p_CcNode);
         ASSERT_COND(p_StatsObj);
 
+        statsParams.h_StatsAd = p_StatsObj->h_StatsAd;
+        statsParams.h_StatsCounters = p_StatsObj->h_StatsCounters;
+#if (DPAA_VERSION >= 11)
+        statsParams.h_StatsFLRs = p_CcNode->h_StatsFLRs;
+
+#endif /* (DPAA_VERSION >= 11) */
+
         NextStepAd(p_AdTableTmp,
-                   p_StatsObj->h_StatsAd,
-                   p_StatsObj->h_StatsCounters,
-                   p_CcNode->h_StatsFLRs,
+                   &statsParams,
                    &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
                    p_FmPcd);
 
@@ -5785,8 +5832,6 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     {
         NextStepAd(p_AdTableTmp,
                    NULL,
-                   NULL,
-                   NULL,
                    &p_CcNodeParam->keysParams.ccNextEngineParamsForMiss,
                    p_FmPcd);
 
@@ -5815,28 +5860,28 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
                                              &ccNodeInfo,
                                              p_FmPcdCcNextNode->h_Spinlock);
             }
-            else // TODO - think about Spinlock around ++
+            else
                 p_CcInformation->index++;
-            if(p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
+            if (p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip)
             {
                 h_Manip = p_CcNode->keyAndNextEngineParams[tmp].nextEngineParams.h_Manip;
                 p_CcInformation = FindNodeInfoInReleventLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
                                                              (t_Handle)p_CcNode,
                                                              FmPcdManipGetSpinlock(h_Manip));
                 if (!p_CcInformation)
-                 {
+                {
                      memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                      ccNodeInfo.h_CcNode = (t_Handle)p_CcNode;
                      ccNodeInfo.index = 1;
                      EnqueueNodeInfoToRelevantLst(FmPcdManipGetNodeLstPointedOnThisManip(h_Manip),
                                                   &ccNodeInfo,
                                                   FmPcdManipGetSpinlock(h_Manip));
+                }
+                else
+                    p_CcInformation->index++;
             }
-            else
-                p_CcInformation->index++;
         }
     }
-    }
 
     p_AdTableTmp = p_CcNode->h_AdTable;
 
@@ -5852,12 +5897,12 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNodeParams *p_CcNodePar
     {
         if (p_CcNode->keyAndNextEngineParams[tmp].requiredAction)
         {
-            err = FmPcdCcSetRequiredAction(h_FmPcd,
-                                           p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
-                                           &p_CcNode->keyAndNextEngineParams[tmp],
-                                           p_AdTableTmp,
-                                           1,
-                                           NULL);
+            err = SetRequiredAction(h_FmPcd,
+                                    p_CcNode->keyAndNextEngineParams[tmp].requiredAction,
+                                    &p_CcNode->keyAndNextEngineParams[tmp],
+                                    p_AdTableTmp,
+                                    1,
+                                    NULL);
             if (err)
             {
                 FmPcdLockUnlockAll(h_FmPcd);
@@ -6395,8 +6440,8 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
     if (keyIndex >= p_CcNode->numOfKeys)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("keyIndex exceeds current number of keys"));
 
-    if (keyIndex > FM_PCD_MAX_NUM_OF_CC_NODES)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex can not be larger than 255"));
+    if (keyIndex > (FM_PCD_MAX_NUM_OF_KEYS - 1))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("keyIndex can not be larger than %d", (FM_PCD_MAX_NUM_OF_KEYS - 1)));
 
     memcpy(p_FmPcdCcNextEngineParams,
            &p_CcNode->keyAndNextEngineParams[keyIndex].nextEngineParams,
@@ -6580,7 +6625,7 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     if (p_Param->statisticsMode == e_FM_PCD_CC_STATS_MODE_RMON)
     {
         REPORT_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("RMON statistics mode currently not supported for hash table"));
+                     ("RMON statistics mode is not supported for hash table"));
         return NULL;
     }
 #endif /* (DPAA_VERSION >= 11) */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
index 6288f79..9efe721 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_cc.h
@@ -50,7 +50,7 @@
 /*          Coarse classification defines                              */
 /***********************************************************************/
 
-#define CC_MAX_NUM_OF_KEYS                  MAX(FM_PCD_MAX_NUM_OF_KEYS, FM_PCD_MAX_NUM_OF_FLOWS)
+#define CC_MAX_NUM_OF_KEYS                  MAX(FM_PCD_MAX_NUM_OF_KEYS + 1, FM_PCD_MAX_NUM_OF_FLOWS)
 
 #define CC_PC_FF_MACDST                     0x00
 #define CC_PC_FF_MACSRC                     0x01
@@ -85,7 +85,7 @@
 #define CC_PC_FF_IPV6SRC2                   0x1e
 #define CC_PC_FF_IPV6HOP_LIMIT              0x2a
 #define CC_PC_FF_IPPID                      0x24
-#define CC_PC_FF_IPTOS1                     0x76
+#define CC_PC_FF_IPDSCP                     0x76
 
 #define CC_PC_FF_GREPTYPE                   0x11
 
@@ -147,6 +147,18 @@
 #define FM_PCD_AD_CONT_LOOKUP_TYPE          0x40000000
 #define FM_PCD_AD_CONT_LOOKUP_LCL_MASK      0x00800000
 
+#define FM_PCD_AD_STATS_TYPE                0x40000000
+#define FM_PCD_AD_STATS_FLR_ADDR_MASK       0x00FFFFFF
+#define FM_PCD_AD_STATS_COUNTERS_ADDR_MASK  0x00FFFFFF
+#define FM_PCD_AD_STATS_NEXT_ACTION_MASK    0xFFFF0000
+#define FM_PCD_AD_STATS_NEXT_ACTION_SHIFT   12
+#define FM_PCD_AD_STATS_NAD_EN              0x00008000
+#define FM_PCD_AD_STATS_OP_CODE             0x00000036
+#define FM_PCD_AD_STATS_FLR_EN              0x00004000
+#define FM_PCD_AD_STATS_COND_EN             0x00002000
+
+
+
 #define FM_PCD_AD_BYPASS_TYPE               0xc0000000
 
 #define FM_PCD_AD_TYPE_MASK                 0xc0000000
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
index c74aa1c..fdb86d9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.c
@@ -94,7 +94,7 @@ static t_Error WriteKgarWait(t_FmPcd *p_FmPcd, uint32_t kgar)
 {
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar, kgar);
     /* Wait for GO to be idle and read error */
-    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO);
+    while ((kgar = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgar)) & FM_PCD_KG_KGAR_GO) ;
     if (kgar & FM_PCD_KG_KGAR_ERR)
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Keygen scheme access violation"));
     return E_OK;
@@ -104,59 +104,59 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
 {
     int i;
 
-    switch(code)
+    switch (code)
     {
-        case( KG_SCH_GEN_PARSE_RESULT_N_FQID):
-        case( KG_SCH_GEN_DEFAULT):
-        case( KG_SCH_GEN_NEXTHDR):
-            for(i=0 ; i<numOfSwDefaults ; i++)
-                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
+        case (KG_SCH_GEN_PARSE_RESULT_N_FQID):
+        case (KG_SCH_GEN_DEFAULT):
+        case (KG_SCH_GEN_NEXTHDR):
+            for (i=0 ; i<numOfSwDefaults ; i++)
+                if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
                     return swDefaults[i].dfltSelect;
             ASSERT_COND(FALSE);
-        case( KG_SCH_GEN_SHIM1):
-        case( KG_SCH_GEN_SHIM2):
-        case( KG_SCH_GEN_IP_PID_NO_V):
-        case( KG_SCH_GEN_ETH_NO_V):
-        case( KG_SCH_GEN_SNAP_NO_V):
-        case( KG_SCH_GEN_VLAN1_NO_V):
-        case( KG_SCH_GEN_VLAN2_NO_V):
-        case( KG_SCH_GEN_ETH_TYPE_NO_V):
-        case( KG_SCH_GEN_PPP_NO_V):
-        case( KG_SCH_GEN_MPLS1_NO_V):
-        case( KG_SCH_GEN_MPLS_LAST_NO_V):
-        case( KG_SCH_GEN_L3_NO_V):
-        case( KG_SCH_GEN_IP2_NO_V):
-        case( KG_SCH_GEN_GRE_NO_V):
-        case( KG_SCH_GEN_L4_NO_V):
-            for(i=0 ; i<numOfSwDefaults ; i++)
-                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
+        case (KG_SCH_GEN_SHIM1):
+        case (KG_SCH_GEN_SHIM2):
+        case (KG_SCH_GEN_IP_PID_NO_V):
+        case (KG_SCH_GEN_ETH_NO_V):
+        case (KG_SCH_GEN_SNAP_NO_V):
+        case (KG_SCH_GEN_VLAN1_NO_V):
+        case (KG_SCH_GEN_VLAN2_NO_V):
+        case (KG_SCH_GEN_ETH_TYPE_NO_V):
+        case (KG_SCH_GEN_PPP_NO_V):
+        case (KG_SCH_GEN_MPLS1_NO_V):
+        case (KG_SCH_GEN_MPLS_LAST_NO_V):
+        case (KG_SCH_GEN_L3_NO_V):
+        case (KG_SCH_GEN_IP2_NO_V):
+        case (KG_SCH_GEN_GRE_NO_V):
+        case (KG_SCH_GEN_L4_NO_V):
+            for (i=0 ; i<numOfSwDefaults ; i++)
+                if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
                     return swDefaults[i].dfltSelect;
 
-        case( KG_SCH_GEN_START_OF_FRM):
-        case( KG_SCH_GEN_ETH):
-        case( KG_SCH_GEN_SNAP):
-        case( KG_SCH_GEN_VLAN1):
-        case( KG_SCH_GEN_VLAN2):
-        case( KG_SCH_GEN_ETH_TYPE):
-        case( KG_SCH_GEN_PPP):
-        case( KG_SCH_GEN_MPLS1):
-        case( KG_SCH_GEN_MPLS2):
-        case( KG_SCH_GEN_MPLS3):
-        case( KG_SCH_GEN_MPLS_LAST):
-        case( KG_SCH_GEN_IPV4):
-        case( KG_SCH_GEN_IPV6):
-        case( KG_SCH_GEN_IPV4_TUNNELED):
-        case( KG_SCH_GEN_IPV6_TUNNELED):
-        case( KG_SCH_GEN_MIN_ENCAP):
-        case( KG_SCH_GEN_GRE):
-        case( KG_SCH_GEN_TCP):
-        case( KG_SCH_GEN_UDP):
-        case( KG_SCH_GEN_IPSEC_AH):
-        case( KG_SCH_GEN_SCTP):
-        case( KG_SCH_GEN_DCCP):
-        case( KG_SCH_GEN_IPSEC_ESP):
-            for(i=0 ; i<numOfSwDefaults ; i++)
-                if(swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
+        case (KG_SCH_GEN_START_OF_FRM):
+        case (KG_SCH_GEN_ETH):
+        case (KG_SCH_GEN_SNAP):
+        case (KG_SCH_GEN_VLAN1):
+        case (KG_SCH_GEN_VLAN2):
+        case (KG_SCH_GEN_ETH_TYPE):
+        case (KG_SCH_GEN_PPP):
+        case (KG_SCH_GEN_MPLS1):
+        case (KG_SCH_GEN_MPLS2):
+        case (KG_SCH_GEN_MPLS3):
+        case (KG_SCH_GEN_MPLS_LAST):
+        case (KG_SCH_GEN_IPV4):
+        case (KG_SCH_GEN_IPV6):
+        case (KG_SCH_GEN_IPV4_TUNNELED):
+        case (KG_SCH_GEN_IPV6_TUNNELED):
+        case (KG_SCH_GEN_MIN_ENCAP):
+        case (KG_SCH_GEN_GRE):
+        case (KG_SCH_GEN_TCP):
+        case (KG_SCH_GEN_UDP):
+        case (KG_SCH_GEN_IPSEC_AH):
+        case (KG_SCH_GEN_SCTP):
+        case (KG_SCH_GEN_DCCP):
+        case (KG_SCH_GEN_IPSEC_ESP):
+            for (i=0 ; i<numOfSwDefaults ; i++)
+                if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
                     return swDefaults[i].dfltSelect;
         default:
             return e_FM_PCD_KG_DFLT_ILLEGAL;
@@ -167,18 +167,18 @@ static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
 {
     *p_Offset = 0;
 
-    switch(src)
+    switch (src)
     {
-        case(e_FM_PCD_EXTRACT_FROM_FRAME_START):
+        case (e_FM_PCD_EXTRACT_FROM_FRAME_START):
             return KG_SCH_GEN_START_OF_FRM;
-        case(e_FM_PCD_EXTRACT_FROM_DFLT_VALUE):
+        case (e_FM_PCD_EXTRACT_FROM_DFLT_VALUE):
             return KG_SCH_GEN_DEFAULT;
-        case(e_FM_PCD_EXTRACT_FROM_PARSE_RESULT):
+        case (e_FM_PCD_EXTRACT_FROM_PARSE_RESULT):
             return KG_SCH_GEN_PARSE_RESULT_N_FQID;
-        case(e_FM_PCD_EXTRACT_FROM_ENQ_FQID):
+        case (e_FM_PCD_EXTRACT_FROM_ENQ_FQID):
             *p_Offset = 32;
             return KG_SCH_GEN_PARSE_RESULT_N_FQID;
-        case(e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
+        case (e_FM_PCD_EXTRACT_FROM_CURR_END_OF_PARSE):
             return KG_SCH_GEN_NEXTHDR;
         default:
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 'extract from' src"));
@@ -188,104 +188,104 @@ static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
 
 static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool ignoreProtocolValidation)
 {
-    if(!ignoreProtocolValidation)
-        switch(hdr)
+    if (!ignoreProtocolValidation)
+        switch (hdr)
         {
-            case(HEADER_TYPE_NONE):
+            case (HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-            case(HEADER_TYPE_ETH):
+            case (HEADER_TYPE_ETH):
                 return KG_SCH_GEN_ETH;
-            case(HEADER_TYPE_LLC_SNAP):
+            case (HEADER_TYPE_LLC_SNAP):
                 return KG_SCH_GEN_SNAP;
-            case(HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_PPPoE):
                 return KG_SCH_GEN_PPP;
-            case(HEADER_TYPE_MPLS):
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_MPLS):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_MPLS1;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
                     return KG_SCH_GEN_MPLS2;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_3)
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_3)
                     return KG_SCH_GEN_MPLS3;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                     return KG_SCH_GEN_MPLS_LAST;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
                 return 0;
-            case(HEADER_TYPE_IPv4):
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_IPv4):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_IPV4;
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IPV4_TUNNELED;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 header index"));
                 return 0;
-            case(HEADER_TYPE_IPv6):
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_IPv6):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_IPV6;
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IPV6_TUNNELED;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 header index"));
                 return 0;
-            case(HEADER_TYPE_GRE):
+            case (HEADER_TYPE_GRE):
                 return KG_SCH_GEN_GRE;
-            case(HEADER_TYPE_TCP):
+            case (HEADER_TYPE_TCP):
                 return KG_SCH_GEN_TCP;
-            case(HEADER_TYPE_UDP):
+            case (HEADER_TYPE_UDP):
                 return KG_SCH_GEN_UDP;
-            case(HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_AH):
                 return KG_SCH_GEN_IPSEC_AH;
-            case(HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_IPSEC_ESP):
                 return KG_SCH_GEN_IPSEC_ESP;
-            case(HEADER_TYPE_SCTP):
+            case (HEADER_TYPE_SCTP):
                 return KG_SCH_GEN_SCTP;
-            case(HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_DCCP):
                 return KG_SCH_GEN_DCCP;
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                 return 0;
         }
     else
-        switch(hdr)
+        switch (hdr)
         {
-            case(HEADER_TYPE_NONE):
+            case (HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-            case(HEADER_TYPE_ETH):
+            case (HEADER_TYPE_ETH):
                 return KG_SCH_GEN_ETH_NO_V;
-            case(HEADER_TYPE_LLC_SNAP):
+            case (HEADER_TYPE_LLC_SNAP):
                 return KG_SCH_GEN_SNAP_NO_V;
-            case(HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_PPPoE):
                 return KG_SCH_GEN_PPP_NO_V;
-            case(HEADER_TYPE_MPLS):
-                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_MPLS):
+                 if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_MPLS1_NO_V;
-                if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                     return KG_SCH_GEN_MPLS_LAST_NO_V;
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_3) )
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_3) )
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Indexed MPLS Extraction not supported"));
                 else
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS header index"));
                 return 0;
-            case(HEADER_TYPE_IPv4):
-            case(HEADER_TYPE_IPv6):
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_IPv4):
+            case (HEADER_TYPE_IPv6):
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     return KG_SCH_GEN_L3_NO_V;
-                if((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
+                if ((hdrIndex == e_FM_PCD_HDR_INDEX_2) || (hdrIndex == e_FM_PCD_HDR_INDEX_LAST))
                     return KG_SCH_GEN_IP2_NO_V;
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IP header index"));
-            case(HEADER_TYPE_MINENCAP):
+            case (HEADER_TYPE_MINENCAP):
                 return KG_SCH_GEN_IP2_NO_V;
-            case(HEADER_TYPE_USER_DEFINED_L3):
+            case (HEADER_TYPE_USER_DEFINED_L3):
                 return KG_SCH_GEN_L3_NO_V;
-            case(HEADER_TYPE_GRE):
+            case (HEADER_TYPE_GRE):
                 return KG_SCH_GEN_GRE_NO_V;
-            case(HEADER_TYPE_TCP):
-            case(HEADER_TYPE_UDP):
-            case(HEADER_TYPE_IPSEC_AH):
-            case(HEADER_TYPE_IPSEC_ESP):
-            case(HEADER_TYPE_SCTP):
-            case(HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_TCP):
+            case (HEADER_TYPE_UDP):
+            case (HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_SCTP):
+            case (HEADER_TYPE_DCCP):
                 return KG_SCH_GEN_L4_NO_V;
-            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+            case (HEADER_TYPE_USER_DEFINED_SHIM1):
                 return KG_SCH_GEN_SHIM1;
-            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+            case (HEADER_TYPE_USER_DEFINED_SHIM2):
                 return KG_SCH_GEN_SHIM2;
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
@@ -295,106 +295,106 @@ static uint8_t GetGenHdrCode(e_NetHeaderType hdr, e_FmPcdHdrIndex hdrIndex, bool
 static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field, bool ignoreProtocolValidation, e_FmPcdHdrIndex hdrIndex)
 {
     if (!ignoreProtocolValidation)
-        switch(hdr)
+        switch (hdr)
         {
-            case(HEADER_TYPE_NONE):
+            case (HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
-            case(HEADER_TYPE_ETH):
-                switch(field.eth)
+            case (HEADER_TYPE_ETH):
+                switch (field.eth)
                 {
-                    case(NET_HEADER_FIELD_ETH_TYPE):
+                    case (NET_HEADER_FIELD_ETH_TYPE):
                         return KG_SCH_GEN_ETH_TYPE;
                     default:
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
-            case(HEADER_TYPE_VLAN):
-                switch(field.vlan)
+            case (HEADER_TYPE_VLAN):
+                switch (field.vlan)
                 {
-                    case(NET_HEADER_FIELD_VLAN_TCI):
-                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    case (NET_HEADER_FIELD_VLAN_TCI):
+                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                             return KG_SCH_GEN_VLAN1;
-                        if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                             return KG_SCH_GEN_VLAN2;
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                         return 0;
                 }
-            case(HEADER_TYPE_MPLS):
-            case(HEADER_TYPE_IPSEC_AH):
-            case(HEADER_TYPE_IPSEC_ESP):
-            case(HEADER_TYPE_LLC_SNAP):
-            case(HEADER_TYPE_PPPoE):
-            case(HEADER_TYPE_IPv4):
-            case(HEADER_TYPE_IPv6):
-            case(HEADER_TYPE_GRE):
-            case(HEADER_TYPE_MINENCAP):
-            case(HEADER_TYPE_USER_DEFINED_L3):
-            case(HEADER_TYPE_TCP):
-            case(HEADER_TYPE_UDP):
-            case(HEADER_TYPE_SCTP):
-            case(HEADER_TYPE_DCCP):
-            case(HEADER_TYPE_USER_DEFINED_L4):
+            case (HEADER_TYPE_MPLS):
+            case (HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_LLC_SNAP):
+            case (HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_IPv4):
+            case (HEADER_TYPE_IPv6):
+            case (HEADER_TYPE_GRE):
+            case (HEADER_TYPE_MINENCAP):
+            case (HEADER_TYPE_USER_DEFINED_L3):
+            case (HEADER_TYPE_TCP):
+            case (HEADER_TYPE_UDP):
+            case (HEADER_TYPE_SCTP):
+            case (HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_USER_DEFINED_L4):
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
             default:
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
                 return 0;
         }
         else
-            switch(hdr)
+            switch (hdr)
             {
-                case(HEADER_TYPE_NONE):
+                case (HEADER_TYPE_NONE):
                     ASSERT_COND(FALSE);
-                case(HEADER_TYPE_ETH):
-                switch(field.eth)
+                case (HEADER_TYPE_ETH):
+                switch (field.eth)
                 {
-                    case(NET_HEADER_FIELD_ETH_TYPE):
+                    case (NET_HEADER_FIELD_ETH_TYPE):
                         return KG_SCH_GEN_ETH_TYPE_NO_V;
                     default:
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
-                case(HEADER_TYPE_VLAN):
-                    switch(field.vlan)
+                case (HEADER_TYPE_VLAN):
+                    switch (field.vlan)
                     {
-                        case(NET_HEADER_FIELD_VLAN_TCI) :
-                            if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                        case (NET_HEADER_FIELD_VLAN_TCI) :
+                            if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                                 return KG_SCH_GEN_VLAN1_NO_V;
-                            if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                            if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                                 return KG_SCH_GEN_VLAN2_NO_V;
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                             return 0;
                     }
-                case(HEADER_TYPE_IPv4):
-                    switch(field.ipv4)
+                case (HEADER_TYPE_IPv4):
+                    switch (field.ipv4)
                     {
-                        case(NET_HEADER_FIELD_IPv4_PROTO):
+                        case (NET_HEADER_FIELD_IPv4_PROTO):
                             return KG_SCH_GEN_IP_PID_NO_V;
                         default:
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
-                case(HEADER_TYPE_IPv6):
-                   switch(field.ipv6)
+                case (HEADER_TYPE_IPv6):
+                   switch (field.ipv6)
                     {
-                        case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                        case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
                             return KG_SCH_GEN_IP_PID_NO_V;
                         default:
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
-                case(HEADER_TYPE_MPLS):
-                case(HEADER_TYPE_LLC_SNAP):
-                case(HEADER_TYPE_PPPoE):
-                case(HEADER_TYPE_GRE):
-                case(HEADER_TYPE_MINENCAP):
-                case(HEADER_TYPE_USER_DEFINED_L3):
-                case(HEADER_TYPE_TCP):
-                case(HEADER_TYPE_UDP):
-                case(HEADER_TYPE_IPSEC_AH):
-                case(HEADER_TYPE_IPSEC_ESP):
-                case(HEADER_TYPE_SCTP):
-                case(HEADER_TYPE_DCCP):
-                case(HEADER_TYPE_USER_DEFINED_L4):
+                case (HEADER_TYPE_MPLS):
+                case (HEADER_TYPE_LLC_SNAP):
+                case (HEADER_TYPE_PPPoE):
+                case (HEADER_TYPE_GRE):
+                case (HEADER_TYPE_MINENCAP):
+                case (HEADER_TYPE_USER_DEFINED_L3):
+                case (HEADER_TYPE_TCP):
+                case (HEADER_TYPE_UDP):
+                case (HEADER_TYPE_IPSEC_AH):
+                case (HEADER_TYPE_IPSEC_ESP):
+                case (HEADER_TYPE_SCTP):
+                case (HEADER_TYPE_DCCP):
+                case (HEADER_TYPE_USER_DEFINED_L4):
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
                 default:
@@ -407,39 +407,39 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
 {
     UNUSED(p_FmPcd);
 
-    switch(hdr)
+    switch (hdr)
     {
-        case(HEADER_TYPE_NONE):
+        case (HEADER_TYPE_NONE):
             ASSERT_COND(FALSE);
-        case(HEADER_TYPE_ETH):
-            switch(field.eth)
+        case (HEADER_TYPE_ETH):
+            switch (field.eth)
             {
-                case(NET_HEADER_FIELD_ETH_DA):
+                case (NET_HEADER_FIELD_ETH_DA):
                     return KG_SCH_KN_MACDST;
-                case(NET_HEADER_FIELD_ETH_SA):
+                case (NET_HEADER_FIELD_ETH_SA):
                     return KG_SCH_KN_MACSRC;
-                case(NET_HEADER_FIELD_ETH_TYPE):
+                case (NET_HEADER_FIELD_ETH_TYPE):
                     return KG_SCH_KN_ETYPE;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
-           }
-        case(HEADER_TYPE_LLC_SNAP):
-            switch(field.llcSnap)
+            }
+        case (HEADER_TYPE_LLC_SNAP):
+            switch (field.llcSnap)
             {
-                case(NET_HEADER_FIELD_LLC_SNAP_TYPE):
+                case (NET_HEADER_FIELD_LLC_SNAP_TYPE):
                     return KG_SCH_KN_ETYPE;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
-           }
-        case(HEADER_TYPE_VLAN):
-            switch(field.vlan)
+            }
+        case (HEADER_TYPE_VLAN):
+            switch (field.vlan)
             {
-                case(NET_HEADER_FIELD_VLAN_TCI):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_VLAN_TCI):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_TCI1;
-                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return KG_SCH_KN_TCI2;
                     else
                     {
@@ -450,15 +450,15 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_MPLS):
-            switch(field.mpls)
+        case (HEADER_TYPE_MPLS):
+            switch (field.mpls)
             {
-                case(NET_HEADER_FIELD_MPLS_LABEL_STACK):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_MPLS_LABEL_STACK):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_MPLS1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return KG_SCH_KN_MPLS2;
-                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
                         return KG_SCH_KN_MPLS_LAST;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal MPLS index"));
                     return 0;
@@ -466,34 +466,34 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_IPv4):
-            switch(field.ipv4)
+        case (HEADER_TYPE_IPv4):
+            switch (field.ipv4)
             {
-                case(NET_HEADER_FIELD_IPv4_SRC_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_SRC_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPSRC1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPSRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv4_DST_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_DST_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPDST1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPDST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv4_PROTO):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_PROTO):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_PTYPE1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_PTYPE2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv4_TOS):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv4_TOS):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPTOS_TC1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPTOS_TC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv4 index"));
                     return 0;
@@ -501,29 +501,29 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_IPv6):
-             switch(field.ipv6)
+        case (HEADER_TYPE_IPv6):
+             switch (field.ipv6)
             {
-                case(NET_HEADER_FIELD_IPv6_SRC_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_SRC_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPSRC1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPSRC2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv6_DST_IP):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_DST_IP):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_IPDST1;
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return KG_SCH_KN_IPDST2;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv6_NEXT_HDR):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_NEXT_HDR):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return KG_SCH_KN_PTYPE1;
-                    if(index == e_FM_PCD_HDR_INDEX_2)
+                    if (index == e_FM_PCD_HDR_INDEX_2)
                         return KG_SCH_KN_PTYPE2;
-                    if(index == e_FM_PCD_HDR_INDEX_LAST)
+                    if (index == e_FM_PCD_HDR_INDEX_LAST)
 #ifdef FM_KG_NO_IPPID_SUPPORT
                     if (p_FmPcd->fmRevInfo.majorRev < 6)
                         return KG_SCH_KN_PTYPE2;
@@ -531,10 +531,10 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                         return KG_SCH_KN_IPPID;
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
-                case(NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
-                    if((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
+                case (NET_HEADER_FIELD_IPv6_VER | NET_HEADER_FIELD_IPv6_FL | NET_HEADER_FIELD_IPv6_TC):
+                    if ((index == e_FM_PCD_HDR_INDEX_NONE) || (index == e_FM_PCD_HDR_INDEX_1))
                         return (KG_SCH_KN_IPV6FL1 | KG_SCH_KN_IPTOS_TC1);
-                    if((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
+                    if ((index == e_FM_PCD_HDR_INDEX_2) || (index == e_FM_PCD_HDR_INDEX_LAST))
                         return (KG_SCH_KN_IPV6FL2 | KG_SCH_KN_IPTOS_TC2);
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal IPv6 index"));
                     return 0;
@@ -542,100 +542,100 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_GRE):
-            switch(field.gre)
+        case (HEADER_TYPE_GRE):
+            switch (field.gre)
             {
-                case(NET_HEADER_FIELD_GRE_TYPE):
+                case (NET_HEADER_FIELD_GRE_TYPE):
                     return KG_SCH_KN_GREPTYPE;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
-           }
-        case(HEADER_TYPE_MINENCAP):
-            switch(field.minencap)
+            }
+        case (HEADER_TYPE_MINENCAP):
+            switch (field.minencap)
             {
-                case(NET_HEADER_FIELD_MINENCAP_SRC_IP):
+                case (NET_HEADER_FIELD_MINENCAP_SRC_IP):
                     return KG_SCH_KN_IPSRC2;
-                case(NET_HEADER_FIELD_MINENCAP_DST_IP):
+                case (NET_HEADER_FIELD_MINENCAP_DST_IP):
                     return KG_SCH_KN_IPDST2;
-                case(NET_HEADER_FIELD_MINENCAP_TYPE):
+                case (NET_HEADER_FIELD_MINENCAP_TYPE):
                     return KG_SCH_KN_PTYPE2;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
-           }
-        case(HEADER_TYPE_TCP):
-            switch(field.tcp)
+            }
+        case (HEADER_TYPE_TCP):
+            switch (field.tcp)
             {
-                case(NET_HEADER_FIELD_TCP_PORT_SRC):
+                case (NET_HEADER_FIELD_TCP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case(NET_HEADER_FIELD_TCP_PORT_DST):
+                case (NET_HEADER_FIELD_TCP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
-                case(NET_HEADER_FIELD_TCP_FLAGS):
+                case (NET_HEADER_FIELD_TCP_FLAGS):
                     return KG_SCH_KN_TFLG;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_UDP):
-            switch(field.udp)
+        case (HEADER_TYPE_UDP):
+            switch (field.udp)
             {
-                case(NET_HEADER_FIELD_UDP_PORT_SRC):
+                case (NET_HEADER_FIELD_UDP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case(NET_HEADER_FIELD_UDP_PORT_DST):
+                case (NET_HEADER_FIELD_UDP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_IPSEC_AH):
-            switch(field.ipsecAh)
+        case (HEADER_TYPE_IPSEC_AH):
+            switch (field.ipsecAh)
             {
-                case(NET_HEADER_FIELD_IPSEC_AH_SPI):
+                case (NET_HEADER_FIELD_IPSEC_AH_SPI):
                     return KG_SCH_KN_IPSEC_SPI;
-                case(NET_HEADER_FIELD_IPSEC_AH_NH):
+                case (NET_HEADER_FIELD_IPSEC_AH_NH):
                     return KG_SCH_KN_IPSEC_NH;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_IPSEC_ESP):
-            switch(field.ipsecEsp)
+        case (HEADER_TYPE_IPSEC_ESP):
+            switch (field.ipsecEsp)
             {
-                case(NET_HEADER_FIELD_IPSEC_ESP_SPI):
+                case (NET_HEADER_FIELD_IPSEC_ESP_SPI):
                     return KG_SCH_KN_IPSEC_SPI;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_SCTP):
-            switch(field.sctp)
+        case (HEADER_TYPE_SCTP):
+            switch (field.sctp)
             {
-                case(NET_HEADER_FIELD_SCTP_PORT_SRC):
+                case (NET_HEADER_FIELD_SCTP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case(NET_HEADER_FIELD_SCTP_PORT_DST):
+                case (NET_HEADER_FIELD_SCTP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_DCCP):
-            switch(field.dccp)
+        case (HEADER_TYPE_DCCP):
+            switch (field.dccp)
             {
-                case(NET_HEADER_FIELD_DCCP_PORT_SRC):
+                case (NET_HEADER_FIELD_DCCP_PORT_SRC):
                     return KG_SCH_KN_L4PSRC;
-                case(NET_HEADER_FIELD_DCCP_PORT_DST):
+                case (NET_HEADER_FIELD_DCCP_PORT_DST):
                     return KG_SCH_KN_L4PDST;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
             }
-        case(HEADER_TYPE_PPPoE):
-            switch(field.pppoe)
+        case (HEADER_TYPE_PPPoE):
+            switch (field.pppoe)
             {
-                case(NET_HEADER_FIELD_PPPoE_PID):
+                case (NET_HEADER_FIELD_PPPoE_PID):
                     return KG_SCH_KN_PPPID;
-                case(NET_HEADER_FIELD_PPPoE_SID):
+                case (NET_HEADER_FIELD_PPPoE_SID):
                     return KG_SCH_KN_PPPSID;
                 default:
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
@@ -653,7 +653,7 @@ static uint8_t GetKnownFieldId(uint32_t bitMask)
     uint8_t cnt = 0;
 
     while (bitMask)
-        if(bitMask & 0x80000000)
+        if (bitMask & 0x80000000)
             break;
         else
         {
@@ -669,24 +669,24 @@ static uint8_t GetExtractedOrMask(uint8_t bitOffset, bool fqid)
     uint8_t i, mask, numOfOnesToClear, walking1Mask = 1;
 
     /* bitOffset 1-7 --> mask 0x1-0x7F */
-    if(bitOffset<8)
+    if (bitOffset<8)
     {
         mask = 0;
-        for(i = 0 ; i < bitOffset ; i++, walking1Mask <<= 1)
+        for (i = 0 ; i < bitOffset ; i++, walking1Mask <<= 1)
             mask |= walking1Mask;
     }
     else
     {
        mask = 0xFF;
        numOfOnesToClear = 0;
-       if(fqid && bitOffset>24)
+       if (fqid && bitOffset>24)
            /* bitOffset 25-31 --> mask 0xFE-0x80 */
            numOfOnesToClear = (uint8_t)(bitOffset-24);
        else
           /* bitOffset 9-15 --> mask 0xFE-0x80 */
-          if(!fqid && bitOffset>8)
+          if (!fqid && bitOffset>8)
                numOfOnesToClear = (uint8_t)(bitOffset-8);
-       for(i = 0 ; i < numOfOnesToClear ; i++, walking1Mask <<= 1)
+       for (i = 0 ; i < numOfOnesToClear ; i++, walking1Mask <<= 1)
            mask &= ~walking1Mask;
        /* bitOffset 8-24 for FQID, 8 for PP --> no mask (0xFF)*/
     }
@@ -729,7 +729,7 @@ static void DecSchemeOwners(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleBindPortToSche
     p_FmPcdKg = p_FmPcd->p_FmPcdKg;
 
     /* for each scheme - update owners counters */
-    for(i = 0; i < p_BindPort->numOfSchemes; i++)
+    for (i = 0; i < p_BindPort->numOfSchemes; i++)
     {
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
         ASSERT_COND(relativeSchemeId < FM_PCD_KG_NUM_OF_SCHEMES);
@@ -747,10 +747,10 @@ static void DecSchemeOwners(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleBindPortToSche
 static void UpateSchemePointedOwner(t_FmPcdKgScheme *p_Scheme, bool add)
 {
     /* this routine is locked by the calling routine */
-   ASSERT_COND(p_Scheme);
-   ASSERT_COND(p_Scheme->valid);
+    ASSERT_COND(p_Scheme);
+    ASSERT_COND(p_Scheme->valid);
 
-    if(add)
+    if (add)
         p_Scheme->pointedOwners++;
     else
         p_Scheme->pointedOwners--;
@@ -773,7 +773,7 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
     /* lock a common KG reg */
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
     err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-    if(err)
+    if (err)
     {
         KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         RETURN_ERROR(MINOR, err, NO_MSG);
@@ -781,7 +781,7 @@ static t_Error KgWriteSp(t_FmPcd *p_FmPcd, uint8_t hardwarePortId, uint32_t spRe
 
     tmpKgpeSp = GET_UINT32(p_FmPcdKgPortRegs->kgoe_sp);
 
-    if(add)
+    if (add)
         tmpKgpeSp |= spReg;
     else /* clear */
         tmpKgpeSp &= ~spReg;
@@ -870,21 +870,21 @@ static void PcdKgErrorException(t_Handle h_FmPcd)
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgfeer, force & ~event);
 
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeer, event);
     WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgseer, schemeIndexes);
 
-    if(event & FM_PCD_KG_DOUBLE_ECC)
+    if (event & FM_PCD_KG_DOUBLE_ECC)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC);
-    if(event & FM_PCD_KG_KEYSIZE_OVERFLOW)
+    if (event & FM_PCD_KG_KEYSIZE_OVERFLOW)
     {
-        if(schemeIndexes)
+        if (schemeIndexes)
         {
-            while(schemeIndexes)
+            while (schemeIndexes)
             {
-                if(schemeIndexes & 0x1)
+                if (schemeIndexes & 0x1)
                     p_FmPcd->f_FmPcdIndexedException(p_FmPcd->h_App,e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW, (uint16_t)(31 - index));
                 schemeIndexes >>= 1;
                 index+=1;
@@ -922,7 +922,7 @@ static t_Error KgInitGuest(t_FmPcd *p_FmPcd)
                                  NULL,
                                  NULL)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
-    if(replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
+    if (replyLength != (sizeof(uint32_t) + p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t)))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
     memcpy(p_FmPcd->p_FmPcdKg->schemesIds, (uint8_t*)(reply.replyBody),p_FmPcd->p_FmPcdKg->numOfSchemes*sizeof(uint8_t));
 
@@ -945,12 +945,12 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
 
     /**********************KGEEER******************/
     tmpReg = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
+    if (p_FmPcd->exceptions & FM_PCD_EX_KG_DOUBLE_ECC)
     {
         FmEnableRamsEcc(p_FmPcd->h_Fm);
         tmpReg |= FM_PCD_KG_DOUBLE_ECC;
     }
-    if(p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
+    if (p_FmPcd->exceptions & FM_PCD_EX_KG_KEYSIZE_OVERFLOW)
         tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
     WRITE_UINT32(p_Regs->kgeeer,tmpReg);
     /**********************KGEEER******************/
@@ -985,11 +985,11 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
         SW_PORT_INDX_TO_HW_PORT_ID(hardwarePortId, i);
 
         err = KgWriteSp(p_FmPcd, hardwarePortId, 0xffffffff, FALSE);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         err = KgWriteCpp(p_FmPcd, hardwarePortId, 0);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -997,13 +997,13 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
     WRITE_UINT32(p_Regs->kgseer, 0xFFFFFFFF);
     WRITE_UINT32(p_Regs->kgseeer, 0xFFFFFFFF);
 
-    if(p_FmPcd->p_FmPcdKg->numOfSchemes)
+    if (p_FmPcd->p_FmPcdKg->numOfSchemes)
     {
         err = FmPcdKgAllocSchemes(p_FmPcd,
                                   p_FmPcd->p_FmPcdKg->numOfSchemes,
                                   p_FmPcd->guestId,
                                   p_FmPcd->p_FmPcdKg->schemesIds);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -1013,7 +1013,7 @@ static t_Error KgInitMaster(t_FmPcd *p_FmPcd)
 static void  ValidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
 {
     ASSERT_COND(!p_Scheme->valid);
-    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+    if (p_Scheme->netEnvId != ILLEGAL_NETENV)
         FmPcdIncNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
     p_Scheme->valid = TRUE;
 }
@@ -1023,7 +1023,7 @@ static t_Error InvalidateSchemeSw(t_FmPcdKgScheme *p_Scheme)
     if (p_Scheme->owners)
        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Trying to delete a scheme that has ports bound to"));
 
-    if(p_Scheme->netEnvId != ILLEGAL_NETENV)
+    if (p_Scheme->netEnvId != ILLEGAL_NETENV)
         FmPcdDecNetEnvOwners(p_Scheme->h_FmPcd, p_Scheme->netEnvId);
     p_Scheme->valid = FALSE;
 
@@ -1064,14 +1064,14 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                      ("numOfDistinctionUnits should not exceed %d", FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS));
 
     /* by netEnv parameters, get match vector */
-    if(!p_SchemeParams->alwaysDirect)
+    if (!p_SchemeParams->alwaysDirect)
     {
         p_Scheme->netEnvId = FmPcdGetNetEnvId(p_SchemeParams->netEnvParams.h_NetEnv);
         netEnvParams.netEnvId = p_Scheme->netEnvId;
         netEnvParams.numOfDistinctionUnits = p_SchemeParams->netEnvParams.numOfDistinctionUnits;
         memcpy(netEnvParams.unitIds, p_SchemeParams->netEnvParams.unitIds, (sizeof(uint8_t))*p_SchemeParams->netEnvParams.numOfDistinctionUnits);
         err = PcdGetUnitsVector(p_FmPcd, &netEnvParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
         p_Scheme->matchVector = netEnvParams.vector;
     }
@@ -1081,31 +1081,31 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         p_Scheme->netEnvId = ILLEGAL_NETENV;
     }
 
-    if(p_SchemeParams->nextEngine == e_FM_PCD_INVALID)
+    if (p_SchemeParams->nextEngine == e_FM_PCD_INVALID)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next Engine of the scheme is not Valid"));
 
-    if(p_SchemeParams->bypassFqidGeneration)
+    if (p_SchemeParams->bypassFqidGeneration)
     {
 #ifdef FM_KG_NO_BYPASS_FQID_GEN
         if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassFqidGeneration."));
 #endif /* FM_KG_NO_BYPASS_FQID_GEN */
-        if(p_SchemeParams->baseFqid)
+        if (p_SchemeParams->baseFqid)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid set for a scheme that does not generate an FQID"));
     }
     else
-        if(!p_SchemeParams->baseFqid)
+        if (!p_SchemeParams->baseFqid)
             DBG(WARNING, ("baseFqid is 0."));
 
-    if(p_SchemeParams->nextEngine == e_FM_PCD_PLCR)
+    if (p_SchemeParams->nextEngine == e_FM_PCD_PLCR)
     {
         direct = p_SchemeParams->kgNextEngineParams.plcrProfile.direct;
         p_Scheme->directPlcr = direct;
         absolute = (bool)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? TRUE : FALSE);
-        if(!direct && absolute)
+        if (!direct && absolute)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Indirect policing is not available when profile is shared."));
 
-        if(direct)
+        if (direct)
         {
             profileId = p_SchemeParams->kgNextEngineParams.plcrProfile.profileSelect.directRelativeProfileId;
             numOfProfiles = 1;
@@ -1118,10 +1118,10 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         }
     }
 
-    if(p_SchemeParams->nextEngine == e_FM_PCD_CC)
+    if (p_SchemeParams->nextEngine == e_FM_PCD_CC)
     {
 #ifdef FM_KG_NO_BYPASS_PLCR_PROFILE_GEN
-        if((p_SchemeParams->kgNextEngineParams.cc.plcrNext) && (p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
+        if ((p_SchemeParams->kgNextEngineParams.cc.plcrNext) && (p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
         {
             if ((p_FmPcd->fmRevInfo.majorRev != 4) && (p_FmPcd->fmRevInfo.majorRev < 6))
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("bypassPlcrProfileGeneration."));
@@ -1132,18 +1132,18 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                              p_SchemeParams->kgNextEngineParams.cc.grpId,
                              &grpBits,
                              &grpBase);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
         p_Scheme->ccUnits = grpBits;
 
-        if((p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
+        if ((p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
            (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration))
         {
-                if(p_SchemeParams->kgNextEngineParams.cc.plcrProfile.sharedProfile)
+                if (p_SchemeParams->kgNextEngineParams.cc.plcrProfile.sharedProfile)
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Shared profile may not be used after Coarse classification."));
                 absolute = FALSE;
                 direct = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.direct;
-                if(direct)
+                if (direct)
                 {
                     profileId = p_SchemeParams->kgNextEngineParams.cc.plcrProfile.profileSelect.directRelativeProfileId;
                     numOfProfiles = 1;
@@ -1158,20 +1158,20 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
     }
 
     /* if policer is used directly after KG, or after CC */
-    if((p_SchemeParams->nextEngine == e_FM_PCD_PLCR)  ||
+    if ((p_SchemeParams->nextEngine == e_FM_PCD_PLCR)  ||
        ((p_SchemeParams->nextEngine == e_FM_PCD_CC) &&
         (p_SchemeParams->kgNextEngineParams.cc.plcrNext) &&
         (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)))
     {
         /* if private policer profile, it may be uninitialized yet, therefore no checks are done at this stage */
-        if(absolute)
+        if (absolute)
         {
             /* for absolute direct policy only, */
             relativeProfileId = profileId;
             err = FmPcdPlcrGetAbsoluteIdByProfileParams((t_Handle)p_FmPcd,e_FM_PCD_PLCR_SHARED,NULL, relativeProfileId, &profileId);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, ("Shared profile not valid offset"));
-            if(!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
+            if (!FmPcdPlcrIsProfileValid(p_FmPcd, profileId))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Shared profile not valid."));
             p_Scheme->relativeProfileId = profileId;
         }
@@ -1187,10 +1187,10 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
     {
         /* if policer is NOT going to be used after KG at all than if bypassFqidGeneration
         is set, we do not need numOfUsedExtractedOrs and hashDistributionNumOfFqids */
-        if(p_SchemeParams->bypassFqidGeneration && p_SchemeParams->numOfUsedExtractedOrs)
+        if (p_SchemeParams->bypassFqidGeneration && p_SchemeParams->numOfUsedExtractedOrs)
             RETURN_ERROR(MAJOR, E_INVALID_STATE,
                     ("numOfUsedExtractedOrs is set in a scheme that does not generate FQID or policer profile ID"));
-        if(p_SchemeParams->bypassFqidGeneration &&
+        if (p_SchemeParams->bypassFqidGeneration &&
                 p_SchemeParams->useHash &&
                 p_SchemeParams->keyExtractAndHashParams.hashDistributionNumOfFqids)
             RETURN_ERROR(MAJOR, E_INVALID_STATE,
@@ -1199,24 +1199,24 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
     /* configure all 21 scheme registers */
     tmpReg =  KG_SCH_MODE_EN;
-    switch(p_SchemeParams->nextEngine)
+    switch (p_SchemeParams->nextEngine)
     {
-        case(e_FM_PCD_PLCR):
+        case (e_FM_PCD_PLCR):
             /* add to mode register - NIA */
             tmpReg |= KG_SCH_MODE_NIA_PLCR;
             tmpReg |= NIA_ENG_PLCR;
             tmpReg |= (uint32_t)(p_SchemeParams->kgNextEngineParams.plcrProfile.sharedProfile ? NIA_PLCR_ABSOLUTE:0);
             /* initialize policer profile command - */
             /*  configure kgse_ppc  */
-            if(direct)
+            if (direct)
             /* use profileId as base, other fields are 0 */
                 p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
             else
             {
-                if(shift > MAX_PP_SHIFT)
+                if (shift > MAX_PP_SHIFT)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
 
-                if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                if (!numOfProfiles || !POWER_OF_2(numOfProfiles))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
 
                 ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
@@ -1227,30 +1227,30 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                 p_SchemeRegs->kgse_ppc = ppcTmp;
             }
             break;
-        case(e_FM_PCD_CC):
+        case (e_FM_PCD_CC):
             /* mode reg - define NIA */
             tmpReg |= (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC);
 
             p_SchemeRegs->kgse_ccbs = grpBits;
             tmpReg |= (uint32_t)(grpBase << KG_SCH_MODE_CCOBASE_SHIFT);
 
-            if(p_SchemeParams->kgNextEngineParams.cc.plcrNext)
+            if (p_SchemeParams->kgNextEngineParams.cc.plcrNext)
             {
-                if(!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
+                if (!p_SchemeParams->kgNextEngineParams.cc.bypassPlcrProfileGeneration)
                 {
                     /* find out if absolute or relative */
-                    if(absolute)
+                    if (absolute)
                          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("It is illegal to request a shared profile in a scheme that is in a KG->CC->PLCR flow"));
-                    if(direct)
+                    if (direct)
                     {
                         /* mask = 0, base = directProfileId */
                         p_SchemeRegs->kgse_ppc = (uint32_t)profileId;
                     }
                     else
                     {
-                        if(shift > MAX_PP_SHIFT)
+                        if (shift > MAX_PP_SHIFT)
                             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fqidOffsetShift may not be larger than %d", MAX_PP_SHIFT));
-                        if(!numOfProfiles || !POWER_OF_2(numOfProfiles))
+                        if (!numOfProfiles || !POWER_OF_2(numOfProfiles))
                             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfProfiles must not be 0 and must be a power of 2"));
 
                         ppcTmp = ((uint32_t)shift << KG_SCH_PP_SHIFT_HIGH_SHIFT) & KG_SCH_PP_SHIFT_HIGH;
@@ -1265,8 +1265,8 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                     ppcTmp = KG_SCH_PP_NO_GEN;
             }
             break;
-        case(e_FM_PCD_DONE):
-            if(p_SchemeParams->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
+        case (e_FM_PCD_DONE):
+            if (p_SchemeParams->kgNextEngineParams.doneAction == e_FM_PCD_DROP_FRAME)
                 tmpReg |= GET_NIA_BMI_AC_DISCARD_FRAME(p_FmPcd);
             else
                 tmpReg |= GET_NIA_BMI_AC_ENQ_FRAME(p_FmPcd);
@@ -1316,7 +1316,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         p_SchemeRegs->kgse_vsp = KG_SCH_VSP_NO_KSP_EN;
 #endif /* (DPAA_VERSION >= 11) */
 
-    if(p_SchemeParams->useHash)
+    if (p_SchemeParams->useHash)
     {
         p_KeyAndHash = &p_SchemeParams->keyExtractAndHashParams;
 
@@ -1329,70 +1329,70 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         /*  configure kgse_dv1  */
         p_SchemeRegs->kgse_dv1 = p_KeyAndHash->privateDflt1;
 
-        if(!p_SchemeParams->bypassFqidGeneration)
+        if (!p_SchemeParams->bypassFqidGeneration)
         {
-            if(!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
+            if (!p_KeyAndHash->hashDistributionNumOfFqids || !POWER_OF_2(p_KeyAndHash->hashDistributionNumOfFqids))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionNumOfFqids must not be 0 and must be a power of 2"));
-            if((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_SchemeParams->baseFqid)
+            if ((p_KeyAndHash->hashDistributionNumOfFqids-1) & p_SchemeParams->baseFqid)
                 DBG(WARNING, ("baseFqid unaligned. Distribution may result in less than hashDistributionNumOfFqids queues."));
         }
 
         /*  configure kgse_ekdv  */
         tmpReg = 0;
-        for( i=0 ;i<p_KeyAndHash->numOfUsedDflts ; i++)
+        for ( i=0 ;i<p_KeyAndHash->numOfUsedDflts ; i++)
         {
-            switch(p_KeyAndHash->dflts[i].type)
+            switch (p_KeyAndHash->dflts[i].type)
             {
-                case(e_FM_PCD_KG_MAC_ADDR):
+                case (e_FM_PCD_KG_MAC_ADDR):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MAC_ADDR_SHIFT);
                     break;
-                case(e_FM_PCD_KG_TCI):
+                case (e_FM_PCD_KG_TCI):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCI_SHIFT);
                     break;
-                case(e_FM_PCD_KG_ENET_TYPE):
+                case (e_FM_PCD_KG_ENET_TYPE):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_ENET_TYPE_SHIFT);
                     break;
-                case(e_FM_PCD_KG_PPP_SESSION_ID):
+                case (e_FM_PCD_KG_PPP_SESSION_ID):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_SESSION_ID_SHIFT);
                     break;
-                case(e_FM_PCD_KG_PPP_PROTOCOL_ID):
+                case (e_FM_PCD_KG_PPP_PROTOCOL_ID):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PPP_PROTOCOL_ID_SHIFT);
                     break;
-                case(e_FM_PCD_KG_MPLS_LABEL):
+                case (e_FM_PCD_KG_MPLS_LABEL):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_MPLS_LABEL_SHIFT);
                     break;
-                case(e_FM_PCD_KG_IP_ADDR):
+                case (e_FM_PCD_KG_IP_ADDR):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_ADDR_SHIFT);
                     break;
-                case(e_FM_PCD_KG_PROTOCOL_TYPE):
+                case (e_FM_PCD_KG_PROTOCOL_TYPE):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_PROTOCOL_TYPE_SHIFT);
                     break;
-                case(e_FM_PCD_KG_IP_TOS_TC):
+                case (e_FM_PCD_KG_IP_TOS_TC):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IP_TOS_TC_SHIFT);
                     break;
-                case(e_FM_PCD_KG_IPV6_FLOW_LABEL):
+                case (e_FM_PCD_KG_IPV6_FLOW_LABEL):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
                     break;
-                case(e_FM_PCD_KG_IPSEC_SPI):
+                case (e_FM_PCD_KG_IPSEC_SPI):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_IPSEC_SPI_SHIFT);
                     break;
-                case(e_FM_PCD_KG_L4_PORT):
+                case (e_FM_PCD_KG_L4_PORT):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_L4_PORT_SHIFT);
                     break;
-                case(e_FM_PCD_KG_TCP_FLAG):
+                case (e_FM_PCD_KG_TCP_FLAG):
                     tmpReg |= (p_KeyAndHash->dflts[i].dfltSelect << KG_SCH_DEF_TCP_FLAG_SHIFT);
                     break;
-                case(e_FM_PCD_KG_GENERIC_FROM_DATA):
+                case (e_FM_PCD_KG_GENERIC_FROM_DATA):
                     swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA;
                     swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
                     numOfSwDefaults ++;
                     break;
-                case(e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V):
+                case (e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V):
                     swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V;
                     swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
                     numOfSwDefaults ++;
                     break;
-                case(e_FM_PCD_KG_GENERIC_NOT_FROM_DATA):
+                case (e_FM_PCD_KG_GENERIC_NOT_FROM_DATA):
                     swDefaults[numOfSwDefaults].type = e_FM_PCD_KG_GENERIC_NOT_FROM_DATA;
                     swDefaults[numOfSwDefaults].dfltSelect = p_KeyAndHash->dflts[i].dfltSelect;
                     numOfSwDefaults ++;
@@ -1404,29 +1404,29 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         p_SchemeRegs->kgse_ekdv = tmpReg;
 
         p_LocalExtractsArray = (t_FmPcdKgSchemesExtracts *)XX_Malloc(sizeof(t_FmPcdKgSchemesExtracts));
-        if(!p_LocalExtractsArray)
+        if (!p_LocalExtractsArray)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
 
         /*  configure kgse_ekfc and  kgse_gec */
         knownTmp = 0;
-        for( i=0 ;i<p_KeyAndHash->numOfUsedExtracts ; i++)
+        for ( i=0 ;i<p_KeyAndHash->numOfUsedExtracts ; i++)
         {
             p_Extract = &p_KeyAndHash->extractArray[i];
-            switch(p_Extract->type)
+            switch (p_Extract->type)
             {
-                case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+                case (e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
                     knownTmp |= KG_SCH_KN_PORT_ID;
                     /* save in driver structure */
                     p_LocalExtractsArray->extractsArray[i].id = GetKnownFieldId(KG_SCH_KN_PORT_ID);
                     p_LocalExtractsArray->extractsArray[i].known = TRUE;
                     break;
-                case(e_FM_PCD_EXTRACT_BY_HDR):
-                    switch(p_Extract->extractByHdr.hdr)
+                case (e_FM_PCD_EXTRACT_BY_HDR):
+                    switch (p_Extract->extractByHdr.hdr)
                     {
-                        case(HEADER_TYPE_UDP_ENCAP_ESP):
-                            switch(p_Extract->extractByHdr.type)
+                        case (HEADER_TYPE_UDP_ENCAP_ESP):
+                            switch (p_Extract->extractByHdr.type)
                             {
-                                case(e_FM_PCD_EXTRACT_FROM_HDR):
+                                case (e_FM_PCD_EXTRACT_FROM_HDR):
                                     /* case where extraction from ESP only */
                                     if (p_Extract->extractByHdr.extractByHdrType.fromHdr.offset >= UDP_HEADER_SIZE)
                                     {
@@ -1440,23 +1440,23 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                                         p_Extract->extractByHdr.ignoreProtocolValidation = FALSE;
                                     }
                                     break;
-                                case(e_FM_PCD_EXTRACT_FROM_FIELD):
-                                    switch(p_Extract->extractByHdr.extractByHdrType.fromField.field.udpEncapEsp)
+                                case (e_FM_PCD_EXTRACT_FROM_FIELD):
+                                    switch (p_Extract->extractByHdr.extractByHdrType.fromField.field.udpEncapEsp)
                                     {
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
                                             p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
                                             break;
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                                             /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
@@ -1465,23 +1465,23 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                                             break;
                                     }
                                     break;
-                                case(e_FM_PCD_EXTRACT_FULL_FIELD):
-                                    switch(p_Extract->extractByHdr.extractByHdrType.fullField.udpEncapEsp)
+                                case (e_FM_PCD_EXTRACT_FULL_FIELD):
+                                    switch (p_Extract->extractByHdr.extractByHdrType.fullField.udpEncapEsp)
                                     {
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_SRC):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_PORT_DST):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_LEN):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_CKSUM):
                                             p_Extract->extractByHdr.hdr = HEADER_TYPE_UDP;
                                             break;
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SPI_SIZE;
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.offset = ESP_SPI_OFFSET;
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
-                                        case(NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
+                                        case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
                                             p_Extract->extractByHdr.extractByHdrType.fromHdr.size = ESP_SEQ_NUM_SIZE;
@@ -1495,9 +1495,9 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                         default:
                             break;
                     }
-                    switch(p_Extract->extractByHdr.type)
+                    switch (p_Extract->extractByHdr.type)
                     {
-                        case(e_FM_PCD_EXTRACT_FROM_HDR):
+                        case (e_FM_PCD_EXTRACT_FROM_HDR):
                             generic = TRUE;
                             /* get the header code for the generic extract */
                             code = GetGenHdrCode(p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex, p_Extract->extractByHdr.ignoreProtocolValidation);
@@ -1505,7 +1505,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                             offset = p_Extract->extractByHdr.extractByHdrType.fromHdr.offset;
                             size = p_Extract->extractByHdr.extractByHdrType.fromHdr.size;
                             break;
-                        case(e_FM_PCD_EXTRACT_FROM_FIELD):
+                        case (e_FM_PCD_EXTRACT_FROM_FIELD):
                             generic = TRUE;
                             /* get the field code for the generic extract */
                             code = GetGenFieldCode(p_Extract->extractByHdr.hdr,
@@ -1513,13 +1513,13 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                             offset = p_Extract->extractByHdr.extractByHdrType.fromField.offset;
                             size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                             break;
-                        case(e_FM_PCD_EXTRACT_FULL_FIELD):
-                            if(!p_Extract->extractByHdr.ignoreProtocolValidation)
+                        case (e_FM_PCD_EXTRACT_FULL_FIELD):
+                            if (!p_Extract->extractByHdr.ignoreProtocolValidation)
                             {
                                 /* if we have a known field for it - use it, otherwise use generic */
                                 bitMask = GetKnownProtMask(p_FmPcd, p_Extract->extractByHdr.hdr, p_Extract->extractByHdr.hdrIndex,
                                             p_Extract->extractByHdr.extractByHdrType.fullField);
-                                if(bitMask)
+                                if (bitMask)
                                 {
                                     knownTmp |= bitMask;
                                     /* save in driver structure */
@@ -1532,7 +1532,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                             }
                             else
                                 generic = TRUE;
-                            if(generic)
+                            if (generic)
                             {
                                 /* tmp - till we cover more headers under generic */
                                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
@@ -1542,7 +1542,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
                     }
                     break;
-                case(e_FM_PCD_EXTRACT_NON_HDR):
+                case (e_FM_PCD_EXTRACT_NON_HDR):
                     /* use generic */
                     generic = TRUE;
                     offset = 0;
@@ -1555,22 +1555,22 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                     RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
             }
 
-            if(generic)
+            if (generic)
             {
                 /* set generic register fields */
-                if(currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
+                if (currGenId >= FM_PCD_KG_NUM_OF_GENERIC_REGS)
                     RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
-                if(!code)
+                if (!code)
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
 
                 genTmp = KG_SCH_GEN_VALID;
                 genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
                 genTmp |= offset;
-                if((size > MAX_KG_SCH_SIZE) || (size < 1))
+                if ((size > MAX_KG_SCH_SIZE) || (size < 1))
                       RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
                 genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
                 swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
-                if(swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
+                if (swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
                     DBG(WARNING, ("No sw default configured"));
 
                 genTmp |= swDefault << KG_SCH_GEN_DEF_SHIFT;
@@ -1588,9 +1588,9 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         maskTmp = 0xFFFFFFFF;
         /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
 
-        if(p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+        if (p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Only %d masks supported", FM_PCD_KG_NUM_OF_EXTRACT_MASKS));
-        for( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
+        for ( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
         {
             /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
             id = p_LocalExtractsArray->extractsArray[p_KeyAndHash->masks[i].extractArrayIndex].id;
@@ -1623,9 +1623,9 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         /* kgse_fqb will be written t the end of the routine */
 
         /*  configure kgse_hc  */
-        if(p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
+        if (p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
-        if(p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
+        if (p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
 
         tmpReg = 0;
@@ -1633,9 +1633,9 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         tmpReg |= ((p_KeyAndHash->hashDistributionNumOfFqids - 1) << p_KeyAndHash->hashDistributionFqidsShift);
         tmpReg |= p_KeyAndHash->hashShift << KG_SCH_HASH_CONFIG_SHIFT_SHIFT;
 
-        if(p_KeyAndHash->symmetricHash)
+        if (p_KeyAndHash->symmetricHash)
         {
-            if((!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACDST)) ||
+            if ((!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_MACDST)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC1) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST1)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC2) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST2)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PDST)))
@@ -1658,7 +1658,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         curr = 0;
         for (i=0;i<p_KeyAndHash->numOfUsedExtracts ; i++)
         {
-            if(p_LocalExtractsArray->extractsArray[i].known)
+            if (p_LocalExtractsArray->extractsArray[i].known)
             {
                 ASSERT_COND(curr<(p_KeyAndHash->numOfUsedExtracts - currGenId));
                 j = curr;
@@ -1666,7 +1666,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
                 index in the user's extractions array */
                 /* we compare the id of the current extract with the id of the extract in the orderedArray[j-1]
                 location */
-                while((j > 0) && (p_LocalExtractsArray->extractsArray[i].id <
+                while ((j > 0) && (p_LocalExtractsArray->extractsArray[i].id <
                       p_LocalExtractsArray->extractsArray[p_Scheme->orderedArray[j-1]].id))
                 {
                     p_Scheme->orderedArray[j] =
@@ -1700,38 +1700,38 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         p_SchemeRegs->kgse_dv1 = 0;
     }
 
-    if(p_SchemeParams->bypassFqidGeneration)
+    if (p_SchemeParams->bypassFqidGeneration)
         p_SchemeRegs->kgse_hc |= KG_SCH_HASH_CONFIG_NO_FQID;
 
     /*  configure kgse_spc  */
-    if( p_SchemeParams->schemeCounter.update)
+    if ( p_SchemeParams->schemeCounter.update)
         p_SchemeRegs->kgse_spc = p_SchemeParams->schemeCounter.value;
 
 
     /* check that are enough generic registers */
-    if(p_SchemeParams->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
+    if (p_SchemeParams->numOfUsedExtractedOrs + currGenId > FM_PCD_KG_NUM_OF_GENERIC_REGS)
         RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
 
     /* extracted OR mask on Qid */
-    for( i=0 ;i<p_SchemeParams->numOfUsedExtractedOrs ; i++)
+    for ( i=0 ;i<p_SchemeParams->numOfUsedExtractedOrs ; i++)
     {
 
         p_Scheme->extractedOrs = TRUE;
         /*  configure kgse_gec[i]  */
         p_ExtractOr = &p_SchemeParams->extractedOrs[i];
-        switch(p_ExtractOr->type)
+        switch (p_ExtractOr->type)
         {
-            case(e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
+            case (e_FM_PCD_KG_EXTRACT_PORT_PRIVATE_INFO):
                 code = KG_SCH_GEN_PARSE_RESULT_N_FQID;
                 offset = 0;
                 break;
-            case(e_FM_PCD_EXTRACT_BY_HDR):
+            case (e_FM_PCD_EXTRACT_BY_HDR):
                 /* get the header code for the generic extract */
                 code = GetGenHdrCode(p_ExtractOr->extractByHdr.hdr, p_ExtractOr->extractByHdr.hdrIndex, p_ExtractOr->extractByHdr.ignoreProtocolValidation);
                 /* set generic register fields */
                 offset = p_ExtractOr->extractionOffset;
                 break;
-            case(e_FM_PCD_EXTRACT_NON_HDR):
+            case (e_FM_PCD_EXTRACT_NON_HDR):
                 /* get the field code for the generic extract */
                 offset = 0;
                 code = GetGenCode(p_ExtractOr->src, &offset);
@@ -1742,12 +1742,12 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         }
 
         /* set generic register fields */
-        if(!code)
+        if (!code)
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
         genTmp = KG_SCH_GEN_EXTRACT_TYPE | KG_SCH_GEN_VALID;
         genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
         genTmp |= offset;
-        if(!!p_ExtractOr->bitOffsetInFqid == !!p_ExtractOr->bitOffsetInPlcrProfile)
+        if (!!p_ExtractOr->bitOffsetInFqid == !!p_ExtractOr->bitOffsetInPlcrProfile)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" extracted byte must effect either FQID or Policer profile"));
 
         /************************************************************************************
@@ -1791,11 +1791,11 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
         ************************************************************************************/
 
-        if(p_ExtractOr->bitOffsetInFqid)
+        if (p_ExtractOr->bitOffsetInFqid)
         {
-            if(p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_FQID_BIT_OFFSET )
+            if (p_ExtractOr->bitOffsetInFqid > MAX_KG_SCH_FQID_BIT_OFFSET )
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInFqid out of range)"));
-            if(p_ExtractOr->bitOffsetInFqid<8)
+            if (p_ExtractOr->bitOffsetInFqid<8)
                 genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid+24) << KG_SCH_GEN_SIZE_SHIFT);
             else
                 genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInFqid-8) << KG_SCH_GEN_SIZE_SHIFT);
@@ -1803,7 +1803,7 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
         }
         else /* effect policer profile */
         {
-            if(p_ExtractOr->bitOffsetInPlcrProfile > MAX_KG_SCH_PP_BIT_OFFSET )
+            if (p_ExtractOr->bitOffsetInPlcrProfile > MAX_KG_SCH_PP_BIT_OFFSET )
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal extraction (bitOffsetInPlcrProfile out of range)"));
             p_Scheme->bitOffsetInPlcrProfile = p_ExtractOr->bitOffsetInPlcrProfile;
             genTmp |= (uint32_t)((p_ExtractOr->bitOffsetInPlcrProfile+16) << KG_SCH_GEN_SIZE_SHIFT);
@@ -1819,12 +1819,12 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme          *p_Scheme,
 
     }
     /* clear all unused GEC registers */
-    for( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+    for ( i=currGenId ;i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
         p_SchemeRegs->kgse_gec[i] = 0;
 
     /* add base Qid for this scheme */
     /* add configuration for kgse_fqb */
-    if(p_SchemeParams->baseFqid & ~0x00FFFFFF)
+    if (p_SchemeParams->baseFqid & ~0x00FFFFFF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("baseFqid must be between 1 and 2^24-1"));
 
     fqbTmp |= p_SchemeParams->baseFqid;
@@ -1856,7 +1856,7 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
 
     /* find a new clsPlan group */
     for (i = 0; i < FM_MAX_NUM_OF_PORTS; i++)
-        if(!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
+        if (!p_FmPcd->p_FmPcdKg->clsPlanGrps[i].used)
             break;
     if (i == FM_MAX_NUM_OF_PORTS)
         RETURN_ERROR(MAJOR, E_FULL,("No classification plan groups available."));
@@ -1883,7 +1883,7 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     {
         err = KgAllocClsPlanEntries(h_FmPcd, p_ClsPlanGrp->sizeOfGrp, p_FmPcd->guestId, &p_ClsPlanGrp->baseEntry);
 
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
     }
     else
@@ -1923,7 +1923,7 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     p_ClsPlanSet->numOfClsPlanEntries = p_ClsPlanGrp->sizeOfGrp;
 
     oredVectors = 0;
-    for(i = 0; i<p_Grp->numOfOptions; i++)
+    for (i = 0; i<p_Grp->numOfOptions; i++)
     {
         oredVectors |= p_Grp->optVectors[i];
         /* save an array of used options - the indexes represent the power of 2 index */
@@ -1932,10 +1932,10 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     /* set the classification plan relevant entries so that all bits
      * relevant to the list of options is cleared
      */
-    for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+    for (j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
         p_ClsPlanSet->vectors[j] = ~oredVectors;
 
-    for(i = 0; i<p_Grp->numOfOptions; i++)
+    for (i = 0; i<p_Grp->numOfOptions; i++)
     {
        /* option i got the place 2^i in the clsPlan array. all entries that
          * have bit i set, should have the vector bit cleared. So each option
@@ -1959,9 +1959,9 @@ t_Error FmPcdKgBuildClsPlanGrp(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
         /* now for each option (i), we set their bits in all entries (j)
          * that contain bit 2^i.
          */
-        for(j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
+        for (j = 0; j<p_ClsPlanGrp->sizeOfGrp; j++)
         {
-            if(j & (1<<i))
+            if (j & (1<<i))
                 p_ClsPlanSet->vectors[j] |= p_Grp->optVectors[i];
         }
     }
@@ -2030,7 +2030,7 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
             REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
             return;
         }
-        if((t_Error)reply.error != E_OK)
+        if ((t_Error)reply.error != E_OK)
         {
             REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Free KG clsPlan failed"));
             return;
@@ -2052,35 +2052,35 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
     /* for each scheme */
-    for(i = 0; i<p_BindPort->numOfSchemes; i++)
+    for (i = 0; i<p_BindPort->numOfSchemes; i++)
     {
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, p_BindPort->schemesIds[i]);
-        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+        if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
             RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
-        if(add)
+        if (add)
         {
             p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
             if (!FmPcdKgIsSchemeValidSw(p_Scheme))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested scheme is invalid."));
             /* check netEnvId  of the port against the scheme netEnvId */
-            if((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
+            if ((p_Scheme->netEnvId != p_BindPort->netEnvId) && (p_Scheme->netEnvId != ILLEGAL_NETENV))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port may not be bound to requested scheme - differ in netEnvId"));
 
             /* if next engine is private port policer profile, we need to check that it is valid */
             HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, p_BindPort->hardwarePortId);
-            if(p_Scheme->nextRelativePlcrProfile)
+            if (p_Scheme->nextRelativePlcrProfile)
             {
-                for(j = 0;j<p_Scheme->numOfProfiles;j++)
+                for (j = 0;j<p_Scheme->numOfProfiles;j++)
                 {
                     ASSERT_COND(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].h_FmPort);
-                    if(p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
+                    if (p_Scheme->relativeProfileId+j >= p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].numOfProfiles)
                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Relative profile not in range"));
-                     if(!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
+                     if (!FmPcdPlcrIsProfileValid(p_FmPcd, (uint16_t)(p_FmPcd->p_FmPcdPlcr->portsMapping[swPortIndex].profilesBase + p_Scheme->relativeProfileId + j)))
                         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Relative profile not valid."));
                 }
             }
-            if(!p_BindPort->useClsPlan)
+            if (!p_BindPort->useClsPlan)
             {
                 /* This check may be redundant as port is a assigned to the whole NetEnv */
 
@@ -2095,10 +2095,10 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
                     tmp |= p_Scheme->ccUnits;
                     while (tmp)
                     {
-                        if(tmp & walking1Mask)
+                        if (tmp & walking1Mask)
                         {
                             tmp &= ~walking1Mask;
-                            if(!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                            if (!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
                                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
                         }
                         walking1Mask >>= 1;
@@ -2122,11 +2122,11 @@ t_Error FmPcdKgBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPort
     t_Error                 err = E_OK;
 
     err = FmPcdKgBuildBindPortToSchemes(h_FmPcd, p_SchemeBind, &spReg, TRUE);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, TRUE);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     IncSchemeOwners(p_FmPcd, p_SchemeBind);
@@ -2141,11 +2141,11 @@ t_Error FmPcdKgUnbindPortToSchemes(t_Handle h_FmPcd, t_FmPcdKgInterModuleBindPor
     t_Error                 err = E_OK;
 
     err = FmPcdKgBuildBindPortToSchemes(p_FmPcd, p_SchemeBind, &spReg, FALSE);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     err = KgWriteSp(p_FmPcd, p_SchemeBind->hardwarePortId, spReg, FALSE);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     DecSchemeOwners(p_FmPcd, p_SchemeBind);
@@ -2164,7 +2164,7 @@ bool KgIsSchemeAlwaysDirect(t_Handle h_FmPcd, uint8_t schemeId)
 {
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
 
-    if(p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
+    if (p_FmPcd->p_FmPcdKg->schemes[schemeId].matchVector == SCHEME_ALWAYS_DIRECT)
         return TRUE;
     else
         return FALSE;
@@ -2183,7 +2183,7 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
 
     for (j = 0, i = 0; i < FM_PCD_KG_NUM_OF_SCHEMES && j < numOfSchemes; i++)
     {
-        if(!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
+        if (!p_FmPcd->p_FmPcdKg->schemesMng[i].allocated)
         {
             p_FmPcd->p_FmPcdKg->schemesMng[i].allocated = TRUE;
             p_FmPcd->p_FmPcdKg->schemesMng[i].ownerId = guestId;
@@ -2195,7 +2195,7 @@ t_Error  FmPcdKgAllocSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gue
     if (j != numOfSchemes)
     {
         /* roll back */
-        for(j--; j; j--)
+        for (j--; j; j--)
         {
             p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].allocated = FALSE;
             p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[j]].ownerId = 0;
@@ -2221,11 +2221,11 @@ t_Error  FmPcdKgFreeSchemes(t_Handle h_FmPcd, uint8_t numOfSchemes, uint8_t gues
 
     for (i = 0; i < numOfSchemes; i++)
     {
-        if(!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
+        if (!p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].allocated)
         {
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme was not previously allocated"));
         }
-        if(p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
+        if (p_FmPcd->p_FmPcdKg->schemesMng[p_SchemesIds[i]].ownerId != guestId)
         {
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Scheme is not owned by caller. "));
         }
@@ -2245,7 +2245,7 @@ t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, u
     /* This routine is issued only on master core of master partition -
        either directly or through IPC, so no need for lock */
 
-    if(!numOfClsPlanEntries)
+    if (!numOfClsPlanEntries)
         return E_OK;
 
     if ((numOfClsPlanEntries % CLS_PLAN_NUM_PER_GRP) || (!POWER_OF_2(numOfClsPlanEntries)))
@@ -2257,7 +2257,7 @@ t_Error  KgAllocClsPlanEntries(t_Handle h_FmPcd, uint16_t numOfClsPlanEntries, u
     first = 0;
     for (i = 0; i < FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;)
     {
-        if(!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
+        if (!p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated)
         {
             blocksFound++;
             i++;
@@ -2303,7 +2303,7 @@ UNUSED(guestId);
     ASSERT_COND(!(base%CLS_PLAN_NUM_PER_GRP));
 
     baseBlock = (uint8_t)(base/CLS_PLAN_NUM_PER_GRP);
-    for(i=baseBlock;i<baseBlock+numOfBlocks;i++)
+    for (i=baseBlock;i<baseBlock+numOfBlocks;i++)
     {
         ASSERT_COND(p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].allocated);
         ASSERT_COND(guestId == p_FmPcd->p_FmPcdKg->clsPlanBlocksMng[i].ownerId);
@@ -2340,7 +2340,7 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
     p_FmPcdKgPortRegs = &p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs;
 
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    for(i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
+    for (i=p_Set->baseEntry;i<p_Set->baseEntry+p_Set->numOfClsPlanEntries;i+=8)
     {
         tmpKgarReg = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
 
@@ -2350,7 +2350,7 @@ void KgSetClsPlan(t_Handle h_FmPcd, t_FmPcdKgInterModuleClsPlanSet *p_Set)
             WRITE_UINT32(p_FmPcdKgPortRegs->kgcpe[j % CLS_PLAN_NUM_PER_GRP],p_Set->vectors[j - p_Set->baseEntry]);
         }
 
-        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
+        if (WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
         {
             REPORT_ERROR(MAJOR, E_INVALID_STATE, ("WriteKgarWait FAILED"));
             KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
@@ -2381,14 +2381,14 @@ t_Handle KgConfig( t_FmPcd *p_FmPcd, t_FmPcdParams *p_FmPcdParams)
     }
     memset(p_FmPcdKg, 0, sizeof(t_FmPcdKg));
 
-    if(FmIsMaster(p_FmPcd->h_Fm))
+    if (FmIsMaster(p_FmPcd->h_Fm))
     {
         p_FmPcdKg->p_FmPcdKgRegs  = (t_FmPcdKgRegs *)UINT_TO_PTR(FmGetPcdKgBaseAddr(p_FmPcdParams->h_Fm));
         p_FmPcd->exceptions |= DEFAULT_fmPcdKgErrorExceptions;
     }
 
     p_FmPcdKg->numOfSchemes = p_FmPcdParams->numOfSchemes;
-    if((p_FmPcd->guestId == NCSW_MASTER_ID) && !p_FmPcdKg->numOfSchemes)
+    if ((p_FmPcd->guestId == NCSW_MASTER_ID) && !p_FmPcdKg->numOfSchemes)
     {
         p_FmPcdKg->numOfSchemes = FM_PCD_KG_NUM_OF_SCHEMES;
         DBG(WARNING, ("numOfSchemes was defined 0 by user, re-defined by driver to FM_PCD_KG_NUM_OF_SCHEMES"));
@@ -2412,7 +2412,7 @@ t_Error KgInit(t_FmPcd *p_FmPcd)
     else
         err =  KgInitGuest(p_FmPcd);
 
-    if(err != E_OK)
+    if (err != E_OK)
     {
         if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
             XX_FreeSpinlock(p_FmPcd->p_FmPcdKg->h_HwSpinlock);
@@ -2431,13 +2431,13 @@ t_Error KgFree(t_FmPcd *p_FmPcd)
 
     FmUnregisterIntr(p_FmPcd->h_Fm, e_FM_MOD_KG, 0, e_FM_INTR_TYPE_ERR);
 
-    if(p_FmPcd->guestId == NCSW_MASTER_ID)
+    if (p_FmPcd->guestId == NCSW_MASTER_ID)
     {
         err = FmPcdKgFreeSchemes(p_FmPcd,
                                     p_FmPcd->p_FmPcdKg->numOfSchemes,
                                     p_FmPcd->guestId,
                                     p_FmPcd->p_FmPcdKg->schemesIds);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (p_FmPcd->p_FmPcdKg->h_HwSpinlock)
@@ -2493,10 +2493,10 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     /* Get from the NetEnv the information of the clsPlan (can be already created,
      * or needs to build) */
     err = PcdGetClsPlanGrpParams(h_FmPcd, p_GrpParams);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR,err,NO_MSG);
 
-    if(p_GrpParams->grpExists)
+    if (p_GrpParams->grpExists)
     {
         /* this group was already updated (at least) in SW */
         *p_ClsPlanGrpId = p_GrpParams->clsPlanGrpId;
@@ -2536,7 +2536,7 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
     /* Set caller parameters     */
 
     /* mark if this is an empty classification group */
-    if(*p_ClsPlanGrpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
+    if (*p_ClsPlanGrpId == p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId)
         *p_IsEmptyClsPlanGrp = TRUE;
     else
         *p_IsEmptyClsPlanGrp = FALSE;
@@ -2551,7 +2551,7 @@ t_Error FmPcdKgSetOrBindToClsPlanGrp(t_Handle h_FmPcd, uint8_t hardwarePortId, u
 
     /* bind port to the new or existing group */
     err = BindPortToClsPlanGrp(p_FmPcd, hardwarePortId, p_GrpParams->clsPlanGrpId);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
@@ -2643,7 +2643,7 @@ bool FmPcdKgIsDistrOnPlcrProfile(t_Handle h_FmPcd, uint8_t schemeId)
 
    ASSERT_COND(p_FmPcd->p_FmPcdKg->schemes[schemeId].valid);
 
-    if((p_FmPcd->p_FmPcdKg->schemes[schemeId].extractedOrs &&
+    if ((p_FmPcd->p_FmPcdKg->schemes[schemeId].extractedOrs &&
         p_FmPcd->p_FmPcdKg->schemes[schemeId].bitOffsetInPlcrProfile) ||
         p_FmPcd->p_FmPcdKg->schemes[schemeId].nextRelativePlcrProfile)
         return TRUE;
@@ -2785,11 +2785,11 @@ uint8_t FmPcdKgGetRelativeSchemeId(t_Handle h_FmPcd, uint8_t schemeId)
     t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint8_t     i;
 
-    for(i = 0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
-        if(p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
+    for (i = 0;i<p_FmPcd->p_FmPcdKg->numOfSchemes;i++)
+        if (p_FmPcd->p_FmPcdKg->schemesIds[i] == schemeId)
             return i;
 
-    if(i == p_FmPcd->p_FmPcdKg->numOfSchemes)
+    if (i == p_FmPcd->p_FmPcdKg->numOfSchemes)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of partition range"));
 
     return FM_PCD_KG_NUM_OF_SCHEMES;
@@ -2832,10 +2832,10 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
     {
         if (requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
-            switch(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine)
+            switch (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine)
             {
-                case(e_FM_PCD_DONE):
-                    if(p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction == e_FM_PCD_ENQ_FRAME)
+                case (e_FM_PCD_DONE):
+                    if (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].doneAction == e_FM_PCD_ENQ_FRAME)
                     {
                         tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
                         intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -2849,8 +2849,8 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                         KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
                     }
                 break;
-                case(e_FM_PCD_PLCR):
-                    if(!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr ||
+                case (e_FM_PCD_PLCR):
+                    if (!p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].directPlcr ||
                        (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].extractedOrs &&
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].bitOffsetInPlcrProfile) ||
                         p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextRelativePlcrProfile)
@@ -2858,7 +2858,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("In this situation PP can not be with distribution and has to be shared"));
                         }
                         err = FmPcdPlcrCcGetSetParams(h_FmPcd, p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].relativeProfileId, requiredAction);
-                        if(err)
+                        if (err)
                         {
                             RETURN_ERROR(MAJOR, err, NO_MSG);
                         }
@@ -2867,7 +2867,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,("in this situation the next engine after scheme can be or PLCR or ENQ_FRAME"));
             }
         }
-        if(requiredAction & UPDATE_KG_NIA_CC_WA)
+        if (requiredAction & UPDATE_KG_NIA_CC_WA)
         {
             if (p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId].nextEngine == e_FM_PCD_CC)
             {
@@ -2884,7 +2884,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
                 KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
            }
         }
-        if(requiredAction & UPDATE_KG_OPT_MODE)
+        if (requiredAction & UPDATE_KG_OPT_MODE)
         {
             tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
             intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -2895,7 +2895,7 @@ t_Error FmPcdKgCcGetSetParams(t_Handle h_FmPcd, t_Handle h_Scheme, uint32_t requ
             WriteKgarWait(p_FmPcd, tmpKgarReg);
             KgHwUnlock(p_FmPcd->p_FmPcdKg, intFlags);
         }
-        if(requiredAction & UPDATE_KG_NIA)
+        if (requiredAction & UPDATE_KG_NIA)
         {
             tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
             intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
@@ -2967,17 +2967,17 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
 
         relativeSchemeId = p_SchemeParams->id.relativeSchemeId;
         /* check that schemeId is in range */
-        if(relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
+        if (relativeSchemeId >= p_FmPcd->p_FmPcdKg->numOfSchemes)
         {
-            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("Scheme is out of range"));
+            REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, ("relative-scheme-id %d!", relativeSchemeId));
             return NULL;
         }
 
         p_Scheme = &p_FmPcd->p_FmPcdKg->schemes[relativeSchemeId];
-        if(FmPcdKgIsSchemeValidSw(p_Scheme))
+        if (FmPcdKgIsSchemeValidSw(p_Scheme))
         {
             REPORT_ERROR(MAJOR, E_ALREADY_EXISTS,
-                         ("Scheme is already used"));
+                         ("Scheme id (%d)!", relativeSchemeId));
             return NULL;
         }
 
@@ -2993,7 +2993,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     if (err)
     {
         REPORT_ERROR(MAJOR, err, NO_MSG);
-        if(p_SchemeParams->modify)
+        if (p_SchemeParams->modify)
             KgSchemeFlagUnlock(p_Scheme);
         if (!p_SchemeParams->modify &&
             p_Scheme->p_Lock)
@@ -3007,7 +3007,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
                                  (t_Handle)p_Scheme,
                                  &schemeRegs,
                                  p_SchemeParams->schemeCounter.update);
-        if(p_SchemeParams->modify)
+        if (p_SchemeParams->modify)
             KgSchemeFlagUnlock(p_Scheme);
         if (err)
         {
@@ -3041,7 +3041,7 @@ t_Handle FM_PCD_KgSchemeSet(t_Handle h_FmPcd,  t_FmPcdKgSchemeParams *p_SchemePa
     WRITE_UINT32(p_MemRegs->kgse_fqb,   schemeRegs.kgse_fqb);
     WRITE_UINT32(p_MemRegs->kgse_om,    schemeRegs.kgse_om);
     WRITE_UINT32(p_MemRegs->kgse_vsp,   schemeRegs.kgse_vsp);
-    for(i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
+    for (i=0 ; i<FM_PCD_KG_NUM_OF_GENERIC_REGS ; i++)
         WRITE_UINT32(p_MemRegs->kgse_gec[i], schemeRegs.kgse_gec[i]);
 
     /* call indirect command for scheme write */
@@ -3072,7 +3072,7 @@ t_Error  FM_PCD_KgSchemeDelete(t_Handle h_Scheme)
 
     /* check that no port is bound to this scheme */
     err = InvalidateSchemeSw(h_Scheme);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     if (p_FmPcd->h_Hc)
@@ -3115,7 +3115,7 @@ uint32_t  FM_PCD_KgSchemeGetCounter(t_Handle h_Scheme)
 
     physicalSchemeId = ((t_FmPcdKgScheme *)h_Scheme)->schemeId;
 
-    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+    if (FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
     tmpKgarReg = FmPcdKgBuildReadSchemeActionReg(physicalSchemeId);
@@ -3147,7 +3147,7 @@ t_Error  FM_PCD_KgSchemeSetCounter(t_Handle h_Scheme, uint32_t value)
 
     physicalSchemeId = ((t_FmPcdKgScheme *)h_Scheme)->schemeId;
     /* check that schemeId is in range */
-    if(FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
+    if (FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId) == FM_PCD_KG_NUM_OF_SCHEMES)
         REPORT_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
 
     /* read specified scheme into scheme registers */
@@ -3183,7 +3183,7 @@ t_Error FM_PCD_KgSetAdditionalDataAfterParsing(t_Handle h_FmPcd, uint8_t payload
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs, E_NULL_POINTER);
 
     p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
-    if(!FmIsMaster(p_FmPcd->h_Fm))
+    if (!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetAdditionalDataAfterParsing - guest mode!"));
 
     WRITE_UINT32(p_Regs->kgfdor,payloadOffset);
@@ -3204,10 +3204,10 @@ t_Error FM_PCD_KgSetDfltValue(t_Handle h_FmPcd, uint8_t valueId, uint32_t value)
 
     p_Regs = p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs;
 
-    if(!FmIsMaster(p_FmPcd->h_Fm))
+    if (!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_KgSetDfltValue - guest mode!"));
 
-    if(valueId == 0)
+    if (valueId == 0)
         WRITE_UINT32(p_Regs->kggdv0r,value);
     else
         WRITE_UINT32(p_Regs->kggdv1r,value);
@@ -3251,10 +3251,10 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
 
     DUMP_SUBTITLE(("\n"));
     intFlags = KgHwLock(p_FmPcd->p_FmPcdKg);
-    for(j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
+    for (j = 0;j<FM_PCD_KG_NUM_OF_SCHEMES;j++)
     {
         tmpKgarReg = FmPcdKgBuildReadSchemeActionReg((uint8_t)j);
-        if(WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
+        if (WriteKgarWait(p_FmPcd, tmpKgarReg) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.schemeRegs, ("FmPcdKgIndirectAccessSchemeRegs Scheme %d Regs", j));
@@ -3289,7 +3289,7 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
         tmpKgarReg = FmPcdKgBuildReadPortSchemeBindActionReg(hardwarePortId);
 
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.portRegs, ("FmPcdKgIndirectAccessPortRegs PCD Port %d regs", hardwarePortId));
@@ -3299,14 +3299,14 @@ t_Error FM_PCD_KgDumpRegs(t_Handle h_FmPcd)
     }
 
     DUMP_SUBTITLE(("\n"));
-    for(j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
+    for (j=0;j<FM_PCD_MAX_NUM_OF_CLS_PLANS/CLS_PLAN_NUM_PER_GRP;j++)
     {
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs, ("FmPcdKgIndirectAccessClsPlanRegs Regs group %d", j));
         DUMP_TITLE(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe, ("kgcpe"));
 
         tmpKgarReg = ReadClsPlanBlockActionReg((uint8_t)j);
         err = WriteKgarWait(p_FmPcd, tmpKgarReg);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
         DUMP_SUBSTRUCT_ARRAY(i, 8)
             DUMP_MEMORY(&p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->indirectAccessRegs.clsPlanRegs.kgcpe[i], sizeof(uint32_t));
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
index e0ad786..080b1d5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_kg.h
@@ -187,34 +187,34 @@ typedef uint8_t t_GenericCodes;
 #define MAX_KG_SCH_PP_BIT_OFFSET            15
 #define MAX_DIST_FQID_SHIFT                 23
 
-#define GET_MASK_SEL_SHIFT(shift,i)             \
-switch(i) {                                     \
-    case(0):shift = 26;break;                   \
-    case(1):shift = 20;break;                   \
-    case(2):shift = 10;break;                   \
-    case(3):shift = 4;break;                    \
-    default:                                    \
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+#define GET_MASK_SEL_SHIFT(shift,i)                 \
+switch (i) {                                        \
+    case (0):shift = 26;break;                      \
+    case (1):shift = 20;break;                      \
+    case (2):shift = 10;break;                      \
+    case (3):shift = 4;break;                       \
+    default:                                        \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);   \
 }
 
-#define GET_MASK_OFFSET_SHIFT(shift,i)          \
-switch(i) {                                     \
-    case(0):shift = 16;break;                   \
-    case(1):shift = 0;break;                    \
-    case(2):shift = 28;break;                   \
-    case(3):shift = 24;break;                   \
-    default:                                    \
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+#define GET_MASK_OFFSET_SHIFT(shift,i)              \
+switch (i) {                                        \
+    case (0):shift = 16;break;                      \
+    case (1):shift = 0;break;                       \
+    case (2):shift = 28;break;                      \
+    case (3):shift = 24;break;                      \
+    default:                                        \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);   \
 }
 
-#define GET_MASK_SHIFT(shift,i)                 \
-switch(i) {                                     \
-    case(0):shift = 24;break;                   \
-    case(1):shift = 16;break;                   \
-    case(2):shift = 8;break;                    \
-    case(3):shift = 0;break;                    \
-    default:                                    \
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);\
+#define GET_MASK_SHIFT(shift,i)                     \
+switch (i) {                                        \
+    case (0):shift = 24;break;                      \
+    case (1):shift = 16;break;                      \
+    case (2):shift = 8;break;                       \
+    case (3):shift = 0;break;                       \
+    default:                                        \
+    RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);   \
 }
 
 /***********************************************************************/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
index bb6ab48..8eb3951 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.c
@@ -57,22 +57,22 @@ static t_Handle GetManipInfo(t_FmPcdManip *p_Manip, e_ManipInfo manipInfo)
 {
      t_FmPcdManip     *p_CurManip = p_Manip;
 
-    if(!MANIP_IS_UNIFIED(p_Manip))
+    if (!MANIP_IS_UNIFIED(p_Manip))
         p_CurManip = p_Manip;
     else
     {
         /* go to first unified */
-        while(MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
+        while (MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
             p_CurManip = p_CurManip->h_PrevManip;
     }
 
-    switch(manipInfo)
+    switch (manipInfo)
     {
-        case(e_MANIP_HMCT):
+        case (e_MANIP_HMCT):
             return p_CurManip->p_Hmct;
-        case(e_MANIP_HMTD):
+        case (e_MANIP_HMTD):
             return p_CurManip->h_Ad;
-        case(e_MANIP_HANDLER_TABLE_OWNER):
+        case (e_MANIP_HANDLER_TABLE_OWNER):
             return (t_Handle)p_CurManip;
         default:
             return NULL;
@@ -83,14 +83,14 @@ static uint16_t    GetHmctSize(t_FmPcdManip *p_Manip)
     uint16_t         size = 0;
     t_FmPcdManip     *p_CurManip = p_Manip;
 
-    if(!MANIP_IS_UNIFIED(p_Manip))
+    if (!MANIP_IS_UNIFIED(p_Manip))
         return p_Manip->tableSize;
 
     /* accumulate sizes, starting with the first node */
-    while(MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
+    while (MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
         p_CurManip = p_CurManip->h_PrevManip;
 
-    while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
+    while (MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
     {
         size += p_CurManip->tableSize;
         p_CurManip = (t_FmPcdManip *)p_CurManip->h_NextManip;
@@ -104,14 +104,14 @@ static uint16_t    GetDataSize(t_FmPcdManip *p_Manip)
     uint16_t         size = 0;
     t_FmPcdManip     *p_CurManip = p_Manip;
 
-    if(!MANIP_IS_UNIFIED(p_Manip))
+    if (!MANIP_IS_UNIFIED(p_Manip))
         return p_Manip->dataSize;
 
     /* accumulate sizes, starting with the first node */
-    while(MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
+    while (MANIP_IS_UNIFIED_NON_FIRST(p_CurManip))
         p_CurManip = p_CurManip->h_PrevManip;
 
-    while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
+    while (MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
     {
         size += p_CurManip->dataSize;
         p_CurManip = (t_FmPcdManip *)p_CurManip->h_NextManip;
@@ -124,11 +124,11 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
 {
     uint8_t localDataSize, remain, tableSize = 0, dataSize = 0;
 
-    if(p_FmPcdManipParams->u.hdr.rmv)
+    if (p_FmPcdManipParams->u.hdr.rmv)
     {
-        switch(p_FmPcdManipParams->u.hdr.rmvParams.type){
-            case(e_FM_PCD_MANIP_RMV_GENERIC):
-            case(e_FM_PCD_MANIP_RMV_BY_HDR):
+        switch (p_FmPcdManipParams->u.hdr.rmvParams.type){
+            case (e_FM_PCD_MANIP_RMV_GENERIC):
+            case (e_FM_PCD_MANIP_RMV_BY_HDR):
                 /* As long as the only rmv command is the L2, no check on type is required */
                 tableSize +=  HMCD_BASIC_SIZE;
             break;
@@ -137,21 +137,21 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
         }
     }
 
-    if(p_FmPcdManipParams->u.hdr.insrt)
+    if (p_FmPcdManipParams->u.hdr.insrt)
     {
-        switch(p_FmPcdManipParams->u.hdr.insrtParams.type){
-            case(e_FM_PCD_MANIP_INSRT_GENERIC):
+        switch (p_FmPcdManipParams->u.hdr.insrtParams.type){
+            case (e_FM_PCD_MANIP_INSRT_GENERIC):
                 remain = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size % 4);
-                if(remain)
+                if (remain)
                     localDataSize = (uint8_t)(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size + 4 - remain);
                 else
                     localDataSize = p_FmPcdManipParams->u.hdr.insrtParams.u.generic.size;
                 tableSize += (uint8_t)(HMCD_BASIC_SIZE + localDataSize);
             break;
-            case(e_FM_PCD_MANIP_INSRT_BY_HDR):
+            case (e_FM_PCD_MANIP_INSRT_BY_HDR):
                 /* As long as the only insert command is the internal L2, no check on type is required */
                 tableSize += HMCD_BASIC_SIZE+HMCD_PTR_SIZE;
-                if(p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
+                if (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
                     switch (p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.u.specificL2Params.specificL2)
                     {
                         case (e_FM_PCD_MANIP_HDR_INSRT_MPLS):
@@ -165,39 +165,39 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
                 RETURN_ERROR(MINOR, E_INVALID_SELECTION, ("Unknown insrtParams.type"));
         }
     }
-    if(p_FmPcdManipParams->u.hdr.fieldUpdate)
+    if (p_FmPcdManipParams->u.hdr.fieldUpdate)
     {
-        switch(p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
-            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
+        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
                 tableSize += HMCD_BASIC_SIZE;
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
                    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                 {
                     tableSize += HMCD_PTR_SIZE;
                     dataSize += DSCP_TO_VLAN_TABLE_SIZE;
                 }
             break;
-            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
                 tableSize += HMCD_BASIC_SIZE;
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_ID)
                 {
                     tableSize += HMCD_PARAM_SIZE;
                     dataSize += 2;
                 }
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_SRC)
                     tableSize += HMCD_IPV4_ADDR_SIZE;
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_DST)
                     tableSize += HMCD_IPV4_ADDR_SIZE;
             break;
-            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
                 tableSize += HMCD_BASIC_SIZE;
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_SRC)
                     tableSize += HMCD_IPV6_ADDR_SIZE;
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV6_DST)
                     tableSize += HMCD_IPV6_ADDR_SIZE;
             break;
-            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
                     /* we implement this case with the update-checksum descriptor */
                     tableSize += HMCD_BASIC_SIZE;
                 else
@@ -209,14 +209,14 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
         }
     }
 
-    if(p_FmPcdManipParams->u.hdr.custom)
+    if (p_FmPcdManipParams->u.hdr.custom)
     {
-        switch(p_FmPcdManipParams->u.hdr.customParams.type){
-            case(e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
+        switch (p_FmPcdManipParams->u.hdr.customParams.type){
+            case (e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
             {
                 tableSize += HMCD_BASIC_SIZE + HMCD_PARAM_SIZE + HMCD_PARAM_SIZE;
                 dataSize += p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.hdrSize;
-                if((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
+                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
                         (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
                     dataSize += 2;
             }
@@ -232,11 +232,11 @@ static t_Error CalculateTableSize(t_FmPcdManipParams *p_FmPcdManipParams, uint16
     return E_OK;
 }
 
-static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams, uint32_t *p_DestHmct, uint8_t *p_DestData, bool new)
+static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams, uint8_t *p_DestHmct, uint8_t *p_DestData, bool new)
 {
-    uint32_t        *p_TmpHmct = p_DestHmct, *p_LocalData;
-    uint32_t        tmpReg=0, *p_Last=NULL;
-    uint8_t         remain, i, size=0, origSize, *p_UsrData=NULL, *p_TmpData = p_DestData;
+    uint32_t        *p_TmpHmct = (uint32_t*)p_DestHmct, *p_LocalData;
+    uint32_t        tmpReg=0, *p_Last = NULL;
+    uint8_t         remain, i, size=0, origSize, *p_UsrData = NULL, *p_TmpData = p_DestData;
     t_Handle        h_FmPcd = p_Manip->h_FmPcd;
     uint8_t         j=0;
 
@@ -250,7 +250,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.offset << HMCD_RMV_OFFSET_SHIFT;
             tmpReg |= p_FmPcdManipParams->u.hdr.rmvParams.u.generic.size << HMCD_RMV_SIZE_SHIFT;
         }
-        else if(p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_BY_HDR)
+        else if (p_FmPcdManipParams->u.hdr.rmvParams.type == e_FM_PCD_MANIP_RMV_BY_HDR)
         {
             uint8_t     hmcdOpt;
             if (!p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.type == e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2)
@@ -259,18 +259,18 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             /* initialize HMCD */
             tmpReg = (uint32_t)(HMCD_OPCODE_L2_RMV) << HMCD_OC_SHIFT;
 
-            switch(p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.specificL2)
+            switch (p_FmPcdManipParams->u.hdr.rmvParams.u.byHdr.u.specificL2)
             {
-                case(e_FM_PCD_MANIP_HDR_RMV_ETHERNET):
+                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET):
                     hmcdOpt = HMCD_RMV_L2_ETHERNET;
                     break;
-                case(e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS):
+                case (e_FM_PCD_MANIP_HDR_RMV_STACKED_QTAGS):
                     hmcdOpt = HMCD_RMV_L2_STACKED_QTAGS;
                     break;
-                case(e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS):
+                case (e_FM_PCD_MANIP_HDR_RMV_ETHERNET_AND_MPLS):
                     hmcdOpt = HMCD_RMV_L2_ETHERNET_AND_MPLS;
                     break;
-                case(e_FM_PCD_MANIP_HDR_RMV_MPLS):
+                case (e_FM_PCD_MANIP_HDR_RMV_MPLS):
                     hmcdOpt = HMCD_RMV_L2_MPLS;
                     break;
                 default:
@@ -293,7 +293,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
         if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_GENERIC)
         {
             /* initialize HMCD */
-            if(p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
+            if (p_FmPcdManipParams->u.hdr.insrtParams.u.generic.replace)
                 tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_REPLACE) << HMCD_OC_SHIFT;
             else
                 tmpReg = (uint32_t)(HMCD_OPCODE_GENERIC_INSRT) << HMCD_OC_SHIFT;
@@ -332,7 +332,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 XX_Free(p_LocalData);
         }
 
-        else if(p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_BY_HDR)
+        else if (p_FmPcdManipParams->u.hdr.insrtParams.type == e_FM_PCD_MANIP_INSRT_BY_HDR)
         {
             uint8_t     hmcdOpt;
             if (!p_FmPcdManipParams->u.hdr.insrtParams.u.byHdr.type == e_FM_PCD_MANIP_INSRT_BY_HDR_SPECIFIC_L2)
@@ -376,13 +376,13 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
 
     if (p_FmPcdManipParams->u.hdr.fieldUpdate)
     {
-        switch(p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
-            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
+        switch (p_FmPcdManipParams->u.hdr.fieldUpdateParams.type){
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_VLAN_PRI_UPDATE) << HMCD_OC_SHIFT;
 
                 /* set mode & table pointer */
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
                    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                 {
                     /* set Mode */
@@ -416,11 +416,11 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
 
                     p_TmpData += DSCP_TO_VLAN_TABLE_SIZE;
                 }
-                else if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
+                else if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType ==
                    e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
                 {
                     /* set Mode */
-                    /* TODO - line commented out as it has no-side-effect ('0' value). */
+                    /* line commented out as it has no-side-effect ('0' value). */
                     /*tmpReg |= HMCD_VLAN_PRI_UPDATE << HMCD_VLAN_PRI_REP_MODE_SHIFT*/;
                     /* set VPRI parameter */
                     tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri;
@@ -431,7 +431,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 }
                 break;
 
-            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV4):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_IPV4_UPDATE) << HMCD_OC_SHIFT;
                 if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv4.validUpdates & HDR_MANIP_IPV4_TTL)
@@ -476,19 +476,19 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 }
                 break;
 
-            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_IPV6):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_IPV6_UPDATE) << HMCD_OC_SHIFT;
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_HL)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_HL)
                     tmpReg |= HMCD_IPV6_UPDATE_HL;
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_TC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_TC)
                 {
                     tmpReg |= HMCD_IPV6_UPDATE_TC;
                     tmpReg |= p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.trafficClass << HMCD_IPV6_UPDATE_TC_SHIFT;
                 }
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
                     tmpReg |= HMCD_IPV6_UPDATE_SRC;
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
                     tmpReg |= HMCD_IPV6_UPDATE_DST;
                 /* write the first 4 bytes of the descriptor */
                 WRITE_UINT32(*p_TmpHmct, tmpReg);
@@ -496,22 +496,22 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 p_Last = p_TmpHmct;
 
                 p_TmpHmct += HMCD_BASIC_SIZE/4;
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
-                    for(i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_SRC)
+                    for (i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
                     {
                         WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.src[i]);
                         p_TmpHmct += HMCD_PTR_SIZE/4;
                     }
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
-                    for(i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.validUpdates & HDR_MANIP_IPV6_DST)
+                    for (i = 0 ; i < NET_HEADER_FIELD_IPv6_ADDR_SIZE ; i+=4)
                     {
                         WRITE_UINT32(*p_TmpHmct, *(uint32_t*)&p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.ipv6.dst[i]);
                         p_TmpHmct += HMCD_PTR_SIZE/4;
                     }
                 break;
 
-            case(e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
-                if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
+            case (e_FM_PCD_MANIP_HDR_FIELD_UPDATE_TCP_UDP):
+                if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates == HDR_MANIP_TCP_UDP_CHECKSUM)
                 {
                     /* we implement this case with the update-checksum descriptor */
                     /* set opcode */
@@ -528,9 +528,9 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     /* we implement this case with the TCP/UDP update descriptor */
                     /* set opcode */
                     tmpReg = (uint32_t)(HMCD_OPCODE_TCP_UDP_UPDATE) << HMCD_OC_SHIFT;
-                    if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
                          tmpReg |= HMCD_TCP_UDP_UPDATE_DST;
-                    if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
                          tmpReg |= HMCD_TCP_UDP_UPDATE_SRC;
                     /* write the first 4 bytes of the descriptor */
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
@@ -540,9 +540,9 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                     p_TmpHmct += HMCD_BASIC_SIZE/4;
 
                     tmpReg = 0;
-                    if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_SRC)
                         tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.src) << HMCD_TCP_UDP_UPDATE_SRC_SHIFT;
-                    if(p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
+                    if (p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.validUpdates & HDR_MANIP_TCP_UDP_DST)
                         tmpReg |= ((uint32_t)p_FmPcdManipParams->u.hdr.fieldUpdateParams.u.tcpUdp.dst);
                     WRITE_UINT32(*p_TmpHmct, tmpReg);
                     p_TmpHmct += HMCD_PTR_SIZE/4;
@@ -558,14 +558,14 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
     {
         switch (p_FmPcdManipParams->u.hdr.customParams.type)
         {
-            case(e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
+            case (e_FM_PCD_MANIP_HDR_CUSTOM_IP_REPLACE):
                 /* set opcode */
                 tmpReg = (uint32_t)(HMCD_OPCODE_REPLACE_IP) << HMCD_OC_SHIFT;
 
                 if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.decTtlHl)
                     tmpReg |= HMCD_IP_REPLACE_TTL_HL;
                 if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV4_BY_IPV6)
-                    /* TODO - line commented out as it has no-side-effect ('0' value). */
+                    /* line commented out as it has no-side-effect ('0' value). */
                     /*tmpReg |= HMCD_IP_REPLACE_REPLACE_IPV4*/;
                 else if (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4)
                 {
@@ -593,7 +593,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
                 p_TmpHmct += HMCD_PTR_SIZE/4;
                 p_TmpData += size;
 
-                if((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
+                if ((p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.replaceType == e_FM_PCD_MANIP_HDR_CUSTOM_REPLACE_IPV6_BY_IPV4) &&
                         (p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.updateIpv4Id))
                 {
                     WRITE_UINT16(*(uint16_t*)p_TmpData, p_FmPcdManipParams->u.hdr.customParams.u.ipHdrReplace.id);
@@ -613,7 +613,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
     if (p_FmPcdManipParams->h_NextManip &&
         (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip)))
     {
-        if(new)
+        if (new)
         {
         /* If this is the first time this manip is created we need to free unused memory. If it
          * is a dynamic changes case, the memory used is either the CC shadow or the existing
@@ -623,7 +623,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
             p_Manip->unifiedPosition = e_MANIP_UNIFIED_FIRST;
 
             /* The HMTD of the next Manip is never going to be used */
-            if(((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->muramAllocate)
+            if (((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->muramAllocate)
                 FM_MURAM_FreeMem(((t_FmPcd *)((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_FmPcd)->h_FmMuram, ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
             else
                 XX_Free(((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
@@ -645,16 +645,16 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManip
 
 static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    t_Error     err;
-    uint16_t    tmpReg;
-    t_FmPcdManip *p_CurManip;
-    uint8_t *p_OldHmct,*p_TmpHmctPtr, *p_TmpDataPtr;
+    t_FmPcdManip    *p_CurManip;
+    t_Error         err;
+    uint32_t        nextSize = 0, totalSize;
+    uint16_t        tmpReg;
+    uint8_t         *p_OldHmct, *p_TmpHmctPtr, *p_TmpDataPtr;
 
-    uint32_t    nextSize = 0, totalSize;
     /* set Manip structure */
-    if(p_FmPcdManipParams->h_NextManip)
+    if (p_FmPcdManipParams->h_NextManip)
     {
-        if(MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
+        if (MANIP_DONT_REPARSE(p_FmPcdManipParams->h_NextManip))
             nextSize = (uint32_t)(GetHmctSize(p_FmPcdManipParams->h_NextManip) + GetDataSize(p_FmPcdManipParams->h_NextManip));
         else
             p_Manip->cascadedNext = TRUE;
@@ -664,17 +664,17 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
     /* Allocate new table */
     /* calculate table size according to manip parameters */
     err = CalculateTableSize(p_FmPcdManipParams, &p_Manip->tableSize, &p_Manip->dataSize);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     totalSize =(uint16_t)(p_Manip->tableSize + p_Manip->dataSize + nextSize);
 
-    p_Manip->p_Hmct = (uint32_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, totalSize, 4);
+    p_Manip->p_Hmct = (uint8_t*)FM_MURAM_AllocMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, totalSize, 4);
     if (!p_Manip->p_Hmct)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc failed"));
 
     if (p_Manip->dataSize)
-        p_Manip->p_Data = (uint8_t*)p_Manip->p_Hmct + p_Manip->tableSize + nextSize;
+        p_Manip->p_Data = (uint8_t*)PTR_MOVE(p_Manip->p_Hmct, (p_Manip->tableSize + nextSize));
 
     /* update shadow size to allow runtime replacement of Header manipulation */
     /* The allocated shadow is divided as follows:
@@ -700,23 +700,29 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
         p_OldHmct = (uint8_t *)GetManipInfo(p_FmPcdManipParams->h_NextManip, e_MANIP_HMCT);
         p_CurManip = p_FmPcdManipParams->h_NextManip;
        /* Run till the last Manip (which is the first to configure) */
-        while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
+        while (MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
             p_CurManip = p_CurManip->h_NextManip;
 
-        while(p_CurManip)
+        while (p_CurManip)
         {
             /* If this is a unified table, point to the part of the table
              * which is the relative offset in HMCT.
             */
-
-            p_TmpHmctPtr = (uint8_t*)p_Manip->p_Hmct + p_Manip->tableSize + ((uint8_t*)p_CurManip->p_Hmct - p_OldHmct);
-            if(p_CurManip->p_Data)
-                p_TmpDataPtr = (uint8_t*)p_Manip->p_Hmct + p_Manip->tableSize + (p_CurManip->p_Data - p_OldHmct);
+            p_TmpHmctPtr = (uint8_t*)PTR_MOVE(p_Manip->p_Hmct,
+                                              (p_Manip->tableSize +
+                                               (PTR_TO_UINT(p_CurManip->p_Hmct) -
+                                                PTR_TO_UINT(p_OldHmct))));
+            if (p_CurManip->p_Data)
+                p_TmpDataPtr = (uint8_t*)PTR_MOVE(p_Manip->p_Hmct,
+                                                  (p_Manip->tableSize +
+                                                   (PTR_TO_UINT(p_CurManip->p_Data) -
+                                                    PTR_TO_UINT(p_OldHmct))));
             else
                 p_TmpDataPtr = NULL;
-            BuildHmct(p_CurManip, &p_CurManip->manipParams, (uint32_t*)p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr, p_TmpDataPtr, FALSE);
             /* update old manip table pointer */
-            MANIP_SET_HMCT_PTR(p_CurManip, (uint32_t*)p_TmpHmctPtr);
+            MANIP_SET_HMCT_PTR(p_CurManip, p_TmpHmctPtr);
             MANIP_SET_DATA_PTR(p_CurManip, p_TmpDataPtr);
 
             p_CurManip = p_CurManip->h_PrevManip;
@@ -751,36 +757,35 @@ static t_Error CreateManipActionNew(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p
 
     WRITE_UINT16(((t_Hmtd *)p_Manip->h_Ad)->cfg, tmpReg);
     WRITE_UINT32(((t_Hmtd *)p_Manip->h_Ad)->hmcdBasePtr,
-            (uint32_t)(XX_VirtToPhys(p_Manip->p_Hmct) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
+                 (uint32_t)(XX_VirtToPhys(p_Manip->p_Hmct) - (((t_FmPcd*)p_Manip->h_FmPcd)->physicalMuramBase)));
 
     WRITE_UINT8(((t_Hmtd *)p_Manip->h_Ad)->opCode, HMAN_OC);
 
     return E_OK;
 }
+
 static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    uint8_t         *p_WholeHmct, newDataSize, *p_TmpDataPtr = NULL;
+    uint8_t         *p_WholeHmct, *p_TmpHmctPtr, newDataSize, *p_TmpDataPtr = NULL;
     uint16_t        newSize;
     t_FmPcd         *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
-    t_Error            err;
+    t_Error         err;
     t_FmPcdManip    *p_CurManip = p_Manip;
-    uint32_t        *p_TmpHmctPtr;
-
 
     err = CalculateTableSize(p_FmPcdManipParams, &newSize, &newDataSize);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     /* check coherency of new table parameters */
-    if(newSize > p_Manip->tableSize)
+    if (newSize > p_Manip->tableSize)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (command table)."));
-    if(newDataSize > p_Manip->dataSize)
+    if (newDataSize > p_Manip->dataSize)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration requires larger size than current one (data)."));
-    if(p_FmPcdManipParams->h_NextManip)
+    if (p_FmPcdManipParams->h_NextManip)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration can not contain h_NextManip."));
-    if(MANIP_IS_UNIFIED(p_Manip) && (newSize != p_Manip->tableSize))
+    if (MANIP_IS_UNIFIED(p_Manip) && (newSize != p_Manip->tableSize))
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration in a chained manipulation requires different size than current one."));
-    if(p_Manip->dontParseAfterManip != p_FmPcdManipParams->u.hdr.dontParseAfterManip)
+    if (p_Manip->dontParseAfterManip != p_FmPcdManipParams->u.hdr.dontParseAfterManip)
         RETURN_ERROR(MINOR, E_INVALID_VALUE, ("New Hdr Manip configuration differs in dontParseAfterManip value."));
 
     p_Manip->tableSize = newSize;
@@ -788,35 +793,38 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
 
 
     /* Build the new table in the shadow */
-    if(!MANIP_IS_UNIFIED(p_Manip))
+    if (!MANIP_IS_UNIFIED(p_Manip))
     {
-        p_TmpHmctPtr = (uint32_t*)((uint8_t*)p_FmPcd->p_CcShadow + 16);
+        p_TmpHmctPtr = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow, 16);
         if (p_Manip->p_Data)
-            p_TmpDataPtr = (uint8_t*)p_FmPcd->p_CcShadow + 16 + (p_Manip->p_Data - (uint8_t*)p_Manip->p_Hmct);
+            p_TmpDataPtr = (uint8_t*)PTR_MOVE(p_TmpHmctPtr,
+                                              (PTR_TO_UINT(p_Manip->p_Data) - PTR_TO_UINT(p_Manip->p_Hmct)));
 
-        BuildHmct(p_Manip, p_FmPcdManipParams, (uint32_t*)((uint8_t*)p_FmPcd->p_CcShadow + 16), p_Manip->p_Data, FALSE);
+        BuildHmct(p_Manip, p_FmPcdManipParams, p_TmpHmctPtr, p_Manip->p_Data, FALSE);
     }
     else
     {
-        p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);// TODO GetHmctPtr(p_Manip);
+        p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);
         ASSERT_COND(p_WholeHmct);
 
         /* Run till the last Manip (which is the first to configure) */
-        while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
+        while (MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
             p_CurManip = p_CurManip->h_NextManip;
 
-        while(p_CurManip)
+        while (p_CurManip)
         {
             /* If this is a non-head node in a unified table, point to the part of the shadow
              * which is the relative offset in HMCT.
              * else, point to the beginning of the
              * shadow table (we save 16 for the HMTD.
              */
-            p_TmpHmctPtr = (uint32_t*)((uint8_t*)p_FmPcd->p_CcShadow + 16 + ((uint8_t*)p_CurManip->p_Hmct - p_WholeHmct));
-            if(p_CurManip->p_Data)
-                p_TmpDataPtr = (uint8_t*)p_FmPcd->p_CcShadow + 16 + (p_CurManip->p_Data - p_WholeHmct);
+            p_TmpHmctPtr = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
+                                              (16 + PTR_TO_UINT(p_CurManip->p_Hmct) - PTR_TO_UINT(p_WholeHmct)));
+            if (p_CurManip->p_Data)
+                p_TmpDataPtr = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow,
+                                                  (16 + PTR_TO_UINT(p_CurManip->p_Data) - PTR_TO_UINT(p_WholeHmct)));
 
-            BuildHmct(p_CurManip, &p_CurManip->manipParams, (uint32_t*)p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr, p_TmpDataPtr, FALSE);
             p_CurManip = p_CurManip->h_PrevManip;
         }
     }
@@ -826,34 +834,33 @@ static t_Error CreateManipActionShadow(t_FmPcdManip *p_Manip, t_FmPcdManipParams
 
 static t_Error CreateManipActionBackToOrig(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_FmPcdManipParams)
 {
-    uint8_t         *p_WholeHmct, *p_TmpDataPtr;
+    uint8_t         *p_WholeHmct, *p_TmpHmctPtr, *p_TmpDataPtr;
     t_FmPcdManip    *p_CurManip = p_Manip;
-    uint32_t        *p_TmpHmctPtr;
 
     /* Build the new table in the shadow */
-    if(!MANIP_IS_UNIFIED(p_Manip))
+    if (!MANIP_IS_UNIFIED(p_Manip))
         BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data, FALSE);
     else
     {
-        p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);// TODO GetHmctPtr(p_Manip);
+        p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);
         ASSERT_COND(p_WholeHmct);
 
         /* Run till the last Manip (which is the first to configure) */
-        while(MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
+        while (MANIP_IS_UNIFIED_NON_LAST(p_CurManip))
             p_CurManip = p_CurManip->h_NextManip;
 
-        while(p_CurManip)
+        while (p_CurManip)
         {
             /* If this is a unified table, point to the part of the table
              * which is the relative offset in HMCT.
-            */
-            p_TmpHmctPtr = p_CurManip->p_Hmct;
-            p_TmpDataPtr = p_CurManip->p_Data;
+             */
+            p_TmpHmctPtr = p_CurManip->p_Hmct; /*- (uint32_t)p_WholeHmct*/
+            p_TmpDataPtr = p_CurManip->p_Data; /*- (uint32_t)p_WholeHmct*/
 
-            BuildHmct(p_CurManip, &p_CurManip->manipParams, (uint32_t*)p_TmpHmctPtr, p_TmpDataPtr, FALSE);
+            BuildHmct(p_CurManip, &p_CurManip->manipParams, p_TmpHmctPtr, p_TmpDataPtr, FALSE);
 
             p_CurManip = p_CurManip->h_PrevManip;
-       }
+        }
     }
 
     return E_OK;
@@ -867,11 +874,11 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
     SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
 
-    switch(p_Manip->opcode)
+    switch (p_Manip->opcode)
     {
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-           if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+           if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
             {
                 tmpReg32 = *(uint32_t *)&((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets;
                 tmpReg32 |=  (uint32_t)((uint32_t)icOffset << 16);
@@ -881,15 +888,15 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
             }
             else
             {
-                if(p_Manip->icOffset != icOffset)
-                        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
+                if (p_Manip->icOffset != icOffset)
+                    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previously by different value"););
             }
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if(p_Manip->h_Frag)
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if (p_Manip->h_Frag)
             {
-                if(p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
+                if (p_Manip->updateParams & INTERNAL_CONTEXT_OFFSET)
                 {
                     p_Ad     = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
                     tmpReg32 |= GET_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets);
@@ -900,7 +907,7 @@ static t_Error UpdateManipIc(t_Handle h_Manip, uint8_t icOffset)
                 }
                 else
                 {
-                    if(p_Manip->icOffset != icOffset)
+                    if (p_Manip->icOffset != icOffset)
                             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("this manipulation was updated previousely by different value"););
                 }
             }
@@ -925,9 +932,9 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
     SANITY_CHECK_RETURN_ERROR((p_Manip->opcode & HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX), E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->muramAllocate, E_INVALID_STATE);
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
-        if((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
+        if ((!(p_Manip->updateParams & OFFSET_OF_PR)) ||
            (p_Manip->shadowUpdateParams & OFFSET_OF_PR))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
 
@@ -936,9 +943,9 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
         fmPortGetSetCcParams.setCcParams.psoSize = 16;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
 #ifdef FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004
         ASSERT_COND(!(fmPortGetSetCcParams.getCcParams.prOffset % 16));
@@ -946,7 +953,7 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
     }
     else if (validate)
     {
-         if((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
+         if ((!(p_Manip->shadowUpdateParams & OFFSET_OF_PR)) ||
            (p_Manip->updateParams & OFFSET_OF_PR))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
@@ -954,29 +961,29 @@ static t_Error UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(t_Handle h_FmPo
         fmPortGetSetCcParams.setCcParams.psoSize = 16;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
+        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_PR)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Parser result offset wasn't configured previousely"));
 
     }
 
     ASSERT_COND(p_Ad);
 
-   if(p_Manip->updateParams & OFFSET_OF_PR)
-   {
+    if (p_Manip->updateParams & OFFSET_OF_PR)
+    {
         tmpReg32 = 0;
         tmpReg32 |= fmPortGetSetCcParams.getCcParams.prOffset;
         WRITE_UINT32(p_Ad->matchTblPtr, (GET_UINT32(p_Ad->matchTblPtr) | tmpReg32));
         p_Manip->updateParams &= ~OFFSET_OF_PR;
         p_Manip->shadowUpdateParams |= OFFSET_OF_PR;
-   }
-   else if (validate)
-   {
+    }
+    else if (validate)
+    {
         tmpReg32 = GET_UINT32(p_Ad->matchTblPtr);
-        if((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
+        if ((uint8_t)tmpReg32 != fmPortGetSetCcParams.getCcParams.prOffset)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"););
-   }
+    }
 
     return E_OK;
 }
@@ -995,14 +1002,14 @@ static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_
 
     p_Ad         = (t_AdOfTypeContLookup *)p_Manip->h_Frag;
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
 
-        if((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
+        if ((!(p_Manip->updateParams & OFFSET_OF_DATA)) ||
            ((p_Manip->shadowUpdateParams & OFFSET_OF_DATA)))
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
-        if(!p_SavedManipParams)
+        if (!p_SavedManipParams)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
         p_Manip->fragParams.dataOffset = p_SavedManipParams->capwapParams.dataOffset;
 
@@ -1017,9 +1024,9 @@ static t_Error UpdateModifyCapwapFragmenation(t_FmPcdManip *p_Manip, t_Handle h_
    {
 
         p_SavedManipParams = FmPcdCcTreeGetSavedManipParams(h_FmTree);
-        if(!p_SavedManipParams)
+        if (!p_SavedManipParams)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("for this manipulation tree has to be configured previosely with this type"));
-        if(p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
+        if (p_Manip->fragParams.dataOffset != p_SavedManipParams->capwapParams.dataOffset)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("this manipulation was updated previousely by different value"));
    }
 
@@ -1084,14 +1091,14 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
-        if(fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
+        if (fmPortGetSetCcParams.getCcParams.type & OFFSET_OF_DATA)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Data offset wasn't configured previousely"));
     }
 
-    if(p_Manip->updateParams)
+    if (p_Manip->updateParams)
     {
         tmpReg32 = GET_UINT32(p_Ad->pcAndOffsets);
         tmpReg32 |= ((uint32_t)fmPortGetSetCcParams.getCcParams.dataOffset<< 16);
@@ -1157,7 +1164,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
@@ -1186,7 +1193,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         if (fmPortGetSetCcParams.getCcParams.type & NUM_OF_TASKS)
@@ -1218,7 +1225,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
             IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, 0,  (uint32_t)(size + 1));
 
-            for( i = 0; i < size; i++)
+            for ( i = 0; i < size; i++)
                 WRITE_UINT8(*(uint8_t *)PTR_MOVE(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl, i), (uint8_t)(i+1));
 
             tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl) - p_FmPcd->physicalMuramBase);
@@ -1231,7 +1238,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
                                             (uint32_t)((size + 1) * FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE),
                                             4);
 
-           if(!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+           if (!p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly frame buffer pool table"));
 
             IOMemSet32(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl, 0,  (uint32_t)((size +1)* FM_PCD_MANIP_CAPWAP_REASM_RFD_SIZE));
@@ -1247,7 +1254,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
                                             (uint32_t)((size + 1)* FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE),
                                             4);
 
-            if(!p_Manip->fragParams.p_TimeOutTbl)
+            if (!p_Manip->fragParams.p_TimeOutTbl)
                 RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP Reassembly timeout table"));
 
             IOMemSet32(p_Manip->fragParams.p_TimeOutTbl, 0,  (uint16_t)((size + 1)*FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_ENTRY_SIZE));
@@ -1328,6 +1335,48 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 }
 #endif /* FM_CAPWAP_SUPPORT */
 
+t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
+{
+    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
+    t_FmPcdCcIpReassmTimeoutParams  ccIpReassmTimeoutParams = {0};
+    t_Error                         err = E_OK;
+    uint8_t                         result;
+    uint32_t                        bitFor1Micro, tsbs, log2num;
+
+    ASSERT_COND(p_FmPcd);
+    ASSERT_COND(h_IpReasmCommonPramTbl);
+
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    bitFor1Micro = 32 - bitFor1Micro;
+    LOG2(FM_PCD_MANIP_IP_REASSM_TIMEOUT_THREAD_THRESH, log2num);
+    tsbs = bitFor1Micro - log2num;
+
+    ccIpReassmTimeoutParams.iprcpt      = (uint32_t)(XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
+    ccIpReassmTimeoutParams.tsbs        = (uint8_t)tsbs;
+    ccIpReassmTimeoutParams.activate    = TRUE;
+    if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
+
+    switch (result)
+    {
+        case (0):
+            return E_OK;
+        case (1):
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate TNUM"));
+        case (2):
+            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer"));
+        case (3):
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Disable Timeout Task with invalid IPRCPT"));
+        case (4):
+            RETURN_ERROR(MAJOR, E_FULL, ("too many timeout tasks"));
+        case (5):
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("invalid sub command"));
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
+    }
+    return E_OK;
+}
+
 static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
 {
     uint32_t    tmpReg32 = 0, i;
@@ -1388,7 +1437,7 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
     p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr =
         PTR_TO_UINT(XX_MallocSmart((uint32_t)(size * 64), p_Manip->ipReassmParams.dataMemId, 64));
 
-    if(!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
+    if (!p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Memory allocation FAILED"));
 
     IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.reassFrmDescrPoolTblAddr), 0,  (uint32_t)(size * 32));
@@ -1405,7 +1454,7 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
     p_Manip->ipReassmParams.timeOutTblAddr =
         PTR_TO_UINT(FM_MURAM_AllocMem(p_FmPcd->h_FmMuram, (uint32_t)(size  * 8),8));
 
-    if(!p_Manip->ipReassmParams.timeOutTblAddr)
+    if (!p_Manip->ipReassmParams.timeOutTblAddr)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly timeout table"));
 
     IOMemSet32(UINT_TO_PTR(p_Manip->ipReassmParams.timeOutTblAddr), 0,  (uint16_t)(size * 8));
@@ -1416,7 +1465,7 @@ static t_Error CreateIpReassCommonTable(t_FmPcdManip *p_Manip)
 
     /* Sets the Expiration Delay */
     tmpReg32 = 0;
-    tmpReg32 |= p_Manip->ipReassmParams.timeoutThresholdForReassmProcess * 256;
+    tmpReg32 |= (((uint32_t)(1 << FmGetTimeStampScale(p_FmPcd->h_Fm))) * p_Manip->ipReassmParams.timeoutThresholdForReassmProcess);
     WRITE_UINT32(p_Manip->ipReassmParams.p_IpReassCommonTbl->expirationDelay, tmpReg32);
 
     err = FmPcdRegisterReassmPort(p_FmPcd, p_Manip->ipReassmParams.p_IpReassCommonTbl);
@@ -1470,7 +1519,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     *p_IpReassTbl = (t_IpReassTbl *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                       FM_PCD_MANIP_IP_REASM_TABLE_SIZE,
                                                       FM_PCD_MANIP_IP_REASM_TABLE_ALIGN);
-    if(!*p_IpReassTbl)
+    if (!*p_IpReassTbl)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Reassembly IPv4/IPv6 specific parameters table"));
     memset(*p_IpReassTbl, 0, sizeof(t_IpReassTbl));
 
@@ -1508,7 +1557,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     autoLearnHashTblSize = numOfSets * setSize;
 
     *p_AutoLearnHashTblAddr = PTR_TO_UINT(XX_MallocSmart(autoLearnHashTblSize, p_Manip->ipReassmParams.dataMemId, setSize));
-    if(!*p_AutoLearnHashTblAddr)
+    if (!*p_AutoLearnHashTblAddr)
     {
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
         *p_IpReassTbl = NULL;
@@ -1527,7 +1576,7 @@ static t_Error CreateIpReassTable(t_FmPcdManip *p_Manip, bool ipv4)
     The size of this table is (number of sets in the IP Reassembly Automatic Learning Hash table)*4 bytes.
     This table resides in external memory and its base address should be 4-byte aligned */
     *p_AutoLearnSetLockTblAddr = PTR_TO_UINT(XX_MallocSmart((uint32_t)(numOfSets * 4), p_Manip->ipReassmParams.dataMemId, 4));
-    if(!*p_AutoLearnSetLockTblAddr)
+    if (!*p_AutoLearnSetLockTblAddr)
     {
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, *p_IpReassTbl);
         *p_IpReassTbl = NULL;
@@ -1560,11 +1609,10 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
     t_FmPortGetSetCcParams      fmPortGetSetCcParams;
     uint32_t                    tmpReg32;
     t_Error                     err;
-#if (DPAA_VERSION == 10)
     t_FmPortPcdParams           *p_PcdParams = (t_FmPortPcdParams *)h_PcdParams;
-#else
+#if (DPAA_VERSION >= 11)
     uint8_t                     *p_Ptr;
-#endif /* (DPAA_VERSION == 10) */
+#endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Manip->frag, E_INVALID_HANDLE);
@@ -1649,51 +1697,47 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
         }
     }
 
+    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
+    {
+        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv4Scheme;
+        p_PcdParams->p_KgParams->numOfSchemes++;
+    }
+    if (p_Manip->ipReassmParams.h_Ipv6Scheme)
+    {
+        p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv6Scheme;
+        p_PcdParams->p_KgParams->numOfSchemes++;
+    }
+
+#if (DPAA_VERSION >= 11)
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
     fmPortGetSetCcParams.setCcParams.type = 0;
     fmPortGetSetCcParams.getCcParams.type = FM_REV;
     if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
-#if (DPAA_VERSION == 10)
-    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev < 6)
+
+    if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev >= 6)
     {
+        if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_Ptr)) != E_OK)
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
+        tmpReg32 = NIA_ENG_KG;
         if (p_Manip->ipReassmParams.h_Ipv4Scheme)
         {
-            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv4Scheme;
-            p_PcdParams->p_KgParams->numOfSchemes++;
+            tmpReg32 |= NIA_KG_DIRECT;
+            tmpReg32 |= NIA_KG_CC_EN;
+            tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv4Scheme);
+            WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV4_OFFSET), tmpReg32);
         }
         if (p_Manip->ipReassmParams.h_Ipv6Scheme)
         {
-            p_PcdParams->p_KgParams->h_Schemes[p_PcdParams->p_KgParams->numOfSchemes] = p_Manip->ipReassmParams.h_Ipv6Scheme;
-            p_PcdParams->p_KgParams->numOfSchemes++;
+            tmpReg32 &= ~NIA_AC_MASK;
+            tmpReg32 |= NIA_KG_DIRECT;
+            tmpReg32 |= NIA_KG_CC_EN;
+            tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv6Scheme);
+            WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV6_OFFSET), tmpReg32);
         }
     }
-    else
-    {
-#else
-    if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_Ptr)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    tmpReg32 = NIA_ENG_KG;
-    if (p_Manip->ipReassmParams.h_Ipv4Scheme)
-    {
-        tmpReg32 |= NIA_KG_DIRECT;
-        tmpReg32 |= NIA_KG_CC_EN;
-        tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv4Scheme);
-        WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV4_OFFSET), tmpReg32);
-    }
-    if (p_Manip->ipReassmParams.h_Ipv6Scheme)
-    {
-        tmpReg32 &= ~NIA_AC_MASK;
-        tmpReg32 |= NIA_KG_DIRECT;
-        tmpReg32 |= NIA_KG_CC_EN;
-        tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv6Scheme);
-        WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV6_OFFSET), tmpReg32);
-    }
-#endif /* (DPAA_VERSION == 10) */
-#if (DPAA_VERSION == 10)
-    }
-#endif /* (DPAA_VERSION == 10) */
+#endif /* (DPAA_VERSION >= 11) */
 
     return E_OK;
 }
@@ -1740,28 +1784,28 @@ static t_Error FmPcdFragHcScratchPoolEmpty(t_Handle h_FmPcd, uint8_t scratchBpid
 
 static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
 {
-    if(p_Manip->h_Ad)
+    if (p_Manip->h_Ad)
     {
-        if(p_Manip->muramAllocate)
+        if (p_Manip->muramAllocate)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Ad);
         else
             XX_Free(p_Manip->h_Ad);
         p_Manip->h_Ad = NULL;
     }
-    if(p_Manip->p_Template)
+    if (p_Manip->p_Template)
     {
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_Template);
         p_Manip->p_Template = NULL;
     }
-    if(p_Manip->h_Frag)
+    if (p_Manip->h_Frag)
     {
-        if(p_Manip->fragParams.p_AutoLearnHashTbl)
+        if (p_Manip->fragParams.p_AutoLearnHashTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_AutoLearnHashTbl);
-        if(p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
+        if (p_Manip->fragParams.p_ReassmFrmDescrPoolTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrPoolTbl);
-        if(p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
+        if (p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_ReassmFrmDescrIndxPoolTbl);
-        if(p_Manip->fragParams.p_TimeOutTbl)
+        if (p_Manip->fragParams.p_TimeOutTbl)
             FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->fragParams.p_TimeOutTbl);
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->h_Frag);
 
@@ -1813,38 +1857,37 @@ static void ReleaseManipHandler(t_FmPcdManip *p_Manip, t_FmPcd *p_FmPcd)
             XX_FreeSmart(p_Manip->ipReassmParams.h_Ipv4Ad);
     }
 
-    if(p_Manip->p_StatsTbl)
+    if (p_Manip->p_StatsTbl)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, p_Manip->p_StatsTbl);
 }
 
 #ifdef FM_CAPWAP_SUPPORT
 static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipParams *p_ManipParams)
 {
-
-    if(p_ManipParams->u.hdr.rmv)
+    if (p_ManipParams->u.hdr.rmv)
     {
-        switch(p_ManipParams->u.hdr.rmvParams.type)
+        switch (p_ManipParams->u.hdr.rmvParams.type)
         {
-            case(e_FM_PCD_MANIP_RMV_BY_HDR):
-                switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+            case (e_FM_PCD_MANIP_RMV_BY_HDR):
+                switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
                 {
-                    case(e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
-                        if(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START) :
+                        if (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.include)
                         {
-                            switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
                             {
-                                case(HEADER_TYPE_CAPWAP_DTLS) :
+                                case (HEADER_TYPE_CAPWAP_DTLS) :
                                     p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
                                     p_Manip->muramAllocate = TRUE;
-                                    if(p_ManipParams->u.hdr.insrt)
+                                    if (p_ManipParams->u.hdr.insrt)
                                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for  CAPWAP_DTLS_HDR remove can not be insrt manipualtion after"));
-                                    if(p_ManipParams->fragOrReasm)
+                                    if (p_ManipParams->fragOrReasm)
                                     {
-                                        if(!p_ManipParams->fragOrReasmParams.frag)
+                                        if (!p_ManipParams->fragOrReasmParams.frag)
                                         {
-                                            switch(p_ManipParams->fragOrReasmParams.hdr)
+                                            switch (p_ManipParams->fragOrReasmParams.hdr)
                                             {
-                                                case(HEADER_TYPE_CAPWAP):
+                                                case (HEADER_TYPE_CAPWAP):
                                                     p_Manip->opcode = HMAN_OC_CAPWAP_REASSEMBLY;
                                                     break;
                                                 default:
@@ -1861,10 +1904,10 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                         }
                         else
                         {
-                            switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
+                            switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.u.fromStartByHdr.hdrInfo.hdr)
                             {
-                                case(HEADER_TYPE_CAPWAP_DTLS) :
-                                case(HEADER_TYPE_CAPWAP) :
+                                case (HEADER_TYPE_CAPWAP_DTLS) :
+                                case (HEADER_TYPE_CAPWAP) :
                                     if  (p_ManipParams->fragOrReasm || p_ManipParams->u.hdr.insrt)
                                         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for the type of remove e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_TILL_CAPWAP can not be insert or fragOrReasm TRUE"));
                                     p_Manip->opcode = HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
@@ -1884,21 +1927,21 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
         }
     }
-    else if(p_ManipParams->u.hdr.insrt)
+    else if (p_ManipParams->u.hdr.insrt)
     {
-        switch(p_ManipParams->u.hdr.insrtParams.type)
+        switch (p_ManipParams->u.hdr.insrtParams.type)
         {
-            case(e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
+            case (e_FM_PCD_MANIP_INSRT_BY_TEMPLATE) :
 
                 p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
                 p_Manip->muramAllocate = FALSE;
-                if(p_ManipParams->fragOrReasm)
+                if (p_ManipParams->fragOrReasm)
                 {
-                    if(p_ManipParams->fragOrReasmParams.frag)
+                    if (p_ManipParams->fragOrReasmParams.frag)
                     {
-                           switch(p_ManipParams->fragOrReasmParams.hdr)
+                           switch (p_ManipParams->fragOrReasmParams.hdr)
                            {
-                                case(HEADER_TYPE_CAPWAP):
+                                case (HEADER_TYPE_CAPWAP):
                                     p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
                                     break;
                                 default:
@@ -1914,13 +1957,13 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("for only isert manipulation unsupported type"));
         }
     }
-    else if(p_ManipParams->fragOrReasm)
+    else if (p_ManipParams->fragOrReasm)
     {
-        if(p_ManipParams->fragOrReasmParams.frag)
+        if (p_ManipParams->fragOrReasmParams.frag)
         {
-            switch(p_ManipParams->fragOrReasmParams.hdr)
+            switch (p_ManipParams->fragOrReasmParams.hdr)
             {
-                case(HEADER_TYPE_CAPWAP):
+                case (HEADER_TYPE_CAPWAP):
                     p_Manip->opcode = HMAN_OC_CAPWAP_FRAGMENTATION;
                     p_Manip->muramAllocate = FALSE;
                     break;
@@ -1932,7 +1975,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
         {
             switch (p_ManipParams->fragOrReasmParams.hdr)
             {
-                case(HEADER_TYPE_CAPWAP):
+                case (HEADER_TYPE_CAPWAP):
                     RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Reassembly has to be with additional operation - rmv = TRUE, type of remove - e_FM_PCD_MANIP_RMV_FROM_START_OF_FRAME_INCLUDE_SPECIFIC_LOCATION,type = e_FM_PCD_MANIP_LOC_BY_HDR, hdr = HEADER_TYPE_CAPWAP_DTLS"));
                 default:
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported header for reassembly"));
@@ -1948,6 +1991,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdManipPa
 
     return E_OK;
 }
+
 #else /* not FM_CAPWAP_SUPPORT */
 static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipParams *p_ManipParams)
 {
@@ -1963,14 +2007,14 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("For a Header Manipulation node - no support of h_NextManip of type other than Header Manipulation."));
             }
 
-            if(p_ManipParams->u.hdr.rmv)
+            if (p_ManipParams->u.hdr.rmv)
             {
-                switch(p_ManipParams->u.hdr.rmvParams.type)
+                switch (p_ManipParams->u.hdr.rmvParams.type)
                 {
-                    case(e_FM_PCD_MANIP_RMV_BY_HDR):
-                        switch(p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
+                    case (e_FM_PCD_MANIP_RMV_BY_HDR):
+                        switch (p_ManipParams->u.hdr.rmvParams.u.byHdr.type)
                         {
-                            case(e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2) :
+                            case (e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2) :
                                 p_Manip->opcode = HMAN_OC;
                                 p_Manip->muramAllocate = TRUE;
                                 break;
@@ -1978,7 +2022,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                                  RETURN_ERROR(MAJOR, E_INVALID_STATE, ("invalid type of remove manipulation"));
                         }
                         break;
-                   case(e_FM_PCD_MANIP_RMV_GENERIC):
+                   case (e_FM_PCD_MANIP_RMV_GENERIC):
                        p_Manip->opcode = HMAN_OC;
                        p_Manip->muramAllocate = TRUE;
                        break;
@@ -1987,12 +2031,12 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 }
                 p_Manip->rmv = TRUE;
             }
-            else if(p_ManipParams->u.hdr.insrt)
+            else if (p_ManipParams->u.hdr.insrt)
             {
-                switch(p_ManipParams->u.hdr.insrtParams.type)
+                switch (p_ManipParams->u.hdr.insrtParams.type)
                 {
-                    case(e_FM_PCD_MANIP_INSRT_BY_HDR) :
-                    case(e_FM_PCD_MANIP_INSRT_GENERIC):
+                    case (e_FM_PCD_MANIP_INSRT_BY_HDR) :
+                    case (e_FM_PCD_MANIP_INSRT_GENERIC):
                         p_Manip->opcode = HMAN_OC;
                         p_Manip->muramAllocate = TRUE;
                         break;
@@ -2001,22 +2045,22 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 }
                 p_Manip->insrt = TRUE;
             }
-            else if(p_ManipParams->u.hdr.fieldUpdate)
+            else if (p_ManipParams->u.hdr.fieldUpdate)
             {
                 /* Check parameters */
-                if(p_ManipParams->u.hdr.fieldUpdateParams.type == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN)
+                if (p_ManipParams->u.hdr.fieldUpdateParams.type == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN)
                 {
-                    if((p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
+                    if ((p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_VPRI)
                         && (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.vpri > 7))
                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpri should get values of 0-7 "));
-                    if(p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
+                    if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.updateType == e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN)
                     {
                         int i;
 
-                        if(p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal > 7)
+                        if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.vpriDefVal > 7)
                             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("vpriDefVal should get values of 0-7 "));
-                        for(i = 0 ; i < FM_PCD_MANIP_DSCP_TO_VLAN_TRANS ; i++)
-                            if(p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i] & 0xf0)
+                        for (i = 0 ; i < FM_PCD_MANIP_DSCP_TO_VLAN_TRANS ; i++)
+                            if (p_ManipParams->u.hdr.fieldUpdateParams.u.vlan.u.dscpToVpri.dscpToVpriTable[i] & 0xf0)
                                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dscpToVpriTabl value out of range (0-15)"));
                     }
 
@@ -2026,7 +2070,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
                 p_Manip->muramAllocate = TRUE;
                 p_Manip->fieldUpdate = TRUE;
             }
-            else if(p_ManipParams->u.hdr.custom)
+            else if (p_ManipParams->u.hdr.custom)
             {
                 p_Manip->opcode = HMAN_OC;
                 p_Manip->muramAllocate = TRUE;
@@ -2036,12 +2080,12 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
         case e_FM_PCD_MANIP_REASSEM :
             if (p_ManipParams->h_NextManip)
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with reassembly"));
-            switch(p_ManipParams->u.reassem.hdr)
+            switch (p_ManipParams->u.reassem.hdr)
             {
-                case(HEADER_TYPE_IPv4):
+                case (HEADER_TYPE_IPv4):
                     p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv4;
                     break;
-                case(HEADER_TYPE_IPv6):
+                case (HEADER_TYPE_IPv6):
                     p_Manip->ipReassmParams.hdr = HEADER_TYPE_IPv6;
                     break;
                 default:
@@ -2052,10 +2096,10 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
         case e_FM_PCD_MANIP_FRAG :
             if (p_ManipParams->h_NextManip)
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("next manip with fragmentation"));
-            switch(p_ManipParams->u.frag.hdr)
+            switch (p_ManipParams->u.frag.hdr)
             {
-                case(HEADER_TYPE_IPv4):
-                case(HEADER_TYPE_IPv6):
+                case (HEADER_TYPE_IPv4):
+                case (HEADER_TYPE_IPv6):
                     break;
                 default:
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header for fragmentation"));
@@ -2064,7 +2108,7 @@ static t_Error CheckManipParamsAndSetType(t_FmPcdManip *p_Manip, t_FmPcdManipPar
             p_Manip->muramAllocate = TRUE;
             break;
         case e_FM_PCD_MANIP_SPECIAL_OFFLOAD :
-            switch(p_ManipParams->u.specialOffload.type)
+            switch (p_ManipParams->u.specialOffload.type)
             {
                 case (e_FM_PCD_MANIP_SPECIAL_OFFLOAD_IPSEC):
                     p_Manip->opcode = HMAN_OC_IPSEC_MANIP;
@@ -2097,19 +2141,19 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad,E_INVALID_HANDLE);
 
     p_Ad    = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if(p_Manip->h_FmPcd != h_FmPcd)
+    if (p_Manip->h_FmPcd != h_FmPcd)
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
                      ("handler of PCD previously was initiated by different value"));
 
     memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
 
-    if(!p_Manip->p_StatsTbl)
+    if (!p_Manip->p_StatsTbl)
     {
 
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 = GET_UINT32(p_Ad->ccAdBase);
@@ -2118,14 +2162,14 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
             (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                         (uint32_t)p_Manip->owner * FM_PCD_MANIP_INDEXED_STATS_ENTRY_SIZE,
                                         4);
-        if(!p_Manip->p_StatsTbl)
+        if (!p_Manip->p_StatsTbl)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation indexed statistics table"));
 
         IOMemSet32(p_Manip->p_StatsTbl, 0,  (uint32_t)(p_Manip->owner * 4));
 
         tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->p_StatsTbl) - p_FmPcd->physicalMuramBase);
 
-        if(p_Manip->cnia)
+        if (p_Manip->cnia)
             tmpReg32 |= FM_PCD_MANIP_INDEXED_STATS_CNIA;
 
         tmpReg32 |=  FM_PCD_MANIP_INDEXED_STATS_DPD;
@@ -2136,7 +2180,7 @@ static t_Error UpdateIndxStats(t_Handle     h_FmPcd,
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNDN;
         fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_CC;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -2162,27 +2206,27 @@ static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd,
     UNUSED(h_FmPcd);
     UNUSED(h_FmTree);
 
-    switch(p_Manip->opcode)
+    switch (p_Manip->opcode)
     {
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             err = UpdateInitMvIntFrameHeaderFromFrameToBufferPrefix(h_FmPort, p_Manip, h_Ad, validate);
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if(!p_Manip->h_Frag)
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if (!p_Manip->h_Frag)
                 break;
-        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
             err = UpdateInitCapwapFragmentation(h_FmPort, p_Manip, h_Ad, validate, h_FmTree);
             break;
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             if (p_Manip->h_Frag)
                 err = UpdateInitCapwapReasm(h_FmPcd, h_FmPort, p_Manip, h_Ad, validate);
             break;
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
             err = UpdateIndxStats(h_FmPcd, h_FmPort, p_Manip);
             break;
 #endif /* FM_CAPWAP_SUPPORT */
-        case(HMAN_OC_IP_REASSEMBLY):
+        case (HMAN_OC_IP_REASSEMBLY):
             err = UpdateInitIpReasm(h_FmPcd, h_PcdParams, h_FmPort, p_Manip, h_Ad, validate);
             break;
         default:
@@ -2200,11 +2244,11 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
 
     UNUSED(level);
 
-    switch(p_Manip->opcode)
+    switch (p_Manip->opcode)
     {
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("modify node with this type of manipulation  is not suppported"));
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
 
            if (p_Manip->h_Frag)
            {
@@ -2215,11 +2259,9 @@ static t_Error FmPcdManipModifyUpdate(t_Handle h_Manip, t_Handle h_Ad, bool vali
            }
            break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if(p_Manip->h_Frag)
-            {
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+            if (p_Manip->h_Frag)
                 err = UpdateModifyCapwapFragmenation(p_Manip, h_Ad, validate, h_FmTree);
-            }
             break;
 #endif /* FM_CAPWAP_SUPPORT */
         default:
@@ -2237,30 +2279,30 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *
     bool            byField     = p_HdrInfo->byField;
     t_FmPcdFields   field;
 
-    if(byField)
+    if (byField)
         field = p_HdrInfo->fullField;
 
-    if(byField)
+    if (byField)
     {
-        switch(hdr)
+        switch (hdr)
         {
-            case(HEADER_TYPE_ETH):
-                switch(field.eth)
+            case (HEADER_TYPE_ETH):
+                switch (field.eth)
                 {
-                    case(NET_HEADER_FIELD_ETH_TYPE):
+                    case (NET_HEADER_FIELD_ETH_TYPE):
                         *parseArrayOffset = CC_PC_PR_ETYPE_LAST_OFFSET;
                         break;
                     default:
                         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header manipulation of the type Ethernet with this field not supported"));
                 }
                 break;
-            case(HEADER_TYPE_VLAN):
-                switch(field.vlan)
+            case (HEADER_TYPE_VLAN):
+                switch (field.vlan)
                 {
-                    case(NET_HEADER_FIELD_VLAN_TCI) :
-                        if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+                    case (NET_HEADER_FIELD_VLAN_TCI) :
+                        if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                             *parseArrayOffset = CC_PC_PR_VLAN1_OFFSET;
-                        else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                        else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                              *parseArrayOffset = CC_PC_PR_VLAN2_OFFSET;
                         break;
                     default:
@@ -2273,51 +2315,51 @@ static t_Error GetPrOffsetByHeaderOrField(t_FmManipHdrInfo *p_HdrInfo, uint8_t *
     }
     else
     {
-        switch(hdr){
-             case(HEADER_TYPE_ETH):
+        switch (hdr){
+             case (HEADER_TYPE_ETH):
                  *parseArrayOffset = (uint8_t)CC_PC_PR_ETH_OFFSET;
                 break;
-            case(HEADER_TYPE_USER_DEFINED_SHIM1):
+            case (HEADER_TYPE_USER_DEFINED_SHIM1):
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM1_OFFSET;
                 break;
-            case(HEADER_TYPE_USER_DEFINED_SHIM2):
+            case (HEADER_TYPE_USER_DEFINED_SHIM2):
                 *parseArrayOffset = (uint8_t)CC_PC_PR_USER_DEFINED_SHIM2_OFFSET;
                 break;
-            case(HEADER_TYPE_LLC_SNAP):
+            case (HEADER_TYPE_LLC_SNAP):
                 *parseArrayOffset = CC_PC_PR_USER_LLC_SNAP_OFFSET;
                 break;
-            case(HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_PPPoE):
                 *parseArrayOffset = CC_PC_PR_PPPOE_OFFSET;
                 break;
-            case(HEADER_TYPE_MPLS):
-                 if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_MPLS):
+                 if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                         *parseArrayOffset = CC_PC_PR_MPLS1_OFFSET;
-                else if(hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
+                else if (hdrIndex == e_FM_PCD_HDR_INDEX_LAST)
                         *parseArrayOffset = CC_PC_PR_MPLS_LAST_OFFSET;
                 break;
-            case(HEADER_TYPE_IPv4):
-            case(HEADER_TYPE_IPv6):
-              if((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
+            case (HEADER_TYPE_IPv4):
+            case (HEADER_TYPE_IPv6):
+              if ((hdrIndex == e_FM_PCD_HDR_INDEX_NONE) || (hdrIndex == e_FM_PCD_HDR_INDEX_1))
                     *parseArrayOffset = CC_PC_PR_IP1_OFFSET;
-              else if(hdrIndex == e_FM_PCD_HDR_INDEX_2)
+              else if (hdrIndex == e_FM_PCD_HDR_INDEX_2)
                     *parseArrayOffset = CC_PC_PR_IP_LAST_OFFSET;
                 break;
-            case(HEADER_TYPE_MINENCAP):
+            case (HEADER_TYPE_MINENCAP):
                 *parseArrayOffset = CC_PC_PR_MINENC_OFFSET;
                 break;
-            case(HEADER_TYPE_GRE):
+            case (HEADER_TYPE_GRE):
                 *parseArrayOffset = CC_PC_PR_GRE_OFFSET;
                 break;
-            case(HEADER_TYPE_TCP):
-            case(HEADER_TYPE_UDP):
-            case(HEADER_TYPE_IPSEC_AH):
-            case(HEADER_TYPE_IPSEC_ESP):
-            case(HEADER_TYPE_DCCP):
-            case(HEADER_TYPE_SCTP):
+            case (HEADER_TYPE_TCP):
+            case (HEADER_TYPE_UDP):
+            case (HEADER_TYPE_IPSEC_AH):
+            case (HEADER_TYPE_IPSEC_ESP):
+            case (HEADER_TYPE_DCCP):
+            case (HEADER_TYPE_SCTP):
                 *parseArrayOffset = CC_PC_PR_L4_OFFSET;
                 break;
-            case(HEADER_TYPE_CAPWAP):
-            case(HEADER_TYPE_CAPWAP_DTLS):
+            case (HEADER_TYPE_CAPWAP):
+            case (HEADER_TYPE_CAPWAP_DTLS):
                 *parseArrayOffset = CC_PC_PR_NEXT_HEADER_OFFSET;
                 break;
             default:
@@ -2342,14 +2384,14 @@ static t_Error RmvHdrTillSpecLocNOrInsrtIntFrmHdr(t_FmPcdManipHdrRmvParams  *p_M
     if (p_Manip->rmv)
     {
         err = GetPrOffsetByHeaderOrField(&p_ManipParams->u.byHdr.u.fromStartByHdr.hdrInfo, &prsArrayOffset);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 |= (uint32_t)prsArrayOffset << 24;
         tmpReg32 |= HMAN_RMV_HDR;
     }
 
-    if(p_Manip->insrt)
+    if (p_Manip->insrt)
         tmpReg32 |= HMAN_INSRT_INT_FRM_HDR;
 
     tmpReg32 |= (uint32_t)HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR;
@@ -2407,7 +2449,7 @@ static t_Error CapwapRmvDtlsHdr(t_FmPcd *p_FmPcd, t_FmPcdManip *p_Manip)
     tmpReg32 |= FM_PCD_AD_CONT_LOOKUP_TYPE;
 
 
-    if(p_Manip->h_Frag)
+    if (p_Manip->h_Frag)
     {
         p_Manip->updateParams |= INTERNAL_CONTEXT_OFFSET;
         tmpReg32 |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
@@ -2501,7 +2543,7 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams    *p_ManipParams,
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
 
     for (j=0; j<p_ManipParams->maxNumFramesInProcess*2; j++)
-        if(((j / i)  % 2)== 0)
+        if (((j / i)  % 2)== 0)
             WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->fragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
 
     tmpReg32 = 0x00008000;
@@ -2542,7 +2584,7 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                   FM_PCD_CC_AD_ENTRY_SIZE,
                                                   FM_PCD_CC_AD_TABLE_ALIGN);
-    if(!p_Manip->h_Frag)
+    if (!p_Manip->h_Frag)
          RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for CAPWAP fragmentation table descriptor"));
 
     IOMemSet32(p_Manip->h_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
@@ -2552,7 +2594,7 @@ static t_Error CapwapFragmentation(t_CapwapFragmentationParams  *p_ManipParams,
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_FRAGMENTATION;
 
-    if(p_ManipParams->headerOptionsCompr)
+    if (p_ManipParams->headerOptionsCompr)
         tmpReg32 |= FM_PCD_MANIP_CAPWAP_FRAG_COMPR_OPTION_FIELD_EN;
     tmpReg32 |= ((uint32_t)poolId << 8);
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
@@ -2614,6 +2656,7 @@ static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, bool ipv4)
         WRITE_UINT32(p_Ad->gmask, tmpReg32);
     }
 #endif /* (DPAA_VERSION >= 11) */
+
     /* Sets the third Ad register (pcAndOffsets)- IP Reassemble Operation Code*/
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_IP_REASSEMBLY;
@@ -2633,7 +2676,7 @@ static t_Error SetIpv4ReassmManip(t_FmPcdManip *p_Manip)
         (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
                                  p_Manip->ipReassmParams.dataMemId,
                                  FM_PCD_CC_AD_TABLE_ALIGN);
-    if(!p_Manip->ipReassmParams.h_Ipv4Ad)
+    if (!p_Manip->ipReassmParams.h_Ipv4Ad)
     {
         ReleaseManipHandler(p_Manip, p_FmPcd);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv4 table descriptor"));
@@ -2654,7 +2697,7 @@ static t_Error SetIpv6ReassmManip(t_FmPcdManip *p_Manip)
         (t_Handle)XX_MallocSmart(FM_PCD_CC_AD_ENTRY_SIZE,
                                  p_Manip->ipReassmParams.dataMemId,
                                  FM_PCD_CC_AD_TABLE_ALIGN);
-     if(!p_Manip->ipReassmParams.h_Ipv6Ad)
+     if (!p_Manip->ipReassmParams.h_Ipv6Ad)
      {
         ReleaseManipHandler(p_Manip, p_FmPcd);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of IPv6 table descriptor"));
@@ -2711,7 +2754,9 @@ static t_Error IpReassembly(t_FmPcdManipReassemParams   *p_ManipReassmParams,
     {
         p_Manip->ipReassmParams.nonConsistentSpFqid = reassmManipParams.nonConsistentSpFqid;
     }
-#endif /* (DPAA_VERSION >= 11) */    /* Creates and initializes the IP Reassembly common parameter table */
+#endif /* (DPAA_VERSION >= 11) */
+
+    /* Creates and initializes the IP Reassembly common parameter table */
     CreateIpReassCommonTable(p_Manip);
 
     /* Creation of IPv4 reassembly manipulation */
@@ -2802,7 +2847,7 @@ static void setReassmSchemeParams(t_FmPcd* p_FmPcd, t_FmPcdKgSchemeParams *p_Sch
     p_Scheme->keyExtractAndHashParams.privateDflt0 = 0x01020304;
     p_Scheme->keyExtractAndHashParams.privateDflt1 = 0x11121314;
     p_Scheme->keyExtractAndHashParams.numOfUsedDflts = FM_PCD_KG_NUM_OF_DEFAULT_GROUPS;
-    for(j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
+    for (j=0; j<FM_PCD_KG_NUM_OF_DEFAULT_GROUPS; j++)
     {
         p_Scheme->keyExtractAndHashParams.dflts[j].type = (e_FmPcdKgKnownFieldsDfltTypes)j; /* all types */
         p_Scheme->keyExtractAndHashParams.dflts[j].dfltSelect = e_FM_PCD_KG_DFLT_GBL_0;
@@ -2859,7 +2904,7 @@ static t_Error IndxStats(t_FmPcdStatsParams *p_StatsParams,t_FmPcdManip *p_Manip
 
     tmpReg32 = 0;
     tmpReg32 |= (uint32_t)HMAN_OC_CAPWAP_INDEXED_STATS;
-    if(p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
+    if (p_StatsParams->type == e_FM_PCD_STATS_PER_FLOWID)
         tmpReg32 |= (uint32_t)0x16 << 16;
     WRITE_UINT32(p_Ad->pcAndOffsets, tmpReg32);
 
@@ -2891,25 +2936,25 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     SANITY_CHECK_RETURN_ERROR(p_FmPcd,E_NULL_POINTER);
 
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
-    if(p_Manip->insrt)
+    if (p_Manip->insrt)
     {
-        if((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
+        if ((!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp) ||
              (!p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterVlan))
              RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : asking for header template modifications with no template for insertion (template size)"));
 
          if (p_InsrtByTemplate->size && p_InsrtByTemplate->modifyOuterIp && (p_InsrtByTemplate->size <= p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset))
              RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : size of template < ipOuterOffset"));
 
-         if(p_InsrtByTemplate->size > 128)
+         if (p_InsrtByTemplate->size > 128)
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Size of header template for insertion can not be more than 128"));
 
-         if(p_InsrtByTemplate->size)
+         if (p_InsrtByTemplate->size)
          {
              p_Manip->p_Template =
                 (uint8_t *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                              p_InsrtByTemplate->size,
                                              FM_PCD_CC_AD_TABLE_ALIGN);
-             if(!p_Manip->p_Template)
+             if (!p_Manip->p_Template)
                  RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for manipulation header template"));
 
              tmpReg32 = (uint32_t)(XX_VirtToPhys(p_Manip->p_Template) - (p_FmPcd->physicalMuramBase));
@@ -2921,39 +2966,39 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
         p_Template = (uint8_t *)XX_Malloc(p_InsrtByTemplate->size * sizeof(uint8_t));
 
-        if(!p_Template)
+        if (!p_Template)
             RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of manipulation header template"));
 
         memcpy(p_Template, p_InsrtByTemplate->hdrTemplate, p_InsrtByTemplate->size * sizeof(uint8_t));
 
 
-         if(p_InsrtByTemplate->modifyOuterIp)
+         if (p_InsrtByTemplate->modifyOuterIp)
          {
              ipModify = TRUE;
 
              tmpReg8 = (uint8_t)p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset];
 
-             if((tmpReg8 & 0xf0) == 0x40)
+             if ((tmpReg8 & 0xf0) == 0x40)
                  tmpReg8 = 4;
-             else if((tmpReg8 & 0xf0) == 0x60)
+             else if ((tmpReg8 & 0xf0) == 0x60)
                  tmpReg8 = 6;
              else
                  tmpReg8 = 0xff;
 
-             if(tmpReg8 == 4)
+             if (tmpReg8 == 4)
              {
-                 if((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
+                 if ((IP_HDRCHECKSUM_FIELD_OFFSET_FROM_IP + p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset) > p_InsrtByTemplate->size)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IP present in header template, user asked for IP modifications but ipOffset + ipTotalLengthFieldOffset in header template bigger than template size"));
 
-                 if(p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
+                 if (p_InsrtByTemplate->modifyOuterIpParams.dscpEcn & 0xff00)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : IPV4 present in header template, dscpEcn has to be only 1 byte"));
 
                  p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_DSCECN_FIELD_OFFSET_FROM_IP] = (uint8_t)p_InsrtByTemplate->modifyOuterIpParams.dscpEcn;
 
-                 if(p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
+                 if (p_InsrtByTemplate->modifyOuterIpParams.recalculateLength)
                  {
 
-                     if((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
+                     if ((p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize) > 255)
                             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("extra Byte added can not be more than 256 bytes"));
                      extraAddedBytes = (uint8_t) (p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedAlignedToBlockSize + p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.extraBytesAddedNotAlignedToBlockSize);
                      blockSize = p_InsrtByTemplate->modifyOuterIpParams.recalculateLengthParams.blockSize;
@@ -2963,14 +3008,14 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
                      in the case of SEC insertedBytesAfterThisStage - SEC trailer (21/31) + header(13)
                      second byte - extraByteForIp = headerTemplate - ipOffset + insertedBytesAfterThisStage*/
                  }
-                 if(blockSize)
+                 if (blockSize)
                  {
                      if (!POWER_OF_2(blockSize))
                          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("inputFrmPaddingUpToBlockSize has to be power of 2"));
                      blockSize -= 1;
                  }
 
-                 if((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
+                 if ((p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes) > 255)
                      RETURN_ERROR(MAJOR, E_INVALID_STATE, ("p_InsrtByTemplate->size - p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + extraAddedBytes has to be less than 255"));
 
                 p_Template[p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset + IP_TOTALLENGTH_FIELD_OFFSET_FROM_IP + 1] = blockSize;
@@ -2986,9 +3031,9 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
 
                  /*UDP checksum has to be 0*/
-                 if(p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
+                 if (p_InsrtByTemplate->modifyOuterIpParams.udpPresent)
                  {
-                     if((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
+                     if ((p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP + UDP_UDPCHECKSUM_FIELD_SIZE) > p_InsrtByTemplate->size)
                          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Inconsistent parameters : UDP present according to user but (UDP offset + UDP header size) < size of header template"));
 
                     p_Template[p_InsrtByTemplate->modifyOuterIpParams.udpOffset + UDP_UDPHECKSUM_FIELD_OFFSET_FROM_UDP ] = 0x00;
@@ -2996,7 +3041,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
 
                  }
 
-                 if(p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
+                 if (p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId > 7)
                      RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("ipIdentGenId has to be one out of 8 sequence number generators (0 - 7) for IP identification field"));
 
                  tmpRegNia |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipIdentGenId<<24;
@@ -3029,7 +3074,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     }
 
     tmpReg32 = 0;
-    if(p_Manip->h_Frag)
+    if (p_Manip->h_Frag)
     {
         tmpRegNia |= (uint32_t)(XX_VirtToPhys(p_Manip->h_Frag) - (p_FmPcd->physicalMuramBase));
         tmpReg32 |= (uint32_t)p_Manip->sizeForFragmentation << 16;
@@ -3037,7 +3082,7 @@ static t_Error InsrtHdrByTempl(t_FmPcdManipHdrInsrtParams   *p_ManipParams,
     else
           tmpReg32 = 0xffff0000;
 
-    if(ipModify)
+    if (ipModify)
         tmpReg32 |= (uint32_t)p_InsrtByTemplate->modifyOuterIpParams.ipOuterOffset << 8;
     else
         tmpReg32 |= (uint32_t)0x0000ff00;
@@ -3086,7 +3131,7 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdM
     p_Manip->ipFragParams.p_Frag = (t_AdOfTypeContLookup *)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                                              FM_PCD_CC_AD_ENTRY_SIZE,
                                                                              FM_PCD_CC_AD_TABLE_ALIGN);
-    if(!p_Manip->ipFragParams.p_Frag)
+    if (!p_Manip->ipFragParams.p_Frag)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Fragmentation table descriptor"));
     IOMemSet32( p_Manip->ipFragParams.p_Frag, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
 
@@ -3097,10 +3142,6 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdM
     ccAdBaseReg = FM_PCD_AD_CONT_LOOKUP_TYPE;
     ccAdBaseReg |= (p_ManipParams->dontFragAction << FM_PCD_MANIP_IP_FRAG_DF_SHIFT);
 
-#ifdef FM_EXP_FEATURES
-    if (p_ManipParams->optionsCounterEn)
-        ccAdBaseReg |= FM_PCD_MANIP_IP_FRAG_OPT_COUNT_EN;
-#endif /* FM_EXP_FEATURES */
 
     /* Set Scatter/Gather BPid */
     if (p_ManipParams->sgBpidEn)
@@ -3143,7 +3184,6 @@ static t_Error IpFragmentation(t_FmPcdManipFragIpParams *p_ManipParams, t_FmPcdM
 
 static t_Error IPManip(t_FmPcdManip *p_Manip)
 {
-
     t_Error                     err = E_OK;
     t_FmPcd                     *p_FmPcd;
     t_AdOfTypeContLookup        *p_Ad;
@@ -3156,7 +3196,7 @@ static t_Error IPManip(t_FmPcdManip *p_Manip)
     p_Ad = (t_AdOfTypeContLookup *)p_Manip->h_Ad;
 
     tmpReg32 = FM_PCD_MANIP_IP_NO_FRAGMENTATION;
-    if(p_Manip->frag == TRUE)
+    if (p_Manip->frag == TRUE)
     {
         tmpRegNia = (uint32_t)(XX_VirtToPhys(p_Manip->ipFragParams.p_Frag) - (p_FmPcd->physicalMuramBase));
         tmpReg32  = (uint32_t)p_Manip->sizeForFragmentation << FM_PCD_MANIP_IP_MTU_SHIFT;
@@ -3225,9 +3265,9 @@ static t_Error IPSecManip(t_FmPcdManipParams    *p_ManipParams,
 static t_Error CheckStatsParamsAndSetType(t_FmPcdManip  *p_Manip, t_FmPcdStatsParams *p_StatsParams)
 {
 
-    switch(p_StatsParams->type)
+    switch (p_StatsParams->type)
     {
-        case(e_FM_PCD_STATS_PER_FLOWID):
+        case (e_FM_PCD_STATS_PER_FLOWID):
             p_Manip->opcode = HMAN_OC_CAPWAP_INDEXED_STATS;
             p_Manip->muramAllocate = TRUE;
             break;
@@ -3285,7 +3325,7 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
             p_Manip->h_Ad = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
                                                         FM_PCD_CC_AD_ENTRY_SIZE,
                                                         FM_PCD_CC_AD_TABLE_ALIGN);
-             if(!p_Manip->h_Ad)
+             if (!p_Manip->h_Ad)
              {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -3298,7 +3338,7 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params, bool s
         else
         {
             p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-             if(!p_Manip->h_Ad)
+             if (!p_Manip->h_Ad)
              {
                 REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -3346,10 +3386,10 @@ uint32_t FmPcdManipGetRequiredAction (t_Handle h_Manip)
 
     ASSERT_COND(h_Manip);
 
-    switch(p_Manip->opcode)
+    switch (p_Manip->opcode)
     {
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             return UPDATE_NIA_ENQ_WITHOUT_DMA;
         default:
             return 0;
@@ -3360,34 +3400,36 @@ void FmPcdManipUpdateOwner(t_Handle h_Manip, bool add)
 {
 
     uint32_t            intFlags;
-    t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
 
-    ASSERT_COND(p_Manip);
-
-    intFlags = XX_LockIntrSpinlock(p_Manip->h_Spinlock);
-    if(add)
-        p_Manip->owner++;
+    intFlags = XX_LockIntrSpinlock(((t_FmPcdManip *)h_Manip)->h_Spinlock);
+    if (add)
+        ((t_FmPcdManip *)h_Manip)->owner++;
     else
     {
-        ASSERT_COND(p_Manip->owner);
-        p_Manip->owner--;
+        ASSERT_COND(((t_FmPcdManip *)h_Manip)->owner);
+        ((t_FmPcdManip *)h_Manip)->owner--;
     }
-    XX_UnlockIntrSpinlock(p_Manip->h_Spinlock, intFlags);
+    XX_UnlockIntrSpinlock(((t_FmPcdManip *)h_Manip)->h_Spinlock, intFlags);
 }
+
 t_List *FmPcdManipGetNodeLstPointedOnThisManip(t_Handle h_Manip)
 {
     ASSERT_COND(h_Manip);
     return &((t_FmPcdManip *)h_Manip)->nodesLst;
 }
+
 t_List *FmPcdManipGetSpinlock(t_Handle h_Manip)
 {
     ASSERT_COND(h_Manip);
    return ((t_FmPcdManip *)h_Manip)->h_Spinlock;
 }
+
 t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCcNextEngineParams, uint32_t *requiredAction)
 {
     t_FmPcdManip             *p_Manip;
     t_Error                   err;
+    bool                     pointFromCc = TRUE;
+
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip, E_NULL_POINTER);
@@ -3395,70 +3437,73 @@ t_Error FmPcdManipCheckParamsForCcNextEgine(t_FmPcdCcNextEngineParams *p_FmPcdCc
     p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
     *requiredAction = 0;
 
-    switch(p_Manip->opcode)
+    while (p_Manip)
     {
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
-            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
-            if(p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
-               p_Manip->cnia = TRUE;
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
-        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
-            p_Manip->ownerTmp++;
-            break;
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) &&
-                !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
-            p_Manip->ownerTmp++;
-            break;
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
-                (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
-            err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip, FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
-            if(err)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
-            break;
-        case(HMAN_OC_IP_FRAGMENTATION):
+        switch (p_Manip->opcode)
+        {
+            case (HMAN_OC_CAPWAP_INDEXED_STATS):
+                if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+                if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+                   p_Manip->cnia = TRUE;
+            case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+                *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+            case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+                p_Manip->ownerTmp++;
+                break;
+            case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE) &&
+                    !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
+                p_Manip->ownerTmp++;
+                break;
+            case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)  &&
+                    (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode) != CC_PC_GENERIC_IC_HASH_INDEXED))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
+                err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip, FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
+                if (err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+                *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+                break;
+            case (HMAN_OC_IP_FRAGMENTATION):
 #if (DPAA_VERSION == 10)
-            if (!(p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE))
-                    RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                                 ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+                if (!(p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE))
+                        RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                     ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
 #else
-            if (!((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE) ||
-                  (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_PLCR)))
-                RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                             ("For this type of header manipulation has to be nextEngine "
-                              "e_FM_PCD_DONE or e_FM_PCD_PLCR"));
+                if (!((p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_DONE) ||
+                      (p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_PLCR)))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE,
+                                 ("For this type of header manipulation has to be nextEngine "
+                                  "e_FM_PCD_DONE or e_FM_PCD_PLCR"));
 #endif /* (DPAA_VERSION == 10) */
-            p_Manip->ownerTmp++;
-            break;
-        case(HMAN_OC_IP_REASSEMBLY):
-            if(p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
-            p_Manip->ownerTmp++;
-            break;
-        case(HMAN_OC_IPSEC_MANIP):
-            p_Manip->ownerTmp++;
-            break;
-        case(HMAN_OC):
-            if(( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE_NEXT(p_Manip))
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't have a cascaded manipulation when and Next Engine is CC"));
-            if(!MANIP_IS_FIRST(p_Manip)) //TODO Ganit - maybe change to owners
-                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_Manip is already used and may not be shared (no sharing of non-head manip nodes)"));
-
-            break;
-
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE,("invalid type of header manipulation for this state"));
+                p_Manip->ownerTmp++;
+                break;
+            case (HMAN_OC_IP_REASSEMBLY):
+                if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+                p_Manip->ownerTmp++;
+                break;
+            case (HMAN_OC_IPSEC_MANIP):
+                p_Manip->ownerTmp++;
+                break;
+            case (HMAN_OC):
+                if (( p_FmPcdCcNextEngineParams->nextEngine == e_FM_PCD_CC) && MANIP_IS_CASCADE_NEXT(p_Manip))
+                    RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't have a cascaded manipulation when and Next Engine is CC"));
+                if (!MANIP_IS_FIRST(p_Manip) && pointFromCc)
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("h_Manip is already used and may not be shared (no sharing of non-head manip nodes)"));
+                break;
+            default:
+                RETURN_ERROR(MAJOR, E_INVALID_STATE,("invalid type of header manipulation for this state"));
+        }
+        p_Manip = p_Manip->h_NextManip;
+        pointFromCc = FALSE;
     }
-
     return E_OK;
 }
 
+
 t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcdCcNode)
 {
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
@@ -3467,19 +3512,19 @@ t_Error FmPcdManipCheckParamsWithCcNodeParams(t_Handle h_Manip, t_Handle h_FmPcd
     SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(h_FmPcdCcNode, E_INVALID_HANDLE);
 
-    switch(p_Manip->opcode)
+    switch (p_Manip->opcode)
     {
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
-            if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
+            if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type statistics flowId if exist has to be pointed by all numOfKeys"));
             break;
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            if(p_Manip->h_Frag)
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+            if (p_Manip->h_Frag)
             {
-                if(p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
+                if (p_Manip->ownerTmp != FmPcdCcGetNumOfKeys(h_FmPcdCcNode))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("The manipulation of the type remove DTLS if exist has to be pointed by all numOfKeys"));
                 err = UpdateManipIc(h_Manip, FmPcdCcGetOffset(h_FmPcdCcNode));
-                if(err)
+                if (err)
                     RETURN_ERROR(MAJOR, err, NO_MSG);
             }
             break;
@@ -3510,17 +3555,17 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
 
     /* According to "type", either build & initialize a new AD (p_AdNew) or initialize
      * p_Ad ( the AD in the match table) and set p_AdNew = NULL. */
-    switch(p_Manip->opcode)
+    switch (p_Manip->opcode)
     {
-        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
-        case(HMAN_OC_IPSEC_MANIP):
+        case (HMAN_OC_IPSEC_MANIP):
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
-        case(HMAN_OC_IP_FRAGMENTATION):
+        case (HMAN_OC_IP_FRAGMENTATION):
             if ((p_CcNextEngineParams->nextEngine == e_FM_PCD_DONE) &&
                 (!p_CcNextEngineParams->params.enqueueParams.overrideFqid))
             {
@@ -3534,7 +3579,7 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
             else
                 *p_AdNewPtr = p_Manip->h_Ad;
             break;
-        case(HMAN_OC_IP_REASSEMBLY):
+        case (HMAN_OC_IP_REASSEMBLY):
             if (FmPcdManipIpReassmIsIpv6Hdr(p_Manip))
             {
                 if (!p_Manip->ipReassmParams.ipv6Assigned)
@@ -3554,14 +3599,14 @@ void FmPcdManipUpdateAdResultForCc(t_Handle                     h_Manip,
             memcpy((uint8_t *)p_Ad, (uint8_t *)*p_AdNewPtr, sizeof(t_AdOfTypeContLookup));
             *p_AdNewPtr = NULL;
             break;
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->fqid,         ((t_AdOfTypeResult *)(p_Manip->h_Ad))->fqid);
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->plcrProfile,  ((t_AdOfTypeResult *)(p_Manip->h_Ad))->plcrProfile);
             WRITE_UINT32(((t_AdOfTypeResult *)p_Ad)->nia,          ((t_AdOfTypeResult *)(p_Manip->h_Ad))->nia);
             *p_AdNewPtr = NULL;
             break;
-        case(HMAN_OC):
+        case (HMAN_OC):
             /* Allocate and initialize HMTD */
             *p_AdNewPtr = p_Manip->h_Ad;
             break;
@@ -3580,9 +3625,9 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
 
     FmPcdManipUpdateOwner(h_Manip, TRUE);
 
-    switch(p_Manip->opcode)
+    switch (p_Manip->opcode)
     {
-        case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+        case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->ccAdBase,      ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->ccAdBase);
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->matchTblPtr,   ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->matchTblPtr);
             WRITE_UINT32(((t_AdOfTypeContLookup *)p_Ad)->pcAndOffsets,  ((t_AdOfTypeContLookup *)(p_Manip->h_Ad))->pcAndOffsets);
@@ -3591,7 +3636,7 @@ void FmPcdManipUpdateAdContLookupForCc(t_Handle h_Manip, t_Handle p_Ad, t_Handle
             *p_AdNewPtr = NULL;
             break;
 
-        case(HMAN_OC):
+        case (HMAN_OC):
             /* Initialize HMTD within the match table*/
             IOMemSet32(p_Ad, 0,  FM_PCD_CC_AD_ENTRY_SIZE);
             /* copy the existing HMTD */ /* ask Alla - memcpy??? */
@@ -3630,12 +3675,17 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Han
     /* Configures the IPv4 or IPv6 scheme*/
     memset(p_SchemeParams, 0, sizeof(t_FmPcdKgSchemeParams));
     p_SchemeParams->netEnvParams.h_NetEnv = h_NetEnv;
-    p_SchemeParams->id.relativeSchemeId = (uint8_t)((isIpv4 == TRUE) ?  p_Manip->ipReassmParams.relativeSchemeId[0] : p_Manip->ipReassmParams.relativeSchemeId[1]);
+    p_SchemeParams->id.relativeSchemeId =
+        (uint8_t)((isIpv4 == TRUE) ?
+                  p_Manip->ipReassmParams.relativeSchemeId[0] :
+                  p_Manip->ipReassmParams.relativeSchemeId[1]);
     p_SchemeParams->schemeCounter.update = TRUE;
-    p_SchemeParams->baseFqid = 0xFFFFFF; /*TODO- baseFqid*/
-    p_SchemeParams->keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
 #if (DPAA_VERSION >= 11)
     p_SchemeParams->alwaysDirect = TRUE;
+    p_SchemeParams->bypassFqidGeneration = TRUE;
+#else
+    p_SchemeParams->keyExtractAndHashParams.hashDistributionNumOfFqids = 1;
+    p_SchemeParams->baseFqid = 0xFFFFFF; /*TODO- baseFqid*/
 #endif /* (DPAA_VERSION >= 11) */
 
     setReassmSchemeParams(p_FmPcd, p_SchemeParams, h_CcTree, isIpv4, groupId);
@@ -3653,7 +3703,7 @@ t_Error FmPcdManipBuildIpReassmScheme(t_FmPcd *p_FmPcd, t_Handle h_NetEnv, t_Han
 
 t_Error FmPcdManipDeleteIpReassmSchemes(t_Handle h_Manip)
 {
-    t_FmPcdManip            *p_Manip = (t_FmPcdManip *)h_Manip;
+    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_Manip;
 
     ASSERT_COND(p_Manip);
 
@@ -3692,7 +3742,7 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     p_Manip->muramAllocate = FALSE;
 
     p_Manip->h_Ad = (t_Handle)XX_Malloc(FM_PCD_CC_AD_ENTRY_SIZE * sizeof(uint8_t));
-     if(!p_Manip->h_Ad)
+     if (!p_Manip->h_Ad)
      {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Allocation of Manipulation action descriptor"));
         XX_Free(p_Manip);
@@ -3704,7 +3754,7 @@ t_Handle FmPcdManipApplSpecificBuild(void)
     /*treatFdStatusFieldsAsErrors = TRUE hardcoded - assumption its always come after CAAM*/
     /*Application specific = type of flowId index, move internal frame header from data to IC,
     SEC errors check*/
-    if(MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE)!= E_OK)
+    if (MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE)!= E_OK)
     {
         XX_Free(p_Manip->h_Ad);
         XX_Free(p_Manip);
@@ -3718,7 +3768,7 @@ bool FmPcdManipIsCapwapApplSpecific(t_Handle h_Manip)
     t_FmPcdManip *p_Manip = (t_FmPcdManip *)h_Manip;
     ASSERT_COND(h_Manip);
 
-    return (bool)((p_Manip->type == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST) ? TRUE : FALSE);
+    return (bool)((p_Manip->opcode == HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST) ? TRUE : FALSE);
 }
 #endif /* FM_CAPWAP_SUPPORT */
 /*********************** End of inter-module routines ************************/
@@ -3730,15 +3780,15 @@ bool FmPcdManipIsCapwapApplSpecific(t_Handle h_Manip)
 
 t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams)
 {
-    t_FmPcd                     *p_FmPcd = (t_FmPcd *)h_FmPcd;
-    t_FmPcdManip                *p_Manip;
-    t_Error                     err;
+    t_FmPcd         *p_FmPcd = (t_FmPcd *)h_FmPcd;
+    t_FmPcdManip    *p_Manip;
+    t_Error         err;
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd,E_INVALID_HANDLE,NULL);
     SANITY_CHECK_RETURN_VALUE(p_ManipParams,E_INVALID_HANDLE,NULL);
 
     p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_ManipParams, FALSE);
-    if(!p_Manip)
+    if (!p_Manip)
         return NULL;
     p_Manip->h_Spinlock = XX_InitSpinlock();
     if (!p_Manip->h_Spinlock)
@@ -3750,12 +3800,12 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
     }
     INIT_LIST(&p_Manip->nodesLst);
 
-    switch(p_Manip->opcode)
+    switch (p_Manip->opcode)
     {
-        case(HMAN_OC_IP_REASSEMBLY):
+        case (HMAN_OC_IP_REASSEMBLY):
             /* IpReassembly */
             err = IpReassembly(&p_ManipParams->u.reassem, p_Manip);
-            if(err)
+            if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -3763,10 +3813,10 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 return NULL;
             }
             break;
-       case(HMAN_OC_IP_FRAGMENTATION):
+       case (HMAN_OC_IP_FRAGMENTATION):
             /* IpFragmentation */
             err = IpFragmentation(&p_ManipParams->u.frag.u.ipFrag ,p_Manip);
-            if(err)
+            if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
@@ -3775,15 +3825,15 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
             }
             err = IPManip(p_Manip);
             break;
-        case(HMAN_OC_IPSEC_MANIP) :
+        case (HMAN_OC_IPSEC_MANIP) :
             err = IPSecManip(p_ManipParams, p_Manip);
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
+        case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
             /* HmanType1 */
             err = RmvHdrTillSpecLocNOrInsrtIntFrmHdr(&p_ManipParams->u.hdr.rmvParams, p_Manip);
             break;
-        case(HMAN_OC_CAPWAP_FRAGMENTATION):
+        case (HMAN_OC_CAPWAP_FRAGMENTATION):
             err = CapwapFragmentation(&p_ManipParams->fragOrReasmParams.u.capwapFragParams,
                                       p_Manip,
                                       p_FmPcd,
@@ -3795,36 +3845,36 @@ t_Handle FM_PCD_ManipNodeSet(t_Handle h_FmPcd, t_FmPcdManipParams *p_ManipParams
                 XX_Free(p_Manip);
                 return NULL;
             }
-            if(p_Manip->insrt)
+            if (p_Manip->insrt)
                 p_Manip->opcode = HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER;
-        case(HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
+        case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
             /* HmanType2 + if user asked only for fragmentation still need to allocate HmanType2 */
             err = InsrtHdrByTempl(&p_ManipParams->u.hdr.insrtParams, p_Manip, p_FmPcd);
             break;
-        case(HMAN_OC_CAPWAP_REASSEMBLY):
+        case (HMAN_OC_CAPWAP_REASSEMBLY):
             err = CapwapReassembly(&p_ManipParams->fragOrReasmParams.u.capwapReasmParams,
                                    p_Manip,
                                    p_FmPcd,
                                    p_ManipParams->fragOrReasmParams.sgBpid);
-            if(err)
+            if (err)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("UNSUPPORTED HEADER MANIPULATION TYPE"));
                 ReleaseManipHandler(p_Manip, p_FmPcd);
                 XX_Free(p_Manip);
                 return NULL;
             }
-            if(p_Manip->rmv)
+            if (p_Manip->rmv)
                 p_Manip->opcode = HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST;
-        case(HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
+        case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
             /*CAPWAP decapsulation + if user asked only for reassembly still need to allocate CAPWAP decapsulation*/
             err = CapwapRmvDtlsHdr(p_FmPcd, p_Manip);
             break;
 #endif /* FM_CAPWAP_SUPPORT */
-       case(HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
+       case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
             /*Application Specific type 1*/
             err = MvIntFrameHeaderFromFrameToBufferPrefix(p_Manip, TRUE);
             break;
-       case(HMAN_OC):
+       case (HMAN_OC):
            /* New Manip */
            err = CreateManipActionNew(p_Manip, p_ManipParams);
            break;
@@ -3875,11 +3925,11 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_Crnt
         ASSERT_COND(p_NodePtrOnCurrentMdfManip);
 
         /* Search in the previous node which exact index points on this current modified node for getting AD */
-        for(i = 0; i < p_NodePtrOnCurrentMdfManip->numOfKeys + 1; i++)
+        for (i = 0; i < p_NodePtrOnCurrentMdfManip->numOfKeys + 1; i++)
         {
-            if(p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
+            if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.nextEngine == e_FM_PCD_CC)
             {
-                if(p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip == (t_Handle)p_CrntMdfManip)
+                if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].nextEngineParams.h_Manip == (t_Handle)p_CrntMdfManip)
                 {
                     if (p_NodePtrOnCurrentMdfManip->keyAndNextEngineParams[i].p_StatsObj)
                         p_AdTablePtOnCrntCurrentMdfNode =
@@ -3891,7 +3941,6 @@ static void UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(t_FmPcdManip     *p_Crnt
                     memset(&ccNodeInfo, 0, sizeof(t_CcNodeInformation));
                     ccNodeInfo.h_CcNode = p_AdTablePtOnCrntCurrentMdfNode;
                     EnqueueNodeInfoToRelevantLst(h_NodesLst, &ccNodeInfo, NULL);
-
                 }
             }
         }
@@ -3915,8 +3964,7 @@ static void BuildHmtd(uint8_t *p_Dest, uint8_t *p_Src, uint8_t *p_Hmcd, t_FmPcd
                                 (uint32_t)(XX_VirtToPhys(p_Src) - p_FmPcd->physicalMuramBase),
                                 (uint32_t)(XX_VirtToPhys(p_Dest) - p_FmPcd->physicalMuramBase));
     if (err)
-     REPORT_ERROR(MINOR, err, ("Failed in dynamic manip change, continued to the rest of the owners."));
-
+        REPORT_ERROR(MINOR, err, ("Failed in dynamic manip change, continued to the rest of the owners."));
 }
 
 t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipParams)
@@ -3924,7 +3972,7 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
     t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_Manip, *p_FirstManip;
     t_FmPcd                     *p_FmPcd = (t_FmPcd *)(p_Manip->h_FmPcd);
     t_Error                     err;
-    uint8_t                     *p_WholeHmct= NULL, *p_ShadowHmct= NULL, *p_Hmtd = NULL;
+    uint8_t                     *p_WholeHmct = NULL, *p_ShadowHmct = NULL, *p_Hmtd = NULL;
     t_List                      lstOfNodeshichPointsOnCrntMdfManip, *p_Pos;
     t_CcNodeInformation         *p_CcNodeInfo;
     SANITY_CHECK_RETURN_ERROR(h_Manip,E_INVALID_HANDLE);
@@ -3932,8 +3980,10 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
 
     INIT_LIST(&lstOfNodeshichPointsOnCrntMdfManip);
 
-    if((p_ManipParams->type != e_FM_PCD_MANIP_HDR) || (p_Manip->type != e_FM_PCD_MANIP_HDR))
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PCD_ManipNodeReplace Functionality supported only for Header Manipulation."));
+    if ((p_ManipParams->type != e_FM_PCD_MANIP_HDR) ||
+        (p_Manip->type != e_FM_PCD_MANIP_HDR))
+        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
+                     ("FM_PCD_ManipNodeReplace Functionality supported only for Header Manipulation."));
 
     ASSERT_COND(p_Manip->opcode == HMAN_OC);
     ASSERT_COND(p_Manip->manipParams.h_NextManip == p_Manip->h_NextManip);
@@ -3965,49 +4015,40 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
     /* this routine creates a new manip action in the CC Shadow. */
     err = CreateManipActionShadow(p_Manip, p_ManipParams);
     if (err)
-    {
-        RELEASE_LOCK(p_FmPcd->shadowLock);
         RETURN_ERROR(MINOR, err, NO_MSG);
-    }
 
     /* If the owners list is empty (these are NOT the "owners" counter, but pointers from CC)
      * replace only HMTD and no lcok is required. Otherwise
      * lock the whole PCD
      * In case 4 MANIP_IS_UNIFIED_NON_FIRST(p_Manip) - Use the head node instead. */
-    //TODO - restrict the lock if LIST >0 .
-     if (!FmPcdLockTryLockAll(p_FmPcd))
-     {
-         DBG(TRACE, ("FmPcdLockTryLockAll failed"));
-         return ERROR_CODE(E_BUSY);
-     }
+    if (!FmPcdLockTryLockAll(p_FmPcd))
+    {
+        DBG(TRACE, ("FmPcdLockTryLockAll failed"));
+        return ERROR_CODE(E_BUSY);
+    }
 
-    p_ShadowHmct = (uint8_t*)UINT_TO_PTR((PTR_TO_UINT(p_FmPcd->p_CcShadow) + 16));
+    p_ShadowHmct = (uint8_t*)PTR_MOVE(p_FmPcd->p_CcShadow, 16);
 
-    p_FirstManip = GetManipInfo(p_Manip, e_MANIP_HANDLER_TABLE_OWNER);//TODO GetFirstManip(p_Manip);
+    p_FirstManip = (t_FmPcdManip*)GetManipInfo(p_Manip, e_MANIP_HANDLER_TABLE_OWNER);
     ASSERT_COND(p_FirstManip);
 
-    if(!LIST_IsEmpty(&p_FirstManip->nodesLst))
+    if (!LIST_IsEmpty(&p_FirstManip->nodesLst))
         UpdateAdPtrOfNodesWhichPointsOnCrntMdfManip(p_FirstManip, &lstOfNodeshichPointsOnCrntMdfManip);
 
-    p_Hmtd =(uint8_t *) GetManipInfo(p_Manip, e_MANIP_HMTD);//TODO GetHmtd(p_Manip);
+    p_Hmtd = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMTD);
     ASSERT_COND(p_Hmtd);
-    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_ShadowHmct,((t_FmPcd*)(p_Manip->h_FmPcd)));
+    BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_ShadowHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
 
     LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
-        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_ShadowHmct,((t_FmPcd*)(p_Manip->h_FmPcd)));
+        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_ShadowHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
     }
 
-    /* If LIST > 0, create a list of p_Ad's that point to the HMCT. Join also t_HMTD to this list.
-      * For each p_Hmct (from list+fixed):
-      * call Host Command to replace HMTD by a new one */
-    //TODO: Ganit
-    /* Copy shadow table to original location */
-    p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);// TODO GetHmctPtr(p_Manip);
+    p_WholeHmct = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMCT);
     ASSERT_COND(p_WholeHmct);
 
-    /* re-build the HMCT n the origional location */
+    /* re-build the HMCT n the original location */
     err = CreateManipActionBackToOrig(p_Manip, p_ManipParams);
     if (err)
     {
@@ -4015,20 +4056,22 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
         RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    p_Hmtd = (uint8_t *) GetManipInfo(p_Manip, e_MANIP_HMTD);//TODO GetHmtd(p_Manip);
+    p_Hmtd = (uint8_t *)GetManipInfo(p_Manip, e_MANIP_HMTD);
     ASSERT_COND(p_Hmtd);
     BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_Hmtd, p_WholeHmct,((t_FmPcd*)p_Manip->h_FmPcd));
 
+    /* If LIST > 0, create a list of p_Ad's that point to the HMCT. Join also t_HMTD to this list.
+     * For each p_Hmct (from list+fixed):
+     * call Host Command to replace HMTD by a new one */
     LIST_FOR_EACH(p_Pos, &lstOfNodeshichPointsOnCrntMdfManip)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
-        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_WholeHmct,((t_FmPcd*)(p_Manip->h_FmPcd)));
+        BuildHmtd(p_FmPcd->p_CcShadow, (uint8_t *)p_CcNodeInfo->h_CcNode, p_WholeHmct, ((t_FmPcd*)(p_Manip->h_FmPcd)));
     }
 
 
     ReleaseLst(&lstOfNodeshichPointsOnCrntMdfManip);
 
-    //TODO : Ganit - if locked!
     FmPcdLockUnlockAll(p_FmPcd);
 
     /* unlock shadow */
@@ -4039,20 +4082,20 @@ t_Error FM_PCD_ManipNodeReplace(t_Handle h_Manip, t_FmPcdManipParams *p_ManipPar
 
 t_Error FM_PCD_ManipNodeDelete(t_Handle h_ManipNode)
 {
-    t_FmPcdManip                *p_Manip = (t_FmPcdManip *)h_ManipNode;
+    t_FmPcdManip    *p_Manip = (t_FmPcdManip *)h_ManipNode;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip,E_INVALID_HANDLE);
 
-    if(p_Manip->owner)
+    if (p_Manip->owner)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("This manipulation node not be removed because this node is occupied, first - unbind this node "));
 
-    if(p_Manip->h_NextManip)
+    if (p_Manip->h_NextManip)
     {
         MANIP_SET_PREV(p_Manip->h_NextManip, NULL);
         FmPcdManipUpdateOwner(p_Manip->h_NextManip, FALSE);
     }
 
-    if(p_Manip->p_Hmct && MANIP_IS_UNIFIED_FIRST(p_Manip))
+    if (p_Manip->p_Hmct && MANIP_IS_UNIFIED_FIRST(p_Manip))
         FM_MURAM_FreeMem(((t_FmPcd *)p_Manip->h_FmPcd)->h_FmMuram, p_Manip->p_Hmct);
 
     if (p_Manip->h_Spinlock)
@@ -4075,11 +4118,11 @@ t_Error FM_PCD_ManipGetStatistics(t_Handle h_ManipNode, t_FmPcdManipStats *p_FmP
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdManipStats, E_NULL_POINTER);
 
-    switch(p_Manip->opcode)
+    switch (p_Manip->opcode)
     {
-        case(HMAN_OC_IP_REASSEMBLY):
+        case (HMAN_OC_IP_REASSEMBLY):
             return IpReassemblyStats(p_Manip, &p_FmPcdManipStats->u.reassem.u.ipReassem);
-       case(HMAN_OC_IP_FRAGMENTATION):
+       case (HMAN_OC_IP_FRAGMENTATION):
             return IpFragmentationStats(p_Manip, &p_FmPcdManipStats->u.frag.u.ipFrag);
        default:
             RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("no statistics to this type of manip"));
@@ -4099,12 +4142,12 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsP
     SANITY_CHECK_RETURN_VALUE(p_StatsParams,E_INVALID_HANDLE,NULL);
 
     p_Manip =  ManipOrStatsSetNode(h_FmPcd, (t_Handle)p_StatsParams, TRUE);
-    if(!p_Manip)
+    if (!p_Manip)
         return NULL;
 
-     switch(p_Manip->opcode)
+     switch (p_Manip->opcode)
      {
-        case(HMAN_OC_CAPWAP_INDEXED_STATS):
+        case (HMAN_OC_CAPWAP_INDEXED_STATS):
             /* Indexed statistics */
             err = IndxStats(p_StatsParams, p_Manip, p_FmPcd);
             break;
@@ -4115,7 +4158,7 @@ t_Handle FM_PCD_StatisticsSetNode(t_Handle h_FmPcd, t_FmPcdStatsParams *p_StatsP
             return NULL;
      }
 
-     if(err)
+     if (err)
      {
          REPORT_ERROR(MAJOR, err, NO_MSG);
          ReleaseManipHandler(p_Manip, p_FmPcd);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
index 5c6418f..729c1d9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_manip.h
@@ -115,14 +115,12 @@
 #define FM_PCD_MANIP_IP_NO_FRAGMENTATION                    0xFFFF0000
 #define FM_PCD_MANIP_IP_CNIA                                0x20000000
 
+#define FM_PCD_MANIP_IP_REASSM_TIMEOUT_THREAD_THRESH        1024
 #define FM_PCD_MANIP_IP_FRAG_DF_SHIFT                       28
 #define FM_PCD_MANIP_IP_FRAG_SCRATCH_BPID                   24
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_EN                     0x08000000
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_MASK                   0xFF000000
 #define FM_PCD_MANIP_IP_FRAG_SG_BDID_SHIFT                  24
-#ifdef FM_EXP_FEATURES
-#define FM_PCD_MANIP_IP_FRAG_OPT_COUNT_EN                   0x04000000
-#endif /* FM_EXP_FEATURES */
 
 #define FM_PCD_MANIP_IPSEC_DEC                              0x10000000
 #define FM_PCD_MANIP_IPSEC_VIPV_EN                          0x08000000
@@ -228,11 +226,11 @@
 #define MANIP_SET_UNIFIED_TBL_PTR_INDICATION(h_Manip)   (((t_FmPcdManip *)h_Manip)->unifiedTablePtr = TRUE)
 #define MANIP_GET_MURAM(h_Manip)                        (((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram)
 #define MANIP_FREE_HMTD(h_Manip)                        \
-        {if(((t_FmPcdManip *)h_Manip)->muramAllocate)   \
+        {if (((t_FmPcdManip *)h_Manip)->muramAllocate)    \
             FM_MURAM_FreeMem(((t_FmPcd *)((t_FmPcdManip *)h_Manip)->h_FmPcd)->h_FmMuram, ((t_FmPcdManip *)h_Manip)->h_Ad);\
         else                                            \
-            XX_Free(((t_FmPcdManip *)h_Manip)->h_Ad);   \
-        ((t_FmPcdManip *)h_Manip)->h_Ad = NULL;         \
+            XX_Free(((t_FmPcdManip *)h_Manip)->h_Ad);    \
+        ((t_FmPcdManip *)h_Manip)->h_Ad = NULL;            \
         }
 /* position regarding Manip SW structure */
 #define MANIP_IS_FIRST(h_Manip)                         (!(((t_FmPcdManip *)h_Manip)->h_PrevManip))
@@ -242,12 +240,12 @@
                                                          (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_LAST))
 #define MANIP_IS_UNIFIED_NON_LAST(h_Manip)              ((((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_FIRST) ||\
                                                          (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_MID))
-#define MANIP_IS_UNIFIED_FIRST(h_Manip)                 (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_FIRST)
-#define MANIP_IS_UNIFIED_LAST(h_Manip)                  (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_LAST)
+#define MANIP_IS_UNIFIED_FIRST(h_Manip)                    (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_FIRST)
+#define MANIP_IS_UNIFIED_LAST(h_Manip)                   (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_LAST)
 
 #define MANIP_UPDATE_UNIFIED_POSITION(h_Manip)          (((t_FmPcdManip *)h_Manip)->unifiedPosition = \
-                                                        (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_NONE)? \
-                                                           e_MANIP_UNIFIED_LAST : e_MANIP_UNIFIED_MID)
+                                                         (((t_FmPcdManip *)h_Manip)->unifiedPosition == e_MANIP_UNIFIED_NONE)? \
+                                                            e_MANIP_UNIFIED_LAST : e_MANIP_UNIFIED_MID)
 
 typedef enum e_ManipUnifiedPosition {
     e_MANIP_UNIFIED_NONE = 0,
@@ -410,6 +408,7 @@ typedef struct t_IpReassmParams
     uint32_t                        nonConsistentSpFqid;
 } t_IpReassmParams;
 
+
 typedef struct{
     e_FmPcdManipType        type;
     t_FmPcdManipParams      manipParams;
@@ -421,7 +420,7 @@ typedef struct{
     t_Handle                h_NextManip;
     t_Handle                h_PrevManip;
     /* HdrManip parameters*/
-    uint32_t                *p_Hmct;
+    uint8_t                 *p_Hmct;
     uint8_t                 *p_Data;
     bool                    dontParseAfterManip;
     bool                    fieldUpdate;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
index 4fa2a03..9e7707e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.c
@@ -117,7 +117,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
     memset(p_IpcReply, 0, (sizeof(uint8_t) * FM_PCD_MAX_REPLY_SIZE));
     *p_ReplyLength = 0;
 
-    switch(p_IpcMsg->msgId)
+    switch (p_IpcMsg->msgId)
     {
         case (FM_PCD_MASTER_IS_ALIVE):
             *(uint8_t*)(p_IpcReply->replyBody) = 1;
@@ -126,14 +126,14 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
             break;
         case (FM_PCD_MASTER_IS_ENABLED):
             /* count partitions registrations */
-            if(p_FmPcd->enabled)
+            if (p_FmPcd->enabled)
                 p_FmPcd->numOfEnabledGuestPartitionsPcds++;
             *(uint8_t*)(p_IpcReply->replyBody)  = (uint8_t)p_FmPcd->enabled;
             p_IpcReply->error = E_OK;
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
             break;
         case (FM_PCD_GUEST_DISABLE):
-            if(p_FmPcd->numOfEnabledGuestPartitionsPcds)
+            if (p_FmPcd->numOfEnabledGuestPartitionsPcds)
             {
                 p_FmPcd->numOfEnabledGuestPartitionsPcds--;
                 p_IpcReply->error = E_OK;
@@ -145,7 +145,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
             }
             *p_ReplyLength = sizeof(uint32_t);
             break;
-        case(FM_PCD_GET_COUNTER):
+        case (FM_PCD_GET_COUNTER):
         {
             e_FmPcdCounters inCounter;
             uint32_t        outCounter;
@@ -249,7 +249,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
                                   ipcAllocParams.guestId);
             break;
         }
-        case(FM_PCD_GET_SW_PRS_OFFSET):
+        case (FM_PCD_GET_SW_PRS_OFFSET):
         {
             t_FmPcdIpcSwPrsLable   ipcSwPrsLable;
             uint32_t               swPrsOffset;
@@ -263,7 +263,7 @@ static t_Error IpcMsgHandlerCB(t_Handle  h_FmPcd,
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint32_t);
             break;
         }
-        case(FM_PCD_PRS_INC_PORT_STATS):
+        case (FM_PCD_PRS_INC_PORT_STATS):
         {
             t_FmPcdIpcPrsIncludePort   ipcPrsIncludePort;
 
@@ -381,7 +381,7 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
     int     i, k, j;
 
     ASSERT_COND(p_FmPcd);
-    if(p_FmPcd->netEnvs[netEnvId].clsPlanGrpId != ILLEGAL_CLS_PLAN)
+    if (p_FmPcd->netEnvs[netEnvId].clsPlanGrpId != ILLEGAL_CLS_PLAN)
     {
         p_GrpParams->grpExists = TRUE;
         p_GrpParams->clsPlanGrpId = p_FmPcd->netEnvs[netEnvId].clsPlanGrpId;
@@ -395,16 +395,16 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
                    (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE)); k++)
         {
             /* if an option exists, add it to the opts list */
-            if(p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+            if (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
             {
                 /* check if this option already exists, add if it doesn't */
-                for(j = 0;j<p_GrpParams->numOfOptions;j++)
+                for (j = 0;j<p_GrpParams->numOfOptions;j++)
                 {
-                    if(p_GrpParams->options[j] == p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                    if (p_GrpParams->options[j] == p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
                         break;
                 }
                 p_GrpParams->optVectors[j] |= p_FmPcd->netEnvs[netEnvId].unitsVectors[i];
-                if(j == p_GrpParams->numOfOptions)
+                if (j == p_GrpParams->numOfOptions)
                 {
                     p_GrpParams->options[p_GrpParams->numOfOptions] = p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt;
                     p_GrpParams->numOfOptions++;
@@ -413,9 +413,9 @@ t_Error PcdGetClsPlanGrpParams(t_FmPcd *p_FmPcd, t_FmPcdKgInterModuleClsPlanGrpP
         }
     }
 
-    if(p_GrpParams->numOfOptions == 0)
+    if (p_GrpParams->numOfOptions == 0)
     {
-        if(p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId != ILLEGAL_CLS_PLAN)
+        if (p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId != ILLEGAL_CLS_PLAN)
         {
             p_GrpParams->grpExists = TRUE;
             p_GrpParams->clsPlanGrpId = p_FmPcd->p_FmPcdKg->emptyClsPlanGrpId;
@@ -458,9 +458,9 @@ t_Error PcdGetUnitsVector(t_FmPcd *p_FmPcd, t_NetEnvParams *p_Params)
     ASSERT_COND(p_Params->netEnvId < FM_MAX_NUM_OF_PORTS);
 
     p_Params->vector = 0;
-    for(i=0; i<p_Params->numOfDistinctionUnits ;i++)
+    for (i=0; i<p_Params->numOfDistinctionUnits ;i++)
     {
-        if(p_FmPcd->netEnvs[p_Params->netEnvId].units[p_Params->unitIds[i]].hdrs[0].hdr == HEADER_TYPE_NONE)
+        if (p_FmPcd->netEnvs[p_Params->netEnvId].units[p_Params->unitIds[i]].hdrs[0].hdr == HEADER_TYPE_NONE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Requested unit was not defined for this Network Environment Characteristics module"));
         ASSERT_COND(p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]]);
         p_Params->vector |= p_FmPcd->netEnvs[p_Params->netEnvId].unitsVectors[p_Params->unitIds[i]];
@@ -485,7 +485,7 @@ bool PcdNetEnvIsUnitWithoutOpts(t_FmPcd *p_FmPcd, uint8_t netEnvId, uint32_t uni
                   (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE));
                  k++)
                 /* check that no option exists */
-                if((protocolOpt_t)p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
+                if ((protocolOpt_t)p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt)
                     return FALSE;
             break;
         }
@@ -529,13 +529,13 @@ uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType
 
     if (interchangable)
     {
-        for(i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
+        for (i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
                  (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
         {
-            for(k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS) &&
+            for (k=0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS) &&
                      (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
             {
-                if((p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr == hdr) &&
+                if ((p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].hdr == hdr) &&
                     (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[k].opt == opt))
 
                 return i;
@@ -544,14 +544,14 @@ uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType
     }
     else
     {
-        for(i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
+        for (i=0; (i < FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS) &&
                  (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr != HEADER_TYPE_NONE); i++)
             if ((p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].hdr == hdr) &&
                 (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[0].opt == opt) &&
                 (p_FmPcd->netEnvs[netEnvId].units[i].hdrs[1].hdr == HEADER_TYPE_NONE))
                     return i;
 
-        for(i=0; (i < FM_PCD_MAX_NUM_OF_ALIAS_HDRS) &&
+        for (i=0; (i < FM_PCD_MAX_NUM_OF_ALIAS_HDRS) &&
                  (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr != HEADER_TYPE_NONE); i++)
             if ((p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].hdr == hdr) &&
                 (p_FmPcd->netEnvs[netEnvId].aliasHdrs[i].opt == opt))
@@ -561,47 +561,6 @@ uint8_t FmPcdNetEnvGetUnitId(t_FmPcd *p_FmPcd, uint8_t netEnvId, e_NetHeaderType
     return FM_PCD_MAX_NUM_OF_DISTINCTION_UNITS;
 }
 
-t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
-{
-    t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
-    t_FmPcdCcIpReassmTimeoutParams  ccIpReassmTimeoutParams = {0};
-    t_Error                         err = E_OK;
-    uint8_t                         result;
-    uint32_t                        bitFor1Micro, tsbs;
-
-    ASSERT_COND(p_FmPcd);
-    ASSERT_COND(h_IpReasmCommonPramTbl);
-
-    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
-    tsbs = 31 - bitFor1Micro + 1;
-    tsbs = 17; /* for TimeOut check will be triggered every 1/8ms */
-
-    ccIpReassmTimeoutParams.iprcpt      = (uint32_t)(XX_VirtToPhys(h_IpReasmCommonPramTbl) - p_FmPcd->physicalMuramBase);
-    ccIpReassmTimeoutParams.tsbs        = (uint8_t)tsbs;
-    ccIpReassmTimeoutParams.activate    = TRUE;
-    if ((err = FmHcPcdCcIpTimeoutReassm(p_FmPcd->h_Hc, &ccIpReassmTimeoutParams, &result)) != E_OK)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
-
-    switch (result)
-    {
-        case (0):
-            return E_OK;
-        case (1):
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate TNUM"));
-        case (2):
-            RETURN_ERROR(MAJOR, E_NO_MEMORY, ("failed to allocate internal buffer"));
-        case (3):
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("'Disable Timeout Task' with invalid IPRCPT"));
-        case (4):
-            RETURN_ERROR(MAJOR, E_FULL, ("too many timeout tasks"));
-        case (5):
-            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("invalid sub command"));
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
-    }
-    return E_OK;
-}
-
 t_Error FmPcdUnregisterReassmPort(t_Handle h_FmPcd, t_Handle h_IpReasmCommonPramTbl)
 {
     t_FmPcd                         *p_FmPcd = (t_FmPcd*)h_FmPcd;
@@ -850,7 +809,7 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         p_FmPcd->physicalMuramBase = (uint64_t)((uint64_t)(&physicalMuramBase)->low | ((uint64_t)(&physicalMuramBase)->high << 32));
     }
 
-    for(i = 0; i<FM_MAX_NUM_OF_PORTS; i++)
+    for (i = 0; i<FM_MAX_NUM_OF_PORTS; i++)
         p_FmPcd->netEnvs[i].clsPlanGrpId = ILLEGAL_CLS_PLAN;
 
     if (p_FmPcdParams->useHostCommand)
@@ -872,10 +831,10 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
     else if (p_FmPcd->guestId != NCSW_MASTER_ID)
         REPORT_ERROR(MAJOR, E_INVALID_STATE, ("No Host Command defined for a guest partition."));
 
-    if(p_FmPcdParams->kgSupport)
+    if (p_FmPcdParams->kgSupport)
     {
         p_FmPcd->p_FmPcdKg = (t_FmPcdKg *)KgConfig(p_FmPcd, p_FmPcdParams);
-        if(!p_FmPcd->p_FmPcdKg)
+        if (!p_FmPcd->p_FmPcdKg)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Keygen"));
             FM_PCD_Free(p_FmPcd);
@@ -883,10 +842,10 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         }
     }
 
-    if(p_FmPcdParams->plcrSupport)
+    if (p_FmPcdParams->plcrSupport)
     {
         p_FmPcd->p_FmPcdPlcr = (t_FmPcdPlcr *)PlcrConfig(p_FmPcd, p_FmPcdParams);
-        if(!p_FmPcd->p_FmPcdPlcr)
+        if (!p_FmPcd->p_FmPcdPlcr)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Policer"));
             FM_PCD_Free(p_FmPcd);
@@ -894,10 +853,10 @@ t_Handle FM_PCD_Config(t_FmPcdParams *p_FmPcdParams)
         }
     }
 
-    if(p_FmPcdParams->prsSupport)
+    if (p_FmPcdParams->prsSupport)
     {
         p_FmPcd->p_FmPcdPrs = (t_FmPcdPrs *)PrsConfig(p_FmPcd, p_FmPcdParams);
-        if(!p_FmPcd->p_FmPcdPrs)
+        if (!p_FmPcd->p_FmPcdPrs)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM PCD Parser"));
             FM_PCD_Free(p_FmPcd);
@@ -954,7 +913,7 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
 
     FM_GetRevision(p_FmPcd->h_Fm, &p_FmPcd->fmRevInfo);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
     {
         memset(p_FmPcd->fmPcdIpcHandlerModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
         if (Sprint (p_FmPcd->fmPcdIpcHandlerModuleName, "FM_PCD_%d_%d", FmGetId(p_FmPcd->h_Fm), NCSW_MASTER_ID) != 10)
@@ -1000,21 +959,21 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     if (p_FmPcd->p_FmPcdKg)
     {
         err = KgInit(p_FmPcd);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if (p_FmPcd->p_FmPcdPlcr)
     {
         err = PlcrInit(p_FmPcd);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     if (p_FmPcd->p_FmPcdPrs)
     {
         err = PrsInit(p_FmPcd);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1022,10 +981,10 @@ t_Error FM_PCD_Init(t_Handle h_FmPcd)
     {
          /* register to inter-core messaging mechanism */
         memset(p_FmPcd->fmPcdModuleName, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-        if(Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm),NCSW_MASTER_ID) != 10)
+        if (Sprint (p_FmPcd->fmPcdModuleName, "FM_PCD_%d_%d",FmGetId(p_FmPcd->h_Fm),NCSW_MASTER_ID) != 10)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
         err = XX_IpcRegisterMsgHandler(p_FmPcd->fmPcdModuleName, IpcMsgHandlerCB, p_FmPcd, FM_PCD_MAX_REPLY_SIZE);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
@@ -1054,34 +1013,34 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
     if (p_FmPcd->ipv6FrameIdAddr)
         FM_MURAM_FreeMem(p_FmPcd->h_FmMuram, UINT_TO_PTR(p_FmPcd->ipv6FrameIdAddr));
 
-    if(p_FmPcd->enabled)
+    if (p_FmPcd->enabled)
         FM_PCD_Disable(p_FmPcd);
 
-    if(p_FmPcd->p_FmPcdDriverParam)
+    if (p_FmPcd->p_FmPcdDriverParam)
     {
         XX_Free(p_FmPcd->p_FmPcdDriverParam);
         p_FmPcd->p_FmPcdDriverParam = NULL;
     }
 
-    if(p_FmPcd->p_FmPcdKg)
+    if (p_FmPcd->p_FmPcdKg)
     {
-        if((err = KgFree(p_FmPcd)) != E_OK)
+        if ((err = KgFree(p_FmPcd)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         XX_Free(p_FmPcd->p_FmPcdKg);
         p_FmPcd->p_FmPcdKg = NULL;
     }
 
-    if(p_FmPcd->p_FmPcdPlcr)
+    if (p_FmPcd->p_FmPcdPlcr)
     {
-        if((err = PlcrFree(p_FmPcd)) != E_OK)
+        if ((err = PlcrFree(p_FmPcd)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
         XX_Free(p_FmPcd->p_FmPcdPlcr);
         p_FmPcd->p_FmPcdPlcr = NULL;
     }
 
-    if(p_FmPcd->p_FmPcdPrs)
+    if (p_FmPcd->p_FmPcdPrs)
     {
-        if(p_FmPcd->guestId == NCSW_MASTER_ID)
+        if (p_FmPcd->guestId == NCSW_MASTER_ID)
             PrsFree(p_FmPcd);
         XX_Free(p_FmPcd->p_FmPcdPrs);
         p_FmPcd->p_FmPcdPrs = NULL;
@@ -1117,11 +1076,11 @@ t_Error FM_PCD_ConfigException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bo
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigException - guest mode!"));
 
     GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_FmPcd->exceptions |= bitMask;
@@ -1331,7 +1290,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                 for (j = 0; (j < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                         && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr != HEADER_TYPE_NONE); j++)
                 {
-                    if((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
+                    if ((p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].hdr == p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr) &&
                         !p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[j].opt)
                     {
                         REPORT_ERROR(MINOR, E_FULL,
@@ -1452,9 +1411,9 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
     for (i = 0; i < p_NetEnvParams->numOfDistinctionUnits; i++)
     {
         if (IS_PRIVATE_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
-            switch(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
+            switch (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr)
             {
-                case(HEADER_TYPE_USER_DEFINED_SHIM1):
+                case (HEADER_TYPE_USER_DEFINED_SHIM1):
                     if (shim1Selected)
                     {
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("SHIM header cannot be selected with UDP_IPSEC_ESP"));
@@ -1464,7 +1423,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
                     shim1Selected = TRUE;
                     p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000001;
                 break;
-                case(HEADER_TYPE_USER_DEFINED_SHIM2):
+                case (HEADER_TYPE_USER_DEFINED_SHIM2):
                     p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = 0x00000002;
                     break;
                 default:
@@ -1474,7 +1433,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
         {
             p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i] = (uint32_t)(0x80000000 >> bitId++);
 
-            if(IS_SPECIAL_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
+            if (IS_SPECIAL_HEADER(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[0].hdr))
                 p_FmPcd->netEnvs[netEnvCurrId].macsecVector = p_FmPcd->netEnvs[netEnvCurrId].unitsVectors[i];
         }
     }
@@ -1524,7 +1483,7 @@ t_Error FM_PCD_NetEnvCharacteristicsDelete(t_Handle h_NetEnv)
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
     /* check that no port is bound to this netEnv */
-    if(p_FmPcd->netEnvs[netEnvId].owners)
+    if (p_FmPcd->netEnvs[netEnvId].owners)
     {
         RETURN_ERROR(MINOR, E_INVALID_STATE,
                 ("Trying to delete a netEnv that has ports/schemes/trees/clsPlanGrps bound to"));
@@ -1563,7 +1522,7 @@ t_Error FM_PCD_SetAdvancedOffloadSupport(t_Handle h_FmPcd)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->enabled, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmPcd->enabled, E_INVALID_STATE);
 
     if ((err = FM_GetFmanCtrlCodeRevision(p_FmPcd->h_Fm, &revInfo)) != E_OK)
     {
@@ -1587,10 +1546,10 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE, 0);
 
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
-            if(!p_FmPcd->p_FmPcdKg)
+        case (e_FM_PCD_KG_COUNTERS_TOTAL):
+            if (!p_FmPcd->p_FmPcdKg)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, ("KeyGen is not activated"));
                 return 0;
@@ -1605,12 +1564,12 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
             }
             break;
 
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
             if (!p_FmPcd->p_FmPcdPlcr)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Policer is not activated"));
@@ -1636,24 +1595,24 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                         ((p_FmPcd->guestId != NCSW_MASTER_ID) && p_FmPcd->h_IpcSession));
             break;
 
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-            if(!p_FmPcd->p_FmPcdPrs)
+        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if (!p_FmPcd->p_FmPcdPrs)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Parser is not activated"));
                 return 0;
@@ -1699,58 +1658,58 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
         return outCounter;
     }
 
-    switch(counter)
+    switch (counter)
     {
         /* Parser statistics */
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds);
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs);
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs);
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs);
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs);
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres);
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres);
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres);
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres);
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs);
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs);
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs);
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs);
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
                return GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs);
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+        case (e_FM_PCD_KG_COUNTERS_TOTAL):
                return GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc);
 
         /* Policer statistics */
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RED):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
 
         default:
@@ -1802,35 +1761,35 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetException - guest mode!"));
 
     GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception);
 
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_FmPcd->exceptions |= bitMask;
         else
             p_FmPcd->exceptions &= ~bitMask;
 
-        switch(exception)
+        switch (exception)
         {
-            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
-            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
-                if(!p_FmPcd->p_FmPcdKg)
+            case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+                if (!p_FmPcd->p_FmPcdKg)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
-            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
-            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
-            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
-                if(!p_FmPcd->p_FmPcdPlcr)
+            case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+            case (e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+            case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+                if (!p_FmPcd->p_FmPcdPlcr)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
             break;
-            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
-            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
-                if(!p_FmPcd->p_FmPcdPrs)
+            case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+                if (!p_FmPcd->p_FmPcdPrs)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - parser is not working"));
             break;
             default:
@@ -1838,67 +1797,67 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
 
         }
 
-        switch(exception)
+        switch (exception)
         {
-            case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_KG_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_KG_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
                 break;
-            case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+            case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_KG_KEYSIZE_OVERFLOW;
                 else
                     tmpReg &= ~FM_PCD_KG_KEYSIZE_OVERFLOW;
                 WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgeeer, tmpReg);
                 break;
-            case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PRS_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perer, tmpReg);
                 break;
-            case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+            case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PRS_SINGLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PRS_SINGLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pever, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+            case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PLCR_DOUBLE_ECC;
                 else
                     tmpReg &= ~FM_PCD_PLCR_DOUBLE_ECC;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+            case (e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PLCR_INIT_ENTRY_ERROR;
                 else
                     tmpReg &= ~FM_PCD_PLCR_INIT_ENTRY_ERROR;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eier, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+            case (e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
                 else
                     tmpReg &= ~FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
                 break;
-            case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+            case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
                 tmpReg = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
                 else
                     tmpReg &= ~FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
@@ -1909,12 +1868,12 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
         }
         /* for ECC exceptions driver automatically enables ECC mechanism, if disabled.
            Driver may disable them automatically, depending on driver's status */
-        if(enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if (enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
             FmEnableRamsEcc(p_FmPcd->h_Fm);
-        if(!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if (!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
@@ -1933,33 +1892,33 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ForceIntr - guest mode!"));
 
-    switch(exception)
+    switch (exception)
     {
-        case(e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
-            if(!p_FmPcd->p_FmPcdKg)
+        case (e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC):
+        case (e_FM_PCD_KG_EXCEPTION_KEYSIZE_OVERFLOW):
+            if (!p_FmPcd->p_FmPcdKg)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - keygen is not working"));
             break;
-        case(e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
-        case(e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
-        case(e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
-            if(!p_FmPcd->p_FmPcdPlcr)
+        case (e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC):
+        case (e_FM_PCD_PLCR_EXCEPTION_INIT_ENTRY_ERROR):
+        case (e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE):
+        case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
+            if (!p_FmPcd->p_FmPcdPlcr)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
             break;
-        case(e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
-        case(e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
-           if(!p_FmPcd->p_FmPcdPrs)
+        case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
+        case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
+           if (!p_FmPcd->p_FmPcdPrs)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
 
     }
-    switch(exception)
+    switch (exception)
     {
         case e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC:
             if (!(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC))
@@ -2016,123 +1975,123 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_STATE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ModifyCounter - guest mode!"));
 
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
-            if(!p_FmPcd->p_FmPcdKg)
+        case (e_FM_PCD_KG_COUNTERS_TOTAL):
+            if (!p_FmPcd->p_FmPcdKg)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid counters - KeyGen is not working"));
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
-            if(!p_FmPcd->p_FmPcdPlcr)
+        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+            if (!p_FmPcd->p_FmPcdPlcr)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid counters - Policer is not working"));
-            if(!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
+            if (!(GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr) & FM_PCD_PLCR_GCR_STEN))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
-            if(!p_FmPcd->p_FmPcdPrs)
+        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+            if (!p_FmPcd->p_FmPcdPrs)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
             break;
         default:
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
     }
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
+        case (e_FM_PCD_PRS_COUNTERS_PARSE_DISPATCH):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pds, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rrs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rrs, value);
              break;
-       case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
+       case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rrs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srrs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L2_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l2rres, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L3_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l3rres, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_L4_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->l4rres, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
+        case (e_FM_PCD_PRS_COUNTERS_SHIM_PARSE_RESULT_RETURNED_WITH_ERR):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->srres, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spcs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_SOFT_PRS_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->spscs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_HARD_PRS_CYCLE_INCL_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->hxscs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrcs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_READ_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mrscs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwcs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_MURAM_WRITE_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->mwscs, value);
             break;
-        case(e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
+        case (e_FM_PCD_PRS_COUNTERS_FPM_COMMAND_STALL_CYCLES):
                WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->fcscs, value);
              break;
-        case(e_FM_PCD_KG_COUNTERS_TOTAL):
+        case (e_FM_PCD_KG_COUNTERS_TOTAL):
             WRITE_UINT32(p_FmPcd->p_FmPcdKg->p_FmPcdKgRegs->kgtpc,value);
             break;
 
         /*Policer counters*/
-        case(e_FM_PCD_PLCR_COUNTERS_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_YELLOW):
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ypcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RED):
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rpcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_RED):
              WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rrpcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
+        case (e_FM_PCD_PLCR_COUNTERS_RECOLORED_TO_YELLOW):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_rypcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_TOTAL):
+        case (e_FM_PCD_PLCR_COUNTERS_TOTAL):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt, value);
             break;
-        case(e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
+        case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt, value);
             break;
         default:
@@ -2141,3 +2100,5 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
 
 return E_OK;
 }
+
+
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
index ac4f692..eb004f7 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_pcd.h
@@ -95,7 +95,7 @@
 #define FM_PCD_EX_PRS_SINGLE_ECC                    0x01000000
 
 #define GET_FM_PCD_EXCEPTION_FLAG(bitMask, exception)               \
-switch(exception){                                                  \
+switch (exception){                                                 \
     case e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC:                          \
         bitMask = FM_PCD_EX_KG_DOUBLE_ECC; break;                   \
     case e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC:                        \
@@ -555,20 +555,19 @@ t_CcNodeInformation* FindNodeInfoInReleventLst(t_List *p_List, t_Handle h_Info,
 t_List *FmPcdManipGetSpinlock(t_Handle h_Manip);
 t_List *FmPcdManipGetNodeLstPointedOnThisManip(t_Handle h_Manip);
 
+typedef struct
+{
+    t_Handle    h_StatsAd;
+    t_Handle    h_StatsCounters;
+#if (DPAA_VERSION >= 11)
+    t_Handle    h_StatsFLRs;
+#endif /* (DPAA_VERSION >= 11) */
+} t_FmPcdCcStatsParams;
 
 void NextStepAd(t_Handle                     h_Ad,
-                t_Handle                     h_StatsAd,
-                t_Handle                     h_StatsCounters,
-                t_Handle                     h_StatsFrameLengthRanges,
+                t_FmPcdCcStatsParams         *p_FmPcdCcStatsParams,
                 t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams,
                 t_FmPcd                      *p_FmPcd);
-
-void FillAdOfTypeResult(t_Handle                    h_Ad,
-                        t_Handle                    h_StatsAd,
-                        t_Handle                    h_StatsCounters,
-                        t_Handle                    h_StatsFrameLengthRanges,
-                        t_FmPcd                     *p_FmPcd,
-                        t_FmPcdCcNextEngineParams   *p_CcNextEngineParams);
 void ReleaseLst(t_List *p_List);
 
 static __inline__ t_Handle FmPcdGetMuramHandle(t_Handle h_FmPcd)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
index 08c236d..fe95bec 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_plcr.c
@@ -141,19 +141,19 @@ static t_Error SetProfileNia(t_FmPcd *p_FmPcd, e_FmPcdEngine nextEngine, u_FmPcd
         case e_FM_PCD_KG:
             physicalSchemeId = FmPcdKgGetSchemeId(p_NextEngineParams->h_DirectScheme);
             relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPcd, physicalSchemeId);
-            if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+            if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
                 RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, NO_MSG);
             if (!FmPcdKgIsSchemeValidSw(p_NextEngineParams->h_DirectScheme))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid direct scheme."));
-            if(!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
+            if (!KgIsSchemeAlwaysDirect(p_FmPcd, relativeSchemeId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Policer Profile may point only to a scheme that is always direct."));
             nia |= NIA_ENG_KG | NIA_KG_DIRECT | physicalSchemeId;
             break;
         case e_FM_PCD_PLCR:
             absoluteProfileId = ((t_FmPcdPlcrProfile *)p_NextEngineParams->h_Profile)->absoluteProfileId;
-            if(!IsProfileShared(p_FmPcd, absoluteProfileId))
+            if (!IsProfileShared(p_FmPcd, absoluteProfileId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Next profile must be a shared profile"));
-            if(!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
+            if (!FmPcdPlcrIsProfileValid(p_FmPcd, absoluteProfileId))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid profile "));
             nia |= NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId;
             break;
@@ -254,7 +254,7 @@ static void CalcRates(t_Handle                              h_FmPcd,
      * For high rates it will never exceed the 32 bit reg (after the 16 shift), as it is
      * limited by the 10G physical port.
      */
-    if(temp != 0)
+    if (temp != 0)
     {
         /* In this case, the largest rate integer is non 0, if it does not occupy all (high) 16
          * bits of the PIR_EIR we can use this fact and enlarge it to occupy all 16 bits.
@@ -275,7 +275,7 @@ static void CalcRates(t_Handle                              h_FmPcd,
             temp = temp << 1;
             fppShift++;
         }
-        if(fppShift > 15)
+        if (fppShift > 15)
         {
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, ("timeStampPeriod to Information rate ratio is too small"));
             return;
@@ -284,7 +284,7 @@ static void CalcRates(t_Handle                              h_FmPcd,
     else
     {
         temp = (uint32_t)fraction; /* fraction will alyas be smaller than 2^16 */
-        if(!temp)
+        if (!temp)
             /* integer and fraction are 0, we set FP to its max val */
             fppShift = 31;
         else
@@ -329,7 +329,7 @@ static void WritePar(t_FmPcd *p_FmPcd, uint32_t par)
     ASSERT_COND(FmIsMaster(p_FmPcd->h_Fm));
     WRITE_UINT32(p_FmPcdPlcrRegs->fmpl_par, par);
 
-    while(GET_UINT32(p_FmPcdPlcrRegs->fmpl_par) & FM_PCD_PLCR_PAR_GO) ;
+    while (GET_UINT32(p_FmPcdPlcrRegs->fmpl_par) & FM_PCD_PLCR_PAR_GO) ;
 }
 
 static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
@@ -343,13 +343,13 @@ static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
 
 /* Set G, Y, R Nia */
     err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnGreen,  &(p_ProfileParams->paramsOnGreen), &gnia);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnYellow, &(p_ProfileParams->paramsOnYellow), &ynia);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
     err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnRed,    &(p_ProfileParams->paramsOnRed), &rnia);
-   if(err)
+   if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
 /* Mode fmpl_pemode */
@@ -581,6 +581,7 @@ static void FreeSharedProfiles(t_FmPcd *p_FmPcd, uint16_t numOfProfiles, uint16_
     {
         ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated);
         p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.allocated = FALSE;
+        p_FmPcd->p_FmPcdPlcr->profiles[profilesIds[i]].profilesMng.ownerId = p_FmPcd->guestId;
     }
 }
 
@@ -600,15 +601,15 @@ static void EventsCB(t_Handle h_FmPcd)
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, force & ~event);
 
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_evr, event);
 
-    if(event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
+    if (event & FM_PCD_PLCR_PRAM_SELF_INIT_COMPLETE)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_PRAM_SELF_INIT_COMPLETE);
-    if(event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
+    if (event & FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE);
 }
 
@@ -627,7 +628,7 @@ static void ErrorExceptionsCB(t_Handle h_FmPcd)
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eifr, force & ~event);
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_eevr, event);
@@ -1104,8 +1105,7 @@ t_Error FmPcdPlcrAllocProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId, uint16_
     err = PlcrSetPortProfiles(p_FmPcd, hardwarePortId, numOfProfiles, first);
     if (err)
     {
-        /* TODO - rollback the allocated profiles! */
-        RETURN_ERROR(MAJOR, err,NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
@@ -1144,7 +1144,7 @@ t_Error FmPcdPlcrFreeProfiles(t_Handle h_FmPcd, uint8_t hardwarePortId)
         ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated);
 
         p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.allocated = FALSE;
-        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = 0;
+        p_FmPcd->p_FmPcdPlcr->profiles[i].profilesMng.ownerId = p_FmPcd->guestId;
     }
     PlcrSwUnlock(p_FmPcd->p_FmPcdPlcr, intFlags);
 
@@ -1189,12 +1189,12 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
     intFlags = PlcrHwLock(p_FmPcdPlcr);
     WritePar(p_FmPcd, FmPcdPlcrBuildReadPlcrActionReg(profileIndx));
 
-    if(!p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners ||
+    if (!p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].pointedOwners ||
        !(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].requiredAction & requiredAction))
     {
-        if(requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
+        if (requiredAction & UPDATE_NIA_ENQ_WITHOUT_DMA)
         {
-            if((p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnGreen!= e_FM_PCD_DONE) ||
+            if ((p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnGreen!= e_FM_PCD_DONE) ||
                (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnYellow!= e_FM_PCD_DONE) ||
                (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].nextEngineOnRed!= e_FM_PCD_DONE))
             {
@@ -1203,10 +1203,10 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 RETURN_ERROR (MAJOR, E_OK, ("In this case the next engine can be e_FM_PCD_DONE"));
             }
 
-            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnGreen.action == e_FM_PCD_ENQ_FRAME)
+            if (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnGreen.action == e_FM_PCD_ENQ_FRAME)
             {
                 tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pegnia);
-                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
                     /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
@@ -1219,10 +1219,10 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 WritePar(p_FmPcd, tmpReg32);
             }
 
-            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnYellow.action == e_FM_PCD_ENQ_FRAME)
+            if (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnYellow.action == e_FM_PCD_ENQ_FRAME)
             {
                 tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_peynia);
-                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
                     /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
@@ -1236,10 +1236,10 @@ t_Error FmPcdPlcrCcGetSetParams(t_Handle h_FmPcd, uint16_t profileIndx ,uint32_t
                 PlcrHwUnlock(p_FmPcdPlcr, intFlags);
             }
 
-            if(p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnRed.action == e_FM_PCD_ENQ_FRAME)
+            if (p_FmPcd->p_FmPcdPlcr->profiles[profileIndx].paramsOnRed.action == e_FM_PCD_ENQ_FRAME)
             {
                 tmpReg32 = GET_UINT32(p_FmPcdPlcrRegs->profileRegs.fmpl_pernia);
-                if(!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
+                if (!(tmpReg32 & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)))
                 {
                     PlcrHwUnlock(p_FmPcdPlcr, intFlags);
                     /*PlcrProfileUnlock(&p_FmPcd->p_FmPcdPlcr->profiles[profileIndx], intFlags);*/
@@ -1272,7 +1272,7 @@ void FmPcdPlcrUpatePointedOwner(t_Handle h_FmPcd, uint16_t absoluteProfileId, bo
 
     ASSERT_COND(p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].valid);
 
-    if(add)
+    if (add)
         p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners++;
     else
         p_FmPcd->p_FmPcdPlcr->profiles[absoluteProfileId].pointedOwners--;
@@ -1350,7 +1350,7 @@ t_Error FmPcdPlcrGetAbsoluteIdByProfileParams(t_Handle                      h_Fm
         case e_FM_PCD_PLCR_PORT_PRIVATE:
             /* get port PCD id from port handle */
             for (i=0;i<FM_MAX_NUM_OF_PORTS;i++)
-                if(p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
+                if (p_FmPcd->p_FmPcdPlcr->portsMapping[i].h_FmPort == h_FmPort)
                     break;
             if (i ==  FM_MAX_NUM_OF_PORTS)
                 RETURN_ERROR(MAJOR, E_INVALID_STATE , ("Invalid port handle."));
@@ -1409,7 +1409,7 @@ uint32_t FmPcdPlcrBuildWritePlcrActionRegs(uint16_t absoluteProfileId)
 bool    FmPcdPlcrHwProfileIsValid(uint32_t profileModeReg)
 {
 
-    if(profileModeReg & FM_PCD_PLCR_PEMODE_PI)
+    if (profileModeReg & FM_PCD_PLCR_PEMODE_PI)
         return TRUE;
     else
         return FALSE;
@@ -1425,17 +1425,17 @@ uint32_t FmPcdPlcrBuildReadPlcrActionReg(uint16_t absoluteProfileId)
 
 uint32_t FmPcdPlcrBuildCounterProfileReg(e_FmPcdPlcrProfileCounters counter)
 {
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER):
+        case (e_FM_PCD_PLCR_PROFILE_GREEN_PACKET_TOTAL_COUNTER):
             return FM_PCD_PLCR_PAR_PWSEL_PEGPC;
-        case(e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER):
+        case (e_FM_PCD_PLCR_PROFILE_YELLOW_PACKET_TOTAL_COUNTER):
             return FM_PCD_PLCR_PAR_PWSEL_PEYPC;
-        case(e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER) :
+        case (e_FM_PCD_PLCR_PROFILE_RED_PACKET_TOTAL_COUNTER) :
             return FM_PCD_PLCR_PAR_PWSEL_PERPC;
-        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER) :
+        case (e_FM_PCD_PLCR_PROFILE_RECOLOURED_YELLOW_PACKET_TOTAL_COUNTER) :
             return FM_PCD_PLCR_PAR_PWSEL_PERYPC;
-        case(e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER) :
+        case (e_FM_PCD_PLCR_PROFILE_RECOLOURED_RED_PACKET_TOTAL_COUNTER) :
             return FM_PCD_PLCR_PAR_PWSEL_PERRPC;
        default:
             REPORT_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
@@ -1448,11 +1448,11 @@ uint32_t FmPcdPlcrBuildNiaProfileReg(bool green, bool yellow, bool red)
 
     uint32_t tmpReg32 = 0;
 
-    if(green)
+    if (green)
         tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEGNIA;
-    if(yellow)
+    if (yellow)
         tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PEYNIA;
-    if(red)
+    if (red)
         tmpReg32 |= FM_PCD_PLCR_PAR_PWSEL_PERNIA;
 
     return tmpReg32;
@@ -1483,7 +1483,7 @@ t_Error FM_PCD_ConfigPlcrAutoRefreshMode(t_Handle h_FmPcd, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
 
-    if(!FmIsMaster(p_FmPcd->h_Fm))
+    if (!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPlcrAutoRefreshMode - guest mode!"));
 
     p_FmPcd->p_FmPcdDriverParam->plcrAutoRefresh = enable;
@@ -1513,11 +1513,11 @@ t_Error FM_PCD_SetPlcrStatistics(t_Handle h_FmPcd, bool enable)
     SANITY_CHECK_RETURN_ERROR(!p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdPlcr, E_INVALID_HANDLE);
 
-    if(!FmIsMaster(p_FmPcd->h_Fm))
+    if (!FmIsMaster(p_FmPcd->h_Fm))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPlcrStatistics - guest mode!"));
 
     tmpReg32 =  GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_gcr);
-    if(enable)
+    if (enable)
         tmpReg32 |= FM_PCD_PLCR_GCR_STEN;
     else
         tmpReg32 &= ~FM_PCD_PLCR_GCR_STEN;
@@ -1587,7 +1587,7 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
 
     SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
 
-    if(p_ProfileParams->modify)
+    if (p_ProfileParams->modify)
     {
         p_Profile = (t_FmPcdPlcrProfile *)p_ProfileParams->id.h_Profile;
         p_FmPcd = p_Profile->h_FmPcd;
@@ -1662,7 +1662,7 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     if (err)
     {
         REPORT_ERROR(MAJOR, err, NO_MSG);
-        if(p_ProfileParams->modify)
+        if (p_ProfileParams->modify)
             /* unlock */
             PlcrProfileFlagUnlock(p_Profile);
         if (!p_ProfileParams->modify &&
@@ -1675,9 +1675,9 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
     if (p_FmPcd->h_Hc)
     {
          err = FmHcPcdPlcrSetProfile(p_FmPcd->h_Hc, (t_Handle)p_Profile, &plcrProfileReg);
-         if(p_ProfileParams->modify)
+         if (p_ProfileParams->modify)
              PlcrProfileFlagUnlock(p_Profile);
-         if(err)
+         if (err)
          {
              /* release the allocated scheme lock */
              if (!p_ProfileParams->modify &&
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
index 620ef96..3e387b3 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.c
@@ -61,14 +61,14 @@ static void PcdPrsErrorException(t_Handle h_FmPcd)
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perfr, force & ~event);
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->perr, event);
 
     DBG(TRACE, ("parser error - 0x%08x\n",event));
 
-    if(event & FM_PCD_PRS_DOUBLE_ECC)
+    if (event & FM_PCD_PRS_DOUBLE_ECC)
         p_FmPcd->f_Exception(p_FmPcd->h_App,e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC);
 }
 
@@ -87,7 +87,7 @@ static void PcdPrsException(t_Handle h_FmPcd)
 
     /* clear the forced events */
     force = GET_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevfr, force & ~event);
 
     WRITE_UINT32(p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs->pevr, event);
@@ -177,7 +177,7 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
 
     /**********************PERER******************/
     tmpReg = 0;
-    if(p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC)
+    if (p_FmPcd->exceptions & FM_PCD_EX_PRS_DOUBLE_ECC)
     {
         FmEnableRamsEcc(p_FmPcd->h_Fm);
         tmpReg |= FM_PCD_PRS_DOUBLE_ECC;
@@ -348,7 +348,7 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable)
     SANITY_CHECK_RETURN(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(p_FmPcd->p_FmPcdPrs, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
     {
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_SetPrsStatistics - guest mode!"));
         return;
@@ -378,7 +378,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 
     if (!p_SwPrs->override)
     {
-        if(p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
+        if (p_FmPcd->p_FmPcdPrs->p_CurrSwPrs > p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SW parser base must be larger than current loaded code"));
     }
     else
@@ -404,7 +404,7 @@ t_Error FM_PCD_PrsLoadSw(t_Handle h_FmPcd, t_FmPcdPrsSwParams *p_SwPrs)
 
     /* load sw parser code */
     p_LoadTarget = p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4;
-    for(i=0; i<DIV_CEIL(p_SwPrs->size,4); i++)
+    for (i=0; i<DIV_CEIL(p_SwPrs->size,4); i++)
         WRITE_UINT32(p_LoadTarget[i], p_TmpCode[i]);
     p_FmPcd->p_FmPcdPrs->p_CurrSwPrs =
         p_FmPcd->p_FmPcdPrs->p_SwPrsCode + p_SwPrs->base*2/4 + ROUND_UP(p_SwPrs->size,4);
@@ -428,7 +428,7 @@ t_Error FM_PCD_ConfigPrsMaxCycleLimit(t_Handle h_FmPcd,uint16_t value)
     SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->p_FmPcdDriverParam, E_INVALID_HANDLE);
 
-    if(p_FmPcd->guestId != NCSW_MASTER_ID)
+    if (p_FmPcd->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM_PCD_ConfigPrsMaxCycleLimit - guest mode!"));
 
     p_FmPcd->p_FmPcdDriverParam->prsMaxParseCycleLimit = value;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
index b4a162f..04e4362 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_prs.h
@@ -47,7 +47,7 @@
 /***********************************************************************/
 
 #if (DPAA_VERSION == 10)
-/* Version: 106.1.7 */
+/* Version: 106.1.8 */
 #define SW_PRS_IP_FRAG_PATCH                           \
 {                                                      \
     0x31,0x52,0x00,0xDA,0x0A,0x00,0x00,0x00,0x00,0x00, \
@@ -61,29 +61,29 @@
     0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x2F,0x00,0x00, \
     0x00,0x01,0x1B,0xFE,0x31,0x52,0x00,0xDA,0x00,0x40, \
     0x00,0x00,0x00,0x00,0x00,0x00,0x53,0x96,0x00,0x00, \
-    0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00, \
+    0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x23,0x00,0x00, \
     0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
     0x28,0x43,0x30,0x7E,0x43,0x49,0x00,0x00,0x30,0x7E, \
-    0x43,0x49,0x00,0x3C,0x1B,0x63,0x32,0x11,0x28,0x41, \
+    0x43,0x49,0x00,0x3C,0x1B,0x63,0x32,0x11,0x28,0x23, \
     0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81,0x00,0x00, \
     0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11,0x32,0xC0, \
     0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81,0x32,0x11, \
     0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01,0x01,0x04, \
     0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x42,0x30,0x7E, \
-    0x53,0x79,0x00,0x2B,0x32,0x11,0x28,0x41,0x32,0x11, \
+    0x53,0x79,0x00,0x2B,0x32,0x11,0x28,0x23,0x32,0x11, \
     0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
     0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
     0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
     0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0x8D,0x00,0x00, \
-    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x41,0x06,0x29, \
-    0x32,0x01,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
+    0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x23,0x06,0x29, \
+    0x31,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
     0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x00,0x01, \
-    0x1B,0xFE,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
+    0x1B,0xFE,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x23, \
     0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43,0x1B,0xCE, \
-    0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41,0x00,0x00, \
+    0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x23,0x00,0x00, \
     0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55,0x00,0x28, \
     0x28,0x43,0x30,0x7E,0x43,0xBE,0x00,0x2C,0x32,0x11, \
-    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81, \
+    0x28,0x23,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81, \
     0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11, \
     0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
     0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
@@ -95,7 +95,7 @@
 }
 
 #else
-/* version: 106.3.9 */
+/* version: 106.3.11 */
 #define SW_PRS_IP_FRAG_PATCH                           \
 {                                                      \
     0x31,0x52,0x00,0xDA,0x0E,0x4F,0x00,0x00,0x00,0x00, \
@@ -106,54 +106,52 @@
     0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x00,0x00,0x00, \
     0x00,0x01,0x1B,0xFE,0x00,0x00,0x99,0x00,0x53,0x09, \
     0x00,0x00,0x00,0x00,0x9F,0x98,0x53,0x09,0x00,0x00, \
-    0x1B,0x25,0x34,0xF5,0x00,0xFB,0xFF,0xFF,0x00,0x7F, \
-    0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7,0x00,0xF9, \
-    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97, \
-    0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01, \
-    0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03, \
-    0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01, \
-    0x1B,0xFE,0x31,0x52,0x00,0xDA,0x0E,0x4F,0x00,0x00, \
-    0x00,0x00,0x00,0x00,0x53,0x3D,0x04,0x4B,0x31,0x53, \
-    0x00,0xFB,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00, \
-    0x29,0x2B,0x33,0xF1,0x00,0xFB,0x00,0xDF,0x00,0x00, \
-    0x00,0x00,0x00,0x00,0x28,0x7F,0x31,0x52,0x00,0xDA, \
-    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x43,0x47, \
-    0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52,0x00,0xDA, \
-    0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x53,0xAE, \
-    0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
-    0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x61,0x00,0x00, \
-    0x30,0x7E,0x43,0x61,0x00,0x3C,0x1B,0x7B,0x32,0x11, \
-    0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x81, \
-    0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00,0x32,0x11, \
-    0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01,0x00,0x81, \
-    0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50,0x00,0x01, \
-    0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00,0x1B,0x5A, \
-    0x30,0x7E,0x53,0x91,0x00,0x2B,0x32,0x11,0x28,0x41, \
-    0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
-    0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
-    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
-    0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E,0x53,0xA5, \
-    0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x41, \
-    0x06,0x29,0x32,0x01,0x00,0x00,0x83,0x8E,0x00,0x50, \
-    0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
-    0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55,0x00,0x06, \
-    0x28,0x41,0x32,0xC1,0x00,0x55,0x00,0x28,0x28,0x43, \
-    0x1B,0xF2,0x32,0xC1,0x00,0x55,0x00,0x06,0x28,0x41, \
-    0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1,0x00,0x55, \
-    0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xD6,0x00,0x2C, \
-    0x32,0x11,0x28,0x41,0x32,0x11,0x32,0xC0,0x00,0x4F, \
+    0x1B,0x21,0x09,0x4F,0x00,0x20,0x00,0x00,0x34,0xB7, \
+    0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00, \
+    0x2B,0x97,0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9, \
+    0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F, \
+    0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE, \
+    0x00,0x01,0x1B,0xFE,0x31,0x52,0x00,0xDA,0x0E,0x4F, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x53,0x39,0x04,0x4B, \
+    0x31,0x53,0x00,0xFB,0xFF,0xF0,0x00,0x00,0x00,0x00, \
+    0x00,0x00,0x29,0x2B,0x33,0xF1,0x00,0xFB,0x00,0xDF, \
+    0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F,0x31,0x52, \
+    0x00,0xDA,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x43,0x43,0x00,0x00,0x00,0x01,0x1B,0xFE,0x31,0x52, \
+    0x00,0xDA,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x53,0xAA,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x23,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0x5D, \
+    0x00,0x00,0x30,0x7E,0x43,0x5D,0x00,0x3C,0x1B,0x77, \
+    0x32,0x11,0x28,0x23,0x32,0x11,0x32,0xC0,0x00,0x4F, \
     0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F,0x06,0x00, \
     0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55,0x00,0x01, \
     0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E,0x00,0x50, \
     0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43,0x06,0x00, \
-    0x1B,0xB9,0x34,0xF5,0x00,0xFB,0xFF,0xFF,0x00,0x7F, \
-    0x00,0x00,0x00,0x00,0x2A,0x9F,0x34,0xB7,0x00,0xF9, \
-    0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x2B,0x97, \
-    0x31,0xB3,0x29,0x8F,0x33,0xF1,0x00,0xF9,0x00,0x01, \
-    0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x7F,0x00,0x03, \
-    0x00,0x02,0x00,0x00,0x00,0x01,0x1B,0xFE,0x00,0x01, \
-    0x1B,0xFE,                                         \
+    0x1B,0x56,0x30,0x7E,0x53,0x8D,0x00,0x2B,0x32,0x11, \
+    0x28,0x23,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x00,0x01,0x1B,0xFE,0x00,0x00,0x9B,0x8E, \
+    0x53,0xA1,0x00,0x00,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x23,0x06,0x29,0x31,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x00,0x01,0x1B,0xFE,0x32,0xC1,0x00,0x55, \
+    0x00,0x06,0x28,0x23,0x32,0xC1,0x00,0x55,0x00,0x28, \
+    0x28,0x43,0x1B,0xEA,0x32,0xC1,0x00,0x55,0x00,0x06, \
+    0x28,0x23,0x00,0x00,0x9B,0x8F,0x2F,0x0F,0x32,0xC1, \
+    0x00,0x55,0x00,0x28,0x28,0x43,0x30,0x7E,0x43,0xD2, \
+    0x00,0x2C,0x32,0x11,0x28,0x23,0x32,0x11,0x32,0xC0, \
+    0x00,0x4F,0x00,0x81,0x00,0x00,0x83,0x8F,0x2F,0x0F, \
+    0x06,0x00,0x32,0x11,0x32,0xC0,0x00,0x4F,0x00,0x55, \
+    0x00,0x01,0x00,0x81,0x32,0x11,0x00,0x00,0x83,0x8E, \
+    0x00,0x50,0x00,0x01,0x01,0x04,0x00,0x4D,0x28,0x43, \
+    0x06,0x00,0x1B,0xB5,0x09,0x4F,0x00,0x20,0x00,0x00, \
+    0x34,0xB7,0x00,0xF9,0x00,0x00,0x01,0x00,0x00,0x00, \
+    0x00,0x00,0x2B,0x97,0x31,0xB3,0x29,0x8F,0x33,0xF1, \
+    0x00,0xF9,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00, \
+    0x28,0x7F,0x00,0x03,0x00,0x02,0x00,0x00,0x00,0x01, \
+    0x1B,0xFE,0x00,0x01,0x1B,0xFE,                     \
 }
 #endif /* (DPAA_VERSION == 10) */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
index 72553b1..ba8d807 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
@@ -222,7 +222,6 @@ static t_Error ModifyDescriptor(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
 {
     t_Handle            h_Hc;
     t_Error             err;
-    uint32_t            oldDescriptorOffset, newDescriptorOffset;
     t_FmPcd             *p_FmPcd;
 
     ASSERT_COND(p_ReplicGroup);
@@ -235,12 +234,9 @@ static t_Error ModifyDescriptor(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
     if (!h_Hc)
         RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("Host command"));
 
-    oldDescriptorOffset =
-        (uint32_t)(XX_VirtToPhys(p_OldDescriptor) - p_FmPcd->physicalMuramBase);
-    newDescriptorOffset =
-        (uint32_t)(XX_VirtToPhys(p_NewDescriptor) - p_FmPcd->physicalMuramBase);
-
-    err = FmHcPcdCcDoDynamicChange(h_Hc, oldDescriptorOffset, newDescriptorOffset);
+    err = FmHcPcdCcDoDynamicChange(h_Hc,
+                                   (uint32_t)(XX_VirtToPhys(p_OldDescriptor) - p_FmPcd->physicalMuramBase),
+                                   (uint32_t)(XX_VirtToPhys(p_NewDescriptor) - p_FmPcd->physicalMuramBase));
     if (err)
         RETURN_ERROR(MAJOR, err, ("Dynamic change host command"));
 
@@ -421,8 +417,6 @@ static t_FmPcdFrmReplicMember* InitMember(t_FmPcdFrmReplicGroup     *p_ReplicGro
     /* Initialize the Ad of the member */
     NextStepAd(p_CurrentMember->p_MemberAd,
                NULL,
-               NULL,
-               NULL,
                p_MemberParams,
                p_ReplicGroup->h_FmPcd);
 
@@ -481,8 +475,6 @@ static t_Error RemoveMember(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
                                                  NULL,
                                                  TRUE/*sourceDescriptor*/,
                                                  FALSE/*last*/);
-            if (err)
-                RETURN_ERROR(MAJOR, err, ("update source td itself"));
             break;
 
         case FRM_REPLIC_MIDDLE_MEMBER_INDEX:
@@ -498,8 +490,6 @@ static t_Error RemoveMember(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
                                                  FALSE/*sourceDescriptor*/,
                                                  FALSE/*last*/);
 
-            if (err)
-                RETURN_ERROR(MAJOR, err, ("Build Shadow and modify descriptor in case of middle member"));
             break;
 
         case FRM_REPLIC_LAST_MEMBER_INDEX:
@@ -511,14 +501,25 @@ static t_Error RemoveMember(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
                                                  p_PreviousMember,
                                                  FALSE/*sourceDescriptor*/,
                                                  TRUE/*last*/);
-            if (err)
-                RETURN_ERROR(MAJOR, err, ("Build Shadow and modify descriptor in case of last member"));
             break;
 
         default:
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member position in remove member"));
     }
 
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
+
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
+
     if (p_CurrentMember->h_Manip)
     {
         FmPcdManipUpdateOwner(p_CurrentMember->h_Manip, FALSE);
@@ -835,7 +836,12 @@ t_Error FM_PCD_FrmReplicAddMember(t_Handle                  h_ReplicGroup,
     /* group lock */
     err = FrmReplicGroupTryLock(p_ReplicGroup);
     if (err)
-        RETURN_ERROR(MAJOR, err, ("Lock in add operation"));
+    {
+        if (GET_ERROR_TYPE(err) == E_BUSY)
+            return ERROR_CODE(E_BUSY);
+        else
+            RETURN_ERROR(MAJOR, err, ("try lock in Add member"));
+    }
 
     if (memberIndex > p_ReplicGroup->numOfEntries)
     {
@@ -948,6 +954,16 @@ t_Error FM_PCD_FrmReplicRemoveMember(t_Handle   h_ReplicGroup,
 
     SANITY_CHECK_RETURN_ERROR(p_ReplicGroup, E_INVALID_HANDLE);
 
+    /* lock */
+    err = FrmReplicGroupTryLock(p_ReplicGroup);
+    if (err)
+    {
+        if (GET_ERROR_TYPE(err) == E_BUSY)
+            return ERROR_CODE(E_BUSY);
+        else
+            RETURN_ERROR(MAJOR, err, ("try lock in Remove member"));
+    }
+
     if (memberIndex >= p_ReplicGroup->numOfEntries)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member index to remove"));
 
@@ -956,23 +972,23 @@ t_Error FM_PCD_FrmReplicRemoveMember(t_Handle   h_ReplicGroup,
     if (p_ReplicGroup->numOfEntries == 1)
         RETURN_ERROR(MAJOR, E_CONFLICT, ("Can't remove the last member. At least one member should be related to a group."));
 
-    /* lock */
-    err = FrmReplicGroupTryLock(p_ReplicGroup);
-    if (err)
-        RETURN_ERROR(MAJOR, err, ("Lock in remove member operation"));
-
     err = RemoveMember(p_ReplicGroup, memberIndex);
-    if (err)
-    {
-        /* unlock */
-        FrmReplicGroupUnlock(p_ReplicGroup);
-        RETURN_ERROR(MAJOR, err, ("Unlock in remove member operation"));
-    }
 
     /* unlock */
     FrmReplicGroupUnlock(p_ReplicGroup);
 
-    return E_OK;
+    switch (GET_ERROR_TYPE(err))
+    {
+        case E_OK:
+            return E_OK;
+
+        case E_BUSY:
+            DBG(TRACE, ("E_BUSY error"));
+            return ERROR_CODE(E_BUSY);
+
+        default:
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+    }
 }
 
 /*********************** End of API routines ************************/
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
index 30c57f8..335da8f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.c
@@ -57,8 +57,8 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
 
     if (p_FmPort->imEn)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
-            if(p_FmPort->fifoDeqPipelineDepth > 2)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G)
+            if (p_FmPort->fifoDeqPipelineDepth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for IM 10G can't be larger than 2"));
 
         if ((ans = FmPortImCheckInitParameters(p_FmPort)) != E_OK)
@@ -69,25 +69,25 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx only                            */
         /****************************************/
-        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         {
             /* external buffer pools */
-            if(!p_Params->extBufPools.numOfPoolsUsed)
+            if (!p_Params->extBufPools.numOfPoolsUsed)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.numOfPoolsUsed=0. At least one buffer pool must be defined"));
 
-            if(FmSpCheckBufPoolsParams(&p_Params->extBufPools, p_Params->p_BackupBmPools, &p_Params->bufPoolDepletion)!= E_OK)
+            if (FmSpCheckBufPoolsParams(&p_Params->extBufPools, p_Params->p_BackupBmPools, &p_Params->bufPoolDepletion)!= E_OK)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
             /* Check that part of IC that needs copying is small enough to enter start margin */
-            if(p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
+            if (p_Params->intContext.size && (p_Params->intContext.size + p_Params->intContext.extBufOffset > p_Params->bufMargins.startMargins))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("intContext.size is larger than start margins"));
 
-            if(p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK)
+            if (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
 
 #ifdef FM_NO_BACKUP_POOLS
     if ((p_FmPort->fmRevInfo.majorRev != 4) && (p_FmPort->fmRevInfo.majorRev < 6))
-        if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+        if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("BackupBmPools"));
 #endif /* FM_NO_BACKUP_POOLS */
         }
@@ -97,19 +97,19 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         else
         {
-            if(p_Params->deqSubPortal >= FM_MAX_NUM_OF_SUB_PORTALS)
+            if (p_Params->deqSubPortal >= FM_MAX_NUM_OF_SUB_PORTALS)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" deqSubPortal has to be in the range of 0 - %d", FM_MAX_NUM_OF_SUB_PORTALS));
 
             /* to protect HW internal-context from overwrite */
-            if((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
+            if ((p_Params->intContext.size) && (p_Params->intContext.intContextOffset < MIN_TX_INT_OFFSET))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("non-Rx intContext.intContextOffset can't be smaller than %d", MIN_TX_INT_OFFSET));
 
-            if((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_TX) || (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
                     /* in O/H DEFAULT_notSupported indicates that it is not suppported and should not be checked */
                     || (p_FmPort->fifoDeqPipelineDepth != DEFAULT_notSupported))
             {
                 /* Check that not larger than 8 */
-                if((!p_FmPort->fifoDeqPipelineDepth) ||( p_FmPort->fifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
+                if ((!p_FmPort->fifoDeqPipelineDepth) ||( p_FmPort->fifoDeqPipelineDepth > MAX_FIFO_PIPELINE_DEPTH))
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth can't be larger than %d", MAX_FIFO_PIPELINE_DEPTH));
             }
         }
@@ -117,13 +117,13 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /*   Rx Or Offline Parsing              */
         /****************************************/
-        if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         {
 
-            if(!p_Params->dfltFqid)
+            if (!p_Params->dfltFqid)
                  RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
 #if defined(FM_CAPWAP_SUPPORT) && defined(FM_LOCKUP_ALIGNMENT_ERRATA_FMAN_SW004)
-            if(p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace % 16)
+            if (p_FmPort->p_FmPortDriverParam->bufferPrefixContent.manipExtraSpace % 16)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufferPrefixContent.manipExtraSpace has to be devidable by 16"));
 #endif /* defined(FM_CAPWAP_SUPPORT) && ... */
         }
@@ -133,46 +133,46 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         /****************************************/
         /* common BMI registers values */
         /* Check that Queue Id is not larger than 2^24, and is not 0 */
-        if((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
+        if ((p_Params->errFqid & ~0x00FFFFFF) || !p_Params->errFqid)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("errFqid must be between 1 and 2^24-1"));
-        if(p_Params->dfltFqid & ~0x00FFFFFF)
+        if (p_Params->dfltFqid & ~0x00FFFFFF)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dfltFqid must be between 1 and 2^24-1"));
     }
 
     /****************************************/
     /*   Rx only                            */
     /****************************************/
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* Check that divisible by 256 and not larger than 256 */
-        if(p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
+        if (p_Params->rxFifoPriElevationLevel % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if(!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
+        if (!p_Params->rxFifoPriElevationLevel || (p_Params->rxFifoPriElevationLevel > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoPriElevationLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-        if(p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
+        if (p_Params->rxFifoThreshold % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be divisible by %d", BMI_FIFO_UNITS));
-        if(!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
+        if (!p_Params->rxFifoThreshold ||(p_Params->rxFifoThreshold > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("rxFifoThreshold has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
 
         /* Check that not larger than 16 */
-        if(p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
+        if (p_Params->cutBytesFromEnd > FRAME_END_DATA_SIZE)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
 
-        if(FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
+        if (FmSpCheckBufMargins(&p_Params->bufMargins)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
         /* extra FIFO size (allowed only to Rx ports) */
-        if(p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
+        if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.extra % BMI_FIFO_UNITS))
              RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.extra has to be divisible by %d", BMI_FIFO_UNITS));
 
-        if(p_Params->bufPoolDepletion.poolsGrpModeEnable &&
+        if (p_Params->bufPoolDepletion.poolsGrpModeEnable &&
            !p_Params->bufPoolDepletion.numOfPools)
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("bufPoolDepletion.numOfPoolsToConsider can not be 0 when poolsGrpModeEnable=TRUE"));
 #ifdef FM_CSI_CFED_LIMIT
         if (p_FmPort->fmRevInfo.majorRev == 4)
         {
             /* Check that not larger than 16 */
-            if(p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
+            if (p_Params->cutBytesFromEnd + p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore + cutBytesFromEnd can't be larger than %d", FRAME_END_DATA_SIZE));
         }
 #endif /* FM_CSI_CFED_LIMIT */
@@ -193,17 +193,17 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         (p_FmPort->portType == e_FM_PORT_TYPE_TX_10G))
     {
         /* Check that divisible by 256 and not larger than 256 */
-        if(p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
+        if (p_Params->txFifoMinFillLevel % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if(p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
+        if (p_Params->txFifoMinFillLevel > (BMI_MAX_FIFO_SIZE - 256))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoMinFillLevel has to be in the range of 0 - %d", BMI_MAX_FIFO_SIZE));
-        if(p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
+        if (p_Params->txFifoLowComfLevel % BMI_FIFO_UNITS)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be divisible by %d", BMI_FIFO_UNITS));
-        if(!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
+        if (!p_Params->txFifoLowComfLevel || (p_Params->txFifoLowComfLevel > BMI_MAX_FIFO_SIZE))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("txFifoLowComfLevel has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
 
-        if(p_FmPort->portType == e_FM_PORT_TYPE_TX)
-            if(p_FmPort->fifoDeqPipelineDepth > 2)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_TX)
+            if (p_FmPort->fifoDeqPipelineDepth > 2)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoDeqPipelineDepth for 1G can't be larger than 2"));
     }
     /****************************************/
@@ -230,12 +230,14 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
         if (p_Params->errorsToDiscard & unusedMask)
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("errorsToDiscard contains undefined bits"));
     }
+
     /****************************************/
     /*   Offline Ports                      */
     /****************************************/
 #ifdef FM_OP_OPEN_DMA_MIN_LIMIT
     if ((p_FmPort->fmRevInfo.majorRev >= 6) &&
         (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
+        p_Params->setNumOfOpenDmas &&
         (p_FmPort->openDmas.num < MIN_NUM_OF_OP_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For Offline port, openDmas.num can't be smaller than %d", MIN_NUM_OF_OP_DMAS));
 #endif /* FM_OP_OPEN_DMA_MIN_LIMIT */
@@ -266,29 +268,29 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
     /****************************************/
 
     /* Check that not larger than 16 */
-    if((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
+    if ((p_Params->cheksumLastBytesIgnore > FRAME_END_DATA_SIZE) && ((p_Params->cheksumLastBytesIgnore != DEFAULT_notSupported)))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("cheksumLastBytesIgnore can't be larger than %d", FRAME_END_DATA_SIZE));
 
-    if(FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
+    if (FmSpCheckIntContextParams(&p_Params->intContext)!= E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
 
     /* common BMI registers values */
-    if(p_Params->setNumOfTasks && ((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS)))
+    if (p_Params->setNumOfTasks && ((!p_FmPort->tasks.num) || (p_FmPort->tasks.num > MAX_NUM_OF_TASKS)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.num can't be larger than %d", MAX_NUM_OF_TASKS));
-    if(p_Params->setNumOfTasks && (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS))
+    if (p_Params->setNumOfTasks && (p_FmPort->tasks.extra > MAX_NUM_OF_EXTRA_TASKS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("tasks.extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
-    if(p_Params->setNumOfOpenDmas && ((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS)))
+    if (p_Params->setNumOfOpenDmas && ((!p_FmPort->openDmas.num) || (p_FmPort->openDmas.num > MAX_NUM_OF_DMAS)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.num can't be larger than %d", MAX_NUM_OF_DMAS));
-    if(p_Params->setNumOfOpenDmas && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
+    if (p_Params->setNumOfOpenDmas && (p_FmPort->openDmas.extra > MAX_NUM_OF_EXTRA_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas.extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
-    if(p_Params->setSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
+    if (p_Params->setSizeOfFifo && (!p_FmPort->fifoBufs.num || (p_FmPort->fifoBufs.num > BMI_MAX_FIFO_SIZE)))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be in the range of 256 - %d", BMI_MAX_FIFO_SIZE));
-    if(p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
+    if (p_Params->setSizeOfFifo && (p_FmPort->fifoBufs.num % BMI_FIFO_UNITS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fifoBufs.num has to be divisible by %d", BMI_FIFO_UNITS));
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
     if (p_FmPort->fmRevInfo.majorRev == 4)
-        if(p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
+        if (p_FmPort->p_FmPortDriverParam->deqPrefetchOption != DEFAULT_notSupported)
             /* this is an indication that user called config for this mode which is not supported in this integration */
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("deqPrefetchOption"));
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
@@ -338,9 +340,9 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
              !p_FmPort->imEn)
     {
 #ifdef FM_FIFO_ALLOCATION_ALG
-        if(p_FmPort->fmRevInfo.majorRev == 4)
+        if (p_FmPort->fmRevInfo.majorRev == 4)
         {
-            if(p_FmPort->rxPoolsParams.numOfPools == 1)
+            if (p_FmPort->rxPoolsParams.numOfPools == 1)
                 minFifoSizeRequired = 8*BMI_FIFO_UNITS;
             else
                 minFifoSizeRequired = (uint32_t)(DIV_CEIL(p_FmPort->rxPoolsParams.secondLargestBufSize, BMI_FIFO_UNITS) +
@@ -388,7 +390,7 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 
 static void FmPortDriverParamFree(t_FmPort *p_FmPort)
 {
-    if(p_FmPort->p_FmPortDriverParam)
+    if (p_FmPort->p_FmPortDriverParam)
     {
         XX_Free(p_FmPort->p_FmPortDriverParam);
         p_FmPort->p_FmPortDriverParam = NULL;
@@ -412,15 +414,15 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     memset(&sizesArray, 0, sizeof(uint16_t) * BM_MAX_NUM_OF_POOLS);
     memcpy(&p_FmPort->extBufPools, p_ExtBufPools, sizeof(t_FmExtPools));
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi;
             p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rmpd;
             rxPort = TRUE;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_ExtBufRegs = p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi;
             p_BufPoolDepletionReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ompd;
             rxPort = FALSE;
@@ -432,15 +434,15 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     FmSpSetBufPoolsInAscOrderOfBufSizes(p_ExtBufPools, orderedArray, sizesArray);
 
     /* build the register value */
-    for(i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
+    for (i=0;i<p_ExtBufPools->numOfPoolsUsed;i++)
     {
         tmpReg = BMI_EXT_BUF_POOL_VALID | BMI_EXT_BUF_POOL_EN_COUNTER;
         tmpReg |= ((uint32_t)orderedArray[i] << BMI_EXT_BUF_POOL_ID_SHIFT);
         tmpReg |= sizesArray[orderedArray[i]];
         /* functionality available only for some deriviatives (limited by config) */
-        if(p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
-            for(j=0;j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;j++)
-                if(orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
+        if (p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+            for (j=0;j<p_FmPort->p_FmPortDriverParam->p_BackupBmPools->numOfBackupPools;j++)
+                if (orderedArray[i] == p_FmPort->p_FmPortDriverParam->p_BackupBmPools->poolIds[j])
                 {
                     tmpReg |= BMI_EXT_BUF_POOL_BACKUP;
                     break;
@@ -468,11 +470,11 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     {
         /* calculate vector for number of pools depletion */
         vector = 0;
-        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
-            if(p_BufPoolDepletion->poolsToConsider[i])
+            if (p_BufPoolDepletion->poolsToConsider[i])
             {
-                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                for (j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
                 {
                     if (i == orderedArray[j])
                     {
@@ -491,11 +493,11 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
     {
         /* calculate vector for number of pools depletion */
         vector = 0;
-        for(i=0;i<BM_MAX_NUM_OF_POOLS;i++)
+        for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
-            if(p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
+            if (p_BufPoolDepletion->poolsToConsiderForSingleMode[i])
             {
-                for(j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
+                for (j=0;j<p_ExtBufPools->numOfPoolsUsed;j++)
                 {
                     if (i == orderedArray[j])
                      {
@@ -533,8 +535,9 @@ static t_Error SetExtBufferPools(t_FmPort *p_FmPort)
 
 static t_Error ClearPerfCnts(t_FmPort *p_FmPort)
 {
+    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        FM_PORT_ModifyCounter(p_FmPort, e_FM_PORT_COUNTERS_QUEUE_UTIL, 0);
     FM_PORT_ModifyCounter(p_FmPort, e_FM_PORT_COUNTERS_TASK_UTIL, 0);
-    FM_PORT_ModifyCounter(p_FmPort, e_FM_PORT_COUNTERS_QUEUE_UTIL, 0);
     FM_PORT_ModifyCounter(p_FmPort, e_FM_PORT_COUNTERS_DMA_UTIL, 0);
     FM_PORT_ModifyCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL, 0);
     return E_OK;
@@ -659,7 +662,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     if (!p_FmPort->imEn)
     {
         tmpReg |= BMI_CMD_ATTR_ORDER;
-        if(p_Params->syncReq)
+        if (p_Params->syncReq)
             tmpReg |= BMI_CMD_ATTR_SYNC;
         tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
     }
@@ -680,7 +683,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
     performanceContersParams.queueCompVal   = 1;
     performanceContersParams.dmaCompVal     =(uint8_t) p_FmPort->openDmas.num;
     performanceContersParams.fifoCompVal    = p_FmPort->fifoBufs.num;
-    if((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams)) != E_OK)
+    if ((err = FM_PORT_SetPerformanceCountersParams(p_FmPort, &performanceContersParams)) != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     WRITE_UINT32(p_Regs->fmbm_rpc, BMI_COUNTERS_EN);
@@ -772,14 +775,14 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
         if (!p_Params->dfltFqid && p_Params->dontReleaseBuf)
         {
             /* override fmbm_tcfqid 0 with a false non-0 value. This will force FM to
-             * act acording to tfene. Otherwise, if fmbm_tcfqid is 0 the FM will release
+             * act according to tfene. Otherwise, if fmbm_tcfqid is 0 the FM will release
              * buffers to BM regardless of fmbm_tfene
              */
             WRITE_UINT32(p_Regs->fmbm_tcfqid, 0xFFFFFF);
             WRITE_UINT32(p_Regs->fmbm_tfene, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
 #if (DPAA_VERSION >= 11)
-        WRITE_UINT32(p_Regs->fmbm_tfne,
-                     (GET_UINT32(p_Regs->fmbm_tfne) & ~BMI_EBD_EN));
+            WRITE_UINT32(p_Regs->fmbm_tfne,
+                         (GET_UINT32(p_Regs->fmbm_tfne) & ~BMI_EBD_EN));
 #endif /* (DPAA_VERSION >= 11) */
         }
     }
@@ -793,7 +796,6 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
         tmpReg |= BMI_CMD_ATTR_ORDER;
         tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
     }
-
     WRITE_UINT32(p_Regs->fmbm_tfca, tmpReg);
 
     /* default queues */
@@ -815,6 +817,7 @@ static t_Error BmiTxPortInit(t_FmPort *p_FmPort)
 
     WRITE_UINT32(p_Regs->fmbm_tpc, BMI_COUNTERS_EN);
 
+
     return E_OK;
 }
 
@@ -835,7 +838,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     tmpReg |= (uint32_t)p_Params->dmaIntContextCacheAttr << BMI_DMA_ATTR_IC_CACHE_SHIFT;
     tmpReg |= (uint32_t)p_Params->dmaHeaderCacheAttr << BMI_DMA_ATTR_HDR_CACHE_SHIFT;
     tmpReg |= (uint32_t)p_Params->dmaScatterGatherCacheAttr << BMI_DMA_ATTR_SG_CACHE_SHIFT;
-    if(p_Params->dmaWriteOptimize)
+    if (p_Params->dmaWriteOptimize)
         tmpReg |= BMI_DMA_ATTR_WRITE_OPTIMIZE;
 
     WRITE_UINT32(p_Regs->fmbm_oda, tmpReg);
@@ -862,7 +865,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
     else
         tmpReg = BMI_CMD_ATTR_ORDER | BMI_CMD_MR_DEAS | BMI_CMD_MR_MA;
 
-    if(p_Params->syncReq)
+    if (p_Params->syncReq)
         tmpReg |= BMI_CMD_ATTR_SYNC;
     tmpReg |= ((uint32_t)p_Params->color << BMI_CMD_ATTR_COLOR_SHIFT);
     WRITE_UINT32(p_Regs->fmbm_ofca, tmpReg);
@@ -874,7 +877,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         tmpReg = 0;
     WRITE_UINT32(p_Regs->fmbm_ocfg, tmpReg);
 
-    if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
     {
         WRITE_UINT32(p_Regs->fmbm_ofsdm, p_Params->errorsToDiscard);
 
@@ -892,7 +895,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         {
             /* define external buffer pools */
             t_Error err = SetExtBufferPools(p_FmPort);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
         }
 #endif /* FM_NO_OP_OBSERVED_POOLS */
@@ -933,7 +936,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
 #endif /* FM_DEQ_PIPELINE_PARAMS_FOR_OP */
 
 #ifdef FM_FRAME_END_PARAMS_FOR_OP
-    if(p_FmPort->fmRevInfo.majorRev >= 6)
+    if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
         /* frame end parameters */
         tmpReg = 0;
@@ -954,7 +957,7 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
     p_Params = p_FmPort->p_FmPortDriverParam;
 
     /* check that port is not busy */
-    if(((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    if (((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
         (p_FmPort->portType != e_FM_PORT_TYPE_RX)) &&
        (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN))
          RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port is already enabled"));
@@ -963,10 +966,10 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
     WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc, QMI_PORT_CFG_EN_COUNTERS);
 
     /* The following is  done for non-Rx ports only */
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) &&
         (p_FmPort->portType != e_FM_PORT_TYPE_RX))
     {
-        if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
+        if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) ||
                         (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         {
             /* define dequeue NIA */
@@ -983,18 +986,18 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
 
         /* configure dequeue */
         tmpReg = 0;
-        if(p_Params->deqHighPriority)
+        if (p_Params->deqHighPriority)
             tmpReg |= QMI_DEQ_CFG_PRI;
 
-        switch(p_Params->deqType)
+        switch (p_Params->deqType)
         {
-            case(e_FM_PORT_DEQ_TYPE1):
+            case (e_FM_PORT_DEQ_TYPE1):
                 tmpReg |= QMI_DEQ_CFG_TYPE1;
                 break;
-            case(e_FM_PORT_DEQ_TYPE2):
+            case (e_FM_PORT_DEQ_TYPE2):
                 tmpReg |= QMI_DEQ_CFG_TYPE2;
                 break;
-            case(e_FM_PORT_DEQ_TYPE3):
+            case (e_FM_PORT_DEQ_TYPE3):
                 tmpReg |= QMI_DEQ_CFG_TYPE3;
                 break;
             default:
@@ -1002,17 +1005,17 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
         }
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-        if(p_FmPort->fmRevInfo.majorRev != 4)
+        if (p_FmPort->fmRevInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-        switch(p_Params->deqPrefetchOption)
+        switch (p_Params->deqPrefetchOption)
         {
-            case(e_FM_PORT_DEQ_NO_PREFETCH):
+            case (e_FM_PORT_DEQ_NO_PREFETCH):
                 /* Do nothing - QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_1_FRAME = 0 */
                 break;
-            case(e_FM_PORT_DEQ_PARTIAL_PREFETCH):
+            case (e_FM_PORT_DEQ_PARTIAL_PREFETCH):
                 tmpReg |= QMI_DEQ_CFG_PREFETCH_WAITING_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
                 break;
-            case(e_FM_PORT_DEQ_FULL_PREFETCH):
+            case (e_FM_PORT_DEQ_FULL_PREFETCH):
                 tmpReg |= QMI_DEQ_CFG_PREFETCH_NO_TNUM | QMI_DEQ_CFG_PREFETCH_3_FRAMES;
                 break;
             default:
@@ -1036,26 +1039,26 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     t_FmPortRxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs;
 
      /* check that counters are enabled */
-    switch(counter)
-    {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+    switch (counter)
+    {
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             /* performance counters - may be read when disabled */
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
-            if(!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+            if (!(GET_UINT32(p_BmiRegs->fmbm_rstc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
          default:
@@ -1063,51 +1066,51 @@ static t_Error BmiRxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     }
 
     /* Set counter */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_CYCLE):
             *p_Ptr = &p_BmiRegs->fmbm_rccn;
             break;
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rtuc;
             break;
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rrquc;
             break;
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rduc;
             break;
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_rfuc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
+        case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             *p_Ptr = &p_BmiRegs->fmbm_rpac;
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rfrc;
             break;
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rfcd;
             break;
-        case(e_FM_PORT_COUNTERS_RX_BAD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rfbc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rlfc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
             *p_Ptr = &p_BmiRegs->fmbm_rffc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
             *p_Ptr = &p_BmiRegs->fmbm_rfldec;
             break;
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_Ptr = &p_BmiRegs->fmbm_rodc;
             break;
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_rbdc;
             break;
-        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             *p_Ptr = &p_BmiRegs->fmbm_rpec;
             break;
         default:
@@ -1122,21 +1125,21 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     t_FmPortTxBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs;
 
      /* check that counters are enabled */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
             /* performance counters - may be read when disabled */
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            if(!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if (!(GET_UINT32(p_BmiRegs->fmbm_tstc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -1144,36 +1147,36 @@ static t_Error BmiTxPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     }
 
     /* Set counter */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_CYCLE):
            *p_Ptr = &p_BmiRegs->fmbm_tccn;
             break;
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_ttuc;
             break;
-        case(e_FM_PORT_COUNTERS_QUEUE_UTIL):
+        case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
             *p_Ptr = &p_BmiRegs->fmbm_ttcquc;
             break;
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_tduc;
             break;
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_tfuc;
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_tfrc;
             break;
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_tfdc;
             break;
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
            *p_Ptr = &p_BmiRegs->fmbm_tfledc;
             break;
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
             *p_Ptr = &p_BmiRegs->fmbm_tfufdc;
             break;
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_tbdc;
             break;
         default:
@@ -1188,78 +1191,78 @@ static t_Error BmiOhPortCheckAndGetCounterPtr(t_FmPort *p_FmPort, e_FmPortCounte
     t_FmPortOhBmiRegs   *p_BmiRegs = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs;
 
     /* check that counters are enabled */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
             /* performance counters - may be read when disabled */
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
-            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+        case (e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
+            if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME): /* only valid for offline parsing */
             /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
             ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
-            if(!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
+            if (!(GET_UINT32(p_BmiRegs->fmbm_ostc) & BMI_COUNTERS_EN))
                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for O/H ports"));
+            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter(%d) is not available for O/H ports", counter));
     }
 
     /* Set counter */
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_CYCLE):
+        case (e_FM_PORT_COUNTERS_CYCLE):
            *p_Ptr = &p_BmiRegs->fmbm_occn;
             break;
-        case(e_FM_PORT_COUNTERS_TASK_UTIL):
+        case (e_FM_PORT_COUNTERS_TASK_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_otuc;
             break;
-        case(e_FM_PORT_COUNTERS_DMA_UTIL):
+        case (e_FM_PORT_COUNTERS_DMA_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_oduc;
             break;
-        case(e_FM_PORT_COUNTERS_FIFO_UTIL):
+        case (e_FM_PORT_COUNTERS_FIFO_UTIL):
            *p_Ptr = &p_BmiRegs->fmbm_ofuc;
             break;
-        case(e_FM_PORT_COUNTERS_FRAME):
+        case (e_FM_PORT_COUNTERS_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_ofrc;
             break;
-        case(e_FM_PORT_COUNTERS_DISCARD_FRAME):
+        case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_ofdc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
+        case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
            *p_Ptr = &p_BmiRegs->fmbm_offc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
+        case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
           *p_Ptr = &p_BmiRegs->fmbm_ofldec;
             break;
-        case(e_FM_PORT_COUNTERS_WRED_DISCARD):
+        case (e_FM_PORT_COUNTERS_WRED_DISCARD):
            *p_Ptr = &p_BmiRegs->fmbm_ofwdc;
             break;
-        case(e_FM_PORT_COUNTERS_LENGTH_ERR):
+        case (e_FM_PORT_COUNTERS_LENGTH_ERR):
            *p_Ptr = &p_BmiRegs->fmbm_ofledc;
             break;
-        case(e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
+        case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
             *p_Ptr = &p_BmiRegs->fmbm_ofufdc;
             break;
-        case(e_FM_PORT_COUNTERS_DEALLOC_BUF):
+        case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_Ptr = &p_BmiRegs->fmbm_obdc;
             break;
-        case(e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
+        case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_Ptr = &p_BmiRegs->fmbm_oodc;
             break;
-        case(e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
+        case (e_FM_PORT_COUNTERS_PREPARE_TO_ENQUEUE_COUNTER):
             *p_Ptr = &p_BmiRegs->fmbm_opec;
             break;
         default:
@@ -1275,46 +1278,46 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     u_FmPcdHdrPrsOpts           *p_prsOpts;
     uint32_t                    tmpReg = *p_SoftSeqAttachReg, tmpPrsOffset;
 
-    if(IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
+    if (IS_PRIVATE_HEADER(p_HdrParams->hdr) || IS_SPECIAL_HEADER(p_HdrParams->hdr))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("No additional parameters for private or special headers."));
 
-    if(p_HdrParams->errDisable)
+    if (p_HdrParams->errDisable)
         tmpReg |= PRS_HDR_ERROR_DIS;
 
     /* Set parser options */
-    if(p_HdrParams->usePrsOpts)
+    if (p_HdrParams->usePrsOpts)
     {
         p_prsOpts = &p_HdrParams->prsOpts;
-        switch(p_HdrParams->hdr)
+        switch (p_HdrParams->hdr)
         {
-            case(HEADER_TYPE_MPLS):
-                if(p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
+            case (HEADER_TYPE_MPLS):
+                if (p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
                     tmpReg |= PRS_HDR_MPLS_LBL_INTER_EN;
                 GET_PRS_HDR_NUM(hdrNum, p_prsOpts->mplsPrsOptions.nextParse);
-                if(hdrNum == ILLEGAL_HDR_NUM)
+                if (hdrNum == ILLEGAL_HDR_NUM)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
                 GET_PRS_HDR_NUM(Ipv4HdrNum, HEADER_TYPE_IPv4);
-                if(hdrNum < Ipv4HdrNum)
+                if (hdrNum < Ipv4HdrNum)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                         ("Header must be equal or higher than IPv4"));
                 tmpReg |= ((uint32_t)hdrNum * PRS_HDR_ENTRY_SIZE) << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
                 break;
-            case(HEADER_TYPE_PPPoE):
+            case (HEADER_TYPE_PPPoE):
                 if (p_prsOpts->pppoePrsOptions.enableMTUCheck)
                     tmpReg |= PRS_HDR_PPPOE_MTU_CHECK_EN;
                 break;
-            case(HEADER_TYPE_IPv6):
+            case (HEADER_TYPE_IPv6):
                 if (p_prsOpts->ipv6PrsOptions.routingHdrEnable)
                     tmpReg |= PRS_HDR_IPV6_ROUTE_HDR_EN;
                 break;
-            case(HEADER_TYPE_TCP):
+            case (HEADER_TYPE_TCP):
                 if (p_prsOpts->tcpPrsOptions.padIgnoreChecksum)
                    tmpReg |= PRS_HDR_TCP_PAD_REMOVAL;
                 else
                    tmpReg &= ~PRS_HDR_TCP_PAD_REMOVAL;
                break;
-            case(HEADER_TYPE_UDP):
-                if(p_prsOpts->udpPrsOptions.padIgnoreChecksum)
+            case (HEADER_TYPE_UDP):
+                if (p_prsOpts->udpPrsOptions.padIgnoreChecksum)
                    tmpReg |= PRS_HDR_UDP_PAD_REMOVAL;
                 else
                    tmpReg &= ~PRS_HDR_UDP_PAD_REMOVAL;
@@ -1325,10 +1328,10 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort, t_FmPcdPrsAdditionalHdrPa
     }
 
     /* set software parsing (address is devided in 2 since parser uses 2 byte access. */
-    if(p_HdrParams->swPrsEnable)
+    if (p_HdrParams->swPrsEnable)
     {
         tmpPrsOffset = FmPcdGetSwPrsOffset(p_FmPort->h_FmPcd, p_HdrParams->hdr, p_HdrParams->indexPerHdr);
-        if(tmpPrsOffset == ILLEGAL_BASE)
+        if (tmpPrsOffset == ILLEGAL_BASE)
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
         tmpReg |= (PRS_HDR_SW_PRS_EN | tmpPrsOffset);
     }
@@ -1352,7 +1355,7 @@ static uint32_t GetPortSchemeBindParams(t_Handle h_FmPort, t_FmPcdKgInterModuleB
     {
         while (tmp)
         {
-            if(tmp & walking1Mask)
+            if (tmp & walking1Mask)
             {
                 p_SchemeBind->schemesIds[p_SchemeBind->numOfSchemes] = idx;
                 p_SchemeBind->numOfSchemes++;
@@ -1400,58 +1403,58 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     p_FmPort->pcdEngines = 0;
 
     /* initialize p_FmPort->pcdEngines field in port's structure */
-    switch(p_PcdParams->pcdSupport)
+    switch (p_PcdParams->pcdSupport)
     {
-        case(e_FM_PORT_PCD_SUPPORT_NONE):
+        case (e_FM_PORT_PCD_SUPPORT_NONE):
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("No PCD configuration required if e_FM_PORT_PCD_SUPPORT_NONE selected"));
-        case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
+        case (e_FM_PORT_PCD_SUPPORT_PLCR_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_PRS;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
             break;
 #ifdef FM_CAPWAP_SUPPORT
-        case(e_FM_PORT_PCD_SUPPORT_CC_ONLY):
+        case (e_FM_PORT_PCD_SUPPORT_CC_ONLY):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
+        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             break;
-        case(e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
+        case (e_FM_PORT_PCD_SUPPORT_CC_AND_KG_AND_PLCR):
             p_FmPort->pcdEngines |= FM_PCD_CC;
             p_FmPort->pcdEngines |= FM_PCD_KG;
             p_FmPort->pcdEngines |= FM_PCD_PLCR;
@@ -1473,17 +1476,17 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PCD initialization structure is not consistent with pcdSupport"));
 
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             p_BmiInitPrsResult = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[0];
             p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiPrsNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
@@ -1495,7 +1498,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
     }
 
     /* set PCD port parameter */
-    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         err = FmPcdCcBindTree(p_FmPort->h_FmPcd,
                               p_PcdParams,
@@ -1509,9 +1512,9 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         p_FmPort->ccTreeId = p_PcdParams->p_CcParams->h_CcTree;
     }
 
-    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    if (p_FmPort->pcdEngines & FM_PCD_KG)
     {
-        if(p_PcdParams->p_KgParams->numOfSchemes == 0)
+        if (p_PcdParams->p_KgParams->numOfSchemes == 0)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("For ports using Keygen, at least one scheme must be bound. "));
 
         err = FmPcdKgSetOrBindToClsPlanGrp(p_FmPort->h_FmPcd,
@@ -1531,7 +1534,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         schemeBind.useClsPlan = p_FmPort->useClsPlan;
 
         /* for each scheme */
-        for(i=0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+        for (i=0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
         {
             ASSERT_COND(p_PcdParams->p_KgParams->h_Schemes[i]);
             physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_Schemes[i]);
@@ -1541,7 +1544,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 #if (DPAA_VERSION >= 11)
             /*because of the state that VSPE is defined per port - all PCD path should be according to this requirement
              if !VSPE - in port, for relevant scheme VSPE can not be set*/
-            if(!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
+            if (!p_FmPort->vspe && FmPcdKgGetVspe((p_PcdParams->p_KgParams->h_Schemes[i])))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSPE is not at port level"));
 #endif /* (DPAA_VERSION >= 11) */
         }
@@ -1562,12 +1565,12 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         ((p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PLCR_ONLY) ||
          (p_PcdParams->pcdSupport == e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR)))
     {
-        if(!p_PcdParams->p_PlcrParams->h_Profile)
+        if (!p_PcdParams->p_PlcrParams->h_Profile)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Profile should be initialized"));
 
         absoluteProfileId = (uint16_t)FmPcdPlcrProfileGetAbsoluteId(p_PcdParams->p_PlcrParams->h_Profile);
 
-        if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+        if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
             RETURN_ERROR(MINOR, E_INVALID_STATE, ("Private port profile not valid."));
 
         tmpReg = (uint32_t)(absoluteProfileId | NIA_PLCR_ABSOLUTE);
@@ -1603,34 +1606,34 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         p_FmPort->savedBmiNia |= (uint32_t)(NIA_ENG_PRS | (uint32_t)(hdrNum));
         /* set after parser NIA */
         tmpReg = 0;
-        switch(p_PcdParams->pcdSupport)
+        switch (p_PcdParams->pcdSupport)
         {
-            case(e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_ONLY):
                 WRITE_UINT32(*p_BmiPrsNia, GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd));
                 break;
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_CC_AND_PLCR):
                 tmpReg = NIA_KG_CC_EN;
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
-                if(p_PcdParams->p_KgParams->directScheme)
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_KG_AND_PLCR):
+                if (p_PcdParams->p_KgParams->directScheme)
                 {
                     physicalSchemeId = FmPcdKgGetSchemeId(p_PcdParams->p_KgParams->h_DirectScheme);
                     /* check that this scheme was bound to this port */
-                    for(i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
-                        if(p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
+                    for (i=0 ; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                        if (p_PcdParams->p_KgParams->h_DirectScheme == p_PcdParams->p_KgParams->h_Schemes[i])
                             break;
-                    if(i == p_PcdParams->p_KgParams->numOfSchemes)
+                    if (i == p_PcdParams->p_KgParams->numOfSchemes)
                         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Direct scheme is not one of the port selected schemes."));
                     tmpReg |= (uint32_t)(NIA_KG_DIRECT | physicalSchemeId);
                 }
                 WRITE_UINT32(*p_BmiPrsNia, NIA_ENG_KG | tmpReg);
                 break;
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_CC_AND_PLCR):
                 WRITE_UINT32(*p_BmiPrsNia, (uint32_t)(NIA_ENG_FM_CTL | NIA_FM_CTL_AC_CC));
                 break;
-            case(e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
+            case (e_FM_PORT_PCD_SUPPORT_PRS_AND_PLCR):
                 break;
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid PCD support"));
@@ -1645,56 +1648,56 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         /* stop before configuring */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
         /* wait for parser to be in idle state */
-        while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
 
         /* set soft seq attachment register */
         memset(tmpHxs, 0, FM_PCD_PRS_NUM_OF_HDRS*sizeof(uint32_t));
 
         /* set protocol options */
-        for(i=0;p_FmPort->optArray[i];i++)
-            switch(p_FmPort->optArray[i])
+        for (i=0;p_FmPort->optArray[i];i++)
+            switch (p_FmPort->optArray[i])
             {
-                case(ETH_BROADCAST):
+                case (ETH_BROADCAST):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_BC_SHIFT;
                     break;
-                case(ETH_MULTICAST):
+                case (ETH_MULTICAST):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_ETH_MC_SHIFT;
                     break;
-                case(VLAN_STACKED):
+                case (VLAN_STACKED):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
                     tmpHxs[hdrNum] |= (i+1)<< PRS_HDR_VLAN_STACKED_SHIFT;
                     break;
-                case(MPLS_STACKED):
+                case (MPLS_STACKED):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_MPLS_STACKED_SHIFT;
                     break;
-                case(IPV4_BROADCAST_1):
+                case (IPV4_BROADCAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_BC_SHIFT;
                     break;
-                case(IPV4_MULTICAST_1):
+                case (IPV4_MULTICAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_1_MC_SHIFT;
                     break;
-                case(IPV4_UNICAST_2):
+                case (IPV4_UNICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_UC_SHIFT;
                     break;
-                case(IPV4_MULTICAST_BROADCAST_2):
+                case (IPV4_MULTICAST_BROADCAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
                     break;
-                case(IPV6_MULTICAST_1):
+                case (IPV6_MULTICAST_1):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_1_MC_SHIFT;
                     break;
-                case(IPV6_UNICAST_2):
+                case (IPV6_UNICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_UC_SHIFT;
                     break;
-                case(IPV6_MULTICAST_2):
+                case (IPV6_MULTICAST_2):
                     GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
                     tmpHxs[hdrNum] |= (i+1) << PRS_HDR_IPV6_2_MC_SHIFT;
                     break;
@@ -1772,12 +1775,12 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
 
         /* set tpid. */
         tmpReg = PRS_TPID_DFLT;
-        if(p_PcdParams->p_PrsParams->setVlanTpid1)
+        if (p_PcdParams->p_PrsParams->setVlanTpid1)
         {
             tmpReg &= PRS_TPID2_MASK;
             tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid1 << PRS_PCTPID_SHIFT;
         }
-        if(p_PcdParams->p_PrsParams->setVlanTpid2)
+        if (p_PcdParams->p_PrsParams->setVlanTpid2)
         {
             tmpReg &= PRS_TPID1_MASK;
             tmpReg |= (uint32_t)p_PcdParams->p_PrsParams->vlanTpid2;
@@ -1832,18 +1835,18 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
-    if(!p_FmPort->pcdEngines)
+    if (!p_FmPort->pcdEngines)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("called for non PCD port"));
 
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             break;
@@ -1851,23 +1854,23 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if((GET_UINT32(*p_BmiNia) & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+    if ((GET_UINT32(*p_BmiNia) & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("port has to be detached previousely"));
 
     /* "cut" PCD out of the port's flow - go to BMI */
     /* WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)); */
 
-    if(p_FmPort->pcdEngines | FM_PCD_PRS)
+    if (p_FmPort->pcdEngines | FM_PCD_PRS)
     {
         WRITE_UINT32(*p_BmiPrsStartOffset, 0);
 
         /* stop parser */
         WRITE_UINT32(p_FmPort->p_FmPortPrsRegs->pcac, PRS_CAC_STOP);
         /* wait for parser to be in idle state */
-        while(GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
+        while (GET_UINT32(p_FmPort->p_FmPortPrsRegs->pcac) & PRS_CAC_ACTIVE) ;
     }
 
-    if(p_FmPort->pcdEngines & FM_PCD_KG)
+    if (p_FmPort->pcdEngines & FM_PCD_KG)
     {
         t_FmPcdKgInterModuleBindPortToSchemes   schemeBind;
 
@@ -1875,20 +1878,20 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
         p_FmPort->schemesPerPortVector = GetPortSchemeBindParams(p_FmPort, &schemeBind);
 
         err = FmPcdKgUnbindPortToSchemes(p_FmPort->h_FmPcd, &schemeBind);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
 
         err = FmPcdKgDeleteOrUnbindPortToClsPlanGrp(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, p_FmPort->clsPlanGrpId);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
         p_FmPort->useClsPlan = FALSE;
     }
 
-    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         /* unbind - we need to get the treeId too */
         err = FmPcdCcUnbindTree(p_FmPort->h_FmPcd,  p_FmPort->ccTreeId);
-        if(err)
+        if (err)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
@@ -1903,25 +1906,22 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
 
     ASSERT_COND(p_FmPort);
 
-/*TODO - to take care about the chnges that were made in the port because of the previously assigned tree.
-pndn, pnen ... maybe were changed because of the Tree requirement*/
-
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
     }
 
-    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
+    if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 1, p_FmPort->orFmanCtrl)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     /* check that current NIA is BMI to BMI */
@@ -1931,29 +1931,29 @@ pndn, pnen ... maybe were changed because of the Tree requirement*/
 
     WRITE_UINT32(*p_BmiNia, p_FmPort->savedBmiNia);
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, p_FmPort->savedQmiPnen);
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
         WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, p_FmPort->savedNonRxQmiRegsPndn);
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, p_FmPort->savedBmiFene);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, p_FmPort->savedBmiFene);
     }
-    if(p_FmPort->requiredAction & UPDATE_NIA_FPNE)
+    if (p_FmPort->requiredAction & UPDATE_NIA_FPNE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne, p_FmPort->savedBmiFpne);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne, p_FmPort->savedBmiFpne);
     }
-    if(p_FmPort->requiredAction & UPDATE_NIA_CMNE)
+    if (p_FmPort->requiredAction & UPDATE_NIA_CMNE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocmne, p_FmPort->savedBmiCmne);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcmne, p_FmPort->savedBmiCmne);
@@ -1969,13 +1969,13 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     ASSERT_COND(p_FmPort);
 
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             break;
         default:
@@ -1984,19 +1984,18 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
 
     WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
 
-    /* TODO - not atomic - it seems that port has to be disabled */
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNEN)
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNEN)
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_TX):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_TX_RELEASE);
                 break;
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_RX):
-            case(e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_RX):
+            case (e_FM_PORT_TYPE_RX_10G):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnen, NIA_ENG_BMI | NIA_BMI_AC_RELEASE);
                 break;
            default:
@@ -2004,16 +2003,16 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
         }
     }
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_PNDN)
+    if (p_FmPort->requiredAction & UPDATE_NIA_PNDN)
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_TX):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_TX);
                 break;
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn, NIA_ENG_BMI | NIA_BMI_AC_FETCH);
                 break;
             default:
@@ -2021,16 +2020,16 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
         }
     }
 
-    if(p_FmPort->requiredAction & UPDATE_NIA_FENE)
+    if (p_FmPort->requiredAction & UPDATE_NIA_FENE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
         else
             WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
     }
 
-    if(p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
-        if(FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
+    if (p_FmPort->requiredAction & UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY)
+        if (FmSetNumOfRiscsPerPort(p_FmPort->h_Fm, p_FmPort->hardwarePortId, 2, p_FmPort->orFmanCtrl)!= E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
 
     p_FmPort->requiredAction = 0;
@@ -2054,7 +2053,7 @@ void FmPortSetMacsecLcv(t_Handle h_FmPort)
     SANITY_CHECK_RETURN(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
     {
         REPORT_ERROR(MAJOR, E_INVALID_OPERATION, ("The routine is relevant for Rx ports only"));
         return;
@@ -2064,7 +2063,7 @@ void FmPortSetMacsecLcv(t_Handle h_FmPort)
     /* get LCV for MACSEC */
     if ((p_FmPort->h_FmPcd) && ((lcv = FmPcdGetMacsecLcv(p_FmPort->h_FmPcd, p_FmPort->netEnvId))!= 0))
     {
-        while(!(lcv & walking1Mask))
+        while (!(lcv & walking1Mask))
         {
             cnt++;
             walking1Mask >>= 1;
@@ -2130,7 +2129,7 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
     }
     else
     {
-        switch(gprFunc)
+        switch (gprFunc)
         {
             case (e_FM_PORT_GPR_MURAM_PAGE):
                 p_FmPort->p_MuramPage = FM_MURAM_AllocMem(p_FmPort->h_FmMuram,
@@ -2142,13 +2141,13 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
                 IOMemSet32(p_FmPort->p_MuramPage, 0, 256);
                 muramPageOffset = (uint32_t)(XX_VirtToPhys(p_FmPort->p_MuramPage) -
                                              p_FmPort->fmMuramPhysBaseAddr);
-                switch(p_FmPort->portType)
+                switch (p_FmPort->portType)
                 {
-                    case(e_FM_PORT_TYPE_RX_10G):
-                    case(e_FM_PORT_TYPE_RX):
+                    case (e_FM_PORT_TYPE_RX_10G):
+                    case (e_FM_PORT_TYPE_RX):
                         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rgpr, muramPageOffset);
                         break;
-                    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+                    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                         WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ogpr, muramPageOffset);
                         break;
                     default:
@@ -2161,7 +2160,7 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
         p_FmPort->gprFunc = gprFunc;
     }
 
-    switch(p_FmPort->gprFunc)
+    switch (p_FmPort->gprFunc)
     {
         case (e_FM_PORT_GPR_MURAM_PAGE):
             *p_Value = p_FmPort->p_MuramPage;
@@ -2217,7 +2216,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     if (p_CcParams->getCcParams.type & GET_NIA_FPNE)
     {
-        if(p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
             p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne);
         else
             p_CcParams->getCcParams.nia = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne);
@@ -2246,7 +2245,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNEN)
     {
-       if(p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
+       if (p_FmPort->savedQmiPnen != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNEN was defined previously different"));
     }
 
@@ -2258,7 +2257,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_PNDN)
     {
-        if(p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
+        if (p_FmPort->savedNonRxQmiRegsPndn != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("PNDN was defined previously different"));
     }
 
@@ -2271,7 +2270,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_FENE)
     {
-       if(p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
+       if (p_FmPort->savedBmiFene != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFENE was defined previously different"));
     }
 
@@ -2283,7 +2282,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_FPNE)
     {
-       if(p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
+       if (p_FmPort->savedBmiFpne != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xFPNE was defined previously different"));
     }
 
@@ -2295,7 +2294,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_NIA_CMNE)
     {
-       if(p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
+       if (p_FmPort->savedBmiCmne != p_CcParams->setCcParams.nia)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("xCMNE was defined previously different"));
     }
 
@@ -2303,13 +2302,13 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
         !(p_FmPort->requiredAction & UPDATE_PSO))
     {
         /* get PCD registers pointers */
-         switch(p_FmPort->portType)
+         switch (p_FmPort->portType)
          {
-             case(e_FM_PORT_TYPE_RX_10G):
-             case(e_FM_PORT_TYPE_RX):
+             case (e_FM_PORT_TYPE_RX_10G):
+             case (e_FM_PORT_TYPE_RX):
                  p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
                  break;
-             case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+             case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                  p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
                  break;
              default:
@@ -2317,7 +2316,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
          }
         /* set start parsing offset */
         tmpInt = (int)GET_UINT32(*p_BmiPrsStartOffset)+ p_CcParams->setCcParams.psoSize;
-        if(tmpInt>0)
+        if (tmpInt>0)
             WRITE_UINT32(*p_BmiPrsStartOffset, (uint32_t)tmpInt);
 
         p_FmPort->requiredAction |= UPDATE_PSO;
@@ -2326,7 +2325,7 @@ t_Error FmPortGetSetCcParams(t_Handle h_FmPort, t_FmPortGetSetCcParams *p_CcPara
     }
     else if (p_CcParams->setCcParams.type & UPDATE_PSO)
     {
-        if(p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
+        if (p_FmPort->savedPrsStartOffset != p_CcParams->setCcParams.psoSize)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("parser start offset was defoned previousley different"));
     }
 
@@ -2403,24 +2402,24 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     p_FmPort->maxFrameLength                                        = DEFAULT_PORT_maxFrameLength;
     /* resource distribution. */
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if(1)// if(p_FmPort->fmRevInfo.majorRev < 6)
+    if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
     {
-        p_FmPort->fifoBufs.num                                          = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
-        p_FmPort->fifoBufs.extra                                        = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
-        p_FmPort->openDmas.num                                          = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType, p_FmPort->fmRevInfo.majorRev);
-        p_FmPort->openDmas.extra                                        = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
-        p_FmPort->tasks.num                                             = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
-        p_FmPort->tasks.extra                                           = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+        p_FmPort->fifoBufs.num                                      = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)*BMI_FIFO_UNITS;
+        p_FmPort->fifoBufs.extra                                    = DEFAULT_PORT_extraNumOfFifoBufs*BMI_FIFO_UNITS;
+        p_FmPort->openDmas.num                                      = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType, p_FmPort->fmRevInfo.majorRev);
+        p_FmPort->openDmas.extra                                    = DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+        p_FmPort->tasks.num                                         = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+        p_FmPort->tasks.extra                                       = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
     }
     else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
     {
-        p_FmPort->fifoBufs.num                                          = 0;
-        p_FmPort->fifoBufs.extra                                        = 0;
-        p_FmPort->openDmas.num                                          = 0;
-        p_FmPort->openDmas.extra                                        = 0;
-        p_FmPort->tasks.num                                             = 0;
-        p_FmPort->tasks.extra                                           = 0;
+        p_FmPort->fifoBufs.num                                      = 0;
+        p_FmPort->fifoBufs.extra                                    = 0;
+        p_FmPort->openDmas.num                                      = 0;
+        p_FmPort->openDmas.extra                                    = 0;
+        p_FmPort->tasks.num                                         = 0;
+        p_FmPort->tasks.extra                                       = 0;
     }
 
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
@@ -2433,16 +2432,16 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         (p_FmPort->portType != e_FM_PORT_TYPE_TX_10G))
         p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-    case(e_FM_PORT_TYPE_RX):
-    case(e_FM_PORT_TYPE_RX_10G):
+    case (e_FM_PORT_TYPE_RX):
+    case (e_FM_PORT_TYPE_RX_10G):
         /* Initialize FM port parameters for initialization phase only */
         p_FmPort->p_FmPortDriverParam->cutBytesFromEnd              = DEFAULT_PORT_cutBytesFromEnd;
         p_FmPort->p_FmPortDriverParam->enBufPoolDepletion           = FALSE;
         p_FmPort->p_FmPortDriverParam->frmDiscardOverride           = DEFAULT_PORT_frmDiscardOverride;
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if(1)// if(p_FmPort->fmRevInfo.majorRev < 6)
+    if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
     {
         p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel      = DEFAULT_PORT_rxFifoPriElevationLevel;
         p_FmPort->p_FmPortDriverParam->rxFifoThreshold              = DEFAULT_PORT_rxFifoThreshold;
@@ -2463,18 +2462,18 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 #endif /* (DPAA_VERSION >= 11) */
         break;
 
-    case(e_FM_PORT_TYPE_TX):
+    case (e_FM_PORT_TYPE_TX):
         p_FmPort->p_FmPortDriverParam->dontReleaseBuf               = FALSE;
-    case(e_FM_PORT_TYPE_TX_10G):
+    case (e_FM_PORT_TYPE_TX_10G):
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-        if(1)// if(p_FmPort->fmRevInfo.majorRev < 6)
+        if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
         {
-            p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel           = DEFAULT_PORT_txFifoMinFillLevel;
-            p_FmPort->fifoDeqPipelineDepth                              =
+            p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel       = DEFAULT_PORT_txFifoMinFillLevel;
+            p_FmPort->fifoDeqPipelineDepth                          =
                 (uint8_t)((p_FmPort->portType == e_FM_PORT_TYPE_TX) ?
                           DEFAULT_PORT_fifoDeqPipelineDepth_1G :
                           DEFAULT_PORT_fifoDeqPipelineDepth_10G);
-            p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel           = DEFAULT_PORT_txFifoLowComfLevel;
+            p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel       = DEFAULT_PORT_txFifoLowComfLevel;
         }
         else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
@@ -2499,20 +2498,20 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
                        DEFAULT_PORT_deqByteCnt_1G :
                        DEFAULT_PORT_deqByteCnt_10G);
         break;
-    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
         p_FmPort->p_FmPortDriverParam->errorsToDiscard              = DEFAULT_PORT_errorsToDiscard;
 #if (DPAA_VERSION >= 11)
         p_FmPort->p_FmPortDriverParam->noScatherGather              = DEFAULT_PORT_noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
-    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption            = DEFAULT_PORT_deqPrefetchOption_HC;
         p_FmPort->p_FmPortDriverParam->deqHighPriority              = DEFAULT_PORT_deqHighPriority_1G;
         p_FmPort->p_FmPortDriverParam->deqType                      = DEFAULT_PORT_deqType;
         p_FmPort->p_FmPortDriverParam->deqByteCnt                   = DEFAULT_PORT_deqByteCnt_1G;
 
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if(1)// if(p_FmPort->fmRevInfo.majorRev < 6)
-       p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+    if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
+        p_FmPort->fifoDeqPipelineDepth                              = DEFAULT_PORT_fifoDeqPipelineDepth_OH;
     else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
     {
@@ -2522,7 +2521,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     }
 
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
-        if(p_FmPort->fmRevInfo.majorRev < 6)
+        if (p_FmPort->fmRevInfo.majorRev < 6)
             p_FmPort->p_FmPortDriverParam->cheksumLastBytesIgnore   = DEFAULT_notSupported;
 #endif /* !FM_FRAME_END_PARAMS_FOR_OP */
 
@@ -2540,7 +2539,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
         return NULL;
     }
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if(p_FmPort->fmRevInfo.majorRev == 4)
+    if (p_FmPort->fmRevInfo.majorRev == 4)
         p_FmPort->p_FmPortDriverParam->deqPrefetchOption = (e_FmPortDeqPrefetchOption)DEFAULT_notSupported;
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
 
@@ -2555,10 +2554,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     }
     else
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-        case(e_FM_PORT_TYPE_RX):
-        case(e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
             /* Initialize FM port parameters for initialization phase only */
             memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools,
                    &p_FmPortParams->specificParams.rxParams.extBufPools,
@@ -2567,10 +2566,10 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             p_FmPort->p_FmPortDriverParam->dfltFqid                     = p_FmPortParams->specificParams.rxParams.dfltFqid;
             p_FmPort->p_FmPortDriverParam->liodnOffset                  = p_FmPortParams->specificParams.rxParams.liodnOffset;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_TX):
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_FmPort->p_FmPortDriverParam->errFqid                      = p_FmPortParams->specificParams.nonRxParams.errFqid;
             p_FmPort->p_FmPortDriverParam->deqSubPortal                 =
                 (uint8_t)(p_FmPortParams->specificParams.nonRxParams.qmChannel & QMI_DEQ_CFG_SUBPORTAL_MASK);
@@ -2585,7 +2584,7 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     }
 
     memset(p_FmPort->name, 0, (sizeof(char)) * MODULE_NAME_SIZE);
-    if(Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
+    if (Sprint (p_FmPort->name, "FM-%d-port-%s-%d",
                FmGetId(p_FmPort->h_Fm),
                ((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING ||
                  (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)) ?
@@ -2639,6 +2638,14 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
                                    &p_FmPort->internalBufferOffset);
     if (err != E_OK)
         RETURN_ERROR(MAJOR, err, NO_MSG);
+#ifdef FM_BCB_ERRATA_BMI_SW001
+    if ((p_FmPort->p_FmPortDriverParam->bcbWorkaround) &&
+           (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    {
+        p_FmPort->p_FmPortDriverParam->errorsToDiscard |= FM_PORT_FRM_ERR_PHYSICAL;
+        p_FmPort->fifoBufs.num += 4*KILOBYTE;
+    }
+#endif /* FM_BCB_ERRATA_BMI_SW001 */
 
     CHECK_INIT_PARAMETERS(p_FmPort, CheckInitParameters);
 
@@ -2666,10 +2673,10 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     fmParams.numOfExtraTasks    = (uint8_t)p_FmPort->tasks.extra;
     fmParams.numOfOpenDmas      = (uint8_t)p_FmPort->openDmas.num;
     fmParams.numOfExtraOpenDmas = (uint8_t)p_FmPort->openDmas.extra;
-    if(p_FmPort->fifoBufs.num)
+    if (p_FmPort->fifoBufs.num)
     {
         err = VerifySizeOfFifo(p_FmPort);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     fmParams.sizeOfFifo         = p_FmPort->fifoBufs.num;
@@ -2694,7 +2701,7 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
 
     err = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     /* get params for use in init */
@@ -2704,7 +2711,7 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     p_FmPort->h_FmMuram = FmGetMuramHandle(p_FmPort->h_Fm);
 
 #ifndef FM_NO_GUARANTEED_RESET_VALUES
-    if(p_FmPort->fmRevInfo.majorRev >= 6)
+    if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
         p_FmPort->tasks.num = fmParams.numOfTasks;
         p_FmPort->tasks.extra = fmParams.numOfExtraTasks;
@@ -2714,27 +2721,28 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
         p_FmPort->fifoBufs.extra = fmParams.extraSizeOfFifo;
     }
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
+
     /**********************/
     /* Init BMI Registers */
     /**********************/
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             err = BmiRxPortInit(p_FmPort);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             err = BmiTxPortInit(p_FmPort);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             err = BmiOhPortInit(p_FmPort);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             break;
         default:
@@ -2773,7 +2781,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    if(p_FmPort->pcdEngines)
+    if (p_FmPort->pcdEngines)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Trying to free a port with PCD. FM_PORT_DeletePCD must be called first."));
 
     if (p_FmPort->enabled)
@@ -2794,7 +2802,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     FmFreePortParams(p_FmPort->h_Fm, &fmParams);
 
 #if (DPAA_VERSION >= 11)
-    if(FmVSPFreeForPort(p_FmPort->h_Fm,
+    if (FmVSPFreeForPort(p_FmPort->h_Fm,
                         p_FmPort->portType,
                         p_FmPort->portId) != E_OK)
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("VSP free of port FAILED"));
@@ -2860,7 +2868,7 @@ t_Error FM_PORT_ConfigDeqHighPriority(t_Handle h_FmPort, bool highPri)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->deqHighPriority = highPri;
@@ -2874,7 +2882,7 @@ t_Error FM_PORT_ConfigDeqType(t_Handle h_FmPort, e_FmPortDeqType deqType)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->deqType = deqType;
@@ -2888,7 +2896,7 @@ t_Error FM_PORT_ConfigDeqPrefetchOption(t_Handle h_FmPort, e_FmPortDeqPrefetchOp
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
     p_FmPort->p_FmPortDriverParam->deqPrefetchOption = deqPrefetchOption;
     return E_OK;
@@ -2900,11 +2908,11 @@ t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_Backup
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->p_BackupBmPools = (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
-    if(!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
+    if (!p_FmPort->p_FmPortDriverParam->p_BackupBmPools)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
     memcpy(p_FmPort->p_FmPortDriverParam->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmBackupBmPools));
 
@@ -2917,7 +2925,7 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Rx ports"));
 
     p_FmPort->p_FmPortDriverParam->deqByteCnt = deqByteCnt;
@@ -2958,7 +2966,7 @@ t_Error FM_PORT_ConfigCutBytesFromEnd(t_Handle h_FmPort, uint8_t cutBytesFromEnd
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->cutBytesFromEnd = cutBytesFromEnd;
@@ -2972,7 +2980,7 @@ t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_B
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
@@ -2987,7 +2995,7 @@ t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle h_FmPort, t_FmPortObservedB
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
     p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = TRUE;
@@ -3008,7 +3016,7 @@ t_Error FM_PORT_ConfigExtBufPools(t_Handle h_FmPort, t_FmExtPools *p_FmExtPools)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for OP ports only"));
 
     memcpy(&p_FmPort->p_FmPortDriverParam->extBufPools, p_FmExtPools, sizeof(t_FmExtPools));
@@ -3022,7 +3030,7 @@ t_Error FM_PORT_ConfigDontReleaseTxBufToBM(t_Handle h_FmPort)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->dontReleaseBuf = TRUE;
@@ -3048,7 +3056,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->syncReq = syncReq;
@@ -3063,7 +3071,7 @@ t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->frmDiscardOverride = override;
@@ -3077,7 +3085,7 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX) &&
                                                             (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx and offline parsing ports only"));
 
@@ -3141,7 +3149,7 @@ t_Error FM_PORT_ConfigDmaWriteOptimize(t_Handle h_FmPort, bool optimize)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dmaWriteOptimize = optimize;
@@ -3173,7 +3181,7 @@ t_Error FM_PORT_ConfigForwardReuseIntContext(t_Handle h_FmPort, bool forwardReus
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->forwardReuseIntContext = forwardReuse;
@@ -3193,6 +3201,20 @@ t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length)
     return E_OK;
 }
 
+#ifdef FM_BCB_ERRATA_BMI_SW001
+t_Error FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort)
+{
+    t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
+
+    p_FmPort->p_FmPortDriverParam->bcbWorkaround = TRUE;
+
+    return E_OK;
+}
+#endif /* FM_BCB_ERRATA_BMI_SW001 */
+
 /****************************************************/
 /*       Hidden-DEBUG Only API                      */
 /****************************************************/
@@ -3203,7 +3225,7 @@ t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLeve
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = minFillLevel;
@@ -3218,7 +3240,7 @@ t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelin
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Not available for Rx ports"));
 
     if (p_FmPort->imEn)
@@ -3235,7 +3257,7 @@ t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComf
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_TX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx ports only"));
 
     p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = fifoLowComfLevel;
@@ -3249,7 +3271,7 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->rxFifoThreshold = fifoThreshold;
@@ -3263,7 +3285,7 @@ t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priEle
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
     p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel = priElevationLevel;
@@ -3282,12 +3304,12 @@ t_Error FM_PORT_SetNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfOpenDma
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
+    if ((!p_NumOfOpenDmas->num) || (p_NumOfOpenDmas->num > MAX_NUM_OF_DMAS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-num can't be larger than %d", MAX_NUM_OF_DMAS));
-    if(p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
+    if (p_NumOfOpenDmas->extra > MAX_NUM_OF_EXTRA_DMAS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("openDmas-extra can't be larger than %d", MAX_NUM_OF_EXTRA_DMAS));
     err = FmSetNumOfOpenDmas(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfOpenDmas->num, (uint8_t*)&p_NumOfOpenDmas->extra, FALSE);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     memcpy(&p_FmPort->openDmas, p_NumOfOpenDmas, sizeof(t_FmPortRsrc));
@@ -3306,13 +3328,13 @@ t_Error FM_PORT_SetNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks)
     /* only driver uses host command port, so ASSERT rather than  RETURN_ERROR */
     ASSERT_COND(p_FmPort->portType != e_FM_PORT_TYPE_OH_HOST_COMMAND);
 
-    if((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
+    if ((!p_NumOfTasks->num) || (p_NumOfTasks->num > MAX_NUM_OF_TASKS))
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-num can't be larger than %d", MAX_NUM_OF_TASKS));
-    if(p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
+    if (p_NumOfTasks->extra > MAX_NUM_OF_EXTRA_TASKS)
          RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("NumOfTasks-extra can't be larger than %d", MAX_NUM_OF_EXTRA_TASKS));
 
     err = FmSetNumOfTasks(p_FmPort->h_Fm, p_FmPort->hardwarePortId, (uint8_t*)&p_NumOfTasks->num, (uint8_t*)&p_NumOfTasks->extra, FALSE);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     /* update driver's struct */
@@ -3335,18 +3357,18 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
     if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         /* extra FIFO size (allowed only to Rx ports) */
-         if(p_SizeOfFifo->extra % BMI_FIFO_UNITS)
+         if (p_SizeOfFifo->extra % BMI_FIFO_UNITS)
               RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("SizeOfFifo-extra has to be divisible by %d", BMI_FIFO_UNITS));
     }
     else
-        if(p_SizeOfFifo->extra)
+        if (p_SizeOfFifo->extra)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, (" No SizeOfFifo-extra for non Rx ports"));
 
     memcpy(&p_FmPort->fifoBufs, p_SizeOfFifo, sizeof(t_FmPortRsrc));
 
     /* we do not change user's parameter */
     err = VerifySizeOfFifo(p_FmPort);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
     err = FmSetSizeOfFifo(p_FmPort->h_Fm,
@@ -3354,7 +3376,7 @@ t_Error FM_PORT_SetSizeOfFifo(t_Handle h_FmPort, t_FmPortRsrc *p_SizeOfFifo)
                           &p_SizeOfFifo->num,
                           &p_SizeOfFifo->extra,
                           FALSE);
-    if(err)
+    if (err)
         RETURN_ERROR(MINOR, err, NO_MSG);
 
     return E_OK;
@@ -3433,33 +3455,34 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rst;
             rxPort = TRUE;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
              p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
              p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tst;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
             p_BmiStatusReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ost;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
+
     /* check if port is already disabled */
-    if(!(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN))
+    if (!(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN))
     {
         if (!rxPort && !p_FmPort->imEn)
         {
-            if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN))
+            if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN))
                 /* port is disabled */
                 return E_OK;
             else
@@ -3522,19 +3545,19 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcfg;
             rxPort = TRUE;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
              p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tcfg;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiCfgReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ocfg;
             break;
         default:
@@ -3542,11 +3565,11 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort)
     }
 
     /* check if port is already enabled */
-    if(GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN)
+    if (GET_UINT32(*p_BmiCfgReg) & BMI_PORT_CFG_EN)
     {
         if (!rxPort && !p_FmPort->imEn)
         {
-            if(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN)
+            if (GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc)& QMI_PORT_CFG_EN)
                 /* port is enabled */
                 return E_OK;
             else
@@ -3583,19 +3606,19 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
                                                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
             baseGran = 16000;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
             baseGran = 10000;
@@ -3622,12 +3645,12 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 
     tmpRateLimit = (uint32_t)(p_RateLimit->rateLimit*factor/baseGran - 1);
 
-    if(!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > MAX_BURST_SIZE))
+    if (!p_RateLimit->maxBurstSize || (p_RateLimit->maxBurstSize > MAX_BURST_SIZE))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxBurstSize must be between 1K and %dk", MAX_BURST_SIZE));
 
     tmpRateLimitScale = ((31 - (uint32_t)countUnitBit) << BMI_COUNT_RATE_UNIT_SHIFT) | BMI_RATE_LIMIT_EN;
 
-    if(p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+    if (p_FmPort->portType != e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         tmpRateLimit |= (uint32_t)(p_RateLimit->maxBurstSize - 1) << BMI_MAX_BURST_SHIFT;
     else
     {
@@ -3635,17 +3658,17 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
 
         if ((p_FmPort->fmRevInfo.majorRev == 4) || (p_FmPort->fmRevInfo.majorRev >= 6))
         {
-            switch(p_RateLimit->rateLimitDivider)
+            switch (p_RateLimit->rateLimitDivider)
             {
-                case(e_FM_PORT_DUAL_RATE_LIMITER_NONE):
+                case (e_FM_PORT_DUAL_RATE_LIMITER_NONE):
                     break;
-                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2):
+                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_2):
                     tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_2;
                     break;
-                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4):
+                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_4):
                     tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_4;
                     break;
-                case(e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8):
+                case (e_FM_PORT_DUAL_RATE_LIMITER_SCALE_DOWN_BY_8):
                     tmpRateLimitScale |= BMI_RATE_LIMIT_SCALE_BY_8;
                     break;
                 default:
@@ -3656,10 +3679,10 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit)
         else
 #endif /* ! FM_NO_ADVANCED_RATE_LIMITER */
         {
-            if(p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
+            if (p_RateLimit->rateLimitDivider != e_FM_PORT_DUAL_RATE_LIMITER_NONE)
                     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("FM_PORT_ConfigDualRateLimitScaleDown"));
 
-            if(p_RateLimit->maxBurstSize % 1000)
+            if (p_RateLimit->maxBurstSize % 1000)
             {
                 p_RateLimit->maxBurstSize = (uint16_t)((p_RateLimit->maxBurstSize/1000)+1);
                 DBG(WARNING, ("rateLimit.maxBurstSize rounded up to %d", (p_RateLimit->maxBurstSize/1000+1)*1000));
@@ -3684,18 +3707,18 @@ t_Error FM_PORT_DeleteRateLimit(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) || (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
                                                 (p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Tx and Offline parsing ports only"));
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_trlmts;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_RateLimitReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmt;
             p_RateLimitScaleReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_orlmts;
            break;
@@ -3719,7 +3742,7 @@ t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
     tmpReg = GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc);
-    if(enable)
+    if (enable)
         tmpReg |= QMI_PORT_CFG_EN_COUNTERS ;
     else
         tmpReg &= ~QMI_PORT_CFG_EN_COUNTERS;
@@ -3737,25 +3760,25 @@ t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpc;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpc;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiPcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opc;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if(enable)
+    if (enable)
         WRITE_UINT32(*p_BmiPcReg, BMI_COUNTERS_EN);
     else
         WRITE_UINT32(*p_BmiPcReg, 0);
@@ -3771,18 +3794,18 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpcp;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tpcp;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiPcpReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opcp;
             break;
         default:
@@ -3809,26 +3832,26 @@ t_Error FM_PORT_SetPerformanceCountersParams(t_Handle h_FmPort, t_FmPortPerforma
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                      ("performanceCnt.fifoCompVal has to be divisible by %d",
                       BMI_FIFO_UNITS));
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             if (!p_FmPortPerformanceCnt->queueCompVal ||
                 (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_RX_QUEUE_COMP))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                              ("performanceCnt.queueCompVal for Rx has to be in the range of 1 - %d",
                               MAX_PERFORMANCE_RX_QUEUE_COMP));
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             if (!p_FmPortPerformanceCnt->queueCompVal ||
                 (p_FmPortPerformanceCnt->queueCompVal > MAX_PERFORMANCE_TX_QUEUE_COMP))
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                              ("performanceCnt.queueCompVal for Tx has to be in the range of 1 - %d",
                               MAX_PERFORMANCE_TX_QUEUE_COMP));
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             if (p_FmPortPerformanceCnt->queueCompVal)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("performanceCnt.queueCompVal is not relevant for H/O ports."));
             break;
@@ -3888,7 +3911,7 @@ t_Error FM_PORT_AnalyzePerformanceParams(t_Handle h_FmPort)
     }
     if (FM_PORT_GetCounter(p_FmPort, e_FM_PORT_COUNTERS_FIFO_UTIL))
     {
-        XX_Print ("Max size of defined port fifo (%d) utilized - Please enlarge\n",p_FmPort->fifoBufs.num*BMI_FIFO_UNITS);
+        XX_Print ("Max size of defined port fifo (%d) utilized - Please enlarge\n",p_FmPort->fifoBufs.num);
         failed = TRUE;
     }
     if (failed)
@@ -3945,18 +3968,18 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rstc;
             break;
-        case(e_FM_PORT_TYPE_TX_10G):
-        case(e_FM_PORT_TYPE_TX):
+        case (e_FM_PORT_TYPE_TX_10G):
+        case (e_FM_PORT_TYPE_TX):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tstc;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
             p_BmiStcReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ostc;
             break;
         default:
@@ -3965,7 +3988,7 @@ t_Error FM_PORT_SetStatisticsCounters(t_Handle h_FmPort, bool enable)
 
     tmpReg = GET_UINT32(*p_BmiStcReg);
 
-    if(enable)
+    if (enable)
         tmpReg |= BMI_COUNTERS_EN;
     else
         tmpReg &= ~BMI_COUNTERS_EN;
@@ -3980,14 +4003,14 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
     t_FmPort                *p_FmPort = (t_FmPort*)h_FmPort;
     volatile uint32_t       *p_ErrQReg, *p_ErrDiscard;
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem;
             p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_ErrQReg = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem;
             p_ErrDiscard = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm;
             break;
@@ -4013,15 +4036,15 @@ t_Error FM_PORT_SetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, bool enabl
     SANITY_CHECK_RETURN_ERROR(poolId<BM_MAX_NUM_OF_POOLS, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for Rx ports only"));
 
-    for(i=0 ; i< FM_PORT_MAX_NUM_OF_EXT_POOLS ; i++)
+    for (i=0 ; i< FM_PORT_MAX_NUM_OF_EXT_POOLS ; i++)
     {
         tmpReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if ((uint8_t)((tmpReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT) == poolId)
         {
-            if(enable)
+            if (enable)
                 tmpReg |= BMI_EXT_BUF_POOL_EN_COUNTER;
             else
                 tmpReg &= ~BMI_EXT_BUF_POOL_EN_COUNTER;
@@ -4044,19 +4067,19 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
-            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
             {
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
                 return 0;
             }
             bmiCounter = FALSE;
-        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -4064,29 +4087,29 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
             break;
     }
 
-    if(bmiCounter)
+    if (bmiCounter)
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_RX_10G):
-            case(e_FM_PORT_TYPE_RX):
-                if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case (e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_RX):
+                if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
                 break;
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
-                if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_TX):
+                if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
                 }
                 break;
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-                if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+                if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                 {
                     REPORT_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                     return 0;
@@ -4102,22 +4125,22 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
     {
 
         /* check that counters are enabled */
-        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
         {
             REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             return 0;
         }
 
         /* Set counter */
-        switch(counter)
+        switch (counter)
         {
-           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+           case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc);
-            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc);
-            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc);
-            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 return GET_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc);
             default:
                 REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
@@ -4135,15 +4158,15 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    switch(counter)
+    switch (counter)
     {
-        case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
-        case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
-        case(e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
+        case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+        case (e_FM_PORT_COUNTERS_DEQ_CONFIRM ):
             /* check that counter is available for the port type */
-            if((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+            if ((p_FmPort->portType == e_FM_PORT_TYPE_RX) || (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
                         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for Rx ports"));
-        case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+        case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
         default: /* BMI counters (or error - will be checked in BMI routine )*/
@@ -4151,23 +4174,23 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
             break;
     }
 
-    if(bmiCounter)
+    if (bmiCounter)
     {
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_RX_10G):
-            case(e_FM_PORT_TYPE_RX):
-               if(BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case (e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_RX):
+               if (BmiRxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                 break;
-            case(e_FM_PORT_TYPE_TX_10G):
-            case(e_FM_PORT_TYPE_TX):
-               if(BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case (e_FM_PORT_TYPE_TX_10G):
+            case (e_FM_PORT_TYPE_TX):
+               if (BmiTxPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                 break;
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            case(e_FM_PORT_TYPE_OH_HOST_COMMAND):
-               if(BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+               if (BmiOhPortCheckAndGetCounterPtr(p_FmPort, counter, &p_Reg))
                     RETURN_ERROR(MINOR, E_INVALID_STATE, NO_MSG);
                  break;
             default:
@@ -4179,22 +4202,22 @@ t_Error FM_PORT_ModifyCounter(t_Handle h_FmPort, e_FmPortCounters counter, uint3
     {
 
         /* check that counters are enabled */
-        if(!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
+        if (!(GET_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnc) & QMI_PORT_CFG_EN_COUNTERS))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
 
         /* Set counter */
-        switch(counter)
+        switch (counter)
         {
-           case(e_FM_PORT_COUNTERS_ENQ_TOTAL):
+           case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->fmqm_pnetfc, value);
                 break;
-            case(e_FM_PORT_COUNTERS_DEQ_TOTAL):
+            case (e_FM_PORT_COUNTERS_DEQ_TOTAL):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndtfc, value);
                 break;
-            case(e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
+            case (e_FM_PORT_COUNTERS_DEQ_FROM_DEFAULT):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndfdc, value);
                 break;
-            case(e_FM_PORT_COUNTERS_DEQ_CONFIRM):
+            case (e_FM_PORT_COUNTERS_DEQ_CONFIRM):
                 WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndcc, value);
                 break;
             default:
@@ -4215,21 +4238,21 @@ uint32_t FM_PORT_GetAllocBufCounter(t_Handle h_FmPort, uint8_t poolId)
     SANITY_CHECK_RETURN_VALUE(p_FmPort, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
     {
         REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
         return 0;
     }
 
-    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    for (i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
     {
         extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
         {
             tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
-            if(tmpPool == poolId)
+            if (tmpPool == poolId)
             {
-                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                if (extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
                     return  GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i]);
                 else
                 {
@@ -4253,19 +4276,19 @@ t_Error FM_PORT_ModifyAllocBufCounter(t_Handle h_FmPort, uint8_t poolId, uint32_
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX) && (p_FmPort->portType == e_FM_PORT_TYPE_RX_10G))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available for non-Rx ports"));
 
 
-    for(i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
+    for (i=0;i<FM_PORT_MAX_NUM_OF_EXT_POOLS;i++)
     {
         extPoolReg = GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i]);
         if (extPoolReg & BMI_EXT_BUF_POOL_VALID)
         {
             tmpPool = (uint8_t)((extPoolReg & BMI_EXT_BUF_POOL_ID_MASK) >> BMI_EXT_BUF_POOL_ID_SHIFT);
-            if(tmpPool == poolId)
+            if (tmpPool == poolId)
             {
-                if(extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
+                if (extPoolReg & BMI_EXT_BUF_POOL_EN_COUNTER)
                 {
                     WRITE_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], value);
                     return E_OK;
@@ -4288,7 +4311,7 @@ bool FM_PORT_IsStalled(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_VALUE(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE, FALSE);
 
     err = FmIsPortStalled(p_FmPort->h_Fm, p_FmPort->hardwarePortId, &isStalled);
-    if(err != E_OK)
+    if (err != E_OK)
     {
         REPORT_ERROR(MINOR, err, NO_MSG);
         return TRUE;
@@ -4338,7 +4361,7 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
     t_FmPort                    *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error                     err = E_OK;
     volatile uint32_t           *p_BmiStorageProfileId = NULL, *p_BmiVspe = NULL;
-    uint32_t                    tmpReg = 0;
+    uint32_t                    tmpReg = 0, tmp = 0;
     uint16_t                    hwStoragePrflId;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
@@ -4398,8 +4421,12 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
             break;
 
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            tmpReg = NIA_ENG_BMI | NIA_BMI_AC_FETCH_ALL_FRAME;
+            WRITE_UINT32(p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs.fmqm_pndn,tmpReg);
+
             p_BmiStorageProfileId = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofqid;
             p_BmiVspe = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opp;
+            tmp |= BMI_EBD_EN;
             break;
 
         default:
@@ -4413,7 +4440,7 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
     WRITE_UINT32(*p_BmiStorageProfileId, tmpReg);
 
     tmpReg = GET_UINT32(*p_BmiVspe);
-    WRITE_UINT32(*p_BmiVspe, tmpReg | BMI_SP_EN);
+    WRITE_UINT32(*p_BmiVspe, tmpReg | BMI_SP_EN | tmp);
     return E_OK;
 }
 #endif /* (DPAA_VERSION >= 11) */
@@ -4435,7 +4462,7 @@ t_Error FM_PORT_PcdPlcrAllocProfiles(t_Handle h_FmPort, uint16_t numOfProfiles)
     if (numOfProfiles)
     {
         err = FmPcdPlcrAllocProfiles(p_FmPort->h_FmPcd, p_FmPort->hardwarePortId, numOfProfiles);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     /* set the port handle within the PCD policer, even if no profiles defined */
@@ -4461,7 +4488,7 @@ t_Error FM_PORT_PcdPlcrFreeProfiles(t_Handle h_FmPort)
 
     RELEASE_LOCK(p_FmPort->lock);
 
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err,NO_MSG);
 
     return E_OK;
@@ -4480,13 +4507,13 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_KG , E_INVALID_STATE);
 
     tmpReg = (uint32_t)((p_FmPort->pcdEngines & FM_PCD_CC)? NIA_KG_CC_EN:0);
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             break;
         default:
@@ -4500,24 +4527,24 @@ t_Error FM_PORT_PcdKgModifyInitialScheme (t_Handle h_FmPort, t_FmPcdKgSchemeSele
     }
 
     /* if we want to change to direct scheme, we need to check that this scheme is valid */
-    if(p_FmPcdKgScheme->direct)
+    if (p_FmPcdKgScheme->direct)
     {
         physicalSchemeId = FmPcdKgGetSchemeId(p_FmPcdKgScheme->h_DirectScheme);
         /* check that this scheme is bound to this port */
-        if(!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
+        if (!(p_FmPort->schemesPerPortVector &  (uint32_t)(1 << (31 - (uint32_t)physicalSchemeId))))
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with a scheme that is not bound to this port"));
         }
 
         relativeSchemeId = FmPcdKgGetRelativeSchemeId(p_FmPort->h_FmPcd, physicalSchemeId);
-        if(relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
+        if (relativeSchemeId >= FM_PCD_KG_NUM_OF_SCHEMES)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("called with invalid Scheme "));
         }
 
-        if(!FmPcdKgIsSchemeValidSw(p_FmPcdKgScheme->h_DirectScheme))
+        if (!FmPcdKgIsSchemeValidSw(p_FmPcdKgScheme->h_DirectScheme))
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("called with uninitialized Scheme "));
@@ -4546,18 +4573,18 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
 
     /* check relevance of this routine  - only when policer is used
     directly after BMI or Parser */
-    if((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
+    if ((p_FmPort->pcdEngines & FM_PCD_KG) || (p_FmPort->pcdEngines & FM_PCD_CC))
         RETURN_ERROR(MINOR, E_INVALID_STATE, ("relevant only when PCD support mode is e_FM_PCD_SUPPORT_PLCR_ONLY or e_FM_PCD_SUPPORT_PRS_AND_PLCR"));
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfpne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             p_BmiHpnia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofpne;
             tmpReg = 0;
@@ -4572,7 +4599,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
          return ERROR_CODE(E_BUSY);
     }
 
-    if(!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
+    if (!FmPcdPlcrIsProfileValid(p_FmPort->h_FmPcd, absoluteProfileId))
     {
         RELEASE_LOCK(p_FmPort->lock);
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Invalid profile"));
@@ -4580,7 +4607,7 @@ t_Error     FM_PORT_PcdPlcrModifyInitialProfile (t_Handle h_FmPort, t_Handle h_P
 
     tmpReg = (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
 
-    if(p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
+    if (p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
     {
         /* update BMI HPNIA */
         WRITE_UINT32(*p_BmiHpnia, tmpReg);
@@ -4611,13 +4638,13 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("available for non-independent mode ports only"));
 
     /* get PCD registers pointers */
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             break;
         default:
@@ -4625,10 +4652,10 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
     }
 
     /* check that current NIA is BMI to BMI */
-    if((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NIA_BMI_AC_ENQ_FRAME(p_FmPort->h_FmPcd))
             RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("may be called only for ports in BMI-to-BMI state."));
 
-    if(p_FmPort->pcdEngines & FM_PCD_CC)
+    if (p_FmPort->pcdEngines & FM_PCD_CC)
     {
         if (p_FmPort->h_IpReassemblyManip)
         {
@@ -4642,13 +4669,13 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
             }
         }
-        switch(p_FmPort->portType)
+        switch (p_FmPort->portType)
         {
-            case(e_FM_PORT_TYPE_RX_10G):
-            case(e_FM_PORT_TYPE_RX):
+            case (e_FM_PORT_TYPE_RX_10G):
+            case (e_FM_PORT_TYPE_RX):
                 p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rccb;
                 break;
-            case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+            case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
                 p_BmiCcBase = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_occb;
                 break;
             default:
@@ -4661,7 +4688,7 @@ t_Error FM_PORT_PcdCcModifyTree (t_Handle h_FmPort, t_Handle h_CcTree)
              return ERROR_CODE(E_BUSY);
         }
         err = FmPcdCcBindTree(p_FmPort->h_FmPcd, NULL, h_CcTree, &ccTreePhysOffset, h_FmPort);
-        if(err)
+        if (err)
         {
             RELEASE_LOCK(p_FmPort->lock);
             RETURN_ERROR(MINOR, err, NO_MSG);
@@ -4742,11 +4769,6 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
     t_FmPcdCcTreeParams     *p_FmPcdCcTreeParams;
     t_FmPortPcdCcParams     fmPortPcdCcParams;
     t_FmPortGetSetCcParams  fmPortGetSetCcParams;
-#if (DPAA_VERSION >= 11)
-#ifdef FM_EXP_FEATURES
-    void                    *p_MuramPage;
-#endif /* FM_EXP_FEATURES */
-#endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(h_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
@@ -4880,9 +4902,6 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         {
 #if (DPAA_VERSION >= 11)
-#ifdef FM_EXP_FEATURES
-            FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, &p_MuramPage);
-#endif /* FM_EXP_FEATURES */
 #endif /* (DPAA_VERSION >= 11) */
 
 #ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
@@ -4890,7 +4909,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 (p_FmPort->pcdEngines & FM_PCD_KG))
             {
                 int i;
-                for(i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
+                for (i = 0; i<p_PcdParams->p_KgParams->numOfSchemes; i++)
                     /* The following function must be locked */
                     FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd,
                                           p_PcdParams->p_KgParams->h_Schemes[i],
@@ -5017,7 +5036,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
         FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
 
     err = AttachPCD(h_FmPort);
-    if(err)
+    if (err)
     {
         DeletePcd(p_FmPort);
         if (p_FmPort->h_IpReassemblyTree)
@@ -5140,7 +5159,7 @@ t_Error  FM_PORT_PcdKgBindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams *
         (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING) &&
         (p_FmPort->fmRevInfo.majorRev < 6))
     {
-        for(i=0; i<p_PortScheme->numOfSchemes; i++)
+        for (i=0; i<p_PortScheme->numOfSchemes; i++)
             FmPcdKgCcGetSetParams(p_FmPort->h_FmPcd, p_PortScheme->h_Schemes[i], UPDATE_KG_NIA_CC_WA, 0);
     }
 #endif /* FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004 */
@@ -5198,15 +5217,15 @@ t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_F
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->pcdEngines & FM_PCD_PRS , E_INVALID_STATE);
 
-    switch(p_FmPort->portType)
+    switch (p_FmPort->portType)
     {
-        case(e_FM_PORT_TYPE_RX_10G):
-        case(e_FM_PORT_TYPE_RX):
+        case (e_FM_PORT_TYPE_RX_10G):
+        case (e_FM_PORT_TYPE_RX):
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rpso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
             tmpReg = GET_UINT32(*p_BmiNia) & BMI_RFNE_FDCS_MASK;
             break;
-        case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+        case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
             p_BmiPrsStartOffset = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_opso;
             p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
             tmpReg = 0;
@@ -5249,7 +5268,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
 {
     t_FmPort            *p_FmPort = (t_FmPort*)h_FmPort;
     t_Error             err = E_OK;
-    char                arr[30];
+    char                arr[20];
     uint8_t             flag;
     int                 i=0;
 
@@ -5260,46 +5279,50 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortQmiRegs, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortBmiRegs, E_INVALID_HANDLE);
 
+    memset(arr, 0, sizeof(arr));
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-            strcpy(arr, "PORT_TYPE_OFFLINE_PARSING");
+            strcpy(arr, "OFFLINE-PARSING");
             flag = 0;
             break;
         case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-            strcpy(arr, "PORT_TYPE_HOST_COMMAND");
+            strcpy(arr, "HOST-COMMAND");
             flag = 0;
             break;
         case (e_FM_PORT_TYPE_RX):
-            strcpy(arr, "PORT_TYPE_RX");
+            strcpy(arr, "RX");
             flag = 1;
             break;
         case (e_FM_PORT_TYPE_RX_10G):
-            strcpy(arr, "PORT_TYPE_RX_10G");
+            strcpy(arr, "RX-10G");
             flag = 1;
             break;
         case (e_FM_PORT_TYPE_TX):
-            strcpy(arr, "PORT_TYPE_TX");
+            strcpy(arr, "TX");
             flag = 2;
             break;
         case (e_FM_PORT_TYPE_TX_10G):
-            strcpy(arr, "PORT_TYPE_TX_10G");
+            strcpy(arr, "TX-10G");
             flag = 2;
             break;
         default:
             return ERROR_CODE(E_INVALID_VALUE);
     }
 
-    DUMP_TITLE(UINT_TO_PTR(p_FmPort->hardwarePortId), ("PortId for %s %d", arr, p_FmPort->portId ));
-    DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
+    DUMP_TITLE(NULL,
+               ("FMan-Port (%s #%d) registers:",
+                arr, p_FmPort->portId));
 
     err = FmDumpPortRegs(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
-    if(err)
+    if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
-    switch(flag)
+    DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
+
+    switch (flag)
     {
-        case(0):
+        case (0):
 
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
@@ -5368,7 +5391,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ogpr);
         break;
-    case(1):
+    case (1):
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
@@ -5436,7 +5459,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rgpr);
         break;
-    case(2):
+    case (2):
 
         DUMP_SUBTITLE(("\n"));
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
@@ -5450,6 +5473,9 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfqid);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfeqid);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfene);
+#if (DPAA_VERSION >= 11)
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfne);
+#endif /* (DPAA_VERSION >= 11) */
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmts);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmt);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tstc);
@@ -5485,7 +5511,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnen);
     DUMP_VAR(p_FmPort->p_FmPortQmiRegs,fmqm_pnetfc);
 
-    if(flag !=1)
+    if (flag !=1)
     {
         DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndn);
         DUMP_VAR(&p_FmPort->p_FmPortQmiRegs->nonRxQmiRegs,fmqm_pndc);
@@ -5549,8 +5575,8 @@ t_Error FM_PORT_AddCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *p_C
         tmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] = TRUE;
 
 #if (DPAA_VERSION >= 11)
-        for(j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
-            if(p_CongestionGrps->pfcPrioritiesEn[i][j])
+        for (j=0;j<FM_MAX_NUM_OF_PFC_PRIORITIES;j++)
+            if (p_CongestionGrps->pfcPrioritiesEn[i][j])
                 priorityTmpArray[p_CongestionGrps->congestionGrpsToConsider[i]] |= (0x01 <<(FM_MAX_NUM_OF_PFC_PRIORITIES-j+1));
 #endif /* (DPAA_VERSION >= 11) */
     }
@@ -5663,20 +5689,5 @@ t_Error FM_PORT_RemoveCongestionGrps(t_Handle h_FmPort, t_FmPortCongestionGrps *
 }
 
 #if (DPAA_VERSION >= 11)
-#ifdef FM_EXP_FEATURES
-t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount)
-{
-    t_FmPort    *p_FmPort = (t_FmPort*)h_FmPort;
-
-    SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR((p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING), E_INVALID_VALUE);
-    SANITY_CHECK_RETURN_ERROR(p_FmPort->p_MuramPage, E_INVALID_STATE);
-    SANITY_CHECK_RETURN_ERROR(p_Ipv4OptionsCount, E_NULL_POINTER);
-
-    *p_Ipv4OptionsCount = GET_UINT32(*(uint32_t*)PTR_MOVE(p_FmPort->p_MuramPage,
-                                                          IPF_OPTIONS_COUNT_OFFSET));
-
-    return E_OK;
-}
-#endif /* FM_EXP_FEATURES */
 #endif /* (DPAA_VERSION >= 11) */
+
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
index 7667043..f10ea97 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port.h
@@ -122,10 +122,9 @@
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
                 ((type) == e_FM_PORT_TYPE_TX_10G)) ? 8 :    \
                ((((type) == e_FM_PORT_TYPE_RX) ||           \
-                 ((type) == e_FM_PORT_TYPE_TX) ||           \
-                 ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 2 : 0))
+                 ((type) == e_FM_PORT_TYPE_TX)) ? 2 : 0))
 
-#define DEFAULT_PORT_numOfOpenDmas(type, rev)                  \
+#define DEFAULT_PORT_numOfOpenDmas(type, rev)             \
     (uint32_t)((((type) == e_FM_PORT_TYPE_TX_10G) ||      \
                 ((type) == e_FM_PORT_TYPE_RX_10G)) ? 8 : ((rev>=6) ? 2 : 1))
 
@@ -133,8 +132,7 @@
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
                 ((type) == e_FM_PORT_TYPE_TX_10G)) ? 8 :    \
                ((((type) == e_FM_PORT_TYPE_RX) ||           \
-                 ((type) == e_FM_PORT_TYPE_TX) ||           \
-                 ((type) == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)) ? 1 : 0))
+                 ((type) == e_FM_PORT_TYPE_TX)) ? 1 : 0))
 
 #define DEFAULT_PORT_numOfFifoBufs(type)                    \
     (uint32_t)((((type) == e_FM_PORT_TYPE_RX_10G) ||        \
@@ -176,7 +174,7 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #define IP_FRAG_SW_PATCH_IPv4_SIZE              0x025
 #else
 #define IP_FRAG_SW_PATCH_IPv4_LABEL             0x2E0
-#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x047
+#define IP_FRAG_SW_PATCH_IPv4_SIZE              0x043
 #endif /* (DPAA_VERSION == 10) */
 #define IP_FRAG_SW_PATCH_IPv6_LABEL             \
     (IP_FRAG_SW_PATCH_IPv4_LABEL + IP_FRAG_SW_PATCH_IPv4_SIZE)
@@ -469,6 +467,7 @@ typedef _Packed struct
                                                  BMI_CMD_MR_DEAS)
 #define BMI_CMD_ATTR_ORDER                      0x80000000
 #define BMI_CMD_ATTR_SYNC                       0x02000000
+#define BMI_CMD_ATTR_MODE_MISS_ALLIGN_ADDR_EN   0x00080000
 #define BMI_CMD_ATTR_MACCMD_MASK                0x0000ff00
 #define BMI_CMD_ATTR_MACCMD_OVERRIDE            0x00008000
 #define BMI_CMD_ATTR_MACCMD_SECURED             0x00001000
@@ -528,14 +527,12 @@ typedef _Packed struct
 
 #ifdef FM_DISABLE_SEC_ERRORS
 #define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
-                                                 FM_PORT_FRM_ERR_IPFE                   | \
                                                  FM_PORT_FRM_ERR_LENGTH                 | \
                                                  FM_PORT_FRM_ERR_NON_FM                 | \
                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
 
 #else
 #define OP_ERRS_TO_ENQ                          (RX_ERRS_TO_ENQ                         | \
-                                                 FM_PORT_FRM_ERR_IPFE                   | \
                                                  FM_PORT_FRM_ERR_LENGTH                 | \
                                                  FM_PORT_FRM_ERR_UNSUPPORTED_FORMAT)
 #endif /* FM_DISABLE_SEC_ERRORS */
@@ -739,9 +736,6 @@ typedef _Packed struct
 /**************************************************************************//**
  @Description       Additional defines
 *//***************************************************************************/
-#ifdef FM_EXP_FEATURES
-#define IPF_OPTIONS_COUNT_OFFSET                0x30
-#endif /* FM_EXP_FEATURES */
 
 typedef struct {
     t_Handle                    h_FmMuram;
@@ -818,6 +812,9 @@ typedef struct {
     bool                                noScatherGather;
 #endif /* (DPAA_VERSION >= 11) */
 
+#ifdef FM_BCB_ERRATA_BMI_SW001
+    bool                                bcbWorkaround;
+#endif /* FM_BCB_ERRATA_BMI_SW001 */
 } t_FmPortDriverParam;
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
index 6ddb040..25eecd1 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Port/fm_port_im.c
@@ -46,25 +46,6 @@
 
 #define TX_CONF_STATUS_UNSENT 0x1
 
-#ifdef CORE_8BIT_ACCESS_ERRATA
-#undef WRITE_UINT16
-#undef GET_UINT16
-
-#define WRITE_UINT16(addr, val)  \
-    do{                             \
-            if((int)&(addr) % 4)    \
-                WRITE_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L),                                           \
-                        ((GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L)) & 0xffff0000) | (uint32_t)val));  \
-            else                    \
-                WRITE_UINT32(*(uint32_t*)&addr,                                                                         \
-                        ((GET_UINT32(*(uint32_t*)&addr) & 0x0000ffff) | (uint32_t)val<<16));                            \
-      }while(0);
-
-#define GET_UINT16(addr) (((uint32_t)&addr%4) ?           \
-       ((uint16_t)GET_UINT32(*(uint32_t*)(uint32_t)((uint32_t)&addr & ~0x3L))):  \
-       ((uint16_t)(GET_UINT32(*(uint32_t*)(uint32_t)&addr) >> 16)))
-#endif /* CORE_8BIT_ACCESS_ERRATA */
-
 
 typedef enum e_TxConfType
 {
@@ -313,13 +294,8 @@ t_Error FmPortImCheckInitParameters(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must be power of 2!!!"));
         if (p_FmPort->im.mrblr < 256)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("max Rx buffer length must at least 256!!!"));
-        if(p_FmPort->p_FmPortDriverParam->liodnOffset & ~FM_LIODN_OFFSET_MASK)
+        if (p_FmPort->p_FmPortDriverParam->liodnOffset & ~FM_LIODN_OFFSET_MASK)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("liodnOffset is larger than %d", FM_LIODN_OFFSET_MASK+1));
-/* TODO - add checks */
-    }
-    else
-    {
-/* TODO - add checks */
     }
 
     return E_OK;
@@ -396,19 +372,19 @@ t_Error FmPortImInit(t_FmPort *p_FmPort)
         {
             /* Allocate, configure and register interrupts */
             err = FmAllocFmanCtrlEventReg(p_FmPort->h_Fm, &p_FmPort->fmanCtrlEventId);
-            if(err)
+            if (err)
                 RETURN_ERROR(MAJOR, err, NO_MSG);
 
             ASSERT_COND(!(p_FmPort->fmanCtrlEventId & ~IM_RXQD_FPMEVT_SEL_MASK));
             tmpReg16 = (uint16_t)(p_FmPort->fmanCtrlEventId & IM_RXQD_FPMEVT_SEL_MASK);
             tmpReg32 = 0;
 
-            if(p_FmPort->exceptions & IM_EV_BSY)
+            if (p_FmPort->exceptions & IM_EV_BSY)
             {
                 tmpReg16 |= IM_RXQD_BSYINTM;
                 tmpReg32 |= IM_EV_BSY;
             }
-            if(!p_FmPort->polling)
+            if (!p_FmPort->polling)
             {
                 tmpReg16 |= IM_RXQD_RXFINTM;
                 tmpReg32 |= IM_EV_RX;
@@ -579,7 +555,7 @@ t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort)
     SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
+    if ((p_FmPort->portType != e_FM_PORT_TYPE_RX_10G) && (p_FmPort->portType != e_FM_PORT_TYPE_RX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Available for Rx ports only"));
 
     if (!FmIsMaster(p_FmPort->h_Fm))
@@ -602,16 +578,16 @@ t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception,
     SANITY_CHECK_RETURN_ERROR(p_FmPort->imEn, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
-    if(exception == e_FM_PORT_EXCEPTION_IM_BUSY)
+    if (exception == e_FM_PORT_EXCEPTION_IM_BUSY)
     {
-        if(enable)
+        if (enable)
         {
             p_FmPort->exceptions |= IM_EV_BSY;
-            if(p_FmPort->fmanCtrlEventId == (uint8_t)NO_IRQ)
+            if (p_FmPort->fmanCtrlEventId == (uint8_t)NO_IRQ)
             {
                 /* Allocate, configure and register interrupts */
                 err = FmAllocFmanCtrlEventReg(p_FmPort->h_Fm, &p_FmPort->fmanCtrlEventId);
-                if(err)
+                if (err)
                     RETURN_ERROR(MAJOR, err, NO_MSG);
                 ASSERT_COND(!(p_FmPort->fmanCtrlEventId & ~IM_RXQD_FPMEVT_SEL_MASK));
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
index 0d03916..d65b1d4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Rtc/fm_rtc.c
@@ -129,7 +129,7 @@ static void RtcExceptions(t_Handle h_FmRtc)
 
     if (events & TMR_TEVENT_ALM1)
     {
-        if(p_Rtc->alarmParams[0].clearOnExpiration)
+        if (p_Rtc->alarmParams[0].clearOnExpiration)
         {
             WRITE_UINT32(p_MemMap->tmr_alarm[0].tmr_alarm_l, 0);
             WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~TMR_TEVENT_ALM1);
@@ -139,7 +139,7 @@ static void RtcExceptions(t_Handle h_FmRtc)
     }
     if (events & TMR_TEVENT_ALM2)
     {
-        if(p_Rtc->alarmParams[1].clearOnExpiration)
+        if (p_Rtc->alarmParams[1].clearOnExpiration)
         {
             WRITE_UINT32(p_MemMap->tmr_alarm[1].tmr_alarm_l, 0);
             WRITE_UINT32(p_MemMap->tmr_temask, GET_UINT32(p_MemMap->tmr_temask) & ~TMR_TEVENT_ALM2);
@@ -225,12 +225,11 @@ t_Error FM_RTC_Init(t_Handle h_FmRtc)
     p_RtcDriverParam = p_Rtc->p_RtcDriverParam;
     p_MemMap = p_Rtc->p_MemMap;
 
-    if(CheckInitParameters(p_Rtc)!=E_OK)
+    if (CheckInitParameters(p_Rtc)!=E_OK)
         RETURN_ERROR(MAJOR, E_CONFLICT,
                      ("Init Parameters are not Valid"));
 
-    /* TODO A check must be added here, that no timestamping MAC's
-     * are working in this stage. */
+    /* TODO check that no timestamping MACs are working in this stage. */
     WRITE_UINT32(p_MemMap->tmr_ctrl, TMR_CTRL_TMSR);
     XX_UDelay(10);
     WRITE_UINT32(p_MemMap->tmr_ctrl, 0);
@@ -313,7 +312,7 @@ t_Error FM_RTC_Init(t_Handle h_FmRtc)
     /* check the legality of the relation between source and destination clocks */
     /* should be larger than 1.0001 */
     tmpDouble = 10000 * (uint64_t)p_Rtc->clockPeriodNanoSec * (uint64_t)p_Rtc->srcClkFreqMhz;
-    if((tmpDouble) <= 10001)
+    if ((tmpDouble) <= 10001)
         RETURN_ERROR(MAJOR, E_CONFLICT,
               ("Invalid relation between source and destination clocks. Should be larger than 1.0001"));
 
@@ -373,7 +372,7 @@ t_Error FM_RTC_ConfigSourceClock(t_Handle         h_FmRtc,
     SANITY_CHECK_RETURN_ERROR(p_Rtc->p_RtcDriverParam, E_INVALID_STATE);
 
     p_Rtc->p_RtcDriverParam->srcClk = srcClk;
-    if(srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM)
+    if (srcClk != e_FM_RTC_SOURCE_CLOCK_SYSTEM)
         p_Rtc->p_RtcDriverParam->extSrcClkFreq = freqInMhz;
 
     return E_OK;
@@ -508,8 +507,7 @@ t_Error FM_RTC_Enable(t_Handle h_FmRtc, bool resetClock)
 
     tmrCtrl = GET_UINT32(p_Rtc->p_MemMap->tmr_ctrl);
 
-    /* TODO A check must be added here, that no timestamping MAC's
-     * are working in this stage. */
+    /* TODO check that no timestamping MACs are working in this stage. */
     if (resetClock)
     {
         WRITE_UINT32(p_Rtc->p_MemMap->tmr_ctrl, (tmrCtrl | TMR_CTRL_TMSR));
@@ -575,9 +573,9 @@ t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm ID"));
     }
 
-    if(p_FmRtcAlarmParams->alarmTime < p_Rtc->clockPeriodNanoSec)
+    if (p_FmRtcAlarmParams->alarmTime < p_Rtc->clockPeriodNanoSec)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm time must be equal or larger than RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
-    if(p_FmRtcAlarmParams->alarmTime % (uint64_t)p_Rtc->clockPeriodNanoSec)
+    if (p_FmRtcAlarmParams->alarmTime % (uint64_t)p_Rtc->clockPeriodNanoSec)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Alarm time must be a multiple of RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
     tmpAlarm = p_FmRtcAlarmParams->alarmTime/(uint64_t)p_Rtc->clockPeriodNanoSec;
 
@@ -586,12 +584,12 @@ t_Error FM_RTC_SetAlarm(t_Handle h_FmRtc, t_FmRtcAlarmParams *p_FmRtcAlarmParams
     WRITE_UINT32(p_MemMap->tmr_alarm[p_FmRtcAlarmParams->alarmId].tmr_alarm_h,
                  (uint32_t)(tmpAlarm >> 32));
 
-    if(p_FmRtcAlarmParams->f_AlarmCallback)
+    if (p_FmRtcAlarmParams->f_AlarmCallback)
     {
         p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].f_AlarmCallback = p_FmRtcAlarmParams->f_AlarmCallback;
         p_Rtc->alarmParams[p_FmRtcAlarmParams->alarmId].clearOnExpiration = p_FmRtcAlarmParams->clearOnExpiration;
 
-        if(p_FmRtcAlarmParams->alarmId == 0)
+        if (p_FmRtcAlarmParams->alarmId == 0)
             tmpReg = TMR_TEVENT_ALM1;
         else
             tmpReg = TMR_TEVENT_ALM2;
@@ -618,24 +616,24 @@ t_Error FM_RTC_SetPeriodicPulse(t_Handle h_FmRtc, t_FmRtcPeriodicPulseParams *p_
     {
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse ID"));
     }
-    if(GET_UINT32(p_MemMap->tmr_ctrl) & TMR_CTRL_TE)
+    if (GET_UINT32(p_MemMap->tmr_ctrl) & TMR_CTRL_TE)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Can't set Periodic pulse when RTC is enabled."));
-    if(p_FmRtcPeriodicPulseParams->periodicPulsePeriod < p_Rtc->clockPeriodNanoSec)
+    if (p_FmRtcPeriodicPulseParams->periodicPulsePeriod < p_Rtc->clockPeriodNanoSec)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse must be equal or larger than RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
-    if(p_FmRtcPeriodicPulseParams->periodicPulsePeriod % (uint64_t)p_Rtc->clockPeriodNanoSec)
+    if (p_FmRtcPeriodicPulseParams->periodicPulsePeriod % (uint64_t)p_Rtc->clockPeriodNanoSec)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse must be a multiple of RTC period - %d nanoseconds", p_Rtc->clockPeriodNanoSec));
     tmpFiper = p_FmRtcPeriodicPulseParams->periodicPulsePeriod/(uint64_t)p_Rtc->clockPeriodNanoSec;
-    if(tmpFiper & 0xffffffff00000000LL)
+    if (tmpFiper & 0xffffffff00000000LL)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("Periodic pulse/RTC Period must be smaller than 4294967296", p_Rtc->clockPeriodNanoSec));
 
     WRITE_UINT32(p_MemMap->tmr_fiper[p_FmRtcPeriodicPulseParams->periodicPulseId], (uint32_t)tmpFiper);
 
-    if(p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback)
+    if (p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback)
     {
         p_Rtc->periodicPulseParams[p_FmRtcPeriodicPulseParams->periodicPulseId].f_PeriodicPulseCallback =
                                                                 p_FmRtcPeriodicPulseParams->f_PeriodicPulseCallback;
 
-        if(p_FmRtcPeriodicPulseParams->periodicPulseId == 0)
+        if (p_FmRtcPeriodicPulseParams->periodicPulseId == 0)
             tmpReg = TMR_TEVENT_PP1;
         else
             tmpReg = TMR_TEVENT_PP2;
@@ -661,7 +659,7 @@ t_Error FM_RTC_ClearPeriodicPulse(t_Handle h_FmRtc, uint8_t periodicPulseId)
 
     p_Rtc->periodicPulseParams[periodicPulseId].f_PeriodicPulseCallback = NULL;
 
-    if(periodicPulseId == 0)
+    if (periodicPulseId == 0)
         tmpReg = TMR_TEVENT_PP1;
     else
         tmpReg = TMR_TEVENT_PP2;
@@ -692,16 +690,16 @@ t_Error FM_RTC_SetExternalTrigger(t_Handle h_FmRtc, t_FmRtcExternalTriggerParams
     if (p_FmRtcExternalTriggerParams->f_ExternalTriggerCallback)
     {
         p_Rtc->externalTriggerParams[p_FmRtcExternalTriggerParams->externalTriggerId].f_ExternalTriggerCallback = p_FmRtcExternalTriggerParams->f_ExternalTriggerCallback;
-        if(p_FmRtcExternalTriggerParams->externalTriggerId == 0)
+        if (p_FmRtcExternalTriggerParams->externalTriggerId == 0)
             tmpReg = TMR_TEVENT_ETS1;
         else
             tmpReg = TMR_TEVENT_ETS2;
         WRITE_UINT32(p_Rtc->p_MemMap->tmr_temask, GET_UINT32(p_Rtc->p_MemMap->tmr_temask) | tmpReg);
     }
 
-    if(p_FmRtcExternalTriggerParams->usePulseAsInput)
+    if (p_FmRtcExternalTriggerParams->usePulseAsInput)
     {
-        if(p_FmRtcExternalTriggerParams->externalTriggerId == 0)
+        if (p_FmRtcExternalTriggerParams->externalTriggerId == 0)
             tmpReg = TMR_CTRL_PP1L;
         else
             tmpReg = TMR_CTRL_PP2L;
@@ -725,13 +723,13 @@ t_Error FM_RTC_ClearExternalTrigger(t_Handle h_FmRtc, uint8_t externalTriggerId)
 
     p_Rtc->externalTriggerParams[externalTriggerId].f_ExternalTriggerCallback = NULL;
 
-    if(externalTriggerId == 0)
+    if (externalTriggerId == 0)
         tmpReg = TMR_TEVENT_ETS1;
     else
         tmpReg = TMR_TEVENT_ETS2;
     WRITE_UINT32(p_Rtc->p_MemMap->tmr_temask, GET_UINT32(p_Rtc->p_MemMap->tmr_temask) & ~tmpReg);
 
-    if(externalTriggerId == 0)
+    if (externalTriggerId == 0)
         tmpReg = TMR_CTRL_PP1L;
     else
         tmpReg = TMR_CTRL_PP2L;
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
index 5cfe4b9..a457078 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/SP/fm_sp.c
@@ -150,7 +150,7 @@ static void fm_vsp_fill_entry(fm_pcd_storage_profile_regs   *regs,
     tmp_reg |= (uint32_t)fm_vsp_params->int_context_cache_attr << FM_SP_DMA_ATTR_IC_CACHE_SHIFT;
     tmp_reg |= (uint32_t)fm_vsp_params->header_cache_attr << FM_SP_DMA_ATTR_HDR_CACHE_SHIFT;
     tmp_reg |= (uint32_t)fm_vsp_params->scatter_gather_cache_attr << FM_SP_DMA_ATTR_SG_CACHE_SHIFT;
-    if(fm_vsp_params->dma_write_optimize)
+    if (fm_vsp_params->dma_write_optimize)
         tmp_reg |= FM_SP_DMA_ATTR_WRITE_OPTIMIZE;
     WRITE_UINT32(sp_regs->fm_sp_da, tmp_reg);
 
@@ -239,10 +239,10 @@ void FmSpSetBufPoolsInAscOrderOfBufSizes(t_FmExtPools   *p_FmExtPools,
             else
             {
                 /* find the right place for this poolId */
-                if(bufSize < sizesArray[orderedArray[j]])
+                if (bufSize < sizesArray[orderedArray[j]])
                 {
                     /* move the poolIds one place ahead to make room for this poolId */
-                    for(k=i;k>j;k--)
+                    for (k=i;k>j;k--)
                        orderedArray[k] = orderedArray[k-1];
 
                     /* now k==j, this is the place for the new size */
@@ -263,35 +263,35 @@ t_Error FmSpCheckBufPoolsParams(t_FmExtPools            *p_FmExtPools,
     bool        found;
     uint8_t     count = 0;
 
-    if(p_FmExtPools)
+    if (p_FmExtPools)
     {
-        if(p_FmExtPools->numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
+        if (p_FmExtPools->numOfPoolsUsed > FM_PORT_MAX_NUM_OF_EXT_POOLS)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOfPoolsUsed can't be larger than %d", FM_PORT_MAX_NUM_OF_EXT_POOLS));
 
-        for(i=0;i<p_FmExtPools->numOfPoolsUsed;i++)
+        for (i=0;i<p_FmExtPools->numOfPoolsUsed;i++)
         {
-            if(p_FmExtPools->extBufPool[i].id >= BM_MAX_NUM_OF_POOLS)
+            if (p_FmExtPools->extBufPool[i].id >= BM_MAX_NUM_OF_POOLS)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[%d].id can't be larger than %d", i, BM_MAX_NUM_OF_POOLS));
-            if(!p_FmExtPools->extBufPool[i].size)
+            if (!p_FmExtPools->extBufPool[i].size)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("extBufPools.extBufPool[%d].size is 0", i));
         }
     }
-    if(!p_FmExtPools && (p_FmBackupBmPools || p_FmBufPoolDepletion))
+    if (!p_FmExtPools && (p_FmBackupBmPools || p_FmBufPoolDepletion))
           RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("backupBmPools ot bufPoolDepletion can not be defined without external pools"));
 
     /* backup BM pools indication is valid only for some chip derivatives
        (limited by the config routine) */
-    if(p_FmBackupBmPools)
+    if (p_FmBackupBmPools)
     {
-        if(p_FmBackupBmPools->numOfBackupPools >= p_FmExtPools->numOfPoolsUsed)
+        if (p_FmBackupBmPools->numOfBackupPools >= p_FmExtPools->numOfPoolsUsed)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("p_BackupBmPools must be smaller than extBufPools.numOfPoolsUsed"));
         found = FALSE;
-        for(i = 0;i<p_FmBackupBmPools->numOfBackupPools;i++)
+        for (i = 0;i<p_FmBackupBmPools->numOfBackupPools;i++)
         {
 
-            for(j=0;j<p_FmExtPools->numOfPoolsUsed;j++)
+            for (j=0;j<p_FmExtPools->numOfPoolsUsed;j++)
             {
-                if(p_FmBackupBmPools->poolIds[i] == p_FmExtPools->extBufPool[j].id)
+                if (p_FmBackupBmPools->poolIds[i] == p_FmExtPools->extBufPool[j].id)
                 {
                     found = TRUE;
                     break;
@@ -348,7 +348,7 @@ t_Error FmSpCheckBufPoolsParams(t_FmExtPools            *p_FmExtPools,
         count = 0;
         for (i=0;i<BM_MAX_NUM_OF_POOLS;i++)
         {
-            if(p_FmBufPoolDepletion->poolsToConsiderForSingleMode[i])
+            if (p_FmBufPoolDepletion->poolsToConsiderForSingleMode[i])
             {
                 for (j=0;j<p_FmExtPools->numOfPoolsUsed;j++)
                 {
@@ -532,7 +532,7 @@ t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams)
     t_FmVspEntry          *p_FmVspEntry = NULL;
 
     p_FmVspEntry = (t_FmVspEntry *)XX_Malloc(sizeof(t_FmVspEntry));
-    if(!p_FmVspEntry)
+    if (!p_FmVspEntry)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_StorageProfile allocation failed"));
         return NULL;
@@ -540,7 +540,7 @@ t_Handle FM_VSP_Config(t_FmVspParams *p_FmVspParams)
     memset(p_FmVspEntry, 0, sizeof(t_FmVspEntry));
 
     p_FmVspEntry->p_FmVspEntryDriverParams = (t_FmVspEntryDriverParams *)XX_Malloc(sizeof(t_FmVspEntryDriverParams));
-    if(!p_FmVspEntry->p_FmVspEntryDriverParams)
+    if (!p_FmVspEntry->p_FmVspEntryDriverParams)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("p_StorageProfile allocation failed"));
         XX_Free(p_FmVspEntry);
@@ -609,7 +609,7 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
         RETURN_ERROR(MAJOR, err, NO_MSG);
 
 
-    p_FmVspEntry->p_FmSpRegsBase =
+     p_FmVspEntry->p_FmSpRegsBase =
         (fm_pcd_storage_profile_regs *)FmGetVSPBaseAddr(p_FmVspEntry->h_Fm);
     if (!p_FmVspEntry->p_FmSpRegsBase)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("impossible to initialize SpRegsBase"));
@@ -769,7 +769,7 @@ t_Error FM_VSP_ConfigPoolDepletion(t_Handle h_FmVsp, t_FmBufPoolDepletion *p_Buf
     SANITY_CHECK_RETURN_ERROR(p_BufPoolDepletion, E_INVALID_HANDLE);
 
     p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion = (t_FmBufPoolDepletion *)XX_Malloc(sizeof(t_FmBufPoolDepletion));
-    if(!p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion)
+    if (!p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BufPoolDepletion allocation failed"));
     memcpy(p_FmVspEntry->p_FmVspEntryDriverParams->p_BufPoolDepletion, p_BufPoolDepletion, sizeof(t_FmBufPoolDepletion));
 
@@ -785,7 +785,7 @@ t_Error FM_VSP_ConfigBackupPools(t_Handle h_FmVsp, t_FmBackupBmPools *p_BackupBm
     SANITY_CHECK_RETURN_ERROR(p_BackupBmPools, E_INVALID_HANDLE);
 
     p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools = (t_FmBackupBmPools *)XX_Malloc(sizeof(t_FmBackupBmPools));
-    if(!p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools)
+    if (!p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools)
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("p_BackupBmPools allocation failed"));
     memcpy(p_FmVspEntry->p_FmVspEntryDriverParams->p_BackupBmPools, p_BackupBmPools, sizeof(t_FmBackupBmPools));
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 8099565..b40e08e 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -78,33 +78,50 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
 {
     if (IsFmanCtrlCodeLoaded(p_Fm) && !p_Fm->p_FmDriverParam->resetOnInit)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old FMan CTRL code is loaded; FM must be reset!"));
-    if(!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
+#if (DPAA_VERSION < 11)
+    if (!p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats || (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats > DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("axiDbgNumOfBeats has to be in the range 1 - %d", DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS));
-    if(p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
+#endif
+    if (p_Fm->p_FmDriverParam->dmaCamNumOfEntries % DMA_CAM_UNITS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be divisble by %d", DMA_CAM_UNITS));
-    if(!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
+    if (!p_Fm->p_FmDriverParam->dmaCamNumOfEntries || (p_Fm->p_FmDriverParam->dmaCamNumOfEntries > DMA_MODE_MAX_CAM_NUM_OF_ENTRIES))
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCamNumOfEntries has to be in the range 1 - %d", DMA_MODE_MAX_CAM_NUM_OF_ENTRIES));
-    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
+    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency > DMA_THRESH_MAX_COMMQ)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
-    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
+    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency > DMA_THRESH_MAX_COMMQ)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_COMMQ));
-    if(p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
+    if (p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaCommQThresholds.clearEmergency must be smaller than dmaCommQThresholds.assertEmergency"));
-    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+#if (DPAA_VERSION < 11)
+    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
+    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
-    if(p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
+    if (p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaReadBufThresholds.clearEmergency must be smaller than dmaReadBufThresholds.assertEmergency"));
-    if(p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
+    if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.assertEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
     if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency > DMA_THRESH_MAX_BUF)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency can not be larger than %d", DMA_THRESH_MAX_BUF));
     if (p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency >= p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaWriteBufThresholds.clearEmergency must be smaller than dmaWriteBufThresholds.assertEmergency"));
-    if ((p_Fm->p_FmStateStruct->revInfo.majorRev >= 6) &&
-        ((p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_READ_EM)||(p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_WRITE_EM)))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaDbgCntMode not supported by this integration."));
+#endif
+#if (DPAA_VERSION >= 11)
+    if ((p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_READ_EM)||
+            (p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_INT_WRITE_EM) ||
+            (p_Fm->p_FmDriverParam->dmaDbgCntMode == e_FM_DMA_DBG_CNT_RAW_WAR_PROT))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaDbgCntMode value not supported by this integration."));
+    if ((p_Fm->p_FmDriverParam->dmaEmergency.emergencyBusSelect == FM_DMA_MURAM_READ_EMERGENCY)||
+            (p_Fm->p_FmDriverParam->dmaEmergency.emergencyBusSelect == FM_DMA_MURAM_WRITE_EMERGENCY))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("emergencyBusSelect value not supported by this integration."));
+    if (p_Fm->p_FmDriverParam->dmaStopOnBusError)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaStopOnBusError not supported by this integration."));
+    /* TODO - workaround for simulator not supporting reset values, uncomment! */
+    /*if (p_Fm->p_FmDriverParam->dmaAidMode)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaAidMode not supported by this integration."));
+    if (p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("dmaAxiDbgNumOfBeats not supported by this integration."));*/
+#endif /* (DPAA_VERSION >= 11) */
 
     if (!p_Fm->p_FmStateStruct->fmClkFreq)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fmClkFreq must be set."));
@@ -150,7 +167,7 @@ static t_Error CheckFmParameters(t_Fm *p_Fm)
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev < 6) &&
         (p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError))
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("HaltOnEccError!"));
-#endif /* not FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
+#endif /* FM_ECC_HALT_NO_SYNC_ERRATA_10GMAC_A008 */
 
 #ifdef FM_NO_TNUM_AGING
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) &&
@@ -254,15 +271,15 @@ static void    QmiErrEvent(t_Fm *p_Fm)
 
     /* clear the forced events */
     force = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eif, force & ~event);
 
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, event);
 
-    if(event & QMI_ERR_INTR_EN_DOUBLE_ECC)
+    if (event & QMI_ERR_INTR_EN_DOUBLE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DOUBLE_ECC);
-    if(event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
+    if (event & QMI_ERR_INTR_EN_DEQ_FROM_DEF)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID);
 }
 
@@ -278,7 +295,7 @@ static void    DmaErrEvent(t_Fm *p_Fm)
     status = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr);
     mask = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
 
-    /* get bus error regs befor clearing BER */
+    /* get bus error regs before clearing BER */
     if ((status & DMA_STATUS_BUS_ERR) && (mask & DMA_MODE_BER))
     {
         addr = (uint64_t)GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtal);
@@ -305,7 +322,7 @@ static void    DmaErrEvent(t_Fm *p_Fm)
                          tnum,
                          liodn);
     }
-    if(mask & DMA_MODE_ECC)
+    if (mask & DMA_MODE_ECC)
     {
         if (status & DMA_STATUS_FM_SPDAT_ECC)
             p_Fm->f_Exception(p_Fm->h_App, e_FM_EX_DMA_SINGLE_PORT_ECC);
@@ -322,16 +339,16 @@ static void    FpmErrEvent(t_Fm *p_Fm)
 {
     uint32_t    event;
 
-    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
+    event = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
 
     /* clear the all occurred events */
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, event);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, event);
 
-    if((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
+    if ((event  & FPM_EV_MASK_DOUBLE_ECC) && (event & FPM_EV_MASK_DOUBLE_ECC_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_DOUBLE_ECC);
-    if((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
+    if ((event  & FPM_EV_MASK_STALL) && (event & FPM_EV_MASK_STALL_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_STALL_ON_TASKS);
-    if((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
+    if ((event  & FPM_EV_MASK_SINGLE_ECC) && (event & FPM_EV_MASK_SINGLE_ECC_EN))
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_FPM_SINGLE_ECC);
 }
 
@@ -384,13 +401,13 @@ static void QmiEvent(t_Fm *p_Fm)
 
     /* clear the forced events */
     force = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_if);
-    if(force & event)
+    if (force & event)
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_if, force & ~event);
 
     /* clear the acknowledged events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, event);
 
-    if(event & QMI_INTR_EN_SINGLE_ECC)
+    if (event & QMI_INTR_EN_SINGLE_ECC)
         p_Fm->f_Exception(p_Fm->h_App,e_FM_EX_QMI_SINGLE_ECC);
 }
 
@@ -398,14 +415,14 @@ static void UnimplementedIsr(t_Handle h_Arg)
 {
     UNUSED(h_Arg);
 
-    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented Isr!"));
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented ISR!"));
 }
 
 static void UnimplementedFmanCtrlIsr(t_Handle h_Arg, uint32_t event)
 {
     UNUSED(h_Arg); UNUSED(event);
 
-    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented FmCtl Isr!"));
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented FmCtl ISR!"));
 }
 
 static void EnableTimeStamp(t_Fm *p_Fm)
@@ -427,7 +444,7 @@ static void EnableTimeStamp(t_Fm *p_Fm)
        256/600 = 0.4266666... */
     integer = tsFrequency/p_Fm->p_FmStateStruct->fmClkFreq;
     /* we multiply by 2^16 to keep the fraction of the division */
-    /* we do not divid back, since we write this value as fraction - see spec */
+    /* we do not divide back, since we write this value as fraction - see spec */
     fraction = ((tsFrequency << 16) - (integer << 16) * p_Fm->p_FmStateStruct->fmClkFreq) / p_Fm->p_FmStateStruct->fmClkFreq;
     /* we check remainder of the division in order to round up if not integer */
     if (((tsFrequency << 16) - (integer << 16) * p_Fm->p_FmStateStruct->fmClkFreq) % p_Fm->p_FmStateStruct->fmClkFreq)
@@ -492,12 +509,12 @@ static t_Error LoadFmanCtrlCode(t_Fm *p_Fm)
         WRITE_UINT32(p_Iram->idata, p_Fm->p_FmDriverParam->firmware.p_Code[i]);
 
     compTo16 = (uint8_t)(p_Fm->p_FmDriverParam->firmware.size % 16);
-    if(compTo16)
+    if (compTo16)
         for (i=0; i < ((16-compTo16) / 4); i++)
             WRITE_UINT32(p_Iram->idata, 0xffffffff);
 
     WRITE_UINT32(p_Iram->iadd,p_Fm->p_FmDriverParam->firmware.size-4);
-    while(GET_UINT32(p_Iram->iadd) != (p_Fm->p_FmDriverParam->firmware.size-4)) ;
+    while (GET_UINT32(p_Iram->iadd) != (p_Fm->p_FmDriverParam->firmware.size-4)) ;
 
     /* verify that writing has completed */
     while (GET_UINT32(p_Iram->idata) != p_Fm->p_FmDriverParam->firmware.p_Code[(p_Fm->p_FmDriverParam->firmware.size / 4)-1]) ;
@@ -594,7 +611,7 @@ do {                                    \
         FM_G_CALL_10G_MAC_ISR(0);
     if (pending & INTR_EN_10G_MAC1)
         FM_G_CALL_10G_MAC_ISR(1);
-    if(pending & INTR_EN_TMR)
+    if (pending & INTR_EN_TMR)
         p_Fm->intrMng[e_FM_EV_TMR].f_Isr(p_Fm->intrMng[e_FM_EV_TMR].h_SrcHandle);
 }
 
@@ -766,7 +783,7 @@ static void FreeVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOfProf
 
     for (i=base; i<numOfProfiles; i++)
     {
-        if(p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == guestId)
+        if (p_Fm->p_FmSp->profiles[i].profilesMng.ownerId == guestId)
            p_Fm->p_FmSp->profiles[i].profilesMng.ownerId = (uint8_t)ILLEGAL_BASE;
         else
             DBG(WARNING, ("Request for freeing storage profile window which wasn't allocated to this partition"));
@@ -795,14 +812,14 @@ static t_Error FmGuestHandleIpcMsgCB(t_Handle  h_Fm,
 
     *p_ReplyLength = 0;
 
-    switch(p_IpcMsg->msgId)
+    switch (p_IpcMsg->msgId)
     {
         case (FM_GUEST_ISR):
         {
             t_FmIpcIsr ipcIsr;
 
             memcpy((uint8_t*)&ipcIsr, p_IpcMsg->msgBody, sizeof(t_FmIpcIsr));
-            if(ipcIsr.boolErr)
+            if (ipcIsr.boolErr)
                 GuestErrorIsr(p_Fm, ipcIsr.pendingReg);
             else
                 GuestEventIsr(p_Fm, ipcIsr.pendingReg);
@@ -838,7 +855,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
     memset(p_IpcReply, 0, (sizeof(uint8_t) * FM_IPC_MAX_REPLY_SIZE));
     *p_ReplyLength = 0;
 
-    switch(p_IpcMsg->msgId)
+    switch (p_IpcMsg->msgId)
     {
         case (FM_GET_SET_PORT_PARAMS):
         {
@@ -921,7 +938,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             uint8_t guestId = p_IpcMsg->msgBody[0];
             /* build the FM master partition IPC address */
             memset(p_Fm->fmIpcHandlerModuleName[guestId], 0, (sizeof(char)) * MODULE_NAME_SIZE);
-            if(Sprint (p_Fm->fmIpcHandlerModuleName[guestId], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, guestId) != (guestId<10 ? 6:7))
+            if (Sprint (p_Fm->fmIpcHandlerModuleName[guestId], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, guestId) != (guestId<10 ? 6:7))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
             p_Fm->h_IpcSessions[guestId] = XX_IpcInitSession(p_Fm->fmIpcHandlerModuleName[guestId], p_Fm->fmModuleName);
             if (p_Fm->h_IpcSessions[guestId] == NULL)
@@ -1176,84 +1193,6 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
     return E_OK;
 }
 
-static void ErrorIsrCB(t_Handle h_Fm)
-{
-#define FM_M_CALL_1G_MAC_ERR_ISR(_id)   \
-    {                                   \
-       if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id)].guestId) \
-            SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id), pending);             \
-       else                                                                                         \
-            p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id)].h_SrcHandle);\
-    }
-#define FM_M_CALL_10G_MAC_ERR_ISR(_id)   \
-    {                                   \
-       if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id)].guestId) \
-            SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id), pending);             \
-       else                                                                                         \
-            p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id)].h_SrcHandle);\
-    }
-    t_Fm                    *p_Fm = (t_Fm*)h_Fm;
-    uint32_t                pending;
-
-    SANITY_CHECK_RETURN(h_Fm, E_INVALID_HANDLE);
-
-    /* error interrupts */
-    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fm_epi);
-    if (!pending)
-        return;
-
-    if (pending & ERR_INTR_EN_BMI)
-        BmiErrEvent(p_Fm);
-    if (pending & ERR_INTR_EN_QMI)
-        QmiErrEvent(p_Fm);
-    if (pending & ERR_INTR_EN_FPM)
-        FpmErrEvent(p_Fm);
-    if (pending & ERR_INTR_EN_DMA)
-        DmaErrEvent(p_Fm);
-    if (pending & ERR_INTR_EN_IRAM)
-        IramErrIntr(p_Fm);
-    if (pending & ERR_INTR_EN_MURAM)
-        MuramErrIntr(p_Fm);
-    if (pending & ERR_INTR_EN_PRS)
-        p_Fm->intrMng[e_FM_EV_ERR_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PRS].h_SrcHandle);
-    if (pending & ERR_INTR_EN_PLCR)
-        p_Fm->intrMng[e_FM_EV_ERR_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PLCR].h_SrcHandle);
-    if (pending & ERR_INTR_EN_KG)
-        p_Fm->intrMng[e_FM_EV_ERR_KG].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_KG].h_SrcHandle);
-
-    /* MAC events may belong to different partitions */
-    if (pending & ERR_INTR_EN_1G_MAC0)
-        FM_M_CALL_1G_MAC_ERR_ISR(0);
-    if (pending & ERR_INTR_EN_1G_MAC1)
-        FM_M_CALL_1G_MAC_ERR_ISR(1);
-    if (pending & ERR_INTR_EN_1G_MAC2)
-        FM_M_CALL_1G_MAC_ERR_ISR(2);
-    if (pending & ERR_INTR_EN_1G_MAC3)
-        FM_M_CALL_1G_MAC_ERR_ISR(3);
-    if (pending & ERR_INTR_EN_1G_MAC4)
-        FM_M_CALL_1G_MAC_ERR_ISR(4);
-    if (pending & ERR_INTR_EN_1G_MAC5)
-        FM_M_CALL_1G_MAC_ERR_ISR(5);
-    if (pending & ERR_INTR_EN_1G_MAC6)
-        FM_M_CALL_1G_MAC_ERR_ISR(6);
-    if (pending & ERR_INTR_EN_1G_MAC7)
-        FM_M_CALL_1G_MAC_ERR_ISR(7);
-    if (pending & ERR_INTR_EN_10G_MAC0)
-        FM_M_CALL_10G_MAC_ERR_ISR(0);
-    if (pending & ERR_INTR_EN_10G_MAC1)
-        FM_M_CALL_10G_MAC_ERR_ISR(1);
-
-#ifdef FM_MACSEC_SUPPORT
-    if (pending & ERR_INTR_EN_MACSEC_MAC0)
-    {
-       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].guestId)
-            SendIpcIsr(p_Fm, e_FM_EV_ERR_MACSEC_MAC0, pending);
-        else
-            p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].h_SrcHandle);
-    }
-#endif /* FM_MACSEC_SUPPORT */
-}
-
 
 /****************************************/
 /*       Inter-Module functions         */
@@ -1297,7 +1236,7 @@ t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
     if ((p_Fm->p_FmStateStruct->portsTypes[rxHardwarePortId] != e_FM_PORT_TYPE_DUMMY) ||
         (p_Fm->p_FmStateStruct->portsTypes[txHardwarePortId] != e_FM_PORT_TYPE_DUMMY))
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
-                     ("MAC should be initialized prior to rx and tx ports!"));
+                     ("MAC should be initialized prior to Rx and Tx ports!"));
     WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_extc, 0x40000000);
     CORE_MemoryBarrier();
     while ((GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_extc) & 0x40000000) &&
@@ -1529,7 +1468,7 @@ t_Error FmVSPAllocForPort (t_Handle        h_Fm,
          RETURN_ERROR(MINOR, E_INVALID_VALUE, ("can not allocate storage profile port window"));
 
     if (first < p_Fm->partVSPBase)
-        while(first < p_Fm->partVSPBase)
+        while (first < p_Fm->partVSPBase)
             first = first + numOfVSPs;
 
     if ((first + numOfVSPs) > (p_Fm->partVSPBase + p_Fm->partNumOfVSPs))
@@ -1543,7 +1482,7 @@ t_Error FmVSPAllocForPort (t_Handle        h_Fm,
         {
             profilesFound++;
             i++;
-            if(profilesFound == numOfVSPs)
+            if (profilesFound == numOfVSPs)
                 break;
         }
         else
@@ -1554,7 +1493,7 @@ t_Error FmVSPAllocForPort (t_Handle        h_Fm,
         }
     }
     if (profilesFound == numOfVSPs)
-        for(i = first; i<first + numOfVSPs; i++)
+        for (i = first; i<first + numOfVSPs; i++)
             p_Fm->p_FmSp->profiles[i].profilesMng.allocated = TRUE;
     else
     {
@@ -1569,7 +1508,7 @@ t_Error FmVSPAllocForPort (t_Handle        h_Fm,
     p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase = first;
 
     if ((err = SetVSPWindow(h_Fm,hardwarePortId, first,log2Num)) != E_OK)
-        for(i = first; i < first + numOfVSPs; i++)
+        for (i = first; i < first + numOfVSPs; i++)
             p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
 
     XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
@@ -1594,7 +1533,7 @@ t_Error FmVSPFreeForPort(t_Handle        h_Fm,
     first = p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
 
     intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
-    for(i = first; i < first + numOfVSPs; i++)
+    for (i = first; i < first + numOfVSPs; i++)
            p_Fm->p_FmSp->profiles[i].profilesMng.allocated = FALSE;
     XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
 
@@ -1653,7 +1592,7 @@ t_Error FmAllocFmanCtrlEventReg(t_Handle h_Fm, uint8_t *p_EventId)
         }
 
     if (i==FM_NUM_OF_FMAN_CTRL_EVENT_REGS)
-        RETURN_ERROR(MAJOR, E_BUSY, ("No resource - Fman controller event register."));
+        RETURN_ERROR(MAJOR, E_BUSY, ("No resource - FMan controller event register."));
 
     return E_OK;
 }
@@ -1867,7 +1806,7 @@ void  FmUnregisterFmanCtrlIntr(t_Handle h_Fm, uint8_t eventRegId)
 
     ASSERT_COND(eventRegId<FM_NUM_OF_FMAN_CTRL_EVENT_REGS);
 
-    if(p_Fm->guestId != NCSW_MASTER_ID)
+    if (p_Fm->guestId != NCSW_MASTER_ID)
     {
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("FM in guest-mode"));
         return;
@@ -2029,7 +1968,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
 
     intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
-    if(p_PortParams->independentMode)
+    if (p_PortParams->independentMode)
     {
         /* set port parameters */
         p_Fm->independentMode = p_PortParams->independentMode;
@@ -2037,9 +1976,9 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_mxd, 0);
     }
 
-    if(p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
+    if (p_PortParams->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
     {
-        if(p_Fm->hcPortInitialized)
+        if (p_Fm->hcPortInitialized)
         {
             XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Only one host command port is allowed."));
@@ -2050,16 +1989,16 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] = p_PortParams->portType;
 
     err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, &p_PortParams->numOfTasks, &p_PortParams->numOfExtraTasks, TRUE);
-    if(err)
+    if (err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
     }
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-    if((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
+    if ((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
        (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
     /* for transmit & O/H ports */
     {
@@ -2097,7 +2036,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 #ifdef FM_LOW_END_RESTRICTION
     if ((hardwarePortId==0x1) || (hardwarePortId==0x29))
     {
-        if(p_Fm->p_FmStateStruct->lowEndRestriction)
+        if (p_Fm->p_FmStateStruct->lowEndRestriction)
         {
             XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("OP #0 cannot work with Tx Port #1."));
@@ -2112,7 +2051,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
                           &p_PortParams->sizeOfFifo,
                           &p_PortParams->extraSizeOfFifo,
                           TRUE);
-    if(err)
+    if (err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2123,7 +2062,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
                              &p_PortParams->numOfOpenDmas,
                              &p_PortParams->numOfExtraOpenDmas,
                              TRUE);
-    if(err)
+    if (err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -2134,9 +2073,9 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
         tmpReg = (uint32_t)(hardwarePortId << FPM_PORT_FM_CTL_PORTID_SHIFT);
-        if(p_PortParams->independentMode)
+        if (p_PortParams->independentMode)
         {
-            if((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
+            if ((p_PortParams->portType==e_FM_PORT_TYPE_RX) || (p_PortParams->portType==e_FM_PORT_TYPE_RX_10G))
                 tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL1;
             else
                 tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT) |FPM_PORT_FM_CTL2;
@@ -2146,7 +2085,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
             tmpReg |= (FPM_PORT_FM_CTL2|FPM_PORT_FM_CTL1);
 
             /* order restoration */
-            if(hardwarePortId%2)
+            if (hardwarePortId%2)
                 tmpReg |= (FPM_PORT_FM_CTL1 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
             else
                 tmpReg |= (FPM_PORT_FM_CTL2 << FPM_PRC_ORA_FM_CTL_SEL_SHIFT);
@@ -2156,7 +2095,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
 
     /* set LIODN base for this port */
     tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2]);
-    if(hardwarePortId%2)
+    if (hardwarePortId%2)
     {
         tmpReg &= ~FM_LIODN_BASE_MASK;
         tmpReg |= (uint32_t)p_PortParams->liodnBase;
@@ -2174,6 +2113,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm,t_FmInterModulePortInitParams *p_PortPa
     if ((p_PortParams->portType == e_FM_PORT_TYPE_TX_10G) ||
         (p_PortParams->portType == e_FM_PORT_TYPE_RX_10G))
     {
+        ASSERT_COND(macId < FM_MAX_NUM_OF_10G_MACS);
         if (p_PortParams->maxFrameLength >= p_Fm->p_FmStateStruct->macMaxFrameLengths10G[macId])
             p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId] = p_PortParams->maxFrameLength;
         else
@@ -2274,7 +2214,7 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
     /* WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], 0); */
 
 #ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
-    if(p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
+    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
     if ((p_PortParams->portType != e_FM_PORT_TYPE_RX) &&
         (p_PortParams->portType != e_FM_PORT_TYPE_RX_10G))
@@ -2307,7 +2247,10 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 #if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
     if ((p_PortParams->portType == e_FM_PORT_TYPE_TX_10G) ||
         (p_PortParams->portType == e_FM_PORT_TYPE_RX_10G))
+    {
+        ASSERT_COND(macId < FM_MAX_NUM_OF_10G_MACS);
         p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId] = 0;
+    }
     else
 #endif /* defined(FM_MAX_NUM_OF_10G_MACS) && ... */
     if ((p_PortParams->portType == e_FM_PORT_TYPE_TX) ||
@@ -2468,18 +2411,21 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
     /* Get the relevant bit mask */
     if (type == e_FM_MAC_10G)
     {
-        switch(macId)
+        switch (macId)
         {
             case (0):
                 bitMask = FPM_RSTC_10G0_RESET;
                 break;
+            case (1):
+                bitMask = FPM_RSTC_10G1_RESET;
+                break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
         }
     }
     else
     {
-        switch(macId)
+        switch (macId)
         {
             case (0):
                 bitMask = FPM_RSTC_1G0_RESET;
@@ -2496,6 +2442,15 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
             case (4):
                 bitMask = FPM_RSTC_1G4_RESET;
                 break;
+            case (5):
+                bitMask = FPM_RSTC_1G5_RESET;
+                break;
+            case (6):
+                bitMask = FPM_RSTC_1G6_RESET;
+                break;
+            case (7):
+                bitMask = FPM_RSTC_1G7_RESET;
+                break;
             default:
                 RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
         }
@@ -2544,7 +2499,7 @@ t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_
 #if (defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS))
     if (type == e_FM_MAC_10G)
     {
-        if((!p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId])
+        if ((!p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId])
            || (p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId] &&
               (mtu <= p_Fm->p_FmStateStruct->portMaxFrameLengths10G[macId])))
                p_Fm->p_FmStateStruct->macMaxFrameLengths10G[macId] = mtu;
@@ -2556,7 +2511,7 @@ t_Error FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uint16_
 #else
     UNUSED(type);
 #endif /* (defined(FM_MAX_NUM_OF_10G_MACS) && ... */
-    if((!p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId])
+    if ((!p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId])
        || (p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId] &&
           (mtu <= p_Fm->p_FmStateStruct->portMaxFrameLengths1G[macId])))
         p_Fm->p_FmStateStruct->macMaxFrameLengths1G[macId] = mtu;
@@ -2600,7 +2555,7 @@ uint32_t FmGetTimeStampScale(t_Handle h_Fm)
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MINOR, err, NO_MSG);
-        if(replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
+        if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
         memcpy((uint8_t*)&timeStamp, reply.replyBody, sizeof(uint32_t));
@@ -2615,7 +2570,7 @@ uint32_t FmGetTimeStampScale(t_Handle h_Fm)
         return p_Fm->p_FmStateStruct->count1MicroBit;
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
-        DBG(WARNING, ("No Ipc - can't validate FM if timestamp enabled."));
+        DBG(WARNING, ("No IPC - can't validate FM if timestamp enabled."));
 
     return p_Fm->p_FmStateStruct->count1MicroBit;
 }
@@ -2712,7 +2667,7 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
              p_Fm->baseAddr)
     {
-        DBG(WARNING, ("No Ipc - can't validate FM total-fifo size."));
+        DBG(WARNING, ("No IPC - can't validate FM total-fifo size."));
 
         tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
                             ((extraSizeOfFifo/BMI_FIFO_UNITS) << BMI_EXTRA_FIFO_SIZE_SHIFT));
@@ -2762,6 +2717,7 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
 
     return E_OK;
 }
+
 #else /*FM_NO_GUARANTEED_RESET_VALUES*/
 t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
                         uint8_t     hardwarePortId,
@@ -2812,9 +2768,9 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
              p_Fm->baseAddr)
     {
-        DBG(WARNING, ("No Ipc - can't validate FM total-fifo size."));
+        DBG(WARNING, ("No IPC - can't validate FM total-fifo size."));
 
-        if(sizeOfFifo)
+        if (sizeOfFifo)
         {
             /* whether it is the first time with explicit value, or runtime "set" - write register */
             tmpReg = (uint32_t)((sizeOfFifo/BMI_FIFO_UNITS - 1) |
@@ -2834,7 +2790,7 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
                      ("running in guest-mode without neither IPC nor mapped register!"));
 
-    if(!initialConfig || !sizeOfFifo)
+    if (!initialConfig || !sizeOfFifo)
     {
         /* !initialConfig - runtime change of existing value.
          * !numOfTasks - first configuration according to values in regs.
@@ -2851,9 +2807,9 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     {
         /* This is the first configuration and user did not specify value (!numOfTasks),
          * reset values will be used and we just save these values for resource management */
-        if(currentExtraVal)
+        if (currentExtraVal)
         {
-            if(!p_Fm->p_FmStateStruct->extraFifoPoolSize)
+            if (!p_Fm->p_FmStateStruct->extraFifoPoolSize)
                 /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
                  * must be initialized to 1 buffer per port
                  */
@@ -2960,7 +2916,7 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
     else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
              p_Fm->baseAddr)
     {
-        DBG(WARNING, ("No Ipc - can't validate FM total-num-of-tasks."));
+        DBG(WARNING, ("No IPC - can't validate FM total-num-of-tasks."));
 
         /* calculate reg */
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
@@ -2996,7 +2952,7 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
     else
     {
         ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= oldVal);
-        /* update acummulated */
+        /* update accumulated */
         p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= oldVal;
         p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
         /* calculate reg */
@@ -3008,6 +2964,7 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
 
     return E_OK;
 }
+
 #else /*FM_NO_GUARANTEED_RESET_VALUES*/
 t_Error FmSetNumOfTasks(t_Handle    h_Fm,
                         uint8_t     hardwarePortId,
@@ -3060,7 +3017,7 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
     {
         DBG(WARNING, ("No Ipc - can't validate FM total-num-of-tasks."));
 
-        if(numOfTasks)
+        if (numOfTasks)
         {
             /* whether it is the first time with explicit value, or runtime "set" - write register */
             tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_TASKS_MASK | BMI_NUM_OF_EXTRA_TASKS_MASK);
@@ -3081,7 +3038,7 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
                      ("running in guest-mode without neither IPC nor mapped register!"));
 
-    if(!initialConfig || !numOfTasks)
+    if (!initialConfig || !numOfTasks)
     {
         /* !initialConfig - runtime change of existing value.
          * !numOfTasks - first configuration according to values in regs.
@@ -3099,7 +3056,7 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
          * reset values will be used and we just save these values for resource management */
          p_Fm->p_FmStateStruct->extraTasksPoolSize =
                     (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, currentExtraVal);
-         if((p_Fm->p_FmStateStruct->accumulatedNumOfTasks + currentVal) >
+         if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks + currentVal) >
                  (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
              RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
                                       ("Total ports' numOfTasks and extra tasks pool for fm%d exceed total available numOfTasks.",
@@ -3199,7 +3156,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
              p_Fm->baseAddr &&
              (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
     {
-        /*DBG(WARNING, ("No Ipc - can't validate FM total-num-of-dmas."));*/
+        /*DBG(WARNING, ("No IPC - can't validate FM total-num-of-dmas."));*/
 
         /* calculate reg */
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
@@ -3269,6 +3226,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
 
     return E_OK;
 }
+
 #else /* FM_NO_GUARANTEED_RESET_VALUES */
 t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
                             uint8_t hardwarePortId,
@@ -3324,9 +3282,9 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
              p_Fm->baseAddr &&
              (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
     {
-        /*DBG(WARNING, ("No Ipc - can't validate FM total-num-of-dmas."));*/
+        /*DBG(WARNING, ("No IPC - can't validate FM total-num-of-dmas."));*/
 
-        if(numOfOpenDmas)
+        if (numOfOpenDmas)
         {
             /* whether it is the first time with explicit value, or runtime "set" - write register */
             tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_pp[hardwarePortId-1]) & ~(BMI_NUM_OF_DMAS_MASK | BMI_NUM_OF_EXTRA_DMAS_MASK);
@@ -3351,7 +3309,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     /* it's illegal to be in a state where this is not the first set and no value is specified */
     ASSERT_COND(initialConfig || numOfOpenDmas);
 
-    if(!initialConfig || !numOfOpenDmas)
+    if (!initialConfig || !numOfOpenDmas)
     {
         /* !initialConfig - runtime change of existing value.
          * !numOfTasks - first configuration according to values in regs.
@@ -3475,7 +3433,7 @@ t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
     p_Fm = (t_Fm*)h_Fm;
 
     err = FmVSPCheckRelativeProfile(h_Fm, portType, portId, relativeProfile);
-    if(err != E_OK)
+    if (err != E_OK)
         return err;
 
     SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
@@ -3502,10 +3460,11 @@ static t_Error InitFmDma(t_Fm *p_Fm)
     p_FmDriverParam = p_Fm->p_FmDriverParam;
 
     /* clear status reg events */
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+#if (DPAA_VERSION >= 11)
         tmpReg = DMA_STATUS_FM_SPDAT_ECC;
-    else
+#else
         tmpReg = DMA_STATUS_FM_ECC;
+#endif /* DPAA_VERSION >= 11 */
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmsr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsr) | tmpReg);
 
     /* configure mode register */
@@ -3515,36 +3474,31 @@ static t_Error InitFmDma(t_Fm *p_Fm)
         tmpReg |= DMA_MODE_AID_OR;
     if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_BUS_ERROR)
         tmpReg |= DMA_MODE_BER;
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-    {
-        if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SINGLE_PORT_ECC)
-            tmpReg |= DMA_MODE_ECC;
-    }
-    else
-    {
-        if ((p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_FM_WRITE_ECC))
-            tmpReg |= DMA_MODE_ECC;
-    }
-
-    if(p_FmDriverParam->dmaStopOnBusError)
-        tmpReg |= DMA_MODE_SBER;
-    tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
     if (p_FmDriverParam->dmaEnEmergency)
     {
         tmpReg |= p_FmDriverParam->dmaEmergency.emergencyBusSelect;
         tmpReg |= p_FmDriverParam->dmaEmergency.emergencyLevel << DMA_MODE_EMERGENCY_LEVEL_SHIFT;
-        if(p_FmDriverParam->dmaEnEmergencySmoother)
+        if (p_FmDriverParam->dmaEnEmergencySmoother)
             WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr, p_FmDriverParam->dmaEmergencySwitchCounter);
     }
     tmpReg |= ((p_FmDriverParam->dmaCamNumOfEntries/DMA_CAM_UNITS) - 1) << DMA_MODE_CEN_SHIFT;
-
-    tmpReg |= DMA_MODE_SECURE_PROT;
     tmpReg |= p_FmDriverParam->dmaDbgCntMode << DMA_MODE_DBG_SHIFT;
-    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
 
+#if (DPAA_VERSION >= 11)
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SINGLE_PORT_ECC)
+        tmpReg |= DMA_MODE_ECC;
+#else
+    if ((p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_SYSTEM_WRITE_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_READ_ECC) | (p_Fm->p_FmStateStruct->exceptions & FM_EX_DMA_FM_WRITE_ECC))
+        tmpReg |= DMA_MODE_ECC;
+    if (p_FmDriverParam->dmaStopOnBusError)
+        tmpReg |= DMA_MODE_SBER;
+    tmpReg |= (uint32_t)(p_FmDriverParam->dmaAxiDbgNumOfBeats - 1) << DMA_MODE_AXI_DBG_SHIFT;
+    tmpReg |= p_FmDriverParam->dmaAidMode << DMA_MODE_AID_MODE_SHIFT;
+    tmpReg |= DMA_MODE_SECURE_PROT;
 #ifdef FM_PEDANTIC_DMA
     tmpReg |= DMA_MODE_EMERGENCY_READ;
 #endif /* FM_PEDANTIC_DMA */
+#endif /* DPAA_VERSION >= 11 */
 
     WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
 
@@ -3591,7 +3545,7 @@ static t_Error InitFmDma(t_Fm *p_Fm)
                    0,
                    (uint32_t)(p_FmDriverParam->dmaCamNumOfEntries*72 + 128));
 
-        switch(p_FmDriverParam->dmaCamNumOfEntries)
+        switch (p_FmDriverParam->dmaCamNumOfEntries)
         {
             case (8):
                 WRITE_UINT32(*(uint32_t*)p_Fm->camBaseAddr, 0xff000000);
@@ -3660,10 +3614,10 @@ static t_Error InitFmFpm(t_Fm *p_Fm)
         tmpReg |= FPM_EV_MASK_EXTERNAL_HALT;
     if (!p_Fm->p_FmDriverParam->haltOnUnrecoverableEccError)
         tmpReg |= FPM_EV_MASK_ECC_ERR_HALT;
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg);
 
     /* clear all fmCtls event registers */
-    for(i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
+    for (i=0;i<FM_NUM_OF_FMAN_CTRL_EVENT_REGS;i++)
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_cev[i], 0xFFFFFFFF);
 
     /* RAM ECC -  enable and clear events */
@@ -3749,9 +3703,9 @@ static t_Error InitFmQmi(t_Fm *p_Fm)
      /* Clear error interrupt events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eie, (QMI_ERR_INTR_EN_DOUBLE_ECC | QMI_ERR_INTR_EN_DEQ_FROM_DEF));
     tmpReg = 0;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID)
         tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
-    if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC)
+    if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DOUBLE_ECC)
         tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
     /* enable events */
     WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien, tmpReg);
@@ -3770,7 +3724,7 @@ static t_Error InitFmQmi(t_Fm *p_Fm)
         else
         {
             tmpReg = (uint32_t)(periodInFmClocks/64);
-            if(!tmpReg)
+            if (!tmpReg)
                 tmpReg = 1;
         }
         tmpReg <<= QMI_TAPC_TAP;
@@ -3783,7 +3737,7 @@ static t_Error InitFmQmi(t_Fm *p_Fm)
     if ((p_Fm->p_FmStateStruct->revInfo.majorRev != 4) && (p_Fm->p_FmStateStruct->revInfo.majorRev < 6))
     {
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ie, QMI_INTR_EN_SINGLE_ECC);
-        if(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
+        if (p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_SINGLE_ECC)
             tmpReg |= QMI_INTR_EN_SINGLE_ECC;
         /* enable events */
         WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien, tmpReg);
@@ -3812,7 +3766,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
     if (Sprint (p_Fm->fmIpcHandlerModuleName[0], "FM_%d_%d",p_Fm->p_FmStateStruct->fmId, NCSW_MASTER_ID) != 6)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
 
-    for(i=0;i<e_FM_EV_DUMMY_LAST;i++)
+    for (i=0;i<e_FM_EV_DUMMY_LAST;i++)
         p_Fm->intrMng[i].f_Isr = UnimplementedIsr;
 
     p_Fm->h_IpcSessions[0] = XX_IpcInitSession(p_Fm->fmIpcHandlerModuleName[0], p_Fm->fmModuleName);
@@ -3822,7 +3776,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
         t_FmIpcParams           ipcParams;
 
         err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmGuestHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
-        if(err)
+        if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         memset(&msg, 0, sizeof(msg));
@@ -3841,8 +3795,8 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
                                          IpcMsgCompletionCB,
                                          p_Fm)) != E_OK)
                 REPORT_ERROR(MINOR, err, NO_MSG);
-            while(blockingFlag) ;
-            if(replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
+            while (blockingFlag) ;
+            if (replyLength != (sizeof(uint32_t) + sizeof(uint8_t)))
                 REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
             isMasterAlive = *(uint8_t*)(reply.replyBody);
         } while (!isMasterAlive);
@@ -3860,7 +3814,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
                                      NULL,
                                      NULL)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-        if(replyLength != (sizeof(uint32_t) + sizeof(t_FmIpcParams)))
+        if (replyLength != (sizeof(uint32_t) + sizeof(t_FmIpcParams)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
         memcpy((uint8_t*)&ipcParams, reply.replyBody, sizeof(t_FmIpcParams));
 
@@ -3926,9 +3880,15 @@ t_Error FmDumpPortRegs (t_Handle h_Fm, uint8_t hardwarePortId)
     DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], ("fmbm_pfs for port %u", (hardwarePortId )));
     DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_pfs[hardwarePortId-1], sizeof(uint32_t));
 
-    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], ("bm_ppid for port %u", (hardwarePortId)));
+    DUMP_TITLE(&p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], ("fmbm_spliodn for port %u", (hardwarePortId)));
     DUMP_MEMORY(&p_Fm->p_FmBmiRegs->fmbm_spliodn[hardwarePortId-1], sizeof(uint32_t));
 
+    DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId], ("fmfp_ps for port %u", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmFpmRegs->fmfp_ps[hardwarePortId], sizeof(uint32_t));
+
+    DUMP_TITLE(&p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], ("fmdmplr for port %u", (hardwarePortId)));
+    DUMP_MEMORY(&p_Fm->p_FmDmaRegs->fmdmplr[hardwarePortId/2], sizeof(uint32_t));
+
     return E_OK;
 }
 #endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
@@ -3973,7 +3933,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmStateStruct->fmId = p_FmParam->fmId;
     p_Fm->guestId               = p_FmParam->guestId;
 
-    for(i=0; i<FM_MAX_NUM_OF_HW_PORT_IDS; i++)
+    for (i=0; i<FM_MAX_NUM_OF_HW_PORT_IDS; i++)
         p_Fm->p_FmStateStruct->portsTypes[i] = e_FM_PORT_TYPE_DUMMY;
 
     /* Allocate the FM driver's parameters structure */
@@ -4045,35 +4005,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmDriverParam->tnumAgingPeriod                      = 0;
     p_Fm->p_FmDriverParam->resetOnInit                          = DEFAULT_resetOnInit;
 
-    p_Fm->p_FmDriverParam->thresholds.dispLimit                 = DEFAULT_dispLimit;
-    p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = DEFAULT_prsDispTh;
-    p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = DEFAULT_plcrDispTh;
-    p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = DEFAULT_kgDispTh;
-    p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = DEFAULT_bmiDispTh;
-    p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = DEFAULT_qmiEnqDispTh;
-    p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = DEFAULT_qmiDeqDispTh;
-    p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = DEFAULT_fmCtl1DispTh;
-    p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = DEFAULT_fmCtl2DispTh;
-
-    p_Fm->p_FmDriverParam->dmaStopOnBusError                    = DEFAULT_dmaStopOnBusError;
-
-    p_Fm->p_FmDriverParam->dmaCacheOverride                     = DEFAULT_cacheOverride;
-    p_Fm->p_FmDriverParam->dmaAidMode                           = DEFAULT_aidMode;
-    p_Fm->p_FmDriverParam->dmaAidOverride                       = DEFAULT_aidOverride;
-    p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats                  = DEFAULT_axiDbgNumOfBeats;
-    p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = DEFAULT_dmaCamNumOfEntries;
-    p_Fm->p_FmDriverParam->dmaWatchdog                          = DEFAULT_dmaWatchdog;
-
-    p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency      = DEFAULT_dmaReadIntBufLow;
-    p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency     = DEFAULT_dmaReadIntBufHigh;
-    p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency     = DEFAULT_dmaWriteIntBufLow;
-    p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency    = DEFAULT_dmaWriteIntBufHigh;
-    p_Fm->p_FmDriverParam->dmaSosEmergency                          = DEFAULT_dmaSosEmergency;
-
-    p_Fm->p_FmDriverParam->dmaDbgCntMode                        = DEFAULT_dmaDbgCntMode;
-
-    p_Fm->p_FmDriverParam->dmaEnEmergency                       = FALSE;
-    p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = FALSE;
     p_Fm->p_FmDriverParam->catastrophicErr                      = DEFAULT_catastrophicErr;
     p_Fm->p_FmDriverParam->dmaErr                               = DEFAULT_dmaErr;
     p_Fm->p_FmDriverParam->haltOnExternalActivation             = DEFAULT_haltOnExternalActivation;
@@ -4107,33 +4038,96 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmStateStruct->revInfo.majorRev = (uint8_t)((tmpReg & FPM_REV1_MAJOR_MASK) >> FPM_REV1_MAJOR_SHIFT);
     p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
     /* Chip dependent, will be configured in Init */
+
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if(1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
+    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
     {
         p_Fm->p_FmStateStruct->totalFifoSize        = 0;
         p_Fm->p_FmStateStruct->totalNumOfTasks      = BMI_MAX_NUM_OF_TASKS;
         p_Fm->p_FmStateStruct->maxNumOfOpenDmas     = BMI_MAX_NUM_OF_DMAS;
         p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency        = DEFAULT_dmaCommQLow;
         p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency       = DEFAULT_dmaCommQHigh;
+        p_Fm->p_FmDriverParam->dmaReadBufThresholds.clearEmergency      = DEFAULT_dmaReadIntBufLow;
+        p_Fm->p_FmDriverParam->dmaReadBufThresholds.assertEmergency     = DEFAULT_dmaReadIntBufHigh;
+        p_Fm->p_FmDriverParam->dmaWriteBufThresholds.clearEmergency     = DEFAULT_dmaWriteIntBufLow;
+        p_Fm->p_FmDriverParam->dmaWriteBufThresholds.assertEmergency    = DEFAULT_dmaWriteIntBufHigh;
+        //p_Fm->p_FmDriverParam->dmaStopOnBusError                    = DEFAULT_dmaStopOnBusError;
+        p_Fm->p_FmDriverParam->dmaCacheOverride                     = DEFAULT_cacheOverride;
+        p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = DEFAULT_dmaCamNumOfEntries;
+        p_Fm->p_FmDriverParam->dmaAidOverride                       = DEFAULT_aidOverride;
+        p_Fm->p_FmDriverParam->dmaDbgCntMode                        = DEFAULT_dmaDbgCntMode;
+        p_Fm->p_FmDriverParam->dmaEnEmergency                       = FALSE;
+        p_Fm->p_FmDriverParam->dmaAidMode                           = DEFAULT_aidMode;
+        p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats                  = DEFAULT_axiDbgNumOfBeats;
+        p_Fm->p_FmDriverParam->dmaSosEmergency                      = DEFAULT_dmaSosEmergency;
+        p_Fm->p_FmDriverParam->dmaWatchdog                          = DEFAULT_dmaWatchdog;
+        p_Fm->p_FmDriverParam->thresholds.dispLimit                 = DEFAULT_dispLimit;
+        p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = DEFAULT_prsDispTh;
+        p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = DEFAULT_plcrDispTh;
+        p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = DEFAULT_kgDispTh;
+        p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = DEFAULT_bmiDispTh;
+        p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = DEFAULT_qmiEnqDispTh;
+        p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = DEFAULT_qmiDeqDispTh;
+        p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = DEFAULT_fmCtl1DispTh;
+        p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = DEFAULT_fmCtl2DispTh;
+        p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = FALSE;
     }
     else
 #endif /* FM_NO_GUARANTEED_RESET_VALUES */
     {
+        /* read the values from the registers as they are initialized by the HW with
+         * the required values.
+         */
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg1);
         p_Fm->p_FmStateStruct->totalFifoSize =
             (((tmpReg & BMI_TOTAL_FIFO_SIZE_MASK) >> BMI_CFG1_FIFO_SIZE_SHIFT) + 1) * BMI_FIFO_UNITS;
+
         tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2);
         p_Fm->p_FmStateStruct->totalNumOfTasks =
             (uint8_t)(((tmpReg & BMI_TOTAL_NUM_OF_TASKS_MASK) >> BMI_CFG2_TASKS_SHIFT) + 1);
+
         tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmtr);
         p_Fm->p_FmDriverParam->dmaCommQThresholds.assertEmergency =
             (uint8_t)(tmpReg >> DMA_THRESH_COMMQ_SHIFT);
+
         tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmhy);
         p_Fm->p_FmDriverParam->dmaCommQThresholds.clearEmergency =
             (uint8_t)(tmpReg >> DMA_THRESH_COMMQ_SHIFT);
+
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
+        p_Fm->p_FmDriverParam->dmaCacheOverride                     = (e_FmDmaCacheOverride)((tmpReg & DMA_MODE_CACHE_OR_MASK) >> DMA_MODE_CACHE_OR_SHIFT);
+        p_Fm->p_FmDriverParam->dmaCamNumOfEntries                   = (uint8_t)((((tmpReg & DMA_MODE_CEN_MASK) >> DMA_MODE_CEN_SHIFT) +1)*DMA_CAM_UNITS);
+        p_Fm->p_FmDriverParam->dmaAidOverride                       = (bool)((tmpReg & DMA_MODE_AID_OR)? TRUE:FALSE);
+        p_Fm->p_FmDriverParam->dmaDbgCntMode                        = (e_FmDmaDbgCntMode)((tmpReg & DMA_MODE_DBG_MASK) >> DMA_MODE_DBG_SHIFT);
+        p_Fm->p_FmDriverParam->dmaEnEmergency                       = (bool)((tmpReg & DMA_MODE_EB)? TRUE : FALSE);
+
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_mxd);
+        p_Fm->p_FmDriverParam->thresholds.dispLimit                 = (uint8_t)((tmpReg & FPM_DISP_LIMIT_MASK) << FPM_DISP_LIMIT_SHIFT);
+
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis1);
+        p_Fm->p_FmDriverParam->thresholds.prsDispTh                 = (uint8_t)((tmpReg & FPM_THR1_PRS_MASK ) << FPM_THR1_PRS_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.plcrDispTh                = (uint8_t)((tmpReg & FPM_THR1_KG_MASK ) << FPM_THR1_KG_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.kgDispTh                  = (uint8_t)((tmpReg & FPM_THR1_PLCR_MASK ) << FPM_THR1_PLCR_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.bmiDispTh                 = (uint8_t)((tmpReg & FPM_THR1_BMI_MASK ) << FPM_THR1_BMI_SHIFT);
+
+        tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_dis2);
+        p_Fm->p_FmDriverParam->thresholds.qmiEnqDispTh              = (uint8_t)((tmpReg & FPM_THR2_QMI_ENQ_MASK ) << FPM_THR2_QMI_ENQ_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.qmiDeqDispTh              = (uint8_t)((tmpReg & FPM_THR2_QMI_DEQ_MASK ) << FPM_THR2_QMI_DEQ_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.fmCtl1DispTh              = (uint8_t)((tmpReg & FPM_THR2_FM_CTL1_MASK ) << FPM_THR2_FM_CTL1_SHIFT);
+        p_Fm->p_FmDriverParam->thresholds.fmCtl2DispTh              = (uint8_t)((tmpReg & FPM_THR2_FM_CTL2_MASK ) << FPM_THR2_FM_CTL2_SHIFT);
+
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmsetr);
+        p_Fm->p_FmDriverParam->dmaSosEmergency                        = tmpReg;
+
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmwcr);
+        p_Fm->p_FmDriverParam->dmaWatchdog                          = tmpReg/p_Fm->p_FmStateStruct->fmClkFreq;
+
+        tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmemsr);
+        p_Fm->p_FmDriverParam->dmaEnEmergencySmoother               = (bool)((tmpReg & DMA_EMSR_EMSTR_MASK)? TRUE : FALSE);
+        p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter            = (tmpReg & DMA_EMSR_EMSTR_MASK);
     }
 
-    return p_Fm;
+   return p_Fm;
 }
 
 /**************************************************************************//**
@@ -4162,8 +4156,7 @@ t_Error FM_Init(t_Handle h_Fm)
         return InitGuestMode(p_Fm);
 
 #ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if(1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
-
+    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
         /* if user didn't configured totalFifoSize - (totalFifoSize=0) we configure default
          * according to chip. otherwise, we use user's configuration.
          */
@@ -4204,9 +4197,7 @@ t_Error FM_Init(t_Handle h_Fm)
     if (p_FmDriverParam->resetOnInit)
     {
         t_FMIramRegs    *p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
-#if (DPAA_VERSION == 10)
-        uint32_t        debug_reg;
-#endif
+        uint32_t        tmpReg;
 
         /* write to IRAM first location the debug instruction */
         WRITE_UINT32(p_Iram->iadd, 0);
@@ -4225,18 +4216,13 @@ t_Error FM_Init(t_Handle h_Fm)
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
         XX_UDelay(100);
 
-/* FIXME: Temporary workaround, since this is not currently working on hw or simulator
- *        This FMan debug register might be in another location or absent
- *        This register access is just a verification and is not mandatory */
-#if (DPAA_VERSION == 10)
         /* verify breakpoint debug status register */
-        debug_reg = GET_UINT32(*(uint32_t *)UINT_TO_PTR(p_Fm->baseAddr + FM_DEBUG_STATUS_REGISTER_OFFSET));
-        if(!debug_reg)
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Invalid debug status register value = 0"));
-#endif
+        tmpReg = GET_UINT32(*(uint32_t *)UINT_TO_PTR(p_Fm->baseAddr + FM_DEBUG_STATUS_REGISTER_OFFSET));
+        if (!tmpReg)
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid debug status register value is '0'"));
 
         /*************************************/
-        /* Load FMan-Controller code to Iram */
+        /* Load FMan-Controller code to IRAM */
         /*************************************/
         if (ClearIRam(p_Fm) != E_OK)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
@@ -4247,7 +4233,18 @@ t_Error FM_Init(t_Handle h_Fm)
 
         /* reset FMAN again to start the microcode */
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
-        XX_UDelay(1000);
+        CORE_MemoryBarrier();
+        XX_UDelay(100);
+
+        if (GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gs) & QMI_GS_HALT_NOT_BUSY)
+        {
+            tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
+            /* clear tmpReg event bits in order not to clear standing events */
+            tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg | FPM_EV_MASK_RELEASE_FM);
+            CORE_MemoryBarrier();
+            XX_UDelay(100);
+        }
     }
     else
     {
@@ -4257,11 +4254,22 @@ t_Error FM_Init(t_Handle h_Fm)
     if (p_FmDriverParam->resetOnInit)
     {
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
+        CORE_MemoryBarrier();
         XX_UDelay(100);
+
+        if (GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gs) & QMI_GS_HALT_NOT_BUSY)
+        {
+            uint32_t tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
+            /* clear tmpReg event bits in order not to clear standing events */
+            tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
+            WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg | FPM_EV_MASK_RELEASE_FM);
+            CORE_MemoryBarrier();
+            XX_UDelay(100);
+        }
     }
 
     /*************************************/
-    /* Load FMan-Controller code to Iram */
+    /* Load FMan-Controller code to IRAM */
     /*************************************/
     if (ClearIRam(p_Fm) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
@@ -4355,7 +4363,7 @@ t_Error FM_Init(t_Handle h_Fm)
     }
 
     err = XX_IpcRegisterMsgHandler(p_Fm->fmModuleName, FmHandleIpcMsgCB, p_Fm, FM_IPC_MAX_REPLY_SIZE);
-    if(err)
+    if (err)
     {
         FreeInitResources(p_Fm);
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -4370,7 +4378,7 @@ t_Error FM_Init(t_Handle h_Fm)
 
     if (p_Fm->p_FmStateStruct->errIrq != NO_IRQ)
     {
-        XX_SetIntr(p_Fm->p_FmStateStruct->errIrq, ErrorIsrCB, p_Fm);
+        XX_SetIntr(p_Fm->p_FmStateStruct->errIrq, (void (*) (t_Handle))FM_ErrorIsr, p_Fm);
         XX_EnableIntr(p_Fm->p_FmStateStruct->errIrq);
     }
 
@@ -4579,6 +4587,9 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
+#if (DPAA_VERSION >= 11)
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
+#endif
     p_Fm->p_FmDriverParam->dmaAxiDbgNumOfBeats = axiDbgNumOfBeats;
 
     return E_OK;
@@ -4630,7 +4641,6 @@ t_Error FM_ConfigDmaEmergency(t_Handle h_Fm, t_FmDmaEmergency *p_Emergency)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
-
     p_Fm->p_FmDriverParam->dmaEnEmergency = TRUE;
     memcpy(&p_Fm->p_FmDriverParam->dmaEmergency, p_Emergency, sizeof(t_FmDmaEmergency));
 
@@ -4645,9 +4655,6 @@ t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt)
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if(!p_Fm->p_FmDriverParam->dmaEnEmergency)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("FM_ConfigEnDmaEmergencySmoother may be called only after FM_ConfigEnDmaEmergency"));
-
     p_Fm->p_FmDriverParam->dmaEnEmergencySmoother = TRUE;
     p_Fm->p_FmDriverParam->dmaEmergencySwitchCounter = emergencyCnt;
 
@@ -4750,7 +4757,7 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     GET_EXCEPTION_FLAG(bitMask, exception);
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_Fm->p_FmDriverParam->userSetExceptions |= bitMask;
@@ -4820,6 +4827,7 @@ t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergenc
 }
 
 t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
+
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
@@ -4827,9 +4835,9 @@ t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDma
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
-
+#if (DPAA_VERSION >= 11)
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
+#endif
     memcpy(&p_Fm->p_FmDriverParam->dmaWriteBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
 
     return E_OK;
@@ -4856,9 +4864,9 @@ t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaT
     SANITY_CHECK_RETURN_ERROR(p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
-
+#if (DPAA_VERSION >= 11)
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
+#endif
     memcpy(&p_Fm->p_FmDriverParam->dmaReadBufThresholds, p_FmDmaThresholds, sizeof(t_FmDmaThresholds));
 
     return E_OK;
@@ -4883,15 +4891,15 @@ t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
 /****************************************************/
 void FM_EventIsr(t_Handle h_Fm)
 {
-#define FM_M_CALL_1G_MAC_ISR(_id)   \
-    {                                   \
+#define FM_M_CALL_1G_MAC_ISR(_id)    \
+    {                                \
         if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].guestId)    \
             SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id), pending);                 \
         else                                                                                        \
             p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_1G_MAC0+_id)].h_SrcHandle);\
     }
 #define FM_M_CALL_10G_MAC_ISR(_id)   \
-    {                                   \
+    {                                \
         if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id)].guestId)    \
             SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_10G_MAC0+_id), pending);                 \
         else                                                                                         \
@@ -4906,7 +4914,9 @@ void FM_EventIsr(t_Handle h_Fm)
 
     /* normal interrupts */
     pending = GET_UINT32(p_Fm->p_FmFpmRegs->fm_npi);
-    ASSERT_COND(pending);
+    if (!pending)
+        return;
+
     if (pending & INTR_EN_QMI)
         QmiEvent(p_Fm);
     if (pending & INTR_EN_PRS)
@@ -4961,7 +4971,6 @@ void FM_EventIsr(t_Handle h_Fm)
             /* SendIpcIsr(p_Fm, e_FM_EV_FMAN_CTRL_1, pending); */
         else
             p_Fm->fmanCtrlIntr[1].f_Isr(p_Fm->fmanCtrlIntr[1].h_SrcHandle, event);
-
     }
     if (pending & INTR_EN_REV2)
     {
@@ -4998,17 +5007,82 @@ void FM_EventIsr(t_Handle h_Fm)
 
 t_Error FM_ErrorIsr(t_Handle h_Fm)
 {
+#define FM_M_CALL_1G_MAC_ERR_ISR(_id)   \
+    {                                   \
+       if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id)].guestId) \
+            SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id), pending);             \
+       else                                                                                         \
+            p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_1G_MAC0+_id)].h_SrcHandle);\
+    }
+#define FM_M_CALL_10G_MAC_ERR_ISR(_id)   \
+    {                                    \
+       if (p_Fm->guestId != p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id)].guestId) \
+            SendIpcIsr(p_Fm, (e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id), pending);             \
+       else                                                                                          \
+            p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id)].f_Isr(p_Fm->intrMng[(e_FmInterModuleEvent)(e_FM_EV_ERR_10G_MAC0+_id)].h_SrcHandle);\
+    }
     t_Fm                    *p_Fm = (t_Fm*)h_Fm;
+    uint32_t                pending;
 
     SANITY_CHECK_RETURN_ERROR(h_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     /* error interrupts */
-    if (GET_UINT32(p_Fm->p_FmFpmRegs->fm_epi) == 0)
+    pending = GET_UINT32(p_Fm->p_FmFpmRegs->fm_epi);
+    if (!pending)
         return ERROR_CODE(E_EMPTY);
 
-    ErrorIsrCB(p_Fm);
+    if (pending & ERR_INTR_EN_BMI)
+        BmiErrEvent(p_Fm);
+    if (pending & ERR_INTR_EN_QMI)
+        QmiErrEvent(p_Fm);
+    if (pending & ERR_INTR_EN_FPM)
+        FpmErrEvent(p_Fm);
+    if (pending & ERR_INTR_EN_DMA)
+        DmaErrEvent(p_Fm);
+    if (pending & ERR_INTR_EN_IRAM)
+        IramErrIntr(p_Fm);
+    if (pending & ERR_INTR_EN_MURAM)
+        MuramErrIntr(p_Fm);
+    if (pending & ERR_INTR_EN_PRS)
+        p_Fm->intrMng[e_FM_EV_ERR_PRS].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PRS].h_SrcHandle);
+    if (pending & ERR_INTR_EN_PLCR)
+        p_Fm->intrMng[e_FM_EV_ERR_PLCR].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_PLCR].h_SrcHandle);
+    if (pending & ERR_INTR_EN_KG)
+        p_Fm->intrMng[e_FM_EV_ERR_KG].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_KG].h_SrcHandle);
+
+    /* MAC events may belong to different partitions */
+    if (pending & ERR_INTR_EN_1G_MAC0)
+        FM_M_CALL_1G_MAC_ERR_ISR(0);
+    if (pending & ERR_INTR_EN_1G_MAC1)
+        FM_M_CALL_1G_MAC_ERR_ISR(1);
+    if (pending & ERR_INTR_EN_1G_MAC2)
+        FM_M_CALL_1G_MAC_ERR_ISR(2);
+    if (pending & ERR_INTR_EN_1G_MAC3)
+        FM_M_CALL_1G_MAC_ERR_ISR(3);
+    if (pending & ERR_INTR_EN_1G_MAC4)
+        FM_M_CALL_1G_MAC_ERR_ISR(4);
+    if (pending & ERR_INTR_EN_1G_MAC5)
+        FM_M_CALL_1G_MAC_ERR_ISR(5);
+    if (pending & ERR_INTR_EN_1G_MAC6)
+        FM_M_CALL_1G_MAC_ERR_ISR(6);
+    if (pending & ERR_INTR_EN_1G_MAC7)
+        FM_M_CALL_1G_MAC_ERR_ISR(7);
+    if (pending & ERR_INTR_EN_10G_MAC0)
+        FM_M_CALL_10G_MAC_ERR_ISR(0);
+    if (pending & ERR_INTR_EN_10G_MAC1)
+        FM_M_CALL_10G_MAC_ERR_ISR(1);
+
+#ifdef FM_MACSEC_SUPPORT
+    if (pending & ERR_INTR_EN_MACSEC_MAC0)
+    {
+       if (p_Fm->guestId != p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].guestId)
+            SendIpcIsr(p_Fm, e_FM_EV_ERR_MACSEC_MAC0, pending);
+        else
+            p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].f_Isr(p_Fm->intrMng[e_FM_EV_ERR_MACSEC_MAC0].h_SrcHandle);
+    }
+#endif /* FM_MACSEC_SUPPORT */
 
     return E_OK;
 }
@@ -5033,7 +5107,7 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
     if (sum != 100)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Sum of ports bandwidth differ from 100%"));
 
-    /* find highest precent */
+    /* find highest percent */
     for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
     {
         if (p_PortsBandwidth->portsBandwidths[i].bandwidth > maxPercent)
@@ -5061,7 +5135,7 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
         shift = (uint8_t)(32-4*(relativePortId+1));
 
 
-        if(weight > 1)
+        if (weight > 1)
             /* Add this port to tmpReg */
             /* (each 8 ports result in one register)*/
             tmpRegs[hardwarePortId/8] |= ((weight-1) << shift);
@@ -5080,6 +5154,7 @@ t_Error FM_EnableRamsEcc(t_Handle h_Fm)
     uint32_t    tmpReg;
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    /*SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);*/
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -5127,6 +5202,7 @@ t_Error FM_DisableRamsEcc(t_Handle h_Fm)
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_HANDLE);
+    /*SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);*/
 
     if (p_Fm->guestId != NCSW_MASTER_ID)
     {
@@ -5188,18 +5264,18 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
     SANITY_CHECK_RETURN_ERROR((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
     GET_EXCEPTION_FLAG(bitMask, exception);
-    if(bitMask)
+    if (bitMask)
     {
         if (enable)
             p_Fm->p_FmStateStruct->exceptions |= bitMask;
         else
             p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
 
-        switch(exception)
+        switch (exception)
         {
              case (e_FM_EX_DMA_BUS_ERROR):
                 tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-                if(enable)
+                if (enable)
                     tmpReg |= DMA_MODE_BER;
                 else
                     tmpReg &= ~DMA_MODE_BER;
@@ -5210,35 +5286,35 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
              case (e_FM_EX_DMA_SYSTEM_WRITE_ECC):
              case (e_FM_EX_DMA_FM_WRITE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr);
-                if(enable)
+                if (enable)
                     tmpReg |= DMA_MODE_ECC;
                 else
                     tmpReg &= ~DMA_MODE_ECC;
                 WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, tmpReg);
                 break;
              case (e_FM_EX_FPM_STALL_ON_TASKS):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
-                if(enable)
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
+                if (enable)
                     tmpReg |= FPM_EV_MASK_STALL_EN;
                 else
                     tmpReg &= ~FPM_EV_MASK_STALL_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg);
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg);
                 break;
              case (e_FM_EX_FPM_SINGLE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
-                if(enable)
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
+                if (enable)
                     tmpReg |= FPM_EV_MASK_SINGLE_ECC_EN;
                 else
                     tmpReg &= ~FPM_EV_MASK_SINGLE_ECC_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg);
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg);
                 break;
             case ( e_FM_EX_FPM_DOUBLE_ECC):
-                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
-                if(enable)
+                tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
+                if (enable)
                     tmpReg |= FPM_EV_MASK_DOUBLE_ECC_EN;
                 else
                     tmpReg &= ~FPM_EV_MASK_DOUBLE_ECC_EN;
-                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg);
+                WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg);
                 break;
             case ( e_FM_EX_QMI_SINGLE_ECC):
 #if defined(FM_QMI_NO_ECC_EXCEPTIONS) || defined(FM_QMI_NO_SINGLE_ECC_EXCEPTION)
@@ -5250,7 +5326,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_ien);
-                if(enable)
+                if (enable)
                     tmpReg |= QMI_INTR_EN_SINGLE_ECC;
                 else
                     tmpReg &= ~QMI_INTR_EN_SINGLE_ECC;
@@ -5265,7 +5341,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 }
 #endif   /* FM_QMI_NO_ECC_EXCEPTIONS */
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-                if(enable)
+                if (enable)
                     tmpReg |= QMI_ERR_INTR_EN_DOUBLE_ECC;
                 else
                     tmpReg &= ~QMI_ERR_INTR_EN_DOUBLE_ECC;
@@ -5273,7 +5349,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID):
                 tmpReg = GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_eien);
-                if(enable)
+                if (enable)
                     tmpReg |= QMI_ERR_INTR_EN_DEQ_FROM_DEF;
                 else
                     tmpReg &= ~QMI_ERR_INTR_EN_DEQ_FROM_DEF;
@@ -5281,7 +5357,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_BMI_LIST_RAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= BMI_ERR_INTR_EN_LIST_RAM_ECC;
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_LIST_RAM_ECC;
@@ -5289,7 +5365,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_BMI_STORAGE_PROFILE_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_STORAGE_PROFILE_ECC;
@@ -5297,7 +5373,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_BMI_STATISTICS_RAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-                if(enable)
+                if (enable)
                     tmpReg |= BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
                 else
                     tmpReg &= ~BMI_ERR_INTR_EN_STATISTICS_RAM_ECC;
@@ -5305,7 +5381,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                 break;
              case (e_FM_EX_BMI_DISPATCH_RAM_ECC):
                tmpReg = GET_UINT32(p_Fm->p_FmBmiRegs->fmbm_ier);
-               if(enable)
+               if (enable)
                {
 #ifdef FM_NO_DISPATCH_RAM_ECC
                    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
@@ -5322,7 +5398,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
                break;
              case (e_FM_EX_IRAM_ECC):
                  tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
-                if(enable)
+                if (enable)
                 {
                     /* enable ECC if not enabled */
                     FmEnableRamsEcc(p_Fm);
@@ -5340,7 +5416,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
 
              case (e_FM_EX_MURAM_ECC):
                 tmpReg = GET_UINT32(p_Fm->p_FmFpmRegs->fm_rie);
-                if(enable)
+                if (enable)
                 {
                     /* enable ECC if not enabled */
                     FmEnableRamsEcc(p_Fm);
@@ -5431,9 +5507,9 @@ t_Error FM_GetFmanCtrlCodeRevision(t_Handle h_Fm, t_FmCtrlCodeRevisionInfo *p_Re
 
 uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
 {
-    t_Fm                *p_Fm = (t_Fm*)h_Fm;
-    t_Error             err;
-    uint32_t            counterValue;
+    t_Fm        *p_Fm = (t_Fm*)h_Fm;
+    t_Error     err;
+    uint32_t    counterValue;
 
     SANITY_CHECK_RETURN_VALUE(p_Fm, E_INVALID_HANDLE, 0);
     SANITY_CHECK_RETURN_VALUE(!p_Fm->p_FmDriverParam, E_INVALID_STATE, 0);
@@ -5459,26 +5535,37 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
                                      NULL,
                                      NULL);
         if (err != E_OK)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+        {
+            REPORT_ERROR(MAJOR, err, NO_MSG);
+            return 0;
+        }
         if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
-        memcpy((uint8_t*)&outCounter, reply.replyBody, sizeof(uint32_t));
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
+            return 0;
+        }
 
+        memcpy((uint8_t*)&outCounter, reply.replyBody, sizeof(uint32_t));
         return outCounter;
     }
     else if (!p_Fm->baseAddr)
-        RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                     ("Either IPC or 'baseAddress' is required!"));
+    {
+        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Either IPC or 'baseAddress' is required!"));
+        return 0;
+    }
 
     /* When applicable (when there is an 'enable counters' bit,
     check that counters are enabled */
-    switch(counter)
+    switch (counter)
     {
         case (e_FM_COUNTERS_DEQ_1):
         case (e_FM_COUNTERS_DEQ_2):
         case (e_FM_COUNTERS_DEQ_3):
-              if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
+            if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+            {
+                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
+                return 0;
+            }
         case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
         case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
         case (e_FM_COUNTERS_DEQ_0):
@@ -5486,14 +5573,17 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
         case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
         case (e_FM_COUNTERS_DEQ_FROM_FD):
         case (e_FM_COUNTERS_DEQ_CONFIRM):
-            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+            if (!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+            {
+                REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter was not enabled"));
+                return 0;
+            }
             break;
         default:
             break;
     }
 
-    switch(counter)
+    switch (counter)
     {
         case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
             return GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc);
@@ -5519,11 +5609,10 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
     }
     /* should never get here */
     ASSERT_COND(FALSE);
-
     return 0;
 }
 
-t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
+t_Error FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
 {
     t_Fm *p_Fm = (t_Fm*)h_Fm;
 
@@ -5533,12 +5622,12 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
 
     /* When applicable (when there is an 'enable counters' bit,
     check that counters are enabled */
-    switch(counter)
+    switch (counter)
     {
         case (e_FM_COUNTERS_DEQ_1):
         case (e_FM_COUNTERS_DEQ_2):
         case (e_FM_COUNTERS_DEQ_3):
-             if(p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+             if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
                  RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
         case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
         case (e_FM_COUNTERS_DEQ_TOTAL_FRAME):
@@ -5547,7 +5636,7 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
         case (e_FM_COUNTERS_DEQ_FROM_CONTEXT):
         case (e_FM_COUNTERS_DEQ_FROM_FD):
         case (e_FM_COUNTERS_DEQ_CONFIRM):
-            if(!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
+            if (!(GET_UINT32(p_Fm->p_FmQmiRegs->fmqm_gc) & QMI_CFG_EN_COUNTERS))
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Requested counter was not enabled"));
             break;
         default:
@@ -5555,7 +5644,7 @@ t_Error  FM_ModifyCounter(t_Handle h_Fm, e_FmCounters counter, uint32_t val)
     }
 
     /* Set counter */
-    switch(counter)
+    switch (counter)
     {
         case (e_FM_COUNTERS_ENQ_TOTAL_FRAME):
             WRITE_UINT32(p_Fm->p_FmQmiRegs->fmqm_etfc, val);
@@ -5605,7 +5694,7 @@ void FM_SetDmaEmergency(t_Handle h_Fm, e_FmDmaMuramPort muramPort, bool enable)
 
     bitMask = (uint32_t)((muramPort==e_FM_DMA_MURAM_PORT_WRITE) ? DMA_MODE_EMERGENCY_WRITE : DMA_MODE_EMERGENCY_READ);
 
-    if(enable)
+    if (enable)
         WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) | bitMask);
     else /* disable */
         WRITE_UINT32(p_Fm->p_FmDmaRegs->fmdmmr, GET_UINT32(p_Fm->p_FmDmaRegs->fmdmmr) & ~bitMask);
@@ -5705,10 +5794,10 @@ void FM_Resume(t_Handle h_Fm)
     SANITY_CHECK_RETURN(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
     SANITY_CHECK_RETURN((p_Fm->guestId == NCSW_MASTER_ID), E_NOT_SUPPORTED);
 
-    tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_em);
+    tmpReg  = GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee);
     /* clear tmpReg event bits in order not to clear standing events */
     tmpReg &= ~(FPM_EV_MASK_DOUBLE_ECC | FPM_EV_MASK_STALL | FPM_EV_MASK_SINGLE_ECC);
-    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_em, tmpReg | FPM_EV_MASK_RELEASE_FM);
+    WRITE_UINT32(p_Fm->p_FmFpmRegs->fmfp_ee, tmpReg | FPM_EV_MASK_RELEASE_FM);
 }
 
 t_Error FM_GetSpecialOperationCoding(t_Handle               h_Fm,
@@ -5922,7 +6011,7 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_rstc);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_cld);
     DUMP_VAR(p_Fm->p_FmFpmRegs,fm_npi);
-    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_em);
+    DUMP_VAR(p_Fm->p_FmFpmRegs,fmfp_ee);
 
     DUMP_TITLE(&p_Fm->p_FmFpmRegs->fmfp_cev, ("fmfp_cev"));
     DUMP_SUBSTRUCT_ARRAY(i, 4)
@@ -5983,7 +6072,6 @@ t_Error FM_DumpRegs(t_Handle h_Fm)
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ien);
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_if);
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_gs);
-    DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_ts);
     DUMP_VAR(p_Fm->p_FmQmiRegs,fmqm_etfc);
 
     return E_OK;
@@ -6003,7 +6091,7 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
 
-    switch(exception)
+    switch (exception)
     {
         case e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
             if (!(p_Fm->p_FmStateStruct->exceptions & FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID))
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
index 6522bda..c6c3df2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.h
@@ -72,7 +72,7 @@
 #define FM_EX_DMA_SINGLE_PORT_ECC           0x00008000
 
 #define GET_EXCEPTION_FLAG(bitMask, exception)              \
-switch(exception){                                          \
+switch (exception){                                         \
     case e_FM_EX_DMA_BUS_ERROR:                             \
         bitMask = FM_EX_DMA_BUS_ERROR; break;               \
     case e_FM_EX_DMA_SINGLE_PORT_ECC:                       \
@@ -110,6 +110,46 @@ switch(exception){                                          \
     default: bitMask = 0;break;                             \
 }
 
+#define GET_FM_MODULE_EVENT(_mod, _id, _intrType, _event)                                           \
+    switch (_mod) {                                                                                 \
+        case e_FM_MOD_PRS:                                                                          \
+            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS : e_FM_EV_PRS;        \
+            break;                                                                                  \
+        case e_FM_MOD_KG:                                                                           \
+            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG : e_FM_EV_DUMMY_LAST;  \
+            break;                                                                                  \
+        case e_FM_MOD_PLCR:                                                                         \
+            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR : e_FM_EV_PLCR;      \
+            break;                                                                                  \
+        case e_FM_MOD_TMR:                                                                          \
+            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_TMR;     \
+            break;                                                                                  \
+        case e_FM_MOD_10G_MAC:                                                                      \
+            if (_id >= FM_MAX_NUM_OF_10G_MACS) _event = e_FM_EV_DUMMY_LAST;                         \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? (e_FM_EV_ERR_10G_MAC0 + _id) : (e_FM_EV_10G_MAC0 + _id); \
+            break;                                                                                  \
+        case e_FM_MOD_1G_MAC:                                                                       \
+            if (_id >= FM_MAX_NUM_OF_1G_MACS) _event = e_FM_EV_DUMMY_LAST;                          \
+            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? (e_FM_EV_ERR_1G_MAC0 + _id) : (e_FM_EV_1G_MAC0 + _id); \
+            break;                                                                                  \
+        case e_FM_MOD_MACSEC:                                                                       \
+            switch (_id){                                                                           \
+                 case (0): _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_MACSEC_MAC0:e_FM_EV_MACSEC_MAC0; \
+                 break;                                                                             \
+                 }                                                                                  \
+            break;                                                                                  \
+        case e_FM_MOD_FMAN_CTRL:                                                                    \
+            if (_intrType == e_FM_INTR_TYPE_ERR) _event = e_FM_EV_DUMMY_LAST;                       \
+            else _event = (e_FM_EV_FMAN_CTRL_0 + _id);                                              \
+            break;                                                                                  \
+        default: _event = e_FM_EV_DUMMY_LAST;                                                       \
+        break;                                                                                      \
+    }
+
 /**************************************************************************//**
  @Description       defaults
 *//***************************************************************************/
@@ -133,7 +173,7 @@ switch(exception){                                          \
 
 #define DEFAULT_totalFifoSize(major)       (((major == 2) || (major == 5))  ?   \
                                             (100*KILOBYTE):((major == 6) ?      \
-                                            (288*KILOBYTE):((major == 4) ? (48*KILOBYTE):(122*KILOBYTE))))
+                                            (288*KILOBYTE):((major == 4) ? (46*KILOBYTE):(122*KILOBYTE))))
 
 #define DEFAULT_eccEnable                   FALSE
 #define DEFAULT_dispLimit                   0
@@ -180,8 +220,6 @@ switch(exception){                                          \
  @Collection   Defines used for enabling/disabling FM interrupts
  @{
 *//***************************************************************************/
-typedef uint32_t t_FmBlockErrIntrEnable;
-
 #define ERR_INTR_EN_DMA         0x00010000
 #define ERR_INTR_EN_FPM         0x80000000
 #define ERR_INTR_EN_BMI         0x00800000
@@ -203,8 +241,6 @@ typedef uint32_t t_FmBlockErrIntrEnable;
 #define ERR_INTR_EN_1G_MAC7     0x00000080
 #define ERR_INTR_EN_MACSEC_MAC0 0x00000001
 
-typedef uint32_t t_FmBlockIntrEnable;
-
 #define INTR_EN_QMI             0x40000000
 #define INTR_EN_PRS             0x20000000
 #define INTR_EN_PLCR            0x08000000
@@ -284,7 +320,7 @@ typedef _Packed struct
     volatile uint32_t   fm_cld;         /**< FM Classifier Debug */
     volatile uint32_t   fm_npi;         /**< FM Normal Pending Interrupts  */
     volatile uint32_t   fmfp_exte;      /**< FPM External Requests Enable */
-    volatile uint32_t   fmfp_em;        /**< FPM Event & Mask */
+    volatile uint32_t   fmfp_ee;        /**< FPM Event & Enable */
     volatile uint32_t   fmfp_cev[4];    /**< FPM CPU Event 1-4 */
     volatile uint8_t    res4[16];       /**< reserved */
     volatile uint32_t   fmfp_ps[0x40];  /**< FPM Port Status */
@@ -321,7 +357,7 @@ typedef _Packed struct
 typedef _Packed struct
 {
     volatile uint32_t   fmqm_gc;        /**<  General Configuration Register */
-    volatile uint32_t   Reserved0;
+    volatile uint32_t   reserved0;
     volatile uint32_t   fmqm_eie;       /**<  Error Interrupt Event Register */
     volatile uint32_t   fmqm_eien;      /**<  Error Interrupt Enable Register */
     volatile uint32_t   fmqm_eif;       /**<  Error Interrupt Force Register */
@@ -329,7 +365,7 @@ typedef _Packed struct
     volatile uint32_t   fmqm_ien;       /**<  Interrupt Enable Register */
     volatile uint32_t   fmqm_if;        /**<  Interrupt Force Register */
     volatile uint32_t   fmqm_gs;        /**<  Global Status Register */
-    volatile uint32_t   fmqm_ts;        /**<  Task Status Register */
+    volatile uint32_t   reserved1;
     volatile uint32_t   fmqm_etfc;      /**<  Enqueue Total Frame Counter */
     volatile uint32_t   fmqm_dtfc;      /**<  Dequeue Total Frame Counter */
     volatile uint32_t   fmqm_dc0;       /**<  Dequeue Counter 0 */
@@ -340,15 +376,15 @@ typedef _Packed struct
     volatile uint32_t   fmqm_dfcc;      /**<  Dequeue FQID from Context Counter */
     volatile uint32_t   fmqm_dffc;      /**<  Dequeue FQID from FD Counter */
     volatile uint32_t   fmqm_dcc;       /**<  Dequeue Confirm Counter */
-    volatile uint32_t   Reserved1a[7];
+    volatile uint32_t   reserved1a[7];
     volatile uint32_t   fmqm_tapc;      /**<  Tnum Aging Period Control */
     volatile uint32_t   fmqm_dmcvc;     /**<  Dequeue MAC Command Valid Counter */
     volatile uint32_t   fmqm_difdcc;    /**<  Dequeue Invalid FD Command Counter */
     volatile uint32_t   fmqm_da1v;      /**<  Dequeue A1 Valid Counter */
-    volatile uint32_t   Reserved1b;
+    volatile uint32_t   reserved1b;
     volatile uint32_t   fmqm_dtc;       /**<  0x0080 Debug Trap Counter */
     volatile uint32_t   fmqm_efddd;     /**<  0x0084 Enqueue Frame Descriptor Dynamic Debug */
-    volatile uint32_t   Reserved3[2];
+    volatile uint32_t   reserved3[2];
     _Packed struct {
         volatile uint32_t   fmqm_dtcfg1;    /**<  0x0090 Debug Trap Configuration 1 Register */
         volatile uint32_t   fmqm_dtval1;    /**<  Debug Trap Value 1 Register */
@@ -357,7 +393,7 @@ typedef _Packed struct
         volatile uint32_t   fmqm_dtcfg2;    /**<  Debug Trap Configuration 2 Register */
         volatile uint32_t   fmqm_dtval2;    /**<  Debug Trap Value 2 Register */
         volatile uint32_t   fmqm_dtm2;      /**<  Debug Trap Mask 2 Register */
-        volatile uint32_t   Reserved1;
+        volatile uint32_t   reserved1;
     } _PackedType dbgTraps[NUM_OF_DBG_TRAPS];
 } _PackedType t_FmQmiRegs;
 
@@ -449,11 +485,16 @@ typedef _Packed struct t_FmTrbRegs
 #define DMA_MODE_AID_OR                     0x20000000
 #define DMA_MODE_SBER                       0x10000000
 #define DMA_MODE_BER                        0x00200000
+#define DMA_MODE_EB                         0x00100000
 #define DMA_MODE_ECC                        0x00000020
 #define DMA_MODE_PRIVILEGE_PROT             0x00001000
 #define DMA_MODE_SECURE_PROT                0x00000800
 #define DMA_MODE_EMERGENCY_READ             0x00080000
 #define DMA_MODE_EMERGENCY_WRITE            0x00040000
+#define DMA_MODE_CACHE_OR_MASK              0xC0000000
+#define DMA_MODE_CEN_MASK                   0x0000E000
+#define DMA_MODE_DBG_MASK                   0x00000380
+
 
 #define DMA_TRANSFER_PORTID_MASK            0xFF000000
 #define DMA_TRANSFER_TNUM_MASK              0x00FF0000
@@ -486,6 +527,8 @@ typedef _Packed struct t_FmTrbRegs
 
 #define FM_LIODN_BASE_MASK                  0x00000FFF
 
+#define DMA_EMSR_EMSTR_MASK                 0x0000FFFF
+
 /* shifts */
 #define DMA_MODE_CACHE_OR_SHIFT             30
 #define DMA_MODE_BUS_PRI_SHIFT              16
@@ -496,7 +539,7 @@ typedef _Packed struct t_FmTrbRegs
 #define DMA_MODE_EMERGENCY_LEVEL_SHIFT      6
 #define DMA_MODE_AID_MODE_SHIFT             4
 #define DMA_MODE_MAX_AXI_DBG_NUM_OF_BEATS   16
-#define DMA_MODE_MAX_CAM_NUM_OF_ENTRIES     32
+#define DMA_MODE_MAX_CAM_NUM_OF_ENTRIES     64
 
 #define DMA_THRESH_COMMQ_SHIFT              24
 #define DMA_THRESH_READ_INT_BUF_SHIFT       16
@@ -558,13 +601,28 @@ typedef _Packed struct t_FmTrbRegs
 #define FPM_PS_FM_CTL_SEL_MASK          (FPM_PS_FM_CTL1_SEL | FPM_PS_FM_CTL2_SEL)
 
 #define FPM_RSTC_FM_RESET               0x80000000
-#define FPM_RSTC_10G0_RESET             0x04000000
 #define FPM_RSTC_1G0_RESET              0x40000000
 #define FPM_RSTC_1G1_RESET              0x20000000
 #define FPM_RSTC_1G2_RESET              0x10000000
 #define FPM_RSTC_1G3_RESET              0x08000000
+#define FPM_RSTC_10G0_RESET             0x04000000
 #define FPM_RSTC_1G4_RESET              0x02000000
+#define FPM_RSTC_1G5_RESET              0x01000000
+#define FPM_RSTC_1G6_RESET              0x00800000
+#define FPM_RSTC_1G7_RESET              0x00400000
+#define FPM_RSTC_10G1_RESET             0x00200000
+
 
+#define FPM_DISP_LIMIT_MASK             0x1F000000
+#define FPM_THR1_PRS_MASK               0xFF000000
+#define FPM_THR1_KG_MASK                0x00FF0000
+#define FPM_THR1_PLCR_MASK              0x0000FF00
+#define FPM_THR1_BMI_MASK               0x000000FF
+
+#define FPM_THR2_QMI_ENQ_MASK           0xFF000000
+#define FPM_THR2_QMI_DEQ_MASK           0x000000FF
+#define FPM_THR2_FM_CTL1_MASK           0x00FF0000
+#define FPM_THR2_FM_CTL2_MASK           0x0000FF00
 
 /* shifts */
 #define FPM_DISP_LIMIT_SHIFT            24
@@ -649,6 +707,8 @@ typedef _Packed struct t_FmTrbRegs
 #define QMI_CFG_DEQ_MASK                0x0000003F
 #define QMI_CFG_ENQ_MASK                0x00003F00
 
+#define QMI_GS_HALT_NOT_BUSY            0x00000002
+
 #define QMI_ERR_INTR_EN_DOUBLE_ECC      0x80000000
 #define QMI_ERR_INTR_EN_DEQ_FROM_DEF    0x40000000
 #define QMI_INTR_EN_SINGLE_ECC          0x80000000
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
index 6a29d6a..12c7098 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/inc/fm_common.h
@@ -118,47 +118,6 @@ typedef enum e_FmInterModuleEvent
 } e_FmInterModuleEvent;
 
 
-#define GET_FM_MODULE_EVENT(_mod, _id, _intrType, _event)                                           \
-    switch(_mod) {                                                                                  \
-        case e_FM_MOD_PRS:                                                                          \
-            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
-            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PRS : e_FM_EV_PRS;        \
-            break;                                                                                  \
-        case e_FM_MOD_KG:                                                                           \
-            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
-            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_KG : e_FM_EV_DUMMY_LAST;  \
-            break;                                                                                  \
-        case e_FM_MOD_PLCR:                                                                         \
-            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
-            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_PLCR : e_FM_EV_PLCR;      \
-            break;                                                                                  \
-        case e_FM_MOD_TMR:                                                                          \
-            if (_id) _event = e_FM_EV_DUMMY_LAST;                                                   \
-            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_DUMMY_LAST : e_FM_EV_TMR;     \
-            break;                                                                                  \
-        case e_FM_MOD_10G_MAC:                                                                      \
-            if (_id >= FM_MAX_NUM_OF_10G_MACS) _event = e_FM_EV_DUMMY_LAST;                         \
-            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? (e_FM_EV_ERR_10G_MAC0 + _id) : (e_FM_EV_10G_MAC0 + _id); \
-            break;                                                                                  \
-        case e_FM_MOD_1G_MAC:                                                                       \
-            if (_id >= FM_MAX_NUM_OF_1G_MACS) _event = e_FM_EV_DUMMY_LAST;                          \
-            else _event = (_intrType == e_FM_INTR_TYPE_ERR) ? (e_FM_EV_ERR_1G_MAC0 + _id) : (e_FM_EV_1G_MAC0 + _id); \
-            break;                                                                                  \
-        case e_FM_MOD_MACSEC:                                                                       \
-            switch(_id){                                                                            \
-                 case(0): _event = (_intrType == e_FM_INTR_TYPE_ERR) ? e_FM_EV_ERR_MACSEC_MAC0:e_FM_EV_MACSEC_MAC0; \
-                 break;                                                                             \
-                 }                                                                                  \
-            break;                                                                                  \
-        case e_FM_MOD_FMAN_CTRL:                                                                    \
-            if (_intrType == e_FM_INTR_TYPE_ERR) _event = e_FM_EV_DUMMY_LAST;                       \
-            else _event = (e_FM_EV_FMAN_CTRL_0 + _id);                                              \
-            break;                                                                                  \
-        default: _event = e_FM_EV_DUMMY_LAST;                                                       \
-        break;                                                                                      \
-    }
-
-
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
@@ -408,6 +367,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define NIA_FM_CTL_AC_POST_BMI_ENQ_ORR          0x00000014
 #define NIA_FM_CTL_AC_POST_BMI_ENQ              0x00000022
 #define NIA_FM_CTL_AC_PRE_CC                    0x00000020
+#define NIA_FM_CTL_AC_POST_TX                   0x00000024
 
 #define NIA_BMI_AC_ENQ_FRAME        0x00000002
 #define NIA_BMI_AC_TX_RELEASE       0x000002C0
@@ -498,25 +458,25 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 
 
 #define SW_PORT_ID_TO_HW_PORT_ID(_port, _type, _relativePortId)         \
-switch(_type) {                                                         \
-    case(e_FM_PORT_TYPE_OH_OFFLINE_PARSING):                            \
-    case(e_FM_PORT_TYPE_OH_HOST_COMMAND):                               \
+switch (_type) {                                                        \
+    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):                            \
+    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):                               \
         CHECK_PORT_ID_OH_PORTS(_relativePortId);                        \
         _port = (uint8_t)(BASE_OH_PORTID + (_relativePortId));          \
         break;                                                          \
-    case(e_FM_PORT_TYPE_RX):                                            \
+    case (e_FM_PORT_TYPE_RX):                                            \
         CHECK_PORT_ID_1G_RX_PORTS(_relativePortId);                     \
         _port = (uint8_t)(BASE_1G_RX_PORTID + (_relativePortId));       \
         break;                                                          \
-    case(e_FM_PORT_TYPE_RX_10G):                                        \
+    case (e_FM_PORT_TYPE_RX_10G):                                        \
         CHECK_PORT_ID_10G_RX_PORTS(_relativePortId);                    \
         _port = (uint8_t)(BASE_10G_RX_PORTID + (_relativePortId));      \
         break;                                                          \
-    case(e_FM_PORT_TYPE_TX):                                            \
+    case (e_FM_PORT_TYPE_TX):                                            \
         CHECK_PORT_ID_1G_TX_PORTS(_relativePortId);                     \
         _port = (uint8_t)(BASE_1G_TX_PORTID + (_relativePortId));       \
         break;                                                          \
-    case(e_FM_PORT_TYPE_TX_10G):                                        \
+    case (e_FM_PORT_TYPE_TX_10G):                                        \
         CHECK_PORT_ID_10G_TX_PORTS(_relativePortId);                    \
         _port = (uint8_t)(BASE_10G_TX_PORTID + (_relativePortId));      \
         break;                                                          \
@@ -598,27 +558,27 @@ typedef struct {
 #define IS_SPECIAL_HEADER(hdr)              ((hdr) == HEADER_TYPE_MACSEC)
 
 #define GET_PRS_HDR_NUM(num, hdr)                           \
-switch(hdr)                                                 \
-{   case(HEADER_TYPE_ETH):              num = 0;  break;    \
-    case(HEADER_TYPE_LLC_SNAP):         num = 1;  break;    \
-    case(HEADER_TYPE_VLAN):             num = 2;  break;    \
-    case(HEADER_TYPE_PPPoE):            num = 3;  break;    \
-    case(HEADER_TYPE_MPLS):             num = 4;  break;    \
-    case(HEADER_TYPE_IPv4):             num = 5;  break;    \
-    case(HEADER_TYPE_IPv6):             num = 6;  break;    \
-    case(HEADER_TYPE_GRE):              num = 7;  break;    \
-    case(HEADER_TYPE_MINENCAP):         num = 8;  break;    \
-    case(HEADER_TYPE_USER_DEFINED_L3):  num = 9;  break;    \
-    case(HEADER_TYPE_TCP):              num = 10; break;    \
-    case(HEADER_TYPE_UDP):              num = 11; break;    \
-    case(HEADER_TYPE_IPSEC_AH):                             \
-    case(HEADER_TYPE_IPSEC_ESP):        num = 12; break;    \
-    case(HEADER_TYPE_SCTP):             num = 13; break;    \
-    case(HEADER_TYPE_DCCP):             num = 14; break;    \
-    case(HEADER_TYPE_USER_DEFINED_L4):  num = 15; break;    \
-    case(HEADER_TYPE_USER_DEFINED_SHIM1):                   \
-    case(HEADER_TYPE_USER_DEFINED_SHIM2):                   \
-    case(HEADER_TYPE_MACSEC):                               \
+switch (hdr)                                                \
+{   case (HEADER_TYPE_ETH):              num = 0;  break;   \
+    case (HEADER_TYPE_LLC_SNAP):         num = 1;  break;   \
+    case (HEADER_TYPE_VLAN):             num = 2;  break;   \
+    case (HEADER_TYPE_PPPoE):            num = 3;  break;   \
+    case (HEADER_TYPE_MPLS):             num = 4;  break;   \
+    case (HEADER_TYPE_IPv4):             num = 5;  break;   \
+    case (HEADER_TYPE_IPv6):             num = 6;  break;   \
+    case (HEADER_TYPE_GRE):              num = 7;  break;   \
+    case (HEADER_TYPE_MINENCAP):         num = 8;  break;   \
+    case (HEADER_TYPE_USER_DEFINED_L3):  num = 9;  break;   \
+    case (HEADER_TYPE_TCP):              num = 10; break;   \
+    case (HEADER_TYPE_UDP):              num = 11; break;   \
+    case (HEADER_TYPE_IPSEC_AH):                            \
+    case (HEADER_TYPE_IPSEC_ESP):        num = 12; break;   \
+    case (HEADER_TYPE_SCTP):             num = 13; break;   \
+    case (HEADER_TYPE_DCCP):             num = 14; break;   \
+    case (HEADER_TYPE_USER_DEFINED_L4):  num = 15; break;   \
+    case (HEADER_TYPE_USER_DEFINED_SHIM1):                  \
+    case (HEADER_TYPE_USER_DEFINED_SHIM2):                  \
+    case (HEADER_TYPE_MACSEC):                              \
         num = NO_HDR_NUM; break;                            \
     default:                                                \
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header for parser"));\
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
index 4c7a697..fead7f50 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/error.c
@@ -37,9 +37,10 @@
 
  @Description   General errors and events reporting utilities.
 *//***************************************************************************/
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+#include "error_ext.h"
 
 
-#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 const char *dbgLevelStrings[] =
 {
      "CRITICAL"
@@ -50,44 +51,45 @@ const char *dbgLevelStrings[] =
     ,"TRACE"
 };
 
-const char *errTypeStrings[] =
+
+char * ErrTypeStrings (e_ErrorType err)
 {
-     "Invalid State"                        /* E_INVALID_STATE */
-    ,"Invalid Operation"                    /* E_INVALID_OPERATION */
-    ,"Unsupported Operation"                /* E_NOT_SUPPORTED */
-    ,"No Device"                            /* E_NO_DEVICE */
-    ,"Invalid Handle"                       /* E_INVALID_HANDLE */
-    ,"Invalid ID"                           /* E_INVALID_ID */
-    ,"Unexpected NULL Pointer"              /* E_NULL_POINTER */
-    ,"Invalid Value"                        /* E_INVALID_VALUE */
-    ,"Invalid Selection"                    /* E_INVALID_SELECTION */
-    ,"Invalid Communication Mode"           /* E_INVALID_COMM_MODE */
-    ,"Invalid Memory Type"                  /* E_INVALID_MEMORY_TYPE */
-    ,"Invalid Interrupt Queue"              /* E_INVALID_INTR_QUEUE */
-    ,"Invalid Priority"                     /* E_INVALID_PRIORITY */
-    ,"Invalid Clock"                        /* E_INVALID_CLOCK */
-    ,"Invalid Rate"                         /* E_INVALID_RATE */
-    ,"Invalid Address"                      /* E_INVALID_ADDRESS */
-    ,"Invalid Bus"                          /* E_INVALID_BUS */
-    ,"Conflict In Bus Selection"            /* E_BUS_CONFLICT */
-    ,"Conflict In Settings"                 /* E_CONFLICT */
-    ,"Incorrect Alignment"                  /* E_NOT_ALIGNED */
-    ,"Value Out Of Range"                   /* E_NOT_IN_RANGE */
-    ,"Invalid Frame"                        /* E_INVALID_FRAME */
-    ,"Frame Is Empty"                       /* E_EMPTY_FRAME */
-    ,"Buffer Is Empty"                      /* E_EMPTY_BUFFER */
-    ,"Memory Allocation Failed"             /* E_NO_MEMORY */
-    ,"Resource Not Found"                   /* E_NOT_FOUND */
-    ,"Resource Is Unavailable"              /* E_NOT_AVAILABLE */
-    ,"Resource Already Exists"              /* E_ALREADY_EXISTS */
-    ,"Resource Is Full"                     /* E_FULL */
-    ,"Resource Is Empty"                    /* E_EMPTY */
-    ,"Resource Is Busy"                     /* E_BUSY */
-    ,"Resource Already Free"                /* E_ALREADY_FREE */
-    ,"Read Access Failed"                   /* E_READ_FAILED */
-    ,"Write Access Failed"                  /* E_WRITE_FAILED */
-    ,"Send Operation Failed"                /* E_SEND_FAILED */
-    ,"Receive Operation Failed"             /* E_RECEIVE_FAILED */
-    ,"Operation Timed Out"                  /* E_TIMEOUT */
-};
+    switch (err)
+    {
+        case (E_OK):                    return "OK";
+        case (E_WRITE_FAILED):          return "Write Access Failed";
+        case (E_NO_DEVICE):             return "No Device";
+        case (E_NOT_AVAILABLE):         return "Resource Is Unavailable";
+        case (E_NO_MEMORY):             return "Memory Allocation Failed";
+        case (E_INVALID_ADDRESS):       return "Invalid Address";
+        case (E_BUSY):                  return "Resource Is Busy";
+        case (E_ALREADY_EXISTS):        return "Resource Already Exists";
+        case (E_INVALID_OPERATION):     return "Invalid Operation";
+        case (E_INVALID_VALUE):         return "Invalid Value";
+        case (E_NOT_IN_RANGE):          return "Value Out Of Range";
+        case (E_NOT_SUPPORTED):         return "Unsupported Operation";
+        case (E_INVALID_STATE):         return "Invalid State";
+        case (E_INVALID_HANDLE):        return "Invalid Handle";
+        case (E_INVALID_ID):            return "Invalid ID";
+        case (E_NULL_POINTER):          return "Unexpected NULL Pointer";
+        case (E_INVALID_SELECTION):     return "Invalid Selection";
+        case (E_INVALID_COMM_MODE):     return "Invalid Communication Mode";
+        case (E_INVALID_MEMORY_TYPE):   return "Invalid Memory Type";
+        case (E_INVALID_CLOCK):         return "Invalid Clock";
+        case (E_CONFLICT):              return "Conflict In Settings";
+        case (E_NOT_ALIGNED):           return "Incorrect Alignment";
+        case (E_NOT_FOUND):             return "Resource Not Found";
+        case (E_FULL):                  return "Resource Is Full";
+        case (E_EMPTY):                 return "Resource Is Empty";
+        case (E_ALREADY_FREE):          return "Resource Already Free";
+        case (E_READ_FAILED):           return "Read Access Failed";
+        case (E_INVALID_FRAME):         return "Invalid Frame";
+        case (E_SEND_FAILED):           return "Send Operation Failed";
+        case (E_RECEIVE_FAILED):        return "Receive Operation Failed";
+        case (E_TIMEOUT):               return "Operation Timed Out";
+        default:
+            break;
+    }
+    return NULL;
+}
 #endif /* (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0)) */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
index e366ee7..02973e5 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/etc/memcpy.c
@@ -37,71 +37,6 @@
 #include "memcpy_ext.h"
 
 
-#ifdef CORE_8BIT_ACCESS_ERRATA
-static void MY_MY_WRITE_UINT8(uint8_t *addr, uint8_t val)
-{
-    uint32_t newAddr, newVal;
-    newAddr = (uint32_t)addr & ~0x3L;
-    switch ((uint32_t)addr%4)
-    {
-    case (0):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0x00ffffff) | (((uint32_t)val)<<24);
-        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
-        break;
-    case (1):
-         newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0xff00ffff) | (((uint32_t)val)<<16);
-        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
-        break;
-    case (2):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0xffff00ff) | (((uint32_t)val)<<8);
-        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
-        break;
-    case (3):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0xffffff00) | val;
-        WRITE_UINT32(*(uint32_t*)newAddr, newVal);
-        break;
-    }
-}
-
-static uint8_t MY_MY_GET_UINT8(uint8_t *addr)
-{
-    uint32_t newAddr, newVal=0;
-    newAddr = (uint32_t)addr & ~0x3L;
-    switch ((uint32_t)addr%4)
-    {
-    case (0):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0xff000000)>>24;
-        break;
-    case (1):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0x00ff0000)>>16;
-        break;
-    case (2):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0x0000ff00)>>8;
-        break;
-    case (3):
-        newVal = GET_UINT32(*(uint32_t*)newAddr);
-        newVal = (newVal & 0x000000ff);
-        break;
-    }
-
-    return (uint8_t)newVal;
-}
-
-#define MY_WRITE_UINT8(addr,val) MY_MY_WRITE_UINT8(&addr,val)
-#define MY_GET_UINT8(addr) MY_MY_GET_UINT8(&addr)
-#else
-#define MY_WRITE_UINT8 WRITE_UINT8
-#define MY_GET_UINT8   GET_UINT8
-#endif /* CORE_8BIT_ACCESS_ERRATA */
-
-
 void * MemCpy32(void* pDst,void* pSrc, uint32_t size)
 {
     uint32_t leftAlign;
@@ -195,7 +130,7 @@ void * IO2IOCpy32(void* pDst,void* pSrc, uint32_t size)
      */
     while((PTR_TO_UINT(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
     {
-        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        WRITE_UINT8(*p_Dst8, GET_UINT8(*p_Src8));
         p_Dst8++;p_Src8++;
         size--;
     }
@@ -203,7 +138,7 @@ void * IO2IOCpy32(void* pDst,void* pSrc, uint32_t size)
     /* align destination (possibly disaligning source)*/
     while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
     {
-        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        WRITE_UINT8(*p_Dst8, GET_UINT8(*p_Src8));
         p_Dst8++;p_Src8++;
         size--;
     }
@@ -248,7 +183,7 @@ void * IO2IOCpy32(void* pDst,void* pSrc, uint32_t size)
     /* complete the left overs */
     while (size--)
     {
-        MY_WRITE_UINT8(*p_Dst8, MY_GET_UINT8(*p_Src8));
+        WRITE_UINT8(*p_Dst8, GET_UINT8(*p_Src8));
         p_Dst8++;p_Src8++;
     }
 
@@ -274,7 +209,7 @@ void * Mem2IOCpy32(void* pDst,void* pSrc, uint32_t size)
      */
     while((PTR_TO_UINT(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
     {
-        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        WRITE_UINT8(*p_Dst8, *p_Src8);
         p_Dst8++;p_Src8++;
         size--;
     }
@@ -282,7 +217,7 @@ void * Mem2IOCpy32(void* pDst,void* pSrc, uint32_t size)
     /* align destination (possibly disaligning source)*/
     while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
     {
-        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        WRITE_UINT8(*p_Dst8, *p_Src8);
         p_Dst8++;p_Src8++;
         size--;
     }
@@ -326,7 +261,7 @@ void * Mem2IOCpy32(void* pDst,void* pSrc, uint32_t size)
     /* complete the left overs */
     while (size--)
     {
-        MY_WRITE_UINT8(*p_Dst8, *p_Src8);
+        WRITE_UINT8(*p_Dst8, *p_Src8);
         p_Dst8++;p_Src8++;
     }
 
@@ -352,7 +287,7 @@ void * IO2MemCpy32(void* pDst,void* pSrc, uint32_t size)
      */
     while((PTR_TO_UINT(p_Src8) & 3) && size) /* (pSrc mod 4) > 0 and size > 0 */
     {
-        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        *p_Dst8 = GET_UINT8(*p_Src8);
         p_Dst8++;p_Src8++;
         size--;
     }
@@ -360,7 +295,7 @@ void * IO2MemCpy32(void* pDst,void* pSrc, uint32_t size)
     /* align destination (possibly disaligning source)*/
     while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
     {
-        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        *p_Dst8 = GET_UINT8(*p_Src8);
         p_Dst8++;p_Src8++;
         size--;
     }
@@ -405,7 +340,7 @@ void * IO2MemCpy32(void* pDst,void* pSrc, uint32_t size)
     /* complete the left overs */
     while (size--)
     {
-        *p_Dst8 = MY_GET_UINT8(*p_Src8);
+        *p_Dst8 = GET_UINT8(*p_Src8);
         p_Dst8++;p_Src8++;
     }
 
@@ -538,7 +473,7 @@ void * IOMemSet32(void* pDst, uint8_t val, uint32_t size)
     /* align destination to 32 */
     while((PTR_TO_UINT(p_Dst8) & 3) && size) /* (pDst mod 4) > 0 and size > 0 */
     {
-        MY_WRITE_UINT8(*p_Dst8, val);
+        WRITE_UINT8(*p_Dst8, val);
         p_Dst8++;
         size--;
     }
@@ -556,7 +491,7 @@ void * IOMemSet32(void* pDst, uint8_t val, uint32_t size)
     p_Dst8 = (uint8_t*)(p_Dst32);
     while (size--)
     {
-        MY_WRITE_UINT8(*p_Dst8, val);
+        WRITE_UINT8(*p_Dst8, val);
         p_Dst8++;
     }
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
index feced06..77f91d2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/dpaa_ext.h
@@ -106,14 +106,14 @@ typedef enum e_DpaaFDFormatType {
 #define DPAA_FD_GET_OFFSET(fd)        ((((t_DpaaFD *)fd)->length & DPAA_FD_OFFSET_MASK) >> (31-11))     /**< Macro to get FD OFFSET field */
 #define DPAA_FD_GET_LENGTH(fd)        (((t_DpaaFD *)fd)->length & DPAA_FD_LENGTH_MASK)                  /**< Macro to get FD LENGTH field */
 #define DPAA_FD_GET_STATUS(fd)        ((t_DpaaFD *)fd)->status                                          /**< Macro to get FD STATUS field */
-#define DPAA_FD_GET_ADDR(fd)          XX_PhysToVirt(DPAA_FD_GET_PHYS_ADDR(fd))
+#define DPAA_FD_GET_ADDR(fd)          XX_PhysToVirt(DPAA_FD_GET_PHYS_ADDR(fd))                          /**< TODO */
 
 #define DPAA_FD_SET_DD(fd,val)        (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_DD_MASK) | (((val) << (31-1)) & DPAA_FD_DD_MASK )))      /**< Macro to set FD DD field */
                                                                                                         /**< Macro to set FD PID field or LIODN offset*/
 #define DPAA_FD_SET_PID(fd,val)       (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~(DPAA_FD_PID_MASK|DPAA_FD_ELIODN_MASK)) | ((((val) << (31-7)) & DPAA_FD_PID_MASK) | ((((val)>>6) << (31-19)) & DPAA_FD_ELIODN_MASK))))
 #define DPAA_FD_SET_BPID(fd,val)      (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_BPID_MASK) | (((val)  << (31-15)) & DPAA_FD_BPID_MASK))) /**< Macro to set FD BPID field */
 #define DPAA_FD_SET_ADDRH(fd,val)     (((t_DpaaFD *)fd)->id = ((((t_DpaaFD *)fd)->id & ~DPAA_FD_ADDRH_MASK) | ((val) & DPAA_FD_ADDRH_MASK)))            /**< Macro to set FD ADDRH field */
-#define DPAA_FD_SET_ADDRL(fd,val)     ((t_DpaaFD *)fd)->addrl = (val)                                     /**< Macro to set FD ADDRL field */
+#define DPAA_FD_SET_ADDRL(fd,val)     ((t_DpaaFD *)fd)->addrl = (val)                                   /**< Macro to set FD ADDRL field */
 #define DPAA_FD_SET_ADDR(fd,val)                            \
 do {                                                        \
     uint64_t physAddr = (uint64_t)(XX_VirtToPhys(val));     \
@@ -123,7 +123,7 @@ do {                                                        \
 #define DPAA_FD_SET_FORMAT(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_FORMAT_MASK) | (((val)  << (31-2))& DPAA_FD_FORMAT_MASK)))  /**< Macro to set FD FORMAT field */
 #define DPAA_FD_SET_OFFSET(fd,val)    (((t_DpaaFD *)fd)->length = ((((t_DpaaFD *)fd)->length & ~DPAA_FD_OFFSET_MASK) | (((val) << (31-11))& DPAA_FD_OFFSET_MASK) )) /**< Macro to set FD OFFSET field */
 #define DPAA_FD_SET_LENGTH(fd,val)    (((t_DpaaFD *)fd)->length = (((t_DpaaFD *)fd)->length & ~DPAA_FD_LENGTH_MASK) | ((val) & DPAA_FD_LENGTH_MASK))                /**< Macro to set FD LENGTH field */
-#define DPAA_FD_SET_STATUS(fd,val)    ((t_DpaaFD *)fd)->status = (val)                                    /**< Macro to set FD STATUS field */
+#define DPAA_FD_SET_STATUS(fd,val)    ((t_DpaaFD *)fd)->status = (val)                                  /**< Macro to set FD STATUS field */
 /* @} */
 
 /**************************************************************************//**
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
index 53976f3..195e2d4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_ext.h
@@ -112,7 +112,7 @@ typedef _Packed struct t_FmPrsResult {
     volatile uint8_t     l4r;                /**< Layer 4 result */
     volatile uint8_t     cplan;              /**< Classification plan id */
     volatile uint16_t    nxthdr;             /**< Next Header  */
-    volatile uint16_t    cksum;              /**< Checksum */
+    volatile uint16_t    cksum;              /**< running-sum */
     volatile uint16_t    flags_frag_off;     /**< Flags & fragment-offset field of the last IP-header */
     volatile uint8_t     route_type;         /**< Routing type field of a IPv6 routing extension header */
     volatile uint8_t     rhp_ip_valid;       /**< Routing Extension Header Present; last bit is IP valid */
@@ -160,7 +160,6 @@ typedef _Packed struct t_FmPrsResult {
 #define FM_FD_ERR_IPR_NCSP              (0x00100000 | FM_FD_IPR)    /**< IPR non-consistent-sp */
 #define FM_FD_ERR_IPR                   (0x00200000 | FM_FD_IPR)    /**< IPR error */
 #define FM_FD_ERR_IPR_TO                (0x00300000 | FM_FD_IPR)    /**< IPR timeout */
-#define FM_FD_ERR_IPF                   0x00100000                  /**< IPF error */
 
 #ifdef FM_CAPWAP_SUPPORT
 #define FM_FD_ERR_CRE                   0x00200000
@@ -194,7 +193,6 @@ typedef _Packed struct t_FmPrsResult {
                                          FM_FD_ERR_IPR                  | \
                                          FM_FD_ERR_IPR_TO               | \
                                          FM_FD_ERR_IPR_NCSP             | \
-                                         FM_FD_ERR_IPF                  | \
                                          FM_FD_ERR_PHYSICAL             | \
                                          FM_FD_ERR_SIZE                 | \
                                          FM_FD_ERR_CLS_DISCARD          | \
@@ -288,7 +286,7 @@ typedef uint32_t fmSpecialOperations_t;                 /**< typedef for definin
  @Description   FM Exceptions
 *//***************************************************************************/
 typedef enum e_FmExceptions {
-    e_FM_EX_DMA_BUS_ERROR,              /**< DMA bus error. */
+    e_FM_EX_DMA_BUS_ERROR = 0,          /**< DMA bus error. */
     e_FM_EX_DMA_READ_ECC,               /**< Read Buffer ECC error (Valid for FM rev < 6)*/
     e_FM_EX_DMA_SYSTEM_WRITE_ECC,       /**< Write Buffer ECC error on system side (Valid for FM rev < 6)*/
     e_FM_EX_DMA_FM_WRITE_ECC,           /**< Write Buffer ECC error on FM side (Valid for FM rev < 6)*/
@@ -646,7 +644,7 @@ typedef struct t_FmDmaEmergency {
     e_FmDmaEmergencyLevel   emergencyLevel;                 /**< EBS/SOS */
 } t_FmDmaEmergency;
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Description   structure for defining FM threshold
 *//***************************************************************************/
 typedef struct t_FmThresholds {
@@ -671,7 +669,7 @@ typedef struct t_FmThresholds {
                                                                  queued in fmCtl2 dispatch queue*/
 } t_FmThresholds;
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Description   structure for defining DMA thresholds
 *//***************************************************************************/
 typedef struct t_FmDmaThresholds {
@@ -1039,7 +1037,7 @@ t_Error FM_ConfigExternalEccRamsEnable(t_Handle h_Fm, bool enable);
 *//***************************************************************************/
 t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_ConfigDmaEmergencySmoother
 
  @Description   Define DMA emergency smoother.
@@ -1059,7 +1057,7 @@ t_Error FM_ConfigTnumAgingPeriod(t_Handle h_Fm, uint16_t tnumAgingPeriod);
 *//***************************************************************************/
 t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_ConfigThresholds
 
  @Description   Calling this routine changes the internal driver data base
@@ -1086,7 +1084,7 @@ t_Error FM_ConfigDmaEmergencySmoother(t_Handle h_Fm, uint32_t emergencyCnt);
 *//***************************************************************************/
 t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_ConfigDmaSosEmergencyThreshold
 
  @Description   Calling this routine changes the internal driver data base
@@ -1103,7 +1101,7 @@ t_Error FM_ConfigThresholds(t_Handle h_Fm, t_FmThresholds *p_FmThresholds);
 *//***************************************************************************/
 t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergency);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_ConfigDmaWriteBufThresholds
 
  @Description   Calling this routine changes the internal driver data base
@@ -1125,7 +1123,7 @@ t_Error FM_ConfigDmaSosEmergencyThreshold(t_Handle h_Fm, uint32_t dmaSosEmergenc
 *//***************************************************************************/
 t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
 
- /**************************************************************************//**
+ /**************************************************************************//*
  @Function      FM_ConfigDmaCommQThresholds
 
  @Description   Calling this routine changes the internal driver data base
@@ -1146,7 +1144,7 @@ t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDma
 *//***************************************************************************/
 t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_ConfigDmaReadBufThresholds
 
  @Description   Calling this routine changes the internal driver data base
@@ -1168,7 +1166,7 @@ t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThr
 *//***************************************************************************/
 t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_ConfigDmaWatchdog
 
  @Description   Calling this routine changes the internal driver data base
@@ -1214,8 +1212,8 @@ t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchDogValue);
                                      FM_MAX_NUM_OF_10G_TX_PORTS)      /**< Number of available FM ports */
 /* @} */
 
-/**************************************************************************//**
- @Description   A structure for Port bandwidth requirement. Port is identified
+/**************************************************************************//*
+ @Description   A Structure for Port bandwidth requirement. Port is identified
                 by type and relative id.
 *//***************************************************************************/
 typedef struct t_FmPortBandwidth {
@@ -1224,7 +1222,7 @@ typedef struct t_FmPortBandwidth {
     uint8_t             bandwidth;      /**< bandwidth - (in term of percents) */
 } t_FmPortBandwidth;
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Description   A Structure containing an array of Port bandwidth requirements.
                 The user should state the ports requiring bandwidth in terms of
                 percentage - i.e. all port's bandwidths in the array must add
@@ -1332,23 +1330,6 @@ t_Error FM_DumpRegs(t_Handle h_Fm);
 t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable);
 
 /**************************************************************************//**
- @Function      FM_SetPortsBandwidth
-
- @Description   Sets relative weights between ports when accessing common resources.
-
- @Param[in]     h_Fm                A handle to an FM Module.
- @Param[in]     p_PortsBandwidth    A structure of ports bandwidths in percentage, i.e.
-                                    total must equal 100.
-
- @Return        E_OK on success; Error code otherwise.
-
- @Cautions      Allowed only following FM_Init().
-                This routine should NOT be called from guest-partition
-                (i.e. guestId != NCSW_MASTER_ID)
-*//***************************************************************************/
-t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
-
-/**************************************************************************//**
  @Function      FM_EnableRamsEcc
 
  @Description   Enables ECC mechanism for all the different FM RAM's; E.g. IRAM,
@@ -1624,7 +1605,8 @@ t_Error FM_CtrlMonStop(t_Handle h_Fm);
 *//***************************************************************************/
 t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p_Mon);
 
-/**************************************************************************//**
+
+/**************************************************************************//*
  @Function      FM_ForceIntr
 
  @Description   Causes an interrupt event on the requested source.
@@ -1641,12 +1623,30 @@ t_Error FM_CtrlMonGetCounters(t_Handle h_Fm, uint8_t fmCtrlIndex, t_FmCtrlMon *p
 *//***************************************************************************/
 t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception);
 
+/**************************************************************************//*
+ @Function      FM_SetPortsBandwidth
+
+ @Description   Sets relative weights between ports when accessing common resources.
+
+ @Param[in]     h_Fm                A handle to an FM Module.
+ @Param[in]     p_PortsBandwidth    A structure of ports bandwidths in percentage, i.e.
+                                    total must equal 100.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
+*//***************************************************************************/
+t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBandwidth);
+
 /** @} */ /* end of FM_runtime_control_grp group */
 /** @} */ /* end of FM_lib_grp group */
 /** @} */ /* end of FM_grp group */
 
 
 #ifdef NCSW_BACKWARD_COMPATIBLE_API
+typedef t_FmFirmwareParams          t_FmPcdFirmwareParams;
 typedef t_FmBufferPrefixContent     t_FmPortBufferPrefixContent;
 typedef t_FmExtPoolParams           t_FmPortExtPoolParams;
 typedef t_FmExtPools                t_FmPortExtPools;
@@ -1656,6 +1656,7 @@ typedef e_FmDmaSwapOption           e_FmPortDmaSwapOption;
 typedef e_FmDmaCacheOption          e_FmPortDmaCacheOption;
 
 #define FM_CONTEXTA_GET_OVVERIDE    FM_CONTEXTA_GET_OVERRIDE
+#define FM_CONTEXTA_SET_OVVERIDE    FM_CONTEXTA_SET_OVERRIDE
 
 #define e_FM_EX_BMI_PIPELINE_ECC    e_FM_EX_BMI_STORAGE_PROFILE_ECC
 #define e_FM_PORT_DMA_NO_SWP        e_FM_DMA_NO_SWP
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
index 1c188e6..f18d497 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_mac_ext.h
@@ -67,40 +67,40 @@
  @Description   FM MAC Exceptions
 *//***************************************************************************/
 typedef enum e_FmMacExceptions {
-    e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO = 0
-   ,e_FM_MAC_EX_10G_MDIO_CMD_CMPL
-   ,e_FM_MAC_EX_10G_REM_FAULT
-   ,e_FM_MAC_EX_10G_LOC_FAULT
-   ,e_FM_MAC_EX_10G_1TX_ECC_ER
-   ,e_FM_MAC_EX_10G_TX_FIFO_UNFL
-   ,e_FM_MAC_EX_10G_TX_FIFO_OVFL
-   ,e_FM_MAC_EX_10G_TX_ER
-   ,e_FM_MAC_EX_10G_RX_FIFO_OVFL
-   ,e_FM_MAC_EX_10G_RX_ECC_ER
-   ,e_FM_MAC_EX_10G_RX_JAB_FRM
-   ,e_FM_MAC_EX_10G_RX_OVRSZ_FRM
-   ,e_FM_MAC_EX_10G_RX_RUNT_FRM
-   ,e_FM_MAC_EX_10G_RX_FRAG_FRM
-   ,e_FM_MAC_EX_10G_RX_LEN_ER
-   ,e_FM_MAC_EX_10G_RX_CRC_ER
-   ,e_FM_MAC_EX_10G_RX_ALIGN_ER
-   ,e_FM_MAC_EX_1G_BAB_RX
-   ,e_FM_MAC_EX_1G_RX_CTL
-   ,e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET
-   ,e_FM_MAC_EX_1G_BAB_TX
-   ,e_FM_MAC_EX_1G_TX_CTL
-   ,e_FM_MAC_EX_1G_TX_ERR
-   ,e_FM_MAC_EX_1G_LATE_COL
-   ,e_FM_MAC_EX_1G_COL_RET_LMT
-   ,e_FM_MAC_EX_1G_TX_FIFO_UNDRN
-   ,e_FM_MAC_EX_1G_MAG_PCKT
-   ,e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET
-   ,e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET
-   ,e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET
-   ,e_FM_MAC_EX_1G_TX_DATA_ERR
-   ,e_FM_MAC_EX_1G_RX_DATA_ERR
-   ,e_FM_MAC_EX_1G_1588_TS_RX_ERR
-   ,e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL
+    e_FM_MAC_EX_10G_MDIO_SCAN_EVENTMDIO = 0                     /**< 10GEC MDIO scan event interrupt */
+   ,e_FM_MAC_EX_10G_MDIO_CMD_CMPL                               /**< 10GEC MDIO command completion interrupt */
+   ,e_FM_MAC_EX_10G_REM_FAULT                                   /**< 10GEC, mEMAC Remote fault interrupt */
+   ,e_FM_MAC_EX_10G_LOC_FAULT                                   /**< 10GEC, mEMAC Local fault interrupt */
+   ,e_FM_MAC_EX_10G_1TX_ECC_ER                                  /**< 10GEC, mEMAC Transmit frame ECC error interrupt */
+   ,e_FM_MAC_EX_10G_TX_FIFO_UNFL                                /**< 10GEC, mEMAC Transmit FIFO underflow interrupt */
+   ,e_FM_MAC_EX_10G_TX_FIFO_OVFL                                /**< 10GEC, mEMAC Transmit FIFO overflow interrupt */
+   ,e_FM_MAC_EX_10G_TX_ER                                       /**< 10GEC Transmit frame error interrupt */
+   ,e_FM_MAC_EX_10G_RX_FIFO_OVFL                                /**< 10GEC, mEMAC Receive FIFO overflow interrupt */
+   ,e_FM_MAC_EX_10G_RX_ECC_ER                                   /**< 10GEC, mEMAC Receive frame ECC error interrupt */
+   ,e_FM_MAC_EX_10G_RX_JAB_FRM                                  /**< 10GEC Receive jabber frame interrupt */
+   ,e_FM_MAC_EX_10G_RX_OVRSZ_FRM                                /**< 10GEC Receive oversized frame interrupt */
+   ,e_FM_MAC_EX_10G_RX_RUNT_FRM                                 /**< 10GEC Receive runt frame interrupt */
+   ,e_FM_MAC_EX_10G_RX_FRAG_FRM                                 /**< 10GEC Receive fragment frame interrupt */
+   ,e_FM_MAC_EX_10G_RX_LEN_ER                                   /**< 10GEC Receive payload length error interrupt */
+   ,e_FM_MAC_EX_10G_RX_CRC_ER                                   /**< 10GEC Receive CRC error interrupt */
+   ,e_FM_MAC_EX_10G_RX_ALIGN_ER                                 /**< 10GEC Receive alignment error interrupt */
+   ,e_FM_MAC_EX_1G_BAB_RX                                       /**< dTSEC Babbling receive error */
+   ,e_FM_MAC_EX_1G_RX_CTL                                       /**< dTSEC Receive control (pause frame) interrupt */
+   ,e_FM_MAC_EX_1G_GRATEFUL_TX_STP_COMPLET                      /**< dTSEC Graceful transmit stop complete */
+   ,e_FM_MAC_EX_1G_BAB_TX                                       /**< dTSEC Babbling transmit error */
+   ,e_FM_MAC_EX_1G_TX_CTL                                       /**< dTSEC Transmit control (pause frame) interrupt */
+   ,e_FM_MAC_EX_1G_TX_ERR                                       /**< dTSEC Transmit error */
+   ,e_FM_MAC_EX_1G_LATE_COL                                     /**< dTSEC Late collision */
+   ,e_FM_MAC_EX_1G_COL_RET_LMT                                  /**< dTSEC Collision retry limit */
+   ,e_FM_MAC_EX_1G_TX_FIFO_UNDRN                                /**< dTSEC Transmit FIFO underrun */
+   ,e_FM_MAC_EX_1G_MAG_PCKT                                     /**< dTSEC Magic Packet detection */
+   ,e_FM_MAC_EX_1G_MII_MNG_RD_COMPLET                           /**< dTSEC MII management read completion */
+   ,e_FM_MAC_EX_1G_MII_MNG_WR_COMPLET                           /**< dTSEC MII management write completion */
+   ,e_FM_MAC_EX_1G_GRATEFUL_RX_STP_COMPLET                      /**< dTSEC Graceful receive stop complete */
+   ,e_FM_MAC_EX_1G_TX_DATA_ERR                                  /**< dTSEC Internal data error on transmit */
+   ,e_FM_MAC_EX_1G_RX_DATA_ERR                                  /**< dTSEC Internal data error on receive */
+   ,e_FM_MAC_EX_1G_1588_TS_RX_ERR                               /**< dTSEC Time-Stamp Receive Error */
+   ,e_FM_MAC_EX_1G_RX_MIB_CNT_OVFL                              /**< dTSEC MIB counter overflow */
 } e_FmMacExceptions;
 
 /**************************************************************************//**
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
index 9c9650a..a21fbe0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_pcd_ext.h
@@ -669,7 +669,7 @@ void FM_PCD_SetPrsStatistics(t_Handle h_FmPcd, bool enable);
 *//***************************************************************************/
 void FM_PCD_HcTxConf(t_Handle h_FmPcd, t_DpaaFD *p_Fd);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_PCD_ForceIntr
 
  @Description   Causes an interrupt event on the requested source.
@@ -800,7 +800,6 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
                 parameters as required by KeyGen (when coarse classification
                 is the next engine after this scheme).
 *//***************************************************************************/
-#define FM_PCD_MAX_NUM_OF_CC_NODES              255
 #define FM_PCD_MAX_NUM_OF_CC_TREES              8
 #define FM_PCD_MAX_NUM_OF_CC_GROUPS             16
 #define FM_PCD_MAX_NUM_OF_CC_UNITS              4
@@ -810,6 +809,8 @@ t_Error     FM_PCD_HcDumpRegs(t_Handle h_FmPcd);
 #define FM_PCD_MAX_NUM_OF_CC_ENTRIES_IN_GRP     16
 #define FM_PCD_LAST_KEY_INDEX                   0xffff
 #define FM_PCD_MANIP_DSCP_VALUES                64
+
+#define FM_PCD_MAX_NUM_OF_CC_NODES              255 /* Obsolete, not used - will be removed in the future */
 /* @} */
 
 /**************************************************************************//**
@@ -1167,10 +1168,10 @@ typedef enum e_FmPcdManipHdrCustomIpReplace {
  @Description   Enumeration type for selecting type of header removal
 *//***************************************************************************/
 typedef enum e_FmPcdManipHdrRmvByHdrType {
+    e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2 = 0,      /**< Specific L2 fields removal */
 #ifdef FM_CAPWAP_SUPPORT
     e_FM_PCD_MANIP_RMV_BY_HDR_FROM_START,           /**< Locate from data that is not the header */
 #endif /* FM_CAPWAP_SUPPORT */
-    e_FM_PCD_MANIP_RMV_BY_HDR_SPECIFIC_L2           /**< Specific L2 fields removal */
 } e_FmPcdManipHdrRmvByHdrType;
 
 /**************************************************************************//**
@@ -1233,8 +1234,12 @@ typedef enum e_FmPcdCcStatsMode {
                 is larger than MTU but its DF (Don't Fragment) bit is set.
 *//***************************************************************************/
 typedef enum e_FmPcdManipDontFragAction {
-    e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = 0,  /**< Discard packet */
-    e_FM_PCD_MANIP_FRAGMENT_PACKET,                     /**< Fragment packet and continue normal processing */
+    e_FM_PCD_MANIP_DISCARD_PACKET = 0,                  /**< Discard packet */
+    e_FM_PCD_MANIP_ENQ_TO_ERR_Q_OR_DISCARD_PACKET = e_FM_PCD_MANIP_DISCARD_PACKET,
+                                                        /**< Obsolete, cannot enqueue to error queue;
+                                                             In practice, selects to discard packets;
+                                                             Will be removed in the future */
+    e_FM_PCD_MANIP_FRAGMENT_PACKECT,                    /**< Fragment packet and continue normal processing */
     e_FM_PCD_MANIP_CONTINUE_WITHOUT_FRAG                /**< Continue normal processing without fragmenting the packet */
 } e_FmPcdManipDontFragAction;
 
@@ -1306,6 +1311,13 @@ typedef union u_FmPcdHdrProtocolOpt {
                                  present at the Ipv6 last extension. On earlier revisions this field
                                  applies to the Next-Header field of the main IPv6 header)
 
+                    HEADER_TYPE_IP:
+                        NET_HEADER_FIELD_IP_PROTO
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_LAST)
+                        NET_HEADER_FIELD_IP_DSCP
+                                (index may apply:
+                                 e_FM_PCD_HDR_INDEX_NONE/e_FM_PCD_HDR_INDEX_1)
                     HEADER_TYPE_GRE:
                         NET_HEADER_FIELD_GRE_TYPE
 
@@ -1372,6 +1384,7 @@ typedef union t_FmPcdFields {
     headerFieldLlcSnap_t        llcSnap;        /**< LLC SNAP               */
     headerFieldPppoe_t          pppoe;          /**< PPPoE                  */
     headerFieldMpls_t           mpls;           /**< MPLS                   */
+    headerFieldIp_t             ip;             /**< IP                     */
     headerFieldIpv4_t           ipv4;           /**< IPv4                   */
     headerFieldIpv6_t           ipv6;           /**< IPv6                   */
     headerFieldUdp_t            udp;            /**< UDP                    */
@@ -1852,13 +1865,16 @@ typedef struct t_KeysParams {
                                                      masks at runtime.
                                                      NOTE that if user want to use only global-masks (i.e. one common mask
                                                      for all the entries within this table, this parameter should set to 'FALSE'. */
-    e_FmPcdCcStatsMode          statisticsMode; /**< If not e_FM_PCD_CC_STATS_MODE_NONE, the required structures for
-                                                     the requested statistics mode will be allocated according to
-                                                     'maxNumOfKeys'. */
+    e_FmPcdCcStatsMode          statisticsMode; /**< Determines the supported statistics mode for all node's keys.
+                                                     To enable statistics gathering, statistics should be enabled per
+                                                     every key, using 'statisticsEn' in next engine parameters structure
+                                                     of that key;
+                                                     If 'maxNumOfKeys' is set, all required structures will be
+                                                     preallocated for all keys. */
 #if (DPAA_VERSION >= 11)
     uint16_t                    frameLengthRanges[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
-                                                /**< Relevant only for 'e_FM_PCD_CC_STATS_MODE_RMON' statistics
-                                                     mode (this feature is supported only on B4860 device);
+                                                /**< Relevant only for 'RMON' statistics mode
+                                                     (this feature is supported only on B4860 device);
                                                      Holds a list of programmable thresholds - for each received frame,
                                                      its length in bytes is examined against these range thresholds and
                                                      the appropriate counter is incremented by 1 - for example, to belong
@@ -1966,8 +1982,7 @@ typedef struct t_FmPcdCcKeyStatistics {
 #if (DPAA_VERSION >= 11)
     uint32_t    frameLengthRangeCount[FM_PCD_CC_STATS_MAX_NUM_OF_FLR];
                                 /**< These counters reflect how many frames matched
-                                     this key in 'e_FM_PCD_CC_STATS_MODE_RMON'
-                                     statistics mode:
+                                     this key in 'RMON' statistics mode:
                                      Each counter holds the number of frames of a
                                      specific frames length range, according to the
                                      ranges provided at initialization. */
@@ -2040,9 +2055,9 @@ typedef struct t_FmPcdPlcrProfileParams {
     e_FmPcdEngine                       nextEngineOnRed;            /**< Next engine for red-colored frames */
     u_FmPcdPlcrNextEngineParams         paramsOnRed;                /**< Next engine parameters for red-colored frames  */
 
-    bool                                trapProfileOnFlowA;         /**< Trap on flow A */
-    bool                                trapProfileOnFlowB;         /**< Trap on flow B */
-    bool                                trapProfileOnFlowC;         /**< Trap on flow C */
+    bool                                trapProfileOnFlowA;         /**< Obsolete - do not use */
+    bool                                trapProfileOnFlowB;         /**< Obsolete - do not use */
+    bool                                trapProfileOnFlowC;         /**< Obsolete - do not use */
 } t_FmPcdPlcrProfileParams;
 
 #ifdef FM_CAPWAP_SUPPORT
@@ -2180,6 +2195,7 @@ typedef struct t_FmPcdManipFragIpParams {
                                                              If disabled, the Scatter/Gather buffer will be allocated from the same pool as the
                                                              received frame's buffer. */
     uint8_t                     sgBpid;                 /**< Scatter/Gather buffer pool id;
+                                                             This parameters is relevant when 'sgBpidEn=TRUE';
                                                              Same LIODN number is used for these buffers as for the received frames buffers, so buffers
                                                              of this pool need to be allocated in the same memory area as the received buffers.
                                                              If the received buffers arrive from different sources, the Scatter/Gather BP id should be
@@ -2187,11 +2203,6 @@ typedef struct t_FmPcdManipFragIpParams {
     e_FmPcdManipDontFragAction  dontFragAction;         /**< Don't Fragment Action - If an IP packet is larger
                                                              than MTU and its DF bit is set, then this field will
                                                              determine the action to be taken.*/
-#ifdef FM_EXP_FEATURES
-    bool                        optionsCounterEn;       /**< If TRUE, A counter is incremented each time an IPv4 frame with IPv4 Options
-                                                             is encountered and the COPIED flag on one of the options is cleared.
-                                                             The counter is located on the port page */
-#endif /* FM_EXP_FEATURES */
 } t_FmPcdManipFragIpParams;
 
 /**************************************************************************//**
@@ -2205,7 +2216,7 @@ typedef struct t_FmPcdManipReassemIpParams {
     uint8_t                         relativeSchemeId[2];    /**< Partition relative scheme id:
                                                                  relativeSchemeId[0] -  Relative scheme ID for IPV4 Reassembly manipulation;
                                                                  relativeSchemeId[1] -  Relative scheme ID for IPV6 Reassembly manipulation;
-                                                                 NOTE: The following is relevant only for v2 devices
+                                                                 NOTE: The following comment is relevant only for FMAN v2 devices:
                                                                  Relative scheme ID for IPv4/IPv6 Reassembly manipulation must be smaller than
                                                                  the user schemes id to ensure that the reassembly's schemes will be first match;
                                                                  Rest schemes, if defined, should have higher relative scheme ID. */
@@ -2307,12 +2318,12 @@ typedef struct t_FmPcdManipHdrFieldUpdateVlanDscpToVpri {
  @Description   Parameters for defining header manipulation VLAN fields updates
 *//***************************************************************************/
 typedef struct t_FmPcdManipHdrFieldUpdateVlan {
-    e_FmPcdManipHdrFieldUpdateVlan  updateType;         /**< Selects VLAN update type */
+    e_FmPcdManipHdrFieldUpdateVlan                  updateType; /**< Selects VLAN update type */
     union {
         uint8_t                                     vpri;       /**< 0-7, Relevant only if If updateType =
                                                                      e_FM_PCD_MANIP_HDR_FIELD_UPDATE_VLAN_PRI, this
                                                                      is the new VLAN pri. */
-        t_FmPcdManipHdrFieldUpdateVlanDscpToVpri    dscpToVpri;/**<  Parameters structure, Relevant only if updateType
+        t_FmPcdManipHdrFieldUpdateVlanDscpToVpri    dscpToVpri; /**< Parameters structure, Relevant only if updateType
                                                                      = e_FM_PCD_MANIP_HDR_FIELD_UPDATE_DSCP_TO_VLAN. */
     } u;
 } t_FmPcdManipHdrFieldUpdateVlan;
@@ -2507,7 +2518,8 @@ typedef struct t_FmPcdManipParams {
         t_FmPcdManipSpecialOffloadParams    specialOffload;     /**< Parameters for defining special offload manipulation node */
     } u;
 
-    t_Handle                                h_NextManip;        /**< Handle to another (previously defined) manipulation node;
+    t_Handle                                h_NextManip;        /**< Supported for Header Manipulation only;
+                                                                     Handle to another (previously defined) manipulation node;
                                                                      Allows concatenation of manipulation actions;
                                                                      This parameter is optional and may be NULL. */
 #ifdef FM_CAPWAP_SUPPORT
@@ -3188,7 +3200,7 @@ t_Error FM_PCD_MatchTableGetNextEngine(t_Handle                     h_CcNode,
                                        uint16_t                     keyIndex,
                                        t_FmPcdCcNextEngineParams    *p_FmPcdCcNextEngineParams);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_PCD_MatchTableGetIndexedHashBucket
 
  @Description   This routine simulates KeyGen operation on the provided key and
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
index 8e0eba5..77d3f05 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/Peripherals/fm_port_ext.h
@@ -72,9 +72,7 @@
                 verifies coherence and returns error if applicable.
 
                 On initialization, user specifies the port type and it's index
-                (relative to the port's type). Host command and offline parsing
-                ports share the same id range, i.e. the user may only initialize
-                port 0 as either host command or offline parsing, but not both.
+                (relative to the port's type) - always starting at 0.
 
  @{
 *//***************************************************************************/
@@ -139,7 +137,8 @@ typedef uint32_t    fmPortFrameErrSelect_t;                         /**< typedef
 
 #define FM_PORT_FRM_ERR_IPRE                    (FM_FD_ERR_IPR & ~FM_FD_IPR)        /**< IPR error */
 #define FM_PORT_FRM_ERR_IPR_NCSP                (FM_FD_ERR_IPR_NCSP & ~FM_FD_IPR)   /**< IPR non-consistent-sp */
-#define FM_PORT_FRM_ERR_IPFE                    FM_FD_ERR_IPF                       /**< IPF error */
+
+#define FM_PORT_FRM_ERR_IPFE                    0 /**< Obsolete; will be removed in the future */
 
 #ifdef FM_CAPWAP_SUPPORT
 #define FM_PORT_FRM_ERR_CRE                     FM_FD_ERR_CRE
@@ -241,7 +240,7 @@ typedef struct t_FmPortRxParams {
 *//***************************************************************************/
 typedef struct t_FmPortNonRxParams {
     uint32_t                errFqid;            /**< Error Queue Id. */
-    uint32_t                dfltFqid;           /**< For Tx and HC - Default Confirmation queue,
+    uint32_t                dfltFqid;           /**< For Tx - Default Confirmation queue,
                                                      0 means no Tx confirmation for processed
                                                      frames. For OP port - default Rx queue. */
     uint32_t                qmChannel;          /**< QM-channel dedicated to this port; will be used
@@ -411,14 +410,14 @@ typedef struct t_FmPortObservedBufPoolDepletion {
  @Description   A structure for defining Tx rate limiting
 *//***************************************************************************/
 typedef struct t_FmPortRateLimit {
-    uint16_t                            maxBurstSize;           /**< in kBytes for Tx ports, in frames
-                                                                     for offline parsing ports. (note that
+    uint16_t                            maxBurstSize;           /**< in KBytes for Tx ports, in frames
+                                                                     for OP ports. (note that
                                                                      for early chips burst size is
                                                                      rounded up to a multiply of 1000 frames).*/
     uint32_t                            rateLimit;              /**< in Kb/sec for Tx ports, in frame/sec for
-                                                                     offline parsing ports. Rate limit refers to
+                                                                     OP ports. Rate limit refers to
                                                                      data rate (rather than line rate). */
-    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For offline parsing ports only. Not-valid
+    e_FmPortDualRateLimiterScaleDown    rateLimitDivider;       /**< For OP ports only. Not-valid
                                                                      for some earlier chip revisions */
 } t_FmPortRateLimit;
 
@@ -442,7 +441,9 @@ typedef struct t_FmPortPerformanceCnt {
  @Description   Calling this routine changes the max number of open DMA's
                 available for this port. It changes this parameter in the
                 internal driver data base from its default configuration
-                [type]
+                [OP: 1]
+                [1G-RX, 1G-TX: 1 (+1)]
+                [10G-RX, 10G-TX: 8 (+8)]
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     p_OpenDmas  A pointer to a structure of parameters defining
@@ -460,7 +461,9 @@ t_Error FM_PORT_ConfigNumOfOpenDmas(t_Handle h_FmPort, t_FmPortRsrc *p_OpenDmas)
  @Description   Calling this routine changes the max number of tasks
                 available for this port. It changes this parameter in the
                 internal driver data base from its default configuration
-                [type]
+                [OP: 1]
+                [1G-RX, 1G-TX: 3 (+2)]
+                [10G-RX, 10G-TX: 16 (+8)]
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_NumOfTasks    A pointer to a structure of parameters defining
@@ -480,6 +483,9 @@ t_Error FM_PORT_ConfigNumOfTasks(t_Handle h_FmPort, t_FmPortRsrc *p_NumOfTasks);
                 This function changes the internal driver data base from its
                 default configuration. Please refer to the driver's User Guide for
                 information on default FIFO sizes in the various devices.
+                [OP: 2KB]
+                [1G-RX, 1G-TX: 11KB]
+                [10G-RX, 10G-TX: 12KB]
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_SizeOfFifo    A pointer to a structure of parameters defining
@@ -579,9 +585,9 @@ t_Error FM_PORT_ConfigDeqByteCnt(t_Handle h_FmPort, uint16_t deqByteCnt);
                 application buffer, and to offset.
                 Calling this routine changes the buffer margins definitions
                 in the internal driver data base from its default
-                configuration: Data size:  [0]
-                               Pass Parser result: [FALSE].
-                               Pass timestamp: [FALSE].
+                configuration: Data size:  [DEFAULT_FM_SP_bufferPrefixContent_privDataSize]
+                               Pass Parser result: [DEFAULT_FM_SP_bufferPrefixContent_passPrsResult].
+                               Pass timestamp: [DEFAULT_FM_SP_bufferPrefixContent_passTimeStamp].
 
                 May be used for all ports
 
@@ -664,7 +670,7 @@ t_Error FM_PORT_ConfigPoolDepletion(t_Handle h_FmPort, t_FmBufPoolDepletion *p_B
 
                 Note: Available for some chips only
 
-                May be used for offline parsing ports only
+                May be used for OP ports only
 
  @Param[in]     h_FmPort                            A handle to a FM Port module.
  @Param[in]     p_FmPortObservedBufPoolDepletion    A structure of parameters for pool depletion.
@@ -679,14 +685,14 @@ t_Error FM_PORT_ConfigObservedPoolDepletion(t_Handle
 /**************************************************************************//**
  @Function      FM_PORT_ConfigExtBufPools
 
- @Description   This routine should be called for offline parsing ports
+ @Description   This routine should be called for OP ports
                 that internally use BM buffer pools. In such cases, e.g. for fragmentation and
                 re-assembly, the FM needs new BM buffers. By calling this routine the user
                 specifies the BM buffer pools that should be used.
 
                 Note: Available for some chips only
 
-                May be used for offline parsing ports only
+                May be used for OP ports only
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
  @Param[in]     p_FmExtPools        A structure of parameters for the external pools.
@@ -724,7 +730,7 @@ t_Error FM_PORT_ConfigBackupPools(t_Handle h_FmPort, t_FmBackupBmPools *p_FmPort
                 in the internal driver data base from its default configuration:
                 override = [FALSE]
 
-                May be used for Rx and offline parsing ports only
+                May be used for Rx and OP ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     override    TRUE to override discarding of error frames and
@@ -747,7 +753,7 @@ t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override);
                 Errors that were not defined either as "ErrorsToEnqueue" nor as
                 "ErrorsToDiscard", will be forwarded to CPU.
 
-                May be used for Rx and offline parsing ports only
+                May be used for Rx and OP ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     errs        A list of errors to discard
@@ -763,7 +769,7 @@ t_Error FM_PORT_ConfigErrorsToDiscard(t_Handle h_FmPort, fmPortFrameErrSelect_t
 
  @Description   Calling this routine changes the DMA swap data aparameter
                 in the internal driver data base from its default
-                configuration  [e_FM_PORT_DMA_NO_SWP]
+                configuration  [DEFAULT_FM_SP_dmaSwapData]
 
                 May be used for all port types
 
@@ -781,7 +787,7 @@ t_Error FM_PORT_ConfigDmaSwapData(t_Handle h_FmPort, e_FmDmaSwapOption swapData)
 
  @Description   Calling this routine changes the internal context cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [e_FM_PORT_DMA_NO_STASH]
+                from its default configuration  [DEFAULT_FM_SP_dmaIntContextCacheAttr]
 
                 May be used for all port types
 
@@ -799,7 +805,7 @@ t_Error FM_PORT_ConfigDmaIcCacheAttr(t_Handle h_FmPort, e_FmDmaCacheOption intCo
 
  @Description   Calling this routine changes the header cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [e_FM_PORT_DMA_NO_STASH]
+                from its default configuration  [DEFAULT_FM_SP_dmaHeaderCacheAttr]
 
                 May be used for all port types
 
@@ -817,7 +823,7 @@ t_Error FM_PORT_ConfigDmaHdrAttr(t_Handle h_FmPort, e_FmDmaCacheOption headerCac
 
  @Description   Calling this routine changes the scatter gather cache
                 attribute parameter in the internal driver data base
-                from its default configuration  [e_FM_PORT_DMA_NO_STASH]
+                from its default configuration  [DEFAULT_FM_SP_dmaScatterGatherCacheAttr]
 
                 May be used for all port types
 
@@ -835,7 +841,7 @@ t_Error FM_PORT_ConfigDmaScatterGatherAttr(t_Handle h_FmPort, e_FmDmaCacheOption
 
  @Description   Calling this routine changes the write optimization
                 parameter in the internal driver data base
-                from its default configuration:  optimize = [TRUE]
+                from its default configuration:  By default optimize = [DEFAULT_FM_SP_dmaWriteOptimize].
                 Note:
 
                 1. For head optimization, data alignment must be >= 16 (supported by default).
@@ -911,7 +917,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
 /**************************************************************************//**
  @Function      FM_PORT_ConfigForwardReuseIntContext
 
- @Description   This routine is relevant for Rx ports that are routed to offline parsing port.
+ @Description   This routine is relevant for Rx ports that are routed to OP port.
                 It changes the internal context reuse option in the internal
                 driver data base from its default configuration:
                 reuse = [FALSE]
@@ -920,7 +926,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq);
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     reuse           TRUE to reuse internal context on frames
-                                forwarded to offline parsing port.
+                                forwarded to OP port.
 
  @Return        E_OK on success; Error code otherwise.
 
@@ -1061,7 +1067,7 @@ t_Error FM_PORT_ConfigIMPolling(t_Handle h_FmPort);
 *//***************************************************************************/
 t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_PORT_ConfigTxFifoMinFillLevel
 
  @Description   Calling this routine changes the fifo minimum
@@ -1079,7 +1085,7 @@ t_Error FM_PORT_ConfigMaxFrameLength(t_Handle h_FmPort, uint16_t length);
 *//***************************************************************************/
 t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLevel);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_PORT_ConfigFifoDeqPipelineDepth
 
  @Description   Calling this routine changes the fifo dequeue
@@ -1099,7 +1105,7 @@ t_Error FM_PORT_ConfigTxFifoMinFillLevel(t_Handle h_FmPort, uint32_t minFillLeve
 *//***************************************************************************/
 t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelineDepth);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_PORT_ConfigTxFifoLowComfLevel
 
  @Description   Calling this routine changes the fifo low comfort level
@@ -1117,7 +1123,7 @@ t_Error FM_PORT_ConfigFifoDeqPipelineDepth(t_Handle h_FmPort, uint8_t deqPipelin
 *//***************************************************************************/
 t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComfLevel);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_PORT_ConfigRxFifoThreshold
 
  @Description   Calling this routine changes the threshold of the FIFO
@@ -1141,7 +1147,7 @@ t_Error FM_PORT_ConfigTxFifoLowComfLevel(t_Handle h_FmPort, uint32_t fifoLowComf
 *//***************************************************************************/
 t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_PORT_ConfigRxFifoPriElevationLevel
 
  @Description   Calling this routine changes the priority elevation level
@@ -1164,11 +1170,16 @@ t_Error FM_PORT_ConfigRxFifoThreshold(t_Handle h_FmPort, uint32_t fifoThreshold)
 *//***************************************************************************/
 t_Error FM_PORT_ConfigRxFifoPriElevationLevel(t_Handle h_FmPort, uint32_t priElevationLevel);
 
+#ifdef FM_BCB_ERRATA_BMI_SW001
+t_Error FM_PORT_ConfigBCBWorkaround(t_Handle h_FmPort);
+#endif /* FM_BCB_ERRATA_BMI_SW001 */
+
 #if (DPAA_VERSION >= 11)
 /**************************************************************************//*
  @Function      FM_PORT_ConfigInternalBuffOffset
 
- @Description   TODO
+ @Description   Configures internal buffer offset.
+
                 May be used for Rx and OP ports only
 
  @Param[in]     h_FmPort            A handle to a FM Port module.
@@ -1229,7 +1240,7 @@ typedef enum e_FmPortCounters {
                 Fields commented 'OUT' will be filled by FM before returning to port.
 *//***************************************************************************/
 typedef struct t_FmPortCongestionGrps {
-    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required congestion groups
+    uint16_t    numOfCongestionGrpsToConsider;          /**< The number of required CGs
                                                              to define the size of the following array */
     uint8_t     congestionGrpsToConsider[FM_PORT_NUM_OF_CONGESTION_GRPS];
                                                         /**< An array of CG indexes;
@@ -1385,7 +1396,7 @@ t_Error FM_PORT_Enable(t_Handle h_FmPort);
                 The selected rate limit specified here would be
                 rounded DOWN to the nearest 16M.
 
-                May be used for Tx and offline parsing ports only
+                May be used for Tx and OP ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_RateLimit     A structure of rate limit parameters
@@ -1402,7 +1413,7 @@ t_Error FM_PORT_SetRateLimit(t_Handle h_FmPort, t_FmPortRateLimit *p_RateLimit);
  @Description   Calling this routine disables and clears rate limit
                 initialization.
 
-                May be used for Tx and offline parsing ports only
+                May be used for Tx and OP ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
 
@@ -1649,7 +1660,7 @@ t_Error FM_PORT_SetRxL4ChecksumVerify(t_Handle h_FmPort, bool l4Checksum);
                 Errors that were configured to be discarded (at initialization)
                 may not be selected here.
 
-                May be used for Rx and offline parsing ports only
+                May be used for Rx and OP ports only
 
  @Param[in]     h_FmPort    A handle to a FM Port module.
  @Param[in]     errs        A list of errors to enqueue to error queue
@@ -1672,10 +1683,12 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs);
  @Return        E_OK on success; Error code otherwise.
 
  @Cautions      Allowed only following FM_PORT_Init().
+                This routine should NOT be called from guest-partition
+                (i.e. guestId != NCSW_MASTER_ID)
 *//***************************************************************************/
 t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception, bool enable);
 
-/**************************************************************************//**
+/**************************************************************************//*
  @Function      FM_PORT_SetPerformanceCounters
 
  @Description   Calling this routine enables/disables port's performance counters.
@@ -1692,8 +1705,8 @@ t_Error FM_PORT_SetIMExceptions(t_Handle h_FmPort, e_FmPortExceptions exception,
 *//***************************************************************************/
 t_Error FM_PORT_SetPerformanceCounters(t_Handle h_FmPort, bool enable);
 
-/**************************************************************************//**
- @Function      FM_PORT_SetPerformanceCountersParams
+/**************************************************************************//*
+ @Function      FM_PORT_SetPerformanceCounters
 
  @Description   Calling this routine defines port's performance
                 counters parameters.
@@ -1808,7 +1821,9 @@ typedef struct t_FmPortPcdPrsParams {
                                                                          incoming frames. */
     uint8_t                         parsingOffset;                  /**< Number of bytes from beginning of packet to start parsing */
     e_NetHeaderType                 firstPrsHdr;                    /**< The type of the first header expected at 'parsingOffset' */
-    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics */
+    bool                            includeInPrsStatistics;         /**< TRUE to include this port in the parser statistics;
+                                                                         NOTE: this field is not valid when the FM is in "guest" mode
+                                                                               and IPC is not available. */
     uint8_t                         numOfHdrsWithAdditionalParams;  /**< Normally 0, some headers may get
                                                                          special parameters */
     t_FmPcdPrsAdditionalHdrParams   additionalParams[FM_PCD_PRS_NUM_OF_HDRS];
@@ -1905,7 +1920,7 @@ typedef struct t_FmPortVSPAllocParams {
                 disabled (BMI to BMI) and configures it according to the passed
                 parameters.
 
-                May be used for Rx and offline parsing ports only
+                May be used for Rx and OP ports only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
  @Param[in]     p_FmPortPcd     A Structure of parameters defining the port's PCD
@@ -1924,7 +1939,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_FmPortPcd);
                 The port returns to its default configuration which is PCD
                 disabled (BMI to BMI) and all PCD configuration is removed.
 
-                May be used for Rx and offline parsing ports which are
+                May be used for Rx and OP ports which are
                 in PCD mode  only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
@@ -1943,7 +1958,7 @@ t_Error FM_PORT_DeletePCD(t_Handle h_FmPort);
                 The couple of routines are used to allow PCD configuration changes
                 that demand that PCD will not be used while changes take place.
 
-                May be used for Rx and offline parsing ports which are
+                May be used for Rx and OP ports which are
                 in PCD mode only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
@@ -1960,7 +1975,7 @@ t_Error FM_PORT_AttachPCD(t_Handle h_FmPort);
  @Description   Calling this routine detaches the port from its PCD functionality.
                 The port returns to its default flow which is BMI to BMI.
 
-                May be used for Rx and offline parsing ports which are
+                May be used for Rx and OP ports which are
                 in PCD mode only
 
  @Param[in]     h_FmPort        A handle to a FM Port module.
@@ -2123,11 +2138,6 @@ t_Error FM_PORT_PcdKgUnbindSchemes (t_Handle h_FmPort, t_FmPcdPortSchemesParams
 *//***************************************************************************/
 t_Error FM_PORT_PcdPrsModifyStartOffset (t_Handle h_FmPort, t_FmPcdPrsStart *p_FmPcdPrsStart);
 
-#if (DPAA_VERSION >= 11)
-#ifdef FM_EXP_FEATURES
-t_Error FM_PORT_GetIPv4OptionsCount(t_Handle h_FmPort, uint32_t *p_Ipv4OptionsCount);
-#endif /* FM_EXP_FEATURES */
-#endif /* (DPAA_VERSION >= 11) */
 
 /** @} */ /* end of FM_PORT_pcd_runtime_control_grp group */
 /** @} */ /* end of FM_PORT_runtime_control_grp group */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
index 0b15dda..f5148d0 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/debug_ext.h
@@ -124,11 +124,11 @@
                 The inputs for this macro are the structure/memory title and
                 its base addresses.
 *//***************************************************************************/
-#define DUMP_TITLE(addr, msg)  \
+#define DUMP_TITLE(addr, msg)           \
     DUMP_Print("\r\n"); DUMP_Print msg; \
-    DUMP_Print(" (0x%p)\r\n" \
-               "---------------------------------------------------------\r\n", \
-               (addr))
+    if (addr)                           \
+        DUMP_Print(" (%p)", (addr));    \
+    DUMP_Print("\r\n---------------------------------------------------------\r\n");
 
 /**************************************************************************//**
  @Description   Prints a subtitle for a subsequent dumped sub-structure (optional).
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
index a45f004..4b3f3b2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/enet_ext.h
@@ -60,7 +60,6 @@ typedef enum e_EnetAddrType
     e_ENET_ADDR_TYPE_BROADCAST      /**< Broadcast address */
 } e_EnetAddrType;
 
-
 /**************************************************************************//**
  @Description   Ethernet MAC-PHY Interface
 *//***************************************************************************/
@@ -152,7 +151,20 @@ typedef enum e_EnetMode
 #define ENET_INTERFACE_FROM_MODE(mode)          (e_EnetInterface)((mode) & 0xFFFF0000)
 #define ENET_SPEED_FROM_MODE(mode)              (e_EnetSpeed)((mode) & 0x0000FFFF)
 
-
+#define ENET_ADDR_TO_UINT64(_enetAddr)                  \
+        (uint64_t)(((uint64_t)(_enetAddr)[0] << 40) |   \
+                   ((uint64_t)(_enetAddr)[1] << 32) |   \
+                   ((uint64_t)(_enetAddr)[2] << 24) |   \
+                   ((uint64_t)(_enetAddr)[3] << 16) |   \
+                   ((uint64_t)(_enetAddr)[4] << 8) |    \
+                   ((uint64_t)(_enetAddr)[5]))
+
+#define MAKE_ENET_ADDR_FROM_UINT64(_addr64, _enetAddr)              \
+        do {                                                        \
+            int i;                                                  \
+            for (i=0; i < ENET_NUM_OCTETS_PER_ADDRESS; i++)         \
+                (_enetAddr)[i] = (uint8_t)((_addr64) >> ((5-i)*8)); \
+        } while (0)
 
 #endif /* __ENET_EXT_H */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
index d8b8488..71f9398 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/error_ext.h
@@ -40,12 +40,17 @@
 #ifndef __ERROR_EXT_H
 #define __ERROR_EXT_H
 
+#if !defined(NCSW_LINUX)
+#include <errno.h>
+#endif
+
 #include "std_ext.h"
 #include "xx_ext.h"
 #include "core_ext.h"
 
 
 
+
 /**************************************************************************//**
  @Group         gen_id  General Drivers Utilities
 
@@ -88,18 +93,45 @@ The scheme below provides the bits description for error codes:
 typedef enum e_ErrorType    /*   Comments / Associated Message Strings                      */
 {                           /* ------------------------------------------------------------ */
     E_OK = 0                /*   Never use "RETURN_ERROR" with E_OK; Use "return E_OK;"     */
-
-    /* Invalid Function Calls */
-    ,E_INVALID_STATE        /**< The operation is not allowed in current module state.      */
+    ,E_WRITE_FAILED = EIO   /**< Write access failed on memory/device.                      */
+                            /*   String: none, or device name.                              */
+    ,E_NO_DEVICE = ENXIO    /**< The associated device is not initialized.                  */
                             /*   String: none.                                              */
-    ,E_INVALID_OPERATION    /**< The operation/command is invalid (unrecognized).           */
+    ,E_NOT_AVAILABLE = EAGAIN
+                            /**< Resource is unavailable.                                   */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_NO_MEMORY = ENOMEM   /**< External memory allocation failed.                         */
+                            /*   String: description of item for which allocation failed.   */
+    ,E_INVALID_ADDRESS = EFAULT
+                            /**< Invalid address.                                           */
+                            /*   String: description of the specific violation.             */
+    ,E_BUSY = EBUSY         /**< Resource or module is busy.                                */
+                            /*   String: none, unless the operation is not the main goal
+                                 of the function (in this case add resource description).   */
+    ,E_ALREADY_EXISTS = EEXIST
+                            /**< Requested resource or item already exists.                 */
+                            /*   Use when resource duplication or sharing are not allowed.
+                                 String: none, unless the operation is not the main goal
+                                 of the function (in this case add item description).       */
+    ,E_INVALID_OPERATION = ENODEV
+                            /**< The operation/command is invalid (unrecognized).           */
                             /*   String: none.                                              */
-    ,E_NOT_SUPPORTED        /**< The function is not supported or not implemented.          */
+    ,E_INVALID_VALUE = EDOM /**< Invalid value.                                             */
+                            /*   Use for non-enumeration parameters, and
+                                 only when other error types are not suitable.
+                                 String: parameter description + "(should be <attribute>)",
+                                 e.g: "Maximum Rx buffer length (should be divisible by 8)",
+                                      "Channel number (should be even)".                    */
+    ,E_NOT_IN_RANGE = ERANGE/**< Parameter value is out of range.                           */
+                            /*   Don't use this error for enumeration parameters.
+                                 String: parameter description + "(should be %d-%d)",
+                                 e.g: "Number of pad characters (should be 0-15)".          */
+    ,E_NOT_SUPPORTED = ENOSYS
+                            /**< The function is not supported or not implemented.          */
                             /*   String: none.                                              */
-    ,E_NO_DEVICE            /**< The associated device is not initialized.                  */
+    ,E_INVALID_STATE        /**< The operation is not allowed in current module state.      */
                             /*   String: none.                                              */
-
-    /* Invalid Parameters */
     ,E_INVALID_HANDLE       /**< Invalid handle of module or object.                        */
                             /*   String: none, unless the function takes in more than one
                                  handle (in this case add the handle description)           */
@@ -108,12 +140,6 @@ typedef enum e_ErrorType    /*   Comments / Associated Message Strings
                                  ID (in this case add the ID description)                   */
     ,E_NULL_POINTER         /**< Unexpected NULL pointer.                                   */
                             /*   String: pointer description.                               */
-    ,E_INVALID_VALUE        /**< Invalid value.                                             */
-                            /*   Use for non-enumeration parameters, and
-                                 only when other error types are not suitable.
-                                 String: parameter description + "(should be <attribute>)",
-                                 e.g: "Maximum Rx buffer length (should be divisible by 8)",
-                                      "Channel number (should be even)".                    */
     ,E_INVALID_SELECTION    /**< Invalid selection or mode.                                 */
                             /*   Use for enumeration values, only when other error types
                                  are not suitable.
@@ -126,93 +152,43 @@ typedef enum e_ErrorType    /*   Comments / Associated Message Strings
                             /*   String: none, unless the function takes in more than one
                                  memory types (in this case add memory description,
                                  e.g: "Data memory", "Buffer descriptors memory").          */
-    ,E_INVALID_INTR_QUEUE   /**< Invalid interrupt queue.                                   */
-                            /*   String: none, unless the function takes in more than one
-                                 interrupt queues (in this case add queue description,
-                                 e.g: "Rx interrupt queue", "Tx interrupt queue").          */
-    ,E_INVALID_PRIORITY     /**< Invalid priority.                                          */
-                            /*   String: none, unless the function takes in more than one
-                                 priority (in this case add priority description).          */
     ,E_INVALID_CLOCK        /**< Invalid clock.                                             */
                             /*   String: none, unless the function takes in more than one
                                  clocks (in this case add clock description,
                                  e.g: "Rx clock", "Tx clock").                              */
-    ,E_INVALID_RATE         /**< Invalid rate value.                                        */
-                            /*   String: none, unless the function takes in more than one
-                                 rate values (in this case add rate description).           */
-    ,E_INVALID_ADDRESS      /**< Invalid address.                                           */
-                            /*   String: description of the specific violation.             */
-    ,E_INVALID_BUS          /**< Invalid bus type.                                          */
-                            /*   String: none, unless the function takes in more than one
-                                 bus parameters (in this case add bus description).         */
-    ,E_BUS_CONFLICT         /**< Bus (or memory) type conflicts with another setting.       */
-                            /*   String: description of the conflicting buses/memories.     */
     ,E_CONFLICT             /**< Some setting conflicts with another setting.               */
                             /*   String: description of the conflicting settings.           */
     ,E_NOT_ALIGNED          /**< Non-aligned address.                                       */
                             /*   String: parameter description + "(should be %d-bytes aligned)",
                                  e.g: "Rx data buffer (should be 32-bytes aligned)".        */
-    ,E_NOT_IN_RANGE         /**< Parameter value is out of range.                           */
-                            /*   Don't use this error for enumeration parameters.
-                                 String: parameter description + "(should be %d-%d)",
-                                 e.g: "Number of pad characters (should be 0-15)".          */
-
-    /* Frame/Buffer Errors */
-    ,E_INVALID_FRAME        /**< Invalid frame object (NULL handle or missing buffers).     */
-                            /*   String: none.                                              */
-    ,E_EMPTY_FRAME          /**< Frame object is empty (has no buffers).                    */
-                            /*   String: none.                                              */
-    ,E_EMPTY_BUFFER         /**< Buffer object is empty (no data, or zero data length).     */
-                            /*   String: none.                                              */
-
-    /* Resource Errors */
-    ,E_NO_MEMORY            /**< External memory allocation failed.                         */
-                            /*   String: description of item for which allocation failed.   */
     ,E_NOT_FOUND            /**< Requested resource or item was not found.                  */
                             /*   Use only when the resource/item is uniquely identified.
                                  String: none, unless the operation is not the main goal
                                  of the function (in this case add item description).       */
-    ,E_NOT_AVAILABLE        /**< Resource is unavailable.                                   */
-                            /*   String: none, unless the operation is not the main goal
-                                 of the function (in this case add resource description).   */
-    ,E_ALREADY_EXISTS       /**< Requested resource or item already exists.                 */
-                            /*   Use when resource duplication or sharing are not allowed.
-                                 String: none, unless the operation is not the main goal
-                                 of the function (in this case add item description).       */
     ,E_FULL                 /**< Resource is full.                                          */
                             /*   String: none, unless the operation is not the main goal
                                  of the function (in this case add resource description).   */
     ,E_EMPTY                /**< Resource is empty.                                         */
                             /*   String: none, unless the operation is not the main goal
                                  of the function (in this case add resource description).   */
-    ,E_BUSY                 /**< Resource or module is busy.                                */
-                            /*   String: none, unless the operation is not the main goal
-                                 of the function (in this case add resource description).   */
     ,E_ALREADY_FREE         /**< Specified resource or item is already free or deleted.     */
                             /*   String: none, unless the operation is not the main goal
                                  of the function (in this case add item description).       */
-
-    /* Read/Write Access Errors */
     ,E_READ_FAILED          /**< Read access failed on memory/device.                       */
                             /*   String: none, or device name.                              */
-    ,E_WRITE_FAILED         /**< Write access failed on memory/device.                      */
-                            /*   String: none, or device name.                              */
-
-    /* Send/Receive Failures */
+    ,E_INVALID_FRAME        /**< Invalid frame object (NULL handle or missing buffers).     */
+                            /*   String: none.                                              */
     ,E_SEND_FAILED          /**< Send operation failed on device.                           */
                             /*   String: none, or device name.                              */
     ,E_RECEIVE_FAILED       /**< Receive operation failed on device.                        */
                             /*   String: none, or device name.                              */
-
-    /* Operation time-out */
-    ,E_TIMEOUT              /**< The operation timed out.                                   */
+    ,E_TIMEOUT/* = ETIMEDOUT*/  /**< The operation timed out.                                   */
                             /*   String: none.                                              */
 
     ,E_DUMMY_LAST           /* NEVER USED */
 
 } e_ErrorType;
 
-
 /**************************************************************************//**
  @Description    Event Type Enumeration
 *//***************************************************************************/
@@ -362,12 +338,31 @@ int ERROR_DYNAMIC_LEVEL = ERROR_GLOBAL_LEVEL;
 #define RETURN_ERROR(_level, _err, _vmsg) \
         return ERROR_CODE(_err)
 
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
 
 #else /* DEBUG_ERRORS > 0 */
 
 extern const char *dbgLevelStrings[];
-extern const char *errTypeStrings[];
 extern const char *moduleStrings[];
+#if (REPORT_EVENTS > 0)
+extern const char *eventStrings[];
+#endif /* (REPORT_EVENTS > 0) */
+
+char * ErrTypeStrings (e_ErrorType err);
 
 
 #if ((defined(DEBUG_USING_STATIC_LEVEL)) && (DEBUG_DYNAMIC_LEVEL < REPORT_LEVEL_WARNING))
@@ -395,7 +390,7 @@ extern const char *moduleStrings[];
                      dbgLevelStrings[REPORT_LEVEL_##_level - 1], \
                      moduleStrings[__ERR_MODULE__ >> 16], \
                      PRINT_FMT_PARAMS, \
-                     errTypeStrings[(GET_ERROR_TYPE(_err) - E_OK - 1)]); \
+                     ErrTypeStrings((e_ErrorType)GET_ERROR_TYPE(_err))); \
             XX_Print _vmsg; \
             XX_Print("\r\n"); \
         } \
@@ -409,6 +404,29 @@ extern const char *moduleStrings[];
     } while (0)
 
 
+#if (REPORT_EVENTS > 0)
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg) \
+    do { \
+        if (_ev##_LEVEL <= EVENT_DYNAMIC_LEVEL) { \
+            XX_Print("~ %s %s Event " PRINT_FORMAT ": %s (flags: 0x%04x); ", \
+                     dbgLevelStrings[_ev##_LEVEL - 1], \
+                     moduleStrings[__ERR_MODULE__ >> 16], \
+                     PRINT_FMT_PARAMS, \
+                     eventStrings[((_ev) - EV_NO_EVENT - 1)], \
+                     (uint16_t)(_flg)); \
+            XX_Print _vmsg; \
+            XX_Print("\r\n"); \
+            XX_EventById((uint32_t)(_ev), (t_Handle)(_appId), (uint16_t)(_flg), NO_MSG); \
+        } \
+    } while (0)
+
+#else /* not REPORT_EVENTS */
+
+#define REPORT_EVENT(_ev, _appId, _flg, _vmsg)
+
+#endif /* (REPORT_EVENTS > 0) */
+
 #endif /* (DEBUG_ERRORS > 0) */
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
index 39456a0..ee6b9f2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/list_ext.h
@@ -32,6 +32,7 @@
 
 
 /**************************************************************************//**
+
  @File          list_ext.h
 
  @Description   External prototypes for list.c
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
index e88330c..d0565d4 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/mem_ext.h
@@ -32,6 +32,7 @@
 
 
 /**************************************************************************//**
+
  @File          mem_ext.h
 
  @Description   External prototypes for the memory manager object
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
index 31690a4..cc5bb72 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/memcpy_ext.h
@@ -32,6 +32,7 @@
 
 
 /**************************************************************************//**
+
  @File          memcpy_ext.h
 
  @Description   Efficient functions for copying and setting blocks of memory.
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
index 5ebc3e7..52f7a9d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/etc/sprint_ext.h
@@ -35,6 +35,7 @@
  @File          sprint_ext.h
 
  @Description   Debug routines (externals).
+
 *//***************************************************************************/
 
 #ifndef __SPRINT_EXT_H
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/common/arch/ppc_access.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/common/arch/ppc_access.h
new file mode 100644
index 0000000..c7b9b46
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/common/arch/ppc_access.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef FL_E500_MACROS_H
+#define FL_E500_MACROS_H
+
+#endif /* FL_E500_MACROS_H */
+
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/common/general.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/common/general.h
new file mode 100644
index 0000000..8150e01
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/common/general.h
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __GENERAL_H
+#define __GENERAL_H
+
+#include "std_ext.h"
+#if !defined(NCSW_LINUX)
+#include "errno.h"
+#endif
+
+
+extern uint32_t get_mac_addr_crc(uint64_t _addr);
+
+
+#define iowrite32be(val, addr)  WRITE_UINT32(*addr, val)
+#define ioread32be(addr)        GET_UINT32(*addr)
+
+#define ether_crc(len, addr)    get_mac_addr_crc(*(uint64_t *)(addr)>>16)
+
+
+#endif /* __GENERAL_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_enet.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_enet.h
new file mode 100644
index 0000000..acf7fce
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/flib/fsl_enet.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_ENET_H
+#define __FSL_ENET_H
+
+/**
+ @Description  Ethernet MAC-PHY Interface
+*/
+
+enum enet_interface {
+    enet_if_mii    = 0x00010000, /**< MII interface */
+    enet_if_rmii   = 0x00020000, /**< RMII interface */
+    enet_if_smii   = 0x00030000, /**< SMII interface */
+    enet_if_gmii   = 0x00040000, /**< GMII interface */
+    enet_if_rgmii  = 0x00050000, /**< RGMII interface */
+    enet_if_tbi    = 0x00060000, /**< TBI interface */
+    enet_if_rtbi   = 0x00070000, /**< RTBI interface */
+    enet_if_sgmii  = 0x00080000, /**< SGMII interface */
+    enet_if_xgmii  = 0x00090000, /**< XGMII interface */
+    enet_if_qsgmii = 0x000a0000, /**< QSGMII interface */
+    enet_if_xfi    = 0x000b0000  /**< XFI interface */
+};
+
+/**
+ @Description  Ethernet Speed (nominal data rate)
+*/
+enum enet_speed {
+    enet_speed_10     = 10,      /**< 10 Mbps */
+    enet_speed_100    = 100,     /**< 100 Mbps */
+    enet_speed_1000   = 1000,    /**< 1000 Mbps = 1 Gbps */
+    enet_speed_10000  = 10000    /**< 10000 Mbps = 10 Gbps */
+};
+
+enum mac_stat_level {
+    /* No statistics */
+    mac_stat_none = 0,
+    /* Only RMON MIB group 1 (ether stats). Optimized for performance */
+    mac_stat_mib_grp1,
+    /* Only error counters are available. Optimized for performance */
+    mac_stat_partial,
+    /* All counters available. Not optimized for performance */
+    mac_stat_full
+};
+
+
+#endif /* __ENET_EXT_H */
+
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
index 68fe2ba..f76cecc 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/dpaa_integration_ext.h
@@ -101,6 +101,7 @@ typedef enum {
 ******************************************************************************/
 #define SEC_NUM_OF_DECOS    2
 #define SEC_ALL_DECOS_MASK  0x00000003
+#define SEC_RNGB
 
 /*****************************************************************************
  FM INTEGRATION-SPECIFIC DEFINITIONS
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
index 2f91e34..dae64f2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P1023/part_integration_ext.h
@@ -39,6 +39,7 @@
 #define __PART_INTEGRATION_EXT_H
 
 #include "std_ext.h"
+#include "ddr_std_ext.h"
 #include "dpaa_integration_ext.h"
 
 
@@ -52,6 +53,7 @@
 
 #define INTG_MAX_NUM_OF_CORES   2
 
+
 /**************************************************************************//**
  @Description   Module types.
 *//***************************************************************************/
@@ -137,6 +139,7 @@ typedef enum e_ModuleId
 
 #define NUM_OF_MODULES  e_MODULE_ID_DUMMY_LAST
 
+
 #define P1023_OFFSET_LAW                    0x00000C08
 #define P1023_OFFSET_ECM                    0x00001000
 #define P1023_OFFSET_DDR                    0x00002000
@@ -378,6 +381,19 @@ t_Error P1023_GetDdrFactor( uintptr_t   gutilBase,
                             uint32_t    *p_DdrDivFactor);
 
 
+/**************************************************************************//**
+ @Function      P1023_GetDdrType
+
+ @Description   returns the multiplication factor of the clock in for the DDR clock .
+
+ @Param[in]     gutilBase       - Base address of P1023 GUTIL registers.
+ @Param         p_DdrType   - (Out) returns DDR type DDR1/DDR2/DDR3.
+
+ @Return        E_OK on success; Other value otherwise.
+*//***************************************************************************/
+t_Error P1023_GetDdrType(uintptr_t gutilBase, e_DdrType *p_DdrType );
+
+
 /** @} */ /* end of 1023_init_grp group */
 /** @} */ /* end of 1023_grp group */
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index 3f0d0ad..327fe3f 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -167,25 +167,24 @@ typedef enum
 #define INTG_MAX_NUM_OF_FM          2
 
 /* Ports defines */
-#define FM_MAX_NUM_OF_1G_RX_PORTS   5
-#define FM_MAX_NUM_OF_10G_RX_PORTS  1
-#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS+FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_1G_TX_PORTS   5
-#define FM_MAX_NUM_OF_10G_TX_PORTS  1
-#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS+FM_MAX_NUM_OF_1G_TX_PORTS)
+#define FM_MAX_NUM_OF_1G_MACS       5
+#define FM_MAX_NUM_OF_10G_MACS      1
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
 #define FM_MAX_NUM_OF_OH_PORTS      7
-#define FM_MAX_NUM_OF_1G_MACS       (FM_MAX_NUM_OF_1G_RX_PORTS)
-#define FM_MAX_NUM_OF_10G_MACS      (FM_MAX_NUM_OF_10G_RX_PORTS)
-#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS+FM_MAX_NUM_OF_10G_MACS)
 
+#define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS)
+
+#define FM_MAX_NUM_OF_1G_TX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_TX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS + FM_MAX_NUM_OF_1G_TX_PORTS)
 
 #define FM_PORT_MAX_NUM_OF_EXT_POOLS            8           /**< Number of external BM pools per Rx port */
 #define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
 #define FM_MAX_NUM_OF_SUB_PORTALS               12
 #define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
 
-#define FM_IPSEC_SUPPORT
-
 /* RAMs defines */
 #define FM_MURAM_SIZE                   (160 * KILOBYTE)
 #define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h
index 519df46..ba17913 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h
@@ -251,12 +251,7 @@ typedef enum
 #define FM_NO_OP_OBSERVED_POOLS
 #define FM_FRAME_END_PARAMS_FOR_OP
 #define FM_DEQ_PIPELINE_PARAMS_FOR_OP
-#define FM_NO_TOTAL_DMAS
 #define FM_QMI_NO_SINGLE_ECC_EXCEPTION
-//TODO - for simulator only, due to wrong reset values. Remove when fixed,
-//and also search for the places it appears in the source files and remove
-//comments of majorRev<6
-#define FM_NO_GUARANTEED_RESET_VALUES
 
 /* FM erratas */
 //#define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
@@ -266,6 +261,8 @@ typedef enum
 #define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2              /* No implementation, Out of LLD scope */
 
 
+
+#define FM_BCB_ERRATA_BMI_SW001
 #define FM_LEN_CHECK_ERRATA_FMAN_SW002
 
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_integration_ext.h
index eb0766b..7f07e13 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_integration_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_integration_ext.h
@@ -233,6 +233,7 @@ typedef enum e_ModuleId
 #define LAW_MIN_WINDOW_SIZE     0x0000000000001000LL    /**< 4 Kbytes */
 #define LAW_MAX_WINDOW_SIZE     0x0000010000000000LL    /**< 1 Tbytes for 40-bit address space */
 
+
 /*****************************************************************************
  LBC INTEGRATION-SPECIFIC DEFINITIONS
 ******************************************************************************/
@@ -288,7 +289,7 @@ typedef enum e_ModuleId
 
 #define GPIO_VALID_PIN_MASKS   \
     { /* Port A */ 0xFFFFFFFF, \
-	  /* Port B */ 0xFFFFFFFF, \
+      /* Port B */ 0xFFFFFFFF, \
       /* Port C */ 0xFFFFFFFF }
 
 #define GPIO_VALID_INTR_MASKS  \
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
index c684647..6827476 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/net_ext.h
@@ -85,6 +85,15 @@ typedef uint8_t headerFieldEth_t;
 
 #define NET_HEADER_FIELD_ETH_ADDR_SIZE                 6
 
+typedef uint16_t headerFieldIp_t;
+
+#define NET_HEADER_FIELD_IP_VER                         (1)
+#define NET_HEADER_FIELD_IP_DSCP                        (NET_HEADER_FIELD_IP_VER << 2)
+#define NET_HEADER_FIELD_IP_ECN                         (NET_HEADER_FIELD_IP_VER << 3)
+#define NET_HEADER_FIELD_IP_PROTO                       (NET_HEADER_FIELD_IP_VER << 4)
+
+#define NET_HEADER_FIELD_IP_PROTO_SIZE                  1
+
 typedef uint16_t headerFieldIpv4_t;
 
 #define NET_HEADER_FIELD_IPv4_VER                       (1)
@@ -369,6 +378,7 @@ typedef enum {
     HEADER_TYPE_VLAN,
     HEADER_TYPE_IPv4,
     HEADER_TYPE_IPv6,
+    HEADER_TYPE_IP,
     HEADER_TYPE_TCP,
     HEADER_TYPE_UDP,
     HEADER_TYPE_IPHC,
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk b/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
index 540db18..26e847d 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
@@ -20,6 +20,7 @@ EXTRA_CFLAGS += -I$(NCSW)/inc
 EXTRA_CFLAGS += -I$(NCSW)/inc/cores
 EXTRA_CFLAGS += -I$(NCSW)/inc/etc
 EXTRA_CFLAGS += -I$(NCSW)/inc/Peripherals
+EXTRA_CFLAGS += -I$(NCSW)/inc/flib
 
 ifeq ("$(CONFIG_FMAN_P3040_P4080_P5020)", "y")
 EXTRA_CFLAGS += -I$(NCSW)/inc/integrations/P3040_P4080_P5020
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
index eb894b9..cd830db 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
@@ -892,12 +892,9 @@ static int /*__devinit*/ fm_probe(struct platform_device *of_dev)
     if (InitFmDev(p_LnxWrpFmDev) != E_OK)
         return -EIO;
 
-/* FIXME: ioctl support for FMan v3 features is not ready yet */
-#if (DPAA_VERSION == 10)
     /* IOCTL ABI checking */
     LnxWrpPCDIOCTLEnumChecking();
     LnxWrpPCDIOCTLTypeChecking();
-#endif
 
     Sprint (p_LnxWrpFmDev->name, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
index c2fcdf6..a411a65 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
@@ -581,7 +581,7 @@ Status: not exported
     FM_VSP_ConfigPoolDepletion
     FM_VSP_ConfigBufferPrefixContent
     FM_VSP_ConfigNoScatherGather
-    FM_VSP_GetStatistics -- its not available yet
+    FM_VSP_GetStatistics -- it's not available yet
     FM_VSP_GetBufferPrsResult
 #endif
 
diff --git a/include/linux/fmd/Peripherals/fm_ioctls.h b/include/linux/fmd/Peripherals/fm_ioctls.h
index f0904a1..437eb10 100644
--- a/include/linux/fmd/Peripherals/fm_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_ioctls.h
@@ -100,7 +100,6 @@ typedef enum ioc_fm_port_type {
 #define FM_FD_ERR_IPR_NCSP              (0x00100000 | FM_FD_IPR)    /**< IPR non-consistent-sp */
 #define FM_FD_ERR_IPR                   (0x00200000 | FM_FD_IPR)    /**< IPR error */
 #define FM_FD_ERR_IPR_TO                (0x00300000 | FM_FD_IPR)    /**< IPR timeout */
-#define FM_FD_ERR_IPF                   0x00100000                  /**< IPF error */
 
 #ifdef FM_CAPWAP_SUPPORT
 #define FM_FD_ERR_CRE                   0x00200000
@@ -134,7 +133,6 @@ typedef enum ioc_fm_port_type {
                                          FM_FD_ERR_IPR                  | \
                                          FM_FD_ERR_IPR_TO               | \
                                          FM_FD_ERR_IPR_NCSP             | \
-                                         FM_FD_ERR_IPF                  | \
                                          FM_FD_ERR_PHYSICAL             | \
                                          FM_FD_ERR_SIZE                 | \
                                          FM_FD_ERR_CLS_DISCARD          | \
-- 
1.7.9.7

