From 33dd95d2ae8edd4f65bc48509204e98df0aecca1 Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Thu, 18 Oct 2012 17:06:01 +0300
Subject: [PATCH 111/227] fmd: add IOCTLs for the frame replicator API

Add required IOCTL for the frame replicator API.
The Frame replicator APIs enable the FMAN to enqueue the same incoming
frame to several FQs defined into a frame replicator group.
Header manipulation operations may be applied on group or for each member/FQ.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c   |  149 +++++++++++++++++++-
 .../src/wrapper/lnxwrp_ioctls_fm_compat.c          |   33 +++++
 .../src/wrapper/lnxwrp_ioctls_fm_compat.h          |   16 +++
 include/linux/fmd/Peripherals/fm_pcd_ioctls.h      |   37 +++++
 4 files changed, 234 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
index d2a6664..c2fcdf6 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm.c
@@ -428,7 +428,7 @@ void LnxWrpPCDIOCTLTypeChecking(void)
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_frag_stats_t) == sizeof(t_FmPcdManipFragStats));
     ASSERT_COND(sizeof(ioc_fm_pcd_manip_stats_t) == sizeof(t_FmPcdManipStats));
 #if DPAA_VERSION >= 11
-    ASSERT_COND(sizeof(ioc_fm_pcd_frm_replic_group_params_t) == sizeof(t_FmPcdFrmReplicGroupParams));
+    ASSERT_COND(sizeof(ioc_fm_pcd_frm_replic_group_params_t) == sizeof(t_FmPcdFrmReplicGroupParams) + sizeof(void *));
 #endif
 
     /* fm_port_ext.h == fm_port_ioctls.h */
@@ -2584,6 +2584,153 @@ invalid_port_id:
             break;
         }
 
+#if (DPAA_VERSION >= 11)
+#if defined(CONFIG_COMPAT)
+	case FM_PCD_IOC_FRM_REPLIC_GROUP_SET_COMPAT:
+#endif
+	case FM_PCD_IOC_FRM_REPLIC_GROUP_SET:
+	{
+		ioc_fm_pcd_frm_replic_group_params_t *param;
+
+		param = (ioc_fm_pcd_frm_replic_group_params_t *) XX_Malloc(
+				sizeof(ioc_fm_pcd_frm_replic_group_params_t));
+		if (!param)
+			RETURN_ERROR(MINOR, E_NO_MEMORY, ("IOCTL FM PCD"));
+
+		memset(param, 0, sizeof(ioc_fm_pcd_plcr_profile_params_t));
+
+#if defined(CONFIG_COMPAT)
+		if (compat)
+		{
+			ioc_compat_fm_pcd_frm_replic_group_params_t
+				*compat_param;
+
+			compat_param =
+				(ioc_compat_fm_pcd_frm_replic_group_params_t *)
+					XX_Malloc(sizeof(*compat_param));
+			if (!compat_param)
+			{
+				XX_Free(param);
+				RETURN_ERROR(MINOR, E_NO_MEMORY,
+						("IOCTL FM PCD"));
+			}
+
+			memset(compat_param, 0, sizeof(*compat_param));
+			if (copy_from_user(compat_param,
+				(ioc_compat_fm_pcd_frm_replic_group_params_t *)
+					compat_ptr(arg),
+					sizeof(*compat_param))) {
+				XX_Free(compat_param);
+				XX_Free(param);
+				RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+			}
+
+			compat_copy_fm_pcd_frm_replic_group_params(compat_param,
+					param, COMPAT_US_TO_K);
+
+			XX_Free(compat_param);
+		}
+		else
+#endif
+		{
+			if (copy_from_user(param,
+				(ioc_fm_pcd_frm_replic_group_params_t *)arg,
+				sizeof(ioc_fm_pcd_frm_replic_group_params_t)))
+			{
+				XX_Free(param);
+				RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+			}
+		}
+
+		param->id = FM_PCD_FrmReplicSetGroup(p_LnxWrpFmDev->h_PcdDev,
+				(t_FmPcdFrmReplicGroupParams*)param);
+
+		if (!param->id) {
+			XX_Free(param);
+			err = E_INVALID_VALUE;
+			/*
+			 * Since the LLD has no errno-style error reporting,
+			 * we're left here with no other option than to report
+			 * a generic E_INVALID_VALUE
+			 */
+			break;
+		}
+
+#if defined(CONFIG_COMPAT)
+		if (compat)
+		{
+			ioc_compat_fm_pcd_frm_replic_group_params_t
+				*compat_param;
+
+			compat_param =
+				(ioc_compat_fm_pcd_frm_replic_group_params_t *)
+					XX_Malloc(sizeof(*compat_param));
+			if (!compat_param)
+			{
+				XX_Free(param);
+				RETURN_ERROR(MINOR, E_NO_MEMORY,
+						("IOCTL FM PCD"));
+			}
+
+			memset(compat_param, 0, sizeof(*compat_param));
+			compat_copy_fm_pcd_frm_replic_group_params(compat_param,
+					param, COMPAT_K_TO_US);
+			if (copy_to_user(
+				(ioc_compat_fm_pcd_frm_replic_group_params_t *)
+					compat_ptr(arg),
+					compat_param,
+					sizeof(*compat_ptr)))
+				err = E_WRITE_FAILED;
+
+			XX_Free(compat_param);
+		}
+		else
+#endif
+		{
+			if (copy_to_user(
+				(ioc_fm_pcd_frm_replic_group_params_t *)arg,
+				param,
+				sizeof(ioc_fm_pcd_frm_replic_group_params_t)))
+				err = E_WRITE_FAILED;
+		}
+
+		XX_Free(param);
+		break;
+	}
+	break;
+
+#if defined(CONFIG_COMPAT)
+	case FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE_COMPAT:
+#endif
+	case FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE:
+	{
+		ioc_fm_obj_t id;
+
+		memset(&id, 0, sizeof(ioc_fm_obj_t));
+#if defined(CONFIG_COMPAT)
+		if (compat)
+		{
+			ioc_compat_fm_obj_t compat_id;
+
+			if (copy_from_user(&compat_id,
+					(ioc_compat_fm_obj_t *) compat_ptr(arg),
+					sizeof(ioc_compat_fm_obj_t)))
+				break;
+			compat_obj_delete(&compat_id, &id);
+		}
+		else
+#endif
+		{
+			if (copy_from_user(&id, (ioc_fm_obj_t *) arg,
+					sizeof(ioc_fm_obj_t)))
+				break;
+		}
+
+		return FM_PCD_FrmReplicDeleteGroup(id.obj);
+	}
+	break;
+#endif
+
 #ifdef FM_CAPWAP_SUPPORT
 #warning "feature not supported!"
 #if defined(CONFIG_COMPAT)
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
index 9e03eaa..4edf928 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -1022,3 +1022,36 @@ void compat_fm_pcd_manip_set_node(
     }
 }
 
+#if DPAA_VERSION >= 11
+void compat_copy_fm_pcd_frm_replic_group_params(
+	ioc_compat_fm_pcd_frm_replic_group_params_t *compat_param,
+	ioc_fm_pcd_frm_replic_group_params_t *param,
+	uint8_t compat)
+{
+	int k;
+
+	_fm_cpt_dbg (compat, " {->...\n");
+
+	if (compat == COMPAT_US_TO_K)
+	{
+		param->max_num_of_entries = compat_param->max_num_of_entries;
+		param->num_of_entries = compat_param->num_of_entries;
+		param->id = compat_pcd_id2ptr(compat_param->id);
+	}
+	else
+	{
+		compat_param->max_num_of_entries = param->max_num_of_entries;
+		compat_param->num_of_entries = param->num_of_entries;
+		compat_param->id = compat_add_ptr2id(param->id,
+				FM_MAP_TYPE_PCD_NODE);
+	}
+
+	for (k=0; k < IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES; k++)
+		compat_copy_fm_pcd_cc_next_engine(
+				&compat_param->next_engine_params[k],
+				&param->next_engine_params[k],
+				compat);
+
+	_fm_cpt_dbg (compat, " ...->}\n");
+}
+#endif
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
index acaba3f..183bb66 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_ioctls_fm_compat.h
@@ -450,6 +450,16 @@ typedef struct ioc_compat_fm_pcd_manip_params_t {
     compat_uptr_t                                 id;
 } ioc_compat_fm_pcd_manip_params_t;
 
+#if DPAA_VERSION >= 11
+typedef struct ioc_compat_fm_pcd_frm_replic_group_params_t {
+	uint8_t                     max_num_of_entries;
+	uint8_t                     num_of_entries;
+	ioc_compat_fm_pcd_cc_next_engine_params_t
+		next_engine_params[IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
+	compat_uptr_t               id;
+} ioc_compat_fm_pcd_frm_replic_group_params_t;
+#endif /* DPAA_VERSION >= 11 */
+
 /* } pcd compat structures */
 
 void compat_obj_delete(
@@ -557,5 +567,11 @@ void compat_copy_fm_port_pcd_modify_tree(
         ioc_fm_obj_t *id,
         uint8_t compat);
 
+#if DPAA_VERSION >= 11
+void compat_copy_fm_pcd_frm_replic_group_params(
+	ioc_compat_fm_pcd_frm_replic_group_params_t *compat_param,
+	ioc_fm_pcd_frm_replic_group_params_t *param,
+	uint8_t compat);
+#endif
 /* } pcd compat functions */
 #endif
diff --git a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
index 7d1eeaf..2d437a1 100644
--- a/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
+++ b/include/linux/fmd/Peripherals/fm_pcd_ioctls.h
@@ -2088,6 +2088,7 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
     uint8_t                     num_of_entries;       /**< Number of members in the group - must be at least 1 */
     ioc_fm_pcd_cc_next_engine_params_t   next_engine_params[IOC_FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES];
                                                     /**< Array of members' parameters */
+    void                        *id;
 } ioc_fm_pcd_frm_replic_group_params_t;
 #endif /* DPAA_VERSION >= 11 */
 
@@ -2544,6 +2545,42 @@ typedef struct ioc_fm_pcd_frm_replic_group_params_t {
 *//***************************************************************************/
 #define FM_PCD_IOC_SET_ADVANCED_OFFLOAD_SUPPORT _IO(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(45))
 
+#if (DPAA_VERSION >= 11)
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicSetGroup
+
+ @Description   Initialize a Frame Replicator group.
+
+ @Param[in]     h_FmPcd                FM PCD module descriptor.
+ @Param[in]     p_FrmReplicGroupParam  A structure of parameters for the initialization of
+                                       the frame replicator group.
+
+ @Return        A handle to the initialized object on success; NULL code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_Init().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_compat_fm_pcd_frm_replic_group_params_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_SET _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(46), ioc_fm_pcd_frm_replic_group_params_t)
+
+/**************************************************************************//**
+ @Function      FM_PCD_FrmReplicDeleteGroup
+
+ @Description   Delete a Frame Replicator group.
+
+ @Param[in]     h_FrmReplicGroup  A handle to the frame replicator group.
+
+ @Return        E_OK on success;  Error code otherwise.
+
+ @Cautions      Allowed only following FM_PCD_FrmReplicSetGroup().
+*//***************************************************************************/
+#if defined(CONFIG_COMPAT)
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE_COMPAT _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_compat_fm_obj_t)
+#endif
+#define FM_PCD_IOC_FRM_REPLIC_GROUP_DELETE _IOWR(FM_IOC_TYPE_BASE, FM_PCD_IOC_NUM(47), ioc_fm_obj_t)
+#endif
+
 #ifdef FM_CAPWAP_SUPPORT
 #warning "CAPWAP IOCTL not implemented"
 /**************************************************************************//**
-- 
1.7.9.7

