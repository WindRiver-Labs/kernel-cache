From 668f85ff3a4f7b29ae62905f72c24bb1295f03d4 Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Thu, 8 Dec 2011 01:20:27 -0600
Subject: [PATCH 015/227] Preliminary thread support for e6500

Add support for starting hardware threads on e6500.

The general idea is that each core will release all of its
threads into the secondary thread startup code, which will
eventually wait in the secondary core holding area, for the
appropriate bit in the PACA to be set. The kick_cpu function
pointer will set that bit in the PACA, and thus "release"
the core/thread to boot.

This is my third attempt. It boots with 24 threads. The big
change was the simulator, but I also moved thread enabling so
that only the first thread was doing it.

Caches are probably screwed up, as the "restore" function
doesn't know about the shared nature of the caches.

Also of note: there's no MMU protection. I was hoping that we could
show threads working without robustness, but that may be wrong. :)

Signed-off-by: Andy Fleming <afleming@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso. Just some minor context
mods in order to port to 3.4 kernel.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/include/asm/cputable.h  |    2 +-
 arch/powerpc/include/asm/reg_booke.h |   23 ++++++++++++++++
 arch/powerpc/kernel/exceptions-64e.S |   48 ++++++++++++++++++++++++++--------
 arch/powerpc/kernel/head_64.S        |   18 ++++++++++---
 arch/powerpc/kernel/prom.c           |   31 +++++++++-------------
 arch/powerpc/kernel/setup-common.c   |    9 ++++---
 arch/powerpc/kernel/setup_64.c       |    2 +-
 arch/powerpc/platforms/85xx/Kconfig  |    8 ++++++
 arch/powerpc/platforms/85xx/smp.c    |   14 ++++++++++
 9 files changed, 116 insertions(+), 39 deletions(-)

diff --git a/arch/powerpc/include/asm/cputable.h b/arch/powerpc/include/asm/cputable.h
index 74eb305..c1b4af2 100644
--- a/arch/powerpc/include/asm/cputable.h
+++ b/arch/powerpc/include/asm/cputable.h
@@ -394,7 +394,7 @@ extern const char *powerpc_base_platform;
 #define CPU_FTRS_E6500	(CPU_FTR_USE_TB | CPU_FTR_NODSISRALIGN | \
 	    CPU_FTR_L2CSR | CPU_FTR_LWSYNC | CPU_FTR_NOEXECUTE | \
 	    CPU_FTR_DBELL | CPU_FTR_POPCNTB | CPU_FTR_POPCNTD | \
-	    CPU_FTR_DEBUG_LVL_EXC | CPU_FTR_EMB_HV)
+	    CPU_FTR_DEBUG_LVL_EXC | CPU_FTR_EMB_HV | CPU_FTR_SMT)
 #define CPU_FTRS_GENERIC_32	(CPU_FTR_COMMON | CPU_FTR_NODSISRALIGN)
 
 /* 64-bit CPUs */
diff --git a/arch/powerpc/include/asm/reg_booke.h b/arch/powerpc/include/asm/reg_booke.h
index 0400a1d..7a86966 100644
--- a/arch/powerpc/include/asm/reg_booke.h
+++ b/arch/powerpc/include/asm/reg_booke.h
@@ -707,5 +707,28 @@
 #define MMUBE1_VBE4		0x00000002
 #define MMUBE1_VBE5		0x00000001
 
+#ifdef CONFIG_FSL_THREADS
+#define TMRN_TPRI0	0x0C0	/* Thread Priority Register 0 */
+#define TMRN_TPRI1	0x0C1	/* Thread Priority Register 1 */
+#define TMRN_TPRI2	0x0C2	/* Thread Priority Register 2 */
+#define TMRN_INIA0	0x140	/* Next Instruction Address Register 0 */
+#define TMRN_INIA1	0x141	/* Next Instruction Address Register 1 */
+#define TMRN_INIA2	0x142	/* Next Instruction Address Register 2 */
+#define TMRN_IMSR0	0x120	/* Initial MSR Register 0 */
+#define TMRN_IMSR1	0x121	/* Initial MSR Register 1 */
+#define SPRN_TENSR	0x1b5	/* Thread Enable Status Register */
+#define SPRN_TENS	0x1b6	/* Thread Enable Set Register */
+#define SPRN_TENC	0x1b7	/* Thread Enable Clear Register */
+
+#define TEN_THREAD(x)	(1 << x)
+
+#define SPRN_PPR32	0x382	/* Processor Priority Register */
+
+#define TMRN(x)		(((x & 0x1f) << 16) | ((x & 0x3e0) << 6))
+#define MTTMR(tmr, reg)	.long (0x7c0003dc | TMRN(tmr) | (reg << 21))
+#define MFTMR(tmr, reg)	.long (0x7c0002dc | TMRN(tmr) | (reg << 21))
+
+#endif
+
 #endif /* __ASM_POWERPC_REG_BOOKE_H__ */
 #endif /* __KERNEL__ */
diff --git a/arch/powerpc/kernel/exceptions-64e.S b/arch/powerpc/kernel/exceptions-64e.S
index fc57393..89ddf09 100644
--- a/arch/powerpc/kernel/exceptions-64e.S
+++ b/arch/powerpc/kernel/exceptions-64e.S
@@ -1284,6 +1284,11 @@ _GLOBAL(book3e_secondary_core_init)
 	/* Init global core bits */
 2:	bl	.init_core_book3e
 
+#ifdef CONFIG_FSL_THREADS
+	/* Start threads */
+	bl      .fsl_enable_threads
+#endif
+
 	/* Init per-thread bits */
 3:	bl	.init_thread_book3e
 
@@ -1324,6 +1329,27 @@ _GLOBAL(init_core_book3e)
 	sync
 	blr
 
+#ifdef CONFIG_FSL_THREADS
+_GLOBAL(fsl_enable_threads)
+	/* Configure the MSR per the default */
+	LOAD_REG_IMMEDIATE(r3, MSR_KERNEL);
+	MTTMR(TMRN_IMSR1, 3);
+
+	/*
+	 * Set the NIA for the secondary thread to
+	 * generic_secondary_thread_init
+	 */
+	LOAD_REG_IMMEDIATE(r3, .fsl_secondary_thread_init);
+	MTTMR(TMRN_INIA1, 3);
+
+	/* Release the other thread. It will spin until kick_cpu is called */
+	li	r3, 2
+	mtspr	SPRN_TENS, r3
+
+	blr
+#endif
+
+
 _STATIC(init_thread_book3e)
 	lis	r3,(SPRN_EPCR_ICM | SPRN_EPCR_GICM)@h
 	mtspr	SPRN_EPCR,r3
@@ -1342,18 +1368,18 @@ _STATIC(init_thread_book3e)
 _GLOBAL(__setup_base_ivors)
 	SET_IVOR(0, 0x020) /* Critical Input */
 	SET_IVOR(1, 0x000) /* Machine Check */
-	SET_IVOR(2, 0x060) /* Data Storage */ 
+	SET_IVOR(2, 0x060) /* Data Storage */
 	SET_IVOR(3, 0x080) /* Instruction Storage */
-	SET_IVOR(4, 0x0a0) /* External Input */ 
-	SET_IVOR(5, 0x0c0) /* Alignment */ 
-	SET_IVOR(6, 0x0e0) /* Program */ 
-	SET_IVOR(7, 0x100) /* FP Unavailable */ 
-	SET_IVOR(8, 0x120) /* System Call */ 
-	SET_IVOR(9, 0x140) /* Auxiliary Processor Unavailable */ 
-	SET_IVOR(10, 0x160) /* Decrementer */ 
-	SET_IVOR(11, 0x180) /* Fixed Interval Timer */ 
-	SET_IVOR(12, 0x1a0) /* Watchdog Timer */ 
-	SET_IVOR(13, 0x1c0) /* Data TLB Error */ 
+	SET_IVOR(4, 0x0a0) /* External Input */
+	SET_IVOR(5, 0x0c0) /* Alignment */
+	SET_IVOR(6, 0x0e0) /* Program */
+	SET_IVOR(7, 0x100) /* FP Unavailable */
+	SET_IVOR(8, 0x120) /* System Call */
+	SET_IVOR(9, 0x140) /* Auxiliary Processor Unavailable */
+	SET_IVOR(10, 0x160) /* Decrementer */
+	SET_IVOR(11, 0x180) /* Fixed Interval Timer */
+	SET_IVOR(12, 0x1a0) /* Watchdog Timer */
+	SET_IVOR(13, 0x1c0) /* Data TLB Error */
 	SET_IVOR(14, 0x1e0) /* Instruction TLB Error */
 	SET_IVOR(15, 0x040) /* Debug */
 
diff --git a/arch/powerpc/kernel/head_64.S b/arch/powerpc/kernel/head_64.S
index 8350aba..3e229af6 100644
--- a/arch/powerpc/kernel/head_64.S
+++ b/arch/powerpc/kernel/head_64.S
@@ -167,6 +167,12 @@ exception_marker:
 #include "exceptions-64s.S"
 #endif
 
+#ifdef CONFIG_FSL_THREADS
+_GLOBAL(fsl_secondary_thread_init)
+	mfspr	r3, SPRN_PIR
+	rlwimi	r3, r3, 30, 2, 30
+#endif
+
 _GLOBAL(generic_secondary_thread_init)
 	mr	r24,r3
 
@@ -301,7 +307,7 @@ _STATIC(__mmu_off)
  *
  *   r5 != NULL -> OF entry, we go to prom_init, "legacy" parameter content
  *                 in r3...r7
- *   
+ *
  *   r5 == NULL -> kexec style entry. r3 is a physical pointer to the
  *                 DT block, r4 is a physical pointer to the kernel itself
  *
@@ -551,7 +557,7 @@ __secondary_start_pmac_0:
 	b	1f
 	li	r24,3
 1:
-	
+
 _GLOBAL(pmac_secondary_start)
 	/* turn on 64-bit mode */
 	bl	.enable_64b_mode
@@ -656,7 +662,7 @@ __secondary_start:
 	RFI
 	b	.	/* prevent speculative execution */
 
-/* 
+/*
  * Running with relocation on at this point.  All we want to do is
  * zero the stack back-chain pointer and get the TOC virtual address
  * before going into C code.
@@ -783,7 +789,7 @@ _INIT_STATIC(start_here_multiplatform)
 	mtspr	SPRN_SRR1,r4
 	RFI
 	b	.	/* prevent speculative execution */
-	
+
 	/* This is where all platforms converge execution */
 _INIT_GLOBAL(start_here_common)
 	/* relocation is on at this point */
@@ -795,6 +801,10 @@ _INIT_GLOBAL(start_here_common)
 	/* Do more system initializations in virtual mode */
 	bl	.setup_system
 
+#ifdef CONFIG_FSL_THREADS
+	bl	.fsl_enable_threads
+#endif
+
 	/* Mark interrupts soft and hard disabled (they might be enabled
 	 * in the PACA when doing hotplug)
 	 */
diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c
index b021ff0..120edb7 100644
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@ -309,12 +309,10 @@ static int __init early_init_dt_scan_cpus(unsigned long node,
 
 	/* Get physical cpuid */
 	intserv = of_get_flat_dt_prop(node, "ibm,ppc-interrupt-server#s", &len);
-	if (intserv) {
-		nthreads = len / sizeof(int);
-	} else {
-		intserv = of_get_flat_dt_prop(node, "reg", NULL);
-		nthreads = 1;
-	}
+	if (!intserv)
+		intserv = of_get_flat_dt_prop(node, "reg", &len);
+
+	nthreads = len / sizeof(int);
 
 	/*
 	 * Now see if any of these threads match our boot cpu.
@@ -851,23 +849,18 @@ struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
 		intserv = of_get_property(np, "ibm,ppc-interrupt-server#s",
 				&plen);
 		if (intserv == NULL) {
-			const u32 *reg = of_get_property(np, "reg", NULL);
-			if (reg == NULL)
+			intserv = of_get_property(np, "reg", &plen);
+			if (intserv == NULL)
 				continue;
-			if (*reg == hardid) {
+		}
+
+		plen /= sizeof(u32);
+		for (t = 0; t < plen; t++) {
+			if (hardid == intserv[t]) {
 				if (thread)
-					*thread = 0;
+					*thread = t;
 				return np;
 			}
-		} else {
-			plen /= sizeof(u32);
-			for (t = 0; t < plen; t++) {
-				if (hardid == intserv[t]) {
-					if (thread)
-						*thread = t;
-					return np;
-				}
-			}
 		}
 	}
 	return NULL;
diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c
index bdc499c..1f6cbae0c 100644
--- a/arch/powerpc/kernel/setup-common.c
+++ b/arch/powerpc/kernel/setup-common.c
@@ -444,16 +444,19 @@ void __init smp_setup_cpu_maps(void)
 		intserv = of_get_property(dn, "ibm,ppc-interrupt-server#s",
 				&len);
 		if (intserv) {
-			nthreads = len / sizeof(int);
 			DBG("    ibm,ppc-interrupt-server#s -> %d threads\n",
 			    nthreads);
 		} else {
 			DBG("    no ibm,ppc-interrupt-server#s -> 1 thread\n");
-			intserv = of_get_property(dn, "reg", NULL);
-			if (!intserv)
+			intserv = of_get_property(dn, "reg", &len);
+			if (!intserv) {
 				intserv = &cpu;	/* assume logical == phys */
+				len = 4;
+			}
 		}
 
+		nthreads = len / sizeof(int);
+
 		for (j = 0; j < nthreads && cpu < nr_cpu_ids; j++) {
 			DBG("    thread %d -> cpu %d (hard id %d)\n",
 			    j, cpu, intserv[j]);
diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c
index 389bd4f..e45f21c 100644
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@ -421,7 +421,7 @@ void __init setup_system(void)
 	smp_setup_cpu_maps();
 	check_smt_enabled();
 
-#ifdef CONFIG_SMP
+#if defined(CONFIG_SMP) && !defined(CONFIG_FSL_THREADS)
 	/* Release secondary cpus out of their spinloops at 0x60 now that
 	 * we can map physical -> logical CPU ids
 	 */
diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 1f433b3..7b7dde8 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -285,6 +285,14 @@ config B4860_QDS
 	help
 	  This option enables support for the B4860 QDS board
 
+# Note that this is a big hack, surely we have to figure this out
+# at runtime.
+config FSL_THREADS
+	bool "Freescale smt"
+	default y
+	help
+	  This option enables support for e6500 SMT
+
 config P5020_DS
 	bool "Freescale P5020 DS"
 	select DEFAULT_UIMAGE
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index 7aca627..5019d5b 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -26,6 +26,7 @@
 #include <asm/cacheflush.h>
 #include <asm/dbell.h>
 #include <asm/fsl_guts.h>
+#include <asm/cputhreads.h>
 
 #include <sysdev/fsl_soc.h>
 #include <sysdev/mpic.h>
@@ -229,6 +230,19 @@ static int __cpuinit smp_85xx_kick_cpu(int nr)
 
 	pr_debug("smp_85xx_kick_cpu: kick CPU #%d\n", nr);
 
+#ifdef CONFIG_PPC64
+	/* If the cpu we're kicking is a thread, kick it and return */
+	if (cpu_thread_in_core(nr) != 0) {
+		local_irq_save(flags);
+
+		smp_generic_kick_cpu(nr);
+
+		local_irq_restore(flags);
+
+		return 0;
+	}
+#endif
+
 	np = of_get_cpu_node(nr, NULL);
 	cpu_rel_addr = of_get_property(np, "cpu-release-addr", NULL);
 
-- 
1.7.9.7

