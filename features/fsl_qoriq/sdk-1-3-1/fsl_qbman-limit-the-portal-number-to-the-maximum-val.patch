From 0f01fd547faacfe04b24dbb6a7e45c86cf117b9d Mon Sep 17 00:00:00 2001
From: Hai-Ying Wang <Haiying.Wang@freescale.com>
Date: Thu, 4 Oct 2012 21:05:17 +0000
Subject: [PATCH 086/227] fsl_qbman: limit the portal number to the maximum
 value

Set qman_portal_max and bman_portal_max according to portal info passed by dts,
then limit the portal intialization according to the max values. This allows us
to consolidate the portal feature of the same QMan/BMan version in one dtsi.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/bman_driver.c |   30 ++++++++++++++++++++++------
 drivers/staging/fsl_qbman/qman_driver.c |   33 ++++++++++++++++++++++++++-----
 2 files changed, 52 insertions(+), 11 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 0f0a635..12f8769 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -38,6 +38,7 @@ u16 bman_ip_rev;
 EXPORT_SYMBOL(bman_ip_rev);
 u16 bman_pool_max;
 EXPORT_SYMBOL(bman_pool_max);
+u16 bman_portal_max;
 
 /* After initialising cpus that own shared portal configs, we cache the
  * resulting portals (ie. not just the configs) in this array. Then we
@@ -110,19 +111,32 @@ static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 		return NULL;
 	}
 
-	if (of_device_is_compatible(node, "fsl,bman-portal-1.0")) {
+	if (of_device_is_compatible(node, "fsl,bman-portal-1.0") ||
+		of_device_is_compatible(node, "fsl,bman-portal-1.0.0")) {
 		bman_ip_rev = BMAN_REV10;
 		bman_pool_max = 64;
-	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.0")) {
+		bman_portal_max = 10;
+	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.0") ||
+	 	of_device_is_compatible(node, "fsl,bman-portal-2.0.8")) {
 		bman_ip_rev = BMAN_REV20;
 		bman_pool_max = 8;
-	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.1-0") ||
-		of_device_is_compatible(node, "fsl,bman-portal-2.1-1")) {
+		bman_portal_max = 3;
+	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.1.0")) {
 		bman_ip_rev = BMAN_REV21;
 		bman_pool_max = 64;
-	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.1-2")) {
+		bman_portal_max = 50;
+	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.1.1")) {
 		bman_ip_rev = BMAN_REV21;
-		bman_pool_max = 32;
+		bman_pool_max = 64;
+		bman_portal_max = 25;
+	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.1.2")) {
+		bman_ip_rev = BMAN_REV21;
+		bman_pool_max = 64;
+		bman_portal_max = 10;
+	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.1.3")) {
+		bman_ip_rev = BMAN_REV21;
+		bman_pool_max = 64;
+		bman_portal_max = 18;
         }
 
 	ret = of_address_to_resource(node, DPA_PORTAL_CE,
@@ -137,12 +151,16 @@ static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 		pr_err("Can't get %s property 'reg::CI'\n", node->full_name);
 		goto err;
 	}
+
 	index = of_get_property(node, "cell-index", &ret);
 	if (!index || (ret != 4)) {
 		pr_err("Can't get %s property '%s'\n", node->full_name,
 			"cell-index");
 		goto err;
 	}
+	if (*index >= bman_portal_max)
+		goto err;
+
 	pcfg->public_cfg.cpu = -1;
 
 	irq = irq_of_parse_and_map(node, 0);
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index e11fab4..78a9c9e 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -42,6 +42,7 @@ u16 qm_channel_caam = QMAN_CHANNEL_CAAM;
 EXPORT_SYMBOL(qm_channel_caam);
 u16 qm_channel_pme = QMAN_CHANNEL_PME;
 EXPORT_SYMBOL(qm_channel_pme);
+u16 qman_portal_max;
 
 /* size of the fqd region in bytes */
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
@@ -165,16 +166,35 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 		return NULL;
 	}
 
-	if (of_device_is_compatible(node, "fsl,qman-portal-1.0"))
+	if (of_device_is_compatible(node, "fsl,qman-portal-1.0") ||
+		of_device_is_compatible(node, "fsl,qman-portal-1.0.0")) {
 		ip_rev = QMAN_REV10;
-	else if (of_device_is_compatible(node, "fsl,qman-portal-1.1"))
+		qman_portal_max = 10;
+	} else if (of_device_is_compatible(node, "fsl,qman-portal-1.1") ||
+		of_device_is_compatible(node, "fsl,qman-portal-1.1.0")) {
 		ip_rev = QMAN_REV11;
-	else if	(of_device_is_compatible(node, "fsl,qman-portal-1.2"))
+		qman_portal_max = 10;
+	} else if (of_device_is_compatible(node, "fsl,qman-portal-1.2") ||
+		of_device_is_compatible(node, "fsl,qman-portal-1.2.0")) {
 		ip_rev = QMAN_REV12;
-	else if (of_device_is_compatible(node, "fsl,qman-portal-2.0"))
+		qman_portal_max = 10;
+	} else if (of_device_is_compatible(node, "fsl,qman-portal-2.0") ||
+		of_device_is_compatible(node, "fsl,qman-portal-2.0.0")) {
 		ip_rev = QMAN_REV20;
-	else if (of_device_is_compatible(node, "fsl,qman-portal-3.0"))
+		qman_portal_max = 3;
+	} else if (of_device_is_compatible(node, "fsl,qman-portal-3.0.0")) {
 		ip_rev = QMAN_REV30;
+		qman_portal_max = 50;
+	} else if (of_device_is_compatible(node, "fsl,qman-portal-3.0.1")) {
+		ip_rev = QMAN_REV30;
+		qman_portal_max = 25;
+	} else if (of_device_is_compatible(node, "fsl,qman-portal-3.0.2")) {
+		ip_rev = QMAN_REV30;
+		qman_portal_max = 10;
+	} else if (of_device_is_compatible(node, "fsl,qman-portal-3.0.3")) {
+		ip_rev = QMAN_REV30;
+		qman_portal_max = 18;
+	}
 
 	if (!qman_ip_rev) {
 		if (ip_rev)
@@ -213,6 +233,9 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 			"cell-index");
 		goto err;
 	}
+	if (*index >= qman_portal_max)
+		goto err;
+
 	channel = of_get_property(node, "fsl,qman-channel-id", &ret);
 	if (!channel || (ret != 4)) {
 		pr_err("Can't get %s property '%s'\n", node->full_name,
-- 
1.7.9.7

