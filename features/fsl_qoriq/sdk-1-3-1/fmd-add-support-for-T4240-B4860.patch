From acb37c91fa6d01d402cb9e70d8cc1c4ee240430a Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Thu, 1 Nov 2012 12:05:28 +0200
Subject: [PATCH 110/227] fmd: add support for T4240/B4860

Add FMan v3 related files.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Signed-off-by: Cristian Sovaiala <cristian.sovaiala@freescale.com>
Signed-off-by: Stefan Szabo <szbs001@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../net/ethernet/freescale/dpa/NetCommSw/Kconfig   |    3 +
 .../dpa/NetCommSw/Peripherals/FM/MAC/Makefile      |    4 +
 .../dpa/NetCommSw/Peripherals/FM/MAC/memac.c       | 1056 ++++++++++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/MAC/memac.h       |  408 ++++++++
 .../NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c   |  275 +++++
 .../NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h   |   72 ++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/Makefile      |    4 +
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c   |  980 ++++++++++++++++++
 .../dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h   |  104 ++
 .../freescale/dpa/NetCommSw/Peripherals/FM/fm.c    |    7 +
 .../inc/integrations/T4240/dpaa_integration_ext.h  |  272 +++++
 .../NetCommSw/inc/integrations/T4240/part_ext.h    |   71 ++
 .../freescale/dpa/NetCommSw/ncsw_config.mk         |    6 +
 .../dpa/NetCommSw/src/wrapper/fman_test.c          |    8 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_fm.c          |   11 +-
 .../dpa/NetCommSw/src/wrapper/lnxwrp_resources.c   |    4 +-
 .../freescale/dpa/NetCommSw/t4240_dflags.h         |   57 ++
 17 files changed, 3334 insertions(+), 8 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_ext.h
 create mode 100644 drivers/net/ethernet/freescale/dpa/NetCommSw/t4240_dflags.h

diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Kconfig b/drivers/net/ethernet/freescale/dpa/NetCommSw/Kconfig
index 2dc1df5..e640465 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Kconfig
@@ -26,6 +26,9 @@ config FMAN_P3040_P4080_P5020
 config FMAN_P1023
 	bool "P1023"
 
+config FMAN_T4240
+	bool "T4240"
+
 endchoice
 endmenu
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
index 00c36a1..6c02470 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/Makefile
@@ -12,3 +12,7 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 obj-y		+= fsl-ncsw-MAC.o
 
 fsl-ncsw-MAC-objs	:=   dtsec.o dtsec_mii_acc.o fm_mac.o tgec.o tgec_mii_acc.o
+
+ifeq ($(CONFIG_FMAN_T4240),y)
+fsl-ncsw-MAC-objs	+=  memac.o memac_mii_acc.o
+endif
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
new file mode 100644
index 0000000..41df4c0
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.c
@@ -0,0 +1,1056 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          memac.c
+
+ @Description   FM 10G MAC ...
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "string_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "endian_ext.h"
+#include "crc_mac_addr_ext.h"
+#include "debug_ext.h"
+
+#include "fm_common.h"
+#include "memac.h"
+
+
+/*****************************************************************************/
+/*                      Internal routines                                    */
+/*****************************************************************************/
+
+static void SetupSgmiiInternalPhy(t_Memac *p_Memac, uint8_t phyAddr)
+{
+    uint16_t    tmpReg16;
+
+    /* SGMII mode + AN enable */
+    tmpReg16 = PHY_SGMII_IF_MODE_AN | PHY_SGMII_IF_MODE_SGMII;
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x14, tmpReg16);
+
+    /* Dev ability according to SGMII specification */
+    tmpReg16 = PHY_SGMII_DEV_ABILITY_SGMII;
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x4, tmpReg16);
+
+    /* Adjust link timer for SGMII  -
+       1.6 ms in units of 8 ns = 2 * 10^5 = 0x30d40 */
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x13, 0x0003);
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x12, 0x0d40);
+
+    /* Restart AN */
+    tmpReg16 = PHY_SGMII_CR_DEF_VAL | PHY_SGMII_CR_RESET_AN;
+    MEMAC_MII_WritePhyReg(p_Memac, phyAddr, 0x0, tmpReg16);
+}
+
+static t_Error CheckInitParameters(t_Memac *p_Memac)
+{
+    e_FmMacType     portType;
+
+    portType = ((ENET_SPEED_FROM_MODE(p_Memac->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G);
+
+#if (FM_MAX_NUM_OF_10G_MACS > 0)
+    if((portType == e_FM_MAC_10G) && (p_Memac->macId >= FM_MAX_NUM_OF_10G_MACS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("10G MAC ID must be less than %d", FM_MAX_NUM_OF_10G_MACS));
+#endif /* (FM_MAX_NUM_OF_10G_MACS > 0) */
+
+    if ((portType == e_FM_MAC_1G) && (p_Memac->macId >= FM_MAX_NUM_OF_1G_MACS))
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("1G MAC ID must be less than %d", FM_MAX_NUM_OF_1G_MACS));
+    if (p_Memac->addr == 0)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Ethernet MAC must have a valid MAC address"));
+    if (!p_Memac->f_Exception)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized f_Exception"));
+    if (!p_Memac->f_Event)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Uninitialized f_Event"));
+    return E_OK;
+
+#ifdef FM_LEN_CHECK_ERRATA_FMAN_SW002
+    if (!p_Memac->p_MemacDriverParam->noLengthCheckEnable)
+       RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("LengthCheck!"));
+#endif /* FM_LEN_CHECK_ERRATA_FMAN_SW002 */
+}
+
+/* .............................................................................. */
+
+static void SetDefaultParam(t_MemacDriverParam *p_MemacDriverParam)
+{
+    p_MemacDriverParam->wanModeEnable            = DEFAULT_wanModeEnable;
+    p_MemacDriverParam->promiscuousModeEnable    = DEFAULT_promiscuousEnable;
+    p_MemacDriverParam->pauseForwardEnable       = DEFAULT_pauseForwardEnable;
+    p_MemacDriverParam->pauseIgnore              = DEFAULT_rxIgnorePause;
+    p_MemacDriverParam->txAddrInsEnable          = DEFAULT_txAddrInsEnable;
+
+    p_MemacDriverParam->loopbackEnable           = DEFAULT_loopback;
+    p_MemacDriverParam->cmdFrameEnable           = DEFAULT_cmdFrameEnable;
+    p_MemacDriverParam->rxErrorDiscard           = DEFAULT_rxErrorDiscard;
+    p_MemacDriverParam->phyTxenaOn               = DEFAULT_phyTxenaOn;
+    p_MemacDriverParam->sendIdleEnable           = DEFAULT_sendIdleEnable;
+
+    p_MemacDriverParam->noLengthCheckEnable      = !DEFAULT_lengthCheckEnable;
+
+    p_MemacDriverParam->lgthCheckNostdr          = DEFAULT_lgthCheckNostdr;
+    p_MemacDriverParam->timeStampEnable          = DEFAULT_timeStampEnable;
+    p_MemacDriverParam->padAndCrcEnable          = DEFAULT_padAndCrcEnable;
+    p_MemacDriverParam->rxSfdAny                 = DEFAULT_rxSfdAny;
+    p_MemacDriverParam->rxPblFwd                 = DEFAULT_rxPblFwd;
+    p_MemacDriverParam->txPblFwd                 = DEFAULT_txPblFwd;
+
+    p_MemacDriverParam->txIpgLength              = DEFAULT_txIpgLength;
+    p_MemacDriverParam->maxFrameLength           = DEFAULT_maxFrameLength;
+
+    p_MemacDriverParam->debugMode                = DEFAULT_debugMode;
+
+    p_MemacDriverParam->pauseTime                = DEFAULT_pauseTime;
+    p_MemacDriverParam->resetOnInit              = DEFAULT_resetOnInit;
+}
+
+/* ........................................................................... */
+
+static void MemacErrException(t_Handle h_Memac)
+{
+    t_Memac             *p_Memac = (t_Memac *)h_Memac;
+    uint32_t            event;
+    t_MemacMemMap        *p_MemacMemMap = p_Memac->p_MemMap;
+
+    event = GET_UINT32(p_MemacMemMap->ievent);
+    /* do not handle MDIO events */
+    //event &= ~(IMASK_MDIO_SCAN_EVENTMDIO | IMASK_MDIO_CMD_CMPL);
+
+    event &= GET_UINT32(p_MemacMemMap->imask);
+
+    WRITE_UINT32(p_MemacMemMap->ievent, event);
+
+}
+
+
+static void FreeInitResources(t_Memac *p_Memac)
+{
+    e_FmMacType             portType;
+
+    portType =
+        ((ENET_SPEED_FROM_MODE(p_Memac->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G);
+
+    if (portType == e_FM_MAC_10G)
+        FmUnregisterIntr(p_Memac->fmMacControllerDriver.h_Fm, e_FM_MOD_10G_MAC, p_Memac->macId, e_FM_INTR_TYPE_ERR);
+    else
+        FmUnregisterIntr(p_Memac->fmMacControllerDriver.h_Fm, e_FM_MOD_1G_MAC, p_Memac->macId, e_FM_INTR_TYPE_ERR);
+
+    /* release the driver's group hash table */
+    FreeHashTable(p_Memac->p_MulticastAddrHash);
+    p_Memac->p_MulticastAddrHash =   NULL;
+
+    /* release the driver's individual hash table */
+    FreeHashTable(p_Memac->p_UnicastAddrHash);
+    p_Memac->p_UnicastAddrHash =     NULL;
+}
+
+/* .............................................................................. */
+
+static void HardwareClearAddrInPaddr(t_Memac *p_Memac, uint8_t paddrNum)
+{
+    WRITE_UINT32(p_Memac->p_MemMap->mac_addr[paddrNum].mac_addr_l, 0x0);
+    WRITE_UINT32(p_Memac->p_MemMap->mac_addr[paddrNum].mac_addr_u, 0x0);
+}
+
+/* ........................................................................... */
+
+static void HardwareAddAddrInPaddr(t_Memac *p_Memac, uint64_t *p_Addr, uint8_t paddrNum)
+{
+    uint32_t        tmpReg32 = 0;
+    uint64_t        addr = *p_Addr;
+    t_MemacMemMap   *p_MemacMemMap = p_Memac->p_MemMap;
+
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_MemacMemMap->mac_addr[paddrNum].mac_addr_l, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_MemacMemMap->mac_addr[paddrNum].mac_addr_u, tmpReg32);
+}
+
+/*****************************************************************************/
+/*                     10G MAC API routines                                  */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error MemacEnable(t_Handle h_Memac,  e_CommMode mode)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_MemacMemMap*)(p_Memac->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
+
+    switch (mode)
+    {
+        case e_COMM_MODE_NONE:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+        case e_COMM_MODE_RX :
+            tmpReg32 |= CMD_CFG_RX_EN ;
+            break;
+        case e_COMM_MODE_TX :
+            tmpReg32 |= CMD_CFG_TX_EN ;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 |= (CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+            break;
+    }
+
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacDisable (t_Handle h_Memac, e_CommMode mode)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap       *p_MemMap ;
+    uint32_t            tmpReg32 = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap= (t_MemacMemMap*)(p_Memac->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
+    switch (mode)
+    {
+        case e_COMM_MODE_RX:
+            tmpReg32 &= ~CMD_CFG_RX_EN;
+            break;
+        case e_COMM_MODE_TX:
+            tmpReg32 &= ~CMD_CFG_TX_EN;
+            break;
+        case e_COMM_MODE_RX_AND_TX:
+            tmpReg32 &= ~(CMD_CFG_TX_EN | CMD_CFG_RX_EN);
+        break;
+        default:
+            RETURN_ERROR(MINOR, E_INVALID_SELECTION, NO_MSG);
+    }
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacSetPromiscuous(t_Handle h_Memac, bool newVal)
+{
+    t_Memac       *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap *p_MemacMemMap;
+    uint32_t     tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+
+    tmpReg32 = GET_UINT32(p_MemacMemMap->command_config);
+
+    if (newVal)
+        tmpReg32 |= CMD_CFG_PROMIS_EN;
+    else
+        tmpReg32 &= ~CMD_CFG_PROMIS_EN;
+
+    WRITE_UINT32(p_MemacMemMap->command_config, tmpReg32);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                      Memac Configs modification functions                 */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error MemacConfigLoopback(t_Handle h_Memac, bool newVal)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->loopbackEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacConfigWan(t_Handle h_Memac, bool newVal)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->wanModeEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacConfigMaxFrameLength(t_Handle h_Memac, uint16_t newVal)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->maxFrameLength = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacConfigPadAndCrc(t_Handle h_Memac, bool newVal)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->padAndCrcEnable = newVal;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacConfigLengthCheck(t_Handle h_Memac, bool newVal)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->noLengthCheckEnable = !newVal;
+
+    return E_OK;
+}
+
+
+/* .............................................................................. */
+
+static t_Error MemacConfigResetOnInit(t_Handle h_Memac, bool enable)
+{
+    t_Memac *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    p_Memac->p_MemacDriverParam->resetOnInit = enable;
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*                      Memac Run Time API functions                         */
+/*****************************************************************************/
+
+static t_Error MemacSetTxPauseFrames(t_Handle h_Memac,
+                                     uint8_t  priority,
+                                     uint16_t pauseTime,
+                                     uint16_t threshTime)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    uint32_t         tmpReg32 = 0;
+    t_MemacMemMap    *p_MemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_MemacMemMap*)(p_Memac->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
+    if (priority == FM_MAC_NO_PFC)
+    {
+        tmpReg32 &= ~CMD_CFG_PFC_MODE;
+        priority = 0;
+    }
+    else
+        tmpReg32 |= CMD_CFG_PFC_MODE;
+
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    tmpReg32 =  GET_UINT32(p_MemMap->pause_quanta[priority/2]);
+    tmpReg32 &= (~0xFFFF<<(16*(priority%2)));
+    tmpReg32 |= ((uint32_t)pauseTime<<(16*(priority%2)));
+    WRITE_UINT32(p_MemMap->pause_quanta[priority/2], tmpReg32);
+
+    tmpReg32 =  GET_UINT32(p_MemMap->pause_thresh[priority/2]);
+    tmpReg32 &= (~0xFFFF<<(16*(priority%2)));
+    tmpReg32 |= ((uint32_t)threshTime<<(16*(priority%2)));
+    WRITE_UINT32(p_MemMap->pause_thresh[priority/2], tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacSetTxAutoPauseFrames(t_Handle h_Memac,
+                                         uint16_t pauseTime)
+{
+    return MemacSetTxPauseFrames(h_Memac, FM_MAC_NO_PFC, pauseTime, 0);
+}
+
+/* .............................................................................. */
+
+static t_Error MemacSetRxIgnorePauseFrames(t_Handle h_Memac, bool en)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap    *p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_STATE);
+
+    p_MemMap = (t_MemacMemMap*)(p_Memac->p_MemMap);
+    tmpReg32 = GET_UINT32(p_MemMap->command_config);
+    if (en)
+        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+    else
+        tmpReg32 &= ~CMD_CFG_PAUSE_IGNORE;
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    return E_OK;
+}
+
+/* Counters handling */
+/* .............................................................................. */
+
+static t_Error MemacGetStatistics(t_Handle h_Memac, t_FmMacStatistics *p_Statistics)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap    *p_MemacMemMap;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Statistics, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+
+    p_Statistics->eStatPkts64           = (((uint64_t)GET_UINT32(p_MemacMemMap->r64_u)<<32)|GET_UINT32(p_MemacMemMap->r64_l));
+    p_Statistics->eStatPkts65to127      = (((uint64_t)GET_UINT32(p_MemacMemMap->r127_u)<<32)|GET_UINT32(p_MemacMemMap->r127_l));
+    p_Statistics->eStatPkts128to255     = (((uint64_t)GET_UINT32(p_MemacMemMap->r255_u)<<32)|GET_UINT32(p_MemacMemMap->r255_l));
+    p_Statistics->eStatPkts256to511     = (((uint64_t)GET_UINT32(p_MemacMemMap->r511_u)<<32)|GET_UINT32(p_MemacMemMap->r511_l));
+    p_Statistics->eStatPkts512to1023    = (((uint64_t)GET_UINT32(p_MemacMemMap->r1023_u)<<32)|GET_UINT32(p_MemacMemMap->r1023_l));
+    p_Statistics->eStatPkts1024to1518   = (((uint64_t)GET_UINT32(p_MemacMemMap->r1518_u)<<32)|GET_UINT32(p_MemacMemMap->r1518_l));
+    p_Statistics->eStatPkts1519to1522   = (((uint64_t)GET_UINT32(p_MemacMemMap->r1519x_u)<<32)|GET_UINT32(p_MemacMemMap->r1519x_l));
+/* */
+    p_Statistics->eStatFragments        = (((uint64_t)GET_UINT32(p_MemacMemMap->rfrg_u)<<32)|GET_UINT32(p_MemacMemMap->rfrg_l));
+    p_Statistics->eStatJabbers          = (((uint64_t)GET_UINT32(p_MemacMemMap->rjbr_u)<<32)|GET_UINT32(p_MemacMemMap->rjbr_l));
+
+    p_Statistics->eStatsDropEvents      = (((uint64_t)GET_UINT32(p_MemacMemMap->rdrp_u)<<32)|GET_UINT32(p_MemacMemMap->rdrp_l));
+    p_Statistics->eStatCRCAlignErrors   = (((uint64_t)GET_UINT32(p_MemacMemMap->raln_u)<<32)|GET_UINT32(p_MemacMemMap->raln_l));
+
+    p_Statistics->eStatUndersizePkts    = (((uint64_t)GET_UINT32(p_MemacMemMap->tund_u)<<32)|GET_UINT32(p_MemacMemMap->tund_l));
+    p_Statistics->eStatOversizePkts     = (((uint64_t)GET_UINT32(p_MemacMemMap->rovr_u)<<32)|GET_UINT32(p_MemacMemMap->rovr_l));
+/* Pause */
+    p_Statistics->reStatPause           = (((uint64_t)GET_UINT32(p_MemacMemMap->rxpf_u)<<32)|GET_UINT32(p_MemacMemMap->rxpf_l));
+    p_Statistics->teStatPause           = (((uint64_t)GET_UINT32(p_MemacMemMap->txpf_u)<<32)|GET_UINT32(p_MemacMemMap->txpf_l));
+
+/* MIB II */
+    p_Statistics->ifInOctets            = (((uint64_t)GET_UINT32(p_MemacMemMap->roct_u)<<32)|GET_UINT32(p_MemacMemMap->roct_l));
+    p_Statistics->ifInMcastPkts         = (((uint64_t)GET_UINT32(p_MemacMemMap->rmca_u)<<32)|GET_UINT32(p_MemacMemMap->rmca_l));
+    p_Statistics->ifInBcastPkts         = (((uint64_t)GET_UINT32(p_MemacMemMap->rbca_u)<<32)|GET_UINT32(p_MemacMemMap->rbca_l));
+    p_Statistics->ifInPkts              = (((uint64_t)GET_UINT32(p_MemacMemMap->ruca_u)<<32)|GET_UINT32(p_MemacMemMap->ruca_l))
+                                        + p_Statistics->ifInMcastPkts
+                                        + p_Statistics->ifInBcastPkts;
+    p_Statistics->ifInDiscards          = 0;
+    p_Statistics->ifInErrors            = (((uint64_t)GET_UINT32(p_MemacMemMap->rerr_u)<<32)|GET_UINT32(p_MemacMemMap->rerr_l));
+
+    p_Statistics->ifOutOctets           = (((uint64_t)GET_UINT32(p_MemacMemMap->toct_u)<<32)|GET_UINT32(p_MemacMemMap->toct_l));
+    p_Statistics->ifOutMcastPkts        = (((uint64_t)GET_UINT32(p_MemacMemMap->tmca_u)<<32)|GET_UINT32(p_MemacMemMap->tmca_l));
+    p_Statistics->ifOutBcastPkts        = (((uint64_t)GET_UINT32(p_MemacMemMap->tbca_u)<<32)|GET_UINT32(p_MemacMemMap->tbca_l));
+    p_Statistics->ifOutPkts             = (((uint64_t)GET_UINT32(p_MemacMemMap->tuca_u)<<32)|GET_UINT32(p_MemacMemMap->tuca_l))
+                                            + p_Statistics->ifOutMcastPkts
+                                            + p_Statistics->ifOutBcastPkts;
+    p_Statistics->ifOutDiscards         = 0;
+    p_Statistics->ifOutErrors           = (((uint64_t)GET_UINT32(p_MemacMemMap->terr_u)<<32)|GET_UINT32(p_MemacMemMap->terr_l));
+
+    return E_OK;
+}
+
+
+/* .............................................................................. */
+
+static t_Error MemacModifyMacAddress (t_Handle h_Memac, t_EnetAddr *p_EnetAddr)
+{
+    t_Memac              *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap        *p_MemacMemMap;
+    uint32_t            tmpReg32 = 0;
+    uint64_t            addr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+
+    addr = ((*(uint64_t *)p_EnetAddr) >> 16);
+    p_Memac->addr = addr;
+
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_MemacMemMap->mac_addr0.mac_addr_l, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_MemacMemMap->mac_addr0.mac_addr_u, tmpReg32);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacResetCounters (t_Handle h_Memac)
+{
+    t_Memac         *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap   *p_MemMap;
+    uint32_t        tmpReg32;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+
+    p_MemMap = (t_MemacMemMap*)(p_Memac->p_MemMap);
+
+    tmpReg32 = GET_UINT32(p_MemMap->statn_config);
+
+    tmpReg32 |= STATS_CFG_CLR;
+
+    WRITE_UINT32(p_MemMap->statn_config, tmpReg32);
+
+    while (GET_UINT32(p_MemMap->statn_config) & STATS_CFG_CLR) ;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacAddExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
+{
+    t_Memac   *p_Memac = (t_Memac *) h_Memac;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (ethAddr & GROUP_ADDRESS)
+        /* Multicast address has no effect in PADDR */
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Multicast address"));
+
+    /* Make sure no PADDR contains this address */
+    for (paddrNum = 0; paddrNum < MEMAC_NUM_OF_PADDRS; paddrNum++)
+        if (p_Memac->indAddrRegUsed[paddrNum])
+            if (p_Memac->paddr[paddrNum] == ethAddr)
+                RETURN_ERROR(MAJOR, E_ALREADY_EXISTS, NO_MSG);
+
+    /* Find first unused PADDR */
+    for (paddrNum = 0; paddrNum < MEMAC_NUM_OF_PADDRS; paddrNum++)
+        if (!(p_Memac->indAddrRegUsed[paddrNum]))
+        {
+            /* mark this PADDR as used */
+            p_Memac->indAddrRegUsed[paddrNum] = TRUE;
+            /* store address */
+            p_Memac->paddr[paddrNum] = ethAddr;
+
+            /* put in hardware */
+            HardwareAddAddrInPaddr(p_Memac, &ethAddr, paddrNum);
+            p_Memac->numOfIndAddrInRegs++;
+
+            return E_OK;
+        }
+
+    /* No free PADDR */
+    RETURN_ERROR(MAJOR, E_FULL, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
+{
+    t_Memac   *p_Memac = (t_Memac *) h_Memac;
+    uint64_t  ethAddr;
+    uint8_t   paddrNum;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* Find used PADDR containing this address */
+    for (paddrNum = 0; paddrNum < MEMAC_NUM_OF_PADDRS; paddrNum++)
+    {
+        if ((p_Memac->indAddrRegUsed[paddrNum]) &&
+            (p_Memac->paddr[paddrNum] == ethAddr))
+        {
+            /* mark this PADDR as not used */
+            p_Memac->indAddrRegUsed[paddrNum] = FALSE;
+            /* clear in hardware */
+            HardwareClearAddrInPaddr(p_Memac, paddrNum);
+            p_Memac->numOfIndAddrInRegs--;
+
+            return E_OK;
+        }
+    }
+
+    RETURN_ERROR(MAJOR, E_NOT_FOUND, NO_MSG);
+}
+
+/* .............................................................................. */
+
+static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap    *p_MemacMemMap;
+    t_EthHashEntry  *p_HashEntry;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    if (!(ethAddr & GROUP_ADDRESS))
+        /* Unicast addresses not supported in hash */
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unicast Address"));
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_CTRL_ADDR_MASK;        /* Take 6 MSB bits */
+
+    /* Create element to be added to the driver hash table */
+    p_HashEntry = (t_EthHashEntry *)XX_Malloc(sizeof(t_EthHashEntry));
+    p_HashEntry->addr = ethAddr;
+    INIT_LIST(&p_HashEntry->node);
+
+    LIST_AddToTail(&(p_HashEntry->node), &(p_Memac->p_MulticastAddrHash->p_Lsts[hash]));
+    WRITE_UINT32(p_MemacMemMap->hashtable_ctrl, (hash | HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacDelHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
+{
+    t_Memac          *p_Memac = (t_Memac *)h_Memac;
+    t_MemacMemMap    *p_MemacMemMap;
+    t_EthHashEntry  *p_HashEntry = NULL;
+    t_List          *p_Pos;
+    uint32_t        crc;
+    uint32_t        hash;
+    uint64_t        ethAddr;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_NULL_POINTER);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_NULL_POINTER);
+
+    p_MemacMemMap = p_Memac->p_MemMap;
+    ethAddr = ((*(uint64_t *)p_EthAddr) >> 16);
+
+    /* CRC calculation */
+    GET_MAC_ADDR_CRC(ethAddr, crc);
+    crc = MIRROR_32(crc);
+
+    hash = (crc >> HASH_CTRL_MCAST_SHIFT) & HASH_CTRL_ADDR_MASK;        /* Take 6 MSB bits */
+
+    LIST_FOR_EACH(p_Pos, &(p_Memac->p_MulticastAddrHash->p_Lsts[hash]))
+    {
+
+        p_HashEntry = ETH_HASH_ENTRY_OBJ(p_Pos);
+        if(p_HashEntry->addr == ethAddr)
+        {
+            LIST_DelAndInit(&p_HashEntry->node);
+            XX_Free(p_HashEntry);
+            break;
+        }
+    }
+    if(LIST_IsEmpty(&p_Memac->p_MulticastAddrHash->p_Lsts[hash]))
+        WRITE_UINT32(p_MemacMemMap->hashtable_ctrl, (hash & ~HASH_CTRL_MCAST_EN));
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+/* .............................................................................. */
+
+static uint16_t MemacGetMaxFrameLength(t_Handle h_Memac)
+{
+    t_Memac              *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_VALUE(p_Memac, E_INVALID_HANDLE, 0);
+
+    return (uint16_t)GET_UINT32(p_Memac->p_MemMap->maxfrm);
+}
+
+/* .............................................................................. */
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+static t_Error MemacDumpRegs(t_Handle h_Memac)
+{
+    return E_OK;
+}
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+
+/*****************************************************************************/
+/*                      FM Init & Free API                                   */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+static t_Error MemacInit(t_Handle h_Memac)
+{
+    t_Memac                 *p_Memac = (t_Memac *)h_Memac;
+    t_MemacDriverParam      *p_MemacDriverParam;
+    t_MemacMemMap           *p_MemMap;
+    uint64_t                addr;
+    uint32_t                tmpReg32;
+    uint8_t                 i, phyAddr;
+    e_FmMacType             portType;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MemMap, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->fmMacControllerDriver.h_Fm, E_INVALID_HANDLE);
+
+    /* not needed! */
+    /*FM_GetRevision(p_Memac->fmMacControllerDriver.h_Fm, &p_Memac->fmMacControllerDriver.fmRevInfo);*/
+
+    CHECK_INIT_PARAMETERS(p_Memac, CheckInitParameters);
+
+    p_MemacDriverParam = p_Memac->p_MemacDriverParam;
+    p_MemMap = p_Memac->p_MemMap;
+
+    portType =
+        ((ENET_SPEED_FROM_MODE(p_Memac->enetMode) < e_ENET_SPEED_10000) ? e_FM_MAC_1G : e_FM_MAC_10G);
+
+    /* First, reset the MAC if desired. */
+    if (p_MemacDriverParam->resetOnInit)
+    {
+        tmpReg32 = GET_UINT32(p_MemMap->command_config);
+        WRITE_UINT32(p_MemMap->command_config, tmpReg32 | CMD_CFG_SW_RESET);
+        XX_UDelay(10);
+        do
+        {
+            tmpReg32 = GET_UINT32(p_MemMap->command_config);
+        }
+        while (tmpReg32 & CMD_CFG_SW_RESET);
+    }
+
+    /* MAC Address */
+    addr = p_Memac->addr;
+    tmpReg32 = (uint32_t)(addr>>16);
+    SwapUint32P(&tmpReg32);
+    WRITE_UINT32(p_MemMap->mac_addr0.mac_addr_l, tmpReg32);
+
+    tmpReg32 = (uint32_t)(addr);
+    SwapUint32P(&tmpReg32);
+    tmpReg32 >>= 16;
+    WRITE_UINT32(p_MemMap->mac_addr0.mac_addr_u, tmpReg32);
+
+    /* Config */
+    tmpReg32 = 0;
+    if (p_MemacDriverParam->wanModeEnable)
+        tmpReg32 |= CMD_CFG_WAN_MODE;
+    if (p_MemacDriverParam->promiscuousModeEnable)
+        tmpReg32 |= CMD_CFG_PROMIS_EN;
+    if (p_MemacDriverParam->pauseForwardEnable)
+        tmpReg32 |= CMD_CFG_PAUSE_FWD;
+    if (p_MemacDriverParam->pauseIgnore)
+        tmpReg32 |= CMD_CFG_PAUSE_IGNORE;
+    if (p_MemacDriverParam->txAddrInsEnable)
+        tmpReg32 |= CMD_CFG_TX_ADDR_INS;
+    if (p_MemacDriverParam->loopbackEnable)
+        tmpReg32 |= CMD_CFG_LOOPBACK_EN;
+    if (p_MemacDriverParam->cmdFrameEnable)
+        tmpReg32 |= CMD_CFG_CNT_FRM_EN;
+    if (p_MemacDriverParam->sendIdleEnable)
+        tmpReg32 |= CMD_CFG_SEND_IDLE;
+    if (p_MemacDriverParam->noLengthCheckEnable)
+        tmpReg32 |= CMD_CFG_NO_LEN_CHK;
+    if (p_MemacDriverParam->rxSfdAny)
+        tmpReg32 |= CMD_CFG_SFD_ANY;
+    if (p_MemacDriverParam->padAndCrcEnable)
+        tmpReg32 |= CMD_CFG_TX_PAD_EN;
+    tmpReg32 |= CMD_CFG_CRC_FWD;
+
+    WRITE_UINT32(p_MemMap->command_config, tmpReg32);
+
+    /* Set up interface bits */
+    tmpReg32 = GET_UINT32(p_MemMap->if_mode) & ~IF_MODE_MASK;
+    if (portType == e_FM_MAC_10G)
+        WRITE_UINT32(p_MemMap->if_mode, tmpReg32 | IF_MODE_XGMII);
+    else
+        WRITE_UINT32(p_MemMap->if_mode, tmpReg32 | IF_MODE_GMII);
+
+    if (ENET_INTERFACE_FROM_MODE(p_Memac->enetMode) == e_ENET_IF_SGMII)
+    {
+        /* Configure internal SGMII phy */
+        SetupSgmiiInternalPhy(p_Memac, PHY_MDIO_ADDR);
+    }
+    else if (ENET_INTERFACE_FROM_MODE(p_Memac->enetMode) == e_ENET_IF_QSGMII)
+    {
+        /* Configure 4 internal SGMII phys */
+        for (i = 0; i < 4; i++)
+        {
+            /* QSGMII phy address occupies 3 upper bits of 5-bit
+               phyAddress; the lower 2 bits are used to extend
+               register address space and access each one of 4
+               ports inside QSGMII. */
+            phyAddr = (uint8_t)((PHY_MDIO_ADDR << 2) | i);
+            SetupSgmiiInternalPhy(p_Memac, phyAddr);
+        }
+    }
+
+    /* Max Frame Length */
+    WRITE_UINT32(p_MemMap->maxfrm, (uint32_t)p_MemacDriverParam->maxFrameLength);
+    err = FmSetMacMaxFrame(p_Memac->fmMacControllerDriver.h_Fm,
+                           portType,
+                           p_Memac->fmMacControllerDriver.macId,
+                           p_MemacDriverParam->maxFrameLength);
+
+    /* Pause Time */
+    WRITE_UINT32(p_MemMap->pause_quanta[0], p_MemacDriverParam->pauseTime);
+    WRITE_UINT32(p_MemMap->pause_thresh[0], 0);
+
+    p_Memac->p_MulticastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if (!p_Memac->p_MulticastAddrHash)
+    {
+        FreeInitResources(p_Memac);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    p_Memac->p_UnicastAddrHash = AllocHashTable(HASH_TABLE_SIZE);
+    if (!p_Memac->p_UnicastAddrHash)
+    {
+        FreeInitResources(p_Memac);
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("allocation hash table is FAILED"));
+    }
+
+    /* interrupts */
+    WRITE_UINT32(p_MemMap->ievent, EVENTS_MASK);
+    WRITE_UINT32(p_MemMap->imask, p_Memac->exceptions);
+
+    if (portType == e_FM_MAC_10G)
+        FmRegisterIntr(p_Memac->fmMacControllerDriver.h_Fm,
+                       e_FM_MOD_10G_MAC,
+                       p_Memac->macId,
+                       e_FM_INTR_TYPE_ERR,
+                       MemacErrException,
+                       p_Memac);
+    else
+        FmRegisterIntr(p_Memac->fmMacControllerDriver.h_Fm,
+                       e_FM_MOD_1G_MAC,
+                       p_Memac->macId,
+                       e_FM_INTR_TYPE_ERR,
+                       MemacErrException,
+                       p_Memac);
+    /*if ((p_Memac->mdioIrq != 0) && (p_Memac->mdioIrq != NO_IRQ))
+    {
+        XX_SetIntr(p_Memac->mdioIrq, MemacException, p_Memac);
+        XX_EnableIntr(p_Memac->mdioIrq);
+    }
+    else if (p_Memac->mdioIrq == 0)
+        REPORT_ERROR(MINOR, E_NOT_SUPPORTED, (NO_MSG));*/
+
+    XX_Free(p_MemacDriverParam);
+    p_Memac->p_MemacDriverParam = NULL;
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static t_Error MemacFree(t_Handle h_Memac)
+{
+    t_Memac       *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+
+    FreeInitResources(p_Memac);
+
+    if (p_Memac->p_MemacDriverParam)
+    {
+        XX_Free(p_Memac->p_MemacDriverParam);
+        p_Memac->p_MemacDriverParam = NULL;
+    }
+    XX_Free (p_Memac);
+
+    return E_OK;
+}
+
+/* .............................................................................. */
+
+static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacControllerDriver)
+{
+    p_FmMacControllerDriver->f_FM_MAC_Init                      = MemacInit;
+    p_FmMacControllerDriver->f_FM_MAC_Free                      = MemacFree;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetStatistics             = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLoopback            = MemacConfigLoopback;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigMaxFrameLength      = MemacConfigMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigWan                 = MemacConfigWan;
+
+    p_FmMacControllerDriver->f_FM_MAC_ConfigPadAndCrc           = MemacConfigPadAndCrc;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigHalfDuplex          = NULL; /* half-duplex is not supported in xgec */
+    p_FmMacControllerDriver->f_FM_MAC_ConfigLengthCheck         = MemacConfigLengthCheck;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigException           = NULL; //MemacConfigException;
+    p_FmMacControllerDriver->f_FM_MAC_ConfigResetOnInit         = NULL; //MemacConfigResetOnInit;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetException              = NULL; //MemacSetExcpetion;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable1588TimeStamp       = NULL; //MemacEnable1588TimeStamp;
+    p_FmMacControllerDriver->f_FM_MAC_Disable1588TimeStamp      = NULL; //MemacDisable1588TimeStamp;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetPromiscuous            = MemacSetPromiscuous;
+    p_FmMacControllerDriver->f_FM_MAC_AdjustLink                = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_RestartAutoneg            = NULL;
+
+    p_FmMacControllerDriver->f_FM_MAC_Enable                    = MemacEnable;
+    p_FmMacControllerDriver->f_FM_MAC_Disable                   = MemacDisable;
+
+    p_FmMacControllerDriver->f_FM_MAC_SetTxAutoPauseFrames      = MemacSetTxAutoPauseFrames;
+    p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames          = MemacSetTxPauseFrames;
+    p_FmMacControllerDriver->f_FM_MAC_SetRxIgnorePauseFrames    = MemacSetRxIgnorePauseFrames;
+
+    p_FmMacControllerDriver->f_FM_MAC_ResetCounters             = MemacResetCounters;
+    p_FmMacControllerDriver->f_FM_MAC_GetStatistics             = MemacGetStatistics;
+
+    p_FmMacControllerDriver->f_FM_MAC_ModifyMacAddr             = MemacModifyMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddHashMacAddr            = MemacAddHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = MemacDelHashMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = MemacAddExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = MemacDelExactMatchMacAddress;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_GetVersion                = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength         = MemacGetMaxFrameLength;
+
+    p_FmMacControllerDriver->f_FM_MAC_MII_WritePhyReg           = MEMAC_MII_WritePhyReg;
+    p_FmMacControllerDriver->f_FM_MAC_MII_ReadPhyReg            = MEMAC_MII_ReadPhyReg;
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+    p_FmMacControllerDriver->f_FM_MAC_DumpRegs                  = MemacDumpRegs;
+#endif /* (defined(DEBUG_ERRORS) && ... */
+}
+
+
+/*****************************************************************************/
+/*                      Memac Config  Main Entry                             */
+/*****************************************************************************/
+
+/* .............................................................................. */
+
+t_Handle MEMAC_Config(t_FmMacParams *p_FmMacParam)
+{
+    t_Memac                 *p_Memac;
+    t_MemacDriverParam      *p_MemacDriverParam;
+    uintptr_t               baseAddr;
+    uint8_t                 i;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_NULL_POINTER, NULL);
+
+    baseAddr = p_FmMacParam->baseAddr;
+
+    /* Allocate memory for the mEMAC data structure */
+    p_Memac = (t_Memac *) XX_Malloc(sizeof(t_Memac));
+    if (!p_Memac)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("mEMAC driver structure"));
+        return NULL;
+    }
+    /* Zero out *p_Memac */
+    memset(p_Memac, 0, sizeof(t_Memac));
+    InitFmMacControllerDriver(&p_Memac->fmMacControllerDriver);
+
+    /* Allocate memory for the mEMAC driver parameters data structure */
+    p_MemacDriverParam = (t_MemacDriverParam *) XX_Malloc(sizeof(t_MemacDriverParam));
+    if (!p_MemacDriverParam)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("mEMAC driver parameters"));
+        MemacFree(p_Memac);
+        return NULL;
+    }
+    /* Zero out */
+    memset(p_MemacDriverParam, 0, sizeof(t_MemacDriverParam));
+
+    /* Plant parameter structure pointer */
+    p_Memac->p_MemacDriverParam = p_MemacDriverParam;
+
+    SetDefaultParam(p_MemacDriverParam);
+
+    for (i=0; i < sizeof(p_FmMacParam->addr); i++)
+        p_Memac->addr |= ((uint64_t)p_FmMacParam->addr[i] << ((5-i) * 8));
+
+    p_Memac->p_MemMap        = (t_MemacMemMap *)UINT_TO_PTR(baseAddr);
+    p_Memac->p_MiiMemMap     = (t_MemacMiiAccessMemMap *)UINT_TO_PTR(baseAddr + MEMAC_TO_MII_OFFSET);
+    p_Memac->enetMode        = p_FmMacParam->enetMode;
+    p_Memac->macId           = p_FmMacParam->macId;
+    p_Memac->exceptions      = DEFAULT_exceptions;
+    p_Memac->f_Exception     = p_FmMacParam->f_Exception;
+    p_Memac->f_Event         = p_FmMacParam->f_Event;
+    p_Memac->h_App           = p_FmMacParam->h_App;
+
+    return p_Memac;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
new file mode 100644
index 0000000..953f1c0
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac.h
@@ -0,0 +1,408 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          memac.h
+
+ @Description   FM Multirate Ethernet MAC (mEMAC)
+*//***************************************************************************/
+#ifndef __MEMAC_H
+#define __MEMAC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "list_ext.h"
+#include "memac_mii_acc.h"
+#include "fm_mac.h"
+
+
+/* Interrupt Mask Register (IMASK) */
+#define IMASK_PCS                   0x80000000  /* 0 PCS
+                                                 * XGMII - PCS event
+                                                 * GMII - link synchronization event
+                                                 */
+#define IMASK_AN                    0x40000000  /* 1 AN
+                                                 * XGMII - Auto-negotiation event
+                                                 * GMII - Auto-negotiation status
+                                                 */
+#define IMASK_LT                    0x20000000  /* 2 LT
+                                                 * XGMII - Link Training event
+                                                 * GMII - new page received by auto-negotiation function
+                                                 */
+#define IMASK_MGI                   0x00004000  /* 17 Magic packet detection indication event */
+#define IMASK_RX_FIFO_OVFL          0x00001000  /* 19 Receive FIFO overflow event */
+#define IMASK_TX_FIFO_UNFL          0x00000800  /* 20 Transmit FIFO underflow event */
+#define IMASK_TX_FIFO_OVFL          0x00000400  /* 21 Transmit FIFO overflow event */
+#define IMASK_TX_ECC_ER             0x00000200  /* 22 Transmit frame ECC error event */
+#define IMASK_RX_ECC_ER             0x00000100  /* 23 Receive frame ECC error event */
+#define IMASK_LI_FAULT              0x00000080  /* 24 Link Interruption fault event (XGMII) */
+#define IMASK_RX_EMPTY              0x00000040  /* 25 Receive FIFO empty event */
+#define IMASK_TX_EMPTY              0x00000020  /* 26 Transmit FIFO empty event */
+#define IMASK_RX_LOWP               0x00000010  /* 27 Low Power Idle event */
+#define IMASK_PHY_LOS               0x00000004  /* 29 Phy loss of signal event */
+#define IMASK_REM_FAULT             0x00000002  /* 30 Remote fault event (XGMII) */
+#define IMASK_LOC_FAULT             0x00000001  /* 31 Local fault event (XGMII) */
+
+#define EVENTS_MASK                 ((uint32_t)(IMASK_PCS           |  \
+                                                IMASK_AN            |  \
+                                                IMASK_LT            |  \
+                                                IMASK_MGI           |  \
+                                                IMASK_RX_FIFO_OVFL  |  \
+                                                IMASK_TX_FIFO_UNFL  |  \
+                                                IMASK_TX_FIFO_OVFL  |  \
+                                                IMASK_TX_ECC_ER     |  \
+                                                IMASK_RX_ECC_ER     |  \
+                                                IMASK_LI_FAULT      |  \
+                                                IMASK_RX_EMPTY      |  \
+                                                IMASK_TX_EMPTY      |  \
+                                                IMASK_RX_LOWP       |  \
+                                                IMASK_PHY_LOS       |  \
+                                                IMASK_REM_FAULT     |  \
+                                                IMASK_LOC_FAULT))
+
+#define GET_EXCEPTION_FLAG(bitMask, exception) \
+    (bitMask = EVENTS_MASK)
+
+
+#define DEFAULT_pauseForwardEnable          FALSE
+#define DEFAULT_txAddrInsEnable             FALSE
+#define DEFAULT_cmdFrameEnable              FALSE
+#define DEFAULT_rxErrorDiscard              FALSE
+#define DEFAULT_phyTxenaOn                  FALSE
+#define DEFAULT_sendIdleEnable              FALSE
+#define DEFAULT_lgthCheckNostdr             FALSE
+#define DEFAULT_rxSfdAny                    FALSE
+#define DEFAULT_rxPblFwd                    FALSE
+#define DEFAULT_txPblFwd                    FALSE
+#define DEFAULT_txIpgLength                 12
+#define DEFAULT_debugMode                   FALSE
+#define DEFAULT_timeStampEnable             FALSE
+
+#define DEFAULT_exceptions          ((uint32_t)(IMASK_RX_FIFO_OVFL  |  \
+                                                IMASK_TX_FIFO_UNFL  |  \
+                                                IMASK_TX_FIFO_OVFL  |  \
+                                                IMASK_TX_ECC_ER     |  \
+                                                IMASK_RX_ECC_ER     |  \
+                                                IMASK_RX_EMPTY      |  \
+                                                IMASK_TX_EMPTY      |  \
+                                                IMASK_REM_FAULT     |  \
+                                                IMASK_LOC_FAULT))
+
+
+/* Control and Configuration Register (COMMAND_CONFIG) */
+#define CMD_CFG_MG                  0x80000000  /* 00 Magic Packet detection */
+#define CMD_CFG_REG_LOWP_RXETY      0x01000000  /* 07 Rx low power indication */
+#define CMD_CFG_TX_LOWP_ENA         0x00800000  /* 08 Transmit Low Power Idle Enable */
+#define CMD_CFG_SFD_ANY             0x00200000  /* 10 Disable check of SFD (0xd5) character at frame start */
+#define CMD_CFG_PFC_MODE            0x00080000  /* 12 Enable Priority Flow Control (PFC) mode of operation */
+#define CMD_CFG_NO_LEN_CHK          0x00020000  /* 14 Payload length check disable */
+#define CMD_CFG_SEND_IDLE           0x00010000  /* 15 Force idle generation */
+#define CMD_CFG_CNT_FRM_EN          0x00002000  /* 18 Control frame reception enable */
+#define CMD_CFG_SW_RESET            0x00001000  /* 19 Software Reset, self clearing bit */
+#define CMD_CFG_TX_PAD_EN           0x00000800  /* 20 Enable padding of frames in transmit direction */
+#define CMD_CFG_LOOPBACK_EN         0x00000400  /* 21 XGMII/GMII loopback enable */
+#define CMD_CFG_TX_ADDR_INS         0x00000200  /* 22 Transmit source MAC address insertion */
+#define CMD_CFG_PAUSE_IGNORE        0x00000100  /* 23 Ignore Pause frame quanta */
+#define CMD_CFG_PAUSE_FWD           0x00000080  /* 24 Terminate/forward received Pause frames */
+#define CMD_CFG_CRC_FWD             0x00000040  /* 25 Terminate/forward CRC of received frames */
+#define CMD_CFG_PAD_EN              0x00000020  /* 26 Frame padding removal in receive path enable */
+#define CMD_CFG_PROMIS_EN           0x00000010  /* 27 Promiscuous operation enable */
+#define CMD_CFG_WAN_MODE            0x00000008  /* 28 WAN mode enable */
+#define CMD_CFG_RX_EN               0x00000002  /* 30 MAC receive path enable */
+#define CMD_CFG_TX_EN               0x00000001  /* 31 MAC transmit path enable */
+
+/* Interface Mode Register (IF_MODE) */
+#define IF_MODE_MASK                0x00000003  /* 30-31 Mask on interface mode bits */
+#define IF_MODE_XGMII               0x00000000  /* 30-31 XGMII (10G) interface */
+#define IF_MODE_GMII                0x00000002  /* 30-31 GMII (1G) interface */
+
+/* Hash table Control Register (HASHTABLE_CTRL) */
+#define HASH_CTRL_MCAST_SHIFT       26
+#define HASH_CTRL_MCAST_EN          0x00000100  /* 23 Multicast frame reception for the hash entry */
+#define HASH_CTRL_ADDR_MASK         0x0000003F  /* 26-31 Hash table address code */
+
+#define GROUP_ADDRESS               0x0000010000000000LL /* MAC multicast address bit indication */
+#define HASH_TABLE_SIZE             64          /* Hash table size (bits 26-31 in HASHTABLE_CTRL allows for 2^6 entries) */
+
+/* Transmit Inter-Packet Gap Length Register (TX_IPG_LENGTH) */
+#define TX_IPG_LENGTH_MASK          0x0000003F
+
+/* Statistics Configuration Register (STATN_CONFIG) */
+#define STATS_CFG_CLR               0x00000004  /* 29 Reset all counters */
+#define STATS_CFG_CLR_ON_RD         0x00000002  /* 30 Clear on read */
+#define STATS_CFG_SATURATE          0x00000001  /* 31 Saturate at the maximum value */
+
+/* Internal PHY access */
+#define PHY_MDIO_ADDR               0
+/* SGMII registers */
+#define PHY_SGMII_CR_PHY_RESET      0x8000
+#define PHY_SGMII_CR_RESET_AN       0x0200
+#define PHY_SGMII_CR_DEF_VAL        0x1140
+#define PHY_SGMII_DEV_ABILITY_SGMII 0x4001
+#define PHY_SGMII_IF_MODE_AN        0x0002
+#define PHY_SGMII_IF_MODE_SGMII     0x0001
+
+
+#define MEMAC_NUM_OF_PADDRS         7           /* Number of additional exact match MAC address registers */
+typedef _Packed struct t_MacAddr
+{
+    volatile uint32_t   mac_addr_l;         /* Lower 32 bits of 48-bit MAC address */
+    volatile uint32_t   mac_addr_u;         /* Upper 16 bits of 48-bit MAC address */
+} t_MacAddr;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+
+typedef _Packed struct t_MemacMemMap
+{
+    /* General Control and Status */
+    volatile uint32_t   reserved1[2];
+    volatile uint32_t   command_config;     /* 0x008 COMMAND_CONFIG - Control and configuration register */
+    t_MacAddr mac_addr0;                    /* 0x00C-0x010 MAC_ADDR_0...MAC_ADDR_1 */
+    volatile uint32_t   maxfrm;             /* 0x014 MAXFRM - Maximum frame length register */
+    volatile uint32_t   reserved2[5];
+    volatile uint32_t   hashtable_ctrl;     /* 0x02C HASHTABLE_CTRL - Hash table control register */
+    volatile uint32_t   reserved3[4];
+    volatile uint32_t   ievent;             /* 0x040 IEVENT - Interrupt event register */
+    volatile uint32_t   tx_ipg_length;      /* 0x044 TX_IPG_LENGTH - Transmitter inter-packet-gap register */
+    volatile uint32_t   reserved4;
+    volatile uint32_t   imask;              /* 0x04C IMASK - Interrupt mask register */
+    volatile uint32_t   reserved5;
+    volatile uint32_t   pause_quanta[4];    /* 0x054 CL0x_PAUSE_QUANTA - CL0-7 Pause quanta register */
+    volatile uint32_t   pause_thresh[4];    /* 0x064 CL0x_PAUSE_THRESH - CL0-7 Pause quanta threshold register */
+    volatile uint32_t   rx_pause_status;    /* 0x074 RX_PAUSE_STATUS - Receive pause status register */
+    volatile uint32_t   reserved6[2];
+    t_MacAddr mac_addr[MEMAC_NUM_OF_PADDRS]; /* 0x80-0x0B4 MAC_ADDR_2...MAC_ADDR_15 */
+    volatile uint32_t   lpwake_timer;       /* 0x0B8 LPWAKE_TIMER - EEE Low Power Wakeup Timer register */
+    volatile uint32_t   sleep_timer;        /* 0x0BC SLEEP_TIMER - Transmit EEE Low Power Timer register */
+    volatile uint32_t   reserved7[8];
+    volatile uint32_t   statn_config;       /* 0x0E0 STATN_CONFIG - Statistics configuration register */
+    volatile uint32_t   reserved8[7];
+
+    /* Rx Statistics Counter */
+    volatile uint32_t   reoct_l;
+    volatile uint32_t   reoct_u;
+    volatile uint32_t   roct_l;
+    volatile uint32_t   roct_u;
+    volatile uint32_t   raln_l;
+    volatile uint32_t   raln_u;
+    volatile uint32_t   rxpf_l;
+    volatile uint32_t   rxpf_u;
+    volatile uint32_t   rfrm_l;
+    volatile uint32_t   rfrm_u;
+    volatile uint32_t   rfcs_l;
+    volatile uint32_t   rfcs_u;
+    volatile uint32_t   rvlan_l;
+    volatile uint32_t   rvlan_u;
+    volatile uint32_t   rerr_l;
+    volatile uint32_t   rerr_u;
+    volatile uint32_t   ruca_l;
+    volatile uint32_t   ruca_u;
+    volatile uint32_t   rmca_l;
+    volatile uint32_t   rmca_u;
+    volatile uint32_t   rbca_l;
+    volatile uint32_t   rbca_u;
+    volatile uint32_t   rdrp_l;
+    volatile uint32_t   rdrp_u;
+    volatile uint32_t   rpkt_l;
+    volatile uint32_t   rpkt_u;
+    volatile uint32_t   rund_l;
+    volatile uint32_t   rund_u;
+    volatile uint32_t   r64_l;
+    volatile uint32_t   r64_u;
+    volatile uint32_t   r127_l;
+    volatile uint32_t   r127_u;
+    volatile uint32_t   r255_l;
+    volatile uint32_t   r255_u;
+    volatile uint32_t   r511_l;
+    volatile uint32_t   r511_u;
+    volatile uint32_t   r1023_l;
+    volatile uint32_t   r1023_u;
+    volatile uint32_t   r1518_l;
+    volatile uint32_t   r1518_u;
+    volatile uint32_t   r1519x_l;
+    volatile uint32_t   r1519x_u;
+    volatile uint32_t   rovr_l;
+    volatile uint32_t   rovr_u;
+    volatile uint32_t   rjbr_l;
+    volatile uint32_t   rjbr_u;
+    volatile uint32_t   rfrg_l;
+    volatile uint32_t   rfrg_u;
+    volatile uint32_t   rcnp_l;
+    volatile uint32_t   rcnp_u;
+    volatile uint32_t   rdrntp_l;
+    volatile uint32_t   rdrntp_u;
+    volatile uint32_t   reserved9[12];
+
+    /* Tx Statistics Counter */
+    volatile uint32_t   teoct_l;
+    volatile uint32_t   teoct_u;
+    volatile uint32_t   toct_l;
+    volatile uint32_t   toct_u;
+    volatile uint32_t   reserved10[2];
+    volatile uint32_t   txpf_l;
+    volatile uint32_t   txpf_u;
+    volatile uint32_t   tfrm_l;
+    volatile uint32_t   tfrm_u;
+    volatile uint32_t   tfcs_l;
+    volatile uint32_t   tfcs_u;
+    volatile uint32_t   tvlan_l;
+    volatile uint32_t   tvlan_u;
+    volatile uint32_t   terr_l;
+    volatile uint32_t   terr_u;
+    volatile uint32_t   tuca_l;
+    volatile uint32_t   tuca_u;
+    volatile uint32_t   tmca_l;
+    volatile uint32_t   tmca_u;
+    volatile uint32_t   tbca_l;
+    volatile uint32_t   tbca_u;
+    volatile uint32_t   reserved11[2];
+    volatile uint32_t   tpkt_l;
+    volatile uint32_t   tpkt_u;
+    volatile uint32_t   tund_l;
+    volatile uint32_t   tund_u;
+    volatile uint32_t   t64_l;
+    volatile uint32_t   t64_u;
+    volatile uint32_t   t127_l;
+    volatile uint32_t   t127_u;
+    volatile uint32_t   t255_l;
+    volatile uint32_t   t255_u;
+    volatile uint32_t   t511_l;
+    volatile uint32_t   t511_u;
+    volatile uint32_t   t1023_l;
+    volatile uint32_t   t1023_u;
+    volatile uint32_t   t1518_l;
+    volatile uint32_t   t1518_u;
+    volatile uint32_t   t1519x_l;
+    volatile uint32_t   t1519x_u;
+    volatile uint32_t   reserved12[6];
+    volatile uint32_t   tcnp_l;
+    volatile uint32_t   tcnp_u;
+    volatile uint32_t   reserved13[14];
+
+    /* Line Interface Control */
+    volatile uint32_t   if_mode;            /* 0x300 IF_MODE - Interface Mode Control register */
+    volatile uint32_t   if_status;          /* 0x304 IF_STATUS - Interface Status register */
+    volatile uint32_t   reserved14[14];
+
+    /* HiGig/2 */
+    volatile uint32_t   hg_config;          /* 0x340 HG_CONFIG - HiGig/2 Control and configuration register */
+    volatile uint32_t   reserved15[3];
+    volatile uint32_t   hg_pause_quanta;    /* 0x350 HG_PAUSE_QUANTA - HiGig2 Pause quanta register */
+    volatile uint32_t   reserved16[3];
+    volatile uint32_t   hg_pause_thresh;    /* 0x360 HG_PAUSE_THRESH - HiGig2 Pause quanta threshold register */
+    volatile uint32_t   reserved17[3];
+    volatile uint32_t   hgrx_pause_status;  /* 0x370 HGRX_PAUSE_STATUS - HiGig2 Receive pause status register*/
+    volatile uint32_t   hg_fifos_status;    /* 0x374 HG_FIFOS_STATUS - HiGig2 fifos status register */
+    volatile uint32_t   rhm;                /* 0x378 RHM - Receive HiGig2 messages counter register */
+    volatile uint32_t   thm;                /* 0x37C THM - Transmit HiGig2 messages counter register */
+} _PackedType t_MemacMemMap;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+typedef struct t_MemacDriverParam
+{
+    bool resetOnInit;
+    bool wanModeEnable;             /* WAN Mode Enable. Sets WAN mode (1) or LAN mode (0, default) of operation. */
+    bool promiscuousModeEnable;     /* Enables MAC promiscuous operation. When set to '1', all frames are received without any MAC address filtering, when set to '0' (Reset value) Unicast Frames with a destination address not matching the Core MAC Address (MAC Address programmed in Registers MAC_ADDR_0 and MAC_ADDR_1 or the MAC address programmed in Registers MAC_ADDR_2 and MAC_ADDR_3 ) are rejected. */
+    bool pauseForwardEnable;        /* Terminate / Forward Pause Frames. If set to '1' pause frames are forwarded to the user application. When set to '0' (Reset value) pause frames are terminated and discarded within the MAC. */
+    bool pauseIgnore;               /* Ignore Pause Frame Quanta. If set to '1' received pause frames are ignored by the MAC. When set to '0' (Reset value) the transmit process is stopped for the amount of time specified in the pause quanta received within a pause frame. */
+    bool txAddrInsEnable;           /* Set Source MAC Address on Transmit.
+                                        If set to '1' the MAC overwrites the source MAC address received from the Client Interface with one of the MAC addresses (Refer to section 10.4)
+                                        If set to '0' (Reset value), the source MAC address from the Client Interface is transmitted unmodified to the line. */
+    bool loopbackEnable;            /* PHY Interface Loopback. When set to '1', the signal loop_ena is set to '1', when set to '0' (Reset value) the signal loop_ena is set to '0'. */
+    bool cmdFrameEnable;            /* Enables reception of all command frames. When set to '1' all Command Frames are accepted, when set to '0' (Reset Value) only Pause Frames are accepted and all other Command Frames are rejected. */
+    bool rxErrorDiscard;            /* Receive Errored Frame Discard Enable. When set to 1, any frame received with an error is discarded in the Core and not forwarded to the Client interface. When set to 0 (Reset value), errored Frames are forwarded to the Client interface with ff_rx_err asserted. */
+    bool phyTxenaOn;                /* PHY Transmit Enable. When set to '1', the signal phy_txena is set to '1', when set to '0' (Reset value) the signal phy_txena is set to '0' */
+    bool sendIdleEnable;            /* Force Idle Generation. When set to '1', the MAC permanently sends XGMII Idle sequences even when faults are received. */
+    bool noLengthCheckEnable;       /* Payload Length Check Disable. When set to 0 (Reset value), the Core checks the frame's payload length with the Frame Length/Type field, when set to 1, the payload length check is disabled. */
+    bool lgthCheckNostdr;           /* The Core interprets the Length/Type field differently depending on the value of this Bit */
+    bool timeStampEnable;           /* This bit selects between enabling and disabling the IEEE 1588 functionality.
+                                        1: IEEE 1588 is enabled.
+                                        0: IEEE 1588 is disabled. */
+    bool padAndCrcEnable;
+    bool rxSfdAny;                  /* Enables, when set, that any character is allowed at the SFD position of the preamble and the frame will be accepted.
+                                        If cleared (default) the frame is accepted only if the 8th byte of the preamble contains the SFD value 0xd5. If another value is received, the frame is discarded and the alignment error counter increments. */
+    bool rxPblFwd;                  /* Receive Preamble Forwarding (custom preamble).
+                                        If set, the first word (ff_rx_sop) of every received frame contains the preamble of the frame. The frame data starts with the 2nd word from the FIFO.
+                                        If the bit is cleared (default) the preamble is removed from the frame before it is written into the receive FIFO. */
+    bool txPblFwd;                  /* Transmit Preamble Forwarding (custom preamble).
+                                        If set, the first word written into the TX FIFO is considered as frame preamble. The MAC will not add a preamble in front of the frame. Note that bits 7:0 of the preamble word will still be overwritten with the XGMII start character upon transmission.
+                                        If cleared (default) the MAC */
+    uint32_t txIpgLength;           /*Transmit Inter-Packet-Gap (IPG) value.
+                                      A 6-bit value: Depending on LAN or WAN mode of operation (see COMMAND_CONFIG, 19.2.1 page 91) the value has the following meaning:
+                                        - LAN Mode: Number of octets in steps of 4. Valid values are 8, 12, 16, ... 100. DIC is fully supported (see 10.6.1 page 49) for any setting. A default of 12 (reset value) must be set to conform to IEEE802.3ae. Warning: When set to 8, PCS layers may not be able to perform clock rate compensation.
+                                        - WAN Mode: Stretch factor. Valid values are 4..15. The stretch factor is calculated as (value+1)*8. A default of 12 (reset value) must be set to conform to IEEE 802.3ae (i.e. 13*8=104). A larger value shrinks the IPG (increasing bandwidth). */
+/*.. */
+    uint16_t    maxFrameLength;
+    bool        debugMode;
+    uint16_t    pauseTime;
+#ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+    bool        skipFman11Workaround;
+#endif /* FM_TX_ECC_FRMS_ERRATA_10GMAC_A004 */
+} t_MemacDriverParam;
+
+typedef struct t_Memac
+{
+    t_FmMacControllerDriver     fmMacControllerDriver;               /**< Upper Mac control block */
+    t_Handle                    h_App;                               /**< Handle to the upper layer application  */
+    t_MemacMemMap               *p_MemMap;                           /**< Pointer to MAC memory mapped registers */
+    t_MemacMiiAccessMemMap      *p_MiiMemMap;                        /**< Pointer to MII memory mapped registers */
+    uint64_t                    addr;                                /**< MAC address of device */
+    e_EnetMode                  enetMode;                            /**< Ethernet physical interface  */
+    t_FmMacExceptionCallback    *f_Exception;
+    int                         mdioIrq;
+    t_FmMacExceptionCallback    *f_Event;
+    bool                        indAddrRegUsed[MEMAC_NUM_OF_PADDRS]; /**< Whether a particular individual address recognition register is being used */
+    uint64_t                    paddr[MEMAC_NUM_OF_PADDRS];          /**< MAC address for particular individual address recognition register */
+    uint8_t                     numOfIndAddrInRegs;                  /**< Number of individual addresses in registers for this station. */
+    t_EthHash                   *p_MulticastAddrHash;                /**< Pointer to driver's global address hash table  */
+    t_EthHash                   *p_UnicastAddrHash;                  /**< Pointer to driver's individual address hash table  */
+    bool                        debugMode;
+    uint8_t                     macId;
+    uint32_t                    exceptions;
+    t_MemacDriverParam          *p_MemacDriverParam;
+} t_Memac;
+
+#define MEMAC_TO_MII_OFFSET         0x030       /* Offset from the MEM map to the MDIO mem map */
+
+t_Error MEMAC_MII_WritePhyReg(t_Handle h_Memac, uint8_t phyAddr, uint8_t reg, uint16_t data);
+t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,  uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
+
+
+#endif /* __MEMAC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
new file mode 100644
index 0000000..a278efd
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.c
@@ -0,0 +1,275 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_mac.h"
+#include "memac.h"
+#include "xx_ext.h"
+
+#include "fm_common.h"
+
+
+static void WritePhyReg10G(t_Memac   *p_Memac,
+                           uint8_t   phyAddr,
+                           uint8_t   reg,
+                           uint16_t  data,
+                           uint16_t  clkDiv)
+{
+    t_MemacMiiAccessMemMap  *p_MiiAccess;
+    uint32_t                tmpReg;
+
+    p_MiiAccess = p_Memac->p_MiiMemMap;
+
+    /* Set up MDC frequency and 10G interface */
+    tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
+    tmpReg &= ~MDIO_CFG_CLK_DIV_MASK;
+    tmpReg |= (clkDiv << MDIO_CFG_CLK_DIV_SHIFT);
+    tmpReg |= MDIO_CFG_ENC45;
+    WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
+        XX_UDelay(1);
+
+    /* Specify phy and register to be accessed */
+    WRITE_UINT32(p_MiiAccess->mdio_ctrl, phyAddr);
+    WRITE_UINT32(p_MiiAccess->mdio_addr, reg);
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
+        XX_UDelay(1);
+
+    /* Write data */
+    WRITE_UINT32(p_MiiAccess->mdio_data, data);
+
+    CORE_MemoryBarrier();
+
+    /* Wait for write transaction end */
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
+        XX_UDelay(1);
+}
+
+static t_Error ReadPhyReg10G(t_Memac   *p_Memac,
+                             uint8_t   phyAddr,
+                             uint8_t   reg,
+                             uint16_t  *p_Data,
+                             uint16_t  clkDiv)
+{
+    t_MemacMiiAccessMemMap  *p_MiiAccess;
+    uint32_t                tmpReg;
+
+    p_MiiAccess = p_Memac->p_MiiMemMap;
+
+    /* Set up MDC frequency and 10G interface */
+    tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
+    tmpReg &= ~MDIO_CFG_CLK_DIV_MASK;
+    tmpReg |= (clkDiv << MDIO_CFG_CLK_DIV_SHIFT);
+    tmpReg |= MDIO_CFG_ENC45;
+    WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
+        XX_UDelay(1);
+
+    /* Specify phy and register to be accessed */
+    WRITE_UINT32(p_MiiAccess->mdio_ctrl, phyAddr);
+    WRITE_UINT32(p_MiiAccess->mdio_addr, reg);
+
+    CORE_MemoryBarrier();
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
+        XX_UDelay(1);
+
+    /* Read cycle */
+    tmpReg = phyAddr;
+    tmpReg |= MDIO_CTL_READ;
+    WRITE_UINT32(p_MiiAccess->mdio_ctrl, tmpReg);
+
+    CORE_MemoryBarrier();
+
+    /* Wait for data to be available */
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
+        XX_UDelay(1);
+
+    *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
+
+    /* Check error */
+    tmpReg  = GET_UINT32(p_MiiAccess->mdio_cfg);
+
+    if (tmpReg & MDIO_CFG_READ_ERR)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE,
+                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfgReg 0x%x",
+                      ((phyAddr & 0xe0) >> 5), (phyAddr & 0x1f), reg, tmpReg));
+
+    return E_OK;
+}
+
+static void WritePhyReg1G(t_Memac   *p_Memac,
+                          uint8_t   phyAddr,
+                          uint8_t   reg,
+                          uint16_t  data,
+                          uint16_t  clkDiv)
+{
+    t_MemacMiiAccessMemMap  *p_MiiAccess;
+    uint32_t                tmpReg;
+
+    p_MiiAccess = p_Memac->p_MiiMemMap;
+
+    /* Set up MDC frequency and 1G interface */
+    tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
+    tmpReg &= ~MDIO_CFG_CLK_DIV_MASK;
+    tmpReg |= (clkDiv << MDIO_CFG_CLK_DIV_SHIFT);
+    tmpReg &= ~MDIO_CFG_ENC45;
+    WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
+        XX_UDelay(1);
+
+    /* Write transaction */
+    tmpReg = (phyAddr << MDIO_CTL_PHY_ADDR_SHIFT);
+    tmpReg |= reg;
+    WRITE_UINT32(p_MiiAccess->mdio_ctrl, tmpReg);
+
+    WRITE_UINT32(p_MiiAccess->mdio_data, data);
+
+    CORE_MemoryBarrier();
+
+    /* Wait for write transaction end */
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
+        XX_UDelay(1);
+}
+
+static t_Error ReadPhyReg1G(t_Memac   *p_Memac,
+                            uint8_t   phyAddr,
+                            uint8_t   reg,
+                            uint16_t  *p_Data,
+                            uint16_t  clkDiv)
+{
+    t_MemacMiiAccessMemMap  *p_MiiAccess;
+    uint32_t                tmpReg;
+
+    p_MiiAccess = p_Memac->p_MiiMemMap;
+
+    /* Set up MDC frequency and 1G interface */
+    tmpReg = GET_UINT32(p_MiiAccess->mdio_cfg);
+    tmpReg &= ~MDIO_CFG_CLK_DIV_MASK;
+    tmpReg |= (clkDiv << MDIO_CFG_CLK_DIV_SHIFT);
+    tmpReg &= ~MDIO_CFG_ENC45;
+    WRITE_UINT32(p_MiiAccess->mdio_cfg, tmpReg);
+
+    while ((GET_UINT32(p_MiiAccess->mdio_cfg)) & MDIO_CFG_BSY)
+        XX_UDelay(1);
+
+    /* Read transaction */
+    tmpReg = (phyAddr << MDIO_CTL_PHY_ADDR_SHIFT);
+    tmpReg |= reg;
+    tmpReg |= MDIO_CTL_READ;
+    WRITE_UINT32(p_MiiAccess->mdio_ctrl, tmpReg);
+
+    /* Wait for data to be available */
+    while ((GET_UINT32(p_MiiAccess->mdio_data)) & MDIO_DATA_BSY)
+        XX_UDelay(1);
+
+    *p_Data =  (uint16_t)GET_UINT32(p_MiiAccess->mdio_data);
+
+    /* Check error */
+    tmpReg  = GET_UINT32(p_MiiAccess->mdio_cfg);
+
+    if (tmpReg & MDIO_CFG_READ_ERR)
+        RETURN_ERROR(MINOR, E_INVALID_VALUE,
+                     ("Read Error: phyAddr 0x%x, dev 0x%x, reg 0x%x, cfgReg 0x%x",
+                      ((phyAddr & 0xe0) >> 5), (phyAddr & 0x1f), reg, tmpReg));
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error MEMAC_MII_WritePhyReg(t_Handle  h_Memac,
+                             uint8_t    phyAddr,
+                             uint8_t    reg,
+                             uint16_t   data)
+{
+    t_Memac                 *p_Memac = (t_Memac *)h_Memac;
+    bool                    phy10G;
+    uint16_t                clkDiv;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MiiMemMap, E_INVALID_HANDLE);
+
+    /* Figure out interface type - 10G vs 1G.
+       In 10G interface both phyAddr and devAddr present. */
+    phy10G = (phyAddr > 0x1F) ? TRUE : FALSE;
+
+    /* Figure out MDC frequency: the resulting clock should be 2.5 MHz.
+       MDC freq (2.5 MHz) = memacRefClk / ((2*MDIO_CLK_DIV)+1) */
+    clkDiv = DIV_CEIL((p_Memac->fmMacControllerDriver.clkFreq*10), 2*25) - 1;
+    clkDiv = DIV_CEIL(clkDiv, 2);
+
+    if (phy10G)
+        WritePhyReg10G(p_Memac, phyAddr, reg, data, clkDiv);
+    else
+        WritePhyReg1G(p_Memac, phyAddr, reg, data, clkDiv);
+
+    return E_OK;
+}
+
+/*****************************************************************************/
+t_Error MEMAC_MII_ReadPhyReg(t_Handle h_Memac,
+                            uint8_t   phyAddr,
+                            uint8_t   reg,
+                            uint16_t  *p_Data)
+{
+    t_Memac                 *p_Memac = (t_Memac *)h_Memac;
+    bool                    phy10G;
+    uint16_t                clkDiv;
+    t_Error                 errCode;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_Memac->p_MiiMemMap, E_INVALID_HANDLE);
+
+    /* Figure out interface type - 10G vs 1G.
+       In 10G interface both phyAddr and devAddr present. */
+    phy10G = (phyAddr > 0x1F) ? TRUE : FALSE;
+
+    /* Figure out MDC frequency: the resulting clock should be 2.5 MHz.
+       MDC freq (2.5 MHz) = memacRefClk / ((2*MDIO_CLK_DIV)+1) */
+    clkDiv = DIV_CEIL((p_Memac->fmMacControllerDriver.clkFreq*10), 2*25) - 1;
+    clkDiv = DIV_CEIL(clkDiv, 2);
+
+    if (phy10G)
+        errCode = ReadPhyReg10G(p_Memac, phyAddr, reg, p_Data, clkDiv);
+    else
+        errCode = ReadPhyReg1G(p_Memac, phyAddr, reg, p_Data, clkDiv);
+
+    return errCode;
+}
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h
new file mode 100644
index 0000000..3179f71
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/MAC/memac_mii_acc.h
@@ -0,0 +1,72 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#ifndef __MEMAC_MII_ACC_H
+#define __MEMAC_MII_ACC_H
+
+#include "std_ext.h"
+
+
+/* MII Management Registers */
+#define MDIO_CFG_CLK_DIV_MASK       0x0000ff80
+#define MDIO_CFG_CLK_DIV_SHIFT      7
+#define MDIO_CFG_ENC45              0x00000040
+#define MDIO_CFG_READ_ERR           0x00000002
+#define MDIO_CFG_BSY                0x00000001
+
+#define MDIO_CTL_PHY_ADDR_SHIFT     5
+#define MDIO_CTL_READ               0x00008000
+
+#define MDIO_DATA_BSY               0x80000000
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+/*----------------------------------------------------*/
+/* MII Configuration Control Memory Map Registers     */
+/*----------------------------------------------------*/
+typedef _Packed struct t_MemacMiiAccessMemMap
+{
+    volatile uint32_t   mdio_cfg;       /* 0x030  */
+    volatile uint32_t   mdio_ctrl;      /* 0x034  */
+    volatile uint32_t   mdio_data;      /* 0x038  */
+    volatile uint32_t   mdio_addr;      /* 0x03c  */
+} _PackedType t_MemacMiiAccessMemMap ;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+#endif /* __MEMAC_MII_ACC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
index 603e120..34a689b 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/Makefile
@@ -13,3 +13,7 @@ EXTRA_CFLAGS += -I$(NCSW_FM_INC)
 obj-y		+= fsl-ncsw-Pcd.o
 
 fsl-ncsw-Pcd-objs	:= fm_cc.o fm_kg.o fm_pcd.o fm_plcr.o fm_prs.o fm_manip.o
+
+ifeq ($(CONFIG_FMAN_T4240),y)
+fsl-ncsw-Pcd-objs	+= fm_replic.o
+endif
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
new file mode 100644
index 0000000..72553b1
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.c
@@ -0,0 +1,980 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_replic.c
+
+ @Description   FM frame replicator
+*//***************************************************************************/
+#include "std_ext.h"
+#include "error_ext.h"
+#include "string_ext.h"
+#include "debug_ext.h"
+#include "fm_pcd_ext.h"
+#include "fm_muram_ext.h"
+#include "fm_common.h"
+#include "fm_hc.h"
+#include "fm_replic.h"
+#include "fm_cc.h"
+#include "list_ext.h"
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+static uint8_t  GetMemberPosition(t_FmPcdFrmReplicGroup *p_ReplicGroup,
+                                  uint32_t              memberIndex,
+                                  bool                  isAddOperation)
+{
+    uint8_t     memberPosition;
+    uint32_t    lastMemberIndex;
+
+    ASSERT_COND(p_ReplicGroup);
+
+    /* the last member index is different between add and remove operation -
+    in case of remove - this is exactly the last member index
+    in case of add - this is the last member index + 1 - e.g.
+    if we have 4 members, the index of the actual last member is 3(because the
+    index starts from 0) therefore in order to add a new member as the last
+    member we shall use memberIndex = 4 and not 3
+    */
+    if (isAddOperation)
+        lastMemberIndex = p_ReplicGroup->numOfEntries;
+    else
+        lastMemberIndex = p_ReplicGroup->numOfEntries-1;
+
+    /* last */
+    if (memberIndex == lastMemberIndex)
+        memberPosition = FRM_REPLIC_LAST_MEMBER_INDEX;
+    else
+    {
+        /* first */
+        if (memberIndex == 0)
+            memberPosition = FRM_REPLIC_FIRST_MEMBER_INDEX;
+        else
+        {
+            /* middle */
+            ASSERT_COND(memberIndex < lastMemberIndex);
+            memberPosition = FRM_REPLIC_MIDDLE_MEMBER_INDEX;
+        }
+    }
+    return memberPosition;
+}
+
+static t_Error MemberCheckParams(t_Handle                  h_FmPcd,
+                                 t_FmPcdCcNextEngineParams *p_MemberParams)
+{
+    t_Error         err;
+
+
+    if ((p_MemberParams->nextEngine != e_FM_PCD_DONE) &&
+        (p_MemberParams->nextEngine != e_FM_PCD_KG)   &&
+        (p_MemberParams->nextEngine != e_FM_PCD_PLCR))
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Next engine of a member should be MatchTable(cc) or Done or Policer"));
+
+    /* check the regular parameters of the next engine */
+    err = ValidateNextEngineParams(h_FmPcd, p_MemberParams, e_FM_PCD_CC_STATS_MODE_NONE);
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("member next engine parameters"));
+
+    return E_OK;
+}
+
+static t_Error CheckParams(t_Handle                     h_FmPcd,
+                           t_FmPcdFrmReplicGroupParams *p_ReplicGroupParam)
+{
+    int             i;
+    t_Error         err;
+
+    /* check that max num of entries is at least 2 */
+    if (!IN_RANGE(2, p_ReplicGroupParam->maxNumOfEntries, FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES))
+        RETURN_ERROR(MAJOR, E_NOT_IN_RANGE, ("maxNumOfEntries in the frame replicator parameters should be 2-%d",FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES));
+
+    /* check that number of entries is greater than zero */
+    if (!p_ReplicGroupParam->numOfEntries)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("numOFEntries in the frame replicator group should be greater than zero"));
+
+    /* check that max num of entries is equal or greater than number of entries */
+    if (p_ReplicGroupParam->maxNumOfEntries < p_ReplicGroupParam->numOfEntries)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("maxNumOfEntries should be equal or greater than numOfEntries"));
+
+    for (i=0; i<p_ReplicGroupParam->numOfEntries; i++)
+    {
+        err = MemberCheckParams(h_FmPcd, &p_ReplicGroupParam->nextEngineParams[i]);
+        if (err)
+            RETURN_ERROR(MAJOR, err, ("member check parameters"));
+    }
+    return E_OK;
+}
+
+static t_FmPcdFrmReplicMember *GetAvailableMember(t_FmPcdFrmReplicGroup *p_ReplicGroup)
+{
+    t_FmPcdFrmReplicMember  *p_ReplicMember = NULL;
+    t_List                  *p_Next;
+
+    if (!LIST_IsEmpty(&p_ReplicGroup->availableMembersList))
+    {
+        p_Next = LIST_FIRST(&p_ReplicGroup->availableMembersList);
+        p_ReplicMember = LIST_OBJECT(p_Next, t_FmPcdFrmReplicMember, node);
+        ASSERT_COND(p_ReplicMember);
+        LIST_DelAndInit(p_Next);
+    }
+    return p_ReplicMember;
+}
+
+static void PutAvailableMember(t_FmPcdFrmReplicGroup    *p_ReplicGroup,
+                               t_FmPcdFrmReplicMember   *p_ReplicMember)
+{
+    LIST_AddToTail(&p_ReplicMember->node, &p_ReplicGroup->availableMembersList);
+}
+
+static void AddMemberToList(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                            t_FmPcdFrmReplicMember  *p_CurrentMember,
+                            t_List                  *p_ListHead)
+{
+    LIST_Add(&p_CurrentMember->node, p_ListHead);
+
+    p_ReplicGroup->numOfEntries++;
+}
+
+static void RemoveMemberFromList(t_FmPcdFrmReplicGroup  *p_ReplicGroup,
+                                 t_FmPcdFrmReplicMember *p_CurrentMember)
+{
+    ASSERT_COND(p_ReplicGroup->numOfEntries);
+    LIST_DelAndInit(&p_CurrentMember->node);
+    p_ReplicGroup->numOfEntries--;
+}
+
+static void LinkSourceToMember(t_FmPcdFrmReplicGroup    *p_ReplicGroup,
+                               t_AdOfTypeContLookup     *p_SourceTd,
+                               t_FmPcdFrmReplicMember   *p_ReplicMember)
+{
+    t_FmPcd             *p_FmPcd;
+
+    ASSERT_COND(p_SourceTd);
+    ASSERT_COND(p_ReplicMember);
+    ASSERT_COND(p_ReplicGroup);
+    ASSERT_COND(p_ReplicGroup->h_FmPcd);
+
+    /* Link the first member in the group to the source TD */
+    p_FmPcd = p_ReplicGroup->h_FmPcd;
+
+    WRITE_UINT32(p_SourceTd->matchTblPtr,
+        (uint32_t)(XX_VirtToPhys(p_ReplicMember->p_MemberAd) -
+                        p_FmPcd->physicalMuramBase));
+}
+
+static void LinkMemberToMember(t_FmPcdFrmReplicGroup    *p_ReplicGroup,
+                               t_FmPcdFrmReplicMember   *p_CurrentMember,
+                               t_FmPcdFrmReplicMember   *p_NextMember)
+{
+    t_AdOfTypeResult    *p_CurrReplicAd = (t_AdOfTypeResult*)p_CurrentMember->p_MemberAd;
+    t_AdOfTypeResult    *p_NextReplicAd = NULL;
+    t_FmPcd             *p_FmPcd;
+    uint32_t            offset = 0;
+
+    /* Check if the next member exists or it's NULL (- means that this is the last member) */
+    if (p_NextMember)
+    {
+        p_NextReplicAd = (t_AdOfTypeResult*)p_NextMember->p_MemberAd;
+        p_FmPcd = p_ReplicGroup->h_FmPcd;
+        offset = (XX_VirtToPhys(p_NextReplicAd) - (p_FmPcd->physicalMuramBase));
+        offset = ((offset>>NEXT_FRM_REPLIC_ADDR_SHIFT)<< NEXT_FRM_REPLIC_MEMBER_INDEX_SHIFT);
+    }
+
+    /* link the current AD to point to the AD of the next member */
+    WRITE_UINT32(p_CurrReplicAd->res, offset);
+}
+
+static t_Error ModifyDescriptor(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                                void                    *p_OldDescriptor,
+                                void                    *p_NewDescriptor)
+{
+    t_Handle            h_Hc;
+    t_Error             err;
+    uint32_t            oldDescriptorOffset, newDescriptorOffset;
+    t_FmPcd             *p_FmPcd;
+
+    ASSERT_COND(p_ReplicGroup);
+    ASSERT_COND(p_ReplicGroup->h_FmPcd);
+    ASSERT_COND(p_OldDescriptor);
+    ASSERT_COND(p_NewDescriptor);
+
+    p_FmPcd = p_ReplicGroup->h_FmPcd;
+    h_Hc = FmPcdGetHcHandle(p_FmPcd);
+    if (!h_Hc)
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("Host command"));
+
+    oldDescriptorOffset =
+        (uint32_t)(XX_VirtToPhys(p_OldDescriptor) - p_FmPcd->physicalMuramBase);
+    newDescriptorOffset =
+        (uint32_t)(XX_VirtToPhys(p_NewDescriptor) - p_FmPcd->physicalMuramBase);
+
+    err = FmHcPcdCcDoDynamicChange(h_Hc, oldDescriptorOffset, newDescriptorOffset);
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("Dynamic change host command"));
+
+    return E_OK;
+}
+
+static void FillReplicAdOfTypeResult(void *p_ReplicAd, bool last)
+{
+    t_AdOfTypeResult    *p_CurrReplicAd = (t_AdOfTypeResult*)p_ReplicAd;
+    uint32_t            tmp;
+
+    tmp = GET_UINT32(p_CurrReplicAd->plcrProfile);
+    if (last)
+        /* clear the NL bit in case it's the last member in the group*/
+        WRITE_UINT32(p_CurrReplicAd->plcrProfile,(tmp & ~FRM_REPLIC_NL_BIT));
+    else
+        /* set the NL bit in case it's not the last member in the group */
+        WRITE_UINT32(p_CurrReplicAd->plcrProfile, (tmp |FRM_REPLIC_NL_BIT));
+
+    /* set FR bit in the action descriptor */
+    tmp = GET_UINT32(p_CurrReplicAd->nia);
+    WRITE_UINT32(p_CurrReplicAd->nia,
+        (tmp | FRM_REPLIC_FR_BIT | FM_PCD_AD_RESULT_EXTENDED_MODE ));
+}
+
+static void BuildSourceTd(void *p_Ad)
+{
+    t_AdOfTypeContLookup    *p_SourceTd;
+
+    ASSERT_COND(p_Ad);
+
+    p_SourceTd = (t_AdOfTypeContLookup *)p_Ad;
+
+    IOMemSet32((uint8_t*)p_SourceTd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    /* initialize the source table descriptor */
+    WRITE_UINT32(p_SourceTd->ccAdBase,     FM_PCD_AD_CONT_LOOKUP_TYPE);
+    WRITE_UINT32(p_SourceTd->pcAndOffsets, FRM_REPLIC_SOURCE_TD_OPCODE);
+}
+
+static t_Error BuildShadowAndModifyDescriptor(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                                              t_FmPcdFrmReplicMember  *p_NextMember,
+                                              t_FmPcdFrmReplicMember  *p_CurrentMember,
+                                              bool                    sourceDescriptor,
+                                              bool                    last)
+{
+    t_FmPcd                 *p_FmPcd;
+    t_FmPcdFrmReplicMember  shadowMember;
+    t_Error                 err;
+
+    ASSERT_COND(p_ReplicGroup);
+    ASSERT_COND(p_ReplicGroup->h_FmPcd);
+
+    p_FmPcd = p_ReplicGroup->h_FmPcd;
+    ASSERT_COND(p_FmPcd->p_CcShadow);
+
+    if (!TRY_LOCK(p_FmPcd->h_ShadowSpinlock, &p_FmPcd->shadowLock))
+        return ERROR_CODE(E_BUSY);
+
+    if (sourceDescriptor)
+    {
+        BuildSourceTd(p_FmPcd->p_CcShadow);
+        LinkSourceToMember(p_ReplicGroup, p_FmPcd->p_CcShadow, p_NextMember);
+
+        /* Modify the source table descriptor according to the prepared shadow descriptor */
+        err = ModifyDescriptor(p_ReplicGroup,
+                               p_ReplicGroup->p_SourceTd,
+                               p_FmPcd->p_CcShadow/* new prepared source td */);
+
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+        if (err)
+            RETURN_ERROR(MAJOR, err, ("Modify source Descriptor in BuildShadowAndModifyDescriptor"));
+
+    }
+    else
+    {
+        IO2IOCpy32(p_FmPcd->p_CcShadow,
+                   p_CurrentMember->p_MemberAd,
+                   FM_PCD_CC_AD_ENTRY_SIZE);
+
+        /* update the last bit in the shadow ad */
+        FillReplicAdOfTypeResult(p_FmPcd->p_CcShadow, last);
+
+        shadowMember.p_MemberAd = p_FmPcd->p_CcShadow;
+
+        /* update the next FR member index */
+        LinkMemberToMember(p_ReplicGroup, &shadowMember, p_NextMember);
+
+        /* Modify the next member according to the prepared shadow descriptor */
+        err = ModifyDescriptor(p_ReplicGroup,
+                               p_CurrentMember->p_MemberAd,
+                               p_FmPcd->p_CcShadow);
+
+        RELEASE_LOCK(p_FmPcd->shadowLock);
+        if (err)
+            RETURN_ERROR(MAJOR, err, ("Modify Descriptor in BuildShadowAndModifyDescriptor"));
+    }
+
+
+    return E_OK;
+}
+
+static t_FmPcdFrmReplicMember* GetMemberByIndex(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                                                uint16_t                memberIndex)
+{
+    int                     i=0;
+    t_List                  *p_Pos;
+    t_FmPcdFrmReplicMember  *p_Member = NULL;
+
+    LIST_FOR_EACH(p_Pos, &p_ReplicGroup->membersList)
+    {
+        if (i == memberIndex)
+        {
+            p_Member = LIST_OBJECT(p_Pos, t_FmPcdFrmReplicMember, node);
+            return p_Member;
+        }
+        i++;
+    }
+    return p_Member;
+}
+
+static t_Error AllocMember(t_FmPcdFrmReplicGroup *p_ReplicGroup)
+{
+    t_FmPcdFrmReplicMember  *p_CurrentMember;
+    t_Handle                h_Muram;
+
+    ASSERT_COND(p_ReplicGroup);
+
+    h_Muram = FmPcdGetMuramHandle(p_ReplicGroup->h_FmPcd);
+    ASSERT_COND(h_Muram);
+
+    /* Initialize an internal structure of a member to add to the available members list */
+    p_CurrentMember = (t_FmPcdFrmReplicMember *)XX_Malloc(sizeof(t_FmPcdFrmReplicMember));
+    if (!p_CurrentMember)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("Frame replicator member"));
+
+    memset(p_CurrentMember, 0 ,sizeof(t_FmPcdFrmReplicMember));
+
+    /* Allocate the member AD */
+    p_CurrentMember->p_MemberAd =
+        (t_AdOfTypeResult*)FM_MURAM_AllocMem(h_Muram,
+                                             FM_PCD_CC_AD_ENTRY_SIZE,
+                                             FM_PCD_CC_AD_TABLE_ALIGN);
+
+    if (!p_CurrentMember->p_MemberAd)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("member AD table"));
+
+    IOMemSet32((uint8_t*)p_CurrentMember->p_MemberAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    /* Add the new member to the available members list */
+    LIST_AddToTail(&p_CurrentMember->node, &(p_ReplicGroup->availableMembersList));
+
+    return E_OK;
+}
+
+static t_FmPcdFrmReplicMember* InitMember(t_FmPcdFrmReplicGroup     *p_ReplicGroup,
+                                          t_FmPcdCcNextEngineParams *p_MemberParams,
+                                          bool                      last)
+{
+    t_FmPcdFrmReplicMember  *p_CurrentMember = NULL;
+
+    ASSERT_COND(p_ReplicGroup);
+
+    /* Get an available member from the internal members list */
+    p_CurrentMember = GetAvailableMember(p_ReplicGroup);
+    if (!p_CurrentMember)
+    {
+        REPORT_ERROR(MAJOR, E_NOT_FOUND, ("Available member"));
+        return NULL;
+    }
+    p_CurrentMember->h_Manip = NULL;
+
+    /* clear the Ad of the new member */
+    IOMemSet32((uint8_t*)p_CurrentMember->p_MemberAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+    INIT_LIST(&p_CurrentMember->node);
+
+    /* Initialize the Ad of the member */
+    NextStepAd(p_CurrentMember->p_MemberAd,
+               NULL,
+               NULL,
+               NULL,
+               p_MemberParams,
+               p_ReplicGroup->h_FmPcd);
+
+    /* save Manip handle (for free needs) */
+    if (p_MemberParams->h_Manip)
+        p_CurrentMember->h_Manip = p_MemberParams->h_Manip;
+
+    /* Initialize the relevant frame replicator fields in the AD */
+    FillReplicAdOfTypeResult(p_CurrentMember->p_MemberAd, last);
+
+    return p_CurrentMember;
+}
+
+static void FreeMember(t_FmPcdFrmReplicGroup    *p_ReplicGroup,
+                       t_FmPcdFrmReplicMember   *p_Member)
+{
+    /* Note: Can't free the member AD just returns the member to the available
+       member list - therefore only memset the AD */
+
+    /* zero the AD */
+    IOMemSet32(p_Member->p_MemberAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
+
+
+    /* return the member to the available members list */
+    PutAvailableMember(p_ReplicGroup, p_Member);
+}
+
+static t_Error RemoveMember(t_FmPcdFrmReplicGroup   *p_ReplicGroup,
+                            uint16_t                memberIndex)
+{
+    t_FmPcd                 *p_FmPcd = NULL;
+    t_FmPcdFrmReplicMember  *p_CurrentMember = NULL, *p_PreviousMember = NULL, *p_NextMember = NULL;
+    t_Error                 err;
+    uint8_t                 memberPosition;
+
+    p_FmPcd         = p_ReplicGroup->h_FmPcd;
+    ASSERT_COND(p_FmPcd);
+
+    p_CurrentMember = GetMemberByIndex(p_ReplicGroup, memberIndex);
+    ASSERT_COND(p_CurrentMember);
+
+    /* determine the member position in the group */
+    memberPosition = GetMemberPosition(p_ReplicGroup,
+                                       memberIndex,
+                                       FALSE/*remove operation*/);
+
+    switch (memberPosition)
+    {
+        case FRM_REPLIC_FIRST_MEMBER_INDEX:
+            p_NextMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex+1));
+            ASSERT_COND(p_NextMember);
+
+            /* update the source td itself by using a host command */
+            err = BuildShadowAndModifyDescriptor(p_ReplicGroup,
+                                                 p_NextMember,
+                                                 NULL,
+                                                 TRUE/*sourceDescriptor*/,
+                                                 FALSE/*last*/);
+            if (err)
+                RETURN_ERROR(MAJOR, err, ("update source td itself"));
+            break;
+
+        case FRM_REPLIC_MIDDLE_MEMBER_INDEX:
+            p_PreviousMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex-1));
+            ASSERT_COND(p_PreviousMember);
+
+            p_NextMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex+1));
+            ASSERT_COND(p_NextMember);
+
+            err = BuildShadowAndModifyDescriptor(p_ReplicGroup,
+                                                 p_NextMember,
+                                                 p_PreviousMember,
+                                                 FALSE/*sourceDescriptor*/,
+                                                 FALSE/*last*/);
+
+            if (err)
+                RETURN_ERROR(MAJOR, err, ("Build Shadow and modify descriptor in case of middle member"));
+            break;
+
+        case FRM_REPLIC_LAST_MEMBER_INDEX:
+            p_PreviousMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex-1));
+            ASSERT_COND(p_PreviousMember);
+
+            err = BuildShadowAndModifyDescriptor(p_ReplicGroup,
+                                                 NULL,
+                                                 p_PreviousMember,
+                                                 FALSE/*sourceDescriptor*/,
+                                                 TRUE/*last*/);
+            if (err)
+                RETURN_ERROR(MAJOR, err, ("Build Shadow and modify descriptor in case of last member"));
+            break;
+
+        default:
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member position in remove member"));
+    }
+
+    if (p_CurrentMember->h_Manip)
+    {
+        FmPcdManipUpdateOwner(p_CurrentMember->h_Manip, FALSE);
+        p_CurrentMember->h_Manip = NULL;
+    }
+
+    /* remove the member from the driver internal members list */
+    RemoveMemberFromList(p_ReplicGroup, p_CurrentMember);
+
+    /* return the member to the available members list */
+    FreeMember(p_ReplicGroup, p_CurrentMember);
+
+    return E_OK;
+}
+
+static void DeleteGroup(t_FmPcdFrmReplicGroup *p_ReplicGroup)
+{
+    int                     i, j;
+    t_Handle                h_Muram;
+    t_FmPcdFrmReplicMember  *p_Member, *p_CurrentMember;
+
+    if (p_ReplicGroup)
+    {
+        ASSERT_COND(p_ReplicGroup->h_FmPcd);
+        h_Muram = FmPcdGetMuramHandle(p_ReplicGroup->h_FmPcd);
+        ASSERT_COND(h_Muram);
+
+        /* free the source table descriptor */
+        if (p_ReplicGroup->p_SourceTd)
+        {
+            FM_MURAM_FreeMem(h_Muram, p_ReplicGroup->p_SourceTd);
+            p_ReplicGroup->p_SourceTd = NULL;
+        }
+
+        /* Remove all members from the members linked list (hw and sw) and
+           return the members to the available members list */
+        if (p_ReplicGroup->numOfEntries)
+        {
+            j = p_ReplicGroup->numOfEntries-1;
+
+            /* manually removal of the member because there are no owners of
+               this group */
+            for (i=j; i>=0; i--)
+            {
+                p_CurrentMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)i/*memberIndex*/);
+                ASSERT_COND(p_CurrentMember);
+
+                if (p_CurrentMember->h_Manip)
+                {
+                    FmPcdManipUpdateOwner(p_CurrentMember->h_Manip, FALSE);
+                    p_CurrentMember->h_Manip = NULL;
+                }
+
+                /* remove the member from the internal driver members list */
+                RemoveMemberFromList(p_ReplicGroup, p_CurrentMember);
+
+                /* return the member to the available members list */
+                FreeMember(p_ReplicGroup, p_CurrentMember);
+            }
+        }
+
+        /* Free members AD */
+        for (i=0; i<p_ReplicGroup->maxNumOfEntries; i++)
+        {
+            p_Member = GetAvailableMember(p_ReplicGroup);
+            ASSERT_COND(p_Member);
+            if (p_Member->p_MemberAd)
+            {
+                FM_MURAM_FreeMem(h_Muram, p_Member->p_MemberAd);
+                p_Member->p_MemberAd = NULL;
+            }
+            XX_Free(p_Member);
+        }
+
+        /* release the group lock */
+        if (p_ReplicGroup->p_Lock)
+            FmPcdReleaseLock(p_ReplicGroup->h_FmPcd, p_ReplicGroup->p_Lock);
+
+        /* free the replicator group */
+        XX_Free(p_ReplicGroup);
+        p_ReplicGroup = NULL;
+    }
+}
+
+
+/*****************************************************************************/
+/*              Inter-module API routines                                    */
+/*****************************************************************************/
+
+/* NOTE: the inter-module routines are locked by cc in case of using them */
+void * FrmReplicGroupGetSourceTableDescriptor(t_Handle h_ReplicGroup)
+{
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+    ASSERT_COND(p_ReplicGroup);
+
+    return (p_ReplicGroup->p_SourceTd);
+}
+
+void FrmReplicGroupUpdateAd(t_Handle  h_ReplicGroup,
+                            void      *p_Ad,
+                            t_Handle  *h_AdNew)
+{
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+    t_AdOfTypeResult    *p_AdResult = (t_AdOfTypeResult*)p_Ad;
+    t_FmPcd             *p_FmPcd;
+
+    ASSERT_COND(p_ReplicGroup);
+    p_FmPcd    = p_ReplicGroup->h_FmPcd;
+    /* build a bypass ad */
+    WRITE_UINT32(p_AdResult->fqid, FM_PCD_AD_BYPASS_TYPE |
+        (uint32_t)((XX_VirtToPhys(p_ReplicGroup->p_SourceTd)) - p_FmPcd->physicalMuramBase));
+
+    *h_AdNew = NULL;
+}
+
+void  FrmReplicGroupUpdateOwner(t_Handle                   h_ReplicGroup,
+                                bool                       add)
+{
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+    ASSERT_COND(p_ReplicGroup);
+
+    /* update the group owner counter */
+    if (add)
+        p_ReplicGroup->owners++;
+    else
+    {
+        ASSERT_COND(p_ReplicGroup->owners);
+        p_ReplicGroup->owners--;
+    }
+}
+
+t_Error FrmReplicGroupTryLock(t_Handle h_ReplicGroup)
+{
+    t_FmPcdFrmReplicGroup *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+
+    ASSERT_COND(h_ReplicGroup);
+
+    if (FmPcdLockTryLock(p_ReplicGroup->p_Lock))
+        return E_OK;
+
+    return ERROR_CODE(E_BUSY);
+}
+
+void FrmReplicGroupUnlock(t_Handle h_ReplicGroup)
+{
+    t_FmPcdFrmReplicGroup *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+
+    ASSERT_COND(h_ReplicGroup);
+
+    FmPcdLockUnlock(p_ReplicGroup->p_Lock);
+}
+/*********************** End of inter-module routines ************************/
+
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_PCD_FrmReplicSetGroup(t_Handle                    h_FmPcd,
+                                  t_FmPcdFrmReplicGroupParams *p_ReplicGroupParam)
+{
+    t_FmPcdFrmReplicGroup       *p_ReplicGroup;
+    t_FmPcdFrmReplicMember      *p_CurrentMember, *p_NextMember = NULL;
+    int                         i;
+    t_Error                     err;
+    bool                        last = FALSE;
+    t_Handle                    h_Muram;
+
+    SANITY_CHECK_RETURN_VALUE(h_FmPcd, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_ReplicGroupParam, E_INVALID_HANDLE, NULL);
+
+    err = CheckParams(h_FmPcd, p_ReplicGroupParam);
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, (NO_MSG));
+        return NULL;
+    }
+
+    p_ReplicGroup = (t_FmPcdFrmReplicGroup*)XX_Malloc(sizeof(t_FmPcdFrmReplicGroup));
+    if (!p_ReplicGroup)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("No memory"));
+        return NULL;
+    }
+    memset(p_ReplicGroup, 0, sizeof(t_FmPcdFrmReplicGroup));
+
+    /* initialize lists for internal driver use */
+    INIT_LIST(&p_ReplicGroup->availableMembersList);
+    INIT_LIST(&p_ReplicGroup->membersList);
+
+    p_ReplicGroup->h_FmPcd = h_FmPcd;
+
+    h_Muram = FmPcdGetMuramHandle(p_ReplicGroup->h_FmPcd);
+    ASSERT_COND(h_Muram);
+
+    /* initialize the group lock */
+    p_ReplicGroup->p_Lock = FmPcdAcquireLock(p_ReplicGroup->h_FmPcd);
+    if (!p_ReplicGroup->p_Lock)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Replic group lock"));
+        DeleteGroup(p_ReplicGroup);
+        return NULL;
+    }
+
+    /* Allocate the frame replicator source table descriptor */
+    p_ReplicGroup->p_SourceTd =
+        (t_Handle)FM_MURAM_AllocMem(h_Muram,
+                                    FM_PCD_CC_AD_ENTRY_SIZE,
+                                    FM_PCD_CC_AD_TABLE_ALIGN);
+    if (!p_ReplicGroup->p_SourceTd)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("frame replicator source table descriptor"));
+        DeleteGroup(p_ReplicGroup);
+        return NULL;
+    }
+
+    /* update the shadow size - required for the host commands */
+    err = FmPcdUpdateCcShadow(p_ReplicGroup->h_FmPcd,
+                              FM_PCD_CC_AD_ENTRY_SIZE,
+                              FM_PCD_CC_AD_TABLE_ALIGN);
+    if (err)
+    {
+        REPORT_ERROR(MAJOR, err, ("Update CC shadow"));
+        DeleteGroup(p_ReplicGroup);
+        return NULL;
+    }
+
+    p_ReplicGroup->maxNumOfEntries  = p_ReplicGroupParam->maxNumOfEntries;
+
+    /* Allocate the maximal number of members ADs and Statistics AD for the group
+       It prevents allocation of Muram in run-time */
+    for (i=0; i<p_ReplicGroup->maxNumOfEntries; i++)
+    {
+        err = AllocMember(p_ReplicGroup);
+        if (err)
+        {
+            REPORT_ERROR(MAJOR, err, ("allocate a new member"));
+            DeleteGroup(p_ReplicGroup);
+            return NULL;
+        }
+    }
+
+    /* Initialize the members linked lists:
+      (hw - the one that is used by the FMan controller and
+       sw - the one that is managed by the driver internally) */
+    for (i=(p_ReplicGroupParam->numOfEntries-1); i>=0; i--)
+    {
+        /* check if this is the last member in the group */
+        if (i == (p_ReplicGroupParam->numOfEntries-1))
+            last = TRUE;
+        else
+            last = FALSE;
+
+        /* Initialize a new member */
+        p_CurrentMember = InitMember(p_ReplicGroup,
+                                     &(p_ReplicGroupParam->nextEngineParams[i]),
+                                     last);
+        if (!p_CurrentMember)
+        {
+            REPORT_ERROR(MAJOR, E_INVALID_HANDLE, ("No available member"));
+            DeleteGroup(p_ReplicGroup);
+            return NULL;
+        }
+
+        /* Build the members group - link two consecutive members in the hw linked list */
+        LinkMemberToMember(p_ReplicGroup, p_CurrentMember, p_NextMember);
+
+        /* update the driver internal members list to be compatible to the hw members linked list */
+        AddMemberToList(p_ReplicGroup, p_CurrentMember, &p_ReplicGroup->membersList);
+
+        p_NextMember = p_CurrentMember;
+    }
+
+    /* initialize the source table descriptor */
+    BuildSourceTd(p_ReplicGroup->p_SourceTd);
+
+    /* link the source table descriptor to point to the first member in the group */
+    LinkSourceToMember(p_ReplicGroup, p_ReplicGroup->p_SourceTd, p_NextMember);
+
+    return p_ReplicGroup;
+}
+
+t_Error FM_PCD_FrmReplicDeleteGroup(t_Handle h_ReplicGroup)
+{
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup *)h_ReplicGroup;
+
+    SANITY_CHECK_RETURN_ERROR(p_ReplicGroup, E_INVALID_HANDLE);
+
+    if (p_ReplicGroup->owners)
+        RETURN_ERROR(MAJOR,
+                     E_INVALID_STATE,
+                     ("the group has owners and can't be deleted"));
+
+    DeleteGroup(p_ReplicGroup);
+
+    return E_OK;
+}
+
+
+/*****************************************************************************/
+/*       API Run-time Frame replicator Control unit functions                */
+/*****************************************************************************/
+t_Error FM_PCD_FrmReplicAddMember(t_Handle                  h_ReplicGroup,
+                                  uint16_t                  memberIndex,
+                                  t_FmPcdCcNextEngineParams *p_MemberParams)
+{
+    t_FmPcdFrmReplicGroup       *p_ReplicGroup = (t_FmPcdFrmReplicGroup*) h_ReplicGroup;
+    t_FmPcdFrmReplicMember      *p_NewMember, *p_CurrentMember = NULL, *p_PreviousMember = NULL;
+    t_Error                     err;
+    uint8_t                     memberPosition;
+
+    SANITY_CHECK_RETURN_ERROR(p_ReplicGroup, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_MemberParams, E_INVALID_HANDLE);
+
+    /* group lock */
+    err = FrmReplicGroupTryLock(p_ReplicGroup);
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("Lock in add operation"));
+
+    if (memberIndex > p_ReplicGroup->numOfEntries)
+    {
+        /* unlock */
+        FrmReplicGroupUnlock(p_ReplicGroup);
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION,
+                     ("memberIndex is greater than the members in the list"));
+    }
+
+    if (memberIndex >= p_ReplicGroup->maxNumOfEntries)
+    {
+        /* unlock */
+        FrmReplicGroupUnlock(p_ReplicGroup);
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("memberIndex is greater than the allowed number of members in the group"));
+    }
+
+    if ((p_ReplicGroup->numOfEntries + 1) > FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES)
+    {
+        /* unlock */
+        FrmReplicGroupUnlock(p_ReplicGroup);
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,
+                     ("numOfEntries with new entry can not be larger than %d\n",
+                      FM_PCD_FRM_REPLIC_MAX_NUM_OF_ENTRIES));
+    }
+
+    err = MemberCheckParams(p_ReplicGroup->h_FmPcd, p_MemberParams);
+    if (err)
+    {
+        /* unlock */
+        FrmReplicGroupUnlock(p_ReplicGroup);
+        RETURN_ERROR(MAJOR, err, ("member check parameters in add operation"));
+    }
+    /* determine the member position in the group */
+    memberPosition = GetMemberPosition(p_ReplicGroup,
+                                       memberIndex,
+                                       TRUE/* add operation */);
+
+    /* Initialize a new member */
+    p_NewMember = InitMember(p_ReplicGroup,
+                             p_MemberParams,
+                             (memberPosition == FRM_REPLIC_LAST_MEMBER_INDEX ? TRUE : FALSE));
+    if (!p_NewMember)
+    {
+        /* unlock */
+        FrmReplicGroupUnlock(p_ReplicGroup);
+        RETURN_ERROR(MAJOR, E_INVALID_HANDLE, ("No available member"));
+    }
+
+    switch (memberPosition)
+    {
+        case FRM_REPLIC_FIRST_MEMBER_INDEX:
+            p_CurrentMember = GetMemberByIndex(p_ReplicGroup, memberIndex);
+            ASSERT_COND(p_CurrentMember);
+
+            LinkMemberToMember(p_ReplicGroup, p_NewMember, p_CurrentMember);
+
+            /* update the internal group source TD */
+            LinkSourceToMember(p_ReplicGroup,
+                               p_ReplicGroup->p_SourceTd,
+                               p_NewMember);
+
+            /* add member to the internal sw member list */
+            AddMemberToList(p_ReplicGroup,
+                            p_NewMember,
+                            &p_ReplicGroup->membersList);
+            break;
+
+        case FRM_REPLIC_MIDDLE_MEMBER_INDEX:
+            p_CurrentMember = GetMemberByIndex(p_ReplicGroup, memberIndex);
+            ASSERT_COND(p_CurrentMember);
+
+            p_PreviousMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex-1));
+            ASSERT_COND(p_PreviousMember);
+
+            LinkMemberToMember(p_ReplicGroup, p_NewMember, p_CurrentMember);
+            LinkMemberToMember(p_ReplicGroup, p_PreviousMember, p_NewMember);
+
+            AddMemberToList(p_ReplicGroup, p_NewMember, &p_PreviousMember->node);
+            break;
+
+        case FRM_REPLIC_LAST_MEMBER_INDEX:
+            p_PreviousMember = GetMemberByIndex(p_ReplicGroup, (uint16_t)(memberIndex-1));
+            ASSERT_COND(p_PreviousMember);
+
+            LinkMemberToMember(p_ReplicGroup, p_PreviousMember, p_NewMember);
+            FillReplicAdOfTypeResult(p_PreviousMember->p_MemberAd, FALSE/*last*/);
+
+            /* add the new member to the internal sw member list */
+            AddMemberToList(p_ReplicGroup, p_NewMember, &p_PreviousMember->node);
+            break;
+
+        default:
+            /* unlock */
+            FrmReplicGroupUnlock(p_ReplicGroup);
+            RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member position in add member"));
+
+    }
+
+    /* unlock */
+    FrmReplicGroupUnlock(p_ReplicGroup);
+
+    return E_OK;
+}
+
+t_Error FM_PCD_FrmReplicRemoveMember(t_Handle   h_ReplicGroup,
+                                     uint16_t   memberIndex)
+{
+    t_FmPcdFrmReplicGroup   *p_ReplicGroup = (t_FmPcdFrmReplicGroup*) h_ReplicGroup;
+    t_Error                 err;
+
+    SANITY_CHECK_RETURN_ERROR(p_ReplicGroup, E_INVALID_HANDLE);
+
+    if (memberIndex >= p_ReplicGroup->numOfEntries)
+        RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member index to remove"));
+
+    /* Design decision: group must contain at least one member
+       No possibility to remove the last member from the group */
+    if (p_ReplicGroup->numOfEntries == 1)
+        RETURN_ERROR(MAJOR, E_CONFLICT, ("Can't remove the last member. At least one member should be related to a group."));
+
+    /* lock */
+    err = FrmReplicGroupTryLock(p_ReplicGroup);
+    if (err)
+        RETURN_ERROR(MAJOR, err, ("Lock in remove member operation"));
+
+    err = RemoveMember(p_ReplicGroup, memberIndex);
+    if (err)
+    {
+        /* unlock */
+        FrmReplicGroupUnlock(p_ReplicGroup);
+        RETURN_ERROR(MAJOR, err, ("Unlock in remove member operation"));
+    }
+
+    /* unlock */
+    FrmReplicGroupUnlock(p_ReplicGroup);
+
+    return E_OK;
+}
+
+/*********************** End of API routines ************************/
+
+
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h
new file mode 100644
index 0000000..3cfd67e
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/Pcd/fm_replic.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2008-2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+/******************************************************************************
+ @File          fm_replic.h
+
+ @Description   FM frame replicator
+*//***************************************************************************/
+#ifndef __FM_REPLIC_H
+#define __FM_REPLIC_H
+
+#include "std_ext.h"
+#include "error_ext.h"
+
+
+#define FRM_REPLIC_SOURCE_TD_OPCODE           0x75
+#define NEXT_FRM_REPLIC_ADDR_SHIFT            4
+#define NEXT_FRM_REPLIC_MEMBER_INDEX_SHIFT    16
+#define FRM_REPLIC_FR_BIT                     0x08000000
+#define FRM_REPLIC_NL_BIT                     0x10000000
+#define FRM_REPLIC_INVALID_MEMBER_INDEX       0xffff
+#define FRM_REPLIC_FIRST_MEMBER_INDEX         0
+
+#define FRM_REPLIC_MIDDLE_MEMBER_INDEX        1
+#define FRM_REPLIC_LAST_MEMBER_INDEX          2
+
+#define SOURCE_TD_ITSELF_OPTION               0x01
+#define SOURCE_TD_COPY_OPTION                 0x02
+#define SOURCE_TD_ITSELF_AND_COPY_OPTION      SOURCE_TD_ITSELF_OPTION | SOURCE_TD_COPY_OPTION
+#define SOURCE_TD_NONE                        0x04
+
+/*typedef enum e_SourceTdOption
+{
+    e_SOURCE_TD_NONE = 0,
+    e_SOURCE_TD_ITSELF_OPTION = 1,
+    e_SOURCE_TD_COPY_OPTION = 2,
+    e_SOURCE_TD_ITSELF_AND_COPY_OPTION = e_SOURCE_TD_ITSELF_OPTION | e_SOURCE_TD_COPY_OPTION
+} e_SourceTdOption;
+*/
+
+typedef _Packed struct
+{
+    volatile uint32_t type;
+    volatile uint32_t frGroupPointer;
+    volatile uint32_t operationCode;
+    volatile uint32_t reserved;
+} _PackedType t_FrmReplicGroupSourceAd;
+
+typedef struct t_FmPcdFrmReplicMember
+{
+    void                        *p_MemberAd;    /**< pointer to the member AD */
+    void                        *p_StatisticsAd;/**< pointer to the statistics AD of the member */
+    t_Handle                    h_Manip;        /**< manip handle - need for free routines */
+    t_List                      node;
+} t_FmPcdFrmReplicMember;
+
+typedef struct t_FmPcdFrmReplicGroup
+{
+    t_Handle                    h_FmPcd;
+#ifdef UNDER_CONSTRUCTION_STATISTICS_SUPPORT
+    e_FmPcdCcStatsMode          statisticsMode;
+#endif /* UNDER_CONSTRUCTION_STATISTICS_SUPPORT */
+
+    uint8_t                     maxNumOfEntries;/**< maximal number of members in the group */
+    uint8_t                     numOfEntries;   /**< actual number of members in the group */
+    uint16_t                    owners;         /**< how many keys share this frame replicator group */
+    void                        *p_SourceTd;     /**< pointer to the frame replicator source table descriptor */
+    t_List                      membersList;    /**< the members list - should reflect the order of the members as in the hw linked list*/
+    t_List                      availableMembersList;/**< list of all the available members in the group */
+    t_FmPcdLock                 *p_Lock;
+} t_FmPcdFrmReplicGroup;
+
+
+#endif /* __FM_REPLIC_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
index 6946409..8099565 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/Peripherals/FM/fm.c
@@ -4204,7 +4204,9 @@ t_Error FM_Init(t_Handle h_Fm)
     if (p_FmDriverParam->resetOnInit)
     {
         t_FMIramRegs    *p_Iram = (t_FMIramRegs *)UINT_TO_PTR(p_Fm->baseAddr + FM_MM_IMEM);
+#if (DPAA_VERSION == 10)
         uint32_t        debug_reg;
+#endif
 
         /* write to IRAM first location the debug instruction */
         WRITE_UINT32(p_Iram->iadd, 0);
@@ -4223,10 +4225,15 @@ t_Error FM_Init(t_Handle h_Fm)
         WRITE_UINT32(p_Fm->p_FmFpmRegs->fm_rstc, FPM_RSTC_FM_RESET);
         XX_UDelay(100);
 
+/* FIXME: Temporary workaround, since this is not currently working on hw or simulator
+ *        This FMan debug register might be in another location or absent
+ *        This register access is just a verification and is not mandatory */
+#if (DPAA_VERSION == 10)
         /* verify breakpoint debug status register */
         debug_reg = GET_UINT32(*(uint32_t *)UINT_TO_PTR(p_Fm->baseAddr + FM_DEBUG_STATUS_REGISTER_OFFSET));
         if(!debug_reg)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Invalid debug status register value = 0"));
+#endif
 
         /*************************************/
         /* Load FMan-Controller code to Iram */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h
new file mode 100644
index 0000000..519df46
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/dpaa_integration_ext.h
@@ -0,0 +1,272 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+
+ @File          dpaa_integration_ext.h
+
+ @Description   T4240 FM external definitions and structures.
+*//***************************************************************************/
+#ifndef __DPAA_INTEGRATION_EXT_H
+#define __DPAA_INTEGRATION_EXT_H
+
+#include "std_ext.h"
+
+
+#define DPAA_VERSION    11
+
+/**************************************************************************//**
+ @Description   DPAA SW Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_SWPORTAL0 = 0,
+    e_DPAA_SWPORTAL1,
+    e_DPAA_SWPORTAL2,
+    e_DPAA_SWPORTAL3,
+    e_DPAA_SWPORTAL4,
+    e_DPAA_SWPORTAL5,
+    e_DPAA_SWPORTAL6,
+    e_DPAA_SWPORTAL7,
+    e_DPAA_SWPORTAL8,
+    e_DPAA_SWPORTAL9,
+    e_DPAA_SWPORTAL10,
+    e_DPAA_SWPORTAL11,
+    e_DPAA_SWPORTAL12,
+    e_DPAA_SWPORTAL13,
+    e_DPAA_SWPORTAL14,
+    e_DPAA_SWPORTAL15,
+    e_DPAA_SWPORTAL16,
+    e_DPAA_SWPORTAL17,
+    e_DPAA_SWPORTAL18,
+    e_DPAA_SWPORTAL19,
+    e_DPAA_SWPORTAL20,
+    e_DPAA_SWPORTAL21,
+    e_DPAA_SWPORTAL22,
+    e_DPAA_SWPORTAL23,
+    e_DPAA_SWPORTAL24,
+    e_DPAA_SWPORTAL_DUMMY_LAST
+} e_DpaaSwPortal;
+
+/**************************************************************************//**
+ @Description   DPAA Direct Connect Portals Enumeration.
+*//***************************************************************************/
+typedef enum
+{
+    e_DPAA_DCPORTAL0 = 0,
+    e_DPAA_DCPORTAL1,
+    e_DPAA_DCPORTAL2,
+    e_DPAA_DCPORTAL_DUMMY_LAST
+} e_DpaaDcPortal;
+
+#define DPAA_MAX_NUM_OF_SW_PORTALS      e_DPAA_SWPORTAL_DUMMY_LAST
+#define DPAA_MAX_NUM_OF_DC_PORTALS      e_DPAA_DCPORTAL_DUMMY_LAST
+
+/*****************************************************************************
+ QMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define QM_MAX_NUM_OF_POOL_CHANNELS     15      /**< Total number of channels, dedicated and pool */
+#define QM_MAX_NUM_OF_WQ                8       /**< Number of work queues per channel */
+#define QM_MAX_NUM_OF_CGS               256     /**< Congestion groups number */
+#define QM_MAX_NUM_OF_FQIDS             (16 * MEGABYTE)
+                                                /**< FQIDs range - 24 bits */
+
+/**************************************************************************//**
+ @Description   Work Queue Channel assignments in QMan.
+*//***************************************************************************/
+typedef enum
+{
+    e_QM_FQ_CHANNEL_SWPORTAL0 = 0x0,              /**< Dedicated channels serviced by software portals 0 to 24 */
+    e_QM_FQ_CHANNEL_SWPORTAL1,
+    e_QM_FQ_CHANNEL_SWPORTAL2,
+    e_QM_FQ_CHANNEL_SWPORTAL3,
+    e_QM_FQ_CHANNEL_SWPORTAL4,
+    e_QM_FQ_CHANNEL_SWPORTAL5,
+    e_QM_FQ_CHANNEL_SWPORTAL6,
+    e_QM_FQ_CHANNEL_SWPORTAL7,
+    e_QM_FQ_CHANNEL_SWPORTAL8,
+    e_QM_FQ_CHANNEL_SWPORTAL9,
+    e_QM_FQ_CHANNEL_SWPORTAL10,
+    e_QM_FQ_CHANNEL_SWPORTAL11,
+    e_QM_FQ_CHANNEL_SWPORTAL12,
+    e_QM_FQ_CHANNEL_SWPORTAL13,
+    e_QM_FQ_CHANNEL_SWPORTAL14,
+    e_QM_FQ_CHANNEL_SWPORTAL15,
+    e_QM_FQ_CHANNEL_SWPORTAL16,
+    e_QM_FQ_CHANNEL_SWPORTAL17,
+    e_QM_FQ_CHANNEL_SWPORTAL18,
+    e_QM_FQ_CHANNEL_SWPORTAL19,
+    e_QM_FQ_CHANNEL_SWPORTAL20,
+    e_QM_FQ_CHANNEL_SWPORTAL21,
+    e_QM_FQ_CHANNEL_SWPORTAL22,
+    e_QM_FQ_CHANNEL_SWPORTAL23,
+    e_QM_FQ_CHANNEL_SWPORTAL24,
+
+    e_QM_FQ_CHANNEL_POOL1 = 0x401,               /**< Pool channels that can be serviced by any of the software portals */
+    e_QM_FQ_CHANNEL_POOL2,
+    e_QM_FQ_CHANNEL_POOL3,
+    e_QM_FQ_CHANNEL_POOL4,
+    e_QM_FQ_CHANNEL_POOL5,
+    e_QM_FQ_CHANNEL_POOL6,
+    e_QM_FQ_CHANNEL_POOL7,
+    e_QM_FQ_CHANNEL_POOL8,
+    e_QM_FQ_CHANNEL_POOL9,
+    e_QM_FQ_CHANNEL_POOL10,
+    e_QM_FQ_CHANNEL_POOL11,
+    e_QM_FQ_CHANNEL_POOL12,
+    e_QM_FQ_CHANNEL_POOL13,
+    e_QM_FQ_CHANNEL_POOL14,
+    e_QM_FQ_CHANNEL_POOL15,
+
+    e_QM_FQ_CHANNEL_FMAN0_SP0 = 0x800,           /**< Dedicated channels serviced by Direct Connect Portal 0:
+                                                      connected to FMan 0; assigned in incrementing order to
+                                                      each sub-portal (SP) in the portal */
+    e_QM_FQ_CHANNEL_FMAN0_SP1,
+    e_QM_FQ_CHANNEL_FMAN0_SP2,
+    e_QM_FQ_CHANNEL_FMAN0_SP3,
+    e_QM_FQ_CHANNEL_FMAN0_SP4,
+    e_QM_FQ_CHANNEL_FMAN0_SP5,
+    e_QM_FQ_CHANNEL_FMAN0_SP6,
+    e_QM_FQ_CHANNEL_FMAN0_SP7,
+    e_QM_FQ_CHANNEL_FMAN0_SP8,
+    e_QM_FQ_CHANNEL_FMAN0_SP9,
+    e_QM_FQ_CHANNEL_FMAN0_SP10,
+    e_QM_FQ_CHANNEL_FMAN0_SP11,
+    e_QM_FQ_CHANNEL_FMAN0_SP12,
+    e_QM_FQ_CHANNEL_FMAN0_SP13,
+    e_QM_FQ_CHANNEL_FMAN0_SP14,
+    e_QM_FQ_CHANNEL_FMAN0_SP15,
+
+    e_QM_FQ_CHANNEL_RMAN_SP0 = 0x820,            /**< Dedicated channels serviced by Direct Connect Portal 1: connected to RMan */
+    e_QM_FQ_CHANNEL_RMAN_SP1,
+
+    e_QM_FQ_CHANNEL_CAAM = 0x840                 /**< Dedicated channel serviced by Direct Connect Portal 2:
+                                                      connected to SEC */
+} e_QmFQChannel;
+
+/*****************************************************************************
+ BMan INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define BM_MAX_NUM_OF_POOLS         64          /**< Number of buffers pools */
+
+
+/*****************************************************************************
+ SEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define SEC_NUM_OF_DECOS            3
+#define SEC_ALL_DECOS_MASK          0x00000003
+
+/*****************************************************************************
+ FM INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define INTG_MAX_NUM_OF_FM          2
+
+/* Ports defines */
+#define FM_MAX_NUM_OF_1G_MACS       6
+#define FM_MAX_NUM_OF_10G_MACS      2
+#define FM_MAX_NUM_OF_MACS          (FM_MAX_NUM_OF_1G_MACS + FM_MAX_NUM_OF_10G_MACS)
+#define FM_MAX_NUM_OF_OH_PORTS      6
+
+#define FM_MAX_NUM_OF_1G_RX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_RX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_RX_PORTS      (FM_MAX_NUM_OF_10G_RX_PORTS + FM_MAX_NUM_OF_1G_RX_PORTS)
+
+#define FM_MAX_NUM_OF_1G_TX_PORTS   FM_MAX_NUM_OF_1G_MACS
+#define FM_MAX_NUM_OF_10G_TX_PORTS  FM_MAX_NUM_OF_10G_MACS
+#define FM_MAX_NUM_OF_TX_PORTS      (FM_MAX_NUM_OF_10G_TX_PORTS + FM_MAX_NUM_OF_1G_TX_PORTS)
+
+#define FM_PORT_MAX_NUM_OF_EXT_POOLS            4           /**< Number of external BM pools per Rx port */
+#define FM_PORT_NUM_OF_CONGESTION_GRPS          256         /**< Total number of congestion groups in QM */
+#define FM_MAX_NUM_OF_SUB_PORTALS               16
+#define FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS   0
+
+#define FM_VSP_MAX_NUM_OF_ENTRIES               64
+#define FM_MAX_NUM_OF_PFC_PRIORITIES            8
+
+/* RAMs defines */
+#define FM_MURAM_SIZE                   (384 * KILOBYTE)
+#define FM_IRAM_SIZE                    ( 64 * KILOBYTE)
+
+/* PCD defines */
+#define FM_PCD_PLCR_NUM_ENTRIES         256                 /**< Total number of policer profiles */
+#define FM_PCD_KG_NUM_OF_SCHEMES        32                  /**< Total number of KG schemes */
+#define FM_PCD_MAX_NUM_OF_CLS_PLANS     256                 /**< Number of classification plan entries. */
+
+/* RTC defines */
+#define FM_RTC_NUM_OF_ALARMS            2                   /**< RTC number of alarms */
+#define FM_RTC_NUM_OF_PERIODIC_PULSES   3                   /**< RTC number of periodic pulses */
+#define FM_RTC_NUM_OF_EXT_TRIGGERS      2                   /**< RTC number of external triggers */
+
+/* QMI defines */
+#define QMI_MAX_NUM_OF_TNUMS            64
+#define QMI_DEF_TNUMS_THRESH            48
+
+/* FPM defines */
+#define FM_NUM_OF_FMAN_CTRL_EVENT_REGS  4
+
+/* DMA defines */
+#define DMA_THRESH_MAX_COMMQ            83
+#define DMA_THRESH_MAX_BUF              127
+
+/* BMI defines */
+#define BMI_MAX_NUM_OF_TASKS            128
+#define BMI_MAX_NUM_OF_DMAS             84
+#define BMI_MAX_FIFO_SIZE               (FM_MURAM_SIZE)
+#define PORT_MAX_WEIGHT                 16
+
+#define FM_CHECK_PORT_RESTRICTIONS(__validPorts, __newPortIndx)   TRUE
+
+/* Unique T4240 */
+#define FM_OP_OPEN_DMA_MIN_LIMIT
+#define FM_NO_RESTRICT_ON_ACCESS_RSRC
+#define FM_NO_OP_OBSERVED_POOLS
+#define FM_FRAME_END_PARAMS_FOR_OP
+#define FM_DEQ_PIPELINE_PARAMS_FOR_OP
+#define FM_NO_TOTAL_DMAS
+#define FM_QMI_NO_SINGLE_ECC_EXCEPTION
+//TODO - for simulator only, due to wrong reset values. Remove when fixed,
+//and also search for the places it appears in the source files and remove
+//comments of majorRev<6
+#define FM_NO_GUARANTEED_RESET_VALUES
+
+/* FM erratas */
+//#define FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
+#define FM_BAD_VLAN_DETECT_ERRATA_10GMAC_A010
+
+#define FM_RX_PREAM_4_ERRATA_DTSEC_A001
+#define FM_MAGIC_PACKET_UNRECOGNIZED_ERRATA_DTSEC2              /* No implementation, Out of LLD scope */
+
+
+#define FM_LEN_CHECK_ERRATA_FMAN_SW002
+
+
+#endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_ext.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_ext.h
new file mode 100644
index 0000000..0d62dd1
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/inc/integrations/T4240/part_ext.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+
+ @File          part_ext.h
+
+ @Description   Definitions for the part (integration) module.
+*//***************************************************************************/
+
+#ifndef __PART_EXT_H
+#define __PART_EXT_H
+
+#include "std_ext.h"
+#include "part_integration_ext.h"
+
+#if !(defined(P1023) || \
+      defined(P2041) || \
+      defined(P3041) || \
+      defined(P4080) || \
+      defined(P5020) || \
+      defined(P5040) || \
+      defined(B4860) || \
+      defined(T4240))
+#error "unable to proceed without chip-definition"
+#endif
+
+
+/**************************************************************************//*
+ @Description   Part data structure - must be contained in any integration
+                data structure.
+*//***************************************************************************/
+typedef struct t_Part
+{
+    uintptr_t   (* f_GetModuleBase)(t_Handle h_Part, e_ModuleId moduleId);
+                /**< Returns the address of the module's memory map base. */
+    e_ModuleId  (* f_GetModuleIdByBase)(t_Handle h_Part, uintptr_t baseAddress);
+                /**< Returns the module's ID according to its memory map base. */
+} t_Part;
+
+
+#endif /* __PART_EXT_H */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk b/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
index 347a5da..540db18 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/ncsw_config.mk
@@ -11,6 +11,9 @@ endif
 ifeq ("$(CONFIG_FMAN_P1023)", "y")
 EXTRA_CFLAGS +=-include $(NCSW)/p1023_dflags.h
 endif
+ifdef CONFIG_FMAN_T4240
+EXTRA_CFLAGS +=-include $(NCSW)/t4240_dflags.h
+endif
 
 EXTRA_CFLAGS += -I$(DRV_DPA)/
 EXTRA_CFLAGS += -I$(NCSW)/inc
@@ -24,6 +27,9 @@ endif
 ifeq ("$(CONFIG_FMAN_P1023)", "y")
 EXTRA_CFLAGS += -I$(NCSW)/inc/integrations/P1023
 endif
+ifdef CONFIG_FMAN_T4240
+EXTRA_CFLAGS += -I$(NCSW)/inc/integrations/T4240
+endif
 
 EXTRA_CFLAGS += -I$(NCSW)/src/inc
 EXTRA_CFLAGS += -I$(NCSW)/src/inc/system
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c
index bd5379f..5963836 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/fman_test.c
@@ -1062,7 +1062,9 @@ static int fmt_port_init(
 						fm_port_get_handle(
 							fmt_port->p_rx_port);
 			} else if (of_device_is_compatible(fm_port_node,
-							     "fsl,fman-1g-mac"))
+							"fsl,fman-1g-mac") ||
+				   of_device_is_compatible(fm_port_node,
+							"fsl,fman-memac"))
 				fmt_port->p_mac_dev =
 						(typeof(fmt_port->p_mac_dev))
 						dev_get_drvdata(&of_dev->dev);
@@ -1097,7 +1099,9 @@ static int fmt_port_init(
 						fm_port_get_handle(
 							fmt_port->p_rx_port);
 			} else if (of_device_is_compatible(fm_port_node,
-							    "fsl,fman-10g-mac"))
+							"fsl,fman-10g-mac") ||
+				   of_device_is_compatible(fm_port_node,
+							"fsl,fman-memac"))
 				fmt_port->p_mac_dev =
 						(typeof(fmt_port->p_mac_dev))
 						dev_get_drvdata(&of_dev->dev);
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
index e37bcf5..eb894b9 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_fm.c
@@ -320,11 +320,11 @@ typedef _Packed struct {
     int         i,j;
     uint32_t    fmRev;
 
-    static const uint8_t     phys1GRxPortId[] = {0x8,0x9,0xa,0xb,0xc};
-    static const uint8_t     phys10GRxPortId[] = {0x10};
+    static const uint8_t     phys1GRxPortId[] = {0x8,0x9,0xa,0xb,0xc,0xd,0xe,0xf};
+    static const uint8_t     phys10GRxPortId[] = {0x10,0x11};
     static const uint8_t     physOhPortId[] = {0x1,0x2,0x3,0x4,0x5,0x6,0x7};
-    static const uint8_t     phys1GTxPortId[] = {0x28,0x29,0x2a,0x2b,0x2c};
-    static const uint8_t     phys10GTxPortId[] = {0x30};
+    static const uint8_t     phys1GTxPortId[] = {0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f};
+    static const uint8_t     phys10GTxPortId[] = {0x30,0x31};
 
     fmRev = (uint32_t)(*((volatile uint32_t *)UINT_TO_PTR(p_LnxWrpFmDev->fmBaseAddr+FM_FPM_IP_REV_1_OFFSET)));
     fmRev &= 0xffff;
@@ -892,9 +892,12 @@ static int /*__devinit*/ fm_probe(struct platform_device *of_dev)
     if (InitFmDev(p_LnxWrpFmDev) != E_OK)
         return -EIO;
 
+/* FIXME: ioctl support for FMan v3 features is not ready yet */
+#if (DPAA_VERSION == 10)
     /* IOCTL ABI checking */
     LnxWrpPCDIOCTLEnumChecking();
     LnxWrpPCDIOCTLTypeChecking();
+#endif
 
     Sprint (p_LnxWrpFmDev->name, "%s%d", DEV_FM_NAME, p_LnxWrpFmDev->id);
 
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
index fcac0a7..2686aa2 100644
--- a/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/src/wrapper/lnxwrp_resources.c
@@ -108,8 +108,8 @@ static struct device_node *match_fman_port_to_mac(struct device_node *fm_node,
 	/* for all enet nodes (macs) check which one refers this FMan port. */
 	for_each_child_of_node(fm_node, fm_node_idx) {
 		if (of_device_is_compatible(fm_node_idx, "fsl,fman-1g-mac") ||
-		    of_device_is_compatible(fm_node_idx,
-					    "fsl,fman-10g-mac")) {
+		    of_device_is_compatible(fm_node_idx, "fsl,fman-10g-mac") ||
+		    of_device_is_compatible(fm_node_idx, "fsl,fman-memac")) {
 			struct device_node *fman_port_node_rx = NULL;
 			struct device_node *fman_port_node_tx = NULL;
 			/* RX is first */
diff --git a/drivers/net/ethernet/freescale/dpa/NetCommSw/t4240_dflags.h b/drivers/net/ethernet/freescale/dpa/NetCommSw/t4240_dflags.h
new file mode 100644
index 0000000..435b0d2
--- /dev/null
+++ b/drivers/net/ethernet/freescale/dpa/NetCommSw/t4240_dflags.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __dflags_h
+#define __dflags_h
+
+
+#define NCSW_LINUX
+
+#define T4240
+#define NCSW_PPC_CORE
+
+#define DEBUG_ERRORS        1
+
+#if defined(DEBUG)
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_INFO
+
+#define DEBUG_XX_MALLOC
+#define DEBUG_MEM_LEAKS
+
+#else
+#define DEBUG_GLOBAL_LEVEL  REPORT_LEVEL_WARNING
+#endif /* (DEBUG) */
+
+#define REPORT_EVENTS       1
+#define EVENT_GLOBAL_LEVEL  REPORT_LEVEL_MINOR
+
+#endif /* __dflags_h */
-- 
1.7.9.7

