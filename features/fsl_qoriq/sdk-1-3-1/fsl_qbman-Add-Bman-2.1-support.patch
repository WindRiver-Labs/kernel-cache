From a53a758922626619a3234dd573897b260f15f8d7 Mon Sep 17 00:00:00 2001
From: Hai-Ying Wang <Haiying.Wang@freescale.com>
Date: Wed, 25 Apr 2012 22:14:52 +0000
Subject: [PATCH 004/227] fsl_qbman: Add Bman 2.1 support

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/bman_config.c    |   20 ++++++++++++++++++++
 drivers/staging/fsl_qbman/bman_driver.c    |    9 ++++++++-
 drivers/staging/fsl_qbman/bman_private.h   |    1 +
 drivers/staging/fsl_qbman/bman_test_high.c |    3 ++-
 4 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index d264af0..6f3fa0c 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -210,6 +210,12 @@ static void bm_get_version(struct bman *bm, u16 *id, u8 *major, u8 *minor)
 	*minor = v & 0xff;
 }
 
+static void bm_get_version_2(struct bman *bm, u8 *ip_cfg)
+{
+	u32 v = bm_in(IP_REV_2);
+	*ip_cfg = v & 0xff;
+}
+
 static u32 __generate_thresh(u32 val, int roundup)
 {
 	u32 e = 0;	/* co-efficient, exponent */
@@ -358,6 +364,7 @@ static int __init fsl_bman_init(struct device_node *node)
 	int ret, standby = 0;
 	u16 id;
 	u8 major, minor;
+	u8 ip_cfg;
 
 	ret = of_address_to_resource(node, 0, &res);
 	if (ret) {
@@ -388,6 +395,19 @@ static int __init fsl_bman_init(struct device_node *node)
 	} else if ((major == 2) && (minor == 0)) {
 		bman_ip_rev = BMAN_REV20;
 		bman_pool_max = 8;
+	} else if ((major == 2) && (minor == 1)) {
+		bman_ip_rev = BMAN_REV21;
+		bm_get_version_2(bm, &ip_cfg);
+		switch (ip_cfg) {
+			case 0:
+			case 1:
+				bman_pool_max = 64;
+				break;
+			case 2:
+				bman_pool_max = 32;
+			default:
+				break;
+		}
 	} else {
 		pr_warning("unknown Bman version, default to rev1.0\n");
 	}
diff --git a/drivers/staging/fsl_qbman/bman_driver.c b/drivers/staging/fsl_qbman/bman_driver.c
index 8c7ec84..0f0a635 100644
--- a/drivers/staging/fsl_qbman/bman_driver.c
+++ b/drivers/staging/fsl_qbman/bman_driver.c
@@ -116,7 +116,14 @@ static struct bm_portal_config * __init parse_pcfg(struct device_node *node)
 	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.0")) {
 		bman_ip_rev = BMAN_REV20;
 		bman_pool_max = 8;
-	}
+	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.1-0") ||
+		of_device_is_compatible(node, "fsl,bman-portal-2.1-1")) {
+		bman_ip_rev = BMAN_REV21;
+		bman_pool_max = 64;
+	} else if (of_device_is_compatible(node, "fsl,bman-portal-2.1-2")) {
+		bman_ip_rev = BMAN_REV21;
+		bman_pool_max = 32;
+        }
 
 	ret = of_address_to_resource(node, DPA_PORTAL_CE,
 				&pcfg->addr_phys[DPA_PORTAL_CE]);
diff --git a/drivers/staging/fsl_qbman/bman_private.h b/drivers/staging/fsl_qbman/bman_private.h
index fcccafa..f20f849 100644
--- a/drivers/staging/fsl_qbman/bman_private.h
+++ b/drivers/staging/fsl_qbman/bman_private.h
@@ -35,6 +35,7 @@
 /* Revision info (for errata and feature handling) */
 #define BMAN_REV10 0x0100
 #define BMAN_REV20 0x0200
+#define BMAN_REV21 0x0201
 extern u16 bman_ip_rev; /* 0 if uninitialised, otherwise QMAN_REVx */
 
 /*
diff --git a/drivers/staging/fsl_qbman/bman_test_high.c b/drivers/staging/fsl_qbman/bman_test_high.c
index a9d5cad..d00bc9f 100644
--- a/drivers/staging/fsl_qbman/bman_test_high.c
+++ b/drivers/staging/fsl_qbman/bman_test_high.c
@@ -69,7 +69,8 @@ static void bufs_init(void)
 
 static inline int bufs_cmp(const struct bm_buffer *a, const struct bm_buffer *b)
 {
-	if (bman_ip_rev == BMAN_REV20) {
+	if ((bman_ip_rev == BMAN_REV20) || (bman_ip_rev == BMAN_REV21)) {
+
 		/* On SoCs with Bman revison 2.0, Bman only respects the 40
 		 * LS-bits of buffer addresses, masking off the upper 8-bits on
 		 * release commands. The API provides for 48-bit addresses
-- 
1.7.9.7

