From 3857745660eda3a974bd7b789625347c3f5c124b Mon Sep 17 00:00:00 2001
From: Hai-Ying Wang <Haiying.Wang@freescale.com>
Date: Tue, 4 Dec 2012 04:03:35 +0000
Subject: [PATCH 198/227] fsl_qman: add FQ flow control API

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c |   53 +++++++++++++++++++++++++++++++++
 include/linux/fsl_qman.h              |   19 +++++++++++-
 2 files changed, 71 insertions(+), 1 deletion(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index e5b07b4..b11027a 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -1495,6 +1495,59 @@ out:
 }
 EXPORT_SYMBOL(qman_oos_fq);
 
+int qman_fq_flow_control(struct qman_fq *fq, int xon)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	int ret = 0;
+	u8 res;
+	u8 myverb;
+
+	if ((fq->state == qman_fq_state_oos) ||
+		(fq->state == qman_fq_state_retired) ||
+		(fq->state == qman_fq_state_parked))
+		return -EINVAL;
+
+#ifdef CONFIG_FSL_DPA_CHECKING
+	if (unlikely(fq_isset(fq, QMAN_FQ_FLAG_NO_MODIFY)))
+		return -EINVAL;
+#endif
+	/* Issue a ALTER_FQXON or ALTER_FQXOFF management command */
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+	FQLOCK(fq);
+	if (unlikely((fq_isset(fq, QMAN_FQ_STATE_CHANGING)) ||
+			(fq->state == qman_fq_state_parked) ||
+			(fq->state == qman_fq_state_oos) ||
+			(fq->state == qman_fq_state_retired))) {
+		ret = -EBUSY;
+		goto out;
+	}
+	mcc = qm_mc_start(&p->p);
+	mcc->alterfq.fqid = fq->fqid;
+	mcc->alterfq.count = 0;
+	myverb = xon ? QM_MCC_VERB_ALTER_FQXON : QM_MCC_VERB_ALTER_FQXOFF;
+
+	qm_mc_commit(&p->p, myverb);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == myverb);
+
+	res = mcr->result;
+	if (res != QM_MCR_RESULT_OK) {
+		ret = -EIO;
+		goto out;
+	}
+out:
+	FQUNLOCK(fq);
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+	return ret;
+}
+EXPORT_SYMBOL(qman_fq_flow_control);
+
 int qman_query_fq(struct qman_fq *fq, struct qm_fqd *fqd)
 {
 	struct qm_mc_command *mcc;
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 0ff15c1..4175240 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -626,7 +626,11 @@ struct qm_mcc_queryfq_np {
 struct qm_mcc_alterfq {
 	u8 __reserved1[3];
 	u32 fqid;	/* 24-bit */
-	u8 __reserved2[56];
+	u8 __reserved2;
+	u8 count;	/* number of consecutive FQID */
+	u8 __reserved3[10];
+	u32 context_b;	/* frame queue context b */
+	u8 __reserved4[40];
 } __packed;
 struct qm_mcc_initcgr {
 	u8 __reserved1;
@@ -899,6 +903,8 @@ struct qm_mc_command {
 #define QM_MCC_VERB_ALTER_FE		0x49	/* Force Eligible FQ */
 #define QM_MCC_VERB_ALTER_RETIRE	0x4a	/* Retire FQ */
 #define QM_MCC_VERB_ALTER_OOS		0x4b	/* Take FQ out of service */
+#define QM_MCC_VERB_ALTER_FQXON		0x4d	/* FQ XON */
+#define QM_MCC_VERB_ALTER_FQXOFF	0x4e	/* FQ XOFF */
 #define QM_MCC_VERB_INITCGR		0x50
 #define QM_MCC_VERB_MODIFYCGR		0x51
 #define QM_MCC_VERB_CGRTESTWRITE	0x52
@@ -1925,6 +1931,17 @@ int qman_retire_fq(struct qman_fq *fq, u32 *flags);
 int qman_oos_fq(struct qman_fq *fq);
 
 /**
+ * qman_fq_flow_control - Set the XON/XOFF state of a FQ
+ * @fq: the frame queue object to be set to XON/XOFF state, must not be 'oos',
+ * or 'retired' or 'parked' state
+ * @xon: boolean to set fq in XON or XOFF state
+ *
+ * The frame should be in Tentatively Scheduled state or Truly Schedule sate,
+ * otherwise the IFSI interrupt will be asserted.
+ */
+int qman_fq_flow_control(struct qman_fq *fq, int xon);
+
+/**
  * qman_query_fq - Queries FQD fields (via h/w query command)
  * @fq: the frame queue object to be queried
  * @fqd: storage for the queried FQD fields
-- 
1.7.9.7

