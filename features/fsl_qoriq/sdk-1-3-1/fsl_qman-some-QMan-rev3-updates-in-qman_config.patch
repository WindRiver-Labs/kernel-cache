From d07d2591f6748c0c80a5f6b7ea20aa4e189d894d Mon Sep 17 00:00:00 2001
From: Hai-Ying Wang <Haiying.Wang@freescale.com>
Date: Wed, 5 Dec 2012 10:42:57 +0000
Subject: [PATCH 221/227] fsl_qman: some QMan rev3 updates in qman_config

Update ECIR, ECIR2, SBEI, MBEI, extend sbec_ to 14, add error interrupt IFSI,
IECE etc.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/qman_config.c |  105 +++++++++++++++++++++++++------
 1 file changed, 86 insertions(+), 19 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 7faa050..0fdc9d4 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -64,6 +64,7 @@
 #define REG_ECSR		0x0a00
 #define REG_ECIR		0x0a04
 #define REG_EADR		0x0a08
+#define REG_ECIR2		0x0a0c
 #define REG_EDATA(n)		(0x0a10 + ((n) * 0x04))
 #define REG_SBEC(n)		(0x0a80 + ((n) * 0x04))
 #define REG_MCR			0x0b00
@@ -126,11 +127,13 @@ enum qm_memory {
 #define QM_EIRQ_MBEI	0x02000000	/* Multi-bit ECC Error */
 #define QM_EIRQ_SBEI	0x01000000	/* Single-bit ECC Error */
 #define QM_EIRQ_PEBI	0x00800000	/* PFDR Enqueues Blocked Interrupt */
+#define QM_EIRQ_IFSI	0x00020000	/* Invalid FQ Flow Control State */
 #define QM_EIRQ_ICVI	0x00010000	/* Invalid Command Verb */
 #define QM_EIRQ_IDDI	0x00000800	/* Invalid Dequeue (Direct-connect) */
 #define QM_EIRQ_IDFI	0x00000400	/* Invalid Dequeue FQ */
 #define QM_EIRQ_IDSI	0x00000200	/* Invalid Dequeue Source */
 #define QM_EIRQ_IDQI	0x00000100	/* Invalid Dequeue Queue */
+#define QM_EIRQ_IECE	0x00000010	/* Invalid Enqueue Configuration */
 #define QM_EIRQ_IEOI	0x00000008	/* Invalid Enqueue Overflow */
 #define QM_EIRQ_IESI	0x00000004	/* Invalid Enqueue State */
 #define QM_EIRQ_IECI	0x00000002	/* Invalid Enqueue Channel */
@@ -139,9 +142,10 @@ enum qm_memory {
 /* QMAN_ECIR valid error bit */
 #define PORTAL_ECSR_ERR	(QM_EIRQ_IEQI | QM_EIRQ_IESI | QM_EIRQ_IEOI | \
 				QM_EIRQ_IDQI | QM_EIRQ_IDSI | QM_EIRQ_IDFI | \
-				QM_EIRQ_IDDI | QM_EIRQ_ICVI)
+				QM_EIRQ_IDDI | QM_EIRQ_ICVI | QM_EIRQ_IFSI)
 #define FQID_ECSR_ERR	(QM_EIRQ_IEQI | QM_EIRQ_IECI | QM_EIRQ_IESI | \
-			QM_EIRQ_IEOI | QM_EIRQ_IDQI | QM_EIRQ_IDFI)
+			QM_EIRQ_IEOI | QM_EIRQ_IDQI | QM_EIRQ_IDFI | \
+			QM_EIRQ_IFSI)
 
 union qman_ecir {
 	u32 ecir_raw;
@@ -153,6 +157,15 @@ union qman_ecir {
 	} __packed info;
 };
 
+union qman_ecir2 {
+	u32 ecir2_raw;
+	struct {
+		u32 portal_type:1;
+		u32 __reserved:21;
+		u32 portal_num:10;
+	} __packed info;
+};
+
 union qman_eadr {
 	u32 eadr_raw;
 	struct {
@@ -161,6 +174,12 @@ union qman_eadr {
 		u32 __reserved2:12;
 		u32 eadr:12;
 	} __packed info;
+	struct {
+		u32 __reserved1:3;
+		u32 memid:5;
+		u32 __reserved:8;
+		u32 eadr:16;
+	} __packed info_rev3;
 };
 
 struct qman_hwerr_txt {
@@ -179,10 +198,12 @@ static const struct qman_hwerr_txt qman_hwerr_txts[] = {
 	QMAN_HWE_TXT(SBEI, "Single-bit ECC Error"),
 	QMAN_HWE_TXT(PEBI, "PFDR Enqueues Blocked Interrupt"),
 	QMAN_HWE_TXT(ICVI, "Invalid Command Verb"),
+	QMAN_HWE_TXT(IFSI, "Invalid Flow Control State"),
 	QMAN_HWE_TXT(IDDI, "Invalid Dequeue (Direct-connect)"),
 	QMAN_HWE_TXT(IDFI, "Invalid Dequeue FQ"),
 	QMAN_HWE_TXT(IDSI, "Invalid Dequeue Source"),
 	QMAN_HWE_TXT(IDQI, "Invalid Dequeue Queue"),
+	QMAN_HWE_TXT(IECE, "Invalid Enqueue Configuration"),
 	QMAN_HWE_TXT(IEOI, "Invalid Enqueue Overflow"),
 	QMAN_HWE_TXT(IESI, "Invalid Enqueue State"),
 	QMAN_HWE_TXT(IECI, "Invalid Enqueue Channel"),
@@ -208,6 +229,14 @@ static const struct qman_error_info_mdata error_mdata[] = {
 	QMAN_ERR_MDATA(0x00FF, 240, "CGR memory"),
 	QMAN_ERR_MDATA(0x00FF, 302, "Internal Order Restoration List memory"),
 	QMAN_ERR_MDATA(0x01FF, 256, "SW portal ring memory"),
+	QMAN_ERR_MDATA(0x07FF, 181, "CEETM class queue descriptor memory"),
+	QMAN_ERR_MDATA(0x0FFF, 140, "CEETM extended SFDR memory"),
+	QMAN_ERR_MDATA(0x0FFF, 25, "CEETM logical FQ mapping memory"),
+	QMAN_ERR_MDATA(0x0FFF, 96, "CEETM dequeue context memory"),
+	QMAN_ERR_MDATA(0x07FF, 396, "CEETM ccgr memory"),
+	QMAN_ERR_MDATA(0x00FF, 146, "CEETM CQ channel shaping memory"),
+	QMAN_ERR_MDATA(0x007F, 256, "CEETM CQ channel scheduling memory"),
+	QMAN_ERR_MDATA(0x01FF, 88, "CEETM dequeue statistics memory"),
 };
 #define QMAN_ERR_MDATA_COUNT \
 	(sizeof(error_mdata)/sizeof(struct qman_error_info_mdata))
@@ -726,22 +755,45 @@ static void log_additional_error_info(u32 isr_val, u32 ecsr_val)
 
 	ecir_val.ecir_raw = qm_in(ECIR);
 	/* Is portal info valid */
-	if (ecsr_val & PORTAL_ECSR_ERR) {
-		pr_warning("Qman ErrInt: %s id %d\n",
-			(ecir_val.info.portal_type) ?
-			"DCP" : "SWP", ecir_val.info.portal_num);
-	}
-	if (ecsr_val & FQID_ECSR_ERR) {
-		pr_warning("Qman ErrInt: ecir.fqid 0x%x\n",
-			ecir_val.info.fqid);
-	}
-	if (ecsr_val & (QM_EIRQ_SBEI|QM_EIRQ_MBEI)) {
-		eadr_val.eadr_raw = qm_in(EADR);
-		pr_warning("Qman ErrInt: EADR Memory: %s, 0x%x\n",
-			error_mdata[eadr_val.info.memid].txt,
-			error_mdata[eadr_val.info.memid].addr_mask
-				& eadr_val.info.eadr);
-		log_edata_bits(error_mdata[eadr_val.info.memid].bits);
+	if ((qman_ip_rev & 0xFF00) >= QMAN_REV30) {
+	union qman_ecir2 ecir2_val;
+	ecir2_val.ecir2_raw = qm_in(ECIR2);
+		if (ecsr_val & PORTAL_ECSR_ERR) {
+			pr_warning("Qman ErrInt: %s id %d\n",
+				(ecir2_val.info.portal_type) ?
+				"DCP" : "SWP", ecir2_val.info.portal_num);
+		}
+		if (ecsr_val & (FQID_ECSR_ERR | QM_EIRQ_IECE)) {
+			pr_warning("Qman ErrInt: ecir.fqid 0x%x\n",
+				ecir_val.info.fqid);
+		}
+		if (ecsr_val & (QM_EIRQ_SBEI|QM_EIRQ_MBEI)) {
+			eadr_val.eadr_raw = qm_in(EADR);
+			pr_warning("Qman ErrInt: EADR Memory: %s, 0x%x\n",
+				error_mdata[eadr_val.info_rev3.memid].txt,
+				error_mdata[eadr_val.info_rev3.memid].addr_mask
+					& eadr_val.info_rev3.eadr);
+			log_edata_bits(
+				error_mdata[eadr_val.info_rev3.memid].bits);
+		}
+ 	} else {
+		if (ecsr_val & PORTAL_ECSR_ERR) {
+			pr_warning("Qman ErrInt: %s id %d\n",
+				(ecir_val.info.portal_type) ?
+				"DCP" : "SWP", ecir_val.info.portal_num);
+		}
+		if (ecsr_val & FQID_ECSR_ERR) {
+			pr_warning("Qman ErrInt: ecir.fqid 0x%x\n",
+				ecir_val.info.fqid);
+		}
+		if (ecsr_val & (QM_EIRQ_SBEI|QM_EIRQ_MBEI)) {
+			eadr_val.eadr_raw = qm_in(EADR);
+			pr_warning("Qman ErrInt: EADR Memory: %s, 0x%x\n",
+				error_mdata[eadr_val.info.memid].txt,
+				error_mdata[eadr_val.info.memid].addr_mask
+					& eadr_val.info.eadr);
+			log_edata_bits(error_mdata[eadr_val.info.memid].bits);
+		}
 	}
 }
 
@@ -1097,7 +1149,14 @@ static DEVICE_ATTR(sbec_3, S_IRUSR, show_sbec, NULL);
 static DEVICE_ATTR(sbec_4, S_IRUSR, show_sbec, NULL);
 static DEVICE_ATTR(sbec_5, S_IRUSR, show_sbec, NULL);
 static DEVICE_ATTR(sbec_6, S_IRUSR, show_sbec, NULL);
-
+static DEVICE_ATTR(sbec_7, S_IRUSR, show_sbec, NULL);
+static DEVICE_ATTR(sbec_8, S_IRUSR, show_sbec, NULL);
+static DEVICE_ATTR(sbec_9, S_IRUSR, show_sbec, NULL);
+static DEVICE_ATTR(sbec_10, S_IRUSR, show_sbec, NULL);
+static DEVICE_ATTR(sbec_11, S_IRUSR, show_sbec, NULL);
+static DEVICE_ATTR(sbec_12, S_IRUSR, show_sbec, NULL);
+static DEVICE_ATTR(sbec_13, S_IRUSR, show_sbec, NULL);
+static DEVICE_ATTR(sbec_14, S_IRUSR, show_sbec, NULL);
 
 static struct attribute *qman_dev_attributes[] = {
 	&dev_attr_pfdr_fpc.attr,
@@ -1121,6 +1180,14 @@ static struct attribute *qman_dev_ecr_attributes[] = {
 	&dev_attr_sbec_4.attr,
 	&dev_attr_sbec_5.attr,
 	&dev_attr_sbec_6.attr,
+	&dev_attr_sbec_7.attr,
+	&dev_attr_sbec_8.attr,
+	&dev_attr_sbec_9.attr,
+	&dev_attr_sbec_10.attr,
+	&dev_attr_sbec_11.attr,
+	&dev_attr_sbec_12.attr,
+	&dev_attr_sbec_13.attr,
+	&dev_attr_sbec_14.attr,
 	NULL
 };
 
-- 
1.7.9.7

