From 6ead0f8fca502a1d6573ce17d6ccd86f70059d9f Mon Sep 17 00:00:00 2001
From: Hai-Ying Wang <Haiying.Wang@freescale.com>
Date: Fri, 2 Nov 2012 02:39:02 +0000
Subject: [PATCH 124/227] fsl_qman: Add CEETM support

Customer Edge Egress Traffic Management (CEETM) is the new QMAN feature and
introduced from QMan v3.0. It provides the basic queuing structure - Class Queue
(CQ) which consists of a hardware managed linked list (or queue) of related
frames to replace regular FQ in egress traffic.  It supports the hierarchical
class based scheduling and traffic shaping for sub-portals on specific QMan
Direct Connect Portals (DCPs). CEETM supports up to 8 logical network interfaces
(LNI) that can each be mapped to a DCP sub-portal, and up to 32 channels that
can be configured to deliver frames to any one of the LNI. Each channel contains
a total of 16 CQs to be used in egress traffic.
This patch adds the APIs to support CEETM, allows user to allocate resources
provided by CEETM and configure the shaping and scheduling.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 .../devicetree/bindings/powerpc/fsl/qman-ceetm.txt |   33 +
 arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm0.dtsi   |   43 +
 arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm1.dtsi   |   43 +
 drivers/staging/fsl_qbman/Kconfig                  |   14 +
 drivers/staging/fsl_qbman/dpa_alloc.c              |   81 +
 drivers/staging/fsl_qbman/qman_config.c            |   60 +
 drivers/staging/fsl_qbman/qman_driver.c            |  144 ++
 drivers/staging/fsl_qbman/qman_high.c              | 2110 ++++++++++++++++++++
 drivers/staging/fsl_qbman/qman_private.h           |    9 +
 include/linux/fsl_qman.h                           | 1369 +++++++++++++
 10 files changed, 3906 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/powerpc/fsl/qman-ceetm.txt
 create mode 100644 arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm0.dtsi
 create mode 100644 arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm1.dtsi

diff --git a/Documentation/devicetree/bindings/powerpc/fsl/qman-ceetm.txt b/Documentation/devicetree/bindings/powerpc/fsl/qman-ceetm.txt
new file mode 100644
index 0000000..066c425
--- /dev/null
+++ b/Documentation/devicetree/bindings/powerpc/fsl/qman-ceetm.txt
@@ -0,0 +1,33 @@
+======================================================================
+Freescale Queue Manager CEETM Node
+======================================================================
+
+Customer Edge Egress Traffic Management (CEETM) is the new QMAN feature and
+introduced from QMan v3.0. The CEETM node desribes all the resources to support
+this feature.
+
+Required properties:
+- compatible: must include "fsl,qman-ceetm".
+
+- fsl,ceetm-lfqid-range: 2-cell value <x y>, in which x is the first LFQID and
+  y is the total number of LFQIDs which should not be greater than 0x1000.
+
+- fsl,ceetm-sp-range: 2-cell value <x y>, in which x is the fist sub portal
+  number and y is the total number of sub-portals which should not be greater
+  than 12.
+
+- fsl,ceetm-lni-range: 2-cell value <x y>, in which x is the first LNI number
+  and y is the total number of LNIs which should not be greater than 8.
+
+- fsl,ceetm-channel-range : 2-cell value <x y>, in which x is the first channel
+  number and y is the total number of channels which should no be greater than
+  32.
+
+Example:
+        qman-ceetm@1 {
+                compatible = "fsl,qman-ceetm";
+                fsl,ceetm-lfqid-range = <0xf10000 0x1000>;
+                fsl,ceetm-sp-range = <0 12>;
+                fsl,ceetm-lni-range = <0 8>;
+                fsl,ceetm-channel-range = <0 32>;
+        };
diff --git a/arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm0.dtsi b/arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm0.dtsi
new file mode 100644
index 0000000..9d3cf3e
--- /dev/null
+++ b/arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm0.dtsi
@@ -0,0 +1,43 @@
+/*
+ * QorIQ QMan CEETM stub
+ *
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+&qportals {
+	qman-ceetm@0 {
+		compatible = "fsl,qman-ceetm";
+		fsl,ceetm-lfqid-range = <0xf00000 0x1000>;
+		fsl,ceetm-sp-range = <0 12>;
+		fsl,ceetm-lni-range = <0 8>;
+		fsl,ceetm-channel-range = <0 32>;
+	};
+};
diff --git a/arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm1.dtsi b/arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm1.dtsi
new file mode 100644
index 0000000..4028542
--- /dev/null
+++ b/arch/powerpc/boot/dts/fsl/qoriq-qman-ceetm1.dtsi
@@ -0,0 +1,43 @@
+/*
+ * QorIQ QMan CEETM stub
+ *
+ * Copyright 2012 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+&qportals {
+	qman-ceetm@1 {
+		compatible = "fsl,qman-ceetm";
+		fsl,ceetm-lfqid-range = <0xf10000 0x1000>;
+		fsl,ceetm-sp-range = <0 12>;
+		fsl,ceetm-lni-range = <0 8>;
+		fsl,ceetm-channel-range = <0 32>;
+	};
+};
diff --git a/drivers/staging/fsl_qbman/Kconfig b/drivers/staging/fsl_qbman/Kconfig
index b557bab..6896605 100644
--- a/drivers/staging/fsl_qbman/Kconfig
+++ b/drivers/staging/fsl_qbman/Kconfig
@@ -205,6 +205,20 @@ config FSL_QMAN_FQ_LOOKUP
 	bool
 	default n
 
+config QMAN_CEETM_UPDATE_PERIOD
+	int "Token update period for shaping, in nanoseconds"
+	default 1000
+	 ---help---
+	Traffic shaping works by performing token calculations (using
+	credits) on shaper instances periodically. This update period
+	sets the granularity for how often those token rate credit
+	updates are performed, and thus determines the accuracy and
+	range of traffic rates that can be configured by users. The
+	reference manual recommends a 1 microsecond period as providing
+	a good balance between granularity and range.
+
+	Unless you know what you are doing, leave this value at its default.
+
 endif # FSL_QMAN
 
 endmenu
diff --git a/drivers/staging/fsl_qbman/dpa_alloc.c b/drivers/staging/fsl_qbman/dpa_alloc.c
index d7752de..03a9d28 100644
--- a/drivers/staging/fsl_qbman/dpa_alloc.c
+++ b/drivers/staging/fsl_qbman/dpa_alloc.c
@@ -39,6 +39,10 @@ static DECLARE_DPA_ALLOC(bpalloc); /* BPID allocator */
 static DECLARE_DPA_ALLOC(fqalloc); /* FQID allocator */
 static DECLARE_DPA_ALLOC(qpalloc); /* pool-channel allocator */
 static DECLARE_DPA_ALLOC(cgralloc); /* CGR ID allocator */
+static DECLARE_DPA_ALLOC(ceetm0_challoc); /* CEETM Channel ID allocator */
+static DECLARE_DPA_ALLOC(ceetm0_lfqidalloc); /* CEETM LFQID allocator */
+static DECLARE_DPA_ALLOC(ceetm1_challoc); /* CEETM Channel ID allocator */
+static DECLARE_DPA_ALLOC(ceetm1_lfqidalloc); /* CEETM LFQID allocator */
 
 /* This is a sort-of-conditional dpa_alloc_free() routine. Eg. when releasing
  * FQIDs (probably from user-space), it can filter out those that aren't in the
@@ -205,6 +209,83 @@ void qman_release_cgrid_range(u32 cgrid, u32 count)
 }
 EXPORT_SYMBOL(qman_release_cgrid_range);
 
+/* CEETM CHANNEL ID allocator front-end */
+int qman_alloc_ceetm0_channel_range(u32 *result, u32 count, u32 align,
+								 int partial)
+{
+	return dpa_alloc_new(&ceetm0_challoc, result, count, align, partial);
+}
+EXPORT_SYMBOL(qman_alloc_ceetm0_channel_range);
+
+int qman_alloc_ceetm1_channel_range(u32 *result, u32 count, u32 align,
+								 int partial)
+{
+	return dpa_alloc_new(&ceetm1_challoc, result, count, align, partial);
+}
+EXPORT_SYMBOL(qman_alloc_ceetm1_channel_range);
+
+void qman_release_ceetm0_channel_range(u32 channelid, u32 count)
+{
+	u32 total_invalid;
+
+	total_invalid = release_id_range(&ceetm0_challoc, channelid, count,
+									 NULL);
+	if (total_invalid)
+		pr_err("CEETM channel range [%d..%d] (%d) had %d leaks\n",
+			channelid, channelid + count - 1, count, total_invalid);
+}
+EXPORT_SYMBOL(qman_release_ceetm0_channel_range);
+
+void qman_release_ceetm1_channel_range(u32 channelid, u32 count)
+{
+	u32 total_invalid;
+	total_invalid = release_id_range(&ceetm1_challoc, channelid, count,
+									 NULL);
+	if (total_invalid)
+		pr_err("CEETM channel range [%d..%d] (%d) had %d leaks\n",
+			channelid, channelid + count - 1, count, total_invalid);
+}
+EXPORT_SYMBOL(qman_release_ceetm1_channel_range);
+
+/* CEETM LFQID allocator front-end */
+int qman_alloc_ceetm0_lfqid_range(u32 *result, u32 count, u32 align,
+								 int partial)
+{
+	return dpa_alloc_new(&ceetm0_lfqidalloc, result, count, align, partial);
+}
+EXPORT_SYMBOL(qman_alloc_ceetm0_lfqid_range);
+
+int qman_alloc_ceetm1_lfqid_range(u32 *result, u32 count, u32 align,
+								 int partial)
+{
+	return dpa_alloc_new(&ceetm1_lfqidalloc, result, count, align, partial);
+}
+EXPORT_SYMBOL(qman_alloc_ceetm1_lfqid_range);
+
+void qman_release_ceetm0_lfqid_range(u32 lfqid, u32 count)
+{
+	u32 total_invalid;
+
+	total_invalid = release_id_range(&ceetm0_lfqidalloc, lfqid, count,
+									NULL);
+	if (total_invalid)
+		pr_err("CEETM LFQID range [0x%x..0x%x] (%d) had %d leaks\n",
+			lfqid, lfqid + count - 1, count, total_invalid);
+}
+EXPORT_SYMBOL(qman_release_ceetm0_lfqid_range);
+
+void qman_release_ceetm1_lfqid_range(u32 lfqid, u32 count)
+{
+	u32 total_invalid;
+
+	total_invalid = release_id_range(&ceetm1_lfqidalloc, lfqid, count,
+									NULL);
+	if (total_invalid)
+		pr_err("CEETM LFQID range [0x%x..0x%x] (%d) had %d leaks\n",
+			lfqid, lfqid + count - 1, count, total_invalid);
+}
+EXPORT_SYMBOL(qman_release_ceetm1_lfqid_range);
+
 /* Everything else is the common backend to all the allocators */
 
 /* The allocator is a (possibly-empty) list of these; */
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index a26c6fb..c1ec438 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -86,6 +86,8 @@
 #define REG_REV3_QCSP_LIO_CFG(n)	(0x1000 + ((n) * 0x10))
 #define REG_REV3_QCSP_IO_CFG(n)	(0x1004 + ((n) * 0x10))
 #define REG_REV3_QCSP_DD_CFG(n)	(0x100c + ((n) * 0x10))
+#define REG_CEETM_CFG_IDX      0x900
+#define REG_CEETM_CFG_PRES     0x904
 
 /* Assists for QMAN_MCR */
 #define MCR_INIT_PFDR		0x01000000
@@ -869,6 +871,64 @@ int qman_set_sdest(u16 channel, unsigned int cpu_idx)
 	return 0;
 }
 
+/* CEETM_CFG_PRES register has PRES field which is calculated by:
+ *    PRES = (2^22 / credit update reference period) * QMan clock period
+ *         = (2^22 * 10^9)/ CONFIG_QMAN_CEETM_UPDATE_PERIOD) / qman_clk
+ */
+
+int qman_ceetm_set_prescaler(enum qm_dc_portal portal)
+{
+	u64 temp;
+	u16 pres;
+
+	if (!qman_have_ccsr())
+		return -ENODEV;
+
+	temp = 0x400000 * 100;
+	temp /= CONFIG_QMAN_CEETM_UPDATE_PERIOD;
+	temp *= 10000000;
+	pres = (u16)(temp / qman_clk);
+
+	qm_out(CEETM_CFG_IDX, portal);
+	qm_out(CEETM_CFG_PRES, pres);
+	return 0;
+}
+
+int qman_ceetm_get_prescaler(u16 *pres)
+{
+	if (!qman_have_ccsr())
+		return -ENODEV;
+	*pres = (u16)qm_in(CEETM_CFG_PRES);
+	return 0;
+}
+
+#define DCP_CFG_CEETME_MASK 0xFFFF0000
+#define QM_SP_ENABLE_CEETM(n) (0x80000000 >> (n))
+int qman_sp_enable_ceetm_mode(enum qm_dc_portal portal, u16 sub_portal)
+{
+	u32 dcp_cfg;
+
+	if (!qman_have_ccsr())
+		return -ENODEV;
+
+	dcp_cfg = qm_in(DCP_CFG(portal));
+	dcp_cfg |= QM_SP_ENABLE_CEETM(sub_portal);
+	qm_out(DCP_CFG(portal), dcp_cfg);
+	return 0;
+}
+
+int qman_sp_disable_ceetm_mode(enum qm_dc_portal portal, u16 sub_portal)
+{
+	u32 dcp_cfg;
+
+	if (!qman_have_ccsr())
+		return -ENODEV;
+	dcp_cfg = qm_in(DCP_CFG(portal));
+	dcp_cfg &= ~(QM_SP_ENABLE_CEETM(sub_portal));
+	qm_out(DCP_CFG(portal), dcp_cfg);
+	return 0;
+}
+
 #ifdef CONFIG_SYSFS
 
 #define DRV_NAME	"fsl-qman"
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 78a9c9e..3315902 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -44,6 +44,9 @@ u16 qm_channel_pme = QMAN_CHANNEL_PME;
 EXPORT_SYMBOL(qm_channel_pme);
 u16 qman_portal_max;
 
+u32 qman_clk;
+struct qm_ceetm qman_ceetms[QMAN_CEETM_MAX];
+
 /* size of the fqd region in bytes */
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
 static u32 fqd_size = (PAGE_SIZE << CONFIG_FSL_QMAN_FQD_SZ);
@@ -150,6 +153,132 @@ static __init int fsl_cgrid_range_init(struct device_node *node)
 	return 0;
 }
 
+static __init int fsl_ceetm_init(struct device_node *node)
+{
+	enum qm_dc_portal dcp_portal;
+	struct qm_ceetm_sp *sp;
+	struct qm_ceetm_lni *lni;
+	int ret, i;
+	const u32 *range;
+
+	/* Find LFQID range */
+	range = of_get_property(node, "fsl,ceetm-lfqid-range", &ret);
+	if (!range) {
+		pr_err("No fsl,ceetm-lfqid-range in node %s\n",
+							node->full_name);
+		return -EINVAL;
+	}
+	if (ret != 8) {
+		pr_err("fsl,ceetm-lfqid-range is not a 2-cell range in node"
+					" %s\n", node->full_name);
+		return -EINVAL;
+	}
+
+	dcp_portal = (range[0] & 0x0F0000) >> 16;
+	if (dcp_portal > qm_dc_portal_fman1) {
+		pr_err("The DCP portal %d doesn't support CEETM\n", dcp_portal);
+		return -EINVAL;
+	}
+
+	if (dcp_portal == qm_dc_portal_fman0)
+		qman_release_ceetm0_lfqid_range(range[0], range[1]);
+	if (dcp_portal == qm_dc_portal_fman1)
+		qman_release_ceetm1_lfqid_range(range[0], range[1]);
+	pr_info("Qman: The lfqid allocator of CEETM %d includes range"
+			" 0x%x:0x%x\n", dcp_portal, range[0], range[1]);
+
+	qman_ceetms[dcp_portal].idx = dcp_portal;
+	INIT_LIST_HEAD(&qman_ceetms[dcp_portal].sub_portals);
+	INIT_LIST_HEAD(&qman_ceetms[dcp_portal].lnis);
+
+	/* Find Sub-portal range */
+	range = of_get_property(node, "fsl,ceetm-sp-range", &ret);
+	if (!range) {
+		pr_err("No fsl,ceetm-sp-range in node %s\n", node->full_name);
+		return -EINVAL;
+	}
+	if (ret != 8) {
+		pr_err("fsl,ceetm-sp-range is not a 2-cell range in node %s\n",
+							node->full_name);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < range[1]; i++) {
+		sp = kmalloc(sizeof(*sp), GFP_KERNEL);
+		if (!sp) {
+			pr_err("Can't alloc memory for sub-portal %d\n",
+							range[0] + i);
+			return -ENOMEM;
+		}
+		sp->idx = range[0] + i;
+		sp->dcp_idx = dcp_portal;
+		sp->is_claimed = 0;
+		list_add_tail(&sp->node, &qman_ceetms[dcp_portal].sub_portals);
+		sp++;
+	}
+	pr_info("Qman: Reserve sub-portal %d:%d for CEETM %d\n",
+					range[0], range[1], dcp_portal);
+	qman_ceetms[dcp_portal].sp_range[0] = range[0];
+	qman_ceetms[dcp_portal].sp_range[1] = range[1];
+
+	/* Find LNI range */
+	range = of_get_property(node, "fsl,ceetm-lni-range", &ret);
+	if (!range) {
+		pr_err("No fsl,ceetm-lni-range in node %s\n", node->full_name);
+		return -EINVAL;
+	}
+	if (ret != 8) {
+		pr_err("fsl,ceetm-lni-range is not a 2-cell range in node %s\n",
+							node->full_name);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < range[1]; i++) {
+		lni = kmalloc(sizeof(*lni), GFP_KERNEL);
+		if (!lni) {
+			pr_err("Can't alloc memory for LNI %d\n",
+							range[0] + i);
+			return -ENOMEM;
+		}
+		lni->idx = range[0] + i;
+		lni->dcp_idx = dcp_portal;
+		lni->is_claimed = 0;
+		INIT_LIST_HEAD(&lni->channels);
+		list_add_tail(&lni->node, &qman_ceetms[dcp_portal].lnis);
+		lni++;
+	}
+	pr_info("Qman: Reserve LNI %d:%d for CEETM %d\n",
+					range[0], range[1], dcp_portal);
+	qman_ceetms[dcp_portal].lni_range[0] = range[0];
+	qman_ceetms[dcp_portal].lni_range[1] = range[1];
+
+	/* Find CEETM channel range */
+	range = of_get_property(node, "fsl,ceetm-channel-range", &ret);
+	if (!range) {
+		pr_err("No fsl,ceetm-channel-range in node %s\n",
+							node->full_name);
+		return -EINVAL;
+	}
+	if (ret != 8) {
+		pr_err("fsl,ceetm-channel-range is not a 2-cell range in node"
+						"%s\n", node->full_name);
+		return -EINVAL;
+	}
+
+	if (dcp_portal == qm_dc_portal_fman0)
+		qman_release_ceetm0_channel_range(range[0], range[1]);
+	if (dcp_portal == qm_dc_portal_fman1)
+		qman_release_ceetm1_channel_range(range[0], range[1]);
+	pr_info("Qman: The channel allocator of CEETM %d includes"
+			" range %d:%d\n", dcp_portal, range[0], range[1]);
+
+	/* Set CEETM PRES register */
+	ret = qman_ceetm_set_prescaler(dcp_portal);
+	if (ret)
+		return ret;
+	return 0;
+}
+
 /* Parse a portal node, perform generic mapping duties and return the config. It
  * is not known at this stage for what purpose (or even if) the portal will be
  * used. */
@@ -452,6 +581,7 @@ static __init int qman_init(void)
 	struct qm_portal_config *pcfg;
 	struct qman_portal *p;
 	int cpu, ret;
+	const u32 *clk;
 
 	/* Initialise the Qman (CCSR) device */
 	for_each_compatible_node(dn, NULL, "fsl,qman") {
@@ -459,6 +589,12 @@ static __init int qman_init(void)
 			pr_info("Qman err interrupt handler present\n");
 		else
 			pr_err("Qman CCSR setup failed\n");
+
+		clk = of_get_property(dn, "clock-frequency", NULL);
+		if (!clk)
+			pr_warning("Can't find Qman clock frequency\n");
+		else
+			qman_clk = *clk;
 	}
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
 	/* Setup lookup table for FQ demux */
@@ -466,6 +602,7 @@ static __init int qman_init(void)
 	if (ret)
 		return ret;
 #endif
+
 	/* Parse pool channels into the SDQCR mask. (Must happen before portals
 	 * are initialised.) */
 	for_each_compatible_node(dn, NULL, "fsl,pool-channel-range") {
@@ -579,6 +716,13 @@ static __init int qman_init(void)
 		if (ret)
 			return ret;
 	}
+
+	/* Parse CEETM */
+	for_each_compatible_node(dn, NULL, "fsl,qman-ceetm") {
+		ret = fsl_ceetm_init(dn);
+		if (ret)
+			return ret;
+	}
 	return 0;
 }
 subsys_initcall(qman_init);
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index c2f90ef..e5b07b4 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -2114,3 +2114,2113 @@ put_portal:
 	return ret;
 }
 EXPORT_SYMBOL(qman_delete_cgr);
+
+int qm_get_clock(u64 *clock_hz)
+{
+	if (!qman_clk) {
+		pr_warning("Qman clock speed is unknown\n");
+		return  -EINVAL;
+	}
+	*clock_hz = (u64)qman_clk;
+	return 0;
+}
+EXPORT_SYMBOL(qm_get_clock);
+
+int qm_set_clock(u64 clock_hz)
+{
+	if (qman_clk)
+		return -1;
+	qman_clk = (u32)clock_hz;
+		return 0;
+}
+EXPORT_SYMBOL(qm_set_clock);
+
+/* CEETM management command */
+int qman_ceetm_configure_lfqmt(struct qm_mcc_ceetm_lfqmt_config *opts)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->lfqmt_config = *opts;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_LFQMT_CONFIG);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
+					 QM_CEETM_VERB_LFQMT_CONFIG);
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	res = mcr->result;
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: CONFIGURE LFQMT failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int qman_ceetm_query_lfqmt(int lfqid,
+			struct qm_mcr_ceetm_lfqmt_query *lfqmt_query)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->lfqmt_query.lfqid = lfqid;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_LFQMT_QUERY);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_CEETM_VERB_LFQMT_QUERY);
+	res = mcr->result;
+	if (res == QM_MCR_RESULT_OK)
+		*lfqmt_query = mcr->lfqmt_query;
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: QUERY LFQMT failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int qman_ceetm_configure_cq(struct qm_mcc_ceetm_cq_config *opts)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->cq_config = *opts;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_CQ_CONFIG);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	res = mcr->result;
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_CEETM_VERB_CQ_CONFIG);
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: CONFIGURE CQ failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int qman_ceetm_query_cq(struct qm_ceetm_cq *cq, u32 dcp_idx,
+				struct qm_mcr_ceetm_cq_query *cq_query)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->cq_query.cqid = cq->idx;
+	mcc->cq_query.dcpid = cq->parent->dcp_idx;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_CQ_QUERY);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	res = mcr->result;
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_CEETM_VERB_CQ_QUERY);
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: QUERY CQ failed\n");
+		return -EIO;
+	}
+
+	*cq_query = mcr->cq_query;
+	return 0;
+}
+
+int qman_ceetm_configure_dct(struct qm_mcc_ceetm_dct_config *opts)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->dct_config = *opts;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_DCT_CONFIG);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_CEETM_VERB_DCT_CONFIG);
+	res = mcr->result;
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: CONFIGURE DCT failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int qman_ceetm_query_dct(struct qm_mcc_ceetm_dct_query *opts,
+			 struct qm_mcr_ceetm_dct_query *dct_query)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p = get_affine_portal();
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->dct_query = *opts;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_DCT_QUERY);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_CEETM_VERB_DCT_QUERY);
+	res = mcr->result;
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: QUERY DCT failed\n");
+		return -EIO;
+	}
+
+	*dct_query = mcr->dct_query;
+	return 0;
+}
+
+int qman_ceetm_configure_class_scheduler(
+			struct qm_mcc_ceetm_class_scheduler_config *opts)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->csch_config = *opts;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_CLASS_SCHEDULER_CONFIG);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
+					QM_CEETM_VERB_CLASS_SCHEDULER_CONFIG);
+	res = mcr->result;
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: CONFIGURE CLASS SCHEDULER failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int qman_ceetm_query_class_scheduler(struct qm_ceetm_channel *channel,
+			struct qm_mcr_ceetm_class_scheduler_query *query)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->csch_query.cqcid = channel->idx;
+	mcc->csch_query.dcpid = channel->dcp_idx;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_CLASS_SCHEDULER_QUERY);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
+				QM_CEETM_VERB_CLASS_SCHEDULER_QUERY);
+	res = mcr->result;
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: QUERY CLASS SCHEDULER failed\n");
+		return -EIO;
+	}
+	*query = mcr->csch_query;
+	return 0;
+}
+
+int qman_ceetm_configure_mapping_shaper_tcfc(
+		struct qm_mcc_ceetm_mapping_shaper_tcfc_config *opts)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->mst_config = *opts;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_MAPPING_SHAPER_TCFC_CONFIG);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
+				QM_CEETM_VERB_MAPPING_SHAPER_TCFC_CONFIG);
+	res = mcr->result;
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: CONFIGURE CHANNEL MAPPING failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int qman_ceetm_query_mapping_shaper_tcfc(
+		struct qm_mcc_ceetm_mapping_shaper_tcfc_query *opts,
+		struct qm_mcr_ceetm_mapping_shaper_tcfc_query *response)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->mst_query = *opts;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_MAPPING_SHAPER_TCFC_QUERY);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
+				QM_CEETM_VERB_MAPPING_SHAPER_TCFC_QUERY);
+	res = mcr->result;
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: QUERY CHANNEL MAPPING failed\n");
+		return -EIO;
+	}
+
+	*response = mcr->mst_query;
+	return 0;
+}
+
+int qman_ceetm_configure_ccgr(struct qm_mcc_ceetm_ccgr_config *opts)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->ccgr_config = *opts;
+
+	qm_mc_commit(&p->p, QM_CEETM_VERB_CCGR_CONFIG);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_CEETM_VERB_CCGR_CONFIG);
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	res = mcr->result;
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: CONFIGURE CCGR failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int qman_ceetm_query_ccgr(struct qm_mcc_ceetm_ccgr_query *ccgr_query,
+				struct qm_mcr_ceetm_ccgr_query *response)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->ccgr_query = *ccgr_query;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_CCGR_QUERY);
+
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) == QM_CEETM_VERB_CCGR_QUERY);
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	res = mcr->result;
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: QUERY CCGR failed\n");
+		return -EIO;
+	}
+	*response = mcr->ccgr_query;
+	return 0;
+}
+
+int qman_ceetm_cq_peek_pop_xsfdrread(struct qm_ceetm_cq *cq,
+			u8 command_type, u16 xsfdr,
+			struct qm_mcr_ceetm_cq_peek_pop_xsfdrread *cq_ppxr)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	switch (command_type) {
+	case 0:
+	case 1:
+		mcc->cq_ppxr.cqid = cq->idx;
+		break;
+	case 2:
+		mcc->cq_ppxr.xsfdr = xsfdr;
+		break;
+	default:
+		break;
+	}
+	mcc->cq_ppxr.ct = command_type;
+	mcc->cq_ppxr.dcpid = cq->parent->dcp_idx;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_CQ_PEEK_POP_XFDRREAD);
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
+				QM_CEETM_VERB_CQ_PEEK_POP_XFDRREAD);
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	res = mcr->result;
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: CQ PEEK/POP/XSFDR READ failed\n");
+		return -EIO;
+	}
+	*cq_ppxr = mcr->cq_ppxr;
+	return 0;
+}
+
+int qman_ceetm_query_statistics(u16 cid,
+			enum qm_dc_portal dcp_idx,
+			u16 command_type,
+			struct qm_mcr_ceetm_statistics_query *query_result)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->stats_query_write.cid = cid;
+	mcc->stats_query_write.dcpid = dcp_idx;
+	mcc->stats_query_write.ct = command_type;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_STATISTICS_QUERY_WRITE);
+
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
+					 QM_CEETM_VERB_STATISTICS_QUERY_WRITE);
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	res = mcr->result;
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: STATISTICS QUERY failed\n");
+		return -EIO;
+	}
+	*query_result = mcr->stats_query;
+	return 0;
+}
+
+int qman_ceetm_write_statistics(u16 cid, enum qm_dc_portal dcp_idx,
+			u16 command_type, u64 frame_count, u64 byte_count)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	mcc->stats_query_write.cid = cid;
+	mcc->stats_query_write.dcpid = dcp_idx;
+	mcc->stats_query_write.ct = command_type;
+	mcc->stats_query_write.frm_cnt = frame_count;
+	mcc->stats_query_write.byte_cnt = byte_count;
+	qm_mc_commit(&p->p, QM_CEETM_VERB_STATISTICS_QUERY_WRITE);
+
+	while (!(mcr = qm_mc_result(&p->p)))
+		cpu_relax();
+	DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
+					 QM_CEETM_VERB_STATISTICS_QUERY_WRITE);
+
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+
+	res = mcr->result;
+	if (res != QM_MCR_RESULT_OK) {
+		pr_err("CEETM: STATISTICS WRITE failed\n");
+		return -EIO;
+	}
+	return 0;
+}
+
+int qman_ceetm_bps2tokenrate(u32 bps, struct qm_ceetm_rate *token_rate,
+							int rounding)
+{
+	u16 pres;
+	u64 temp;
+	u64 qman_freq;
+	int ret;
+
+	/* Read PRES from CEET_CFG_PRES register */
+	ret = qman_ceetm_get_prescaler(&pres);
+	if (ret)
+		return -EINVAL;
+
+	ret = qm_get_clock(&qman_freq);
+	if (ret)
+		return -EINVAL;
+
+	/* token-rate = bytes-per-second * update-reference-period
+	 *
+	 * Where token-rate is N/8192 for a interger N, and
+	 * update-reference-period is (2^22)/(PRES*QHz), where PRES
+	 * is the prescalar value and QHz is the QMan clock frequency.
+	 * So:
+	 *
+	 * token-rate = (byte-per-second*2^22)/PRES*QHZ)
+	 *
+	 * Converting to bits-per-second gives;
+	 *
+	 *	token-rate = (bps*2^19) / (PRES*QHZ)
+	 *	N = (bps*2^32) / (PRES*QHz)
+	 *
+	 */
+	temp = ROUNDING(((u64)bps << 32), pres, rounding);
+	temp = ROUNDING(temp, qman_freq, rounding);
+	token_rate->whole = temp >> 13;
+	token_rate->fraction = temp & (((u64)1 << 13) - 1);
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_bps2tokenrate);
+
+int qman_ceetm_tokenrate2bps(const struct qm_ceetm_rate *token_rate, u32 *bps,
+							int rounding)
+{
+	u16 pres;
+	u64 temp;
+	u64 qman_freq;
+	int ret;
+
+	/* Read PRES from CEET_CFG_PRES register */
+	ret = qman_ceetm_get_prescaler(&pres);
+	if (ret)
+		return -EINVAL;
+
+	ret = qm_get_clock(&qman_freq);
+	if (ret)
+		return -EINVAL;
+
+	/* bytes-per-second = token-rate / update-reference-period
+	 *
+	 * where "token-rate" is N/8192 for an integer N, and
+	 * "update-reference-period" is (2^22)/(PRES*QHz), where PRES is
+	 * the prescalar value and QHz is the QMan clock frequency. So;
+	 *
+	 * bytes-per-second = (N/8192) / (4194304/PRES*QHz)
+	 *                  = N*PRES*QHz / (4194304*8192)
+	 *                  = N*PRES*QHz / (2^35)
+	 *
+	 * Converting to bits-per-second gives;
+	 *
+	 *             bps = N*PRES*QHZ / (2^32)
+	 *
+	 * Note, the numerator has a maximum width of 72 bits! So to
+	 * avoid 64-bit overflow errors, we calculate PRES*QHZ (maximum
+	 * width 48 bits) divided by 2^9 (reducing to maximum 39 bits), before
+	 * multiplying by N (goes to maximum of 63 bits).
+	 *
+	 *             temp = PRES*QHZ / (2^16)
+	 *             kbps = temp*N / (2^16)
+	 */
+	temp = ROUNDING(qman_freq * pres, (u64)1 << 16 , rounding);
+	temp *= ((token_rate->whole << 13) + token_rate->fraction);
+	*bps = ROUNDING(temp, (u64)(1) << 16, rounding);
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_tokenrate2bps);
+
+int qman_ceetm_sp_claim(struct qm_ceetm_sp **sp, enum qm_dc_portal dcp_idx,
+						unsigned int sp_idx)
+{
+	struct qm_ceetm_sp *p;
+
+	DPA_ASSERT((dcp_id ==  qm_dc_portal_fman0) ||
+			(dcp_idx == qm_dc_portal_fman1));
+
+	if ((sp_idx < qman_ceetms[dcp_idx].sp_range[0]) ||
+		(sp_idx > (qman_ceetms[dcp_idx].sp_range[0] +
+		qman_ceetms[dcp_idx].sp_range[1]))) {
+		pr_err("Sub-portal index doesn't exist\n");
+		return -EINVAL;
+	}
+
+	list_for_each_entry(p, &qman_ceetms[dcp_idx].sub_portals, node) {
+		if ((p->idx == sp_idx) && (p->is_claimed == 0)) {
+			p->is_claimed = 1;
+			*sp = p;
+			return 0;
+		}
+	}
+	pr_err("The sub-portal#%d is not available!\n", sp_idx);
+	return -ENODEV;
+}
+EXPORT_SYMBOL(qman_ceetm_sp_claim);
+
+int qman_ceetm_sp_release(struct qm_ceetm_sp *sp)
+{
+	struct qm_ceetm_sp *p;
+
+	if (sp->lni->is_claimed == 1) {
+		pr_err("The dependency of sub-portal has not been released!\n");
+		return -EBUSY;
+	}
+
+	list_for_each_entry(p, &qman_ceetms[sp->dcp_idx].sub_portals, node) {
+		if (p->idx == sp->idx)
+			p->is_claimed = 0;
+			p->lni = NULL;
+	}
+	/* Disable CEETM mode of this sub-portal */
+	qman_sp_disable_ceetm_mode(sp->idx, sp->dcp_idx);
+
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_sp_release);
+
+int qman_ceetm_lni_claim(struct qm_ceetm_lni **lni, enum qm_dc_portal dcp_idx,
+							unsigned int lni_idx)
+{
+	struct qm_ceetm_lni *p;
+
+	if ((lni_idx < qman_ceetms[dcp_idx].lni_range[0]) ||
+		(lni_idx > (qman_ceetms[dcp_idx].lni_range[0] +
+		qman_ceetms[dcp_idx].lni_range[1]))) {
+		pr_err("The lni index is out of range\n");
+		return -EINVAL;
+	}
+
+	list_for_each_entry(p, &qman_ceetms[dcp_idx].lnis, node) {
+		if ((p->idx == lni_idx) && (p->is_claimed == 0)) {
+			*lni = p;
+			p->is_claimed = 1;
+			return 0;
+		}
+	}
+
+	pr_err("The LNI#%d is not available!\n", lni_idx);
+	return -EINVAL;
+}
+EXPORT_SYMBOL(qman_ceetm_lni_claim);
+
+int qman_ceetm_lni_release(struct qm_ceetm_lni *lni)
+{
+	struct qm_ceetm_lni *p;
+
+	if (!list_empty(&lni->channels)) {
+		pr_err("The LNI dependencies are not released!\n");
+		return -EBUSY;
+	}
+
+	lni->shaper_enable = 0;
+	lni->shaper_couple = 0;
+	lni->cr_token_rate.whole = 0;
+	lni->cr_token_rate.fraction = 0;
+	lni->er_token_rate.whole = 0;
+	lni->er_token_rate.fraction = 0;
+	lni->cr_token_bucket_limit = 0;
+	lni->er_token_bucket_limit = 0;
+	lni->is_claimed = 0;
+	list_for_each_entry(p, &qman_ceetms[lni->dcp_idx].lnis, node) {
+		if (p->idx == lni->idx)
+			p->is_claimed = 0;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_lni_release);
+
+int qman_ceetm_sp_set_lni(struct qm_ceetm_sp *sp, struct qm_ceetm_lni *lni)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+
+	/*if (sp->lni->idx == lni->idx) {
+		pr_err("This SP <-> LNI mapping has been set\n");
+		return -EINVAL;
+	}
+	*/
+	config_opts.cid = CEETM_COMMAND_SP_MAPPING | sp->idx;
+	config_opts.dcpid = sp->dcp_idx;
+	config_opts.sp_mapping.map_lni_id = lni->idx;
+	sp->lni = lni;
+
+	if (qman_ceetm_configure_mapping_shaper_tcfc(&config_opts))
+		return -EINVAL;
+
+	/* Enable CEETM mode for this sub-portal */
+	qman_sp_enable_ceetm_mode(sp->dcp_idx, sp->idx);
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_sp_set_lni);
+
+int qman_ceetm_sp_get_lni(struct qm_ceetm_sp *sp, unsigned int *lni_idx)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+
+	query_opts.cid = CEETM_COMMAND_SP_MAPPING | sp->idx;
+	query_opts.dcpid = sp->dcp_idx;
+	if (qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result)) {
+		pr_err("Can't get SP <-> LNI mapping\n");
+		return -EINVAL;
+	}
+	*lni_idx = query_result.sp_mapping_query.map_lni_id;
+	sp->lni->idx = query_result.sp_mapping_query.map_lni_id;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_sp_get_lni);
+
+int qman_ceetm_lni_enable_shaper(struct qm_ceetm_lni *lni, int coupled)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+
+	if (lni->shaper_enable) {
+		pr_err("The shaper has already been enabled\n");
+		return -EINVAL;
+	}
+
+	lni->shaper_enable = 1;
+	lni->shaper_couple = coupled;
+
+	config_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+	config_opts.dcpid = lni->dcp_idx;
+	config_opts.shaper_config.cpl = (coupled << 7);
+				 /* | oal_value;  TBD - oal_value */
+	config_opts.shaper_config.crtcr = (lni->cr_token_rate.whole << 13) |
+			 lni->cr_token_rate.fraction;
+	config_opts.shaper_config.ertcr = (lni->er_token_rate.whole << 13) |
+			 lni->cr_token_rate.fraction;
+	config_opts.shaper_config.crtbl = lni->cr_token_bucket_limit;
+	config_opts.shaper_config.ertbl = lni->er_token_bucket_limit;
+	return	qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_lni_enable_shaper);
+
+int qman_ceetm_lni_disable_shaper(struct qm_ceetm_lni *lni)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+
+	if (!lni->shaper_enable) {
+		pr_err("The shaper has been disabled\n");
+		return -EINVAL;
+	}
+
+	lni->shaper_enable = 0;
+	lni->shaper_couple = 0;
+
+	config_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+	config_opts.dcpid = lni->dcp_idx;
+	config_opts.shaper_config.cpl = 0; /* | oal_value;  TBD - oal_value */
+	config_opts.shaper_config.crtcr = 0;
+	config_opts.shaper_config.ertcr = 0;
+	config_opts.shaper_config.ertbl = 0;
+	config_opts.shaper_config.crtbl = 0;
+	return	qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_lni_disable_shaper);
+
+int qman_ceetm_lni_set_commit_rate(struct qm_ceetm_lni *lni,
+				const struct qm_ceetm_rate *token_rate,
+				u16 token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+
+	if (!lni->shaper_enable) {
+		pr_err("The LNI#%d is unshaped, cannot set CR rate\n",
+						lni->idx);
+		return -EINVAL;
+	}
+
+	query_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+	query_opts.dcpid = lni->dcp_idx;
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret) {
+		pr_err("Fail to get current LNI shaper setting\n");
+		return -EINVAL;
+	}
+
+	lni->cr_token_rate.whole = token_rate->whole;
+	lni->cr_token_rate.fraction = token_rate->fraction;
+	lni->cr_token_bucket_limit = token_limit;
+	config_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+	config_opts.dcpid = lni->dcp_idx;
+	config_opts.shaper_config.crtcr = (token_rate->whole << 13) |
+				 (token_rate->fraction);
+	config_opts.shaper_config.crtbl = token_limit;
+	config_opts.shaper_config.cpl = query_result.shaper_query.cpl;
+	config_opts.shaper_config.ertcr = query_result.shaper_query.ertcr;
+	config_opts.shaper_config.ertbl = query_result.shaper_query.ertbl;
+	return	qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_lni_set_commit_rate);
+
+int qman_ceetm_lni_get_commit_rate(struct qm_ceetm_lni *lni,
+				struct qm_ceetm_rate *token_rate,
+				u16 *token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+
+	query_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+	query_opts.dcpid = lni->dcp_idx;
+
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret | !query_result.shaper_query.crtcr |
+			 !query_result.shaper_query.crtbl) {
+		pr_err("The LNI CR rate or limit is not set\n");
+		return -EINVAL;
+	}
+	token_rate->whole = query_result.shaper_query.crtcr >> 13;
+	token_rate->fraction = query_result.shaper_query.crtcr & 0x1FFF;
+	*token_limit = query_result.shaper_query.crtbl;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_lni_get_commit_rate);
+
+int qman_ceetm_lni_set_excess_rate(struct qm_ceetm_lni *lni,
+					const struct qm_ceetm_rate *token_rate,
+					u16 token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+
+	if (!lni->shaper_enable) {
+		pr_err("The LIN#%d is unshaped, cannot set ER rate\n",
+								lni->idx);
+		return -EINVAL;
+	}
+
+	query_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+	query_opts.dcpid = lni->dcp_idx;
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret) {
+		pr_err("Fail to get current LNI shaper setting\n");
+		return -EINVAL;
+	}
+
+	lni->er_token_rate.whole = token_rate->whole;
+	lni->er_token_rate.fraction = token_rate->fraction;
+	lni->er_token_bucket_limit = token_limit;
+	config_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+	config_opts.dcpid = lni->dcp_idx;
+	config_opts.shaper_config.ertcr =
+			 (token_rate->whole << 13) | (token_rate->fraction);
+	config_opts.shaper_config.ertbl = token_limit;
+	config_opts.shaper_config.cpl = query_result.shaper_query.cpl;
+	config_opts.shaper_config.crtcr = query_result.shaper_query.crtcr;
+	config_opts.shaper_config.crtbl = query_result.shaper_query.crtbl;
+	return	qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_lni_set_excess_rate);
+
+int qman_ceetm_lni_get_excess_rate(struct qm_ceetm_lni *lni,
+					struct qm_ceetm_rate *token_rate,
+					u16 *token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+
+	query_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+	query_opts.dcpid = lni->dcp_idx;
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret | !query_result.shaper_query.ertcr |
+			 !query_result.shaper_query.ertbl) {
+		pr_err("The LNI ER rate or limit is not set\n");
+		return -EINVAL;
+	}
+	token_rate->whole = query_result.shaper_query.ertcr >> 13;
+	token_rate->fraction = query_result.shaper_query.ertcr & 0x1FFF;
+	*token_limit = query_result.shaper_query.ertbl;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_lni_get_excess_rate);
+
+#define QMAN_CEETM_LNITCFCC_CQ_LEVEL_SHIFT(n) ((15 - n) * 4)
+#define QMAN_CEETM_LNITCFCC_ENABLE 0x8
+int qman_ceetm_lni_set_tcfcc(struct qm_ceetm_lni *lni,
+				unsigned int cq_level,
+				int traffic_class)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	u64 lnitcfcc;
+	int ret;
+
+	if ((cq_level > 15) | (traffic_class > 7)) {
+		pr_err("The CQ or traffic class id is out of range\n");
+		return -EINVAL;
+	}
+
+	query_opts.cid = CEETM_COMMAND_TCFC | lni->idx;
+	query_opts.dcpid = lni->dcp_idx;
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+
+	lnitcfcc = query_result.tcfc_query.lnitcfcc;
+	if (traffic_class == -1) /* disable tcfc for this CQ */
+		lnitcfcc &= ~(1 >> (cq_level * 4));
+	else
+		lnitcfcc |=
+			((QMAN_CEETM_LNITCFCC_ENABLE | traffic_class) & 0xF) <<
+			QMAN_CEETM_LNITCFCC_CQ_LEVEL_SHIFT(cq_level);
+	config_opts.tcfc_config.lnitcfcc = lnitcfcc;
+	config_opts.cid = CEETM_COMMAND_TCFC | lni->idx;
+	config_opts.dcpid = lni->dcp_idx;
+	return qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_lni_set_tcfcc);
+
+#define QMAN_CEETM_LNITCFCC_TC_MASK 0x00000007
+int qman_ceetm_lni_get_tcfcc(struct qm_ceetm_lni *lni, unsigned int cq_level,
+						int *traffic_class)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+	int lnitcfcc;
+
+	if (cq_level > 15) {
+		pr_err("the CQ level is out of range\n");
+		return -EINVAL;
+	}
+
+	query_opts.cid = CEETM_COMMAND_TCFC | lni->idx;
+	query_opts.dcpid = lni->dcp_idx;
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret)
+		return ret;
+	lnitcfcc = query_result.tcfc_query.lnitcfcc >>
+		QMAN_CEETM_LNITCFCC_CQ_LEVEL_SHIFT(cq_level);
+	if ((lnitcfcc & QMAN_CEETM_LNITCFCC_ENABLE) > 1)
+		*traffic_class = lnitcfcc & QMAN_CEETM_LNITCFCC_TC_MASK;
+	else
+		*traffic_class = -1;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_lni_get_tcfcc);
+
+#define QMAN_CEETM_ENABLE_CHANNEL_SHAPER 0x80
+int qman_ceetm_channel_claim(struct qm_ceetm_channel **channel,
+				struct qm_ceetm_lni *lni)
+{
+	struct qm_ceetm_channel *p;
+	u32 channel_idx;
+	int ret = 0;
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+	static u8 map;
+
+	if (lni->dcp_idx == qm_dc_portal_fman0)
+		ret = qman_alloc_ceetm0_channel(&channel_idx);
+	if (lni->dcp_idx == qm_dc_portal_fman1)
+		ret = qman_alloc_ceetm1_channel(&channel_idx);
+	if (ret) {
+		pr_err("The is no channel available for LNI#%d\n", lni->idx);
+		return -ENODEV;
+	}
+
+	p = kmalloc(sizeof(*p), GFP_KERNEL);
+	p->idx = channel_idx;
+	p->dcp_idx = lni->dcp_idx;
+	p->shaper_enable = 0;
+	p->shaper_couple = 0;
+	list_add_tail(&p->node, &lni->channels);
+	INIT_LIST_HEAD(&p->class_queues);
+	INIT_LIST_HEAD(&p->ccgs);
+	config_opts.cid = CEETM_COMMAND_CHANNEL_MAPPING | channel_idx;
+	config_opts.dcpid = lni->dcp_idx;
+	map = (u8)~QMAN_CEETM_ENABLE_CHANNEL_SHAPER;
+	map &= lni->idx;
+	config_opts.channel_mapping.map = map;
+	if (qman_ceetm_configure_mapping_shaper_tcfc(&config_opts)) {
+		pr_err("Can't map channel#%d for LNI#%d\n",
+						channel_idx, lni->idx);
+		return -EINVAL;
+	}
+	*channel = p;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_claim);
+
+int qman_ceetm_channel_release(struct qm_ceetm_channel *channel)
+{
+	if (!list_empty(&channel->class_queues)) {
+		pr_err("CEETM channel#%d has class queue unreleased!\n",
+						channel->idx);
+		return -EBUSY;
+	}
+	if (!list_empty(&channel->ccgs)) {
+		pr_err("CEETM channel#%d has ccg unreleased!\n",
+						channel->idx);
+		return -EBUSY;
+	}
+	if (channel->dcp_idx == qm_dc_portal_fman0)
+		qman_release_ceetm0_channelid(channel->idx);
+	if (channel->dcp_idx == qm_dc_portal_fman1)
+		qman_release_ceetm1_channelid(channel->idx);
+	list_del(&channel->node);
+	kfree(channel);
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_release);
+
+int qman_ceetm_channel_enable_shaper(struct qm_ceetm_channel *channel,
+								int coupled)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+	u8 map;
+
+	if (channel->shaper_enable == 1) {
+		pr_err("This channel shaper has been enabled!\n");
+		return -EINVAL;
+	}
+
+	channel->shaper_enable = 1;
+	channel->shaper_couple = coupled;
+
+	query_opts.cid = (u16)(CEETM_COMMAND_CHANNEL_MAPPING | channel->idx);
+	query_opts.dcpid = (u8)channel->dcp_idx;
+
+	if (qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result)) {
+		pr_err("Can't query channel mapping\n");
+		return -EINVAL;
+	}
+
+	map = query_result.channel_mapping_query.map;
+	map |= QMAN_CEETM_ENABLE_CHANNEL_SHAPER;
+
+	config_opts.cid = CEETM_COMMAND_CHANNEL_MAPPING | channel->idx;
+	config_opts.dcpid = channel->dcp_idx;
+	config_opts.channel_mapping.map = map;
+	if (qman_ceetm_configure_mapping_shaper_tcfc(&config_opts)) {
+		pr_err("Can't enable shaper for channel #%d\n",
+						channel->idx);
+		return -EINVAL;
+	}
+
+	config_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
+	config_opts.shaper_config.cpl = coupled << 7;
+	if (qman_ceetm_configure_mapping_shaper_tcfc(&config_opts)) {
+		pr_err("Can't set coupled for channel #%d\n", channel->idx);
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_enable_shaper);
+
+int qman_ceetm_channel_disable_shaper(struct qm_ceetm_channel *channel)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+	u8 map;
+
+	if (channel->shaper_enable == 0) {
+		pr_err("This channel shaper has been disabled\n");
+		return -EINVAL;
+	}
+
+	query_opts.cid = CEETM_COMMAND_CHANNEL_MAPPING | channel->idx;
+	query_opts.dcpid = channel->dcp_idx;
+
+	if (qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result)) {
+		pr_err("Can't query channel mapping\n");
+		return -EINVAL;
+	}
+
+	map = query_result.channel_mapping_query.map;
+	map &= ~QMAN_CEETM_ENABLE_CHANNEL_SHAPER;
+
+	config_opts.cid = CEETM_COMMAND_CHANNEL_MAPPING | channel->idx;
+	config_opts.dcpid = channel->dcp_idx;
+	config_opts.channel_mapping.map = map;
+	return qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_channel_disable_shaper);
+
+int qman_ceetm_channel_set_commit_rate(struct qm_ceetm_channel *channel,
+				const struct qm_ceetm_rate *token_rate,
+				u16 token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+
+	if (!channel->shaper_enable) {
+		pr_err("This channel is unshaped\n");
+		return -EINVAL;
+	}
+
+	query_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
+	query_opts.dcpid = channel->dcp_idx;
+
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret) {
+		pr_err("Fail to get the current channel shaper setting\n");
+		return -EINVAL;
+	}
+
+	channel->cr_token_rate.whole = token_rate->whole;
+	channel->cr_token_rate.fraction = token_rate->fraction;
+	channel->cr_token_bucket_limit = token_limit;
+	config_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
+	config_opts.dcpid = channel->dcp_idx;
+	config_opts.shaper_config.crtcr = (token_rate->whole << 13) |
+				 (token_rate->fraction);
+	config_opts.shaper_config.crtbl = token_limit;
+	config_opts.shaper_config.cpl = query_result.shaper_query.cpl;
+	config_opts.shaper_config.ertcr = query_result.shaper_query.ertcr;
+	config_opts.shaper_config.ertbl = query_result.shaper_query.ertbl;
+	return	qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_commit_rate);
+
+int qman_ceetm_channel_get_commit_rate(struct qm_ceetm_channel *channel,
+				struct qm_ceetm_rate *token_rate,
+				u16 *token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+
+	query_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
+	query_opts.dcpid = channel->dcp_idx;
+
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret | !query_result.shaper_query.crtcr |
+			 !query_result.shaper_query.crtbl) {
+		pr_err("The channel commit rate or limit is not set\n");
+		return -EINVAL;
+	}
+	token_rate->whole = query_result.shaper_query.crtcr >> 13;
+	token_rate->fraction = query_result.shaper_query.crtcr & 0x1FFF;
+	*token_limit = query_result.shaper_query.crtbl;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_get_commit_rate);
+
+int qman_ceetm_channel_set_excess_rate(struct qm_ceetm_channel *channel,
+					const struct qm_ceetm_rate *token_rate,
+					u16 token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+
+	if (!channel->shaper_enable) {
+		pr_err("This channel is unshaped\n");
+		return -EINVAL;
+	}
+
+	query_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
+	query_opts.dcpid = channel->dcp_idx;
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret) {
+		pr_err("Fail to get the current channel shaper setting\n");
+		return -EINVAL;
+	}
+
+	channel->er_token_rate.whole = token_rate->whole;
+	channel->er_token_rate.fraction = token_rate->fraction;
+	channel->er_token_bucket_limit = token_limit;
+	config_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
+	config_opts.dcpid = channel->dcp_idx;
+	config_opts.shaper_config.ertcr =
+			 (token_rate->whole << 13) | (token_rate->fraction);
+	config_opts.shaper_config.ertbl = token_limit;
+	config_opts.shaper_config.cpl = query_result.shaper_query.cpl;
+	config_opts.shaper_config.crtcr = query_result.shaper_query.crtcr;
+	config_opts.shaper_config.crtbl = query_result.shaper_query.crtbl;
+	return	qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_excess_rate);
+
+int qman_ceetm_channel_get_excess_rate(struct qm_ceetm_channel *channel,
+					struct qm_ceetm_rate *token_rate,
+					u16 *token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+
+	query_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
+	query_opts.dcpid = channel->dcp_idx;
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret | !query_result.shaper_query.ertcr |
+			 !query_result.shaper_query.ertbl) {
+		pr_err("The channel excess rate or limit is not set\n");
+		return -EINVAL;
+	}
+	token_rate->whole = query_result.shaper_query.ertcr >> 13;
+	token_rate->fraction = query_result.shaper_query.ertcr & 0x1FFF;
+	*token_limit = query_result.shaper_query.ertbl;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_get_excess_rate);
+
+int qman_ceetm_channel_set_weight(struct qm_ceetm_channel *channel,
+						u16 token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
+
+	if (channel->shaper_enable) {
+		pr_err("This channel is a shaped one\n");
+		return -EINVAL;
+	}
+
+	channel->cr_token_bucket_limit = token_limit;
+	config_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
+	config_opts.dcpid = channel->dcp_idx;
+	config_opts.shaper_config.crtbl = token_limit;
+	return	qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_weight);
+
+int qman_ceetm_channel_get_weight(struct qm_ceetm_channel *channel,
+					u16 *token_limit)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	int ret;
+
+	query_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
+	query_opts.dcpid = channel->dcp_idx;
+	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+	if (ret | !query_result.shaper_query.crtbl) {
+		pr_err("This unshaped channel's uFQ wight is unavailable\n");
+		return -EINVAL;
+	}
+	*token_limit = query_result.shaper_query.crtbl;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_get_weight);
+
+int qman_ceetm_channel_set_group(struct qm_ceetm_channel *channel, int group_b,
+				unsigned int prio_a, unsigned int prio_b)
+{
+	struct qm_mcc_ceetm_class_scheduler_config config_opts;
+	struct qm_mcr_ceetm_class_scheduler_query query_result;
+	int i;
+
+	if (!prio_a | (prio_a > 7)) {
+		pr_err("The priority of group A is out of range\n");
+		return -EINVAL;
+	}
+	if (!prio_a || (prio_b > 7)) {
+		pr_err("The priority of group B is out of range\n");
+		return -EINVAL;
+	}
+
+	if (qman_ceetm_query_class_scheduler(channel, &query_result)) {
+		pr_err("Can't query channel#%d's scheduler!\n", channel->idx);
+		return -EINVAL;
+	}
+
+	config_opts.cqcid = channel->idx;
+	config_opts.dcpid = channel->dcp_idx;
+	if (!group_b)
+		config_opts.gpc = (u8)((1 << 6) | prio_a);
+	else
+		config_opts.gpc = (u8)((prio_b << 3) | prio_a);
+
+	for (i = 0; i < 8; i++)
+		config_opts.w[i] = query_result.w[i];
+	config_opts.crem = query_result.crem;
+	config_opts.erem = query_result.erem;
+
+	return qman_ceetm_configure_class_scheduler(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_group);
+
+int qman_ceetm_channel_get_group(struct qm_ceetm_channel *channel, int *group_b,
+				unsigned int *prio_a, unsigned int *prio_b)
+{
+	struct qm_mcr_ceetm_class_scheduler_query query_result;
+
+	if (qman_ceetm_query_class_scheduler(channel, &query_result)) {
+		pr_err("Can't query channel#%d's scheduler!\n", channel->idx);
+		return -EINVAL;
+	}
+	*group_b = (query_result.gpc >> 6) & 0x1;
+	*prio_a = query_result.gpc & 0x3;
+	*prio_b = (query_result.gpc >> 3) & 0x3;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_get_group);
+
+#define CQ_ELIGIBILITY_MASK(n)	(1 << (7 - n))
+#define CQ_A_ELIGIBILITY_MASK	(1 << 8)
+#define CQ_B_ELIGIBILITY_MASK	(1 << 9)
+int qman_ceetm_cq_claim(struct qm_ceetm_cq **cq,
+		struct qm_ceetm_channel *channel, unsigned int idx,
+		struct qm_ceetm_ccg *ccg)
+{
+	struct qm_ceetm_cq *p;
+	struct qm_mcc_ceetm_cq_config cq_config;
+	struct qm_mcc_ceetm_class_scheduler_config csch_config;
+	struct qm_mcr_ceetm_class_scheduler_query csch_query_result;
+	int i;
+
+	if (idx > 7) {
+		pr_err("The independent class queue id is out of range\n");
+		return -EINVAL;
+	}
+
+	list_for_each_entry(p, &channel->class_queues, node) {
+		if (p->idx == idx) {
+			pr_err("The CQ#%d has been claimed!\n", idx);
+			return -EINVAL;
+		}
+	}
+
+	p = kmalloc(sizeof(*p), GFP_KERNEL);
+	if (!p) {
+		pr_err("Can't allocate memory for CQ#%d!\n", idx);
+		return -ENOMEM;
+	}
+
+	list_add_tail(&p->node, &channel->class_queues);
+	p->idx = idx;
+	p->is_claimed = 1;
+	p->parent = channel;
+	INIT_LIST_HEAD(&p->bound_lfqids);
+
+	if (ccg) {
+		cq_config.cqid = (channel->idx << 4) | idx;
+		cq_config.dcpid = channel->dcp_idx;
+		cq_config.ccgid = ccg->idx;
+		if (qman_ceetm_configure_cq(&cq_config)) {
+			pr_err("Can't configure the CQ#%d with CCGRID#%d\n",
+						 idx, ccg->idx);
+		return -EINVAL;
+		}
+	}
+
+	if (channel->shaper_enable) {
+		if (qman_ceetm_query_class_scheduler(channel,
+						&csch_query_result)) {
+			pr_err("Can't query channel#%d!\n", channel->idx);
+			return -EINVAL;
+		}
+		csch_config.cqcid = channel->idx;
+		csch_config.dcpid = channel->dcp_idx;
+		csch_config.crem = csch_query_result.crem |
+						CQ_ELIGIBILITY_MASK(idx);
+		csch_config.erem = csch_query_result.erem |
+						CQ_ELIGIBILITY_MASK(idx);
+		csch_config.gpc = csch_query_result.gpc;
+		for (i = 0; i < 8; i++)
+			csch_config.w[i] = csch_query_result.w[i];
+
+		if (qman_ceetm_configure_class_scheduler(&csch_config)) {
+			pr_err("Can't config channel scheduler to set"
+					" eligibility mask for CQ#%d\n", idx);
+			return -EINVAL;
+		}
+	}
+
+	*cq = p;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_cq_claim);
+
+int qman_ceetm_cq_claim_A(struct qm_ceetm_cq **cq,
+		struct qm_ceetm_channel *channel, unsigned int idx,
+		struct qm_ceetm_ccg *ccg)
+{
+	struct qm_ceetm_cq *p;
+	struct qm_mcc_ceetm_cq_config cq_config;
+	struct qm_mcc_ceetm_class_scheduler_config csch_config;
+	struct qm_mcr_ceetm_class_scheduler_query csch_query_result;
+	int i;
+
+	if ((idx < 7) || (idx > 15)) {
+		pr_err("This grouped class queue id is out of range\n");
+		return -EINVAL;
+	}
+	p = kmalloc(sizeof(*p), GFP_KERNEL);
+	if (!p) {
+		pr_err("Can't allocate memory for CQ#%d!\n", idx);
+		return -ENOMEM;
+	}
+
+	list_for_each_entry(p, &channel->class_queues, node) {
+		if (p->idx == idx) {
+			pr_err("The CQ#%d has been claimed!\n", idx);
+			return -EINVAL;
+		}
+	}
+	list_add_tail(&p->node, &channel->class_queues);
+	p->idx = idx;
+	p->is_claimed = 1;
+	p->parent = channel;
+	INIT_LIST_HEAD(&p->bound_lfqids);
+
+	if (ccg) {
+		cq_config.cqid = (channel->idx << 4) | idx;
+		cq_config.dcpid = channel->dcp_idx;
+		cq_config.ccgid = ccg->idx;
+		if (qman_ceetm_configure_cq(&cq_config)) {
+			pr_err("Can't configure the CQ#%d with CCGRID#%d\n",
+						 idx, ccg->idx);
+			return -EINVAL;
+		}
+	}
+
+	if (channel->shaper_enable) {
+		if (qman_ceetm_query_class_scheduler(channel,
+						&csch_query_result)) {
+			pr_err("Can't query channel#%d!\n", channel->idx);
+			return -EINVAL;
+		}
+		csch_config.cqcid = channel->idx;
+		csch_config.dcpid = channel->dcp_idx;
+		csch_config.crem = csch_query_result.crem |
+						CQ_A_ELIGIBILITY_MASK;
+		csch_config.erem = csch_query_result.erem |
+						CQ_A_ELIGIBILITY_MASK;
+		csch_config.gpc = csch_query_result.gpc;
+		for (i = 0; i < 8; i++)
+			csch_config.w[i] = csch_query_result.w[i];
+		if (qman_ceetm_configure_class_scheduler(&csch_config)) {
+			pr_err("Can't config channel scheduler to set"
+					" eligibility mask for CQ#%d\n", idx);
+			return -EINVAL;
+		}
+	}
+	*cq = p;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_cq_claim_A);
+
+int qman_ceetm_cq_claim_B(struct qm_ceetm_cq **cq,
+		struct qm_ceetm_channel *channel, unsigned int idx,
+		struct qm_ceetm_ccg *ccg)
+{
+	struct qm_ceetm_cq *p;
+	struct qm_mcc_ceetm_cq_config cq_config;
+	struct qm_mcc_ceetm_class_scheduler_config csch_config;
+	struct qm_mcr_ceetm_class_scheduler_query csch_query_result;
+	int i;
+
+	if ((idx < 11) || (idx > 15)) {
+		pr_err("This grouped class queue id is out of range\n");
+		return -EINVAL;
+	}
+
+	p = kmalloc(sizeof(*p), GFP_KERNEL);
+	if (!p) {
+		pr_err("Can't allocate memory for CQ#%d!\n", idx);
+		return -ENOMEM;
+	}
+
+	list_for_each_entry(p, &channel->class_queues, node) {
+		if (p->idx == idx) {
+			pr_err("The CQ#%d has been claimed!\n", idx);
+			return -EINVAL;
+		}
+	}
+	list_add_tail(&p->node, &channel->class_queues);
+	p->idx = idx;
+	p->is_claimed = 1;
+	p->parent = channel;
+	INIT_LIST_HEAD(&p->bound_lfqids);
+
+	if (ccg) {
+		cq_config.cqid = (channel->idx << 4) | idx;
+		cq_config.dcpid = channel->dcp_idx;
+		cq_config.ccgid = ccg->idx;
+		if (qman_ceetm_configure_cq(&cq_config)) {
+			pr_err("Can't configure the CQ#%d with CCGRID#%d\n",
+					 idx, ccg->idx);
+		return -EINVAL;
+		}
+	}
+
+	if (channel->shaper_enable) {
+		if (qman_ceetm_query_class_scheduler(channel,
+						&csch_query_result)) {
+			pr_err("Can't query channel#%d!\n", channel->idx);
+			return -EINVAL;
+		}
+		csch_config.cqcid = channel->idx;
+		csch_config.dcpid = channel->dcp_idx;
+		csch_config.crem = csch_query_result.crem |
+							 CQ_B_ELIGIBILITY_MASK;
+		csch_config.erem = csch_query_result.erem |
+							CQ_B_ELIGIBILITY_MASK;
+		csch_config.gpc = csch_query_result.gpc;
+		for (i = 0; i < 8; i++)
+			csch_config.w[i] = csch_query_result.w[i];
+		if (qman_ceetm_configure_class_scheduler(&csch_config)) {
+			pr_err("Can't config channel scheduler to set"
+					" eligibility mask for CQ#%d\n", idx);
+			return -EINVAL;
+		}
+	}
+	*cq = p;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_cq_claim_B);
+
+int qman_ceetm_cq_release(struct qm_ceetm_cq *cq)
+{
+	if (!list_empty(&cq->bound_lfqids)) {
+		pr_err("The CQ#%d has unreleased LFQID\n", cq->idx);
+		return -EBUSY;
+	}
+	list_del(&cq->node);
+	kfree(cq);
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_cq_release);
+
+int qman_ceetm_set_queue_weight(struct qm_ceetm_cq *cq,
+				struct qm_ceetm_weight_code *weight_code)
+{
+	struct qm_mcc_ceetm_class_scheduler_config config_opts;
+	struct qm_mcr_ceetm_class_scheduler_query query_result;
+	int i;
+
+	if (qman_ceetm_query_class_scheduler(cq->parent, &query_result)) {
+		pr_err("Can't query channel#%d's scheduler!\n",
+						cq->parent->idx);
+		return -EINVAL;
+	}
+
+	config_opts.cqcid = cq->parent->idx;
+	config_opts.dcpid = cq->parent->dcp_idx;
+	config_opts.crem = query_result.crem;
+	config_opts.erem = query_result.erem;
+	config_opts.gpc = query_result.gpc;
+	for (i = 0; i < 8; i++)
+		config_opts.w[i] = query_result.w[i];
+	config_opts.w[cq->idx] = (weight_code->y << 3) | weight_code->x;
+	return qman_ceetm_configure_class_scheduler(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_set_queue_weight);
+
+int qman_ceetm_get_queue_weight(struct qm_ceetm_cq *cq,
+				struct qm_ceetm_weight_code *weight_code)
+{
+	struct qm_mcr_ceetm_class_scheduler_query query_result;
+
+	if (qman_ceetm_query_class_scheduler(cq->parent,
+						&query_result)) {
+		pr_err("Can't get the weight code for CQ#%d!\n", cq->idx);
+		return -EINVAL;
+	}
+	weight_code->y = (query_result.w[cq->idx] >> 3) & 0x1F;
+	weight_code->x = query_result.w[cq->idx] & 0x3;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_get_queue_weight);
+
+/* The WBFS code is represent as {x,y}, the effect wieght can be calculated as:
+ *	effective weight = 2^x / (1 - (y/64))
+ *			 = 2^(x+6) / (64 - y)
+ */
+#define QM_WBFS_MAKECODE(x, y) (((y) << 3) | ((x & 0x7)))
+#define QM_WBFS_CODE_X(c) ((c) & 0x7)
+#define QM_WBFS_CODE_Y(c) ((c) >> 3)
+static void reduce_fraction(u32 *n, u32 *d)
+{
+	u32 factor = 2;
+	u32 lesser = (*n < *d) ? *n : *d;
+	/* If factor exceeds the square-root of the lesser of *n and *d,
+	 * then there's no point continuing. Proof: if there was a factor
+	 * bigger than the square root, that would imply there exists
+	 * another factor smaller than the square-root with which it
+	 * multiplies to give 'lesser' - but that's a contradiction
+	 * because the other factor would have already been found and
+	 * divided out.
+	 */
+	while ((factor * factor) <= lesser) {
+		/* If 'factor' is a factor of *n and *d, divide them both
+		 * by 'factor' as many times as possible.
+		 */
+		while (!(*n % factor) && !(*d % factor)) {
+			*n /= factor;
+			*d /= factor;
+			lesser /= factor;
+		}
+		if (factor == 2)
+			factor = 3;
+		else
+			factor += 2;
+	}
+}
+
+int qman_ceetm_wbfs2ratio(unsigned int weight_code,
+				u32 *numerator,
+				u32 *denominator)
+{
+	*numerator = (u32) 1 << (QM_WBFS_CODE_X(weight_code) + 6);
+	*denominator = 64 - QM_WBFS_CODE_Y(weight_code);
+	reduce_fraction(numerator, denominator);
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_wbfs2ratio);
+
+/* For a given x, the weight is between 2^x (inclusive) and 2^(x+1) (exclusive).
+ * So find 'x' by range, and then estimate 'y' using:
+ *		64 - y	= 2^(x + 6) / weight
+ *			= 2^(x + 6) / (n/d)
+ *			= d * 2^(x+6) / n
+ *		y = 64 - (d * 2^(x+6) / n)
+ */
+int qman_ceetm_ratio2wbfs(u32 numerator,
+				u32 denominator,
+				unsigned int *weight_code,
+				int rounding)
+{
+	unsigned int y, x = 0;
+	/* search incrementing 'x' until:
+	 * weight < 2^(x+1)
+	 *    n/d < 2^(x+1)
+	 *	n < d * 2^(x+1)
+	 */
+	while ((x < 8) && (numerator >= (denominator << (x + 1))))
+		x++;
+	if (x >= 8)
+		return -ERANGE;
+	/* because of the subtraction, use '-rounding' */
+	y = 64 - ROUNDING(denominator << (x + 6), numerator, -rounding);
+	if (y >= 32)
+		return -ERANGE;
+	*weight_code = QM_WBFS_MAKECODE(x, y);
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_ratio2wbfs);
+
+int qman_ceetm_cq_get_dequeue_statistics(struct qm_ceetm_cq *cq, u32 flags,
+					u64 *frame_count, u64 *byte_count)
+{
+	struct qm_mcr_ceetm_statistics_query result;
+	u16 cid, command_type;
+	enum qm_dc_portal dcp_idx;
+	int ret;
+
+	cid = (cq->parent->idx << 4) | cq->idx;
+	dcp_idx = cq->parent->dcp_idx;
+	if (flags == QMAN_CEETM_FLAG_CLEAR_STATISTICS_COUNTER)
+		command_type = CEETM_QUERY_DEQUEUE_CLEAR_STATISTICS;
+	else
+		command_type = CEETM_QUERY_DEQUEUE_STATISTICS;
+
+	ret = qman_ceetm_query_statistics(cid, dcp_idx, command_type, &result);
+	if (ret) {
+		pr_err("Can't query the statistics of CQ#%d!\n", cq->idx);
+		return -EINVAL;
+	}
+
+	*frame_count = result.frm_cnt;
+	*byte_count = result.byte_cnt;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_cq_get_dequeue_statistics);
+
+#define CEETM_LFQMT_LFQID_MSB 0xF00000
+#define CEETM_LFQMT_LFQID_LSB 0x000FFF
+int qman_ceetm_lfq_claim(struct qm_ceetm_lfq **lfq,
+					struct qm_ceetm_cq *cq)
+{
+	struct qm_ceetm_lfq *p;
+	u32 lfqid;
+	int ret = 0;
+	struct qm_mcc_ceetm_lfqmt_config lfqmt_config;
+
+	if (cq->parent->dcp_idx == qm_dc_portal_fman0)
+		ret = qman_alloc_ceetm0_lfqid(&lfqid);
+	if (cq->parent->dcp_idx == qm_dc_portal_fman1)
+		ret = qman_alloc_ceetm1_lfqid(&lfqid);
+	if (ret) {
+		pr_err("There is no lfqid avalaible for CQ#%d!\n", cq->idx);
+		return -ENODEV;
+	}
+	p = kmalloc(sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return -ENOMEM;
+	p->idx = lfqid;
+	p->dctidx = (u16)(lfqid & CEETM_LFQMT_LFQID_LSB);
+	p->parent = cq->parent;
+	list_add_tail(&p->node, &cq->bound_lfqids);
+
+	lfqmt_config.lfqid = CEETM_LFQMT_LFQID_MSB |
+				(cq->parent->dcp_idx << 16) |
+				(lfqid & CEETM_LFQMT_LFQID_LSB);
+	lfqmt_config.cqid = (cq->parent->idx << 4) | (cq->idx);
+	lfqmt_config.dctidx = p->dctidx;
+	if (qman_ceetm_configure_lfqmt(&lfqmt_config)) {
+		pr_err("Can't configure LFQMT for LFQID#%d @ CQ#%d\n",
+				lfqid, cq->idx);
+		return -EINVAL;
+	}
+	*lfq = p;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_lfq_claim);
+
+int qman_ceetm_lfq_release(struct qm_ceetm_lfq *lfq)
+{
+	if (lfq->parent->dcp_idx == qm_dc_portal_fman0)
+		qman_release_ceetm0_lfqid(lfq->idx);
+	if (lfq->parent->dcp_idx == qm_dc_portal_fman0)
+		qman_release_ceetm1_lfqid(lfq->idx);
+	list_del(&lfq->node);
+	kfree(lfq);
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_lfq_release);
+
+int qman_ceetm_lfq_set_context(struct qm_ceetm_lfq *lfq, u64 context_a,
+							u32 context_b)
+{
+	struct qm_mcc_ceetm_dct_config dct_config;
+	lfq->context_a = context_a;
+	lfq->context_b = context_b;
+	dct_config.dctidx = (u16)lfq->dctidx;
+	dct_config.dcpid = lfq->parent->dcp_idx;
+	dct_config.context_b = context_b;
+	dct_config.context_a = context_a;
+	return qman_ceetm_configure_dct(&dct_config);
+}
+EXPORT_SYMBOL(qman_ceetm_lfq_set_context);
+
+int qman_ceetm_lfq_get_context(struct qm_ceetm_lfq *lfq, u64 *context_a,
+							u32 *context_b)
+{
+	struct qm_mcc_ceetm_dct_query dct_query;
+	struct qm_mcr_ceetm_dct_query query_result;
+
+	dct_query.dctidx = (u16)lfq->dctidx;
+	dct_query.dcpid = lfq->parent->dcp_idx;
+	if (qman_ceetm_query_dct(&dct_query, &query_result)) {
+		pr_err("Can't query LFQID#%d's context!\n", lfq->idx);
+		return -EINVAL;
+	}
+	*context_a = query_result.context_a;
+	*context_b = query_result.context_b;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_lfq_get_context);
+
+int qman_ceetm_create_fq(struct qm_ceetm_lfq *lfq, struct qman_fq *fq)
+{
+	spin_lock_init(&fq->fqlock);
+	fq->fqid = lfq->idx;
+	fq->flags = QMAN_FQ_FLAG_NO_MODIFY;
+	if (lfq->ern)
+		fq->cb.ern = lfq->ern;
+#ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
+	if (unlikely(find_empty_fq_table_entry(&fq->key, fq)))
+		return -ENOMEM;
+#endif
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_create_fq);
+
+int qman_ceetm_ccg_claim(struct qm_ceetm_ccg **ccg,
+				struct qm_ceetm_channel *channel,
+				unsigned int idx,
+				void (*cscn)(struct qm_ceetm_ccg *,
+					void *cb_ctx,
+					int congested),
+				void *cb_ctx)
+{
+	struct qm_ceetm_ccg *p;
+
+	if ((idx < 0) || (idx > 15)) {
+		pr_err("The given ccg index is out of range\n");
+		return -EINVAL;
+	}
+
+	list_for_each_entry(p, &channel->ccgs, node) {
+		if (p->idx == idx) {
+			pr_err("The CCG#%d has been claimed\n", idx);
+			return -EINVAL;
+		}
+	}
+
+	p = kmalloc(sizeof(*p), GFP_KERNEL);
+	if (!p) {
+		pr_err("Can't allocate memory for CCG#%d!\n", idx);
+		return -ENOMEM;
+	}
+
+	list_add_tail(&p->node, &channel->ccgs);
+
+	p->idx = idx;
+	p->parent = channel;
+	p->cb = cscn;
+	p->cb_ctx = cb_ctx;
+
+	*ccg = p;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_ccg_claim);
+
+int qman_ceetm_ccg_release(struct qm_ceetm_ccg *ccg)
+{
+	list_del(&ccg->node);
+	kfree(ccg);
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_ccg_release);
+
+int qman_ceetm_ccg_set(struct qm_ceetm_ccg *ccg, u16 we_mask,
+				const struct qm_ceetm_ccg_params *params)
+{
+	struct qm_mcc_ceetm_ccgr_config config_opts;
+
+	config_opts.ccgrid = CEETM_CCGR_CM_CONFIGURE |
+				(ccg->parent->idx << 4) | ccg->idx;
+	config_opts.dcpid = ccg->parent->dcp_idx;
+	config_opts.we_mask = we_mask;
+	config_opts.cm_config.ctl = (params->wr_en_g << 6) |
+				(params->wr_en_y << 5) |
+				(params->wr_en_r << 4) |
+				(params->td_en << 3)   |
+				(params->td_mode << 2) |
+				(params->cscn_en << 1) |
+				(params->mode);
+	config_opts.cm_config.oal = params->oal;
+	config_opts.cm_config.cs_thres = params->cs_thres_in;
+	config_opts.cm_config.cs_thres_x = params->cs_thres_out;
+	config_opts.cm_config.td_thres = params->td_thres;
+	config_opts.cm_config.wr_parm_g = params->wr_parm_g;
+	config_opts.cm_config.wr_parm_y = params->wr_parm_y;
+	config_opts.cm_config.wr_parm_r = params->wr_parm_r;
+
+	return qman_ceetm_configure_ccgr(&config_opts);
+}
+EXPORT_SYMBOL(qman_ceetm_ccg_set);
+
+#define CEETM_CCGR_CTL_MASK 0x01
+int qman_ceetm_ccg_get(struct qm_ceetm_ccg *ccg,
+				struct qm_ceetm_ccg_params *params)
+{
+	struct qm_mcc_ceetm_ccgr_query query_opts;
+	struct qm_mcr_ceetm_ccgr_query query_result;
+
+	query_opts.ccgrid = CEETM_CCGR_CM_QUERY |
+				(ccg->parent->idx << 4) | ccg->idx;
+	query_opts.dcpid = ccg->parent->dcp_idx;
+
+	if (qman_ceetm_query_ccgr(&query_opts, &query_result)) {
+		pr_err("Can't query CCGR#%d\n", ccg->idx);
+		return -EINVAL;
+	}
+
+	params->wr_parm_r = query_result.cm_query.wr_parm_r;
+	params->wr_parm_y = query_result.cm_query.wr_parm_y;
+	params->wr_parm_g = query_result.cm_query.wr_parm_g;
+	params->td_thres = query_result.cm_query.td_thres;
+	params->cs_thres_out = query_result.cm_query.cs_thres_x;
+	params->cs_thres_in = query_result.cm_query.cs_thres;
+	params->oal = query_result.cm_query.oal;
+	params->wr_en_g = (query_result.cm_query.ctl >> 6) &
+					 CEETM_CCGR_CTL_MASK;
+	params->wr_en_y = (query_result.cm_query.ctl >> 5) &
+					 CEETM_CCGR_CTL_MASK;
+	params->wr_en_r = (query_result.cm_query.ctl >> 4) &
+					 CEETM_CCGR_CTL_MASK;
+	params->td_en = (query_result.cm_query.ctl >> 3) &
+					 CEETM_CCGR_CTL_MASK;
+	params->td_mode = (query_result.cm_query.ctl >> 2) &
+					 CEETM_CCGR_CTL_MASK;
+	params->cscn_en = (query_result.cm_query.ctl >> 1) &
+					 CEETM_CCGR_CTL_MASK;
+	params->mode = (query_result.cm_query.ctl & CEETM_CCGR_CTL_MASK);
+
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_ccg_get);
+
+int qman_ceetm_ccg_get_reject_statistics(struct qm_ceetm_ccg *ccg, u32 flags,
+					u64 *frame_count, u64 *byte_count)
+{
+	struct qm_mcr_ceetm_statistics_query result;
+	u16 cid, command_type;
+	enum qm_dc_portal dcp_idx;
+	int ret;
+
+	cid = (ccg->parent->idx << 4) | ccg->idx;
+	dcp_idx = ccg->parent->dcp_idx;
+	if (flags == QMAN_CEETM_FLAG_CLEAR_STATISTICS_COUNTER)
+		command_type = CEETM_QUERY_REJECT_CLEAR_STATISTICS;
+	else
+		command_type = CEETM_QUERY_REJECT_STATISTICS;
+
+	ret = qman_ceetm_query_statistics(cid, dcp_idx, command_type, &result);
+	if (ret) {
+		pr_err("Can't query the statistics of CCG#%d!\n", ccg->idx);
+		return -EINVAL;
+	}
+
+	*frame_count = result.frm_cnt;
+	*byte_count = result.byte_cnt;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_ccg_get_reject_statistics);
+
+#define CEETM_CSCN_TARG_SWP	0
+#define CEETM_CSCN_TARG_DCP	1
+int qman_ceetm_cscn_swp_set(struct qm_ceetm_ccg *ccg,
+				u16 swp_idx,
+				unsigned int cscn_enabled,
+				u16 we_mask,
+				const struct qm_ceetm_ccg_params *params)
+{
+	struct qm_mcc_ceetm_ccgr_config config_opts;
+	int ret;
+
+	config_opts.ccgrid = CEETM_CCGR_CM_CONFIGURE |
+				(ccg->parent->idx << 4) | ccg->idx;
+	config_opts.dcpid = ccg->parent->dcp_idx;
+	config_opts.we_mask = we_mask | QM_CCGR_WE_CSCN_TUPD;
+	config_opts.cm_config.cscn_tupd = (cscn_enabled << 15) |
+					(CEETM_CSCN_TARG_SWP << 14) |
+					swp_idx;
+	config_opts.cm_config.ctl = (params->wr_en_g << 6) |
+				(params->wr_en_y << 5) |
+				(params->wr_en_r << 4) |
+				(params->td_en << 3)   |
+				(params->td_mode << 2) |
+				(params->cscn_en << 1) |
+				(params->mode);
+	config_opts.cm_config.cs_thres = params->cs_thres_in;
+	config_opts.cm_config.cs_thres_x = params->cs_thres_out;
+	config_opts.cm_config.td_thres = params->td_thres;
+	config_opts.cm_config.wr_parm_g = params->wr_parm_g;
+	config_opts.cm_config.wr_parm_y = params->wr_parm_y;
+	config_opts.cm_config.wr_parm_r = params->wr_parm_r;
+
+	ret = qman_ceetm_configure_ccgr(&config_opts);
+	if (ret) {
+		pr_err("Configure CSCN_TARG_SWP failed!\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_cscn_swp_set);
+
+int qman_ceetm_cscn_swp_get(struct qm_ceetm_ccg *ccg,
+					u16 swp_idx,
+					unsigned int *cscn_enabled)
+{
+	struct qm_mcc_ceetm_ccgr_query query_opts;
+	struct qm_mcr_ceetm_ccgr_query query_result;
+
+	query_opts.ccgrid = CEETM_CCGR_CM_QUERY |
+				(ccg->parent->idx << 4) | ccg->idx;
+	query_opts.dcpid = ccg->parent->dcp_idx;
+
+	if (qman_ceetm_query_ccgr(&query_opts, &query_result)) {
+		pr_err("Can't query CCGR#%d\n", ccg->idx);
+		return -EINVAL;
+	}
+
+	if (swp_idx < 63)
+		*cscn_enabled = (query_result.cm_query.cscn_targ_swp[0] >>
+			(63 - swp_idx)) & 0x1;
+	else
+		*cscn_enabled = (query_result.cm_query.cscn_targ_swp[1] >>
+			(127 - swp_idx)) & 0x1;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_cscn_swp_get);
+
+int qman_ceetm_cscn_dcp_set(struct qm_ceetm_ccg *ccg,
+				u16 dcp_idx,
+				u8 vcgid,
+				unsigned int cscn_enabled,
+				u16 we_mask,
+				const struct qm_ceetm_ccg_params *params)
+{
+	struct qm_mcc_ceetm_ccgr_config config_opts;
+	int ret;
+
+	config_opts.ccgrid = CEETM_CCGR_CM_CONFIGURE |
+				(ccg->parent->idx << 4) | ccg->idx;
+	config_opts.dcpid = ccg->parent->dcp_idx;
+	config_opts.we_mask = we_mask | QM_CCGR_WE_CSCN_TUPD | QM_CCGR_WE_CDV;
+	config_opts.cm_config.cdv = vcgid;
+	config_opts.cm_config.cscn_tupd = (cscn_enabled << 15) |
+					(CEETM_CSCN_TARG_DCP << 14) |
+					dcp_idx;
+	config_opts.cm_config.ctl = (params->wr_en_g << 6) |
+				(params->wr_en_y << 5) |
+				(params->wr_en_r << 4) |
+				(params->td_en << 3)   |
+				(params->td_mode << 2) |
+				(params->cscn_en << 1) |
+				(params->mode);
+	config_opts.cm_config.cs_thres = params->cs_thres_in;
+	config_opts.cm_config.cs_thres_x = params->cs_thres_out;
+	config_opts.cm_config.td_thres = params->td_thres;
+	config_opts.cm_config.wr_parm_g = params->wr_parm_g;
+	config_opts.cm_config.wr_parm_y = params->wr_parm_y;
+	config_opts.cm_config.wr_parm_r = params->wr_parm_r;
+
+	ret = qman_ceetm_configure_ccgr(&config_opts);
+	if (ret) {
+		pr_err("Configure CSCN_TARG_DCP failed!\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_cscn_dcp_set);
+
+int qman_ceetm_cscn_dcp_get(struct qm_ceetm_ccg *ccg,
+				u16 dcp_idx,
+				u8 *vcgid,
+				unsigned int *cscn_enabled)
+{
+	struct qm_mcc_ceetm_ccgr_query query_opts;
+	struct qm_mcr_ceetm_ccgr_query query_result;
+
+	query_opts.ccgrid = CEETM_CCGR_CM_QUERY |
+				(ccg->parent->idx << 4) | ccg->idx;
+	query_opts.dcpid = ccg->parent->dcp_idx;
+
+	if (qman_ceetm_query_ccgr(&query_opts, &query_result)) {
+		pr_err("Can't query CCGR#%d\n", ccg->idx);
+		return -EINVAL;
+	}
+
+	*vcgid = query_result.cm_query.cdv;
+	*cscn_enabled = (query_result.cm_query.cscn_targ_dcp >>
+							(7 - dcp_idx)) & 0x1;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_cscn_dcp_get);
+
+int qman_ceetm_querycongestion(u16 *ccg_state, unsigned int dcp_idx)
+{
+	struct qm_mc_command *mcc;
+	struct qm_mc_result *mcr;
+	struct qman_portal *p;
+	unsigned long irqflags __maybe_unused;
+	u8 res;
+	int i, j;
+
+	p = get_affine_portal();
+	PORTAL_IRQ_LOCK(p, irqflags);
+
+	mcc = qm_mc_start(&p->p);
+	for (i = 0; i < 1 ; i++) {
+		mcc->ccgr_query.ccgrid = i;
+		mcc->ccgr_query.dcpid = dcp_idx;
+		qm_mc_commit(&p->p, QM_CEETM_VERB_CCGR_QUERY);
+
+		while (!(mcr = qm_mc_result(&p->p)))
+			cpu_relax();
+		DPA_ASSERT((mcr->verb & QM_MCR_VERB_MASK) ==
+						QM_CEETM_VERB_CCGR_QUERY);
+		res = mcr->result;
+		if (res == QM_MCR_RESULT_OK) {
+			for (j = 0; j < 16; j++)
+				*(ccg_state + j) =
+				mcr->ccgr_query.congestion_state.ccg_state[j];
+		} else {
+			pr_err("QUERY CEETM CONGESTION STATE failed\n");
+			return -EIO;
+		}
+	}
+	PORTAL_IRQ_UNLOCK(p, irqflags);
+	put_affine_portal();
+	return 0;
+}
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index abb62db..c329659 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -129,6 +129,7 @@ struct qm_portal_config {
 #define QMAN_REV20 0x0200
 #define QMAN_REV30 0x0300
 extern u16 qman_ip_rev; /* 0 if uninitialised, otherwise QMAN_REVx */
+extern u32 qman_clk;
 
 #ifdef CONFIG_FSL_QMAN_CONFIG
 /* Hooks from qman_driver.c to qman_config.c */
@@ -284,3 +285,11 @@ int qman_setup_fq_lookup_table(size_t num_entries);
 /* TODO: unfortunate name-clash here, reword? */
 #define qm_isr_inhibit(qm)		__qm_isr_write(qm, qm_isr_inhibit, 1)
 #define qm_isr_uninhibit(qm)		__qm_isr_write(qm, qm_isr_inhibit, 0)
+
+/* CEETM related */
+#define QMAN_CEETM_MAX	2
+extern struct qm_ceetm qman_ceetms[QMAN_CEETM_MAX];
+int qman_sp_enable_ceetm_mode(enum qm_dc_portal portal, u16 sub_portal);
+int qman_sp_disable_ceetm_mode(enum qm_dc_portal portal, u16 sub_portal);
+int qman_ceetm_set_prescaler(enum qm_dc_portal portal);
+int qman_ceetm_get_prescaler(u16 *pres);
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index a5e9308..0ff15c1 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -65,6 +65,21 @@ enum qm_dc_portal {
 #define QM_PIRQ_SLOW	(QM_PIRQ_CSCI | QM_PIRQ_EQCI | QM_PIRQ_EQRI | \
 			QM_PIRQ_MRI)
 
+/* --- Clock speed --- */
+/* A qman driver instance may or may not know the current qman clock speed.
+ * However, certain CEETM calculations may not be possible if this is not known.
+ * The 'set' function will only succeed (return zero) if the driver did not
+ * already know the clock speed. Likewise, the 'get' function will only succeed
+ * if the driver does know the clock speed (either because it knew when booting,
+ * or was told via 'set'). In cases where software is running on a driver
+ * instance that does not know the clock speed (eg. on a hypervised data-plane),
+ * and the user can obtain the current qman clock speed by other means (eg. from
+ * a message sent from the control-plane), then the 'set' function can be used
+ * to enable rate-calculations in a driver where it would otherwise not be
+ * possible. */
+int qm_get_clock(u64 *clock_hz);
+int qm_set_clock(u64 clock_hz);
+
 /* For qman_static_dequeue_*** APIs */
 #define QM_SDQCR_CHANNELS_POOL_MASK	0x00007fff
 /* for n in [1,15] */
@@ -649,6 +664,201 @@ struct qm_mcc_querywq {
 	};
 	u8 __reserved2[60];
 } __packed;
+
+struct qm_mcc_ceetm_lfqmt_config {
+	u8 __reserved1[4];
+	u32 lfqid:24;
+	u8 __reserved2[2];
+	u16 cqid;
+	u8 __reserved3[2];
+	u16 dctidx;
+	u8 __reserved4[48];
+} __packed;
+
+struct qm_mcc_ceetm_lfqmt_query {
+	u8 __reserved1[4];
+	u32 lfqid:24;
+	u8 __reserved2[56];
+} __packed;
+
+struct qm_mcc_ceetm_cq_config {
+	u8 __reserved1;
+	u16 cqid;
+	u8 dcpid;
+	u8 __reserved2;
+	u16 ccgid;
+	u8 __reserved3[56];
+} __packed;
+
+struct qm_mcc_ceetm_cq_query {
+	u8 __reserved1;
+	u16 cqid;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+struct qm_mcc_ceetm_dct_config {
+	u8 __reserved1;
+	u16 dctidx;
+	u8 dcpid;
+	u8 __reserved2[15];
+	u32 context_b;
+	u64 context_a;
+	u8 __reserved3[32];
+} __packed;
+
+struct qm_mcc_ceetm_dct_query {
+	u8 __reserved1;
+	u16 dctidx;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+struct qm_mcc_ceetm_class_scheduler_config {
+	u8 __reserved1;
+	u16 cqcid;
+	u8 dcpid;
+	u8 __reserved2[6];
+	u8 gpc;
+	u16 crem;
+	u16 erem;
+	u8 w[8];
+	u8 __reserved3[40];
+} __packed;
+
+struct qm_mcc_ceetm_class_scheduler_query {
+	u8 __reserved1;
+	u16 cqcid;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+#define CEETM_COMMAND_CHANNEL_MAPPING	(0 << 12)
+#define CEETM_COMMAND_SP_MAPPING	(1 << 12)
+#define CEETM_COMMAND_CHANNEL_SHAPER	(2 << 12)
+#define CEETM_COMMAND_LNI_SHAPER	(3 << 12)
+#define CEETM_COMMAND_TCFC		(4 << 12)
+
+#define CEETM_CCGRID_MASK	0x01FF
+#define CEETM_CCGR_CM_CONFIGURE	(0 << 14)
+#define CEETM_CCGR_DN_CONFIGURE	(1 << 14)
+#define CEETM_CCGR_TEST_WRITE	(2 << 14)
+#define CEETM_CCGR_CM_QUERY	(0 << 14)
+#define CEETM_CCGR_DN_QUERY	(1 << 14)
+#define CEETM_CCGR_DN_QUERY_FLUSH	(2 << 14)
+#define CEETM_QUERY_CONGESTION_STATE (3 << 14)
+
+struct qm_mcc_ceetm_mapping_shaper_tcfc_config {
+	u8 __reserved1;
+	u16 cid;
+	u8 dcpid;
+	union {
+		struct {
+			u8 map;
+			u8 __reserved2[58];
+		} __packed channel_mapping;
+		struct {
+			u8 map_reserved:5;
+			u8 map_lni_id:3;
+			u8 __reserved2[58];
+		} __packed sp_mapping;
+		struct {
+			u8 cpl;
+			u32 crtcr:24;
+			u32 ertcr:24;
+			u16 crtbl;
+			u16 ertbl;
+			u8 __reserved2[48];
+		} __packed shaper_config;
+		struct {
+			u8 __reserved2[11];
+			u64 lnitcfcc;
+			u8 __reserved3[40];
+		} __packed tcfc_config;
+	};
+} __packed;
+
+struct qm_mcc_ceetm_mapping_shaper_tcfc_query {
+	u8 __reserved1;
+	u16 cid;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+struct qm_mcc_ceetm_ccgr_config {
+	u8 __reserved1;
+	u16 ccgrid;
+	u8 dcpid;
+	u8 __reserved2;
+	u16 we_mask;
+	union {
+		struct {
+			u8 ctl;
+			u8 cdv;
+			u16 cscn_tupd;
+			u8 oal;
+			u8 __reserved3;
+			struct qm_cgr_cs_thres cs_thres;
+			struct qm_cgr_cs_thres cs_thres_x;
+			struct qm_cgr_cs_thres td_thres;
+			struct qm_cgr_wr_parm wr_parm_g;
+			struct qm_cgr_wr_parm wr_parm_y;
+			struct qm_cgr_wr_parm wr_parm_r;
+		} __packed cm_config;
+		struct {
+			u8 dnc;
+			u8 dn0;
+			u8 dn1;
+			u64 dnba:40;
+			u8 __reserved3[2];
+			u16 dnth_0;
+			u8 __reserved4[2];
+			u16 dnth_1;
+			u8 __reserved5[8];
+		} __packed dn_config;
+		struct {
+			u8 __reserved3[3];
+			u64 i_cnt:40;
+			u8 __reserved4[16];
+		} __packed test_write;
+	};
+	u8 __reserved5[32];
+} __packed;
+
+struct qm_mcc_ceetm_ccgr_query {
+	u8 __reserved1;
+	u16 ccgrid;
+	u8 dcpid;
+	u8 __reserved2[59];
+} __packed;
+
+struct qm_mcc_ceetm_cq_peek_pop_xsfdrread {
+	u8 __reserved1;
+	u16 cqid;
+	u8 dcpid;
+	u8 ct;
+	u16 xsfdr;
+	u8 __reserved2[56];
+} __packed;
+
+#define CEETM_QUERY_DEQUEUE_STATISTICS 0x00
+#define CEETM_QUERY_DEQUEUE_CLEAR_STATISTICS 0x01
+#define CEETM_WRITE_DEQUEUE_STATISTICS 0x02
+#define CEETM_QUERY_REJECT_STATISTICS 0x03
+#define CEETM_QUERY_REJECT_CLEAR_STATISTICS 0x04
+#define CEETM_WRITE_REJECT_STATISTICS 0x05
+struct qm_mcc_ceetm_statistics_query_write {
+	u8 __reserved1;
+	u16 cid;
+	u8 dcpid;
+	u8 ct;
+	u8 __reserved2[13];
+	u64 frm_cnt:40;
+	u16 __reserved3[2];
+	u64 byte_cnt:40;
+	u8 __reserved[32];
+} __packed;
+
 struct qm_mc_command {
 	u8 __dont_write_directly__verb;
 	union {
@@ -661,6 +871,20 @@ struct qm_mc_command {
 		struct qm_mcc_querycgr querycgr;
 		struct qm_mcc_querycongestion querycongestion;
 		struct qm_mcc_querywq querywq;
+		struct qm_mcc_ceetm_lfqmt_config lfqmt_config;
+		struct qm_mcc_ceetm_lfqmt_query lfqmt_query;
+		struct qm_mcc_ceetm_cq_config cq_config;
+		struct qm_mcc_ceetm_cq_query cq_query;
+		struct qm_mcc_ceetm_dct_config dct_config;
+		struct qm_mcc_ceetm_dct_query dct_query;
+		struct qm_mcc_ceetm_class_scheduler_config csch_config;
+		struct qm_mcc_ceetm_class_scheduler_query csch_query;
+		struct qm_mcc_ceetm_mapping_shaper_tcfc_config mst_config;
+		struct qm_mcc_ceetm_mapping_shaper_tcfc_query mst_query;
+		struct qm_mcc_ceetm_ccgr_config ccgr_config;
+		struct qm_mcc_ceetm_ccgr_query ccgr_query;
+		struct qm_mcc_ceetm_cq_peek_pop_xsfdrread cq_ppxr;
+		struct qm_mcc_ceetm_statistics_query_write stats_query_write;
 	};
 } __packed;
 #define QM_MCC_VERB_VBIT		0x80
@@ -705,6 +929,22 @@ struct qm_mc_command {
 #define QM_CGR_WE_CS_THRES		0x0002
 #define QM_CGR_WE_MODE			0x0001
 
+/* See 1.5.9.7 CEETM Management Commands */
+#define QM_CEETM_VERB_LFQMT_CONFIG	0x70
+#define QM_CEETM_VERB_LFQMT_QUERY	0x71
+#define QM_CEETM_VERB_CQ_CONFIG		0x72
+#define QM_CEETM_VERB_CQ_QUERY		0x73
+#define QM_CEETM_VERB_DCT_CONFIG	0x74
+#define QM_CEETM_VERB_DCT_QUERY		0x75
+#define QM_CEETM_VERB_CLASS_SCHEDULER_CONFIG		0x76
+#define QM_CEETM_VERB_CLASS_SCHEDULER_QUERY		0x77
+#define QM_CEETM_VERB_MAPPING_SHAPER_TCFC_CONFIG	0x78
+#define QM_CEETM_VERB_MAPPING_SHAPER_TCFC_QUERY		0x79
+#define QM_CEETM_VERB_CCGR_CONFIG			0x7A
+#define QM_CEETM_VERB_CCGR_QUERY			0x7B
+#define QM_CEETM_VERB_CQ_PEEK_POP_XFDRREAD		0x7C
+#define QM_CEETM_VERB_STATISTICS_QUERY_WRITE		0x7D
+
 /* See 1.5.8.5.1: "Initialize FQ" */
 /* See 1.5.8.5.2: "Query FQ" */
 /* See 1.5.8.5.3: "Query FQ Non-Programmable Fields" */
@@ -842,6 +1082,189 @@ struct qm_mcr_querywq {
 	u8 __reserved[28];
 	u32 wq_len[8];
 } __packed;
+
+/* QMAN CEETM Management Command Response */
+struct qm_mcr_ceetm_lfqmt_config {
+	u8 __reserved1[62];
+} __packed;
+struct qm_mcr_ceetm_lfqmt_query {
+	u8 __reserved1[8];
+	u16 cqid;
+	u8 __reserved2[2];
+	u16 dctidx;
+	u8 __reserved3[2];
+	u16 ccgid;
+	u8 __reserved4[44];
+} __packed;
+
+struct qm_mcr_ceetm_cq_config {
+	u8 __reserved1[62];
+} __packed;
+
+struct qm_mcr_ceetm_cq_query {
+	u8 __reserved1[4];
+	u16 ccgid;
+	u16 state;
+	u32 pfdr_hptr:24;
+	u32 pfdr_tptr:24;
+	u16 od1_xsfdr;
+	u16 od2_xsfdr;
+	u16 od3_xsfdr;
+	u16 od4_xsfdr;
+	u16 od5_xsfdr;
+	u16 od6_xsfdr;
+	u16 ra1_xsfdr;
+	u16 ra2_xsfdr;
+	u8 __reserved2;
+	u32 frm_cnt:24;
+	u8 __reserved333[28];
+} __packed;
+
+struct qm_mcr_ceetm_dct_config {
+	u8 __reserved1[62];
+} __packed;
+
+struct qm_mcr_ceetm_dct_query {
+	u8 __reserved1[18];
+	u32 context_b;
+	u64 context_a;
+	u8 __reserved2[32];
+} __packed;
+
+struct qm_mcr_ceetm_class_scheduler_config {
+	u8 __reserved1[62];
+} __packed;
+
+struct qm_mcr_ceetm_class_scheduler_query {
+	u8 __reserved1[9];
+	u8 gpc;
+	u16 crem;
+	u16 erem;
+	u8 w[8];
+	u8 __reserved2[5];
+	u32 wbfslist:24;
+	u32 d8;
+	u32 d9;
+	u32 d10;
+	u32 d11;
+	u32 d12;
+	u32 d13;
+	u32 d14;
+	u32 d15;
+} __packed;
+
+struct qm_mcr_ceetm_mapping_shaper_tcfc_config {
+	u16 cid;
+	u8 __reserved2[60];
+} __packed;
+
+struct qm_mcr_ceetm_mapping_shaper_tcfc_query {
+	u16 cid;
+	u8 __reserved1;
+	union {
+		struct {
+			u8 map;
+			u8 __reserved2[58];
+		} __packed channel_mapping_query;
+		struct {
+			u8 map_reserved:5;
+			u8 map_lni_id:3;
+			u8 __reserved2[58];
+		} __packed sp_mapping_query;
+		struct {
+			u8 cpl;
+			u32 crtcr:24;
+			u32 ertcr:24;
+			u16 crtbl;
+			u16 ertbl;
+			u8 __reserved2[16];
+			u32 crat;
+			u32 erat;
+			u8 __reserved3[24];
+		} __packed shaper_query;
+		struct {
+			u8 __reserved1[11];
+			u64 lnitcfcc;
+			u8 __reserved3[40];
+		} __packed tcfc_query;
+	};
+} __packed;
+
+struct qm_mcr_ceetm_ccgr_config {
+	u8 __reserved1[46];
+	union {
+		u8 __reserved2[8];
+		struct {
+			u16 timestamp;
+			u16 wr_porb_g;
+			u16 wr_prob_y;
+			u16 wr_prob_r;
+		} __packed test_write;
+	};
+	u8 __reserved3[8];
+} __packed;
+
+struct qm_mcr_ceetm_ccgr_query {
+	u8 __reserved1[6];
+	union {
+		struct {
+			u8 ctl;
+			u8 cdv;
+			u8 __reserved2[2];
+			u8 oal;
+			u8 __reserved3;
+			struct qm_cgr_cs_thres cs_thres;
+			struct qm_cgr_cs_thres cs_thres_x;
+			struct qm_cgr_cs_thres td_thres;
+			struct qm_cgr_wr_parm wr_parm_g;
+			struct qm_cgr_wr_parm wr_parm_y;
+			struct qm_cgr_wr_parm wr_parm_r;
+			u8 cscn_targ_dcp;
+			u16 dcp_lsn;
+			u64 i_cnt:40;
+			u8 __reserved4[3];
+			u64 a_cnt:40;
+			u64 cscn_targ_swp[2];
+		} __packed cm_query;
+		struct {
+			u8 dnc;
+			u8 dn0;
+			u8 dn1;
+			u64 dnba:40;
+			u8 __reserved2[2];
+			u16 dnth_0;
+			u8 __reserved3[2];
+			u16 dnth_1;
+			u8 __reserved4[10];
+			u16 dnacc_0;
+			u8 __reserved5[2];
+			u16 dnacc_1;
+			u8 __reserved6[24];
+		} __packed dn_query;
+		struct {
+			u8 __reserved2[24];
+			u16 ccg_state[16];
+		} __packed congestion_state;
+
+	};
+} __packed;
+
+struct qm_mcr_ceetm_cq_peek_pop_xsfdrread {
+	u8 stat;
+	u8 __reserved1[11];
+	u16 dctidx;
+	struct qm_fd fd;
+	u8 __reserved2[32];
+} __packed;
+
+struct qm_mcr_ceetm_statistics_query {
+	u8 __reserved1[15];
+	u64 frm_cnt:40;
+	u8 __reserved2[2];
+	u64 byte_cnt:40;
+	u8 __reserved3[32];
+} __packed;
+
 struct qm_mc_result {
 	u8 verb;
 	u8 result;
@@ -855,8 +1278,23 @@ struct qm_mc_result {
 		struct qm_mcr_querycgr querycgr;
 		struct qm_mcr_querycongestion querycongestion;
 		struct qm_mcr_querywq querywq;
+		struct qm_mcr_ceetm_lfqmt_config lfqmt_config;
+		struct qm_mcr_ceetm_lfqmt_query lfqmt_query;
+		struct qm_mcr_ceetm_cq_config cq_config;
+		struct qm_mcr_ceetm_cq_query cq_query;
+		struct qm_mcr_ceetm_dct_config dct_config;
+		struct qm_mcr_ceetm_dct_query dct_query;
+		struct qm_mcr_ceetm_class_scheduler_config csch_config;
+		struct qm_mcr_ceetm_class_scheduler_query csch_query;
+		struct qm_mcr_ceetm_mapping_shaper_tcfc_config mst_config;
+		struct qm_mcr_ceetm_mapping_shaper_tcfc_query mst_query;
+		struct qm_mcr_ceetm_ccgr_config ccgr_config;
+		struct qm_mcr_ceetm_ccgr_query ccgr_query;
+		struct qm_mcr_ceetm_cq_peek_pop_xsfdrread cq_ppxr;
+		struct qm_mcr_ceetm_statistics_query stats_query;
 	};
 } __packed;
+
 #define QM_MCR_VERB_RRID		0x80
 #define QM_MCR_VERB_MASK		QM_MCC_VERB_MASK
 #define QM_MCR_VERB_INITFQ_PARKED	QM_MCC_VERB_INITFQ_PARKED
@@ -1789,6 +2227,937 @@ static inline int qman_poll_fq_for_init(struct qman_fq *fq)
 	return 0;
 }
 
+	/* -------------- */
+	/* CEETM :: types */
+	/* -------------- */
+/**
+ * Token Rate Structure
+ * Shaping rates are based on a "credit" system and a pre-configured h/w
+ * internal timer. The following type represents a shaper "rate" parameter as a
+ * fractional number of "tokens". Here's how it works. This (fractional) number
+ * of tokens is added to the shaper's "credit" every time the h/w timer elapses
+ * (up to a limit which is set by another shaper parameter). Every time a frame
+ * is enqueued through a shaper, the shaper deducts as many tokens as there are
+ * bytes of data in the enqueued frame. A shaper will not allow itself to
+ * enqueue any frames if its token count is negative. As such;
+ *
+ *         The rate at which data is enqueued is limited by the
+ *         rate at which tokens are added.
+ *
+ * Therefore if the user knows the period between these h/w timer updates in
+ * seconds, they can calculate the maximum traffic rate of the shaper (in
+ * bytes-per-second) from the token rate. And vice versa, they can calculate
+ * the token rate to use in order to achieve a given traffic rate.
+ */
+struct qm_ceetm_rate {
+	/* The token rate is; whole + (fraction/8192) */
+	u32 whole:11; /* 0..2047 */
+	u32 fraction:13; /* 0..8191 */
+};
+
+struct qm_ceetm_weight_code {
+	/* The weight code is; 5 msbits + 3 lsbits */
+	u8 y:5;
+	u8 x:3;
+};
+
+struct qm_ceetm {
+	unsigned int idx;
+	struct list_head sub_portals;
+	struct list_head lnis;
+	unsigned int sp_range[2];
+	unsigned int lni_range[2];
+};
+
+struct qm_ceetm_sp {
+	struct list_head node;
+	unsigned int idx;
+	unsigned int dcp_idx;
+	int is_claimed;
+	struct qm_ceetm_lni *lni;
+};
+
+/* Logical Network Interface */
+struct qm_ceetm_lni {
+	struct list_head node;
+	unsigned int idx;
+	unsigned int dcp_idx;
+	int is_claimed;
+	struct qm_ceetm_sp *sp;
+	struct list_head channels;
+	u8 shaper_enable;
+	u8 shaper_couple;
+	struct qm_ceetm_rate cr_token_rate;
+	struct qm_ceetm_rate er_token_rate;
+	u16 cr_token_bucket_limit;
+	u16 er_token_bucket_limit;
+};
+
+/* Class Queue Channel */
+struct qm_ceetm_channel {
+	struct list_head node;
+	unsigned int idx;
+	unsigned int lni_idx;
+	unsigned int dcp_idx;
+	struct list_head class_queues;
+	struct list_head ccgs;
+	u8 shaper_enable;
+	u8 shaper_couple;
+	struct qm_ceetm_rate cr_token_rate;
+	struct qm_ceetm_rate er_token_rate;
+	u16 cr_token_bucket_limit;
+	u16 er_token_bucket_limit;
+};
+
+struct qm_ceetm_ccg;
+
+/* This callback type is used when handling congestion entry/exit. The
+ * 'cb_ctx' value is the opaque value associated with ccg object.
+ * 'congested' is non-zero on congestion-entry, and zero on congestion-exit.
+ */
+typedef void (*qman_cb_ccgr)(struct qm_ceetm_ccg *ccg, void *cb_ctx,
+							int congested);
+
+/* Class Congestion Group */
+struct qm_ceetm_ccg {
+	struct qm_ceetm_channel *parent;
+	struct list_head node;
+	qman_cb_ccgr cb;
+	void *cb_ctx;
+	unsigned int idx;
+};
+
+/* Class Queue */
+struct qm_ceetm_cq {
+	struct qm_ceetm_channel *parent;
+	struct qm_ceetm_ccg *ccg;
+	struct list_head node;
+	unsigned int idx;
+	int is_claimed;
+	struct list_head bound_lfqids;
+	struct list_head binding_node;
+};
+
+/* Logical Frame Queue */
+struct qm_ceetm_lfq {
+	struct qm_ceetm_channel *parent;
+	struct list_head node;
+	unsigned int idx;
+	unsigned int dctidx;
+	u64 context_a;
+	u32 context_b;
+	qman_cb_mr ern;
+};
+
+/* Divide 'n' by 'd', rounding down if 'r' is negative, rounding up if
+ * it's positive, and rounding to the closest value if it's zero. NB,
+ * this macro assumes no particular type, so feed it with types that are
+ * appropriate for its use. NB, these arguments should not be expressions
+ * unless it is safe for them to be evaluated multiple times. Eg. do not
+ * pass in "some_value++" as a parameter to the macro! */
+#define ROUNDING(n, d, r) \
+	(((r) < 0) ? ((n) / (d)) : \
+	(((r) > 0) ? (((n) + (d) - 1) / (d)) : \
+	(((n) + ((d) / 2)) / (d))))
+
+/**
+ * qman_ceetm_bps2tokenrate - Given a desired rate 'bps' measured in bps
+ * (ie. bits-per-second), compute the 'token_rate' fraction that best
+ * approximates that rate.
+ * @bps: the desired shaper rate in bps.
+ * @token_rate: the output token rate computed with the given kbps.
+ * @rounding: dictates how to round if an exact conversion is not possible; if
+ * it is negative then 'token_rate' will round down to the highest value that
+ * does not exceed the desired rate, if it is positive then 'token_rate' will
+ * round up to the lowest value that is greater than or equal to the desired
+ * rate, and if it is zero then it will round to the nearest approximation,
+ * whether that be up or down.
+ *
+ * Return 0 for success, or -EINVAL if prescaler or qman clock is not available.
+  */
+int qman_ceetm_bps2tokenrate(u32 bps,
+				struct qm_ceetm_rate *token_rate,
+				int rounding);
+
+/**
+ * qman_ceetm_tokenrate2bps - Given a 'token_rate', compute the
+ * corresponding number of 'bps'.
+ * @token_rate: the input desired token_rate fraction.
+ * @bps: the output shaper rate in bps computed with the give token rate.
+ * @rounding: has the same semantics as the previous function.
+ *
+ * Return 0 for success, or -EINVAL if prescaler or qman clock is not available.
+ */
+int qman_ceetm_tokenrate2bps(const struct qm_ceetm_rate *token_rate,
+			      u32 *bps,
+			      int rounding);
+
+int qman_alloc_ceetm0_channel_range(u32 *result, u32 count, u32 align,
+								int partial);
+static inline int qman_alloc_ceetm0_channel(u32 *result)
+{
+	int ret = qman_alloc_ceetm0_channel_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+void qman_release_ceetm0_channel_range(u32 channelid, u32 count);
+static inline void qman_release_ceetm0_channelid(u32 channelid)
+{
+	qman_release_ceetm0_channel_range(channelid, 1);
+}
+
+int qman_alloc_ceetm1_channel_range(u32 *result, u32 count, u32 align,
+								int partial);
+static inline int qman_alloc_ceetm1_channel(u32 *result)
+{
+	int ret = qman_alloc_ceetm1_channel_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+void qman_release_ceetm1_channel_range(u32 channelid, u32 count);
+static inline void qman_release_ceetm1_channelid(u32 channelid)
+{
+	qman_release_ceetm1_channel_range(channelid, 1);
+}
+
+int qman_alloc_ceetm0_lfqid_range(u32 *result, u32 count, u32 align,
+								int partial);
+static inline int qman_alloc_ceetm0_lfqid(u32 *result)
+{
+	int ret = qman_alloc_ceetm0_lfqid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+void qman_release_ceetm0_lfqid_range(u32 lfqid, u32 count);
+static inline void qman_release_ceetm0_lfqid(u32 lfqid)
+{
+	qman_release_ceetm0_lfqid_range(lfqid, 1);
+}
+
+int qman_alloc_ceetm1_lfqid_range(u32 *result, u32 count, u32 align,
+								int partial);
+static inline int qman_alloc_ceetm1_lfqid(u32 *result)
+{
+	int ret = qman_alloc_ceetm1_lfqid_range(result, 1, 0, 0);
+	return (ret > 0) ? 0 : ret;
+}
+void qman_release_ceetm1_lfqid_range(u32 lfqid, u32 count);
+static inline void qman_release_ceetm1_lfqid(u32 lfqid)
+{
+	qman_release_ceetm1_lfqid_range(lfqid, 1);
+}
+	/* ----------------------------- */
+	/* CEETM :: sub-portals          */
+	/* ----------------------------- */
+
+/**
+ * qman_ceetm_claim_sp - Claims the given sub-portal, provided it is available
+ * to us and configured for traffic-management.
+ * @sp: the returned sub-portal object, if successful.
+ * @dcp_id: specifies the desired Fman block (and thus the relevant CEETM
+ * instance),
+ * @sp_idx" is the desired sub-portal index from 0 to 15.
+ *
+ * Returns zero for success, or -ENODEV if the sub-portal is in use,  or -EINVAL
+ * if the sp_idx is out of range.
+ *
+ * Note that if there are multiple driver domains (eg. a linux kernel versus
+ * user-space drivers in USDPAA, or multiple guests running under a hypervisor)
+ * then a sub-portal may be accessible by more than one instance of a qman
+ * driver and so it may be claimed multiple times. If this is the case, it is
+ * up to the system architect to prevent conflicting configuration actions
+ * coming from the different driver domains. The qman drivers do not have any
+ * behind-the-scenes coordination to prevent this from happening.
+ */
+int qman_ceetm_sp_claim(struct qm_ceetm_sp **sp,
+			enum qm_dc_portal dcp_idx,
+			unsigned int sp_idx);
+
+/**
+ * qman_ceetm_sp_release - Releases a previously claimed sub-portal.
+ * @sp: the sub-portal to be released.
+ *
+ * Returns 0 for success, or -EBUSY for failure if the dependencies are not
+ * released.
+ */
+int qman_ceetm_sp_release(struct qm_ceetm_sp *sp);
+
+	/* ----------------------------------- */
+	/* CEETM :: logical network interfaces */
+	/* ----------------------------------- */
+
+/**
+ * qman_ceetm_lni_claim - Claims an unclaimed LNI.
+ * @lni: the returned LNI object, if successful.
+ * @dcp_id: specifies the desired Fman block (and thus the relevant CEETM
+ * instance)
+ * @lni_idx: is the desired LNI index.
+ *
+ * Returns zero for success, or -EINVAL on failure, which will happen if the LNI
+ * is not available or has already been claimed (and not yet successfully
+ * released), or lni_dix is out of range.
+ *
+ * Note that there may be multiple driver domains (or instances) that need to
+ * transmit out the same LNI, so this claim is only guaranteeing exclusivity
+ * within the domain of the driver being called. See qman_ceetm_sp_claim() and
+ * qman_ceetm_sp_get_lni() for more information.
+ */
+int qman_ceetm_lni_claim(struct qm_ceetm_lni **lni,
+			 enum qm_dc_portal dcp_id,
+			 unsigned int lni_idx);
+
+/**
+ * qman_ceetm_lni_releaes - Releases a previously claimed LNI.
+ * @lni: the lni needs to be released.
+ *
+ * This will only succeed if all dependent objects have been released.
+ * Returns zero for success, or -EBUSY if the dependencies are not released.
+ */
+int qman_ceetm_lni_release(struct qm_ceetm_lni *lni);
+
+/**
+ * qman_ceetm_sp_set_lni
+ * qman_ceetm_sp_get_lni - Set/get the LNI that the sub-portal is currently
+ * mapped to.
+ * @sp: the given sub-portal.
+ * @lni(in "set"function): the LNI object which the sp will be mappaed to.
+ * @lni_idx(in "get" function): the LNI index which the sp is mapped to.
+ *
+ * Returns zero for success, or -EINVAL for the "set" function when this sp-lni
+ * mapping has been set, or configure mapping command returns error, and
+ * -EINVAL for "get" function when this sp-lni mapping is not set or the query
+ * mapping command returns error.
+ *
+ * This may be useful in situations where multiple driver domains have access
+ * to the same sub-portals in order to all be able to transmit out the same
+ * physical interface (perhaps they're on different IP addresses or VPNs, so
+ * Fman is splitting Rx traffic and here we need to converge Tx traffic). In
+ * that case, a control-plane is likely to use qman_ceetm_lni_claim() followed
+ * by qman_ceetm_sp_set_lni() to configure the sub-portal, and other domains
+ * are likely to use qman_ceetm_sp_get_lni() followed by qman_ceetm_lni_claim()
+ * in order to determine the LNI that the control-plane had assigned. This is
+ * why the "get" returns an index, whereas the "set" takes an (already claimed)
+ * LNI object.
+ */
+int qman_ceetm_sp_set_lni(struct qm_ceetm_sp *sp,
+			  struct qm_ceetm_lni *lni);
+int qman_ceetm_sp_get_lni(struct qm_ceetm_sp *sp,
+			  unsigned int *lni_idx);
+
+/**
+ * qman_ceetm_lni_enable_shaper
+ * qman_ceetm_lni_disable_shaper - Enables/disables shaping on the LNI.
+ * @lni: the given LNI.
+ * @coupled: indicates whether CR and ER are coupled.
+ *
+ * When the number of (unused) committed-rate tokens reach the committed-rate
+ * token limit, 'coupled' indicates whether surplus tokens should be added to
+ * the excess-rate token count (up to the excess-rate token limit).
+ * When LNI is claimed, the shaper is disabled by default. The enable function
+ * will turn on this shaper for this lni.
+ * Whenever a claimed LNI is first enabled for shaping, its committed and
+ * excess token rates and limits are zero, so will need to be changed to do
+ * anything useful. The shaper can subsequently be enabled/disabled without
+ * resetting the shaping parameters, but the shaping parameters will be reset
+ * when the LNI is released.
+ *
+ * Returns zero for success, or  errno for "enable" function in the cases as:
+ * a) -EINVAL if the shaper is already enabled,
+ * b) -EIO if the configure shaper command returns error.
+ * For "disable" function, returns:
+ * a) -EINVAL if the shaper is has already disabled.
+ * b) -EIO if calling configure shaper command returns error.
+ */
+int qman_ceetm_lni_enable_shaper(struct qm_ceetm_lni *lni, int coupled);
+int qman_ceetm_lni_disable_shaper(struct qm_ceetm_lni *lni);
+
+/**
+ * qman_ceetm_lni_set_commit_rate
+ * qman_ceetm_lni_get_commit_rate
+ * qman_ceetm_lni_set_excess_rate
+ * qman_ceetm_lni_get_excess_rate - Set/get the shaper CR/ER token rate and
+ * token limit for the given LNI.
+ * @lni: the given LNI.
+ * @token_rate: the desired token rate for "set" fuction, or the token rate of
+ * the LNI queried by "get" function.
+ * @token_limit: the desired token bucket limit for "set" function, or the token
+ * limit of the given LNI queried by "get" function.
+ *
+ * Returns zero for success. The "set" function returns -EINVAL if the given
+ * LNI is unshapped or -EIO if the configure shaper command returns error.
+ * The "get" function returns -EINVAL if the token rate or the token limit is
+ * not set or the query command returns error.
+ */
+int qman_ceetm_lni_set_commit_rate(struct qm_ceetm_lni *lni,
+				   const struct qm_ceetm_rate *token_rate,
+				   u16 token_limit);
+int qman_ceetm_lni_get_commit_rate(struct qm_ceetm_lni *lni,
+				   struct qm_ceetm_rate *token_rate,
+				   u16 *token_limit);
+int qman_ceetm_lni_set_excess_rate(struct qm_ceetm_lni *lni,
+				   const struct qm_ceetm_rate *token_rate,
+				   u16 token_limit);
+int qman_ceetm_lni_get_excess_rate(struct qm_ceetm_lni *lni,
+				   struct qm_ceetm_rate *token_rate,
+				   u16 *token_limit);
+
+/**
+ * qman_ceetm_lni_set_tcfcc
+ * qman_ceetm_lni_get_tcfcc - Configure/query "Traffic Class Flow Control".
+ * @lni: the given LNI.
+ * @cq_level: is between 0 and 15, representing individual class queue levels
+ * (CQ0 to CQ7 for every channel) and grouped class queue levels (CQ8 to CQ15
+ * for every channel).
+ * @traffic_class: is between 0 and 7 when associating a given class queue level
+ * to a traffic class, or -1 when disabling traffic class flow control for this
+ * class queue level.
+ *
+ * Return zero for success, or -EINVAL if the cq_level or traffic_class is out
+ * of range as indicated above, or -EIO if the configure/query tcfcc command
+ * returns error.
+ *
+ * Refer to the section of QMan CEETM traffic class flow control in the Refernce
+ * Manual.
+ */
+int qman_ceetm_lni_set_tcfcc(struct qm_ceetm_lni *lni,
+			     unsigned int cq_level,
+			     int traffic_class);
+int qman_ceetm_lni_get_tcfcc(struct qm_ceetm_lni *lni,
+			     unsigned int cq_level,
+			     int *traffic_class);
+
+	/* ----------------------------- */
+	/* CEETM :: class queue channels */
+	/* ----------------------------- */
+
+/**
+ * qman_ceetm_channel_claim - Claims an unclaimed CQ channel that is mapped to
+ * the given LNI.
+ * @channel: the returned class queue channel object, if successful.
+ * @lni: the LNI that the channel belongs to.
+ *
+ * Channels are always initially "unshaped".
+ *
+ * Return zero for success, or -ENODEV if there is no channel available(all 32
+ * channels are claimed) or -EINVAL if the channel mapping command returns
+ * error.
+ */
+int qman_ceetm_channel_claim(struct qm_ceetm_channel **channel,
+			     struct qm_ceetm_lni *lni);
+
+/**
+ * qman_ceetm_channel_release - Releases a previously claimed CQ channel.
+ * @channel: the channel needs to be released.
+ *
+ * Returns zero for success, or -EBUSY if the dependencies are still in use.
+ *
+ * Note any shaping of the channel will be cleared to leave it in an unshaped
+ * state.
+ */
+int qman_ceetm_channel_release(struct qm_ceetm_channel *channel);
+
+/**
+ * qman_ceetm_channel_enable_shaper
+ * qman_ceetm_channel_disable_shaper - Enables/disables shaping on the channel.
+ * @channel: the given channel.
+ * @coupled: indicates whether surplus CR tokens should be added to the
+ * excess-rate token count (up to the excess-rate token limit) when the number
+ * of (unused) committed-rate tokens reach the committed_rate token limit.
+ *
+ * Whenever a claimed channel is first enabled for shaping, its committed and
+ * excess token rates and limits are zero, so will need to be changed to do
+ * anything useful. The shaper can subsequently be enabled/disabled without
+ * resetting the shaping parameters, but the shaping parameters will be reset
+ * when the channel is released.
+ *
+ * Return 0 for success, or -EINVAL for failure, in the case that the channel
+ * shaper has been enabled/disabled or the management command returns error.
+ */
+int qman_ceetm_channel_enable_shaper(struct qm_ceetm_channel *channel,
+							 int coupled);
+int qman_ceetm_channel_disable_shaper(struct qm_ceetm_channel *channel);
+
+/**
+ * qman_ceetm_channel_set_commit_rate
+ * qman_ceetm_channel_get_commit_rate
+ * qman_ceetm_channel_set_excess_rate
+ * qman_ceetm_channel_get_excess_rate - Set/get channel CR/ER shaper parameters.
+ * @channel: the given channel.
+ * @token_rate: the desired token rate for "set" function, or the queried token
+ * rate for "get" function.
+ * @token_limit: the desired token limit for "set" function, or the queried
+ * token limit for "get" function.
+ *
+ * Return zero for success. The "set" function returns -EINVAL if the channel
+ * is unshaped, or -EIO if the configure shapper command returns error. The
+ * "get" function returns -EINVAL if token rate of token limit is not set, or
+ * the query shaper command returns error.
+ */
+int qman_ceetm_channel_set_commit_rate(struct qm_ceetm_channel *channel,
+				   const struct qm_ceetm_rate *token_rate,
+				   u16 token_limit);
+int qman_ceetm_channel_get_commit_rate(struct qm_ceetm_channel *channel,
+				   struct qm_ceetm_rate *token_rate,
+				   u16 *token_limit);
+int qman_ceetm_channel_set_excess_rate(struct qm_ceetm_channel *channel,
+				   const struct qm_ceetm_rate *token_rate,
+				   u16 token_limit);
+int qman_ceetm_channel_get_excess_rate(struct qm_ceetm_channel *channel,
+				   struct qm_ceetm_rate *token_rate,
+				   u16 *token_limit);
+
+/**
+ * qman_ceetm_channel_set_weight
+ * qman_ceetm_channel_get_weight - Set/get the weight for unshaped channel
+ * @channel: the given channel.
+ * @token_limit: the desired token limit as the weight of the unshaped channel
+ * for "set" function, or the queried token limit for "get" function.
+ *
+ * The algorithm of unshaped fair queuing (uFQ) is used for unshaped channel.
+ * It allows the unshaped channels to be included in the CR time eligible list,
+ * and thus use the configured CR token limit value as their fair queuing
+ * weight.
+ *
+ * Return zero for success, or -EINVAL if the channel is a shaped channel or
+ * the management command returns error.
+ */
+int qman_ceetm_channel_set_weight(struct qm_ceetm_channel *channel,
+				  u16 token_limit);
+int qman_ceetm_channel_get_weight(struct qm_ceetm_channel *channel,
+				  u16 *token_limit);
+
+/**
+ * qman_ceetm_channel_set_group
+ * qman_ceetm_channel_get_group - Set/get the grouping of the class scheduler.
+ * @channel: the given channel.
+ * @group_b: indicates whether there is group B in this channel.
+ * @prio_a: the priority of group A.
+ * @prio_b: the priority of group B.
+ *
+ * There are 8 individual class queues (CQ0-CQ7), and 8 grouped class queues
+ * (CQ8-CQ15). If 'group_b' is zero, then all the grouped class queues are in
+ * group A, otherwise they are split into group A (CQ8-11) and group B
+ * (CQ12-C15). The individual class queues and the group(s) are in strict
+ * priority order relative to each other. Within the group(s), the scheduling
+ * is not strict priority order, but the result of scheduling within a group
+ * is in strict priority order relative to the other class queues in the
+ * channel. 'prio_a' and 'prio_b' control the priority order of the groups
+ * relative to the individual class queues, and take values from 0-7. Eg. if
+ * 'group_b' is non-zero, 'prio_a' is 2 and 'prio_b' is 6, then the strict
+ * priority order would be;
+ *      CQ0, CQ1, CQ2, GROUPA, CQ3, CQ4, CQ5, CQ6, GROUPB, CQ7
+ *
+ * Return 0 for success. For "set" function, returns -EINVAL if prio_a or
+ * prio_b are out of the range 1 - 7 (priority of group A or group B can not
+ * be 0, CQ0 is always the highest class queue in this channel.), or -EIO if
+ * the configure scheduler command returns error. For "get" function, return
+ * -EINVAL if the query scheduler command returns error.
+ */
+int qman_ceetm_channel_set_group(struct qm_ceetm_channel *channel,
+			     int group_b,
+			     unsigned int prio_a,
+			     unsigned int prio_b);
+int qman_ceetm_channel_get_group(struct qm_ceetm_channel *channel,
+			     int *group_b,
+			     unsigned int *prio_a,
+			     unsigned int *prio_b);
+
+	/* --------------------- */
+	/* CEETM :: class queues */
+	/* --------------------- */
+
+/**
+ * qman_ceetm_cq_claim - Claims an individual class queue.
+ * @cq: the returned class queue object, if successful.
+ * @channel: the class queue channel.
+ * @idx: is from 0 to 7 (representing CQ0 to CQ7).
+ * @ccg: represents the class congestion group that this class queue should be
+ * subscribed to, or NULL if no congestion group membership is desired.
+ *
+ * Returns zero for success, or -EINVAL if @idx is out of range 0 - 7 or
+ * if this class queue has been claimed, or configure class queue command
+ * returns error, or returns -ENOMEM if allocating CQ memory fails.
+ */
+int qman_ceetm_cq_claim(struct qm_ceetm_cq **cq,
+			struct qm_ceetm_channel *channel,
+			unsigned int idx,
+			struct qm_ceetm_ccg *ccg);
+
+/**
+ * qman_ceetm_cq_claim_A - Claims a class queue group A.
+ * @cq: the returned class queue object, if successful.
+ * @channel: the class queue channel.
+ * @idx: is from 8 to 15 if only group A exits, otherwise, it is from 8 to 11.
+ * @ccg: represents the class congestion group that this class queue should be
+ * subscribed to, or NULL if no congestion group membership is desired.
+ *
+ * Return zero for success, or -EINVAL if @idx is out the range or if
+ * this class queue has been claimed or configure class queue command returns
+ * error, or returns -ENOMEM if allocating CQ memory fails.
+ */
+int qman_ceetm_cq_claim_A(struct qm_ceetm_cq **cq,
+				struct qm_ceetm_channel *channel,
+				unsigned int idx,
+				struct qm_ceetm_ccg *ccg);
+
+/**
+ * qman_ceetm_cq_claim_B - Claims a class queue group B.
+ * @cq: the returned class queue object, if successful.
+ * @channel: the class queue channel.
+ * @idx: is from 0 to 3 (CQ12 to CQ15).
+ * @ccg: represents the class congestion group that this class queue should be
+ * subscribed to, or NULL if no congestion group membership is desired.
+ *
+ * Return zero for success, or -EINVAL if @idx is out the range or if
+ * this class queue has been claimed or configure class queue command returns
+ * error, or returns -ENOMEM if allocating CQ memory fails.
+ */
+int qman_ceetm_cq_claim_B(struct qm_ceetm_cq **cq,
+				struct qm_ceetm_channel *channel,
+				unsigned int idx,
+				struct qm_ceetm_ccg *ccg);
+
+/**
+ * qman_ceetm_cq_release - Releases a previously claimed class queue.
+ * @cq: The class queue to be released.
+ *
+ * Return zero for success, or -EBUSY if the dependent objects (eg. logical
+ * FQIDs) have not been released.
+ */
+int qman_ceetm_cq_release(struct qm_ceetm_cq *cq);
+
+/**
+ * qman_ceetm_set_queue_weight
+ * qman_ceetm_get_queue_weight - Configure/query the weight of a grouped class
+ * queue.
+ * @cq: the given class queue.
+ * @weight_code: the desired weight code to set for the given class queue for
+ * "set" function or the queired weight code for "get" function.
+ *
+ * Grouped class queues have a default weight code of zero, which corresponds to
+ * a scheduler weighting of 1. This function can be used to modify a grouped
+ * class queue to another weight, (Use the helpers qman_ceetm_wbfs2ratio()
+ * and qman_ceetm_ratio2wbfs() to convert between these 'weight_code' values
+ * and the corresponding sharing weight.)
+ *
+ * Returns zero for success, or -EIO if the configure weight command returns
+ * error for "set" function, or -EINVAL if the query command returns
+ * error for "get" function.
+ * See section "CEETM Weighted Scheduling among Grouped Classes" in Reference
+ * Manual for weight and weight code.
+ */
+int qman_ceetm_set_queue_weight(struct qm_ceetm_cq *cq,
+				struct qm_ceetm_weight_code *weight_code);
+int qman_ceetm_get_queue_weight(struct qm_ceetm_cq *cq,
+				struct qm_ceetm_weight_code *weight_code);
+
+/* Weights are encoded using a pseudo-exponential scheme. The weight codes 0,
+ * 32, 64, [...] correspond to weights of 1, 2, 4, [...]. The weights
+ * corresponding to intermediate weight codes are calculated using linear
+ * interpolation on the inverted values. Or put another way, the inverse weights
+ * for each 32nd weight code are 1, 1/2, 1/4, [...], and so the intervals
+ * between these are divided linearly into 32 intermediate values, the inverses
+ * of which form the remaining weight codes.
+ *
+ * The Weighted Bandwidth Fair Scheduling (WBFS) algorithm provides a form of
+ * scheduling within a group of class queues (group A or B). Weights are used to
+ * normalise the class queues to an underlying BFS algorithm where all class
+ * queues are assumed to require "equal bandwidth". So the weights referred to
+ * by the weight codes act as divisors on the size of frames being enqueued. Ie.
+ * one class queue in a group is assigned a weight of 2 whilst the other class
+ * queues in the group keep the default weight of 1, then the WBFS scheduler
+ * will effectively treat all frames enqueued on the weight-2 class queue as
+ * having half the number of bytes they really have. Ie. if all other things are
+ * equal, that class queue would get twice as much bytes-per-second bandwidth as
+ * the others. So weights should be chosen to provide bandwidth ratios between
+ * members of the same class queue group. These weights have no bearing on
+ * behaviour outside that group's WBFS mechanism though.
+ */
+
+/**
+ * qman_ceetm_wbfs2ratio - Given a weight code ('wbfs'), an accurate fractional
+ * representation of the corresponding weight is given (in order to not lose
+ * any precision).
+ * @weight_code: The given weight code in WBFS.
+ * @numerator: the numerator part of the weight computed by the weight code.
+ * @denominator: the denominator part of the weight computed by the weight code
+ *
+ * Returns zero for success or -EINVAL if the given weight code is illegal.
+ */
+int qman_ceetm_wbfs2ratio(unsigned int weight_code,
+			   u32 *numerator,
+			   u32 *denominator);
+/**
+ * qman_ceetm_ratio2wbfs - Given a weight, find the nearest possible weight code
+ * If the user needs to know how close this is, convert the resulting weight
+ * code back to a weight and compare.
+ * @numerator: numerator part of the given weight.
+ * @denominator: denominator part of the given weight.
+ * @weight_code: the weight code computed from the given weight.
+ *
+ * Returns zero for success, or -ERANGE if "numerator/denominator" is outside
+ * the range of weights.
+ */
+int qman_ceetm_ratio2wbfs(u32 numerator,
+			   u32 denominator,
+			   unsigned int *weight_code,
+			   int rounding);
+
+#define QMAN_CEETM_FLAG_CLEAR_STATISTICS_COUNTER	0x1
+/**
+ * qman_ceetm_cq_get_dequeue_statistics - Get the statistics provided by CEETM
+ * CQ counters.
+ * @cq: the given CQ object.
+ * @flags: indicates whether the statistics counter will be cleared after query.
+ * @frame_count: The number of the frames that have been counted since the
+ * counter was cleared last time.
+ * @byte_count: the number of bytes in all frames that have been counted.
+ *
+ * Return zero for success or -EINVAL if query statistics command returns error.
+ *
+ */
+int qman_ceetm_cq_get_dequeue_statistics(struct qm_ceetm_cq *cq, u32 flags,
+					u64 *frame_count, u64 *byte_count);
+
+	/* ---------------------- */
+	/* CEETM :: logical FQIDs */
+	/* ---------------------- */
+/**
+ * qman_ceetm_lfq_claim - Claims an unused logical FQID, associates it with
+ * the given class queue.
+ * @lfq: the returned lfq object, if successful.
+ * @cq: the class queue which needs to claim a LFQID.
+ *
+ * Return zero for success, or -ENODEV if no LFQID is available or -ENOMEM if
+ * allocating memory for lfq fails, or -EINVAL if configuring LFQMT fails.
+ */
+int qman_ceetm_lfq_claim(struct qm_ceetm_lfq **lfq,
+				struct qm_ceetm_cq *cq);
+
+/**
+ * qman_ceetm_lfq_release - Releases a previously claimed logical FQID.
+ * @lfq: the lfq to be released.
+ *
+ * Return zero for success.
+ */
+int qman_ceetm_lfq_release(struct qm_ceetm_lfq *lfq);
+
+/**
+ * qman_ceetm_lfq_set_context
+ * qman_ceetm_lfq_get_context - Set/get the context_a/context_b pair to the
+ * "dequeue context table" associated with the logical FQID.
+ * @lfq: the given logical FQ object.
+ * @context_a: contextA of the dequeue context.
+ * @context_b: contextB of the dequeue context.
+ *
+ * Returns zero for success, or -EINVAL if there is error to set/get the
+ * context pair.
+ */
+int qman_ceetm_lfq_set_context(struct qm_ceetm_lfq *lfq,
+				u64 context_a,
+				u32 context_b);
+int qman_ceetm_lfq_get_context(struct qm_ceetm_lfq *lfq,
+				u64 *context_a,
+				u32 *context_b);
+
+/**
+ * qman_ceetm_create_fq - Initialise a FQ object for the LFQ.
+ * @lfq: the given logic fq.
+ * @fq: the fq object created for the given logic fq.
+ *
+ * The FQ object can be used in qman_enqueue() and qman_enqueue_orp() APIs to
+ * target a logical FQID (and the class queue it is associated with).
+ * Note that this FQ object can only be used for enqueues, and
+ * in the case of qman_enqueue_orp() it can not be used as the 'orp' parameter,
+ * only as 'fq'. This FQ object can not (and shouldn't) be destroyed, it is only
+ * valid as long as the underlying 'lfq' remains claimed. It is the user's
+ * responsibility to ensure that the underlying 'lfq' is not released until any
+ * enqueues to this FQ object have completed. The only field the user needs to
+ * fill in is fq->cb.ern, as that enqueue rejection handler is the callback that
+ * could conceivably be called on this FQ object. This API can be called
+ * multiple times to create multiple FQ objects referring to the same logical
+ * FQID, and any enqueue rejections will respect the callback of the object that
+ * issued the enqueue (and will identify the object via the parameter passed to
+ * the callback too). There is no 'flags' parameter to this API as there is for
+ * qman_create_fq() - the created FQ object behaves as though qman_create_fq()
+ * had been called with the single flag QMAN_FQ_FLAG_NO_MODIFY.
+ *
+ * Returns 0 for success.
+ */
+int qman_ceetm_create_fq(struct qm_ceetm_lfq *lfq, struct qman_fq *fq);
+
+	/* -------------------------------- */
+	/* CEETM :: class congestion groups */
+	/* -------------------------------- */
+
+/**
+ * qman_ceetm_ccg_claim - Claims an unused CCG.
+ * @ccg: the returned CCG object, if successful.
+ * @channel: the given class queue channel
+ * @cscn: the callback function of this CCG.
+ * @cb_ctx: the corresponding context to be used used if state change
+ * notifications are later enabled for this CCG.
+ *
+ * The congestion group is local to the given class queue channel, so only
+ * class queues within the channel can be associated with that congestion group.
+ * The association of class queues to congestion groups occurs  when the class
+ * queues are claimed, see qman_ceetm_cq_claim() and related functions.
+ * Congestion groups are in a "zero" state when initially claimed, and they are
+ * returned to that state when released.
+ *
+ * Return zero for success, or -EINVAL if no CCG in the channel is available.
+ */
+int qman_ceetm_ccg_claim(struct qm_ceetm_ccg **ccg,
+			 struct qm_ceetm_channel *channel,
+			 unsigned int idx,
+			 void (*cscn)(struct qm_ceetm_ccg *,
+				       void *cb_ctx,
+				       int congested),
+			 void *cb_ctx);
+
+/**
+ * qman_ceetm_ccg_release - Releases a previously claimed CCG.
+ * @ccg: the given ccg.
+ *
+ * Returns zero for success, or -EBUSY if the given ccg's dependent objects
+ * (class queues that are associated with the CCG) have not been released.
+ */
+int qman_ceetm_ccg_release(struct qm_ceetm_ccg *ccg);
+
+/* This struct is used to specify attributes for a CCG. The 'we_mask' field
+ * controls which CCG attributes are to be updated, and the remainder specify
+ * the values for those attributes. A CCG counts either frames or the bytes
+ * within those frames, but not both ('mode'). A CCG can optionally cause
+ * enqueues to be rejected, due to tail-drop or WRED, or both (they are
+ * independent options, 'td_en' and 'wr_en_g,wr_en_y,wr_en_r'). Tail-drop can be
+ * level-triggered due to a single threshold ('td_thres') or edge-triggered due
+ * to a "congestion state", but not both ('td_mode'). Congestion state has
+ * distinct entry and exit thresholds ('cs_thres_in' and 'cs_thres_out'), and
+ * notifications can be sent to software the CCG goes in to and out of this
+ * congested state ('cscn_en'). */
+struct qm_ceetm_ccg_params {
+	/* Boolean fields together in a single bitfield struct */
+	struct {
+		/* Whether to count bytes or frames. 1==frames */
+		int mode:1;
+		/* En/disable tail-drop. 1==enable */
+		int td_en:1;
+		/* Tail-drop on congestion-state or threshold. 1=threshold */
+		int td_mode:1;
+		/* Generate congestion state change notifications. 1==enable */
+		int cscn_en:1;
+		/* Enable WRED rejections (per colour). 1==enable */
+		int wr_en_g:1;
+		int wr_en_y:1;
+		int wr_en_r:1;
+	} __packed;
+	/* Tail-drop threshold. See qm_cgr_thres_[gs]et64(). */
+	struct qm_cgr_cs_thres td_thres;
+	/* Congestion state thresholds, for entry and exit. */
+	struct qm_cgr_cs_thres cs_thres_in;
+	struct qm_cgr_cs_thres cs_thres_out;
+	/* Overhead accounting length. Per-packet "tax", from -128 to +127 */
+	signed char oal;
+	/* Congestion state change notification for DCP portal, virtual CCGID*/
+	/* WRED parameters. */
+	struct qm_cgr_wr_parm wr_parm_g;
+	struct qm_cgr_wr_parm wr_parm_y;
+	struct qm_cgr_wr_parm wr_parm_r;
+};
+/* Bits used in 'we_mask' to qman_ceetm_ccg_set(), controls which attributes of
+ * the CCGR are to be updated. */
+#define QM_CCGR_WE_CDV		0x0000 /* cdv */
+#define QM_CCGR_WE_MODE         0x0001 /* mode (bytes/frames) */
+#define QM_CCGR_WE_CS_THRES_IN  0x0002 /* congestion state entry threshold */
+#define QM_CCGR_WE_TD_EN        0x0004 /* congestion state tail-drop enable */
+#define QM_CCGR_WE_CSCN_TUPD	0x0008 /* CSCN target update */
+#define QM_CCGR_WE_CSCN_EN      0x0010 /* congestion notification enable */
+#define QM_CCGR_WE_WR_EN_R      0x0020 /* WRED enable - red */
+#define QM_CCGR_WE_WR_EN_Y      0x0040 /* WRED enable - yellow */
+#define QM_CCGR_WE_WR_EN_G      0x0080 /* WRED enable - green */
+#define QM_CCGR_WE_WR_PARM_R    0x0100 /* WRED parameters - red */
+#define QM_CCGR_WE_WR_PARM_Y    0x0200 /* WRED parameters - yellow */
+#define QM_CCGR_WE_WR_PARM_G    0x0400 /* WRED parameters - green */
+#define QM_CCGR_WE_OAL          0x0800 /* overhead accounting length */
+#define QM_CCGR_WE_CS_THRES_OUT 0x1000 /* congestion state exit threshold */
+#define QM_CCGR_WE_TD_THRES     0x2000 /* tail-drop threshold */
+#define QM_CCGR_WE_TD_MODE      0x4000 /* tail-drop mode (state/threshold) */
+
+/**
+ * qman_ceetm_ccg_set
+ * qman_ceetm_ccg_get - Configure/query a subset of CCG attributes.
+ * @ccg: the given CCG object.
+ * @we_mask: the write enable mask.
+ * @params: the parameters setting for this ccg
+ *
+ * Return 0 for success, or -EIO if configure ccg command returns error for
+ * "set" function, or -EINVAL if query ccg command returns error for "get"
+ * function.
+ */
+int qman_ceetm_ccg_set(struct qm_ceetm_ccg *ccg,
+			u16 we_mask,
+			const struct qm_ceetm_ccg_params *params);
+int qman_ceetm_ccg_get(struct qm_ceetm_ccg *ccg,
+			struct qm_ceetm_ccg_params *params);
+
+/** qman_ceetm_cscn_swp_set - Add or remove a software portal from the target
+ * mask.
+ * qman_ceetm_cscn_swp_get - Query whether a given software portal index is
+ * in the cscn target mask.
+ * @ccg: the give CCG object.
+ * @swp_idx: the index of the software portal.
+ * @cscn_enabled: 1: Set the swp to be cscn target. 0: remove the swp from
+ * the target mask.
+ * @we_mask: the write enable mask.
+ * @params: the parameters setting for this ccg
+ *
+ * Return 0 for success, or -EINVAL if command in set/get function fails.
+ */
+int qman_ceetm_cscn_swp_set(struct qm_ceetm_ccg *ccg,
+				u16 swp_idx,
+				unsigned int cscn_enabled,
+				u16 we_mask,
+				const struct qm_ceetm_ccg_params *params);
+int qman_ceetm_cscn_swp_get(struct qm_ceetm_ccg *ccg,
+				u16 swp_idx,
+				unsigned int *cscn_enabled);
+
+/** qman_ceetm_cscn_dcp_set - Add or remove a direct connect portal from the\
+ * target mask.
+ * qman_ceetm_cscn_swp_get - Query whether a given direct connect portal index
+ * is in the cscn target mask.
+ * @ccg: the give CCG object.
+ * @dcp_idx: the index of the direct connect portal.
+ * @vcgid: congestion state change notification for dcp portal, virtual CGID.
+ * @cscn_enabled: 1: Set the dcp to be cscn target. 0: remove the dcp from
+ * the target mask.
+ * @we_mask: the write enable mask.
+ * @params: the parameters setting for this ccg
+ *
+ * Return 0 for success, or -EINVAL if command in set/get function fails.
+  */
+int qman_ceetm_cscn_dcp_set(struct qm_ceetm_ccg *ccg,
+				u16 dcp_idx,
+				u8 vcgid,
+				unsigned int cscn_enabled,
+				u16 we_mask,
+				const struct qm_ceetm_ccg_params *params);
+int qman_ceetm_cscn_dcp_get(struct qm_ceetm_ccg *ccg,
+				u16 dcp_idx,
+				u8 *vcgid,
+				unsigned int *cscn_enabled);
+
+/**
+ * qman_ceetm_ccg_get_reject_statistics - Get the statistics provided by
+ * CEETM CCG counters.
+ * @ccg: the given CCG object.
+ * @flags: indicates whether the statistics counter will be cleared after query.
+ * @frame_count: The number of the frames that have been counted since the
+ * counter was cleared last time.
+ * @byte_count: the number of bytes in all frames that have been counted.
+ *
+ * Return zero for success or -EINVAL if query statistics command returns error.
+ *
+ */
+int qman_ceetm_ccg_get_reject_statistics(struct qm_ceetm_ccg *ccg, u32 flags,
+					u64 *frame_count, u64 *byte_count);
 #ifdef __cplusplus
 }
 #endif
-- 
1.7.9.7

