From e71cf2e606b9e9f0ab6dc098c6f8876f248bd8c1 Mon Sep 17 00:00:00 2001
From: Hai-Ying Wang <Haiying.Wang@freescale.com>
Date: Thu, 5 Jul 2012 03:14:56 +0000
Subject: [PATCH 006/227] qman: remove "enum qm_channel"

Qman channel numbers vary in different qman versions, we can no longer use the
enum to define them.  This patch removes the enum qm_channel and adds the
relevant changes.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Signed-off-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_pme2/pme2_high.c     |    6 ++--
 drivers/staging/fsl_qbman/qman_config.c  |   15 +++++----
 drivers/staging/fsl_qbman/qman_debugfs.c |    2 +-
 drivers/staging/fsl_qbman/qman_driver.c  |   16 +++++++++-
 drivers/staging/fsl_qbman/qman_high.c    |    6 ++--
 drivers/staging/fsl_qbman/qman_private.h |    4 +--
 include/linux/fsl_pme.h                  |    4 +--
 include/linux/fsl_qman.h                 |   49 ++++++++++++------------------
 8 files changed, 52 insertions(+), 50 deletions(-)

diff --git a/drivers/staging/fsl_pme2/pme2_high.c b/drivers/staging/fsl_pme2/pme2_high.c
index 4c8a3e6..111686b 100644
--- a/drivers/staging/fsl_pme2/pme2_high.c
+++ b/drivers/staging/fsl_pme2/pme2_high.c
@@ -189,7 +189,7 @@ static int park(struct qman_fq *fq, struct qm_mcc_initfq *initfq)
 }
 
 static inline int reconfigure_rx(struct pme_ctx *ctx, int to_park, u8 qosout,
-				enum qm_channel dest,
+				u16 dest,
 				const struct qm_fqd_stashing *stashing)
 {
 	struct qm_mcc_initfq initfq;
@@ -251,7 +251,7 @@ static int empty_pipeline(struct pme_ctx *ctx, __maybe_unused u32 flags)
 }
 
 int pme_ctx_init(struct pme_ctx *ctx, u32 flags, u32 bpid, u8 qosin,
-			u8 qosout, enum qm_channel dest,
+			u8 qosout, u16 dest,
 			const struct qm_fqd_stashing *stashing)
 {
 	int rxinit = 0, ret = -ENOMEM, fqin_inited = 0;
@@ -468,7 +468,7 @@ int pme_ctx_reconfigure_tx(struct pme_ctx *ctx, u32 bpid, u8 qosin)
 EXPORT_SYMBOL(pme_ctx_reconfigure_tx);
 
 int pme_ctx_reconfigure_rx(struct pme_ctx *ctx, u8 qosout,
-		enum qm_channel dest, const struct qm_fqd_stashing *stashing)
+		u16 dest, const struct qm_fqd_stashing *stashing)
 {
 	return reconfigure_rx(ctx, 1, qosout, dest, stashing);
 }
diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index a13de15..fa3eb69 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -299,14 +299,13 @@ static void qm_set_default_wq(struct qman *qm, u16 wqid)
 	qm_out(WQ_DEF_ENC_WQID, wqid);
 }
 
-static void qm_set_channel_ddebug(struct qman *qm, enum qm_channel channel,
-				u16 tp_cfg)
+static void qm_set_channel_ddebug(struct qman *qm, u16 channel, u16 tp_cfg)
 {
 	u32 offset;
 	int upperhalf = 0;
-	if ((channel >= qm_channel_swportal0) &&
+	if ((channel >= QM_CHANNEL_SWPORTAL0) &&
 				(channel <= qm_channel_swportal9)) {
-		offset = (channel - qm_channel_swportal0);
+		offset = (channel - QM_CHANNEL_SWPORTAL0);
 		upperhalf = offset & 0x1;
 		offset = REG_WQ_SC_DD_CFG(offset / 2);
 	} else if ((channel >= qm_channel_pool1) &&
@@ -828,12 +827,12 @@ int qman_init_ccsr(struct device_node *node)
 }
 
 #define PID_CFG_LIODN_MASK 0x0fff0000
-void qman_liodn_fixup(enum qm_channel channel)
+void qman_liodn_fixup(u16 channel)
 {
 	static int done;
 	static u32 liodn_offset;
 	u32 before, after;
-	int idx = channel - qm_channel_swportal0;
+	int idx = channel - QM_CHANNEL_SWPORTAL0;
 
 	if (!qman_have_ccsr())
 		return;
@@ -848,9 +847,9 @@ void qman_liodn_fixup(enum qm_channel channel)
 }
 
 #define IO_CFG_SDEST_MASK 0x00ff0000
-int qman_set_sdest(enum qm_channel channel, unsigned int cpu_idx)
+int qman_set_sdest(u16 channel, unsigned int cpu_idx)
 {
-	int idx = channel - qm_channel_swportal0;
+	int idx = channel - QM_CHANNEL_SWPORTAL0;
 	u32 before, after;
 
 	if (!qman_have_ccsr())
diff --git a/drivers/staging/fsl_qbman/qman_debugfs.c b/drivers/staging/fsl_qbman/qman_debugfs.c
index 67fa240..f40a96f 100644
--- a/drivers/staging/fsl_qbman/qman_debugfs.c
+++ b/drivers/staging/fsl_qbman/qman_debugfs.c
@@ -416,7 +416,7 @@ struct query_wq_lengths_data_s {
 	union {
 		u16 channel_wq; /* ignores wq (3 lsbits) */
 		struct {
-			u16 id:13; /* enum qm_channel */
+			u16 id:13; /* qm_channel */
 			u16 __reserved:3;
 		} __packed channel;
 	};
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index 83a6563..e11fab4 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -36,6 +36,12 @@
  * where CCSR isn't available) */
 u16 qman_ip_rev;
 EXPORT_SYMBOL(qman_ip_rev);
+u16 qm_channel_pool1;
+EXPORT_SYMBOL(qm_channel_pool1);
+u16 qm_channel_caam = QMAN_CHANNEL_CAAM;
+EXPORT_SYMBOL(qm_channel_caam);
+u16 qm_channel_pme = QMAN_CHANNEL_PME;
+EXPORT_SYMBOL(qm_channel_pme);
 
 /* size of the fqd region in bytes */
 #ifdef CONFIG_FSL_QMAN_FQ_LOOKUP
@@ -89,6 +95,7 @@ static __init int fsl_pool_channel_range_sdqcr(struct device_node *node)
 		pr_err(STR_ERR_CELL, STR_POOL_CHAN_RANGE, 1, node->full_name);
 		return -EINVAL;
 	}
+	qm_channel_pool1 = chanid[0];
 	for (ret = 0; ret < chanid[1]; ret++)
 		pools_sdqcr |= QM_SDQCR_CHANNELS_POOL_CONV(chanid[0] + ret);
 	return 0;
@@ -108,6 +115,7 @@ static __init int fsl_pool_channel_range_init(struct device_node *node)
 		return -EINVAL;
 	}
 	qman_release_pool_range(chanid[0], chanid[1]);
+	qm_channel_pool1 = chanid[0];
 	pr_info("Qman: pool channel allocator includes range %d:%d\n",
 		chanid[0], chanid[1]);
 	return 0;
@@ -179,6 +187,12 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 		pr_warning("Revision=0x%04x, but portal '%s' has 0x%04x\n",
 			qman_ip_rev, node->full_name, ip_rev);
 
+	if ((qman_ip_rev & 0xff00) >= QMAN_REV30)
+	{
+		qm_channel_caam = QMAN_CHANNEL_CAAM_REV3;;
+		qm_channel_pme = QMAN_CHANNEL_PME_REV3;
+	}
+
 	ret = of_address_to_resource(node, DPA_PORTAL_CE,
 				&pcfg->addr_phys[DPA_PORTAL_CE]);
 	if (ret) {
@@ -205,7 +219,7 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 			"fsl,qman-channel-id");
 		goto err;
 	}
-	if (*channel != (*index + qm_channel_swportal0))
+	if (*channel != (*index + QM_CHANNEL_SWPORTAL0))
 		pr_err("Warning: node %s has mismatched %s and %s\n",
 			node->full_name, "cell-index", "fsl,qman-channel-id");
 	pcfg->public_cfg.channel = *channel;
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 8344a9e..a762ae9 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -132,7 +132,7 @@ static qman_cb_dc_ern cb_dc_ern;
 
 static cpumask_t affine_mask;
 static DEFINE_SPINLOCK(affine_mask_lock);
-static enum qm_channel affine_channels[NR_CPUS];
+static u16 affine_channels[NR_CPUS];
 static DEFINE_PER_CPU(struct qman_portal, qman_affine_portal);
 
 struct qman_portal *per_cpu_affine_portal(int cpu)
@@ -914,7 +914,7 @@ const cpumask_t *qman_affine_cpus(void)
 }
 EXPORT_SYMBOL(qman_affine_cpus);
 
-enum qm_channel qman_affine_channel(int cpu)
+u16 qman_affine_channel(int cpu)
 {
 	if (cpu < 0) {
 		struct qman_portal *portal = get_raw_affine_portal();
@@ -2004,7 +2004,7 @@ int qman_modify_cgr(struct qman_cgr *cgr, u32 flags,
 EXPORT_SYMBOL(qman_modify_cgr);
 
 #define TARG_MASK(n) (0x80000000 >> (n->config->public_cfg.channel - \
-					qm_channel_swportal0))
+					QM_CHANNEL_SWPORTAL0))
 
 int qman_create_cgr(struct qman_cgr *cgr, u32 flags,
 			struct qm_mcc_initcgr *opts)
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index 2880319..abb62db 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -133,8 +133,8 @@ extern u16 qman_ip_rev; /* 0 if uninitialised, otherwise QMAN_REVx */
 #ifdef CONFIG_FSL_QMAN_CONFIG
 /* Hooks from qman_driver.c to qman_config.c */
 int qman_init_ccsr(struct device_node *node);
-void qman_liodn_fixup(enum qm_channel channel);
-int qman_set_sdest(enum qm_channel channel, unsigned int cpu_idx);
+void qman_liodn_fixup(u16 channel);
+int qman_set_sdest(u16 channel, unsigned int cpu_idx);
 #endif
 
 /* Hooks from qman_driver.c in to qman_high.c */
diff --git a/include/linux/fsl_pme.h b/include/linux/fsl_pme.h
index 085dd74..6e87241 100644
--- a/include/linux/fsl_pme.h
+++ b/include/linux/fsl_pme.h
@@ -547,7 +547,7 @@ struct pme_ctx {
  * Returns 0 on success.
  */
 int pme_ctx_init(struct pme_ctx *ctx, u32 flags, u32 bpid, u8 qosin,
-			u8 qosout, enum qm_channel dest,
+			u8 qosout, u16 dest,
 			const struct qm_fqd_stashing *stashing);
 
 /* Cleanup allocated resources */
@@ -578,7 +578,7 @@ int pme_ctx_is_dead(struct pme_ctx *ctx);
  */
 int pme_ctx_reconfigure_tx(struct pme_ctx *ctx, u32 bpid, u8 qosin);
 int pme_ctx_reconfigure_rx(struct pme_ctx *ctx, u8 qosout,
-		enum qm_channel dest, const struct qm_fqd_stashing *stashing);
+		u16 dest, const struct qm_fqd_stashing *stashing);
 
 /* Precondition: pme_ctx must be enabled
  * if PME_CTX_OP_WAIT is specified, it'll wait (if it has to) to start the ctrl
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 75105ad..a5e9308 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -39,27 +39,14 @@ extern "C" {
 /* Last updated for v00.800 of the BG */
 
 /* Hardware constants */
-enum qm_channel {
-	qm_channel_swportal0 = 0, qm_channel_swportal1, qm_channel_swportal2,
-	qm_channel_swportal3, qm_channel_swportal4, qm_channel_swportal5,
-	qm_channel_swportal6, qm_channel_swportal7, qm_channel_swportal8,
-	qm_channel_swportal9,
-	qm_channel_pool1 = 0x21, qm_channel_pool2, qm_channel_pool3,
-	qm_channel_pool4, qm_channel_pool5, qm_channel_pool6,
-	qm_channel_pool7, qm_channel_pool8, qm_channel_pool9,
-	qm_channel_pool10, qm_channel_pool11, qm_channel_pool12,
-	qm_channel_pool13, qm_channel_pool14, qm_channel_pool15,
-	qm_channel_fman0_sp0 = 0x40, qm_channel_fman0_sp1, qm_channel_fman0_sp2,
-	qm_channel_fman0_sp3, qm_channel_fman0_sp4, qm_channel_fman0_sp5,
-	qm_channel_fman0_sp6, qm_channel_fman0_sp7, qm_channel_fman0_sp8,
-	qm_channel_fman0_sp9, qm_channel_fman0_sp10, qm_channel_fman0_sp11,
-	qm_channel_fman1_sp0 = 0x60, qm_channel_fman1_sp1, qm_channel_fman1_sp2,
-	qm_channel_fman1_sp3, qm_channel_fman1_sp4, qm_channel_fman1_sp5,
-	qm_channel_fman1_sp6, qm_channel_fman1_sp7, qm_channel_fman1_sp8,
-	qm_channel_fman1_sp9, qm_channel_fman1_sp10, qm_channel_fman1_sp11,
-	qm_channel_caam = 0x80,
-	qm_channel_pme = 0xa0,
-};
+#define QM_CHANNEL_SWPORTAL0 0
+#define QMAN_CHANNEL_CAAM 0x80
+#define QMAN_CHANNEL_PME 0xa0
+#define QMAN_CHANNEL_CAAM_REV3 0x840
+#define QMAN_CHANNEL_PME_REV3 0x860
+extern u16 qm_channel_pool1;
+extern u16 qm_channel_caam;
+extern u16 qm_channel_pme;
 enum qm_dc_portal {
 	qm_dc_portal_fman0 = 0,
 	qm_dc_portal_fman1 = 1,
@@ -82,9 +69,11 @@ enum qm_dc_portal {
 #define QM_SDQCR_CHANNELS_POOL_MASK	0x00007fff
 /* for n in [1,15] */
 #define QM_SDQCR_CHANNELS_POOL(n)	(0x00008000 >> (n))
-/* for conversion from n of type "enum qm_channel" */
-#define QM_SDQCR_CHANNELS_POOL_CONV(c) \
-	QM_SDQCR_CHANNELS_POOL((c) + 1 - qm_channel_pool1)
+/* for conversion from n of qm_channel */
+static inline u32 QM_SDQCR_CHANNELS_POOL_CONV(u16 channel)
+{
+	return QM_SDQCR_CHANNELS_POOL(channel + 1 - qm_channel_pool1);
+}
 
 /* For qman_volatile_dequeue(); Choose one PRECEDENCE. EXACT is optional. Use
  * NUMFRAMES(n) (6-bit) or NUMFRAMES_TILLEMPTY to fill in the frame-count. Use
@@ -407,7 +396,7 @@ struct qm_fqd {
 	union {
 		u16 dest_wq;
 		struct {
-			u16 channel:13; /* enum qm_channel */
+			u16 channel:13; /* qm_channel */
 			u16 wq:3;
 		} __packed dest;
 	};
@@ -654,7 +643,7 @@ struct qm_mcc_querywq {
 	union {
 		u16 channel_wq; /* ignores wq (3 lsbits) */
 		struct {
-			u16 id:13; /* enum qm_channel */
+			u16 id:13; /* qm_channel */
 			u16 __reserved1:3;
 		} __packed channel;
 	};
@@ -846,7 +835,7 @@ struct qm_mcr_querywq {
 	union {
 		u16 channel_wq; /* ignores wq (3 lsbits) */
 		struct {
-			u16 id:13; /* enum qm_channel */
+			u16 id:13; /* qm_channel */
 			u16 __reserved:3;
 		} __packed channel;
 	};
@@ -974,7 +963,7 @@ struct qman_portal_config {
 	int is_shared;
 	/* The portal's dedicated channel id, use this value for initialising
 	 * frame queues to target this portal when scheduled. */
-	enum qm_channel channel;
+	u16 channel;
 	/* A mask of which pool channels this portal has dequeue access to
 	 * (using QM_SDQCR_CHANNELS_POOL(n) for the bitmask) */
 	u32 pools;
@@ -1091,7 +1080,7 @@ struct qman_cgr {
 	u32 cgrid; /* 0..255, but u32 to allow specials like -1, 256, etc.*/
 	qman_cb_cgr cb;
 	/* These are private to the driver */
-	enum qm_channel chan; /* portal channel this object is created on */
+	u16 chan; /* portal channel this object is created on */
 	struct list_head node;
 };
 
@@ -1214,7 +1203,7 @@ const cpumask_t *qman_affine_cpus(void);
  * bug to call this function for any value of @cpu (other than -1) that is not a
  * member of the mask returned from qman_affine_cpus().
  */
-enum qm_channel qman_affine_channel(int cpu);
+u16 qman_affine_channel(int cpu);
 
 /**
  * qman_poll_dqrr - process DQRR (fast-path) entries
-- 
1.7.9.7

