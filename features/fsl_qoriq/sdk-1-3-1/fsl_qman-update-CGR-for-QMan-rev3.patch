From 82daf92462d9c9b8c548f697fc36281a1efddb0d Mon Sep 17 00:00:00 2001
From: Hai-Ying Wang <Haiying.Wang@freescale.com>
Date: Wed, 5 Dec 2012 10:42:56 +0000
Subject: [PATCH 220/227] fsl_qman: update CGR for QMan rev3

QMan rev3 use cscn_targ_upd_ctrl filed to control the CSCN singal to send
whether to SWP or DCP.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
[Kevin: Original patch taken from fsl sdk 1.3.1
QorIQ-SDK-V1.3.1-SOURCE-20121220-yocto.iso.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/qman_debugfs.c |   26 +++++++++++++-
 drivers/staging/fsl_qbman/qman_high.c    |   56 ++++++++++++++++++++++++++++--
 include/linux/fsl_qman.h                 |   26 ++++++++++++--
 3 files changed, 102 insertions(+), 6 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_debugfs.c b/drivers/staging/fsl_qbman/qman_debugfs.c
index 5b63036..1e96820 100644
--- a/drivers/staging/fsl_qbman/qman_debugfs.c
+++ b/drivers/staging/fsl_qbman/qman_debugfs.c
@@ -482,6 +482,8 @@ static int query_cgr_show(struct seq_file *file, void *offset)
 	int ret;
 	struct qm_mcr_querycgr cgrd;
 	struct qman_cgr cgr;
+	int i, j;
+	u32 mask;
 
 	memset(&cgr, 0, sizeof(struct qm_mcr_querycgr));
 	cgr.cgrid = query_cgr_data.cgid;
@@ -508,7 +510,29 @@ static int query_cgr_show(struct seq_file *file, void *offset)
 		cgrd.cgr.wr_en_g, cgrd.cgr.wr_en_y, cgrd.cgr.wr_en_r);
 
 	seq_printf(file, " cscn_en: %u\n", cgrd.cgr.cscn_en);
-	seq_printf(file, " cscn_targ: %u\n", cgrd.cgr.cscn_targ);
+	if ((qman_ip_rev & 0xFF00) >= QMAN_REV30) {
+		seq_printf(file, " cscn_targ_dcp:\n");
+		mask = 0x80000000;
+		for (i = 0; i < 32; i++) {
+			if (cgrd.cgr.cscn_targ & mask)
+				seq_printf(file, "  send CSCN to dcp %u\n",
+								(31 - i));
+			mask >>= 1;
+		}
+
+		seq_printf(file, " cscn_targ_swp:\n");
+		for (i = 0; i < 4; i++) {
+			mask = 0x80000000;
+			for (j = 0; j < 32; j++) {
+				if (cgrd.cscn_targ_swp[i] & mask)
+					seq_printf(file, "  send CSCN to swp"
+						" %u\n", (127 - (i * 32) - j));
+				mask >>= 1;
+			}
+		}
+	} else {
+		seq_printf(file, " cscn_targ: %u\n", cgrd.cgr.cscn_targ);
+	}
 	seq_printf(file, " cstd_en: %u\n", cgrd.cgr.cstd_en);
 	seq_printf(file, " cs: %u\n", cgrd.cgr.cs);
 
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 6a85b90..862bbf4 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -2060,6 +2060,7 @@ EXPORT_SYMBOL(qman_modify_cgr);
 
 #define TARG_MASK(n) (0x80000000 >> (n->config->public_cfg.channel - \
 					QM_CHANNEL_SWPORTAL0))
+#define PORTAL_IDX(n) (n->config->public_cfg.channel - QM_CHANNEL_SWPORTAL0)
 
 int qman_create_cgr(struct qman_cgr *cgr, u32 flags,
 			struct qm_mcc_initcgr *opts)
@@ -2093,8 +2094,13 @@ int qman_create_cgr(struct qman_cgr *cgr, u32 flags,
 		goto release_lock;
 	if (opts)
 		local_opts = *opts;
-	/* Overwrite TARG */
-	local_opts.cgr.cscn_targ = cgr_state.cgr.cscn_targ | TARG_MASK(p);
+	if ((qman_ip_rev & 0xFF00) >= QMAN_REV30)
+		local_opts.cgr.cscn_targ_upd_ctrl =
+			QM_CGR_TARG_UDP_CTRL_WRITE_BIT | PORTAL_IDX(p);
+	else
+		/* Overwrite TARG */
+		local_opts.cgr.cscn_targ = cgr_state.cgr.cscn_targ |
+							TARG_MASK(p);
 	local_opts.we_mask |= QM_CGR_WE_CSCN_TARG;
 
 	/* send init if flags indicate so */
@@ -2126,6 +2132,45 @@ release_lock:
 }
 EXPORT_SYMBOL(qman_create_cgr);
 
+int qman_create_cgr_to_dcp(struct qman_cgr *cgr, u32 flags, u16 dcp_portal,
+					struct qm_mcc_initcgr *opts)
+{
+	unsigned long irqflags __maybe_unused;
+	struct qm_mcc_initcgr local_opts;
+	int ret;
+
+	if ((qman_ip_rev & 0xFF00) < QMAN_REV30) {
+		pr_warning("This QMan version doesn't support to send CSCN to"
+						" DCP portal\n");
+		return -EINVAL;
+	}
+	/* We have to check that the provided CGRID is within the limits of the
+	 * data-structures, for obvious reasons. However we'll let h/w take
+	 * care of determining whether it's within the limits of what exists on
+	 * the SoC.
+	 */
+	if (cgr->cgrid >= __CGR_NUM)
+		return -EINVAL;
+
+	memset(&local_opts, 0, sizeof(struct qm_mcc_initcgr));
+	if (opts)
+		local_opts = *opts;
+
+	local_opts.cgr.cscn_targ_upd_ctrl = QM_CGR_TARG_UDP_CTRL_WRITE_BIT |
+				QM_CGR_TARG_UDP_CTRL_DCP | dcp_portal;
+	local_opts.we_mask |= QM_CGR_WE_CSCN_TARG;
+
+	/* send init if flags indicate so */
+	if (opts && (flags & QMAN_CGR_FLAG_USE_INIT))
+		ret = qman_modify_cgr(cgr, QMAN_CGR_FLAG_USE_INIT,
+							&local_opts);
+	else
+		ret = qman_modify_cgr(cgr, 0, &local_opts);
+
+	return ret;
+}
+EXPORT_SYMBOL(qman_create_cgr_to_dcp);
+
 int qman_delete_cgr(struct qman_cgr *cgr)
 {
 	unsigned long irqflags __maybe_unused;
@@ -2155,7 +2200,12 @@ int qman_delete_cgr(struct qman_cgr *cgr)
 	}
 	/* Overwrite TARG */
 	local_opts.we_mask = QM_CGR_WE_CSCN_TARG;
-	local_opts.cgr.cscn_targ = cgr_state.cgr.cscn_targ & ~(TARG_MASK(p));
+	if ((qman_ip_rev & 0xFF00) >= QMAN_REV30)
+		local_opts.cgr.cscn_targ_upd_ctrl =
+			~QM_CGR_TARG_UDP_CTRL_WRITE_BIT | PORTAL_IDX(p);
+	else
+		local_opts.cgr.cscn_targ = cgr_state.cgr.cscn_targ &
+							 ~(TARG_MASK(p));
 	ret = qman_modify_cgr(cgr, 0, &local_opts);
 	if (ret)
 		/* add back to the list */
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 7c5bd8f..ae7f6cc 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -565,13 +565,21 @@ struct __qm_mc_cgr {
 	u8 wr_en_y;	/* boolean, use QM_CGR_EN */
 	u8 wr_en_r;	/* boolean, use QM_CGR_EN */
 	u8 cscn_en;	/* boolean, use QM_CGR_EN */
-	u32 cscn_targ;	/* use QM_CGR_TARG_* */
+	union {
+		struct {
+			u16 cscn_targ_upd_ctrl; /* use QM_CSCN_TARG_UDP_ */
+			u16 cscn_targ_dcp_low;  /* CSCN_TARG_DCP low-16bits */
+		};
+		u32 cscn_targ;	/* use QM_CGR_TARG_* */
+	};
 	u8 cstd_en;	/* boolean, use QM_CGR_EN */
 	u8 cs;		/* boolean, only used in query response */
 	struct qm_cgr_cs_thres cs_thres; /* use qm_cgr_cs_thres_set64() */
 	u8 mode;	/* QMAN_CGR_MODE_FRAME not supported in rev1.0 */
 } __packed;
 #define QM_CGR_EN		0x01 /* For wr_en_*, cscn_en, cstd_en */
+#define QM_CGR_TARG_UDP_CTRL_WRITE_BIT	0x8000 /* value written to portal bit*/
+#define QM_CGR_TARG_UDP_CTRL_DCP	0x4000 /* 0: SWP, 1: DCP */
 #define QM_CGR_TARG_PORTAL(n)	(0x80000000 >> (n)) /* s/w portal, 0-9 */
 #define QM_CGR_TARG_FMAN0	0x00200000 /* direct-connect portal: fman0 */
 #define QM_CGR_TARG_FMAN1	0x00100000 /*                      : fman1 */
@@ -1036,7 +1044,10 @@ struct qm_mcr_querycgr {
 	u32 __reserved4:24;
 	u32 a_bcnt_hi:8;/* high 8-bits of 40-bit "Average" */
 	u32 a_bcnt_lo;	/* low 32-bits of 40-bit */
-	u8 __reserved5[16];
+	union {
+		u32 cscn_targ_swp[4];
+		u8 __reserved5[16];
+	};
 } __packed;
 static inline u64 qm_mcr_querycgr_i_get64(const struct qm_mcr_querycgr *q)
 {
@@ -2144,6 +2155,17 @@ int qman_create_cgr(struct qman_cgr *cgr, u32 flags,
 			struct qm_mcc_initcgr *opts);
 
 /**
+ * qman_create_cgr_to_dcp - Register a congestion group object to DCP portal
+ * @cgr: the 'cgr' object, with fields filled in
+ * @flags: QMAN_CGR_FLAG_* values
+ * @dcp_portal: the DCP portal to which the cgr object is registered.
+ * @opts: optional state of CGR settings
+ *
+ */
+int qman_create_cgr_to_dcp(struct qman_cgr *cgr, u32 flags, u16 dcp_portal,
+				struct qm_mcc_initcgr *opts);
+
+/**
  * qman_delete_cgr - Deregisters a congestion group object
  * @cgr: the 'cgr' object to deregister
  *
-- 
1.7.9.7

