From 2391fcfa12228d537c924700dd0629220ae4b129 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Wed, 18 Apr 2012 17:05:26 +0300
Subject: [PATCH 15/27] gianfar: Fix RXICr/TXICr programming for MQ_MG_MODE
 (VeTSEC)

The correct behavior is to program the interrupt coalescing regs
(RXICr/TXICr) in accordance with the corresponding Rx/Tx Q's
[rx|tx]coalescing flags. That is, if the coalescing flag is 0,
for a given rx/tx queue, then the corresponding coalescing
register should be cleared.
This behavior is correctly implemented for SQ_SG_MODE, but not
for MQ_MG_MODE (VeTSECs). This fixes MQ_MG_MODE implementation.

Coalescing is enabled via "ethtool -C", by setting [rx|tx]-usecs
and [rx|tx]-frames params to valid non-zero values. If either
of these params is set to 0, then coalescing is disabled.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   16 ++++++----------
 1 file changed, 6 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index ea1f274..873e1c3 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -2328,13 +2328,11 @@ void gfar_configure_tx_coalescing(struct gfar_private *priv,
 	if (priv->mode == MQ_MG_MODE) {
 		baddr = &regs->txic0;
 		for (i = 0; i < priv->num_tx_queues; i++) {
-			if (tx_mask & mask) {
-				if (likely(priv->tx_queue[i]->txcoalescing)) {
-					gfar_write(baddr + i, 0);
+			gfar_write(baddr + i, 0);
+			if (tx_mask & mask)
+				if (likely(priv->tx_queue[i]->txcoalescing))
 					gfar_write(baddr + i,
 						 priv->tx_queue[i]->txic);
-				}
-			}
 			mask = mask << 0x1;
 		}
 	}
@@ -2359,13 +2357,11 @@ void gfar_configure_rx_coalescing(struct gfar_private *priv,
 	if (priv->mode == MQ_MG_MODE) {
 		baddr = &regs->rxic0;
 		for (i = 0; i < priv->num_rx_queues; i++) {
-			if (rx_mask & mask) {
-				if (likely(priv->rx_queue[i]->rxcoalescing)) {
-					gfar_write(baddr + i, 0);
+			gfar_write(baddr + i, 0);
+			if (rx_mask & mask)
+				if (likely(priv->rx_queue[i]->rxcoalescing))
 					gfar_write(baddr + i,
 						priv->rx_queue[i]->rxic);
-				}
-			}
 			mask = mask << 0x1;
 		}
 	}
-- 
1.7.9.7

