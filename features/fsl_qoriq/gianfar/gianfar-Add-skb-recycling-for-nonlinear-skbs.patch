From 63f50968f536d863b533f62b726f8bc58a9623c1 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Tue, 3 Apr 2012 21:55:27 +0000
Subject: [PATCH 07/27] gianfar: Add skb recycling for nonlinear skbs

Enable skb recycling for nonlinear skbs,
in case the size of contiguous buffer in skb is large
enough to allow recycling. The basic use case is TSO,
when the driver allocates new skbs and then it can add
fragments to the new skb. In this case, skb_is_recycleable()
returns false because skb is not linear.

Signed-off-by: Elena Tebesoi <elena.tebesoi@freescale.com>
Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   48 +++++++++++++++++++++++++++---
 1 file changed, 44 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index f93bb33..7c2f174 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -3032,6 +3032,20 @@ static struct sk_buff * gfar_alloc_skb(struct net_device *dev)
 	return skb;
 }
 
+static inline bool gfar_skb_nonlinear_recycleable(struct sk_buff *skb,
+		int skb_size)
+{
+	if (!skb_is_nonlinear(skb))
+		return false;
+
+	/* True size allocated for an skb */
+	if (skb->truesize != SKB_DATA_ALIGN(skb_size + NET_SKB_PAD)
+				+ sizeof(struct sk_buff))
+		return false;
+
+	return true;
+}
+
 static void gfar_free_skb(struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
@@ -3040,15 +3054,41 @@ static void gfar_free_skb(struct sk_buff *skb)
 	struct gfar_recycle_cntxt *recycle_cntxt;
 	struct gfar_recycle_cntxt_percpu *local;
 	unsigned long flags;
-	int cpu;
+	int cpu, skb_size;
 
+	skb_size = priv->rx_buffer_size + RXBUF_ALIGNMENT;
 	recycle_cntxt = priv->recycle;
 
-	if (!skb_recycle_check(skb, priv->rx_buffer_size + RXBUF_ALIGNMENT)) {
-		dev_kfree_skb_any(skb);
-		return;
+	if (!skb_is_recycleable(skb, skb_size)) {
+		if (!gfar_skb_nonlinear_recycleable(skb, skb_size)) {
+			dev_kfree_skb_any(skb);
+			return;
+		}
+
+		/*
+		 * skb was alocated in driver, hence the size of
+		 * contiguous buffer in skb is big enough to recycle it for rx.
+		 * Clean first the SKB fragments and test again.
+		 * Possible usecase is TSO, when driver allocates new skb and
+		 * then it can add fragments to new skb. In this case,
+		 * skb_is_recycleable() returns false because skb is not linear.
+		 */
+		if (skb_shinfo(skb)->nr_frags) {
+			int i;
+			for (i = 0; i < skb_shinfo(skb)->nr_frags; i++)
+				put_page(&skb_shinfo(skb)->frags[i].page);
+			skb_shinfo(skb)->nr_frags = 0;
+			skb->data_len = 0;
+		}
+
+		if (!skb_is_recycleable(skb, skb_size)) {
+			dev_kfree_skb_any(skb);
+			return;
+		}
 	}
 
+	skb_recycle(skb);
+
 	cpu = get_cpu();
 	local = per_cpu_ptr(recycle_cntxt->local, cpu);
 	recycle_q = local->recycle_q;
-- 
1.7.9.7

