From 1282c29f06919d30ad0145f86feed7fa81b672ef Mon Sep 17 00:00:00 2001
From: Elena Tebesoi <elena.tebesoi@freescale.com>
Date: Thu, 23 Feb 2012 00:40:54 +0000
Subject: [PATCH 04/27] gianfar: Optimize Tx/Rx ring cleanup using TSTAT/RSTAT

In Rx/Tx cleanup functions divide the total cleanup bugdet
only among active queues. i.e calcute budget_per_queue
based on active queues indicated by rstat/tstat instead
of using num_queues (total number of queues).

Signed-off-by: Pankaj Chauhan <pankaj.chauhan@freescale.com>
Signed-off-by: Elena Tebesoi <elena.tebesoi@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |  120 ++++++++++++++++--------------
 drivers/net/ethernet/freescale/gianfar.h |    1 +
 2 files changed, 65 insertions(+), 56 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index e520643..d7c30db 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -3040,49 +3040,61 @@ static int gfar_poll_rx(struct napi_struct *napi, int budget)
 	struct gfar __iomem *regs = gfargrp->regs;
 	struct gfar_priv_rx_q *rx_queue = NULL;
 	int rx_cleaned = 0, budget_per_queue = 0, rx_cleaned_per_queue = 0;
-	int i, left_over_budget = budget;
-	unsigned long serviced_queues = 0;
-	int num_queues = 0;
+	int i, num_act_qs = 0, napi_done = 1;
+	u32 imask, ievent, rstat, rstat_local, rstat_rxf, rstat_rhalt = 0, mask;
 
-	num_queues = gfargrp->num_rx_queues;
-	budget_per_queue = budget/num_queues;
+	rstat = gfar_read(&regs->rstat);
+	rstat_rxf = (rstat & RSTAT_RXF_ALL_MASK);
+	rstat_rxf |= gfargrp->rstat_prev;
+	rstat_local = rstat_rxf;
 
-	/* Clear IEVENT, so interrupts aren't called again
-	 * because of the packets that have already arrived */
-	gfar_write(&regs->ievent, IEVENT_RX_MASK);
-
-	while (num_queues && left_over_budget) {
+	while (rstat_local) {
+		num_act_qs++;
+		rstat_local &= (rstat_local - 1);
+	}
+	budget_per_queue = budget/num_act_qs;
 
-		budget_per_queue = left_over_budget/num_queues;
-		left_over_budget = 0;
+	gfar_write(&regs->rstat, rstat_rxf);
+	gfar_write(&gfargrp->regs->ievent, IEVENT_RX_MASK);
+	gfargrp->rstat_prev = rstat_rxf;
 
-		for_each_set_bit(i, &gfargrp->rx_bit_map, priv->num_rx_queues) {
-			if (test_bit(i, &serviced_queues))
-				continue;
+	for_each_set_bit(i, &gfargrp->rx_bit_map, priv->num_rx_queues) {
+		mask = RSTAT_RXF0_MASK >> i;
+		if (rstat_rxf & mask) {
 			rx_queue = priv->rx_queue[i];
 			rx_cleaned_per_queue = gfar_clean_rx_ring(rx_queue,
-							budget_per_queue);
-			rx_cleaned += rx_cleaned_per_queue;
-			if(rx_cleaned_per_queue < budget_per_queue) {
-				left_over_budget = left_over_budget +
-					(budget_per_queue - rx_cleaned_per_queue);
-				set_bit(i, &serviced_queues);
-				num_queues--;
+					budget_per_queue);
+			if (rx_cleaned_per_queue >= budget_per_queue) {
+				napi_done = 0;
+			} else {
+				gfargrp->rstat_prev &= ~(mask);
+				rstat_rhalt |= RSTAT_CLEAR_RHALT >> i;
 			}
+
+			rx_cleaned += rx_cleaned_per_queue;
 		}
 	}
 
-	if (rx_cleaned < budget) {
-		napi_complete(napi);
+	if (rstat_rhalt)
+		gfar_write(&regs->rstat, rstat_rhalt);
 
-		/* Clear the halt bit in RSTAT */
-		gfar_write(&regs->rstat, gfargrp->rstat);
-
-		gfar_write(&regs->imask, IMASK_DEFAULT);
 
-		/* If we are coalescing interrupts, update the timer */
-		/* Otherwise, clear it */
+	if (napi_done) {
+		napi_complete(napi);
 		gfar_configure_rx_coalescing(priv, gfargrp->rx_bit_map);
+		spin_lock_irq(&gfargrp->grplock);
+		imask = gfar_read(&regs->imask);
+		imask |= IMASK_DEFAULT_RX;
+		gfar_write(&regs->imask, imask);
+		ievent = gfar_read(&regs->ievent);
+		ievent &= IEVENT_RX_MASK;
+		if (ievent) {
+			imask = imask & IMASK_RX_DISABLED;
+			gfar_write(&gfargrp->regs->imask, imask);
+			gfar_write(&gfargrp->regs->ievent, IEVENT_RX_MASK);
+			napi_schedule(napi);
+		}
+		spin_unlock_irq(&gfargrp->grplock);
 	}
 
 	return rx_cleaned;
@@ -3096,47 +3108,43 @@ static int gfar_poll_tx(struct napi_struct *napi, int budget)
 	struct gfar __iomem *regs = gfargrp->regs;
 	struct gfar_priv_tx_q *tx_queue = NULL;
 	int tx_cleaned = 0, budget_per_queue = 0, tx_cleaned_per_queue = 0;
-	int i, left_over_budget = budget;
-	unsigned long serviced_queues = 0;
-	int num_queues = 0;
+	int i, num_act_qs = 0, napi_done = 1;
+	u32 imask, tstat, tstat_local, mask;
 
 
-	num_queues = gfargrp->num_rx_queues;
-	budget_per_queue = budget/num_queues;
+	tstat = gfar_read(&regs->tstat);
+	tstat = tstat & TSTAT_TXF_MASK_ALL;
+	tstat_local = tstat;
+
+	while (tstat_local) {
+		num_act_qs++;
+		tstat_local &= (tstat_local - 1);
+	}
+	budget_per_queue = budget/num_act_qs;
 
 	/* Clear IEVENT, so interrupts aren't called again
 	 * because of the packets that have already arrived */
 	gfar_write(&regs->ievent, IEVENT_TX_MASK);
 
-	while (num_queues && left_over_budget) {
-
-		budget_per_queue = left_over_budget/num_queues;
-		left_over_budget = 0;
-
-		for_each_set_bit(i, &gfargrp->tx_bit_map, priv->num_tx_queues) {
-			if (test_bit(i, &serviced_queues))
-				continue;
+	for_each_set_bit(i, &gfargrp->tx_bit_map, priv->num_tx_queues) {
+		mask = TSTAT_TXF0_MASK >> i;
+		if (tstat & mask) {
 			tx_queue = priv->tx_queue[i];
 			tx_cleaned_per_queue = gfar_clean_tx_ring(tx_queue,
-							budget_per_queue);
+					budget_per_queue);
 			tx_cleaned += tx_cleaned_per_queue;
-			if (tx_cleaned_per_queue < budget_per_queue) {
-				left_over_budget = left_over_budget +
-					budget_per_queue - tx_cleaned_per_queue;
-				set_bit(i, &serviced_queues);
-				num_queues--;
-			}
+			napi_done &= (tx_cleaned_per_queue < budget_per_queue);
 		}
 	}
 
-	if (tx_cleaned < budget) {
+	if (napi_done) {
 		napi_complete(napi);
-
-		gfar_write(&regs->imask, IMASK_DEFAULT);
-
-		/* If we are coalescing interrupts, update the timer */
-		/* Otherwise, clear it */
 		gfar_configure_tx_coalescing(priv, gfargrp->tx_bit_map);
+		spin_lock_irq(&gfargrp->grplock);
+		imask = gfar_read(&regs->imask);
+		imask |= IMASK_DEFAULT_TX;
+		gfar_write(&regs->imask, imask);
+		spin_unlock_irq(&gfargrp->grplock);
 	}
 
 	return tx_cleaned;
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index c351e14..cc31542 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1048,6 +1048,7 @@ struct gfar_priv_grp {
 	char int_name_tx[GFAR_INT_NAME_MAX];
 	char int_name_rx[GFAR_INT_NAME_MAX];
 	char int_name_er[GFAR_INT_NAME_MAX];
+	u32 rstat_prev;
 };
 
 enum gfar_errata {
-- 
1.7.9.7

