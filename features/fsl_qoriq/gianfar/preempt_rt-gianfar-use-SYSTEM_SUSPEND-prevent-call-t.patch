From e2c99753c06176b6955e76c5de8d257c7633e5b6 Mon Sep 17 00:00:00 2001
From: Yang Shi <yang.shi@windriver.com>
Date: Fri, 5 Oct 2012 10:40:37 -0700
Subject: [PATCH] preempt_rt: gianfar:use SYSTEM_SUSPEND prevent call trace

During suspend/resume operation, sleepable spinlocks introduce
call trace:

BUG: sleeping function called from invalid context at kernel/rtmutex.c:707
pcnt: 0 0 in_atomic(): 0, irqs_disabled(): 1, pid: 693, name: bash
Call Trace:
[ee149cc0] [c000842c] show_stack+0x44/0x160 (unreliable)
[ee149cf0] [c003c85c] __might_sleep+0xe4/0x108
[ee149d00] [c04785ec] rt_spin_lock+0x38/0xb4
[ee149d10] [c02fe49c] lock_tx_qs+0x38/0x58
[ee149d30] [c02fed6c] gfar_suspend+0xa4/0x184
[ee149d50] [c03a6788] of_platform_pm_suspend+0x38/0x84
[ee149d60] [c02b7ce4] pm_op+0x90/0x140
[ee149d90] [c02b83c4] __device_suspend+0x104/0x18c
[ee149dc0] [c02b8a44] dpm_suspend_start+0x290/0x44c
[ee149e30] [c0090808] suspend_devices_and_enter+0x98/0x20c
[ee149e60] [c0090a60] enter_state+0xe4/0xf4
[ee149e80] [c008ffe4] state_store+0x9c/0x108
[ee149ea0] [c0247c2c] kobj_attr_store+0x24/0x3c
[ee149eb0] [c017809c] sysfs_write_file+0xe4/0x1dc
[ee149ee0] [c0118c34] vfs_write+0xb4/0x188
[ee149f00] [c0118e7c] sys_write+0x50/0x10c
[ee149f40] [c0011cec] ret_from_syscall+0x0/0x4

Preempt-rt kernel introduce SYSTEM_SUSPEND state to prevent
such condition. The commit log as following:

timekeeping suspend/resume calls read_persistant_clock() which takes
rtc_lock. That results in might sleep warnings because at that point
we run with interrupts disabled.

We cannot convert rtc_lock to a raw spinlock as that would trigger
other might sleep warnings.

As a temporary workaround we disable the might sleep warnings by
setting system_state to SYSTEM_SUSPEND before calling sysdev_suspend()
and restoring it to SYSTEM_RUNNING afer sysdev_resume().

For GIANFAR driver, suspend() & resume() routines are called after
suspend_freeze_processes() and before suspend_thaw_processes()
routines during suspend & resume process. And interrupts have
been disabled, it is safe to get a spinlock without might_sleep
check.

Set system_state to SYSTEM_SUSPEND could force skipping might_sleep
check.

Preempt-rt kernel involved same strategy for sysdev_suspend() &
sysdev_resume() routines.

Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
Signed-off-by: Yang Shi <yang.shi@windriver.com>
[make is safe for non-preempt-rt configurations]
Signed-off-by: Michel Thebeau <michel.thebeau@windriver.com>

---
 drivers/net/ethernet/freescale/gianfar.c |   12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index badcb7e..12cdba4 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -1702,6 +1702,9 @@ static int gfar_suspend(struct device *dev)
 		return 0;
 
 	local_irq_save(flags);
+#ifndef CONFIG_PREEMPT_RT_FULL
+	system_state = SYSTEM_SUSPEND;
+#endif
 	lock_tx_qs(priv);
 	lock_rx_qs(priv);
 
@@ -1709,6 +1712,9 @@ static int gfar_suspend(struct device *dev)
 
 	unlock_rx_qs(priv);
 	unlock_tx_qs(priv);
+#ifndef CONFIG_PREEMPT_RT_FULL
+	system_state = SYSTEM_RUNNING;
+#endif
 	local_irq_restore(flags);
 
 	disable_napi(priv);
@@ -1757,6 +1763,9 @@ static int gfar_resume(struct device *dev)
 	mpc85xx_pmc_set_wake(priv->ofdev, 0);
 
 	local_irq_save(flags);
+#ifndef CONFIG_PREEMPT_RT_FULL
+	system_state = SYSTEM_SUSPEND;
+#endif
 	lock_rx_qs(priv);
 	gfar_halt_rx(ndev);
 	unlock_rx_qs(priv);
@@ -2153,6 +2162,9 @@ void stop_gfar(struct net_device *dev)
 
 	unlock_rx_qs(priv);
 	unlock_tx_qs(priv);
+#ifndef CONFIG_PREEMPT_RT_FULL
+	system_state = SYSTEM_RUNNING;
+#endif
 	local_irq_restore(flags);
 
 	/* Free the IRQs */
-- 
1.7.9.7

