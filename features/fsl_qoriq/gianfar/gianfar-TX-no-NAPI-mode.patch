From 16bad9382d6bbf011c35362a79ec91a0af9cfb89 Mon Sep 17 00:00:00 2001
From: Elena Tebesoi <elena.tebesoi@freescale.com>
Date: Thu, 8 Mar 2012 23:49:37 +0000
Subject: [PATCH 05/27] gianfar: TX no-NAPI mode

Adding TX no-NAPI mode to benefit IP termination scenarios (like NAS).
On such scenarios TX traffic is minimal, hence a no-napi processing
is also suitable. TX no-NAPI mode brings 5% performance improvement on NAS
read and write tests, measured with SDK 1.0.1.

By default Gianfar driver works in TX NAPI mode.
The setting can be changed in two ways:
- modprobe gianfar_driver tx_napi_enabled=0 -> when Gianfar is built as loadable module
- append to bootargs 'gianfar_driver.tx_napi_enabled=0' -> when Gianfar is built into the kernel

The current Giafar TX working mode is visible in /sys/module/gianfar_driver/parameters/tx_napi_enabled

Signed-off-by: Jiajun Wu <b06378@freescale.com>
Signed-off-by: Elena Tebesoi <elena.tebesoi@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image. Just minor context
mods in order to port to 3.4 kernel.]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   65 ++++++++++++++++++++++++++----
 1 file changed, 57 insertions(+), 8 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index d7c30db..3b8d1a6 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -10,7 +10,7 @@
  * Maintainer: Kumar Gala
  * Modifier: Sandeep Gopalpet <sandeep.kumar@freescale.com>
  *
- * Copyright 2002-2009, 2011 Freescale Semiconductor, Inc.
+ * Copyright 2002-2009, 2011-2012 Freescale Semiconductor, Inc.
  * Copyright 2007 MontaVista Software, Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -110,6 +110,9 @@
 
 const char gfar_driver_version[] = "1.3";
 static struct gfar_recycle_cntxt *gfar_global_recycle_cntxt;
+static int tx_napi_enabled = 1;
+module_param(tx_napi_enabled, bool, S_IRUGO);
+MODULE_PARM_DESC(tx_napi_enabled, "Flag to control TX IRQ handling method: NAPI or No-NAPI(hw polling)");
 
 static int gfar_enet_open(struct net_device *dev);
 static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev);
@@ -124,6 +127,7 @@ static int gfar_set_mac_address(struct net_device *dev);
 static int gfar_change_mtu(struct net_device *dev, int new_mtu);
 static irqreturn_t gfar_error(int irq, void *dev_id);
 static irqreturn_t gfar_transmit(int irq, void *dev_id);
+static irqreturn_t gfar_transmit_no_napi(int irq, void *dev_id);
 static irqreturn_t gfar_interrupt(int irq, void *dev_id);
 static void adjust_link(struct net_device *dev);
 static void init_registers(struct net_device *dev);
@@ -144,6 +148,7 @@ static void gfar_schedule_tx_cleanup(struct gfar_priv_grp *gfargrp);
 int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit);
 static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue,
 		int tx_work_limit);
+
 static int gfar_process_frame(struct net_device *dev, struct sk_buff *skb,
 			      int amount_pull);
 void gfar_halt(struct net_device *dev);
@@ -568,7 +573,8 @@ static void disable_napi(struct gfar_private *priv)
 
 	for (i = 0; i < priv->num_grps; i++) {
 		napi_disable(&priv->gfargrp[i].napi_rx);
-		napi_disable(&priv->gfargrp[i].napi_tx);
+		if (likely(tx_napi_enabled))
+			napi_disable(&priv->gfargrp[i].napi_tx);
 	}
 }
 
@@ -578,7 +584,8 @@ static void enable_napi(struct gfar_private *priv)
 
 	for (i = 0; i < priv->num_grps; i++) {
 		napi_enable(&priv->gfargrp[i].napi_rx);
-		napi_enable(&priv->gfargrp[i].napi_tx);
+		if (likely(tx_napi_enabled))
+			napi_enable(&priv->gfargrp[i].napi_tx);
 	}
 }
 
@@ -1057,7 +1064,9 @@ static int gfar_probe(struct platform_device *ofdev)
 	for (i = 0; i < priv->num_grps; i++) {
 		netif_napi_add(dev, &priv->gfargrp[i].napi_rx, gfar_poll_rx,
 					GFAR_DEV_RX_WEIGHT);
-		netif_napi_add(dev, &priv->gfargrp[i].napi_tx, gfar_poll_tx,
+		if (likely(tx_napi_enabled))
+			netif_napi_add(dev, &priv->gfargrp[i].napi_tx,
+					gfar_poll_tx,
 					GFAR_DEV_TX_WEIGHT);
 	}
 
@@ -1905,8 +1914,17 @@ static int register_grp_irqs(struct gfar_priv_grp *grp)
 			goto err_irq_fail;
 		}
 
-		if ((err = request_irq(grp->interruptTransmit, gfar_transmit,
-				0, grp->int_name_tx, grp)) < 0) {
+		if (likely(tx_napi_enabled)) {
+			err = request_irq(grp->interruptTransmit,
+					gfar_transmit, 0,
+					grp->int_name_tx, grp);
+		} else {
+			err = request_irq(grp->interruptTransmit,
+					gfar_transmit_no_napi, 0,
+					grp->int_name_tx, grp);
+		}
+
+		if (err < 0) {
 			netif_err(priv, intr, dev, "Can't get IRQ %d\n",
 				  grp->interruptTransmit);
 			goto tx_irq_fail;
@@ -2560,7 +2578,6 @@ static void gfar_align_skb(struct sk_buff *skb)
 		(((unsigned long) skb->data) & (RXBUF_ALIGNMENT - 1)));
 }
 
-/* Interrupt Handler for Transmit complete */
 static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue,
 		int tx_work_limit)
 {
@@ -2703,13 +2720,45 @@ static void gfar_schedule_tx_cleanup(struct gfar_priv_grp *gfargrp)
 	}
 }
 
-/* Interrupt Handler for Transmit complete */
+/* Interrupt Handler for Transmit complete when TX NAPI mode is used*/
 static irqreturn_t gfar_transmit(int irq, void *grp_id)
 {
 	gfar_schedule_tx_cleanup((struct gfar_priv_grp *)grp_id);
 	return IRQ_HANDLED;
 }
 
+/* Interrupt Handler for Transmit complete when TX NO NAPI mode is used*/
+static irqreturn_t gfar_transmit_no_napi(int irq, void *grp_id)
+{
+	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
+	struct gfar_private *priv = priv = grp->priv;
+	struct gfar_priv_tx_q *tx_queue = NULL;
+	u32 tstat, mask;
+	int i;
+
+	tstat = gfar_read(&grp->regs->tstat);
+	tstat = tstat & TSTAT_TXF_MASK_ALL;
+
+	/* Clear IEVENT */
+	gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
+
+	for_each_set_bit(i, &grp->tx_bit_map, priv->num_tx_queues) {
+		mask = TSTAT_TXF0_MASK >> i;
+		if (tstat & mask) {
+			tx_queue = priv->tx_queue[i];
+			/* Use the same cleanup function for both NAPI and
+			 * No-NAPI modes. For No-NAPI configure the budget
+			 * to a big enough value to be sure the cleanup
+			 * function will not exit because budget is met.
+			*/
+			gfar_clean_tx_ring(tx_queue, GFAR_TX_MAX_RING_SIZE);
+		}
+	}
+
+	gfar_configure_tx_coalescing(priv, grp->tx_bit_map);
+	return IRQ_HANDLED;
+}
+
 static void gfar_new_rxbdp(struct gfar_priv_rx_q *rx_queue, struct rxbd8 *bdp,
 		struct sk_buff *skb)
 {
-- 
1.7.9.7

