From 48cb47ac81a97a6602591a16945b5a14f4297926 Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Wed, 12 Sep 2012 15:29:51 +0800
Subject: [PATCH 16/27] gianfar: Adding TX interrupts handling for waking up
 the stopped TX queues

When RX_TX_BUFF_XCHG is enabled, stopped TX queues are not enabled again
as TX interuupts are disabled and indication that tx queue is ready for transmission
is not received. Enabling TX interrupt to re-enable the TX queues if disabled.
TX interrupts are masked by default and are enabled only if TX queues are stopped.

Signed-off-by: Rajan Gupta <rajan.gupta@freescale.com>
[Kevin: Original patch taken from FSL
QorIQ-SDK-V1.2-SOURCE-20120614-yocto.iso image]
Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   54 +++++++++++++++++++++++++++---
 drivers/net/ethernet/freescale/gianfar.h |    8 +++++
 2 files changed, 58 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 873e1c3..51e9170 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -146,6 +146,9 @@ static int gfar_change_mtu(struct net_device *dev, int new_mtu);
 static irqreturn_t gfar_error(int irq, void *dev_id);
 static irqreturn_t gfar_transmit(int irq, void *dev_id);
 static irqreturn_t gfar_transmit_no_napi(int irq, void *dev_id);
+#ifdef CONFIG_RX_TX_BUFF_XCHG
+static irqreturn_t gfar_enable_tx_queue(int irq, void *dev_id);
+#endif
 static irqreturn_t gfar_interrupt(int irq, void *dev_id);
 static void adjust_link(struct net_device *dev);
 static void init_registers(struct net_device *dev);
@@ -2109,9 +2112,7 @@ void gfar_halt(struct net_device *dev)
 static void free_grp_irqs(struct gfar_priv_grp *grp)
 {
 	free_irq(grp->interruptError, grp);
-#ifndef CONFIG_RX_TX_BUFF_XCHG
 	free_irq(grp->interruptTransmit, grp);
-#endif
 	free_irq(grp->interruptReceive, grp);
 }
 
@@ -2398,6 +2399,10 @@ static int register_grp_irqs(struct gfar_priv_grp *grp)
 					gfar_transmit_no_napi, 0,
 					grp->int_name_tx, grp);
 		}
+#else
+		err = request_irq(grp->interruptTransmit,
+					gfar_enable_tx_queue, 0,
+					grp->int_name_tx, grp);
 #endif
 
 		if (err < 0) {
@@ -2426,9 +2431,7 @@ static int register_grp_irqs(struct gfar_priv_grp *grp)
 	return 0;
 
 rx_irq_fail:
-#ifndef CONFIG_RX_TX_BUFF_XCHG
 	free_irq(grp->interruptTransmit, grp);
-#endif
 tx_irq_fail:
 	free_irq(grp->interruptError, grp);
 err_irq_fail:
@@ -2728,9 +2731,15 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	do {
 		lstatus = txbdp->lstatus;
 		if ((lstatus & BD_LFLAG(TXBD_READY))) {
+			u32 imask;
 			/* BD not free for tx */
 			netif_tx_stop_queue(txq);
 			dev->stats.tx_fifo_errors++;
+			spin_lock_irq(&tx_queue->grp->grplock);
+			imask = gfar_read(&regs->imask);
+			imask |= IMASK_DEFAULT_TX;
+			gfar_write(&regs->imask, imask);
+			spin_unlock_irq(&tx_queue->grp->grplock);
 			return NETDEV_TX_BUSY;
 		}
 
@@ -3308,6 +3317,43 @@ static irqreturn_t gfar_transmit(int irq, void *grp_id)
 	return IRQ_HANDLED;
 }
 
+#ifdef CONFIG_RX_TX_BUFF_XCHG
+static irqreturn_t gfar_enable_tx_queue(int irq, void *grp_id)
+{
+	struct gfar_priv_grp *grp = (struct gfar_priv_grp *)grp_id;
+	struct gfar_private *priv = priv = grp->priv;
+	struct gfar_priv_tx_q *tx_queue = NULL;
+	u32 tstat, mask;
+	int i;
+	unsigned long flags;
+
+	struct net_device *dev = NULL;
+	tstat = gfar_read(&grp->regs->tstat);
+	tstat = tstat & TSTAT_TXF_MASK_ALL;
+
+	/* Clear IEVENT */
+	gfar_write(&grp->regs->ievent, IEVENT_TX_MASK);
+
+	for_each_set_bit(i, &grp->tx_bit_map, priv->num_tx_queues) {
+		mask = TSTAT_TXF0_MASK >> i;
+		if (tstat & mask) {
+			tx_queue = priv->tx_queue[i];
+			dev = tx_queue->dev;
+			if (__netif_subqueue_stopped(dev, tx_queue->qindex))
+				netif_wake_subqueue(dev, tx_queue->qindex);
+		}
+	}
+
+	spin_lock_irqsave(&grp->grplock, flags);
+	mask = gfar_read(&grp->regs->imask);
+	mask = mask & IMASK_TX_DISABLED;
+	gfar_write(&grp->regs->imask, mask);
+	spin_unlock_irqrestore(&grp->grplock, flags);
+
+	return IRQ_HANDLED;
+}
+#endif
+
 /* Interrupt Handler for Transmit complete when TX NO NAPI mode is used*/
 static irqreturn_t gfar_transmit_no_napi(int irq, void *grp_id)
 {
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index f3bbaac..3acdd9a 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -439,10 +439,18 @@ extern const char gfar_driver_version[];
 #define IMASK_FIQ		0x00000004
 #define IMASK_DPE		0x00000002
 #define IMASK_PERR		0x00000001
+#ifndef CONFIG_RX_TX_BUFF_XCHG
 #define IMASK_DEFAULT  (IMASK_TXEEN | IMASK_TXFEN | IMASK_TXBEN | \
 		IMASK_RXFEN0 | IMASK_BSY | IMASK_EBERR | IMASK_BABR | \
 		IMASK_XFUN | IMASK_RXC | IMASK_BABT | IMASK_FGPI | \
 		IMASK_FIR | IMASK_FIQ | IMASK_DPE | IMASK_PERR | IMASK_MAG)
+#else
+#define IMASK_DEFAULT  (IMASK_TXEEN | \
+		IMASK_RXFEN0 | IMASK_BSY | IMASK_EBERR | IMASK_BABR | \
+		IMASK_XFUN | IMASK_RXC | IMASK_BABT | IMASK_FGPI | \
+		IMASK_FIR | IMASK_FIQ | IMASK_DPE | IMASK_PERR | IMASK_MAG)
+#endif
+ 
 #define IMASK_RTX_DISABLED ((~(IMASK_RXFEN0 | IMASK_TXFEN | IMASK_BSY)) \
 			   & IMASK_DEFAULT)
 
-- 
1.7.9.7

