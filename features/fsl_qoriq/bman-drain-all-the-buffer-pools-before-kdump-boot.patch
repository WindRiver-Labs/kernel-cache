From 228d936dce1bddfe894e66ea7ad8ac15d2293f98 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Mon, 11 Mar 2013 19:05:23 +0800
Subject: [PATCH 12/12] bman: drain all the buffer pools before kdump boot

In the kdump boot, there are still buffers in the bman buffer pools
released by the first kernel. These buffers have nothing to do with
the current kernel, and may cause issues when we try to use these
buffers. So we should drain all the buffer pools before kdump boot.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/staging/fsl_qbman/bman_config.c |   72 +++++++++++++++++++++++++++++++
 1 files changed, 72 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_config.c b/drivers/staging/fsl_qbman/bman_config.c
index db57f80..1a21756 100644
--- a/drivers/staging/fsl_qbman/bman_config.c
+++ b/drivers/staging/fsl_qbman/bman_config.c
@@ -35,6 +35,9 @@
 
 #include <asm/cacheflush.h>
 #include "bman_private.h"
+#ifdef CONFIG_KEXEC
+#include <linux/kexec.h>
+#endif
 
 /* Last updated for v00.79 of the BG */
 
@@ -424,6 +427,72 @@ int bm_pool_set(u32 bpid, const u32 *thresholds)
 }
 EXPORT_SYMBOL(bm_pool_set);
 
+#ifdef CONFIG_KEXEC
+static void bman_drain_one_pool(u32 bpid)
+{
+	struct bman_pool_params params;
+	struct bman_pool *pool;
+	struct bm_buffer bufs[8];
+	struct bm_pool_state state;
+	int ret;
+
+	ret = bman_query_pools(&state);
+	if (ret) {
+		pr_err("Query pool state failed\n");
+		return;
+	}
+
+	/* Check if there are free buffers in this pool */
+	if (bman_depletion_get(&state.as.state, bpid))
+		return;
+
+	memset(&params, 0, sizeof(params));
+	params.bpid = bpid;
+	pool = bman_new_pool(&params);
+	if (!pool) {
+		pr_err("Create bman pool for %d failed\n", bpid);
+		return;
+	}
+
+	ret = 0;
+	do {
+		/* Acquire is all-or-nothing, so we drain in 8s, then in
+		 * 1s for the remainder. */
+		if (ret != 1)
+			ret = bman_acquire(pool, bufs, 8, 0);
+		if (ret < 8)
+			ret = bman_acquire(pool, bufs, 1, 0);
+	} while (ret > 0);
+	return;
+}
+
+void bman_crash_shutdown(void)
+{
+	struct device_node *dn;
+	int ret;
+	u32 *range, base, count, i;
+
+	for_each_compatible_node(dn, NULL, "fsl,bpid-range") {
+		range = (u32 *)of_get_property(dn, "fsl,bpid-range", &ret);
+		if (!range) {
+			pr_err("No 'fsl,bpid-range' property in node %s\n",
+				dn->full_name);
+			continue;
+		}
+		if (ret != 8) {
+			pr_err("'fsl,bpid-range' is not a 2-cell range in node %s\n",
+				dn->full_name);
+			continue;
+		}
+		base = range[0];
+		count = range[1];
+
+		for (i = 0; i < count; i++)
+			bman_drain_one_pool(base + i);
+	}
+}
+#endif
+
 __init void bman_init_early(void)
 {
 	struct device_node *dn;
@@ -441,6 +510,9 @@ __init void bman_init_early(void)
 			BUG_ON(ret);
 		}
 	}
+#ifdef CONFIG_KEXEC
+	crash_shutdown_register(&bman_crash_shutdown);
+#endif
 }
 
 static void log_edata_bits(u32 bit_count)
-- 
1.7.0

