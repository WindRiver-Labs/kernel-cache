From d57dbf3de431639fc77404d8836dd886f4ba5f46 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Thu, 28 Mar 2013 10:47:35 +0200
Subject: [PATCH 375/547] gianfar: Add module param to enable/disable skb
 recycling

The gfar_skb_recycling_en driver option (boot time or module load time)
when disabled (set to 'N') effectively prevents recycling of skbs.
The option is enabled by default.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: Ib54fbd4bcc0102e10e8fa4e2a658272a6b8192ff
Reviewed-on: http://git.am.freescale.net:8181/871
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c       | 15 +++++++++++++--
 drivers/net/ethernet/freescale/gianfar.h       |  1 +
 drivers/net/ethernet/freescale/gianfar_sysfs.c |  6 +++++-
 3 files changed, 19 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 74faeb7..3731c9b 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -145,6 +145,12 @@ static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 
 LIST_HEAD(gfar_recycle_queues);
 
+bool gfar_skb_recycling_en = true;
+module_param(gfar_skb_recycling_en, bool, 0444);
+MODULE_PARM_DESC(gfar_skb_recycling_en,
+	"Enable buffer recycling.");
+
+
 MODULE_AUTHOR("Freescale Semiconductor, Inc");
 MODULE_DESCRIPTION("Gianfar Ethernet Driver");
 MODULE_LICENSE("GPL");
@@ -981,8 +987,13 @@ static void gfar_init_recycle(struct gfar_private *priv)
 	rec->buff_size = priv->rx_buffer_size + RXBUF_ALIGNMENT;
 	skb_queue_head_init(&rec->recycle_q);
 	/* recycle skbs to the own queue by default */
-	priv->recycle_target = &priv->recycle;
-	priv->recycle_ndev = priv->ndev;
+	if (gfar_skb_recycling_en) {
+		priv->recycle_target = &priv->recycle;
+		priv->recycle_ndev = priv->ndev;
+	} else {
+		priv->recycle_target = NULL;
+		priv->recycle_ndev = NULL;
+	}
 
 	list_add(&priv->recycle_node, &gfar_recycle_queues);
 }
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index ab9041e..2ce5654 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1203,6 +1203,7 @@ extern void gfar_vlan_mode(struct net_device *dev, netdev_features_t features);
 
 extern const struct ethtool_ops gfar_ethtool_ops;
 extern struct list_head gfar_recycle_queues;
+extern bool gfar_skb_recycling_en;
 
 #define MAX_FILER_CACHE_IDX (2*(MAX_FILER_IDX))
 
diff --git a/drivers/net/ethernet/freescale/gianfar_sysfs.c b/drivers/net/ethernet/freescale/gianfar_sysfs.c
index e2d5542..8838d6b 100644
--- a/drivers/net/ethernet/freescale/gianfar_sysfs.c
+++ b/drivers/net/ethernet/freescale/gianfar_sysfs.c
@@ -340,8 +340,9 @@ static ssize_t gfar_show_recycle_target(struct device *dev,
 					char *buf)
 {
 	struct gfar_private *priv = netdev_priv(to_net_dev(dev));
+	char *name = gfar_skb_recycling_en ? priv->recycle_ndev->name : "";
 
-	return sprintf(buf, "%s\n", priv->recycle_ndev->name);
+	return sprintf(buf, "%s\n", name);
 }
 
 static ssize_t gfar_set_recycle_target(struct device *dev,
@@ -353,6 +354,9 @@ static ssize_t gfar_set_recycle_target(struct device *dev,
 	struct gfar_private *priv_target;
 	int found = 0;
 
+	if (!gfar_skb_recycling_en)
+		return count;
+
 	list_for_each_entry(priv_target, &gfar_recycle_queues, recycle_node) {
 		char *name = priv_target->ndev->name;
 		if ((strlen(name) == count - 1) &&
-- 
1.8.4.93.g57e4c17

