From 7f4c045b489345387c89568f4c2e2d442191f8f9 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Thu, 28 Nov 2013 13:30:23 +0800
Subject: [PATCH 2/2] powerpc64: add the support for relocation type
 R_PPC64_ADDR16_*

In some cases we need to load a symbol value by using macro such as
LOAD_REG_IMMEDIATE, this will produce the R_PPC64_ADDR16_* relocation
types if CONFIG_RELOCATABLE is enabled. So add the support for these
relocation types. Also add the missed cache flushing instructions
after we modify the text code.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 arch/powerpc/kernel/reloc_64.S    | 71 +++++++++++++++++++++++++++++++++++++--
 arch/powerpc/kernel/vmlinux.lds.S |  2 --
 2 files changed, 68 insertions(+), 5 deletions(-)

diff --git a/arch/powerpc/kernel/reloc_64.S b/arch/powerpc/kernel/reloc_64.S
index d5ce45b..edc7de8 100644
--- a/arch/powerpc/kernel/reloc_64.S
+++ b/arch/powerpc/kernel/reloc_64.S
@@ -14,7 +14,14 @@
 RELA = 7
 RELASZ = 8
 RELAENT = 9
+
+STN_UNDEF = 0
+
+R_PPC64_ADDR16_LO = 4
+R_PPC64_ADDR16_HI = 5
 R_PPC64_RELATIVE = 22
+R_PPC64_ADDR16_HIGHER = 39
+R_PPC64_ADDR16_HIGHEST = 41
 
 /*
  * r3 = desired final address of kernel
@@ -30,6 +37,8 @@ _GLOBAL(relocate)
 	add	r9,r9,r12	/* r9 has runtime addr of .rela.dyn section */
 	ld	r10,(p_st - 0b)(r12)
 	add	r10,r10,r12	/* r10 has runtime addr of _stext */
+	ld	r5,(p_sym - 0b)(r12)
+	add	r5,r5,r12	/* r5 has runtime addr of .dynsym section */
 
 	/*
 	 * Scan the dynamic section for the RELA and RELACOUNT entries.
@@ -78,18 +87,74 @@ relaent:cmpdi	r6,RELAENT
 	 */
 	mtctr	r8
 5:	lwz	r0,12(9)	/* ELF64_R_TYPE(reloc->r_info) */
+	lwz	r4,8(r9)	/* ELF64_R_SYM(reloc->r_info) */
+	cmpwi	r4,STN_UNDEF	/* sym == STN_UNDEF ? */
+	beq	get_type
+	/* Find the value of the symbol at index(r4) */
+	mulli	r4,r4,24	/* r4 = r4 * sizeof(ELF64_Sym) */
+	add	r4,r4,r5	/* r4 = &__dyn_sym[Index] */
+	ld	r4,8(r4)	/* r4 = __dyn_sym[Index].st_value */
+
+get_type:
 	cmpwi	r0,R_PPC64_RELATIVE
-	bne	6f
+	bne	addr16_highest
 	ld	r6,0(r9)	/* reloc->r_offset */
 	ld	r0,16(r9)	/* reloc->r_addend */
 	add	r0,r0,r3
 	stdx	r0,r7,r6
+	b	nextrela
+addr16_highest:
+	cmpwi	r0,R_PPC64_ADDR16_HIGHEST
+	bne	addr16_higher
+	ld	r6,0(r9)	/* reloc->r_offset */
+	ld	r0,16(r9)	/* reloc->r_addend */
+	add	r0,r0,r3
+	add	r0,r0,r4	/* r0 = (S + A + Offset) */
+	extrdi	r0,r0,16,0	/* r0 = (r0 >> 48) & 0xffff) */
+	b	store_half
+addr16_higher:
+	cmpwi	r0,R_PPC64_ADDR16_HIGHER
+	bne	addr16_hi
+	ld	r6,0(r9)	/* reloc->r_offset */
+	ld	r0,16(r9)	/* reloc->r_addend */
+	add	r0,r0,r3
+	add	r0,r0,r4	/* r0 = (S + A + Offset) */
+	extrdi	r0,r0,16,16	/* r0 = (r0 >> 32) & 0xffff) */
+	b	store_half
+addr16_hi:
+	cmpwi	r0,R_PPC64_ADDR16_HI
+	bne	addr16_lo
+	ld	r6,0(r9)	/* reloc->r_offset */
+	ld	r0,16(r9)	/* reloc->r_addend */
+	add	r0,r0,r3
+	add	r0,r0,r4	/* r0 = (S + A + Offset) */
+	extrdi	r0,r0,16,32	/* r0 = (r0 >> 16) & 0xffff) */
+	b	store_half
+addr16_lo:
+	cmpwi	r0,R_PPC64_ADDR16_LO
+	bne	nextrela
+	ld	r6,0(r9)	/* reloc->r_offset */
+	ld	r0,16(r9)	/* reloc->r_addend */
+	add	r0,r0,r3
+	add	r0,r0,r4	/* r0 = (S + A + Offset) */
+	extrdi	r0,r0,16,48	/* r0 = r0 & 0xffff) */
+
+	/* Store half word */
+store_half:
+	sthx	r0,r6,r7	/* memory[r6 + r7] = (u16)r0 */
+
+nextrela:
+	dcbst	r6,r7
+	sync
+	icbi	r6,r7
 	addi	r9,r9,24
 	bdnz	5b
 
-6:	blr
+6:	sync
+	isync
+	blr
 
 p_dyn:	.llong	__dynamic_start - 0b
 p_rela:	.llong	__rela_dyn_start - 0b
 p_st:	.llong	_stext - 0b
-
+p_sym:	.llong  __dynamic_symtab - 0b
diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S
index f096e72..366f78e 100644
--- a/arch/powerpc/kernel/vmlinux.lds.S
+++ b/arch/powerpc/kernel/vmlinux.lds.S
@@ -164,9 +164,7 @@ SECTIONS
 	. = ALIGN(8);
 	.dynsym : AT(ADDR(.dynsym) - LOAD_OFFSET)
 	{
-#ifdef CONFIG_RELOCATABLE_PPC32
 		__dynamic_symtab = .;
-#endif
 		*(.dynsym)
 	}
 	.dynstr : AT(ADDR(.dynstr) - LOAD_OFFSET) { *(.dynstr) }
-- 
1.8.4.93.g57e4c17

