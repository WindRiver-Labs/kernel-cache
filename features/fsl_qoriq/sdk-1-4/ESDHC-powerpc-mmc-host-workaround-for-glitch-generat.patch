From 5fd4fcbcf555af36be8d0de1877dcb9c1ced9228 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Fri, 28 Jun 2013 16:39:55 +0800
Subject: [PATCH 257/430] ESDHC-powerpc mmc:host workaround for glitch
 generated when clock changed

A-005055: SDHC: Glitch is generated on the card clock with software reset or
clock divider change.

A simple workaround is to disable the SD card clock before the software reset,
and enable it when the module resumes normal operation.The Host and the SD card
are in a master-slave relationship. The Host provides clock and control
transfer across the interface. Therefore, any existing operation is discarded
when the Host controller is reset.
The recommended flow is as follows:
1. Software disable bit[3], SDCLKEN, of the System Control Register
2. Trigger software reset and/or set clock divider
3. Check bit[3], SDSTB, of the Present State Register for stable clock
4. Enable bit[3], SDCLKEN, of the System Control Register
Using the above method, the eSDHC cannot send command or transfer data when
there is a glitch in the clock line, and the glitch does not cause any issue.

In case the reason of Reset All command, we use reset data and reset command
to instead.
In case the reason of Clock change, this situation can only be occurred in card
setup phases, so just go idle state and re-init the card(Card detect can do
this for us).

Signed-off-by: Jerry Huang <Chang-Ming.Huang@freescale.com>
Signed-off-by: Haijun Zhang <haijun.zhang@freescale.com>
Change-Id: I1add2738ecf77369adc9f30718bd6a6e08ee4f17
Reviewed-on: http://git.am.freescale.net:8181/569
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch is from QorIQ-SDK-V1.4-20130625-yocto, just a minor
modification to port 3.4 kernel]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/mmc/host/sdhci-of-esdhc.c |   26 ++++++++++++++++++++++++++
 drivers/mmc/host/sdhci-pltfm.c    |   13 ++++++++++++-
 drivers/mmc/host/sdhci-pltfm.h    |    1 +
 include/linux/mmc/sdhci.h         |    5 +++++
 4 files changed, 44 insertions(+), 1 deletions(-)

diff --git a/drivers/mmc/host/sdhci-of-esdhc.c b/drivers/mmc/host/sdhci-of-esdhc.c
index b2c386f..c60ffb1 100644
--- a/drivers/mmc/host/sdhci-of-esdhc.c
+++ b/drivers/mmc/host/sdhci-of-esdhc.c
@@ -132,6 +132,15 @@ static void esdhc_writeb(struct sdhci_host *host, u8 val, int reg)
 	/* Prevent SDHCI core from writing reserved bits (e.g. HISPD). */
 	if (reg == SDHCI_HOST_CONTROL)
 		val &= ~ESDHC_HOST_CONTROL_RES;
+
+	/* If we have this quirk just use reset cmd and reset data to
+	 * instead of reset all.
+	 */
+	if ((reg == SDHCI_SOFTWARE_RESET) &&
+			(host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL) &&
+			(val & SDHCI_RESET_ALL))
+		val = SDHCI_RESET_CMD | SDHCI_RESET_DATA;
+
 	sdhci_be32bs_writeb(host, val, reg);
 }
 
@@ -217,6 +226,20 @@ static void esdhc_of_resume(struct sdhci_host *host)
 }
 #endif
 
+static u32 clock;
+static void esdhc_of_platform_reset_enter(struct sdhci_host *host, u8 mask)
+{
+	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
+		clock = host->clock;
+}
+
+static void esdhc_of_platform_reset_exit(struct sdhci_host *host, u8 mask)
+{
+	if (host->quirks2 & SDHCI_QUIRK2_BROKEN_RESET_ALL)
+		host->clock = clock;
+}
+
+
 /* Return: none zero - the card is presetn; 0 - card is absent */
 static int esdhc_of_get_cd(struct sdhci_host *host)
 {
@@ -239,6 +262,7 @@ static int esdhc_of_get_cd(struct sdhci_host *host)
 	return present;
 }
 
+
 static struct sdhci_ops sdhci_esdhc_ops = {
 	.read_l = esdhc_readl,
 	.read_w = esdhc_readw,
@@ -251,6 +275,8 @@ static struct sdhci_ops sdhci_esdhc_ops = {
 	.enable_dma = esdhc_of_enable_dma,
 	.get_max_clock = esdhc_of_get_max_clock,
 	.get_min_clock = esdhc_of_get_min_clock,
+	.platform_reset_enter = esdhc_of_platform_reset_enter,
+	.platform_reset_exit = esdhc_of_platform_reset_exit,
 #ifdef CONFIG_PM
 	.platform_suspend = esdhc_of_suspend,
 	.platform_resume = esdhc_of_resume,
diff --git a/drivers/mmc/host/sdhci-pltfm.c b/drivers/mmc/host/sdhci-pltfm.c
index 9778bd6..2e25dc9 100644
--- a/drivers/mmc/host/sdhci-pltfm.c
+++ b/drivers/mmc/host/sdhci-pltfm.c
@@ -91,6 +91,15 @@ void sdhci_get_of_property(struct platform_device *pdev)
 			host->quirks |= SDHCI_QUIRK_QORIQ_CIRCUIT_SUPPORT_VS33;
 		}
 
+		if (of_device_is_compatible(np, "fsl,t4240-esdhc"))
+			host->quirks2 |= SDHCI_QUIRK2_BROKEN_RESET_ALL;
+
+		if (of_device_is_compatible(np, "fsl,p4860-rev1-esdhc") ||
+		    of_device_is_compatible(np, "fsl,p1010-esdhc") ||
+		    of_device_is_compatible(np, "fsl,p2041-esdhc") ||
+		    of_device_is_compatible(np, "fsl,p3041-esdhc"))
+			host->quirks2 |= SDHCI_QUIRK2_BROKEN_RESET_ALL;
+
 		clk = of_get_property(np, "clock-frequency", &size);
 		if (clk && size == sizeof(*clk) && *clk)
 			pltfm_host->clock = be32_to_cpup(clk);
@@ -137,8 +146,10 @@ struct sdhci_host *sdhci_pltfm_init(struct platform_device *pdev,
 		host->ops = pdata->ops;
 	else
 		host->ops = &sdhci_pltfm_ops;
-	if (pdata)
+	if (pdata) {
 		host->quirks = pdata->quirks;
+		host->quirks2 = pdata->quirks2;
+	}
 	host->irq = platform_get_irq(pdev, 0);
 
 	if (!request_mem_region(iomem->start, resource_size(iomem),
diff --git a/drivers/mmc/host/sdhci-pltfm.h b/drivers/mmc/host/sdhci-pltfm.h
index 37e0e18..283d54a 100644
--- a/drivers/mmc/host/sdhci-pltfm.h
+++ b/drivers/mmc/host/sdhci-pltfm.h
@@ -18,6 +18,7 @@
 struct sdhci_pltfm_data {
 	struct sdhci_ops *ops;
 	unsigned int quirks;
+	unsigned int quirks2;
 };
 
 struct sdhci_pltfm_host {
diff --git a/include/linux/mmc/sdhci.h b/include/linux/mmc/sdhci.h
index 416db5a..2864e91 100644
--- a/include/linux/mmc/sdhci.h
+++ b/include/linux/mmc/sdhci.h
@@ -101,6 +101,11 @@ struct sdhci_host {
 	unsigned int quirks2;	/* More deviations from spec. */
 
 #define SDHCI_QUIRK2_HOST_OFF_CARD_ON			(1<<0)
+#define SDHCI_QUIRK2_HOST_NO_CMD23			(1<<1)
+/* The system physically doesn't support 1.8v, even if the host does */
+#define SDHCI_QUIRK2_NO_1_8_V				(1<<2)
+/* Controller can't perform reset all successfully */
+#define SDHCI_QUIRK2_BROKEN_RESET_ALL			(1<<3)
 
 	int irq;		/* Device IRQ */
 	void __iomem *ioaddr;	/* Mapped address */
-- 
1.7.5.4

