From 2c478aad005989e256fc563a2af5ed66d53a2ffd Mon Sep 17 00:00:00 2001
From: Andy Fleming <afleming@freescale.com>
Date: Thu, 8 Dec 2011 01:20:27 -0600
Subject: [PATCH 006/547] powerpc/e6500: Add support for hardware threads on
 e6500.

The general idea is that each core will release all of its
threads into the secondary thread startup code, which will
eventually wait in the secondary core holding area, for the
appropriate bit in the PACA to be set. The kick_cpu function
pointer will set that bit in the PACA, and thus "release"
the core/thread to boot. We also need to do a few things that
U-Boot normally does for CPUs (like enable branch prediction).

Signed-off-by: Andy Fleming <afleming@freescale.com>
Signed-off-by: Zhao Chenhui <chenhui.zhao@freescale.com>
Signed-off-by: Li Yang <leoli@freescale.com>
[some bug fixes for hotplug support]
Signed-off-by: Scott Wood <scottwood@freescale.com>
[Fixed feature section placement]
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/powerpc/include/asm/cputable.h  |  3 +-
 arch/powerpc/include/asm/reg_booke.h | 27 ++++++++++++++++++
 arch/powerpc/kernel/exceptions-64e.S | 55 ++++++++++++++++++++++++++++--------
 arch/powerpc/kernel/head_64.S        | 29 ++++++++++++++++---
 arch/powerpc/kernel/prom.c           | 31 ++++++++------------
 arch/powerpc/kernel/setup-common.c   |  9 ++++--
 arch/powerpc/kernel/setup_64.c       |  6 +++-
 arch/powerpc/mm/tlb_low_64e.S        | 24 ++++++++--------
 arch/powerpc/platforms/85xx/smp.c    | 14 +++++++++
 9 files changed, 146 insertions(+), 52 deletions(-)

diff --git a/arch/powerpc/include/asm/cputable.h b/arch/powerpc/include/asm/cputable.h
index 6f3887d..0ac7000 100644
--- a/arch/powerpc/include/asm/cputable.h
+++ b/arch/powerpc/include/asm/cputable.h
@@ -378,7 +378,8 @@ extern const char *powerpc_base_platform;
 #define CPU_FTRS_E6500	(CPU_FTR_USE_TB | CPU_FTR_NODSISRALIGN | \
 	    CPU_FTR_L2CSR | CPU_FTR_LWSYNC | CPU_FTR_NOEXECUTE | \
 	    CPU_FTR_DBELL | CPU_FTR_POPCNTB | CPU_FTR_POPCNTD | \
-	    CPU_FTR_DEBUG_LVL_EXC | CPU_FTR_EMB_HV | CPU_FTR_ALTIVEC_COMP)
+	    CPU_FTR_DEBUG_LVL_EXC | CPU_FTR_EMB_HV | CPU_FTR_ALTIVEC_COMP | \
+	    CPU_FTR_SMT)
 #define CPU_FTRS_GENERIC_32	(CPU_FTR_COMMON | CPU_FTR_NODSISRALIGN)
 
 /* 64-bit CPUs */
diff --git a/arch/powerpc/include/asm/reg_booke.h b/arch/powerpc/include/asm/reg_booke.h
index b417de3..8ae6b9f 100644
--- a/arch/powerpc/include/asm/reg_booke.h
+++ b/arch/powerpc/include/asm/reg_booke.h
@@ -587,6 +587,13 @@
 /* Bit definitions for L1CSR2. */
 #define L1CSR2_DCWS	0x40000000	/* Data Cache write shadow */
 
+/* Bit definitions for BUCSR. */
+#define BUCSR_STAC_EN	0x01000000	/* Segment Target Address Cache */
+#define BUCSR_LS_EN	0x00400000	/* Link Stack */
+#define BUCSR_BBFI	0x00000200	/* Branch Buffer flash invalidate */
+#define BUCSR_BPEN	0x00000001	/* Branch prediction enable */
+#define BUCSR_INIT	(BUCSR_STAC_EN | BUCSR_LS_EN | BUCSR_BBFI | BUCSR_BPEN)
+
 /* Bit definitions for L2CSR0. */
 #define L2CSR0_L2E	0x80000000	/* L2 Cache Enable */
 #define L2CSR0_L2PE	0x40000000	/* L2 Cache Parity/ECC Enable */
@@ -710,5 +717,25 @@
 #define MMUBE1_VBE4		0x00000002
 #define MMUBE1_VBE5		0x00000001
 
+#define TMRN_TPRI0	0x0C0	/* Thread Priority Register 0 */
+#define TMRN_TPRI1	0x0C1	/* Thread Priority Register 1 */
+#define TMRN_TPRI2	0x0C2	/* Thread Priority Register 2 */
+#define TMRN_INIA0	0x140	/* Next Instruction Address Register 0 */
+#define TMRN_INIA1	0x141	/* Next Instruction Address Register 1 */
+#define TMRN_INIA2	0x142	/* Next Instruction Address Register 2 */
+#define TMRN_IMSR0	0x120	/* Initial MSR Register 0 */
+#define TMRN_IMSR1	0x121	/* Initial MSR Register 1 */
+#define SPRN_TENSR	0x1b5	/* Thread Enable Status Register */
+#define SPRN_TENS	0x1b6	/* Thread Enable Set Register */
+#define SPRN_TENC	0x1b7	/* Thread Enable Clear Register */
+
+#define TEN_THREAD(x)	(1 << x)
+
+#define SPRN_PPR32	0x382	/* Processor Priority Register */
+
+#define TMRN(x)		(((x & 0x1f) << 16) | ((x & 0x3e0) << 6))
+#define MTTMR(tmr, reg)	.long (0x7c0003dc | TMRN(tmr) | (reg << 21))
+#define MFTMR(tmr, reg)	.long (0x7c0002dc | TMRN(tmr) | (reg << 21))
+
 #endif /* __ASM_POWERPC_REG_BOOKE_H__ */
 #endif /* __KERNEL__ */
diff --git a/arch/powerpc/kernel/exceptions-64e.S b/arch/powerpc/kernel/exceptions-64e.S
index 645170a..1d9480c 100644
--- a/arch/powerpc/kernel/exceptions-64e.S
+++ b/arch/powerpc/kernel/exceptions-64e.S
@@ -1320,6 +1320,11 @@ _GLOBAL(book3e_secondary_core_init)
 	/* Init global core bits */
 2:	bl	.init_core_book3e
 
+BEGIN_FTR_SECTION
+	/* Start threads */
+	bl      .fsl_enable_threads
+END_FTR_SECTION_IFSET(CPU_FTR_SMT)
+
 	/* Init per-thread bits */
 3:	bl	.init_thread_book3e
 
@@ -1355,6 +1360,34 @@ _STATIC(init_core_book3e)
 	sync
 	blr
 
+_GLOBAL(fsl_enable_threads)
+BEGIN_FTR_SECTION
+	/* Disable the other thread */
+	li	r3,2
+	mtspr	SPRN_TENC,r3
+
+1:	mfspr	r3,SPRN_TENSR
+	andi.	r3,r3,2
+	bne	1b
+
+	/* Configure the MSR per the default */
+	LOAD_REG_IMMEDIATE(r3, MSR_KERNEL);
+	MTTMR(TMRN_IMSR1, 3);
+
+	/*
+	 * Set the NIA for the secondary thread to
+	 * generic_secondary_thread_init
+	 */
+	LOAD_REG_IMMEDIATE(r3, .fsl_secondary_thread_init);
+	MTTMR(TMRN_INIA1, 3);
+
+	/* Release the other thread. It will spin until kick_cpu is called */
+	li	r3, 2
+	mtspr	SPRN_TENS, r3
+END_FTR_SECTION_IFSET(CPU_FTR_SMT)
+
+	blr
+
 _STATIC(init_thread_book3e)
 	lis	r3,(SPRN_EPCR_ICM | SPRN_EPCR_GICM)@h
 	mtspr	SPRN_EPCR,r3
@@ -1373,18 +1406,18 @@ _STATIC(init_thread_book3e)
 _GLOBAL(__setup_base_ivors)
 	SET_IVOR(0, 0x020) /* Critical Input */
 	SET_IVOR(1, 0x000) /* Machine Check */
-	SET_IVOR(2, 0x060) /* Data Storage */ 
+	SET_IVOR(2, 0x060) /* Data Storage */
 	SET_IVOR(3, 0x080) /* Instruction Storage */
-	SET_IVOR(4, 0x0a0) /* External Input */ 
-	SET_IVOR(5, 0x0c0) /* Alignment */ 
-	SET_IVOR(6, 0x0e0) /* Program */ 
-	SET_IVOR(7, 0x100) /* FP Unavailable */ 
-	SET_IVOR(8, 0x120) /* System Call */ 
-	SET_IVOR(9, 0x140) /* Auxiliary Processor Unavailable */ 
-	SET_IVOR(10, 0x160) /* Decrementer */ 
-	SET_IVOR(11, 0x180) /* Fixed Interval Timer */ 
-	SET_IVOR(12, 0x1a0) /* Watchdog Timer */ 
-	SET_IVOR(13, 0x1c0) /* Data TLB Error */ 
+	SET_IVOR(4, 0x0a0) /* External Input */
+	SET_IVOR(5, 0x0c0) /* Alignment */
+	SET_IVOR(6, 0x0e0) /* Program */
+	SET_IVOR(7, 0x100) /* FP Unavailable */
+	SET_IVOR(8, 0x120) /* System Call */
+	SET_IVOR(9, 0x140) /* Auxiliary Processor Unavailable */
+	SET_IVOR(10, 0x160) /* Decrementer */
+	SET_IVOR(11, 0x180) /* Fixed Interval Timer */
+	SET_IVOR(12, 0x1a0) /* Watchdog Timer */
+	SET_IVOR(13, 0x1c0) /* Data TLB Error */
 	SET_IVOR(14, 0x1e0) /* Instruction TLB Error */
 	SET_IVOR(15, 0x040) /* Debug */
 
diff --git a/arch/powerpc/kernel/head_64.S b/arch/powerpc/kernel/head_64.S
index b61363d..843f71a 100644
--- a/arch/powerpc/kernel/head_64.S
+++ b/arch/powerpc/kernel/head_64.S
@@ -178,6 +178,21 @@ exception_marker:
 #include "exceptions-64s.S"
 #endif
 
+#ifdef CONFIG_PPC_BOOK3E
+_GLOBAL(fsl_secondary_thread_init)
+BEGIN_FTR_SECTION
+	/* Enable branch prediction */
+	lis     r3,BUCSR_INIT@h
+	ori     r3,r3,BUCSR_INIT@l
+	mtspr   SPRN_BUCSR,r3
+	isync
+
+	mfspr	r3, SPRN_PIR
+	rlwimi	r3, r3, 30, 2, 30
+	mtspr	SPRN_PIR, r3
+END_FTR_SECTION_IFSET(CPU_FTR_SMT)
+#endif
+
 _GLOBAL(generic_secondary_thread_init)
 	mr	r24,r3
 
@@ -314,7 +329,7 @@ _STATIC(__mmu_off)
  *
  *   r5 != NULL -> OF entry, we go to prom_init, "legacy" parameter content
  *                 in r3...r7
- *   
+ *
  *   r5 == NULL -> kexec style entry. r3 is a physical pointer to the
  *                 DT block, r4 is a physical pointer to the kernel itself
  *
@@ -535,7 +550,7 @@ __secondary_start_pmac_0:
 	b	1f
 	li	r24,3
 1:
-	
+
 _GLOBAL(pmac_secondary_start)
 	/* turn on 64-bit mode */
 	bl	.enable_64b_mode
@@ -641,7 +656,7 @@ __secondary_start:
 	RFI
 	b	.	/* prevent speculative execution */
 
-/* 
+/*
  * Running with relocation on at this point.  All we want to do is
  * zero the stack back-chain pointer and get the TOC virtual address
  * before going into C code.
@@ -777,7 +792,7 @@ _INIT_STATIC(start_here_multiplatform)
 	mtspr	SPRN_SRR1,r4
 	RFI
 	b	.	/* prevent speculative execution */
-	
+
 	/* This is where all platforms converge execution */
 _INIT_GLOBAL(start_here_common)
 	/* relocation is on at this point */
@@ -789,6 +804,12 @@ _INIT_GLOBAL(start_here_common)
 	/* Do more system initializations in virtual mode */
 	bl	.setup_system
 
+#ifdef CONFIG_PPC_BOOK3E
+BEGIN_FTR_SECTION
+	bl	.fsl_enable_threads
+END_FTR_SECTION_IFSET(CPU_FTR_SMT)
+#endif
+
 	/* Mark interrupts soft and hard disabled (they might be enabled
 	 * in the PACA when doing hotplug)
 	 */
diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c
index 8b6f7a9..35bcfa7 100644
--- a/arch/powerpc/kernel/prom.c
+++ b/arch/powerpc/kernel/prom.c
@@ -308,12 +308,10 @@ static int __init early_init_dt_scan_cpus(unsigned long node,
 
 	/* Get physical cpuid */
 	intserv = of_get_flat_dt_prop(node, "ibm,ppc-interrupt-server#s", &len);
-	if (intserv) {
-		nthreads = len / sizeof(int);
-	} else {
-		intserv = of_get_flat_dt_prop(node, "reg", NULL);
-		nthreads = 1;
-	}
+	if (!intserv)
+		intserv = of_get_flat_dt_prop(node, "reg", &len);
+
+	nthreads = len / sizeof(int);
 
 	/*
 	 * Now see if any of these threads match our boot cpu.
@@ -848,23 +846,18 @@ struct device_node *of_get_cpu_node(int cpu, unsigned int *thread)
 		intserv = of_get_property(np, "ibm,ppc-interrupt-server#s",
 				&plen);
 		if (intserv == NULL) {
-			const u32 *reg = of_get_property(np, "reg", NULL);
-			if (reg == NULL)
+			intserv = of_get_property(np, "reg", &plen);
+			if (intserv == NULL)
 				continue;
-			if (*reg == hardid) {
+		}
+
+		plen /= sizeof(u32);
+		for (t = 0; t < plen; t++) {
+			if (hardid == intserv[t]) {
 				if (thread)
-					*thread = 0;
+					*thread = t;
 				return np;
 			}
-		} else {
-			plen /= sizeof(u32);
-			for (t = 0; t < plen; t++) {
-				if (hardid == intserv[t]) {
-					if (thread)
-						*thread = t;
-					return np;
-				}
-			}
 		}
 	}
 	return NULL;
diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c
index 63d051f..03e0f72 100644
--- a/arch/powerpc/kernel/setup-common.c
+++ b/arch/powerpc/kernel/setup-common.c
@@ -444,16 +444,19 @@ void __init smp_setup_cpu_maps(void)
 		intserv = of_get_property(dn, "ibm,ppc-interrupt-server#s",
 				&len);
 		if (intserv) {
-			nthreads = len / sizeof(int);
 			DBG("    ibm,ppc-interrupt-server#s -> %d threads\n",
 			    nthreads);
 		} else {
 			DBG("    no ibm,ppc-interrupt-server#s -> 1 thread\n");
-			intserv = of_get_property(dn, "reg", NULL);
-			if (!intserv)
+			intserv = of_get_property(dn, "reg", &len);
+			if (!intserv) {
 				intserv = &cpu;	/* assume logical == phys */
+				len = 4;
+			}
 		}
 
+		nthreads = len / sizeof(int);
+
 		for (j = 0; j < nthreads && cpu < nr_cpu_ids; j++) {
 			DBG("    thread %d -> cpu %d (hard id %d)\n",
 			    j, cpu, intserv[j]);
diff --git a/arch/powerpc/kernel/setup_64.c b/arch/powerpc/kernel/setup_64.c
index 0853d82..241d7bc 100644
--- a/arch/powerpc/kernel/setup_64.c
+++ b/arch/powerpc/kernel/setup_64.c
@@ -457,7 +457,11 @@ void __init setup_system(void)
 	smp_setup_cpu_maps();
 	check_smt_enabled();
 
-#ifdef CONFIG_SMP
+	/*
+	 * Freescale Book3e parts spin in a loop provided by firmware,
+	 * so smp_release_cpus() does nothing for them
+	 */
+#if defined(CONFIG_SMP) && !defined(CONFIG_PPC_FSL_BOOK3E)
 	/* Release secondary cpus out of their spinloops at 0x60 now that
 	 * we can map physical -> logical CPU ids
 	 */
diff --git a/arch/powerpc/mm/tlb_low_64e.S b/arch/powerpc/mm/tlb_low_64e.S
index f9b7738..1e47dd5 100644
--- a/arch/powerpc/mm/tlb_low_64e.S
+++ b/arch/powerpc/mm/tlb_low_64e.S
@@ -110,9 +110,9 @@ END_FTR_SECTION_IFSET(CPU_FTR_EMB_HV)
 	ori	r10,r10,_PAGE_PRESENT
 	oris	r11,r10,_PAGE_ACCESSED@h
 
-#ifdef CONFIG_FSL_THREADS
+BEGIN_FTR_SECTION
 	ld	r10,PACA_TLB_PER_CORE_PTR(r13)
-#endif
+END_FTR_SECTION_IFSET(CPU_FTR_SMT)
 
 	TLB_MISS_STATS_SAVE_INFO_BOLTED
 	bne	tlb_miss_kernel_bolted
@@ -130,11 +130,11 @@ tlb_miss_common_bolted:
  * r10 = tlb_per_core ptr
  */
 
-#ifdef CONFIG_FSL_THREADS
 	/*
 	 * Search if we already have an entry for that virtual
 	 * address, and if we do, bail out.
 	 */
+BEGIN_FTR_SECTION
 	mtocrf	0x01,r10
 	addi	r10,r10,PACA_TLB_LOCK-1 /* -1 to compensate for low bit set */
 	bf	31,1f		/* no lock if TLB_PER_CORE_HAS_LOCK clear */
@@ -151,17 +151,17 @@ tlb_miss_common_bolted:
 	b	2b
 	.previous
 1:
-#endif
+END_FTR_SECTION_IFSET(CPU_FTR_SMT)
 
 	rldicl	r15,r16,64-PGDIR_SHIFT+3,64-PGD_INDEX_SIZE-3
 	cmpldi	cr0,r14,0
 	clrrdi	r15,r15,3
 	beq	tlb_miss_fault_bolted	/* No PGDIR, bail */
 
-#ifdef CONFIG_FSL_THREADS
+	ldx	r14,r14,r15		/* grab pgd entry */
+BEGIN_FTR_SECTION
 	mfspr	r10,SPRN_MAS2
 	tlbsx	0,r16
-	ldx	r14,r14,r15		/* grab pgd entry */
 	mfspr	r15,SPRN_MAS1
 	andis.	r15,r15,MAS1_VALID@h
 	bne	tlb_miss_done_bolted	/* tlb exists already, bail */
@@ -171,9 +171,7 @@ tlb_miss_common_bolted:
 	oris	r15,r15,MAS1_VALID@h
 	mtspr	SPRN_MAS1,r15
 	mtspr	SPRN_MAS2,r10
-#else
-	ldx	r14,r14,r15		/* grab pgd entry */
-#endif
+END_FTR_SECTION_IFSET(CPU_FTR_SMT)
 
 #ifndef CONFIG_PPC_64K_PAGES
 	rldicl	r15,r16,64-PUD_SHIFT+3,64-PUD_INDEX_SIZE-3
@@ -228,14 +226,14 @@ tlb_miss_common_bolted:
 
 tlb_miss_done_bolted:
 	.macro	tlb_unlock_bolted
-#ifdef CONFIG_FSL_THREADS
+BEGIN_FTR_SECTION
 	ld	r10,PACA_TLB_PER_CORE_PTR(r13)
 	bf	31,1f
 	li	r15,0
 	isync
 	stb	r15,PACA_TLB_LOCK-1(r10)
 1:
-#endif
+END_FTR_SECTION_IFSET(CPU_FTR_SMT)
 	.endm
 
 	tlb_unlock_bolted
@@ -278,9 +276,9 @@ itlb_miss_fault_bolted:
 	TLB_MISS_STATS_SAVE_INFO_BOLTED
 	bne-	itlb_miss_fault_bolted
 
-#ifdef CONFIG_FSL_THREADS
+BEGIN_FTR_SECTION
 	ld	r10,PACA_TLB_PER_CORE_PTR(r13)
-#endif
+END_FTR_SECTION_IFSET(CPU_FTR_SMT)
 	li	r11,_PAGE_PRESENT|_PAGE_EXEC	/* Base perm */
 
 	/* We do the user/kernel test for the PID here along with the RW test
diff --git a/arch/powerpc/platforms/85xx/smp.c b/arch/powerpc/platforms/85xx/smp.c
index 6a17599..c4ed55f 100644
--- a/arch/powerpc/platforms/85xx/smp.c
+++ b/arch/powerpc/platforms/85xx/smp.c
@@ -26,6 +26,7 @@
 #include <asm/cacheflush.h>
 #include <asm/dbell.h>
 #include <asm/fsl_guts.h>
+#include <asm/cputhreads.h>
 
 #include <sysdev/fsl_soc.h>
 #include <sysdev/mpic.h>
@@ -156,6 +157,19 @@ static int __cpuinit smp_85xx_kick_cpu(int nr)
 
 	pr_debug("smp_85xx_kick_cpu: kick CPU #%d\n", nr);
 
+#ifdef CONFIG_PPC64
+	/* If the cpu we're kicking is a thread, kick it and return */
+	if (cpu_thread_in_core(nr) != 0) {
+		local_irq_save(flags);
+
+		smp_generic_kick_cpu(nr);
+
+		local_irq_restore(flags);
+
+		return 0;
+	}
+#endif
+
 	np = of_get_cpu_node(nr, NULL);
 	cpu_rel_addr = of_get_property(np, "cpu-release-addr", NULL);
 
-- 
1.8.4.93.g57e4c17

