From b06d501a94ccb465836bb73fac420ff6d69da123 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Thu, 1 Aug 2013 17:38:22 +0800
Subject: [PATCH 063/430] dpaa_eth: use FSL_DPAA_ETH prefix for all config
 options

Use consistent naming for Kconfig options in DPAA Ethernet driver.
Also updated default configs.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>

Change-Id: I5603919a9d0649741a9494caed3826605b131903
Reviewed-on: http://git.am.freescale.net:8181/1720
Reviewed-by: Sovaiala Cristian-Constantin-B39531 <Cristian.Sovaiala@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch is from QorIQ-SDK-V1.4-20130625-yocto, just
a minor modification to port 3.4 kernel]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/Makefile            |    2 +-
 drivers/net/ethernet/freescale/dpa/Kconfig         |   67 ++++++-----
 drivers/net/ethernet/freescale/dpa/Makefile        |    8 +-
 drivers/net/ethernet/freescale/dpa/dpaa_1588.c     |   16 ++--
 .../net/ethernet/freescale/dpa/dpaa_eth-common.h   |    2 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      |  124 ++++++++++----------
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      |   40 +++---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c   |   30 +++---
 .../net/ethernet/freescale/dpa/dpaa_eth_sysfs.c    |    8 +-
 9 files changed, 151 insertions(+), 146 deletions(-)

diff --git a/drivers/net/ethernet/freescale/Makefile b/drivers/net/ethernet/freescale/Makefile
index 470666f..830647b 100644
--- a/drivers/net/ethernet/freescale/Makefile
+++ b/drivers/net/ethernet/freescale/Makefile
@@ -11,7 +11,7 @@ obj-$(CONFIG_FS_ENET) += fs_enet/
 obj-$(CONFIG_FSL_PQ_MDIO) += fsl_pq_mdio.o
 obj-$(CONFIG_GIANFAR) += gianfar_driver.o
 obj-$(if $(CONFIG_FSL_FMAN),y) += fman/
-obj-$(if $(CONFIG_DPA_ETH),y) += dpa/
+obj-$(if $(CONFIG_FSL_DPAA_ETH),y) += dpa/
 obj-$(CONFIG_PTP_1588_CLOCK_GIANFAR) += gianfar_ptp.o
 gianfar_driver-objs := gianfar.o \
 		gianfar_ethtool.o \
diff --git a/drivers/net/ethernet/freescale/dpa/Kconfig b/drivers/net/ethernet/freescale/dpa/Kconfig
index 8a14c88..801e8b2 100644
--- a/drivers/net/ethernet/freescale/dpa/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/Kconfig
@@ -1,4 +1,4 @@
-config DPA_ETH
+config FSL_DPAA_ETH
 	bool "DPAA Ethernet"
 	depends on FSL_SOC && FSL_BMAN && FSL_QMAN && FSL_FMAN
 	select PHYLIB
@@ -6,9 +6,9 @@ config DPA_ETH
 	  Data Path Acceleration Architecture Ethernet driver, supporting the
 	  Freescale QorIQ chips.
 
-config DPA_OFFLINE_PORTS
+config FSL_DPAA_OFFLINE_PORTS
 	bool "Offline Ports support"
-	depends on DPA_ETH
+	depends on FSL_DPAA_ETH
 	default y
 	---help---
 	  The Offline Parsing / Host Command ports (short: OH ports, of Offline ports) provide
@@ -22,61 +22,66 @@ config DPA_OFFLINE_PORTS
 	  Choosing this feature will not impact the functionality and/or performance of the system,
 	  so it is safe to have it.
 
-config DPAA_ETH_SG_SUPPORT
+config FSL_DPAA_ETH_SG_SUPPORT
 	bool
 
-choice DPAA_ETH_OPTIMIZE
+choice FSL_DPAA_ETH_OPTIMIZE
 	prompt "Optimization choices for the DPAA Ethernet driver"
-	depends on DPA_ETH
-	default DPAA_ETH_OPTIMIZE_FOR_TERM
+	depends on FSL_DPAA_ETH
+	default FSL_DPAA_ETH_OPTIMIZE_FOR_TERM
 	---help---
 	  Compile-time switch between driver optimizations for forwarding use-cases and
 	  termination scenarios.
 
-	config DPAA_ETH_OPTIMIZE_FOR_IPFWD
+	config FSL_DPAA_ETH_OPTIMIZE_FOR_IPFWD
 		bool "Optimize for forwarding"
-		select DPA_TX_RECYCLE if FMAN_T4240
+		select FSL_DPAA_TX_RECYCLE if FMAN_T4240
 		---help---
 		  Optimize the DPAA-Ethernet driver for IP/IPSec forwarding use-cases.
+		  This option disabled SG support in the DPAA Ethernet driver.
 
-	config DPAA_ETH_OPTIMIZE_FOR_TERM
+	config FSL_DPAA_ETH_OPTIMIZE_FOR_TERM
 		bool "Optimize for termination"
-		select DPAA_ETH_SG_SUPPORT
+		select FSL_DPAA_ETH_SG_SUPPORT
 		---help---
 		  Optimize the DPAA-Ethernet driver for termination (TCP, UDP) use-cases.
 		  In particular, this choice enables Scatter-Gather (SG) support
 		  in the driver, which is momentarily not accessible otherwise.
 endchoice
 
-config DPA_TX_RECYCLE
+config FSL_DPAA_TX_RECYCLE
 	bool
 	depends on FMAN_T4240
 
-config FSL_DPA_1588
+config FSL_DPAA_1588
 	tristate "IEEE 1588-compliant timestamping"
-	depends on DPA_ETH
+	depends on FSL_DPAA_ETH
 	default n
+	---help---
+	 Enable IEEE1588 support code.
 
-config FSL_DPA_TS
+config FSL_DPAA_TS
 	tristate "Linux compliant timestamping"
-	depends on DPA_ETH
+	depends on FSL_DPAA_ETH
 	default n
+	---help---
+	  Enable Linux API compliant timestamping support.
 
-choice DPA_ETH_WQ_ASSIGN
+choice FSL_DPAA_ETH_WQ_ASSIGN
 	prompt "WorkQueue assignment scheme for FrameQueues"
-	depends on DPA_ETH
-	default DPA_ETH_WQ_MULTI
+	depends on FSL_DPAA_ETH
+	default FSL_DPAA_ETH_WQ_MULTI
 	---help---
 	  Selects the FrameQueue to WorkQueue assignment scheme.
 
-	config DPA_ETH_WQ_LEGACY
+	config FSL_DPAA_ETH_WQ_LEGACY
 		bool "Legacy WQ assignment"
 		---help---
 		  Statically-defined FQIDs are round-robin assigned to all WQs (0..7). PCD queues are always
 		  in this category. Other frame queues may be those used for "MAC-less" or "shared MAC" configurations
 		  of the driver.
 		  Dynamically-defined FQIDs all go to WQ7.
-	config DPA_ETH_WQ_MULTI
+	config FSL_DPAA_ETH_WQ_MULTI
 	bool "Multi-WQ assignment"
 	---help---
 	  Tx Confirmation FQs go to WQ1.
@@ -84,10 +89,10 @@ choice DPA_ETH_WQ_ASSIGN
 	  Rx Error and Tx Error FQs go to WQ2.
 endchoice
 
-config DPAA_ETH_USE_NDO_SELECT_QUEUE
+config FSL_DPAA_ETH_USE_NDO_SELECT_QUEUE
 	bool "Use driver's Tx queue selection mechanism"
 	default y
-	depends on DPA_ETH
+	depends on FSL_DPAA_ETH
 	---help---
 	  The DPAA-Ethernet driver defines a ndo_select_queue() callback for optimal selection
 	  of the egress FQ. That will override the XPS support for this netdevice.
@@ -95,9 +100,9 @@ config DPAA_ETH_USE_NDO_SELECT_QUEUE
 	  or simply don't want to use the driver's ndo_select_queue() callback, then unselect this
 	  and use the standard XPS support instead.
 
-config DPAA_ETH_MAX_BUF_COUNT
+config FSL_DPAA_ETH_MAX_BUF_COUNT
 	int "Maximum nuber of buffers in private bpool"
-	depends on DPA_ETH
+	depends on FSL_DPAA_ETH
 	range 64 2048
 	default "128"
 	---help---
@@ -105,24 +110,24 @@ config DPAA_ETH_MAX_BUF_COUNT
 	  buffer pool. One needn't normally modify this, as it has probably been tuned for performance
 	  already. This cannot be lower than DPAA_ETH_REFILL_THRESHOLD.
 
-config DPAA_ETH_REFILL_THRESHOLD
+config FSL_DPAA_ETH_REFILL_THRESHOLD
 	int "Private bpool refill threshold"
-	depends on DPA_ETH
-	range 32 DPAA_ETH_MAX_BUF_COUNT
+	depends on FSL_DPAA_ETH
+	range 32 FSL_DPAA_ETH_MAX_BUF_COUNT
 	default "80"
 	---help---
 	  The DPAA-Ethernet driver will start replenishing buffer pools whose count
 	  falls below this threshold. This must be related to DPAA_ETH_MAX_BUF_COUNT. One needn't normally
 	  modify this value unless one has very specific performance reasons.
 
-config DPAA_ETH_UNIT_TESTS
+config FSL_DPAA_ETH_UNIT_TESTS
 	bool
-	depends on DPA_ETH
+	depends on FSL_DPAA_ETH
 	default n
 
 config FSL_DPAA_ETH_DEBUGFS
 	tristate "DPAA Ethernet debugfs interface"
-	depends on DEBUG_FS
+	depends on DEBUG_FS && FSL_DPAA_ETH
 	default y
 	---help---
 	  This option compiles debugfs code for the DPAA Ethernet driver.
diff --git a/drivers/net/ethernet/freescale/dpa/Makefile b/drivers/net/ethernet/freescale/dpa/Makefile
index 7278394..7d4b9c7 100644
--- a/drivers/net/ethernet/freescale/dpa/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/Makefile
@@ -8,12 +8,12 @@ include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
 EXTRA_CFLAGS += -I$(NET_DPA)
 
-obj-$(CONFIG_FSL_DPA_1588) += dpaa_1588.o
-obj-$(CONFIG_DPAA_ETH_SG_SUPPORT) += fsl-dpa-sg.o
+obj-$(CONFIG_FSL_DPAA_1588) += dpaa_1588.o
+obj-$(CONFIG_FSL_DPAA_ETH_SG_SUPPORT) += fsl-dpa-sg.o
 # dpaa_debugfs needs to be initialized before dpaa_eth
 obj-$(CONFIG_FSL_DPAA_ETH_DEBUGFS) += dpaa_debugfs.o
-obj-$(CONFIG_DPA_ETH) += fsl-mac.o fsl-dpa.o
-obj-$(CONFIG_DPA_OFFLINE_PORTS) += fsl-oh.o
+obj-$(CONFIG_FSL_DPAA_ETH) += fsl-mac.o fsl-dpa.o
+obj-$(CONFIG_FSL_DPAA_OFFLINE_PORTS) += fsl-oh.o
 
 fsl-dpa-objs	:= dpa-ethtool.o dpaa_eth.o dpaa_eth_sysfs.o
 fsl-dpa-sg-objs	:= dpaa_eth_sg.o
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_1588.c b/drivers/net/ethernet/freescale/dpa/dpaa_1588.c
index 51b8b85..a2f3d86 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_1588.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_1588.c
@@ -196,14 +196,14 @@ static u8 *dpa_ptp_parse_packet(struct sk_buff *skb, u16 *eth_type)
 	u8 *pos = skb->data + ETH_ALEN + ETH_ALEN;
 	u8 *ptp_loc = NULL;
 	u8 msg_type;
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 	u32 access_len = ETH_ALEN + ETH_ALEN + DPA_ETYPE_LEN;
 #endif
 	struct iphdr *iph;
 	struct udphdr *udph;
 	struct ipv6hdr *ipv6h;
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 	/* when we can receive S/G frames we need to check the data we want to
 	 * access is in the linear skb buffer */
 	if (!pskb_may_pull(skb, access_len))
@@ -214,7 +214,7 @@ static u8 *dpa_ptp_parse_packet(struct sk_buff *skb, u16 *eth_type)
 
 	/* Check if inner tag is here */
 	if (*eth_type == ETH_P_8021Q) {
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 		access_len += DPA_VLAN_TAG_LEN;
 
 		if (!pskb_may_pull(skb, access_len))
@@ -232,7 +232,7 @@ static u8 *dpa_ptp_parse_packet(struct sk_buff *skb, u16 *eth_type)
 	case ETH_P_1588:
 		ptp_loc = pos;
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 		if (!pskb_may_pull(skb, access_len + PTP_OFFS_MSG_TYPE + 1))
 			return NULL;
 #endif
@@ -247,7 +247,7 @@ static u8 *dpa_ptp_parse_packet(struct sk_buff *skb, u16 *eth_type)
 	/* Transport of PTP over IPv4 */
 	case ETH_P_IP:
 		iph = (struct iphdr *)pos;
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 		access_len += sizeof(struct iphdr);
 
 		if (!pskb_may_pull(skb, access_len))
@@ -257,7 +257,7 @@ static u8 *dpa_ptp_parse_packet(struct sk_buff *skb, u16 *eth_type)
 		if (ntohs(iph->protocol) != IPPROTO_UDP)
 			return NULL;
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 		access_len += iph->ihl * 4 - sizeof(struct iphdr) +
 				sizeof(struct udphdr);
 
@@ -275,7 +275,7 @@ static u8 *dpa_ptp_parse_packet(struct sk_buff *skb, u16 *eth_type)
 	case ETH_P_IPV6:
 		ipv6h = (struct ipv6hdr *)pos;
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 		access_len += sizeof(struct ipv6hdr) + sizeof(struct udphdr);
 #endif
 
@@ -320,7 +320,7 @@ static int dpa_ptp_store_stamp(struct net_device *dev, struct sk_buff *skb,
 		return -EINVAL;
 	}
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 	if (!pskb_may_pull(skb, ptp_loc - skb->data + PTP_OFFS_SEQ_ID + 2))
 		return -EINVAL;
 #endif
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
index 25474e7..5b9bfdb 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth-common.h
@@ -50,7 +50,7 @@ enum dpa_fq_type {
 	FQ_TYPE_TX,             /* "Real" Tx FQs */
 	FQ_TYPE_TX_CONFIRM,     /* Tx Confirmation FQs (actually Rx FQs) */
 	FQ_TYPE_TX_ERROR,       /* Tx Error FQs (these are actually Rx FQs) */
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	FQ_TYPE_TX_RECYCLE,	/* Tx FQs for recycleable frames only */
 #endif
 };
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index cc825e6..7b2a8ef 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -82,8 +82,8 @@
 /* DPAA platforms benefit from hardware-assisted queue management */
 #define DPA_NETIF_FEATURES	(0)
 
-#ifdef CONFIG_DPAA_ETH_UNIT_TESTS
-#undef CONFIG_DPAA_ETH_UNIT_TESTS
+#ifdef CONFIG_FSL_DPAA_ETH_UNIT_TESTS
+#undef CONFIG_FSL_DPAA_ETH_UNIT_TESTS
 #endif
 
 #define DPA_NAPI_WEIGHT		64
@@ -172,7 +172,7 @@ int dpa_alloc_pcd_fqids(struct device *, uint32_t, uint8_t, uint32_t *)
 __attribute__((weak));
 
 int dpa_free_pcd_fqids(struct device *, uint32_t) __attribute__((weak));
-#endif /* CONFIG_DPAA_FMAN_UNIT_TESTS */
+#endif /* CONFIG_FSL_DPAA_FMAN_UNIT_TESTS */
 
 /* BM */
 
@@ -270,7 +270,7 @@ copy_to_unmapped_area(dma_addr_t phys_start, void *src, size_t buf_size)
 	}
 }
 
-#ifndef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 static void dpa_bp_add_8(const struct dpa_bp *dpa_bp)
 {
 	struct bm_buffer bmb[8];
@@ -363,7 +363,7 @@ void dpa_make_private_pool(struct dpa_bp *dpa_bp)
 			*thiscount = *thiscount - j;
 	}
 }
-#endif /* CONFIG_DPAA_ETH_SG_SUPPORT */
+#endif /* CONFIG_FSL_DPAA_ETH_SG_SUPPORT */
 
 static void dpaa_eth_seed_pool(struct dpa_bp *bp)
 {
@@ -398,16 +398,16 @@ static void dpaa_eth_refill_bpools(struct dpa_priv_s *priv,
 	int count = *countptr;
 	const struct dpa_bp *dpa_bp = percpu_priv->dpa_bp;
 
-#ifndef CONFIG_DPAA_ETH_SG_SUPPORT
-	if (unlikely(count < CONFIG_DPAA_ETH_REFILL_THRESHOLD)) {
+#ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
+	if (unlikely(count < CONFIG_FSL_DPAA_ETH_REFILL_THRESHOLD)) {
 		int i;
 
-		for (i = count; i < CONFIG_DPAA_ETH_MAX_BUF_COUNT; i += 8)
+		for (i = count; i < CONFIG_FSL_DPAA_ETH_MAX_BUF_COUNT; i += 8)
 			dpa_bp_add_8(dpa_bp);
 	}
 #else
 	/* Add pages to the buffer pool */
-	while (count < CONFIG_DPAA_ETH_MAX_BUF_COUNT)
+	while (count < CONFIG_FSL_DPAA_ETH_MAX_BUF_COUNT)
 		count += _dpa_bp_add_8_pages(dpa_bp);
 	*countptr = count;
 
@@ -525,7 +525,7 @@ pdev_register_failed:
 	return err;
 }
 
-#ifndef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 static inline void _dpa_bp_free_buf(void *addr)
 {
 	struct sk_buff **skbh = addr;
@@ -692,7 +692,7 @@ _dpa_fq_alloc(struct list_head *list, struct dpa_fq *dpa_fq)
 			}
 		}
 
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 		/*
 		 * Configure the Tx queues for recycled frames, such that the
 		 * buffers are released by FMan and no confirmation is sent
@@ -891,7 +891,7 @@ dpa_fd_release(const struct net_device *net_dev, const struct qm_fd *fd)
 		cpu_relax();
 }
 
-#ifndef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 /*
  * Cleanup function for outgoing frame descriptors that were built on Tx path,
  * either contiguous frames or scatter/gather ones with a single data buffer.
@@ -952,7 +952,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 	}
 /* on some error paths this might not be necessary: */
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (unlikely(priv->ts_tx_en &&
 			skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
 		struct skb_shared_hwtstamps shhwtstamps;
@@ -960,7 +960,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 		if (!dpa_get_ts(priv, TX, &shhwtstamps, (void *)skbh))
 			skb_tstamp_tx(skb, &shhwtstamps);
 	}
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	/* Free first buffer (which was allocated on Tx) containing the
 	 * skb backpointer and hardware timestamp information
@@ -970,7 +970,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 	return skb;
 }
-#endif /* CONFIG_DPAA_ETH_SG_SUPPORT */
+#endif /* CONFIG_FSL_DPAA_ETH_SG_SUPPORT */
 
 /* net_device */
 
@@ -1096,7 +1096,7 @@ static void dpa_set_rx_mode(struct net_device *net_dev)
 		netdev_err(net_dev, "mac_dev->set_multi() = %d\n", _errno);
 }
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 int dpa_get_ts(const struct dpa_priv_s *priv, enum port_type rx_tx,
 	struct skb_shared_hwtstamps *shhwtstamps, const void *data)
 {
@@ -1218,27 +1218,27 @@ static int dpa_ts_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	return copy_to_user(rq->ifr_data, &config, sizeof(config)) ?
 			-EFAULT : 0;
 }
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 static int dpa_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 {
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	struct dpa_priv_s *priv = netdev_priv(dev);
 #endif
 	int ret = 0;
 
 /* at least one timestamping feature must be enabled to proceed */
-#if defined(CONFIG_FSL_DPA_1588) || defined(CONFIG_FSL_DPA_TS)
+#if defined(CONFIG_FSL_DPAA_1588) || defined(CONFIG_FSL_DPAA_TS)
 	if (!netif_running(dev))
 #endif
 		return -EINVAL;
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (cmd == SIOCSHWTSTAMP)
 		return dpa_ts_ioctl(dev, rq, cmd);
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	if ((cmd >= PTP_ENBL_TXTS_IOCTL) && (cmd <= PTP_CLEANUP_TS)) {
 		if (priv->tsu && priv->tsu->valid)
 			ret = dpa_ioctl_1588(dev, rq, cmd);
@@ -1250,7 +1250,7 @@ static int dpa_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
 	return ret;
 }
 
-#ifndef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 /*
  * When we put the buffer into the pool, we purposefully added
  * some padding to the address so that the buffers wouldn't all
@@ -1410,7 +1410,7 @@ void __hot _dpa_process_parse_results(const t_FmPrsResult *parse_results,
 		if (!fm_l4_frame_is_tcp(parse_results))
 			*use_gro = 0;
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 		/*
 		 * If the L4 HXS Parser has successfully run, we can reduce the
 		 * number of bytes we'll memcopy into skb->data.
@@ -1426,7 +1426,7 @@ void __hot _dpa_process_parse_results(const t_FmPrsResult *parse_results,
 	 * checksum zero or an L4 proto other than TCP/UDP
 	 */
 	skb->ip_summed = CHECKSUM_NONE;
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 	/*
 	 * Even if checksum was not verified, it's still possible L4 parser
 	 * has run, in which case we know the headers size.
@@ -1443,7 +1443,7 @@ void __hot _dpa_process_parse_results(const t_FmPrsResult *parse_results,
 	*use_gro = 0;
 }
 
-#ifndef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 void __hot _dpa_rx(struct net_device *net_dev,
 		const struct dpa_priv_s *priv,
 		struct dpa_percpu_priv_s *percpu_priv,
@@ -1497,7 +1497,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	prefetch(skb_shinfo(skb));
 
 /* Shouldn't we store the timestamp after we validate the mtu? */
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
 		dpa_ptp_store_rxstamp(net_dev, skb, fd);
 #endif
@@ -1517,10 +1517,10 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	_dpa_process_parse_results(parse_result, fd, skb, &use_gro,
 					 &hdr_size_unused);
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (priv->ts_rx_en)
 		dpa_get_ts(priv, RX, skb_hwtstamps(skb), (void *)skbh);
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	if (use_gro) {
 		gro_result_t gro_result;
@@ -1549,7 +1549,7 @@ drop_large_frame:
 _return_dpa_fd_release:
 	dpa_fd_release(net_dev, fd);
 }
-#endif /* CONFIG_DPAA_ETH_SG_SUPPORT */
+#endif /* CONFIG_FSL_DPAA_ETH_SG_SUPPORT */
 
 static void dpaa_eth_napi_disable(struct dpa_priv_s *priv)
 {
@@ -1625,7 +1625,7 @@ static void __hot _dpa_tx_conf(struct net_device	*net_dev,
 
 	skb = _dpa_cleanup_tx_fd(priv, fd);
 
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_tx_en_ioctl)
 		dpa_ptp_store_txstamp(net_dev, skb, fd);
 #endif
@@ -1651,11 +1651,11 @@ static void dpa_set_buffer_layout(struct dpa_priv_s *priv, struct fm_port *port,
 			DPA_RX_PRIV_DATA_SIZE : DPA_TX_PRIV_DATA_SIZE);
 	layout->parse_results = true;
 	layout->hash_results = true;
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	if (priv && priv->tsu && priv->tsu->valid)
 		layout->time_stamp = true;
 #endif
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	layout->time_stamp = true;
 #endif
 
@@ -1850,7 +1850,7 @@ buf_acquire_failed:
 	return NETDEV_TX_OK;
 }
 
-#ifndef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 static int skb_to_sg_fd(struct dpa_priv_s *priv,
 		struct sk_buff *skb, struct qm_fd *fd)
 {
@@ -1926,12 +1926,12 @@ static int skb_to_sg_fd(struct dpa_priv_s *priv,
 	sg_entry->addr_hi = upper_32_bits(paddr);
 	sg_entry->addr_lo = lower_32_bits(paddr);
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (unlikely(priv->ts_tx_en &&
 			skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
 	}
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	return 0;
 }
@@ -2002,14 +2002,14 @@ static int skb_to_contig_fd(struct dpa_priv_s *priv,
 		}
 	}
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (unlikely(priv->ts_tx_en &&
 			skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
 		/* we need the fd back to get the timestamp */
 		can_recycle = false;
 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
 	}
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	if (likely(can_recycle)) {
 		/* Buffer will get recycled, setup fd accordingly */
@@ -2096,15 +2096,15 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		skb = skb_new;
 	}
 
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_tx_en_ioctl)
 		fd.cmd |= FM_FD_CMD_UPD;
 #endif
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (unlikely(priv->ts_tx_en &&
 			skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))
 		fd.cmd |= FM_FD_CMD_UPD;
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	/*
 	 * We have two paths here:
@@ -2168,7 +2168,7 @@ fd_create_failed:
 done:
 	return NETDEV_TX_OK;
 }
-#endif /* CONFIG_DPAA_ETH_SG_SUPPORT */
+#endif /* CONFIG_FSL_DPAA_ETH_SG_SUPPORT */
 
 /**
  * Congestion group state change notification callback.
@@ -2616,7 +2616,7 @@ static const struct qman_fq shared_egress_fq __devinitconst = {
 	.cb = { .ern = shared_ern }
 };
 
-#ifdef CONFIG_DPAA_ETH_UNIT_TESTS
+#ifdef CONFIG_FSL_DPAA_ETH_UNIT_TESTS
 static bool __devinitdata tx_unit_test_passed = true;
 
 static void __devinit tx_unit_test_ern(struct qman_portal	*portal,
@@ -2727,7 +2727,7 @@ static const struct qman_fq tx_unit_test_fq __devinitconst = {
 };
 
 static struct __devinitdata dpa_fq unit_fq;
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 static struct dpa_fq unit_recycle_fq;
 #endif
 static bool __devinitdata tx_unit_test_ran; /* Starts as false */
@@ -2744,7 +2744,7 @@ static int __devinit dpa_tx_unit_test(struct net_device *net_dev)
 	int err = 0;
 	int tests_failed = 0;
 	const cpumask_t *cpus = qman_affine_cpus();
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	struct qman_fq *oldrecycleq;
 #endif
 
@@ -2784,7 +2784,7 @@ static int __devinit dpa_tx_unit_test(struct net_device *net_dev)
 	/* Replace queue 0 with this queue */
 	priv->egress_fqs[smp_processor_id()] = &unit_fq.fq_base;
 
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	oldrecycleq = priv->recycle_fqs[smp_processor_id()];
 	unit_recycle_fq.net_dev = net_dev;
 	unit_recycle_fq.fq_base = tx_unit_test_fq;
@@ -2883,7 +2883,7 @@ end_test:
 	if (unlikely(err < 0))
 		pr_err("Could not OOS TX Unit Test FQ (%d)\n", err);
 
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	err = qman_retire_fq(&unit_recycle_fq.fq_base, NULL);
 	if (unlikely(err < 0))
 		pr_err("Could not retire Recycle TX Unit Test FQ (%d)\n", err);
@@ -3163,7 +3163,7 @@ dpa_bp_probe(struct platform_device *_of_dev, size_t *count)
 		dpa_bp = ERR_PTR(-EINVAL);
 		goto _return_of_node_put;
 	} else if (has_kernel_pool) {
-		dpa_bp->target_count = CONFIG_DPAA_ETH_MAX_BUF_COUNT;
+		dpa_bp->target_count = CONFIG_FSL_DPAA_ETH_MAX_BUF_COUNT;
 		dpa_bp->kernel_pool = 1;
 	}
 
@@ -3226,7 +3226,7 @@ dpa_mac_probe(struct platform_device *_of_dev)
 	const phandle		*phandle_prop;
 	struct platform_device	*of_dev;
 	struct mac_device	*mac_dev;
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	struct net_device	*net_dev = NULL;
 	struct dpa_priv_s	*priv = NULL;
 	struct device_node	*timer_node;
@@ -3265,7 +3265,7 @@ dpa_mac_probe(struct platform_device *_of_dev)
 		return ERR_PTR(-EINVAL);
 	}
 
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	phandle_prop = of_get_property(mac_node, "ptimer-handle", &lenp);
 	if (phandle_prop && ((mac_dev->phy_if != PHY_INTERFACE_MODE_SGMII) ||
 			((mac_dev->phy_if == PHY_INTERFACE_MODE_SGMII) &&
@@ -3289,7 +3289,7 @@ static const char fsl_qman_frame_queues[][25] __devinitconst = {
 };
 
 
-#ifdef CONFIG_DPAA_ETH_USE_NDO_SELECT_QUEUE
+#ifdef CONFIG_FSL_DPAA_ETH_USE_NDO_SELECT_QUEUE
 static u16 dpa_select_queue(struct net_device *net_dev, struct sk_buff *skb)
 {
 	return smp_processor_id();
@@ -3332,7 +3332,7 @@ static const struct net_device_ops dpa_private_ops = {
 	.ndo_get_stats64 = dpa_get_stats64,
 	.ndo_set_mac_address = dpa_set_mac_address,
 	.ndo_validate_addr = eth_validate_addr,
-#ifdef CONFIG_DPAA_ETH_USE_NDO_SELECT_QUEUE
+#ifdef CONFIG_FSL_DPAA_ETH_USE_NDO_SELECT_QUEUE
 	.ndo_select_queue = dpa_select_queue,
 #endif
 	.ndo_change_mtu = dpa_change_mtu,
@@ -3354,7 +3354,7 @@ static const struct net_device_ops dpa_shared_ops = {
 	.ndo_get_stats64 = dpa_get_stats64,
 	.ndo_set_mac_address = dpa_set_mac_address,
 	.ndo_validate_addr = eth_validate_addr,
-#ifdef CONFIG_DPAA_ETH_USE_NDO_SELECT_QUEUE
+#ifdef CONFIG_FSL_DPAA_ETH_USE_NDO_SELECT_QUEUE
 	.ndo_select_queue = dpa_select_queue,
 #endif
 	.ndo_change_mtu = dpa_change_mtu,
@@ -3398,7 +3398,7 @@ static const struct fqid_cell tx_confirm_fqids[] __devinitconst = {
 	{0, DPAA_ETH_TX_QUEUES}
 };
 
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 static const struct fqid_cell tx_recycle_fqids[] = {
 	{0, DPAA_ETH_TX_QUEUES}
 };
@@ -3439,7 +3439,7 @@ dpa_fq_probe(struct platform_device *_of_dev, struct list_head *list,
 		}
 	}
 
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	/* per-core tx queues for recycleable frames (FManv3 only) */
 	if (txrecycle) {
 		fqids = tx_recycle_fqids;
@@ -3582,7 +3582,7 @@ static void dpa_setup_egress(struct dpa_priv_s *priv,
 	}
 }
 
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 static void dpa_setup_recycle_queues(struct dpa_priv_s *priv, struct dpa_fq *fq,
 				     struct fm_port *port)
 {
@@ -3749,7 +3749,7 @@ static void dpa_tx_fq_init(struct dpa_priv_s *priv, struct list_head *head,
 		dpa_setup_ingress(priv, errq, &tx_private_errq);
 		if (confqs)
 			dpa_setup_conf_queues(priv, confqs);
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 		if (recyclefqs)
 			dpa_setup_recycle_queues(priv, recyclefqs, port);
 #endif
@@ -3788,7 +3788,7 @@ static int dpa_netdev_init(struct device_node *dpa_node,
 		 * private interfaces
 		 */
 		if (!priv->shared) {
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 			net_dev->hw_features |= NETIF_F_SG | NETIF_F_HIGHDMA;
 			/* Recent kernels enable GSO automatically, if
 			 * we declare NETIF_F_SG. For conformity, we'll
@@ -3853,7 +3853,7 @@ static int dpa_private_netdev_init(struct device_node *dpa_node,
 		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
 		percpu_priv->net_dev = net_dev;
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 		/* init the percpu list and add some skbs */
 		skb_queue_head_init(&percpu_priv->skb_list);
 
@@ -4074,7 +4074,7 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		goto rx_fq_probe_failed;
 
 	if (txport)
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 		err = dpa_fq_probe(_of_dev, &txfqlist, &txdefault, &txerror,
 				&txfqs, (is_shared ? NULL : &txconf),
 				(is_shared ? NULL : &txrecycle), TX);
@@ -4227,7 +4227,7 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 
 	dpaa_eth_sysfs_init(&net_dev->dev);
 
-#ifdef CONFIG_DPAA_ETH_UNIT_TESTS
+#ifdef CONFIG_FSL_DPAA_ETH_UNIT_TESTS
 	/* The unit test is designed to test private interfaces */
 	if (!priv->shared && !tx_unit_test_ran) {
 		err = dpa_tx_unit_test(net_dev);
@@ -4304,7 +4304,7 @@ static int __devexit __cold dpa_remove(struct platform_device *of_dev)
 	dpa_netdev_debugfs_remove(net_dev);
 #endif /* CONFIG_FSL_DPAA_ETH_DEBUGFS */
 
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid)
 		dpa_ptp_cleanup(priv);
 #endif
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 21e699c..40bac8a 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -57,7 +57,7 @@
 #endif /* CONFIG_FSL_DPAA_ETH_DEBUGFS */
 #include "dpaa_eth_trace.h"
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 #define dpa_get_rx_extra_headroom() fm_get_rx_extra_headroom()
 #else
 #define dpa_get_rx_extra_headroom() dpa_rx_extra_headroom
@@ -73,7 +73,7 @@
 	(dpa_get_max_frm() - (VLAN_ETH_HLEN + ETH_FCS_LEN))
 
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 /* We may want this value configurable. Must be <= PAGE_SIZE
  * A lower value may help with recycling rates, at least on forwarding
  */
@@ -94,7 +94,7 @@
 #define DPAA_ETH_TX_QUEUES	NR_CPUS
 #define DPAA_ETH_RX_QUEUES	128
 
-#if defined(CONFIG_DPAA_FMAN_UNIT_TESTS)
+#if defined(CONFIG_FSL_DPAA_FMAN_UNIT_TESTS)
 /*TODO: temporary for fman pcd testing */
 #define FMAN_PCD_TESTS_MAX_NUM_RANGES	20
 #endif
@@ -165,7 +165,7 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 
 #define DPA_SGT_MAX_ENTRIES 16 /* maximum number of entries in SG Table */
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 #define DEFAULT_SKB_COUNT 64 /* maximum number of SKBs in each percpu list */
 /*
  * Default amount data to be copied from the beginning of a frame into the
@@ -173,7 +173,7 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
  */
 #define DPA_COPIED_HEADERS_SIZE 128
 
-#endif /* CONFIG_DPAA_ETH_SG_SUPPORT */
+#endif /* CONFIG_FSL_DPAA_ETH_SG_SUPPORT */
 
 /*
  * Largest value that the FQD's OAL field can hold.
@@ -329,7 +329,7 @@ struct dpa_percpu_priv_s {
 	int *dpa_bp_count;
 	struct dpa_bp *dpa_bp;
 	struct napi_struct napi;
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 	/* a list of preallocated SKBs for this CPU */
 	struct sk_buff_head skb_list;
 	/* current number of skbs in the CPU's list */
@@ -355,7 +355,7 @@ struct dpa_priv_s {
 	struct list_head	 dpa_fq_list;
 	struct qman_fq		*egress_fqs[DPAA_ETH_TX_QUEUES];
 	struct qman_fq		*conf_fqs[DPAA_ETH_TX_QUEUES];
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	struct qman_fq		*recycle_fqs[DPAA_ETH_TX_QUEUES];
 #endif
 
@@ -367,11 +367,11 @@ struct dpa_priv_s {
 #endif /* CONFIG_FSL_DPAA_ETH_DEBUGFS */
 
 	uint32_t		 msg_enable;	/* net_device message level */
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	struct dpa_ptp_tsu	 *tsu;
 #endif
 
-#if defined(CONFIG_DPAA_FMAN_UNIT_TESTS)
+#if defined(CONFIG_FSL_DPAA_FMAN_UNIT_TESTS)
 /* TODO: this is temporary until pcd support is implemented in dpaa */
 	int			priv_pcd_num_ranges;
 	struct pcd_range	priv_pcd_ranges[FMAN_PCD_TESTS_MAX_NUM_RANGES];
@@ -394,10 +394,10 @@ struct dpa_priv_s {
 		u32 cgr_congested_count;
 	} cgr_data;
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	bool ts_tx_en; /* Tx timestamping enabled */
 	bool ts_rx_en; /* Rx timestamping enabled */
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	/*
 	 * Store here the needed Tx headroom for convenience and speed
@@ -433,7 +433,7 @@ void __hot _dpa_process_parse_results(const t_FmPrsResult *parse_results,
 				     int *use_gro,
 				     unsigned int *hdr_size __maybe_unused);
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 void dpa_bp_add_8_pages(const struct dpa_bp *dpa_bp, int cpu_id);
 int _dpa_bp_add_8_pages(const struct dpa_bp *dpa_bp);
 
@@ -544,7 +544,7 @@ static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
 	int err, i;
 	struct qman_fq *egress_fq;
 
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	/* Choose egress fq based on whether we want
 	 * to recycle the frame or not */
 	if (fd->cmd & FM_FD_CMD_FCO)
@@ -577,7 +577,7 @@ static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
 	return 0;
 }
 
-#if defined CONFIG_DPA_ETH_WQ_LEGACY
+#if defined CONFIG_FSL_DPAA_ETH_WQ_LEGACY
 #define DPA_NUM_WQS 8
 /*
  * Older WQ assignment: statically-defined FQIDs (such as PCDs) are assigned
@@ -590,7 +590,7 @@ static inline void _dpa_assign_wq(struct dpa_fq *fq)
 {
 	fq->wq = fq->fqid ? fq->fqid % DPA_NUM_WQS : DPA_NUM_WQS - 1;
 }
-#elif defined CONFIG_DPA_ETH_WQ_MULTI
+#elif defined CONFIG_FSL_DPAA_ETH_WQ_MULTI
 /*
  * Use multiple WQs for FQ assignment:
  *	- Tx Confirmation queues go to WQ1.
@@ -611,7 +611,7 @@ static inline void _dpa_assign_wq(struct dpa_fq *fq)
 		break;
 	case FQ_TYPE_RX_DEFAULT:
 	case FQ_TYPE_TX:
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	case FQ_TYPE_TX_RECYCLE:
 #endif
 	case FQ_TYPE_RX_PCD:
@@ -629,10 +629,10 @@ static inline void _dpa_assign_wq(struct dpa_fq *fq)
 #else
 /* This shouldn't happen, since we've made a "default" choice in the Kconfig. */
 #warning "No WQ assignment scheme chosen; Kconfig out-of-sync?"
-#endif /* CONFIG_DPA_ETH_WQ_ASSIGN_* */
+#endif /* CONFIG_FSL_DPAA_ETH_WQ_ASSIGN_* */
 
 
-#ifdef CONFIG_DPAA_ETH_USE_NDO_SELECT_QUEUE
+#ifdef CONFIG_FSL_DPAA_ETH_USE_NDO_SELECT_QUEUE
 /* Use in lieu of skb_get_queue_mapping() */
 #define dpa_get_queue_mapping(skb) \
 	smp_processor_id()
@@ -642,10 +642,10 @@ static inline void _dpa_assign_wq(struct dpa_fq *fq)
 	skb_get_queue_mapping(skb)
 #endif
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 /* Updates the skb shared hw timestamp from the hardware timestamp */
 int dpa_get_ts(const struct dpa_priv_s *priv, enum port_type rx_tx,
 	struct skb_shared_hwtstamps *shhwtstamps, const void *data);
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 #endif	/* __DPA_H */
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 48f32fe..a9c3f04 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -42,7 +42,7 @@
 #include "dpaa_eth.h"
 #include "dpaa_1588.h"
 
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
+#ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 #define DPA_SGT_MAX_ENTRIES 16 /* maximum number of entries in SG Table */
 
 /*
@@ -249,7 +249,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 		 */
 		sgt = phys_to_virt(addr + dpa_fd_offset(fd));
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (unlikely(priv->ts_tx_en &&
 			skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
 		struct skb_shared_hwtstamps shhwtstamps;
@@ -257,7 +257,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 		dpa_get_ts(priv, TX, &shhwtstamps, (void *)skbh);
 		skb_tstamp_tx(skb, &shhwtstamps);
 	}
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 		/* sgt[0] is from lowmem, was dma_map_single()-ed */
 		dma_unmap_single(dpa_bp->dev, sgt[0].addr,
@@ -280,7 +280,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 		/* Free separately the pages that we allocated on Tx */
 		free_page((unsigned long)phys_to_virt(addr));
 	}
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	else {
 		/* get the timestamp for non-SG frames */
 		if (unlikely(priv->ts_tx_en &&
@@ -291,7 +291,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 			skb_tstamp_tx(skb, &shhwtstamps);
 		}
 	}
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	return skb;
 }
@@ -318,7 +318,7 @@ static void __hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	vaddr = phys_to_virt(addr);
 
 	/* do we need the timestamp for bad frames? */
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
 		dpa_ptp_store_rxstamp(priv->net_dev, skb, fd);
 #endif
@@ -327,10 +327,10 @@ static void __hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	parse_results = (const t_FmPrsResult *)(vaddr + DPA_RX_PRIV_DATA_SIZE);
 	_dpa_process_parse_results(parse_results, fd, skb, use_gro, &copy_size);
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (priv->ts_rx_en)
 		dpa_get_ts(priv, RX, skb_hwtstamps(skb), vaddr);
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	tailptr = skb_put(skb, copy_size);
 
@@ -392,10 +392,10 @@ static void __hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 	/* Inspect the parse results before anything else. */
 	_dpa_process_parse_results(parse_results, fd, skb, use_gro, &copy_size);
 
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (priv->ts_rx_en)
 		dpa_get_ts(priv, RX, skb_hwtstamps(skb), vaddr);
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	/*
 	 * Iterate through the SGT entries and add the data buffers as
@@ -451,7 +451,7 @@ static void __hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 			break;
 	}
 
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
 		dpa_ptp_store_rxstamp(priv->net_dev, skb, fd);
 #endif
@@ -737,16 +737,16 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 	clear_fd(&fd);
 
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_tx_en_ioctl)
 		fd.cmd |= FM_FD_CMD_UPD;
 #endif
-#ifdef CONFIG_FSL_DPA_TS
+#ifdef CONFIG_FSL_DPAA_TS
 	if (unlikely(priv->ts_tx_en &&
 			skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP))
 		fd.cmd |= FM_FD_CMD_UPD;
 	skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
-#endif /* CONFIG_FSL_DPA_TS */
+#endif /* CONFIG_FSL_DPAA_TS */
 
 	/*
 	 * MAX_SKB_FRAGS is larger than our DPA_SGT_MAX_ENTRIES; make sure
@@ -823,4 +823,4 @@ enomem:
 	return NETDEV_TX_OK;
 }
 
-#endif /* CONFIG_DPAA_ETH_SG_SUPPORT */
+#endif /* CONFIG_FSL_DPAA_ETH_SG_SUPPORT */
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sysfs.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sysfs.c
index 24d64db..0b6072b 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sysfs.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sysfs.c
@@ -37,7 +37,7 @@
 #include <linux/io.h>
 #include <linux/of_net.h>
 #include "dpaa_eth.h"
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 #include "dpaa_1588.h"
 #endif
 
@@ -88,7 +88,7 @@ static ssize_t dpaa_eth_show_fqids(struct device *dev,
 		case FQ_TYPE_TX:
 			str = "Tx";
 			break;
-#ifdef CONFIG_DPA_TX_RECYCLE
+#ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 		case FQ_TYPE_TX_RECYCLE:
 			str = "Tx(recycling)";
 			break;
@@ -160,7 +160,7 @@ static ssize_t dpaa_eth_show_mac_regs(struct device *dev,
 }
 
 
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 static ssize_t dpaa_eth_show_ptp_1588(struct device *dev,
 			struct device_attribute *attr, char *buf)
 {
@@ -204,7 +204,7 @@ static struct device_attribute dpaa_eth_attrs[] = {
 	__ATTR(fqids, S_IRUGO, dpaa_eth_show_fqids, NULL),
 	__ATTR(dflt_bpid, S_IRUGO, dpaa_eth_show_dflt_bpid, NULL),
 	__ATTR(mac_regs, S_IRUGO, dpaa_eth_show_mac_regs, NULL),
-#ifdef CONFIG_FSL_DPA_1588
+#ifdef CONFIG_FSL_DPAA_1588
 	__ATTR(ptp_1588, S_IRUGO | S_IWUSR, dpaa_eth_show_ptp_1588,
 					dpaa_eth_set_ptp_1588),
 #endif
-- 
1.7.5.4

