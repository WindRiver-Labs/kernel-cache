From f955f08f9071ac03aff6322dc11477ad2b26cac4 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Fri, 10 May 2013 13:32:26 +0300
Subject: [PATCH 392/547] gianfar: Add BD rings allocation to L2 SRAM

When this option is enabled the driver will try to allocate the
buffer descriptors (BDs) to the L2 SRAM memory, using the
powerpc/85xx cache-sram support API for the P1/P2 QorIQ platforms.
For this to work, the size and the address of the SRAM region
must be provided as kernel boot params.
Should the attempt to allocate in L2 SRAM fail, the driver falls
back to normal allocation of BDs as before (i.e. to DDR).

The gfar_l2sram_en driver module param is provided to allow to
disable the allocation to L2 SRAM at driver level (enabled by
default).
Sysfs stubs allow to enable/diable allocation of BDs to L2 SRAM
for individual gianfar devices, as the L2 SRAM is an expensive
resource. By default, each device has this feature enabled.
This feature also disables the BD L2 stasing feature by default.
Stasing however may still be configured per device via sysfs.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: Ie967cd24c2c6d6654b33d175be0d9e3c785c324a
Reviewed-on: http://git.am.freescale.net:8181/2596
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Gupta Rajan-B15745 <rajan.gupta@freescale.com>
Reviewed-by: Sovaiala Cristian-Constantin-B39531 <Cristian.Sovaiala@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/Kconfig         |  1 +
 drivers/net/ethernet/freescale/gianfar.c       | 54 +++++++++++++++++++-------
 drivers/net/ethernet/freescale/gianfar.h       |  8 +++-
 drivers/net/ethernet/freescale/gianfar_sysfs.c | 46 ++++++++++++++++++++++
 4 files changed, 94 insertions(+), 15 deletions(-)

diff --git a/drivers/net/ethernet/freescale/Kconfig b/drivers/net/ethernet/freescale/Kconfig
index 49623d1..798da5d 100644
--- a/drivers/net/ethernet/freescale/Kconfig
+++ b/drivers/net/ethernet/freescale/Kconfig
@@ -86,6 +86,7 @@ config UGETH_TX_ON_DEMAND
 config GIANFAR
 	tristate "Gianfar Ethernet"
 	depends on FSL_SOC
+	select FSL_85XX_CACHE_SRAM
 	select FSL_PQ_MDIO
 	select PHYLIB
 	select CRC32
diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index fa9d21f..f0cf599 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -102,6 +102,7 @@
 #include <linux/of_net.h>
 
 #include "gianfar.h"
+#include <asm/fsl_85xx_cache_sram.h>
 
 #ifdef CONFIG_RX_TX_BUFF_XCHG
 #define RT_PKT_ID 0xff
@@ -174,6 +175,10 @@ module_param(gfar_skb_recycling_en, bool, 0444);
 MODULE_PARM_DESC(gfar_skb_recycling_en,
 	"Enable buffer recycling.");
 
+bool gfar_l2sram_en = true;
+module_param(gfar_l2sram_en, bool, 0444);
+MODULE_PARM_DESC(gfar_l2sram_en,
+	"Enable allocation to L2 SRAM.");
 
 MODULE_AUTHOR("Freescale Semiconductor, Inc");
 MODULE_DESCRIPTION("Gianfar Ethernet Driver");
@@ -259,8 +264,9 @@ static int gfar_init_bds(struct net_device *ndev)
 
 static int gfar_alloc_skb_resources(struct net_device *ndev)
 {
-	void *vaddr;
+	void *vaddr = NULL;
 	dma_addr_t addr;
+	phys_addr_t paddr;
 	int i, j, k;
 	struct gfar_private *priv = netdev_priv(ndev);
 	struct device *dev = priv->dev;
@@ -276,12 +282,23 @@ static int gfar_alloc_skb_resources(struct net_device *ndev)
 		priv->total_rx_ring_size += priv->rx_queue[i]->rx_ring_size;
 
 	/* Allocate memory for the buffer descriptors */
-	vaddr = dma_alloc_coherent(dev,
-				   (priv->total_tx_ring_size *
-				    sizeof(struct txbd8)) +
-				   (priv->total_rx_ring_size *
-				    sizeof(struct rxbd8)),
-				   &addr, GFP_KERNEL);
+	if (priv->bd_l2sram_en) {
+		vaddr = mpc85xx_cache_sram_alloc(BD_RING_REG_SZ(priv),
+						 &paddr, L1_CACHE_BYTES);
+		if (vaddr)
+			addr = phys_to_dma(dev, paddr);
+		else {
+			netif_info(priv, ifup, ndev, "%s, %s\n",
+				   "Could not allocate BDs to SRAM",
+				   "fallback to DDR");
+			priv->bd_l2sram_en = 0;
+		}
+	}
+
+	if (!priv->bd_l2sram_en)
+		vaddr = dma_alloc_coherent(dev, BD_RING_REG_SZ(priv),
+					   &addr, GFP_KERNEL);
+
 	if (!vaddr)
 		return -ENOMEM;
 
@@ -451,6 +468,10 @@ static void gfar_init_mac(struct net_device *ndev)
 	 */
 	attrs = ATTR_INIT_SETTINGS;
 
+	if (priv->bd_l2sram_en)
+		/* disable BD stashing to L2 */
+		priv->bd_stash_en = 0;
+
 	if (priv->bd_stash_en)
 		attrs |= ATTR_BDSTASH;
 
@@ -813,6 +834,10 @@ static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 		priv->bd_stash_en = 1;
 	}
 
+	if (gfar_l2sram_en)
+		/* try to alloc the BD rings to L2 SRAM */
+		priv->bd_l2sram_en = 1;
+
 	stash_len = of_get_property(np, "rx-stash-len", NULL);
 
 	if (stash_len)
@@ -832,13 +857,13 @@ static int gfar_of_init(struct platform_device *ofdev, struct net_device **pdev)
 		memcpy(dev->dev_addr, mac_addr, ETH_ALEN);
 
 	if (model && !strcasecmp(model, "TSEC"))
-		priv->device_flags = FSL_GIANFAR_DEV_HAS_GIGABIT |
+		priv->device_flags |= FSL_GIANFAR_DEV_HAS_GIGABIT |
 				     FSL_GIANFAR_DEV_HAS_COALESCE |
 				     FSL_GIANFAR_DEV_HAS_RMON |
 				     FSL_GIANFAR_DEV_HAS_MULTI_INTR;
 
 	if (model && !strcasecmp(model, "eTSEC"))
-		priv->device_flags = FSL_GIANFAR_DEV_HAS_GIGABIT |
+		priv->device_flags |= FSL_GIANFAR_DEV_HAS_GIGABIT |
 				     FSL_GIANFAR_DEV_HAS_COALESCE |
 				     FSL_GIANFAR_DEV_HAS_RMON |
 				     FSL_GIANFAR_DEV_HAS_MULTI_INTR |
@@ -2120,11 +2145,12 @@ static void free_skb_resources(struct gfar_private *priv)
 			free_skb_rx_queue(rx_queue);
 	}
 
-	dma_free_coherent(priv->dev,
-			  sizeof(struct txbd8) * priv->total_tx_ring_size +
-			  sizeof(struct rxbd8) * priv->total_rx_ring_size,
-			  priv->tx_queue[0]->tx_bd_base,
-			  priv->tx_queue[0]->tx_bd_dma_base);
+	if (priv->bd_l2sram_en)
+		mpc85xx_cache_sram_free(priv->tx_queue[0]->tx_bd_base);
+	else
+		dma_free_coherent(priv->dev, BD_RING_REG_SZ(priv),
+				  priv->tx_queue[0]->tx_bd_base,
+				  priv->tx_queue[0]->tx_bd_dma_base);
 
 	/* purge the skb recycle queue */
 	free_skb_recycle_q(&priv->recycle);
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index f6734a1..9ec96cd 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1315,7 +1315,9 @@ struct gfar_private {
 		/* Wake-on-LAN enabled */
 		wol_en:1,
 		/* Enable priorty based Tx scheduling in Hw */
-		prio_sched_en:1;
+		prio_sched_en:1,
+		/* L2 SRAM alloc of BDs enabled */
+		bd_l2sram_en:1;
 
 	struct net_device *recycle_ndev;
 	struct list_head recycle_node;
@@ -1352,6 +1354,9 @@ struct gfar_private {
 	unsigned int ftp_rqfcr[MAX_FILER_IDX + 1];
 };
 
+#define BD_RING_REG_SZ(priv) ( \
+	sizeof(struct txbd8) * (priv)->total_tx_ring_size + \
+	sizeof(struct rxbd8) * (priv)->total_rx_ring_size)
 
 static inline int gfar_has_errata(struct gfar_private *priv,
 				  enum gfar_errata err)
@@ -1421,6 +1426,7 @@ extern void gfar_vlan_mode(struct net_device *dev, netdev_features_t features);
 extern const struct ethtool_ops gfar_ethtool_ops;
 extern struct list_head gfar_recycle_queues;
 extern bool gfar_skb_recycling_en;
+extern bool gfar_l2sram_en;
 
 #define MAX_FILER_CACHE_IDX (2*(MAX_FILER_IDX))
 
diff --git a/drivers/net/ethernet/freescale/gianfar_sysfs.c b/drivers/net/ethernet/freescale/gianfar_sysfs.c
index 7de46a4..2f2c451 100644
--- a/drivers/net/ethernet/freescale/gianfar_sysfs.c
+++ b/drivers/net/ethernet/freescale/gianfar_sysfs.c
@@ -91,6 +91,51 @@ static ssize_t gfar_set_bd_stash(struct device *dev,
 
 static DEVICE_ATTR(bd_stash, 0644, gfar_show_bd_stash, gfar_set_bd_stash);
 
+static ssize_t gfar_show_bd_l2sram(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct gfar_private *priv = netdev_priv(to_net_dev(dev));
+
+	return sprintf(buf, "%s\n", priv->bd_l2sram_en ? "on" : "off");
+}
+
+static ssize_t gfar_set_bd_l2sram(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t count)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct gfar_private *priv = netdev_priv(ndev);
+	int new_setting = 0;
+
+	if (!gfar_l2sram_en)
+		return count;
+
+	/* Find out the new setting */
+	if (!strncmp("on", buf, count - 1) || !strncmp("1", buf, count - 1))
+		new_setting = 1;
+	else if (!strncmp("off", buf, count - 1) ||
+		 !strncmp("0", buf, count - 1))
+		new_setting = 0;
+	else
+		return count;
+
+	if (new_setting == priv->bd_l2sram_en)
+		/* nothing to do */
+		return count;
+
+	if (ndev->flags & IFF_UP)
+		stop_gfar(ndev);
+
+	priv->bd_l2sram_en = new_setting;
+
+	if (ndev->flags & IFF_UP)
+		startup_gfar(ndev);
+
+	return count;
+}
+
+static DEVICE_ATTR(bd_l2sram, 0644, gfar_show_bd_l2sram, gfar_set_bd_l2sram);
+
 static ssize_t gfar_show_rx_stash_size(struct device *dev,
 				       struct device_attribute *attr, char *buf)
 {
@@ -453,6 +498,7 @@ void gfar_init_sysfs(struct net_device *dev)
 
 	/* Create our sysfs files */
 	rc = device_create_file(&dev->dev, &dev_attr_bd_stash);
+	rc |= device_create_file(&dev->dev, &dev_attr_bd_l2sram);
 	rc |= device_create_file(&dev->dev, &dev_attr_rx_stash_size);
 	rc |= device_create_file(&dev->dev, &dev_attr_rx_stash_index);
 	rc |= device_create_file(&dev->dev, &dev_attr_fifo_threshold);
-- 
1.8.4.93.g57e4c17

