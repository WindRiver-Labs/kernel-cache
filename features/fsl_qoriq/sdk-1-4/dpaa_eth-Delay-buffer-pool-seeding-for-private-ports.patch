From 82d8e62178ac018dd9428e8fcb8fc1b85b9d82c1 Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Wed, 17 Apr 2013 19:42:34 +0000
Subject: [PATCH 201/547] dpaa_eth: Delay buffer pool seeding for private ports

Until now, all private ports had to be configured to use the same
buffer size, as they all share a common buffer pool.

Create the framework for working with different buffer sizes on the
private ports; a single, common buffer pool is still used by all
private ports.
The pool is seeded with buffers large enough to accomodate frames
for all private ports. In order to be able to compute the largest
needed buffer size, the buffer pool seeding is delayed until the
first private interface is raised.

Temporarily disable the boot-time ethernet unit test, which requires
the use of the common buffer pool.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: I22d40d136e35320b7b4af76e18e53faff7460cbf
Reviewed-on: http://git.am.freescale.net:8181/1466
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/Kconfig    |  5 +--
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c | 56 ++++++++++++++++++++-------
 2 files changed, 43 insertions(+), 18 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/Kconfig b/drivers/net/ethernet/freescale/dpa/Kconfig
index 1dbe8f1..6ef0918 100644
--- a/drivers/net/ethernet/freescale/dpa/Kconfig
+++ b/drivers/net/ethernet/freescale/dpa/Kconfig
@@ -91,7 +91,6 @@ config DPAA_ETH_USE_NDO_SELECT_QUEUE
 	  and use the standard XPS support instead.
 
 config DPAA_ETH_UNIT_TESTS
-	bool "Run Unit Tests for DPAA Ethernet"
+	bool
 	depends on DPA_ETH
-	default y
-
+	default n
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 334cafa..0ddb3fb 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -75,6 +75,10 @@
 /* DPAA platforms benefit from hardware-assisted queue management */
 #define DPA_NETIF_FEATURES	(0)
 
+#ifdef CONFIG_DPAA_ETH_UNIT_TESTS
+#undef CONFIG_DPAA_ETH_UNIT_TESTS
+#endif
+
 #define DEFAULT_COUNT		128
 #define REFILL_THRESHOLD	80
 
@@ -169,6 +173,8 @@ int dpa_free_pcd_fqids(struct device *, uint32_t) __attribute__((weak));
 static struct dpa_bp *dpa_bp_array[64];
 
 static struct dpa_bp *default_pool;
+static bool default_pool_seeded;
+static uint32_t default_buf_size;
 
 /* A set of callbacks for hooking into the fastpath at different points. */
 static struct dpaa_eth_hooks_s dpaa_eth_hooks;
@@ -484,7 +490,6 @@ dpa_bp_alloc(struct dpa_bp *dpa_bp)
 	dpa_bp->dev = &pdev->dev;
 
 	if (dpa_bp->kernel_pool) {
-		dpa_make_private_pool(dpa_bp);
 		if (!default_pool)
 			default_pool = dpa_bp;
 	} else {
@@ -1467,6 +1472,11 @@ static struct dpa_bp *dpa_size2pool(struct dpa_priv_s *priv, size_t size)
 	return ERR_PTR(-ENODEV);
 }
 
+static inline uint32_t dpa_bp_size(struct fm_port *rx_port)
+{
+	return DEFAULT_BUF_SIZE;
+}
+
 /**
  * Turn on HW checksum computation for this outgoing frame.
  * If the current protocol is not something we support in this regard
@@ -2702,6 +2712,7 @@ static int __cold dpa_start(struct net_device *net_dev)
 	int err, i;
 	struct dpa_priv_s *priv;
 	struct mac_device *mac_dev;
+	struct dpa_percpu_priv_s *percpu_priv;
 
 	priv = netdev_priv(net_dev);
 	mac_dev = priv->mac_dev;
@@ -2709,6 +2720,23 @@ static int __cold dpa_start(struct net_device *net_dev)
 	if (!mac_dev)
 		goto no_mac;
 
+	/* Seed the global buffer pool at the first ifconfig up
+	 * of a private port. Update the percpu buffer counters
+	 * of each private interface.
+	 */
+	if (!priv->shared && !default_pool_seeded) {
+		default_pool->size = default_buf_size;
+		dpa_make_private_pool(default_pool);
+		default_pool_seeded = true;
+	}
+	for_each_online_cpu(i) {
+		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
+		if (!priv->shared && !percpu_priv->dpa_bp)
+			percpu_priv->dpa_bp = priv->dpa_bp;
+			percpu_priv->dpa_bp_count =
+				per_cpu_ptr(priv->dpa_bp->percpu_count, i);
+	}
+
 	dpaa_eth_napi_enable(priv);
 
 	err = mac_dev->init_phy(net_dev);
@@ -2905,14 +2933,6 @@ dpa_bp_probe(struct platform_device *_of_dev, size_t *count)
 		goto _return_of_node_put;
 	} else if (has_kernel_pool) {
 		dpa_bp->target_count = DEFAULT_COUNT;
-		dpa_bp->size = DEFAULT_BUF_SIZE;
-#ifdef CONFIG_DPAA_ETH_SG_SUPPORT
-		if (dpa_bp->size > PAGE_SIZE) {
-			dev_warn(dev, "Default buffer size too large. "
-				     "Round down to PAGE_SIZE\n");
-			dpa_bp->size = PAGE_SIZE;
-		}
-#endif
 		dpa_bp->kernel_pool = 1;
 	}
 
@@ -3607,7 +3627,6 @@ dpaa_eth_init_rx_port(struct fm_port *port, struct dpa_bp *bp, size_t count,
 	for (i = 0; i < count; i++) {
 		if (i >= rx_port_param.num_pools)
 			break;
-
 		rx_port_param.pool_param[i].id = bp[i].bpid;
 		rx_port_param.pool_param[i].size = bp[i].size;
 	}
@@ -3772,9 +3791,6 @@ static int dpa_private_netdev_init(struct device_node *dpa_node,
 		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
 		percpu_priv->net_dev = net_dev;
 
-		percpu_priv->dpa_bp = priv->dpa_bp;
-		percpu_priv->dpa_bp_count =
-			per_cpu_ptr(priv->dpa_bp->percpu_count, i);
 #ifdef CONFIG_DPAA_ETH_SG_SUPPORT
 		/* init the percpu list and add some skbs */
 		skb_queue_head_init(&percpu_priv->skb_list);
@@ -3942,8 +3958,6 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		err = PTR_ERR(dpa_bp);
 		goto bp_probe_failed;
 	}
-	if (!dpa_bp->kernel_pool)
-		is_shared = true;
 
 	mac_dev = dpa_mac_probe(_of_dev);
 	if (IS_ERR(mac_dev)) {
@@ -3954,6 +3968,18 @@ dpaa_eth_probe(struct platform_device *_of_dev)
 		txport = mac_dev->port_dev[TX];
 	}
 
+	if (!dpa_bp->kernel_pool) {
+		is_shared = true;
+	} else {
+		/* For private ports, need to compute the size of the default
+		 * buffer pool, based on FMan port buffer layout;also update
+		 * the maximum buffer size for private ports if necessary
+		 */
+		dpa_bp->size = dpa_bp_size(rxport);
+		if (dpa_bp->size > default_buf_size)
+			default_buf_size = dpa_bp->size;
+	}
+
 	INIT_LIST_HEAD(&rxfqlist);
 	INIT_LIST_HEAD(&txfqlist);
 
-- 
1.8.4.93.g57e4c17

