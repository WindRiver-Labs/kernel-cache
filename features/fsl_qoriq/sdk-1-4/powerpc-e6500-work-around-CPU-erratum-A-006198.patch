From 9034a4879d8a1f1eaa667326537f1477b5bc68a0 Mon Sep 17 00:00:00 2001
From: Scott Wood <scottwood@freescale.com>
Date: Fri, 22 Mar 2013 19:00:12 -0500
Subject: [PATCH 010/547] powerpc/e6500: work around CPU erratum A-006198

Erratum A-006198 says that a CPU can hang if a certain race
occurs between threads, involving CFX instructions (which includes
mtmsr).  The workaround is to avoid using mtmsr to disable
MSR[EE/CE/DE].  To accomplish this, we use rfmci instead,
with some gymnastics to be resistant to races that overwrite
MCSRR0/MCSRR1.

Signed-off-by: Scott Wood <scottwood@freescale.com>
Signed-off-by: Andy Fleming <afleming@freescale.com>
Change-Id: I61de1d7b753723a1046cdb0ee1e07b9d41f8f162
Reviewed-on: http://git.am.freescale.net:8181/693
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/powerpc/include/asm/hw_irq.h      | 49 +++++++++++++++++++++++++++++++---
 arch/powerpc/include/asm/ppc_asm.h     | 43 +++++++++++++++++++++++++++++
 arch/powerpc/kernel/entry_64.S         |  6 ++---
 arch/powerpc/kernel/exceptions-64e.S   |  6 +++--
 arch/powerpc/kernel/idle_book3e.S      |  2 +-
 arch/powerpc/kernel/misc_64.S          |  3 +++
 arch/powerpc/kernel/ppc_ksyms.c        |  5 ++++
 arch/powerpc/mm/tlb_nohash_low.S       | 24 ++++++++---------
 arch/powerpc/platforms/Kconfig.cputype |  7 +++++
 9 files changed, 124 insertions(+), 21 deletions(-)

diff --git a/arch/powerpc/include/asm/hw_irq.h b/arch/powerpc/include/asm/hw_irq.h
index ba713f1..29a5a7a 100644
--- a/arch/powerpc/include/asm/hw_irq.h
+++ b/arch/powerpc/include/asm/hw_irq.h
@@ -89,7 +89,31 @@ static inline bool arch_irqs_disabled(void)
 
 #ifdef CONFIG_PPC_BOOK3E
 #define __hard_irq_enable()	asm volatile("wrteei 1" : : : "memory")
-#define __hard_irq_disable()	asm volatile("wrteei 0" : : : "memory")
+
+#ifdef CONFIG_FSL_ERRATUM_A_006198
+static inline void __hard_irq_disable(void)
+{
+	void fsl_erratum_a006198_return(void);
+	unsigned long tmp;
+
+	asm volatile("bl 2f;"
+		     "2: mflr %0;"
+		     "addi %0, %0, 1f-2b;"
+		     "mtlr %0;"
+		     "mtspr %1, %4;"
+		     "mfmsr %0;"
+		     "rlwinm %0, %0, 0, ~%3;"
+		     "mtspr %2, %0;"
+		     "rfmci;"
+		     "1: mtmsr %0" : "=&r" (tmp) :
+		     "i" (SPRN_MCSRR0), "i" (SPRN_MCSRR1),
+		     "i" (MSR_EE), "r" (*(u64 *)fsl_erratum_a006198_return) :
+		     "memory", "lr");
+}
+#else
+#define __hard_irq_disable()	asm volatile("wrteei 0" : : : "memory");
+#endif
+
 #else
 #define __hard_irq_enable()	__mtmsrd(local_paca->kernel_msr | MSR_EE, 1)
 #define __hard_irq_disable()	__mtmsrd(local_paca->kernel_msr, 1)
@@ -132,6 +156,8 @@ extern bool prep_irq_for_idle(void);
 
 #define SET_MSR_EE(x)	mtmsr(x)
 
+#define __hard_irq_disable()	asm volatile("wrteei 0" : : : "memory")
+
 static inline unsigned long arch_local_save_flags(void)
 {
 	return mfmsr();
@@ -140,7 +166,24 @@ static inline unsigned long arch_local_save_flags(void)
 static inline void arch_local_irq_restore(unsigned long flags)
 {
 #if defined(CONFIG_BOOKE)
+#ifdef CONFIG_FSL_ERRATUM_A_006198
+	void fsl_erratum_a006198_return(void);
+	unsigned long tmp;
+
+	asm volatile("bl 2f;"
+		     "2: mflr %0;"
+		     "addi %0, %0, 1f-2b;"
+		     "mtlr %0;"
+		     "mtspr %1, %3;"
+		     "mtspr %2, %4;"
+		     "rfmci;"
+		     "1: mtmsr %3" : "=&r" (tmp) :
+		     "i" (SPRN_MCSRR1), "i" (SPRN_MCSRR0),
+		     "r" (flags), "r" (*(u64 *)fsl_erratum_a006198_return) :
+		     "memory", "lr");
+#else
 	asm volatile("wrtee %0" : : "r" (flags) : "memory");
+#endif
 #else
 	mtmsr(flags);
 #endif
@@ -150,7 +193,7 @@ static inline unsigned long arch_local_irq_save(void)
 {
 	unsigned long flags = arch_local_save_flags();
 #ifdef CONFIG_BOOKE
-	asm volatile("wrteei 0" : : : "memory");
+	__hard_irq_disable();
 #else
 	SET_MSR_EE(flags & ~MSR_EE);
 #endif
@@ -160,7 +203,7 @@ static inline unsigned long arch_local_irq_save(void)
 static inline void arch_local_irq_disable(void)
 {
 #ifdef CONFIG_BOOKE
-	asm volatile("wrteei 0" : : : "memory");
+	__hard_irq_disable();
 #else
 	arch_local_irq_save();
 #endif
diff --git a/arch/powerpc/include/asm/ppc_asm.h b/arch/powerpc/include/asm/ppc_asm.h
index 2f1b6c5..c8200e6 100644
--- a/arch/powerpc/include/asm/ppc_asm.h
+++ b/arch/powerpc/include/asm/ppc_asm.h
@@ -844,6 +844,49 @@ END_FTR_SECTION_NESTED(CPU_FTR_HAS_PPR,CPU_FTR_HAS_PPR,946)
 #define N_SLINE	68
 #define N_SO	100
 
+.macro fsl_erratum_a006198_mtmsr newmsr scratch1 scratch2
+#ifdef CONFIG_FSL_ERRATUM_A_006198
+	mflr	\scratch2
+	LOAD_REG_IMMEDIATE(\scratch1, 237f)
+	mtlr	\scratch1
+	LOAD_REG_IMMEDIATE(\scratch1, .fsl_erratum_a006198_return)
+	mtspr	SPRN_MCSRR1, \newmsr
+	mtspr	SPRN_MCSRR0, \scratch1
+	rfmci
+237:	mtmsr	\newmsr
+	mtlr	\scratch2
+#else
+	mtmsr	\newmsr
+#endif
+.endm
+
+.macro fsl_erratum_a006198_wrteei0 scratch1 scratch2
+#ifdef CONFIG_FSL_ERRATUM_A_006198
+	mflr	\scratch2
+	LOAD_REG_IMMEDIATE(\scratch1, 237f)
+	mtlr	\scratch1
+	LOAD_REG_IMMEDIATE(\scratch1, .fsl_erratum_a006198_return)
+	mtspr	SPRN_MCSRR0, \scratch1
+	mfmsr	\scratch1
+	rlwinm	\scratch1, \scratch1, 0, ~MSR_EE
+	mtspr	SPRN_MCSRR1, \scratch1
+	rfmci
+237:	mtmsr	\scratch1
+	mtlr	\scratch2
+#else
+	wrteei	0
+#endif
+.endm
+
+.macro fsl_erratum_a006198_restore_srr scratch
+#ifdef CONFIG_FSL_ERRATUM_A_006198
+	LOAD_REG_IMMEDIATE(\scratch, .fsl_erratum_a006198_return)
+	mtspr	SPRN_MCSRR0, \scratch
+	lis	\scratch, MSR_CM@h
+	mtspr	SPRN_MCSRR1, \scratch
+#endif
+.endm
+
 #endif /*  __ASSEMBLY__ */
 
 #endif /* _ASM_POWERPC_PPC_ASM_H */
diff --git a/arch/powerpc/kernel/entry_64.S b/arch/powerpc/kernel/entry_64.S
index 38847767..5c78625 100644
--- a/arch/powerpc/kernel/entry_64.S
+++ b/arch/powerpc/kernel/entry_64.S
@@ -196,7 +196,7 @@ syscall_exit:
 	 * and so that we don't get interrupted after loading SRR0/1.
 	 */
 #ifdef CONFIG_PPC_BOOK3E
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r10 r9
 #else
 	ld	r10,PACAKMSR(r13)
 	/*
@@ -637,7 +637,7 @@ _GLOBAL(ret_from_except_lite)
 	 * from the interrupt.
 	 */
 #ifdef CONFIG_PPC_BOOK3E
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r10 r9
 #else
 	ld	r10,PACAKMSR(r13) /* Get kernel MSR without EE */
 	mtmsrd	r10,1		  /* Update machine state */
@@ -733,7 +733,7 @@ resume_kernel:
 	 * interrupted after loading SRR0/1.
 	 */
 #ifdef CONFIG_PPC_BOOK3E
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r10 r5
 #else
 	ld	r10,PACAKMSR(r13) /* Get kernel MSR without EE */
 	mtmsrd	r10,1		  /* Update machine state */
diff --git a/arch/powerpc/kernel/exceptions-64e.S b/arch/powerpc/kernel/exceptions-64e.S
index 1d9480c..0a8f99f 100644
--- a/arch/powerpc/kernel/exceptions-64e.S
+++ b/arch/powerpc/kernel/exceptions-64e.S
@@ -695,6 +695,7 @@ kernel_dbg_exc:
 	mtcr	r11
 	ld	r10,PACA_EXGEN+EX_R10(r13)
 	ld	r11,PACA_EXGEN+EX_R11(r13)
+	fsl_erratum_a006198_restore_srr r13
 	mfspr	r13,SPRN_SPRG_GEN_SCRATCH
 	rfi
 	b	.
@@ -799,7 +800,7 @@ _GLOBAL(exception_return_book3e)
  */
 	.globl fast_exception_return
 fast_exception_return:
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r0 r10
 1:	mr	r0,r13
 	ld	r10,_MSR(r1)
 	REST_4GPRS(2, r1)
@@ -835,6 +836,7 @@ fast_exception_return:
 	mtspr	SPRN_SRR1,r11
 	ld	r10,PACA_EXGEN+EX_R10(r13)
 	ld	r11,PACA_EXGEN+EX_R11(r13)
+	fsl_erratum_a006198_restore_srr r13
 	mfspr	r13,SPRN_SPRG_GEN_SCRATCH
 	rfi
 
@@ -1393,7 +1395,7 @@ _STATIC(init_thread_book3e)
 	mtspr	SPRN_EPCR,r3
 
 	/* Make sure interrupts are off */
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r3 r4
 
 	/* disable all timers and clear out status */
 	li	r3,0
diff --git a/arch/powerpc/kernel/idle_book3e.S b/arch/powerpc/kernel/idle_book3e.S
index bfb73cc..ee1f024 100644
--- a/arch/powerpc/kernel/idle_book3e.S
+++ b/arch/powerpc/kernel/idle_book3e.S
@@ -28,7 +28,7 @@ _GLOBAL(\name)
 	std	r0,16(r1)
 
 	/* Hard disable interrupts */
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r0 r3
 
 	/* Now check if an interrupt came in while we were soft disabled
 	 * since we may otherwise lose it (doorbells etc...).
diff --git a/arch/powerpc/kernel/misc_64.S b/arch/powerpc/kernel/misc_64.S
index 6820e45..27c3403 100644
--- a/arch/powerpc/kernel/misc_64.S
+++ b/arch/powerpc/kernel/misc_64.S
@@ -603,3 +603,6 @@ _GLOBAL(kexec_sequence)
 	li	r5,0
 	blr	/* image->start(physid, image->start, 0); */
 #endif /* CONFIG_KEXEC */
+
+_GLOBAL(fsl_erratum_a006198_return)
+	blr
diff --git a/arch/powerpc/kernel/ppc_ksyms.c b/arch/powerpc/kernel/ppc_ksyms.c
index c296665..c7be028 100644
--- a/arch/powerpc/kernel/ppc_ksyms.c
+++ b/arch/powerpc/kernel/ppc_ksyms.c
@@ -197,3 +197,8 @@ EXPORT_SYMBOL_GPL(mmu_psize_defs);
 #ifdef CONFIG_EPAPR_PARAVIRT
 EXPORT_SYMBOL(epapr_hypercall_start);
 #endif
+
+#ifdef CONFIG_FSL_ERRATUM_A_006198
+void fsl_erratum_a006198_return(void);
+EXPORT_SYMBOL(fsl_erratum_a006198_return);
+#endif
diff --git a/arch/powerpc/mm/tlb_nohash_low.S b/arch/powerpc/mm/tlb_nohash_low.S
index 4ba0da4..4f64fb1 100644
--- a/arch/powerpc/mm/tlb_nohash_low.S
+++ b/arch/powerpc/mm/tlb_nohash_low.S
@@ -352,12 +352,12 @@ ALT_MMU_FTR_SECTION_END_IFCLR(MMU_FTR_USE_TLBILX)
 _GLOBAL(_tlbil_pid)
 	slwi	r4,r3,MAS6_SPID_SHIFT
 	mfmsr	r10
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r0 r7
 	tlb_lock
 	mtspr	SPRN_MAS6,r4
 	PPC_TLBILX_PID(0,R0)
 	tlb_unlock
-	wrtee	r10
+	fsl_erratum_a006198_mtmsr r10 r0 r7
 	msync
 	isync
 	blr
@@ -366,30 +366,30 @@ _GLOBAL(_tlbil_pid_noind)
 	slwi	r4,r3,MAS6_SPID_SHIFT
 	mfmsr	r10
 	ori	r4,r4,MAS6_SIND
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r0 r7
 	tlb_lock
 	mtspr	SPRN_MAS6,r4
 	PPC_TLBILX_PID(0,R0)
 	tlb_unlock
-	wrtee	r10
+	fsl_erratum_a006198_mtmsr r10 r0 r7
 	msync
 	isync
 	blr
 
 _GLOBAL(_tlbil_all)
 	mfmsr	r10
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r0 r7
 	tlb_lock
 	PPC_TLBILX_ALL(0,R0)
 	msync
 	isync
 	tlb_unlock
-	wrtee	r10
+	fsl_erratum_a006198_mtmsr r10 r0 r7
 	blr
 
 _GLOBAL(_tlbil_va)
 	mfmsr	r10
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r0 r7
 	tlb_lock
 	cmpwi	cr0,r6,0
 	slwi	r4,r4,MAS6_SPID_SHIFT
@@ -401,12 +401,12 @@ _GLOBAL(_tlbil_va)
 	msync
 	isync
 	tlb_unlock
-	wrtee	r10
+	fsl_erratum_a006198_mtmsr r10 r0 r7
 	blr
 
 _GLOBAL(_tlbivax_bcast)
 	mfmsr	r10
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r0 r7
 	cmpwi	cr0,r6,0
 	slwi	r4,r4,MAS6_SPID_SHIFT
 	rlwimi	r4,r5,MAS6_ISIZE_SHIFT,MAS6_ISIZE_MASK
@@ -417,7 +417,7 @@ _GLOBAL(_tlbivax_bcast)
 	eieio
 	tlbsync
 	sync
-	wrtee	r10
+	fsl_erratum_a006198_mtmsr r10 r0 r7
 	blr
 
 _GLOBAL(set_context)
@@ -444,7 +444,7 @@ _GLOBAL(set_context)
  */
 _GLOBAL(loadcam_entry)
 	mfmsr	r10
-	wrteei	0
+	fsl_erratum_a006198_wrteei0 r0 r7
 	tlb_lock
 
 	LOAD_REG_ADDR(r4, TLBCAM)
@@ -467,6 +467,6 @@ END_MMU_FTR_SECTION_IFSET(MMU_FTR_BIG_PHYS)
 	isync
 
 	tlb_unlock
-	wrtee	r10
+	fsl_erratum_a006198_mtmsr r10 r0 r7
 	blr
 #endif
diff --git a/arch/powerpc/platforms/Kconfig.cputype b/arch/powerpc/platforms/Kconfig.cputype
index 4e8d387..c697163 100644
--- a/arch/powerpc/platforms/Kconfig.cputype
+++ b/arch/powerpc/platforms/Kconfig.cputype
@@ -173,6 +173,13 @@ config PPC_E6500_REV1_BUGS
           Do not define this if you are running on a simulator or rev2,
           and want features like hardware tablewalk.
 
+config FSL_ERRATUM_A_006198
+	bool "Work around e6500 rev1 erratum A-006198"
+	depends on PPC_E500MC
+	help
+	  Define this if running e6500 rev1, to avoid a source
+	  of hangs due to CPU erratum A-006198.
+
 config PPC_FPU
 	bool
 	default y if PPC64
-- 
1.8.4.93.g57e4c17

