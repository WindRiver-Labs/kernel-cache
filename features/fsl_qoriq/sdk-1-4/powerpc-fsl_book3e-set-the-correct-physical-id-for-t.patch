From a940b973015592f5ec456579127711c298ab4ec3 Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Wed, 20 Mar 2013 18:42:07 +0800
Subject: [PATCH 534/547] powerpc/fsl_book3e: set the correct physical id for
 the secondary thread in cpu hotplug

For the first booting, we would tweak the PIR register to get a
sequential physical id for all the threads. But in cpu hotplug,
the core will be reset when all the threads in a core are disabled.
That means the PIR register may contains the correct cpu physical id
or the hardware initialized value. And we don't have a way to
distinguish these two cases. We also can't set the cpu physical id
to a general register as what the kexec/kdump do since this register
will also be initialized after the core reset.

So we choose to get the cpu physical id from the PACA struct. Before
that we need to know the cpu logical id first. Fortunately we can
get this based on the current thread cpu logical id and TIR register.
This method also works for the booting.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/powerpc/kernel/exceptions-64e.S | 24 ++++++++++++++++++++++++
 arch/powerpc/kernel/head_64.S        | 36 +++++++++++++++++++++++++++++++-----
 2 files changed, 55 insertions(+), 5 deletions(-)

diff --git a/arch/powerpc/kernel/exceptions-64e.S b/arch/powerpc/kernel/exceptions-64e.S
index 527c87e..533bf31 100644
--- a/arch/powerpc/kernel/exceptions-64e.S
+++ b/arch/powerpc/kernel/exceptions-64e.S
@@ -1456,6 +1456,30 @@ BEGIN_FTR_SECTION
 	bne	1b
 
 #ifndef CONFIG_PPC_DISABLE_THREADS
+	/*
+	 * Get the cpu id of the thread0 and write this value to
+	 * __thread0_cpu_id.
+	 */
+	mfspr	r4,SPRN_PIR	/* The current thread physical id */
+	LOAD_REG_ADDR(r8, paca)	/* Get the current paca */
+	ld	r8,0(r8)
+	li	r5,0
+	LOAD_REG_ADDR(r7, nr_cpu_ids)
+	lwz	r7,0(r7)
+11:	lhz	r6,PACAHWCPUID(r8)
+	cmpw	r6,r4
+	beq	12f
+	addi	r8,r8,PACA_SIZE
+	addi	r5,r5,1
+	cmpw	r5,r7
+	blt	11b
+	b	.		/* Spin here if we can't find a matched paca. */
+
+12:	lhz	r4,PACAPACAINDEX(r8)
+	rlwinm	r4,r4,0,0,30	/* Get the thread0 cpu id. */
+	LOAD_REG_ADDR(r5, __thread0_cpu_id)
+	std	r4,0(r5)
+
 	/* Configure the MSR per the default */
 	LOAD_REG_IMMEDIATE(r4, MSR_KERNEL);
 
diff --git a/arch/powerpc/kernel/head_64.S b/arch/powerpc/kernel/head_64.S
index 490d1a8..eb44fc9 100644
--- a/arch/powerpc/kernel/head_64.S
+++ b/arch/powerpc/kernel/head_64.S
@@ -93,6 +93,15 @@ __secondary_hold_acknowledge:
 __run_at_kexec:
 	.llong	0x0	/* Flag for the secondary kernel from kexec. */
 
+	/*
+	 * The first thread will write this value with the logical id of
+	 * the thread0 and the secondary thread will calculate his logical
+	 * id based on this and the value in TIR register.
+	 */
+	.global __thread0_cpu_id
+__thread0_cpu_id:
+	.llong 0x0
+
 #ifdef CONFIG_RELOCATABLE
 	/* This flag is set to 1 by a loader if the kernel should run
 	 * at the loaded address instead of the linked address.  This
@@ -199,17 +208,34 @@ BEGIN_FTR_SECTION
 	mtspr   SPRN_BUCSR,r4
 	isync
 
-#if defined(CONFIG_KEXEC) || defined(CONFIG_CRASH_DUMP)
 	bl	.relative_toc
+#if defined(CONFIG_KEXEC) || defined(CONFIG_CRASH_DUMP)
 	LOAD_REG_ADDR(r4, __run_at_kexec)
 	ld	r4,0(r4)
 	cmpdi	r4,0
 	bne	1f
 #endif
-	mfspr	r4, SPRN_PIR
-	rlwimi	r4, r4, 30, 2, 30
-	mtspr	SPRN_PIR, r4
-	mr	r3,r4
+	/*
+	 * Get the cpu physical id, we can't use this method for kexec/kdump
+	 * because all the sencondary cores will run fsl_enable_threads
+	 * concurrently in kexec/kdump boot.
+	 */
+	LOAD_REG_ADDR(r3, __thread0_cpu_id)
+	ld	r3,0(r3)
+	mfspr	r4,SPRN_TIR	/* The thread0 cpu id plus TIR is the */
+	add	r3,r3,r4	/* logical id of the current thread. */
+	LOAD_REG_ADDR(r4, nr_cpu_ids)
+	lwz	r4,0(r4)
+	cmpld	r3,r4
+	bge	.
+
+	LOAD_REG_ADDR(r4, paca)
+	ld	r4,0(r4)
+	mulli	r3,r3,PACA_SIZE
+	add	r4,r4,r3
+	lhz	r3,PACAHWCPUID(r4)
+
+	mtspr	SPRN_PIR, r3
 1:
 END_FTR_SECTION_IFSET(CPU_FTR_SMT)
 #endif
-- 
1.8.4.93.g57e4c17

