From b168a1a3f2d77ec85daaea518a6d5c53e5d755a9 Mon Sep 17 00:00:00 2001
From: Varun Sethi <Varun.Sethi@freescale.com>
Date: Fri, 12 Apr 2013 12:33:19 +0530
Subject: [PATCH 106/547] iommu/fsl: PAMU driver fix for t4240.

While obtaining the stash destination from the device tree, current code
was assuming a single cpu reg property value. In case of t4240, the e6500
cpu node has two entries per reg property. Thus, for certain cpu values code
wasn't able to find a valid device tree node.

The code also lacked a check to identify if a valid cpu node (cpu node for a stash
target) had been found. Thus, resulting in a crash on null cpu node pointer access.

This patch fixes the issue, by introducing a mechanism to process all cpu
reg property values per cpu node. Also, introduced chek to identify if
cpu node corresponding to the stash vcpu has been found or not.

Additionally, added a check for l3-cache-controller compatible strings
for T4 and B4 devices.

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Change-Id: Iced2d9b85cb87a01a6cbc8cb1a592f92e9f7f704
Reviewed-on: http://git.am.freescale.net:8181/1276
Reviewed-by: Yoder Stuart-B08248 <stuart.yoder@freescale.com>
Reviewed-by: Schmitt Richard-B43082 <B43082@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/iommu/fsl_pamu.c | 33 +++++++++++++++++++++++++++------
 1 file changed, 27 insertions(+), 6 deletions(-)

diff --git a/drivers/iommu/fsl_pamu.c b/drivers/iommu/fsl_pamu.c
index 87b8de9..90c27cc 100644
--- a/drivers/iommu/fsl_pamu.c
+++ b/drivers/iommu/fsl_pamu.c
@@ -66,6 +66,22 @@ static const struct of_device_id guts_device_ids[] = {
 	{}
 };
 
+
+/*
+ * Table for matching compatible strings, for device tree
+ * L3 cache controller node.
+ * "fsl,t4240-l3-cache-controller" corresponds to T4,
+ * "fsl,b4860-l3-cache-controller" corresponds to B4 &
+ * "fsl,p4080-l3-cache-controller" corresponds to other,
+ * SOCs.
+*/
+static const struct of_device_id l3_device_ids[] = {
+	{ .compatible = "fsl,t4240-l3-cache-controller", },
+	{ .compatible = "fsl,b4860-l3-cache-controller", },
+	{ .compatible = "fsl,p4080-l3-cache-controller", },
+	{}
+};
+
 /* maximum subwindows permitted per liodn */
 static u32 max_subwindow_count;
 
@@ -521,12 +537,12 @@ u32 get_stash_id(u32 stash_dest_hint, u32 vcpu)
 	const u32 *prop;
 	struct device_node *node;
 	u32 cache_level;
-	int len;
+	int len, found = 0;
+	int i;
 
 	/* Fastpath, exit early if L3/CPC cache is target for stashing */
 	if (stash_dest_hint == IOMMU_ATTR_CACHE_L3) {
-		node = of_find_compatible_node(NULL, NULL,
-				"fsl,p4080-l3-cache-controller");
+		node = of_find_matching_node(NULL, l3_device_ids);
 		if (node) {
 			prop = of_get_property(node, "cache-stash-id", 0);
 			if (!prop) {
@@ -542,12 +558,17 @@ u32 get_stash_id(u32 stash_dest_hint, u32 vcpu)
 
 	for_each_node_by_type(node, "cpu") {
 		prop = of_get_property(node, "reg", &len);
-		if (be32_to_cpup(prop) == vcpu)
-			break;
+		for (i = 0; i < len / sizeof(u32); i++) {
+			if (be32_to_cpup(&prop[i]) == vcpu) {
+				found = 1;
+				goto found_cpu_node;
+			}
+		}
 	}
+found_cpu_node:
 
 	/* find the hwnode that represents the cache */
-	for (cache_level = IOMMU_ATTR_CACHE_L1; cache_level < IOMMU_ATTR_CACHE_L3; cache_level++) {
+	for (cache_level = IOMMU_ATTR_CACHE_L1; cache_level < IOMMU_ATTR_CACHE_L3 && found; cache_level++) {
 		if (stash_dest_hint == cache_level) {
 			prop = of_get_property(node, "cache-stash-id", 0);
 			if (!prop) {
-- 
1.8.4.93.g57e4c17

