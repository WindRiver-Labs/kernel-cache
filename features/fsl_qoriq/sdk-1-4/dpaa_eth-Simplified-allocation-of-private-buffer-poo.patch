From 62a09a350d1eaa608712d3a985cabec0f68a0f16 Mon Sep 17 00:00:00 2001
From: Marian Rotariu <marian.rotariu@freescale.com>
Date: Fri, 24 May 2013 13:05:43 +0300
Subject: [PATCH 224/547] dpaa_eth: Simplified allocation of private buffer
 pool

With this patch, some unnecessary instructions are removed.
There is no need to know the CPU that executes the allocation
procedure. This will eliminate some of dpa_make_private_pool()
requirements (no need to disable thread migration or preemption).

The CPU whose counters will be updated must now be provided to
dpa_bp_add_8().

Change-Id: I09bc88a69649cd52ad1b0055c00117cff5313eac
Signed-off-by: Marian Rotariu <marian.rotariu@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/2689
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Radulescu Ruxandra Ioana-B05472 <ruxandra.radulescu@freescale.com>
Reviewed-by: Hamciuc Bogdan-BHAMCIU1 <bogdan.hamciuc@freescale.com>
Reviewed-by: Sovaiala Cristian-Constantin-B39531 <Cristian.Sovaiala@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c | 28 ++++++++++++---------------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index be298d7..29e7746 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -271,7 +271,10 @@ copy_to_unmapped_area(dma_addr_t phys_start, void *src, size_t buf_size)
 }
 
 #ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
-static void dpa_bp_add_8(const struct dpa_bp *dpa_bp)
+/* Allocate 8 socket buffers.
+ * These buffers are counted for a particular CPU.
+ */
+static void dpa_bp_add_8(const struct dpa_bp *dpa_bp, unsigned int cpu)
 {
 	struct bm_buffer bmb[8];
 	struct sk_buff **skbh;
@@ -280,7 +283,7 @@ static void dpa_bp_add_8(const struct dpa_bp *dpa_bp)
 	struct sk_buff *skb;
 	int *count_ptr;
 
-	count_ptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+	count_ptr = per_cpu_ptr(dpa_bp->percpu_count, cpu);
 
 	for (i = 0; i < 8; i++) {
 		/*
@@ -345,21 +348,10 @@ void dpa_make_private_pool(struct dpa_bp *dpa_bp)
 
 	/* Give each cpu an allotment of "count" buffers */
 	for_each_online_cpu(i) {
-		int *thiscount;
-		int *countptr;
 		int j;
-		thiscount = per_cpu_ptr(dpa_bp->percpu_count,
-				smp_processor_id());
-		countptr = per_cpu_ptr(dpa_bp->percpu_count, i);
 
 		for (j = 0; j < dpa_bp->target_count; j += 8)
-			dpa_bp_add_8(dpa_bp);
-
-		/* Adjust the counts */
-		*countptr = j;
-
-		if (countptr != thiscount)
-			*thiscount = *thiscount - j;
+			dpa_bp_add_8(dpa_bp, i);
 	}
 }
 #endif /* CONFIG_FSL_DPAA_ETH_SG_SUPPORT */
@@ -396,13 +388,17 @@ static void dpaa_eth_refill_bpools(struct dpa_priv_s *priv,
 	int *countptr = percpu_priv->dpa_bp_count;
 	int count = *countptr;
 	const struct dpa_bp *dpa_bp = percpu_priv->dpa_bp;
-
 #ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
+	/* this function is called in softirq context;
+	 * no need to protect smp_processor_id() on RT kernel
+	 */
+	unsigned int cpu = smp_processor_id();
+
 	if (unlikely(count < CONFIG_FSL_DPAA_ETH_REFILL_THRESHOLD)) {
 		int i;
 
 		for (i = count; i < CONFIG_FSL_DPAA_ETH_MAX_BUF_COUNT; i += 8)
-			dpa_bp_add_8(dpa_bp);
+			dpa_bp_add_8(dpa_bp, cpu);
 	}
 #else
 	/* Add pages to the buffer pool */
-- 
1.8.4.93.g57e4c17

