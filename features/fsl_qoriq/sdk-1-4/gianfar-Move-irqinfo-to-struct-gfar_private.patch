From 771e1bba23062baff149cae9213bfec891a8df64 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Thu, 21 Mar 2013 10:25:57 +0200
Subject: [PATCH 379/547] gianfar: Move irqinfo to struct gfar_private

Make room in gfar_priv_grp for new runtime performance
critical members. The access to the irqinfo pointers is
not performance critical.
This implies also that grp->grp_id and grp->priv need to
be set before the first gfar_irq() call, which is a
trivial change.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: I69443e732cf1ad6bcbb2ee65cd614698abf259f4
Reviewed-on: http://git.am.freescale.net:8181/1163
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c | 18 ++++++++++--------
 drivers/net/ethernet/freescale/gianfar.h |  6 +++---
 2 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 97dc8e2..2017b54 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -546,10 +546,10 @@ static void free_gfar_dev(struct gfar_private *priv)
 {
 	int i, j;
 
-	for (i = 0; i < priv->num_grps; i++)
+	for (i = 0; i < MAXGROUPS; i++)
 		for (j = 0; j < GFAR_NUM_IRQS; j++) {
-			kfree(priv->gfargrp[i].irqinfo[j]);
-			priv->gfargrp[i].irqinfo[j] = NULL;
+			kfree(priv->irqinfo[i][j]);
+			priv->irqinfo[i][j] = NULL;
 		}
 
 	free_netdev(priv->ndev);
@@ -579,16 +579,20 @@ static int gfar_parse_group(struct device_node *np,
 	int i;
 
 	for (i = 0; i < GFAR_NUM_IRQS; i++) {
-		grp->irqinfo[i] = kzalloc(sizeof(struct gfar_irqinfo),
-					  GFP_KERNEL);
-		if (!grp->irqinfo[i])
+		struct gfar_irqinfo *irqinfo = NULL;
+
+		irqinfo = kzalloc(sizeof(*irqinfo), GFP_KERNEL);
+		if (!irqinfo)
 			return -ENOMEM;
+		priv->irqinfo[priv->num_grps][i] = irqinfo;
 	}
 
 	grp->regs = of_iomap(np, 0);
 	if (!grp->regs)
 		return -ENOMEM;
 
+	grp->grp_id = priv->num_grps;
+	grp->priv = priv;
 	gfar_irq(grp, TX)->irq = irq_of_parse_and_map(np, 0);
 
 	/* If we aren't the FEC we have multiple interrupts */
@@ -601,8 +605,6 @@ static int gfar_parse_group(struct device_node *np,
 			return -EINVAL;
 	}
 
-	grp->grp_id = priv->num_grps;
-	grp->priv = priv;
 	spin_lock_init(&grp->grplock);
 	if (priv->mode == MQ_MG_MODE) {
 		queue_mask = (u32 *)of_get_property(np, "fsl,rx-bit-map", NULL);
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 551ec37..0c81172 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1171,12 +1171,10 @@ struct gfar_priv_grp {
 	unsigned int tstat;
 	unsigned long num_tx_queues;
 	unsigned long tx_bit_map;
-
-	struct gfar_irqinfo *irqinfo[GFAR_NUM_IRQS];
 };
 
 #define gfar_irq(grp, ID) \
-	((grp)->irqinfo[GFAR_##ID])
+	((grp)->priv->irqinfo[(grp)->grp_id][GFAR_##ID])
 
 enum gfar_errata {
 	GFAR_ERRATA_74		= 0x01,
@@ -1252,6 +1250,8 @@ struct gfar_private {
 	int oldduplex;
 	int oldlink;
 
+	struct gfar_irqinfo *irqinfo[MAXGROUPS][GFAR_NUM_IRQS];
+
 	/* Bitfield update lock */
 	spinlock_t bflock;
 
-- 
1.8.4.93.g57e4c17

