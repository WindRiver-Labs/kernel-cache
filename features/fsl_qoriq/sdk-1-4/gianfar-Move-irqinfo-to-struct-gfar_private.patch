From 61fc6add08b36c5700e8f7957ee6630905cbe13c Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Fri, 9 Aug 2013 11:17:00 +0800
Subject: [PATCH 422/430] gianfar: Move irqinfo to struct gfar_private

Make room in gfar_priv_grp for new runtime performance
critical members. The access to the irqinfo pointers is
not performance critical.
This implies also that grp->grp_id and grp->priv need to
be set before the first gfar_irq() call, which is a
trivial change.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: I69443e732cf1ad6bcbb2ee65cd614698abf259f4
Reviewed-on: http://git.am.freescale.net:8181/1163
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch is from QorIQ-SDK-V1.4-20130625-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   18 ++++++++++--------
 drivers/net/ethernet/freescale/gianfar.h |    6 +++---
 2 files changed, 13 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 1a5e170..0307326 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -623,10 +623,10 @@ static void free_gfar_dev(struct gfar_private *priv)
 {
 	int i, j;
 
-	for (i = 0; i < priv->num_grps; i++)
+	for (i = 0; i < MAXGROUPS; i++)
 		for (j = 0; j < GFAR_NUM_IRQS; j++) {
-			kfree(priv->gfargrp[i].irqinfo[j]);
-			priv->gfargrp[i].irqinfo[j] = NULL;
+			kfree(priv->irqinfo[i][j]);
+			priv->irqinfo[i][j] = NULL;
 		}
 
 	free_netdev(priv->ndev);
@@ -662,16 +662,20 @@ static int gfar_parse_group(struct device_node *np,
 	int i;
 
 	for (i = 0; i < GFAR_NUM_IRQS; i++) {
-		grp->irqinfo[i] = kzalloc(sizeof(struct gfar_irqinfo),
-					  GFP_KERNEL);
-		if (!grp->irqinfo[i])
+		struct gfar_irqinfo *irqinfo = NULL;
+
+		irqinfo = kzalloc(sizeof(*irqinfo), GFP_KERNEL);
+		if (!irqinfo)
 			return -ENOMEM;
+		priv->irqinfo[priv->num_grps][i] = irqinfo;
 	}
 
 	grp->regs = of_iomap(np, 0);
 	if (!grp->regs)
 		return -ENOMEM;
 
+	grp->grp_id = priv->num_grps;
+	grp->priv = priv;
 	gfar_irq(grp, TX)->irq = irq_of_parse_and_map(np, 0);
 
 	/* If we aren't the FEC we have multiple interrupts */
@@ -684,8 +688,6 @@ static int gfar_parse_group(struct device_node *np,
 			return -EINVAL;
 	}
 
-	grp->grp_id = priv->num_grps;
-	grp->priv = priv;
 	spin_lock_init(&grp->grplock);
 	if(priv->mode == MQ_MG_MODE) {
 		queue_mask = (u32 *)of_get_property(np,
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 8b32b2c..bd72cd7 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1226,12 +1226,10 @@ struct gfar_priv_grp {
 	u32 rstat_prev;
 	unsigned long num_tx_queues;
 	unsigned long tx_bit_map;
-
-	struct gfar_irqinfo *irqinfo[GFAR_NUM_IRQS];
 };
 
 #define gfar_irq(grp, ID) \
-	((grp)->irqinfo[GFAR_##ID])
+	((grp)->priv->irqinfo[(grp)->grp_id][GFAR_##ID])
 
 enum gfar_errata {
 	GFAR_ERRATA_74		= 0x01,
@@ -1333,6 +1331,8 @@ struct gfar_private {
 	int oldduplex;
 	int oldlink;
 
+	struct gfar_irqinfo *irqinfo[MAXGROUPS][GFAR_NUM_IRQS];
+
 	/* Bitfield update lock */
 	spinlock_t bflock;
 
-- 
1.7.5.4

