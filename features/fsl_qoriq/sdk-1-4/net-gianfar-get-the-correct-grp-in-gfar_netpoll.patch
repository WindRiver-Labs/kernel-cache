From 61ae435abc10047a9cc78d221b182d4ae096f4dd Mon Sep 17 00:00:00 2001
From: Kevin Hao <kexin.hao@windriver.com>
Date: Tue, 21 Jan 2014 11:02:11 +0800
Subject: [PATCH 3/3] net/gianfar: get the correct grp in gfar_netpoll()

The '&priv->gfargrp[priv->num_grps]' will yield an address which is
beyond the end of 'gfargrp' array if the 'num_grps' is equal to
'MAXGROUPS'. Actually we should get the correct corresponding 'grp'
for each iteration

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   12 +++++++-----
 1 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index d3a1313..587ffa2 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -4054,26 +4054,28 @@ static int gfar_poll_tx(struct napi_struct *napi, int budget)
 static void gfar_netpoll(struct net_device *dev)
 {
 	struct gfar_private *priv = netdev_priv(dev);
- 	struct gfar_priv_grp *grp = &priv->gfargrp[priv->num_grps];
+	struct gfar_priv_grp *grp;
 	int i = 0;
 
 	/* If the device has multiple interrupts, run tx/rx */
 	if (priv->device_flags & FSL_GIANFAR_DEV_HAS_MULTI_INTR) {
 		for (i = 0; i < priv->num_grps; i++) {
+			grp = &priv->gfargrp[i];
+
 			disable_irq(gfar_irq(grp, TX)->irq);
 			disable_irq(gfar_irq(grp, RX)->irq);
 			disable_irq(gfar_irq(grp, ER)->irq);
-			gfar_interrupt(gfar_irq(grp, TX)->irq,
-						&priv->gfargrp[i]);
+			gfar_interrupt(gfar_irq(grp, TX)->irq, grp);
 			enable_irq(gfar_irq(grp, ER)->irq);
 			enable_irq(gfar_irq(grp, RX)->irq);
 			enable_irq(gfar_irq(grp, TX)->irq);
 		}
 	} else {
 		for (i = 0; i < priv->num_grps; i++) {
+			grp = &priv->gfargrp[i];
+
 			disable_irq(gfar_irq(grp, TX)->irq);
-			gfar_interrupt(gfar_irq(grp, TX)->irq,
-						&priv->gfargrp[i]);
+			gfar_interrupt(gfar_irq(grp, TX)->irq, grp);
 			enable_irq(gfar_irq(grp, ER)->irq);
 		}
 	}
-- 
1.7.5.4

