From 95b35938590885d7c6887d119cbae69bbba205e7 Mon Sep 17 00:00:00 2001
From: Priyanka Jain <Priyanka.Jain@freescale.com>
Date: Tue, 23 Apr 2013 10:45:41 +0530
Subject: [PATCH 151/430] fsl_qbman: Enable preemption in
 bman_create_affine_portal()

bman_create_affine_portal() calls bman_create_portal() which in turn calls
request_irq() to register portal_isr.
In case of PREEMPT_RT enabled, request_irq() is converted into
request_threaded_irq() as portal_isr is threaded IRQ handler. But this
request_threaded_irq() can sleep, so it is mandatory to call
request_threaded_irq() only from context that can sleep.

bman_create_affine_portal() is called from context that is already affine
to CPU or in other words this is non-migratable to other CPUs. Hence, it is
not required to run this function in non-preemptible context. Enabling
preemption will allow subsequent functions to sleep.

Call put_affine_portal() on entry i.e. before calling bman_create_portal()
to enable preemption.

Signed-off-by: Priyanka Jain <Priyanka.Jain@freescale.com>

Fixes CQ: ENGR00259733
	kernel crash in bman_init when PREEMPT_RT is enabled

Change-Id: I628b6fbc986a5bd980ffa68af4fd1ec7a2661758
Reviewed-on: http://git.am.freescale.net:8181/1717
Reviewed-by: Medve Emilian-EMMEDVE1 <Emilian.Medve@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[original patch is from QorIQ-SDK-V1.4-20130625-yocto]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/bman_high.c |    8 +++++++-
 1 files changed, 7 insertions(+), 1 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index 9a4f0d2..8487f98 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -302,13 +302,19 @@ struct bman_portal *bman_create_affine_portal(
 			const struct bm_portal_config *config)
 {
 	struct bman_portal *portal = get_raw_affine_portal();
+
+	/*This function is called from the context which is already affine to
+	 *CPU or in other words this in non-migratable to other CPUs. Call
+	 *put_affine_portal() on entry which allows subsequent functions to
+	 *sleep.
+	 */
+	put_affine_portal();
 	portal = bman_create_portal(portal, config);
 	if (portal) {
 		spin_lock(&affine_mask_lock);
 		cpumask_set_cpu(config->public_cfg.cpu, &affine_mask);
 		spin_unlock(&affine_mask_lock);
 	}
-	put_affine_portal();
 	return portal;
 }
 
-- 
1.7.5.4

