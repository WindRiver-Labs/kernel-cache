From ecd24862d8e9f3500972de0ba49f3b7dfa590e21 Mon Sep 17 00:00:00 2001
From: Varun Sethi <Varun.Sethi@freescale.com>
Date: Fri, 12 Jul 2013 18:38:24 +0530
Subject: [PATCH] Put the PCI specific code in the PAMU driver under
 CONFIG_PCI.

This fixes the problem where the kernel build breaks, when PCI
support is disabled.

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Change-Id: I698626ec0a40ba81ef132890bc339c6be10d8673
Reviewed-on: http://git.am.freescale.net:8181/3282
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.5-SOURCE-20131219-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/iommu/fsl_pamu_domain.c |   28 ++++++++++++++++++++--------
 1 files changed, 20 insertions(+), 8 deletions(-)

diff --git a/drivers/iommu/fsl_pamu_domain.c b/drivers/iommu/fsl_pamu_domain.c
index 776b803..4943b6c 100644
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@ -691,6 +691,7 @@ static int fsl_pamu_attach_device(struct iommu_domain *domain,
 	const u32 *liodn;
 	u32 liodn_cnt;
 	int len, ret = 0;
+#ifdef CONFIG_PCI
 	struct pci_dev *pdev = NULL;
 	struct pci_controller *pci_ctl;
 
@@ -708,6 +709,7 @@ static int fsl_pamu_attach_device(struct iommu_domain *domain,
 		 */
 		dev = pci_ctl->parent;
 	}
+#endif
 
 	liodn = of_get_property(dev->of_node, "fsl,liodn", &len);
 	if (liodn) {
@@ -729,6 +731,7 @@ static void fsl_pamu_detach_device(struct iommu_domain *domain,
 	struct fsl_dma_domain *dma_domain = domain->priv;
 	const u32 *prop;
 	int len;
+#ifdef CONFIG_PCI
 	struct pci_dev *pdev = NULL;
 	struct pci_controller *pci_ctl;
 
@@ -746,6 +749,7 @@ static void fsl_pamu_detach_device(struct iommu_domain *domain,
 		 */
 		dev = pci_ctl->parent;
 	}
+#endif
 
 	prop = of_get_property(dev->of_node, "fsl,liodn", &len);
 	if (prop)
@@ -901,12 +905,6 @@ static int fsl_pamu_get_domain_attr(struct iommu_domain *domain,
 	return ret;
 }
 
-static void swap_pci_ref(struct pci_dev **from, struct pci_dev *to)
-{
-	pci_dev_put(*from);
-	*from = to;
-}
-
 static struct iommu_group *get_device_iommu_group(struct device *dev)
 {
 	struct iommu_group *group;
@@ -918,6 +916,13 @@ static struct iommu_group *get_device_iommu_group(struct device *dev)
 	return group;
 }
 
+#ifdef CONFIG_PCI
+static void swap_pci_ref(struct pci_dev **from, struct pci_dev *to)
+{
+	pci_dev_put(*from);
+	*from = to;
+}
+
 static  bool check_pci_ctl_endpt_part(struct pci_controller *pci_ctl)
 {
 	u32 version;
@@ -1014,12 +1019,14 @@ static struct iommu_group *get_pci_device_group(struct pci_dev *pdev)
 
 	return group;
 }
+#endif
 
 static int fsl_pamu_add_device(struct device *dev)
 {
 	struct iommu_group *group = NULL;
-	struct pci_dev *pdev;
 	int ret;
+#ifdef CONFIG_PCI
+	struct pci_dev *pdev;
 
 	/*
 	 * For platform devices we allocate a separate group for
@@ -1034,6 +1041,7 @@ static int fsl_pamu_add_device(struct device *dev)
 		group = get_pci_device_group(pdev);
 
 	} else
+#endif
 		group = get_device_iommu_group(dev);
 
 	if (!group || IS_ERR(group))
@@ -1108,8 +1116,9 @@ static u32 fsl_pamu_get_windows(struct iommu_domain *domain)
 
 static struct iommu_domain *fsl_get_dev_domain(struct device *dev)
 {
-	struct pci_controller *pci_ctl;
 	struct device_domain_info *info;
+#ifdef CONFIG_PCI
+	struct pci_controller *pci_ctl;
 	struct pci_dev *pdev;
 
 	/*
@@ -1127,6 +1136,7 @@ static struct iommu_domain *fsl_get_dev_domain(struct device *dev)
 		 */
 		dev = pci_ctl->parent;
 	}
+#endif
 
 	info = dev->archdata.iommu_domain;
 	if (info && info->domain)
@@ -1162,7 +1172,9 @@ int pamu_domain_init()
 		return ret;
 
 	bus_set_iommu(&platform_bus_type, &fsl_pamu_ops);
+#ifdef CONFIG_PCI
 	bus_set_iommu(&pci_bus_type, &fsl_pamu_ops);
+#endif
 
 	return ret;
 }
-- 
1.7.5.4

