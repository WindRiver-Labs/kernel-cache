From 21a586d59e64cae1631170e829f3673c40163494 Mon Sep 17 00:00:00 2001
From: Xulin Sun <xulin.sun@windriver.com>
Date: Tue, 5 Nov 2013 13:20:58 +0800
Subject: [PATCH] preempt_rt gianfar replace preempt disable with lock to
 prevent call trace

During gfar_poll_tx operation, introduce sleep spinlocks call
trace:

BUG: sleeping function called from invalid context at kernel/rtmutex.c:659
PU: 0 PID: 125 Comm: irq/31-eth2_g0_ Not tainted
3.10.10-rt3-WR6.0.0.0_preempt-rt #8
Call Trace:
[c777fc70] [c000853c] show_stack+0xf8/0x1b0 (unreliable)
[c777fcc0] [c06d2c3c] rt_spin_lock+0x34/0x8c
[c777fcd0] [c007ed30] __wake_up_sync_key+0x3c/0x88
[c777fcf0] [c05a40a8] sock_def_write_space+0x68/0xc4
[c777fd00] [c05a6068] sock_wfree+0xa8/0xb0
[c777fd10] [c05a8714] skb_release_head_state+0x98/0xfc
[c777fd20] [c05a87a0] skb_recycle+0x28/0x90
[c777fd40] [c04c102c] gfar_poll_tx+0x470/0x6ac
[c777fde0] [c05b9e28] net_rx_action+0x150/0x294
[c777fe20] [c004c8c4] do_current_softirqs+0x1c8/0x324
[c777fe70] [c004ca9c] local_bh_enable+0x7c/0x80
[c777fe80] [c00cd858] irq_forced_thread_fn+0x5c/0xa0
[c777fea0] [c00cdbbc] irq_thread+0x114/0x168
[c777fee0] [c006dcd0] kthread+0xa4/0xa8
[c777ff40] [c0010538] ret_from_kernel_thread+0x5c/0x64

The reason is that gfar_recycle_skb calling the function skb_recycle with
preempt disable situation, skb_recycle finally calling the spin_lock.

Here for the critical data protection, with atomic operation and add lock
replaced the preempt disable protection to avoid the call trace.

Signed-off-by: Xulin Sun <xulin.sun@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c       | 25 ++++++++-----------------
 drivers/net/ethernet/freescale/gianfar.h       |  4 ++--
 drivers/net/ethernet/freescale/gianfar_sysfs.c |  3 ++-
 3 files changed, 12 insertions(+), 20 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 7951e19..90fb262 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -1156,8 +1156,8 @@ static void gfar_init_recycle(struct gfar_private *priv)
 		struct gfar_priv_recycle_local *local;
 		local = per_cpu_ptr(rec->local, cpu);
 		skb_queue_head_init(&local->recycle_q);
-		local->recycle_cnt = 0;
-		local->reuse_cnt = 0;
+		atomic_set(&local->recycle_cnt, 0);
+		atomic_set(&local->reuse_cnt, 0);
 	}
 
 	list_add(&priv->recycle_node, &gfar_recycle_queues);
@@ -3013,7 +3013,6 @@ static void gfar_recycle_skb(struct gfar_private *priv, struct sk_buff *skb)
 	struct gfar_priv_recycle *rec_target = priv->recycle_target;
 	struct sk_buff_head *recycle_q;
 	struct gfar_priv_recycle_local *local;
-	int cpu;
 
 	if (unlikely(!rec_target))
 		goto free;
@@ -3021,21 +3020,17 @@ static void gfar_recycle_skb(struct gfar_private *priv, struct sk_buff *skb)
 	if (unlikely(!skb_is_recycleable(skb, rec_target->buff_size)))
 		goto free;
 
-	cpu = get_cpu();
-	local = per_cpu_ptr(rec_target->local, cpu);
+	local = this_cpu_ptr(rec_target->local);
 
 	if (likely(skb_queue_len(&local->recycle_q) < GFAR_RECYCLE_MAX)) {
-		local->recycle_cnt++;
-
+		atomic_inc(&local->recycle_cnt);
 		skb_recycle(skb);
 
 		gfar_align_skb(skb);
 
-		__skb_queue_head(&local->recycle_q, skb);
-		put_cpu();
+		skb_queue_head(&local->recycle_q, skb);
 		return;
 	}
-	put_cpu();
 
 	recycle_q = &rec_target->recycle_q;
 
@@ -3276,17 +3271,13 @@ static struct sk_buff *gfar_new_skb(struct gfar_private *priv)
 	struct gfar_priv_recycle *rec = &priv->recycle;
 	struct gfar_priv_recycle_local *local;
 	struct sk_buff_head *recycle_q;
-	int cpu;
 
-	cpu = get_cpu();
-	local = per_cpu_ptr(rec->local, cpu);
-	skb = __skb_dequeue(&local->recycle_q);
+	local = this_cpu_ptr(rec->local);
+	skb = skb_dequeue(&local->recycle_q);
 	if (likely(skb)) {
-		local->reuse_cnt++;
-		put_cpu();
+		atomic_inc(&local->reuse_cnt);
 		return skb;
 	}
-	put_cpu();
 
 	recycle_q = &rec->recycle_q;
 
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 6dd03bf..0a59967 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1227,8 +1227,8 @@ enum gfar_errata {
 
 struct gfar_priv_recycle_local {
 	struct sk_buff_head recycle_q; /* percpu queue */
-	unsigned int recycle_cnt;
-	unsigned int reuse_cnt;
+	atomic_t recycle_cnt;
+	atomic_t reuse_cnt;
 };
 
 #define GFAR_RECYCLE_MAX	DEFAULT_TX_RING_SIZE
diff --git a/drivers/net/ethernet/freescale/gianfar_sysfs.c b/drivers/net/ethernet/freescale/gianfar_sysfs.c
index 2f2c451..6221f04 100644
--- a/drivers/net/ethernet/freescale/gianfar_sysfs.c
+++ b/drivers/net/ethernet/freescale/gianfar_sysfs.c
@@ -377,7 +377,8 @@ static ssize_t gfar_show_recycle(struct device *dev,
 
 		local = per_cpu_ptr(rec->local, cpu);
 		pr_info("local: CPU#%d: recycled skbs %d, reused skbs %d\n",
-			cpu, local->recycle_cnt, local->reuse_cnt);
+			cpu, atomic_read(&local->recycle_cnt),
+			atomic_read(&local->reuse_cnt));
 	}
 
 	pr_info("shared: recycled skbs %d, reused skbs %d\n",
-- 
1.8.4.93.g57e4c17

