From f41b51adc1d444bccb0680b251ee7e2cce6783a3 Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Wed, 10 Jul 2013 15:48:05 +0800
Subject: [PATCH 333/430] net/phy: Adding is_c45 to mii_bus for Clause 45 PHY

Some MDIO controllers(e.g. mEMAC MDIO) can support both Clause 22
and Clause 45. In 3.8 kernel, it decides whether current MII bus is for
Clause 45 via "reg & MII_ADDR_C45", but unfortunately, the condition
is not introduced by 3.4 kernel. so we have to introduce a new variable
is_c45 for struct mii_bus to indicate whether current MII bus is for
Clause 45. At the same time, since the 3.4 kernel introduces
a new parameter for mdiobus_read to support 10G PHY, so we also have to
convert xgmac_mdio to the old API.

Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/xgmac_mdio.c |   17 +++++++----------
 drivers/net/phy/mdio-mux.c                  |    1 +
 drivers/of/of_mdio.c                        |    3 +++
 include/linux/phy.h                         |    2 ++
 4 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/drivers/net/ethernet/freescale/xgmac_mdio.c b/drivers/net/ethernet/freescale/xgmac_mdio.c
index 6ad992a..56c7029 100644
--- a/drivers/net/ethernet/freescale/xgmac_mdio.c
+++ b/drivers/net/ethernet/freescale/xgmac_mdio.c
@@ -91,17 +91,16 @@ static int xgmac_wait_until_done(struct device *dev,
  * until the write is done before it returns.  All PHY configuration has to be
  * done through the TSEC1 MIIM regs.
  */
-static int xgmac_mdio_write(struct mii_bus *bus, int phy_id, int regnum, u16 value)
+static int xgmac_mdio_write(struct mii_bus *bus, int phy_id, int dev_addr,
+			int regnum, u16 value)
 {
 	struct tgec_mdio_controller __iomem *regs = bus->priv;
-	uint16_t dev_addr;
 	u32 mdio_ctl, mdio_stat;
 	int ret;
 
 	mdio_stat = in_be32(&regs->mdio_stat);
-	if (regnum & MII_ADDR_C45) {
+	if (bus->is_c45) {
 		/* Clause 45 (ie 10G) */
-		dev_addr = (regnum >> 16) & 0x1f;
 		mdio_stat |= MDIO_STAT_ENC | MDIO_STAT_HOLD_15_CLK;
 	} else {
 		/* Clause 22 (ie 1G) */
@@ -120,7 +119,7 @@ static int xgmac_mdio_write(struct mii_bus *bus, int phy_id, int regnum, u16 val
 	out_be32(&regs->mdio_ctl, mdio_ctl);
 
 	/* Set the register address */
-	if (regnum & MII_ADDR_C45) {
+	if (bus->is_c45) {
 		out_be32(&regs->mdio_addr, regnum & 0xffff);
 
 		ret = xgmac_wait_until_free(&bus->dev, regs);
@@ -143,18 +142,16 @@ static int xgmac_mdio_write(struct mii_bus *bus, int phy_id, int regnum, u16 val
  * Clears miimcom first.  All PHY configuration has to be done through the
  * TSEC1 MIIM regs.
  */
-static int xgmac_mdio_read(struct mii_bus *bus, int phy_id, int regnum)
+static int xgmac_mdio_read(struct mii_bus *bus, int phy_id, int dev_addr, int regnum)
 {
 	struct tgec_mdio_controller __iomem *regs = bus->priv;
-	uint16_t dev_addr;
 	uint32_t mdio_stat;
 	uint32_t mdio_ctl;
 	uint16_t value;
 	int ret;
 
 	mdio_stat = in_be32(&regs->mdio_stat);
-	if (regnum & MII_ADDR_C45) {
-		dev_addr = (regnum >> 16) & 0x1f;
+	if (bus->is_c45) {
 		mdio_stat |= MDIO_STAT_ENC | MDIO_STAT_HOLD_15_CLK;
 	} else {
 		dev_addr = regnum & 0x1f;
@@ -172,7 +169,7 @@ static int xgmac_mdio_read(struct mii_bus *bus, int phy_id, int regnum)
 	out_be32(&regs->mdio_ctl, mdio_ctl);
 
 	/* Set the register address */
-	if (regnum & MII_ADDR_C45) {
+	if (bus->is_c45) {
 		out_be32(&regs->mdio_addr, regnum & 0xffff);
 
 		ret = xgmac_wait_until_free(&bus->dev, regs);
diff --git a/drivers/net/phy/mdio-mux.c b/drivers/net/phy/mdio-mux.c
index ccd0c9a..f096217 100644
--- a/drivers/net/phy/mdio-mux.c
+++ b/drivers/net/phy/mdio-mux.c
@@ -168,6 +168,7 @@ int mdio_mux_init(struct device *dev,
 			devm_kfree(dev, cb);
 		} else {
 			of_node_get(child_bus_node);
+			pb->mii_bus->is_c45 = cb->mii_bus->is_c45;
 			cb->next = pb->children;
 			pb->children = cb;
 		}
diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c
index f0f4545..b96ec04 100644
--- a/drivers/of/of_mdio.c
+++ b/drivers/of/of_mdio.c
@@ -79,6 +79,9 @@ int of_mdiobus_register(struct mii_bus *mdio, struct device_node *np)
 				mdio->irq[addr] = PHY_POLL;
 		}
 
+		mdio->is_c45 = of_device_is_compatible(child,
+					"ethernet-phy-ieee802.3-c45");
+
 		phy = get_phy_device(mdio, addr);
 		if (!phy || IS_ERR(phy)) {
 			dev_err(&mdio->dev, "error probing PHY at address %i\n",
diff --git a/include/linux/phy.h b/include/linux/phy.h
index 9ede46b..87bb34b 100644
--- a/include/linux/phy.h
+++ b/include/linux/phy.h
@@ -131,6 +131,8 @@ struct mii_bus {
 	 * interrupt at the index matching its address
 	 */
 	int *irq;
+	/*  indicate whether it's for Clause 45 PHY */
+	bool is_c45;
 };
 #define to_mii_bus(d) container_of(d, struct mii_bus, dev)
 
-- 
1.7.5.4

