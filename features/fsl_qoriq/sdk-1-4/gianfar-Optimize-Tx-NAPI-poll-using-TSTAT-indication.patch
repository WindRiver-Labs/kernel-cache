From e87f1e0f9a798d58e025c2206af3485233140f61 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Tue, 23 Apr 2013 15:16:43 +0300
Subject: [PATCH 386/547] gianfar: Optimize Tx NAPI poll using TSTAT indication

Use TSTAT TXF h/w indication to identify the active Tx queues.
Simplify the polling routine to make it faster. No need to poll
the Tx rings in a loop due to Tx interrupt coalescing plus the fact
that Tx polling does not consume NAPI budget, as Tx ring cleanup
is run to completion.
This contributes to a faster/ more responsive cleanup of Tx rings
reducing the possibility of Tx congestion (Tx timeout triggering).

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: I09b87ef36aa8f51a9814d1fa701364a5e68411ff
Reviewed-on: http://git.am.freescale.net:8181/1745
Reviewed-by: Xie Jianhua-B29408 <jianhua.xie@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c | 40 +++++++++++++-------------------
 drivers/net/ethernet/freescale/gianfar.h |  3 +++
 2 files changed, 19 insertions(+), 24 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index f5de116..46a64e1 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -3332,43 +3332,35 @@ static int gfar_poll_tx(struct napi_struct *napi, int budget)
 	struct gfar_private *priv = napi_tx->grp->priv;
 	struct gfar __iomem *regs = napi_tx->grp->regs;
 	struct gfar_priv_tx_q *tx_queue = NULL;
-	int has_tx_work;
+	u32 tstat_txf, imask;
 	int i;
 
+	tstat_txf = gfar_read(&regs->tstat) & TSTAT_TXF_MASK_ALL;
 	/* Clear IEVENT, so interrupts aren't called again
 	 * because of the packets that have already arrived
 	 */
 	gfar_write(&regs->ievent, IEVENT_TX_MASK);
 
-	while (1) {
-		has_tx_work = 0;
-		for_each_set_bit(i, &napi_tx->tx_bit_map, priv->num_tx_queues) {
+	for_each_set_bit(i, &napi_tx->tx_bit_map, priv->num_tx_queues) {
+		if (tstat_txf & (TSTAT_TXF0_MASK >> i)) {
 			tx_queue = priv->tx_queue[i];
 			/* run Tx cleanup to completion */
-			if (tx_queue->tx_skbuff[tx_queue->skb_dirtytx]) {
-				gfar_clean_tx_ring(tx_queue);
-				has_tx_work = 1;
-			}
+			gfar_clean_tx_ring(tx_queue);
 		}
+	}
 
-		if (unlikely(!has_tx_work)) {
-			u32 imask;
-			napi_complete(napi);
+	napi_complete(napi);
 
-			spin_lock_irq(&napi_tx->grp->grplock);
-			imask = gfar_read(&regs->imask);
-			imask |= IMASK_TX_DEFAULT;
-			gfar_write(&regs->imask, imask);
-			spin_unlock_irq(&napi_tx->grp->grplock);
+	spin_lock_irq(&napi_tx->grp->grplock);
+	imask = gfar_read(&regs->imask);
+	imask |= IMASK_TX_DEFAULT;
+	gfar_write(&regs->imask, imask);
+	spin_unlock_irq(&napi_tx->grp->grplock);
 
-			/* If we are coalescing interrupts, update the timer
-			 * Otherwise, clear it
-			 */
-			gfar_configure_tx_coalescing(priv, napi_tx->tx_bit_map);
-
-			break;
-		}
-	}
+	/* If we are coalescing interrupts, update the timer
+	 * Otherwise, clear it
+	 */
+	gfar_configure_tx_coalescing(priv, napi_tx->tx_bit_map);
 
 	return 0;
 }
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index c897750..7220d1e 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -306,6 +306,9 @@ extern const char gfar_driver_version[];
 #define TSTAT_CLEAR_THALT6	0x02000000
 #define TSTAT_CLEAR_THALT7	0x01000000
 
+#define TSTAT_TXF_MASK_ALL	0x0000ff00
+#define TSTAT_TXF0_MASK		0x00008000
+
 /* Interrupt coalescing macros */
 #define IC_ICEN			0x80000000
 #define IC_ICFT_MASK		0x1fe00000
-- 
1.8.4.93.g57e4c17

