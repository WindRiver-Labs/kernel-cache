From f9377e95ff076e209ed485c55bd52729402b5c2c Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Mon, 29 Apr 2013 17:58:41 +0300
Subject: [PATCH 389/547] gianfar: Revert BQL support in Gianfar

Remove BQL support from Gianfar. The original upstream
commit that added BQL to Gianfar does not revert cleanly:
"d8a0f1b gianfar: Add support for byte queue limits."

BQL has been integrated in Gianfar by the upstream comunity
with no clear reason why would it be required for this driver.
Only a few drivers have it integrated. It adds overhead to the
Tx path and potential functional issues as BQL may stop the
transmission, which could result in tx timeout.

The current BQL support in Gianfar breaks the Tx timestamping
functionality. The fix is non-trivial (adding more overhead) and
still under debate in upstream.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: I125690a91cfc1f2cc955af4aa11ed9b8c00a5f08
Reviewed-on: http://git.am.freescale.net:8181/2262
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso
 Remove ASF codes]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c | 11 -----------
 1 file changed, 11 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 4ec4d8b..aa8107e 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -2072,13 +2072,9 @@ static void free_skb_resources(struct gfar_private *priv)
 
 	/* Go through all the buffer descriptors and free their data buffers */
 	for (i = 0; i < priv->num_tx_queues; i++) {
-		struct netdev_queue *txq;
-
 		tx_queue = priv->tx_queue[i];
-		txq = netdev_get_tx_queue(tx_queue->dev, tx_queue->qindex);
 		if (tx_queue->tx_skbuff)
 			free_skb_tx_queue(tx_queue);
-		netdev_tx_reset_queue(txq);
 	}
 
 	for (i = 0; i < priv->num_rx_queues; i++) {
@@ -2690,8 +2686,6 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	}
 
 #ifndef CONFIG_RX_TX_BUFF_XCHG
-	netdev_tx_sent_queue(txq, skb->len);
-
 	/* We can work in parallel with gfar_clean_tx_ring(), except
 	 * when modifying num_txbdfree. Note that we didn't grab the lock
 	 * when we were reading the num_txbdfree and checking for available
@@ -2987,7 +2981,6 @@ static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 	int i;
 	int howmany = 0;
 	int tqi = tx_queue->qindex;
-	unsigned int bytes_sent = 0;
 	u32 lstatus;
 	size_t buflen;
 
@@ -3074,8 +3067,6 @@ static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 			bdp = next_txbd(bdp, base, tx_ring_size);
 		}
 
-		bytes_sent += skb->len;
-
 		gfar_recycle_skb(priv, skb);
 
 		tx_queue->tx_skbuff[skb_dirtytx] = NULL;
@@ -3096,8 +3087,6 @@ static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 	/* Update dirty indicators */
 	tx_queue->skb_dirtytx = skb_dirtytx;
 	tx_queue->dirty_tx = bdp;
-
-	netdev_tx_completed_queue(txq, howmany, bytes_sent);
 }
 
 static void gfar_schedule_tx_cleanup(struct gfar_priv_grp *grp)
-- 
1.8.4.93.g57e4c17

