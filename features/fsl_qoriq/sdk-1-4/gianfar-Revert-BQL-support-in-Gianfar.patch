From c1dbe812ae2907258596a0bdee272a8e409f70b2 Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Fri, 9 Aug 2013 11:17:04 +0800
Subject: [PATCH 426/430] gianfar: Revert BQL support in Gianfar

Remove BQL support from Gianfar. The original upstream
commit that added BQL to Gianfar does not revert cleanly:
"d8a0f1b gianfar: Add support for byte queue limits."

BQL has been integrated in Gianfar by the upstream comunity
with no clear reason why would it be required for this driver.
Only a few drivers have it integrated. It adds overhead to the
Tx path and potential functional issues as BQL may stop the
transmission, which could result in tx timeout.

The current BQL support in Gianfar breaks the Tx timestamping
functionality. The fix is non-trivial (adding more overhead) and
still under debate in upstream.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: I125690a91cfc1f2cc955af4aa11ed9b8c00a5f08
Reviewed-on: http://git.am.freescale.net:8181/2262
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch is from QorIQ-SDK-V1.4-20130625-yocto]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |    9 ---------
 1 files changed, 0 insertions(+), 9 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index f488128..d899b0c 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -2295,12 +2295,9 @@ static void free_skb_resources(struct gfar_private *priv)
 
 	/* Go through all the buffer descriptors and free their data buffers */
 	for (i = 0; i < priv->num_tx_queues; i++) {
-		struct netdev_queue *txq;
 		tx_queue = priv->tx_queue[i];
-		txq = netdev_get_tx_queue(tx_queue->dev, tx_queue->qindex);
 		if(tx_queue->tx_skbuff)
 			free_skb_tx_queue(tx_queue);
-		netdev_tx_reset_queue(txq);
 	}
 
 	for (i = 0; i < priv->num_rx_queues; i++) {
@@ -2957,8 +2954,6 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		lstatus |= BD_LFLAG(TXBD_CRC | TXBD_READY) | skb_headlen(skb);
 	}
 
-	netdev_tx_sent_queue(txq, skb->len);
-
 	/*
 	 * We can work in parallel with gfar_clean_tx_ring(), except
 	 * when modifying num_txbdfree. Note that we didn't grab the lock
@@ -3224,7 +3219,6 @@ static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue,
 	int i;
 	int howmany = 0;
 	int tqi = tx_queue->qindex;
-	unsigned int bytes_sent = 0;
 	u32 lstatus;
 	size_t buflen;
 
@@ -3312,7 +3306,6 @@ static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue,
 			bdp = next_txbd(bdp, base, tx_ring_size);
 		}
 
-		bytes_sent += skb->len;
 
 		gfar_free_skb(skb);
 		tx_queue->tx_skbuff[skb_dirtytx] = NULL;
@@ -3334,8 +3327,6 @@ static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue,
 	tx_queue->skb_dirtytx = skb_dirtytx;
 	tx_queue->dirty_tx = bdp;
 
-	netdev_tx_completed_queue(txq, howmany, bytes_sent);
-
 	return howmany;
 }
 
-- 
1.7.5.4

