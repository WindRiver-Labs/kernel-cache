From d9faa0d53b8c1c418580ad56879d8d7ae7a75ad2 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Mon, 29 Apr 2013 17:58:41 +0300
Subject: [PATCH] gianfar: Revert BQL support in Gianfar

Remove BQL support from Gianfar. The original upstream
commit that added BQL to Gianfar does not revert cleanly:
"d8a0f1b gianfar: Add support for byte queue limits."

BQL has been integrated in Gianfar by the upstream comunity
with no clear reason why would it be required for this driver.
Only a few drivers have it integrated. It adds overhead to the
Tx path and potential functional issues as BQL may stop the
transmission, which could result in tx timeout.

The current BQL support in Gianfar breaks the Tx timestamping
functionality. The fix is non-trivial (adding more overhead) and
still under debate in upstream.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: I125690a91cfc1f2cc955af4aa11ed9b8c00a5f08
Reviewed-on: http://git.am.freescale.net:8181/2262
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso
 Remove ASF codes]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 2351490fceb0..a0d9d869e93a 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -2071,13 +2071,9 @@ static void free_skb_resources(struct gfar_private *priv)
 
 	/* Go through all the buffer descriptors and free their data buffers */
 	for (i = 0; i < priv->num_tx_queues; i++) {
-		struct netdev_queue *txq;
-
 		tx_queue = priv->tx_queue[i];
-		txq = netdev_get_tx_queue(tx_queue->dev, tx_queue->qindex);
 		if (tx_queue->tx_skbuff)
 			free_skb_tx_queue(tx_queue);
-		netdev_tx_reset_queue(txq);
 	}
 
 	for (i = 0; i < priv->num_rx_queues; i++) {
@@ -2689,8 +2685,6 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	}
 
 #ifndef CONFIG_RX_TX_BUFF_XCHG
-	netdev_tx_sent_queue(txq, skb->len);
-
 	/* We can work in parallel with gfar_clean_tx_ring(), except
 	 * when modifying num_txbdfree. Note that we didn't grab the lock
 	 * when we were reading the num_txbdfree and checking for available
@@ -2986,7 +2980,6 @@ static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 	int i;
 	int howmany = 0;
 	int tqi = tx_queue->qindex;
-	unsigned int bytes_sent = 0;
 	u32 lstatus;
 	size_t buflen;
 
@@ -3073,8 +3066,6 @@ static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 			bdp = next_txbd(bdp, base, tx_ring_size);
 		}
 
-		bytes_sent += skb->len;
-
 		gfar_recycle_skb(priv, skb);
 
 		tx_queue->tx_skbuff[skb_dirtytx] = NULL;
@@ -3095,8 +3086,6 @@ static int gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 	/* Update dirty indicators */
 	tx_queue->skb_dirtytx = skb_dirtytx;
 	tx_queue->dirty_tx = bdp;
-
-	netdev_tx_completed_queue(txq, howmany, bytes_sent);
 	return howmany;
 }
 
-- 
2.0.1

