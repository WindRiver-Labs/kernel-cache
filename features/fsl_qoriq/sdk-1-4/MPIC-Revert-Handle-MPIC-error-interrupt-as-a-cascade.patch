From 26fbc0a94a7b37fab31534a2c924b8edc4782fb2 Mon Sep 17 00:00:00 2001
From: Yang Wei <Wei.Yang@windriver.com>
Date: Thu, 1 Aug 2013 18:32:43 +0800
Subject: [PATCH 208/430] MPIC: Revert Handle MPIC error interrupt as a
 cascaded interrupt.

MPIC error interrupt already is refined by SDK1.4, so we need to
remove the previous patch in order to introduce the new patch.

Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 arch/powerpc/include/asm/mpic.h |   17 -----
 arch/powerpc/sysdev/mpic.c      |  152 +--------------------------------------
 2 files changed, 1 insertions(+), 168 deletions(-)

diff --git a/arch/powerpc/include/asm/mpic.h b/arch/powerpc/include/asm/mpic.h
index 2057d22..8a7991e 100644
--- a/arch/powerpc/include/asm/mpic.h
+++ b/arch/powerpc/include/asm/mpic.h
@@ -114,13 +114,6 @@
 #define MPIC_FSL_BRR1			0x00000
 #define 	MPIC_FSL_BRR1_VER			0x0000ffff
 
-/*
- * Error interrupt registers
- */
-
-#define MPIC_ERR_INT_BASE	0x3900
-#define MPIC_ERR_INT_EISR	0x0000
-#define MPIC_ERR_INT_EIMR	0x0010
 
 #define MPIC_MAX_IRQ_SOURCES	2048
 #define MPIC_MAX_CPUS		32
@@ -128,7 +121,6 @@
 
 #define MPIC_MAX_TIMER    8
 #define MPIC_MAX_IPI      4
-#define MPIC_MAX_ERR      32
 
 /*
  * Tsi108 implementation of MPIC has many differences from the original one
@@ -280,7 +272,6 @@ struct mpic
 #endif
 	struct irq_chip		hc_ipi;
 	struct irq_chip		hc_tm;
-	struct irq_chip		hc_err;
 	const char		*name;
 	/* Flags */
 	unsigned int		flags;
@@ -294,8 +285,6 @@ struct mpic
 	/* vector numbers used for internal sources (ipi/timers) */
 	unsigned int		ipi_vecs[MPIC_MAX_IPI];
 	unsigned int		timer_vecs[MPIC_MAX_TIMER];
-	/* vector numbers used for FSL MPIC error interrupts */
-	unsigned int		err_int_vecs[MPIC_MAX_ERR];
 
 	/* Spurious vector to program into unused sources */
 	unsigned int		spurious_vec;
@@ -318,10 +307,6 @@ struct mpic
 	struct mpic_reg_bank	tmregs;
 	struct mpic_reg_bank	cpuregs[MPIC_MAX_CPUS];
 	struct mpic_reg_bank	isus[MPIC_MAX_ISU];
-	struct mpic_reg_bank	err_regs;
-
-	/* error interrupt config */
-	u32			err_int_config_done;
 
 	/* Protected sources */
 	unsigned long		*protected;
@@ -387,8 +372,6 @@ struct mpic
 #define MPIC_NO_RESET			0x00004000
 /* Freescale MPIC (compatible includes "fsl,mpic") */
 #define MPIC_FSL			0x00008000
-/* Freescale MPIC supports EIMR (error interrupt mask register)*/
-#define MPIC_FSL_HAS_EIMR		0x00010000
 
 /* MPIC HW modification ID */
 #define MPIC_REGSET_MASK		0xf0000000
diff --git a/arch/powerpc/sysdev/mpic.c b/arch/powerpc/sysdev/mpic.c
index d3255cf..91653c9 100644
--- a/arch/powerpc/sysdev/mpic.c
+++ b/arch/powerpc/sysdev/mpic.c
@@ -221,17 +221,6 @@ static inline void _mpic_ipi_write(struct mpic *mpic, unsigned int ipi, u32 valu
 	_mpic_write(mpic->reg_type, &mpic->gregs, offset, value);
 }
 
-static inline u32 _mpic_err_read(struct mpic *mpic, unsigned int err_reg)
-{
-	return _mpic_read(mpic->reg_type, &mpic->err_regs, err_reg);
-}
-
-static inline void _mpic_err_write(struct mpic *mpic, unsigned int err_reg,
-				   u32 value)
-{
-	_mpic_write(mpic->reg_type, &mpic->err_regs, err_reg, value);
-}
-
 static inline unsigned int mpic_tm_offset(struct mpic *mpic, unsigned int tm)
 {
 	return (tm >> 2) * MPIC_TIMER_GROUP_STRIDE +
@@ -305,8 +294,6 @@ static inline void _mpic_irq_write(struct mpic *mpic, unsigned int src_no,
 #define mpic_ipi_write(i,v)	_mpic_ipi_write(mpic,(i),(v))
 #define mpic_tm_read(i)		_mpic_tm_read(mpic,(i))
 #define mpic_tm_write(i,v)	_mpic_tm_write(mpic,(i),(v))
-#define mpic_err_read(i)	_mpic_err_read(mpic, (i))
-#define mpic_err_write(i, v)	_mpic_err_write(mpic, (i), (v))
 #define mpic_cpu_read(i)	_mpic_cpu_read(mpic,(i))
 #define mpic_cpu_write(i,v)	_mpic_cpu_write(mpic,(i),(v))
 #define mpic_irq_read(s,r)	_mpic_irq_read(mpic,(s),(r))
@@ -837,86 +824,6 @@ static void mpic_mask_tm(struct irq_data *d)
 	mpic_tm_read(src);
 }
 
-static void mpic_mask_err(struct irq_data *d)
-{
-	u32 eimr;
-	struct mpic *mpic = mpic_from_irq_data(d);
-	unsigned int src = virq_to_hw(d->irq) - mpic->err_int_vecs[0];
-	unsigned int err_reg_offset = MPIC_INFO(ERR_INT_EIMR);
-
-	eimr = mpic_err_read(err_reg_offset);
-	eimr |= (0x80000000 >> src);
-	mpic_err_write(err_reg_offset, eimr);
-}
-
-static void mpic_unmask_err(struct irq_data *d)
-{
-	u32 eimr;
-	struct mpic *mpic = mpic_from_irq_data(d);
-	unsigned int src = virq_to_hw(d->irq) - mpic->err_int_vecs[0];
-	unsigned int err_reg_offset = MPIC_INFO(ERR_INT_EIMR);
-
-	eimr = mpic_err_read(err_reg_offset);
-	eimr &= ~(0x80000000 >> src);
-	mpic_err_write(err_reg_offset, eimr);
-}
-
-static irqreturn_t error_int_handler(int irq, void *data)
-{
-	struct mpic *mpic = (struct mpic *) data;
-	unsigned int eisr_offset = MPIC_INFO(ERR_INT_EISR);
-	unsigned int eimr_offset = MPIC_INFO(ERR_INT_EIMR);
-	u32 eisr, eimr;
-	int errint;
-	unsigned int cascade_irq;
-
-	eisr = mpic_err_read(eisr_offset);
-	eimr = mpic_err_read(eimr_offset);
-
-	if (!(eisr & ~eimr))
-		return IRQ_NONE;
-
-	while (eisr) {
-		errint = __ffs(eisr);
-		cascade_irq = irq_linear_revmap(mpic->irqhost,
-				 mpic->err_int_vecs[31 - errint]);
-		WARN_ON(cascade_irq == NO_IRQ);
-		if (cascade_irq != NO_IRQ) {
-			generic_handle_irq(cascade_irq);
-		} else {
-			eimr |=  1 << errint;
-			mpic_err_write(eimr_offset, eimr);
-		}
-		eisr &= ~(1 << errint);
-	}
-
-	return IRQ_HANDLED;
-}
-
-static int mpic_err_int_init(struct mpic *mpic, irq_hw_number_t irqnum)
-{
-	unsigned int virq;
-	unsigned int offset = MPIC_INFO(ERR_INT_EIMR);
-	int ret;
-
-	virq = irq_create_mapping(mpic->irqhost, irqnum);
-	if (virq == NO_IRQ) {
-		pr_err("Error interrupt setup failed\n");
-		return -ENOSPC;
-	}
-
-	mpic_err_write(offset, ~0);
-
-	ret = request_irq(virq, error_int_handler, IRQF_NO_THREAD,
-		    "mpic-error-int", mpic);
-	if (ret) {
-		pr_err("Failed to register error interrupt handler\n");
-		return ret;
-	}
-
-	return 0;
-}
-
 int mpic_set_affinity(struct irq_data *d, const struct cpumask *cpumask,
 		      bool force)
 {
@@ -1067,12 +974,6 @@ static struct irq_chip mpic_ipi_chip = {
 	.irq_eoi	= mpic_end_ipi,
 };
 
-static struct irq_chip mpic_err_chip = {
-	.irq_disable	= mpic_mask_err,
-	.irq_mask	= mpic_mask_err,
-	.irq_unmask	= mpic_unmask_err,
-};
-
 static struct irq_chip mpic_tm_chip = {
 	.irq_disable	= mpic_mask_tm,
 	.irq_mask	= mpic_mask_tm,
@@ -1112,19 +1013,7 @@ static int mpic_host_map(struct irq_domain *h, unsigned int virq,
 	if (mpic->protected && test_bit(hw, mpic->protected))
 		return -EINVAL;
 
-	if ((mpic->flags & MPIC_FSL_HAS_EIMR) &&
-	    hw >= mpic->err_int_vecs[0]) {
-		WARN_ON(mpic->flags & MPIC_SECONDARY);
-
-		DBG("mpic: mapping as Error Interrupt\n");
-		irq_set_chip_data(virq, mpic);
-		irq_set_chip_and_handler(virq, &mpic->hc_err,
-					 handle_level_irq);
-		return 0;
-	}
-
-	if (hw >= mpic->ipi_vecs[0] &&
-	    hw <= mpic->ipi_vecs[MPIC_MAX_IPI - 1]) {
+	if (hw >= mpic->ipi_vecs[0]) {
 		WARN_ON(mpic->flags & MPIC_SECONDARY);
 
 		DBG("mpic: mapping as IPI\n");
@@ -1204,23 +1093,7 @@ static int mpic_host_xlate(struct irq_domain *h, struct device_node *ct,
 		 */
 		switch (intspec[2]) {
 		case 0:
-			break;
 		case 1:
-			if (!(mpic->flags & MPIC_FSL_HAS_EIMR))
-				break;
-
-			if (intspec[3] >= ARRAY_SIZE(mpic->err_int_vecs))
-				return -EINVAL;
-
-			if (!mpic->err_int_config_done) {
-				int ret;
-				ret = mpic_err_int_init(mpic, intspec[0]);
-				if (ret)
-					return ret;
-				mpic->err_int_config_done = 1;
-			}
-
-			*out_hwirq = mpic->err_int_vecs[intspec[3]];
 			break;
 		case 2:
 			if (intspec[0] >= ARRAY_SIZE(mpic->ipi_vecs))
@@ -1295,11 +1168,6 @@ static void mpic_alloc_int_sources(struct mpic *mpic, int intvec_top)
 
 	intvec = intvec_top;
 
-	if (mpic->flags & MPIC_FSL_HAS_EIMR) {
-		for (i = MPIC_MAX_ERR - 1; i >= 0; i--)
-			mpic->err_int_vecs[i] = --intvec;
-	}
-
 	for (i = MPIC_MAX_IPI - 1; i >= 0; i--)
 		mpic->ipi_vecs[i] = --intvec;
 
@@ -1442,7 +1310,6 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 	mpic_map(mpic, mpic->paddr, &mpic->tmregs, MPIC_INFO(TIMER_BASE), 0x1000);
 
 	if (mpic->flags & MPIC_FSL) {
-		u32 brr1, version;
 		/*
 		 * Yes, Freescale really did put global registers in the
 		 * magic per-cpu area -- and they don't even show up in the
@@ -1451,23 +1318,6 @@ struct mpic * __init mpic_alloc(struct device_node *node,
 		mpic_map(mpic, mpic->paddr, &mpic->thiscpuregs,
 			 MPIC_CPU_THISBASE, 0x1000);
 
-		brr1 = _mpic_read(mpic->reg_type, &mpic->thiscpuregs,
-				MPIC_FSL_BRR1);
-		version = brr1 & MPIC_FSL_BRR1_VER;
-
-		/* Error interrupt mask register (EIMR) is required for
-		 * handling individual device error interrupts. EIMR
-		 * was added in MPIC version 4.1.
-		 */
-		if (version >= 0x401) {
-			mpic->hc_err = mpic_err_chip;
-			mpic->hc_err.name = mpic->name;
-			/* Map error interrupt registers */
-			mpic_map(mpic, mpic->paddr, &mpic->err_regs,
-				 MPIC_INFO(ERR_INT_BASE), 0x1000);
-			mpic->flags |= MPIC_FSL_HAS_EIMR;
-		}
-
 		if (isu_size == 0) {
 			if (version < 0x403)
 				irq_count = 256;
-- 
1.7.5.4

