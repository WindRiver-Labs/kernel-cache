From d1fc710c491ca51856e342a85f95b4fbe634bbfa Mon Sep 17 00:00:00 2001
From: Jiucheng Xu <Jiucheng.Xu@freescale.com>
Date: Tue, 28 Aug 2012 15:34:12 +0000
Subject: [PATCH 041/547] P1021RDB: Add QE TDM support

The P1021RDB-PC have PMC sockets that support QE-TDM function.
The patch enable Quicc Engine and the related signals of QE-TDM.

Signed-off-by: Jiucheng Xu <Jiucheng.Xu@freescale.com>
Signed-off-by: Xie Xiaobo <X.Xie@freescale.com>
Signed-off-by: Li Yang <leoli@freescale.com>
Change-Id: Ic1b01085322b92442b4e1b3df928b6247580d889
Reviewed-on: http://git.am.freescale.net:8181/902
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso
 Move guts declaration in CONFIG_QUICC_ENGINE]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 arch/powerpc/platforms/85xx/mpc85xx_rdb.c | 79 +++++++++++++++++++++----------
 1 file changed, 55 insertions(+), 24 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/mpc85xx_rdb.c b/arch/powerpc/platforms/85xx/mpc85xx_rdb.c
index ede8771..939c5f3 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_rdb.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_rdb.c
@@ -88,6 +88,10 @@ static void __init mpc85xx_rdb_setup_arch(void)
 {
 #ifdef CONFIG_QUICC_ENGINE
 	struct device_node *np;
+#if defined(CONFIG_SPI_FSL_SPI)
+	struct device_node *qe_spi;
+#endif
+	struct ccsr_guts __iomem *guts;
 #endif
 
 	if (ppc_md.progress)
@@ -116,39 +120,66 @@ static void __init mpc85xx_rdb_setup_arch(void)
 
 		for_each_node_by_name(ucc, "ucc")
 			par_io_of_config(ucc);
-
+#ifdef CONFIG_SPI_FSL_SPI
+		for_each_node_by_name(qe_spi, "spi")
+			par_io_of_config(qe_spi);
+#endif	/* CONFIG_SPI_FSL_SPI */
 	}
-#if defined(CONFIG_UCC_GETH) || defined(CONFIG_SERIAL_QE)
-	if (machine_is(p1025_rdb)) {
-
-		struct ccsr_guts __iomem *guts;
-
-		np = of_find_node_by_name(NULL, "global-utilities");
-		if (np) {
-			guts = of_iomap(np, 0);
-			if (!guts) {
 
-				pr_err("mpc85xx-rdb: could not map global utilities register\n");
-
-			} else {
-			/* P1025 has pins muxed for QE and other functions. To
-			* enable QE UEC mode, we need to set bit QE0 for UCC1
-			* in Eth mode, QE0 and QE3 for UCC5 in Eth mode, QE9
-			* and QE12 for QE MII management singals in PMUXCR
-			* register.
-			*/
+	np = of_find_node_by_name(NULL, "global-utilities");
+	if (np) {
+		guts = of_iomap(np, 0);
+		if (!guts)
+			pr_err("mpc85xx-rdb: could not map global "
+					"utilities register\n");
+		else {
+#if defined(CONFIG_UCC_GETH) || defined(CONFIG_SERIAL_QE)
+			if (machine_is(p1025_rdb)) {
+				/*
+				 * P1025 has pins muxed for QE and other
+				 * functions. To enable QE UEC mode, we
+				 * need to set bit QE0 for UCC1 in Eth mode,
+				 * QE0 and QE3 for UCC5 in Eth mode, QE9
+				 * and QE12 for QE MII management singals
+				 * in PMUXCR register.
+				 */
 				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(0) |
 						MPC85xx_PMUXCR_QE(3) |
 						MPC85xx_PMUXCR_QE(9) |
 						MPC85xx_PMUXCR_QE(12));
-				iounmap(guts);
 			}
-			of_node_put(np);
-		}
-
-	}
 #endif
 
+#ifdef CONFIG_FSL_UCC_TDM
+			if (machine_is(p1021_rdb_pc)) {
+
+				/* Clear QE12 for releasing the LBCTL */
+				clrbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(12));
+				/* TDMA */
+				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(5) |
+						  MPC85xx_PMUXCR_QE(11));
+				/* TDMB */
+				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(0) |
+						  MPC85xx_PMUXCR_QE(9));
+				/* TDMC */
+				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(0));
+				/* TDMD */
+				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(8) |
+						  MPC85xx_PMUXCR_QE(7));
+			}
+#endif	/* CONFIG_FSL_UCC_TDM */
+
+#ifdef CONFIG_SPI_FSL_SPI
+			clrbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(12));
+			/*QE-SPI*/
+			setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(6) |
+					  MPC85xx_PMUXCR_QE(9) |
+					  MPC85xx_PMUXCR_QE(10));
+#endif	/* CONFIG_SPI_FSL_SPI */
+			iounmap(guts);
+		}
+		of_node_put(np);
+	}
 qe_fail:
 #endif	/* CONFIG_QUICC_ENGINE */
 
-- 
1.8.4.93.g57e4c17

