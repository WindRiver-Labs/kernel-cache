From a9f0161568134b73869781ca2f75e34ce89e5548 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Fri, 26 Jul 2013 10:12:37 +0800
Subject: [PATCH 147/430] fsl_qman: Add QMan3.1 reversion support

The QMan revision on both T4240 and B4860 rev2 silicon is 3.1, and both T2080
and T1040 also have QMan rev3.1. Update the qman driver to support rev3.1.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: I7ea2149f982023cd5f99729df6c6b61cba46b668
Reviewed-on: http://git.am.freescale.net:8181/1261
Reviewed-by: Thorpe Geoff-R01361 <Geoff.Thorpe@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch is from QorIQ-SDK-V1.4-20130625-yocto, just
a minor modification to port 3.4 kernel]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/qman_config.c  |    2 +
 drivers/staging/fsl_qbman/qman_driver.c  |  126 ++++++++++++++++++-----------
 drivers/staging/fsl_qbman/qman_private.h |    1 +
 3 files changed, 81 insertions(+), 48 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 9751c02..8c7fb8f 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -688,6 +688,8 @@ static int __init fsl_qman_init(struct device_node *node)
 			qman_ip_rev = QMAN_REV20;
 		else if ((major == 3) && (minor == 0))
 			qman_ip_rev = QMAN_REV30;
+		else if ((major == 3) && (minor == 1))
+			qman_ip_rev = QMAN_REV31;
 		else {
 			pr_warning("unknown Qman version, default to rev1.1\n");
 			qman_ip_rev = QMAN_REV11;
diff --git a/drivers/staging/fsl_qbman/qman_driver.c b/drivers/staging/fsl_qbman/qman_driver.c
index cb653cb..90dbdf9 100644
--- a/drivers/staging/fsl_qbman/qman_driver.c
+++ b/drivers/staging/fsl_qbman/qman_driver.c
@@ -280,6 +280,76 @@ static __init int fsl_ceetm_init(struct device_node *node)
 	return 0;
 }
 
+void qman_get_ip_revision(struct device_node *dn)
+{
+	u16 ip_rev = 0;
+	for_each_compatible_node(dn, NULL, "fsl,qman-portal") {
+		if (!of_device_is_available(dn))
+			continue;
+		if (of_device_is_compatible(dn, "fsl,qman-portal-1.0") ||
+			of_device_is_compatible(dn, "fsl,qman-portal-1.0.0")) {
+			ip_rev = QMAN_REV10;
+			qman_portal_max = 10;
+		} else if (of_device_is_compatible(dn, "fsl,qman-portal-1.1") ||
+			of_device_is_compatible(dn, "fsl,qman-portal-1.1.0")) {
+			ip_rev = QMAN_REV11;
+			qman_portal_max = 10;
+		} else if (of_device_is_compatible(dn, "fsl,qman-portal-1.2") ||
+			of_device_is_compatible(dn, "fsl,qman-portal-1.2.0")) {
+			ip_rev = QMAN_REV12;
+			qman_portal_max = 10;
+		} else if (of_device_is_compatible(dn, "fsl,qman-portal-2.0") ||
+			of_device_is_compatible(dn, "fsl,qman-portal-2.0.0")) {
+			ip_rev = QMAN_REV20;
+			qman_portal_max = 3;
+		} else if (of_device_is_compatible(dn,
+						"fsl,qman-portal-3.0.0")) {
+			ip_rev = QMAN_REV30;
+			qman_portal_max = 50;
+		} else if (of_device_is_compatible(dn,
+						"fsl,qman-portal-3.0.1")) {
+			ip_rev = QMAN_REV30;
+			qman_portal_max = 25;
+		} else if (of_device_is_compatible(dn,
+						"fsl,qman-portal-3.1.0")) {
+			ip_rev = QMAN_REV31;
+			qman_portal_max = 50;
+		} else if (of_device_is_compatible(dn,
+						"fsl,qman-portal-3.1.1")) {
+			ip_rev = QMAN_REV31;
+			qman_portal_max = 25;
+		} else if (of_device_is_compatible(dn,
+						"fsl,qman-portal-3.1.2")) {
+			ip_rev = QMAN_REV31;
+			qman_portal_max = 18;
+		} else if (of_device_is_compatible(dn,
+						"fsl,qman-portal-3.1.3")) {
+			ip_rev = QMAN_REV31;
+			qman_portal_max = 10;
+		} else {
+			pr_warn("unknown QMan version in portal node,"
+				"default to rev1.1\n");
+			ip_rev = QMAN_REV11;
+			qman_portal_max = 10;
+		}
+
+		if (!qman_ip_rev) {
+			if (ip_rev) {
+				qman_ip_rev = ip_rev;
+			} else {
+				pr_warning("unknown Qman version,"
+					" default to rev1.1\n");
+				qman_ip_rev = QMAN_REV11;
+			}
+		} else if (ip_rev && (qman_ip_rev != ip_rev))
+			pr_warning("Revision=0x%04x, but portal '%s' has"
+							" 0x%04x\n",
+			qman_ip_rev, dn->full_name, ip_rev);
+		if (qman_ip_rev == ip_rev)
+			break;
+	}
+}
+
 /* Parse a portal node, perform generic mapping duties and return the config. It
  * is not known at this stage for what purpose (or even if) the portal will be
  * used. */
@@ -288,7 +358,6 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 	struct qm_portal_config *pcfg;
 	const u32 *index, *channel;
 	int irq, ret;
-	u16 ip_rev = 0;
 
 	pcfg = kmalloc(sizeof(*pcfg), GFP_KERNEL);
 	if (!pcfg) {
@@ -296,53 +365,6 @@ static struct qm_portal_config * __init parse_pcfg(struct device_node *node)
 		return NULL;
 	}
 
-	if (of_device_is_compatible(node, "fsl,qman-portal-1.0") ||
-		of_device_is_compatible(node, "fsl,qman-portal-1.0.0")) {
-		ip_rev = QMAN_REV10;
-		qman_portal_max = 10;
-	} else if (of_device_is_compatible(node, "fsl,qman-portal-1.1") ||
-		of_device_is_compatible(node, "fsl,qman-portal-1.1.0")) {
-		ip_rev = QMAN_REV11;
-		qman_portal_max = 10;
-	} else if (of_device_is_compatible(node, "fsl,qman-portal-1.2") ||
-		of_device_is_compatible(node, "fsl,qman-portal-1.2.0")) {
-		ip_rev = QMAN_REV12;
-		qman_portal_max = 10;
-	} else if (of_device_is_compatible(node, "fsl,qman-portal-2.0") ||
-		of_device_is_compatible(node, "fsl,qman-portal-2.0.0")) {
-		ip_rev = QMAN_REV20;
-		qman_portal_max = 3;
-	} else if (of_device_is_compatible(node, "fsl,qman-portal-3.0.0")) {
-		ip_rev = QMAN_REV30;
-		qman_portal_max = 50;
-	} else if (of_device_is_compatible(node, "fsl,qman-portal-3.0.1")) {
-		ip_rev = QMAN_REV30;
-		qman_portal_max = 25;
-	} else if (of_device_is_compatible(node, "fsl,qman-portal-3.0.2")) {
-		ip_rev = QMAN_REV30;
-		qman_portal_max = 10;
-	} else if (of_device_is_compatible(node, "fsl,qman-portal-3.0.3")) {
-		ip_rev = QMAN_REV30;
-		qman_portal_max = 18;
-	}
-
-	if (!qman_ip_rev) {
-		if (ip_rev)
-			qman_ip_rev = ip_rev;
-		else {
-			pr_warning("unknown Qman version, default to rev1.1\n");
-			qman_ip_rev = QMAN_REV11;
-		}
-	} else if (ip_rev && (qman_ip_rev != ip_rev))
-		pr_warning("Revision=0x%04x, but portal '%s' has 0x%04x\n",
-			qman_ip_rev, node->full_name, ip_rev);
-
-	if ((qman_ip_rev & 0xff00) >= QMAN_REV30)
-	{
-		qm_channel_caam = QMAN_CHANNEL_CAAM_REV3;;
-		qm_channel_pme = QMAN_CHANNEL_PME_REV3;
-	}
-
 	ret = of_address_to_resource(node, DPA_PORTAL_CE,
 				&pcfg->addr_phys[DPA_PORTAL_CE]);
 	if (ret) {
@@ -589,6 +611,14 @@ static __init int qman_init(void)
 		return ret;
 #endif
 
+	/* Get qman ip revision */
+	qman_get_ip_revision(dn);
+	if ((qman_ip_rev & 0xff00) >= QMAN_REV30) {
+		qm_channel_pool1 = QMAN_CHANNEL_POOL1_REV3;
+		qm_channel_caam = QMAN_CHANNEL_CAAM_REV3;
+		qm_channel_pme = QMAN_CHANNEL_PME_REV3;
+	}
+
 	/* Parse pool channels into the SDQCR mask. (Must happen before portals
 	 * are initialised.) */
 	for_each_compatible_node(dn, NULL, "fsl,pool-channel-range") {
diff --git a/drivers/staging/fsl_qbman/qman_private.h b/drivers/staging/fsl_qbman/qman_private.h
index 74191fe..13917a3 100644
--- a/drivers/staging/fsl_qbman/qman_private.h
+++ b/drivers/staging/fsl_qbman/qman_private.h
@@ -188,6 +188,7 @@ struct qm_portal_config {
 #define QMAN_REV12 0x0102
 #define QMAN_REV20 0x0200
 #define QMAN_REV30 0x0300
+#define QMAN_REV31 0x0301
 extern u16 qman_ip_rev; /* 0 if uninitialised, otherwise QMAN_REVx */
 extern u32 qman_clk;
 
-- 
1.7.5.4

