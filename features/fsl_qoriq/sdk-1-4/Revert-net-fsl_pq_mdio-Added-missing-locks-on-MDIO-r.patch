From cbb4edad07ea31037afcb644fda90b05ac59919e Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Tue, 25 Jun 2013 12:53:23 +0800
Subject: [PATCH 310/430] Revert "net/fsl_pq_mdio: Added missing locks on MDIO
 read and write functions"

This reverts commit a7df23e2bd3511cf1c7c7a89ae1b234585d47c0c.

SDK 1.4 does not introduce the patch, so revert it.

Conflicts:

	drivers/net/ethernet/freescale/fsl_pq_mdio.c

Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/fsl_pq_mdio.c |   43 ++------------------------
 1 files changed, 3 insertions(+), 40 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fsl_pq_mdio.c b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
index debf268..07bc2a7 100644
--- a/drivers/net/ethernet/freescale/fsl_pq_mdio.c
+++ b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
@@ -5,7 +5,7 @@
  * Author: Andy Fleming <afleming@freescale.com>
  * Modifier: Sandeep Gopalpet <sandeep.kumar@freescale.com>
  *
- * Copyright 2002-2004, 2008-2009, 2012 Freescale Semiconductor, Inc.
+ * Copyright 2002-2004, 2008-2009 Freescale Semiconductor, Inc.
  *
  * Based on gianfar_mii.c and ucc_geth_mii.c (Li Yang, Kim Phillips)
  *
@@ -53,7 +53,6 @@
 struct fsl_pq_mdio_priv {
 	void __iomem *map;
 	struct fsl_pq_mdio __iomem *regs;
-	struct mutex mdio_lock;
 };
 
 /* pointer to bus, to be used by the fsl_pq_mdio locking functions when called
@@ -130,26 +129,6 @@ static struct fsl_pq_mdio __iomem *fsl_pq_mdio_get_regs(struct mii_bus *bus)
 	return priv->regs;
 }
 
-void fsl_pq_mdio_lock(struct mii_bus *bus)
-{
-	struct fsl_pq_mdio_priv *priv;
-
-	priv = (bus) ? bus->priv : fsl_pq_mdio_bus->priv;
-
-	mutex_lock(&priv->mdio_lock);
-}
-EXPORT_SYMBOL(fsl_pq_mdio_lock);
-
-void fsl_pq_mdio_unlock(struct mii_bus *bus)
-{
-	struct fsl_pq_mdio_priv *priv;
-
-	priv = (bus) ? bus->priv : fsl_pq_mdio_bus->priv;
-
-	mutex_unlock(&priv->mdio_lock);
-}
-EXPORT_SYMBOL(fsl_pq_mdio_unlock);
-
 /*
  * Write value to the PHY at mii_id at register regnum,
  * on the bus, waiting until the write is done before returning.
@@ -158,16 +137,9 @@ int fsl_pq_mdio_write(struct mii_bus *bus, int mii_id, int devad, int regnum,
 			u16 value)
 {
 	struct fsl_pq_mdio __iomem *regs = fsl_pq_mdio_get_regs(bus);
-	int result;
-
-	fsl_pq_mdio_lock(bus);
 
 	/* Write to the local MII regs */
-	result = fsl_pq_local_mdio_write(regs, mii_id, regnum, value);
-
-	fsl_pq_mdio_unlock(bus);
-
-	return result;
+	return fsl_pq_local_mdio_write(regs, mii_id, regnum, value);
 }
 
 /*
@@ -177,16 +149,9 @@ int fsl_pq_mdio_write(struct mii_bus *bus, int mii_id, int devad, int regnum,
 int fsl_pq_mdio_read(struct mii_bus *bus, int mii_id, int devad, int regnum)
 {
 	struct fsl_pq_mdio __iomem *regs = fsl_pq_mdio_get_regs(bus);
-	int result;
-
-	fsl_pq_mdio_lock(bus);
 
 	/* Read the local MII regs */
-	result =  fsl_pq_local_mdio_read(regs, mii_id, regnum);
-
-	fsl_pq_mdio_unlock(bus);
-
-	return result;
+	return fsl_pq_local_mdio_read(regs, mii_id, regnum);
 }
 
 /* Reset the MIIM registers, and wait for the bus to free */
@@ -315,8 +280,6 @@ static int fsl_pq_mdio_probe(struct platform_device *ofdev)
 	if (!priv)
 		return -ENOMEM;
 
-	mutex_init(&priv->mdio_lock);
-
 	new_bus = mdiobus_alloc();
 	if (!new_bus) {
 		err = -ENOMEM;
-- 
1.7.5.4

