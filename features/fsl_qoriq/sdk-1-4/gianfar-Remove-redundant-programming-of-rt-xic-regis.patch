From 56f7c4d5c83050ed48593c0f085e52106aa4516d Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Fri, 9 Aug 2013 11:16:57 +0800
Subject: [PATCH 419/430] gianfar: Remove redundant programming of [rt]xic
 registers

commit 5d9657d83a1cfecfbe41add0d94863d3fe714df0 upstream

For Multi Q Multi Group (MQ_MG_MODE) mode, the Rx/Tx colescing registers [rt]xic
are aliased with the [rt]xic0 registers (coalescing setting regs for Q0). This
avoids programming twice in a row the coalescing registers for the Rx/Tx hw Q0.

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Signed-off-by: David S. Miller <davem@davemloft.net>
[Just a minor modification to port our 3.4 kernel]
Signed-off-by: Yang Wei <Wei.Yang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c |   31 +++++++++++++----------------
 1 files changed, 14 insertions(+), 17 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 9e8c60f..8217742 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -2372,14 +2372,6 @@ void gfar_configure_tx_coalescing(struct gfar_private *priv,
 	u32 __iomem *baddr;
 	int i = 0, mask = 0x1;
 
-	/* Backward compatible case ---- even if we enable
-	 * multiple queues, there's only single reg to program
-	 */
-	if (priv->mode == SQ_SG_MODE) {
-		gfar_write(&regs->txic, 0);
-		if (likely(priv->tx_queue[0]->txcoalescing))
-			gfar_write(&regs->txic, priv->tx_queue[0]->txic);
-	}
 
 	if (priv->mode == MQ_MG_MODE) {
 		baddr = &regs->txic0;
@@ -2391,6 +2383,13 @@ void gfar_configure_tx_coalescing(struct gfar_private *priv,
 						 priv->tx_queue[i]->txic);
 			mask = mask << 0x1;
 		}
+	} else {
+		/* Backward compatible case ---- even if we enable
+		 * multiple queues, there's only single reg to program
+		 */
+		gfar_write(&regs->txic, 0);
+		if (likely(priv->tx_queue[0]->txcoalescing))
+			gfar_write(&regs->txic, priv->tx_queue[0]->txic);
 	}
 }
 
@@ -2401,15 +2400,6 @@ void gfar_configure_rx_coalescing(struct gfar_private *priv,
 	u32 __iomem *baddr;
 	int i = 0, mask = 0x1;
 
-	/* Backward compatible case ---- even if we enable
-	 * multiple queues, there's only single reg to program
-	 */
-	if (priv->mode == SQ_SG_MODE) {
-		gfar_write(&regs->rxic, 0);
-		if (unlikely(priv->rx_queue[0]->rxcoalescing))
-			gfar_write(&regs->rxic, priv->rx_queue[0]->rxic);
-	}
-
 	if (priv->mode == MQ_MG_MODE) {
 		baddr = &regs->rxic0;
 		for (i = 0; i < priv->num_rx_queues; i++) {
@@ -2420,6 +2410,13 @@ void gfar_configure_rx_coalescing(struct gfar_private *priv,
 						priv->rx_queue[i]->rxic);
 			mask = mask << 0x1;
 		}
+	} else {
+		/* Backward compatible case ---- even if we enable
+		 * multiple queues, there's only single reg to program
+		 */
+		gfar_write(&regs->rxic, 0);
+		if (unlikely(priv->rx_queue[0]->rxcoalescing))
+			gfar_write(&regs->rxic, priv->rx_queue[0]->rxic);
 	}
 }
 
-- 
1.7.5.4

