From a0fd6b954a44919813f139c51a506213072893a4 Mon Sep 17 00:00:00 2001
From: Rajan Gupta <rajan.gupta@freescale.com>
Date: Tue, 21 May 2013 21:02:57 +0530
Subject: [PATCH 391/547] gianfar: avoid allocating new skb to rx ring for fwd
 packets.

Patch enhances the performance for forwarded traffic by re-using the
skb in rx ring instead of allocating a new skb.
Patch also removes  per-cpu variables used in RX_TX_BUFF_XCHG patch, replacing
with parameters in skbuff structures to enhance the performance.

Change-Id: I2b3c1ec80fe3ef21ade9ce881d5cb86695169518
Signed-off-by: Rajan Gupta <rajan.gupta@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/2678
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Manoil Claudiu-B08782 <claudiu.manoil@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso
 Remove ASF codes]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c | 73 +++++++++++++++-----------------
 include/linux/skbuff.h                   |  4 ++
 2 files changed, 38 insertions(+), 39 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index b7f73a7..fa9d21f 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -103,6 +103,10 @@
 
 #include "gianfar.h"
 
+#ifdef CONFIG_RX_TX_BUFF_XCHG
+#define RT_PKT_ID 0xff
+#define KER_PKT_ID 0xfe
+#endif
 #define TX_TIMEOUT      (1*HZ)
 
 const char gfar_driver_version[] = "1.3";
@@ -134,6 +138,8 @@ static void gfar_set_hash_for_addr(struct net_device *dev, u8 *addr);
 static void gfar_configure_serdes(struct net_device *dev);
 static int gfar_poll_rx(struct napi_struct *napi, int budget);
 static int gfar_poll_tx(struct napi_struct *napi, int budget);
+static void gfar_recycle_skb(struct gfar_private *priv, struct sk_buff *skb);
+
 #ifdef CONFIG_NET_POLL_CONTROLLER
 static void gfar_netpoll(struct net_device *dev);
 #endif
@@ -173,11 +179,6 @@ MODULE_AUTHOR("Freescale Semiconductor, Inc");
 MODULE_DESCRIPTION("Gianfar Ethernet Driver");
 MODULE_LICENSE("GPL");
 
-#ifdef CONFIG_RX_TX_BUFF_XCHG
-static DEFINE_PER_CPU(void*, curr_skb);
-static DEFINE_PER_CPU(void*, recycled_skb);
-static DEFINE_PER_CPU(void*, reserved_skb);
-#endif
 static void gfar_init_rxbdp(struct gfar_priv_rx_q *rx_queue, struct rxbd8 *bdp,
 			    dma_addr_t buf)
 {
@@ -2578,14 +2579,8 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		/* BD is free to be used by s/w */
 		/* Free skb for this BD if not recycled */
 		if (tx_queue->tx_skbuff[skb_curtx]) {
-			if (skb_is_recycleable(tx_queue->tx_skbuff[skb_curtx],
-			    DEFAULT_RX_BUFFER_SIZE + RXBUF_ALIGNMENT)) {
-				skb_recycle(tx_queue->tx_skbuff[skb_curtx]);
-				gfar_align_skb(tx_queue->tx_skbuff[skb_curtx]);
-			} else {
-				dev_kfree_skb_any(tx_queue->tx_skbuff[skb_curtx]);
-				tx_queue->tx_skbuff[skb_curtx] = NULL;
-			}
+			gfar_recycle_skb(priv, tx_queue->tx_skbuff[skb_curtx]);
+			tx_queue->tx_skbuff[skb_curtx] = NULL;
 		}
 
 		txbdp->lstatus &= BD_LFLAG(TXBD_WRAP);
@@ -2694,16 +2689,6 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 		gfar_write(&regs->dfvlan, vlan_ctrl);
 	}
 
-#ifdef CONFIG_RX_TX_BUFF_XCHG
-	new_skb = tx_queue->tx_skbuff[tx_queue->skb_curtx];
-	skb_curtx = tx_queue->skb_curtx;
-	if (new_skb && (__this_cpu_read(curr_skb) != skb)) {
-		/* Packet from Kernel free the skb to recycle poll */
-		new_skb->dev = dev;
-		dev_kfree_skb_any(new_skb);
-		new_skb = NULL;
-	}
-#endif
 	txbdp_start->bufPtr = dma_map_single(priv->dev, skb->data,
 					     skb_headlen(skb), DMA_TO_DEVICE);
 
@@ -2749,7 +2734,11 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	eieio(); /* force lstatus write before tx_skbuff */
 
+#ifndef CONFIG_RX_TX_BUFF_XCHG
 	tx_queue->tx_skbuff[tx_queue->skb_curtx] = skb;
+#else
+	skb_curtx = tx_queue->skb_curtx;
+#endif
 
 	/* Update the current skb pointer to the next entry we will use
 	 * (wrapping if necessary)
@@ -2780,7 +2769,15 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	spin_unlock_irqrestore(&tx_queue->txlock, flags);
 #endif
 #ifdef CONFIG_RX_TX_BUFF_XCHG
-	__this_cpu_write(recycled_skb, new_skb);
+	if ((skb->owner != RT_PKT_ID) ||
+	  (!skb_is_recycleable(skb, DEFAULT_RX_BUFFER_SIZE + RXBUF_ALIGNMENT))) {
+		tx_queue->tx_skbuff[skb_curtx] = skb;
+		skb->new_skb = NULL;
+	} else {
+			skb_recycle(skb);
+			gfar_align_skb(skb);
+			skb->new_skb = skb;
+		}
 	txq->trans_start = jiffies;
 #endif
 	return NETDEV_TX_OK;
@@ -3439,16 +3436,13 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 	amount_pull = priv->uses_rxfcb ? GMAC_FCB_LEN : 0;
 
 	while (!((bdp->status & RXBD_EMPTY) || (--rx_work_limit < 0))) {
-		struct sk_buff *newskb;
+		struct sk_buff *newskb = NULL;
 
 		rmb();
 
 #ifndef CONFIG_RX_TX_BUFF_XCHG
 		/* Add another skb for the future */
 		newskb = gfar_new_skb(priv);
-#else
-		if (__this_cpu_read(reserved_skb) == NULL)
-			__this_cpu_write(reserved_skb, gfar_new_skb(priv));
 #endif
 
 		skb = rx_queue->rx_skbuff[rx_queue->skb_currx];
@@ -3471,11 +3465,10 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 			else if (skb)
 				dev_kfree_skb(skb);
 #else
-		if ((__this_cpu_read(reserved_skb) == NULL)
-			|| unlikely(!(bdp->status & RXBD_LAST)
-			|| bdp->status & RXBD_ERR)) {
-				count_errors(bdp->status, dev);
-				newskb = skb;
+		if (unlikely(!(bdp->status & RXBD_LAST) ||
+				bdp->status & RXBD_ERR)) {
+			count_errors(bdp->status, dev);
+			newskb = skb;
 #endif
 		} else {
 			/* Increment the number of packets */
@@ -3489,14 +3482,14 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 				rx_queue->stats.rx_bytes += pkt_len;
 				skb_record_rx_queue(skb, rx_queue->qindex);
 #ifdef CONFIG_RX_TX_BUFF_XCHG
-				__this_cpu_write(curr_skb, skb);
+				skb->owner = RT_PKT_ID;
 #endif
 				gfar_process_frame(dev, skb, amount_pull,
 						   &rx_queue->napi_rx->napi);
 #ifdef CONFIG_RX_TX_BUFF_XCHG
-				newskb =  __this_cpu_read(recycled_skb);
-				__this_cpu_write(curr_skb, NULL);
-				__this_cpu_write(recycled_skb, NULL);
+				newskb = skb->new_skb;
+				skb->owner = 0;
+				skb->new_skb = NULL;
 #endif
 
 			} else {
@@ -3510,9 +3503,11 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 #ifdef CONFIG_RX_TX_BUFF_XCHG
 		if (!newskb) {
 			/* Allocate new skb for Rx ring */
-			newskb = __this_cpu_read(reserved_skb);
-			__this_cpu_write(reserved_skb, NULL);
+			newskb = gfar_new_skb(priv);
 		}
+		if (!newskb)
+			/* All memory Exhausted,a BUG */
+			BUG();
 #endif
 		rx_queue->rx_skbuff[rx_queue->skb_currx] = newskb;
 
diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h
index 087ab5b..1936f4d 100644
--- a/include/linux/skbuff.h
+++ b/include/linux/skbuff.h
@@ -511,6 +511,10 @@ struct sk_buff {
 
 	sk_buff_data_t		inner_transport_header;
 	sk_buff_data_t		inner_network_header;
+#ifdef CONFIG_RX_TX_BUFF_XCHG
+	__u8			owner;
+	struct sk_buff		*new_skb;
+#endif
 	sk_buff_data_t		inner_mac_header;
 	sk_buff_data_t		transport_header;
 	sk_buff_data_t		network_header;
-- 
1.8.4.93.g57e4c17

