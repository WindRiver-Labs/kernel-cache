From 560bd17a72961f014b176725bae51aa0954fa83f Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Thu, 16 May 2013 19:07:56 +0300
Subject: [PATCH 269/547] fmd: fmd21.1 integration

Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>

- PFC
  Adjustments for PFC configuration constraints and limitations related to
  port prefetch mode

- workaround ucode issues
  Fix the following HW erratas regarding discard/error frames on V3:

    FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675 -
      Description: OP without VSP will cause buffer leaks when instructed to discard a frame.
      Workaround: FW will release the buffers.

    FM_ERROR_VSP_NO_MATCH_SW006 -
      Description: Any port with VSP enabled and multiple VSPs are configured
                   on this port can cause a situation where an error frame will
                   be enqueued to the error queue not with the default VSP.
      Workaround:  FW will replaced the current VSP with the default VSP
                   just before the frame is being enqueued to the error queue.

- Chosen-node new parameter support
  errors-to-discard
      Usage: optional
      Value type: <u32>
      Definition: Specifies which errors should be discarded.
        Errors that are not in the mask, will not be discarded;
        I.e. those errors will be enqueued and sent to the default error queue.

Change-Id: Ib468c67de88376e17d9c39ab5a0c8fc5b33b7b82
Reviewed-on: http://git.am.freescale.net:8181/2605
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Garg Vakul-B16394 <vakul@freescale.com>
Reviewed-by: Radulescu Ruxandra Ioana-B05472 <ruxandra.radulescu@freescale.com>
Reviewed-by: Chereji Marian-Cornel-R27762 <marian.chereji@freescale.com>
Reviewed-by: Wang Haiying-R54964 <Haiying.Wang@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 .../freescale/fman/Peripherals/FM/MAC/dtsec.c      |  10 +-
 .../freescale/fman/Peripherals/FM/MAC/dtsec.h      |   3 +-
 .../fman/Peripherals/FM/MAC/dtsec_mii_acc.c        |  26 +---
 .../fman/Peripherals/FM/MAC/dtsec_mii_acc.h        |   5 +-
 .../freescale/fman/Peripherals/FM/MAC/fm_mac.c     |   3 -
 .../fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c   |  64 ++++++----
 .../Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h    | 109 ----------------
 .../freescale/fman/Peripherals/FM/MAC/memac.c      |  20 +++
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.c   |  16 +--
 .../freescale/fman/Peripherals/FM/Port/fm_port.c   | 141 +++++++++++++++++----
 .../freescale/fman/Peripherals/FM/Port/fm_port.h   |   4 +-
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    |  71 +++++++++--
 .../ethernet/freescale/fman/Peripherals/FM/fm.h    |   2 +
 .../freescale/fman/Peripherals/FM/inc/fm_common.h  |  50 +++++++-
 .../fman/inc/flib/fsl_fman_dtsec_mii_acc.h         | 107 ++++++++++++++++
 .../inc/integrations/T4240/dpaa_integration_ext.h  |   2 +
 .../freescale/fman/src/wrapper/lnxwrp_fm_port.c    |  13 +-
 include/uapi/linux/fmd/Peripherals/fm_ioctls.h     |   2 +-
 18 files changed, 429 insertions(+), 219 deletions(-)
 delete mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h
 create mode 100644 drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec_mii_acc.h

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
index 605a1aa..e6fdb3f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -30,11 +30,10 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
 /******************************************************************************
  @File          dtsec.c
 
- @Description   FM dTSEC ...
+ @Description   FMan dTSEC driver
 *//***************************************************************************/
 
 #include "std_ext.h"
@@ -410,7 +409,8 @@ static t_Error GracefulStop(t_Dtsec *p_Dtsec, e_CommMode mode)
     }
 
     if (mode & e_COMM_MODE_TX)
-#if defined(FM_GTS_ERRATA_DTSEC_A004) || defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012)
+#if defined(FM_GTS_ERRATA_DTSEC_A004) || \
+    defined(FM_GTS_AFTER_MAC_ABORTED_FRAME_ERRATA_DTSEC_A0012)
     if (p_Dtsec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
         DBG(INFO, ("GTS not supported due to DTSEC_A004 errata."));
 #else  /* not defined(FM_GTS_ERRATA_DTSEC_A004) ||... */
@@ -1289,8 +1289,6 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
         RETURN_ERROR(MAJOR, err, ("This DTSEC version does not support the required i/f mode"));
     }
 
-    DTSEC_MII_Init(h_Dtsec);
-
     if (ENET_INTERFACE_FROM_MODE(p_Dtsec->enetMode) == e_ENET_IF_SGMII)
     {
         uint16_t            tmpReg16;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.h
index 177bc45..c26f40c 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -30,7 +30,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
 /******************************************************************************
  @File          dtsec.h
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c
index 371e1f9..f9dff6f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -52,14 +52,16 @@ t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
 {
     t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
     struct dtsec_mii_reg *miiregs;
+    uint16_t              dtsec_freq;
     t_Error               err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
 
+    dtsec_freq = (uint16_t)(p_Dtsec->fmMacControllerDriver.clkFreq >> 1);
     miiregs = p_Dtsec->p_MiiMemMap;
 
-    err = (t_Error)dtsec_mii_write_reg(miiregs, phyAddr, reg, data);
+    err = (t_Error)fman_dtsec_mii_write_reg(miiregs, phyAddr, reg, data, dtsec_freq);
 
     return err;
 }
@@ -72,14 +74,16 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
 {
     t_Dtsec               *p_Dtsec = (t_Dtsec *)h_Dtsec;
     struct dtsec_mii_reg  *miiregs;
+    uint16_t               dtsec_freq;
     t_Error                err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
 
+    dtsec_freq = (uint16_t)(p_Dtsec->fmMacControllerDriver.clkFreq >> 1);
     miiregs = p_Dtsec->p_MiiMemMap;
 
-    err = (t_Error)dtsec_mii_read_reg(miiregs, phyAddr, reg, p_Data);
+    err = (t_Error)fman_dtsec_mii_read_reg(miiregs, phyAddr, reg, p_Data, dtsec_freq);
 
     if (*p_Data == 0xffff)
         RETURN_ERROR(MINOR, E_NO_DEVICE,
@@ -91,19 +95,3 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
     return err;
 }
 
-t_Error DTSEC_MII_Init(t_Handle h_Dtsec)
-{
-    t_Dtsec                *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    struct dtsec_mii_reg  *miiregs;
-    uint16_t dtsec_freq;
-
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
-    SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
-
-    miiregs = p_Dtsec->p_MiiMemMap;
-    dtsec_freq = (uint16_t)(p_Dtsec->fmMacControllerDriver.clkFreq >> 1);
-
-    dtsec_mii_init(miiregs, dtsec_freq);
-
-    return E_OK;
-}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.h
index d5dd39a..75cc658 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -30,7 +30,6 @@
  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
 #ifndef __DTSEC_MII_ACC_H
 #define __DTSEC_MII_ACC_H
 
@@ -39,7 +38,5 @@
 
 t_Error DTSEC_MII_WritePhyReg(t_Handle h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t data);
 t_Error DTSEC_MII_ReadPhyReg(t_Handle  h_Dtsec, uint8_t phyAddr, uint8_t reg, uint16_t *p_Data);
-t_Error DTSEC_MII_Init(t_Handle h_Dtsec);
-
 
 #endif /* __DTSEC_MII_ACC_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
index f07b174..9050a77 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
@@ -350,9 +350,6 @@ t_Error FM_MAC_SetTxPauseFrames(t_Handle h_FmMac,
 
     SANITY_CHECK_RETURN_ERROR(p_FmMacControllerDriver, E_INVALID_HANDLE);
 
-    if ((priority != 0xFF) && FmGetTnumAgingPeriod(p_FmMacControllerDriver->h_Fm) == 0)
-        RETURN_ERROR(MAJOR, E_CONFLICT, ("Can't configure PFC when TNUM aging is disabled"));
-
     if (p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames)
         return p_FmMacControllerDriver->f_FM_MAC_SetTxPauseFrames(h_FmMac,
                                                                   priority,
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
index b1b7bae..1831f09 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec_mii_acc.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
@@ -40,7 +40,8 @@
  * @dtsec_freq:		dtsec clock frequency (in Mhz)
  *
  * This function calculates the dtsec mii clock divider that determines
- * the MII MDC clock. MII MDC clock can work in the range of 2.5 to 12.5 Mhz.
+ * the MII MDC clock. MII MDC clock will be set to work in the range
+ * of 1.5 to 2.5Mhz
  * The output of this function is the value of MIIMCFG[MgmtClk] which
  * implicitly determines the divider value.
  * Note: the dTSEC system clock is equal to 1/2 of the FMan clock.
@@ -49,31 +50,35 @@
  * shows the relations among dtsec_freq, MgmtClk, actual divider
  * and the MII frequency:
  *
- * dtsec freq   MgmtClk     div         MII freq
- * [80..159]      0      (1/4)(1/8)   [2.5 to 5.0]
- * [160..319]     1      (1/4)(1/8)   [5.0 to 10.0]
- * [320..479]     2      (1/6)(1/8)   [6.7 to 10.0]
- * [480..639]     3      (1/8)(1/8)   [7.5 to 10.0]
- * [640..799]     4      (1/10)(1/8)  [8.0 to 10.0]
- * [800..959]     5      (1/14)(1/8)  [7.1 to 8.5]
- * [960..1119]    6      (1/20)(1/8)  [6.0 to 7.0]
- * [1120..1279]   7      (1/28)(1/8)  [5.0 to 5.7]
- * [1280..2800]   7      (1/28)(1/8)  [5.7 to 12.5]
+ * dtsec freq   MgmtClk     div        MII freq Mhz
+ * [0.....80]     1      (1/4)(1/8)    [0   to 2.5]
+ * [81...120]     2      (1/6)(1/8)    [1.6 to 2.5]
+ * [121..160]     3      (1/8)(1/8)    [1.8 to 2.5]
+ * [161..200]     4      (1/10)(1/8)   [2.0 to 2.5]
+ * [201..280]     5      (1/14)(1/8)   [1.8 to 2.5]
+ * [281..400]     6      (1/20)(1/8)   [1.1 to 2.5]
+ * [401..560]     7      (1/28)(1/8)   [1.8 to 2.5]
+ * [560..frq]     7      (1/28)(1/8)   [frq/224]
  *
  * Returns: the MIIMCFG[MgmtClk] appropriate value
  */
 
 static uint8_t dtsec_mii_get_div(uint16_t dtsec_freq)
 {
-	uint16_t mgmt_clk = (uint16_t)(dtsec_freq / 160);
+	uint16_t mgmt_clk;
 
-	if (mgmt_clk > 7)
-		mgmt_clk = 7;
+	if (dtsec_freq < 80) mgmt_clk = 1;
+	else if (dtsec_freq < 120) mgmt_clk = 2;
+	else if (dtsec_freq < 160) mgmt_clk = 3;
+	else if (dtsec_freq < 200) mgmt_clk = 4;
+	else if (dtsec_freq < 280) mgmt_clk = 5;
+	else if (dtsec_freq < 400) mgmt_clk = 6;
+	else mgmt_clk = 7;
 
 	return (uint8_t)mgmt_clk;
 }
 
-void dtsec_mii_reset(struct dtsec_mii_reg *regs)
+void fman_dtsec_mii_reset(struct dtsec_mii_reg *regs)
 {
 	/* Reset the management interface */
 	iowrite32be(ioread32be(&regs->miimcfg) | MIIMCFG_RESET_MGMT,
@@ -82,30 +87,32 @@ void dtsec_mii_reset(struct dtsec_mii_reg *regs)
 			&regs->miimcfg);
 }
 
-void dtsec_mii_init(struct dtsec_mii_reg *regs, uint16_t dtsec_freq)
-{
-	/* Setup the MII Mgmt clock speed */
-	iowrite32be((uint32_t)dtsec_mii_get_div(dtsec_freq), &regs->miimcfg);
-}
 
-int dtsec_mii_write_reg(struct dtsec_mii_reg *regs, uint8_t addr,
-		uint8_t reg, uint16_t data)
+int fman_dtsec_mii_write_reg(struct dtsec_mii_reg *regs, uint8_t addr,
+		uint8_t reg, uint16_t data, uint16_t dtsec_freq)
 {
 	uint32_t	tmp;
 
+	/* Setup the MII Mgmt clock speed */
+	iowrite32be((uint32_t)dtsec_mii_get_div(dtsec_freq), &regs->miimcfg);
+	wmb();
+
 	/* Stop the MII management read cycle */
 	iowrite32be(0, &regs->miimcom);
 	/* Dummy read to make sure MIIMCOM is written */
 	tmp = ioread32be(&regs->miimcom);
+	wmb();
 
 	/* Setting up MII Management Address Register */
 	tmp = (uint32_t)((addr << MIIMADD_PHY_ADDR_SHIFT) | reg);
 	iowrite32be(tmp, &regs->miimadd);
+	wmb();
 
 	/* Setting up MII Management Control Register with data */
 	iowrite32be((uint32_t)data, &regs->miimcon);
 	/* Dummy read to make sure MIIMCON is written */
 	tmp = ioread32be(&regs->miimcon);
+	wmb();
 
 	/* Wait untill MII management write is complete */
 	/* todo: a timeout could be useful here */
@@ -115,19 +122,25 @@ int dtsec_mii_write_reg(struct dtsec_mii_reg *regs, uint8_t addr,
 	return 0;
 }
 
-int dtsec_mii_read_reg(struct dtsec_mii_reg *regs, uint8_t  addr,
-		uint8_t reg, uint16_t *data)
+int fman_dtsec_mii_read_reg(struct dtsec_mii_reg *regs, uint8_t  addr,
+		uint8_t reg, uint16_t *data, uint16_t dtsec_freq)
 {
 	uint32_t	tmp;
 
+	/* Setup the MII Mgmt clock speed */
+	iowrite32be((uint32_t)dtsec_mii_get_div(dtsec_freq), &regs->miimcfg);
+	wmb();
+
 	/* Setting up the MII Management Address Register */
 	tmp = (uint32_t)((addr << MIIMADD_PHY_ADDR_SHIFT) | reg);
 	iowrite32be(tmp, &regs->miimadd);
+	wmb();
 
 	/* Perform an MII management read cycle */
 	iowrite32be(MIIMCOM_READ_CYCLE, &regs->miimcom);
 	/* Dummy read to make sure MIIMCOM is written */
 	tmp = ioread32be(&regs->miimcom);
+	wmb();
 
 	/* Wait until MII management read is complete */
 	/* todo: a timeout could be useful here */
@@ -136,6 +149,7 @@ int dtsec_mii_read_reg(struct dtsec_mii_reg *regs, uint8_t  addr,
 
 	/* Read MII management status  */
 	*data = (uint16_t)ioread32be(&regs->miimstat);
+	wmb();
 
 	iowrite32be(0, &regs->miimcom);
 	/* Dummy read to make sure MIIMCOM is written */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h
deleted file mode 100644
index 9d156c0..0000000
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fsl_fman_dtsec_mii_acc.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright 2008-2012 Freescale Semiconductor Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *     * Redistributions of source code must retain the above copyright
- *       notice, this list of conditions and the following disclaimer.
- *     * Redistributions in binary form must reproduce the above copyright
- *       notice, this list of conditions and the following disclaimer in the
- *       documentation and/or other materials provided with the distribution.
- *     * Neither the name of Freescale Semiconductor nor the
- *       names of its contributors may be used to endorse or promote products
- *       derived from this software without specific prior written permission.
- *
- *
- * ALTERNATIVELY, this software may be distributed under the terms of the
- * GNU General Public License ("GPL") as published by the Free Software
- * Foundation, either version 2 of that License or (at your option) any
- * later version.
- *
- * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __FSL_FMAN_DTSEC_MII_ACC_H
-#define __FSL_FMAN_DTSEC_MII_ACC_H
-
-#include "common/general.h"
-
-
-/* MII Management Configuration Register */
-#define MIIMCFG_RESET_MGMT		0x80000000
-#define MIIMCFG_MGNTCLK_MASK		0x00000007
-#define MIIMCFG_MGNTCLK_SHIFT		0
-
-/* MII  Management Command Register */
-#define MIIMCOM_SCAN_CYCLE		0x00000002
-#define MIIMCOM_READ_CYCLE		0x00000001
-
-/* MII  Management Address Register */
-#define MIIMADD_PHY_ADDR_SHIFT		8
-#define MIIMADD_PHY_ADDR_MASK		0x00001f00
-
-#define MIIMADD_REG_ADDR_SHIFT		0
-#define MIIMADD_REG_ADDR_MASK		0x0000001f
-
-/* MII Management Indicator Register */
-#define MIIMIND_BUSY			0x00000001
-
-
-/* PHY Control Register */
-
-#define PHY_CR_PHY_RESET    0x8000
-#define PHY_CR_LOOPBACK     0x4000
-#define PHY_CR_SPEED0       0x2000
-#define PHY_CR_ANE          0x1000
-#define PHY_CR_RESET_AN     0x0200
-#define PHY_CR_FULLDUPLEX   0x0100
-#define PHY_CR_SPEED1       0x0040
-
-
-#define PHY_TBICON_SRESET   0x8000
-#define PHY_TBICON_CLK_SEL  0x0020
-
-#define PHY_TBIANA_SGMII    0x4001
-#define PHY_TBIANA_1000X    0x01a0
-
-
-/* register map */
-
-/* MII Configuration Control Memory Map Registers */
-struct dtsec_mii_reg {
-	uint32_t reserved1[72];
-	uint32_t miimcfg;	/* MII Mgmt:configuration */
-	uint32_t miimcom;	/* MII Mgmt:command       */
-	uint32_t miimadd;	/* MII Mgmt:address       */
-	uint32_t miimcon;	/* MII Mgmt:control 3     */
-	uint32_t miimstat;	/* MII Mgmt:status        */
-	uint32_t miimind;	/* MII Mgmt:indicators    */
-};
-
-/* dTSEC MII API */
-
-/* functions to access the mii registers for phy configuration.
- * this functionality may not be available for all dTSECs in the system.
- * consult the reference manual for details */
-void dtsec_mii_reset(struct dtsec_mii_reg *regs);
-/* frequency is in MHz.
- * note that dtsec clock is 1/2 of fman clock */
-void dtsec_mii_init(struct dtsec_mii_reg *regs, uint16_t dtsec_freq);
-int dtsec_mii_write_reg(struct dtsec_mii_reg *regs,
-			uint8_t addr,
-			uint8_t reg,
-			uint16_t data);
-
-int dtsec_mii_read_reg(struct dtsec_mii_reg *regs,
-			uint8_t addr,
-			uint8_t reg,
-			uint16_t *data);
-
-#endif /* __FSL_FMAN_DTSEC_MII_ACC_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
index d930502..905f91a 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
@@ -415,10 +415,30 @@ static t_Error MemacSetTxPauseFrames(t_Handle h_Memac,
                                      uint16_t threshTime)
 {
     t_Memac     *p_Memac = (t_Memac *)h_Memac;
+    t_Error     err = E_OK;
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_STATE);
     SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
 
+    if (priority != 0xFF)
+    {
+        bool   PortConfigured, PreFetchEnabled;
+
+        if (FmGetTnumAgingPeriod(p_Memac->fmMacControllerDriver.h_Fm) == 0)
+            RETURN_ERROR(MAJOR, E_CONFLICT, ("For PFC operation, TNUM aging must be enabled"));
+
+        FmGetPortPreFetchConfiguration(p_Memac->fmMacControllerDriver.h_Fm,
+                                       p_Memac->fmMacControllerDriver.macId,
+                                       &PortConfigured,
+                                       &PreFetchEnabled);
+
+        if ((ENET_SPEED_FROM_MODE(p_Memac->fmMacControllerDriver.enetMode) == e_ENET_SPEED_1000) && !PortConfigured)
+            DBG(INFO, ("For PFC correct operation, prefetch must be configured on the FM Tx PORT"));
+
+        if ((ENET_SPEED_FROM_MODE(p_Memac->fmMacControllerDriver.enetMode) == e_ENET_SPEED_1000) && PortConfigured && !PreFetchEnabled)
+            DBG(WARNING, ("For PFC correct operation, prefetch must be configured on the FM Tx PORT"));
+    }
+
     fman_memac_set_tx_pause_frames(p_Memac->p_MemMap, priority, pauseTime, threshTime);
 
     return E_OK;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
index 853fb3f..10a7626 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
@@ -1064,7 +1064,7 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has not be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
-        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
         /* For CAPWAP Rassembly used FMAN_CTRL2 hardcoded - so for fragmentation its better to use FMAN_CTRL1 */
         fmPortGetSetCcParams.setCcParams.orFmanCtrl = FPM_PORT_FM_CTL1;
 
@@ -1091,7 +1091,7 @@ static t_Error UpdateInitCapwapFragmentation(t_Handle       h_FmPort,
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("in this stage parameters from Port has be updated"));
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN | UPDATE_FMFP_PRC_WITH_ONE_RISC_ONLY;
-        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -1163,7 +1163,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         fmPortGetSetCcParams.getCcParams.type = p_Manip->updateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
-        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
@@ -1192,7 +1192,7 @@ static t_Error UpdateInitCapwapReasm(t_Handle      h_FmPcd,
 
         fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
         fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
-        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
 
         err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams);
         if (err)
@@ -1612,7 +1612,7 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
     t_Error                     err;
     t_FmPortPcdParams           *p_PcdParams = (t_FmPortPcdParams *)h_PcdParams;
 #if (DPAA_VERSION >= 11)
-    uint8_t                     *p_Ptr;
+    t_FmPcdCtrlParamsPage       *p_ParamsPage;
 #endif /* (DPAA_VERSION >= 11) */
 
     SANITY_CHECK_RETURN_ERROR(p_Manip, E_INVALID_HANDLE);
@@ -1718,7 +1718,7 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
 
     if (fmPortGetSetCcParams.getCcParams.revInfo.majorRev >= 6)
     {
-        if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_Ptr)) != E_OK)
+        if ((err = FmPortSetGprFunc(h_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage)) != E_OK)
             RETURN_ERROR(MAJOR, err, NO_MSG);
 
         tmpReg32 = NIA_ENG_KG;
@@ -1727,7 +1727,7 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
             tmpReg32 |= NIA_KG_DIRECT;
             tmpReg32 |= NIA_KG_CC_EN;
             tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv4Scheme);
-            WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV4_OFFSET), tmpReg32);
+            WRITE_UINT32(p_ParamsPage->iprIpv4Nia, tmpReg32);
         }
         if (p_Manip->ipReassmParams.h_Ipv6Scheme)
         {
@@ -1735,7 +1735,7 @@ static t_Error UpdateInitIpReasm(t_Handle       h_FmPcd,
             tmpReg32 |= NIA_KG_DIRECT;
             tmpReg32 |= NIA_KG_CC_EN;
             tmpReg32 |= FmPcdKgGetSchemeId(p_Manip->ipReassmParams.h_Ipv6Scheme);
-            WRITE_UINT32(*(uint32_t*)PTR_MOVE(p_Ptr, NIA_IPR_DIRECT_SCHEME_IPV6_OFFSET), tmpReg32);
+            WRITE_UINT32(p_ParamsPage->iprIpv6Nia, tmpReg32);
         }
     }
 #endif /* (DPAA_VERSION >= 11) */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index 5752bd6..8ea28dd 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -661,7 +661,7 @@ static t_Error BmiRxPortInit(t_FmPort *p_FmPort)
             tmpReg |= BMI_PORT_RFNE_FRWD_RPD;
         /* L3/L4 checksum verify is enabled by default. */
         /*tmpReg |= BMI_PORT_RFNE_FRWD_DCL4C;*/
-        WRITE_UINT32(p_Regs->fmbm_rfne, tmpReg | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+        WRITE_UINT32(p_Regs->fmbm_rfne, tmpReg | GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
     }
     WRITE_UINT32(p_Regs->fmbm_rfene, NIA_ENG_QMI_ENQ | NIA_ORDER_RESTOR);
 
@@ -893,7 +893,7 @@ static t_Error BmiOhPortInit(t_FmPort *p_FmPort)
         WRITE_UINT32(p_Regs->fmbm_ofsem, errorsToEnq);
 
         /* NIA */
-        WRITE_UINT32(p_Regs->fmbm_ofne, (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
+        WRITE_UINT32(p_Regs->fmbm_ofne, GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
 
 #ifndef FM_NO_OP_OBSERVED_POOLS
         /* Call the external Buffer routine which also checks fifo
@@ -1029,6 +1029,13 @@ static t_Error QmiInit(t_FmPort *p_FmPort)
             default:
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid dequeue prefetch option"));
         }
+#ifdef FM_QMI_NO_DEQ_OPTIONS_SUPPORT
+        if (p_FmPort->fmRevInfo.majorRev != 4)
+#endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
+        if (p_Params->deqPrefetchOption == e_FM_PORT_DEQ_NO_PREFETCH)
+            FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, FALSE);
+        else
+            FmSetPortPreFetchConfiguration(p_FmPort->h_Fm, p_FmPort->portId, TRUE);
 
         tmpReg |= p_Params->deqByteCnt;
         tmpReg |= (uint32_t)p_Params->deqSubPortal << QMI_DEQ_CFG_SUBPORTAL_SHIFT;
@@ -1873,7 +1880,8 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid port type"));
     }
 
-    if ((GET_UINT32(*p_BmiNia) & (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+    if ((GET_UINT32(*p_BmiNia) & GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME()) !=
+        GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("port has to be detached previousely"));
 
     /* "cut" PCD out of the port's flow - go to BMI */
@@ -1925,7 +1933,6 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
 
     ASSERT_COND(p_FmPort);
 
-
     /* get PCD registers pointers */
     if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         p_BmiNia = &p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofne;
@@ -1933,7 +1940,7 @@ static t_Error AttachPCD(t_FmPort *p_FmPort)
         p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
 
     /* check that current NIA is BMI to BMI */
-    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME))
+    if ((GET_UINT32(*p_BmiNia) & ~BMI_RFNE_FDCS_MASK) != GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME())
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
                      ("may be called only for ports in BMI-to-BMI state."));
 
@@ -1994,8 +2001,8 @@ static t_Error DetachPCD(t_FmPort *p_FmPort)
     else
         p_BmiNia = &p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfne;
 
-    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME));
-
+    WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) |
+                            GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME());
 
     if (FmPcdGetHcHandle(p_FmPort->h_FmPcd))
         FmPcdHcSync(p_FmPort->h_FmPcd);
@@ -2115,14 +2122,14 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
         switch (gprFunc)
         {
             case (e_FM_PORT_GPR_MURAM_PAGE):
-                p_FmPort->p_MuramPage = FM_MURAM_AllocMem(p_FmPort->h_FmMuram,
-                                                          256,
-                                                          8);
-                if (!p_FmPort->p_MuramPage)
+                p_FmPort->p_ParamsPage = FM_MURAM_AllocMem(p_FmPort->h_FmMuram,
+                                                           256,
+                                                           8);
+                if (!p_FmPort->p_ParamsPage)
                     RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc for page"));
 
-                IOMemSet32(p_FmPort->p_MuramPage, 0, 256);
-                muramPageOffset = (uint32_t)(XX_VirtToPhys(p_FmPort->p_MuramPage) -
+                IOMemSet32(p_FmPort->p_ParamsPage, 0, 256);
+                muramPageOffset = (uint32_t)(XX_VirtToPhys(p_FmPort->p_ParamsPage) -
                                              p_FmPort->fmMuramPhysBaseAddr);
                 switch (p_FmPort->portType)
                 {
@@ -2146,7 +2153,7 @@ t_Error FmPortSetGprFunc(t_Handle h_FmPort, e_FmPortGprFuncType gprFunc, void **
     switch (p_FmPort->gprFunc)
     {
         case (e_FM_PORT_GPR_MURAM_PAGE):
-            *p_Value = p_FmPort->p_MuramPage;
+            *p_Value = p_FmPort->p_ParamsPage;
             break;
         default:
             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
@@ -2787,6 +2794,39 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
 
     FmPortDriverParamFree(p_FmPort);
 
+#if (DPAA_VERSION >= 11)
+    if ((p_FmPort->portType == e_FM_PORT_TYPE_RX_10G) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_RX) ||
+        (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING))
+    {
+        t_FmPcdCtrlParamsPage   *p_ParamsPage;
+
+        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
+        ASSERT_COND(p_ParamsPage);
+
+        WRITE_UINT32(p_ParamsPage->misc, FM_CTL_PARAMS_PAGE_ALWAYS_ON);
+#ifdef FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+        {
+            WRITE_UINT32(p_ParamsPage->misc,
+                         (GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OP_FIX_EN));
+            WRITE_UINT32(p_ParamsPage->discardMask,
+                         GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
+        }
+#endif /* FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675 */
+#ifdef FM_ERROR_VSP_NO_MATCH_SW006
+        if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+            WRITE_UINT32(p_ParamsPage->errorsDiscardMask,
+                         (GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm) |
+                          GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsem)));
+        else
+            WRITE_UINT32(p_ParamsPage->errorsDiscardMask,
+                         (GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm) |
+                          GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsem)));
+#endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
+    }
+#endif /* (DPAA_VERSION >= 11) */
+
     return E_OK;
 }
 
@@ -2834,8 +2874,8 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
                         p_FmPort->portId) != E_OK)
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("VSP free of port FAILED"));
 
-    if (p_FmPort->p_MuramPage)
-        FM_MURAM_FreeMem(p_FmPort->h_FmMuram, p_FmPort->p_MuramPage);
+    if (p_FmPort->p_ParamsPage)
+        FM_MURAM_FreeMem(p_FmPort->h_FmMuram, p_FmPort->p_ParamsPage);
 #endif /* (DPAA_VERSION >= 11) */
 
     if (p_FmPort->h_Spinlock)
@@ -4081,6 +4121,17 @@ t_Error FM_PORT_SetErrorsRoute(t_Handle h_FmPort, fmPortFrameErrSelect_t errs)
 
     WRITE_UINT32(*p_ErrQReg, errs);
 
+#ifdef FM_ERROR_VSP_NO_MATCH_SW006
+    if (p_FmPort->fmRevInfo.majorRev >= 6)
+    {
+        t_FmPcdCtrlParamsPage   *p_ParamsPage;
+
+        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
+        ASSERT_COND(p_ParamsPage);
+        WRITE_UINT32(p_ParamsPage->errorsDiscardMask, GET_UINT32(*p_ErrDiscard) | errs);
+    }
+#endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
+
     return E_OK;
 }
 
@@ -4492,6 +4543,7 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
     }
 
     p_FmPort->vspe = TRUE;
+    p_FmPort->dfltRelativeId = p_VSPParams->dfltRelativeId;
 
     tmpReg = GET_UINT32(*p_BmiStorageProfileId) & ~BMI_SP_ID_MASK;
     tmpReg |= (uint32_t)hwStoragePrflId<<BMI_SP_ID_SHIFT;
@@ -4974,9 +5026,6 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
 
         if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
         {
-#if (DPAA_VERSION >= 11)
-#endif /* (DPAA_VERSION >= 11) */
-
 #ifdef FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
             if ((p_FmPort->fmRevInfo.majorRev < 6) &&
                 (p_FmPort->pcdEngines & FM_PCD_KG))
@@ -5023,14 +5072,12 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
         if (p_FmPort->fmRevInfo.majorRev < 6)
         {
             fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_PNEN;
-            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
+            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
         }
         else
         {
 #endif /* (DPAA_VERSION == 10) */
         fmPortGetSetCcParams.getCcParams.type = GET_NIA_FPNE;
-        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_CMNE;
-        fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_FRAG | NIA_ENG_FM_CTL;
 #if (DPAA_VERSION == 10)
         }
 #endif /* (DPAA_VERSION == 10) */
@@ -5096,6 +5143,52 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
     else
         FmPcdLockUnlockAll(p_FmPort->h_FmPcd);
 
+#if (DPAA_VERSION >= 11)
+    {
+        t_FmPcdCtrlParamsPage   *p_ParamsPage;
+
+        memset(&fmPortGetSetCcParams, 0, sizeof(t_FmPortGetSetCcParams));
+
+        fmPortGetSetCcParams.setCcParams.type = UPDATE_NIA_CMNE;
+        if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd))
+            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
+        else
+            fmPortGetSetCcParams.setCcParams.nia = NIA_FM_CTL_AC_NO_IPACC_POP_TO_N_STEP | NIA_ENG_FM_CTL;
+        if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams)) != E_OK)
+        {
+            DeletePcd(p_FmPort);
+            if (p_FmPort->h_IpReassemblyTree)
+            {
+                FM_PCD_CcRootDelete(p_FmPort->h_IpReassemblyTree);
+                p_FmPort->h_IpReassemblyTree = NULL;
+            }
+            RELEASE_LOCK(p_FmPort->lock);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+         }
+
+        FmPortSetGprFunc(p_FmPort, e_FM_PORT_GPR_MURAM_PAGE, (void**)&p_ParamsPage);
+        ASSERT_COND(p_ParamsPage);
+
+        if (FmPcdIsAdvancedOffloadSupported(p_FmPort->h_FmPcd))
+            WRITE_UINT32(p_ParamsPage->misc, GET_UINT32(p_ParamsPage->misc) | FM_CTL_PARAMS_PAGE_OFFLOAD_SUPPORT_EN);
+
+        if (p_FmPort->h_IpReassemblyManip)
+        {
+            if (p_FmPort->portType == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)
+                WRITE_UINT32(p_ParamsPage->discardMask,
+                             GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofsdm));
+            else
+                WRITE_UINT32(p_ParamsPage->discardMask,
+                             GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfsdm));
+        }
+#ifdef FM_ERROR_VSP_NO_MATCH_SW006
+        if (p_FmPort->vspe)
+            WRITE_UINT32(p_ParamsPage->misc,
+                         GET_UINT32(p_ParamsPage->misc) | (p_FmPort->dfltRelativeId & FM_CTL_PARAMS_PAGE_ERROR_VSP_MASK));
+#endif /* FM_ERROR_VSP_NO_MATCH_SW006 */
+    }
+#endif /* (DPAA_VERSION >= 11) */
+
     err = AttachPCD(h_FmPort);
     if (err)
     {
@@ -5415,7 +5508,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofene );
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmts);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmt);
-
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocmne);
         {
 #ifndef FM_NO_OP_OBSERVED_POOLS
             if (p_FmPort->fmRevInfo.majorRev == 4)
@@ -5480,6 +5573,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsdm);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsem);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfene);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcmne);
         DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi, ("fmbm_ebmpi"));
         DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
         {
@@ -5537,6 +5631,7 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfene);
 #if (DPAA_VERSION >= 11)
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfne);
+        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcmne);
 #endif /* (DPAA_VERSION >= 11) */
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmts);
         DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmt);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
index f922df8..12be3c2 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
@@ -927,13 +927,15 @@ typedef struct {
     t_FmPortRsrc                tasks;
     t_FmPortRsrc                fifoBufs;
     t_FmPortRxPoolsParams       rxPoolsParams;
+//    bool                        explicitUserSizeOfFifo;
     t_Handle                    h_IpReassemblyManip;
     t_Handle                    h_IpReassemblyTree;
     uint64_t                    fmMuramPhysBaseAddr;
 #if (DPAA_VERSION >= 11)
     bool                        vspe;
+    uint8_t                     dfltRelativeId;
     e_FmPortGprFuncType         gprFunc;
-    void                        *p_MuramPage;
+    t_FmPcdCtrlParamsPage       *p_ParamsPage;
 #endif /* (DPAA_VERSION >= 11) */
 
     t_FmPortDriverParam         *p_FmPortDriverParam;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index 6f27b2c..2fdc4c8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -1317,25 +1317,67 @@ uint16_t FmGetTnumAgingPeriod(t_Handle h_Fm)
     return p_Fm->tnumAgingPeriod;
 }
 
-t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
-                                        uint32_t     congestionGroupId,
-                                        uint8_t      priorityBitMap)
+t_Error FmSetPortPreFetchConfiguration(t_Handle h_Fm,
+                                       uint8_t  portNum,
+                                       bool     preFetchConfigured)
 {
-    t_Fm         *p_Fm  = (t_Fm *)h_Fm;
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    p_Fm->portsPreFetchConfigured[portNum] = TRUE;
+    p_Fm->portsPreFetchValue[portNum] = preFetchConfigured;
+
+    return E_OK;
+}
+
+t_Error FmGetPortPreFetchConfiguration(t_Handle h_Fm,
+                                       uint8_t  portNum,
+                                       bool     *p_PortConfigured,
+                                       bool     *p_PreFetchConfigured)
+{
+    t_Fm *p_Fm = (t_Fm*)h_Fm;
+
+    SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Fm->p_FmDriverParam, E_INVALID_STATE);
+
+    /* If the prefetch wasn't configured yet (not enable or disabled)
+       we return the value TRUE as it was already configured */
+    if (!p_Fm->portsPreFetchConfigured[portNum])
+    {
+        *p_PortConfigured = FALSE;
+        *p_PreFetchConfigured = FALSE;
+    }
+    else
+    {
+        *p_PortConfigured = TRUE;
+        *p_PreFetchConfigured = (p_Fm->portsPreFetchConfigured[portNum]);
+    }
+
+    return E_OK;
+}
+
+t_Error FmSetCongestionGroupPFCpriority(t_Handle    h_Fm,
+                                        uint32_t    congestionGroupId,
+                                        uint8_t     priorityBitMap)
+{
+    t_Fm    *p_Fm  = (t_Fm *)h_Fm;
 
     ASSERT_COND(h_Fm);
 
     if (congestionGroupId > FM_PORT_NUM_OF_CONGESTION_GRPS)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
-                     ("Congestion group ID bigger than %d \n!",
+                     ("Congestion group ID bigger than %d",
                       FM_PORT_NUM_OF_CONGESTION_GRPS));
 
     if (p_Fm->guestId == NCSW_MASTER_ID)
     {
-        uint32_t      *p_Cpg = (uint32_t*)(p_Fm->baseAddr+FM_MM_CGP);
-        uint32_t      tmpReg;
-        uint32_t      reg_num;
-        uint32_t      offset;
+        uint32_t    *p_Cpg = (uint32_t*)(p_Fm->baseAddr+FM_MM_CGP);
+        uint32_t    tmpReg;
+        uint32_t    reg_num;
+        uint32_t    offset;
+        uint32_t    mask;
 
         ASSERT_COND(p_Fm->baseAddr);
         reg_num = (FM_PORT_NUM_OF_CONGESTION_GRPS-1-(congestionGroupId))/4;
@@ -1346,15 +1388,13 @@ t_Error FmSetCongestionGroupPFCpriority(t_Handle     h_Fm,
         /* Adding priorities*/
         if (priorityBitMap)
         {
-            if (tmpReg & (0xFF<<(offset*8)))
+            if (tmpReg & (0xFF << (offset*8)))
                 RETURN_ERROR(MAJOR, E_INVALID_STATE,
                              ("PFC priority for the congestion group is already set!"));
         }
         else /* Deleting priorities */
         {
-            uint32_t mask;
-
-            mask = 0xFF<<(offset*8);
+            mask = (uint32_t)(0xFF << (offset*8));
             tmpReg &= ~mask;
         }
 
@@ -2318,6 +2358,10 @@ void FmFreePortParams(t_Handle h_Fm,t_FmInterModulePortFreeParams *p_PortParams)
 
     HW_PORT_ID_TO_SW_PORT_ID(macId, hardwarePortId);
 
+    /* Delete prefetch configuration*/
+    p_Fm->portsPreFetchConfigured[macId] = FALSE;
+    p_Fm->portsPreFetchValue[macId]      = FALSE;
+
 #if defined(FM_MAX_NUM_OF_10G_MACS) && (FM_MAX_NUM_OF_10G_MACS)
     if ((p_PortParams->portType == e_FM_PORT_TYPE_TX_10G) ||
         (p_PortParams->portType == e_FM_PORT_TYPE_RX_10G))
@@ -4119,6 +4163,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
     p_Fm->p_FmStateStruct->revInfo.minorRev = (uint8_t)((tmpReg & FPM_REV1_MINOR_MASK) >> FPM_REV1_MINOR_SHIFT);
     /* Chip dependent, will be configured in Init */
 
+    p_Fm->tnumAgingPeriod                                       = DEFAULT_tnumAgingPeriod;
     p_Fm->p_FmDriverParam->dmaAidOverride                       = DEFAULT_aidOverride;
     p_Fm->p_FmDriverParam->dmaAidMode                           = DEFAULT_aidMode;
 #ifdef FM_AID_MODE_NO_TNUM_SW005
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
index 5a3a005..cb97d3e 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
@@ -917,6 +917,8 @@ typedef struct t_Fm
     uint8_t                     partVSPBase;
     uintptr_t                   vspBaseAddr;
 #endif /* (DPAA_VERSION >= 11) */
+    bool                        portsPreFetchConfigured[FM_MAX_NUM_OF_HW_PORT_IDS]; /* Prefetch configration per Tx-port */
+    bool                        portsPreFetchValue[FM_MAX_NUM_OF_HW_PORT_IDS];      /* Prefetch value per Tx-port */
 
 /* un-needed for recovery */
     t_Handle                    h_FmMuram;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
index 288d018..a2ca82a 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
@@ -152,6 +152,22 @@ typedef _Packed struct t_FmPcdCcCapwapReassmTimeoutParams {
     volatile uint32_t                       timeoutRequestTime;
 }_PackedType t_FmPcdCcCapwapReassmTimeoutParams;
 
+/**************************************************************************//**
+ @Description   PCD CTRL Parameters Page
+*//***************************************************************************/
+typedef _Packed struct t_FmPcdCtrlParamsPage {
+    volatile uint8_t  reserved0[16];
+    volatile uint32_t iprIpv4Nia;
+    volatile uint32_t iprIpv6Nia;
+    volatile uint8_t  reserved1[24];
+    volatile uint32_t ipfOptionsCounter;
+    volatile uint8_t  reserved2[12];
+    volatile uint32_t misc;
+    volatile uint32_t errorsDiscardMask;
+    volatile uint32_t discardMask;
+    volatile uint8_t  reserved3[180];
+} _PackedType t_FmPcdCtrlParamsPage;
+
 
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
@@ -336,7 +352,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define NIA_FM_CTL_AC_HC                        0x0000000C
 #define NIA_FM_CTL_AC_IND_MODE_TX               0x00000008
 #define NIA_FM_CTL_AC_IND_MODE_RX               0x0000000A
-#define NIA_FM_CTL_AC_FRAG                      0x0000000e
+#define NIA_FM_CTL_AC_POP_TO_N_STEP             0x0000000e
 #define NIA_FM_CTL_AC_PRE_BMI_FETCH_HEADER      0x00000010
 #define NIA_FM_CTL_AC_PRE_BMI_FETCH_FULL_FRAME  0x00000018
 #define NIA_FM_CTL_AC_POST_BMI_FETCH            0x00000012
@@ -346,6 +362,10 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 #define NIA_FM_CTL_AC_POST_BMI_ENQ              0x00000022
 #define NIA_FM_CTL_AC_PRE_CC                    0x00000020
 #define NIA_FM_CTL_AC_POST_TX                   0x00000024
+/* V3 only */
+#define NIA_FM_CTL_AC_NO_IPACC_PRE_BMI_ENQ_FRAME        0x00000028
+#define NIA_FM_CTL_AC_NO_IPACC_PRE_BMI_DISCARD_FRAME    0x0000002A
+#define NIA_FM_CTL_AC_NO_IPACC_POP_TO_N_STEP            0x0000002C
 
 #define NIA_BMI_AC_ENQ_FRAME        0x00000002
 #define NIA_BMI_AC_TX_RELEASE       0x000002C0
@@ -362,6 +382,18 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
 
 #define NIA_BMI_AC_ENQ_FRAME_WITHOUT_DMA    0x00000202
 
+#if defined(FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675) || defined(FM_ERROR_VSP_NO_MATCH_SW006)
+#define GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)   \
+    (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd)) ? \
+                (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_ENQ_FRAME) : \
+                (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_NO_IPACC_PRE_BMI_ENQ_FRAME))
+#define GET_NIA_BMI_AC_DISCARD_FRAME(h_FmPcd)   \
+    (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd)) ? \
+                (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_DISCARD_FRAME) : \
+                (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_NO_IPACC_PRE_BMI_DISCARD_FRAME))
+#define GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME()   \
+        (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_NO_IPACC_PRE_BMI_ENQ_FRAME)
+#else
 #define GET_NIA_BMI_AC_ENQ_FRAME(h_FmPcd)   \
     (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd)) ? \
                 (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_ENQ_FRAME) : \
@@ -370,9 +402,18 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
     (uint32_t)((FmPcdIsAdvancedOffloadSupported(h_FmPcd)) ? \
                 (NIA_ENG_FM_CTL | NIA_FM_CTL_AC_PRE_BMI_DISCARD_FRAME) : \
                 (NIA_ENG_BMI | NIA_BMI_AC_DISCARD))
+#define GET_NO_PCD_NIA_BMI_AC_ENQ_FRAME()   \
+            (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)
+#endif /* defined(FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675) || ... */
 
-#define NIA_IPR_DIRECT_SCHEME_IPV4_OFFSET       0x10
-#define NIA_IPR_DIRECT_SCHEME_IPV6_OFFSET       0x14
+/**************************************************************************//**
+  @Description        CTRL Parameters Page defines
+*//***************************************************************************/
+#define FM_CTL_PARAMS_PAGE_OP_FIX_EN            0x80000000
+#define FM_CTL_PARAMS_PAGE_OFFLOAD_SUPPORT_EN   0x40000000
+#define FM_CTL_PARAMS_PAGE_ALWAYS_ON            0x00000100
+
+#define FM_CTL_PARAMS_PAGE_ERROR_VSP_MASK       0x0000003f
 
 /**************************************************************************//**
  @Description       Port Id defines
@@ -1058,6 +1099,9 @@ t_Error     FmSetMacMaxFrame(t_Handle h_Fm, e_FmMacType type, uint8_t macId, uin
 bool        FmIsMaster(t_Handle h_Fm);
 uint8_t     FmGetGuestId(t_Handle h_Fm);
 uint16_t    FmGetTnumAgingPeriod(t_Handle h_Fm);
+t_Error     FmSetPortPreFetchConfiguration(t_Handle h_Fm, uint8_t portNum, bool preFetchConfigured);
+t_Error     FmGetPortPreFetchConfiguration(t_Handle h_Fm, uint8_t portNum, bool *p_PortConfigured, bool *p_PreFetchConfigured);
+
 
 #ifdef FM_TX_ECC_FRMS_ERRATA_10GMAC_A004
 t_Error     Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId);
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec_mii_acc.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec_mii_acc.h
new file mode 100644
index 0000000..0dda09c
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_dtsec_mii_acc.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright 2008-2013 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FSL_FMAN_DTSEC_MII_ACC_H
+#define __FSL_FMAN_DTSEC_MII_ACC_H
+
+#include "common/general.h"
+
+
+/* MII Management Configuration Register */
+#define MIIMCFG_RESET_MGMT		0x80000000
+#define MIIMCFG_MGNTCLK_MASK		0x00000007
+#define MIIMCFG_MGNTCLK_SHIFT		0
+
+/* MII  Management Command Register */
+#define MIIMCOM_SCAN_CYCLE		0x00000002
+#define MIIMCOM_READ_CYCLE		0x00000001
+
+/* MII  Management Address Register */
+#define MIIMADD_PHY_ADDR_SHIFT		8
+#define MIIMADD_PHY_ADDR_MASK		0x00001f00
+
+#define MIIMADD_REG_ADDR_SHIFT		0
+#define MIIMADD_REG_ADDR_MASK		0x0000001f
+
+/* MII Management Indicator Register */
+#define MIIMIND_BUSY			0x00000001
+
+
+/* PHY Control Register */
+#define PHY_CR_PHY_RESET    0x8000
+#define PHY_CR_LOOPBACK     0x4000
+#define PHY_CR_SPEED0       0x2000
+#define PHY_CR_ANE          0x1000
+#define PHY_CR_RESET_AN     0x0200
+#define PHY_CR_FULLDUPLEX   0x0100
+#define PHY_CR_SPEED1       0x0040
+
+#define PHY_TBICON_SRESET   0x8000
+#define PHY_TBICON_SPEED2   0x0020
+#define PHY_TBICON_CLK_SEL  0x0020
+#define PHY_TBIANA_SGMII    0x4001
+#define PHY_TBIANA_1000X    0x01a0
+/* register map */
+
+/* MII Configuration Control Memory Map Registers */
+struct dtsec_mii_reg {
+	uint32_t reserved1[72];
+	uint32_t miimcfg;	/* MII Mgmt:configuration */
+	uint32_t miimcom;	/* MII Mgmt:command       */
+	uint32_t miimadd;	/* MII Mgmt:address       */
+	uint32_t miimcon;	/* MII Mgmt:control 3     */
+	uint32_t miimstat;	/* MII Mgmt:status        */
+	uint32_t miimind;	/* MII Mgmt:indicators    */
+};
+
+/* dTSEC MII API */
+
+/* functions to access the mii registers for phy configuration.
+ * this functionality may not be available for all dtsecs in the system.
+ * consult the reference manual for details */
+void fman_dtsec_mii_reset(struct dtsec_mii_reg *regs);
+/* frequency is in MHz.
+ * note that dtsec clock is 1/2 of fman clock */
+void fman_dtsec_mii_init(struct dtsec_mii_reg *regs, uint16_t dtsec_freq);
+int fman_dtsec_mii_write_reg(struct dtsec_mii_reg *regs,
+			uint8_t addr,
+			uint8_t reg,
+			uint16_t data,
+			uint16_t dtsec_freq);
+
+int fman_dtsec_mii_read_reg(struct dtsec_mii_reg *regs,
+			uint8_t addr,
+			uint8_t reg,
+			uint16_t *data,
+			uint16_t dtsec_freq);
+
+#endif /* __FSL_FMAN_DTSEC_MII_ACC_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
index be08780..83ae8ba 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
@@ -260,10 +260,12 @@ typedef enum
 #define FM_HEAVY_TRAFFIC_HANG_ERRATA_FMAN_A005669
 #define FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
 #define FM_RX_FIFO_CORRUPT_ERRATA_10GMAC_A006320
+#define FM_OP_NO_VSP_NO_RELEASE_ERRATA_FMAN_A006675
 
 #define FM_BCB_ERRATA_BMI_SW001
 #define FM_LEN_CHECK_ERRATA_FMAN_SW002
 #define FM_AID_MODE_NO_TNUM_SW005 /* refer to pdm TKT068794 - only support of port_id on aid */
+#define FM_ERROR_VSP_NO_MATCH_SW006 /* refer to pdm TKT174304 - no match between errorQ and VSP */
 
 /*****************************************************************************
  RMan INTEGRATION-SPECIFIC DEFINITIONS
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
index 00b0da4..8e61106 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm_port.c
@@ -534,7 +534,7 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
-    uint32_prop = (uint32_t *)of_get_property(port_node, "fifo_size", &lenp);
+    uint32_prop = (uint32_t *)of_get_property(port_node, "fifo-size", &lenp);
     if (uint32_prop) {
     	if (WARN_ON(lenp != sizeof(uint32_t)*2))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
@@ -547,6 +547,16 @@ static t_Error CheckNConfigFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
             RETURN_ERROR(MINOR, err, NO_MSG);
     }
 
+    uint32_prop = (uint32_t *)of_get_property(port_node, "errors-to-discard", &lenp);
+    if (uint32_prop) {
+        if (WARN_ON(lenp != sizeof(uint32_t)))
+            RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
+
+        if ((err = FM_PORT_ConfigErrorsToDiscard(p_LnxWrpFmPortDev->h_Dev,
+                                                 uint32_prop[0])) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+
     of_node_put(port_node);
     of_node_put(fm_node);
 
@@ -595,7 +605,6 @@ static t_Error CheckNSetFmPortAdvArgs (t_LnxWrpFmPortDev *p_LnxWrpFmPortDev)
 
         portVSPAllocParams.numOfProfiles = (uint8_t)uint32_prop[0];
         portVSPAllocParams.dfltRelativeId = (uint8_t)uint32_prop[1];
-
         fmVspParams.h_Fm = p_LnxWrpFmDev->h_Dev;
 
         fmVspParams.portParams.portType = p_LnxWrpFmPortDev->settings.param.portType;
diff --git a/include/uapi/linux/fmd/Peripherals/fm_ioctls.h b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
index 8a62398..870b345 100644
--- a/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
+++ b/include/uapi/linux/fmd/Peripherals/fm_ioctls.h
@@ -622,7 +622,7 @@ typedef struct ioc_fm_ctrl_mon_counters_params_t {
 /** @} */ /* end of lnx_ioctl_FM_grp */
 
 #define FMD_API_VERSION_MAJOR 21
-#define FMD_API_VERSION_MINOR 0
+#define FMD_API_VERSION_MINOR 1
 #define FMD_API_VERSION_RESPIN 0
 
 #endif /* __FM_IOCTLS_H */
-- 
1.8.4.93.g57e4c17

