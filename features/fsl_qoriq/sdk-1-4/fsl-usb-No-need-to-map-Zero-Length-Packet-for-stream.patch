From a649f99a34ef87a5807bdac3fd0bab942e5051ec Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Fri, 28 Jun 2013 15:08:38 +0800
Subject: [PATCH 241/430] fsl/usb: No need to map Zero Length Packet for
 streaming DMA

ZLP buffer mapping using streaming DMA is not required

Signed-off-by: Suresh Gupta <suresh.gupta@freescale.com>
Change-Id: Ifa4ee7970160f0b3e473b167bc53803ac30e51b4
Reviewed-on: http://git.am.freescale.net:8181/1319
Reviewed-by: Mehresh Ramneek-B31383 <ramneek.mehresh@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch is from QorIQ-SDK-V1.4-20130625-yocto, just
a minor modification to port 3.4 kernel]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/usb/gadget/fsl_udc_core.c |   72 +++++++++++++++++++-----------------
 1 files changed, 38 insertions(+), 34 deletions(-)

diff --git a/drivers/usb/gadget/fsl_udc_core.c b/drivers/usb/gadget/fsl_udc_core.c
index bd7e7dd..68434ee 100644
--- a/drivers/usb/gadget/fsl_udc_core.c
+++ b/drivers/usb/gadget/fsl_udc_core.c
@@ -162,6 +162,7 @@ static void done(struct fsl_ep *ep, struct fsl_req *req, int status)
 	unsigned char stopped = ep->stopped;
 	struct ep_td_struct *curr_td, *next_td;
 	int j;
+	struct device *pdev = NULL;
 
 	udc = (struct fsl_udc *)ep->udc;
 	/* Removed the req from fsl_ep->queue */
@@ -183,20 +184,24 @@ static void done(struct fsl_ep *ep, struct fsl_req *req, int status)
 		dma_pool_free(udc->td_pool, curr_td, curr_td->td_dma);
 	}
 
-	if (req->mapped) {
-		dma_unmap_single(ep->udc->gadget.dev.parent,
-			req->req.dma, req->req.length,
-			ep_is_in(ep)
-				? DMA_TO_DEVICE
-				: DMA_FROM_DEVICE);
-		req->req.dma = DMA_ADDR_INVALID;
-		req->mapped = 0;
-	} else
-		dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
-			req->req.dma, req->req.length,
-			ep_is_in(ep)
-				? DMA_TO_DEVICE
-				: DMA_FROM_DEVICE);
+	if (req->req.length) {
+		/* Non Zero Length Packet */
+		pdev = ep->udc->gadget.dev.parent;
+		if (req->mapped) {
+			dma_unmap_single(pdev, req->req.dma,
+				req->req.length,
+				ep_is_in(ep)
+					? DMA_TO_DEVICE
+					: DMA_FROM_DEVICE);
+			req->req.dma = DMA_ADDR_INVALID;
+			req->mapped = 0;
+		} else
+			dma_sync_single_for_cpu(pdev, req->req.dma,
+				req->req.length,
+				ep_is_in(ep)
+					? DMA_TO_DEVICE
+					: DMA_FROM_DEVICE);
+	}
 
 	if (status && (status != -ESHUTDOWN))
 		VDBG("complete %s req %p stat %d len %u/%u",
@@ -887,6 +892,7 @@ fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 	struct fsl_req *req = container_of(_req, struct fsl_req, req);
 	struct fsl_udc *udc;
 	unsigned long flags;
+	struct device *pdev = NULL;
 
 	/* catch various bogus parameters */
 	if (!_req || !req->req.complete || !req->req.buf
@@ -909,21 +915,24 @@ fsl_ep_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
 
 	req->ep = ep;
 
-	/* map virtual address to hardware */
-	if (req->req.dma == DMA_ADDR_INVALID) {
-		req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
-					req->req.buf,
-					req->req.length, ep_is_in(ep)
-						? DMA_TO_DEVICE
-						: DMA_FROM_DEVICE);
-		req->mapped = 1;
-	} else {
-		dma_sync_single_for_device(ep->udc->gadget.dev.parent,
-					req->req.dma, req->req.length,
-					ep_is_in(ep)
-						? DMA_TO_DEVICE
-						: DMA_FROM_DEVICE);
-		req->mapped = 0;
+	if (req->req.length) {
+		/* Non Zero Length Packet */
+		/* map virtual address to hardware */
+		pdev = ep->udc->gadget.dev.parent;
+		if (req->req.dma == DMA_ADDR_INVALID) {
+			req->req.dma = dma_map_single(pdev, req->req.buf,
+						req->req.length, ep_is_in(ep)
+							? DMA_TO_DEVICE
+							: DMA_FROM_DEVICE);
+			req->mapped = 1;
+		} else {
+			dma_sync_single_for_device(pdev, req->req.dma,
+						req->req.length,
+						ep_is_in(ep)
+							? DMA_TO_DEVICE
+							: DMA_FROM_DEVICE);
+			req->mapped = 0;
+		}
 	}
 
 	req->req.status = -EINPROGRESS;
@@ -1305,11 +1314,6 @@ static int ep0_prime_status(struct fsl_udc *udc, int direction)
 	req->req.complete = NULL;
 	req->dtd_count = 0;
 
-	req->req.dma = dma_map_single(ep->udc->gadget.dev.parent,
-			req->req.buf, req->req.length,
-			ep_is_in(ep) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
-	req->mapped = 1;
-
 	if (fsl_req_to_dtd(req, GFP_ATOMIC) == 0)
 		fsl_queue_td(ep, req);
 	else
-- 
1.7.5.4

