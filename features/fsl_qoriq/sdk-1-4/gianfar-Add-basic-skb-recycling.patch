From 5329dc1ad4c7e879f20f31fb84fce1c248bab3b7 Mon Sep 17 00:00:00 2001
From: Claudiu Manoil <claudiu.manoil@freescale.com>
Date: Wed, 27 Mar 2013 13:02:47 +0200
Subject: [PATCH 374/547] gianfar: Add basic skb recycling

Introduce per device skb recycle queues, in order to reuse 'hot'
skbs on the device's Rx path without allocating new ones.
The skb recycling infrastructure is taken from the mainline
kernel 3.0 (see skb_is_recycleable() and skb_recycle()).
The recycle queue accesses (enqueue/ dequeue skbs) are protected
by the skb queue lock, b/w the Rx and Tx paths.

There are two work modes when recycling skbs:
1) the device recycles its own skbs: the skbs 'freed' on the device's
Tx path are put back into the same device's recycle queue;
2) the transmitting device recycles the skbs to the targeted receiving
device's recycle queue, to benefit ipv4 forwarding scenarios.

The 'recycle_target' read/write sysfs entry is provided to select b/w
the two work modes for a gfar (gianfar) interface.
e.g. for the gfar interface 'eth1', by default 'recycle_target' is set
to 'eth1', meaning the the device operates in mode 1.  When forwarding
packets b/w the two gfar devices 'eth2'->'eth1', the 'recycle_target'
entry for 'eth1' should be set to 'eth2', to successfully enable
operation mode 2.

The readonly 'recyle' sysfs entry provides skb recycling statistics
for a given gfar device.

Taken from the mainline kernel 3.0, where it operated only in mode 1,
and adapted to work in packet forwarding scenarios too (mode 2).

Signed-off-by: Claudiu Manoil <claudiu.manoil@freescale.com>
Change-Id: Id5f705759e1519cc42d5fbf94fd7542eb4661ee4
Reviewed-on: http://git.am.freescale.net:8181/870
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/gianfar.c       | 97 ++++++++++++++++++++++++--
 drivers/net/ethernet/freescale/gianfar.h       | 15 ++++
 drivers/net/ethernet/freescale/gianfar_sysfs.c | 70 +++++++++++++++++++
 3 files changed, 176 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c
index 2375a01..74faeb7 100644
--- a/drivers/net/ethernet/freescale/gianfar.c
+++ b/drivers/net/ethernet/freescale/gianfar.c
@@ -110,7 +110,7 @@ static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev);
 static void gfar_reset_task(struct work_struct *work);
 static void gfar_timeout(struct net_device *dev);
 static int gfar_close(struct net_device *dev);
-struct sk_buff *gfar_new_skb(struct net_device *dev);
+static struct sk_buff *gfar_alloc_skb(struct net_device *dev);
 static void gfar_new_rxbdp(struct gfar_priv_rx_q *rx_queue, struct rxbd8 *bdp,
 			   struct sk_buff *skb);
 static int gfar_set_mac_address(struct net_device *dev);
@@ -143,6 +143,8 @@ static void gfar_set_mac_for_addr(struct net_device *dev, int num,
 				  const u8 *addr);
 static int gfar_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 
+LIST_HEAD(gfar_recycle_queues);
+
 MODULE_AUTHOR("Freescale Semiconductor, Inc");
 MODULE_DESCRIPTION("Gianfar Ethernet Driver");
 MODULE_LICENSE("GPL");
@@ -207,7 +209,7 @@ static int gfar_init_bds(struct net_device *ndev)
 				gfar_init_rxbdp(rx_queue, rxbdp,
 						rxbdp->bufPtr);
 			} else {
-				skb = gfar_new_skb(ndev);
+				skb = gfar_alloc_skb(ndev);
 				if (!skb) {
 					netdev_err(ndev, "Can't allocate RX buffers\n");
 					return -ENOMEM;
@@ -972,6 +974,19 @@ static void gfar_detect_errata(struct gfar_private *priv)
 			 priv->errata);
 }
 
+static void gfar_init_recycle(struct gfar_private *priv)
+{
+	struct gfar_priv_recycle *rec = &priv->recycle;
+
+	rec->buff_size = priv->rx_buffer_size + RXBUF_ALIGNMENT;
+	skb_queue_head_init(&rec->recycle_q);
+	/* recycle skbs to the own queue by default */
+	priv->recycle_target = &priv->recycle;
+	priv->recycle_ndev = priv->ndev;
+
+	list_add(&priv->recycle_node, &gfar_recycle_queues);
+}
+
 /* Set up the ethernet device structure, private data,
  * and anything else we need before we start
  */
@@ -1154,6 +1169,9 @@ static int gfar_probe(struct platform_device *ofdev)
 
 	priv->rx_buffer_size = DEFAULT_RX_BUFFER_SIZE;
 
+	/* init buffer recycling fields */
+	gfar_init_recycle(priv);
+
 	/* Initializing some of the rx/tx queue level parameters */
 	for (i = 0; i < priv->num_tx_queues; i++) {
 		priv->tx_queue[i]->tx_ring_size = DEFAULT_TX_RING_SIZE;
@@ -1750,6 +1768,13 @@ static void free_skb_rx_queue(struct gfar_priv_rx_q *rx_queue)
 	rx_queue->rx_skbuff = NULL;
 }
 
+static void free_skb_recycle_q(struct gfar_priv_recycle *rec)
+{
+	struct sk_buff *skb;
+	while ((skb = skb_dequeue(&rec->recycle_q)) != NULL)
+		dev_kfree_skb_any(skb);
+}
+
 /* If there are any tx skbs or rx skbs still around, free them.
  * Then free tx_skbuff and rx_skbuff
  */
@@ -1781,6 +1806,17 @@ static void free_skb_resources(struct gfar_private *priv)
 			  sizeof(struct rxbd8) * priv->total_rx_ring_size,
 			  priv->tx_queue[0]->tx_bd_base,
 			  priv->tx_queue[0]->tx_bd_dma_base);
+
+	/* purge the skb recycle queue */
+	free_skb_recycle_q(&priv->recycle);
+}
+
+static void gfar_reset_recycle(struct gfar_private *priv)
+{
+	struct gfar_priv_recycle *rec = &priv->recycle;
+
+	rec->buff_size = priv->rx_buffer_size + RXBUF_ALIGNMENT;
+	free_skb_recycle_q(rec);
 }
 
 void gfar_start(struct net_device *dev)
@@ -2410,6 +2446,7 @@ static int gfar_change_mtu(struct net_device *dev, int new_mtu)
 		stop_gfar(dev);
 
 	priv->rx_buffer_size = tempsize;
+	gfar_reset_recycle(priv);
 
 	dev->mtu = new_mtu;
 
@@ -2474,6 +2511,36 @@ static void gfar_align_skb(struct sk_buff *skb)
 		    (((unsigned long) skb->data) & (RXBUF_ALIGNMENT - 1)));
 }
 
+static void gfar_recycle_skb(struct gfar_private *priv, struct sk_buff *skb)
+{
+	struct gfar_priv_recycle *rec_target = priv->recycle_target;
+	struct sk_buff_head *recycle_q;
+
+	if (unlikely(!rec_target))
+		goto free;
+
+	if (unlikely(!skb_is_recycleable(skb, rec_target->buff_size)))
+		goto free;
+
+	recycle_q = &rec_target->recycle_q;
+
+	if (unlikely(skb_queue_len(recycle_q) >= GFAR_RECYCLE_MAX))
+		goto free;
+
+	skb_recycle(skb);
+
+	gfar_align_skb(skb);
+
+	skb_queue_head(recycle_q, skb);
+
+	atomic_inc(&rec_target->recycle_cnt);
+
+	return;
+
+free:
+	dev_kfree_skb(skb);
+}
+
 /* Interrupt Handler for Transmit complete */
 static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 {
@@ -2553,7 +2620,7 @@ static void gfar_clean_tx_ring(struct gfar_priv_tx_q *tx_queue)
 
 		bytes_sent += skb->len;
 
-		dev_kfree_skb_any(skb);
+		gfar_recycle_skb(priv, skb);
 
 		tx_queue->tx_skbuff[skb_dirtytx] = NULL;
 
@@ -2628,9 +2695,27 @@ static struct sk_buff *gfar_alloc_skb(struct net_device *dev)
 	return skb;
 }
 
-struct sk_buff *gfar_new_skb(struct net_device *dev)
+static struct sk_buff *gfar_new_skb(struct gfar_private *priv)
 {
-	return gfar_alloc_skb(dev);
+	struct sk_buff *skb = NULL;
+	struct gfar_priv_recycle *rec = &priv->recycle;
+	struct sk_buff_head *recycle_q;
+
+	recycle_q = &rec->recycle_q;
+
+	skb = skb_dequeue(recycle_q);
+
+	if (unlikely(!skb))
+		goto alloc;
+
+	atomic_inc(&rec->reuse_cnt);
+
+	return skb;
+
+alloc:
+	skb = gfar_alloc_skb(priv->ndev);
+
+	return skb;
 }
 
 static inline void count_errors(unsigned short status, struct net_device *dev)
@@ -2764,7 +2849,7 @@ int gfar_clean_rx_ring(struct gfar_priv_rx_q *rx_queue, int rx_work_limit)
 		rmb();
 
 		/* Add another skb for the future */
-		newskb = gfar_new_skb(dev);
+		newskb = gfar_new_skb(priv);
 
 		skb = rx_queue->rx_skbuff[rx_queue->skb_currx];
 
diff --git a/drivers/net/ethernet/freescale/gianfar.h b/drivers/net/ethernet/freescale/gianfar.h
index 0ba8cac..ab9041e 100644
--- a/drivers/net/ethernet/freescale/gianfar.h
+++ b/drivers/net/ethernet/freescale/gianfar.h
@@ -1040,6 +1040,14 @@ enum gfar_errata {
 	GFAR_ERRATA_12		= 0x08, /* a.k.a errata eTSEC49 */
 };
 
+struct gfar_priv_recycle {
+#define GFAR_RECYCLE_MAX	DEFAULT_RX_RING_SIZE
+	struct sk_buff_head recycle_q __aligned(SMP_CACHE_BYTES);
+	unsigned int buff_size;
+	atomic_t recycle_cnt;
+	atomic_t reuse_cnt;
+};
+
 /* Struct stolen almost completely (and shamelessly) from the FCC enet source
  * (Ok, that's not so true anymore, but there is a family resemblance)
  * The GFAR buffer descriptors track the ring buffers.  The rx_bd_base
@@ -1068,6 +1076,9 @@ struct gfar_private {
 	struct gfar_priv_rx_q *rx_queue[MAX_RX_QS];
 	struct gfar_priv_grp gfargrp[MAXGROUPS];
 
+	struct gfar_priv_recycle recycle;
+	struct gfar_priv_recycle *recycle_target;
+
 	u32 device_flags;
 
 	unsigned int mode;
@@ -1104,6 +1115,9 @@ struct gfar_private {
 		/* Enable priorty based Tx scheduling in Hw */
 		prio_sched_en:1;
 
+	struct net_device *recycle_ndev;
+	struct list_head recycle_node;
+
 	/* The total tx and rx ring size for the enabled queues */
 	unsigned int total_tx_ring_size;
 	unsigned int total_rx_ring_size;
@@ -1188,6 +1202,7 @@ extern void gfar_check_rx_parser_mode(struct gfar_private *priv);
 extern void gfar_vlan_mode(struct net_device *dev, netdev_features_t features);
 
 extern const struct ethtool_ops gfar_ethtool_ops;
+extern struct list_head gfar_recycle_queues;
 
 #define MAX_FILER_CACHE_IDX (2*(MAX_FILER_IDX))
 
diff --git a/drivers/net/ethernet/freescale/gianfar_sysfs.c b/drivers/net/ethernet/freescale/gianfar_sysfs.c
index acb55af..e2d5542 100644
--- a/drivers/net/ethernet/freescale/gianfar_sysfs.c
+++ b/drivers/net/ethernet/freescale/gianfar_sysfs.c
@@ -319,6 +319,74 @@ static ssize_t gfar_set_fifo_starve_off(struct device *dev,
 static DEVICE_ATTR(fifo_starve_off, 0644, gfar_show_fifo_starve_off,
 		   gfar_set_fifo_starve_off);
 
+static ssize_t gfar_show_recycle(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct gfar_private *priv = netdev_priv(to_net_dev(dev));
+	struct gfar_priv_recycle *rec = &priv->recycle;
+
+	pr_info("recycled skbs: %d\nreused skbs: %d\n",
+		atomic_read(&rec->recycle_cnt),
+		atomic_read(&rec->reuse_cnt));
+
+	return sprintf(buf, "%s\n", priv->ndev->name);
+}
+
+static DEVICE_ATTR(recycle, 0444, gfar_show_recycle, NULL);
+
+static ssize_t gfar_show_recycle_target(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	struct gfar_private *priv = netdev_priv(to_net_dev(dev));
+
+	return sprintf(buf, "%s\n", priv->recycle_ndev->name);
+}
+
+static ssize_t gfar_set_recycle_target(struct device *dev,
+				       struct device_attribute *attr,
+				       const char *buf, size_t count)
+{
+	struct net_device *ndev = to_net_dev(dev);
+	struct gfar_private *priv = netdev_priv(ndev);
+	struct gfar_private *priv_target;
+	int found = 0;
+
+	list_for_each_entry(priv_target, &gfar_recycle_queues, recycle_node) {
+		char *name = priv_target->ndev->name;
+		if ((strlen(name) == count - 1) &&
+			!strncmp(buf, name, count - 1)) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found) {
+		pr_err("Invalid skb recycle target device!\n");
+		return count;
+	}
+
+	if (priv->recycle_target == &priv_target->recycle)
+		/* nothing to do */
+		return count;
+
+	if (ndev->flags & IFF_UP)
+		stop_gfar(ndev);
+
+	priv->recycle_target = &priv_target->recycle;
+	priv->recycle_ndev = priv_target->ndev;
+
+	if (ndev->flags & IFF_UP)
+		startup_gfar(ndev);
+
+	return count;
+}
+
+static DEVICE_ATTR(recycle_target, 0644, gfar_show_recycle_target,
+		   gfar_set_recycle_target);
+
+
 void gfar_init_sysfs(struct net_device *dev)
 {
 	struct gfar_private *priv = netdev_priv(dev);
@@ -336,6 +404,8 @@ void gfar_init_sysfs(struct net_device *dev)
 	rc |= device_create_file(&dev->dev, &dev_attr_fifo_threshold);
 	rc |= device_create_file(&dev->dev, &dev_attr_fifo_starve);
 	rc |= device_create_file(&dev->dev, &dev_attr_fifo_starve_off);
+	rc |= device_create_file(&dev->dev, &dev_attr_recycle);
+	rc |= device_create_file(&dev->dev, &dev_attr_recycle_target);
 	if (rc)
 		dev_err(&dev->dev, "Error creating gianfar sysfs files\n");
 }
-- 
1.8.4.93.g57e4c17

