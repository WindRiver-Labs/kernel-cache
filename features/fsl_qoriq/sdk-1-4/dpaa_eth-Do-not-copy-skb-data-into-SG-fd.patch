From 5d108adb687beb6d8e8fe3e86142092467939905 Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Mon, 15 Oct 2012 09:53:21 +0300
Subject: [PATCH 015/430] dpaa_eth: Do not copy skb->data into SG fd

Directly map the linear part of the egress fragmented skbuff rather than
copying it into the first fragment of the SG fd we're composing to FMan.

Change-Id: I28db929d5dd0b48d53073a5f854b9ad3a0ef49f5
Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
(cherry picked from commit 80fd59dc890d2198fcd9fc57afa8a6d10a84a7f9)
Reviewed-on: http://git.am.freescale.net:8181/1044
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[original patch is from QorIQ-SDK-V1.4-20130625-yocto]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c |   56 ++++------------------
 1 files changed, 10 insertions(+), 46 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 011ef52..067318c 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -232,14 +232,13 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 	if (fd->format == qm_fd_sg) {
 		/*
-		 * All storage items used are pages, but only the sgt and
-		 * the first page are guaranteed to reside in lowmem.
+		 * The sgt page is guaranteed to reside in lowmem.
 		 */
 		sgt = phys_to_virt(addr + dpa_fd_offset(fd));
 
-		/* page 0 is from lowmem, was dma_map_single()-ed */
+		/* sgt[0] is from lowmem, was dma_map_single()-ed */
 		dma_unmap_single(dpa_bp->dev, sgt[0].addr,
-				 dpa_bp->size, dma_dir);
+				sgt[0].length, dma_dir);
 
 		/* remaining pages were mapped with dma_map_page() */
 		for (i = 1; i < skb_shinfo(skb)->nr_frags; i++) {
@@ -257,8 +256,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 		/* Free separately the pages that we allocated on Tx */
 		free_page((unsigned long)phys_to_virt(addr));
-		free_page((unsigned long)phys_to_virt(sgt[0].addr));
-	}
+}
 
 	return skb;
 }
@@ -604,7 +602,7 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	int err;
 
 	struct qm_sg_entry *sgt;
-	unsigned long sgt_page, sg0_page;
+	unsigned long sgt_page;
 	void *buffer_start;
 	skb_frag_t *frag;
 	int i, j;
@@ -634,45 +632,12 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 	}
 
 	sgt = (struct qm_sg_entry *)(sgt_page + DPA_BP_HEAD);
-	/*
-	 * TODO: do we need to memset all entries or just the number of entries
-	 * we really use? Might improve perf...
-	 */
-	memset(sgt, 0, DPA_SGT_MAX_ENTRIES * sizeof(*sgt));
-
-	/*
-	 * Populate the first SGT entry
-	 * get a new page to store the skb linear buffer content
-	 * in the first SGT entry
-	 *
-	 * TODO: See if we can use the original page that contains
-	 * the linear buffer
-	 */
-	sg0_page = __get_free_page(GFP_ATOMIC);
-	if (unlikely(!sg0_page)) {
-		dpaa_eth_err(dpa_bp->dev, "__get_free_page() failed\n");
-		err = -ENOMEM;
-		goto sg0_page_alloc_failed;
-	}
-
 	sgt[0].bpid = dpa_bp->bpid;
 	sgt[0].offset = 0;
 	sgt[0].length = skb_headlen(skb);
-
-	/*
-	 * FIXME need more than one page if the linear part of the skb
-	 * is longer than PAGE_SIZE
-	 */
-	if (unlikely(sgt[0].offset + skb_headlen(skb) > dpa_bp->size)) {
-		pr_warn_once("tx headlen %d larger than available buffs %d\n",
-			skb_headlen(skb), dpa_bp->size);
-		err = -EINVAL;
-		goto skb_linear_too_large;
-	}
-
-	buffer_start = (void *)sg0_page;
-	memcpy(buffer_start + sgt[0].offset, skb->data, skb_headlen(skb));
-	addr = dma_map_single(dpa_bp->dev, buffer_start, dpa_bp->size, dma_dir);
+	sgt[0].extension = 0;
+	sgt[0].final = 0;
+	addr = dma_map_single(dpa_bp->dev, skb->data, sgt[0].length, dma_dir);
 	if (unlikely(dma_mapping_error(dpa_bp->dev, addr))) {
 		dpaa_eth_err(dpa_bp->dev, "DMA mapping failed");
 		err = -EINVAL;
@@ -688,6 +653,8 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 		sgt[i].bpid = dpa_bp->bpid;
 		sgt[i].offset = 0;
 		sgt[i].length = frag->size;
+		sgt[i].extension = 0;
+		sgt[i].final = 0;
 
 		/* This shouldn't happen */
 		BUG_ON(!frag->page.p);
@@ -732,9 +699,6 @@ sg_map_failed:
 		dma_unmap_page(dpa_bp->dev, qm_sg_addr(&sgt[j]),
 			dpa_bp->size, dma_dir);
 sg0_map_failed:
-	free_page(sg0_page);
-skb_linear_too_large:
-sg0_page_alloc_failed:
 csum_failed:
 	free_page(sgt_page);
 
-- 
1.7.5.4

