From 8a42087249dd35ddc79d94c34e677efe3741cf74 Mon Sep 17 00:00:00 2001
From: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Date: Tue, 21 May 2013 14:23:22 +0300
Subject: [PATCH 416/547] dpa_offload: Fix for Policer engine in
 dpa_ipsec_sa_add_policy

When the function dpa_ipsec_sa_add_policy is called, the policy
parameters are copied in an internal structure. The policer
parameters are provided as a pointer so the parameters should
be copied in an internal allocated memory area and not used "as is".

Change-Id: I342f0f06457bb128452b33bed3eac55752c4bd6b
Signed-off-by: Anca Jeanina FLOAREA <anca.floarea@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/2625
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Varvara Andrei-B21317 <andrei.varvara@freescale.com>
Reviewed-by: Chereji Marian-Cornel-R27762 <marian.chereji@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c     | 28 +++++++++++++++++++++++++
 drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c |  7 ++++---
 2 files changed, 32 insertions(+), 3 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 28e3fdf..86d52a7 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -2665,6 +2665,7 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 				struct dpa_ipsec_policy_entry **policy_entry)
 {
 	struct dpa_ipsec_policy_entry *pol_entry;
+	struct dpa_ipsec_pol_dir_params *dir = NULL;
 
 	BUG_ON(!sa);
 	BUG_ON(!policy_params);
@@ -2682,6 +2683,24 @@ static int store_policy_param_to_sa_pol_list(struct dpa_ipsec_sa *sa,
 	/* copy policy parameters */
 	pol_entry->pol_params = *policy_params;
 
+	/* if necessary, allocate memory to hold policer parameters */
+	dir = &policy_params->dir_params;
+	if (dir->type == DPA_IPSEC_POL_DIR_PARAMS_ACT &&
+	    dir->in_action.type == DPA_CLS_TBL_ACTION_ENQ &&
+	    dir->in_action.enq_params.policer_params) {
+		struct dpa_cls_tbl_policer_params *plcr = NULL;
+
+		plcr = kzalloc(sizeof(*plcr), GFP_KERNEL);
+		if (!plcr) {
+			pr_err("Could not allocate memory for policer\n");
+			return -ENOMEM;
+		}
+		memcpy(plcr, dir->in_action.enq_params.policer_params,
+		       sizeof(*plcr));
+		pol_entry->pol_params.dir_params.in_action.
+		       enq_params.policer_params = plcr;
+	}
+
 	/* add policy to the SA's policy list */
 	list_add(&pol_entry->node, &sa->policy_headlist);
 
@@ -2830,6 +2849,8 @@ static int remove_policy_from_sa_policy_list(struct dpa_ipsec_sa *sa,
 					     struct dpa_ipsec_policy_entry
 					     *policy_entry)
 {
+	struct dpa_ipsec_pol_dir_params *dir = NULL;
+
 	BUG_ON(!sa);
 	BUG_ON(!policy_entry);
 
@@ -2841,6 +2862,13 @@ static int remove_policy_from_sa_policy_list(struct dpa_ipsec_sa *sa,
 	/* unlink this policy from SA's list */
 	list_del(&policy_entry->node);
 
+	/* release memory used for holding policer parameters */
+	dir = &policy_entry->pol_params.dir_params;
+	if (dir->type == DPA_IPSEC_POL_DIR_PARAMS_ACT &&
+	    dir->in_action.type == DPA_CLS_TBL_ACTION_ENQ &&
+	    dir->in_action.enq_params.policer_params)
+		kfree(dir->in_action.enq_params.policer_params);
+
 	/* release memory used for holding policy general parameters */
 	kfree(policy_entry);
 
diff --git a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
index 3ad2325..0faf3e7 100644
--- a/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/wrp_dpa_ipsec.c
@@ -708,7 +708,7 @@ static int do_add_rem_policy_ioctl(void *args, bool add_pol)
 	if (prm.pol_params.dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_ACT) {
 		err = copy_policer_params(&prm.pol_params.dir_params.in_action);
 		if (err < 0)
-			goto free_pol_memory;
+			return err;
 	}
 
 	if (add_pol)
@@ -716,8 +716,8 @@ static int do_add_rem_policy_ioctl(void *args, bool add_pol)
 	else
 		err = dpa_ipsec_sa_remove_policy(prm.sa_id, &prm.pol_params);
 
-free_pol_memory:
-	kfree(prm.pol_params.dir_params.in_action.enq_params.policer_params);
+	if (prm.pol_params.dir_params.type == DPA_IPSEC_POL_DIR_PARAMS_ACT)
+		kfree(prm.pol_params.dir_params.in_action.enq_params.policer_params);
 
 	return err;
 }
@@ -839,6 +839,7 @@ static int do_sa_get_policies_ioctl(void *args)
 	for (i = 0; i < num_pol; i++) {
 		dir = &policy_params[i].dir_params;
 		if (dir->type == DPA_IPSEC_POL_DIR_PARAMS_ACT &&
+		    dir->in_action.type == DPA_CLS_TBL_ACTION_ENQ &&
 		    dir->in_action.enq_params.policer_params != NULL)
 			kplcr[i] = dir->in_action.enq_params.policer_params;
 	}
-- 
1.8.4.93.g57e4c17

