From 2deca4b89d80905d6933a0dfa85e9ef30c0089fe Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Thu, 4 Jul 2013 18:42:01 +0800
Subject: [PATCH 331/430] Revert "powerpc/85xx: Add a new MDIO driver for
 hydra boards"

This reverts commit 675b88fbbc431af3cf7c7c58798a122db3324e06.

The 416912a commit introuced a new MDIO bus multiplexer driven by GPIO
lines, in SDK1.4, the driver is used instead of hydra boards's mdio
driver.
The 6cc2ff8 commit added support for a MDIO bus multiplexer controlled
by FPGA. For hydra boards like P5040DS or P5020DS they just use
FPGA to control MDIO bus multiplexer. SDK1.4 replaces the old QDS
boards's mdio driver introduced by SDK1.3 with the new driver.

Conflicts:

	arch/powerpc/platforms/85xx/corenet_ds.c
	arch/powerpc/platforms/85xx/hydra_mdio.c

Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
---
 arch/powerpc/platforms/85xx/Kconfig      |    8 -
 arch/powerpc/platforms/85xx/Makefile     |    1 -
 arch/powerpc/platforms/85xx/corenet_ds.c |    6 -
 arch/powerpc/platforms/85xx/hydra_mdio.c |  265 ------------------------------
 4 files changed, 0 insertions(+), 280 deletions(-)
 delete mode 100644 arch/powerpc/platforms/85xx/hydra_mdio.c

diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 7e69bfe..321c135 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -243,7 +243,6 @@ config P3041_DS
 	select HAS_FSL_PAMU
 	select HAS_FSL_QBMAN
 	select HAS_FSL_PME
-	select FSL_HYDRA_DS_MDIO if PHYLIB
 	help
 	  This option enables support for the P3041 DS board
 
@@ -311,7 +310,6 @@ config P5020_DS
 	select HAS_FSL_PAMU
 	select HAS_FSL_QBMAN
 	select HAS_FSL_PME
-	select FSL_HYDRA_DS_MDIO if PHYLIB
 	help
 	  This option enables support for the P5020 DS board
 
@@ -332,7 +330,6 @@ config P5040_DS
 	select HAS_FSL_PAMU
 	select HAS_FSL_QBMAN
 	select HAS_FSL_PME
-	select FSL_HYDRA_DS_MDIO if PHYLIB
 	help
 	  This option enables support for the Freescale P5040 DS
 	  ("Super Hydra") reference board.
@@ -362,10 +359,5 @@ config FSL_P4080_DS_MDIO
 	select VITESSE_PHY
 	depends on PHYLIB
 
-config FSL_HYDRA_DS_MDIO
-	bool
-	select VITESSE_PHY
-	depends on PHYLIB
-
 config TQM85xx
 	bool
diff --git a/arch/powerpc/platforms/85xx/Makefile b/arch/powerpc/platforms/85xx/Makefile
index 2913941..9664618 100644
--- a/arch/powerpc/platforms/85xx/Makefile
+++ b/arch/powerpc/platforms/85xx/Makefile
@@ -30,7 +30,6 @@ obj-$(CONFIG_P5020_DS)    += p5020_ds.o corenet_ds.o
 obj-$(CONFIG_P5040_DS)    += p5040_ds.o corenet_ds.o
 obj-$(CONFIG_T4240_QDS)   += t4240_qds.o corenet_ds.o
 obj-$(CONFIG_FSL_P4080_DS_MDIO) += p4080_ds_mdio.o
-obj-$(CONFIG_FSL_HYDRA_DS_MDIO) += hydra_mdio.o
 obj-$(CONFIG_STX_GP3)	  += stx_gp3.o
 obj-$(CONFIG_TQM85xx)	  += tqm85xx.o
 obj-$(CONFIG_SBC8560)     += sbc8560.o
diff --git a/arch/powerpc/platforms/85xx/corenet_ds.c b/arch/powerpc/platforms/85xx/corenet_ds.c
index fa166e6..0ac734b 100644
--- a/arch/powerpc/platforms/85xx/corenet_ds.c
+++ b/arch/powerpc/platforms/85xx/corenet_ds.c
@@ -143,12 +143,6 @@ int __init declare_of_platform_devices(void)
 	for_each_compatible_node(np, NULL, "fsl,p4080ds-xmdio")
 		of_platform_device_create(np, NULL, NULL);
 
-	for_each_compatible_node(np, NULL, "fsl,hydra-mdio")
-		of_platform_device_create(np, NULL, NULL);
-
-	for_each_compatible_node(np, NULL, "fsl,hydra-xmdio")
-		of_platform_device_create(np, NULL, NULL);
-
 	return 0;
 }
 
diff --git a/arch/powerpc/platforms/85xx/hydra_mdio.c b/arch/powerpc/platforms/85xx/hydra_mdio.c
deleted file mode 100644
index 109e289..0000000
--- a/arch/powerpc/platforms/85xx/hydra_mdio.c
+++ /dev/null
@@ -1,265 +0,0 @@
-/*
- * Provides PIXIS-based MDIO muxing the Hydra and Super Hydra boards
- *
- * Copyright 2010-2012 Freescale Semiconductor, Inc.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
- * Hydra is the codename for the P3041 DS & P5020 DS boards
- * Super Hydra is the codename for the P5040 DS boards
- */
-
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/mii.h>
-#include <linux/phy.h>
-#include <linux/of.h>
-#include <linux/of_mdio.h>
-#include <linux/of_platform.h>
-#include <linux/module.h>
-#include <asm/io.h>
-
-#define BRDCFG1	0x9
-#define BRDCFG1_EMI1_SEL_MASK	0x70
-#define BRDCFG1_EMI1_EN		0x08
-
-struct hydra_mdio {
-	struct mii_bus *real_bus;
-	int irqs[PHY_MAX_ADDR];
-	u8 *pixis;
-	u8 value;
-	u8 mask;
-};
-
-/* Mutex for the EMI register in PIXIS */
-static DEFINE_MUTEX(emi_lock);
-
-/* Set the BRDCFG1 pixis register, and then write the MDIO regs */
-static int hydra_mdio_write(struct mii_bus *bus, int port_addr, int dev_addr,
-			int regnum, u16 value)
-{
-	struct hydra_mdio *priv = bus->priv;
-	struct mii_bus *real = priv->real_bus;
-	int ret;
-
-	mutex_lock(&emi_lock);
-
-	/* Write BRDCFG1 to select this bus */
-	clrsetbits_8(priv->pixis + BRDCFG1, priv->mask, priv->value);
-
-	/* Write through to the attached MDIO bus */
-	ret = real->write(real, port_addr, dev_addr, regnum, value);
-
-	mutex_unlock(&emi_lock);
-
-	return ret;
-}
-
-/* Set the BRDCFG1 pixis register, and then read from the MDIO bus */
-static int hydra_mdio_read(struct mii_bus *bus, int port_addr, int dev_addr,
-			int regnum)
-{
-	struct hydra_mdio *priv = bus->priv;
-	struct mii_bus *real = priv->real_bus;
-	int ret;
-
-	mutex_lock(&emi_lock);
-
-	clrsetbits_8(priv->pixis + BRDCFG1, priv->mask, priv->value);
-
-	ret = real->read(real, port_addr, dev_addr, regnum);
-
-	mutex_unlock(&emi_lock);
-
-	return ret;
-}
-
-/* Reset the MIIM registers, and wait for the bus to free */
-static int hydra_mdio_reset(struct mii_bus *bus)
-{
-	struct hydra_mdio *priv = bus->priv;
-	struct mii_bus *real = priv->real_bus;
-	int ret;
-
-	mutex_lock(&emi_lock);
-
-	clrsetbits_8(priv->pixis + BRDCFG1, priv->mask, priv->value);
-
-	ret = real->reset(real);
-
-	mutex_unlock(&emi_lock);
-
-	return ret;
-}
-
-static int __devinit hydra_mdio_probe(struct platform_device *pdev)
-{
-	struct device_node *np = pdev->dev.of_node;
-	struct mii_bus *new_bus;
-	struct hydra_mdio *priv;
-	struct device_node *mdio_np, *pixis_np;
-	struct platform_device *mdiodev;
-	const u32 *iprop;
-	int ret;
-
-	/* TODO: Replace with mdiobus_alloc_size() upstream */
-	new_bus = mdiobus_alloc();
-	if (!new_bus)
-		return -ENOMEM;
-
-	new_bus->name = "Freescale Hydra MDIO Bus";
-	new_bus->read = hydra_mdio_read;
-	new_bus->write = hydra_mdio_write;
-	new_bus->reset = hydra_mdio_reset;
-	strncpy(new_bus->id, np->name, MII_BUS_ID_SIZE);
-
-	priv = kzalloc(sizeof(struct hydra_mdio), GFP_KERNEL);
-	if (!priv) {
-		ret = -ENOMEM;
-		goto err_priv_alloc;
-	}
-	new_bus->priv = priv;
-	new_bus->irq = priv->irqs; /* Initialized by of_mdiobus_register() */
-	new_bus->parent = &pdev->dev;
-
-	/* Get the parent (real) mdio bus */
-	mdio_np = of_parse_phandle(np, "fsl,mdio-handle", 0);
-	if (!mdio_np) {
-		dev_err(&pdev->dev, "could not find real MDIO bus for %s\n",
-		       np->full_name);
-		ret = -ENODEV;
-		goto err_no_mdio_node;
-	}
-
-	mdiodev = of_find_device_by_node(mdio_np);
-	if (!mdiodev) {
-		dev_err(&pdev->dev, "could not find device for MDIO node %s\n",
-		       mdio_np->full_name);
-		ret = -ENODEV;
-		goto err_no_mdio_dev;
-	}
-
-	priv->real_bus = dev_get_drvdata(&mdiodev->dev);
-	if (!priv->real_bus) {
-		dev_err(&pdev->dev, "MDIO node %s has not been probed\n",
-			mdio_np->full_name);
-		ret = -ENODEV;
-		goto err_no_pdev;
-	}
-
-	/* Find the pixis node */
-	pixis_np = of_find_compatible_node(NULL, NULL, "fsl,fpga-ngpixis");
-	if (!pixis_np) {
-		dev_err(&pdev->dev, "could not find PIXIS node\n");
-		ret = -ENODEV;
-		goto err_no_pixis;
-	}
-
-	priv->pixis = of_iomap(pixis_np, 0);
-	if (!priv->pixis) {
-		dev_err(&pdev->dev, "could not map PIXIS node %s\n",
-			pixis_np->full_name);
-		ret = -ENOMEM;
-		goto err_pixis_iomap;
-	}
-
-	/* Get the MDIO MUX mask and value */
-	iprop = of_get_property(np, "fsl,hydra-mdio-mux-val", NULL);
-	if (!iprop)
-		/* Older device trees used -muxval instead of -mux-val */
-		iprop = of_get_property(np, "fsl,hydra-mdio-muxval", NULL);
-	if (!iprop) {
-		dev_err(&pdev->dev, "no MUX value found for %s\n",
-			np->full_name);
-		ret = -ENODEV;
-		goto err_get_muxval;
-	}
-	/* Note: some trees already have BRDCFG1_EMI1_EN in the value */
-	priv->value = BRDCFG1_EMI1_EN | be32_to_cpup(iprop);
-
-	iprop = of_get_property(np, "fsl,hydra-mdio-mux-mask", NULL);
-	if (iprop)
-		priv->mask = be32_to_cpup(iprop);
-	else
-		/* Older device trees assumed a hard-coded constant mask */
-		priv->mask = BRDCFG1_EMI1_SEL_MASK;
-
-	/* Finally, register our new bus */
-	ret = of_mdiobus_register(new_bus, np);
-	if (ret) {
-		dev_err(&pdev->dev, "cannot register MDIO bus %s (ret = %i)\n",
-		       new_bus->name, ret);
-		goto err_registration;
-	}
-
-	dev_set_drvdata(&pdev->dev, new_bus);
-
-	of_node_put(pixis_np);
-	of_node_put(mdio_np);
-
-	return 0;
-
-err_registration:
-err_get_muxval:
-	iounmap(priv->pixis);
-err_pixis_iomap:
-	of_node_put(pixis_np);
-err_no_pixis:
-err_no_pdev:
-err_no_mdio_dev:
-	of_node_put(mdio_np);
-err_no_mdio_node:
-	kfree(priv);
-err_priv_alloc:
-	mdiobus_free(new_bus);
-
-	return ret;
-}
-
-static int __devexit hydra_mdio_remove(struct platform_device *pdev)
-{
-	struct device *device = &pdev->dev;
-	struct mii_bus *bus = dev_get_drvdata(device);
-	struct hydra_mdio *priv = bus->priv;
-
-	mdiobus_unregister(bus);
-	dev_set_drvdata(device, NULL);
-
-	iounmap(priv->pixis);
-	kfree(bus->priv);
-
-	mdiobus_free(bus);
-
-	return 0;
-}
-
-static struct of_device_id hydra_mdio_match[] = {
-	{
-		.compatible = "fsl,hydra-mdio",
-	},
-	{
-		.compatible = "fsl,hydra-xmdio",
-	},
-	{}
-};
-MODULE_DEVICE_TABLE(of, mdio_match);
-
-static struct platform_driver hydra_mdio_driver = {
-	.driver = {
-		.name = "hydra_mdio",
-		.of_match_table = hydra_mdio_match,
-	},
-	.probe = hydra_mdio_probe,
-	.remove = hydra_mdio_remove,
-};
-
-static int __init hydra_mdio_init(void)
-{
-	return platform_driver_register(&hydra_mdio_driver);
-}
-subsys_initcall_sync(hydra_mdio_init);
-- 
1.7.5.4

