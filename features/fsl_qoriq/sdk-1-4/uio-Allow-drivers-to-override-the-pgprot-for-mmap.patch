From a890596bde587195ffd6afd1be7d971bb29016b7 Mon Sep 17 00:00:00 2001
From: Kumar Gala <galak@kernel.crashing.org>
Date: Wed, 14 Mar 2012 04:49:34 +0000
Subject: [PATCH 150/547] uio: Allow drivers to override the pgprot for mmap()

For some devices, the default behavior of pgprot_noncached() is not
appropriate for all of its mappable regions. This provides a means for
the kernel side of the UIO driver to override the flags without having
to implement its own full mmap callback.

Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
Signed-off-by: Geoff Thorpe <geoff@geoffthorpe.net>
Signed-off-by: Emil Medve <Emilian.Medve@Freescale.com>
[Original patch taken from QorIQ-SDK-V1.4-SOURCE-20130625-yocto.iso]
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 Documentation/DocBook/uio-howto.tmpl | 12 ++++++++++++
 drivers/uio/uio.c                    |  6 +++++-
 include/linux/uio_driver.h           |  3 +++
 3 files changed, 20 insertions(+), 1 deletion(-)

diff --git a/Documentation/DocBook/uio-howto.tmpl b/Documentation/DocBook/uio-howto.tmpl
index 9561815..88451f7 100644
--- a/Documentation/DocBook/uio-howto.tmpl
+++ b/Documentation/DocBook/uio-howto.tmpl
@@ -510,6 +510,18 @@ interrupts from userspace by writing to <filename>/dev/uioX</filename>,
 you can implement this function. The parameter <varname>irq_on</varname>
 will be 0 to disable interrupts and 1 to enable them.
 </para></listitem>
+
+<listitem><para>
+<varname>pgprot_t (*set_pgprot)(struct uio_info *info, unsigned int mem_idx,
+pgprot_t prot)</varname>: Optional. If special flags are required when mapping
+certain hardware regions, then this callback can be used to specify those flags.
+The default flags are given by the host architecture's definition of
+<function>pgprot_noncached()</function> and are passed to the callback as the
+<varname>prot</varname> parameter, but the return value is what is used for the
+resulting mapping. Note that this callback is only used by the built in mapping
+logic (when the <function>mmap()</function> callback has not been set), and then
+only for UIO_MEM_PHYS regions.
+</para></listitem>
 </itemizedlist>
 
 <para>
diff --git a/drivers/uio/uio.c b/drivers/uio/uio.c
index b645c47..450c4e6 100644
--- a/drivers/uio/uio.c
+++ b/drivers/uio/uio.c
@@ -643,7 +643,11 @@ static int uio_mmap_physical(struct vm_area_struct *vma)
 	if (mi < 0)
 		return -EINVAL;
 
-	vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
+	if (idev->info->set_pgprot)
+		vma->vm_page_prot = idev->info->set_pgprot(idev->info, mi,
+							   vma->vm_page_prot);
+	else
+		vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);
 
 	return remap_pfn_range(vma,
 			       vma->vm_start,
diff --git a/include/linux/uio_driver.h b/include/linux/uio_driver.h
index 1ad4724..66af0e9 100644
--- a/include/linux/uio_driver.h
+++ b/include/linux/uio_driver.h
@@ -80,6 +80,7 @@ struct uio_device;
  * @open:		open operation for this uio device
  * @release:		release operation for this uio device
  * @irqcontrol:		disable/enable irqs when 0/1 is written to /dev/uioX
+ * @set_pgprot:		allow driver to override default(noncached) pgprot
  */
 struct uio_info {
 	struct uio_device	*uio_dev;
@@ -95,6 +96,8 @@ struct uio_info {
 	int (*open)(struct uio_info *info, struct inode *inode);
 	int (*release)(struct uio_info *info, struct inode *inode);
 	int (*irqcontrol)(struct uio_info *info, s32 irq_on);
+	pgprot_t (*set_pgprot)(struct uio_info *uio, unsigned int mem_idx,
+			       pgprot_t prot);
 };
 
 extern int __must_check
-- 
1.8.4.93.g57e4c17

