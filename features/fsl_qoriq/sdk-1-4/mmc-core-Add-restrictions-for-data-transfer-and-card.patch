From 0b2f94b0aa8ba7b8e99dfaafc06d21c7a0b19413 Mon Sep 17 00:00:00 2001
From: Jiang Lu <lu.jiang@windriver.com>
Date: Fri, 28 Jun 2013 16:50:44 +0800
Subject: [PATCH 259/430] mmc:core: Add restrictions for data transfer and
 card erase

If max_discard_to was not designed, for mmc card preferred erase
size should be used, for sd card just return UINT_MAX. Also add
limit for data transfer, Use max_discard_to as data timeout value
to avoid timeout error in case data timeout was larger than
max_discard_to.

This patch can fix I/O error due to large timeout value for
erase(CMD38) and write(CMD25) for some crappy cards.

Signed-off-by: Haijun Zhang <haijun.zhang@freescale.com>
Signed-off-by: Jerry Huang <Chang-Ming.Huang@freescale.com>
Change-Id: Ib34a7bdb10714b9ab8be0c2b9c2e21bd396edd0f
Reviewed-on: http://git.am.freescale.net:8181/405
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[Original patch is from QorIQ-SDK-V1.4-20130625-yocto, just a minor
modification to port 3.4 kernel]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/mmc/core/core.c        |   45 +++++++++++++++++++++++++++------------
 drivers/mmc/host/sdhci-esdhc.h |    8 +++++++
 2 files changed, 39 insertions(+), 14 deletions(-)

diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c
index 937ae5a..9a6438c 100644
--- a/drivers/mmc/core/core.c
+++ b/drivers/mmc/core/core.c
@@ -488,6 +488,7 @@ EXPORT_SYMBOL(mmc_wait_for_cmd);
  */
 void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 {
+	struct mmc_host *host = card->host;
 	unsigned int mult;
 
 	/*
@@ -511,7 +512,12 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 	if (data->flags & MMC_DATA_WRITE)
 		mult <<= card->csd.r2w_factor;
 
-	data->timeout_ns = card->csd.tacc_ns * mult;
+	/* Avoid over flow for some crappy cards. */
+	if ((UINT_MAX / mult) < card->csd.tacc_ns)
+		data->timeout_ns = UINT_MAX;
+	else
+		data->timeout_ns = card->csd.tacc_ns * mult;
+
 	data->timeout_clks = card->csd.tacc_clks * mult;
 
 	/*
@@ -573,6 +579,12 @@ void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)
 				data->timeout_ns =  100000000;	/* 100ms */
 		}
 	}
+
+	if (host->max_discard_to &&
+			(host->max_discard_to <
+			(data->timeout_ns / 1000000)))
+		data->timeout_ns = host->max_discard_to * 1000000;
+
 }
 EXPORT_SYMBOL(mmc_set_data_timeout);
 
@@ -1450,11 +1462,14 @@ static unsigned int mmc_mmc_erase_timeout(struct mmc_card *card,
 		unsigned int timeout_clks = card->csd.tacc_clks * mult;
 		unsigned int timeout_us;
 
-		/* Avoid overflow: e.g. tacc_ns=80000000 mult=1280 */
-		if (card->csd.tacc_ns < 1000000)
-			timeout_us = (card->csd.tacc_ns * mult) / 1000;
-		else
+		/*
+		 * Avoid over flow for some crappy cards.
+		 * e.g. tacc_ns=80000000 mult=1280
+		 */
+		if ((UINT_MAX / mult) < card->csd.tacc_ns)
 			timeout_us = (card->csd.tacc_ns / 1000) * mult;
+		else
+			timeout_us = (card->csd.tacc_ns * mult) / 1000;
 
 		/*
 		 * ios.clock is only a target.  The real clock rate might be
@@ -1806,16 +1821,18 @@ unsigned int mmc_calc_max_discard(struct mmc_card *card)
 	struct mmc_host *host = card->host;
 	unsigned int max_discard, max_trim;
 
-	if (!host->max_discard_to)
-		return UINT_MAX;
+	if (!host->max_discard_to) {
 
-	/*
-	 * Without erase_group_def set, MMC erase timeout depends on clock
-	 * frequence which can change.  In that case, the best choice is
-	 * just the preferred erase size.
-	 */
-	if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))
-		return card->pref_erase;
+		/*
+		 * Without erase_group_def set, MMC erase timeout depends
+		 * on clock frequence which can change.  In that case, the
+		 * best choice is just the preferred erase size.
+		 */
+		if (mmc_card_mmc(card) && !(card->ext_csd.erase_group_def & 1))
+			return card->pref_erase;
+		else
+			return UINT_MAX;
+	}
 
 	max_discard = mmc_do_calc_max_discard(card, MMC_ERASE_ARG);
 	if (mmc_can_trim(card)) {
diff --git a/drivers/mmc/host/sdhci-esdhc.h b/drivers/mmc/host/sdhci-esdhc.h
index e5c747f..b87feb6 100644
--- a/drivers/mmc/host/sdhci-esdhc.h
+++ b/drivers/mmc/host/sdhci-esdhc.h
@@ -49,6 +49,8 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 	int pre_div = 2;
 	int div = 1;
 	u32 temp;
+	u32 actual_clk;
+
 #ifdef CONFIG_MMC_SDHCI_ESDHC_IMX
 	struct esdhc_platform_data *boarddata;
 
@@ -72,6 +74,7 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 	dev_dbg(mmc_dev(host->mmc), "desired SD clock: %d, actual: %d\n",
 		clock, host->max_clk / pre_div / div);
 
+	actual_clk = host->max_clk / pre_div / div;
 	pre_div >>= 1;
 	div--;
 
@@ -82,6 +85,11 @@ static inline void esdhc_set_clock(struct sdhci_host *host, unsigned int clock)
 	sdhci_writel(host, temp, ESDHC_SYSTEM_CONTROL);
 	mdelay(1);
 
+	if (host->quirks & SDHCI_QUIRK_DATA_TIMEOUT_USES_SDCLK) {
+		host->timeout_clk = actual_clk / 1000;
+		host->mmc->max_discard_to = (1 << 27) / host->timeout_clk;
+	}
+
 #ifdef CONFIG_MMC_SDHCI_ESDHC_IMX
 	/* if there's board callback function
 	 * for pad setting change, that means
-- 
1.7.5.4

