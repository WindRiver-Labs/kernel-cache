From 22265e9bd6ae725deb23659e08e3820cd221c5b2 Mon Sep 17 00:00:00 2001
From: Andrei Varvara <andrei.varvara@freescale.com>
Date: Tue, 14 May 2013 15:20:03 +0300
Subject: [PATCH 111/430] dpa_offload: verify if inbound policy verification
 is enabled

Check if inbound policy verification is enabled prior to adding, removing,
getting, flushing policies

This patch is related to CR ENGR00258699

Signed-off-by: Andrei Varvara <andrei.varvara@freescale.com>
Change-Id: I58e0ada0369eb224492d7d43bd1f4a15f33b7c81
Reviewed-on: http://git.am.freescale.net:8181/2579
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Floarea Anca Jeanina-B12569 <anca.floarea@freescale.com>
Reviewed-by: Chereji Marian-Cornel-R27762 <marian.chereji@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
[original patch is from QorIQ-SDK-V1.4-20130625-yocto]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 drivers/staging/fsl_dpa_offload/dpa_ipsec.c |   32 +++++++++++++++++++++++++++
 1 files changed, 32 insertions(+), 0 deletions(-)

diff --git a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
index 3942323..902a0fa 100644
--- a/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
+++ b/drivers/staging/fsl_dpa_offload/dpa_ipsec.c
@@ -3880,6 +3880,17 @@ int dpa_ipsec_sa_add_policy(int sa_id,
 		return -EBUSY;
 	}
 
+	BUG_ON(!sa->dpa_ipsec);
+	mutex_lock(&sa->dpa_ipsec->lock);
+	if (sa_is_inbound(sa) &&
+	    !sa->dpa_ipsec->config.post_sec_in_params.do_pol_check) {
+		pr_err("Inbound policy verification is disabled.\n");
+		mutex_unlock(&sa->dpa_ipsec->lock);
+		mutex_unlock(&sa->lock);
+		return -EPERM;
+	}
+	mutex_unlock(&sa->dpa_ipsec->lock);
+
 	ret = check_policy_params(sa, policy_params);
 	if (ret < 0) {
 		mutex_unlock(&sa->lock);
@@ -3958,6 +3969,13 @@ int dpa_ipsec_sa_remove_policy(int sa_id,
 		return -EBUSY;
 	}
 
+	if (sa_is_inbound(sa) &&
+	    !sa->dpa_ipsec->config.post_sec_in_params.do_pol_check) {
+		pr_err("Inbound policy verification is disabled.\n");
+		mutex_unlock(&sa->lock);
+		return -EPERM;
+	}
+
 	if (sa_is_parent(sa) && sa_is_outbound(sa)) {
 		pr_err("Illegal removing out policy parent SA %d\n", sa->id);
 		mutex_unlock(&sa->lock);
@@ -4678,6 +4696,13 @@ int dpa_ipsec_sa_get_policies(int sa_id,
 		return -EBUSY;
 	}
 
+	if (sa_is_inbound(sa) &&
+	    !sa->dpa_ipsec->config.post_sec_in_params.do_pol_check) {
+		pr_err("Inbound policy verification is disabled.\n");
+		mutex_unlock(&sa->lock);
+		return -EPERM;
+	}
+
 	if (!policy_params) {
 		/* get the number of policies for SA with id sa_id */
 		*num_pol = get_policy_count_for_sa(sa);
@@ -4733,6 +4758,13 @@ int dpa_ipsec_sa_flush_policies(int sa_id)
 		return -EBUSY;
 	}
 
+	if (sa_is_inbound(sa) &&
+	    !sa->dpa_ipsec->config.post_sec_in_params.do_pol_check) {
+		pr_err("Inbound policy verification is disabled.\n");
+		mutex_unlock(&sa->lock);
+		return -EPERM;
+	}
+
 	ret = sa_flush_policies(sa);
 
 	mutex_unlock(&sa->lock);
-- 
1.7.5.4

