From e732cae7f2a10c1a4e58e044b86ff13fdeca0c0b Mon Sep 17 00:00:00 2001
From: Tiejun Chen <tiejun.chen@windriver.com>
Date: Fri, 20 Jul 2012 18:10:32 +0800
Subject: [PATCH] Q/BMAN: set IRQF_NOBALANCING for the portal irq handler

The Q/BMAN portal is bound to a specific cpu. It make no sense
to migrate the portal irq to orther cpu when a cpu is down. And the
portal irq handler also doesn't support reentry. That mean we can't
handle two portal irq on a single cpu. So set the portal irq with
IQF_NOBALANCING flag to avoid irq migration or setting affinity
by userspace.

But after we set IRQF_NOBALANCING when call request_irq() firstly,

request_irq() -> request_threaded_irq() -> __setup_irq()

{
...
        /* Exclude IRQ from balancing if requested */
        if (new->flags & IRQF_NOBALANCING) {
            irq_settings_set_no_balancing(desc);
            irqd_set(&desc->irq_data, IRQD_NO_BALANCING);
        }
...
}

and current kernel will call irq_can_set_affinity() to check if
one given irq can be set affinity:

int irq_can_set_affinity(unsigned int irq)
{
    struct irq_desc *desc = irq_to_desc(irq);

    if (!desc || !irqd_can_balance(&desc->irq_data) ||
        !desc->irq_data.chip || !desc->irq_data.chip->irq_set_affinity)
        return 0;

    return 1;
}

So if this irq can't be balanced we can't do this properly. Here we have
to check/set irq affinity at first then disable irq blance from request_irq.

Signed-off-by: Kevin Hao <kexin.hao@windriver.com>
Signed-off-by: Tiejun Chen <tiejun.chen@windriver.com>
---
 drivers/staging/fsl_qbman/bman_high.c |   10 +++++-----
 drivers/staging/fsl_qbman/qman_high.c |   10 +++++-----
 2 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/drivers/staging/fsl_qbman/bman_high.c b/drivers/staging/fsl_qbman/bman_high.c
index 042b431..453d88c 100644
--- a/drivers/staging/fsl_qbman/bman_high.c
+++ b/drivers/staging/fsl_qbman/bman_high.c
@@ -246,11 +246,6 @@ struct bman_portal *bman_create_affine_portal(
 	bm_isr_status_clear(__p, 0xffffffff);
 #ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->public_cfg.cpu);
-	if (request_irq(config->public_cfg.irq, portal_isr, 0, portal->irqname,
-			portal)) {
-		pr_err("request_irq() failed\n");
-		goto fail_irq;
-	}
 	if ((config->public_cfg.cpu != -1) &&
 			irq_can_set_affinity(config->public_cfg.irq) &&
 			irq_set_affinity(config->public_cfg.irq,
@@ -258,6 +253,11 @@ struct bman_portal *bman_create_affine_portal(
 		pr_err("irq_set_affinity() failed\n");
 		goto fail_affinity;
 	}
+	if (request_irq(config->public_cfg.irq, portal_isr, IRQF_NOBALANCING, portal->irqname,
+			portal)) {
+		pr_err("request_irq() failed\n");
+		goto fail_irq;
+	}
 	/* Enable the bits that make sense */
 	if (!recovery_mode)
 		bm_isr_uninhibit(__p);
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index bf770e2..d0ecd5e 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -493,11 +493,6 @@ drain_loop:
 	qm_isr_status_clear(__p, 0xffffffff);
 #ifdef CONFIG_FSL_DPA_HAVE_IRQ
 	snprintf(portal->irqname, MAX_IRQNAME, IRQNAME, config->public_cfg.cpu);
-	if (request_irq(config->public_cfg.irq, portal_isr, 0, portal->irqname,
-				portal)) {
-		pr_err("request_irq() failed\n");
-		goto fail_irq;
-	}
 	if ((config->public_cfg.cpu != -1) &&
 			irq_can_set_affinity(config->public_cfg.irq) &&
 			irq_set_affinity(config->public_cfg.irq,
@@ -505,6 +500,11 @@ drain_loop:
 		pr_err("irq_set_affinity() failed\n");
 		goto fail_affinity;
 	}
+	if (request_irq(config->public_cfg.irq, portal_isr, IRQF_NOBALANCING, portal->irqname,
+				portal)) {
+		pr_err("request_irq() failed\n");
+		goto fail_irq;
+	}
 	if (recovery_mode) {
 		qm_isr_inhibit(__p);
 	} else {
-- 
1.7.9.7

