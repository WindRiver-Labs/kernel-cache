From 0f2e00aa5c7fe110a4c89609f4ca5176d82a6c0d Mon Sep 17 00:00:00 2001
From: Wei Yang <Wei.Yang@windriver.com>
Date: Wed, 13 Mar 2013 15:52:51 +0800
Subject: [PATCH 02/21] powerpc/p1021mds: set/release muxed QE12 pin for UEC MII and LBCTL

P1021 has QE_MDIO pin muxed with LBCTL pin, which is controlled by
PMUXCR[QE12]. For accessing mdio by probing mdio bus and read/write phy
registers, QE12 needs to be set together with QE9 to enable both
QE_MDIO and QE_MDC. However, after accessing mdio, QE12 needs to be
released so that eLBC can be accessed properly.

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
[Extracted from the P1021MDS-20101124-ltib.iso vendor drop.
Fixed context to apply to Wind River kernel tree.]
Signed-off-by: Wei Yang <Wei.Yang@windriver.com>
---
 arch/powerpc/platforms/85xx/Kconfig          |    9 +++++
 arch/powerpc/platforms/85xx/mpc85xx_mds.c    |    8 +---
 arch/powerpc/sysdev/fsl_soc.c                |   48 ++++++++++++++++++++++++++
 arch/powerpc/sysdev/fsl_soc.h                |    4 ++
 drivers/net/ethernet/freescale/fsl_pq_mdio.c |   28 +++++++++++++++
 drivers/net/ethernet/freescale/ucc_geth.c    |   11 ++++++
 6 files changed, 102 insertions(+), 6 deletions(-)

diff --git a/arch/powerpc/platforms/85xx/Kconfig b/arch/powerpc/platforms/85xx/Kconfig
index 94e35a4..d721b1f 100644
--- a/arch/powerpc/platforms/85xx/Kconfig
+++ b/arch/powerpc/platforms/85xx/Kconfig
@@ -64,6 +64,15 @@ config MPC85xx_MDS
 	help
 	  This option enables support for the MPC85xx MDS board
 
+config P1021_MDIO_MUX
+	bool "Set and clear MII pins for P1021"
+	depends on QUICC_ENGINE
+	depends on PPC_85xx
+	help
+	   P1021 has pins muxed for QE_MDIO and LBCTL, thus QE12 in PMUXCR needs
+	   to be set and released for accessing MIIM and eLBC.
+	default n
+
 config MPC8536_DS
 	bool "Freescale MPC8536 DS"
 	select DEFAULT_UIMAGE
diff --git a/arch/powerpc/platforms/85xx/mpc85xx_mds.c b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
index 4cc839f..fba4091 100644
--- a/arch/powerpc/platforms/85xx/mpc85xx_mds.c
+++ b/arch/powerpc/platforms/85xx/mpc85xx_mds.c
@@ -280,14 +280,10 @@ static void __init mpc85xx_mds_qe_init(void)
 			else{
 			/* P1021 has pins muxed for QE and other functions. To
 			 * enable QE UEC mode, we need to set bit QE0 for UCC1
-			 * in Eth mode, QE0 and QE3 for UCC5 in Eth mode, QE9
-			 * and QE12 for QE MII management signals in PMUXCR
-			 * register.
+			 * in Eth mode, QE0 and QE3 for UCC5 in Eth mode.
 			 */
 				setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(0) |
-						  MPC85xx_PMUXCR_QE(3) |
-						  MPC85xx_PMUXCR_QE(9) |
-						  MPC85xx_PMUXCR_QE(12));
+						  MPC85xx_PMUXCR_QE(3));
 				iounmap(guts);
 			}
 			of_node_put(np);
diff --git a/arch/powerpc/sysdev/fsl_soc.c b/arch/powerpc/sysdev/fsl_soc.c
index c449dbd..41a3feb 100644
--- a/arch/powerpc/sysdev/fsl_soc.c
+++ b/arch/powerpc/sysdev/fsl_soc.c
@@ -41,6 +41,7 @@
 #include <mm/mmu_decl.h>
 #include <asm/cpm2.h>
 #include <asm/fsl_hcalls.h>	/* For the Freescale hypervisor */
+#include <asm/fsl_guts.h>
 
 extern void init_fcc_ioports(struct fs_platform_info*);
 extern void init_fec_ioports(struct fs_platform_info*);
@@ -278,3 +279,50 @@ void fsl_hv_halt(void)
 	pr_info("hv exit\n");
 	fh_partition_stop(-1);
 }
+
+#ifdef CONFIG_P1021_MDIO_MUX
+/*
+ * P1021 has pins muxed for QE and other functions.
+ * Set QE9 and QE12 bit in PMUXCR register to enable QE_MDC and QE_MDIO, clear
+ * QE12 to release the QE_MDIO for LBCTL to allow the eLBC data buffer control.
+ * Please note the potential risk may occur if both QE_MDIO and LBCTL needs to
+ * be active simutaneously.
+ */
+void p1021_pmuxcr_mdio_mux(void)
+{
+	struct device_node *np;
+	struct ccsr_guts __iomem *guts;
+	
+	np = of_find_node_by_name(NULL, "global-utilities");
+	if (np) {
+		guts = of_iomap(np, 0);
+		if (!guts)
+			pr_err("mpc85xx-mds: could not map global utilities register\n");
+		else
+			setbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(9) |
+					  MPC85xx_PMUXCR_QE(12));
+		iounmap(guts);
+		of_node_put(np);
+	}
+}
+EXPORT_SYMBOL(p1021_pmuxcr_mdio_mux);
+
+void p1021_pmuxcr_lbctl_mux(void)
+{
+	struct device_node *np;
+	struct ccsr_guts __iomem *guts;
+	
+	np = of_find_node_by_name(NULL, "global-utilities");
+	if (np) {
+		guts = of_iomap(np, 0);
+		if (!guts)
+			pr_err("mpc85xx-mds: could not map global utilities register\n");
+		else
+			clrbits32(&guts->pmuxcr, MPC85xx_PMUXCR_QE(12));
+		iounmap(guts);
+		of_node_put(np);
+	}
+}
+EXPORT_SYMBOL(p1021_pmuxcr_lbctl_mux);
+#endif /* CONFIG_P1021_MDIO_MUX */
+
diff --git a/arch/powerpc/sysdev/fsl_soc.h b/arch/powerpc/sysdev/fsl_soc.h
index b7d5ef7..3b5b525 100644
--- a/arch/powerpc/sysdev/fsl_soc.h
+++ b/arch/powerpc/sysdev/fsl_soc.h
@@ -67,5 +67,9 @@ static inline void mpc85xx_enter_jog(u64 ccsrbar, u32 powmgtreq)
 {
 	mpc85xx_enter_deep_sleep(ccsrbar, powmgtreq);
 }
+#ifdef CONFIG_P1021_MDIO_MUX
+extern void p1021_pmuxcr_mdio_mux(void);
+extern void p1021_pmuxcr_lbctl_mux(void);
+#endif /* CONFIG_P1021_MDIO_MUX */
 #endif
 #endif
diff --git a/drivers/net/ethernet/freescale/fsl_pq_mdio.c b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
index fcd420a..73ec7d8 100644
--- a/drivers/net/ethernet/freescale/fsl_pq_mdio.c
+++ b/drivers/net/ethernet/freescale/fsl_pq_mdio.c
@@ -16,6 +16,7 @@
  *
  */
 
+#include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/string.h>
 #include <linux/errno.h>
@@ -43,6 +44,9 @@
 #include <asm/irq.h>
 #include <asm/uaccess.h>
 #include <asm/ucc.h>
+#ifdef CONFIG_P1021_MDIO_MUX
+#include <sysdev/fsl_soc.h>
+#endif
 
 #include "gianfar.h"
 #include "fsl_pq_mdio.h"
@@ -69,6 +73,9 @@ struct mii_bus *fsl_pq_mdio_bus;
 int fsl_pq_local_mdio_write(struct fsl_pq_mdio __iomem *regs, int mii_id,
 			int regnum, u16 value)
 {
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	/* Set the PHY address and the register address we want to write */
 	out_be32(&regs->miimadd, (mii_id << 8) | regnum);
 
@@ -79,6 +86,9 @@ int fsl_pq_local_mdio_write(struct fsl_pq_mdio __iomem *regs, int mii_id,
 	while (in_be32(&regs->miimind) & MIIMIND_BUSY)
 		cpu_relax();
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 	return 0;
 }
 
@@ -97,6 +107,9 @@ int fsl_pq_local_mdio_read(struct fsl_pq_mdio __iomem *regs, int mii_id,
 {
 	u16 value;
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	/* Set the PHY address and the register address we want to read */
 	out_be32(&regs->miimadd, (mii_id << 8) | regnum);
 
@@ -110,6 +123,9 @@ int fsl_pq_local_mdio_read(struct fsl_pq_mdio __iomem *regs, int mii_id,
 
 	/* Grab the value of the register from miimstat */
 	value = in_be32(&regs->miimstat);
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 
 	return value;
 }
@@ -188,6 +204,9 @@ static int fsl_pq_mdio_reset(struct mii_bus *bus)
 
 	mutex_lock(&bus->mdio_lock);
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	/* Reset the management interface */
 	out_be32(&regs->miimcfg, MIIMCFG_RESET);
 
@@ -198,6 +217,9 @@ static int fsl_pq_mdio_reset(struct mii_bus *bus)
 	while ((in_be32(&regs->miimind) & MIIMIND_BUSY) && timeout--)
 		cpu_relax();
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 	mutex_unlock(&bus->mdio_lock);
 
 	if (timeout < 0) {
@@ -415,7 +437,13 @@ static int fsl_pq_mdio_probe(struct platform_device *ofdev)
 
 	fsl_pq_mdio_bus = new_bus;
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	err = of_mdiobus_register(new_bus, np);
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 	if (err) {
 		printk (KERN_ERR "%s: Cannot register as MDIO bus\n",
 				new_bus->name);
diff --git a/drivers/net/ethernet/freescale/ucc_geth.c b/drivers/net/ethernet/freescale/ucc_geth.c
index 9ac14f8..5799269 100644
--- a/drivers/net/ethernet/freescale/ucc_geth.c
+++ b/drivers/net/ethernet/freescale/ucc_geth.c
@@ -44,6 +44,10 @@
 #include "ucc_geth.h"
 #include "fsl_pq_mdio.h"
 
+#ifdef CONFIG_P1021_MDIO_MUX
+#include <sysdev/fsl_soc.h>
+#endif
+
 #undef DEBUG
 
 #define ugeth_printk(level, format, arg...)  \
@@ -3563,7 +3567,14 @@ static int ucc_geth_open(struct net_device *dev)
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_mdio_mux();
+#endif
 	err = init_phy(dev);
+
+#ifdef CONFIG_P1021_MDIO_MUX
+	p1021_pmuxcr_lbctl_mux();
+#endif
 	if (err) {
 		if (netif_msg_ifup(ugeth))
 			ugeth_err("%s: Cannot initialize PHY, aborting.",
-- 
1.7.0

