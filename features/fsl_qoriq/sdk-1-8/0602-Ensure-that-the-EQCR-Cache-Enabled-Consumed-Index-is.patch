From 872704a3ad8c38d316e74f762b5d51fdb54fe022 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Wed, 19 Mar 2014 15:26:10 -0400
Subject: [PATCH 602/987] Ensure that the EQCR Cache Enabled Consumed Index is
 reset

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

The QMan block keeps an internal copy of the CI index when
stashing is enabled.  In order to synchronize this internal
copy with the external view the stash threshold must be set
to 1 then 0 otherwise the state of the portal can be bad when
it is reallocated by a different process

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: I1b4c0c7f385abb94ae3ff5e988179f0d328e3455
Reviewed-on: http://git.am.freescale.net:8181/9942
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Haiying Wang <Haiying.Wang@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/qman_low.h | 25 +++++++++++++++++++++++--
 1 file changed, 23 insertions(+), 2 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_low.h b/drivers/staging/fsl_qbman/qman_low.h
index 3f93b95..34562ca 100644
--- a/drivers/staging/fsl_qbman/qman_low.h
+++ b/drivers/staging/fsl_qbman/qman_low.h
@@ -318,8 +318,29 @@ static inline unsigned int qm_eqcr_get_ci_stashing(struct qm_portal *portal)
 static inline void qm_eqcr_finish(struct qm_portal *portal)
 {
 	register struct qm_eqcr *eqcr = &portal->eqcr;
-	u8 pi = qm_in(EQCR_PI_CINH) & (QM_EQCR_SIZE - 1);
-	u8 ci = qm_in(EQCR_CI_CINH) & (QM_EQCR_SIZE - 1);
+	u8 pi, ci;
+	u32 cfg;
+
+	/*
+	 * Disable EQCI stashing because the QMan only
+	 * presents the value it previously stashed to
+	 * maintain coherency.  Setting the stash threshold
+	 * to 1 then 0 ensures that QMan has resyncronized
+	 * its internal copy so that the portal is clean
+	 * when it is reinitialized in the future
+	 */
+	cfg = (qm_in(CFG) & 0x0fffffff) |
+		(1 << 28); /* QCSP_CFG: EST */
+	qm_out(CFG, cfg);
+	cfg &= 0x0fffffff; /* stash threshold = 0 */
+	qm_out(CFG, cfg);
+
+	pi = qm_in(EQCR_PI_CINH) & (QM_EQCR_SIZE - 1);
+	ci = qm_in(EQCR_CI_CINH) & (QM_EQCR_SIZE - 1);
+
+	/* Refresh EQCR CI cache value */
+	qm_cl_invalidate(EQCR_CI);
+	eqcr->ci = qm_cl_in(EQCR_CI) & (QM_EQCR_SIZE - 1);
 
 	DPA_ASSERT(!eqcr->busy);
 	if (pi != EQCR_PTR2IDX(eqcr->cursor))
-- 
1.9.1

