From 76688fca88fc0b6fa47f031f88987b604dde2954 Mon Sep 17 00:00:00 2001
From: Chenhui Zhao <chenhui.zhao@freescale.com>
Date: Tue, 27 Aug 2013 17:50:47 +0800
Subject: [PATCH 1159/1207] drivers/fsl: add EPU FSM configuration for deep
 sleep

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

In the last stage of deep sleep, software will trigger a Finite
State Machine (FSM) to control the hardware precedure, such as
board isolation, killing PLLs, removing power, and so on.

When the system is waked up by an interrupt, the FSM controls the
hardware to complete the early resume precedure.

This patch configure the EPU FSM preparing for deep sleep.

Change-Id: I42b196a656324260c1d1cfcf688016c6f8d7ebe8
Signed-off-by: Hongbo Zhang <hongbo.zhang@freescale.com>
Signed-off-by: Chenhui Zhao <chenhui.zhao@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/10708
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Yang Li <LeoLi@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/platform/Kconfig         |   2 +
 drivers/platform/Makefile        |   1 +
 drivers/platform/fsl/Kconfig     |  10 ++
 drivers/platform/fsl/Makefile    |   5 +
 drivers/platform/fsl/sleep_fsm.c | 342 +++++++++++++++++++++++++++++++++++++++
 5 files changed, 360 insertions(+)
 create mode 100644 drivers/platform/fsl/Kconfig
 create mode 100644 drivers/platform/fsl/Makefile
 create mode 100644 drivers/platform/fsl/sleep_fsm.c

diff --git a/drivers/platform/Kconfig b/drivers/platform/Kconfig
index 0adccbf..c5b1e8d 100644
--- a/drivers/platform/Kconfig
+++ b/drivers/platform/Kconfig
@@ -9,3 +9,5 @@ source "drivers/platform/goldfish/Kconfig"
 endif
 
 source "drivers/platform/chrome/Kconfig"
+
+source "drivers/platform/fsl/Kconfig"
diff --git a/drivers/platform/Makefile b/drivers/platform/Makefile
index ca26925..cece46b 100644
--- a/drivers/platform/Makefile
+++ b/drivers/platform/Makefile
@@ -7,3 +7,4 @@ obj-$(CONFIG_MIPS)		+= mips/
 obj-$(CONFIG_OLPC)		+= olpc/
 obj-$(CONFIG_GOLDFISH)		+= goldfish/
 obj-$(CONFIG_CHROME_PLATFORMS)	+= chrome/
+obj-$(CONFIG_FSL_SOC)		+= fsl/
diff --git a/drivers/platform/fsl/Kconfig b/drivers/platform/fsl/Kconfig
new file mode 100644
index 0000000..72ed053
--- /dev/null
+++ b/drivers/platform/fsl/Kconfig
@@ -0,0 +1,10 @@
+#
+# Freescale Specific Power Management Drivers
+#
+
+config FSL_SLEEP_FSM
+	bool
+	help
+	  This driver configures a hardware FSM (Finite State Machine) for deep sleep.
+	  The FSM is used to finish clean-ups at the last stage of system entering deep
+	  sleep, and also wakes up system when a wake up event happens.
diff --git a/drivers/platform/fsl/Makefile b/drivers/platform/fsl/Makefile
new file mode 100644
index 0000000..d99ca0e
--- /dev/null
+++ b/drivers/platform/fsl/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for linux/drivers/platform/fsl
+# Freescale Specific Power Management Drivers
+#
+obj-$(CONFIG_FSL_SLEEP_FSM)	+= sleep_fsm.o
diff --git a/drivers/platform/fsl/sleep_fsm.c b/drivers/platform/fsl/sleep_fsm.c
new file mode 100644
index 0000000..195a09c
--- /dev/null
+++ b/drivers/platform/fsl/sleep_fsm.c
@@ -0,0 +1,342 @@
+/*
+ * Freescale deep sleep FSM (finite-state machine) configuration
+ *
+ * Copyright 2014 Freescale Semiconductor Inc.
+ *
+ * Author: Hongbo Zhang <hongbo.zhang@freescale.com>
+ *         Chenhui Zhao <chenhui.zhao@freescale.com>
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/io.h>
+#include <linux/types.h>
+
+#define FSL_STRIDE_4B	4
+#define FSL_STRIDE_8B	8
+
+/* End flag */
+#define FSM_END_FLAG		0xFFFFFFFFUL
+
+/* EPGCR (Event Processor Global Control Register) */
+#define EPGCR		0x000
+
+/* EPEVTCR0-9 (Event Processor EVT Pin Control Registers) */
+#define EPEVTCR0	0x050
+#define EPEVTCR_STRIDE	FSL_STRIDE_4B
+
+/* EPXTRIGCR (Event Processor Crosstrigger Control Register) */
+#define EPXTRIGCR	0x090
+
+/* EPIMCR0-31 (Event Processor Input Mux Control Registers) */
+#define EPIMCR0		0x100
+#define EPIMCR_STRIDE	FSL_STRIDE_4B
+
+/* EPSMCR0-15 (Event Processor SCU Mux Control Registers) */
+#define EPSMCR0		0x200
+#define EPSMCR_STRIDE	FSL_STRIDE_8B
+
+/* EPECR0-15 (Event Processor Event Control Registers) */
+#define EPECR0		0x300
+#define EPECR_STRIDE	FSL_STRIDE_4B
+
+/* EPACR0-15 (Event Processor Action Control Registers) */
+#define EPACR0		0x400
+#define EPACR_STRIDE	FSL_STRIDE_4B
+
+/* EPCCRi0-15 (Event Processor Counter Control Registers) */
+#define EPCCR0		0x800
+#define EPCCR_STRIDE	FSL_STRIDE_4B
+
+/* EPCMPR0-15 (Event Processor Counter Compare Registers) */
+#define EPCMPR0		0x900
+#define EPCMPR_STRIDE	FSL_STRIDE_4B
+
+/* EPCTR0-31 (Event Processor Counter Register) */
+#define EPCTR0		0xA00
+#define EPCTR_STRIDE	FSL_STRIDE_4B
+
+/* NPC triggered Memory-Mapped Access Registers */
+#define NCR		0x000
+#define MCCR1		0x0CC
+#define MCSR1		0x0D0
+#define MMAR1LO		0x0D4
+#define MMAR1HI		0x0D8
+#define MMDR1		0x0DC
+#define MCSR2		0x0E0
+#define MMAR2LO		0x0E4
+#define MMAR2HI		0x0E8
+#define MMDR2		0x0EC
+#define MCSR3		0x0F0
+#define MMAR3LO		0x0F4
+#define MMAR3HI		0x0F8
+#define MMDR3		0x0FC
+
+/* RCPM Core State Action Control Register 0 */
+#define CSTTACR0	0xB00
+
+/* RCPM Core Group 1 Configuration Register 0 */
+#define CG1CR0		0x31C
+
+/* Block offsets */
+#define RCPM_BLOCK_OFFSET	0x00022000
+#define EPU_BLOCK_OFFSET	0x00000000
+#define NPC_BLOCK_OFFSET	0x00001000
+
+struct fsm_reg_vals {
+	u32 offset;
+	u32 value;
+};
+
+/*
+ * These values are from chip's reference manual. For example,
+ * the values for T1040 can be found in "8.4.3.8 Programming
+ * supporting deep sleep mode" of Chapter 8 "Run Control and
+ * Power Management (RCPM)".
+ * The default value can be applied to T104x.
+ */
+struct fsm_reg_vals fsm_default_val[] = {
+	/* EPGCR (Event Processor Global Control Register) */
+	{EPU_BLOCK_OFFSET + EPGCR, 0},
+	/* EPCTR (Event Processor Counter Register) */
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 0, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 1, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 2, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 3, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 4, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 5, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 6, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 7, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 8, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 9, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 10, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 11, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 12, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 13, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 14, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 15, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 16, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 17, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 18, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 19, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 20, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 21, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 22, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 23, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 24, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 25, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 26, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 27, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 28, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 29, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 30, 0},
+	{EPU_BLOCK_OFFSET + EPCTR0 + EPCTR_STRIDE * 31, 0},
+	/* EPECR (Event Processor Event Control Registers) */
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 0, 0},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 1, 0},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 2, 0xF0004004},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 3, 0x80000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 4, 0x20000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 5, 0x08000004},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 6, 0x80000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 7, 0x80000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 8, 0x60000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 9, 0x08000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 10, 0x42000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 11, 0x90000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 12, 0x80000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 13, 0x08000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 14, 0x02000084},
+	{EPU_BLOCK_OFFSET + EPECR0 + EPECR_STRIDE * 15, 0x00000004},
+	/*
+	 * EPEVTCR (Event Processor EVT Pin Control Registers)
+	 * SCU8 triger EVT2, and SCU11 triger EVT9
+	 */
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 0, 0},
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 1, 0},
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 2, 0x80000001},
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 3, 0},
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 4, 0},
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 5, 0},
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 6, 0},
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 7, 0},
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 8, 0},
+	{EPU_BLOCK_OFFSET + EPEVTCR0 + EPEVTCR_STRIDE * 9, 0xB0000001},
+	/* EPCMPR (Event Processor Counter Compare Registers) */
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 0, 0},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 1, 0},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 2, 0x000000FF},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 3, 0},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 4, 0x000000FF},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 5, 0x00000020},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 6, 0},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 7, 0},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 8, 0x000000FF},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 9, 0x000000FF},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 10, 0x000000FF},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 11, 0x000000FF},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 12, 0x000000FF},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 13, 0},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 14, 0x000000FF},
+	{EPU_BLOCK_OFFSET + EPCMPR0 + EPCMPR_STRIDE * 15, 0x000000FF},
+	/* EPCCR (Event Processor Counter Control Registers) */
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 0, 0},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 1, 0},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 2, 0x92840000},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 3, 0},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 4, 0x92840000},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 5, 0x92840000},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 6, 0},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 7, 0},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 8, 0x92840000},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 9, 0x92840000},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 10, 0x92840000},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 11, 0x92840000},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 12, 0x92840000},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 13, 0},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 14, 0x92840000},
+	{EPU_BLOCK_OFFSET + EPCCR0 + EPCCR_STRIDE * 15, 0x92840000},
+	/* EPSMCR (Event Processor SCU Mux Control Registers) */
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 0, 0},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 1, 0},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 2, 0x6C700000},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 3, 0x2F000000},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 4, 0x002F0000},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 5, 0x00002E00},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 6, 0x7C000000},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 7, 0x30000000},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 8, 0x64300000},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 9, 0x00003000},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 10, 0x65000030},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 11, 0x31740000},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 12, 0x7F000000},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 13, 0x00003100},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 14, 0x00000031},
+	{EPU_BLOCK_OFFSET + EPSMCR0 + EPSMCR_STRIDE * 15, 0x76000000},
+	/* EPACR (Event Processor Action Control Registers) */
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 0, 0},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 1, 0},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 2, 0},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 3, 0x00000080},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 4, 0},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 5, 0x00000040},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 6, 0},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 7, 0},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 8, 0},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 9, 0x0000001C},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 10, 0x00000020},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 11, 0},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 12, 0x00000003},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 13, 0x06000000},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 14, 0x04000000},
+	{EPU_BLOCK_OFFSET + EPACR0 + EPACR_STRIDE * 15, 0x02000000},
+	/* EPIMCR (Event Processor Input Mux Control Registers) */
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 0, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 1, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 2, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 3, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 4, 0x44000000},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 5, 0x40000000},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 6, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 7, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 8, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 9, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 10, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 11, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 12, 0x44000000},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 13, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 14, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 15, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 16, 0x6A000000},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 17, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 18, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 19, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 20, 0x48000000},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 21, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 22, 0x6C000000},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 23, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 24, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 25, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 26, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 27, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 28, 0x76000000},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 29, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 30, 0},
+	{EPU_BLOCK_OFFSET + EPIMCR0 + EPIMCR_STRIDE * 31, 0x76000000},
+	/* EPXTRIGCR (Event Processor Crosstrigger Control Register) */
+	{EPU_BLOCK_OFFSET + EPXTRIGCR, 0x0000FFDF},
+	/* NPC triggered Memory-Mapped Access Registers */
+	{NPC_BLOCK_OFFSET + NCR, 0x80000000},
+	{NPC_BLOCK_OFFSET + MCCR1, 0},
+	{NPC_BLOCK_OFFSET + MCSR1, 0},
+	{NPC_BLOCK_OFFSET + MMAR1LO, 0},
+	{NPC_BLOCK_OFFSET + MMAR1HI, 0},
+	{NPC_BLOCK_OFFSET + MMDR1, 0},
+	{NPC_BLOCK_OFFSET + MCSR2, 0},
+	{NPC_BLOCK_OFFSET + MMAR2LO, 0},
+	{NPC_BLOCK_OFFSET + MMAR2HI, 0},
+	{NPC_BLOCK_OFFSET + MMDR2, 0},
+	{NPC_BLOCK_OFFSET + MCSR3, 0x80000000},
+	{NPC_BLOCK_OFFSET + MMAR3LO, 0x000E2130},
+	{NPC_BLOCK_OFFSET + MMAR3HI, 0x00030000},
+	{NPC_BLOCK_OFFSET + MMDR3, 0x00020000},
+	/* Configure RCPM for detecting Core0’s PH15 state */
+	{RCPM_BLOCK_OFFSET + CSTTACR0, 0x00001001},
+	{RCPM_BLOCK_OFFSET + CG1CR0, 0x00000001},
+	/* end */
+	{FSM_END_FLAG, 0},
+};
+
+/**
+ * fsl_dp_fsm_clean - Clear EPU's FSM
+ * @dcsr_base: the base address of DCSR registers
+ * @val: Pointer to values for FSM registers. If NULL,
+ *       will use the default value.
+ */
+void fsl_dp_fsm_clean(void __iomem *dcsr_base, struct fsm_reg_vals *val)
+{
+	struct fsm_reg_vals *data;
+
+	/* if NULL, use the default values */
+	if (val)
+		data = val;
+	else
+		data = fsm_default_val;
+
+	while (data->offset != FSM_END_FLAG) {
+		out_be32(dcsr_base + data->offset, 0);
+		in_be32(dcsr_base + data->offset);
+		data++;
+	}
+}
+
+/**
+ * fsl_dp_fsm_setup - Configure EPU's FSM
+ * @dcsr_base: the base address of DCSR registers
+ * @val: Pointer to values for FSM registers. If NULL,
+ *       will use the default value.
+ */
+void fsl_dp_fsm_setup(void __iomem *dcsr_base, struct fsm_reg_vals *val)
+{
+	struct fsm_reg_vals *data;
+
+	/* if NULL, use the default values */
+	if (val)
+		data = val;
+	else
+		data = fsm_default_val;
+
+	/* clear all registers */
+	fsl_dp_fsm_clean(dcsr_base, data);
+
+	while (data->offset != FSM_END_FLAG) {
+		if (data->value) {
+			out_be32(dcsr_base + data->offset, data->value);
+			in_be32(dcsr_base + data->offset);
+		}
+		data++;
+	}
+}
-- 
2.0.2

