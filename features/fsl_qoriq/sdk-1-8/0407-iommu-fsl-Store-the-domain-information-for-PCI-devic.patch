From c86e48cc2373452b757c213662611f19bad6bf8a Mon Sep 17 00:00:00 2001
From: "Lu.Jiang" <lu.jiang@windriver.com>
Date: Thu, 11 Sep 2014 16:11:55 +0800
Subject: [PATCH 407/987] iommu/fsl: Store the domain information for PCI
 device in its corresponding device structure.

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Earlier we were using the PCI controller structure to store the
domain information. Move this information to the PCI device.

Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
Change-Id: If8663c37babfab800676ffa79c5bad9c2ba70033
Reviewed-on: http://git.am.freescale.net:8181/5868
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bhushan Bharat-R65777 <Bharat.Bhushan@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
Signed-off-by: Lu.Jiang <lu.jiang@windriver.com>
[Fix context to apply to WRL.]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/iommu/fsl_pamu_domain.c | 34 ++++++++--------------------------
 1 file changed, 8 insertions(+), 26 deletions(-)

diff --git a/drivers/iommu/fsl_pamu_domain.c b/drivers/iommu/fsl_pamu_domain.c
index 13b595b..d79f77f 100644
--- a/drivers/iommu/fsl_pamu_domain.c
+++ b/drivers/iommu/fsl_pamu_domain.c
@@ -681,6 +681,7 @@ static int fsl_pamu_attach_device(struct iommu_domain *domain,
 {
 	struct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);
 	const u32 *liodn;
+	struct device *dma_dev = dev;
 	u32 liodn_cnt;
 	int len, ret = 0;
 #ifdef CONFIG_PCI
@@ -699,17 +700,17 @@ static int fsl_pamu_attach_device(struct iommu_domain *domain,
 		 * so we can get the LIODN programmed by
 		 * u-boot.
 		 */
-		dev = pci_ctl->parent;
+		dma_dev = pci_ctl->parent;
 	}
 #endif
 
-	liodn = of_get_property(dev->of_node, "fsl,liodn", &len);
+	liodn = of_get_property(dma_dev->of_node, "fsl,liodn", &len);
 	if (liodn) {
 		liodn_cnt = len / sizeof(u32);
 		ret = handle_attach_device(dma_domain, dev, liodn, liodn_cnt);
 	} else {
 		pr_debug("missing fsl,liodn property at %s\n",
-			 dev->of_node->full_name);
+		          dma_dev->of_node->full_name);
 		ret = -EINVAL;
 	}
 
@@ -720,6 +721,7 @@ static void fsl_pamu_detach_device(struct iommu_domain *domain,
 				   struct device *dev)
 {
 	struct fsl_dma_domain *dma_domain = to_fsl_dma_domain(domain);
+	struct device *dma_dev = dev;
 	const u32 *prop;
 	int len;
 #ifdef CONFIG_PCI
@@ -738,16 +740,16 @@ static void fsl_pamu_detach_device(struct iommu_domain *domain,
 		 * so we can get the LIODN programmed by
 		 * u-boot.
 		 */
-		dev = pci_ctl->parent;
+		dma_dev = pci_ctl->parent;
 	}
 #endif
 
-	prop = of_get_property(dev->of_node, "fsl,liodn", &len);
+	prop = of_get_property(dma_dev->of_node, "fsl,liodn", &len);
 	if (prop)
 		detach_device(dev, dma_domain);
 	else
 		pr_debug("missing fsl,liodn property at %s\n",
-			 dev->of_node->full_name);
+		          dma_dev->of_node->full_name);
 }
 
 static  int configure_domain_geometry(struct iommu_domain *domain, void *data)
@@ -1202,26 +1204,6 @@ static u32 fsl_pamu_get_windows(struct iommu_domain *domain)
 static struct iommu_domain *fsl_get_dev_domain(struct device *dev)
 {
 	struct device_domain_info *info;
-#ifdef CONFIG_PCI
-	struct pci_controller *pci_ctl;
-	struct pci_dev *pdev;
-
-	/*
-	 * Use PCI controller dev struct for pci devices as current
-	 * LIODN schema assign LIODN to PCI controller not PCI device
-	 * This should get corrected with proper LIODN schema.
-	 */
-	if (dev->bus == &pci_bus_type) {
-		pdev = to_pci_dev(dev);
-		pci_ctl = pci_bus_to_host(pdev->bus);
-		/*
-		 * make dev point to pci controller device
-		 * so we can get the LIODN programmed by
-		 * u-boot.
-		 */
-		dev = pci_ctl->parent;
-	}
-#endif
 
 	info = dev->archdata.iommu_domain;
 	if (info && info->domain)
-- 
1.9.1

