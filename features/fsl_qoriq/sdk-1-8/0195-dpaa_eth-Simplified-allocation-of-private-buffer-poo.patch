From 0c2b648f79b83fbf1462da3b6caabfadb0fc6308 Mon Sep 17 00:00:00 2001
From: Marian Rotariu <marian.rotariu@freescale.com>
Date: Fri, 24 May 2013 13:05:43 +0300
Subject: [PATCH 195/987] dpaa_eth: Simplified allocation of private buffer
 pool

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

With this patch, some unnecessary instructions are removed.
There is no need to know the CPU that executes the allocation
procedure. This will eliminate some of dpa_make_private_pool()
requirements (no need to disable thread migration or preemption).

The CPU whose counters will be updated must now be provided to
dpa_bp_add_8().

Change-Id: I09bc88a69649cd52ad1b0055c00117cff5313eac
Signed-off-by: Marian Rotariu <marian.rotariu@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/2689
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Radulescu Ruxandra Ioana-B05472 <ruxandra.radulescu@freescale.com>
Reviewed-by: Hamciuc Bogdan-BHAMCIU1 <bogdan.hamciuc@freescale.com>
Reviewed-by: Sovaiala Cristian-Constantin-B39531 <Cristian.Sovaiala@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c | 28 ++++++++++++---------------
 1 file changed, 12 insertions(+), 16 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index f58e46f..aaa02b0 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -271,7 +271,10 @@ copy_to_unmapped_area(dma_addr_t phys_start, void *src, size_t buf_size)
 }
 
 #ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
-static void dpa_bp_add_8(const struct dpa_bp *dpa_bp)
+/* Allocate 8 socket buffers.
+ * These buffers are counted for a particular CPU.
+ */
+static void dpa_bp_add_8(const struct dpa_bp *dpa_bp, unsigned int cpu)
 {
 	struct bm_buffer bmb[8];
 	struct sk_buff **skbh;
@@ -280,7 +283,7 @@ static void dpa_bp_add_8(const struct dpa_bp *dpa_bp)
 	struct sk_buff *skb;
 	int *count_ptr;
 
-	count_ptr = per_cpu_ptr(dpa_bp->percpu_count, smp_processor_id());
+	count_ptr = per_cpu_ptr(dpa_bp->percpu_count, cpu);
 
 	for (i = 0; i < 8; i++) {
 		/*
@@ -345,21 +348,10 @@ void dpa_make_private_pool(struct dpa_bp *dpa_bp)
 
 	/* Give each cpu an allotment of "count" buffers */
 	for_each_online_cpu(i) {
-		int *thiscount;
-		int *countptr;
 		int j;
-		thiscount = per_cpu_ptr(dpa_bp->percpu_count,
-				smp_processor_id());
-		countptr = per_cpu_ptr(dpa_bp->percpu_count, i);
 
 		for (j = 0; j < dpa_bp->target_count; j += 8)
-			dpa_bp_add_8(dpa_bp);
-
-		/* Adjust the counts */
-		*countptr = j;
-
-		if (countptr != thiscount)
-			*thiscount = *thiscount - j;
+			dpa_bp_add_8(dpa_bp, i);
 	}
 }
 #endif /* CONFIG_FSL_DPAA_ETH_SG_SUPPORT */
@@ -396,13 +388,17 @@ static void dpaa_eth_refill_bpools(struct dpa_priv_s *priv,
 	int *countptr = percpu_priv->dpa_bp_count;
 	int count = *countptr;
 	const struct dpa_bp *dpa_bp = percpu_priv->dpa_bp;
-
 #ifndef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
+	/* this function is called in softirq context;
+	 * no need to protect smp_processor_id() on RT kernel
+	 */
+	unsigned int cpu = smp_processor_id();
+
 	if (unlikely(count < CONFIG_FSL_DPAA_ETH_REFILL_THRESHOLD)) {
 		int i;
 
 		for (i = count; i < CONFIG_FSL_DPAA_ETH_MAX_BUF_COUNT; i += 8)
-			dpa_bp_add_8(dpa_bp);
+			dpa_bp_add_8(dpa_bp, cpu);
 	}
 #else
 	/* Add pages to the buffer pool */
-- 
1.9.1

