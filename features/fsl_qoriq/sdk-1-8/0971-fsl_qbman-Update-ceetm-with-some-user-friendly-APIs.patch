From 4f341ac0df393134177b6bc6523dc66e335ef18a Mon Sep 17 00:00:00 2001
From: Haiying Wang <Haiying.Wang@freescale.com>
Date: Mon, 27 Apr 2015 13:28:24 -0400
Subject: [PATCH 971/987] fsl_qbman: Update ceetm with some user friendly APIs

Signed-off-by: Haiying Wang <Haiying.Wang@freescale.com>
Change-Id: Iaaf60a7e20a7cd96698fbcb3f98b5918000872e1
Reviewed-on: http://git.am.freescale.net:8181/36225
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Roy Pledge <roy.pledge@freescale.com>
Reviewed-by: Honghua Yin <Hong-Hua.Yin@freescale.com>
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/staging/fsl_qbman/qman_high.c | 315 +++++++++++++++++++++++++++-------
 include/linux/fsl_qman.h              |  86 ++++++++++
 2 files changed, 338 insertions(+), 63 deletions(-)

diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 038286f..0eea177 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -3430,11 +3430,6 @@ int qman_ceetm_lni_enable_shaper(struct qm_ceetm_lni *lni, int coupled,
 {
 	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
 
-	if (lni->shaper_enable) {
-		pr_err("The shaper has already been enabled\n");
-		return -EINVAL;
-	}
-
 	lni->shaper_enable = 1;
 	lni->shaper_couple = coupled;
 	lni->oal = oal;
@@ -3476,6 +3471,12 @@ int qman_ceetm_lni_disable_shaper(struct qm_ceetm_lni *lni)
 }
 EXPORT_SYMBOL(qman_ceetm_lni_disable_shaper);
 
+int qman_ceetm_lni_is_shaper_enabled(struct qm_ceetm_lni *lni)
+{
+	return lni->shaper_enable;
+}
+EXPORT_SYMBOL(qman_ceetm_lni_is_shaper_enabled);
+
 int qman_ceetm_lni_set_commit_rate(struct qm_ceetm_lni *lni,
 				const struct qm_ceetm_rate *token_rate,
 				u16 token_limit)
@@ -3485,34 +3486,52 @@ int qman_ceetm_lni_set_commit_rate(struct qm_ceetm_lni *lni,
 	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
 	int ret;
 
-	if (!lni->shaper_enable) {
-		pr_err("The LNI#%d is unshaped, cannot set CR rate\n",
-						lni->idx);
-		return -EINVAL;
+	lni->cr_token_rate.whole = token_rate->whole;
+	lni->cr_token_rate.fraction = token_rate->fraction;
+	lni->cr_token_bucket_limit = token_limit;
+	if (lni->shaper_enable) {
+		query_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+		query_opts.dcpid = lni->dcp_idx;
+		ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts,
+							&query_result);
+		if (ret) {
+			pr_err("Fail to get current LNI shaper setting\n");
+			return -EINVAL;
+		}
+
+		config_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+		config_opts.dcpid = lni->dcp_idx;
+		config_opts.shaper_config.crtcr = (token_rate->whole << 13) |
+					 (token_rate->fraction);
+		config_opts.shaper_config.crtbl = token_limit;
+		config_opts.shaper_config.cpl = query_result.shaper_query.cpl;
+		config_opts.shaper_config.ertcr =
+					query_result.shaper_query.ertcr;
+		config_opts.shaper_config.ertbl =
+					query_result.shaper_query.ertbl;
+		return	qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+	} else {
+		return 0;
 	}
+}
+EXPORT_SYMBOL(qman_ceetm_lni_set_commit_rate);
 
-	query_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
-	query_opts.dcpid = lni->dcp_idx;
-	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+int qman_ceetm_lni_set_commit_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 bps,
+				       u16 token_limit)
+{
+	struct qm_ceetm_rate token_rate;
+	int ret;
+
+	ret = qman_ceetm_bps2tokenrate(bps, &token_rate, 0);
 	if (ret) {
-		pr_err("Fail to get current LNI shaper setting\n");
+		pr_err("Can not convert bps to token rate\n");
 		return -EINVAL;
 	}
 
-	lni->cr_token_rate.whole = token_rate->whole;
-	lni->cr_token_rate.fraction = token_rate->fraction;
-	lni->cr_token_bucket_limit = token_limit;
-	config_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
-	config_opts.dcpid = lni->dcp_idx;
-	config_opts.shaper_config.crtcr = (token_rate->whole << 13) |
-				 (token_rate->fraction);
-	config_opts.shaper_config.crtbl = token_limit;
-	config_opts.shaper_config.cpl = query_result.shaper_query.cpl;
-	config_opts.shaper_config.ertcr = query_result.shaper_query.ertcr;
-	config_opts.shaper_config.ertbl = query_result.shaper_query.ertbl;
-	return	qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+	return qman_ceetm_lni_set_commit_rate(lni, &token_rate, token_limit);
 }
-EXPORT_SYMBOL(qman_ceetm_lni_set_commit_rate);
+EXPORT_SYMBOL(qman_ceetm_lni_set_commit_rate_bps);
 
 int qman_ceetm_lni_get_commit_rate(struct qm_ceetm_lni *lni,
 				struct qm_ceetm_rate *token_rate,
@@ -3537,6 +3556,22 @@ int qman_ceetm_lni_get_commit_rate(struct qm_ceetm_lni *lni,
 }
 EXPORT_SYMBOL(qman_ceetm_lni_get_commit_rate);
 
+int qman_ceetm_lni_get_commit_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 *bps, u16 *token_limit)
+{
+	struct qm_ceetm_rate token_rate;
+	int ret;
+
+	ret = qman_ceetm_lni_get_commit_rate(lni, &token_rate, token_limit);
+	if (ret) {
+		pr_err("The LNI CR rate or limit is not available\n");
+		return -EINVAL;
+	}
+
+	return qman_ceetm_tokenrate2bps(&token_rate, bps, 0);
+}
+EXPORT_SYMBOL(qman_ceetm_lni_get_commit_rate_bps);
+
 int qman_ceetm_lni_set_excess_rate(struct qm_ceetm_lni *lni,
 					const struct qm_ceetm_rate *token_rate,
 					u16 token_limit)
@@ -3546,35 +3581,53 @@ int qman_ceetm_lni_set_excess_rate(struct qm_ceetm_lni *lni,
 	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
 	int ret;
 
-	if (!lni->shaper_enable) {
-		pr_err("The LIN#%d is unshaped, cannot set ER rate\n",
-								lni->idx);
-		return -EINVAL;
+	lni->er_token_rate.whole = token_rate->whole;
+	lni->er_token_rate.fraction = token_rate->fraction;
+	lni->er_token_bucket_limit = token_limit;
+	if (lni->shaper_enable) {
+		query_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+		query_opts.dcpid = lni->dcp_idx;
+		ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts,
+							&query_result);
+		if (ret) {
+			pr_err("Fail to get current LNI shaper setting\n");
+			return -EINVAL;
+		}
+
+		config_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
+		config_opts.dcpid = lni->dcp_idx;
+		config_opts.shaper_config.ertcr =
+			 (token_rate->whole << 13) | (token_rate->fraction);
+		config_opts.shaper_config.ertbl = token_limit;
+		config_opts.shaper_config.cpl = query_result.shaper_query.cpl;
+		config_opts.shaper_config.crtcr =
+					query_result.shaper_query.crtcr;
+		config_opts.shaper_config.crtbl =
+					query_result.shaper_query.crtbl;
+
+		return qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+	} else {
+		return 0;
 	}
+}
+EXPORT_SYMBOL(qman_ceetm_lni_set_excess_rate);
 
-	query_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
-	query_opts.dcpid = lni->dcp_idx;
-	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
+int qman_ceetm_lni_set_excess_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 bps,
+				       u16 token_limit)
+{
+	struct qm_ceetm_rate token_rate;
+	int ret;
+
+	ret = qman_ceetm_bps2tokenrate(bps, &token_rate, 0);
 	if (ret) {
-		pr_err("Fail to get current LNI shaper setting\n");
+		pr_err("Can not convert bps to token rate\n");
 		return -EINVAL;
 	}
 
-	lni->er_token_rate.whole = token_rate->whole;
-	lni->er_token_rate.fraction = token_rate->fraction;
-	lni->er_token_bucket_limit = token_limit;
-	config_opts.cid = CEETM_COMMAND_LNI_SHAPER | lni->idx;
-	config_opts.dcpid = lni->dcp_idx;
-	config_opts.shaper_config.ertcr =
-			 (token_rate->whole << 13) | (token_rate->fraction);
-	config_opts.shaper_config.ertbl = token_limit;
-	config_opts.shaper_config.cpl = query_result.shaper_query.cpl;
-	config_opts.shaper_config.crtcr = query_result.shaper_query.crtcr;
-	config_opts.shaper_config.crtbl = query_result.shaper_query.crtbl;
-
-	return qman_ceetm_configure_mapping_shaper_tcfc(&config_opts);
+	return qman_ceetm_lni_set_excess_rate(lni, &token_rate, token_limit);
 }
-EXPORT_SYMBOL(qman_ceetm_lni_set_excess_rate);
+EXPORT_SYMBOL(qman_ceetm_lni_set_excess_rate_bps);
 
 int qman_ceetm_lni_get_excess_rate(struct qm_ceetm_lni *lni,
 					struct qm_ceetm_rate *token_rate,
@@ -3598,6 +3651,22 @@ int qman_ceetm_lni_get_excess_rate(struct qm_ceetm_lni *lni,
 }
 EXPORT_SYMBOL(qman_ceetm_lni_get_excess_rate);
 
+int qman_ceetm_lni_get_excess_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 *bps, u16 *token_limit)
+{
+	struct qm_ceetm_rate token_rate;
+	int ret;
+
+	ret = qman_ceetm_lni_get_excess_rate(lni, &token_rate, token_limit);
+	if (ret) {
+		pr_err("The LNI ER rate or limit is not available\n");
+		return -EINVAL;
+	}
+
+	return qman_ceetm_tokenrate2bps(&token_rate, bps, 0);
+}
+EXPORT_SYMBOL(qman_ceetm_lni_get_excess_rate_bps);
+
 #define QMAN_CEETM_LNITCFCC_CQ_LEVEL_SHIFT(n) ((15 - n) * 4)
 #define QMAN_CEETM_LNITCFCC_ENABLE 0x8
 int qman_ceetm_lni_set_tcfcc(struct qm_ceetm_lni *lni,
@@ -3819,11 +3888,6 @@ int qman_ceetm_channel_disable_shaper(struct qm_ceetm_channel *channel)
 	struct qm_mcc_ceetm_mapping_shaper_tcfc_config config_opts;
 	u8 map;
 
-	if (channel->shaper_enable == 0) {
-		pr_err("This channel shaper has been disabled\n");
-		return -EINVAL;
-	}
-
 	query_opts.cid = CEETM_COMMAND_CHANNEL_MAPPING | channel->idx;
 	query_opts.dcpid = channel->dcp_idx;
 
@@ -3842,6 +3906,25 @@ int qman_ceetm_channel_disable_shaper(struct qm_ceetm_channel *channel)
 }
 EXPORT_SYMBOL(qman_ceetm_channel_disable_shaper);
 
+int qman_ceetm_channel_is_shaper_enabled(struct qm_ceetm_channel *channel)
+{
+	struct qm_mcc_ceetm_mapping_shaper_tcfc_query query_opts;
+	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
+	u8 map;
+
+	query_opts.cid = CEETM_COMMAND_CHANNEL_MAPPING | channel->idx;
+	query_opts.dcpid = channel->dcp_idx;
+
+	if (qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result)) {
+		pr_err("Can't query channel mapping\n");
+		return -EINVAL;
+	}
+
+	map = query_result.channel_mapping_query.map;
+	return (map & QMAN_CEETM_ENABLE_CHANNEL_SHAPER) ? 1 : 0;
+}
+EXPORT_SYMBOL(qman_ceetm_channel_is_shaper_enabled);
+
 int qman_ceetm_channel_set_commit_rate(struct qm_ceetm_channel *channel,
 				const struct qm_ceetm_rate *token_rate,
 				u16 token_limit)
@@ -3851,11 +3934,6 @@ int qman_ceetm_channel_set_commit_rate(struct qm_ceetm_channel *channel,
 	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
 	int ret;
 
-	if (!channel->shaper_enable) {
-		pr_err("This channel is unshaped\n");
-		return -EINVAL;
-	}
-
 	query_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
 	query_opts.dcpid = channel->dcp_idx;
 
@@ -3880,6 +3958,22 @@ int qman_ceetm_channel_set_commit_rate(struct qm_ceetm_channel *channel,
 }
 EXPORT_SYMBOL(qman_ceetm_channel_set_commit_rate);
 
+int qman_ceetm_channel_set_commit_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 bps, u16 token_limit)
+{
+	struct qm_ceetm_rate token_rate;
+	int ret;
+
+	ret = qman_ceetm_bps2tokenrate(bps, &token_rate, 0);
+	if (ret) {
+		pr_err("Can not convert bps to token rate\n");
+		return -EINVAL;
+	}
+	return qman_ceetm_channel_set_commit_rate(channel, &token_rate,
+						  token_limit);
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_commit_rate_bps);
+
 int qman_ceetm_channel_get_commit_rate(struct qm_ceetm_channel *channel,
 				struct qm_ceetm_rate *token_rate,
 				u16 *token_limit)
@@ -3904,6 +3998,23 @@ int qman_ceetm_channel_get_commit_rate(struct qm_ceetm_channel *channel,
 }
 EXPORT_SYMBOL(qman_ceetm_channel_get_commit_rate);
 
+int qman_ceetm_channel_get_commit_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 *bps, u16 *token_limit)
+{
+	struct qm_ceetm_rate token_rate;
+	int ret;
+
+	ret = qman_ceetm_channel_get_commit_rate(channel, &token_rate,
+						 token_limit);
+	if (ret) {
+		pr_err("The channel CR rate or limit is not available\n");
+		return -EINVAL;
+	}
+
+	return qman_ceetm_tokenrate2bps(&token_rate, bps, 0);
+}
+EXPORT_SYMBOL(qman_ceetm_channel_get_commit_rate_bps);
+
 int qman_ceetm_channel_set_excess_rate(struct qm_ceetm_channel *channel,
 					const struct qm_ceetm_rate *token_rate,
 					u16 token_limit)
@@ -3913,11 +4024,6 @@ int qman_ceetm_channel_set_excess_rate(struct qm_ceetm_channel *channel,
 	struct qm_mcr_ceetm_mapping_shaper_tcfc_query query_result;
 	int ret;
 
-	if (!channel->shaper_enable) {
-		pr_err("This channel is unshaped\n");
-		return -EINVAL;
-	}
-
 	query_opts.cid = CEETM_COMMAND_CHANNEL_SHAPER | channel->idx;
 	query_opts.dcpid = channel->dcp_idx;
 	ret = qman_ceetm_query_mapping_shaper_tcfc(&query_opts, &query_result);
@@ -3941,6 +4047,22 @@ int qman_ceetm_channel_set_excess_rate(struct qm_ceetm_channel *channel,
 }
 EXPORT_SYMBOL(qman_ceetm_channel_set_excess_rate);
 
+int qman_ceetm_channel_set_excess_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 bps, u16 token_limit)
+{
+	struct qm_ceetm_rate token_rate;
+	int ret;
+
+	ret = qman_ceetm_bps2tokenrate(bps, &token_rate, 0);
+	if (ret) {
+		pr_err("Can not convert bps to token rate\n");
+		return -EINVAL;
+	}
+	return qman_ceetm_channel_set_excess_rate(channel, &token_rate,
+						  token_limit);
+}
+EXPORT_SYMBOL(qman_ceetm_channel_set_excess_rate_bps);
+
 int qman_ceetm_channel_get_excess_rate(struct qm_ceetm_channel *channel,
 					struct qm_ceetm_rate *token_rate,
 					u16 *token_limit)
@@ -3964,6 +4086,23 @@ int qman_ceetm_channel_get_excess_rate(struct qm_ceetm_channel *channel,
 }
 EXPORT_SYMBOL(qman_ceetm_channel_get_excess_rate);
 
+int qman_ceetm_channel_get_excess_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 *bps, u16 *token_limit)
+{
+	struct qm_ceetm_rate token_rate;
+	int ret;
+
+	ret = qman_ceetm_channel_get_excess_rate(channel, &token_rate,
+						 token_limit);
+	if (ret) {
+		pr_err("The channel ER rate or limit is not available\n");
+		return -EINVAL;
+	}
+
+	return qman_ceetm_tokenrate2bps(&token_rate, bps, 0);
+}
+EXPORT_SYMBOL(qman_ceetm_channel_get_excess_rate_bps);
+
 int qman_ceetm_channel_set_weight(struct qm_ceetm_channel *channel,
 						u16 token_limit)
 {
@@ -4342,6 +4481,7 @@ int qman_ceetm_cq_release(struct qm_ceetm_cq *cq)
 		return -EBUSY;
 	}
 	list_del(&cq->node);
+	qman_ceetm_drain_cq(cq);
 	kfree(cq);
 	return 0;
 }
@@ -4475,6 +4615,38 @@ int qman_ceetm_ratio2wbfs(u32 numerator,
 }
 EXPORT_SYMBOL(qman_ceetm_ratio2wbfs);
 
+int qman_ceetm_set_queue_weight_in_ratio(struct qm_ceetm_cq *cq, u32 ratio)
+{
+	struct qm_ceetm_weight_code weight_code;
+
+	if (qman_ceetm_ratio2wbfs(ratio, 100, &weight_code, 0)) {
+		pr_err("Cannot get wbfs code for cq %x\n", cq->idx);
+		return -EINVAL;
+	}
+	return qman_ceetm_set_queue_weight(cq, &weight_code);
+}
+EXPORT_SYMBOL(qman_ceetm_set_queue_weight_in_ratio);
+
+int qman_ceetm_get_queue_weight_in_ratio(struct qm_ceetm_cq *cq, u32 *ratio)
+{
+	struct qm_ceetm_weight_code weight_code;
+	u32 n, d;
+
+	if (qman_ceetm_get_queue_weight(cq, &weight_code)) {
+		pr_err("Cannot query the weight code for cq%x\n", cq->idx);
+		return -EINVAL;
+	}
+
+	if (qman_ceetm_wbfs2ratio(&weight_code, &n, &d)) {
+		pr_err("Cannot get the ratio with wbfs code\n");
+		return -EINVAL;
+	}
+
+	*ratio = (n * (u32)100) / d;
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_get_queue_weight_in_ratio);
+
 int qman_ceetm_cq_get_dequeue_statistics(struct qm_ceetm_cq *cq, u32 flags,
 					u64 *frame_count, u64 *byte_count)
 {
@@ -4502,6 +4674,23 @@ int qman_ceetm_cq_get_dequeue_statistics(struct qm_ceetm_cq *cq, u32 flags,
 }
 EXPORT_SYMBOL(qman_ceetm_cq_get_dequeue_statistics);
 
+int qman_ceetm_drain_cq(struct qm_ceetm_cq *cq)
+{
+	struct qm_mcr_ceetm_cq_peek_pop_xsfdrread ppxr;
+	int ret;
+
+	do {
+		ret = qman_ceetm_cq_peek_pop_xsfdrread(cq, 1, 0, &ppxr);
+		if (ret) {
+			pr_err("Failed to pop frame from CQ\n");
+			return -EINVAL;
+		}
+	} while (!(ppxr.stat & 0x2));
+
+	return 0;
+}
+EXPORT_SYMBOL(qman_ceetm_drain_cq);
+
 #define CEETM_LFQMT_LFQID_MSB 0xF00000
 #define CEETM_LFQMT_LFQID_LSB 0x000FFF
 int qman_ceetm_lfq_claim(struct qm_ceetm_lfq **lfq,
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 2d48778..1cc316b 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -2718,6 +2718,12 @@ int qman_ceetm_lni_enable_shaper(struct qm_ceetm_lni *lni, int coupled,
 int qman_ceetm_lni_disable_shaper(struct qm_ceetm_lni *lni);
 
 /**
+ * qman_ceetm_lni_is_shaper_enabled - Check LNI shaper status
+ * @lni: the give LNI
+ */
+int qman_ceetm_lni_is_shaper_enabled(struct qm_ceetm_lni *lni);
+
+/**
  * qman_ceetm_lni_set_commit_rate
  * qman_ceetm_lni_get_commit_rate
  * qman_ceetm_lni_set_excess_rate
@@ -2746,6 +2752,33 @@ int qman_ceetm_lni_set_excess_rate(struct qm_ceetm_lni *lni,
 int qman_ceetm_lni_get_excess_rate(struct qm_ceetm_lni *lni,
 				   struct qm_ceetm_rate *token_rate,
 				   u16 *token_limit);
+/**
+ * qman_ceetm_lni_set_commit_rate_bps
+ * qman_ceetm_lni_get_commit_rate_bps
+ * qman_ceetm_lni_set_excess_rate_bps
+ * qman_ceetm_lni_get_excess_rate_bps - Set/get the shaper CR/ER rate
+ * and token limit for the given LNI.
+ * @lni: the given LNI.
+ * @bps: the desired shaping rate in bps for "set" fuction, or the shaping rate
+ * of the LNI queried by "get" function.
+ * @token_limit: the desired token bucket limit for "set" function, or the token
+ * limit of the given LNI queried by "get" function.
+ *
+ * Returns zero for success. The "set" function returns -EINVAL if the given
+ * LNI is unshapped or -EIO if the configure shaper command returns error.
+ * The "get" function returns -EINVAL if the token rate or the token limit is
+ * not set or the query command returns error.
+ */
+int qman_ceetm_lni_set_commit_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 bps,
+				       u16 token_limit);
+int qman_ceetm_lni_get_commit_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 *bps, u16 *token_limit);
+int qman_ceetm_lni_set_excess_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 bps,
+				       u16 token_limit);
+int qman_ceetm_lni_get_excess_rate_bps(struct qm_ceetm_lni *lni,
+				       u64 *bps, u16 *token_limit);
 
 /**
  * qman_ceetm_lni_set_tcfcc
@@ -2824,6 +2857,12 @@ int qman_ceetm_channel_enable_shaper(struct qm_ceetm_channel *channel,
 int qman_ceetm_channel_disable_shaper(struct qm_ceetm_channel *channel);
 
 /**
+ * qman_ceetm_channel_is_shaper_enabled - Check channel shaper status.
+ * @channel: the give channel.
+ */
+int qman_ceetm_channel_is_shaper_enabled(struct qm_ceetm_channel *channel);
+
+/**
  * qman_ceetm_channel_set_commit_rate
  * qman_ceetm_channel_get_commit_rate
  * qman_ceetm_channel_set_excess_rate
@@ -2851,6 +2890,31 @@ int qman_ceetm_channel_set_excess_rate(struct qm_ceetm_channel *channel,
 int qman_ceetm_channel_get_excess_rate(struct qm_ceetm_channel *channel,
 				   struct qm_ceetm_rate *token_rate,
 				   u16 *token_limit);
+/**
+ * qman_ceetm_channel_set_commit_rate_bps
+ * qman_ceetm_channel_get_commit_rate_bps
+ * qman_ceetm_channel_set_excess_rate_bps
+ * qman_ceetm_channel_get_excess_rate_bps - Set/get channel CR/ER shaper
+ * parameters.
+ * @channel: the given channel.
+ * @token_rate: the desired shaper rate in bps for "set" function, or the
+ * shaper rate in bps for "get" function.
+ * @token_limit: the desired token limit for "set" function, or the queried
+ * token limit for "get" function.
+ *
+ * Return zero for success. The "set" function returns -EINVAL if the channel
+ * is unshaped, or -EIO if the configure shapper command returns error. The
+ * "get" function returns -EINVAL if token rate of token limit is not set, or
+ * the query shaper command returns error.
+ */
+int qman_ceetm_channel_set_commit_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 bps, u16 token_limit);
+int qman_ceetm_channel_get_commit_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 *bps, u16 *token_limit);
+int qman_ceetm_channel_set_excess_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 bps, u16 token_limit);
+int qman_ceetm_channel_get_excess_rate_bps(struct qm_ceetm_channel *channel,
+					   u64 *bps, u16 *token_limit);
 
 /**
  * qman_ceetm_channel_set_weight
@@ -3025,6 +3089,21 @@ int qman_ceetm_set_queue_weight(struct qm_ceetm_cq *cq,
 int qman_ceetm_get_queue_weight(struct qm_ceetm_cq *cq,
 				struct qm_ceetm_weight_code *weight_code);
 
+/**
+ * qman_ceetm_set_queue_weight_in_ratio
+ * qman_ceetm_get_queue_weight_in_ratio - Configure/query the weight of a
+ * grouped class queue.
+ * @cq: the given class queue.
+ * @ratio: the weight in ratio. It should be the real ratio number multiplied
+ * by 100 to get rid of fraction.
+ *
+ * Returns zero for success, or -EIO if the configure weight command returns
+ * error for "set" function, or -EINVAL if the query command returns
+ * error for "get" function.
+ */
+int qman_ceetm_set_queue_weight_in_ratio(struct qm_ceetm_cq *cq, u32 ratio);
+int qman_ceetm_get_queue_weight_in_ratio(struct qm_ceetm_cq *cq, u32 *ratio);
+
 /* Weights are encoded using a pseudo-exponential scheme. The weight codes 0,
  * 32, 64, [...] correspond to weights of 1, 2, 4, [...]. The weights
  * corresponding to intermediate weight codes are calculated using linear
@@ -3093,6 +3172,13 @@ int qman_ceetm_ratio2wbfs(u32 numerator,
 int qman_ceetm_cq_get_dequeue_statistics(struct qm_ceetm_cq *cq, u32 flags,
 					u64 *frame_count, u64 *byte_count);
 
+/**
+ * qman_ceetm_drain_cq - drain the CQ till it is empty.
+ * @cq: the give CQ object.
+ * Return 0 for success or -EINVAL for unsuccessful command to empty CQ.
+ */
+int qman_ceetm_drain_cq(struct qm_ceetm_cq *cq);
+
 	/* ---------------------- */
 	/* CEETM :: logical FQIDs */
 	/* ---------------------- */
-- 
1.9.1

