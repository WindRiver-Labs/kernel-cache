From 028eaefa3a0ddaf44a1633669c17a5016aec8b0b Mon Sep 17 00:00:00 2001
From: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
Date: Wed, 27 Feb 2013 02:49:44 +0200
Subject: [PATCH 059/987] dpaa_eth: Simplify access to percpu_priv stats

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Factor out percpu_priv->stats to simplify the code a bit.
So far, this change only affects the private data paths (i.e. not
shared or MAC-less).

Change-Id: I63996b807d27bf68cd155a1eb7015289bc6e202b
Signed-off-by: Bogdan Hamciuc <bogdan.hamciuc@freescale.com>
(cherry picked from commit a8b17bcc074f5e39b6ebfc2ca857a2e541e760ec)
Reviewed-on: http://git.am.freescale.net:8181/1057
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c    | 13 ++++++----
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h    | 10 ++++----
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 30 ++++++++++++------------
 3 files changed, 28 insertions(+), 25 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 92cf91f..6619528 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -1655,7 +1655,7 @@ static int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
 		goto l3_l4_csum_failed;
 	}
 
-	err = dpa_xmit(priv, percpu_priv, queue_mapping, &fd);
+	err = dpa_xmit(priv, &percpu_priv->stats, queue_mapping, &fd);
 
 l3_l4_csum_failed:
 bpools_too_small_error:
@@ -1865,6 +1865,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	struct dpa_priv_s	*priv;
 	struct qm_fd		 fd;
 	struct dpa_percpu_priv_s *percpu_priv;
+	struct net_device_stats *percpu_stats;
 	int queue_mapping;
 	int err;
 
@@ -1876,6 +1877,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 	priv = netdev_priv(net_dev);
 	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
+	percpu_stats = &percpu_priv->stats;
 
 	clear_fd(&fd);
 	queue_mapping = dpa_get_queue_mapping(skb);
@@ -1885,7 +1887,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 		skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
 		if (unlikely(!skb_new)) {
-			percpu_priv->stats.tx_errors++;
+			percpu_stats->tx_errors++;
 			kfree_skb(skb);
 			goto done;
 		}
@@ -1922,13 +1924,13 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		 * it's more efficient to unshare it and then use the new skb */
 		skb = skb_unshare(skb, GFP_ATOMIC);
 		if (unlikely(!skb)) {
-			percpu_priv->stats.tx_errors++;
+			percpu_stats->tx_errors++;
 			goto done;
 		}
 		err = skb_to_contig_fd(priv, percpu_priv, skb, &fd);
 	}
 	if (unlikely(err < 0)) {
-		percpu_priv->stats.tx_errors++;
+		percpu_stats->tx_errors++;
 		goto fd_create_failed;
 	}
 
@@ -1941,7 +1943,8 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		percpu_priv->tx_returned++;
 	}
 
-	if (unlikely(dpa_xmit(priv, percpu_priv, queue_mapping, &fd) < 0))
+	if (unlikely(dpa_xmit(priv, percpu_stats, queue_mapping,
+		&fd) < 0))
 		goto xmit_failed;
 
 	net_dev->trans_start = jiffies;
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 10ccf56..49a5c08 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -499,7 +499,7 @@ static inline void clear_fd(struct qm_fd *fd)
 }
 
 static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
-			struct dpa_percpu_priv_s *percpu, int queue,
+			struct net_device_stats *percpu_stats, int queue,
 			struct qm_fd *fd)
 {
 	int err, i;
@@ -524,13 +524,13 @@ static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
 
 	if (unlikely(err < 0)) {
 		/* TODO differentiate b/w -EBUSY (EQCR full) and other codes? */
-		percpu->stats.tx_errors++;
-		percpu->stats.tx_fifo_errors++;
+		percpu_stats->tx_errors++;
+		percpu_stats->tx_fifo_errors++;
 		return err;
 	}
 
-	percpu->stats.tx_packets++;
-	percpu->stats.tx_bytes += dpa_fd_length(fd);
+	percpu_stats->tx_packets++;
+	percpu_stats->tx_bytes += dpa_fd_length(fd);
 
 	return 0;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 76cb824..cc269a3 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -443,6 +443,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	dma_addr_t addr = qm_fd_addr(fd);
 	u32 fd_status = fd->status;
 	unsigned int skb_len;
+	struct net_device_stats *percpu_stats = &percpu_priv->stats;
 	int use_gro = net_dev->features & NETIF_F_GRO;
 
 	if (unlikely(fd_status & FM_FD_STAT_ERRORS) != 0) {
@@ -450,7 +451,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 			cpu_netdev_warn(net_dev, "FD status = 0x%08x\n",
 					fd_status & FM_FD_STAT_ERRORS);
 
-		percpu_priv->stats.rx_errors++;
+		percpu_stats->rx_errors++;
 		goto _release_frame;
 	}
 
@@ -465,7 +466,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 			if (netif_msg_rx_err(priv) && net_ratelimit())
 				cpu_netdev_err(net_dev,
 						"Could not alloc skb\n");
-			percpu_priv->stats.rx_dropped++;
+			percpu_stats->rx_dropped++;
 			goto _release_frame;
 		}
 	}
@@ -492,13 +493,13 @@ void __hot _dpa_rx(struct net_device *net_dev,
 			 * counters to track this event.
 			 */
 			percpu_priv->l4_hxs_errors++;
-			percpu_priv->stats.rx_dropped++;
+			percpu_stats->rx_dropped++;
 			goto drop_bad_frame;
 		}
 	} else if (fd->format == qm_fd_sg) {
 		if (unlikely(sg_fd_to_skb(priv, fd, skb, &use_gro))) {
 			percpu_priv->l4_hxs_errors++;
-			percpu_priv->stats.rx_dropped++;
+			percpu_stats->rx_dropped++;
 			goto drop_bad_frame;
 		}
 	} else
@@ -510,7 +511,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	/* IP Reassembled frames are allowed to be larger than MTU */
 	if (unlikely(dpa_check_rx_mtu(skb, net_dev->mtu) &&
 		!(fd_status & FM_FD_IPR))) {
-		percpu_priv->stats.rx_dropped++;
+		percpu_stats->rx_dropped++;
 		goto drop_bad_frame;
 	}
 
@@ -521,16 +522,16 @@ void __hot _dpa_rx(struct net_device *net_dev,
 
 		gro_result = napi_gro_receive(&percpu_priv->napi, skb);
 		if (unlikely(gro_result == GRO_DROP)) {
-			percpu_priv->stats.rx_dropped++;
+			percpu_stats->rx_dropped++;
 			goto packet_dropped;
 		}
 	} else if (unlikely(netif_receive_skb(skb) == NET_RX_DROP)) {
-		percpu_priv->stats.rx_dropped++;
+		percpu_stats->rx_dropped++;
 		goto packet_dropped;
 	}
 
-	percpu_priv->stats.rx_packets++;
-	percpu_priv->stats.rx_bytes += skb_len;
+	percpu_stats->rx_packets++;
+	percpu_stats->rx_bytes += skb_len;
 
 packet_dropped:
 	return;
@@ -591,7 +592,6 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 }
 
 static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
-			      struct dpa_percpu_priv_s *percpu_priv,
 			      struct sk_buff *skb, struct qm_fd *fd)
 {
 	struct dpa_bp *dpa_bp = priv->dpa_bp;
@@ -730,7 +730,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 
 	if (skb_is_nonlinear(skb)) {
 		/* Just create a S/G fd based on the skb */
-		err = skb_to_sg_fd(priv, NULL, skb, &fd);
+		err = skb_to_sg_fd(priv, skb, &fd);
 		percpu_priv->tx_frag_skbuffs++;
 	} else {
 		/*
@@ -744,7 +744,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 			skb_new = skb_realloc_headroom(skb, DPA_BP_HEAD);
 			if (unlikely(!skb_new)) {
 				dev_kfree_skb(skb);
-				percpu_priv->stats.tx_errors++;
+				percpu_stats->tx_errors++;
 				return NETDEV_TX_OK;
 			}
 			dev_kfree_skb(skb);
@@ -757,7 +757,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		 */
 		skb = skb_unshare(skb, GFP_ATOMIC);
 		if (unlikely(!skb)) {
-			percpu_priv->stats.tx_errors++;
+			percpu_stats->tx_errors++;
 			return NETDEV_TX_OK;
 		}
 
@@ -765,12 +765,12 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		err = skb_to_contig_fd(priv, skb, &fd);
 	}
 	if (unlikely(err < 0)) {
-		percpu_priv->stats.tx_errors++;
+		percpu_stats->tx_errors++;
 		dev_kfree_skb(skb);
 		return NETDEV_TX_OK;
 	}
 
-	if (unlikely(dpa_xmit(priv, percpu_priv, queue_mapping, &fd) < 0))
+	if (unlikely(dpa_xmit(priv, percpu_stats, queue_mapping, &fd) < 0))
 		goto xmit_failed;
 
 	net_dev->trans_start = jiffies;
-- 
1.9.1

