From 373ef439cfc8503e57331f8834bbbfa5bb9a8366 Mon Sep 17 00:00:00 2001
From: Shengzhou Liu <Shengzhou.Liu@freescale.com>
Date: Tue, 7 May 2013 13:25:02 +0800
Subject: [PATCH 170/987] powerpc/dpaa_eth: some fix for timestamp

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

 - fix issue that 1588 didn't work.
 - use common API dpa_get_timestamp_ns for both CONFIG_FSL_DPAA_1588
   and CONFIG_FSL_DPAA_TS cases.
 - correct timestamp unit for CONFIG_FSL_DPAA_TS case.

Signed-off-by: Shengzhou Liu <Shengzhou.Liu@freescale.com>
Change-Id: Iebdd4935b5ecf4fccca9b5683d8f18fc81b75276
Reviewed-on: http://git.am.freescale.net:8181/2216
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
Tested-by: Fleming Andrew-AFLEMING <AFLEMING@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c    | 52 +++++++++++++-----------
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h    |  5 ++-
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c | 38 ++++++++++-------
 3 files changed, 56 insertions(+), 39 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index b9b034b..518a8b0 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -952,6 +952,10 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 
 	}
 /* on some error paths this might not be necessary: */
+#ifdef CONFIG_FSL_DPAA_1588
+	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_tx_en_ioctl)
+		dpa_ptp_store_txstamp(priv, skb, (void *)skbh);
+#endif
 #ifdef CONFIG_FSL_DPAA_TS
 	if (unlikely(priv->ts_tx_en &&
 			skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
@@ -1096,26 +1100,36 @@ static void dpa_set_rx_mode(struct net_device *net_dev)
 		netdev_err(net_dev, "mac_dev->set_multi() = %d\n", _errno);
 }
 
-#ifdef CONFIG_FSL_DPAA_TS
-int dpa_get_ts(const struct dpa_priv_s *priv, enum port_type rx_tx,
-	struct skb_shared_hwtstamps *shhwtstamps, const void *data)
+#if defined(CONFIG_FSL_DPAA_1588) || defined(CONFIG_FSL_DPAA_TS)
+u64 dpa_get_timestamp_ns(const struct dpa_priv_s *priv, enum port_type rx_tx,
+			const void *data)
 {
 	u64 *ts, ns;
 
-	/* this will be replaced by a new FMD wrapper API */
 	ts = FM_PORT_GetBufferTimeStamp(
-			fm_port_get_handle(priv->mac_dev->port_dev[rx_tx]),
-			(char *)data);
+		fm_port_get_handle(priv->mac_dev->port_dev[rx_tx]), data);
 
-	memset(shhwtstamps, 0, sizeof(*shhwtstamps));
-
-	/* was the timestamping performed? */
 	if (!ts || *ts == 0)
+		return 0;
+
+	/* multiple DPA_PTP_NOMINAL_FREQ_PERIOD_NS for case of non power of 2 */
+	ns = *ts << DPA_PTP_NOMINAL_FREQ_PERIOD_SHIFT;
+
+	return ns;
+}
+#endif
+#ifdef CONFIG_FSL_DPAA_TS
+int dpa_get_ts(const struct dpa_priv_s *priv, enum port_type rx_tx,
+	struct skb_shared_hwtstamps *shhwtstamps, const void *data)
+{
+	u64 ns;
+
+	ns = dpa_get_timestamp_ns(priv, rx_tx, data);
+
+	if (ns == 0)
 		return -EINVAL;
 
-	/* The timestamp unit was found to be 0.4 ns */
-	ns = *ts * 10;
-	do_div(ns, 4);
+	memset(shhwtstamps, 0, sizeof(*shhwtstamps));
 	shhwtstamps->hwtstamp = ns_to_ktime(ns);
 
 	return 0;
@@ -1496,10 +1510,9 @@ void __hot _dpa_rx(struct net_device *net_dev,
 
 	prefetch(skb_shinfo(skb));
 
-/* Shouldn't we store the timestamp after we validate the mtu? */
 #ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
-		dpa_ptp_store_rxstamp(net_dev, skb, fd);
+		dpa_ptp_store_rxstamp(priv, skb, (void *)skbh);
 #endif
 
 	skb->protocol = eth_type_trans(skb, net_dev);
@@ -1625,10 +1638,6 @@ static void __hot _dpa_tx_conf(struct net_device	*net_dev,
 
 	skb = _dpa_cleanup_tx_fd(priv, fd);
 
-#ifdef CONFIG_FSL_DPAA_1588
-	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_tx_en_ioctl)
-		dpa_ptp_store_txstamp(net_dev, skb, fd);
-#endif
 	dev_kfree_skb(skb);
 }
 
@@ -1651,14 +1660,9 @@ static void dpa_set_buffer_layout(struct dpa_priv_s *priv, struct fm_port *port,
 			DPA_RX_PRIV_DATA_SIZE : DPA_TX_PRIV_DATA_SIZE);
 	layout->parse_results = true;
 	layout->hash_results = true;
-#ifdef CONFIG_FSL_DPAA_1588
-	if (priv && priv->tsu && priv->tsu->valid)
-		layout->time_stamp = true;
-#endif
-#ifdef CONFIG_FSL_DPAA_TS
+#if defined(CONFIG_FSL_DPAA_1588) || defined(CONFIG_FSL_DPAA_TS)
 	layout->time_stamp = true;
 #endif
-
 	fm_port_get_buff_layout_ext_params(port, &params);
 	layout->manip_extra_space = params.manip_extra_space;
 	layout->data_align = params.data_align;
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index a6c5dc0..22d6546 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -641,7 +641,10 @@ static inline void _dpa_assign_wq(struct dpa_fq *fq)
 #define dpa_get_queue_mapping(skb) \
 	skb_get_queue_mapping(skb)
 #endif
-
+#if defined(CONFIG_FSL_DPAA_1588) || defined(CONFIG_FSL_DPAA_TS)
+u64 dpa_get_timestamp_ns(const struct dpa_priv_s *priv,
+			enum port_type rx_tx, const void *data);
+#endif
 #ifdef CONFIG_FSL_DPAA_TS
 /* Updates the skb shared hw timestamp from the hardware timestamp */
 int dpa_get_ts(const struct dpa_priv_s *priv, enum port_type rx_tx,
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 8307f77..8369374 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -247,15 +247,19 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 		 * The sgt page is guaranteed to reside in lowmem.
 		 */
 		sgt = phys_to_virt(addr + dpa_fd_offset(fd));
-
+#ifdef CONFIG_FSL_DPAA_1588
+		if (priv->tsu && priv->tsu->valid &&
+				priv->tsu->hwts_tx_en_ioctl)
+			dpa_ptp_store_txstamp(priv, skb, (void *)skbh);
+#endif
 #ifdef CONFIG_FSL_DPAA_TS
-	if (unlikely(priv->ts_tx_en &&
+		if (unlikely(priv->ts_tx_en &&
 			skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
-		struct skb_shared_hwtstamps shhwtstamps;
+			struct skb_shared_hwtstamps shhwtstamps;
 
-		dpa_get_ts(priv, TX, &shhwtstamps, (void *)skbh);
-		skb_tstamp_tx(skb, &shhwtstamps);
-	}
+			dpa_get_ts(priv, TX, &shhwtstamps, (void *)skbh);
+			skb_tstamp_tx(skb, &shhwtstamps);
+		}
 #endif /* CONFIG_FSL_DPAA_TS */
 
 		/* sgt[0] is from lowmem, was dma_map_single()-ed */
@@ -279,9 +283,15 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 		/* Free separately the pages that we allocated on Tx */
 		free_page((unsigned long)phys_to_virt(addr));
 	}
-#ifdef CONFIG_FSL_DPAA_TS
+#if defined(CONFIG_FSL_DPAA_1588) || defined(CONFIG_FSL_DPAA_TS)
 	else {
 		/* get the timestamp for non-SG frames */
+#ifdef CONFIG_FSL_DPAA_1588
+		if (priv->tsu && priv->tsu->valid &&
+						priv->tsu->hwts_tx_en_ioctl)
+			dpa_ptp_store_txstamp(priv, skb, (void *)skbh);
+#endif
+#ifdef CONFIG_FSL_DPAA_TS
 		if (unlikely(priv->ts_tx_en &&
 				skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP)) {
 			struct skb_shared_hwtstamps shhwtstamps;
@@ -289,8 +299,9 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 			dpa_get_ts(priv, TX, &shhwtstamps, (void *)skbh);
 			skb_tstamp_tx(skb, &shhwtstamps);
 		}
+#endif
 	}
-#endif /* CONFIG_FSL_DPAA_TS */
+#endif
 
 	return skb;
 }
@@ -319,7 +330,7 @@ static void __hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	/* do we need the timestamp for bad frames? */
 #ifdef CONFIG_FSL_DPAA_1588
 	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
-		dpa_ptp_store_rxstamp(priv->net_dev, skb, fd);
+		dpa_ptp_store_rxstamp(priv, skb, vaddr);
 #endif
 
 	/* Peek at the parse results for csum validation and headers size */
@@ -383,6 +394,10 @@ static void __hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 	const t_FmPrsResult *parse_results;
 
 	vaddr = phys_to_virt(addr);
+#ifdef CONFIG_FSL_DPAA_1588
+	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
+		dpa_ptp_store_rxstamp(priv, skb, vaddr);
+#endif
 	/*
 	 * In the case of a SG frame, FMan stores the Internal Context
 	 * in the buffer containing the sgt.
@@ -450,11 +465,6 @@ static void __hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 			break;
 	}
 
-#ifdef CONFIG_FSL_DPAA_1588
-	if (priv->tsu && priv->tsu->valid && priv->tsu->hwts_rx_en_ioctl)
-		dpa_ptp_store_rxstamp(priv->net_dev, skb, fd);
-#endif
-
 	/* recycle the SGT page */
 	dpa_bp = dpa_bpid2pool(fd->bpid);
 	BUG_ON(IS_ERR(dpa_bp));
-- 
1.9.1

