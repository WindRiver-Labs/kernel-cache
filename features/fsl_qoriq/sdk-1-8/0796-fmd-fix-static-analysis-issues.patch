From d586dc3aa6dcdc9775aa1065ce09578705273918 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Wed, 19 Nov 2014 07:17:46 +0200
Subject: [PATCH 796/987] fmd: fix static analysis issues

Change-Id: I2d6cead7b62116cd6a264ec91d82f3bdc3a03c10
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/23939
Reviewed-by: Igal Liberman <Igal.Liberman@freescale.com>
Tested-by: Richard Schmitt <richard.schmitt@freescale.com>
Reviewed-by: Richard Schmitt <richard.schmitt@freescale.com>
[Lu:Original patch taken from
QorIQ-SDK-V1.7-SOURCE-20141218-yocto.iso]
Signed-off-by: Jiang Lu <lu.jiang@windriver.com>
---
 .../ethernet/freescale/fman/Peripherals/FM/HC/hc.c |  20 +-
 .../freescale/fman/Peripherals/FM/MAC/dtsec.c      |  57 +-
 .../fman/Peripherals/FM/MAC/dtsec_mii_acc.c        |  10 +-
 .../freescale/fman/Peripherals/FM/MAC/fm_mac.c     |  14 +-
 .../freescale/fman/Peripherals/FM/MAC/fm_mac.h     |   2 +-
 .../freescale/fman/Peripherals/FM/MAC/fman_dtsec.c |   3 +-
 .../freescale/fman/Peripherals/FM/MAC/memac.c      |  11 +-
 .../fman/Peripherals/FM/MAC/memac_mii_acc.h        |   4 +-
 .../freescale/fman/Peripherals/FM/MAC/tgec.c       |  18 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.c      | 140 ++---
 .../freescale/fman/Peripherals/FM/Pcd/fm_cc.h      |  16 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_kg.c      |  96 +++-
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.c   | 153 ++---
 .../freescale/fman/Peripherals/FM/Pcd/fm_manip.h   |   8 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_pcd.c     |  34 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_pcd.h     |   8 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_plcr.c    |  22 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_prs.c     |  11 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_replic.c  |  24 +-
 .../freescale/fman/Peripherals/FM/Pcd/fm_replic.h  |   4 +-
 .../freescale/fman/Peripherals/FM/Pcd/fman_kg.c    |  16 +-
 .../freescale/fman/Peripherals/FM/Port/fm_port.c   | 638 +++++++++------------
 .../freescale/fman/Peripherals/FM/Port/fm_port.h   |  33 +-
 .../fman/Peripherals/FM/Port/fm_port_im.c          |   9 +-
 .../freescale/fman/Peripherals/FM/Port/fman_port.c |   4 +-
 .../freescale/fman/Peripherals/FM/SP/fm_sp.c       |   2 +-
 .../ethernet/freescale/fman/Peripherals/FM/fm.c    | 376 ++++++------
 .../ethernet/freescale/fman/Peripherals/FM/fm.h    |  50 +-
 .../freescale/fman/Peripherals/FM/fm_muram.c       |   1 -
 .../ethernet/freescale/fman/Peripherals/FM/fman.c  |  11 +-
 .../freescale/fman/Peripherals/FM/inc/fm_common.h  |  85 +--
 drivers/net/ethernet/freescale/fman/etc/mm.c       |  19 +-
 .../net/ethernet/freescale/fman/inc/debug_ext.h    |  73 +--
 .../ethernet/freescale/fman/inc/flib/fsl_fman.h    |   3 +-
 .../freescale/fman/inc/flib/fsl_fman_port.h        |   3 +-
 drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h |  14 +-
 .../freescale/fman/src/wrapper/lnxwrp_fm.c         |   2 +
 .../freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c  |  20 +-
 .../fman/src/wrapper/lnxwrp_ioctls_fm_compat.c     |   6 +-
 .../freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c   |   2 +-
 .../fman/src/wrapper/lnxwrp_sysfs_fm_port.c        |   2 -
 .../net/ethernet/freescale/fman/src/xx/Makefile    |   2 +-
 .../net/ethernet/freescale/fman/src/xx/xx_linux.c  |  25 +-
 43 files changed, 896 insertions(+), 1155 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
index 5d25111..5b03cfc 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/HC/hc.c
@@ -90,12 +90,12 @@ do {                                      \
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-typedef _Packed struct t_FmPcdKgPortRegs {
+typedef struct t_FmPcdKgPortRegs {
     volatile uint32_t                       spReg;
     volatile uint32_t                       cppReg;
-} _PackedType t_FmPcdKgPortRegs;
+} t_FmPcdKgPortRegs;
 
-typedef _Packed struct t_HcFrame {
+typedef struct t_HcFrame {
     volatile uint32_t                           opcode;
     volatile uint32_t                           actionReg;
     volatile uint32_t                           extraReg;
@@ -276,7 +276,7 @@ t_Handle FmHcConfigAndInit(t_FmHcParams *p_FmHcParams)
         return NULL;
     }
 
-    err = FM_PORT_ConfigMaxFrameLength(p_FmHc->h_HcPortDev, sizeof(t_HcFrame));
+    err = FM_PORT_ConfigMaxFrameLength(p_FmHc->h_HcPortDev, (uint16_t)sizeof(t_HcFrame));
     if (err != E_OK)
     {
         REPORT_ERROR(MAJOR, err, ("FM HC port init!"));
@@ -644,7 +644,7 @@ t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_S
     t_FmHc                  *p_FmHc = (t_FmHc*)h_FmHc;
     t_HcFrame               *p_HcFrame;
     t_DpaaFD                fmFd;
-    uint32_t                i;
+    uint8_t                 i, idx;
     uint32_t                seqNum;
     t_Error                 err = E_OK;
 
@@ -661,7 +661,10 @@ t_Error FmHcPcdKgSetClsPlan(t_Handle h_FmHc, t_FmPcdKgInterModuleClsPlanSet *p_S
         p_HcFrame->actionReg  = FmPcdKgBuildWriteClsPlanBlockActionReg((uint8_t)(i / CLS_PLAN_NUM_PER_GRP));
         p_HcFrame->extraReg = HC_HCOR_KG_SCHEME_REGS_MASK;
         ASSERT_COND(IN_RANGE(0, (i-p_Set->baseEntry) ,FM_PCD_MAX_NUM_OF_CLS_PLANS-1));
-        memcpy((void*)&p_HcFrame->hcSpecificData.clsPlanEntries, (void *)&p_Set->vectors[i-p_Set->baseEntry], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+        idx = (uint8_t)(i - p_Set->baseEntry);
+        ASSERT_COND(idx < FM_PCD_MAX_NUM_OF_CLS_PLANS);
+        memcpy(&p_HcFrame->hcSpecificData.clsPlanEntries, &p_Set->vectors[idx], CLS_PLAN_NUM_PER_GRP*sizeof(uint32_t));
+
         p_HcFrame->commandSequence = seqNum;
 
         BUILD_FD(sizeof(t_HcFrame));
@@ -693,9 +696,12 @@ t_Error FmHcPcdKgDeleteClsPlan(t_Handle h_FmHc, uint8_t  grpId)
     ASSERT_COND(p_ClsPlanSet->numOfClsPlanEntries <= FM_PCD_MAX_NUM_OF_CLS_PLANS);
 
     if (FmHcPcdKgSetClsPlan(p_FmHc, p_ClsPlanSet) != E_OK)
+    {
+        XX_Free(p_ClsPlanSet);
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
-    XX_Free(p_ClsPlanSet);
+    }
 
+    XX_Free(p_ClsPlanSet);
     FmPcdKgDestroyClsPlanGrp(p_FmHc->h_FmPcd, grpId);
 
     return E_OK;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
index e8cc70a..d0ed2e7 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec.c
@@ -559,17 +559,13 @@ static t_Error DtsecConfigException(t_Handle h_Dtsec, e_FmMacExceptions exceptio
     {
         if (!p_Dtsec->ptpTsuEnabled)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
-        switch (exception){
-        case (e_FM_MAC_EX_1G_1588_TS_RX_ERR):
-            if (enable)
-                p_Dtsec->enTsuErrExeption = TRUE;
-            else
-                p_Dtsec->enTsuErrExeption = FALSE;
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
-        }
+
+        if (enable)
+            p_Dtsec->enTsuErrExeption = TRUE;
+        else
+            p_Dtsec->enTsuErrExeption = FALSE;
     }
+
     return E_OK;
 }
 
@@ -1090,7 +1086,7 @@ static t_Error DtsecSetWakeOnLan(t_Handle h_Dtsec, bool en)
 static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDuplex)
 {
     t_Dtsec             *p_Dtsec = (t_Dtsec *)h_Dtsec;
-    t_Error             err;
+    int                 err;
     enum enet_interface enet_interface;
     enum enet_speed     enet_speed;
 
@@ -1102,12 +1098,12 @@ static t_Error DtsecAdjustLink(t_Handle h_Dtsec, e_EnetSpeed speed, bool fullDup
     enet_speed = (enum enet_speed) ENET_SPEED_FROM_MODE(p_Dtsec->enetMode);
     p_Dtsec->halfDuplex = !fullDuplex;
 
-    err = (t_Error)fman_dtsec_adjust_link(p_Dtsec->p_MemMap, enet_interface, enet_speed, fullDuplex);
+    err = fman_dtsec_adjust_link(p_Dtsec->p_MemMap, enet_interface, enet_speed, fullDuplex);
 
-    if (err == E_CONFLICT)
+    if (err == -EINVAL)
         RETURN_ERROR(MAJOR, E_CONFLICT, ("Ethernet interface does not support Half Duplex mode"));
 
-    return err;
+    return (t_Error)err;
 }
 
 /* .............................................................................. */
@@ -1190,20 +1186,16 @@ static t_Error DtsecSetException(t_Handle h_Dtsec, e_FmMacExceptions exception,
     {
         if (!p_Dtsec->ptpTsuEnabled)
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exception valid for 1588 only"));
-        switch (exception)
+
+        if (enable)
         {
-        case (e_FM_MAC_EX_1G_1588_TS_RX_ERR):
-            if (enable)
-            {
-                p_Dtsec->enTsuErrExeption = TRUE;
-                fman_dtsec_enable_tmr_interrupt(p_Dtsec->p_MemMap);
-            } else {
-                p_Dtsec->enTsuErrExeption = FALSE;
-                fman_dtsec_disable_tmr_interrupt(p_Dtsec->p_MemMap);
-            }
-            break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+            p_Dtsec->enTsuErrExeption = TRUE;
+            fman_dtsec_enable_tmr_interrupt(p_Dtsec->p_MemMap);
+        }
+        else
+        {
+            p_Dtsec->enTsuErrExeption = FALSE;
+            fman_dtsec_disable_tmr_interrupt(p_Dtsec->p_MemMap);
         }
     }
 
@@ -1330,6 +1322,8 @@ static t_Error DtsecInit(t_Handle h_Dtsec)
     maxFrmLn = fman_dtsec_get_max_frame_len(p_Dtsec->p_MemMap);
     err = FmSetMacMaxFrame(p_Dtsec->fmMacControllerDriver.h_Fm, e_FM_MAC_1G,
             p_Dtsec->fmMacControllerDriver.macId, maxFrmLn);
+    if (err)
+        RETURN_ERROR(MINOR,err, NO_MSG);
 
     p_Dtsec->p_MulticastAddrHash = AllocHashTable(EXTENDED_HASH_TABLE_SIZE);
     if (!p_Dtsec->p_MulticastAddrHash) {
@@ -1386,14 +1380,17 @@ static t_Error DtsecFree(t_Handle h_Dtsec)
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
 
-    FreeInitResources(p_Dtsec);
-
     if (p_Dtsec->p_DtsecDriverParam)
     {
+        /* Called after config */
         XX_Free(p_Dtsec->p_DtsecDriverParam);
         p_Dtsec->p_DtsecDriverParam = NULL;
     }
-    XX_Free (h_Dtsec);
+    else
+        /* Called after init */
+        FreeInitResources(p_Dtsec);
+
+    XX_Free(p_Dtsec);
 
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c
index f9dff6f..87da25f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/dtsec_mii_acc.c
@@ -53,7 +53,7 @@ t_Error DTSEC_MII_WritePhyReg(t_Handle    h_Dtsec,
     t_Dtsec              *p_Dtsec = (t_Dtsec *)h_Dtsec;
     struct dtsec_mii_reg *miiregs;
     uint16_t              dtsec_freq;
-    t_Error               err;
+    t_Error                   err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
@@ -75,7 +75,7 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
     t_Dtsec               *p_Dtsec = (t_Dtsec *)h_Dtsec;
     struct dtsec_mii_reg  *miiregs;
     uint16_t               dtsec_freq;
-    t_Error                err;
+    t_Error                    err;
 
     SANITY_CHECK_RETURN_ERROR(p_Dtsec, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_Dtsec->p_MiiMemMap, E_INVALID_HANDLE);
@@ -83,15 +83,15 @@ t_Error DTSEC_MII_ReadPhyReg(t_Handle h_Dtsec,
     dtsec_freq = (uint16_t)(p_Dtsec->fmMacControllerDriver.clkFreq >> 1);
     miiregs = p_Dtsec->p_MiiMemMap;
 
-    err = (t_Error)fman_dtsec_mii_read_reg(miiregs, phyAddr, reg, p_Data, dtsec_freq);
+    err = fman_dtsec_mii_read_reg(miiregs, phyAddr, reg, p_Data, dtsec_freq);
 
     if (*p_Data == 0xffff)
         RETURN_ERROR(MINOR, E_NO_DEVICE,
                      ("Read wrong data (0xffff): phyAddr 0x%x, reg 0x%x",
                       phyAddr, reg));
     if (err)
-        RETURN_ERROR(MINOR, err, NO_MSG);
+        RETURN_ERROR(MINOR, (t_Error)err, NO_MSG);
 
-    return err;
+    return E_OK;
 }
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
index e992f1a..a76ca6a 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.c
@@ -51,9 +51,17 @@
 t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
 {
     t_FmMacControllerDriver *p_FmMacControllerDriver;
+    uint16_t                fmClkFreq;
 
     SANITY_CHECK_RETURN_VALUE(p_FmMacParam, E_INVALID_HANDLE, NULL);
 
+    fmClkFreq = FmGetClockFreq(p_FmMacParam->h_Fm);
+    if (fmClkFreq == 0)
+    {
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Can't get clock for MAC!"));
+        return NULL;
+    }
+
 #if (DPAA_VERSION == 10)
     if (ENET_SPEED_FROM_MODE(p_FmMacParam->enetMode) < e_ENET_SPEED_10000)
         p_FmMacControllerDriver = (t_FmMacControllerDriver *)DTSEC_Config(p_FmMacParam);
@@ -75,11 +83,7 @@ t_Handle FM_MAC_Config (t_FmMacParams *p_FmMacParam)
     p_FmMacControllerDriver->macId          = p_FmMacParam->macId;
     p_FmMacControllerDriver->resetOnInit    = DEFAULT_resetOnInit;
 
-    if ((p_FmMacControllerDriver->clkFreq = FmGetClockFreq(p_FmMacControllerDriver->h_Fm)) == 0)
-    {
-        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Can't get clock for MAC!"));
-        return NULL;
-    }
+    p_FmMacControllerDriver->clkFreq        = fmClkFreq;
 
     return (t_Handle)p_FmMacControllerDriver;
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.h
index 05ccd7e..0d7b8d2 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fm_mac.h
@@ -198,7 +198,7 @@ static __inline__ t_EthHash * AllocHashTable(uint16_t size)
     t_EthHash *p_Hash;
 
     /* Allocate address hash table */
-    p_Hash = (t_EthHash *)XX_Malloc(size*sizeof(t_EthHash *));
+    p_Hash = (t_EthHash *)XX_Malloc(sizeof(t_EthHash));
     if (!p_Hash)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("Address hash table"));
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
index d88291e..5b09286 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/fman_dtsec.c
@@ -261,7 +261,6 @@ UNUSED(fm_rev_maj);UNUSED(fm_rev_min);
 	/***************MACCFG2***********************/
 
 	/***************IPGIFG************************/
-	tmp = 0;
 	tmp = (((cfg->non_back_to_back_ipg1 <<
 		IPGIFG_NON_BACK_TO_BACK_IPG_1_SHIFT)
 		& IPGIFG_NON_BACK_TO_BACK_IPG_1)
@@ -457,7 +456,7 @@ int fman_dtsec_adjust_link(struct dtsec_regs *regs,
 		enum enet_speed speed, bool full_dx)
 {
 	uint32_t		tmp;
-	
+
 	UNUSED(iface_mode);
 
 	if ((speed == E_ENET_SPEED_1000) && !full_dx)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
index 266716d..9566521 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
@@ -998,13 +998,16 @@ static t_Error MemacFree(t_Handle h_Memac)
 
     SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
 
-    FreeInitResources(p_Memac);
-
     if (p_Memac->p_MemacDriverParam)
     {
+        /* Called after config */
         XX_Free(p_Memac->p_MemacDriverParam);
         p_Memac->p_MemacDriverParam = NULL;
     }
+    else
+        /* Called after init */
+        FreeInitResources(p_Memac);
+
     XX_Free(p_Memac);
 
     return E_OK;
@@ -1095,11 +1098,11 @@ t_Handle MEMAC_Config(t_FmMacParams *p_FmMacParam)
     InitFmMacControllerDriver(&p_Memac->fmMacControllerDriver);
 
     /* Allocate memory for the mEMAC driver parameters data structure */
-    p_MemacDriverParam = (struct memac_cfg *) XX_Malloc(sizeof(struct memac_cfg));
+    p_MemacDriverParam = (struct memac_cfg *)XX_Malloc(sizeof(struct memac_cfg));
     if (!p_MemacDriverParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("mEMAC driver parameters"));
-        MemacFree(p_Memac);
+        XX_Free(p_Memac);
         return NULL;
     }
     memset(p_MemacDriverParam, 0, sizeof(struct memac_cfg));
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h
index a8824ef..325ec08 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac_mii_acc.h
@@ -57,13 +57,13 @@
 /*----------------------------------------------------*/
 /* MII Configuration Control Memory Map Registers     */
 /*----------------------------------------------------*/
-typedef _Packed struct t_MemacMiiAccessMemMap
+typedef struct t_MemacMiiAccessMemMap
 {
     volatile uint32_t   mdio_cfg;       /* 0x030  */
     volatile uint32_t   mdio_ctrl;      /* 0x034  */
     volatile uint32_t   mdio_data;      /* 0x038  */
     volatile uint32_t   mdio_addr;      /* 0x03c  */
-} _PackedType t_MemacMiiAccessMemMap ;
+} t_MemacMiiAccessMemMap ;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
index 91f4568..8f39f25 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/tgec.c
@@ -839,7 +839,12 @@ static t_Error TgecInit(t_Handle h_Tgec)
                            e_FM_MAC_10G,
                            p_Tgec->fmMacControllerDriver.macId,
                            p_TgecDriverParam->max_frame_length);
-    /* we consider having no IPC a non crasher... */
+    if (err != E_OK)
+    {
+        FreeInitResources(p_Tgec);
+        RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+/* we consider having no IPC a non crasher... */
 
 #ifdef FM_TX_FIFO_CORRUPTION_ERRATA_10GMAC_A007
     if (p_Tgec->fmMacControllerDriver.fmRevInfo.majorRev == 2)
@@ -886,14 +891,17 @@ static t_Error TgecFree(t_Handle h_Tgec)
 
     SANITY_CHECK_RETURN_ERROR(p_Tgec, E_INVALID_HANDLE);
 
-    FreeInitResources(p_Tgec);
-
     if (p_Tgec->p_TgecDriverParam)
     {
+        /* Called after config */
         XX_Free(p_Tgec->p_TgecDriverParam);
         p_Tgec->p_TgecDriverParam = NULL;
     }
-    XX_Free (p_Tgec);
+    else
+        /* Called after init */
+        FreeInitResources(p_Tgec);
+
+    XX_Free(p_Tgec);
 
     return E_OK;
 }
@@ -989,7 +997,7 @@ t_Handle TGEC_Config(t_FmMacParams *p_FmMacParam)
     if (!p_TgecDriverParam)
     {
         REPORT_ERROR(MAJOR, E_NO_MEMORY, ("10G MAC driver parameters"));
-        TgecFree(p_Tgec);
+        XX_Free(p_Tgec);
         return NULL;
     }
     memset(p_TgecDriverParam, 0, sizeof(struct tgec_cfg));
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
index 52a3314..fc42642 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.c
@@ -590,7 +590,7 @@ static t_Error SetRequiredAction(
 
 static t_Error ReleaseModifiedDataStructure(
         t_Handle h_FmPcd, t_List *h_FmPcdOldPointersLst,
-        t_List *h_FmPcdNewPointersLst, uint16_t numOfGoodChanges,
+        t_List *h_FmPcdNewPointersLst,
         t_FmPcdModifyCcKeyAdditionalParams *p_AdditionalParams,
         bool useShadowStructs)
 {
@@ -602,8 +602,6 @@ static t_Error ReleaseModifiedDataStructure(
     t_List *p_UpdateLst;
     uint32_t intFlags;
 
-    UNUSED(numOfGoodChanges);
-
     SANITY_CHECK_RETURN_ERROR(h_FmPcd, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_AdditionalParams->h_CurrentNode,
                               E_INVALID_HANDLE);
@@ -872,6 +870,7 @@ static t_Handle BuildNewAd(
                     != E_OK)
             {
                 REPORT_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+                XX_Free(p_FmPcdCcNodeTmp);
                 return NULL;
             }
         }
@@ -923,7 +922,7 @@ static t_Error DynamicChangeHc(
         if (newAdAddrOffset == (uint32_t)ILLEGAL_BASE)
         {
             ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
-                                         h_NewPointersLst, 0,
+                                         h_NewPointersLst,
                                          p_AdditionalParams, useShadowStructs);
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("New AD address"));
         }
@@ -936,7 +935,7 @@ static t_Error DynamicChangeHc(
             if (oldAdAddrOffset == (uint32_t)ILLEGAL_BASE)
             {
                 ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
-                                             h_NewPointersLst, i,
+                                             h_NewPointersLst,
                                              p_AdditionalParams,
                                              useShadowStructs);
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Old AD address"));
@@ -948,7 +947,7 @@ static t_Error DynamicChangeHc(
             if (err)
             {
                 ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
-                                             h_NewPointersLst, i,
+                                             h_NewPointersLst,
                                              p_AdditionalParams,
                                              useShadowStructs);
                 RETURN_ERROR(
@@ -994,49 +993,50 @@ static t_Error DoDynamicChange(
                               p_AdditionalParams, useShadowStructs);
         if (err)
             RETURN_ERROR(MAJOR, err, NO_MSG);
-    }
-    if (useShadowStructs)
-    {
-        /* When the host-command above has ended, the old structures are 'free'and we can update
-         them by copying from the new shadow structures. */
-        if (p_CcNode->lclMask)
-            keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
-        else
-            keySize = p_CcNode->ccKeySizeAccExtraction;
 
-        IO2IOCpy32(p_AdditionalParams->p_KeysMatchTableOld,
-                   p_AdditionalParams->p_KeysMatchTableNew,
-                   p_CcNode->maxNumOfKeys * keySize * sizeof(uint8_t));
+		if (useShadowStructs)
+		{
+			/* When the host-command above has ended, the old structures are 'free'and we can update
+			 them by copying from the new shadow structures. */
+			if (p_CcNode->lclMask)
+				keySize = (uint32_t)(2 * p_CcNode->ccKeySizeAccExtraction);
+			else
+				keySize = p_CcNode->ccKeySizeAccExtraction;
 
-        IO2IOCpy32(
-                p_AdditionalParams->p_AdTableOld,
-                p_AdditionalParams->p_AdTableNew,
-                (uint32_t)((p_CcNode->maxNumOfKeys + 1)
-                        * FM_PCD_CC_AD_ENTRY_SIZE));
+			IO2IOCpy32(p_AdditionalParams->p_KeysMatchTableOld,
+					   p_AdditionalParams->p_KeysMatchTableNew,
+					   p_CcNode->maxNumOfKeys * keySize * sizeof(uint8_t));
 
-        /* Retrieve the address of the allocated Ad */
-        p_CcNodeInfo = CC_NODE_F_OBJECT(p_PosNew);
-        h_Ad = p_CcNodeInfo->h_CcNode;
+			IO2IOCpy32(
+					p_AdditionalParams->p_AdTableOld,
+					p_AdditionalParams->p_AdTableNew,
+					(uint32_t)((p_CcNode->maxNumOfKeys + 1)
+							* FM_PCD_CC_AD_ENTRY_SIZE));
 
-        /* Build a new Ad that holds the old (now updated) structures */
-        p_AdditionalParams->p_KeysMatchTableNew =
-                p_AdditionalParams->p_KeysMatchTableOld;
-        p_AdditionalParams->p_AdTableNew = p_AdditionalParams->p_AdTableOld;
+			/* Retrieve the address of the allocated Ad */
+			p_CcNodeInfo = CC_NODE_F_OBJECT(p_PosNew);
+			h_Ad = p_CcNodeInfo->h_CcNode;
 
-        nextEngineParams.nextEngine = e_FM_PCD_CC;
-        nextEngineParams.params.ccParams.h_CcNode = (t_Handle)p_CcNode;
+			/* Build a new Ad that holds the old (now updated) structures */
+			p_AdditionalParams->p_KeysMatchTableNew =
+					p_AdditionalParams->p_KeysMatchTableOld;
+			p_AdditionalParams->p_AdTableNew = p_AdditionalParams->p_AdTableOld;
 
-        BuildNewAd(h_Ad, p_AdditionalParams, p_CcNode, &nextEngineParams);
+			nextEngineParams.nextEngine = e_FM_PCD_CC;
+			nextEngineParams.params.ccParams.h_CcNode = (t_Handle)p_CcNode;
 
-        /* HC to copy from the new Ad (old updated structures) to current Ad (uses shadow structures) */
-        err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst,
-                              p_AdditionalParams, useShadowStructs);
-        if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
+			BuildNewAd(h_Ad, p_AdditionalParams, p_CcNode, &nextEngineParams);
+
+			/* HC to copy from the new Ad (old updated structures) to current Ad (uses shadow structures) */
+			err = DynamicChangeHc(h_FmPcd, h_OldPointersLst, h_NewPointersLst,
+								  p_AdditionalParams, useShadowStructs);
+			if (err)
+				RETURN_ERROR(MAJOR, err, NO_MSG);
+		}
     }
 
     err = ReleaseModifiedDataStructure(h_FmPcd, h_OldPointersLst,
-                                       h_NewPointersLst, numOfModifiedPtr,
+                                       h_NewPointersLst,
                                        p_AdditionalParams, useShadowStructs);
     if (err)
         RETURN_ERROR(MAJOR, err, NO_MSG);
@@ -1361,10 +1361,9 @@ static void GetCcExtractKeySize(uint8_t parseCodeRealSize,
                                             *parseCodeCcSize = 0;
 }
 
-static void GetSizeHeaderField(e_NetHeaderType hdr, e_FmPcdHdrIndex index,
-                               t_FmPcdFields field, uint8_t *parseCodeRealSize)
+static void GetSizeHeaderField(e_NetHeaderType hdr, t_FmPcdFields field,
+		                       uint8_t *parseCodeRealSize)
 {
-    UNUSED(index);
     switch (hdr)
     {
         case (HEADER_TYPE_ETH):
@@ -1691,13 +1690,11 @@ t_Error ValidateNextEngineParams(
     return err;
 }
 
-static uint8_t GetGenParseCode(t_Handle h_FmPcd, e_FmPcdExtractFrom src,
+static uint8_t GetGenParseCode(e_FmPcdExtractFrom src,
                                uint32_t offset, bool glblMask,
                                uint8_t *parseArrayOffset, bool fromIc,
                                ccPrivateInfo_t icCode)
 {
-    UNUSED(h_FmPcd);
-
     if (!fromIc)
     {
         switch (src)
@@ -2122,6 +2119,7 @@ static uint8_t GetFieldParseCode(e_NetHeaderType hdr, t_FmPcdFields field,
     {
         case (HEADER_TYPE_NONE):
             ASSERT_COND(FALSE);
+                break;
         case (HEADER_TYPE_ETH):
             switch (field.eth)
             {
@@ -2278,7 +2276,6 @@ static void FillAdOfTypeResult(t_Handle h_Ad,
                 break;
 
             case (e_FM_PCD_PLCR):
-                tmp = 0;
                 if (p_CcNextEngineParams->params.plcrParams.overrideParams)
                 {
                     tmp = FM_PCD_AD_RESULT_CONTRL_FLOW_TYPE;
@@ -2746,7 +2743,7 @@ static t_Error BuildNewNodeAddOrMdfyKeyAndNextEngine(
                 {
                     p_KeysMatchTableOldTmp =
                             PTR_MOVE(p_CcNode->h_KeysMatchTable,
-                                    i * p_CcNode->ccKeySizeAccExtraction*sizeof(uint8_t));
+                                    i * (int)p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
 
                     if (p_CcNode->ccKeySizeAccExtraction > 4)
                     {
@@ -2881,11 +2878,8 @@ static t_Error BuildNewNodeRemoveKey(
     for (i = 0, j = 0; j < p_CcNode->numOfKeys; i++, j++)
     {
         if (j == keyIndex)
-        {
-            p_AdTableOldTmp =
-                    PTR_MOVE(p_AdditionalInfo->p_AdTableOld, j * FM_PCD_CC_AD_ENTRY_SIZE);
             j++;
-        }
+
         if (j == p_CcNode->numOfKeys)
             break;
         p_AdTableNewTmp =
@@ -3061,7 +3055,8 @@ static t_Error BuildNewNodeModifyKey(
                 else
                 {
                     p_KeysMatchTableOldTmp =
-                            PTR_MOVE(p_CcNode->h_KeysMatchTable, i * p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
+                            PTR_MOVE(p_CcNode->h_KeysMatchTable,
+                                     i * (int)p_CcNode->ccKeySizeAccExtraction * sizeof(uint8_t));
 
                     if (p_CcNode->ccKeySizeAccExtraction > 4)
                         IOMemSet32(PTR_MOVE(p_KeysMatchTableNewTmp,
@@ -3534,9 +3529,6 @@ static t_FmPcdModifyCcKeyAdditionalParams * ModifyNodeCommonPart(
     {
         if (modifyState == e_MODIFY_STATE_ADD)
             j++;
-        else
-            if (modifyState == e_MODIFY_STATE_REMOVE)
-                i++;
     }
 
     memcpy(&p_FmPcdModifyCcKeyAdditionalParams->keyAndNextEngineParams[j],
@@ -3569,7 +3561,6 @@ static t_Error UpdatePtrWhichPointOnCrntMdfNode(
     /* This node must be found as next engine of one of its previous nodes or trees*/
     if (p_NextEngineParams)
     {
-
         /* Building a new action descriptor that points to the modified node */
         h_NewAd = GetNewAd(p_CcNode, FALSE);
         if (!h_NewAd)
@@ -4213,7 +4204,7 @@ static t_Error CalcAndUpdateCcShadow(t_FmPcdCcNode *p_CcNode,
     if (err != E_OK)
     {
         DeleteNode(p_CcNode);
-        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node shadow"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for CC node shadow"));
     }
 
     return E_OK;
@@ -4463,7 +4454,6 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode,
                                     p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField);
                     GetSizeHeaderField(
                             p_CcNodeParam->extractCcParams.extractByHdr.hdr,
-                            p_CcNodeParam->extractCcParams.extractByHdr.hdrIndex,
                             p_CcNodeParam->extractCcParams.extractByHdr.extractByHdrType.fullField,
                             &p_CcNode->sizeOfExtraction);
                     fullField = TRUE;
@@ -4532,7 +4522,7 @@ static t_Error MatchTableSet(t_Handle h_FmPcd, t_FmPcdCcNode *p_CcNode,
             p_CcNode->userOffset =
                     p_CcNodeParam->extractCcParams.extractNonHdr.offset;
             p_CcNode->parseCode = GetGenParseCode(
-                    h_FmPcd, p_CcNodeParam->extractCcParams.extractNonHdr.src,
+                    p_CcNodeParam->extractCcParams.extractNonHdr.src,
                     p_CcNode->offset, glblMask, &p_CcNode->prsArrayOffset,
                     fromIc, icCode);
 
@@ -5346,12 +5336,6 @@ t_Error FmPcdCcRemoveKey(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
         RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                      ("impossible to remove key when numOfKeys <= keyIndex"));
 
-    if (!p_CcNode->numOfKeys)
-        RETURN_ERROR(
-                MAJOR,
-                E_INVALID_VALUE,
-                ("keyIndex you asked > numOfKeys of relevant node that was initialized"));
-
     if (p_CcNode->h_FmPcd != h_FmPcd)
         RETURN_ERROR(
                 MAJOR,
@@ -5831,10 +5815,6 @@ t_Error FmPcdCcNodeTreeTryLock(t_Handle h_FmPcd, t_Handle h_FmPcdCcNode,
 
     intFlags = FmPcdLock(h_FmPcd);
 
- //   if (LIST_IsEmpty(&p_CcNode->ccTreesLst))
-   //     RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-  //                   ("asked for more nodes in CC than MAX"));
-
     LIST_FOR_EACH(p_Pos, &p_CcNode->ccTreesLst)
     {
         p_CcNodeInfo = CC_NODE_F_OBJECT(p_Pos);
@@ -6193,7 +6173,6 @@ t_Handle FM_PCD_CcRootBuild(t_Handle h_FmPcd,
 
     p_CcTreeTmp = UINT_TO_PTR(p_FmPcdCcTree->ccTreeBaseAddr);
 
-    j = 0;
     for (i = 0; i < numOfEntries; i++)
     {
         p_KeyAndNextEngineParams = p_Params + i;
@@ -6421,15 +6400,11 @@ t_Handle FM_PCD_MatchTableSet(t_Handle h_FmPcd,
 
 t_Error FM_PCD_MatchTableDelete(t_Handle h_CcNode)
 {
-    t_FmPcd *p_FmPcd;
     t_FmPcdCcNode *p_CcNode = (t_FmPcdCcNode *)h_CcNode;
     int i = 0;
 
     SANITY_CHECK_RETURN_ERROR(p_CcNode, E_INVALID_HANDLE);
-    p_FmPcd = (t_FmPcd *)p_CcNode->h_FmPcd;
-    SANITY_CHECK_RETURN_ERROR(p_FmPcd, E_INVALID_HANDLE);
-
-    UNUSED(p_FmPcd);
+    SANITY_CHECK_RETURN_ERROR(p_CcNode->h_FmPcd, E_INVALID_HANDLE);
 
     if (p_CcNode->owners)
         RETURN_ERROR(
@@ -7200,6 +7175,8 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         if (!h_MissStatsCounters)
         {
             REPORT_ERROR(MAJOR, E_NO_MEMORY, ("MURAM allocation for statistics table for hash miss"));
+            XX_Free(p_IndxHashCcNodeParam);
+            XX_Free(p_ExactMatchCcNodeParam);
             return NULL;
         }
         memset(h_MissStatsCounters, 0, (2 * FM_PCD_CC_STATS_COUNTER_SIZE));
@@ -7285,7 +7262,8 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
     p_IndxHashCcNodeParam->keysParams.maskSupport = FALSE;
     p_IndxHashCcNodeParam->keysParams.statisticsMode =
             e_FM_PCD_CC_STATS_MODE_NONE;
-    p_IndxHashCcNodeParam->keysParams.numOfKeys = numOfSets; /* Number of keys of this node is number of sets of the hash */
+    /* Number of keys of this node is number of sets of the hash */
+    p_IndxHashCcNodeParam->keysParams.numOfKeys = numOfSets;
     p_IndxHashCcNodeParam->keysParams.keySize = 2;
 
     p_CcNodeHashTbl = FM_PCD_MatchTableSet(h_FmPcd, p_IndxHashCcNodeParam);
@@ -7295,7 +7273,7 @@ t_Handle FM_PCD_HashTableSet(t_Handle h_FmPcd, t_FmPcdHashTableParams *p_Param)
         p_CcNodeHashTbl->kgHashShift = p_Param->kgHashShift;
 
         /* Storing the allocated counters for buckets 'miss' in the hash table
-         and is statistics for miss wre enabled. */
+         and if statistics for miss were enabled. */
         p_CcNodeHashTbl->h_MissStatsCounters = h_MissStatsCounters;
         p_CcNodeHashTbl->statsEnForMiss = statsEnForMiss;
     }
@@ -7337,14 +7315,14 @@ t_Error FM_PCD_HashTableDelete(t_Handle h_HashTbl)
     for (i = 0; i < numOfBuckets; i++)
         err |= FM_PCD_MatchTableDelete(p_HashBuckets[i]);
 
-    if (err)
-        RETURN_ERROR(MAJOR, err, NO_MSG);
+    XX_Free(p_HashBuckets);
 
-    /* Free statistics counters for 'miss', id these were allocated */
+    /* Free statistics counters for 'miss', if these were allocated */
     if (h_MissStatsCounters)
         FM_MURAM_FreeMem(FmPcdGetMuramHandle(h_FmPcd), h_MissStatsCounters);
 
-    XX_Free(p_HashBuckets);
+    if (err)
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     return E_OK;
 }
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
index ceb8e1d..3bc7585 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_cc.h
@@ -190,35 +190,35 @@ typedef uint32_t ccPrivateInfo_t; /**< private info of CC: */
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t fqid;
     volatile uint32_t plcrProfile;
     volatile uint32_t nia;
     volatile uint32_t res;
-} _PackedType t_AdOfTypeResult;
+} t_AdOfTypeResult;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t ccAdBase;
     volatile uint32_t matchTblPtr;
     volatile uint32_t pcAndOffsets;
     volatile uint32_t gmask;
-} _PackedType t_AdOfTypeContLookup;
+} t_AdOfTypeContLookup;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t profileTableAddr;
     volatile uint32_t reserved;
     volatile uint32_t nextActionIndx;
     volatile uint32_t statsTableAddr;
-} _PackedType t_AdOfTypeStats;
+} t_AdOfTypeStats;
 
-typedef _Packed union
+typedef union
 {
     volatile t_AdOfTypeResult        adResult;
     volatile t_AdOfTypeContLookup    adContLookup;
-} _PackedType t_Ad;
+} t_Ad;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
index e423d90..cadc12a 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_kg.c
@@ -114,7 +114,7 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
             for (i=0 ; i<numOfSwDefaults ; i++)
                 if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_NOT_FROM_DATA)
                     return swDefaults[i].dfltSelect;
-            ASSERT_COND(FALSE);
+            break;
         case (KG_SCH_GEN_SHIM1):
         case (KG_SCH_GEN_SHIM2):
         case (KG_SCH_GEN_IP_PID_NO_V):
@@ -133,7 +133,7 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
             for (i=0 ; i<numOfSwDefaults ; i++)
                 if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA_NO_V)
                     return swDefaults[i].dfltSelect;
-
+            break;
         case (KG_SCH_GEN_START_OF_FRM):
         case (KG_SCH_GEN_ETH):
         case (KG_SCH_GEN_SNAP):
@@ -160,9 +160,12 @@ static e_FmPcdKgExtractDfltSelect GetGenericSwDefault(t_FmPcdKgExtractDflt swDef
             for (i=0 ; i<numOfSwDefaults ; i++)
                 if (swDefaults[i].type == e_FM_PCD_KG_GENERIC_FROM_DATA)
                     return swDefaults[i].dfltSelect;
+            break;
         default:
-            return e_FM_PCD_KG_DFLT_ILLEGAL;
+            break;
     }
+
+    return e_FM_PCD_KG_DFLT_ILLEGAL;
 }
 
 static uint8_t GetGenCode(e_FmPcdExtractFrom src, uint8_t *p_Offset)
@@ -301,6 +304,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
         {
             case (HEADER_TYPE_NONE):
                 ASSERT_COND(FALSE);
+                break;
             case (HEADER_TYPE_ETH):
                 switch (field.eth)
                 {
@@ -310,6 +314,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                         return 0;
                 }
+                break;
             case (HEADER_TYPE_VLAN):
                 switch (field.vlan)
                 {
@@ -321,6 +326,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                         return 0;
                 }
+                break;
             case (HEADER_TYPE_MPLS):
             case (HEADER_TYPE_IPSEC_AH):
             case (HEADER_TYPE_IPSEC_ESP):
@@ -337,24 +343,27 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
             case (HEADER_TYPE_DCCP):
             case (HEADER_TYPE_USER_DEFINED_L4):
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-            default:
-                REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
                 return 0;
+            default:
+                break;
+
         }
         else
             switch (hdr)
             {
                 case (HEADER_TYPE_NONE):
                     ASSERT_COND(FALSE);
+                    break;
                 case (HEADER_TYPE_ETH):
-                switch (field.eth)
-                {
-                    case (NET_HEADER_FIELD_ETH_TYPE):
-                        return KG_SCH_GEN_ETH_TYPE_NO_V;
-                    default:
-                        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-                        return 0;
-                }
+                    switch (field.eth)
+                    {
+                        case (NET_HEADER_FIELD_ETH_TYPE):
+                            return KG_SCH_GEN_ETH_TYPE_NO_V;
+                        default:
+                            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+                            return 0;
+                    }
+                    break;
                 case (HEADER_TYPE_VLAN):
                     switch (field.vlan)
                     {
@@ -366,6 +375,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal VLAN header index"));
                             return 0;
                     }
+                    break;
                 case (HEADER_TYPE_IPv4):
                     switch (field.ipv4)
                     {
@@ -375,6 +385,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
+                    break;
                 case (HEADER_TYPE_IPv6):
                    switch (field.ipv6)
                     {
@@ -384,6 +395,7 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                             REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                             return 0;
                     }
+                    break;
                 case (HEADER_TYPE_MPLS):
                 case (HEADER_TYPE_LLC_SNAP):
                 case (HEADER_TYPE_PPPoE):
@@ -400,9 +412,10 @@ static t_GenericCodes GetGenFieldCode(e_NetHeaderType hdr, t_FmPcdFields field,
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
                     return 0;
                 default:
-                    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
-                    return 0;
+                    break;
             }
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Header not supported"));
+    return 0;
 }
 
 static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr, e_FmPcdHdrIndex index, t_FmPcdFields field)
@@ -413,6 +426,7 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
     {
         case (HEADER_TYPE_NONE):
             ASSERT_COND(FALSE);
+            break;
         case (HEADER_TYPE_ETH):
             switch (field.eth)
             {
@@ -658,9 +672,12 @@ static t_KnownFieldsMasks GetKnownProtMask(t_FmPcd *p_FmPcd, e_NetHeaderType hdr
                     return 0;
             }
         default:
-            REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
-            return 0;
+            break;
+
     }
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Extraction not supported"));
+    return 0;
 }
 
 
@@ -1220,8 +1237,6 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                         p_SchemeRegs->kgse_ppc = ppcTmp;
                     }
                 }
-                else
-                    ppcTmp = KG_SCH_PP_NO_GEN;
             }
             break;
         case (e_FM_PCD_DONE):
@@ -1242,7 +1257,6 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
     {
         p_SchemeRegs->kgse_om |= KG_SCH_OM_VSPE;
 
-        tmpReg = 0;
         if (p_SchemeParams->storageProfile.direct)
         {
             profileId = p_SchemeParams->storageProfile.profileSelect.directRelativeProfileId;
@@ -1416,14 +1430,12 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                                         case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SPI):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
-                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                                             /*p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SPI_OFFSET;*/
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
                                         case (NET_HEADER_FIELD_UDP_ENCAP_ESP_SEQUENCE_NUM):
                                             p_Extract->extractByHdr.type = e_FM_PCD_EXTRACT_FROM_HDR;
                                             p_Extract->extractByHdr.hdr = FmPcdGetAliasHdr(p_FmPcd, p_Scheme->netEnvId, HEADER_TYPE_UDP_ENCAP_ESP);
-                                            p_Extract->extractByHdr.extractByHdrType.fromField.size = p_Extract->extractByHdr.extractByHdrType.fromField.size;
                                             p_Extract->extractByHdr.extractByHdrType.fromField.offset += ESP_SEQ_NUM_OFFSET;
                                             p_Extract->extractByHdr.ignoreProtocolValidation = TRUE;
                                             break;
@@ -1492,17 +1504,18 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                                 }
                                 else
                                     generic = TRUE;
-
                             }
                             else
                                 generic = TRUE;
                             if (generic)
                             {
                                 /* tmp - till we cover more headers under generic */
+                                XX_Free(p_LocalExtractsArray);
                                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Full header selection not supported"));
                             }
                             break;
                         default:
+                            XX_Free(p_LocalExtractsArray);
                             RETURN_ERROR(MAJOR, E_INVALID_SELECTION, NO_MSG);
                     }
                     break;
@@ -1523,15 +1536,24 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
             {
                 /* set generic register fields */
                 if (currGenId >= FM_KG_NUM_OF_GENERIC_REGS)
+                {
+                    XX_Free(p_LocalExtractsArray);
                     RETURN_ERROR(MAJOR, E_FULL, ("Generic registers are fully used"));
+                }
                 if (!code)
+                {
+                    XX_Free(p_LocalExtractsArray);
                     RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
+                }
 
                 genTmp = KG_SCH_GEN_VALID;
                 genTmp |= (uint32_t)(code << KG_SCH_GEN_HT_SHIFT);
                 genTmp |= offset;
                 if ((size > MAX_KG_SCH_SIZE) || (size < 1))
-                      RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
+                {
+                    XX_Free(p_LocalExtractsArray);
+                    RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Illegal extraction (size out of range)"));
+                }
                 genTmp |= (uint32_t)((size - 1) << KG_SCH_GEN_SIZE_SHIFT);
                 swDefault = GetGenericSwDefault(swDefaults, numOfSwDefaults, code);
                 if (swDefault == e_FM_PCD_KG_DFLT_ILLEGAL)
@@ -1553,8 +1575,11 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
         maskTmp = 0xFFFFFFFF;
         /*  configure kgse_bmch, kgse_bmcl and kgse_fqb */
 
-        if (p_KeyAndHash->numOfUsedMasks >= FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+        if (p_KeyAndHash->numOfUsedMasks > FM_PCD_KG_NUM_OF_EXTRACT_MASKS)
+        {
+            XX_Free(p_LocalExtractsArray);
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Only %d masks supported", FM_PCD_KG_NUM_OF_EXTRACT_MASKS));
+        }
         for ( i=0 ;i<p_KeyAndHash->numOfUsedMasks ; i++)
         {
             /* Get the relative id of the extract (for known 0-0x1f, for generic 0-7) */
@@ -1589,9 +1614,15 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
 
         /*  configure kgse_hc  */
         if (p_KeyAndHash->hashShift > MAX_HASH_SHIFT)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
+        {
+            XX_Free(p_LocalExtractsArray);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashShift must not be larger than %d", MAX_HASH_SHIFT));
+        }
         if (p_KeyAndHash->hashDistributionFqidsShift > MAX_DIST_FQID_SHIFT)
-             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
+        {
+            XX_Free(p_LocalExtractsArray);
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("hashDistributionFqidsShift must not be larger than %d", MAX_DIST_FQID_SHIFT));
+        }
 
         tmpReg = 0;
 
@@ -1604,7 +1635,10 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC1) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST1)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPSRC2) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_IPDST2)) ||
                     (!!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PSRC) != !!(p_SchemeRegs->kgse_ekfc & KG_SCH_KN_L4PDST)))
+            {
+                XX_Free(p_LocalExtractsArray);
                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("symmetricHash set but src/dest extractions missing"));
+            }
             tmpReg |= KG_SCH_HASH_CONFIG_SYM;
         }
         p_SchemeRegs->kgse_hc = tmpReg;
@@ -1650,8 +1684,6 @@ static t_Error BuildSchemeRegs(t_FmPcdKgScheme            *p_Scheme,
             }
         }
         XX_Free(p_LocalExtractsArray);
-        p_LocalExtractsArray = NULL;
-
     }
     else
     {
@@ -2001,7 +2033,7 @@ void FmPcdKgDestroyClsPlanGrp(t_Handle h_FmPcd, uint8_t grpId)
     memset(&p_FmPcd->p_FmPcdKg->clsPlanGrps[grpId], 0, sizeof(t_FmPcdKgClsPlanGrp));
 }
 
-t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
+t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd, t_FmPcdKgInterModuleBindPortToSchemes *p_BindPort, uint32_t *p_SpReg, bool add)
 {
     t_FmPcd                 *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint32_t                j, schemesPerPortVector = 0;
@@ -2053,7 +2085,9 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
                 the match vector and the grpBits (= ccUnits) */
                 if ((p_Scheme->matchVector != SCHEME_ALWAYS_DIRECT) || p_Scheme->ccUnits)
                 {
+                    uint8_t netEnvId;
                     walking1Mask = 0x80000000;
+                    netEnvId = (p_Scheme->netEnvId == ILLEGAL_NETENV)? p_BindPort->netEnvId:p_Scheme->netEnvId;
                     tmp = (p_Scheme->matchVector == SCHEME_ALWAYS_DIRECT)? 0:p_Scheme->matchVector;
                     tmp |= p_Scheme->ccUnits;
                     while (tmp)
@@ -2061,7 +2095,7 @@ t_Error FmPcdKgBuildBindPortToSchemes(t_Handle h_FmPcd , t_FmPcdKgInterModuleBin
                         if (tmp & walking1Mask)
                         {
                             tmp &= ~walking1Mask;
-                            if (!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, p_Scheme->netEnvId, walking1Mask))
+                            if (!PcdNetEnvIsUnitWithoutOpts(p_FmPcd, netEnvId, walking1Mask))
                                 RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Port (without clsPlan) may not be bound to requested scheme - uses clsPlan options"));
                         }
                         walking1Mask >>= 1;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
index ddf661a..e69ea1d 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.c
@@ -485,7 +485,6 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
                         uint8_t prsArrayOffset;
                         t_Error err = E_OK;
 
-                        UNUSED(err);
                         tmpReg = (uint32_t)(HMCD_OPCODE_RMV_TILL)
                                 << HMCD_OC_SHIFT;
 
@@ -504,11 +503,7 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
                         RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
                                      ("manip header remove by hdr type!"));
                 }
-
             }
-            else
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                             ("manip header remove type!"));
 
         WRITE_UINT32(*p_TmpHmct, tmpReg);
         /* save a pointer to the "last" indication word */
@@ -708,9 +703,6 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
 
                 }
             }
-            else
-                RETURN_ERROR(MINOR, E_NOT_SUPPORTED,
-                             ("manip header insert type!"));
     }
 
     if (p_FmPcdManipParams->u.hdr.fieldUpdate)
@@ -1044,10 +1036,6 @@ static t_Error BuildHmct(t_FmPcdManip *p_Manip,
             else
                 XX_Free(((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad);
             ((t_FmPcdManip *)p_FmPcdManipParams->h_NextManip)->h_Ad = NULL;
-
-            /* advance pointer */
-            p_TmpHmct += MANIP_GET_HMCT_SIZE(p_FmPcdManipParams->h_NextManip)
-                    / 4;
         }
     }
     else
@@ -1287,8 +1275,6 @@ static t_Error CreateManipActionBackToOrig(
     uint8_t *p_WholeHmct = NULL, *p_TmpHmctPtr, *p_TmpDataPtr;
     t_FmPcdManip *p_CurManip = p_Manip;
 
-    UNUSED(p_WholeHmct);
-
     /* Build the new table in the shadow */
     if (!MANIP_IS_UNIFIED(p_Manip))
         BuildHmct(p_Manip, p_FmPcdManipParams, p_Manip->p_Hmct, p_Manip->p_Data,
@@ -1820,6 +1806,9 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_ReasmCommonPramTbl)
     ASSERT_COND(h_ReasmCommonPramTbl);
 
     bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    if (bitFor1Micro == 0)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Timestamp scale"));
+
     bitFor1Micro = 32 - bitFor1Micro;
     LOG2(FM_PCD_MANIP_REASM_TIMEOUT_THREAD_THRESH, log2num);
     tsbs = bitFor1Micro - log2num;
@@ -1857,11 +1846,15 @@ t_Error FmPcdRegisterReassmPort(t_Handle h_FmPcd, t_Handle h_ReasmCommonPramTbl)
 
 static t_Error CreateReassCommonTable(t_FmPcdManip *p_Manip)
 {
-    uint32_t tmpReg32 = 0, i;
+    uint32_t tmpReg32 = 0, i, bitFor1Micro;
     uint64_t tmpReg64, size;
     t_FmPcd *p_FmPcd = (t_FmPcd *)p_Manip->h_FmPcd;
     t_Error err = E_OK;
 
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    if (bitFor1Micro == 0)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Timestamp scale"));
+
     /* Allocation of the Reassembly Common Parameters table. This table is located in the
      MURAM. Its size is 64 bytes and its base address should be 8-byte aligned. */
     p_Manip->reassmParams.p_ReassCommonTbl =
@@ -1969,7 +1962,7 @@ static t_Error CreateReassCommonTable(t_FmPcdManip *p_Manip)
 
     /* Sets the Expiration Delay */
     tmpReg32 = 0;
-    tmpReg32 |= (((uint32_t)(1 << FmGetTimeStampScale(p_FmPcd->h_Fm)))
+    tmpReg32 |= (((uint32_t)(1 << bitFor1Micro))
             * p_Manip->reassmParams.timeoutThresholdForReassmProcess);
     WRITE_UINT32(p_Manip->reassmParams.p_ReassCommonTbl->expirationDelay,
                  tmpReg32);
@@ -2036,7 +2029,7 @@ static t_Error CreateReassTable(t_FmPcdManip *p_Manip, e_NetHeaderType hdr)
             keySize = 4;
             break;
         default:
-            break;
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header type"));
     }
     keySize += 2; /* 2 bytes reserved for RFDIndex */
 #if (DPAA_VERSION >= 11)
@@ -2200,32 +2193,6 @@ static t_Error UpdateInitReasm(t_Handle h_FmPcd, t_Handle h_PcdParams,
                 & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK | FM_REV))
             RETURN_ERROR(MAJOR, E_INVALID_STATE,
                          ("offset of the data wasn't configured previously"));
-    }
-    else
-        if (validate)
-        {
-            if ((!(p_Manip->shadowUpdateParams
-                    & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK)))
-                    || ((p_Manip->updateParams
-                            & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))))
-                RETURN_ERROR(
-                        MAJOR, E_INVALID_STATE,
-                        ("in this stage parameters from Port has be updated"));
-
-            fmPortGetSetCcParams.setCcParams.type = 0;
-            fmPortGetSetCcParams.getCcParams.type = p_Manip->shadowUpdateParams;
-            if ((err = FmPortGetSetCcParams(h_FmPort, &fmPortGetSetCcParams))
-                    != E_OK)
-                RETURN_ERROR(MAJOR, err, NO_MSG);
-            if (fmPortGetSetCcParams.getCcParams.type
-                    & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
-                RETURN_ERROR(
-                        MAJOR, E_INVALID_STATE,
-                        ("offset of the data wasn't configured previously"));
-        }
-
-    if (p_Manip->updateParams)
-    {
         if (p_Manip->updateParams
                 & (NUM_OF_TASKS | NUM_OF_EXTRA_TASKS | DISCARD_MASK))
         {
@@ -3032,18 +2999,19 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
     uint8_t log2Num;
     uint8_t numOfSets;
     uint32_t j = 0;
+    uint32_t bitFor1Micro;
 
     SANITY_CHECK_RETURN_ERROR(p_Manip->h_Ad, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPcd->h_Hc, E_INVALID_HANDLE);
 
     if (!p_FmPcd->h_Hc)
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE,("hc port has to be initialized in this mode"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("hc port has to be initialized in this mode"));
     if (!POWER_OF_2(p_ManipParams->timeoutRoutineRequestTime))
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeoutRoutineRequestTime has to be power of 2"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("timeoutRoutineRequestTime has to be power of 2"));
     if (!POWER_OF_2(p_ManipParams->maxNumFramesInProcess))
-    RETURN_ERROR(MAJOR, E_INVALID_VALUE,("maxNumFramesInProcess has to be power of 2"));
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE,("maxNumFramesInProcess has to be power of 2"));
     if (!p_ManipParams->timeoutRoutineRequestTime && p_ManipParams->timeoutThresholdForReassmProcess)
-    DBG(WARNING, ("if timeoutRoutineRequestTime 0,  timeoutThresholdForReassmProcess is uselessly"));
+        DBG(WARNING, ("if timeoutRoutineRequestTime 0,  timeoutThresholdForReassmProcess is uselessly"));
     if (p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_FOUR_WAYS_HASH)
     {
         if ((p_ManipParams->maxNumFramesInProcess < 4) ||
@@ -3057,13 +3025,17 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
         RETURN_ERROR(MAJOR,E_INVALID_VALUE, ("In the case of numOfFramesPerHashEntry = e_FM_PCD_MANIP_FOUR_WAYS_HASH maxNumFramesInProcess has to be in the range 8-2048"));
     }
 
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    if (bitFor1Micro == 0)
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Timestamp scale"));
+
     p_Manip->updateParams |= (NUM_OF_TASKS | OFFSET_OF_PR | OFFSET_OF_DATA | HW_PORT_ID);
 
     p_Manip->h_Frag = (t_Handle)FM_MURAM_AllocMem(p_FmPcd->h_FmMuram,
             FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE,
             FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
     if (!p_Manip->h_Frag)
-    RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc CAPWAP reassembly parameters table"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("MURAM alloc CAPWAP reassembly parameters table"));
 
     IOMemSet32(p_Manip->h_Frag, 0, FM_PCD_MANIP_CAPWAP_REASM_TABLE_SIZE);
 
@@ -3075,7 +3047,7 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
             FM_PCD_MANIP_CAPWAP_REASM_TABLE_ALIGN);
 
     if (!p_Manip->capwapFragParams.p_AutoLearnHashTbl)
-    RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
+        RETURN_ERROR(MAJOR, E_NO_MEMORY,("MURAM alloc for CAPWAP automatic learning hash table"));
 
     IOMemSet32(p_Manip->capwapFragParams.p_AutoLearnHashTbl, 0, (uint32_t)(p_ManipParams->maxNumFramesInProcess * 2 * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE));
 
@@ -3085,9 +3057,9 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
 
     tmpReg32 = 0;
     if (p_ManipParams->timeOutMode == e_FM_PCD_MANIP_TIME_OUT_BETWEEN_FRAMES)
-    tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES;
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_TIME_OUT_BETWEEN_FRAMES;
     if (p_ManipParams->haltOnDuplicationFrag)
-    tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
+        tmpReg32 |= FM_PCD_MANIP_CAPWAP_REASM_HALT_ON_DUPLICATE_FRAG;
     if (p_ManipParams->numOfFramesPerHashEntry == e_FM_PCD_MANIP_EIGHT_WAYS_HASH)
     {
         i = 8;
@@ -3103,8 +3075,8 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
     WRITE_UINT32(((t_CapwapReasmPram *)p_Table)->mode, tmpReg32);
 
     for (j=0; j<p_ManipParams->maxNumFramesInProcess*2; j++)
-    if (((j / i) % 2)== 0)
-    WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->capwapFragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
+        if (((j / i) % 2)== 0)
+            WRITE_UINT32(*(uint32_t *)PTR_MOVE(p_Manip->capwapFragParams.p_AutoLearnHashTbl, j * FM_PCD_MANIP_CAPWAP_REASM_AUTO_LEARNING_HASH_ENTRY_SIZE), 0x80000000);
 
     tmpReg32 = 0x00008000;
     tmpReg32 |= (uint32_t)poolId << 16;
@@ -3118,7 +3090,7 @@ static t_Error CapwapReassembly(t_CapwapReassemblyParams *p_ManipParams,
 
     p_Manip->capwapFragParams.fqidForTimeOutFrames = p_ManipParams->fqidForTimeOutFrames;
     p_Manip->capwapFragParams.timeoutRoutineRequestTime = p_ManipParams->timeoutRoutineRequestTime;
-    p_Manip->capwapFragParams.bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    p_Manip->capwapFragParams.bitFor1Micro = bitFor1Micro;
 
     tmpReg32 = 0;
     tmpReg32 |= (((uint32_t)1<<p_Manip->capwapFragParams.bitFor1Micro) * p_ManipParams->timeoutThresholdForReassmProcess);
@@ -3449,7 +3421,7 @@ static t_Error FillReassmManipParams(t_FmPcdManip *p_Manip, e_NetHeaderType hdr)
                     - (p_FmPcd->physicalMuramBase));
             break;
         default:
-            break;
+            RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("header type"));
     }
 
     WRITE_UINT32(p_Ad->ccAdBase, tmpReg32);
@@ -4037,7 +4009,6 @@ static void setCapwapReassmSchemeParams(t_FmPcd* p_FmPcd,
                                         t_FmPcdKgSchemeParams *p_Scheme,
                                         t_Handle h_CcTree, uint8_t groupId)
 {
-    uint32_t j;
     uint8_t res;
 
     /* Configures scheme's network environment parameters */
@@ -4356,18 +4327,18 @@ static t_Handle ManipOrStatsSetNode(t_Handle h_FmPcd, t_Handle *p_Params,
                                          (t_FmPcdManipParams *)p_Params);
 #if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     else
-    err = CheckStatsParamsAndSetType(p_Manip, (t_FmPcdStatsParams *)p_Params);
+        err = CheckStatsParamsAndSetType(p_Manip, (t_FmPcdStatsParams *)p_Params);
 #else /* not (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     else
     {
         REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Statistics node!"));
+        XX_Free(p_Manip);
         return NULL;
     }
 #endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
     if (err)
     {
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("INVALID HEADER MANIPULATION TYPE"));
-        ReleaseManipHandler(p_Manip, p_FmPcd);
+        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Invalid header manipulation type"));
         XX_Free(p_Manip);
         return NULL;
     }
@@ -4488,7 +4459,6 @@ static t_Error FmPcdManipInitUpdate(t_Handle h_FmPcd, t_Handle h_PcdParams,
     SANITY_CHECK_RETURN_ERROR(h_Manip, E_INVALID_HANDLE);
 
     UNUSED(level);
-    UNUSED(h_FmPcd);
     UNUSED(h_FmTree);
 
     switch (p_Manip->opcode)
@@ -4635,14 +4605,15 @@ t_Error FmPcdManipCheckParamsForCcNextEngine(
         uint32_t *requiredAction)
 {
     t_FmPcdManip *p_Manip;
+#if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
     t_Error err = E_OK;
+#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))*/
     bool pointFromCc = TRUE;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams, E_NULL_POINTER);
     SANITY_CHECK_RETURN_ERROR(p_FmPcdCcNextEngineParams->h_Manip,
                               E_NULL_POINTER);
 
-    UNUSED(err);
     p_Manip = (t_FmPcdManip *)(p_FmPcdCcNextEngineParams->h_Manip);
     *requiredAction = 0;
 
@@ -4652,46 +4623,36 @@ t_Error FmPcdManipCheckParamsForCcNextEngine(
         {
 #if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
             case (HMAN_OC_CAPWAP_INDEXED_STATS):
-            if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
-            RETURN_ERROR(
-                    MAJOR,
-                    E_INVALID_STATE,
-                    ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
-            if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
-            p_Manip->cnia = TRUE;
+                if (p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                    RETURN_ERROR(MAJOR,	E_INVALID_STATE, ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE"));
+                if (p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
+                    p_Manip->cnia = TRUE;
             case (HMAN_OC_CAPWAP_RMV_DTLS_IF_EXIST):
-            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+                *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
             case (HMAN_OC_RMV_N_OR_INSRT_INT_FRM_HDR):
-            p_Manip->ownerTmp++;
-            break;
+                p_Manip->ownerTmp++;
+                break;
             case (HMAN_OC_INSRT_HDR_BY_TEMPL_N_OR_FRAG_AFTER):
-            if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
+                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_DONE)
                     && !p_FmPcdCcNextEngineParams->params.enqueueParams.overrideFqid)
-            RETURN_ERROR(
-                    MAJOR,
-                    E_INVALID_STATE,
-                    ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
-            p_Manip->ownerTmp++;
-            break;
+                    RETURN_ERROR(
+                        MAJOR,
+                        E_INVALID_STATE,
+                        ("For this type of header manipulation has to be nextEngine e_FM_PCD_DONE with fqidForCtrlFlow FALSE"));
+                p_Manip->ownerTmp++;
+                break;
             case (HMAN_OC_MV_INT_FRAME_HDR_FROM_FRM_TO_BUFFER_PREFFIX):
-            if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)
-                    && (FmPcdCcGetParseCode(
-                                    p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
-                            != CC_PC_GENERIC_IC_HASH_INDEXED))
-            RETURN_ERROR(
-                    MAJOR,
-                    E_INVALID_STATE,
-                    ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
-            err =
-            UpdateManipIc(
-                    p_FmPcdCcNextEngineParams->h_Manip,
-                    FmPcdCcGetOffset(
-                            p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
-            if (err)
-            RETURN_ERROR(MAJOR, err, NO_MSG);
-            *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
-            break;
-#endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
+                if ((p_FmPcdCcNextEngineParams->nextEngine != e_FM_PCD_CC)
+                    && (FmPcdCcGetParseCode(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode)
+                        != CC_PC_GENERIC_IC_HASH_INDEXED))
+                    RETURN_ERROR(MAJOR, E_INVALID_STATE, ("For this type of header manipulation next engine has to be CC and action = e_FM_PCD_ACTION_INDEXED_LOOKUP"));
+                err = UpdateManipIc(p_FmPcdCcNextEngineParams->h_Manip,
+                                    FmPcdCcGetOffset(p_FmPcdCcNextEngineParams->params.ccParams.h_CcNode));
+                if (err)
+                    RETURN_ERROR(MAJOR, err, NO_MSG);
+                *requiredAction = UPDATE_NIA_ENQ_WITHOUT_DMA;
+                break;
+ #endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
             case (HMAN_OC_IP_FRAGMENTATION):
             case (HMAN_OC_IP_REASSEMBLY):
 #if (DPAA_VERSION >= 11)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
index 2827578..de7e4c8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_manip.h
@@ -312,7 +312,7 @@ typedef enum e_ManipInfo {
 #endif /* defined(__MWERKS__) && ... */
 
 #if (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10))
-typedef _Packed struct t_CapwapReasmPram {
+typedef struct t_CapwapReasmPram {
     volatile uint32_t mode;
     volatile uint32_t autoLearnHashTblPtr;
     volatile uint32_t intStatsTblPtr;
@@ -336,7 +336,7 @@ typedef _Packed struct t_CapwapReasmPram {
     volatile uint32_t internalBufferBusy;
     volatile uint32_t externalBufferBusy;
     volatile uint32_t reserved1[4];
-} _PackedType t_CapwapReasmPram;
+} t_CapwapReasmPram;
 #endif /* (defined(FM_CAPWAP_SUPPORT) && (DPAA_VERSION == 10)) */
 
 typedef _Packed struct t_ReassTbl {
@@ -359,7 +359,7 @@ typedef _Packed struct t_ReassTbl {
     volatile uint32_t reserved2[2];
 } _PackedType t_ReassTbl;
 
-typedef _Packed struct t_ReassCommonTbl {
+typedef struct t_ReassCommonTbl {
     volatile uint32_t timeoutModeAndFqid;
     volatile uint32_t reassFrmDescIndexPoolTblPtr;
     volatile uint32_t liodnAndReassFrmDescPoolPtrHi;
@@ -376,7 +376,7 @@ typedef _Packed struct t_ReassCommonTbl {
     volatile uint32_t totalDmaSemaphoreDepletionCounter;
     volatile uint32_t totalNCSPCounter;
     volatile uint32_t discardMask;
-} _PackedType t_ReassCommonTbl;
+} t_ReassCommonTbl;
 
 typedef _Packed struct t_Hmtd {
     volatile uint16_t   cfg;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
index 379e984..4adf9a1 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.c
@@ -1044,8 +1044,7 @@ t_Error FM_PCD_Free(t_Handle h_FmPcd)
 
     if (p_FmPcd->p_FmPcdPlcr)
     {
-        if ((err = PlcrFree(p_FmPcd)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+        PlcrFree(p_FmPcd);
         XX_Free(p_FmPcd->p_FmPcdPlcr);
         p_FmPcd->p_FmPcdPlcr = NULL;
     }
@@ -1485,7 +1484,7 @@ t_Handle FM_PCD_NetEnvCharacteristicsSet(t_Handle h_FmPcd, t_FmPcdNetEnvParams
             for (k = 0; (k < FM_PCD_MAX_NUM_OF_INTERCHANGEABLE_HDRS)
                     && (p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr != HEADER_TYPE_NONE); k++)
             {
-                GET_PRS_HDR_NUM(hdrNum, p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr);
+                hdrNum = GetPrsHdrNum(p_FmPcd->netEnvs[netEnvCurrId].units[i].hdrs[k].hdr);
                 if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
                 {
                     REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, NO_MSG);
@@ -1749,11 +1748,8 @@ uint32_t FM_PCD_GetCounter(t_Handle h_FmPcd, e_FmPcdCounters counter)
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_tpcnt);
         case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
                 return GET_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt);
-
-        default:
-            REPORT_ERROR(MINOR, E_INVALID_STATE, ("Unsupported type of counter"));
-            return 0;
     }
+    return 0;
 }
 
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
@@ -1824,15 +1820,12 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
             case (e_FM_PCD_PLCR_EXCEPTION_ATOMIC_ACTION_COMPLETE):
                 if (!p_FmPcd->p_FmPcdPlcr)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - policer is not working"));
-            break;
+                break;
             case (e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC):
             case (e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC):
                 if (!p_FmPcd->p_FmPcdPrs)
                     RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt - parser is not working"));
-            break;
-            default:
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
-
+                break;
         }
 
         switch (exception)
@@ -1901,24 +1894,20 @@ t_Error FM_PCD_SetException(t_Handle h_FmPcd, e_FmPcdExceptions exception, bool
                     tmpReg &= ~FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE;
                 WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ier, tmpReg);
                 break;
-             default:
-                RETURN_ERROR(MINOR, E_INVALID_STATE, ("Unsupported exception"));
         }
         /* for ECC exceptions driver automatically enables ECC mechanism, if disabled.
            Driver may disable them automatically, depending on driver's status */
-        if (enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if (enable && ((exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
             FmEnableRamsEcc(p_FmPcd->h_Fm);
-        if (!enable && ( (exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
+        if (!enable && ((exception == e_FM_PCD_KG_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PLCR_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_DOUBLE_ECC) |
                        (exception == e_FM_PCD_PRS_EXCEPTION_SINGLE_ECC)))
             FmDisableRamsEcc(p_FmPcd->h_Fm);
     }
-    else
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
     return E_OK;
 }
@@ -1953,8 +1942,7 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
                 RETURN_ERROR(MINOR, E_INVALID_STATE, ("Can't ask for this interrupt -parsrer is not working"));
             break;
         default:
-            RETURN_ERROR(MINOR, E_INVALID_STATE, ("Invalid interrupt requested"));
-
+            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid interrupt requested"));
     }
     switch (exception)
     {
@@ -1996,8 +1984,6 @@ t_Error FM_PCD_ForceIntr (t_Handle h_FmPcd, e_FmPcdExceptions exception)
                 RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception is masked"));
             WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_ifr, FM_PCD_PLCR_ATOMIC_ACTION_COMPLETE);
             break;
-        default:
-            RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
     }
 
     return E_OK;
@@ -2130,11 +2116,9 @@ t_Error FM_PCD_ModifyCounter(t_Handle h_FmPcd, e_FmPcdCounters counter, uint32_t
         case (e_FM_PCD_PLCR_COUNTERS_LENGTH_MISMATCH):
               WRITE_UINT32(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_flmcnt, value);
             break;
-        default:
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Unsupported type of counter"));
     }
 
-return E_OK;
+    return E_OK;
 }
 
 t_Handle FM_PCD_GetHcPort(t_Handle h_FmPcd)
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
index 138145f..27ec9c5 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_pcd.h
@@ -127,7 +127,7 @@ switch (exception){                                                 \
 #endif /* defined(__MWERKS__) && ... */
 
 
-typedef _Packed struct {
+typedef struct {
 /* General Configuration and Status Registers */
     volatile uint32_t fmpl_gcr;         /* 0x000 FMPL_GCR  - FM Policer General Configuration */
     volatile uint32_t fmpl_gsr;         /* 0x004 FMPL_GSR  - FM Policer Global Status Register */
@@ -158,7 +158,7 @@ typedef _Packed struct {
     volatile uint32_t fmpl_dpmr;        /* 0x200 FMPL_DPMR - FM Policer Default Mapping Register */
     volatile uint32_t fmpl_pmr[63];     /*+default 0x204-0x2FF FMPL_PMR1 - FMPL_PMR63, - FM Policer Profile Mapping Registers.
                                            (for port-ID 1-11, only for supported Port-ID registers) */
-} _PackedType t_FmPcdPlcrRegs;
+} t_FmPcdPlcrRegs;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
@@ -238,11 +238,11 @@ typedef struct {
 #endif
 } t_FmPcdKgScheme;
 
-typedef _Packed union {
+typedef union {
     struct fman_kg_scheme_regs schemeRegs;
     struct fman_kg_pe_regs portRegs;
     struct fman_kg_cp_regs clsPlanRegs;
-} _PackedType u_FmPcdKgIndirectAccessRegs;
+} u_FmPcdKgIndirectAccessRegs;
 
 typedef struct {
     struct fman_kg_regs *p_FmPcdKgRegs;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_plcr.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_plcr.c
index e4eeddc..a28b363 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_plcr.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_plcr.c
@@ -216,7 +216,7 @@ static void GetInfoRateReg(e_FmPcdPlcrRateMode  rateMode,
 
 /* .......... */
 
-static void CalcRates(t_Handle                              h_FmPcd,
+static void CalcRates(uint32_t                              bitFor1Micro,
                       t_FmPcdPlcrNonPassthroughAlgParams    *p_NonPassthroughAlgParam,
                       uint32_t                              *cir,
                       uint32_t                              *cbs,
@@ -224,14 +224,12 @@ static void CalcRates(t_Handle                              h_FmPcd,
                       uint32_t                              *pbs_ebs,
                       uint32_t                              *fpp)
 {
-    t_FmPcd     *p_FmPcd = (t_FmPcd*)h_FmPcd;
     uint64_t    integer, fraction;
-    uint32_t    temp, tsuInTenthNanos, bitFor1Micro;
+    uint32_t    temp, tsuInTenthNanos;
     uint8_t     fppShift=0;
 
-    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);  /* TimeStamp per nano seconds units */
     /* we want the tsu to count 10 nano for better precision normally tsu is 3.9 nano, now we will get 39 */
-    tsuInTenthNanos = (uint32_t)(1000*10/(1<<bitFor1Micro));
+    tsuInTenthNanos = (uint32_t)(1000*10/(1 << bitFor1Micro));
 
     /* we choose the faster rate to calibrate fpp */
     /* The meaning of this step:
@@ -337,10 +335,14 @@ static t_Error BuildProfileRegs(t_FmPcd                     *p_FmPcd,
                                 t_FmPcdPlcrProfileRegs      *p_PlcrRegs)
 {
     t_Error                 err = E_OK;
-    uint32_t                pemode, gnia, ynia, rnia;
+    uint32_t                pemode, gnia, ynia, rnia, bitFor1Micro;
 
     ASSERT_COND(p_FmPcd);
 
+    bitFor1Micro = FmGetTimeStampScale(p_FmPcd->h_Fm);
+    if (bitFor1Micro == 0)
+    RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Timestamp scale"));
+
 /* Set G, Y, R Nia */
     err = SetProfileNia(p_FmPcd, p_ProfileParams->nextEngineOnGreen,  &(p_ProfileParams->paramsOnGreen), &gnia);
     if (err)
@@ -485,7 +487,7 @@ cont_rfc:
             {
                 uint32_t cir=0, cbs=0, pir_eir=0, pbs_ebs=0, fpp=0;
 
-                CalcRates(p_FmPcd, &p_ProfileParams->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
+                CalcRates(bitFor1Micro, &p_ProfileParams->nonPassthroughAlgParams, &cir, &cbs, &pir_eir, &pbs_ebs, &fpp);
 
                 /*  Set Committed Information Rate (CIR) */
                 p_PlcrRegs->fmpl_pecir = cir;
@@ -1562,7 +1564,6 @@ t_Error FM_PCD_PlcrDumpRegs(t_Handle h_FmPcd)
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_rypcnt);
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_tpcnt);
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_flmcnt);
-
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_serc);
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_upcr);
     DUMP_VAR(p_FmPcd->p_FmPcdPlcr->p_FmPcdPlcrRegs,fmpl_dpmr);
@@ -1625,6 +1626,11 @@ t_Handle FM_PCD_PlcrProfileSet(t_Handle     h_FmPcd,
                                                     p_ProfileParams->id.newParams.h_FmPort,
                                                     p_ProfileParams->id.newParams.relativeProfileId,
                                                     &absoluteProfileId);
+        if (err)
+        {
+             REPORT_ERROR(MAJOR, err, NO_MSG);
+             return NULL;
+        }
 
          if (absoluteProfileId >= FM_PCD_PLCR_NUM_ENTRIES)
          {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c
index 73f3b223..e6ac6df 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_prs.c
@@ -118,6 +118,12 @@ t_Handle PrsConfig(t_FmPcd *p_FmPcd,t_FmPcdParams *p_FmPcdParams)
     return p_FmPcdPrs;
 }
 
+#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
+    static uint8_t             swPrsPatch[] = SW_PRS_UDP_LITE_PATCH;
+#else
+    static uint8_t             swPrsPatch[] = SW_PRS_OFFLOAD_PATCH;
+#endif /* FM_CAPWAP_SUPPORT */
+
 t_Error PrsInit(t_FmPcd *p_FmPcd)
 {
     t_FmPcdDriverParam  *p_Param = p_FmPcd->p_FmPcdDriverParam;
@@ -125,11 +131,6 @@ t_Error PrsInit(t_FmPcd *p_FmPcd)
     uint32_t            *p_LoadTarget = (uint32_t *)PTR_MOVE(p_FmPcd->p_FmPcdPrs->p_SwPrsCode,
                                                              FM_PCD_SW_PRS_SIZE-FM_PCD_PRS_SW_PATCHES_SIZE);
     struct fman_prs_regs *PrsRegs = (struct fman_prs_regs *)p_FmPcd->p_FmPcdPrs->p_FmPcdPrsRegs;
-#if ((DPAA_VERSION == 10) && defined(FM_CAPWAP_SUPPORT))
-    uint8_t             swPrsPatch[] = SW_PRS_UDP_LITE_PATCH;
-#else
-    uint8_t             swPrsPatch[] = SW_PRS_OFFLOAD_PATCH;
-#endif /* FM_CAPWAP_SUPPORT */
     uint32_t            i;
 
     ASSERT_COND(sizeof(swPrsPatch) <= (FM_PCD_PRS_SW_PATCHES_SIZE-FM_PCD_PRS_SW_TAIL_SIZE));
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c
index 7f84080..ee82f73 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.c
@@ -380,10 +380,11 @@ static t_Error AllocMember(t_FmPcdFrmReplicGroup *p_ReplicGroup)
         (t_AdOfTypeResult*)FM_MURAM_AllocMem(h_Muram,
                                              FM_PCD_CC_AD_ENTRY_SIZE,
                                              FM_PCD_CC_AD_TABLE_ALIGN);
-
     if (!p_CurrentMember->p_MemberAd)
+    {
+        XX_Free(p_CurrentMember);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, ("member AD table"));
-
+    }
     IOMemSet32((uint8_t*)p_CurrentMember->p_MemberAd, 0, FM_PCD_CC_AD_ENTRY_SIZE);
 
     /* Add the new member to the available members list */
@@ -591,7 +592,6 @@ static void DeleteGroup(t_FmPcdFrmReplicGroup *p_ReplicGroup)
 
         /* free the replicator group */
         XX_Free(p_ReplicGroup);
-        p_ReplicGroup = NULL;
     }
 }
 
@@ -833,13 +833,8 @@ t_Error FM_PCD_FrmReplicAddMember(t_Handle                  h_ReplicGroup,
 
     /* group lock */
     err = FrmReplicGroupTryLock(p_ReplicGroup);
-    if (err)
-    {
-        if (GET_ERROR_TYPE(err) == E_BUSY)
-            return ERROR_CODE(E_BUSY);
-        else
-            RETURN_ERROR(MAJOR, err, ("try lock in Add member"));
-    }
+    if (GET_ERROR_TYPE(err) == E_BUSY)
+        return ERROR_CODE(E_BUSY);
 
     if (memberIndex > p_ReplicGroup->numOfEntries)
     {
@@ -954,13 +949,8 @@ t_Error FM_PCD_FrmReplicRemoveMember(t_Handle   h_ReplicGroup,
 
     /* lock */
     err = FrmReplicGroupTryLock(p_ReplicGroup);
-    if (err)
-    {
-        if (GET_ERROR_TYPE(err) == E_BUSY)
-            return ERROR_CODE(E_BUSY);
-        else
-            RETURN_ERROR(MAJOR, err, ("try lock in Remove member"));
-    }
+    if (GET_ERROR_TYPE(err) == E_BUSY)
+        return ERROR_CODE(E_BUSY);
 
     if (memberIndex >= p_ReplicGroup->numOfEntries)
         RETURN_ERROR(MAJOR, E_INVALID_SELECTION, ("member index to remove"));
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.h
index 7e4224b..0e8e8bc 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fm_replic.h
@@ -68,13 +68,13 @@
 } e_SourceTdOption;
 */
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t type;
     volatile uint32_t frGroupPointer;
     volatile uint32_t operationCode;
     volatile uint32_t reserved;
-} _PackedType t_FrmReplicGroupSourceAd;
+} t_FrmReplicGroupSourceAd;
 
 typedef struct t_FmPcdFrmReplicMember
 {
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fman_kg.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fman_kg.c
index 6e77c9386..49b86e8 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fman_kg.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Pcd/fman_kg.c
@@ -267,7 +267,7 @@ void fman_kg_write_sp(struct fman_kg_regs *regs, uint32_t sp, bool add)
 
 	struct fman_kg_pe_regs *kgpe_regs;
 	uint32_t tmp;
-	
+
 	kgpe_regs = (struct fman_kg_pe_regs *)&(regs->fmkg_indirect[0]);
 	tmp = ioread32be(&kgpe_regs->fmkg_pe_sp);
 
@@ -283,7 +283,7 @@ void fman_kg_write_sp(struct fman_kg_regs *regs, uint32_t sp, bool add)
 void fman_kg_write_cpp(struct fman_kg_regs *regs, uint32_t cpp)
 {
 	struct fman_kg_pe_regs *kgpe_regs;
-	
+
 	kgpe_regs = (struct fman_kg_pe_regs *)&(regs->fmkg_indirect[0]);
 
 	iowrite32be(cpp, &kgpe_regs->fmkg_pe_cpp);
@@ -318,7 +318,7 @@ void fman_kg_init(struct fman_kg_regs *regs,
 {
 	uint32_t tmp;
 	int i;
-	
+
 	iowrite32be(FM_EX_KG_DOUBLE_ECC | FM_EX_KG_KEYSIZE_OVERFLOW,
 			&regs->fmkg_eer);
 
@@ -328,7 +328,7 @@ void fman_kg_init(struct fman_kg_regs *regs,
 
 	if (exceptions & FM_EX_KG_KEYSIZE_OVERFLOW)
 		tmp |= FM_EX_KG_KEYSIZE_OVERFLOW;
-	
+
 	iowrite32be(tmp, &regs->fmkg_eeer);
 	iowrite32be(0, &regs->fmkg_fdor);
 	iowrite32be(0, &regs->fmkg_gdv0r);
@@ -471,7 +471,7 @@ int fman_kg_build_scheme(struct fman_kg_scheme_params *params,
 		tmp_reg |= (uint32_t)params->cc_params.base_offset <<
 				FMAN_KG_SCH_MODE_CCOBASE_SHIFT;
 	}
-	
+
 	tmp_reg |= FMAN_KG_SCH_MODE_EN;
 	scheme_regs->kgse_mode = tmp_reg;
 
@@ -644,7 +644,7 @@ int fman_kg_build_scheme(struct fman_kg_scheme_params *params,
 
 	/* Policer Profile register */
 	if (params->policer_params.bypass_pp_gen) {
-		tmp_reg = FMAN_KG_SCH_PP_NO_GEN;
+		tmp_reg = 0;
 	} else {
 		/* Lower 8 bits of 24-bits extracted from hash result
 		 * are used for policer profile generation.
@@ -862,7 +862,7 @@ int fman_kg_build_bind_cls_plans(uint8_t grp_base,
 					uint32_t *bind_cls_plans)
 {
 	/* Check grp_base and grp_mask are 5-bits values */
-	if ((grp_base & ~0x0000001F) || (grp_mask & !0x0000001F))
+	if ((grp_base & ~0x0000001F) || (grp_mask & ~0x0000001F))
 		return -EINVAL;
 
 	*bind_cls_plans = (uint32_t) ((grp_mask << FMAN_KG_PE_CPP_MASK_SHIFT) | grp_base);
@@ -879,7 +879,7 @@ int fman_kg_write_bind_cls_plans(struct fman_kg_regs *regs,
 	int err;
 
 	kg_pe_regs = (struct fman_kg_pe_regs *)&(regs->fmkg_indirect[0]);
-	
+
 	iowrite32be(bind_cls_plans, &kg_pe_regs->fmkg_pe_cpp);
 
 	tmp_reg = build_ar_bind_cls_plan(hwport_id, TRUE);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
index 78ecab5..dc62655 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.c
@@ -101,7 +101,7 @@ static t_Error CheckInitParameters(t_FmPort *p_FmPort)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                              ("intContext.size is larger than start margins"));
 
-            if ((p_Params->liodnOffset != DPAA_LIODN_DONT_OVERRIDE)
+            if ((p_Params->liodnOffset != (uint16_t)DPAA_LIODN_DONT_OVERRIDE)
                     && (p_Params->liodnOffset & ~FM_LIODN_OFFSET_MASK))
                 RETURN_ERROR(
                         MAJOR,
@@ -520,10 +520,11 @@ static t_Error VerifySizeOfFifo(t_FmPort *p_FmPort)
 
     /* Verify the size  */
     if (p_FmPort->fifoBufs.num < minFifoSizeRequired)
-        DBG(INFO, ("FIFO size should be enlarged to %d bytes", minFifoSizeRequired));
+        DBG(INFO,
+	    ("FIFO size is %d and should be enlarged to %d bytes",p_FmPort->fifoBufs.num, minFifoSizeRequired));
     else if (p_FmPort->fifoBufs.num < optFifoSizeForB2B)
-            DBG(INFO, ("For back-to-back frames processing, FIFO size may need to be enlarged to %d bytes", optFifoSizeForB2B));
-
+        DBG(INFO,
+	    ("For back-to-back frames processing, FIFO size is %d and needs to enlarge to %d bytes", p_FmPort->fifoBufs.num, optFifoSizeForB2B));
 
     return E_OK;
 }
@@ -887,6 +888,7 @@ static t_Error BmiPortCheckAndGetCounterType(
         case (e_FM_PORT_COUNTERS_FIFO_UTIL):
         case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             /* performance counters - may be read when disabled */
+            *p_IsStats = FALSE;
             break;
         case (e_FM_PORT_COUNTERS_FRAME):
         case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
@@ -899,6 +901,7 @@ static t_Error BmiPortCheckAndGetCounterType(
         case (e_FM_PORT_COUNTERS_LENGTH_ERR):
         case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
         case (e_FM_PORT_COUNTERS_WRED_DISCARD):
+            *p_IsStats = TRUE;
             if (!(GET_UINT32(*p_Reg) & BMI_COUNTERS_EN))
                 RETURN_ERROR(MINOR, E_INVALID_STATE,
                              ("Requested counter was not enabled"));
@@ -912,67 +915,55 @@ static t_Error BmiPortCheckAndGetCounterType(
     {
         case (e_FM_PORT_COUNTERS_CYCLE):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_CYCLE;
-            *p_IsStats = FALSE;
             break;
         case (e_FM_PORT_COUNTERS_TASK_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_TASK_UTIL;
             break;
         case (e_FM_PORT_COUNTERS_QUEUE_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_QUEUE_UTIL;
-            *p_IsStats = FALSE;
             break;
         case (e_FM_PORT_COUNTERS_DMA_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_DMA_UTIL;
-            *p_IsStats = FALSE;
             break;
         case (e_FM_PORT_COUNTERS_FIFO_UTIL):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_FIFO_UTIL;
-            *p_IsStats = FALSE;
             break;
         case (e_FM_PORT_COUNTERS_RX_PAUSE_ACTIVATION):
             *p_PerfType = E_FMAN_PORT_PERF_CNT_RX_PAUSE;
-            *p_IsStats = FALSE;
             break;
         case (e_FM_PORT_COUNTERS_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_FRAME;
-            *p_IsStats = TRUE;
             break;
         case (e_FM_PORT_COUNTERS_DISCARD_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_DISCARD;
-            *p_IsStats = TRUE;
             break;
         case (e_FM_PORT_COUNTERS_DEALLOC_BUF):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_DEALLOC_BUF;
-            *p_IsStats = TRUE;
             break;
         case (e_FM_PORT_COUNTERS_RX_BAD_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_BAD_FRAME;
-            *p_IsStats = TRUE;
             break;
         case (e_FM_PORT_COUNTERS_RX_LARGE_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_LARGE_FRAME;
-            *p_IsStats = TRUE;
             break;
         case (e_FM_PORT_COUNTERS_RX_OUT_OF_BUFFERS_DISCARD):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_RX_OUT_OF_BUF;
-            *p_IsStats = TRUE;
             break;
         case (e_FM_PORT_COUNTERS_RX_FILTER_FRAME):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_FILTERED_FRAME;
             break;
         case (e_FM_PORT_COUNTERS_RX_LIST_DMA_ERR):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_DMA_ERR;
-            *p_IsStats = TRUE;
             break;
         case (e_FM_PORT_COUNTERS_WRED_DISCARD):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_WRED_DISCARD;
-            *p_IsStats = TRUE;
+            break;
         case (e_FM_PORT_COUNTERS_LENGTH_ERR):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_LEN_ERR;
-            *p_IsStats = TRUE;
+            break;
         case (e_FM_PORT_COUNTERS_UNSUPPRTED_FORMAT):
             *p_StatsType = E_FMAN_PORT_STATS_CNT_UNSUPPORTED_FORMAT;
-            *p_IsStats = TRUE;
+            break;
         default:
             break;
     }
@@ -1006,10 +997,10 @@ static t_Error AdditionalPrsParams(t_FmPort *p_FmPort,
             case (HEADER_TYPE_MPLS):
                 if (p_prsOpts->mplsPrsOptions.labelInterpretationEnable)
                     tmpReg |= PRS_HDR_MPLS_LBL_INTER_EN;
-                GET_PRS_HDR_NUM(hdrNum, p_prsOpts->mplsPrsOptions.nextParse);
+                hdrNum = GetPrsHdrNum(p_prsOpts->mplsPrsOptions.nextParse);
                 if (hdrNum == ILLEGAL_HDR_NUM)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
-                GET_PRS_HDR_NUM(Ipv4HdrNum, HEADER_TYPE_IPv4);
+                Ipv4HdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
                 if (hdrNum < Ipv4HdrNum)
                     RETURN_ERROR(MAJOR, E_INVALID_VALUE,
                                  ("Header must be equal or higher than IPv4"));
@@ -1351,7 +1342,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         {
 #endif /* (DPAA_VERSION >= 11) */
             /* if PRS is used it is always first */
-            GET_PRS_HDR_NUM(hdrNum, p_PcdParams->p_PrsParams->firstPrsHdr);
+                hdrNum = GetPrsHdrNum(p_PcdParams->p_PrsParams->firstPrsHdr);
             if (hdrNum == ILLEGAL_HDR_NUM)
                 RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header."));
 #if (DPAA_VERSION >= 11)
@@ -1421,47 +1412,47 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
             switch (p_FmPort->optArray[i])
             {
                 case (ETH_BROADCAST):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_ETH);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_ETH_BC_SHIFT;
                     break;
                 case (ETH_MULTICAST):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_ETH)
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_ETH);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_ETH_MC_SHIFT;
                     break;
                 case (VLAN_STACKED):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_VLAN)
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_VLAN);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_VLAN_STACKED_SHIFT;
                     break;
                 case (MPLS_STACKED):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_MPLS);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_MPLS_STACKED_SHIFT;
                     break;
                 case (IPV4_BROADCAST_1):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_1_BC_SHIFT;
                     break;
                 case (IPV4_MULTICAST_1):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_1_MC_SHIFT;
                     break;
                 case (IPV4_UNICAST_2):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+					hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_2_UC_SHIFT;
                     break;
                 case (IPV4_MULTICAST_BROADCAST_2):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+					hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV4_2_MC_BC_SHIFT;
                     break;
                 case (IPV6_MULTICAST_1):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV6_1_MC_SHIFT;
                     break;
                 case (IPV6_UNICAST_2):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV6_2_UC_SHIFT;
                     break;
                 case (IPV6_MULTICAST_2):
-                    GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+                    hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
                     tmpHxs[hdrNum] |= (i + 1) << PRS_HDR_IPV6_2_MC_SHIFT;
                     break;
             }
@@ -1469,6 +1460,11 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         if (FmPcdNetEnvIsHdrExist(p_FmPort->h_FmPcd, p_FmPort->netEnvId,
                                   HEADER_TYPE_UDP_ENCAP_ESP))
         {
+            if (p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams == FM_PCD_PRS_NUM_OF_HDRS)
+                RETURN_ERROR(
+                         MINOR, E_INVALID_VALUE,
+                         ("If HEADER_TYPE_UDP_ENCAP_ESP is used, numOfHdrsWithAdditionalParams may be up to FM_PCD_PRS_NUM_OF_HDRS - 1"));
+
             p_PcdParams->p_PrsParams->additionalParams[p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].hdr =
                     HEADER_TYPE_UDP;
             p_PcdParams->p_PrsParams->additionalParams[p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams].swPrsEnable =
@@ -1477,28 +1473,28 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         }
 
         /* set MPLS default next header - HW reset workaround  */
-        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_MPLS)
+        hdrNum = GetPrsHdrNum(HEADER_TYPE_MPLS);
         tmpHxs[hdrNum] |= PRS_HDR_MPLS_LBL_INTER_EN;
-        GET_PRS_HDR_NUM(L3HdrNum, HEADER_TYPE_USER_DEFINED_L3);
+        L3HdrNum = GetPrsHdrNum(HEADER_TYPE_USER_DEFINED_L3);
         tmpHxs[hdrNum] |= (uint32_t)L3HdrNum << PRS_HDR_MPLS_NEXT_HDR_SHIFT;
 
         /* for GRE, disable errors */
-        GET_PRS_HDR_NUM(greHdrNum, HEADER_TYPE_GRE);
+        greHdrNum = GetPrsHdrNum(HEADER_TYPE_GRE);
         tmpHxs[greHdrNum] |= PRS_HDR_ERROR_DIS;
 
         /* For UDP remove PAD from L4 checksum calculation */
-        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_UDP);
+        hdrNum = GetPrsHdrNum(HEADER_TYPE_UDP);
         tmpHxs[hdrNum] |= PRS_HDR_UDP_PAD_REMOVAL;
         /* For TCP remove PAD from L4 checksum calculation */
-        GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_TCP);
+        hdrNum = GetPrsHdrNum(HEADER_TYPE_TCP);
         tmpHxs[hdrNum] |= PRS_HDR_TCP_PAD_REMOVAL;
 
         /* config additional params for specific headers */
         for (i = 0; i < p_PcdParams->p_PrsParams->numOfHdrsWithAdditionalParams;
                 i++)
         {
-            GET_PRS_HDR_NUM( hdrNum,
-                            p_PcdParams->p_PrsParams->additionalParams[i].hdr);
+            hdrNum =
+                GetPrsHdrNum(p_PcdParams->p_PrsParams->additionalParams[i].hdr);
             if (hdrNum == ILLEGAL_HDR_NUM)
                 RETURN_ERROR(MAJOR, E_INVALID_VALUE, NO_MSG);
             if (hdrNum == NO_HDR_NUM)
@@ -1517,7 +1513,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
         if (p_FmPort->h_IpReassemblyManip)
         {
             /* link to sw parser code for IP Frag - only if no other code is applied. */
-            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv4)
+            hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv4);
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
                 tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN
                         | OFFLOAD_SW_PATCH_IPv4_LABEL);
@@ -1530,7 +1526,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
                         && (p_FmPort->portType
                                 == e_FM_PORT_TYPE_OH_OFFLINE_PARSING)))
         {
-            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+            hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
                 tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN
                         | OFFLOAD_SW_PATCH_IPv6_LABEL);
@@ -1541,7 +1537,7 @@ static t_Error SetPcd(t_FmPort *p_FmPort, t_FmPortPcdParams *p_PcdParams)
                         HEADER_TYPE_UDP_LITE))
         {
             /* link to sw parser code for udp lite - only if no other code is applied. */
-            GET_PRS_HDR_NUM(hdrNum, HEADER_TYPE_IPv6)
+            hdrNum = GetPrsHdrNum(HEADER_TYPE_IPv6);
             if (!(tmpHxs[hdrNum] & PRS_HDR_SW_PRS_EN))
             tmpHxs[hdrNum] |= (PRS_HDR_SW_PRS_EN | UDP_LITE_SW_PATCH_LABEL);
         }
@@ -1651,7 +1647,7 @@ static t_Error DeletePcd(t_FmPort *p_FmPort)
     /* "cut" PCD out of the port's flow - go to BMI */
     /* WRITE_UINT32(*p_BmiNia, (p_FmPort->savedBmiNia & BMI_RFNE_FDCS_MASK) | (NIA_ENG_BMI | NIA_BMI_AC_ENQ_FRAME)); */
 
-    if (p_FmPort->pcdEngines | FM_PCD_PRS)
+    if (p_FmPort->pcdEngines & FM_PCD_PRS)
     {
         WRITE_UINT32(*p_BmiPrsStartOffset, 0);
 
@@ -2221,8 +2217,8 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
     FM_GetRevision(p_FmPort->h_Fm, &p_FmPort->fmRevInfo);
 
     /* calculate global portId number */
-    SW_PORT_ID_TO_HW_PORT_ID(p_FmPort->hardwarePortId, p_FmPort->portType,
-                             p_FmPortParams->portId);
+    p_FmPort->hardwarePortId = SwPortIdToHwPortId(p_FmPort->portType,
+                                    p_FmPortParams->portId);
 
     if (p_FmPort->fmRevInfo.majorRev >= 6)
     {
@@ -2313,49 +2309,16 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
 
     p_FmPort->maxFrameLength = DEFAULT_PORT_maxFrameLength;
     /* resource distribution. */
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-    {
-        p_FmPort->fifoBufs.num = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)
-                * BMI_FIFO_UNITS;
-        p_FmPort->fifoBufs.extra = DEFAULT_PORT_extraNumOfFifoBufs
-                * BMI_FIFO_UNITS;
-        p_FmPort->openDmas.num = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
-        p_FmPort->openDmas.extra =
-                DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
-        p_FmPort->tasks.num = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
-        p_FmPort->tasks.extra = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
-    }
-    else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-    {
-        if ((p_FmPort->portType == e_FM_PORT_TYPE_OH_HOST_COMMAND)
-                && (p_FmPortParams->portId != FM_OH_PORT_ID))
-        {
-            /* Overwrite HC defaults */
-            p_FmPort->fifoBufs.num =
-                    DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)
-                            * BMI_FIFO_UNITS;
-            p_FmPort->fifoBufs.extra = DEFAULT_PORT_extraNumOfFifoBufs
-                    * BMI_FIFO_UNITS;
-            p_FmPort->openDmas.num =
-                    DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
-            p_FmPort->openDmas.extra =
-                    DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
-            p_FmPort->tasks.num = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
-            p_FmPort->tasks.extra =
-                    DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
-        }
-        else
-        {
-            p_FmPort->fifoBufs.num = 0;
-            p_FmPort->fifoBufs.extra = 0;
-            p_FmPort->openDmas.num = 0;
-            p_FmPort->openDmas.extra = 0;
-            p_FmPort->tasks.num = 0;
-            p_FmPort->tasks.extra = 0;
-        }
-    }
+	p_FmPort->fifoBufs.num = DEFAULT_PORT_numOfFifoBufs(p_FmPort->portType)
+			* BMI_FIFO_UNITS;
+	p_FmPort->fifoBufs.extra = DEFAULT_PORT_extraNumOfFifoBufs
+			* BMI_FIFO_UNITS;
+	p_FmPort->openDmas.num = DEFAULT_PORT_numOfOpenDmas(p_FmPort->portType);
+	p_FmPort->openDmas.extra =
+			DEFAULT_PORT_extraNumOfOpenDmas(p_FmPort->portType);
+	p_FmPort->tasks.num = DEFAULT_PORT_numOfTasks(p_FmPort->portType);
+	p_FmPort->tasks.extra = DEFAULT_PORT_extraNumOfTasks(p_FmPort->portType);
+
 
 #ifdef FM_HEAVY_TRAFFIC_SEQUENCER_HANG_ERRATA_FMAN_A006981
     if ((p_FmPort->fmRevInfo.majorRev == 6)
@@ -2379,27 +2342,16 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             p_FmPort->p_FmPortDriverParam->enBufPoolDepletion = FALSE;
             p_FmPort->p_FmPortDriverParam->frmDiscardOverride =
                     DEFAULT_PORT_frmDiscardOverride;
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-            if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-            {
-                p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel =
-                        DEFAULT_PORT_rxFifoPriElevationLevel;
-                p_FmPort->p_FmPortDriverParam->rxFifoThreshold =
-                        DEFAULT_PORT_rxFifoThreshold;
-            }
-            else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-            {
+
                 tmpReg =
                         GET_UINT32(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rfp);
-                p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel =
+			p_FmPort->p_FmPortDriverParam->rxFifoPriElevationLevel =
                         (((tmpReg & BMI_RX_FIFO_PRI_ELEVATION_MASK)
                                 >> BMI_RX_FIFO_PRI_ELEVATION_SHIFT) + 1)
                                 * BMI_FIFO_UNITS;
                 p_FmPort->p_FmPortDriverParam->rxFifoThreshold = (((tmpReg
                         & BMI_RX_FIFO_THRESHOLD_MASK)
                         >> BMI_RX_FIFO_THRESHOLD_SHIFT) + 1) * BMI_FIFO_UNITS;
-            }
 
             p_FmPort->p_FmPortDriverParam->bufMargins.endMargins =
                     DEFAULT_PORT_BufMargins_endMargins;
@@ -2421,33 +2373,17 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
                          tmpReg);
 #endif /* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 */
         case (e_FM_PORT_TYPE_TX_10G):
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-            if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-            {
-                p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel =
-                        DEFAULT_PORT_txFifoMinFillLevel;
-                p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
-                        (uint8_t)(
-                                (p_FmPort->portType == e_FM_PORT_TYPE_TX) ? DEFAULT_PORT_fifoDeqPipelineDepth_1G :
-                                        DEFAULT_PORT_fifoDeqPipelineDepth_10G);
-                p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel =
-                        DEFAULT_PORT_txFifoLowComfLevel;
-            }
-            else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-            {
                 tmpReg =
                         GET_UINT32(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tfp);
                 p_FmPort->p_FmPortDriverParam->txFifoMinFillLevel = ((tmpReg
                         & BMI_TX_FIFO_MIN_FILL_MASK)
                         >> BMI_TX_FIFO_MIN_FILL_SHIFT) * BMI_FIFO_UNITS;
-                p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+			p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
                         (uint8_t)(((tmpReg & BMI_FIFO_PIPELINE_DEPTH_MASK)
                                 >> BMI_FIFO_PIPELINE_DEPTH_SHIFT) + 1);
                 p_FmPort->p_FmPortDriverParam->txFifoLowComfLevel = (((tmpReg
                         & BMI_TX_LOW_COMF_MASK) >> BMI_TX_LOW_COMF_SHIFT) + 1)
                         * BMI_FIFO_UNITS;
-            }
 
             p_FmPort->p_FmPortDriverParam->deqType = DEFAULT_PORT_deqType;
             p_FmPort->p_FmPortDriverParam->deqPrefetchOption =
@@ -2476,13 +2412,6 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
             p_FmPort->p_FmPortDriverParam->deqByteCnt =
                     DEFAULT_PORT_deqByteCnt_1G;
 
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-            if (1) /* if (p_FmPort->fmRevInfo.majorRev < 6) */
-                p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
-                        DEFAULT_PORT_fifoDeqPipelineDepth_OH;
-            else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-            {
                 tmpReg =
                         GET_UINT32(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_ofp);
                 p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
@@ -2492,10 +2421,9 @@ t_Handle FM_PORT_Config(t_FmPortParams *p_FmPortParams)
                         && (p_FmPortParams->portId != FM_OH_PORT_ID))
                 {
                     /* Overwrite HC defaults */
-                    p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
-                            DEFAULT_PORT_fifoDeqPipelineDepth_OH;
+			p_FmPort->p_FmPortDriverParam->dfltCfg.tx_fifo_deq_pipeline_depth =
+					DEFAULT_PORT_fifoDeqPipelineDepth_OH;
                 }
-            }
 
 #ifndef FM_FRAME_END_PARAMS_FOR_OP
             if (p_FmPort->fmRevInfo.majorRev < 6)
@@ -2733,7 +2661,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
     }
 #endif /* !FM_DEQ_PIPELINE_PARAMS_FOR_OP */
 
-
     errCode = FmGetSetPortParams(p_FmPort->h_Fm, &fmParams);
     if (errCode)
         RETURN_ERROR(MAJOR, errCode, NO_MSG);
@@ -2744,18 +2671,6 @@ t_Error FM_PORT_Init(t_Handle h_FmPort)
                     | ((uint64_t)(fmParams.fmMuramPhysBaseAddr.high) << 32));
     p_FmPort->h_FmMuram = FmGetMuramHandle(p_FmPort->h_Fm);
 
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-    if (p_FmPort->fmRevInfo.majorRev >= 6)
-    {
-        p_FmPort->tasks.num = fmParams.numOfTasks;
-        p_FmPort->tasks.extra = fmParams.numOfExtraTasks;
-        p_FmPort->openDmas.num = fmParams.numOfOpenDmas;
-        p_FmPort->openDmas.extra = fmParams.numOfExtraOpenDmas;
-        p_FmPort->fifoBufs.num = fmParams.sizeOfFifo;
-        p_FmPort->fifoBufs.extra = fmParams.extraSizeOfFifo;
-    }
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-
     errCode = InitLowLevelDriver(p_FmPort);
     if (errCode != E_OK)
         RETURN_ERROR(MAJOR, errCode, NO_MSG);
@@ -2836,6 +2751,7 @@ t_Error FM_PORT_Free(t_Handle h_FmPort)
     if (p_FmPort->imEn)
         FmPortImFree(p_FmPort);
 
+    memset(&fmParams, 0, sizeof(fmParams));
     fmParams.hardwarePortId = p_FmPort->hardwarePortId;
     fmParams.portType = (e_FmPortType)p_FmPort->portType;
     if (p_FmPort->p_FmPortDriverParam)
@@ -3135,7 +3051,7 @@ t_Error FM_PORT_ConfigSyncReq(t_Handle h_FmPort, bool syncReq)
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
 
     if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
-            && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
                      ("Not available for Tx ports"));
 
@@ -3151,9 +3067,9 @@ t_Error FM_PORT_ConfigFrmDiscardOverride(t_Handle h_FmPort, bool override)
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(p_FmPort->p_FmPortDriverParam, E_INVALID_HANDLE);
     if ((p_FmPort->portType == e_FM_PORT_TYPE_TX_10G)
-            && (p_FmPort->portType == e_FM_PORT_TYPE_TX))
+            || (p_FmPort->portType == e_FM_PORT_TYPE_TX))
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION,
-                     ("not available for Tx ports"));
+                     ("Not available for Tx ports"));
 
     p_FmPort->p_FmPortDriverParam->dfltCfg.discard_override = override;
 
@@ -3587,6 +3503,7 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
     int err;
+
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
@@ -3601,9 +3518,9 @@ t_Error FM_PORT_Disable(t_Handle h_FmPort)
         err = E_OK;
     }
     else if (err != 0)
-    {
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_disable"));
-    }
+        {
+            RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_disable"));
+        }
 
     p_FmPort->enabled = FALSE;
 
@@ -3787,14 +3704,12 @@ t_Error FM_PORT_SetPfcPrioritiesMappingToQmanWQ(t_Handle h_FmPort, uint8_t prio,
 t_Error FM_PORT_SetFrameQueueCounters(t_Handle h_FmPort, bool enable)
 {
     t_FmPort *p_FmPort = (t_FmPort*)h_FmPort;
-    int err;
 
     SANITY_CHECK_RETURN_ERROR(p_FmPort, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(!p_FmPort->p_FmPortDriverParam, E_INVALID_STATE);
 
-    err = fman_port_set_queue_cnt_mode(&p_FmPort->port, enable);
-    if (err != 0)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("fman_port_set_perf_cnt_mode"));
+    fman_port_set_queue_cnt_mode(&p_FmPort->port, enable);
+
     return E_OK;
 }
 
@@ -4099,6 +4014,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
                 return 0;
             }
             bmiCounter = FALSE;
+            break;
         case (e_FM_PORT_COUNTERS_ENQ_TOTAL):
             bmiCounter = FALSE;
             break;
@@ -4148,8 +4064,7 @@ uint32_t FM_PORT_GetCounter(t_Handle h_FmPort, e_FmPortCounters counter)
                 queueType = E_FMAN_PORT_DEQ_CONFIRM;
                 break;
             default:
-                REPORT_ERROR(MINOR, E_INVALID_STATE, ("Requested counter is not available"));
-                return 0;
+                RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Requested counter is not available"));
         }
 
         return fman_port_get_qmi_counter(&p_FmPort->port, queueType);
@@ -4347,7 +4262,7 @@ t_Error FM_PORT_VSPAlloc(t_Handle h_FmPort, t_FmPortVSPAllocParams *p_VSPParams)
     SANITY_CHECK_RETURN_ERROR(p_VSPParams->numOfProfiles, E_INVALID_VALUE);
     /*dfltRelativeId should be in the range of numOfProfiles*/
     SANITY_CHECK_RETURN_ERROR(
-            IN_RANGE(0, p_VSPParams->dfltRelativeId, (p_VSPParams->numOfProfiles - 1)),
+            p_VSPParams->dfltRelativeId < p_VSPParams->numOfProfiles,
             E_INVALID_VALUE);
     /*p_FmPort should be from Rx type or OP*/
     SANITY_CHECK_RETURN_ERROR(
@@ -4608,7 +4523,7 @@ t_Error FM_PORT_PcdPlcrModifyInitialProfile(t_Handle h_FmPort,
         RETURN_ERROR(MAJOR, E_INVALID_OPERATION, ("Invalid profile"));
     }
 
-    tmpReg = (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
+    tmpReg |= (uint32_t)(NIA_ENG_PLCR | NIA_PLCR_ABSOLUTE | absoluteProfileId);
 
     if (p_FmPort->pcdEngines & FM_PCD_PRS) /* e_FM_PCD_SUPPORT_PRS_AND_PLCR */
     {
@@ -4904,6 +4819,7 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                                     p_PcdParams->p_CcParams->h_CcTree,
                                     p_PcdParams->h_NetEnv,
                                     p_FmPort->h_IpReassemblyManip, TRUE);
+#if (DPAA_VERSION >= 11)
         else
             if (p_FmPort->h_CapwapReassemblyManip)
                 err = FmPcdCcTreeAddCPR(p_FmPort->h_FmPcd,
@@ -4911,6 +4827,8 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                                         p_PcdParams->h_NetEnv,
                                         p_FmPort->h_CapwapReassemblyManip,
                                         TRUE);
+#endif /* (DPAA_VERSION >= 11) */
+
         if (err != E_OK)
         {
             if (p_FmPort->h_ReassemblyTree)
@@ -4997,8 +4915,6 @@ t_Error FM_PORT_SetPCD(t_Handle h_FmPort, t_FmPortPcdParams *p_PcdParam)
                 ASSERT_COND(p_ParamsPage);
                 WRITE_UINT32(p_ParamsPage->postBmiFetchNia,
                              p_FmPort->savedBmiNia);
-                XX_Print("p_ParamsPage->postBmiFetchNia 0x%x\n",
-                         GET_UINT32(p_ParamsPage->postBmiFetchNia));
             }
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -5390,7 +5306,7 @@ t_Error FM_PORT_PcdPrsModifyStartOffset(t_Handle h_FmPort,
     }
 
     /* set the first header */
-    GET_PRS_HDR_NUM(hdrNum, p_FmPcdPrsStart->firstPrsHdr);
+    hdrNum = GetPrsHdrNum(p_FmPcdPrsStart->firstPrsHdr);
     if ((hdrNum == ILLEGAL_HDR_NUM) || (hdrNum == NO_HDR_NUM))
     {
         RELEASE_LOCK(p_FmPort->lock);
@@ -5429,31 +5345,31 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
     switch (p_FmPort->portType)
     {
         case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
-        strcpy(arr, "OFFLINE-PARSING");
-        flag = 0;
-        break;
+            strcpy(arr, "OFFLINE-PARSING");
+            flag = 0;
+            break;
         case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
-        strcpy(arr, "HOST-COMMAND");
-        flag = 0;
-        break;
+            strcpy(arr, "HOST-COMMAND");
+            flag = 0;
+            break;
         case (e_FM_PORT_TYPE_RX):
-        strcpy(arr, "RX");
-        flag = 1;
-        break;
+            strcpy(arr, "RX");
+            flag = 1;
+            break;
         case (e_FM_PORT_TYPE_RX_10G):
-        strcpy(arr, "RX-10G");
-        flag = 1;
-        break;
+            strcpy(arr, "RX-10G");
+            flag = 1;
+            break;
         case (e_FM_PORT_TYPE_TX):
-        strcpy(arr, "TX");
-        flag = 2;
-        break;
+            strcpy(arr, "TX");
+            flag = 2;
+            break;
         case (e_FM_PORT_TYPE_TX_10G):
-        strcpy(arr, "TX-10G");
-        flag = 2;
-        break;
+            strcpy(arr, "TX-10G");
+            flag = 2;
+            break;
         default:
-        return ERROR_CODE(E_INVALID_VALUE);
+            return ERROR_CODE(E_INVALID_VALUE);
     }
 
     DUMP_TITLE(NULL,
@@ -5462,190 +5378,192 @@ t_Error FM_PORT_DumpRegs(t_Handle h_FmPort)
 
     err = FmDumpPortRegs(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
     if (err)
-    RETURN_ERROR(MAJOR, err, NO_MSG);
+        RETURN_ERROR(MAJOR, err, NO_MSG);
 
     DUMP_TITLE(p_FmPort->p_FmPortBmiRegs, ("Bmi Port Regs"));
 
     switch (flag)
     {
         case (0):
-
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ost);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oda);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oicp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofca);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofpne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opso);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occb);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oim);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofed);
-
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai), ("fmbm_oprai"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofqid );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oefqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsdm );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsem );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofene );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmts);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmt);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocmne);
-        {
-#ifndef FM_NO_OP_OBSERVED_POOLS
-            if (p_FmPort->fmRevInfo.majorRev == 4)
+            DUMP_SUBTITLE(("\n"));
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocfg);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ost);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oda);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oicp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdne);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofne);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofca);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofpne);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opso);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occb);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oim);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofed);
+
+            DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai), ("fmbm_oprai"));
+            DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
             {
-                DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi, ("fmbm_oebmpi"));
-
-                DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS)
+                DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oprai[i]), sizeof(uint32_t));
+            }
+            DUMP_SUBTITLE(("\n"));
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofqid );
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oefqid);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsdm );
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofsem );
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofene );
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmts);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_orlmt);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocmne);
+            {
+    #ifndef FM_NO_OP_OBSERVED_POOLS
+                if (p_FmPort->fmRevInfo.majorRev == 4)
                 {
-                    DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi[i], sizeof(uint32_t));
+                    DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi, ("fmbm_oebmpi"));
+
+                    DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_OBSERVED_EXT_POOLS)
+                    {
+                        DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_oebmpi[i], sizeof(uint32_t));
+                    }
+                    DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocgm);
                 }
-                DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ocgm);
+    #endif /* !FM_NO_OP_OBSERVED_POOLS */
             }
-#endif /* !FM_NO_OP_OBSERVED_POOLS */
-        }
 
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ostc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofrc );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdc );
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofledc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofufdc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_offc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofwdc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofldec);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opcp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occn);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_otuc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oduc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofuc);
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_odcfg), ("fmbm_odcfg"));
-        DUMP_SUBSTRUCT_ARRAY(i, 3)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_odcfg[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ogpr);
-        break;
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ostc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofrc );
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofdc );
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofledc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofufdc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_offc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofwdc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofldec);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_obdc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_opcp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_occn);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_otuc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_oduc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ofuc);
+            DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_odcfg), ("fmbm_odcfg"));
+            DUMP_SUBSTRUCT_ARRAY(i, 3)
+            {
+                DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs.fmbm_odcfg[i]), sizeof(uint32_t));
+            }
+            DUMP_SUBTITLE(("\n"));
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->ohPortBmiRegs,fmbm_ogpr);
+            break;
+
         case (1):
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rda);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_reth);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfed);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_ricp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rebm);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfca);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfpne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpso);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpp);
-
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai), ("fmbm_rprai"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_refqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsdm);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsem);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfene);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcmne);
-        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi, ("fmbm_ebmpi"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
-        {
-            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], sizeof(uint32_t));
-        }
-        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt, ("fmbm_acnt"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
-        {
-            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], sizeof(uint32_t));
-        }
-        DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm, ("fmbm_rcgm"));
-        DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_NUM_OF_CONGESTION_GRPS/32)
-        {
-            DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[i], sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rmpd);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rstc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfrc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfbc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rlfc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rffc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfcd);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfldec);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rodc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpcp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rccn);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rtuc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rrquc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rduc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfuc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rdcfg), ("fmbm_rdcfg"));
-        DUMP_SUBSTRUCT_ARRAY(i, 3)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rdcfg[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rgpr);
-        break;
-        case (2):
+            DUMP_SUBTITLE(("\n"));
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcfg);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rst);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rda);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_reth);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfed);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_ricp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rebm);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfne);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfca);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfpne);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpso);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpp);
+
+            DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai), ("fmbm_rprai"));
+            DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_PRS_RESULT_NUM_OF_WORDS)
+            {
+                DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rprai[i]), sizeof(uint32_t));
+            }
+            DUMP_SUBTITLE(("\n"));
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfqid);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_refqid);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsdm);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfsem);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfene);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rcmne);
+            DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi, ("fmbm_ebmpi"));
+            DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
+            {
+                DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_ebmpi[i], sizeof(uint32_t));
+            }
+            DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt, ("fmbm_acnt"));
+            DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_MAX_NUM_OF_EXT_POOLS)
+            {
+                DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_acnt[i], sizeof(uint32_t));
+            }
+            DUMP_TITLE(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm, ("fmbm_rcgm"));
+            DUMP_SUBSTRUCT_ARRAY(i, FM_PORT_NUM_OF_CONGESTION_GRPS/32)
+            {
+                DUMP_MEMORY(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rcgm[i], sizeof(uint32_t));
+            }
+            DUMP_SUBTITLE(("\n"));
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rmpd);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rstc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfrc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfbc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rlfc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rffc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfcd);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfldec);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rodc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpcp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rccn);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rtuc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rrquc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rduc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rfuc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rpac);
+            DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rdcfg), ("fmbm_rdcfg"));
+            DUMP_SUBSTRUCT_ARRAY(i, 3)
+            {
+                DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs.fmbm_rdcfg[i]), sizeof(uint32_t));
+            }
+            DUMP_SUBTITLE(("\n"));
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->rxPortBmiRegs,fmbm_rgpr);
+            break;
 
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tst);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tda);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfed);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ticp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfca);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfeqid);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfene);
-#if (DPAA_VERSION >= 11)
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfne);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcmne);
-#endif /* (DPAA_VERSION >= 11) */
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmts);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmt);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tstc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfrc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfledc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfufdc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpcp);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tccn);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttuc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttcquc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tduc);
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfuc);
-        DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tdcfg), ("fmbm_tdcfg"));
-        DUMP_SUBSTRUCT_ARRAY(i, 3)
-        {
-            DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tdcfg[i]), sizeof(uint32_t));
-        }
-        DUMP_SUBTITLE(("\n"));
-        DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tgpr);
-        break;
+        case (2):
+            DUMP_SUBTITLE(("\n"));
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfg);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tst);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tda);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfed);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ticp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdne);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfca);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcfqid);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfeqid);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfene);
+    #if (DPAA_VERSION >= 11)
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfne);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tcmne);
+    #endif /* (DPAA_VERSION >= 11) */
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmts);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_trlmt);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tstc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfrc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfdc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfledc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfufdc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tbdc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tpcp);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tccn);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttuc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_ttcquc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tduc);
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tfuc);
+            DUMP_TITLE(&(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tdcfg), ("fmbm_tdcfg"));
+            DUMP_SUBSTRUCT_ARRAY(i, 3)
+            {
+                DUMP_MEMORY(&(p_FmPort->p_FmPortBmiRegs->txPortBmiRegs.fmbm_tdcfg[i]), sizeof(uint32_t));
+            }
+            DUMP_SUBTITLE(("\n"));
+            DUMP_VAR(&p_FmPort->p_FmPortBmiRegs->txPortBmiRegs,fmbm_tgpr);
+            break;
 
         default:
         RETURN_ERROR(MAJOR, E_INVALID_STATE, ("Invalid flag"));
@@ -6017,7 +5935,7 @@ static t_Error DsarCheckParams(t_FmPortDsarParams *params,
 {
     bool macInit = FALSE;
     uint8_t mac[6];
-    int i;
+    int i = 0;
 
     // check table sizes
     if (params->p_AutoResArpInfo
@@ -6088,16 +6006,13 @@ static t_Error DsarCheckParams(t_FmPortDsarParams *params,
                     E_INVALID_VALUE,
                     ("DSAR: tcp filter table size exceeds the configured maximum size."));
     }
-    // check only 1 MAC address is configured (this is what ucode currently supports)
+    /* check only 1 MAC address is configured (this is what ucode currently supports) */
     if (params->p_AutoResArpInfo && params->p_AutoResArpInfo->tableSize)
     {
-        i = 0;
-        if (!macInit)
-        {
-            memcpy(mac, params->p_AutoResArpInfo->p_AutoResTable[0].mac, 6);
-            i = 1;
-            macInit = TRUE;
-        }
+        memcpy(mac, params->p_AutoResArpInfo->p_AutoResTable[0].mac, 6);
+        i = 1;
+        macInit = TRUE;
+
         for (; i < params->p_AutoResArpInfo->tableSize; i++)
             if (memcmp(mac, params->p_AutoResArpInfo->p_AutoResTable[i].mac, 6))
                 RETURN_ERROR(
@@ -6165,7 +6080,6 @@ static t_Error DsarCheckParams(t_FmPortDsarParams *params,
         {
             memcpy(mac, params->p_AutoResNdpInfo->p_AutoResTableTmp[0].mac, 6);
             i = 1;
-            macInit = TRUE;
         }
         for (; i < params->p_AutoResNdpInfo->tableSizeTmp; i++)
             if (memcmp(mac, params->p_AutoResNdpInfo->p_AutoResTableTmp[i].mac,
@@ -6264,7 +6178,7 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
 	if (params->p_AutoResArpInfo->enableConflictDetection)
 	        WRITE_UINT16(ArpDescriptor->control, 1);
 	else
-	        WRITE_UINT16(ArpDescriptor->control, 0);
+        WRITE_UINT16(ArpDescriptor->control, 0);
         if (params->p_AutoResArpInfo->tableSize)
         {
             t_FmPortDsarArpEntry* arp_entry = params->p_AutoResArpInfo->p_AutoResTable;
@@ -6349,7 +6263,7 @@ t_Error FM_PORT_EnterDsar(t_Handle h_FmPortRx, t_FmPortDsarParams *params)
 	if (params->p_AutoResNdpInfo->enableConflictDetection)
 	        WRITE_UINT16(NDDescriptor->control, 1);
 	else
-	        WRITE_UINT16(NDDescriptor->control, 0);
+        WRITE_UINT16(NDDescriptor->control, 0);
         if (params->p_AutoResNdpInfo->tableSizeAssigned + params->p_AutoResNdpInfo->tableSizeTmp)
         {
             t_FmPortDsarNdpEntry* ndp_entry = params->p_AutoResNdpInfo->p_AutoResTableAssigned;
@@ -6605,7 +6519,7 @@ t_Error FM_PORT_EnterDsarFinal(t_Handle h_DsarRxPort, t_Handle h_DsarTxPort)
 		XX_Print("FM: Sleeping\n");
 //	FM_ChangeClock(p_FmPort->h_Fm, p_FmPort->hardwarePortId);
 
-	return E_OK;
+    return E_OK;
 }
 
 EXPORT_SYMBOL(FM_PORT_EnterDsarFinal);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
index fa69625..b9fe9b3 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port.h
@@ -242,7 +242,7 @@ typedef uint32_t fmPcdEngines_t; /**< options as defined below: */
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   fmbm_rcfg;      /**< Rx Configuration */
     volatile uint32_t   fmbm_rst;       /**< Rx Status */
@@ -303,9 +303,9 @@ typedef _Packed struct
     volatile uint32_t   fmbm_rdcfg[0x3];/**< Rx Debug-*/
     volatile uint32_t   fmbm_rgpr;      /**< Rx General Purpose Register. */
     volatile uint32_t   reserved8[0x3a];/**< (0x310-0x3FF) */
-} _PackedType t_FmPortRxBmiRegs;
+} t_FmPortRxBmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   fmbm_tcfg;      /**< Tx Configuration */
     volatile uint32_t   fmbm_tst;       /**< Tx Status */
@@ -344,9 +344,9 @@ typedef _Packed struct
     volatile uint32_t   fmbm_tdcfg[0x3];/**< Tx Debug-*/
     volatile uint32_t   fmbm_tgpr;      /**< O/H General Purpose Register */
     volatile uint32_t   reserved5[0x3a];/**< (0x310-0x3FF) */
-} _PackedType t_FmPortTxBmiRegs;
+} t_FmPortTxBmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   fmbm_ocfg;      /**< O/H Configuration  */
     volatile uint32_t   fmbm_ost;       /**< O/H Status */
@@ -402,16 +402,16 @@ typedef _Packed struct
     volatile uint32_t   fmbm_odcfg[0x3];/**< O/H Debug (only 1 in P1023) */
     volatile uint32_t   fmbm_ogpr;      /**< O/H General Purpose Register. */
     volatile uint32_t   reserved7[0x3a];/**< (0x310 0x3FF) */
-} _PackedType t_FmPortOhBmiRegs;
+} t_FmPortOhBmiRegs;
 
-typedef _Packed union
+typedef union
 {
     t_FmPortRxBmiRegs rxPortBmiRegs;
     t_FmPortTxBmiRegs txPortBmiRegs;
     t_FmPortOhBmiRegs ohPortBmiRegs;
-} _PackedType u_FmPortBmiRegs;
+} u_FmPortBmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   reserved1[2];   /**<   0xn024 - 0x02B */
     volatile uint32_t   fmqm_pndn;      /**<   PortID n Dequeue NIA Register */
@@ -419,9 +419,9 @@ typedef _Packed struct
     volatile uint32_t   fmqm_pndtfc;    /**<   PortID n Dequeue Total Frame Counter */
     volatile uint32_t   fmqm_pndfdc;    /**<   PortID n Dequeue FQID from Default Counter */
     volatile uint32_t   fmqm_pndcc;     /**<   PortID n Dequeue Confirm Counter */
-} _PackedType t_FmPortNonRxQmiRegs;
+} t_FmPortNonRxQmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
     volatile uint32_t   fmqm_pnc;       /**<   PortID n Configuration Register */
     volatile uint32_t   fmqm_pns;       /**<   PortID n Status Register */
@@ -430,19 +430,19 @@ typedef _Packed struct
     volatile uint32_t   fmqm_pnen;      /**<   PortID n Enqueue NIA Register */
     volatile uint32_t   fmqm_pnetfc;    /**<   PortID n Enqueue Total Frame Counter */
     t_FmPortNonRxQmiRegs    nonRxQmiRegs;  /**<   Registers for Tx Hc & Op ports */
-} _PackedType t_FmPortQmiRegs;
+} t_FmPortQmiRegs;
 
-typedef _Packed struct
+typedef struct
 {
-    _Packed struct
+     struct
     {
         volatile uint32_t   softSeqAttach;  /**<   Soft Sequence Attachment */
         volatile uint32_t   lcv;            /**<   Line-up Enable Confirmation Mask */
-    } _PackedType hdrs[FM_PCD_PRS_NUM_OF_HDRS];
+    } hdrs[FM_PCD_PRS_NUM_OF_HDRS];
     volatile uint8_t    reserved0[0x378];
     volatile uint32_t   pcac;               /**<   Parse Internal Memory Configuration Access Control Register */
     volatile uint32_t   pctpid;             /**<   Parse Internal Memory Configured TPID Register */
-} _PackedType t_FmPortPrsRegs;
+} t_FmPortPrsRegs;
 
 /**************************************************************************//*
  @Description   Basic buffer descriptor (BD) structure
@@ -735,7 +735,6 @@ typedef _Packed struct
 #define BD_RX_OV                                0x00010000
 
 #define BD_RX_ERRORS                            (BD_RX_CRE | BD_RX_FTL | BD_RX_FTS | BD_RX_OV)
-#define BD_ERROR_PASS_FRAME                     BD_RX_ERRORS
 
 #define FM_IM_SIZEOF_BD                         sizeof(t_FmImBd)
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c
index 7f70cc9..8de8f5f 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fm_port_im.c
@@ -39,6 +39,7 @@
 #include "std_ext.h"
 #include "string_ext.h"
 #include "error_ext.h"
+#include "memcpy_ext.h"
 #include "fm_muram_ext.h"
 
 #include "fm_port.h"
@@ -140,7 +141,7 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
     uint32_t                bdStatus;
     volatile uint8_t        buffPos;
     uint16_t                length;
-    uint16_t                errors/*, reportErrors*/;
+    uint16_t                errors;
     uint8_t                 *p_CurData, *p_Data;
     uint32_t                flags;
 
@@ -168,7 +169,6 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
         if (p_FmPort->im.firstBdOfFrameId == IM_ILEGAL_BD_ID)
             p_FmPort->im.firstBdOfFrameId = p_FmPort->im.currBdId;
 
-        errors = 0;
         p_CurData = BdBufferGet(p_FmPort->im.rxPool.f_PhysToVirt, BD_GET(p_FmPort->im.currBdId));
         h_CurrUserPriv = p_FmPort->im.p_BdShadow[p_FmPort->im.currBdId];
         length = (uint16_t)((bdStatus & BD_L) ?
@@ -199,9 +199,8 @@ t_Error FmPortImRx(t_FmPort *p_FmPort)
         WRITE_UINT16(p_FmPort->im.p_FmPortImPram->rxQd.offsetOut, (uint16_t)(p_FmPort->im.currBdId<<4));
         /* Pass the buffer if one of the conditions is true:
         - There are no errors
-        - This is a part of a larger frame ( the application has already received some buffers )
-        - There is an error, but it was defined to be passed anyway. */
-        if ((buffPos != SINGLE_BUF) || !errors || (errors & (uint16_t)(BD_ERROR_PASS_FRAME>>16)))
+        - This is a part of a larger frame ( the application has already received some buffers ) */
+        if ((buffPos != SINGLE_BUF) || !errors)
         {
             if (p_FmPort->im.f_RxStore(p_FmPort->h_App,
                                        p_CurData,
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
index 54e796c..60acbf3 100755
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Port/fman_port.c
@@ -1514,7 +1514,7 @@ int fman_port_add_congestion_grps(struct fman_port *port,
         max_grp_map_num = 1;
         if (port->fm_rev_maj != 4)
             return -EINVAL;
-        grp_map_reg = &port->bmi_regs->oh.fmbm_ocgm;
+        grp_map_reg = port->bmi_regs->oh.fmbm_ocgm;
         break;
     default:
         return -EINVAL;
@@ -1551,7 +1551,7 @@ int fman_port_remove_congestion_grps(struct fman_port *port,
         max_grp_map_num = 1;
         if (port->fm_rev_maj != 4)
             return -EINVAL;
-        grp_map_reg = &port->bmi_regs->oh.fmbm_ocgm;
+        grp_map_reg = port->bmi_regs->oh.fmbm_ocgm;
         break;
     default:
         return -EINVAL;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
index 14b15a1..0994f34 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/SP/fm_sp.c
@@ -549,7 +549,7 @@ t_Error FM_VSP_Init(t_Handle h_FmVsp)
     ASSERT_COND(p_FmVspEntry->p_FmSpRegsBase);
     ASSERT_COND(fm_vsp_params.int_context);
     ASSERT_COND(fm_vsp_params.buf_margins);
-    ASSERT_COND(IN_RANGE(0, absoluteProfileId, FM_VSP_MAX_NUM_OF_ENTRIES));
+    ASSERT_COND((absoluteProfileId <= FM_VSP_MAX_NUM_OF_ENTRIES));
 
     /* Set all registers related to VSP */
     fman_vsp_init(p_FmVspEntry->p_FmSpRegsBase, absoluteProfileId, &fm_vsp_params,FM_PORT_MAX_NUM_OF_EXT_POOLS, BM_MAX_NUM_OF_POOLS, FM_MAX_NUM_OF_PFC_PRIORITIES);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
index 550dd78..aa48455 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.c
@@ -532,8 +532,7 @@ static t_Error FwNotResetErratumBugzilla6173WA(t_Fm *p_Fm)
     /*************************************/
     /* Load FMan-Controller code to IRAM */
     /*************************************/
-    if (ClearIRam(p_Fm) != E_OK)
-        RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
+    ClearIRam(p_Fm);
     if (p_Fm->firmware.p_Code &&
         (LoadFmanCtrlCode(p_Fm) != E_OK))
         RETURN_ERROR(MAJOR, E_INVALID_STATE, NO_MSG);
@@ -720,7 +719,7 @@ static uint8_t AllocVSPsForPartition(t_Handle  h_Fm, uint8_t base, uint8_t numOf
             RETURN_ERROR(MAJOR, err, NO_MSG);
         else
             memcpy((uint8_t*)&p_Fm->partVSPBase, reply.replyBody, sizeof(uint8_t));
-        if (p_Fm->partVSPBase == ILLEGAL_BASE)
+        if (p_Fm->partVSPBase == (uint8_t)(ILLEGAL_BASE))
             RETURN_ERROR(MAJOR, err, NO_MSG);
     }
     if (p_Fm->guestId != NCSW_MASTER_ID)
@@ -997,7 +996,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
             t_FmIpcResourceAllocParams  ipcAllocParams;
             uint8_t                     vspBase;
             memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
-            vspBase =  AllocVSPsForPartition(h_Fm, ipcAllocParams.base, ipcAllocParams.num, ipcAllocParams.guestId);
+            vspBase =  AllocVSPsForPartition(h_Fm, (uint8_t)ipcAllocParams.base, (uint8_t)ipcAllocParams.num, ipcAllocParams.guestId);
             memcpy(p_IpcReply->replyBody, (uint8_t*)&vspBase, sizeof(uint8_t));
             *p_ReplyLength = sizeof(uint32_t) + sizeof(uint8_t);
             break;
@@ -1006,7 +1005,7 @@ static t_Error FmHandleIpcMsgCB(t_Handle  h_Fm,
         {
             t_FmIpcResourceAllocParams   ipcAllocParams;
             memcpy(&ipcAllocParams, p_IpcMsg->msgBody, sizeof(t_FmIpcResourceAllocParams));
-            FreeVSPsForPartition(h_Fm, ipcAllocParams.base, ipcAllocParams.num, ipcAllocParams.guestId);
+            FreeVSPsForPartition(h_Fm, (uint8_t)ipcAllocParams.base, (uint8_t)ipcAllocParams.num, ipcAllocParams.guestId);
             break;
         }
         case (FM_VSP_SET_PORT_WINDOW) :
@@ -1238,8 +1237,8 @@ t_Error Fm10GTxEccWorkaround(t_Handle h_Fm, uint8_t macId)
     SANITY_CHECK_RETURN_ERROR((macId == 0), E_NOT_SUPPORTED);
     SANITY_CHECK_RETURN_ERROR(IsFmanCtrlCodeLoaded(p_Fm), E_INVALID_STATE);
 
-    SW_PORT_ID_TO_HW_PORT_ID(rxHardwarePortId, e_FM_PORT_TYPE_RX_10G, macId);
-    SW_PORT_ID_TO_HW_PORT_ID(txHardwarePortId, e_FM_PORT_TYPE_TX_10G, macId);
+    rxHardwarePortId = SwPortIdToHwPortId(e_FM_PORT_TYPE_RX_10G, macId);
+    txHardwarePortId = SwPortIdToHwPortId(e_FM_PORT_TYPE_TX_10G, macId);
     if ((p_Fm->p_FmStateStruct->portsTypes[rxHardwarePortId] != e_FM_PORT_TYPE_DUMMY) ||
         (p_Fm->p_FmStateStruct->portsTypes[txHardwarePortId] != e_FM_PORT_TYPE_DUMMY))
         RETURN_ERROR(MAJOR, E_INVALID_STATE,
@@ -1538,7 +1537,7 @@ t_Error FmVSPAllocForPort (t_Handle        h_Fm,
         RETURN_ERROR(MINOR, E_FULL, ("No profiles."));
     }
 
-    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    hardwarePortId = SwPortIdToHwPortId(portType, portId);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
     p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles = numOfVSPs;
@@ -1563,11 +1562,11 @@ t_Error FmVSPFreeForPort(t_Handle        h_Fm,
 
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
 
-    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    hardwarePortId = SwPortIdToHwPortId(portType, portId);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
-    numOfVSPs = p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
-    first = p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
+    numOfVSPs = (uint8_t)p_Fm->p_FmSp->portsMapping[swPortIndex].numOfProfiles;
+    first = (uint8_t)p_Fm->p_FmSp->portsMapping[swPortIndex].profilesBase;
 
     intFlags = XX_LockIntrSpinlock(p_Fm->h_Spinlock);
     for (i = first; i < first + numOfVSPs; i++)
@@ -2025,7 +2024,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm, t_FmInterModulePortInitParams *p_PortP
     }
     p_Fm->p_FmStateStruct->portsTypes[hardwarePortId] = p_PortParams->portType;
 
-    err = FmSetNumOfTasks(p_Fm, p_PortParams->hardwarePortId, &p_PortParams->numOfTasks, &p_PortParams->numOfExtraTasks, TRUE);
+    err = FmSetNumOfTasks(p_Fm, hardwarePortId, &p_PortParams->numOfTasks, &p_PortParams->numOfExtraTasks, TRUE);
     if (err)
     {
         XX_UnlockIntrSpinlock(p_Fm->h_Spinlock, intFlags);
@@ -2076,7 +2075,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm, t_FmInterModulePortInitParams *p_PortP
 #endif /* FM_LOW_END_RESTRICTION */
 
     err = FmSetSizeOfFifo(p_Fm,
-                          p_PortParams->hardwarePortId,
+                          hardwarePortId,
                           &p_PortParams->sizeOfFifo,
                           &p_PortParams->extraSizeOfFifo,
                           TRUE);
@@ -2087,7 +2086,7 @@ t_Error FmGetSetPortParams(t_Handle h_Fm, t_FmInterModulePortInitParams *p_PortP
     }
 
     err = FmSetNumOfOpenDmas(p_Fm,
-                             p_PortParams->hardwarePortId,
+                             hardwarePortId,
                              &p_PortParams->numOfOpenDmas,
                              &p_PortParams->numOfExtraOpenDmas,
                              TRUE);
@@ -2402,10 +2401,10 @@ t_Error FmResetMac(t_Handle h_Fm, e_FmMacType type, uint8_t macId)
 
     err = (t_Error)fman_reset_mac(fpm_rg, macId, !!(type == e_FM_MAC_10G));
 
-    if (err == E_INVALID_VALUE)
-                RETURN_ERROR(MINOR, E_INVALID_VALUE, ("Illegal MAC Id"));
-    else if (err == E_TIMEOUT)
+    if (err == -EBUSY)
         return ERROR_CODE(E_TIMEOUT);
+    else if (err)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal MAC ID"));
 
     return E_OK;
 }
@@ -2502,7 +2501,8 @@ uint32_t FmGetTimeStampScale(t_Handle h_Fm)
                                      &replyLength,
                                      NULL,
                                      NULL)) != E_OK)
-            RETURN_ERROR(MINOR, err, NO_MSG);
+            RETURN_ERROR(MAJOR, err, NO_MSG);
+
         if (replyLength != (sizeof(uint32_t) + sizeof(uint32_t)))
             RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("IPC reply length mismatch"));
 
@@ -2513,9 +2513,7 @@ uint32_t FmGetTimeStampScale(t_Handle h_Fm)
              p_Fm->baseAddr)
     {
         if (!(GET_UINT32(p_Fm->p_FmFpmRegs->fmfp_tsc1) & FPM_TS_CTL_EN))
-            RETURN_ERROR(MAJOR, E_INVALID_STATE, ("timestamp is not enabled!"));
-
-        return p_Fm->p_FmStateStruct->count1MicroBit;
+             RETURN_ERROR(MAJOR, E_INVALID_STATE, ("timestamp is not enabled!"));
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
         DBG(WARNING, ("No IPC - can't validate FM if timestamp enabled."));
@@ -2580,8 +2578,6 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
     uint32_t                sizeOfFifo = *p_SizeOfFifo, extraSizeOfFifo = *p_ExtraSizeOfFifo;
     uint16_t                currentVal = 0, currentExtraVal = 0;
 
-    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
-
     if ((p_Fm->guestId != NCSW_MASTER_ID) &&
         !p_Fm->baseAddr &&
         p_Fm->h_IpcSessions[0])
@@ -2616,18 +2612,6 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
              p_Fm->baseAddr)
     {
         DBG(WARNING, ("No IPC - can't validate FM total-fifo size."));
-
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-        if (!sizeOfFifo)
-        /* first config without explicit value: Do Nothing - reset value shouldn't be
-           changed, read register for port save */
-    {
-            *p_ExtraSizeOfFifo = fman_get_size_of_extra_fifo(bmi_rg, hardwarePortId);
-            *p_SizeOfFifo = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
-    }
-    else
-            /* whether it is the first time with explicit value, or runtime "set" - write register */
-#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
         fman_set_size_of_fifo(bmi_rg, hardwarePortId, sizeOfFifo, extraSizeOfFifo);
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
@@ -2642,63 +2626,28 @@ t_Error FmSetSizeOfFifo(t_Handle    h_Fm,
         currentVal = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
     }
 
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-    /* it's illegal to be in a state where this is not the first set and no value is specified */
-    ASSERT_COND(initialConfig || sizeOfFifo);
-    if (!sizeOfFifo)
+    if (extraSizeOfFifo > currentExtraVal)
     {
-        /* !sizeOfFifo - first configuration according to values in regs.
-         * - read the current FIFO  and extra FIFO size  */
-        currentExtraVal = fman_get_size_of_extra_fifo(bmi_rg, hardwarePortId);
-        currentVal = fman_get_size_of_fifo(bmi_rg, hardwarePortId);
-        /* This is the first configuration and user did not specify value (!numOfTasks),
-         * reset values will be used and we just save these values for resource management */
-        if (currentExtraVal)
-        {
-            if (!p_Fm->p_FmStateStruct->extraFifoPoolSize)
-                /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
-                 * must be initialized to 1 buffer per port
-                 */
-                p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
-
-            p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
-        }
-        if ((p_Fm->p_FmStateStruct->accumulatedFifoSize + currentVal) >
-            (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Total port's fifo size and extra size exceed total available FIFO size."));
+        if (extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
+            /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
+             * must be initialized to 1 buffer per port
+             */
+            p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
 
-        p_Fm->p_FmStateStruct->accumulatedFifoSize += currentVal;
+        p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
 
-        *p_SizeOfFifo = currentVal;
-        *p_ExtraSizeOfFifo = currentExtraVal;
-        return E_OK;
     }
-    /* else: user requires a specific value.
-         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
-         * otherwise they hold the value written in the register.
-         */
-#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
-        if (extraSizeOfFifo > currentExtraVal)
-        {
-            if (extraSizeOfFifo && !p_Fm->p_FmStateStruct->extraFifoPoolSize)
-                /* if this is the first time a port requires extraFifoPoolSize, the total extraFifoPoolSize
-                 * must be initialized to 1 buffer per port
-                 */
-                p_Fm->p_FmStateStruct->extraFifoPoolSize = FM_MAX_NUM_OF_RX_PORTS*BMI_FIFO_UNITS;
-
-            p_Fm->p_FmStateStruct->extraFifoPoolSize = MAX(p_Fm->p_FmStateStruct->extraFifoPoolSize, extraSizeOfFifo);
-        }
 
-        /* check that there are enough uncommitted fifo size */
-        if ((p_Fm->p_FmStateStruct->accumulatedFifoSize - currentVal + sizeOfFifo) >
-            (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
-        else
-        {
-            /* update accumulated */
-            ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= currentVal);
-            p_Fm->p_FmStateStruct->accumulatedFifoSize -= currentVal;
-            p_Fm->p_FmStateStruct->accumulatedFifoSize += sizeOfFifo;
+    /* check that there are enough uncommitted fifo size */
+    if ((p_Fm->p_FmStateStruct->accumulatedFifoSize - currentVal + sizeOfFifo) >
+        (p_Fm->p_FmStateStruct->totalFifoSize - p_Fm->p_FmStateStruct->extraFifoPoolSize))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE, ("Requested fifo size and extra size exceed total FIFO size."));
+    else
+    {
+        /* update accumulated */
+        ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedFifoSize >= currentVal);
+        p_Fm->p_FmStateStruct->accumulatedFifoSize -= currentVal;
+        p_Fm->p_FmStateStruct->accumulatedFifoSize += sizeOfFifo;
         fman_set_size_of_fifo(bmi_rg, hardwarePortId, sizeOfFifo, extraSizeOfFifo);
     }
 
@@ -2754,17 +2703,6 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
     {
         DBG(WARNING, ("No IPC - can't validate FM total-num-of-tasks."));
 
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-        if (!numOfTasks)
-        /* first config without explicit value: Do Nothing - reset value shouldn't be
-           changed, read register for port save */
-    {
-           *p_NumOfTasks = fman_get_num_of_tasks(bmi_rg, hardwarePortId);
-           *p_NumOfExtraTasks = fman_get_num_extra_tasks(bmi_rg, hardwarePortId);
-    }
-    else
-            /* whether it is the first time with explicit value, or runtime "set" - write register */
-#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
         fman_set_num_of_tasks(bmi_rg, hardwarePortId, numOfTasks, numOfExtraTasks);
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
@@ -2779,50 +2717,22 @@ t_Error FmSetNumOfTasks(t_Handle    h_Fm,
         currentExtraVal = fman_get_num_extra_tasks(bmi_rg, hardwarePortId);
     }
 
-#ifndef FM_NO_GUARANTEED_RESET_VALUES
-    /* it's illegal to be in a state where this is not the first set and no value is specified */
-    ASSERT_COND(initialConfig || numOfTasks);
-    if (!numOfTasks)
-    {
-        /* !numOfTasks - first configuration according to values in regs.
-         * - read the current number of tasks */
-        currentVal = fman_get_num_of_tasks(bmi_rg, hardwarePortId);
-        currentExtraVal = fman_get_num_extra_tasks(bmi_rg, hardwarePortId);
-        /* This is the first configuration and user did not specify value (!numOfTasks),
-         * reset values will be used and we just save these values for resource management */
+    if (numOfExtraTasks > currentExtraVal)
          p_Fm->p_FmStateStruct->extraTasksPoolSize =
-                    (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, currentExtraVal);
-         if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks + currentVal) >
-                 (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
-             RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                                      ("Total ports' numOfTasks and extra tasks pool for fm%d exceed total available numOfTasks.",
-                                       p_Fm->p_FmStateStruct->fmId));
-        p_Fm->p_FmStateStruct->accumulatedNumOfTasks += currentVal;
-        *p_NumOfTasks = currentVal;
-        *p_NumOfExtraTasks = currentExtraVal;
-        return E_OK;
-    }
-    /* else - user requires a specific value.
-         * If this is the first configuration call, (numOfTasks != 0) currentVal & currentExtraVal are set to "0",
-         * otherwise they hold the value written in the register.
-         */
-#endif /* !FM_NO_GUARANTEED_RESET_VALUES */
-        if (numOfExtraTasks > currentExtraVal)
-             p_Fm->p_FmStateStruct->extraTasksPoolSize =
-                 (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
-
-        /* check that there are enough uncommitted tasks */
-        if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - currentVal + numOfTasks) >
-           (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
-            RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
-                         ("Requested numOfTasks and extra tasks pool for fm%d exceed total numOfTasks.",
-                          p_Fm->p_FmStateStruct->fmId));
-        else
-        {
-            ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= currentVal);
+             (uint8_t)MAX(p_Fm->p_FmStateStruct->extraTasksPoolSize, numOfExtraTasks);
+
+    /* check that there are enough uncommitted tasks */
+    if ((p_Fm->p_FmStateStruct->accumulatedNumOfTasks - currentVal + numOfTasks) >
+       (p_Fm->p_FmStateStruct->totalNumOfTasks - p_Fm->p_FmStateStruct->extraTasksPoolSize))
+        RETURN_ERROR(MAJOR, E_NOT_AVAILABLE,
+                     ("Requested numOfTasks and extra tasks pool for fm%d exceed total numOfTasks.",
+                      p_Fm->p_FmStateStruct->fmId));
+    else
+    {
+        ASSERT_COND(p_Fm->p_FmStateStruct->accumulatedNumOfTasks >= currentVal);
         /* update accumulated */
-            p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= currentVal;
-            p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
+        p_Fm->p_FmStateStruct->accumulatedNumOfTasks -= currentVal;
+        p_Fm->p_FmStateStruct->accumulatedNumOfTasks += numOfTasks;
         fman_set_num_of_tasks(bmi_rg, hardwarePortId, numOfTasks, numOfExtraTasks);
     }
 
@@ -2877,8 +2787,8 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     }
 #ifdef FM_HAS_TOTAL_DMAS
     else if (p_Fm->guestId != NCSW_MASTER_ID)
-        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
-                     ("running in guest-mode without IPC!"));
+        RETURN_ERROR(MAJOR, E_NOT_SUPPORTED, ("running in guest-mode without IPC!"));
+
 #else
     else if ((p_Fm->guestId != NCSW_MASTER_ID) &&
              p_Fm->baseAddr &&
@@ -2886,22 +2796,20 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
     {
         /*DBG(WARNING, ("No IPC - can't validate FM total-num-of-dmas."));*/
 
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
         if (!numOfOpenDmas)
-    {
-         /* first config without explic it value: Do Nothing - reset value shouldn't be
-            changed, read register for port save */
-            *p_NumOfOpenDmas = fman_get_num_of_dmas(bmi_rg, hardwarePortId);
-            *p_NumOfExtraOpenDmas = fman_get_num_extra_dmas(bmi_rg, hardwarePortId);
-    }
-    else
+        {
+             /* first config without explic it value: Do Nothing - reset value shouldn't be
+                changed, read register for port save */
+                *p_NumOfOpenDmas = fman_get_num_of_dmas(bmi_rg, hardwarePortId);
+                *p_NumOfExtraOpenDmas = fman_get_num_extra_dmas(bmi_rg, hardwarePortId);
+        }
+        else
             /* whether it is the first time with explicit value, or runtime "set" - write register */
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-        fman_set_num_of_open_dmas(bmi_rg,
-                               hardwarePortId,
-                               numOfOpenDmas,
-                               numOfExtraOpenDmas,
-                               p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize);
+            fman_set_num_of_open_dmas(bmi_rg,
+                                   hardwarePortId,
+                                   numOfOpenDmas,
+                                   numOfExtraOpenDmas,
+                                   p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize);
     }
     else if (p_Fm->guestId != NCSW_MASTER_ID)
         RETURN_ERROR(MAJOR, E_NOT_SUPPORTED,
@@ -2969,7 +2877,7 @@ t_Error FmSetNumOfOpenDmas(t_Handle h_Fm,
             if (p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
             totalNumDmas = (uint8_t)(p_Fm->p_FmStateStruct->accumulatedNumOfOpenDmas + p_Fm->p_FmStateStruct->extraOpenDmasPoolSize);
 #endif /* FM_HAS_TOTAL_DMAS */
-        fman_set_num_of_open_dmas(bmi_rg,
+            fman_set_num_of_open_dmas(bmi_rg,
                                hardwarePortId,
                                numOfOpenDmas,
                                numOfExtraOpenDmas,
@@ -2992,7 +2900,7 @@ t_Error FmVSPCheckRelativeProfile(t_Handle        h_Fm,
     ASSERT_COND(h_Fm);
     p_Fm = (t_Fm*)h_Fm;
 
-    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    hardwarePortId = SwPortIdToHwPortId(portType, portId);
     ASSERT_COND(hardwarePortId);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
@@ -3025,7 +2933,7 @@ t_Error FmVSPGetAbsoluteProfileId(t_Handle        h_Fm,
     if (err != E_OK)
         return err;
 
-    SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId, portType, portId)
+    hardwarePortId = SwPortIdToHwPortId(portType, portId);
     ASSERT_COND(hardwarePortId);
     HW_PORT_ID_TO_SW_PORT_INDX(swPortIndex, hardwarePortId);
 
@@ -3203,7 +3111,7 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
 
 #if (DPAA_VERSION >= 11)
     p_Fm->partVSPBase = AllocVSPsForPartition(p_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
-    if (p_Fm->partVSPBase == ILLEGAL_BASE)
+    if (p_Fm->partVSPBase == (uint8_t)(ILLEGAL_BASE))
         DBG(WARNING, ("partition VSPs allocation is FAILED"));
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -3226,6 +3134,72 @@ static t_Error InitGuestMode(t_Fm *p_Fm)
     return E_OK;
 }
 
+static __inline__ enum fman_exceptions FmanExceptionTrans(e_FmExceptions exception)
+{
+    switch (exception) {
+            case  e_FM_EX_DMA_BUS_ERROR:
+                return E_FMAN_EX_DMA_BUS_ERROR;
+            case  e_FM_EX_DMA_READ_ECC:
+                return E_FMAN_EX_DMA_READ_ECC;
+            case  e_FM_EX_DMA_SYSTEM_WRITE_ECC:
+                return E_FMAN_EX_DMA_SYSTEM_WRITE_ECC;
+            case  e_FM_EX_DMA_FM_WRITE_ECC:
+                return E_FMAN_EX_DMA_FM_WRITE_ECC;
+            case  e_FM_EX_FPM_STALL_ON_TASKS:
+                return E_FMAN_EX_FPM_STALL_ON_TASKS;
+            case  e_FM_EX_FPM_SINGLE_ECC:
+                return E_FMAN_EX_FPM_SINGLE_ECC;
+            case  e_FM_EX_FPM_DOUBLE_ECC:
+                return E_FMAN_EX_FPM_DOUBLE_ECC;
+            case  e_FM_EX_QMI_SINGLE_ECC:
+                return E_FMAN_EX_QMI_SINGLE_ECC;
+            case  e_FM_EX_QMI_DOUBLE_ECC:
+                return E_FMAN_EX_QMI_DOUBLE_ECC;
+            case  e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:
+                return E_FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID;
+            case  e_FM_EX_BMI_LIST_RAM_ECC:
+                return E_FMAN_EX_BMI_LIST_RAM_ECC;
+            case  e_FM_EX_BMI_STORAGE_PROFILE_ECC:
+                return E_FMAN_EX_BMI_STORAGE_PROFILE_ECC;
+            case  e_FM_EX_BMI_STATISTICS_RAM_ECC:
+                return E_FMAN_EX_BMI_STATISTICS_RAM_ECC;
+            case  e_FM_EX_BMI_DISPATCH_RAM_ECC:
+                return E_FMAN_EX_BMI_DISPATCH_RAM_ECC;
+            case  e_FM_EX_IRAM_ECC:
+                return E_FMAN_EX_IRAM_ECC;
+            case  e_FM_EX_MURAM_ECC:
+                return E_FMAN_EX_MURAM_ECC;
+            default:
+                return E_FMAN_EX_DMA_BUS_ERROR;
+        }
+}
+
+uint8_t SwPortIdToHwPortId(e_FmPortType type, uint8_t relativePortId)
+{
+	switch (type)
+	{
+		case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):
+		case (e_FM_PORT_TYPE_OH_HOST_COMMAND):
+			CHECK_PORT_ID_OH_PORTS(relativePortId);
+			return (uint8_t)(BASE_OH_PORTID + (relativePortId));
+		case (e_FM_PORT_TYPE_RX):
+			CHECK_PORT_ID_1G_RX_PORTS(relativePortId);
+			return (uint8_t)(BASE_1G_RX_PORTID + (relativePortId));
+		case (e_FM_PORT_TYPE_RX_10G):
+			CHECK_PORT_ID_10G_RX_PORTS(relativePortId);
+			return (uint8_t)(BASE_10G_RX_PORTID + (relativePortId));
+		case (e_FM_PORT_TYPE_TX):
+			CHECK_PORT_ID_1G_TX_PORTS(relativePortId);
+			return (uint8_t)(BASE_1G_TX_PORTID + (relativePortId));
+		case (e_FM_PORT_TYPE_TX_10G):
+			CHECK_PORT_ID_10G_TX_PORTS(relativePortId);
+			return (uint8_t)(BASE_10G_TX_PORTID + (relativePortId));
+		default:
+			REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));
+			return 0;
+	}
+}
+
 #if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
 t_Error FmDumpPortRegs (t_Handle h_Fm, uint8_t hardwarePortId)
 {
@@ -3233,6 +3207,8 @@ t_Error FmDumpPortRegs (t_Handle h_Fm, uint8_t hardwarePortId)
 
     DECLARE_DUMP;
 
+    ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
+
     SANITY_CHECK_RETURN_ERROR(p_Fm, E_INVALID_HANDLE);
     SANITY_CHECK_RETURN_ERROR(((p_Fm->guestId == NCSW_MASTER_ID) ||
                                p_Fm->baseAddr), E_INVALID_OPERATION);
@@ -3408,9 +3384,7 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
    if (p_Fm->p_FmStateStruct->revInfo.majorRev != 4)
         p_Fm->p_FmDriverParam->qmi_def_tnums_thresh = QMI_DEF_TNUMS_THRESH;
 #endif /* FM_QMI_NO_DEQ_OPTIONS_SUPPORT */
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
-    {
+
         p_Fm->p_FmStateStruct->totalFifoSize        = 0;
         p_Fm->p_FmStateStruct->totalNumOfTasks      = DEFAULT_totalNumOfTasks;
 #ifdef FM_HAS_TOTAL_DMAS
@@ -3426,25 +3400,6 @@ t_Handle FM_Config(t_FmParams *p_FmParam)
         p_Fm->p_FmDriverParam->dma_write_buf_tsh_asrt_emer    = DEFAULT_dmaWriteIntBufHigh;
         p_Fm->p_FmDriverParam->dma_axi_dbg_num_of_beats       = DEFAULT_axiDbgNumOfBeats;
 #endif /* (DPAA_VERSION < 11) */
-    }
-    else
-#endif /* FM_NO_GUARANTEED_RESET_VALUES */
-    {
-        struct fman_rg          fman_rg;
-
-        fman_rg.bmi_rg = p_Fm->p_FmBmiRegs;
-        fman_rg.qmi_rg = p_Fm->p_FmQmiRegs;
-        fman_rg.fpm_rg = p_Fm->p_FmFpmRegs;
-        fman_rg.dma_rg = p_Fm->p_FmDmaRegs;
-
-#ifdef FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127
-        WRITE_UINT32(p_Fm->p_FmBmiRegs->fmbm_cfg2, 0x007B0000);
-#endif /* FM_WRONG_RESET_VALUES_ERRATA_FMAN_A005127 */
-        fman_regconfig(&fman_rg, p_Fm->p_FmDriverParam);
-
-        p_Fm->p_FmStateStruct->totalFifoSize = p_Fm->p_FmDriverParam->total_fifo_size;
-        p_Fm->p_FmStateStruct->totalNumOfTasks = p_Fm->p_FmDriverParam->total_num_of_tasks;
-    }
 #ifdef FM_NO_TNUM_AGING
     p_Fm->p_FmDriverParam->tnum_aging_period = 0;
 #endif
@@ -3485,15 +3440,13 @@ t_Error FM_Init(t_Handle h_Fm)
     if (p_Fm->guestId != NCSW_MASTER_ID)
         return InitGuestMode(p_Fm);
 
-#ifdef FM_NO_GUARANTEED_RESET_VALUES
-    if (1)//p_Fm->p_FmStateStruct->revInfo.majorRev < 6)
-        /* if user didn't configured totalFifoSize - (totalFifoSize=0) we configure default
-         * according to chip. otherwise, we use user's configuration.
-         */
-        if (p_Fm->p_FmStateStruct->totalFifoSize == 0)
-            p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev,
-                                                                         p_Fm->p_FmStateStruct->revInfo.minorRev);
-#endif  /* FM_NO_GUARANTEED_RESET_VALUES */
+    /* if user didn't configured totalFifoSize - (totalFifoSize=0) we configure default
+    * according to chip. otherwise, we use user's configuration.
+    */
+    if (p_Fm->p_FmStateStruct->totalFifoSize == 0)
+        p_Fm->p_FmStateStruct->totalFifoSize = DEFAULT_totalFifoSize(p_Fm->p_FmStateStruct->revInfo.majorRev,
+                                                                     p_Fm->p_FmStateStruct->revInfo.minorRev);
+
 
     CHECK_INIT_PARAMETERS(p_Fm, CheckFmParameters);
 
@@ -3606,7 +3559,7 @@ t_Error FM_Init(t_Handle h_Fm)
 
 #if (DPAA_VERSION >= 11)
     p_Fm->partVSPBase = AllocVSPsForPartition(h_Fm, p_Fm->partVSPBase, p_Fm->partNumOfVSPs, p_Fm->guestId);
-    if (p_Fm->partVSPBase == ILLEGAL_BASE)
+    if (p_Fm->partVSPBase == (uint8_t)(ILLEGAL_BASE))
         DBG(WARNING, ("partition VSPs allocation is FAILED"));
 #endif /* (DPAA_VERSION >= 11) */
 
@@ -3901,10 +3854,11 @@ t_Error FM_ConfigDmaAxiDbgNumOfBeats(t_Handle h_Fm, uint8_t axiDbgNumOfBeats)
 
 #if (DPAA_VERSION >= 11)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
-#endif /* (DPAA_VERSION >= 11) */
+#else
     p_Fm->p_FmDriverParam->dma_axi_dbg_num_of_beats = axiDbgNumOfBeats;
 
     return E_OK;
+#endif /* (DPAA_VERSION >= 11) */
 }
 
 t_Error FM_ConfigDmaCamNumOfEntries(t_Handle h_Fm, uint8_t numOfEntries)
@@ -4086,7 +4040,7 @@ t_Error FM_ConfigException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
             p_Fm->userSetExceptions |= bitMask;
         else
             p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
-   }
+    }
     else
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
 
@@ -4169,11 +4123,12 @@ t_Error FM_ConfigDmaWriteBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDma
 
 #if (DPAA_VERSION >= 11)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
-#endif
+#else
     p_Fm->p_FmDriverParam->dma_write_buf_tsh_asrt_emer = p_FmDmaThresholds->assertEmergency;
     p_Fm->p_FmDriverParam->dma_write_buf_tsh_clr_emer  = p_FmDmaThresholds->clearEmergency;
 
     return E_OK;
+#endif
 }
 
 t_Error FM_ConfigDmaCommQThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaThresholds)
@@ -4200,11 +4155,12 @@ t_Error FM_ConfigDmaReadBufThresholds(t_Handle h_Fm, t_FmDmaThresholds *p_FmDmaT
 
 #if (DPAA_VERSION >= 11)
     RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("Not available for this FM revision!"));
-#endif
+#else
     p_Fm->p_FmDriverParam->dma_read_buf_tsh_clr_emer   = p_FmDmaThresholds->clearEmergency;
     p_Fm->p_FmDriverParam->dma_read_buf_tsh_asrt_emer  = p_FmDmaThresholds->assertEmergency;
 
     return E_OK;
+#endif
 }
 
 t_Error FM_ConfigDmaWatchdog(t_Handle h_Fm, uint32_t watchdogValue)
@@ -4496,25 +4452,28 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
     bmi_rg = p_Fm->p_FmBmiRegs;
 
     memset(weights, 0, (sizeof(uint8_t) * 64));
+
     /* check that all ports add up to 100% */
     sum = 0;
-    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+    for (i=0; i < p_PortsBandwidth->numOfPorts; i++)
         sum +=p_PortsBandwidth->portsBandwidths[i].bandwidth;
     if (sum != 100)
         RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Sum of ports bandwidth differ from 100%"));
 
     /* find highest percent */
-    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+    for (i=0; i < p_PortsBandwidth->numOfPorts; i++)
     {
         if (p_PortsBandwidth->portsBandwidths[i].bandwidth > maxPercent)
             maxPercent = p_PortsBandwidth->portsBandwidths[i].bandwidth;
     }
 
+    ASSERT_COND(maxPercent > 0); /* guaranteed by sum = 100 */
+
     /* calculate weight for each port */
-    for (i=0;i<p_PortsBandwidth->numOfPorts;i++)
+    for (i=0; i < p_PortsBandwidth->numOfPorts; i++)
     {
-        weight = (uint8_t)((p_PortsBandwidth->portsBandwidths[i].bandwidth * PORT_MAX_WEIGHT )/maxPercent);
-        /* we want even division between 1-to-PORT_MAX_WEIGHT. so if exect division
+        weight = (uint8_t)((p_PortsBandwidth->portsBandwidths[i].bandwidth * PORT_MAX_WEIGHT ) / maxPercent);
+        /* we want even division between 1-to-PORT_MAX_WEIGHT. so if exact division
            is not reached, we round up so that:
            0 until maxPercent/PORT_MAX_WEIGHT get "1"
            maxPercent/PORT_MAX_WEIGHT+1 until (maxPercent/PORT_MAX_WEIGHT)*2 get "2"
@@ -4524,9 +4483,9 @@ t_Error FM_SetPortsBandwidth(t_Handle h_Fm, t_FmPortsBandwidthParams *p_PortsBan
             weight++;
 
         /* find the location of this port within the register */
-        SW_PORT_ID_TO_HW_PORT_ID(hardwarePortId,
-                                 p_PortsBandwidth->portsBandwidths[i].type,
-                                 p_PortsBandwidth->portsBandwidths[i].relativePortId);
+        hardwarePortId =
+            SwPortIdToHwPortId(p_PortsBandwidth->portsBandwidths[i].type,
+                               p_PortsBandwidth->portsBandwidths[i].relativePortId);
 
         ASSERT_COND(IN_RANGE(1, hardwarePortId, 63));
         weights[hardwarePortId] = weight;
@@ -4656,9 +4615,7 @@ t_Error FM_SetException(t_Handle h_Fm, e_FmExceptions exception, bool enable)
         else
             p_Fm->p_FmStateStruct->exceptions &= ~bitMask;
 
-        FMAN_EXCEPTION_TRANS(fslException, exception);
-
-
+        fslException = FmanExceptionTrans(exception);
 
         return (t_Error)fman_set_exception(&fman_rg,
                                   fslException,
@@ -4796,7 +4753,8 @@ uint32_t FM_GetCounter(t_Handle h_Fm, e_FmCounters counter)
         case (e_FM_COUNTERS_DEQ_1):
         case (e_FM_COUNTERS_DEQ_2):
         case (e_FM_COUNTERS_DEQ_3):
-            if (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6)
+            if ((p_Fm->p_FmStateStruct->revInfo.majorRev == 4) ||
+                (p_Fm->p_FmStateStruct->revInfo.majorRev >= 6))
             {
                 REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Requested counter not supported"));
                 return 0;
@@ -5299,7 +5257,7 @@ t_Error FM_ForceIntr (t_Handle h_Fm, e_FmExceptions exception)
             RETURN_ERROR(MINOR, E_NOT_SUPPORTED, ("The selected exception may not be forced"));
     }
 
-    FMAN_EXCEPTION_TRANS(fslException, exception);
+    fslException = FmanExceptionTrans(exception);
     fman_force_intr (&fman_rg, fslException);
 
     return E_OK;
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
index ad391c8..817b70e 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm.h
@@ -157,44 +157,6 @@ switch (exception){                                         \
         break;                                                                                      \
     }
 
-#define FMAN_EXCEPTION_TRANS(fsl_exception, _exception) \
-    switch (_exception) {\
-        case  e_FM_EX_DMA_BUS_ERROR:                    \
-            fsl_exception =  E_FMAN_EX_DMA_BUS_ERROR; break;    \
-        case  e_FM_EX_DMA_READ_ECC:                    \
-            fsl_exception =  E_FMAN_EX_DMA_READ_ECC; break;        \
-        case  e_FM_EX_DMA_SYSTEM_WRITE_ECC:                \
-            fsl_exception =  E_FMAN_EX_DMA_SYSTEM_WRITE_ECC; break;    \
-        case  e_FM_EX_DMA_FM_WRITE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_DMA_FM_WRITE_ECC; break;    \
-        case  e_FM_EX_FPM_STALL_ON_TASKS:                \
-            fsl_exception =  E_FMAN_EX_FPM_STALL_ON_TASKS; break;    \
-        case  e_FM_EX_FPM_SINGLE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_FPM_SINGLE_ECC; break;    \
-        case  e_FM_EX_FPM_DOUBLE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_FPM_DOUBLE_ECC; break;    \
-        case  e_FM_EX_QMI_SINGLE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_QMI_SINGLE_ECC; break;    \
-        case  e_FM_EX_QMI_DOUBLE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_QMI_DOUBLE_ECC; break;    \
-        case  e_FM_EX_QMI_DEQ_FROM_UNKNOWN_PORTID:            \
-            fsl_exception =  E_FMAN_EX_QMI_DEQ_FROM_UNKNOWN_PORTID; break; \
-        case  e_FM_EX_BMI_LIST_RAM_ECC:                    \
-            fsl_exception =  E_FMAN_EX_BMI_LIST_RAM_ECC; break;    \
-        case  e_FM_EX_BMI_STORAGE_PROFILE_ECC:                    \
-            fsl_exception =  E_FMAN_EX_BMI_STORAGE_PROFILE_ECC; break;    \
-        case  e_FM_EX_BMI_STATISTICS_RAM_ECC:                \
-            fsl_exception =  E_FMAN_EX_BMI_STATISTICS_RAM_ECC; break; \
-        case  e_FM_EX_BMI_DISPATCH_RAM_ECC:                \
-            fsl_exception =  E_FMAN_EX_BMI_DISPATCH_RAM_ECC; break;    \
-        case  e_FM_EX_IRAM_ECC:                        \
-            fsl_exception =  E_FMAN_EX_IRAM_ECC; break;        \
-        case  e_FM_EX_MURAM_ECC:                    \
-            fsl_exception =  E_FMAN_EX_MURAM_ECC; break;        \
-        default: \
-            fsl_exception =  E_FMAN_EX_DMA_BUS_ERROR; break;    \
-    }
-
 #define FMAN_CACHE_OVERRIDE_TRANS(fsl_cache_override, _cache_override) \
     switch (_cache_override){ \
         case  e_FM_DMA_NO_CACHE_OR:                    \
@@ -471,18 +433,19 @@ switch (exception){                                         \
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(push,1)
 #endif /* defined(__MWERKS__) && ... */
-typedef _Packed struct
+
+typedef struct
 {
     volatile uint32_t   iadd;           /**< FM IRAM instruction address register */
     volatile uint32_t   idata;          /**< FM IRAM instruction data register */
     volatile uint32_t   itcfg;          /**< FM IRAM timing config register */
     volatile uint32_t   iready;         /**< FM IRAM ready register */
-    volatile uint8_t    res[0x80000-0x10];
-} _PackedType t_FMIramRegs;
+    volatile uint32_t   res[0x1FFFC];
+} t_FMIramRegs;
 
 /* Trace buffer registers -
    each FM Controller has its own trace buffer residing at FM_MM_TRB(fmCtrlIndex) offset */
-typedef _Packed struct t_FmTrbRegs
+typedef struct t_FmTrbRegs
 {
     volatile uint32_t   tcrh;
     volatile uint32_t   tcrl;
@@ -509,11 +472,12 @@ typedef _Packed struct t_FmTrbRegs
     volatile uint32_t   tsnum2;
     volatile uint32_t   tsnum3;
     volatile uint32_t   tsnum4;
-} _PackedType t_FmTrbRegs;
+} t_FmTrbRegs;
 
 #if defined(__MWERKS__) && !defined(__GNUC__)
 #pragma pack(pop)
 #endif /* defined(__MWERKS__) && ... */
+
 /**************************************************************************//**
  @Description       General defines
 *//***************************************************************************/
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_muram.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_muram.c
index a1cbe3f..0bc67cb 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_muram.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fm_muram.c
@@ -44,7 +44,6 @@
 #include "fm_muram_ext.h"
 #include "fm_common.h"
 
-
 #define __ERR_MODULE__  MODULE_FM_MURAM
 
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
index 16a0854..9e59062 100755
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/fman.c
@@ -186,7 +186,8 @@ void fman_enable_time_stamp(struct fman_fpm_regs *fpm_rg,
 	 * we do not div back, since we write this value as a fraction
 	 * see spec */
 
-	frac = ((ts_freq << 16) - (intgr << 16) * fm_clk_freq) / fm_clk_freq;
+	frac = (((uint64_t)ts_freq << 16) - ((uint64_t)intgr << 16) * fm_clk_freq)
+		/ fm_clk_freq;
 	/* we check remainder of the division in order to round up if not int */
 	if (((ts_freq << 16) - (intgr << 16)*fm_clk_freq) % fm_clk_freq)
 		frac++;
@@ -822,7 +823,7 @@ int fman_fpm_init(struct fman_fpm_regs *fpm_rg, struct fman_cfg *cfg)
 	/* RAM ECC -  enable and clear events*/
 	/* first we need to clear all parser memory,
 	 * as it is uninitialized and may cause ECC errors */
-	tmp_reg = 0;
+
 	/* event bits */
 	tmp_reg = (FPM_RAM_MURAM_ECC | FPM_RAM_IRAM_ECC);
 	/* Rams enable not effected by RCR bit, but by a COP configuration */
@@ -913,12 +914,12 @@ int fman_qmi_init(struct fman_qmi_regs *qmi_rg, struct fman_cfg *cfg)
 	iowrite32be(tmp_reg, &qmi_rg->fmqm_eien);
 
 	if (cfg->tnum_aging_period) {
-		/* tnumAgingPeriod is in units of usec, p_FmClockFreq in Mhz */
+		/* tnum_aging_period is in units of usec, p_FmClockFreq in Mhz */
 		period_in_fm_clocks = (uint16_t)
 				(cfg->tnum_aging_period * cfg->clk_freq);
-		/* periodInFmClocks must be a 64 multiply */
+		/* period_in_fm_clocks must be a 64 multiply */
 		remainder = (uint8_t)(period_in_fm_clocks % 64);
-		if (remainder > 64)
+		if (remainder)
 			tmp_reg = (uint32_t)((period_in_fm_clocks / 64) + 1);
 		else{
 			tmp_reg = (uint32_t)(period_in_fm_clocks / 64);
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
index b736dcc..c89cba3 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc/fm_common.h
@@ -241,7 +241,6 @@ typedef struct {
     uint32_t            type;
     uint8_t             prOffset;
     uint16_t            dataOffset;
-  //  uint8_t             poolIndex;
     uint8_t             internalBufferOffset;
     uint8_t             numOfTasks;
     uint8_t             numOfExtraTasks;
@@ -513,35 +512,7 @@ static __inline__ bool TRY_LOCK(t_Handle h_Spinlock, volatile bool *p_Flag)
         REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal 10G_TX_PORT port id"))
 #endif
 
-
-#define SW_PORT_ID_TO_HW_PORT_ID(_port, _type, _relativePortId)         \
-switch (_type) {                                                        \
-    case (e_FM_PORT_TYPE_OH_OFFLINE_PARSING):                           \
-    case (e_FM_PORT_TYPE_OH_HOST_COMMAND):                              \
-        CHECK_PORT_ID_OH_PORTS(_relativePortId);                        \
-        _port = (uint8_t)(BASE_OH_PORTID + (_relativePortId));          \
-        break;                                                          \
-    case (e_FM_PORT_TYPE_RX):                                           \
-        CHECK_PORT_ID_1G_RX_PORTS(_relativePortId);                     \
-        _port = (uint8_t)(BASE_1G_RX_PORTID + (_relativePortId));       \
-        break;                                                          \
-    case (e_FM_PORT_TYPE_RX_10G):                                       \
-        CHECK_PORT_ID_10G_RX_PORTS(_relativePortId);                    \
-        _port = (uint8_t)(BASE_10G_RX_PORTID + (_relativePortId));      \
-        break;                                                          \
-    case (e_FM_PORT_TYPE_TX):                                           \
-        CHECK_PORT_ID_1G_TX_PORTS(_relativePortId);                     \
-        _port = (uint8_t)(BASE_1G_TX_PORTID + (_relativePortId));       \
-        break;                                                          \
-    case (e_FM_PORT_TYPE_TX_10G):                                       \
-        CHECK_PORT_ID_10G_TX_PORTS(_relativePortId);                    \
-        _port = (uint8_t)(BASE_10G_TX_PORTID + (_relativePortId));      \
-        break;                                                          \
-    default:                                                            \
-        REPORT_ERROR(MAJOR, E_INVALID_VALUE, ("Illegal port type"));    \
-        _port = 0;                                                      \
-        break;                                                          \
-}
+uint8_t SwPortIdToHwPortId(e_FmPortType _type, uint8_t _relativePortId);
 
 #define HW_PORT_ID_TO_SW_PORT_ID(_relativePortId, hardwarePortId)                   \
 {   if (((hardwarePortId) >= BASE_OH_PORTID) &&                                     \
@@ -615,33 +586,33 @@ typedef struct {
                                              ((hdr) == HEADER_TYPE_USER_DEFINED_SHIM2))
 #define IS_SPECIAL_HEADER(hdr)              ((hdr) == HEADER_TYPE_MACSEC)
 
-#define GET_PRS_HDR_NUM(num, hdr)                           \
-switch (hdr)                                                \
-{   case (HEADER_TYPE_ETH):              num = 0;  break;   \
-    case (HEADER_TYPE_LLC_SNAP):         num = 1;  break;   \
-    case (HEADER_TYPE_VLAN):             num = 2;  break;   \
-    case (HEADER_TYPE_PPPoE):            num = 3;  break;   \
-    case (HEADER_TYPE_PPP):              num = 3;  break;   \
-    case (HEADER_TYPE_MPLS):             num = 4;  break;   \
-    case (HEADER_TYPE_IPv4):             num = 5;  break;   \
-    case (HEADER_TYPE_IPv6):             num = 6;  break;   \
-    case (HEADER_TYPE_GRE):              num = 7;  break;   \
-    case (HEADER_TYPE_MINENCAP):         num = 8;  break;   \
-    case (HEADER_TYPE_USER_DEFINED_L3):  num = 9;  break;   \
-    case (HEADER_TYPE_TCP):              num = 10; break;   \
-    case (HEADER_TYPE_UDP):              num = 11; break;   \
-    case (HEADER_TYPE_IPSEC_AH):                            \
-    case (HEADER_TYPE_IPSEC_ESP):        num = 12; break;   \
-    case (HEADER_TYPE_SCTP):             num = 13; break;   \
-    case (HEADER_TYPE_DCCP):             num = 14; break;   \
-    case (HEADER_TYPE_USER_DEFINED_L4):  num = 15; break;   \
-    case (HEADER_TYPE_USER_DEFINED_SHIM1):                  \
-    case (HEADER_TYPE_USER_DEFINED_SHIM2):                  \
-    case (HEADER_TYPE_MACSEC):                              \
-        num = NO_HDR_NUM; break;                            \
-    default:                                                \
-        REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unsupported header for parser"));\
-        num = ILLEGAL_HDR_NUM; break;                       \
+static __inline__ uint8_t GetPrsHdrNum(e_NetHeaderType hdr)
+{
+	 switch (hdr)
+	 {   case (HEADER_TYPE_ETH):              return 0;
+	     case (HEADER_TYPE_LLC_SNAP):         return 1;
+	     case (HEADER_TYPE_VLAN):             return 2;
+	     case (HEADER_TYPE_PPPoE):            return 3;
+	     case (HEADER_TYPE_PPP):              return 3;
+	     case (HEADER_TYPE_MPLS):             return 4;
+	     case (HEADER_TYPE_IPv4):             return 5;
+	     case (HEADER_TYPE_IPv6):             return 6;
+	     case (HEADER_TYPE_GRE):              return 7;
+	     case (HEADER_TYPE_MINENCAP):         return 8;
+	     case (HEADER_TYPE_USER_DEFINED_L3):  return 9;
+	     case (HEADER_TYPE_TCP):              return 10;
+	     case (HEADER_TYPE_UDP):              return 11;
+	     case (HEADER_TYPE_IPSEC_AH):
+	     case (HEADER_TYPE_IPSEC_ESP):        return 12;
+	     case (HEADER_TYPE_SCTP):             return 13;
+	     case (HEADER_TYPE_DCCP):             return 14;
+	     case (HEADER_TYPE_USER_DEFINED_L4):  return 15;
+	     case (HEADER_TYPE_USER_DEFINED_SHIM1):
+	     case (HEADER_TYPE_USER_DEFINED_SHIM2):
+	     case (HEADER_TYPE_MACSEC):           return NO_HDR_NUM;
+	     default:
+	         return ILLEGAL_HDR_NUM;
+	 }
 }
 
 #define FM_PCD_MAX_NUM_OF_OPTIONS(clsPlanEntries)   ((clsPlanEntries==256)? 8:((clsPlanEntries==128)? 7: ((clsPlanEntries==64)? 6: ((clsPlanEntries==32)? 5:0))))
diff --git a/drivers/net/ethernet/freescale/fman/etc/mm.c b/drivers/net/ethernet/freescale/fman/etc/mm.c
index 7b9d201..9fcc46e 100644
--- a/drivers/net/ethernet/freescale/fman/etc/mm.c
+++ b/drivers/net/ethernet/freescale/fman/etc/mm.c
@@ -246,6 +246,7 @@ static t_Error AddFree(t_MM *p_MM, uint64_t base, uint64_t end)
                     else
                         p_MM->freeBlocks[i] = p_CurrB->p_Next;
                     XX_Free(p_CurrB);
+                    p_CurrB = NULL;
                 }
                 break;
             }
@@ -575,7 +576,10 @@ static uint64_t MmGetGreaterAlignment(t_MM *p_MM, uint64_t size, uint64_t alignm
 
     /* calls Update routine to update a lists of free blocks */
     if ( CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
+    {
+        XX_Free(p_NewBusyB);
         return (uint64_t)(ILLEGAL_BASE);
+    }
 
     /* insert the new busy block into the list of busy blocks */
     AddBusy ( p_MM, p_NewBusyB );
@@ -617,12 +621,15 @@ t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
     /* Initializes counter of free memory to total size */
     p_MM->freeMemSize = size;
 
+    /* A busy list is empty */
+    p_MM->busyBlocks = 0;
+
     /* Initializes a new memory block */
     if ((p_MM->memBlocks = CreateNewBlock(base, size)) == NULL)
+    {
+        MM_Free(p_MM);
         RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-
-    /* A busy list is empty */
-    p_MM->busyBlocks = 0;
+    }
 
     /* Initializes a new free block for each free list*/
     for (i=0; i <= MM_MAX_ALIGNMENT; i++)
@@ -631,7 +638,10 @@ t_Error MM_Init(t_Handle *h_MM, uint64_t base, uint64_t size)
         newSize = size - (newBase - base);
 
         if ((p_MM->freeBlocks[i] = CreateFreeBlock(newBase, newSize)) == NULL)
+        {
+            MM_Free(p_MM);
             RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
+        }
     }
 
     *h_MM = p_MM;
@@ -754,6 +764,7 @@ uint64_t MM_Get(t_Handle h_MM, uint64_t size, uint64_t alignment, char* name)
     if ( CutFree ( p_MM, holdBase, holdEnd ) != E_OK )
     {
         XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        XX_Free(p_NewBusyB);
         return (uint64_t)(ILLEGAL_BASE);
     }
 
@@ -810,6 +821,7 @@ uint64_t MM_GetForce(t_Handle h_MM, uint64_t base, uint64_t size, char* name)
     if ( CutFree ( p_MM, base, base+size ) != E_OK )
     {
         XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        XX_Free(p_NewBusyB);
         return (uint64_t)(ILLEGAL_BASE);
     }
 
@@ -898,6 +910,7 @@ uint64_t MM_GetForceMin(t_Handle h_MM, uint64_t size, uint64_t alignment, uint64
     if ( CutFree( p_MM, holdBase, holdEnd ) != E_OK )
     {
         XX_UnlockIntrSpinlock(p_MM->h_Spinlock, intFlags);
+        XX_Free(p_NewBusyB);
         return (uint64_t)(ILLEGAL_BASE);
     }
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/debug_ext.h b/drivers/net/ethernet/freescale/fman/inc/debug_ext.h
index 62865bb..57db0a1 100644
--- a/drivers/net/ethernet/freescale/fman/inc/debug_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/debug_ext.h
@@ -55,24 +55,26 @@
 
 #define DUMP_Print          XX_Print
 #define DUMP_MAX_LEVELS     6
+#define DUMP_IDX_LEN        6
 #define DUMP_MAX_STR        64
 
 
 #define _CREATE_DUMP_SUBSTR(phrase) \
     dumpTmpLevel = 0; dumpSubStr[0] = '\0'; \
-    sprintf(dumpTmpStr, "%s", #phrase); \
+    snprintf(dumpTmpStr, DUMP_MAX_STR, "%s", #phrase); \
     p_DumpToken = strtok(dumpTmpStr, (dumpIsArr[0] ? "[" : ".")); \
-    while (p_DumpToken != NULL) \
+    while ((p_DumpToken != NULL) && (dumpTmpLevel < DUMP_MAX_LEVELS)) \
     { \
-        strcat(dumpSubStr, p_DumpToken); \
+        strlcat(dumpSubStr, p_DumpToken, DUMP_MAX_STR); \
         if (dumpIsArr[dumpTmpLevel]) \
         { \
-            strcat(dumpSubStr, dumpIdxStr[dumpTmpLevel]); \
+            strlcat(dumpSubStr, dumpIdxStr[dumpTmpLevel], DUMP_MAX_STR); \
             p_DumpToken = strtok(NULL, "."); \
         } \
-        if ((p_DumpToken = strtok(NULL, (dumpIsArr[++dumpTmpLevel] ? "[" : "."))) != 0) \
-            strcat(dumpSubStr, "."); \
-    }\
+        if ((p_DumpToken != NULL) && \
+            ((p_DumpToken = strtok(NULL, (dumpIsArr[++dumpTmpLevel] ? "[" : "."))) != NULL)) \
+            strlcat(dumpSubStr, ".", DUMP_MAX_STR); \
+    }
 
 
 /**************************************************************************//**
@@ -99,11 +101,11 @@
                 starts.
 *//***************************************************************************/
 #define DECLARE_DUMP \
-    char    dumpIdxStr[DUMP_MAX_LEVELS + 1][6] = { "", }; \
+    char    dumpIdxStr[DUMP_MAX_LEVELS + 1][DUMP_IDX_LEN] = { "", }; \
     char    dumpSubStr[DUMP_MAX_STR] = ""; \
     char    dumpTmpStr[DUMP_MAX_STR] = ""; \
     char    *p_DumpToken = NULL; \
-    int     dumpArrIdx = 0, dumpArrSize = 0, dumpVarSize = 0, dumpLevel = 0, dumpTmpLevel = 0; \
+    int     dumpArrIdx = 0, dumpArrSize = 0, dumpLevel = 0, dumpTmpLevel = 0; \
     uint8_t dumpIsArr[DUMP_MAX_LEVELS + 1] = { 0 }; \
     /* Prevent warnings if not all used */ \
     UNUSED(dumpIdxStr[0][0]); \
@@ -112,7 +114,6 @@
     UNUSED(p_DumpToken); \
     UNUSED(dumpArrIdx); \
     UNUSED(dumpArrSize); \
-    UNUSED(dumpVarSize); \
     UNUSED(dumpLevel); \
     UNUSED(dumpTmpLevel); \
     UNUSED(dumpIsArr[0]);
@@ -164,8 +165,8 @@
 *//***************************************************************************/
 #define DUMP_SUBSTRUCT_ARRAY(idx, cnt) \
     for (idx=0, dumpIsArr[dumpLevel++] = 1; \
-         (idx < cnt) && sprintf(dumpIdxStr[dumpLevel-1], "[%d]", idx); \
-         idx++, ((idx < cnt) || ((dumpIsArr[--dumpLevel] = 0) == 0)))
+         (idx < cnt) && (dumpLevel > 0) && snprintf(dumpIdxStr[dumpLevel-1], DUMP_IDX_LEN, "[%d]", idx); \
+         idx++, ((idx < cnt) || (dumpIsArr[--dumpLevel] = 0)))
 
 
 /**************************************************************************//**
@@ -189,19 +190,8 @@
         void            *addr = (void *)&((st)->phrase); \
         physAddress_t   physAddr = XX_VirtToPhys(addr); \
         _CREATE_DUMP_SUBSTR(phrase); \
-        dumpVarSize = sizeof((st)->phrase); \
-        switch (dumpVarSize) \
-        { \
-            case 1:  DUMP_Print("0x%010llX: 0x%02x%14s\t%s\r\n", \
-                                physAddr, GET_UINT8(*(uint8_t*)addr), "", dumpSubStr); break; \
-            case 2:  DUMP_Print("0x%010llX: 0x%04x%12s\t%s\r\n", \
-                                physAddr, GET_UINT16(*(uint16_t*)addr), "", dumpSubStr); break; \
-            case 4:  DUMP_Print("0x%010llX: 0x%08x%8s\t%s\r\n", \
-                                physAddr, GET_UINT32(*(uint32_t*)addr), "", dumpSubStr); break; \
-            case 8:  DUMP_Print("0x%010llX: 0x%016llx\t%s\r\n", \
-                                physAddr, GET_UINT64(*(uint64_t*)addr), dumpSubStr); break; \
-            default: DUMP_Print("Bad size %d (" #st "->" #phrase ")\r\n", dumpVarSize); \
-        } \
+        DUMP_Print("0x%010llX: 0x%08x%8s\t%s\r\n", \
+                   physAddr, GET_UINT32(*(uint32_t*)addr), "", dumpSubStr); \
     } while (0)
 
 
@@ -223,38 +213,15 @@
         physAddress_t physAddr; \
         _CREATE_DUMP_SUBSTR(phrase); \
         dumpArrSize = ARRAY_SIZE((st)->phrase); \
-        dumpVarSize = sizeof((st)->phrase[0]); \
-        switch (dumpVarSize) \
-        { \
-            case 1: \
-                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
-                    DUMP_Print("0x%010llX: 0x%02x%14s\t%s[%d]\r\n", \
-                               physAddr, GET_UINT8((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
-                } break; \
-            case 2: \
-                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
-                    DUMP_Print("0x%010llX: 0x%04x%12s\t%s[%d]\r\n", \
-                               physAddr, GET_UINT16((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
-                } break; \
-            case 4: \
-                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
-                    DUMP_Print("0x%010llX: 0x%08x%8s\t%s[%d]\r\n", \
-                               physAddr, GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
-                } break; \
-            case 8: \
-                for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
-                    physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
-                    DUMP_Print("0x%010llX: 0x%016llx\t%s[%d]\r\n", \
-                               physAddr, GET_UINT64((st)->phrase[dumpArrIdx]), dumpSubStr, dumpArrIdx); \
-                } break; \
-            default: DUMP_Print("Bad size %d (" #st "->" #phrase "[0])\r\n", dumpVarSize); \
+        for (dumpArrIdx=0; dumpArrIdx < dumpArrSize; dumpArrIdx++) { \
+            physAddr = XX_VirtToPhys((void *)&((st)->phrase[dumpArrIdx])); \
+            DUMP_Print("0x%010llX: 0x%08x%8s\t%s[%d]\r\n", \
+                       physAddr, GET_UINT32((st)->phrase[dumpArrIdx]), "", dumpSubStr, dumpArrIdx); \
         } \
     } while (0)
 
 
+
 #endif /* DEBUG_ERRORS > 0 */
 
 
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
index e66ad73..cec4e10 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
@@ -158,8 +158,7 @@ struct fman_fpm_regs {
 	uint32_t fmfp_ee;	/**< FPM Event & Mask 0xdc */
 	uint32_t fmfp_cev[4];	/**< FPM CPU Event 1-4 0xe0-0xef */
 	uint32_t res00f0[4];	/**< res 0xf0-0xff */
-	uint32_t fmfp_ps[50];	/**< FPM Port Status 0x100-0x1c7 */
-	uint32_t res01c8[14];	/**< res 0x1c8-0x1ff */
+	uint32_t fmfp_ps[64];	/**< FPM Port Status 0x100-0x1ff */
 	uint32_t fmfp_clfabc;	/**< FPM CLFABC 0x200 */
 	uint32_t fmfp_clfcc;	/**< FPM CLFCC 0x204 */
 	uint32_t fmfp_clfaval;	/**< FPM CLFAVAL 0x208 */
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
index 292d37d..080a23e 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman_port.h
@@ -274,8 +274,7 @@ struct fman_port_oh_bmi_regs {
 	uint32_t reserved0080[0x20];	/**< 0x080 - 0x0FF Reserved */
 	uint32_t fmbm_oebmpi[2];	/**< Buf Mngr Observed Pool Info */
 	uint32_t reserved0108[0x16];	/**< 0x108 - 0x15F Reserved */
-	uint32_t fmbm_ocgm;		/**< Observed Congestion Group Map */
-	uint32_t reserved0164[0x7];	/**< 0x164 - 0x17F Reserved */
+	uint32_t fmbm_ocgm[FMAN_PORT_CG_MAP_NUM]; /**< Observed Congestion Group Map */
 	uint32_t fmbm_ompd;		/**< Observed BMan Pool Depletion */
 	uint32_t reserved0184[0x1F];	/**< 0x184 - 0x1FF Reserved */
 	uint32_t fmbm_ostc;		/**< O/H Statistics Counters  */
diff --git a/drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h b/drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h
index e7964ad..8de7f5c 100644
--- a/drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/ncsw_ext.h
@@ -40,11 +40,11 @@
 #ifndef __NCSW_EXT_H
 #define __NCSW_EXT_H
 
-#include "memcpy_ext.h"
 
+#include "memcpy_ext.h"
 
-#define WRITE_BLOCK                 IOMemSet32
-#define COPY_BLOCK                  Mem2IOCpy32
+#define WRITE_BLOCK                 IOMemSet32   /* include memcpy_ext.h */
+#define COPY_BLOCK                  Mem2IOCpy32  /* include memcpy_ext.h */
 
 #define PTR_TO_UINT(_ptr)           ((uintptr_t)(_ptr))
 #define UINT_TO_PTR(_val)           ((void*)(uintptr_t)(_val))
@@ -52,8 +52,10 @@
 #define PTR_MOVE(_ptr, _offset)     (void*)((uint8_t*)(_ptr) + (_offset))
 
 
-#define WRITE_UINT8_UINT24(arg, data08, data24) WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
-#define WRITE_UINT24_UINT8(arg, data24, data08) WRITE_UINT32(arg,((uint32_t)(data24)<< 8)|((uint32_t)(data08)&0x000000FF))
+#define WRITE_UINT8_UINT24(arg, data08, data24) \
+    WRITE_UINT32(arg,((uint32_t)(data08)<<24)|((uint32_t)(data24)&0x00FFFFFF))
+#define WRITE_UINT24_UINT8(arg, data24, data08) \
+    WRITE_UINT32(arg,((uint32_t)(data24)<< 8)|((uint32_t)(data08)&0x000000FF))
 
 /* Little-Endian access macros */
 
@@ -94,7 +96,7 @@
 /* Miscellaneous macros */
 /*----------------------*/
 
-#define UNUSED(X) (X=X)
+#define UNUSED(_x)		((void)(_x))
 
 #define KILOBYTE            0x400UL                 /* 1024 */
 #define MEGABYTE            (KILOBYTE * KILOBYTE)   /* 1024*1024 */
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
index 6175658..5b2662a 100755
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
@@ -239,7 +239,9 @@ early_param(FSL_FM_RX_EXTRA_HEADROOM_BOOTARG, fm_set_rx_extra_headroom);
 static irqreturn_t fm_irq(int irq, void *_dev)
 {
     t_LnxWrpFmDev       *p_LnxWrpFmDev = (t_LnxWrpFmDev *)_dev;
+#ifdef CONFIG_PM_SLEEP
     t_Fm               *p_Fm = (t_Fm*)p_LnxWrpFmDev->h_Dev;
+#endif
     if (!p_LnxWrpFmDev || !p_LnxWrpFmDev->h_Dev)
         return IRQ_NONE;
 
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
index 473c3b0..8fa4c89 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm.c
@@ -1992,9 +1992,10 @@ invalid_port_id:
                 compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_K_TO_US);
                 if (copy_to_user((ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) compat_ptr(arg),
                             compat_param,
-                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t))){
+                    XX_Free(compat_param);
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
-
+                }
                 XX_Free(compat_param);
             }
             else
@@ -2066,9 +2067,10 @@ invalid_port_id:
                 compat_copy_fm_pcd_cc_tbl_get_miss(compat_param, &param, COMPAT_K_TO_US);
                 if (copy_to_user((ioc_compat_fm_pcd_cc_tbl_get_miss_params_t*) compat_ptr(arg),
                             compat_param,
-                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t)))
+                            sizeof(ioc_compat_fm_pcd_cc_tbl_get_miss_params_t))){
+                    XX_Free(compat_param);
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
-
+                }
                 XX_Free(compat_param);
             }
             else
@@ -2259,6 +2261,7 @@ invalid_port_id:
                 else
                 {
                     XX_Free(compat_param);
+                    XX_Free(param);
                     err = E_INVALID_VALUE;
                     break;
                 }
@@ -3242,18 +3245,21 @@ t_Error LnxwrpFmIOCTL(t_LnxWrpFmDev *p_LnxWrpFmDev, unsigned int cmd, unsigned l
             {
                 if (copy_to_user((ioc_fm_revision_info_t *)compat_ptr(arg),
                             param,
-                            sizeof(ioc_fm_revision_info_t)))
+                            sizeof(ioc_fm_revision_info_t))){
+                    XX_Free(param);
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+                 }
             }
             else
 #endif
             {
                 if (copy_to_user((ioc_fm_revision_info_t *)arg,
                             param,
-                            sizeof(ioc_fm_revision_info_t)))
+                            sizeof(ioc_fm_revision_info_t))){
+                    XX_Free(param);
                     RETURN_ERROR(MINOR, E_READ_FAILED, NO_MSG);
+                }
             }
-
             XX_Free(param);
             break;
         }
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
index 3c1ac30..5dc7294 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_ioctls_fm_compat.c
@@ -367,6 +367,7 @@ static inline void compat_copy_fm_pcd_cc_next_engine(
             case e_IOC_FM_PCD_DONE:
             case e_IOC_FM_PCD_PLCR:
                 param->manip_id = compat_pcd_id2ptr(compat_param->manip_id);
+                break;
             default:
                 memcpy(&param->params, &compat_param->params, sizeof(param->params));
         }
@@ -393,6 +394,7 @@ static inline void compat_copy_fm_pcd_cc_next_engine(
             case e_IOC_FM_PCD_DONE:
             case e_IOC_FM_PCD_PLCR:
                 compat_param->manip_id = compat_pcd_ptr2id(param->manip_id);
+                break;
             default:
                 memcpy(&compat_param->params, &param->params, sizeof(compat_param->params));
         }
@@ -938,8 +940,8 @@ void compat_copy_keys(
 #if (DPAA_VERSION >= 11)
         memcpy(&compat_param->frame_length_ranges,
             &param->frame_length_ranges,
-            sizeof(compat_param->frame_length_ranges[0] *
-                IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR));
+            sizeof(compat_param->frame_length_ranges[0]) *
+                IOC_FM_PCD_CC_STATS_MAX_NUM_OF_FLR);
 #endif /* (DPAA_VERSION >= 11) */
     }
 
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
index 0ea6d1c..dd3bc3e 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm.c
@@ -1736,7 +1736,7 @@ int fm_plcr_dump_regs(void *h_fm_pcd, char *buf, int nn)
 			&p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr,
 			"fmpl_pmr");
 
-	for (i = 0; i < 64; ++i)
+	for (i = 0; i < 63; ++i)
 		FM_DMP_MEM_32(buf, n,
 			&p_pcd->p_FmPcdPlcr->p_FmPcdPlcrRegs->fmpl_pmr[i]);
 
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
index ebed557..ae4bb87 100644
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_sysfs_fm_port.c
@@ -1201,8 +1201,6 @@ int fm_port_dump_regs_bmi(void *h_dev, char *buf, int nn)
 		FM_DMP_SUBTITLE(buf, n, "\n");
 		FM_DMP_V32(buf, n, &p_bmi->txPortBmiRegs, fmbm_tgpr);
 		break;
-	default:
-		return -EINVAL;
 	}
 
 	FM_DMP_SUBTITLE(buf, n, "\n");
diff --git a/drivers/net/ethernet/freescale/fman/src/xx/Makefile b/drivers/net/ethernet/freescale/fman/src/xx/Makefile
index 1e0db57..3e857d8 100644
--- a/drivers/net/ethernet/freescale/fman/src/xx/Makefile
+++ b/drivers/net/ethernet/freescale/fman/src/xx/Makefile
@@ -8,5 +8,5 @@ include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
 obj-y		+= fsl-ncsw-xx.o
 
-fsl-ncsw-xx-objs	:=   xx_linux.o udivdi3.o stdlib.o \
+fsl-ncsw-xx-objs	:=   xx_linux.o  stdlib.o \
 				module_strings.o
diff --git a/drivers/net/ethernet/freescale/fman/src/xx/xx_linux.c b/drivers/net/ethernet/freescale/fman/src/xx/xx_linux.c
index 546c68b..d5c639a 100644
--- a/drivers/net/ethernet/freescale/fman/src/xx/xx_linux.c
+++ b/drivers/net/ethernet/freescale/fman/src/xx/xx_linux.c
@@ -400,33 +400,10 @@ typedef struct {
 
 t_Handle interruptHandlers[0x00010000];
 
-static irqreturn_t LinuxInterruptHandler (int irq, void *dev_id)
-{
-    t_InterruptHandler *p_IntrHndl = (t_InterruptHandler *)dev_id;
-    p_IntrHndl->f_Isr(p_IntrHndl->handle);
-    return IRQ_HANDLED;
-}
 
 t_Error XX_SetIntr(int irq, t_Isr *f_Isr, t_Handle handle)
 {
-    const char *device;
-    t_InterruptHandler *p_IntrHndl;
-
-    device = GetDeviceName(irq);
-    if (device == NULL)
-        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Interrupt source - %d", irq));
-
-    p_IntrHndl = (t_InterruptHandler *)XX_Malloc(sizeof(t_InterruptHandler));
-    if (p_IntrHndl == NULL)
-        RETURN_ERROR(MAJOR, E_NO_MEMORY, NO_MSG);
-    p_IntrHndl->f_Isr = f_Isr;
-    p_IntrHndl->handle = handle;
-    interruptHandlers[irq] = p_IntrHndl;
-
-    if (request_irq(GetDeviceIrqNum(irq), LinuxInterruptHandler, 0, device, p_IntrHndl) < 0)
-        RETURN_ERROR(MAJOR, E_BUSY, ("Can't get IRQ %s\n", device));
-    disable_irq(GetDeviceIrqNum(irq));
-
+/* not used */
     return E_OK;
 }
 
-- 
1.9.1

