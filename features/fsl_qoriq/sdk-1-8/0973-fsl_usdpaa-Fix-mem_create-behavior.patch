From f98e98a6ccc4f229d8037b59a0ca7ef3203f49ad Mon Sep 17 00:00:00 2001
From: Ahmed Mansour <Ahmed.Mansour@freescale.com>
Date: Wed, 3 Jun 2015 16:08:07 -0400
Subject: [PATCH 973/987] fsl_usdpaa: Fix mem_create behavior

Remove check added in previous patch to disallow size zero to be
passed from user space in dma_mem_create(). Size zero is deemed valid
if the memory region is already created and a second user wishes to
get a mapping to the existent memory.

Corrected values copied back to the user to include the length of the
memory and the flags. This is important to reflect a memory size
correction when the user passes size zero. The user can check the new
size using dma_mem_params()

Added a warning message if the user attempts to map to an existing
area in memory, but specifies a non-zero size that does not match the
original memory mapping. In the future this case will trigger an
error and the mapping will fail. Currently the behavior is to print a
warning message and the kernel passes back to user space the
corrected size.

Signed-off-by: Ahmed Mansour <Ahmed.Mansour@freescale.com>
Change-Id: Ib8535ada6f0fb616986bce3c52eae65f3bf583da
Reviewed-on: http://git.am.freescale.net:8181/37365
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Haiying Wang <Haiying.Wang@freescale.com>
Reviewed-by: Roy Pledge <roy.pledge@freescale.com>
Reviewed-by: Honghua Yin <Hong-Hua.Yin@freescale.com>
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c | 11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index 8ed7878..1f6df29 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -910,7 +910,7 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 	unsigned long next_addr = PAGE_SIZE, populate;
 
 	/* error checking to ensure values copied from user space are valid */
-	if (!i->len || (i->len % PAGE_SIZE))
+	if (i->len % PAGE_SIZE)
 		return -EINVAL;
 
 	map = kmalloc(sizeof(*map), GFP_KERNEL);
@@ -931,6 +931,13 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 					ret = -EBUSY;
 					goto out;
 				}
+
+				/* Check to ensure size matches record */
+				if (i->len != frag->map_len && i->len) {
+					pr_err("ioctl_dma_map() Size requested does not match %s and is none zero. This usage will be disallowed in future release\n",
+					frag->name);
+				}
+
 				/* Check if this has already been mapped
 				   to this process */
 				list_for_each_entry(tmp, &ctx->maps, list)
@@ -1656,6 +1663,8 @@ static long usdpaa_ioctl_compat(struct file *fp, unsigned int cmd,
 		ret = ioctl_dma_map(fp, ctx, &converted);
 		input.ptr = ptr_to_compat(converted.ptr);
 		input.phys_addr = converted.phys_addr;
+		input.len = converted.len;
+		input.flags = converted.flags;
 		strncpy(input.name, converted.name, USDPAA_DMA_NAME_MAX);
 		input.has_locking = converted.has_locking;
 		input.did_create = converted.did_create;
-- 
1.9.1

