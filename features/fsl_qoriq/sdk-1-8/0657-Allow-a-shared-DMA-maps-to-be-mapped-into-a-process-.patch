From 9001be7dc68bfdda27fae2b71783cad5616fb604 Mon Sep 17 00:00:00 2001
From: Roy Pledge <Roy.Pledge@freescale.com>
Date: Mon, 21 Apr 2014 13:43:55 -0400
Subject: [PATCH 657/987] Allow a shared DMA maps to be mapped into a process
 many times

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Add reference counting to the USDPAA DMA mapping logic so that
dma_mem_create() can be called multiple times on the same
shared region by a process.

Signed-off-by: Roy Pledge <Roy.Pledge@freescale.com>
Change-Id: I7419fd60b3f823764d367018d08f4e620ae09899
Reviewed-on: http://git.am.freescale.net:8181/11407
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Jeffrey Ladouceur <Jeffrey.Ladouceur@freescale.com>
Reviewed-by: Geoff Thorpe <Geoff.Thorpe@freescale.com>
Reviewed-by: Jose Rivera <German.Rivera@freescale.com>
---
 drivers/staging/fsl_qbman/fsl_usdpaa.c | 48 +++++++++++++++++++++++++---------
 1 file changed, 36 insertions(+), 12 deletions(-)

diff --git a/drivers/staging/fsl_qbman/fsl_usdpaa.c b/drivers/staging/fsl_qbman/fsl_usdpaa.c
index e933eb2..a1921c2 100644
--- a/drivers/staging/fsl_qbman/fsl_usdpaa.c
+++ b/drivers/staging/fsl_qbman/fsl_usdpaa.c
@@ -69,6 +69,8 @@ struct mem_mapping {
 	u32 frag_count;
 	u64 total_size;
 	struct list_head list;
+	int refs;
+	void *virt_addr;
 };
 
 struct portal_mapping {
@@ -869,8 +871,16 @@ static long ioctl_dma_map(struct file *fp, struct ctx *ctx,
 				   to this process */
 				list_for_each_entry(tmp, &ctx->maps, list)
 					if (tmp->root_frag == frag) {
-						ret = -EBUSY;
-						goto out;
+						/* Already mapped, just need to
+						   inc ref count */
+						tmp->refs++;
+						kfree(map);
+						i->did_create = 0;
+						i->len = frag->len;
+						i->phys_addr = frag->base;
+						i->ptr = tmp->virt_addr;
+						spin_unlock(&mem_lock);
+						return 0;
 					}
 				i->has_locking = frag->has_locking;
 				i->did_create = 0;
@@ -977,6 +987,7 @@ do_map:
 	map->root_frag = start_frag;
 	map->total_size = i->len;
 	map->frag_count = frag_count;
+	map->refs = 1;
 	list_add(&map->list, &ctx->maps);
 	i->phys_addr = start_frag->base;
 out:
@@ -996,9 +1007,10 @@ out:
 		up_write(&current->mm->mmap_sem);
 		if (longret & ~PAGE_MASK)
 			ret = (int)longret;
-		else
+		else {
 			i->ptr = (void *)longret;
-
+			map->virt_addr = i->ptr;
+		}
 	} else
 		kfree(map);
 	return ret;
@@ -1010,6 +1022,8 @@ static long ioctl_dma_unmap(struct ctx *ctx, void __user *arg)
 	struct vm_area_struct *vma;
 	int ret, i;
 	struct mem_fragment *current_frag;
+	size_t sz;
+	unsigned long base;
 
 	down_write(&current->mm->mmap_sem);
 	vma = find_vma(current->mm, (unsigned long)arg);
@@ -1029,8 +1043,19 @@ static long ioctl_dma_unmap(struct ctx *ctx, void __user *arg)
 			goto map_match;
 		}
 	}
-	map = NULL;
+	/* Failed to find a matching mapping for this process */
+	ret = -EFAULT;
+	spin_unlock(&mem_lock);
+	goto out;
 map_match:
+	map->refs--;
+	if (map->refs != 0) {
+		/* Another call the dma_map is referencing this */
+		ret = 0;
+		spin_unlock(&mem_lock);
+		goto out;
+	}
+
 	current_frag = map->root_frag;
 	for (i = 0; i < map->frag_count; i++) {
 		DPA_ASSERT(current_frag->refs > 0);
@@ -1041,13 +1066,12 @@ map_match:
 	list_del(&map->list);
 	compress_frags();
 	spin_unlock(&mem_lock);
-	if (map) {
-		unsigned long base = vma->vm_start;
-		size_t sz = vma->vm_end - vma->vm_start;
-		do_munmap(current->mm, base, sz);
-		ret = 0;
-	} else
-		ret = -EFAULT;
+
+	base = vma->vm_start;
+	sz = vma->vm_end - vma->vm_start;
+	do_munmap(current->mm, base, sz);
+	ret = 0;
+ out:
 	up_write(&current->mm->mmap_sem);
 	return ret;
 }
-- 
1.9.1

