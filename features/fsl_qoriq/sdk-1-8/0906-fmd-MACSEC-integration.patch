From aafcab1a85bc89f1d583d09bb0bf4a6ade64c56b Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Mon, 22 Sep 2014 17:16:57 +0300
Subject: [PATCH 906/987] fmd: MACSEC integration

This is the MACSEC lower API integration.

Change-Id: I3b6f172b323f1e297d6202856524ac059b7745c1
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/19442
Reviewed-by: Mandy Lavi <Mandy.Lavi@freescale.com>
Tested-by: Mandy Lavi <Mandy.Lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/28484
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Cristian-Constantin Sovaiala <Cristian.Sovaiala@freescale.com>
Reviewed-by: Honghua Yin <Hong-Hua.Yin@freescale.com>
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../freescale/fman/Peripherals/FM/MAC/memac.c      |   17 +-
 .../freescale/fman/Peripherals/FM/MACSEC/Makefile  |   15 +
 .../fman/Peripherals/FM/MACSEC/fm_macsec.c         |  237 ++++
 .../fman/Peripherals/FM/MACSEC/fm_macsec.h         |  203 ++++
 .../fman/Peripherals/FM/MACSEC/fm_macsec_guest.c   |   59 +
 .../fman/Peripherals/FM/MACSEC/fm_macsec_master.c  | 1028 ++++++++++++++++
 .../fman/Peripherals/FM/MACSEC/fm_macsec_master.h  |  476 ++++++++
 .../fman/Peripherals/FM/MACSEC/fm_macsec_secy.c    |  908 ++++++++++++++
 .../fman/Peripherals/FM/MACSEC/fm_macsec_secy.h    |  144 +++
 .../freescale/fman/Peripherals/FM/Makefile         |    1 +
 .../freescale/fman/inc/Peripherals/fm_macsec_ext.h | 1271 ++++++++++++++++++++
 .../P3040_P4080_P5020/dpaa_integration_ext.h       |   10 +
 .../inc/integrations/T4240/dpaa_integration_ext.h  |    9 +
 .../net/ethernet/freescale/fman/inc/xx_common.h    |    2 +-
 14 files changed, 4378 insertions(+), 2 deletions(-)
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/Makefile
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.c
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.h
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_guest.c
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.c
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.h
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.c
 create mode 100644 drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.h
 create mode 100644 drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_macsec_ext.h

diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
index 73c7769..24913de 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MAC/memac.c
@@ -695,6 +695,21 @@ static t_Error MemacDelExactMatchMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthA
 
 /* ......................................................................... */
 
+static t_Error MemacGetId(t_Handle h_Memac, uint32_t *macId)
+{
+    t_Memac     *p_Memac = (t_Memac *)h_Memac;
+
+    SANITY_CHECK_RETURN_ERROR(p_Memac, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_Memac->p_MemacDriverParam, E_INVALID_STATE);
+
+    *macId = p_Memac->macId;
+
+    return E_OK;
+}
+
+/* ......................................................................... */
+
+
 static t_Error MemacAddHashMacAddress(t_Handle h_Memac, t_EnetAddr *p_EthAddr)
 {
     t_Memac             *p_Memac = (t_Memac *)h_Memac;
@@ -1061,7 +1076,7 @@ static void InitFmMacControllerDriver(t_FmMacControllerDriver *p_FmMacController
     p_FmMacControllerDriver->f_FM_MAC_RemoveHashMacAddr         = MemacDelHashMacAddress;
     p_FmMacControllerDriver->f_FM_MAC_AddExactMatchMacAddr      = MemacAddExactMatchMacAddress;
     p_FmMacControllerDriver->f_FM_MAC_RemovelExactMatchMacAddr  = MemacDelExactMatchMacAddress;
-    p_FmMacControllerDriver->f_FM_MAC_GetId                     = NULL;
+    p_FmMacControllerDriver->f_FM_MAC_GetId                     = MemacGetId;
     p_FmMacControllerDriver->f_FM_MAC_GetVersion                = NULL;
     p_FmMacControllerDriver->f_FM_MAC_GetMaxFrameLength         = MemacGetMaxFrameLength;
 
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/Makefile
new file mode 100644
index 0000000..4ab19a3
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/Makefile
@@ -0,0 +1,15 @@
+#
+# Makefile for the Freescale Ethernet controllers
+#
+EXTRA_CFLAGS           += -DVERSION=\"\"
+#
+#Include netcomm SW specific definitions
+include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
+
+NCSW_FM_INC = $(srctree)/drivers/net/ethernet/freescale/fman/Peripherals/FM/inc
+
+EXTRA_CFLAGS += -I$(NCSW_FM_INC)
+
+obj-y		+= fsl-ncsw-macsec.o
+
+fsl-ncsw-macsec-objs	:= fm_macsec.o fm_macsec_guest.o fm_macsec_master.o fm_macsec_secy.o
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.c
new file mode 100644
index 0000000..0a1b31f
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.c
@@ -0,0 +1,237 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/******************************************************************************
+
+ @File          fm_macsec.c
+
+ @Description   FM MACSEC driver routines implementation.
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+
+#include "fm_macsec.h"
+
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_MACSEC_Config(t_FmMacsecParams *p_FmMacsecParam)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecParam, E_INVALID_HANDLE, NULL);
+
+    if (p_FmMacsecParam->guestMode)
+        p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)FM_MACSEC_GUEST_Config(p_FmMacsecParam);
+    else
+        p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)FM_MACSEC_MASTER_Config(p_FmMacsecParam);
+
+    if (!p_FmMacsecControllerDriver)
+        return NULL;
+
+    return (t_Handle)p_FmMacsecControllerDriver;
+}
+
+t_Error FM_MACSEC_Init(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_Init)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_Init(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_Free(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_Free)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_Free(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigUnknownSciFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUnknownSciFrameTreatment treatMode)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUnknownSciFrameTreatment)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUnknownSciFrameTreatment(h_FmMacsec, treatMode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigInvalidTagsFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigInvalidTagsFrameTreatment)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigInvalidTagsFrameTreatment(h_FmMacsec, deliverUncontrolled);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment(t_Handle h_FmMacsec, bool discardUncontrolled)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment(h_FmMacsec, discardUncontrolled);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigUntagFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUntagFrameTreatment treatMode)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUntagFrameTreatment)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUntagFrameTreatment(h_FmMacsec, treatMode);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigPnExhaustionThreshold(t_Handle h_FmMacsec, uint32_t pnExhThr)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigPnExhaustionThreshold)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigPnExhaustionThreshold(h_FmMacsec, pnExhThr);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigKeysUnreadable(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigKeysUnreadable)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigKeysUnreadable(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigSectagWithoutSCI(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigSectagWithoutSCI)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigSectagWithoutSCI(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_ConfigException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigException)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigException(h_FmMacsec, exception, enable);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_GetRevision(t_Handle h_FmMacsec, uint32_t *p_MacsecRevision)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_GetRevision)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_GetRevision(h_FmMacsec, p_MacsecRevision);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+
+t_Error FM_MACSEC_Enable(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_Enable)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_Enable(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_Disable(t_Handle h_FmMacsec)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_Disable)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_Disable(h_FmMacsec);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SetException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable)
+{
+    t_FmMacsecControllerDriver *p_FmMacsecControllerDriver = (t_FmMacsecControllerDriver *)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecControllerDriver, E_INVALID_HANDLE);
+
+    if (p_FmMacsecControllerDriver->f_FM_MACSEC_SetException)
+        return p_FmMacsecControllerDriver->f_FM_MACSEC_SetException(h_FmMacsec, exception, enable);
+
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.h
new file mode 100644
index 0000000..fbe5187
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec.h
@@ -0,0 +1,203 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec.h
+
+ @Description   FM MACSEC internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_MACSEC_H
+#define __FM_MACSEC_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+#include "fm_macsec_ext.h"
+
+#include "fm_common.h"
+
+
+#define __ERR_MODULE__  MODULE_FM_MACSEC
+
+
+typedef struct
+{
+    t_Error (*f_FM_MACSEC_Init) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_Free) (t_Handle h_FmMacsec);
+
+    t_Error (*f_FM_MACSEC_ConfigUnknownSciFrameTreatment) (t_Handle h_FmMacsec, e_FmMacsecUnknownSciFrameTreatment treatMode);
+    t_Error (*f_FM_MACSEC_ConfigInvalidTagsFrameTreatment) (t_Handle h_FmMacsec, bool deliverUncontrolled);
+    t_Error (*f_FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment) (t_Handle h_FmMacsec, bool discardUncontrolled);
+    t_Error (*f_FM_MACSEC_ConfigChangedTextWithNoEncryptFrameTreatment) (t_Handle h_FmMacsec, bool deliverUncontrolled);
+    t_Error (*f_FM_MACSEC_ConfigUntagFrameTreatment) (t_Handle h_FmMacsec, e_FmMacsecUntagFrameTreatment treatMode);
+    t_Error (*f_FM_MACSEC_ConfigOnlyScbIsSetFrameTreatment) (t_Handle h_FmMacsec, bool deliverUncontrolled);
+    t_Error (*f_FM_MACSEC_ConfigPnExhaustionThreshold) (t_Handle h_FmMacsec, uint32_t pnExhThr);
+    t_Error (*f_FM_MACSEC_ConfigKeysUnreadable) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_ConfigSectagWithoutSCI) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_ConfigException) (t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable);
+
+    t_Error (*f_FM_MACSEC_GetRevision) (t_Handle h_FmMacsec, uint32_t *p_MacsecRevision);
+    t_Error (*f_FM_MACSEC_Enable) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_Disable) (t_Handle h_FmMacsec);
+    t_Error (*f_FM_MACSEC_SetException) (t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable);
+
+} t_FmMacsecControllerDriver;
+
+t_Handle  FM_MACSEC_GUEST_Config(t_FmMacsecParams *p_FmMacsecParam);
+t_Handle  FM_MACSEC_MASTER_Config(t_FmMacsecParams *p_FmMacsecParams);
+
+/***********************************************************************/
+/*  MACSEC internal routines                                              */
+/***********************************************************************/
+
+/**************************************************************************//**
+
+ @Group         FM_MACSEC_InterModule_grp FM MACSEC Inter-Module Unit
+
+ @Description   FM MACSEC Inter Module functions -
+                These are not User API routines but routines that may be called
+                from other modules. This will be the case in a single core environment,
+                where instead of using the XX messaging mechanism, the routines may be
+                called from other modules. In a multicore environment, the other modules may
+                be run by other cores and therefore these routines may not be called directly.
+
+ @{
+*//***************************************************************************/
+
+#define MAX_NUM_OF_SA_PER_SC        4
+
+typedef enum
+{
+    e_SC_RX = 0,
+    e_SC_TX
+} e_ScType;
+
+typedef enum
+{
+    e_SC_SA_A = 0,
+    e_SC_SA_B ,
+    e_SC_SA_C ,
+    e_SC_SA_D
+} e_ScSaId;
+
+typedef struct
+{
+    uint32_t                        scId;
+    macsecSCI_t                     sci;
+    bool                            replayProtect;
+    uint32_t                        replayWindow;
+    e_FmMacsecValidFrameBehavior    validateFrames;
+    uint16_t                        confidentialityOffset;
+    e_FmMacsecSecYCipherSuite       cipherSuite;
+} t_RxScParams;
+
+typedef struct
+{
+    uint32_t                        scId;
+    macsecSCI_t                     sci;
+    bool                            protectFrames;
+    e_FmMacsecSciInsertionMode      sciInsertionMode;
+    bool                            confidentialityEnable;
+    uint16_t                        confidentialityOffset;
+    e_FmMacsecSecYCipherSuite       cipherSuite;
+} t_TxScParams;
+
+typedef enum e_FmMacsecGlobalExceptions {
+    e_FM_MACSEC_EX_TX_SC,               /**< Tx Sc 0 frame discarded error. */
+    e_FM_MACSEC_EX_ECC                  /**< MACSEC memory ECC multiple-bit error. */
+} e_FmMacsecGlobalExceptions;
+
+typedef enum e_FmMacsecGlobalEvents {
+    e_FM_MACSEC_EV_TX_SC_NEXT_PN        /**< Tx Sc 0 Next Pn exhaustion threshold reached. */
+} e_FmMacsecGlobalEvents;
+
+/**************************************************************************//**
+ @Description   Enum for inter-module interrupts registration
+*//***************************************************************************/
+typedef enum e_FmMacsecEventModules{
+    e_FM_MACSEC_MOD_SC_TX,
+    e_FM_MACSEC_MOD_DUMMY_LAST
+} e_FmMacsecEventModules;
+
+typedef enum e_FmMacsecInterModuleEvent {
+    e_FM_MACSEC_EV_SC_TX,
+    e_FM_MACSEC_EV_ERR_SC_TX,
+    e_FM_MACSEC_EV_DUMMY_LAST
+} e_FmMacsecInterModuleEvent;
+
+#define NUM_OF_INTER_MODULE_EVENTS (NUM_OF_TX_SC * 2)
+
+#define GET_MACSEC_MODULE_EVENT(mod, id, intrType, event) \
+    switch(mod){                                          \
+        case e_FM_MACSEC_MOD_SC_TX:                       \
+             event = (intrType == e_FM_INTR_TYPE_ERR) ?   \
+                        e_FM_MACSEC_EV_ERR_SC_TX:         \
+                        e_FM_MACSEC_EV_SC_TX;             \
+             event += (uint8_t)(2 * id);break;            \
+            break;                                        \
+        default:event = e_FM_MACSEC_EV_DUMMY_LAST;        \
+        break;}
+
+void FmMacsecRegisterIntr(t_Handle                h_FmMacsec,
+                          e_FmMacsecEventModules  module,
+                          uint8_t                 modId,
+                          e_FmIntrType            intrType,
+                          void (*f_Isr) (t_Handle h_Arg, uint32_t id),
+                          t_Handle                h_Arg);
+
+void FmMacsecUnregisterIntr(t_Handle                h_FmMacsec,
+                            e_FmMacsecEventModules  module,
+                            uint8_t                 modId,
+                            e_FmIntrType            intrType);
+
+t_Error FmMacsecAllocScs(t_Handle h_FmMacsec, e_ScType type, bool isPtp, uint32_t numOfScs, uint32_t *p_ScIds);
+t_Error FmMacsecFreeScs(t_Handle h_FmMacsec, e_ScType type, uint32_t numOfScs, uint32_t *p_ScIds);
+t_Error FmMacsecCreateRxSc(t_Handle h_FmMacsec, t_RxScParams *p_RxScParams);
+t_Error FmMacsecDeleteRxSc(t_Handle h_FmMacsec, uint32_t scId);
+t_Error FmMacsecCreateTxSc(t_Handle h_FmMacsec, t_TxScParams *p_RxScParams);
+t_Error FmMacsecDeleteTxSc(t_Handle h_FmMacsec, uint32_t scId);
+t_Error FmMacsecCreateRxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecAN_t an, uint32_t lowestPn, macsecSAKey_t key);
+t_Error FmMacsecCreateTxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecSAKey_t key);
+t_Error FmMacsecDeleteRxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId);
+t_Error FmMacsecDeleteTxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId);
+t_Error FmMacsecRxSaSetReceive(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, bool enableReceive);
+t_Error FmMacsecRxSaUpdateNextPn(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, uint32_t updtNextPN);
+t_Error FmMacsecRxSaUpdateLowestPn(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, uint32_t updtLowestPN);
+t_Error FmMacsecTxSaSetActive(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecAN_t an);
+t_Error FmMacsecTxSaGetActive(t_Handle h_FmMacsec, uint32_t scId, macsecAN_t *p_An);
+t_Error FmMacsecSetPTP(t_Handle h_FmMacsec, bool enable);
+
+t_Error FmMacsecSetException(t_Handle h_FmMacsec, e_FmMacsecGlobalExceptions exception, uint32_t scId, bool enable);
+t_Error FmMacsecSetEvent(t_Handle h_FmMacsec, e_FmMacsecGlobalEvents event, uint32_t scId, bool enable);
+
+
+
+#endif /* __FM_MACSEC_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_guest.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_guest.c
new file mode 100644
index 0000000..31d789d
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_guest.c
@@ -0,0 +1,59 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec.c
+
+ @Description   FM MACSEC driver routines implementation.
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "debug_ext.h"
+#include "fm_macsec.h"
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_MACSEC_GUEST_Config(t_FmMacsecParams *p_FmMacsecParam)
+{
+    UNUSED(p_FmMacsecParam);
+    return NULL;
+}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.c
new file mode 100644
index 0000000..237c4e5
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.c
@@ -0,0 +1,1028 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec.c
+
+ @Description   FM MACSEC driver routines implementation.
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+#include "fm_mac_ext.h"
+
+#include "fm_macsec_master.h"
+
+
+extern uint16_t    FM_MAC_GetMaxFrameLength(t_Handle FmMac);
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+static t_Error CheckFmMacsecParameters(t_FmMacsec *p_FmMacsec)
+{
+    if (!p_FmMacsec->f_Exception)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+
+    return E_OK;
+}
+
+static void UnimplementedIsr(t_Handle h_Arg, uint32_t id)
+{
+    UNUSED(h_Arg); UNUSED(id);
+
+    REPORT_ERROR(MAJOR, E_NOT_SUPPORTED, ("Unimplemented Isr!"));
+}
+
+static void MacsecEventIsr(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    events,event,i;
+
+    SANITY_CHECK_RETURN(p_FmMacsec, E_INVALID_HANDLE);
+
+    events = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->evr);
+    events |= GET_UINT32(p_FmMacsec->p_FmMacsecRegs->ever);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->evr,events);
+
+    for (i=0; i<NUM_OF_TX_SC; i++)
+        if (events & FM_MACSEC_EV_TX_SC_NEXT_PN(i))
+        {
+            GET_MACSEC_MODULE_EVENT(e_FM_MACSEC_MOD_SC_TX, i, e_FM_INTR_TYPE_NORMAL, event);
+            p_FmMacsec->intrMng[event].f_Isr(p_FmMacsec->intrMng[event].h_SrcHandle, i);
+        }
+}
+
+static void MacsecErrorIsr(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    errors,error,i;
+
+    SANITY_CHECK_RETURN(p_FmMacsec, E_INVALID_HANDLE);
+
+    errors = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->err);
+    errors |= GET_UINT32(p_FmMacsec->p_FmMacsecRegs->erer);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->err,errors);
+
+    for (i=0; i<NUM_OF_TX_SC; i++)
+        if (errors & FM_MACSEC_EX_TX_SC(i))
+        {
+            GET_MACSEC_MODULE_EVENT(e_FM_MACSEC_MOD_SC_TX, i, e_FM_INTR_TYPE_ERR, error);
+            p_FmMacsec->intrMng[error].f_Isr(p_FmMacsec->intrMng[error].h_SrcHandle, i);
+        }
+
+    if (errors & FM_MACSEC_EX_ECC)
+    {
+        uint8_t     eccType;
+        uint32_t    tmpReg;
+
+        tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->meec);
+        ASSERT_COND(tmpReg & MECC_CAP);
+        eccType = (uint8_t)((tmpReg & MECC_CET) >> MECC_CET_SHIFT);
+
+        if (!eccType && (p_FmMacsec->userExceptions & FM_MACSEC_USER_EX_SINGLE_BIT_ECC))
+            p_FmMacsec->f_Exception(p_FmMacsec->h_App,e_FM_MACSEC_EX_SINGLE_BIT_ECC);
+        else if (eccType && (p_FmMacsec->userExceptions & FM_MACSEC_USER_EX_MULTI_BIT_ECC))
+            p_FmMacsec->f_Exception(p_FmMacsec->h_App,e_FM_MACSEC_EX_MULTI_BIT_ECC);
+        else
+            WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->meec,tmpReg);
+    }
+}
+
+static t_Error MacsecInit(t_Handle h_FmMacsec)
+{
+    t_FmMacsec                  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_FmMacsecDriverParam       *p_FmMacsecDriverParam = NULL;
+    uint32_t                    tmpReg,i,macId;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    CHECK_INIT_PARAMETERS(p_FmMacsec, CheckFmMacsecParameters);
+
+    p_FmMacsecDriverParam = p_FmMacsec->p_FmMacsecDriverParam;
+
+    for (i=0;i<e_FM_MACSEC_EV_DUMMY_LAST;i++)
+        p_FmMacsec->intrMng[i].f_Isr = UnimplementedIsr;
+
+    tmpReg = 0;
+    tmpReg |= (p_FmMacsecDriverParam->changedTextWithNoEncryptDeliverUncontrolled << CFG_UECT_SHIFT)|
+              (p_FmMacsecDriverParam->onlyScbIsSetDeliverUncontrolled << CFG_ESCBT_SHIFT)           |
+              (p_FmMacsecDriverParam->unknownSciTreatMode << CFG_USFT_SHIFT)                        |
+              (p_FmMacsecDriverParam->invalidTagsDeliverUncontrolled << CFG_ITT_SHIFT)              |
+              (p_FmMacsecDriverParam->encryptWithNoChangedTextDiscardUncontrolled << CFG_KFT_SHIFT) |
+              (p_FmMacsecDriverParam->untagTreatMode << CFG_UFT_SHIFT)                              |
+              (p_FmMacsecDriverParam->keysUnreadable << CFG_KSS_SHIFT)                              |
+              (p_FmMacsecDriverParam->reservedSc0 << CFG_S0I_SHIFT)                                 |
+              (p_FmMacsecDriverParam->byPassMode << CFG_BYPN_SHIFT);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg, tmpReg);
+
+    tmpReg = FM_MAC_GetMaxFrameLength(p_FmMacsec->h_FmMac);
+    /* Ethernet FCS (4 bytes) overhead must be subtracted from MFL*/
+    tmpReg -= 4;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->mfl, tmpReg);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->tpnet, p_FmMacsecDriverParam->pnExhThr);
+
+    if (!p_FmMacsec->userExceptions)
+        p_FmMacsec->exceptions &= ~FM_MACSEC_EX_ECC;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->erer, p_FmMacsec->exceptions);
+
+    p_FmMacsec->numRxScAvailable = NUM_OF_RX_SC;
+    if (p_FmMacsecDriverParam->reservedSc0)
+        p_FmMacsec->numRxScAvailable --;
+    p_FmMacsec->numTxScAvailable = NUM_OF_TX_SC;
+
+    XX_Free(p_FmMacsecDriverParam);
+    p_FmMacsec->p_FmMacsecDriverParam = NULL;
+
+    FM_MAC_GetId(p_FmMacsec->h_FmMac, &macId);
+    FmRegisterIntr(p_FmMacsec->h_Fm,
+                   e_FM_MOD_MACSEC,
+                   (uint8_t)macId,
+                   e_FM_INTR_TYPE_NORMAL,
+                   MacsecEventIsr,
+                   p_FmMacsec);
+
+    FmRegisterIntr(p_FmMacsec->h_Fm,
+                   e_FM_MOD_MACSEC,
+                   0,
+                   e_FM_INTR_TYPE_ERR,
+                   MacsecErrorIsr,
+                   p_FmMacsec);
+
+    return E_OK;
+}
+
+static t_Error MacsecFree(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    macId;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    FM_MAC_GetId(p_FmMacsec->h_FmMac, &macId);
+    FmUnregisterIntr(p_FmMacsec->h_Fm,
+                   e_FM_MOD_MACSEC,
+                   (uint8_t)macId,
+                   e_FM_INTR_TYPE_NORMAL);
+
+    FmUnregisterIntr(p_FmMacsec->h_Fm,
+                   e_FM_MOD_MACSEC,
+                   0,
+                   e_FM_INTR_TYPE_ERR);
+
+    if (p_FmMacsec->rxScSpinLock)
+        XX_FreeSpinlock(p_FmMacsec->rxScSpinLock);
+    if (p_FmMacsec->txScSpinLock)
+        XX_FreeSpinlock(p_FmMacsec->txScSpinLock);
+
+    XX_Free(p_FmMacsec);
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigUnknownSciFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUnknownSciFrameTreatment treatMode)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->unknownSciTreatMode = treatMode;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigInvalidTagsFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->invalidTagsDeliverUncontrolled = deliverUncontrolled;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigChangedTextWithNoEncryptFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->changedTextWithNoEncryptDeliverUncontrolled = deliverUncontrolled;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigOnlyScbIsSetFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->onlyScbIsSetDeliverUncontrolled = deliverUncontrolled;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigEncryptWithNoChangedTextFrameTreatment(t_Handle h_FmMacsec, bool discardUncontrolled)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->encryptWithNoChangedTextDiscardUncontrolled = discardUncontrolled;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigUntagFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUntagFrameTreatment treatMode)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->untagTreatMode = treatMode;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigPnExhaustionThreshold(t_Handle h_FmMacsec, uint32_t pnExhThr)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->pnExhThr = pnExhThr;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigKeysUnreadable(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->keysUnreadable = TRUE;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigSectagWithoutSCI(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    p_FmMacsec->p_FmMacsecDriverParam->sectagOverhead -= MACSEC_SCI_SIZE;
+
+    return E_OK;
+}
+
+static t_Error MacsecConfigException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    bitMask = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    GET_USER_EXCEPTION_FLAG(bitMask, exception);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsec->userExceptions |= bitMask;
+        else
+            p_FmMacsec->userExceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+static t_Error MacsecGetRevision(t_Handle h_FmMacsec, uint32_t *p_MacsecRevision)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    *p_MacsecRevision = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->ip_rev1);
+
+    return E_OK;
+}
+
+static t_Error MacsecEnable(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    tmpReg  = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg);
+    tmpReg |= CFG_BYPN;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg,tmpReg);
+
+    return E_OK;
+}
+
+static t_Error MacsecDisable(t_Handle h_FmMacsec)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    tmpReg;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    tmpReg  = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg);
+    tmpReg &= ~CFG_BYPN;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg,tmpReg);
+
+    return E_OK;
+}
+
+static t_Error MacsecSetException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    GET_USER_EXCEPTION_FLAG(bitMask, exception);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsec->userExceptions |= bitMask;
+        else
+            p_FmMacsec->userExceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    if (!p_FmMacsec->userExceptions)
+        p_FmMacsec->exceptions &= ~FM_MACSEC_EX_ECC;
+    else
+        p_FmMacsec->exceptions |= FM_MACSEC_EX_ECC;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->erer, p_FmMacsec->exceptions);
+
+    return E_OK;
+}
+
+static void InitFmMacsecControllerDriver(t_FmMacsecControllerDriver *p_FmMacsecControllerDriver)
+{
+    p_FmMacsecControllerDriver->f_FM_MACSEC_Init                                            = MacsecInit;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_Free                                            = MacsecFree;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUnknownSciFrameTreatment                  = MacsecConfigUnknownSciFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigInvalidTagsFrameTreatment                 = MacsecConfigInvalidTagsFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment    = MacsecConfigEncryptWithNoChangedTextFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigUntagFrameTreatment                       = MacsecConfigUntagFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigChangedTextWithNoEncryptFrameTreatment    = MacsecConfigChangedTextWithNoEncryptFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigOnlyScbIsSetFrameTreatment                = MacsecConfigOnlyScbIsSetFrameTreatment;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigPnExhaustionThreshold                     = MacsecConfigPnExhaustionThreshold;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigKeysUnreadable                            = MacsecConfigKeysUnreadable;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigSectagWithoutSCI                          = MacsecConfigSectagWithoutSCI;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_ConfigException                                 = MacsecConfigException;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_GetRevision                                     = MacsecGetRevision;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_Enable                                          = MacsecEnable;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_Disable                                         = MacsecDisable;
+    p_FmMacsecControllerDriver->f_FM_MACSEC_SetException                                    = MacsecSetException;
+}
+
+/****************************************/
+/*       Inter-Module functions         */
+/****************************************/
+
+void FmMacsecRegisterIntr(t_Handle                h_FmMacsec,
+                          e_FmMacsecEventModules  module,
+                          uint8_t                 modId,
+                          e_FmIntrType            intrType,
+                          void (*f_Isr) (t_Handle h_Arg, uint32_t id),
+                          t_Handle                h_Arg)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint8_t     event= 0;
+
+    SANITY_CHECK_RETURN(p_FmMacsec, E_INVALID_HANDLE);
+
+    GET_MACSEC_MODULE_EVENT(module, modId, intrType, event);
+
+    ASSERT_COND(event != e_FM_MACSEC_EV_DUMMY_LAST);
+    p_FmMacsec->intrMng[event].f_Isr = f_Isr;
+    p_FmMacsec->intrMng[event].h_SrcHandle = h_Arg;
+}
+
+void FmMacsecUnregisterIntr(t_Handle                h_FmMacsec,
+                            e_FmMacsecEventModules  module,
+                            uint8_t                 modId,
+                            e_FmIntrType            intrType)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint8_t     event= 0;
+
+    SANITY_CHECK_RETURN(p_FmMacsec, E_INVALID_HANDLE);
+
+    GET_MACSEC_MODULE_EVENT(module, modId,intrType, event);
+
+    ASSERT_COND(event != e_FM_MACSEC_EV_DUMMY_LAST);
+    p_FmMacsec->intrMng[event].f_Isr = NULL;
+    p_FmMacsec->intrMng[event].h_SrcHandle = NULL;
+}
+
+t_Error FmMacsecAllocScs(t_Handle h_FmMacsec, e_ScType type, bool isPtp, uint32_t numOfScs, uint32_t *p_ScIds)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    bool        *p_ScTable;
+    uint32_t    *p_ScAvailable,i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ScIds, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(numOfScs, E_INVALID_HANDLE);
+
+    if (type == e_SC_RX)
+    {
+        p_ScTable       = (bool *)p_FmMacsec->rxScTable;
+        p_ScAvailable   = &p_FmMacsec->numRxScAvailable;
+        i               = (NUM_OF_RX_SC - 1);
+    }
+    else
+    {
+        p_ScTable       = (bool *)p_FmMacsec->txScTable;
+        p_ScAvailable   = &p_FmMacsec->numTxScAvailable;
+        i               = (NUM_OF_TX_SC - 1);
+
+    }
+    if (*p_ScAvailable < numOfScs)
+        RETURN_ERROR(MINOR, E_NOT_AVAILABLE, ("Not enough SCs available"));
+
+    if (isPtp)
+    {
+        i = 0;
+        if (p_ScTable[i])
+            RETURN_ERROR(MINOR, E_NOT_AVAILABLE, ("Sc 0 Not available"));
+    }
+
+    for (;numOfScs;i--)
+    {
+        if (p_ScTable[i])
+            continue;
+        numOfScs --;
+        (*p_ScAvailable)--;
+        p_ScIds[numOfScs] = i;
+        p_ScTable[i] = TRUE;
+    }
+
+    return err;
+}
+
+t_Error FmMacsecFreeScs(t_Handle h_FmMacsec, e_ScType type, uint32_t numOfScs, uint32_t *p_ScIds)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    bool        *p_ScTable;
+    uint32_t    *p_ScAvailable,maxNumOfSc,i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_ScIds, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(numOfScs, E_INVALID_HANDLE);
+
+    if (type == e_SC_RX)
+    {
+        p_ScTable       = (bool *)p_FmMacsec->rxScTable;
+        p_ScAvailable   = &p_FmMacsec->numRxScAvailable;
+        maxNumOfSc      = NUM_OF_RX_SC;
+    }
+    else
+    {
+        p_ScTable       = (bool *)p_FmMacsec->txScTable;
+        p_ScAvailable   = &p_FmMacsec->numTxScAvailable;
+        maxNumOfSc      = NUM_OF_TX_SC;
+    }
+
+    if ((*p_ScAvailable + numOfScs) > maxNumOfSc)
+        RETURN_ERROR(MINOR, E_FULL, ("Too much SCs"));
+
+    for (i=0;i<numOfScs;i++)
+    {
+        p_ScTable[p_ScIds[i]] = FALSE;
+        (*p_ScAvailable)++;
+    }
+
+    return err;
+
+}
+
+t_Error FmMacsecSetPTP(t_Handle h_FmMacsec, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    tmpReg = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg);
+    if (enable && (tmpReg & CFG_S0I))
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("MACSEC already in point-to-point mode"));
+
+    if (enable)
+        tmpReg |= CFG_S0I;
+    else
+        tmpReg &= CFG_S0I;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->cfg, tmpReg);
+
+    return E_OK;
+}
+
+t_Error FmMacsecCreateRxSc(t_Handle h_FmMacsec, t_RxScParams *p_RxScParams)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_RxScParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_RxScParams->scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, p_RxScParams->scId);
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsccfg);
+    if (tmpReg & RX_SCCFG_SCI_EN_MASK)
+    {
+        XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Rx Sc %d must be disable",p_RxScParams->scId));
+    }
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsci1h, GET_SCI_FIRST_HALF(p_RxScParams->sci));
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsci2h, GET_SCI_SECOND_HALF(p_RxScParams->sci));
+    tmpReg |= ((p_RxScParams->replayProtect << RX_SCCFG_RP_SHIFT) & RX_SCCFG_RP_MASK);
+    tmpReg |= ((p_RxScParams->validateFrames << RX_SCCFG_VF_SHIFT) & RX_SCCFG_VF_MASK);
+    tmpReg |= ((p_RxScParams->confidentialityOffset << RX_SCCFG_CO_SHIFT) & RX_SCCFG_CO_MASK);
+    tmpReg |= RX_SCCFG_SCI_EN_MASK;
+    tmpReg |= (p_RxScParams->cipherSuite << RX_SCCFG_CS_SHIFT);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsccfg, tmpReg);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rpw, p_RxScParams->replayWindow);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecDeleteRxSc(t_Handle h_FmMacsec, uint32_t scId)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    tmpReg &= ~RX_SCCFG_SCI_EN_MASK;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsccfg, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecCreateTxSc(t_Handle h_FmMacsec, t_TxScParams *p_TxScParams)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+    bool        alwaysIncludeSCI = FALSE, useES = FALSE, useSCB = FALSE;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TxScParams, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_TxScParams->scId < NUM_OF_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, p_TxScParams->scId);
+
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg);
+    if (tmpReg & TX_SCCFG_SCE_MASK)
+    {
+        XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("Tx Sc %d must be disable",p_TxScParams->scId));
+    }
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsci1h, GET_SCI_FIRST_HALF(p_TxScParams->sci));
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsci2h, GET_SCI_SECOND_HALF(p_TxScParams->sci));
+    alwaysIncludeSCI = (p_TxScParams->sciInsertionMode == e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_SECTAG);
+    useES            = (p_TxScParams->sciInsertionMode == e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_MAC_SA);
+
+    tmpReg |= ((p_TxScParams->protectFrames << TX_SCCFG_PF_SHIFT) & TX_SCCFG_PF_MASK);
+    tmpReg |= ((alwaysIncludeSCI << TX_SCCFG_AIS_SHIFT) & TX_SCCFG_AIS_MASK);
+    tmpReg |= ((useES << TX_SCCFG_UES_SHIFT) & TX_SCCFG_UES_MASK);
+    tmpReg |= ((useSCB << TX_SCCFG_USCB_SHIFT) & TX_SCCFG_USCB_MASK);
+    tmpReg |= ((p_TxScParams->confidentialityEnable << TX_SCCFG_CE_SHIFT) & TX_SCCFG_CE_MASK);
+    tmpReg |= ((p_TxScParams->confidentialityOffset << TX_SCCFG_CO_SHIFT) & TX_SCCFG_CO_MASK);
+    tmpReg |= TX_SCCFG_SCE_MASK;
+    tmpReg |= (p_TxScParams->cipherSuite << TX_SCCFG_CS_SHIFT);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecDeleteTxSc(t_Handle h_FmMacsec, uint32_t scId)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    tmpReg &= ~TX_SCCFG_SCE_MASK;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecCreateRxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecAN_t an, uint32_t lowestPn, macsecSAKey_t key)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsanpn, DEFAULT_initNextPn);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsalpn, lowestPn);
+    Mem2IOCpy32((void*)p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsak, key, sizeof(macsecSAKey_t));
+
+    tmpReg |= RX_SACFG_ACTIVE;
+    tmpReg |= ((an << RX_SACFG_AN_SHIFT) & RX_SACFG_AN_MASK);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecCreateTxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecSAKey_t key)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsanpn, DEFAULT_initNextPn);
+    Mem2IOCpy32((void*)p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsak, key, sizeof(macsecSAKey_t));
+
+    tmpReg |= TX_SACFG_ACTIVE;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecDeleteRxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, i, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsanpn, 0x0);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsalpn, 0x0);
+    for (i=0; i<4; i++)
+        WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsak[i], 0x0);
+
+    tmpReg |= RX_SACFG_ACTIVE;
+    tmpReg &= ~RX_SACFG_EN_MASK;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecDeleteTxSa(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, i, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsanpn, 0x0);
+    for (i=0; i<4; i++)
+        WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsak[i], 0x0);
+
+    tmpReg |= TX_SACFG_ACTIVE;
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecTxScSa[saId].txsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecRxSaSetReceive(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, bool enableReceive)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsacs);
+    if (enableReceive)
+        tmpReg |= RX_SACFG_EN_MASK;
+    else
+        tmpReg &= ~RX_SACFG_EN_MASK;
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsacs, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecRxSaUpdateNextPn(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, uint32_t updtNextPN)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsanpn, updtNextPN);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecRxSaUpdateLowestPn(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, uint32_t updtLowestPN)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_RX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->rxScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->rxsca, scId);
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->fmMacsecRxScSa[saId].rxsalpn, updtLowestPN);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->rxScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecTxSaSetActive(t_Handle h_FmMacsec, uint32_t scId, e_ScSaId saId, macsecAN_t an)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(saId < NUM_OF_SA_PER_TX_SC, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg);
+
+    tmpReg |= ((an << TX_SCCFG_AN_SHIFT) & TX_SCCFG_AN_MASK);
+    tmpReg |= ((saId << TX_SCCFG_ASA_SHIFT) & TX_SCCFG_ASA_MASK);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg, tmpReg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    return err;
+}
+
+t_Error FmMacsecTxSaGetActive(t_Handle h_FmMacsec, uint32_t scId, macsecAN_t *p_An)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    t_Error     err = E_OK;
+    uint32_t    tmpReg = 0, intFlags;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(scId < NUM_OF_RX_SC, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_An, E_INVALID_HANDLE);
+
+    intFlags = XX_LockIntrSpinlock(p_FmMacsec->txScSpinLock);
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->txsca, scId);
+
+    tmpReg = GET_UINT32(p_FmMacsec->p_FmMacsecRegs->txsccfg);
+
+    XX_UnlockIntrSpinlock(p_FmMacsec->txScSpinLock, intFlags);
+
+    *p_An = (macsecAN_t)((tmpReg & TX_SCCFG_AN_MASK) >> TX_SCCFG_AN_SHIFT);
+
+    return err;
+}
+
+t_Error FmMacsecSetException(t_Handle h_FmMacsec, e_FmMacsecGlobalExceptions exception, uint32_t scId, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception, scId);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsec->exceptions |= bitMask;
+        else
+            p_FmMacsec->exceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->erer, p_FmMacsec->exceptions);
+
+    return E_OK;
+}
+
+t_Error FmMacsecSetEvent(t_Handle h_FmMacsec, e_FmMacsecGlobalEvents event, uint32_t scId, bool enable)
+{
+    t_FmMacsec  *p_FmMacsec = (t_FmMacsec*)h_FmMacsec;
+    uint32_t    bitMask;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsec->p_FmMacsecDriverParam, E_INVALID_HANDLE);
+
+    GET_EVENT_FLAG(bitMask, event, scId);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsec->events |= bitMask;
+        else
+            p_FmMacsec->events &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined event"));
+
+    WRITE_UINT32(p_FmMacsec->p_FmMacsecRegs->ever, p_FmMacsec->events);
+
+    return E_OK;
+}
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_MACSEC_MASTER_Config(t_FmMacsecParams *p_FmMacsecParam)
+{
+    t_FmMacsec  *p_FmMacsec;
+    uint32_t    macId;
+
+    /* Allocate FM MACSEC structure */
+    p_FmMacsec = (t_FmMacsec *) XX_Malloc(sizeof(t_FmMacsec));
+    if (!p_FmMacsec)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC driver structure"));
+        return NULL;
+    }
+    memset(p_FmMacsec, 0, sizeof(t_FmMacsec));
+    InitFmMacsecControllerDriver(&p_FmMacsec->fmMacsecControllerDriver);
+
+    /* Allocate the FM MACSEC driver's parameters structure */
+    p_FmMacsec->p_FmMacsecDriverParam = (t_FmMacsecDriverParam *)XX_Malloc(sizeof(t_FmMacsecDriverParam));
+    if (!p_FmMacsec->p_FmMacsecDriverParam)
+    {
+        XX_Free(p_FmMacsec);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC driver parameters"));
+        return NULL;
+    }
+    memset(p_FmMacsec->p_FmMacsecDriverParam, 0, sizeof(t_FmMacsecDriverParam));
+
+    /* Initialize FM MACSEC parameters which will be kept by the driver */
+    p_FmMacsec->h_Fm            = p_FmMacsecParam->h_Fm;
+    p_FmMacsec->h_FmMac         = p_FmMacsecParam->nonGuestParams.h_FmMac;
+    p_FmMacsec->p_FmMacsecRegs  = (t_FmMacsecRegs *)UINT_TO_PTR(p_FmMacsecParam->nonGuestParams.baseAddr);
+    p_FmMacsec->f_Exception     = p_FmMacsecParam->nonGuestParams.f_Exception;
+    p_FmMacsec->h_App           = p_FmMacsecParam->nonGuestParams.h_App;
+    p_FmMacsec->userExceptions  = DEFAULT_userExceptions;
+    p_FmMacsec->exceptions      = DEFAULT_exceptions;
+    p_FmMacsec->events          = DEFAULT_events;
+    p_FmMacsec->rxScSpinLock    = XX_InitSpinlock();
+    p_FmMacsec->txScSpinLock    = XX_InitSpinlock();
+
+    /* Initialize FM MACSEC driver parameters parameters (for initialization phase only) */
+    p_FmMacsec->p_FmMacsecDriverParam->unknownSciTreatMode                           = DEFAULT_unknownSciFrameTreatment;
+    p_FmMacsec->p_FmMacsecDriverParam->invalidTagsDeliverUncontrolled                = DEFAULT_invalidTagsFrameTreatment;
+    p_FmMacsec->p_FmMacsecDriverParam->encryptWithNoChangedTextDiscardUncontrolled   = DEFAULT_encryptWithNoChangedTextFrameTreatment;
+    p_FmMacsec->p_FmMacsecDriverParam->untagTreatMode                                = DEFAULT_untagFrameTreatment;
+    p_FmMacsec->p_FmMacsecDriverParam->keysUnreadable                                = DEFAULT_keysUnreadable;
+    p_FmMacsec->p_FmMacsecDriverParam->reservedSc0                                   = DEFAULT_sc0ReservedForPTP;
+    p_FmMacsec->p_FmMacsecDriverParam->byPassMode                                    = !DEFAULT_normalMode;
+    p_FmMacsec->p_FmMacsecDriverParam->pnExhThr                                      = DEFAULT_pnExhThr;
+    p_FmMacsec->p_FmMacsecDriverParam->sectagOverhead                                = DEFAULT_overhead;
+    /* build the FM MACSEC master IPC address */
+    memset(p_FmMacsec->fmMacsecModuleName, 0, (sizeof(char))*MODULE_NAME_SIZE);
+    FM_MAC_GetId(p_FmMacsec->h_FmMac,&macId);
+    if (Sprint (p_FmMacsec->fmMacsecModuleName, "FM-%d-MAC-%d-MACSEC-Master",
+        FmGetId(p_FmMacsec->h_Fm),macId) != 24)
+    {
+        XX_Free(p_FmMacsec->p_FmMacsecDriverParam);
+        XX_Free(p_FmMacsec);
+        REPORT_ERROR(MAJOR, E_INVALID_STATE, ("Sprint failed"));
+        return NULL;
+    }
+    return p_FmMacsec;
+}
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.h
new file mode 100644
index 0000000..65eadf5
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_master.h
@@ -0,0 +1,476 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec_master.h
+
+ @Description   FM MACSEC internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_MACSEC_MASTER_H
+#define __FM_MACSEC_MASTER_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+#include "fm_macsec.h"
+
+
+#define MACSEC_ICV_SIZE             16
+#define MACSEC_SECTAG_SIZE          16
+#define MACSEC_SCI_SIZE             8
+
+/**************************************************************************//**
+ @Description       Exceptions
+*//***************************************************************************/
+
+#define FM_MACSEC_EX_TX_SC_0       0x80000000
+#define FM_MACSEC_EX_TX_SC(sc)     (FM_MACSEC_EX_TX_SC_0 >> (sc))
+#define FM_MACSEC_EX_ECC           0x00000001
+
+#define GET_EXCEPTION_FLAG(bitMask, exception, id)  switch (exception){     \
+    case e_FM_MACSEC_EX_TX_SC:                                              \
+        bitMask = FM_MACSEC_EX_TX_SC(id); break;                            \
+    case e_FM_MACSEC_EX_ECC:                                                \
+        bitMask = FM_MACSEC_EX_ECC; break;                                  \
+    default: bitMask = 0;break;}
+
+#define FM_MACSEC_USER_EX_SINGLE_BIT_ECC            0x80000000
+#define FM_MACSEC_USER_EX_MULTI_BIT_ECC             0x40000000
+
+#define GET_USER_EXCEPTION_FLAG(bitMask, exception)     switch (exception){ \
+    case e_FM_MACSEC_EX_SINGLE_BIT_ECC:                                     \
+        bitMask = FM_MACSEC_USER_EX_SINGLE_BIT_ECC; break;                  \
+    case e_FM_MACSEC_EX_MULTI_BIT_ECC:                                      \
+        bitMask = FM_MACSEC_USER_EX_MULTI_BIT_ECC; break;                   \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       Events
+*//***************************************************************************/
+
+#define FM_MACSEC_EV_TX_SC_0_NEXT_PN                  0x80000000
+#define FM_MACSEC_EV_TX_SC_NEXT_PN(sc)                (FM_MACSEC_EV_TX_SC_0_NEXT_PN >> (sc))
+
+#define GET_EVENT_FLAG(bitMask, event, id)      switch (event){     \
+    case e_FM_MACSEC_EV_TX_SC_NEXT_PN:                              \
+        bitMask = FM_MACSEC_EV_TX_SC_NEXT_PN(id); break;            \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       Defaults
+*//***************************************************************************/
+#define DEFAULT_userExceptions              (FM_MACSEC_USER_EX_SINGLE_BIT_ECC     |\
+                                            FM_MACSEC_USER_EX_MULTI_BIT_ECC)
+
+#define DEFAULT_exceptions                  (FM_MACSEC_EX_TX_SC(0)     |\
+                                            FM_MACSEC_EX_TX_SC(1)      |\
+                                            FM_MACSEC_EX_TX_SC(2)      |\
+                                            FM_MACSEC_EX_TX_SC(3)      |\
+                                            FM_MACSEC_EX_TX_SC(4)      |\
+                                            FM_MACSEC_EX_TX_SC(5)      |\
+                                            FM_MACSEC_EX_TX_SC(6)      |\
+                                            FM_MACSEC_EX_TX_SC(7)      |\
+                                            FM_MACSEC_EX_TX_SC(8)      |\
+                                            FM_MACSEC_EX_TX_SC(9)      |\
+                                            FM_MACSEC_EX_TX_SC(10)     |\
+                                            FM_MACSEC_EX_TX_SC(11)     |\
+                                            FM_MACSEC_EX_TX_SC(12)     |\
+                                            FM_MACSEC_EX_TX_SC(13)     |\
+                                            FM_MACSEC_EX_TX_SC(14)     |\
+                                            FM_MACSEC_EX_TX_SC(15)     |\
+                                            FM_MACSEC_EX_ECC          )
+
+#define DEFAULT_events                      (FM_MACSEC_EV_TX_SC_NEXT_PN(0)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(1)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(2)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(3)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(4)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(5)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(6)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(7)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(8)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(9)    |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(10)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(11)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(12)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(13)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(14)   |\
+                                            FM_MACSEC_EV_TX_SC_NEXT_PN(15)   )
+
+#define DEFAULT_unknownSciFrameTreatment                e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_BOTH
+#define DEFAULT_invalidTagsFrameTreatment               FALSE
+#define DEFAULT_encryptWithNoChangedTextFrameTreatment  FALSE
+#define DEFAULT_untagFrameTreatment                     e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED
+#define DEFAULT_changedTextWithNoEncryptFrameTreatment  FALSE
+#define DEFAULT_onlyScbIsSetFrameTreatment              FALSE
+#define DEFAULT_keysUnreadable                          FALSE
+#define DEFAULT_normalMode                              TRUE
+#define DEFAULT_sc0ReservedForPTP                       FALSE
+#define DEFAULT_initNextPn                              1
+#define DEFAULT_pnExhThr                                0xffffffff
+#define DEFAULT_overhead                                (MACSEC_ICV_SIZE + MACSEC_SECTAG_SIZE)
+
+
+/**************************************************************************//**
+ @Description       Memory Mapped Registers
+*//***************************************************************************/
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(push,1)
+#endif /* defined(__MWERKS__) && ... */
+
+typedef _Packed struct
+{
+    /* MACsec configuration */
+    volatile uint32_t   cfg;            /**< MACsec configuration */
+    volatile uint32_t   et;             /**< MACsec EtherType */
+    volatile uint8_t    res1[56];       /**< reserved */
+    volatile uint32_t   mfl;            /**< Maximum Frame Length */
+    volatile uint32_t   tpnet;          /**< TX Packet Number exhaustion threshold */
+    volatile uint8_t    res2[56];       /**< reserved */
+    volatile uint32_t   rxsca;          /**< RX SC access select */
+    volatile uint8_t    res3[60];       /**< reserved */
+    volatile uint32_t   txsca;          /**< TX SC access select */
+    volatile uint8_t    res4[60];       /**< reserved */
+
+    /* RX configuration, status and statistic */
+    volatile uint32_t   rxsci1h;        /**< RX Secure Channel Identifier first half */
+    volatile uint32_t   rxsci2h;        /**< RX Secure Channel Identifier second half */
+    volatile uint8_t    res5[8];        /**< reserved */
+    volatile uint32_t   ifio1hs;        /**< ifInOctets first half Statistic */
+    volatile uint32_t   ifio2hs;        /**< ifInOctets second half Statistic */
+    volatile uint32_t   ifiups;         /**< ifInUcastPkts Statistic */
+    volatile uint8_t    res6[4];        /**< reserved */
+    volatile uint32_t   ifimps;         /**< ifInMulticastPkts Statistic */
+    volatile uint32_t   ifibps;         /**< ifInBroadcastPkts Statistic */
+    volatile uint32_t   rxsccfg;        /**< RX Secure Channel configuration */
+    volatile uint32_t   rpw;            /**< replayWindow */
+    volatile uint8_t    res7[16];       /**< reserved */
+    volatile uint32_t   inov1hs;        /**< InOctetsValidated first half Statistic */
+    volatile uint32_t   inov2hs;        /**< InOctetsValidated second half Statistic */
+    volatile uint32_t   inod1hs;        /**< InOctetsDecrypted first half Statistic */
+    volatile uint32_t   inod2hs;        /**< InOctetsDecrypted second half Statistic */
+    volatile uint32_t   rxscipus;       /**< RX Secure Channel InPktsUnchecked Statistic */
+    volatile uint32_t   rxscipds;       /**< RX Secure Channel InPktsDelayed Statistic */
+    volatile uint32_t   rxscipls;       /**< RX Secure Channel InPktsLate Statistic */
+    volatile uint8_t    res8[4];        /**< reserved */
+    volatile uint32_t   rxaninuss[MAX_NUM_OF_SA_PER_SC];   /**< RX AN 0-3 InNotUsingSA Statistic */
+    volatile uint32_t   rxanipuss[MAX_NUM_OF_SA_PER_SC];   /**< RX AN 0-3 InPktsUnusedSA Statistic */
+    _Packed struct
+    {
+        volatile uint32_t   rxsacs;     /**< RX Security Association configuration and status */
+        volatile uint32_t   rxsanpn;    /**< RX Security Association nextPN */
+        volatile uint32_t   rxsalpn;    /**< RX Security Association lowestPN */
+        volatile uint32_t   rxsaipos;   /**< RX Security Association InPktsOK Statistic */
+        volatile uint32_t   rxsak[4];   /**< RX Security Association key (128 bit) */
+        volatile uint32_t   rxsah[4];   /**< RX Security Association hash (128 bit) */
+        volatile uint32_t   rxsaipis;   /**< RX Security Association InPktsInvalid Statistic */
+        volatile uint32_t   rxsaipnvs;  /**< RX Security Association InPktsNotValid Statistic */
+        volatile uint8_t    res9[8];    /**< reserved */
+    } _PackedType fmMacsecRxScSa[NUM_OF_SA_PER_RX_SC];
+
+    /* TX configuration, status and statistic */
+    volatile uint32_t   txsci1h;        /**< TX Secure Channel Identifier first half */
+    volatile uint32_t   txsci2h;        /**< TX Secure Channel Identifier second half */
+    volatile uint8_t    res10[8];        /**< reserved */
+    volatile uint32_t   ifoo1hs;        /**< ifOutOctets first half Statistic */
+    volatile uint32_t   ifoo2hs;        /**< ifOutOctets second half Statistic */
+    volatile uint32_t   ifoups;         /**< ifOutUcastPkts Statistic */
+    volatile uint32_t   opus;           /**< OutPktsUntagged Statistic */
+    volatile uint32_t   ifomps;         /**< ifOutMulticastPkts Statistic */
+    volatile uint32_t   ifobps;         /**< ifOutBroadcastPkts Statistic */
+    volatile uint32_t   txsccfg;        /**< TX Secure Channel configuration */
+    volatile uint32_t   optls;          /**< OutPktsTooLong Statistic */
+    volatile uint8_t    res11[16];      /**< reserved */
+    volatile uint32_t   oop1hs;         /**< OutOctetsProtected first half Statistic */
+    volatile uint32_t   oop2hs;         /**< OutOctetsProtected second half Statistic */
+    volatile uint32_t   ooe1hs;         /**< OutOctetsEncrypted first half Statistic */
+    volatile uint32_t   ooe2hs;         /**< OutOctetsEncrypted second half Statistic */
+    volatile uint8_t    res12[48];      /**< reserved */
+    _Packed struct
+    {
+        volatile uint32_t   txsacs;     /**< TX Security Association configuration and status */
+        volatile uint32_t   txsanpn;    /**< TX Security Association nextPN */
+        volatile uint32_t   txsaopps;   /**< TX Security Association OutPktsProtected Statistic */
+        volatile uint32_t   txsaopes;   /**< TX Security Association OutPktsEncrypted Statistic */
+        volatile uint32_t   txsak[4];   /**< TX Security Association key (128 bit) */
+        volatile uint32_t   txsah[4];   /**< TX Security Association hash (128 bit) */
+        volatile uint8_t    res13[16];  /**< reserved */
+    } _PackedType fmMacsecTxScSa[NUM_OF_SA_PER_TX_SC];
+    volatile uint8_t    res14[248];     /**< reserved */
+
+    /* Global configuration and status */
+    volatile uint32_t   ip_rev1;        /**< MACsec IP Block Revision 1 register */
+    volatile uint32_t   ip_rev2;        /**< MACsec IP Block Revision 2 register */
+    volatile uint32_t   evr;            /**< MACsec Event Register */
+    volatile uint32_t   ever;           /**< MACsec Event Enable Register */
+    volatile uint32_t   evfr;           /**< MACsec Event Force Register */
+    volatile uint32_t   err;            /**< MACsec Error Register */
+    volatile uint32_t   erer;           /**< MACsec Error Enable Register */
+    volatile uint32_t   erfr;           /**< MACsec Error Force Register */
+    volatile uint8_t    res15[40];      /**< reserved */
+    volatile uint32_t   meec;           /**< MACsec Memory ECC Error Capture Register */
+    volatile uint32_t   idle;           /**< MACsec Idle status Register */
+    volatile uint8_t    res16[184];     /**< reserved */
+    /* DEBUG */
+    volatile uint32_t   rxec;           /**< MACsec RX error capture Register */
+    volatile uint8_t    res17[28];      /**< reserved */
+    volatile uint32_t   txec;           /**< MACsec TX error capture Register */
+    volatile uint8_t    res18[220];     /**< reserved */
+
+    /* Macsec Rx global statistic */
+    volatile uint32_t   ifiocp1hs;      /**< ifInOctetsCp first half Statistic */
+    volatile uint32_t   ifiocp2hs;      /**< ifInOctetsCp second half Statistic */
+    volatile uint32_t   ifiupcps;       /**< ifInUcastPktsCp Statistic */
+    volatile uint8_t    res19[4];       /**< reserved */
+    volatile uint32_t   ifioup1hs;      /**< ifInOctetsUp first half Statistic */
+    volatile uint32_t   ifioup2hs;      /**< ifInOctetsUp second half Statistic */
+    volatile uint32_t   ifiupups;       /**< ifInUcastPktsUp Statistic */
+    volatile uint8_t    res20[4];       /**< reserved */
+    volatile uint32_t   ifimpcps;       /**< ifInMulticastPktsCp Statistic */
+    volatile uint32_t   ifibpcps;       /**< ifInBroadcastPktsCp Statistic */
+    volatile uint32_t   ifimpups;       /**< ifInMulticastPktsUp Statistic */
+    volatile uint32_t   ifibpups;       /**< ifInBroadcastPktsUp Statistic */
+    volatile uint32_t   ipwts;          /**< InPktsWithoutTag Statistic */
+    volatile uint32_t   ipkays;         /**< InPktsKaY Statistic */
+    volatile uint32_t   ipbts;          /**< InPktsBadTag Statistic */
+    volatile uint32_t   ipsnfs;         /**< InPktsSCINotFound Statistic */
+    volatile uint32_t   ipuecs;         /**< InPktsUnsupportedEC Statistic */
+    volatile uint32_t   ipescbs;        /**< InPktsEponSingleCopyBroadcast Statistic */
+    volatile uint32_t   iptls;          /**< InPktsTooLong Statistic */
+    volatile uint8_t    res21[52];      /**< reserved */
+
+    /* Macsec Tx global statistic */
+    volatile uint32_t   opds;           /**< OutPktsDiscarded Statistic */
+#if (DPAA_VERSION >= 11)
+    volatile uint8_t    res22[124];     /**< reserved */
+    _Packed struct
+    {
+        volatile uint32_t   rxsak[8];   /**< RX Security Association key (128/256 bit) */
+        volatile uint8_t    res23[32];  /**< reserved */
+    } _PackedType rxScSaKey[NUM_OF_SA_PER_RX_SC];
+    _Packed struct
+    {
+        volatile uint32_t   txsak[8];   /**< TX Security Association key (128/256 bit) */
+        volatile uint8_t    res24[32];  /**< reserved */
+    } _PackedType txScSaKey[NUM_OF_SA_PER_TX_SC];
+#endif /* (DPAA_VERSION >= 11) */
+} _PackedType t_FmMacsecRegs;
+
+#if defined(__MWERKS__) && !defined(__GNUC__)
+#pragma pack(pop)
+#endif /* defined(__MWERKS__) && ... */
+
+
+/**************************************************************************//**
+ @Description       General defines
+*//***************************************************************************/
+
+#define SCI_HIGH_MASK   0xffffffff00000000LL
+#define SCI_LOW_MASK    0x00000000ffffffffLL
+
+#define LONG_SHIFT      32
+
+#define GET_SCI_FIRST_HALF(sci)     (uint32_t)((macsecSCI_t)((macsecSCI_t)(sci) & SCI_HIGH_MASK) >> LONG_SHIFT)
+#define GET_SCI_SECOND_HALF(sci)    (uint32_t)((macsecSCI_t)(sci) & SCI_LOW_MASK)
+
+/**************************************************************************//**
+ @Description       Configuration defines
+*//***************************************************************************/
+
+/* masks */
+#define CFG_UECT                        0x00000800
+#define CFG_ESCBT                       0x00000400
+#define CFG_USFT                        0x00000300
+#define CFG_ITT                         0x00000080
+#define CFG_KFT                         0x00000040
+#define CFG_UFT                         0x00000030
+#define CFG_KSS                         0x00000004
+#define CFG_BYPN                        0x00000002
+#define CFG_S0I                         0x00000001
+
+#define ET_TYPE                         0x0000ffff
+
+#define MFL_MAX_LEN                     0x0000ffff
+
+#define RXSCA_SC_SEL                    0x0000000f
+
+#define TXSCA_SC_SEL                    0x0000000f
+
+#define IP_REV_1_IP_ID                  0xffff0000
+#define IP_REV_1_IP_MJ                  0x0000ff00
+#define IP_REV_1_IP_MM                  0x000000ff
+
+#define IP_REV_2_IP_INT                 0x00ff0000
+#define IP_REV_2_IP_ERR                 0x0000ff00
+#define IP_REV_2_IP_CFG                 0x000000ff
+
+#define MECC_CAP                        0x80000000
+#define MECC_CET                        0x40000000
+#define MECC_SERCNT                     0x00ff0000
+#define MECC_MEMADDR                    0x000001ff
+
+/* shifts */
+#define CFG_UECT_SHIFT                  (31-20)
+#define CFG_ESCBT_SHIFT                 (31-21)
+#define CFG_USFT_SHIFT                  (31-23)
+#define CFG_ITT_SHIFT                   (31-24)
+#define CFG_KFT_SHIFT                   (31-25)
+#define CFG_UFT_SHIFT                   (31-27)
+#define CFG_KSS_SHIFT                   (31-29)
+#define CFG_BYPN_SHIFT                  (31-30)
+#define CFG_S0I_SHIFT                   (31-31)
+
+#define IP_REV_1_IP_ID_SHIFT            (31-15)
+#define IP_REV_1_IP_MJ_SHIFT            (31-23)
+#define IP_REV_1_IP_MM_SHIFT            (31-31)
+
+#define IP_REV_2_IP_INT_SHIFT           (31-15)
+#define IP_REV_2_IP_ERR_SHIFT           (31-23)
+#define IP_REV_2_IP_CFG_SHIFT           (31-31)
+
+#define MECC_CAP_SHIFT                  (31-0)
+#define MECC_CET_SHIFT                  (31-1)
+#define MECC_SERCNT_SHIFT               (31-15)
+#define MECC_MEMADDR_SHIFT              (31-31)
+
+/**************************************************************************//**
+ @Description       RX SC defines
+*//***************************************************************************/
+
+/* masks */
+#define RX_SCCFG_SCI_EN_MASK            0x00000800
+#define RX_SCCFG_RP_MASK                0x00000400
+#define RX_SCCFG_VF_MASK                0x00000300
+#define RX_SCCFG_CO_MASK                0x0000003f
+
+/* shifts */
+#define RX_SCCFG_SCI_EN_SHIFT           (31-20)
+#define RX_SCCFG_RP_SHIFT               (31-21)
+#define RX_SCCFG_VF_SHIFT               (31-23)
+#define RX_SCCFG_CO_SHIFT               (31-31)
+#define RX_SCCFG_CS_SHIFT               (31-7)
+
+/**************************************************************************//**
+ @Description       RX SA defines
+*//***************************************************************************/
+
+/* masks */
+#define RX_SACFG_ACTIVE                 0x80000000
+#define RX_SACFG_AN_MASK                0x00000006
+#define RX_SACFG_EN_MASK                0x00000001
+
+/* shifts */
+#define RX_SACFG_AN_SHIFT               (31-30)
+#define RX_SACFG_EN_SHIFT               (31-31)
+
+/**************************************************************************//**
+ @Description       TX SC defines
+*//***************************************************************************/
+
+/* masks */
+#define TX_SCCFG_AN_MASK                0x000c0000
+#define TX_SCCFG_ASA_MASK               0x00020000
+#define TX_SCCFG_SCE_MASK               0x00010000
+#define TX_SCCFG_CO_MASK                0x00003f00
+#define TX_SCCFG_CE_MASK                0x00000010
+#define TX_SCCFG_PF_MASK                0x00000008
+#define TX_SCCFG_AIS_MASK               0x00000004
+#define TX_SCCFG_UES_MASK               0x00000002
+#define TX_SCCFG_USCB_MASK              0x00000001
+
+/* shifts */
+#define TX_SCCFG_AN_SHIFT               (31-13)
+#define TX_SCCFG_ASA_SHIFT              (31-14)
+#define TX_SCCFG_SCE_SHIFT              (31-15)
+#define TX_SCCFG_CO_SHIFT               (31-23)
+#define TX_SCCFG_CE_SHIFT               (31-27)
+#define TX_SCCFG_PF_SHIFT               (31-28)
+#define TX_SCCFG_AIS_SHIFT              (31-29)
+#define TX_SCCFG_UES_SHIFT              (31-30)
+#define TX_SCCFG_USCB_SHIFT             (31-31)
+#define TX_SCCFG_CS_SHIFT               (31-7)
+
+/**************************************************************************//**
+ @Description       TX SA defines
+*//***************************************************************************/
+
+/* masks */
+#define TX_SACFG_ACTIVE                 0x80000000
+
+
+typedef struct
+{
+    void        (*f_Isr) (t_Handle h_Arg, uint32_t id);
+    t_Handle    h_SrcHandle;
+} t_FmMacsecIntrSrc;
+
+typedef struct
+{
+    e_FmMacsecUnknownSciFrameTreatment  unknownSciTreatMode;
+    bool                                invalidTagsDeliverUncontrolled;
+    bool                                changedTextWithNoEncryptDeliverUncontrolled;
+    bool                                onlyScbIsSetDeliverUncontrolled;
+    bool                                encryptWithNoChangedTextDiscardUncontrolled;
+    e_FmMacsecUntagFrameTreatment       untagTreatMode;
+    uint32_t                            pnExhThr;
+    bool                                keysUnreadable;
+    bool                                byPassMode;
+    bool                                reservedSc0;
+    uint32_t                            sectagOverhead;
+} t_FmMacsecDriverParam;
+
+typedef struct
+{
+    t_FmMacsecControllerDriver      fmMacsecControllerDriver;
+    t_Handle                        h_Fm;
+    t_FmMacsecRegs                  *p_FmMacsecRegs;
+    t_Handle                        h_FmMac;            /**< A handle to the FM MAC object  related to */
+    char                            fmMacsecModuleName[MODULE_NAME_SIZE];
+    t_FmMacsecIntrSrc               intrMng[NUM_OF_INTER_MODULE_EVENTS];
+    uint32_t                        events;
+    uint32_t                        exceptions;
+    uint32_t                        userExceptions;
+    t_FmMacsecExceptionsCallback    *f_Exception;       /**< Exception Callback Routine         */
+    t_Handle                        h_App;              /**< A handle to an application layer object; This handle will
+                                                             be passed by the driver upon calling the above callbacks */
+    bool                            rxScTable[NUM_OF_RX_SC];
+    uint32_t                        numRxScAvailable;
+    bool                            txScTable[NUM_OF_TX_SC];
+    uint32_t                        numTxScAvailable;
+    t_Handle                        rxScSpinLock;
+    t_Handle                        txScSpinLock;
+    t_FmMacsecDriverParam           *p_FmMacsecDriverParam;
+} t_FmMacsec;
+
+
+#endif /* __FM_MACSEC_MASTER_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.c b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.c
new file mode 100644
index 0000000..4d8c6e3
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.c
@@ -0,0 +1,908 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec_secy.c
+
+ @Description   FM MACSEC SECY driver routines implementation.
+*//***************************************************************************/
+
+#include "std_ext.h"
+#include "error_ext.h"
+#include "xx_ext.h"
+#include "string_ext.h"
+#include "sprint_ext.h"
+
+#include "fm_macsec_secy.h"
+
+
+/****************************************/
+/*       static functions               */
+/****************************************/
+static void FmMacsecSecYExceptionsIsr(t_Handle h_FmMacsecSecY, uint32_t id)
+{
+    t_FmMacsecSecY *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    UNUSED(id);
+    SANITY_CHECK_RETURN(p_FmMacsecSecY, E_INVALID_HANDLE);
+
+    if (p_FmMacsecSecY->exceptions & FM_MACSEC_SECY_EX_FRAME_DISCARDED)
+        p_FmMacsecSecY->f_Exception(p_FmMacsecSecY->h_App, e_FM_MACSEC_SECY_EX_FRAME_DISCARDED);
+}
+
+static void FmMacsecSecYEventsIsr(t_Handle h_FmMacsecSecY, uint32_t id)
+{
+    t_FmMacsecSecY *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    UNUSED(id);
+    SANITY_CHECK_RETURN(p_FmMacsecSecY, E_INVALID_HANDLE);
+
+    if (p_FmMacsecSecY->events & FM_MACSEC_SECY_EV_NEXT_PN)
+        p_FmMacsecSecY->f_Event(p_FmMacsecSecY->h_App, e_FM_MACSEC_SECY_EV_NEXT_PN);
+}
+
+static t_Error CheckFmMacsecSecYParameters(t_FmMacsecSecY *p_FmMacsecSecY)
+{
+    if (!p_FmMacsecSecY->f_Exception)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Exceptions callback not provided"));
+
+    if (!p_FmMacsecSecY->f_Event)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Events callback not provided"));
+
+    if (!p_FmMacsecSecY->numOfRxSc)
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Num of Rx Scs must be greater than '0'"));
+
+
+    return E_OK;
+}
+
+static t_Handle FmMacsecSecYCreateSc(t_FmMacsecSecY             *p_FmMacsecSecY,
+                                     macsecSCI_t                sci,
+                                     e_FmMacsecSecYCipherSuite  cipherSuite,
+                                     e_ScType                   type)
+{
+    t_SecYSc        *p_ScTable;
+    void            *p_Params;
+    uint32_t        numOfSc,i;
+    t_Error         err = E_OK;
+    t_RxScParams    rxScParams;
+    t_TxScParams    txScParams;
+
+    ASSERT_COND(p_FmMacsecSecY);
+    ASSERT_COND(p_FmMacsecSecY->h_FmMacsec);
+
+    if (type == e_SC_RX)
+    {
+        memset(&rxScParams, 0, sizeof(rxScParams));
+        i                                   = (NUM_OF_RX_SC - 1);
+        p_ScTable                           = p_FmMacsecSecY->p_RxSc;
+        numOfSc                             = p_FmMacsecSecY->numOfRxSc;
+        rxScParams.confidentialityOffset    = p_FmMacsecSecY->confidentialityOffset;
+        rxScParams.replayProtect            = p_FmMacsecSecY->replayProtect;
+        rxScParams.replayWindow             = p_FmMacsecSecY->replayWindow;
+        rxScParams.validateFrames           = p_FmMacsecSecY->validateFrames;
+        rxScParams.cipherSuite              = cipherSuite;
+        p_Params = &rxScParams;
+    }
+    else
+    {
+        memset(&txScParams, 0, sizeof(txScParams));
+        i                                   = (NUM_OF_TX_SC - 1);
+        p_ScTable                           = p_FmMacsecSecY->p_TxSc;
+        numOfSc                             = p_FmMacsecSecY->numOfTxSc;
+        txScParams.sciInsertionMode         = p_FmMacsecSecY->sciInsertionMode;
+        txScParams.protectFrames            = p_FmMacsecSecY->protectFrames;
+        txScParams.confidentialityEnable    = p_FmMacsecSecY->confidentialityEnable;
+        txScParams.confidentialityOffset    = p_FmMacsecSecY->confidentialityOffset;
+        txScParams.cipherSuite              = cipherSuite;
+        p_Params = &txScParams;
+    }
+
+    for (i=0;i<numOfSc;i++)
+        if (!p_ScTable[i].inUse)
+            break;
+    if (i == numOfSc)
+    {
+        REPORT_ERROR(MAJOR, E_FULL, ("FM MACSEC SECY SC"));
+        return NULL;
+    }
+
+    if (type == e_SC_RX)
+    {
+        ((t_RxScParams *)p_Params)->scId = p_ScTable[i].scId;
+        ((t_RxScParams *)p_Params)->sci  = sci;
+        if ((err = FmMacsecCreateRxSc(p_FmMacsecSecY->h_FmMacsec, (t_RxScParams *)p_Params)) != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY RX SC"));
+            return NULL;
+        }
+    }
+    else
+    {
+        ((t_TxScParams *)p_Params)->scId = p_ScTable[i].scId;
+        ((t_TxScParams *)p_Params)->sci  = sci;
+        if ((err = FmMacsecCreateTxSc(p_FmMacsecSecY->h_FmMacsec, (t_TxScParams *)p_Params)) != E_OK)
+        {
+            REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY TX SC"));
+            return NULL;
+        }
+    }
+
+    p_ScTable[i].inUse = TRUE;
+    return &p_ScTable[i];
+}
+
+static t_Error FmMacsecSecYDeleteSc(t_FmMacsecSecY *p_FmMacsecSecY, t_SecYSc *p_FmSecYSc, e_ScType type)
+{
+    t_Error         err = E_OK;
+
+    ASSERT_COND(p_FmMacsecSecY);
+    ASSERT_COND(p_FmMacsecSecY->h_FmMacsec);
+    ASSERT_COND(p_FmSecYSc);
+
+    if (type == e_SC_RX)
+    {
+        if ((err = FmMacsecDeleteRxSc(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    }
+    else
+        if ((err = FmMacsecDeleteTxSc(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->inUse = FALSE;
+
+    return err;
+}
+
+/****************************************/
+/*       API Init unit functions        */
+/****************************************/
+t_Handle FM_MACSEC_SECY_Config(t_FmMacsecSecYParams *p_FmMacsecSecYParam)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY;
+
+    /* Allocate FM MACSEC structure */
+    p_FmMacsecSecY = (t_FmMacsecSecY *) XX_Malloc(sizeof(t_FmMacsecSecY));
+    if (!p_FmMacsecSecY)
+    {
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY driver structure"));
+        return NULL;
+    }
+    memset(p_FmMacsecSecY, 0, sizeof(t_FmMacsecSecY));
+
+    /* Allocate the FM MACSEC driver's parameters structure */
+    p_FmMacsecSecY->p_FmMacsecSecYDriverParam = (t_FmMacsecSecYDriverParam *)XX_Malloc(sizeof(t_FmMacsecSecYDriverParam));
+    if (!p_FmMacsecSecY->p_FmMacsecSecYDriverParam)
+    {
+        XX_Free(p_FmMacsecSecY);
+        REPORT_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY driver parameters"));
+        return NULL;
+    }
+    memset(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, 0, sizeof(t_FmMacsecSecYDriverParam));
+
+    /* Initialize FM MACSEC SECY parameters which will be kept by the driver */
+    p_FmMacsecSecY->h_FmMacsec              = p_FmMacsecSecYParam->h_FmMacsec;
+    p_FmMacsecSecY->f_Event                 = p_FmMacsecSecYParam->f_Event;
+    p_FmMacsecSecY->f_Exception             = p_FmMacsecSecYParam->f_Exception;
+    p_FmMacsecSecY->h_App                   = p_FmMacsecSecYParam->h_App;
+    p_FmMacsecSecY->confidentialityEnable   = DEFAULT_confidentialityEnable;
+    p_FmMacsecSecY->confidentialityOffset   = DEFAULT_confidentialityOffset;
+    p_FmMacsecSecY->validateFrames          = DEFAULT_validateFrames;
+    p_FmMacsecSecY->replayProtect           = DEFAULT_replayEnable;
+    p_FmMacsecSecY->replayWindow            = DEFAULT_replayWindow;
+    p_FmMacsecSecY->protectFrames           = DEFAULT_protectFrames;
+    p_FmMacsecSecY->sciInsertionMode        = DEFAULT_sciInsertionMode;
+    p_FmMacsecSecY->isPointToPoint          = DEFAULT_ptp;
+    p_FmMacsecSecY->numOfRxSc               = p_FmMacsecSecYParam->numReceiveChannels;
+    p_FmMacsecSecY->numOfTxSc               = DEFAULT_numOfTxSc;
+    p_FmMacsecSecY->exceptions              = DEFAULT_exceptions;
+    p_FmMacsecSecY->events                  = DEFAULT_events;
+
+    memcpy(&p_FmMacsecSecY->p_FmMacsecSecYDriverParam->txScParams,
+           &p_FmMacsecSecYParam->txScParams,
+           sizeof(t_FmMacsecSecYSCParams));
+    return p_FmMacsecSecY;
+}
+
+t_Error FM_MACSEC_SECY_Init(t_Handle h_FmMacsecSecY)
+{
+    t_FmMacsecSecY              *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_FmMacsecSecYDriverParam   *p_FmMacsecSecYDriverParam = NULL;
+    uint32_t                    rxScIds[NUM_OF_RX_SC], txScIds[NUM_OF_TX_SC], i, j;
+    t_Error                     err;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_HANDLE);
+
+    CHECK_INIT_PARAMETERS(p_FmMacsecSecY, CheckFmMacsecSecYParameters);
+
+    p_FmMacsecSecYDriverParam = p_FmMacsecSecY->p_FmMacsecSecYDriverParam;
+
+    if ((p_FmMacsecSecY->isPointToPoint) &&
+        ((err = FmMacsecSetPTP(p_FmMacsecSecY->h_FmMacsec, TRUE)) != E_OK))
+        RETURN_ERROR(MAJOR, err, ("Can't set Poin-to-Point"));
+
+    /* Rx Sc Allocation */
+    p_FmMacsecSecY->p_RxSc = (t_SecYSc *)XX_Malloc(sizeof(t_SecYSc) * p_FmMacsecSecY->numOfRxSc);
+    if (!p_FmMacsecSecY->p_RxSc)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY RX SC"));
+    memset(p_FmMacsecSecY->p_RxSc, 0, sizeof(t_SecYSc) * p_FmMacsecSecY->numOfRxSc);
+    if ((err = FmMacsecAllocScs(p_FmMacsecSecY->h_FmMacsec, e_SC_RX, p_FmMacsecSecY->isPointToPoint, p_FmMacsecSecY->numOfRxSc, rxScIds)) != E_OK)
+    {
+        if (p_FmMacsecSecY->p_TxSc)
+            XX_Free(p_FmMacsecSecY->p_TxSc);
+        if (p_FmMacsecSecY->p_RxSc)
+            XX_Free(p_FmMacsecSecY->p_RxSc);
+        return ERROR_CODE(err);
+    }
+    for (i=0; i<p_FmMacsecSecY->numOfRxSc; i++)
+    {
+        p_FmMacsecSecY->p_RxSc[i].scId  = rxScIds[i];
+        p_FmMacsecSecY->p_RxSc[i].type  = e_SC_RX;
+        for (j=0; j<MAX_NUM_OF_SA_PER_SC;j++)
+            p_FmMacsecSecY->p_RxSc[i].sa[j].saId = (e_ScSaId)SECY_AN_FREE_VALUE;
+    }
+
+    /* Tx Sc Allocation */
+    p_FmMacsecSecY->p_TxSc = (t_SecYSc *)XX_Malloc(sizeof(t_SecYSc) * p_FmMacsecSecY->numOfTxSc);
+    if (!p_FmMacsecSecY->p_TxSc)
+        RETURN_ERROR(MAJOR, E_NO_MEMORY, ("FM MACSEC SECY TX SC"));
+    memset(p_FmMacsecSecY->p_TxSc, 0, sizeof(t_SecYSc) * p_FmMacsecSecY->numOfTxSc);
+
+    if ((err = FmMacsecAllocScs(p_FmMacsecSecY->h_FmMacsec, e_SC_TX, p_FmMacsecSecY->isPointToPoint, p_FmMacsecSecY->numOfTxSc, txScIds)) != E_OK)
+    {
+        if (p_FmMacsecSecY->p_TxSc)
+            XX_Free(p_FmMacsecSecY->p_TxSc);
+        if (p_FmMacsecSecY->p_RxSc)
+            XX_Free(p_FmMacsecSecY->p_RxSc);
+        return ERROR_CODE(err);
+    }
+    for (i=0; i<p_FmMacsecSecY->numOfTxSc; i++)
+    {
+        p_FmMacsecSecY->p_TxSc[i].scId  = txScIds[i];
+        p_FmMacsecSecY->p_TxSc[i].type  = e_SC_TX;
+        for (j=0; j<MAX_NUM_OF_SA_PER_SC;j++)
+            p_FmMacsecSecY->p_TxSc[i].sa[j].saId = (e_ScSaId)SECY_AN_FREE_VALUE;
+        FmMacsecRegisterIntr(p_FmMacsecSecY->h_FmMacsec,
+                             e_FM_MACSEC_MOD_SC_TX,
+                             (uint8_t)txScIds[i],
+                             e_FM_INTR_TYPE_ERR,
+                             FmMacsecSecYExceptionsIsr,
+                             p_FmMacsecSecY);
+        FmMacsecRegisterIntr(p_FmMacsecSecY->h_FmMacsec,
+                             e_FM_MACSEC_MOD_SC_TX,
+                             (uint8_t)txScIds[i],
+                             e_FM_INTR_TYPE_NORMAL,
+                             FmMacsecSecYEventsIsr,
+                             p_FmMacsecSecY);
+
+        if (p_FmMacsecSecY->exceptions & FM_MACSEC_SECY_EX_FRAME_DISCARDED)
+            FmMacsecSetException(p_FmMacsecSecY->h_FmMacsec, e_FM_MACSEC_EX_TX_SC, txScIds[i], TRUE);
+        if (p_FmMacsecSecY->events & FM_MACSEC_SECY_EV_NEXT_PN)
+            FmMacsecSetEvent(p_FmMacsecSecY->h_FmMacsec, e_FM_MACSEC_EV_TX_SC_NEXT_PN, txScIds[i], TRUE);
+    }
+
+    FmMacsecSecYCreateSc(p_FmMacsecSecY,
+                         p_FmMacsecSecYDriverParam->txScParams.sci,
+                         p_FmMacsecSecYDriverParam->txScParams.cipherSuite,
+                         e_SC_TX);
+    XX_Free(p_FmMacsecSecYDriverParam);
+    p_FmMacsecSecY->p_FmMacsecSecYDriverParam = NULL;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_Free(t_Handle h_FmMacsecSecY)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_Error         err             = E_OK;
+    uint32_t        rxScIds[NUM_OF_RX_SC], txScIds[NUM_OF_TX_SC], i;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    if (p_FmMacsecSecY->isPointToPoint)
+        FmMacsecSetPTP(p_FmMacsecSecY->h_FmMacsec, FALSE);
+    if (p_FmMacsecSecY->p_RxSc)
+    {
+        for (i=0; i<p_FmMacsecSecY->numOfRxSc; i++)
+            rxScIds[i] = p_FmMacsecSecY->p_RxSc[i].scId;
+        if ((err = FmMacsecFreeScs(p_FmMacsecSecY->h_FmMacsec, e_SC_RX, p_FmMacsecSecY->numOfRxSc, rxScIds)) != E_OK)
+            return ERROR_CODE(err);
+        XX_Free(p_FmMacsecSecY->p_RxSc);
+    }
+    if (p_FmMacsecSecY->p_TxSc)
+    {
+       FmMacsecSecYDeleteSc(p_FmMacsecSecY, &p_FmMacsecSecY->p_TxSc[0], e_SC_TX);
+
+       for (i=0; i<p_FmMacsecSecY->numOfTxSc; i++) {
+             txScIds[i] = p_FmMacsecSecY->p_TxSc[i].scId;
+            FmMacsecUnregisterIntr(p_FmMacsecSecY->h_FmMacsec,
+                                 e_FM_MACSEC_MOD_SC_TX,
+                                 (uint8_t)txScIds[i],
+                                 e_FM_INTR_TYPE_ERR);
+            FmMacsecUnregisterIntr(p_FmMacsecSecY->h_FmMacsec,
+                                 e_FM_MACSEC_MOD_SC_TX,
+                                 (uint8_t)txScIds[i],
+                                 e_FM_INTR_TYPE_NORMAL);
+
+            if (p_FmMacsecSecY->exceptions & FM_MACSEC_SECY_EX_FRAME_DISCARDED)
+                FmMacsecSetException(p_FmMacsecSecY->h_FmMacsec, e_FM_MACSEC_EX_TX_SC, txScIds[i], FALSE);
+            if (p_FmMacsecSecY->events & FM_MACSEC_SECY_EV_NEXT_PN)
+                FmMacsecSetEvent(p_FmMacsecSecY->h_FmMacsec, e_FM_MACSEC_EV_TX_SC_NEXT_PN, txScIds[i], FALSE);
+       }
+
+        if ((err = FmMacsecFreeScs(p_FmMacsecSecY->h_FmMacsec, e_SC_TX, p_FmMacsecSecY->numOfTxSc, txScIds)) != E_OK)
+            return ERROR_CODE(err);
+        XX_Free(p_FmMacsecSecY->p_TxSc);
+    }
+
+    XX_Free(p_FmMacsecSecY);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_ConfigSciInsertionMode(t_Handle h_FmMacsecSecY, e_FmMacsecSciInsertionMode sciInsertionMode)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->sciInsertionMode = sciInsertionMode;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigProtectFrames(t_Handle h_FmMacsecSecY, bool protectFrames)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->protectFrames = protectFrames;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigReplayWindow(t_Handle h_FmMacsecSecY, bool replayProtect, uint32_t replayWindow)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->replayProtect   = replayProtect;
+    p_FmMacsecSecY->replayWindow    = replayWindow;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigValidationMode(t_Handle h_FmMacsecSecY, e_FmMacsecValidFrameBehavior validateFrames)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->validateFrames = validateFrames;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigConfidentiality(t_Handle h_FmMacsecSecY, bool confidentialityEnable, uint16_t confidentialityOffset)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->confidentialityEnable = confidentialityEnable;
+    p_FmMacsecSecY->confidentialityOffset = confidentialityOffset;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigPointToPoint(t_Handle h_FmMacsecSecY)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    p_FmMacsecSecY->numOfRxSc = 1;
+    p_FmMacsecSecY->isPointToPoint = TRUE;
+    p_FmMacsecSecY->sciInsertionMode = e_FM_MACSEC_SCI_INSERTION_MODE_IMPLICT_PTP;
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigException(t_Handle h_FmMacsecSecY, e_FmMacsecSecYExceptions exception, bool enable)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    uint32_t        bitMask         = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    GET_EXCEPTION_FLAG(bitMask, exception);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsecSecY->exceptions |= bitMask;
+        else
+            p_FmMacsecSecY->exceptions &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined exception"));
+
+    return E_OK;
+}
+
+t_Error FM_MACSEC_SECY_ConfigEvent(t_Handle h_FmMacsecSecY, e_FmMacsecSecYEvents event, bool enable)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    uint32_t        bitMask         = 0;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+
+    GET_EVENT_FLAG(bitMask, event);
+    if (bitMask)
+    {
+        if (enable)
+            p_FmMacsecSecY->events |= bitMask;
+        else
+            p_FmMacsecSecY->events &= ~bitMask;
+    }
+    else
+        RETURN_ERROR(MAJOR, E_INVALID_VALUE, ("Undefined event"));
+
+    return E_OK;
+}
+
+t_Handle FM_MACSEC_SECY_CreateRxSc(t_Handle h_FmMacsecSecY, t_FmMacsecSecYSCParams *p_ScParams)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecSecY, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_ScParams, E_NULL_POINTER, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE, NULL);
+
+    return FmMacsecSecYCreateSc(p_FmMacsecSecY, p_ScParams->sci, p_ScParams->cipherSuite, e_SC_RX);
+}
+
+t_Error FM_MACSEC_SECY_DeleteRxSc(t_Handle h_FmMacsecSecY, t_Handle h_Sc)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+
+    return FmMacsecSecYDeleteSc(p_FmMacsecSecY, p_FmSecYSc, e_SC_RX);
+}
+
+t_Error FM_MACSEC_SECY_CreateRxSa(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t lowestPn, macsecSAKey_t key)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId != SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is already assigned",an));
+
+    if ((err = FmMacsecCreateRxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, (e_ScSaId)p_FmSecYSc->numOfSa, an, lowestPn, key)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->sa[an].saId = (e_ScSaId)p_FmSecYSc->numOfSa++;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_DeleteRxSa(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err             = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is already deleted",an));
+
+    if ((err = FmMacsecDeleteRxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->numOfSa--;
+    p_FmSecYSc->sa[an].saId = (e_ScSaId)SECY_AN_FREE_VALUE;
+    /* TODO - check if statistics need to be read*/
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaEnableReceive(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecRxSaSetReceive(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, TRUE)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->sa[an].active = TRUE;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaDisableReceive(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecRxSaSetReceive(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, FALSE)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->sa[an].active = FALSE;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaUpdateNextPn(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t updtNextPN)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecRxSaUpdateNextPn(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, updtNextPN)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaUpdateLowestPn(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t updtLowestPN)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecRxSaUpdateLowestPn(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, updtLowestPN)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_RxSaModifyKey(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, macsecSAKey_t key)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc     = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if (p_FmSecYSc->sa[an].active)
+        if ((err = FmMacsecRxSaSetReceive(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, FALSE)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* TODO - statistics should be read */
+
+    if ((err = FmMacsecCreateRxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, an, 1, key)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    if (p_FmSecYSc->sa[an].active)
+        if ((err = FmMacsecRxSaSetReceive(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId, TRUE)) != E_OK)
+            RETURN_ERROR(MINOR, err, NO_MSG);
+    return err;
+}
+
+#if 0
+t_Handle FM_MACSEC_SECY_CreateTxSc(t_Handle h_FmMacsecSecY, macsecSCI_t sci)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecSecY, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE, NULL);
+    SANITY_CHECK_RETURN_VALUE(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE, NULL);
+
+    return FmMacsecSecYCreateSc(p_FmMacsecSecY, sci, e_SC_TX);
+}
+
+t_Error FM_MACSEC_SECY_DeleteTxSc(t_Handle h_FmMacsecSecY, t_Handle h_Sc)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc = (t_SecYSc *)h_Sc;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+
+    return FmMacsecSecYDeleteSc(p_FmMacsecSecY, p_FmSecYSc, e_SC_TX);
+}
+#endif /* 0 */
+
+t_Error FM_MACSEC_SECY_CreateTxSa(t_Handle h_FmMacsecSecY, macsecAN_t an, macsecSAKey_t key)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId != SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, err, ("An %d is already assigned",an));
+
+    if ((err = FmMacsecCreateTxSa(p_FmMacsecSecY->h_FmMacsec,p_FmSecYSc->scId, (e_ScSaId)p_FmSecYSc->numOfSa, key)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->sa[an].saId = (e_ScSaId)p_FmSecYSc->numOfSa++;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_DeleteTxSa(t_Handle h_FmMacsecSecY, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is already deleted",an));
+
+    if ((err = FmMacsecDeleteTxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[an].saId)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    p_FmSecYSc->numOfSa--;
+    p_FmSecYSc->sa[an].saId = (e_ScSaId)SECY_AN_FREE_VALUE;
+    /* TODO - check if statistics need to be read*/
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_TxSaModifyKey(t_Handle h_FmMacsecSecY, macsecAN_t nextActiveAn, macsecSAKey_t key)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    macsecAN_t      currentAn;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(nextActiveAn < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if ((err = FmMacsecTxSaGetActive(p_FmMacsecSecY->h_FmMacsec,
+                                     p_FmSecYSc->scId,
+                                     &currentAn)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    if ((err = FmMacsecTxSaSetActive(p_FmMacsecSecY->h_FmMacsec,
+                                     p_FmSecYSc->scId,
+                                     p_FmSecYSc->sa[nextActiveAn].saId,
+                                     nextActiveAn)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    /* TODO - statistics should be read */
+
+    if ((err = FmMacsecCreateTxSa(p_FmMacsecSecY->h_FmMacsec, p_FmSecYSc->scId, p_FmSecYSc->sa[currentAn].saId, key)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_TxSaSetActive(t_Handle h_FmMacsecSecY, macsecAN_t an)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(an < MAX_NUM_OF_SA_PER_SC, E_INVALID_STATE);
+
+    if (p_FmSecYSc->sa[an].saId == SECY_AN_FREE_VALUE)
+        RETURN_ERROR(MINOR, E_INVALID_STATE, ("An %d is not configured",an));
+
+    if ((err = FmMacsecTxSaSetActive(p_FmMacsecSecY->h_FmMacsec,
+                                     p_FmSecYSc->scId,
+                                     p_FmSecYSc->sa[an].saId,
+                                     an)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_TxSaGetActive(t_Handle h_FmMacsecSecY, macsecAN_t *p_An)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_An, E_INVALID_HANDLE);
+
+    if ((err = FmMacsecTxSaGetActive(p_FmMacsecSecY->h_FmMacsec,
+                                     p_FmSecYSc->scId,
+                                     p_An)) != E_OK)
+        RETURN_ERROR(MINOR, err, NO_MSG);
+
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_GetRxScPhysId(t_Handle h_FmMacsecSecY, t_Handle h_Sc, uint32_t *p_ScPhysId)
+{
+    t_SecYSc        *p_FmSecYSc = (t_SecYSc *)h_Sc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(h_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(((t_FmMacsecSecY *)h_FmMacsecSecY)->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!((t_FmMacsecSecY *)h_FmMacsecSecY)->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+#ifdef DISABLE_SANITY_CHECKS
+    UNUSED(h_FmMacsecSecY);
+#endif /* DISABLE_SANITY_CHECKS */
+
+    *p_ScPhysId = p_FmSecYSc->scId;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_GetTxScPhysId(t_Handle h_FmMacsecSecY, uint32_t *p_ScPhysId)
+{
+    t_FmMacsecSecY  *p_FmMacsecSecY = (t_FmMacsecSecY *)h_FmMacsecSecY;
+    t_SecYSc        *p_FmSecYSc;
+    t_Error         err = E_OK;
+
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(p_FmMacsecSecY->h_FmMacsec, E_INVALID_HANDLE);
+    SANITY_CHECK_RETURN_ERROR(!p_FmMacsecSecY->p_FmMacsecSecYDriverParam, E_INVALID_STATE);
+    p_FmSecYSc = &p_FmMacsecSecY->p_TxSc[0];
+    SANITY_CHECK_RETURN_ERROR(p_FmSecYSc, E_INVALID_HANDLE);
+
+    *p_ScPhysId = p_FmSecYSc->scId;
+    return err;
+}
+
+t_Error FM_MACSEC_SECY_SetException(t_Handle h_FmMacsecSecY, e_FmMacsecExceptions exception, bool enable)
+{
+   UNUSED(h_FmMacsecSecY);UNUSED(exception);UNUSED(enable);
+   RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_SetEvent(t_Handle h_FmMacsecSecY, e_FmMacsecSecYEvents event, bool enable)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(event);UNUSED(enable);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_GetStatistics(t_Handle h_FmMacsecSecY, t_FmMacsecSecYStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_RxScGetStatistics(t_Handle h_FmMacsecSecY, t_Handle h_Sc, t_FmMacsecSecYRxScStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(h_Sc);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_RxSaGetStatistics(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, t_FmMacsecSecYRxSaStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(h_Sc);UNUSED(an);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_TxScGetStatistics(t_Handle h_FmMacsecSecY, t_FmMacsecSecYTxScStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
+t_Error FM_MACSEC_SECY_TxSaGetStatistics(t_Handle h_FmMacsecSecY, macsecAN_t an, t_FmMacsecSecYTxSaStatistics *p_Statistics)
+{
+    UNUSED(h_FmMacsecSecY);UNUSED(an);UNUSED(p_Statistics);
+    RETURN_ERROR(MINOR, E_NOT_SUPPORTED, NO_MSG);
+}
+
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.h b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.h
new file mode 100644
index 0000000..0cf624e
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/MACSEC/fm_macsec_secy.h
@@ -0,0 +1,144 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/******************************************************************************
+ @File          fm_macsec_secy.h
+
+ @Description   FM MACSEC SecY internal structures and definitions.
+*//***************************************************************************/
+#ifndef __FM_MACSEC_SECY_H
+#define __FM_MACSEC_SECY_H
+
+#include "error_ext.h"
+#include "std_ext.h"
+
+#include "fm_macsec.h"
+
+
+/**************************************************************************//**
+ @Description       Exceptions
+*//***************************************************************************/
+
+#define FM_MACSEC_SECY_EX_FRAME_DISCARDED           0x80000000
+
+#define GET_EXCEPTION_FLAG(bitMask, exception)  switch (exception){     \
+    case e_FM_MACSEC_SECY_EX_FRAME_DISCARDED:                           \
+        bitMask = FM_MACSEC_SECY_EX_FRAME_DISCARDED; break;             \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       Events
+*//***************************************************************************/
+
+#define FM_MACSEC_SECY_EV_NEXT_PN                        0x80000000
+
+#define GET_EVENT_FLAG(bitMask, event)          switch (event){     \
+    case e_FM_MACSEC_SECY_EV_NEXT_PN:                               \
+        bitMask = FM_MACSEC_SECY_EV_NEXT_PN; break;                 \
+    default: bitMask = 0;break;}
+
+/**************************************************************************//**
+ @Description       Defaults
+*//***************************************************************************/
+
+#define DEFAULT_exceptions                  (FM_MACSEC_SECY_EX_FRAME_DISCARDED)
+#define DEFAULT_events                      (FM_MACSEC_SECY_EV_NEXT_PN)
+#define DEFAULT_numOfTxSc                   1
+#define DEFAULT_confidentialityEnable       FALSE
+#define DEFAULT_confidentialityOffset       0
+#define DEFAULT_sciInsertionMode            e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_SECTAG
+#define DEFAULT_validateFrames              e_FM_MACSEC_VALID_FRAME_BEHAVIOR_STRICT
+#define DEFAULT_replayEnable                FALSE
+#define DEFAULT_replayWindow                0
+#define DEFAULT_protectFrames               TRUE
+#define DEFAULT_ptp                         FALSE
+
+/**************************************************************************//**
+ @Description       General defines
+*//***************************************************************************/
+
+#define SECY_AN_FREE_VALUE              MAX_NUM_OF_SA_PER_SC
+
+
+typedef struct {
+    e_ScSaId                            saId;
+    bool                                active;
+    union {
+        t_FmMacsecSecYRxSaStatistics    rxSaStatistics;
+        t_FmMacsecSecYTxSaStatistics    txSaStatistics;
+    };
+} t_SecYSa;
+
+typedef struct {
+    bool                                inUse;
+    uint32_t                            scId;
+    e_ScType                            type;
+    uint8_t                             numOfSa;
+    t_SecYSa                            sa[MAX_NUM_OF_SA_PER_SC];
+    union {
+        t_FmMacsecSecYRxScStatistics    rxScStatistics;
+        t_FmMacsecSecYTxScStatistics    txScStatistics;
+    };
+} t_SecYSc;
+
+typedef struct {
+    t_FmMacsecSecYSCParams              txScParams;             /**< Tx SC Params */
+} t_FmMacsecSecYDriverParam;
+
+typedef struct {
+    t_Handle                            h_FmMacsec;
+    bool                                confidentialityEnable;  /**< TRUE  - confidentiality protection and integrity protection
+                                                                     FALSE - no confidentiality protection, only integrity protection*/
+    uint16_t                            confidentialityOffset;  /**< The number of initial octets of each MSDU without confidentiality protection
+                                                                     common values are 0, 30, and 50 */
+    bool                                replayProtect;          /**< replay protection function mode */
+    uint32_t                            replayWindow;           /**< the size of the replay window */
+    e_FmMacsecValidFrameBehavior        validateFrames;         /**< validation function mode */
+    e_FmMacsecSciInsertionMode          sciInsertionMode;
+    bool                                protectFrames;
+    bool                                isPointToPoint;
+    e_FmMacsecSecYCipherSuite           cipherSuite;            /**< Cipher suite to be used for this SecY */
+    uint32_t                            numOfRxSc;              /**< Number of receive channels */
+    uint32_t                            numOfTxSc;              /**< Number of transmit channels */
+    t_SecYSc                            *p_RxSc;
+    t_SecYSc                            *p_TxSc;
+    uint32_t                            events;
+    uint32_t                            exceptions;
+    t_FmMacsecSecYExceptionsCallback    *f_Exception;           /**< TODO */
+    t_FmMacsecSecYEventsCallback        *f_Event;               /**< TODO */
+    t_Handle                            h_App;
+    t_FmMacsecSecYStatistics            statistics;
+    t_FmMacsecSecYDriverParam           *p_FmMacsecSecYDriverParam;
+} t_FmMacsecSecY;
+
+
+#endif /* __FM_MACSEC_SECY_H */
diff --git a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile
index e02b57e..d691a13 100644
--- a/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile
+++ b/drivers/net/ethernet/freescale/fman/Peripherals/FM/Makefile
@@ -20,3 +20,4 @@ obj-y		+= SP/
 obj-y		+= Port/
 obj-y		+= HC/
 obj-y		+= Rtc/
+obj-y		+= MACSEC/
diff --git a/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_macsec_ext.h b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_macsec_ext.h
new file mode 100644
index 0000000..57925f1
--- /dev/null
+++ b/drivers/net/ethernet/freescale/fman/inc/Peripherals/fm_macsec_ext.h
@@ -0,0 +1,1271 @@
+/*
+ * Copyright 2008-2015 Freescale Semiconductor Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *     * Redistributions of source code must retain the above copyright
+ *       notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above copyright
+ *       notice, this list of conditions and the following disclaimer in the
+ *       documentation and/or other materials provided with the distribution.
+ *     * Neither the name of Freescale Semiconductor nor the
+ *       names of its contributors may be used to endorse or promote products
+ *       derived from this software without specific prior written permission.
+ *
+ *
+ * ALTERNATIVELY, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") as published by the Free Software
+ * Foundation, either version 2 of that License or (at your option) any
+ * later version.
+ *
+ * THIS SOFTWARE IS PROVIDED BY Freescale Semiconductor ``AS IS'' AND ANY
+ * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL Freescale Semiconductor BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**************************************************************************//**
+ @File          fm_macsec_ext.h
+
+ @Description   FM MACSEC ...
+*//***************************************************************************/
+#ifndef __FM_MACSEC_EXT_H
+#define __FM_MACSEC_EXT_H
+
+#include "std_ext.h"
+
+
+/**************************************************************************//**
+ @Group         FM_grp Frame Manager API
+
+ @Description   FM API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_grp FM MACSEC
+
+ @Description   FM MACSEC API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   MACSEC Exceptions
+*//***************************************************************************/
+typedef enum e_FmMacsecExceptions {
+    e_FM_MACSEC_EX_SINGLE_BIT_ECC,          /**< Single bit ECC error */
+    e_FM_MACSEC_EX_MULTI_BIT_ECC            /**< Multi bit ECC error */
+} e_FmMacsecExceptions;
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_init_grp FM-MACSEC Initialization Unit
+
+ @Description   FM MACSEC Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      t_FmMacsecExceptionsCallback
+
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     exception   The exception.
+*//***************************************************************************/
+typedef void (t_FmMacsecExceptionsCallback) ( t_Handle                  h_App,
+                                              e_FmMacsecExceptions      exception);
+
+
+/**************************************************************************//**
+ @Description   FM MACSEC config input
+*//***************************************************************************/
+typedef struct t_FmMacsecParams {
+    t_Handle                                h_Fm;               /**< A handle to the FM object related to */
+    bool                                    guestMode;          /**< Partition-id */
+    union {
+        struct {
+            uint8_t                         fmMacId;            /**< FM MAC id */
+        } guestParams;
+
+        struct {
+            uintptr_t                       baseAddr;           /**< Base of memory mapped FM MACSEC registers */
+            t_Handle                        h_FmMac;            /**< A handle to the FM MAC object  related to */
+            t_FmMacsecExceptionsCallback    *f_Exception;       /**< Exception Callback Routine         */
+            t_Handle                        h_App;              /**< A handle to an application layer object; This handle will
+                                                                     be passed by the driver upon calling the above callbacks */
+        } nonGuestParams;
+    };
+} t_FmMacsecParams;
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Config
+
+ @Description   Creates descriptor for the FM MACSEC module;
+
+                The routine returns a handle (descriptor) to the FM MACSEC object;
+                This descriptor must be passed as first parameter to all other
+                FM MACSEC function calls;
+
+                No actual initialization or configuration of FM MACSEC hardware is
+                done by this routine.
+
+ @Param[in]     p_FmMacsecParam     Pointer to data structure of parameters.
+
+ @Retval        Handle to FM MACSEC object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MACSEC_Config(t_FmMacsecParams *p_FmMacsecParam);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Init
+
+ @Description   Initializes the FM MACSEC module.
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MACSEC_Init(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Free
+
+ @Description   Frees all resources that were assigned to FM MACSEC module;
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MACSEC_Free(t_Handle h_FmMacsec);
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_advanced_init_grp    FM-MACSEC Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for unknown sci frame treatment
+*//***************************************************************************/
+typedef enum e_FmMacsecUnknownSciFrameTreatment {
+    e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_BOTH = 0,                                               /**< Controlled port - Strict mode */
+    e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_UNCONTROLLED_DELIVER_OR_DISCARD_CONTROLLED,             /**< If C bit clear deliver on controlled port, else discard
+                                                                                                                 Controlled port - Check or Disable mode */
+    e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED,                        /**< Controlled port - Strict mode */
+    e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DELIVER_OR_DISCARD_UNCONTROLLED_DELIVER_OR_DISCARD_CONTROLLED   /**< If C bit set deliver on uncontrolled port and discard on controlled port,
+                                                                                                                 else discard on uncontrolled port and deliver on controlled port
+                                                                                                                 Controlled port - Check or Disable mode */
+} e_FmMacsecUnknownSciFrameTreatment;
+
+/**************************************************************************//**
+ @Description   enum for untag frame treatment
+*//***************************************************************************/
+typedef enum e_FmMacsecUntagFrameTreatment {
+    e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED = 0,                    /**< Controlled port - Strict mode */
+    e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DISCARD_BOTH,                                                   /**< Controlled port - Strict mode */
+    e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DISCARD_UNCONTROLLED_DELIVER_CONTROLLED_UNMODIFIED              /**< Controlled port - Strict mode */
+} e_FmMacsecUntagFrameTreatment;
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigUnknownSciFrameTreatment
+
+ @Description   Change the treatment for received frames with unknown sci from its default
+                configuration [DEFAULT_unknownSciFrameTreatment].
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+ @Param[in]     treatMode       The selected mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigUnknownSciFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUnknownSciFrameTreatment treatMode);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigInvalidTagsFrameTreatment
+
+ @Description   Change the treatment for received frames with invalid tags or
+                a zero value PN or an invalid ICV from its default configuration
+                [DEFAULT_invalidTagsFrameTreatment].
+
+ @Param[in]     h_FmMacsec              FM MACSEC module descriptor.
+ @Param[in]     deliverUncontrolled     If True deliver on the uncontrolled port, else discard;
+                                        In both cases discard on the controlled port;
+                                        this provide Strict, Check or Disable mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigInvalidTagsFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment
+
+ @Description   Change the treatment for received frames with the Encryption bit
+                set and the Changed Text bit clear from its default configuration
+                [DEFAULT_encryptWithNoChangedTextFrameTreatment].
+
+ @Param[in]     h_FmMacsec              FM MACSEC module descriptor.
+ @Param[in]     discardUncontrolled     If True discard on the uncontrolled port, else deliver;
+                                        In both cases discard on the controlled port;
+                                        this provide Strict, Check or Disable mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment(t_Handle h_FmMacsec, bool discardUncontrolled);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigChangedTextWithNoEncryptFrameTreatment
+
+ @Description   Change the treatment for received frames with the Encryption bit
+                clear and the Changed Text bit set from its default configuration
+                [DEFAULT_changedTextWithNoEncryptFrameTreatment].
+
+ @Param[in]     h_FmMacsec              FM MACSEC module descriptor.
+ @Param[in]     deliverUncontrolled     If True deliver on the uncontrolled port, else discard;
+                                        In both cases discard on the controlled port;
+                                        this provide Strict, Check or Disable mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigChangedTextWithNoEncryptFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigUntagFrameTreatment
+
+ @Description   Change the treatment for received frames without the MAC security tag (SecTAG)
+                from its default configuration [DEFAULT_untagFrameTreatment].
+
+ @Param[in]     h_FmMacsec     FM MACSEC module descriptor.
+ @Param[in]     treatMode      The selected mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigUntagFrameTreatment(t_Handle h_FmMacsec, e_FmMacsecUntagFrameTreatment treatMode);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigOnlyScbIsSetFrameTreatment
+
+ @Description   Change the treatment for received frames with only SCB bit set
+                from its default configuration [DEFAULT_onlyScbIsSetFrameTreatment].
+
+ @Param[in]     h_FmMacsec              FM MACSEC module descriptor.
+ @Param[in]     deliverUncontrolled     If True deliver on the uncontrolled port, else discard;
+                                        In both cases discard on the controlled port;
+                                        this provide Strict, Check or Disable mode.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigOnlyScbIsSetFrameTreatment(t_Handle h_FmMacsec, bool deliverUncontrolled);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigPnExhaustionThreshold
+
+ @Description   It's provide the ability to configure a PN exhaustion threshold;
+                When the NextPn crosses this value an interrupt event
+                is asserted to warn that the active SA should re-key.
+
+ @Param[in]     h_FmMacsec     FM MACSEC module descriptor.
+ @Param[in]     pnExhThr       If the threshold is reached, an interrupt event
+                               is asserted to re-key.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigPnExhaustionThreshold(t_Handle h_FmMacsec, uint32_t pnExhThr);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigKeysUnreadable
+
+ @Description   Turn on privacy mode; All the keys and their hash values can't be read any more;
+                Can not be cleared unless hard reset.
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigKeysUnreadable(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigSectagWithoutSCI
+
+ @Description   Promise that all generated Sectag will be without SCI included.
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigSectagWithoutSCI(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement;
+                By default all exceptions are enabled.
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Config() and before FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_ConfigException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable);
+
+/** @} */ /* end of FM_MACSEC_advanced_init_grp group */
+/** @} */ /* end of FM_MACSEC_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_runtime_control_grp FM-MACSEC Runtime Control Data Unit
+
+ @Description   FM MACSEC runtime control data unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_GetRevision
+
+ @Description   Return MACSEC HW chip revision
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+ @Param[out]    p_MacsecRevision   MACSEC revision as defined by the chip.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_GetRevision(t_Handle h_FmMacsec, uint32_t *p_MacsecRevision);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Enable
+
+ @Description   This routine should be called after MACSEC is initialized for enabling all
+                MACSEC engines according to their existing configuration.
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Init() and when MACSEC is disabled.
+*//***************************************************************************/
+t_Error FM_MACSEC_Enable(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_Disable
+
+ @Description   This routine may be called when MACSEC is enabled in order to
+                disable all MACSEC engines; The MACSEC is working in bypass mode.
+
+ @Param[in]     h_FmMacsec         FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Init() and when MACSEC is enabled.
+*//***************************************************************************/
+t_Error FM_MACSEC_Disable(t_Handle h_FmMacsec);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SetException
+
+ @Description   Calling this routine enables/disables the specified exception.
+
+ @Param[in]     h_FmMacsec      FM MACSEC module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SetException(t_Handle h_FmMacsec, e_FmMacsecExceptions exception, bool enable);
+
+#if (defined(DEBUG_ERRORS) && (DEBUG_ERRORS > 0))
+/**************************************************************************//**
+ @Function      FM_MACSEC_DumpRegs
+
+ @Description   Dump internal registers.
+
+ @Param[in]     h_FmMacsec  - FM MACSEC module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only after FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_DumpRegs(t_Handle h_FmMacsec);
+#endif /* (defined(DEBUG_ERRORS) && ... */
+
+#ifdef VERIFICATION_SUPPORT
+/********************* VERIFICATION ONLY ********************************/
+/**************************************************************************//**
+ @Function      FM_MACSEC_BackdoorSet
+
+ @Description   Set register of the MACSEC memory map
+
+ @Param[in]     h_FmMacsec          FM MACSEC module descriptor.
+ @Param[out]    offset              Register offset.
+ @Param[out]    value               Value to write.
+
+
+ @Return        None
+
+ @Cautions      Allowed only following FM_MACSEC_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_BackdoorSet(t_Handle h_FmMacsec, uint32_t offset, uint32_t value);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_BackdoorGet
+
+ @Description   Read from register of the MACSEC memory map.
+
+ @Param[in]     h_FmMacsec          FM MACSEC module descriptor.
+ @Param[out]    offset              Register offset.
+
+ @Return        Value read
+
+ @Cautions      Allowed only following FM_MACSEC_Init().
+*//***************************************************************************/
+uint32_t FM_MACSEC_BackdoorGet(t_Handle h_FmMacsec, uint32_t offset);
+#endif /* VERIFICATION_SUPPORT */
+
+/** @} */ /* end of FM_MACSEC_runtime_control_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_SECY_grp FM-MACSEC SecY
+
+ @Description   FM-MACSEC SecY API functions, definitions and enums
+
+ @{
+*//***************************************************************************/
+
+typedef uint8_t     macsecSAKey_t[32];
+typedef uint64_t    macsecSCI_t;
+typedef uint8_t     macsecAN_t;
+
+/**************************************************************************//**
+@Description   MACSEC SECY Cipher Suite
+*//***************************************************************************/
+typedef enum e_FmMacsecSecYCipherSuite {
+    e_FM_MACSEC_SECY_GCM_AES_128 = 0,       /**< GCM-AES-128 */
+#if (DPAA_VERSION >= 11)
+    e_FM_MACSEC_SECY_GCM_AES_256            /**< GCM-AES-256 */
+#endif /* (DPAA_VERSION >= 11) */
+} e_FmMacsecSecYCipherSuite;
+
+/**************************************************************************//**
+ @Description   MACSEC SECY Exceptions
+*//***************************************************************************/
+typedef enum e_FmMacsecSecYExceptions {
+    e_FM_MACSEC_SECY_EX_FRAME_DISCARDED     /**< Frame  Discarded */
+} e_FmMacsecSecYExceptions;
+
+/**************************************************************************//**
+ @Description   MACSEC SECY Events
+*//***************************************************************************/
+typedef enum e_FmMacsecSecYEvents {
+    e_FM_MACSEC_SECY_EV_NEXT_PN             /**< Next Packet Number exhaustion threshold reached */
+} e_FmMacsecSecYEvents;
+
+/**************************************************************************//**
+ @Collection   MACSEC SECY Frame Discarded Descriptor error
+*//***************************************************************************/
+typedef uint8_t    macsecTxScFrameDiscardedErrSelect_t; /**< typedef for defining Frame Discarded Descriptor errors */
+
+#define FM_MACSEC_SECY_TX_SC_FRM_DISCAR_ERR_NEXT_PN_ZERO              0x8000  /**< NextPn == 0 */
+#define FM_MACSEC_SECY_TX_SC_FRM_DISCAR_ERR_SC_DISBALE                0x4000  /**< SC is disable */
+/* @} */
+
+/**************************************************************************//**
+ @Function      t_FmMacsecSecYExceptionsCallback
+
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+
+ @Param[in]     h_App       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     exception   The exception.
+*//***************************************************************************/
+typedef void (t_FmMacsecSecYExceptionsCallback) ( t_Handle                  h_App,
+                                                  e_FmMacsecSecYExceptions  exception);
+
+/**************************************************************************//**
+ @Function      t_FmMacsecSecYEventsCallback
+
+ @Description   Events user callback routine, will be called upon an
+                event passing the event identification.
+
+ @Param[in]     h_App       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     event       The event.
+*//***************************************************************************/
+typedef void (t_FmMacsecSecYEventsCallback) ( t_Handle                  h_App,
+                                              e_FmMacsecSecYEvents      event);
+
+/**************************************************************************//**
+ @Description   RFC2863 MIB
+*//***************************************************************************/
+typedef struct t_MIBStatistics {
+    uint64_t  ifInOctets;              /**< Total number of byte received */
+    uint64_t  ifInPkts;                /**< Total number of packets received */
+    uint64_t  ifInMcastPkts;           /**< Total number of multicast frame received */
+    uint64_t  ifInBcastPkts;           /**< Total number of broadcast frame received */
+    uint64_t  ifInDiscards;            /**< Frames received, but discarded due to problems within the MAC RX :
+                                               - InPktsNoTag,
+                                               - InPktsLate,
+                                               - InPktsOverrun */
+    uint64_t  ifInErrors;              /**< Number of frames received with error:
+                                               - InPktsBadTag,
+                                               - InPktsNoSCI,
+                                               - InPktsNotUsingSA
+                                               - InPktsNotValid */
+    uint64_t  ifOutOctets;             /**< Total number of byte sent */
+    uint64_t  ifOutPkts;               /**< Total number of packets sent */
+    uint64_t  ifOutMcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutBcastPkts;          /**< Total number of multicast frame sent */
+    uint64_t  ifOutDiscards;           /**< Frames received, but discarded due to problems within the MAC TX N/A! */
+    uint64_t  ifOutErrors;             /**< Number of frames transmitted with error:
+                                               - FIFO Overflow Error
+                                               - FIFO Underflow Error
+                                               - Other */
+} t_MIBStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Rx SA Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYRxSaStatistics {
+    uint32_t            inPktsOK;               /**< The number of frames with resolved SCI, have passed all
+                                                     frame validation frame validation with the validateFrame not set to disable */
+    uint32_t            inPktsInvalid;          /**< The number of frames with resolved SCI, that have failed frame
+                                                     validation with the validateFrame set to check */
+    uint32_t            inPktsNotValid;         /**< The number of frames with resolved SCI, discarded on the controlled port,
+                                                     that have failed frame validation with the validateFrame set to strict or the c bit is set */
+    uint32_t            inPktsNotUsingSA;       /**< The number of frames received with resolved SCI and discarded on disabled or
+                                                     not provisioned SA with validateFrame in the strict mode or the C bit is set */
+    uint32_t            inPktsUnusedSA;         /**< The number of frames received with resolved SCI on disabled or not provisioned SA
+                                                     with validateFrame not in the strict mode and the C bit is cleared */
+} t_FmMacsecSecYRxSaStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Tx SA Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYTxSaStatistics {
+    uint64_t            outPktsProtected;       /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, which were integrity protected */
+    uint64_t            outPktsEncrypted;       /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, which were confidentiality protected */
+} t_FmMacsecSecYTxSaStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Rx SC Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYRxScStatistics {
+    uint64_t            inPktsUnchecked;        /**< The number of frames with resolved SCI, delivered to the user of a controlled port,
+                                                     that are not validated with the validateFrame set to disable */
+    uint64_t            inPktsDelayed;          /**< The number of frames with resolved SCI, delivered to the user of a controlled port,
+                                                     that have their PN smaller than the lowest_PN with the validateFrame set to
+                                                     disable or replayProtect disabled */
+    uint64_t            inPktsLate;             /**< The number of frames with resolved SCI, discarded on the controlled port,
+                                                     that have their PN smaller than the lowest_PN with the validateFrame set to
+                                                     Check or Strict and replayProtect enabled */
+    uint64_t            inPktsOK;               /**< The number of frames with resolved SCI, have passed all
+                                                     frame validation frame validation with the validateFrame not set to disable */
+    uint64_t            inPktsInvalid;          /**< The number of frames with resolved SCI, that have failed frame
+                                                     validation with the validateFrame set to check */
+    uint64_t            inPktsNotValid;         /**< The number of frames with resolved SCI, discarded on the controlled port,
+                                                     that have failed frame validation with the validateFrame set to strict or the c bit is set */
+    uint64_t            inPktsNotUsingSA;       /**< The number of frames received with resolved SCI and discarded on disabled or
+                                                     not provisioned SA with validateFrame in the strict mode or the C bit is set */
+    uint64_t            inPktsUnusedSA;         /**< The number of frames received with resolved SCI on disabled or not provisioned SA
+                                                     with validateFrame not in the strict mode and the C bit is cleared */
+} t_FmMacsecSecYRxScStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Tx SC Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYTxScStatistics {
+    uint64_t            outPktsProtected;       /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, which were integrity protected */
+    uint64_t            outPktsEncrypted;       /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, which were confidentiality protected */
+} t_FmMacsecSecYTxScStatistics;
+
+/**************************************************************************//**
+ @Description   MACSEC SecY Statistics
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYStatistics {
+    t_MIBStatistics     mibCtrlStatistics;      /**< Controlled port MIB statistics */
+    t_MIBStatistics     mibNonCtrlStatistics;   /**< Uncontrolled port MIB statistics */
+/* Frame verification statistics */
+    uint64_t            inPktsUntagged;         /**< The number of received packets without the MAC security tag
+                                                     (SecTAG) with validateFrames which is not in the strict mode */
+    uint64_t            inPktsNoTag;            /**< The number of received packets discarded without the
+                                                     MAC security tag (SecTAG) with validateFrames which is in the strict mode */
+    uint64_t            inPktsBadTag;           /**< The number of received packets discarded with an invalid
+                                                     SecTAG or a zero value PN or an invalid ICV */
+    uint64_t            inPktsUnknownSCI;       /**< The number of received packets with unknown SCI with the
+                                                     condition : validateFrames is not in the strict mode and the
+                                                     C bit in the SecTAG is not set */
+    uint64_t            inPktsNoSCI;            /**< The number of received packets discarded with unknown SCI
+                                                     information with the condition : validateFrames is in the strict mode
+                                                     or the C bit in the SecTAG is set */
+    uint64_t            inPktsOverrun;          /**< The number of packets discarded because the number of
+                                                     received packets exceeded the cryptographic performance capabilities */
+/* Frame validation statistics */
+    uint64_t            inOctetsValidated;      /**< The number of octets of plaintext recovered from received frames with
+                                                     resolved SCI that were integrity protected but not encrypted */
+    uint64_t            inOctetsDecrypted;      /**< The number of octets of plaintext recovered from received frames with
+                                                     resolved SCI that were integrity protected and encrypted */
+/* Frame generation statistics */
+    uint64_t            outPktsUntagged;        /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, with protectFrame false */
+    uint64_t            outPktsTooLong;         /**< The number of frames, that the user of the controlled port requested to
+                                                     be transmitted, discarded due to length being larger than Maximum Frame Length (MACSEC_MFL) */
+/* Frame protection statistics */
+    uint64_t            outOctetsProtected;     /**< The number of octets of User Data in transmitted frames that were
+                                                     integrity protected but not encrypted */
+    uint64_t            outOctetsEncrypted;     /**< The number of octets of User Data in transmitted frames that were
+                                                     both integrity protected and encrypted */
+} t_FmMacsecSecYStatistics;
+
+
+/**************************************************************************//**
+ @Description   MACSEC SecY SC Params
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYSCParams {
+    macsecSCI_t                 sci;            /**< The secure channel identification of the SC */
+    e_FmMacsecSecYCipherSuite   cipherSuite;    /**< Cipher suite to be used for the SC */
+} t_FmMacsecSecYSCParams;
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_SECY_init_grp FM-MACSEC SecY Initialization Unit
+
+ @Description   FM-MACSEC SecY Initialization Unit
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Description   enum for validate frames
+*//***************************************************************************/
+typedef enum e_FmMacsecValidFrameBehavior {
+    e_FM_MACSEC_VALID_FRAME_BEHAVIOR_DISABLE = 0,   /**< disable the validation function */
+    e_FM_MACSEC_VALID_FRAME_BEHAVIOR_CHECK,         /**< enable the validation function but only for checking
+                                                         without filtering out invalid frames */
+    e_FM_MACSEC_VALID_FRAME_BEHAVIOR_STRICT         /**< enable the validation function and also strictly filter
+                                                         out those invalid frames */
+} e_FmMacsecValidFrameBehavior;
+
+/**************************************************************************//**
+ @Description   enum for sci insertion
+*//***************************************************************************/
+typedef enum e_FmMacsecSciInsertionMode {
+    e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_SECTAG = 0, /**< explicit sci in the sectag */
+    e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_MAC_SA,     /**< mac sa is overwritten with the sci*/
+    e_FM_MACSEC_SCI_INSERTION_MODE_IMPLICT_PTP          /**< implicit point-to-point sci (pre-shared) */
+} e_FmMacsecSciInsertionMode;
+
+/**************************************************************************//**
+ @Description   FM MACSEC SecY config input
+*//***************************************************************************/
+typedef struct t_FmMacsecSecYParams {
+    t_Handle                                    h_FmMacsec;             /**< A handle to the FM MACSEC object */
+    t_FmMacsecSecYSCParams                      txScParams;             /**< Tx SC Params */
+    uint32_t                                    numReceiveChannels;     /**< Number of receive channels dedicated to this SecY */
+    t_FmMacsecSecYExceptionsCallback            *f_Exception;           /**< Callback routine to be called by the driver upon SecY exception */
+    t_FmMacsecSecYEventsCallback                *f_Event;               /**< Callback routine to be called by the driver upon SecY event */
+    t_Handle                                    h_App;                  /**< A handle to an application layer object; This handle will
+                                                                             be passed by the driver upon calling the above callbacks */
+} t_FmMacsecSecYParams;
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_Config
+
+ @Description   Creates descriptor for the FM MACSEC SECY module;
+
+                The routine returns a handle (descriptor) to the FM MACSEC SECY object;
+                This descriptor must be passed as first parameter to all other
+                FM MACSEC SECY function calls;
+                No actual initialization or configuration of FM MACSEC SecY hardware is
+                done by this routine.
+
+ @Param[in]     p_FmMacsecSecYParam     Pointer to data structure of parameters.
+
+ @Return        Handle to FM MACSEC SECY object, or NULL for Failure.
+*//***************************************************************************/
+t_Handle FM_MACSEC_SECY_Config(t_FmMacsecSecYParams *p_FmMacsecSecYParam);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_Init
+
+ @Description   Initializes the FM MACSEC SECY module.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_Init(t_Handle h_FmMacsecSecY);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_Free
+
+ @Description   Frees all resources that were assigned to FM MACSEC SECY module.
+
+                Calling this routine invalidates the descriptor.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_Free(t_Handle h_FmMacsecSecY);
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_SECY_advanced_init_grp  FM-MACSEC SecY Advanced Configuration Unit
+
+ @Description   Configuration functions used to change default values.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigSciInsertionMode
+
+ @Description   Calling this routine changes the SCI-insertion-mode in the
+                internal driver data base from its default configuration
+                [DEFAULT_sciInsertionMode]
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     sciInsertionMode    Sci insertion mode
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigSciInsertionMode(t_Handle h_FmMacsecSecY, e_FmMacsecSciInsertionMode sciInsertionMode);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigProtectFrames
+
+ @Description   Calling this routine changes the protect-frame mode in the
+                internal driver data base from its default configuration
+                [DEFAULT_protectFrames]
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     protectFrames       If FALSE, frames are transmitted without modification
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigProtectFrames(t_Handle h_FmMacsecSecY, bool protectFrames);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigReplayWindow
+
+ @Description   Calling this routine changes the replay-window settings in the
+                internal driver data base from its default configuration
+                [DEFAULT_replayEnable], [DEFAULT_replayWindow]
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     replayProtect;      Replay protection function mode
+ @Param[in]     replayWindow;       The size of the replay window
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigReplayWindow(t_Handle h_FmMacsecSecY, bool replayProtect, uint32_t replayWindow);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigValidationMode
+
+ @Description   Calling this routine changes the frame-validation-behavior mode
+                in the internal driver data base from its default configuration
+                [DEFAULT_validateFrames]
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     validateFrames      Validation function mode
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigValidationMode(t_Handle h_FmMacsecSecY, e_FmMacsecValidFrameBehavior validateFrames);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigConfidentiality
+
+ @Description   Calling this routine changes the confidentiality settings in the
+                internal driver data base from its default configuration
+                [DEFAULT_confidentialityEnable], [DEFAULT_confidentialityOffset]
+
+ @Param[in]     h_FmMacsecSecY          FM MACSEC SECY module descriptor.
+ @Param[in]     confidentialityEnable   TRUE  - confidentiality protection and integrity protection
+                                        FALSE - no confidentiality protection, only integrity protection
+ @Param[in]     confidentialityOffset   The number of initial octets of each MSDU without confidentiality protection
+                                        common values are 0, 30, and 50
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigConfidentiality(t_Handle h_FmMacsecSecY, bool confidentialityEnable, uint16_t confidentialityOffset);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigPointToPoint
+
+ @Description   configure this SecY to work in point-to-point mode, means that
+                it will have only one rx sc;
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init();
+                Can be called only once in a system; only the first secY that will call this
+                routine will be able to operate in Point-To-Point mode.
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigPointToPoint(t_Handle h_FmMacsecSecY);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigException
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of exceptions enablement;
+                By default all exceptions are enabled.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigException(t_Handle h_FmMacsecSecY, e_FmMacsecSecYExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_ConfigEvent
+
+ @Description   Calling this routine changes the internal driver data base
+                from its default selection of events enablement;
+                By default all events are enabled.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+ @Param[in]     event           The event to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_ConfigEvent(t_Handle h_FmMacsecSecY, e_FmMacsecSecYEvents event, bool enable);
+
+/** @} */ /* end of FM_MACSEC_SECY_advanced_init_grp group */
+/** @} */ /* end of FM_MACSEC_SECY_init_grp group */
+
+
+/**************************************************************************//**
+ @Group         FM_MACSEC_SECY_runtime_control_grp FM-MACSEC SecY Runtime Control Unit
+
+ @Description   FM MACSEC SECY Runtime control unit API functions, definitions and enums.
+
+ @{
+*//***************************************************************************/
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_CreateRxSc
+
+ @Description   Create a receive secure channel.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     scParams            secure channel params.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Handle FM_MACSEC_SECY_CreateRxSc(t_Handle h_FmMacsecSecY, t_FmMacsecSecYSCParams *p_ScParams);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_DeleteRxSc
+
+ @Description   Deleting an initialized secure channel.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSc().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_DeleteRxSc(t_Handle h_FmMacsecSecY, t_Handle h_Sc);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_CreateRxSa
+
+ @Description   Create a receive secure association for the secure channel;
+                the SA cannot be used to receive frames until FM_MACSEC_SECY_RxSaEnableReceive is called.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     lowestPn            the lowest acceptable PN value for a received frame.
+ @Param[in]     key                 the desired key for this SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSc().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_CreateRxSa(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t lowestPn, macsecSAKey_t key);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_DeleteRxSa
+
+ @Description   Deleting an initialized secure association.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_DeleteRxSa(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaEnableReceive
+
+ @Description   Enabling the SA to receive frames.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaEnableReceive(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaDisableReceive
+
+ @Description   Disabling the SA from receive frames.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaDisableReceive(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaUpdateNextPn
+
+ @Description   Update the next packet number expected on RX;
+                The value of nextPN shall be set to the greater of its existing value and the
+                supplied of updtNextPN (802.1AE-2006 10.7.15).
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     updtNextPN          the next PN value for a received frame.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaUpdateNextPn(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t updtNextPN);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaUpdateLowestPn
+
+ @Description   Update the lowest packet number expected on RX;
+                The value of lowestPN shall be set to the greater of its existing value and the
+                supplied of updtLowestPN (802.1AE-2006 10.7.15).
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     updtLowestPN        the lowest PN acceptable value for a received frame.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaUpdateLowestPn(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, uint32_t updtLowestPN);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaModifyKey
+
+ @Description   Modify the current key of the SA with a new one.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     key                 new key to replace the current key.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSa().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaModifyKey(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, macsecSAKey_t key);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_CreateTxSa
+
+ @Description   Create a transmit secure association for the secure channel;
+                the SA cannot be used to transmit frames until FM_MACSEC_SECY_TxSaSetActivate is called;
+                Only one SA can be active at a time.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     key                 the desired key for this SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_CreateTxSa(t_Handle h_FmMacsecSecY, macsecAN_t an, macsecSAKey_t key);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_DeleteTxSa
+
+ @Description   Deleting an initialized secure association.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_DeleteTxSa(t_Handle h_FmMacsecSecY, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxSaModifyKey
+
+ @Description   Modify the key of the inactive SA with a new one.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     nextActiveAn        association number represent the next SA to be activated.
+ @Param[in]     key                 new key to replace the current key.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxSaModifyKey(t_Handle h_FmMacsecSecY, macsecAN_t nextActiveAn, macsecSAKey_t key);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxSaSetActive
+
+ @Description   Set this SA to the active SA to be used on TX for SC;
+                only one SA can be active at a time.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     an                  association number represent the SA.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxSaSetActive(t_Handle h_FmMacsecSecY, macsecAN_t an);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxSaGetActive
+
+ @Description   Get the active SA that being used for TX.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[out]    p_An                the active an.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxSaGetActive(t_Handle h_FmMacsecSecY, macsecAN_t *p_An);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_GetStatistics
+
+ @Description   get all statistics counters.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_GetStatistics(t_Handle h_FmMacsecSecY, t_FmMacsecSecYStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxScGetStatistics
+
+ @Description   get all statistics counters.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                Rx Sc handle.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxScGetStatistics(t_Handle h_FmMacsecSecY, t_Handle h_Sc, t_FmMacsecSecYRxScStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_RxSaGetStatistics
+
+ @Description   get all statistics counters
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                Rx Sc handle.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_RxSaGetStatistics(t_Handle h_FmMacsecSecY, t_Handle h_Sc, macsecAN_t an, t_FmMacsecSecYRxSaStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxScGetStatistics
+
+ @Description   get all statistics counters.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxScGetStatistics(t_Handle h_FmMacsecSecY, t_FmMacsecSecYTxScStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_TxSaGetStatistics
+
+ @Description   get all statistics counters.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     an                  association number represent the SA.
+ @Param[in]     p_Statistics        Structure with statistics.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_TxSaGetStatistics(t_Handle h_FmMacsecSecY, macsecAN_t an, t_FmMacsecSecYTxSaStatistics *p_Statistics);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_SetException
+
+ @Description   Calling this routine enables/disables the specified exception.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+ @Param[in]     exception       The exception to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_SetException(t_Handle h_FmMacsecSecY, e_FmMacsecExceptions exception, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_SetEvent
+
+ @Description   Calling this routine enables/disables the specified event.
+
+ @Param[in]     h_FmMacsecSecY  FM MACSEC SECY module descriptor.
+ @Param[in]     event           The event to be selected.
+ @Param[in]     enable          TRUE to enable interrupt, FALSE to mask it.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Config() and before FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_SetEvent(t_Handle h_FmMacsecSecY, e_FmMacsecSecYEvents event, bool enable);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_GetRxScPhysId
+
+ @Description   return the physical id of the Secure Channel.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[in]     h_Sc                SC handle as returned by FM_MACSEC_SECY_CreateRxSc.
+ @Param[out]    p_ScPhysId          the SC physical id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_CreateRxSc().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_GetRxScPhysId(t_Handle h_FmMacsecSecY, t_Handle h_Sc, uint32_t *p_ScPhysId);
+
+/**************************************************************************//**
+ @Function      FM_MACSEC_SECY_GetTxScPhysId
+
+ @Description   return the physical id of the Secure Channel.
+
+ @Param[in]     h_FmMacsecSecY      FM MACSEC SECY module descriptor.
+ @Param[out]    p_ScPhysId          the SC physical id.
+
+ @Return        E_OK on success; Error code otherwise.
+
+ @Cautions      Allowed only following FM_MACSEC_SECY_Init().
+*//***************************************************************************/
+t_Error FM_MACSEC_SECY_GetTxScPhysId(t_Handle h_FmMacsecSecY, uint32_t *p_ScPhysId);
+
+/** @} */ /* end of FM_MACSEC_SECY_runtime_control_grp group */
+/** @} */ /* end of FM_MACSEC_SECY_grp group */
+/** @} */ /* end of FM_MACSEC_grp group */
+/** @} */ /* end of FM_grp group */
+
+
+#endif /* __FM_MACSEC_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
index 257acb0..f4e5980 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/P3040_P4080_P5020/dpaa_integration_ext.h
@@ -263,4 +263,14 @@ typedef enum
 #define FM_NO_CTXA_COPY_ERRATA_FMAN_SW001
 #define FM_KG_ERASE_FLOW_ID_ERRATA_FMAN_SW004
 
+/*****************************************************************************
+ FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define NUM_OF_RX_SC                16
+#define NUM_OF_TX_SC                16
+
+#define NUM_OF_SA_PER_RX_SC         2
+#define NUM_OF_SA_PER_TX_SC         2
+
+
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
index cffeef9..5f247fb 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/T4240/dpaa_integration_ext.h
@@ -292,4 +292,13 @@ typedef enum
 /* RMan erratas */
 #define RM_ERRONEOUS_ACK_ERRATA_RMAN_A006756
 
+/*****************************************************************************
+ FM MACSEC INTEGRATION-SPECIFIC DEFINITIONS
+******************************************************************************/
+#define NUM_OF_RX_SC                16
+#define NUM_OF_TX_SC                16
+
+#define NUM_OF_SA_PER_RX_SC         2
+#define NUM_OF_SA_PER_TX_SC         2
+
 #endif /* __DPAA_INTEGRATION_EXT_H */
diff --git a/drivers/net/ethernet/freescale/fman/inc/xx_common.h b/drivers/net/ethernet/freescale/fman/inc/xx_common.h
index 1c45177..8e81094 100644
--- a/drivers/net/ethernet/freescale/fman/inc/xx_common.h
+++ b/drivers/net/ethernet/freescale/fman/inc/xx_common.h
@@ -52,5 +52,5 @@
 #define MODULE_FM_PORT          0x00060000
 #define MODULE_MM               0x00070000
 #define MODULE_FM_SP            0x00080000
-
+#define MODULE_FM_MACSEC        0x00090000
 #endif /* __XX_COMMON_H */
-- 
1.9.1

