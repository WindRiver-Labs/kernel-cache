From 3dbbad3a999b2d4e164caa3d390de78af7f9809c Mon Sep 17 00:00:00 2001
From: Weiwei Wang <weiwei.wang@windriver.com>
Date: Thu, 30 Jun 2011 11:31:48 +0800
Subject: [PATCH 733/987] qman: clean SDQCR when do kexec fast reboot

If kernel option maxcpus is set when we do kexec fast reboot,
kernel will hang due to uncertain status of SDQCR on the offlined
CPU qman portal, so clean it in qman shutdown function.

Signed-off-by: Weiwei Wang <weiwei.wang@windriver.com>
Signed-off-by: Bin Jiang <bin.jiang@windriver.com>
---
 drivers/staging/fsl_qbman/qman_config.c | 17 +++++++++++++++++
 drivers/staging/fsl_qbman/qman_high.c   | 19 +++++++++++++++++++
 include/linux/fsl_qman.h                | 17 +++++++++++++++++
 3 files changed, 53 insertions(+)

diff --git a/drivers/staging/fsl_qbman/qman_config.c b/drivers/staging/fsl_qbman/qman_config.c
index 01d6ef7..f5c17d4 100644
--- a/drivers/staging/fsl_qbman/qman_config.c
+++ b/drivers/staging/fsl_qbman/qman_config.c
@@ -1096,6 +1096,20 @@ static const struct attribute_group qman_dev_ecr_grp = {
 	.attrs = qman_dev_ecr_attributes
 };
 
+#if defined(CONFIG_KEXEC)
+void of_fsl_qman_shutdown(struct platform_device *ofdev)
+{
+	int cpu;
+	struct qman_portal *p;
+	for_each_online_cpu(cpu) {
+		p = per_cpu_affine_portal(cpu);
+		qman_static_dequeue_del_ex(p, ~0);
+	}
+	return;
+};
+#endif
+
+
 static int of_fsl_qman_remove(struct platform_device *ofdev)
 {
 	sysfs_remove_group(&ofdev->dev.kobj, &qman_dev_attr_grp);
@@ -1178,6 +1192,9 @@ static struct platform_driver of_fsl_qman_driver = {
 		.pm = &qman_pm_ops,
 	},
 	.probe = of_fsl_qman_probe,
+#if defined(CONFIG_KEXEC)
+	.shutdown = of_fsl_qman_shutdown,
+#endif
 	.remove      = of_fsl_qman_remove,
 };
 
diff --git a/drivers/staging/fsl_qbman/qman_high.c b/drivers/staging/fsl_qbman/qman_high.c
index 5a5bfb3..3676958 100644
--- a/drivers/staging/fsl_qbman/qman_high.c
+++ b/drivers/staging/fsl_qbman/qman_high.c
@@ -156,6 +156,12 @@ static cpumask_t affine_mask;
 static DEFINE_SPINLOCK(affine_mask_lock);
 static u16 affine_channels[NR_CPUS];
 static DEFINE_PER_CPU(struct qman_portal, qman_affine_portal);
+
+struct qman_portal *per_cpu_affine_portal(int cpu)
+{
+	return &per_cpu(qman_affine_portal, cpu);
+}
+EXPORT_SYMBOL(per_cpu_affine_portal);
 void *affine_portals[NR_CPUS];
 
 /* "raw" gets the cpu-local struct whether it's a redirect or not. */
@@ -1300,6 +1306,19 @@ u32 qman_p_static_dequeue_get(struct qman_portal *p)
 }
 EXPORT_SYMBOL(qman_p_static_dequeue_get);
 
+void qman_static_dequeue_del_ex(struct qman_portal *p, u32 pools)
+{
+	__maybe_unused unsigned long irqflags;
+	if (p->config != NULL) {
+		PORTAL_IRQ_LOCK(p, irqflags);
+		pools &= p->config->public_cfg.pools;
+		p->sdqcr &= ~pools;
+		qm_dqrr_sdqcr_set(&p->p, p->sdqcr);
+		PORTAL_IRQ_UNLOCK(p, irqflags);
+	}
+}
+EXPORT_SYMBOL(qman_static_dequeue_del_ex);
+
 u32 qman_static_dequeue_get(void)
 {
 	struct qman_portal *p = get_affine_portal();
diff --git a/include/linux/fsl_qman.h b/include/linux/fsl_qman.h
index 20e48c6..2960bdc 100644
--- a/include/linux/fsl_qman.h
+++ b/include/linux/fsl_qman.h
@@ -1756,6 +1756,23 @@ void qman_static_dequeue_add(u32 pools);
 void qman_static_dequeue_del(u32 pools);
 
 /**
+ * qman_static_dequeue_del_ex - Remove pool channels from specific portal SDQCR
+ * @p: qman_portal pointer that we will operate on
+ * @pools: bit-mask of pool channels, using QM_SDQCR_CHANNELS_POOL(n)
+ *
+ * Removes a set of pool channels from specific portal's static dequeue command
+ * register (SDQCR). The requested pools are limited to those the portal has
+ * dequeue access to.
+ */
+void qman_static_dequeue_del_ex(struct qman_portal *p, u32 pools);
+
+/**
+ * per_cpu_affine_portal - Get affine portal of specific cpu
+ * @cpu: the specific cpu from which we get affine portal
+ */
+struct qman_portal *per_cpu_affine_portal(int cpu);
+
+/**
  * qman_static_dequeue_get - return the portal's current SDQCR
  *
  * Returns the portal's current static dequeue command register (SDQCR). The
-- 
1.9.1

