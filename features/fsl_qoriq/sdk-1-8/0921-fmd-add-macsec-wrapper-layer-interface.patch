From 348d432bf9b53e3b85afa71e19d3acfdddb330d9 Mon Sep 17 00:00:00 2001
From: Mandy Lavi <mandy.lavi@freescale.com>
Date: Sun, 22 Mar 2015 23:00:27 +0900
Subject: [PATCH 921/987] fmd: add macsec wrapper layer interface

Change-Id: I1498478e96ac52523283e41fd047b1162dad11ba
Signed-off-by: Mandy Lavi <mandy.lavi@freescale.com>
Reviewed-on: http://git.am.freescale.net:8181/33210
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Camelia Alexandra Groza <camelia.groza@freescale.com>
Reviewed-by: Honghua Yin <Hong-Hua.Yin@freescale.com>
[Yang: Original patch taken from
QorIQ-SDK-V1.8-SOURCE-20150619-yocto.iso.
Fix context to apply to WRL.]
Signed-off-by: Quanyang Wang <quanyang.wang@windriver.com>
---
 .../inc/integrations/P1023/dpaa_integration_ext.h  |  25 -
 .../fman/src/inc/wrapper/lnxwrp_fsl_fman.h         | 269 ++++++++-
 .../freescale/fman/src/wrapper/lnxwrp_fm.c         | 663 ++++++++++++++++++++-
 3 files changed, 926 insertions(+), 31 deletions(-)

diff --git a/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h b/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h
index 92906db..ce9c7cd 100644
--- a/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h
+++ b/drivers/net/ethernet/freescale/fman/inc/integrations/P1023/dpaa_integration_ext.h
@@ -180,31 +180,6 @@ typedef enum {
  @Description   Enum for inter-module interrupts registration
 *//***************************************************************************/
 
-typedef enum e_FmMacsecEventModules{
-    e_FM_MACSEC_MOD_SC_TX,
-    e_FM_MACSEC_MOD_DUMMY_LAST
-} e_FmMacsecEventModules;
-
-typedef enum e_FmMacsecInterModuleEvent {
-    e_FM_MACSEC_EV_SC_TX,
-    e_FM_MACSEC_EV_ERR_SC_TX,
-    e_FM_MACSEC_EV_DUMMY_LAST
-} e_FmMacsecInterModuleEvent;
-
-#define NUM_OF_INTER_MODULE_EVENTS (NUM_OF_TX_SC * 2)
-
-#define GET_MACSEC_MODULE_EVENT(mod, id, intrType, event) \
-    switch(mod){                                          \
-        case e_FM_MACSEC_MOD_SC_TX:                       \
-             event = (intrType == e_FM_INTR_TYPE_ERR) ?   \
-                        e_FM_MACSEC_EV_ERR_SC_TX:         \
-                        e_FM_MACSEC_EV_SC_TX;             \
-             event += (uint8_t)(2 * id);break;            \
-            break;                                        \
-        default:event = e_FM_MACSEC_EV_DUMMY_LAST;        \
-        break;}
-
-
 /* 1023 unique features */
 #define FM_QMI_NO_ECC_EXCEPTIONS
 #define FM_CSI_CFED_LIMIT
diff --git a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
index 987fe40..f068499 100644
--- a/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
+++ b/drivers/net/ethernet/freescale/fman/src/inc/wrapper/lnxwrp_fsl_fman.h
@@ -45,6 +45,7 @@
 #include "dpaa_integration_ext.h"
 #include "fm_port_ext.h"
 #include "fm_mac_ext.h"
+#include "fm_macsec_ext.h"
 #include "fm_rtc_ext.h"
 
 /**************************************************************************//**
@@ -69,6 +70,162 @@
 /*****************************************************************************/
 
 /**************************************************************************//**
+ @Description   MACSEC Exceptions wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_exception {
+	SINGLE_BIT_ECC = e_FM_MACSEC_EX_SINGLE_BIT_ECC,
+	MULTI_BIT_ECC = e_FM_MACSEC_EX_MULTI_BIT_ECC
+} fm_macsec_exception;
+
+/**************************************************************************//**
+ @Description   Unknown sci frame treatment wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_unknown_sci_frame_treatment {
+	SCI_DISCARD_BOTH = e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_BOTH,
+	SCI_DISCARD_UNCTRL_DELIVER_DISCARD_CTRL = \
+		e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DISCARD_UNCONTROLLED_DELIVER_OR_DISCARD_CONTROLLED,
+	SCI_DELIVER_UNCTRL_DISCARD_CTRL = \
+		e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED,
+	SCI_DELIVER_DISCARD_UNCTRL_DELIVER_DISCARD_CTRL = \
+		e_FM_MACSEC_UNKNOWN_SCI_FRAME_TREATMENT_DELIVER_OR_DISCARD_UNCONTROLLED_DELIVER_OR_DISCARD_CONTROLLED
+} fm_macsec_unknown_sci_frame_treatment;
+
+/**************************************************************************//**
+ @Description   Untag frame treatment wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_untag_frame_treatment {
+	UNTAG_DELIVER_UNCTRL_DISCARD_CTRL = \
+		e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DELIVER_UNCONTROLLED_DISCARD_CONTROLLED,
+	UNTAG_DISCARD_BOTH = e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DISCARD_BOTH,
+	UNTAG_DISCARD_UNCTRL_DELIVER_CTRL_UNMODIFIED = \
+		e_FM_MACSEC_UNTAG_FRAME_TREATMENT_DISCARD_UNCONTROLLED_DELIVER_CONTROLLED_UNMODIFIED
+} fm_macsec_untag_frame_treatment;
+
+/**************************************************************************//**
+@Description   MACSEC SECY Cipher Suite wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_secy_cipher_suite {
+	SECY_GCM_AES_128 = e_FM_MACSEC_SECY_GCM_AES_128,    /**< GCM-AES-128 */
+#if (DPAA_VERSION >= 11)
+	SECY_GCM_AES_256 = e_FM_MACSEC_SECY_GCM_AES_256     /**< GCM-AES-256 */
+#endif /* (DPAA_VERSION >= 11) */
+} fm_macsec_secy_cipher_suite;
+
+/**************************************************************************//**
+ @Description   MACSEC SECY Exceptions wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_secy_exception {
+	SECY_EX_FRAME_DISCARDED = e_FM_MACSEC_SECY_EX_FRAME_DISCARDED
+} fm_macsec_secy_exception;
+
+/**************************************************************************//**
+ @Description   MACSEC SECY Events wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_secy_event {
+	SECY_EV_NEXT_PN = e_FM_MACSEC_SECY_EV_NEXT_PN
+} fm_macsec_secy_event;
+
+/**************************************************************************//**
+ @Description   Valid frame behaviors wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_valid_frame_behavior {
+	VALID_FRAME_BEHAVIOR_DISABLE = e_FM_MACSEC_VALID_FRAME_BEHAVIOR_DISABLE,
+	VALID_FRAME_BEHAVIOR_CHECK = e_FM_MACSEC_VALID_FRAME_BEHAVIOR_CHECK,
+	VALID_FRAME_BEHAVIOR_STRICT = e_FM_MACSEC_VALID_FRAME_BEHAVIOR_STRICT
+} fm_macsec_valid_frame_behavior;
+
+/**************************************************************************//**
+ @Description   SCI insertion modes wrapper
+*//***************************************************************************/
+typedef enum fm_macsec_sci_insertion_mode {
+	SCI_INSERTION_MODE_EXPLICIT_SECTAG = \
+		e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_SECTAG,
+	SCI_INSERTION_MODE_EXPLICIT_MAC_SA = \
+		e_FM_MACSEC_SCI_INSERTION_MODE_EXPLICIT_MAC_SA,
+	SCI_INSERTION_MODE_IMPLICT_PTP = e_FM_MACSEC_SCI_INSERTION_MODE_IMPLICT_PTP
+} fm_macsec_sci_insertion_mode;
+
+typedef macsecSAKey_t macsec_sa_key_t;
+typedef macsecSCI_t macsec_sci_t;
+typedef macsecAN_t macsec_an_t;
+typedef t_Handle handle_t;
+
+/**************************************************************************//**
+ @Function      fm_macsec_secy_exception_callback wrapper
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+ @Param[in]     app_h       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     exception   The exception.
+*//***************************************************************************/
+typedef void (fm_macsec_secy_exception_callback) (handle_t app_h,
+				fm_macsec_secy_exception exception);
+
+/**************************************************************************//**
+ @Function      fm_macsec_secy_event_callback wrapper
+ @Description   Events user callback routine, will be called upon an
+                event passing the event identification.
+ @Param[in]     app_h       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     event       The event.
+*//***************************************************************************/
+typedef void (fm_macsec_secy_event_callback) (handle_t app_h,
+				fm_macsec_secy_event event);
+
+/**************************************************************************//**
+ @Function      fm_macsec_exception_callback wrapper
+ @Description   Exceptions user callback routine, will be called upon an
+                exception passing the exception identification.
+ @Param[in]     app_h       A handle to an application layer object; This handle
+                            will be passed by the driver upon calling this callback.
+ @Param[in]     exception   The exception.
+*//***************************************************************************/
+typedef void (fm_macsec_exception_callback) (handle_t app_h,
+				fm_macsec_exception exception);
+
+/**************************************************************************//**
+ @Description   MACSEC SecY SC Params wrapper
+*//***************************************************************************/
+struct fm_macsec_secy_sc_params {
+	macsec_sci_t sci;
+	fm_macsec_secy_cipher_suite cipher_suite;
+};
+
+/**************************************************************************//**
+ @Description   FM MACSEC SecY config input wrapper
+*//***************************************************************************/
+struct fm_macsec_secy_params {
+	handle_t fm_macsec_h;
+	struct fm_macsec_secy_sc_params tx_sc_params;
+	uint32_t num_receive_channels;
+	fm_macsec_secy_exception_callback *exception_f;
+	fm_macsec_secy_event_callback *event_f;
+	handle_t app_h;
+};
+
+/**************************************************************************//**
+ @Description   FM MACSEC config input wrapper
+*//***************************************************************************/
+struct fm_macsec_params {
+	handle_t fm_h;
+	bool guest_mode;
+
+	union {
+		struct {
+			uint8_t fm_mac_id;
+		} guest_params;
+
+		struct {
+			uintptr_t base_addr;
+			handle_t fm_mac_h;
+			fm_macsec_exception_callback *exception_f;
+			handle_t app_h;
+		} non_guest_params;
+	};
+
+};
+
+/**************************************************************************//**
  @Description	FM device opaque structure used for type checking
 *//***************************************************************************/
 struct fm;
@@ -79,6 +236,12 @@ struct fm;
 struct fm_mac_dev;
 
 /**************************************************************************//**
+ @Description	FM MACSEC device opaque structure used for type checking
+*//***************************************************************************/
+struct fm_macsec_dev;
+struct fm_macsec_secy_dev;
+
+/**************************************************************************//**
  @Description	A structure ..,
 *//***************************************************************************/
 struct fm_port;
@@ -403,7 +566,7 @@ struct   auto_res_ndp_info
 		refer to temp IP addresses. Note that all temp IP adresses must
 		be from the same multicast group. This will be checked and if
 		not operation will fail. */
-    
+
 	bool                        enable_conflict_detection; /* when TRUE
 		Conflict Detection will be checked and wake the host if
 		needed */
@@ -530,13 +693,13 @@ struct auto_res_port_stats
 
 int fm_port_config_autores_for_deepsleep_support(struct fm_port *port,
 	struct auto_res_tables_sizes *params);
-	
+
 int fm_port_enter_autores_for_deepsleep(struct fm_port *port,
 	struct auto_res_port_params *params);
-	
+
 void fm_port_exit_auto_res_for_deep_sleep(struct fm_port *port_rx,
 	struct fm_port *port_tx);
-	
+
 bool fm_port_is_in_auto_res_mode(struct fm_port *port);
 
 struct auto_res_tables_sizes *fm_port_get_autores_maxsize(
@@ -648,6 +811,104 @@ int fm_rtc_set_fiper(struct fm *fm_dev, uint32_t id,
 int fm_mac_set_wol(struct fm_port *port, struct fm_mac_dev *fm_mac_dev,
 			bool en);
 
+/**************************************************************************//**
+@Function     fm_macsec_set_exception
+
+@Description  Set MACSEC exception state.
+
+@Param[in]    fm_macsec_dev   - A handle of the FM MACSEC device.
+@Param[in]    exception    - FM MACSEC exception type.
+@Param[in]    enable       - new state.
+
+*//***************************************************************************/
+
+int fm_macsec_set_exception(struct fm_macsec_dev *fm_macsec_dev,
+			fm_macsec_exception exception, bool enable);
+int fm_macsec_free(struct fm_macsec_dev *fm_macsec_dev);
+struct fm_macsec_dev *fm_macsec_config(struct fm_macsec_params *fm_params);
+int fm_macsec_init(struct fm_macsec_dev *fm_macsec_dev);
+int fm_macsec_config_unknown_sci_frame_treatment(struct fm_macsec_dev
+				*fm_macsec_dev,
+				fm_macsec_unknown_sci_frame_treatment treat_mode);
+int fm_macsec_config_invalid_tags_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				bool deliver_uncontrolled);
+int fm_macsec_config_kay_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				bool discard_uncontrolled);
+int fm_macsec_config_untag_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				    fm_macsec_untag_frame_treatment treat_mode);
+int fm_macsec_config_pn_exhaustion_threshold(struct fm_macsec_dev *fm_macsec_dev,
+					uint32_t pnExhThr);
+int fm_macsec_config_keys_unreadable(struct fm_macsec_dev *fm_macsec_dev);
+int fm_macsec_config_sectag_without_sci(struct fm_macsec_dev *fm_macsec_dev);
+int fm_macsec_config_exception(struct fm_macsec_dev *fm_macsec_dev,
+			    fm_macsec_exception exception, bool enable);
+int fm_macsec_get_revision(struct fm_macsec_dev *fm_macsec_dev,
+			    int *macsec_revision);
+int fm_macsec_enable(struct fm_macsec_dev *fm_macsec_dev);
+int fm_macsec_disable(struct fm_macsec_dev *fm_macsec_dev);
+
+
+int fm_macsec_secy_config_exception(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    fm_macsec_secy_exception exception,
+				    bool enable);
+int fm_macsec_secy_free(struct fm_macsec_secy_dev *fm_macsec_secy_dev);
+struct fm_macsec_secy_dev *fm_macsec_secy_config(struct fm_macsec_secy_params *secy_params);
+int fm_macsec_secy_init(struct fm_macsec_secy_dev *fm_macsec_secy_dev);
+int fm_macsec_secy_config_sci_insertion_mode(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				fm_macsec_sci_insertion_mode sci_insertion_mode);
+int fm_macsec_secy_config_protect_frames(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool protect_frames);
+int fm_macsec_secy_config_replay_window(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool replay_protect, uint32_t replay_window);
+int fm_macsec_secy_config_validation_mode(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				fm_macsec_valid_frame_behavior validate_frames);
+int fm_macsec_secy_config_confidentiality(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool confidentiality_enable,
+				uint32_t confidentiality_offset);
+int fm_macsec_secy_config_point_to_point(struct fm_macsec_secy_dev *fm_macsec_secy_dev);
+int fm_macsec_secy_config_event(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    fm_macsec_secy_event event,
+				    bool enable);
+struct rx_sc_dev *fm_macsec_secy_create_rxsc(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct fm_macsec_secy_sc_params *params);
+int fm_macsec_secy_delete_rxsc(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc);
+int fm_macsec_secy_create_rx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, macsec_an_t an,
+				uint32_t lowest_pn, macsec_sa_key_t key);
+int fm_macsec_secy_delete_rx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, macsec_an_t an);
+int fm_macsec_secy_rxsa_enable_receive(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an);
+int fm_macsec_secy_rxsa_disable_receive(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an);
+int fm_macsec_secy_rxsa_update_next_pn(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, uint32_t updt_next_pn);
+int fm_macsec_secy_rxsa_update_lowest_pn(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, uint32_t updt_lowest_pn);
+int fm_macsec_secy_rxsa_modify_key(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, macsec_sa_key_t key);
+int fm_macsec_secy_create_tx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				macsec_an_t an, macsec_sa_key_t key);
+int fm_macsec_secy_delete_tx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				macsec_an_t an);
+int fm_macsec_secy_txsa_modify_key(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t next_active_an,
+					macsec_sa_key_t key);
+int fm_macsec_secy_txsa_set_active(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t an);
+int fm_macsec_secy_txsa_get_active(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t *p_an);
+int fm_macsec_secy_get_rxsc_phys_id(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, uint32_t *sc_phys_id);
+int fm_macsec_secy_get_txsc_phys_id(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    uint32_t *sc_phys_id);
+
 /** @} */ /* end of FM_LnxKern_ctrl_grp group */
 /** @} */ /* end of FM_LnxKern_grp group */
 
diff --git a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
index 2801d11..f467d59 100755
--- a/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
+++ b/drivers/net/ethernet/freescale/fman/src/wrapper/lnxwrp_fm.c
@@ -764,7 +764,7 @@ static t_Error CheckNConfigFmAdvArgs (t_LnxWrpFmDev *p_LnxWrpFmDev)
     if (uint32_prop) {
     	if (WARN_ON(lenp != sizeof(uint32_t)))
             RETURN_ERROR(MINOR, E_INVALID_VALUE, NO_MSG);
- 
+
         err = FM_ConfigTnumAgingPeriod(p_LnxWrpFmDev->h_Dev,
             (uint16_t)uint32_prop[0]/*tnumAgingPeriod*/);
 
@@ -1428,7 +1428,7 @@ int fm_port_enter_autores_for_deepsleep(struct fm_port *port,
 		/*Register other under /proc/autoresponse */
     	if (WARN_ON(sizeof(t_FmPortDsarParams) != sizeof(struct auto_res_port_params)))
             return -EFAULT;
-	
+
 	FM_PORT_EnterDsar(p_LnxWrpFmPortDev->h_Dev, (t_FmPortDsarParams*)params);
 	return 0;
 }
@@ -2026,6 +2026,665 @@ void fm_mutex_unlock(void)
 }
 EXPORT_SYMBOL(fm_mutex_unlock);
 
+/*Macsec wrapper functions*/
+struct fm_macsec_dev *fm_macsec_config(struct fm_macsec_params *fm_params)
+{
+	struct fm_macsec_dev *fm_macsec_dev;
+
+	fm_macsec_dev = FM_MACSEC_Config((t_FmMacsecParams *)fm_params);
+	if (unlikely(fm_macsec_dev == NULL))
+		pr_err("FM_MACSEC_Config() failed\n");
+
+	return fm_macsec_dev;
+}
+EXPORT_SYMBOL(fm_macsec_config);
+
+int fm_macsec_init(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_Init(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_Init() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_init);
+
+int fm_macsec_free(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _error;
+
+	err = FM_MACSEC_Free(fm_macsec_dev);
+	_error = -GET_ERROR_TYPE(err);
+
+	if (unlikely(_error < 0))
+		pr_err("FM_MACSEC_Free() = 0x%08x\n", err);
+
+	return _error;
+}
+EXPORT_SYMBOL(fm_macsec_free);
+
+int fm_macsec_config_unknown_sci_frame_treatment(struct fm_macsec_dev
+				*fm_macsec_dev,
+				fm_macsec_unknown_sci_frame_treatment treat_mode)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigUnknownSciFrameTreatment(fm_macsec_dev,
+		treat_mode);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigUnknownSciFrameTreatmen() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_unknown_sci_frame_treatment);
+
+int fm_macsec_config_invalid_tags_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				bool deliver_uncontrolled)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigInvalidTagsFrameTreatment(fm_macsec_dev,
+						deliver_uncontrolled);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MAC_ConfigMaxFrameLength() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_invalid_tags_frame_treatment);
+
+int fm_macsec_config_kay_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				bool discard_uncontrolled)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatment(fm_macsec_dev,
+						discard_uncontrolled);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigEncryptWithNoChangedTextFrameTreatmen() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_kay_frame_treatment);
+
+int fm_macsec_config_untag_frame_treatment(struct fm_macsec_dev *fm_macsec_dev,
+				    fm_macsec_untag_frame_treatment treat_mode)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigUntagFrameTreatment(fm_macsec_dev, treat_mode);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigUntagFrameTreatment() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_untag_frame_treatment);
+
+int fm_macsec_config_pn_exhaustion_threshold(struct fm_macsec_dev *fm_macsec_dev,
+					uint32_t pn_exh_thr)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigPnExhaustionThreshold(fm_macsec_dev, pn_exh_thr);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigPnExhaustionThreshold() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_pn_exhaustion_threshold);
+
+int fm_macsec_config_keys_unreadable(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err =  FM_MACSEC_ConfigKeysUnreadable(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigKeysUnreadable() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_keys_unreadable);
+
+int fm_macsec_config_sectag_without_sci(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err =  FM_MACSEC_ConfigSectagWithoutSCI(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigSectagWithoutSCI() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_sectag_without_sci);
+
+int fm_macsec_config_exception(struct fm_macsec_dev *fm_macsec_dev,
+			    fm_macsec_exception exception, bool enable)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_ConfigException(fm_macsec_dev, exception, enable);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_ConfigException() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_config_exception);
+
+int fm_macsec_get_revision(struct fm_macsec_dev *fm_macsec_dev,
+			    int *macsec_revision)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_GetRevision(fm_macsec_dev, macsec_revision);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_GetRevision() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_get_revision);
+
+int fm_macsec_enable(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_Enable(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_Enable() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_enable);
+
+int fm_macsec_disable(struct fm_macsec_dev *fm_macsec_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_Disable(fm_macsec_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_Disable() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_disable);
+
+int fm_macsec_set_exception(struct fm_macsec_dev *fm_macsec_dev,
+			fm_macsec_exception exception, bool enable)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SetException(fm_macsec_dev, exception, enable);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SetException() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_set_exception);
+
+/* Macsec SECY wrapper API */
+struct fm_macsec_secy_dev *fm_macsec_secy_config(struct fm_macsec_secy_params *secy_params)
+{
+	struct fm_macsec_secy_dev *fm_macsec_secy;
+
+	fm_macsec_secy = FM_MACSEC_SECY_Config((t_FmMacsecSecYParams *)secy_params);
+	if (unlikely(fm_macsec_secy < 0))
+		pr_err("FM_MACSEC_SECY_Config() failed\n");
+
+	return fm_macsec_secy;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config);
+
+int fm_macsec_secy_init(struct fm_macsec_secy_dev *fm_macsec_secy_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_Init(fm_macsec_secy_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_Init() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_init);
+
+int fm_macsec_secy_free(struct fm_macsec_secy_dev *fm_macsec_secy_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_Free(fm_macsec_secy_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_Free() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_free);
+
+int fm_macsec_secy_config_sci_insertion_mode(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				fm_macsec_sci_insertion_mode sci_insertion_mode)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigSciInsertionMode(fm_macsec_secy_dev,
+					sci_insertion_mode);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigSciInsertionMode() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_sci_insertion_mode);
+
+int fm_macsec_secy_config_protect_frames(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool protect_frames)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigProtectFrames(fm_macsec_secy_dev,
+						protect_frames);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigProtectFrames() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_protect_frames);
+
+int fm_macsec_secy_config_replay_window(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool replay_protect, uint32_t replay_window)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigReplayWindow(fm_macsec_secy_dev,
+						replay_protect, replay_window);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigReplayWindow() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_replay_window);
+
+int fm_macsec_secy_config_validation_mode(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				fm_macsec_valid_frame_behavior validate_frames)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigValidationMode(fm_macsec_secy_dev,
+						    validate_frames);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigValidationMode() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_validation_mode);
+
+int fm_macsec_secy_config_confidentiality(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				bool confidentiality_enable,
+				uint32_t confidentiality_offset)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigConfidentiality(fm_macsec_secy_dev,
+						    confidentiality_enable,
+						    confidentiality_offset);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigConfidentiality() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_confidentiality);
+
+int fm_macsec_secy_config_point_to_point(struct fm_macsec_secy_dev *fm_macsec_secy_dev)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigPointToPoint(fm_macsec_secy_dev);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigPointToPoint() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_point_to_point);
+
+int fm_macsec_secy_config_exception(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    fm_macsec_secy_exception exception,
+				    bool enable)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigException(fm_macsec_secy_dev, exception,
+					    enable);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigException() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_exception);
+
+int fm_macsec_secy_config_event(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    fm_macsec_secy_event event,
+				    bool enable)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_ConfigEvent(fm_macsec_secy_dev, event, enable);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_ConfigEvent() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_config_event);
+
+struct rx_sc_dev *fm_macsec_secy_create_rxsc(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct fm_macsec_secy_sc_params  *params)
+{
+	struct rx_sc_dev *rx_sc_dev;
+
+	rx_sc_dev = FM_MACSEC_SECY_CreateRxSc(fm_macsec_secy_dev, (t_FmMacsecSecYSCParams *)params);
+	if (unlikely(rx_sc_dev == NULL))
+		pr_err("FM_MACSEC_SECY_CreateRxSc() failed\n");
+
+	return rx_sc_dev;
+}
+EXPORT_SYMBOL(fm_macsec_secy_create_rxsc);
+
+int fm_macsec_secy_delete_rxsc(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_DeleteRxSc(fm_macsec_secy_dev, sc);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_DeleteRxSc() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_delete_rxsc);
+
+int fm_macsec_secy_create_rx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, macsec_an_t an,
+				uint32_t lowest_pn, macsec_sa_key_t key)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_CreateRxSa(fm_macsec_secy_dev, sc, an,
+					lowest_pn, key);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_CreateRxSa() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_create_rx_sa);
+
+int fm_macsec_secy_delete_rx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_DeleteRxSa(fm_macsec_secy_dev, sc, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_DeleteRxSa() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_delete_rx_sa);
+
+int fm_macsec_secy_rxsa_enable_receive(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaEnableReceive(fm_macsec_secy_dev, sc, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaEnableReceive() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_enable_receive);
+
+int fm_macsec_secy_rxsa_disable_receive(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaDisableReceive(fm_macsec_secy_dev, sc, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaDisableReceive() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_disable_receive);
+
+int fm_macsec_secy_rxsa_update_next_pn(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, uint32_t updt_next_pn)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaUpdateNextPn(fm_macsec_secy_dev, sc, an,
+						updt_next_pn);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaUpdateNextPn() = 0x%08x\n", err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_update_next_pn);
+
+int fm_macsec_secy_rxsa_update_lowest_pn(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, uint32_t updt_lowest_pn)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaUpdateLowestPn(fm_macsec_secy_dev, sc, an,
+						updt_lowest_pn);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaUpdateLowestPn() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_update_lowest_pn);
+
+int fm_macsec_secy_rxsa_modify_key(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					struct rx_sc_dev *sc,
+					macsec_an_t an, macsec_sa_key_t key)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_RxSaModifyKey(fm_macsec_secy_dev, sc, an, key);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_RxSaModifyKey() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_rxsa_modify_key);
+
+int fm_macsec_secy_create_tx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				macsec_an_t an, macsec_sa_key_t key)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_CreateTxSa(fm_macsec_secy_dev, an, key);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_CreateTxSa() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_create_tx_sa);
+
+int fm_macsec_secy_delete_tx_sa(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_DeleteTxSa(fm_macsec_secy_dev, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_DeleteTxSa() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_delete_tx_sa);
+
+int fm_macsec_secy_txsa_modify_key(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t next_active_an,
+					macsec_sa_key_t key)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_TxSaModifyKey(fm_macsec_secy_dev, next_active_an,
+					    key);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_TxSaModifyKey() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_txsa_modify_key);
+
+int fm_macsec_secy_txsa_set_active(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_TxSaSetActive(fm_macsec_secy_dev, an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_TxSaSetActive() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_txsa_set_active);
+
+int fm_macsec_secy_txsa_get_active(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+					macsec_an_t *p_an)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_TxSaGetActive(fm_macsec_secy_dev, p_an);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_TxSaGetActive() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_txsa_get_active);
+
+int fm_macsec_secy_get_rxsc_phys_id(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				struct rx_sc_dev *sc, uint32_t *sc_phys_id)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_GetRxScPhysId(fm_macsec_secy_dev, sc, sc_phys_id);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_GetRxScPhysId() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_get_rxsc_phys_id);
+
+int fm_macsec_secy_get_txsc_phys_id(struct fm_macsec_secy_dev *fm_macsec_secy_dev,
+				    uint32_t *sc_phys_id)
+{
+	int err;
+	int _errno;
+
+	err = FM_MACSEC_SECY_GetTxScPhysId(fm_macsec_secy_dev, sc_phys_id);
+	_errno = -GET_ERROR_TYPE(err);
+	if (unlikely(_errno < 0))
+		pr_err("FM_MACSEC_SECY_GetTxScPhysId() = 0x%08x\n",
+			err);
+
+	return _errno;
+}
+EXPORT_SYMBOL(fm_macsec_secy_get_txsc_phys_id);
+
 static t_Handle h_FmLnxWrp;
 
 #ifdef CONFIG_KEXEC
-- 
1.9.1

