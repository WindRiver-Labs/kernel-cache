From 241c3f05e41419da56a56d5cd113a676c0a6a679 Mon Sep 17 00:00:00 2001
From: Madalin Bucur <madalin.bucur@freescale.com>
Date: Tue, 6 Aug 2013 17:48:49 +0300
Subject: [PATCH 316/987] dpaa_eth: solve several code style issues

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

Fix a series of checkpatch complaints in the dpaa_eth code.

Signed-off-by: Madalin Bucur <madalin.bucur@freescale.com>
Change-Id: I341d5835bb0a4491456947b8e1ae714e095cd580
Reviewed-on: http://git.am.freescale.net:8181/3811
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Rivera Jose-B46482 <Jose.G.Rivera@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/Makefile        |  4 +-
 drivers/net/ethernet/freescale/dpa/dpa-ethtool.c   | 26 ++++---
 drivers/net/ethernet/freescale/dpa/dpaa_1588.c     |  6 +-
 drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c  |  2 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c      | 38 ++++------
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h      | 82 ++++++++--------------
 .../net/ethernet/freescale/dpa/dpaa_eth_common.c   |  4 +-
 .../net/ethernet/freescale/dpa/dpaa_eth_macless.c  |  3 +-
 .../net/ethernet/freescale/dpa/dpaa_eth_non_sg.c   |  4 +-
 .../net/ethernet/freescale/dpa/dpaa_eth_proxy.c    |  3 +-
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c   | 54 ++++++--------
 .../net/ethernet/freescale/dpa/dpaa_eth_shared.c   |  8 ++-
 drivers/net/ethernet/freescale/dpa/mac-api.c       | 31 ++++----
 drivers/net/ethernet/freescale/dpa/mac.c           | 30 ++++----
 .../ethernet/freescale/fman/inc/flib/fsl_fman.h    |  4 ++
 15 files changed, 134 insertions(+), 165 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/Makefile b/drivers/net/ethernet/freescale/dpa/Makefile
index b088046..c6ca17e 100644
--- a/drivers/net/ethernet/freescale/dpa/Makefile
+++ b/drivers/net/ethernet/freescale/dpa/Makefile
@@ -1,12 +1,12 @@
 #
 # Makefile for the Freescale Ethernet controllers
 #
-EXTRA_CFLAGS           += -DVERSION=\"\"
+ccflags-y += -DVERSION=\"\"
 #
 #Include netcomm SW specific definitions
 include $(srctree)/drivers/net/ethernet/freescale/fman/ncsw_config.mk
 
-EXTRA_CFLAGS += -I$(NET_DPA)
+ccflags-y += -I$(NET_DPA)
 
 obj-$(CONFIG_FSL_DPAA_1588) += dpaa_1588.o
 obj-$(CONFIG_FSL_DPAA_ETH_SG_SUPPORT) += fsl-dpa-sg.o
diff --git a/drivers/net/ethernet/freescale/dpa/dpa-ethtool.c b/drivers/net/ethernet/freescale/dpa/dpa-ethtool.c
index 34681d1..37b8cae 100644
--- a/drivers/net/ethernet/freescale/dpa/dpa-ethtool.c
+++ b/drivers/net/ethernet/freescale/dpa/dpa-ethtool.c
@@ -37,7 +37,8 @@
 
 #include "dpaa_eth.h"
 
-static int __cold dpa_get_settings(struct net_device *net_dev, struct ethtool_cmd *et_cmd)
+static int __cold dpa_get_settings(struct net_device *net_dev,
+		struct ethtool_cmd *et_cmd)
 {
 	int			 _errno;
 	struct dpa_priv_s	*priv;
@@ -60,7 +61,8 @@ static int __cold dpa_get_settings(struct net_device *net_dev, struct ethtool_cm
 	return _errno;
 }
 
-static int __cold dpa_set_settings(struct net_device *net_dev, struct ethtool_cmd *et_cmd)
+static int __cold dpa_set_settings(struct net_device *net_dev,
+		struct ethtool_cmd *et_cmd)
 {
 	int			 _errno;
 	struct dpa_priv_s	*priv;
@@ -83,7 +85,8 @@ static int __cold dpa_set_settings(struct net_device *net_dev, struct ethtool_cm
 	return _errno;
 }
 
-static void __cold dpa_get_drvinfo(struct net_device *net_dev, struct ethtool_drvinfo *drvinfo)
+static void __cold dpa_get_drvinfo(struct net_device *net_dev,
+		struct ethtool_drvinfo *drvinfo)
 {
 	int		 _errno;
 
@@ -91,16 +94,18 @@ static void __cold dpa_get_drvinfo(struct net_device *net_dev, struct ethtool_dr
 		sizeof(drvinfo->driver) - 1)[sizeof(drvinfo->driver)-1] = 0;
 	strncpy(drvinfo->version, VERSION,
 		sizeof(drvinfo->driver) - 1)[sizeof(drvinfo->version)-1] = 0;
-	_errno = snprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version), "%X", 0);
+	_errno = snprintf(drvinfo->fw_version, sizeof(drvinfo->fw_version),
+			  "%X", 0);
 
-	if (unlikely(_errno >= sizeof(drvinfo->fw_version))) {	/* Truncated output */
+	if (unlikely(_errno >= sizeof(drvinfo->fw_version))) {
+		/* Truncated output */
 		netdev_notice(net_dev, "snprintf() = %d\n", _errno);
 	} else if (unlikely(_errno < 0)) {
 		netdev_warn(net_dev, "snprintf() = %d\n", _errno);
 		memset(drvinfo->fw_version, 0, sizeof(drvinfo->fw_version));
 	}
 	strncpy(drvinfo->bus_info, dev_name(net_dev->dev.parent->parent),
-		sizeof(drvinfo->bus_info) - 1)[sizeof(drvinfo->bus_info)-1] = 0;
+		sizeof(drvinfo->bus_info)-1)[sizeof(drvinfo->bus_info)-1] = 0;
 }
 
 uint32_t __cold dpa_get_msglevel(struct net_device *net_dev)
@@ -140,7 +145,8 @@ int __cold dpa_nway_reset(struct net_device *net_dev)
 	return _errno;
 }
 
-void __cold dpa_get_ringparam(struct net_device *net_dev, struct ethtool_ringparam *et_ringparam)
+void __cold dpa_get_ringparam(struct net_device *net_dev,
+		struct ethtool_ringparam *et_ringparam)
 {
 	et_ringparam->rx_max_pending	   = 0;
 	et_ringparam->rx_mini_max_pending  = 0;
@@ -153,7 +159,8 @@ void __cold dpa_get_ringparam(struct net_device *net_dev, struct ethtool_ringpar
 	et_ringparam->tx_pending	   = 0;
 }
 
-void __cold dpa_get_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *et_pauseparam)
+void __cold dpa_get_pauseparam(struct net_device *net_dev,
+		struct ethtool_pauseparam *et_pauseparam)
 {
 	struct dpa_priv_s	*priv;
 
@@ -173,7 +180,8 @@ void __cold dpa_get_pauseparam(struct net_device *net_dev, struct ethtool_pausep
 	et_pauseparam->tx_pause	= priv->mac_dev->tx_pause;
 }
 
-int __cold dpa_set_pauseparam(struct net_device *net_dev, struct ethtool_pauseparam *et_pauseparam)
+int __cold dpa_set_pauseparam(struct net_device *net_dev,
+		struct ethtool_pauseparam *et_pauseparam)
 {
 	struct dpa_priv_s	*priv;
 	int _errno;
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_1588.c b/drivers/net/ethernet/freescale/dpa/dpaa_1588.c
index 501eacf..efed56f 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_1588.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_1588.c
@@ -167,8 +167,7 @@ static int dpa_ptp_find_and_remove(struct dpa_ptp_circ_buf *ptp_buf,
 	return 0;
 }
 
-/*
- * Parse the PTP packets
+/* Parse the PTP packets
  *
  * The PTP header can be found in an IPv4 packet, IPv6 patcket or in
  * an IEEE802.3 ethernet frame. This function returns the position of
@@ -188,7 +187,8 @@ static u8 *dpa_ptp_parse_packet(struct sk_buff *skb, u16 *eth_type)
 
 #ifdef CONFIG_FSL_DPAA_ETH_SG_SUPPORT
 	/* when we can receive S/G frames we need to check the data we want to
-	 * access is in the linear skb buffer */
+	 * access is in the linear skb buffer
+	 */
 	if (!pskb_may_pull(skb, access_len))
 		return NULL;
 #endif
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c b/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c
index f84b19e..2a58724 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_debugfs.c
@@ -34,7 +34,7 @@
 #include <linux/fsl_qman.h>	/* struct qm_mcr_querycgr */
 #include <linux/debugfs.h>
 #include <asm/debug.h>
-#include <asm/smp.h>		/* get_hard_smp_processor_id() if !CONFIG_SMP */
+#include <linux/smp.h>		/* get_hard_smp_processor_id() if !CONFIG_SMP */
 #include "dpaa_debugfs.h"
 #include "dpaa_eth.h" /* struct dpa_priv_s, dpa_percpu_priv_s, dpa_bp */
 
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 5709765..683347e 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -52,7 +52,7 @@
 #include <linux/highmem.h>
 #include <linux/percpu.h>
 #include <linux/dma-mapping.h>
-#include <asm/smp.h>		/* get_hard_smp_processor_id() */
+#include <linux/smp.h>		/* get_hard_smp_processor_id() */
 #include <linux/fsl_bman.h>
 
 #include "fsl_fman.h"
@@ -135,8 +135,7 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks)
 }
 EXPORT_SYMBOL(fsl_dpaa_eth_set_hooks);
 
-/*
- * Checks whether the checksum field in Parse Results array is valid
+/* Checks whether the checksum field in Parse Results array is valid
  * (equals 0xFFFF) and increments the .cse counter otherwise
  */
 static inline void
@@ -147,14 +146,14 @@ dpa_csum_validation(const struct dpa_priv_s	*priv,
 	dma_addr_t addr = qm_fd_addr(fd);
 	struct dpa_bp *dpa_bp = priv->dpa_bp;
 	void *frm = phys_to_virt(addr);
-	t_FmPrsResult *parse_result;
+	fm_prs_result_t *parse_result;
 
 	if (unlikely(!frm))
 		return;
 
 	dma_unmap_single(dpa_bp->dev, addr, dpa_bp->size, DMA_BIDIRECTIONAL);
 
-	parse_result = (t_FmPrsResult *)(frm + DPA_RX_PRIV_DATA_SIZE);
+	parse_result = (fm_prs_result_t *)(frm + DPA_RX_PRIV_DATA_SIZE);
 
 	if (parse_result->cksum != DPA_CSUM_VALID)
 		percpu_priv->rx_errors.cse++;
@@ -221,8 +220,7 @@ static void _dpa_tx_error(struct net_device		*net_dev,
 	dev_kfree_skb(skb);
 }
 
-/*
- * Helper function to factor out frame validation logic on all Rx paths. Its
+/* Helper function to factor out frame validation logic on all Rx paths. Its
  * purpose is to extract from the Parse Results structure information about
  * the integrity of the frame, its checksum, the length of the parsed headers
  * and whether the frame is suitable for GRO.
@@ -236,20 +234,18 @@ static void _dpa_tx_error(struct net_device		*net_dev,
  * @hdr_size	will be written with a safe value, at least the size of the
  *		headers' length.
  */
-void __hot _dpa_process_parse_results(const t_FmPrsResult *parse_results,
+void __hot _dpa_process_parse_results(const fm_prs_result_t *parse_results,
 				      const struct qm_fd *fd,
 				      struct sk_buff *skb, int *use_gro)
 {
 	if (fd->status & FM_FD_STAT_L4CV) {
-		/*
-		 * The parser has run and performed L4 checksum validation.
+		/* The parser has run and performed L4 checksum validation.
 		 * We know there were no parser errors (and implicitly no
 		 * L4 csum error), otherwise we wouldn't be here.
 		 */
 		skb->ip_summed = CHECKSUM_UNNECESSARY;
 
-		/*
-		 * Don't go through GRO for certain types of traffic that
+		/* Don't go through GRO for certain types of traffic that
 		 * we know are not GRO-able, such as dgram-based protocols.
 		 * In the worst-case scenarios, such as small-pkt terminating
 		 * UDP, the extra GRO processing would be overkill.
@@ -263,8 +259,7 @@ void __hot _dpa_process_parse_results(const t_FmPrsResult *parse_results,
 		return;
 	}
 
-	/*
-	 * We're here because either the parser didn't run or the L4 checksum
+	/* We're here because either the parser didn't run or the L4 checksum
 	 * was not verified. This may include the case of a UDP frame with
 	 * checksum zero or an L4 proto other than TCP/UDP
 	 */
@@ -456,8 +451,7 @@ static void priv_ern(struct qman_portal	*portal,
 	percpu_priv->stats.tx_fifo_errors++;
 	count_ern(percpu_priv, msg);
 
-	/*
-	 * If we intended this buffer to go into the pool
+	/* If we intended this buffer to go into the pool
 	 * when the FM was done, we need to put it in
 	 * manually.
 	 */
@@ -583,8 +577,7 @@ static int dpa_private_netdev_init(struct device_node *dpa_node,
 	struct dpa_percpu_priv_s *percpu_priv;
 	const uint8_t *mac_addr;
 
-	/*
-	 * Although we access another CPU's private data here
+	/* Although we access another CPU's private data here
 	 * we do it at initialization so it is safe
 	 */
 	for_each_online_cpu(i) {
@@ -704,8 +697,7 @@ dpaa_eth_priv_probe(struct platform_device *_of_dev)
 	if (IS_ERR(dpa_bp))
 		return PTR_ERR(dpa_bp);
 
-	/*
-	 * Allocate this early, so we can store relevant information in
+	/* Allocate this early, so we can store relevant information in
 	 * the private area (needed by 1588 code in dpa_mac_probe)
 	 */
 	net_dev = alloc_etherdev_mq(sizeof(*priv), DPAA_ETH_TX_QUEUES);
@@ -791,8 +783,7 @@ dpaa_eth_priv_probe(struct platform_device *_of_dev)
 
 	dpa_fq_setup(priv, &private_fq_cbs, priv->mac_dev->port_dev[TX]);
 
-	/*
-	 * Create a congestion group for this netdev, with
+	/* Create a congestion group for this netdev, with
 	 * dynamically-allocated CGR ID.
 	 * Must be executed after probing the MAC, but before
 	 * assigning the egress FQs to the CGRs.
@@ -896,7 +887,8 @@ static int __init __cold dpa_load(void)
 {
 	int	 _errno;
 
-	printk(KERN_INFO KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
+	printk(KERN_INFO KBUILD_MODNAME ": "
+		DPA_DESCRIPTION " (" VERSION ")\n");
 
 	/* initialise dpaa_eth mirror values */
 	dpa_rx_extra_headroom = fm_get_rx_extra_headroom();
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index a677af2..611e5d8 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -61,8 +61,7 @@ extern int dpa_max_frm;
 #define dpa_get_rx_extra_headroom() dpa_rx_extra_headroom
 #define dpa_get_max_frm() dpa_max_frm
 
-/*
- * Currently we have the same max_frm on all interfaces, so these macros
+/* Currently we have the same max_frm on all interfaces, so these macros
  * don't get a net_device argument. This will change in the future.
  */
 #define dpa_get_min_mtu()	64
@@ -85,7 +84,7 @@ struct dpa_buffer_layout_s {
 };
 
 #define DPA_TX_PRIV_DATA_SIZE	16
-#define DPA_PARSE_RESULTS_SIZE sizeof(t_FmPrsResult)
+#define DPA_PARSE_RESULTS_SIZE sizeof(fm_prs_result_t)
 #define DPA_TIME_STAMP_SIZE 8
 #define DPA_HASH_RESULTS_SIZE 8
 #define DPA_RX_PRIV_DATA_SIZE   (DPA_TX_PRIV_DATA_SIZE + \
@@ -127,8 +126,7 @@ struct dpa_buffer_layout_s {
 	dpa_get_buffer_size(buffer_layout, (dpa_get_max_frm() - ETH_FCS_LEN))
 #endif /* CONFIG_FSL_DPAA_ETH_SG_SUPPORT */
 
-/*
- * Maximum size of a buffer for which recycling is allowed.
+/* Maximum size of a buffer for which recycling is allowed.
  * We need an upper limit such that forwarded skbs that get reallocated on Tx
  * aren't allowed to grow unboundedly. On the other hand, we need to make sure
  * that skbs allocated by us will not fail to be recycled due to their size.
@@ -165,8 +163,7 @@ enum dpaa_eth_hook_result {
 	 * perform any fd cleanup, nor update the interface statistics.
 	 */
 	DPAA_ETH_STOLEN,
-	/*
-	 * fd/skb was returned to the Ethernet driver for regular processing.
+	/* fd/skb was returned to the Ethernet driver for regular processing.
 	 * The hook is not allowed to, for instance, reallocate the skb (as if
 	 * by linearizing, copying, cloning or reallocating the headroom).
 	 */
@@ -180,19 +177,16 @@ typedef enum dpaa_eth_hook_result (*dpaa_eth_egress_hook_t)(
 typedef enum dpaa_eth_hook_result (*dpaa_eth_confirm_hook_t)(
 		struct net_device *net_dev, const struct qm_fd *fd, u32 fqid);
 
-/*
- * Various hooks used for unit-testing and/or fastpath optimizations.
+/* Various hooks used for unit-testing and/or fastpath optimizations.
  * Currently only one set of such hooks is supported.
  */
 struct dpaa_eth_hooks_s {
-	/*
-	 * Invoked on the Tx private path, immediately after receiving the skb
+	/* Invoked on the Tx private path, immediately after receiving the skb
 	 * from the stack.
 	 */
 	dpaa_eth_egress_hook_t	tx;
 
-	/*
-	 * Invoked on the Rx private path, right before passing the skb
+	/* Invoked on the Rx private path, right before passing the skb
 	 * up the stack. At that point, the packet's protocol id has already
 	 * been set. The skb's data pointer is now at the L3 header, and
 	 * skb->mac_header points to the L2 header. skb->len has been adjusted
@@ -212,8 +206,7 @@ struct dpaa_eth_hooks_s {
 
 void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 
-/*
- * Largest value that the FQD's OAL field can hold.
+/* Largest value that the FQD's OAL field can hold.
  * This is DPAA-1.x specific.
  * TODO: This rather belongs in fsl_qman.h
  */
@@ -225,24 +218,21 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 /* Default alignment for start of data in an Rx FD */
 #define DPA_FD_DATA_ALIGNMENT  16
 
-/*
- * Values for the L3R field of the FM Parse Results
+/* Values for the L3R field of the FM Parse Results
  */
 /* L3 Type field: First IP Present IPv4 */
 #define FM_L3_PARSE_RESULT_IPV4	0x8000
 /* L3 Type field: First IP Present IPv6 */
 #define FM_L3_PARSE_RESULT_IPV6	0x4000
 
-/*
- * Values for the L4R field of the FM Parse Results
+/* Values for the L4R field of the FM Parse Results
  * See $8.8.4.7.20 - L4 HXS - L4 Results from DPAA-Rev2 Reference Manual.
  */
 /* L4 Type field: UDP */
 #define FM_L4_PARSE_RESULT_UDP	0x40
 /* L4 Type field: TCP */
 #define FM_L4_PARSE_RESULT_TCP	0x20
-/*
- * This includes L4 checksum errors, but also other errors that the Hard Parser
+/* This includes L4 checksum errors, but also other errors that the Hard Parser
  * can detect, such as invalid combinations of TCP control flags, or bad UDP
  * lengths.
  */
@@ -250,8 +240,7 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 /* Check if the hardware parser has run */
 #define FM_L4_HXS_RUN		0xE0
 
-/*
- * FD status field indicating whether the FM Parser has attempted to validate
+/* FD status field indicating whether the FM Parser has attempted to validate
  * the L4 csum of the frame.
  * Note that having this bit set doesn't necessarily imply that the checksum
  * is valid. One would have to check the parse results to find that out.
@@ -261,24 +250,21 @@ void fsl_dpaa_eth_set_hooks(struct dpaa_eth_hooks_s *hooks);
 
 #define FM_FD_STAT_ERR_PHYSICAL	FM_PORT_FRM_ERR_PHYSICAL
 
-/*
- * Check if the FMan Hardware Parser has run for L4 protocols.
+/* Check if the FMan Hardware Parser has run for L4 protocols.
  *
- * @parse_result_ptr must be of type (t_FmPrsResult *).
+ * @parse_result_ptr must be of type (fm_prs_result_t *).
  */
 #define fm_l4_hxs_has_run(parse_result_ptr) \
 	((parse_result_ptr)->l4r & FM_L4_HXS_RUN)
-/*
- * Iff the FMan Hardware Parser has run for L4 protocols, check error status.
+/* Iff the FMan Hardware Parser has run for L4 protocols, check error status.
  *
- * @parse_result_ptr must be of type (t_FmPrsResult *).
+ * @parse_result_ptr must be of type (fm_prs_result_t *).
  */
 #define fm_l4_hxs_error(parse_result_ptr) \
 	((parse_result_ptr)->l4r & FM_L4_PARSE_ERROR)
-/*
- * Check if the parsed frame was found to be a TCP segment.
+/* Check if the parsed frame was found to be a TCP segment.
  *
- * @parse_result_ptr must be of type (t_FmPrsResult *).
+ * @parse_result_ptr must be of type (fm_prs_result_t *).
  */
 #define fm_l4_frame_is_tcp(parse_result_ptr) \
 	((parse_result_ptr)->l4r & FM_L4_PARSE_RESULT_TCP)
@@ -336,28 +322,24 @@ struct dpa_bp {
 	uint8_t				bpid;
 	struct device			*dev;
 	union {
-		/*
-		 * The buffer pools used for the private ports are initialized
+		/* The buffer pools used for the private ports are initialized
 		 * with target_count buffers for each CPU; at runtime the
 		 * number of buffers per CPU is constantly brought back to this
 		 * level
 		 */
 		int target_count;
-		/*
-		 * The configured value for the number of buffers in the pool,
+		/* The configured value for the number of buffers in the pool,
 		 * used for shared port buffer pools
 		 */
 		int config_count;
 	};
 	size_t				size;
 	bool				seed_pool;
-	/*
-	 * physical address of the contiguous memory used by the pool to store
+	/* physical address of the contiguous memory used by the pool to store
 	 * the buffers
 	 */
 	dma_addr_t			paddr;
-	/*
-	 * virtual address of the contiguous memory used by the pool to store
+	/* virtual address of the contiguous memory used by the pool to store
 	 * the buffers
 	 */
 	void				*vaddr;
@@ -407,8 +389,7 @@ struct dpa_percpu_priv_s {
 struct dpa_priv_s {
 	struct dpa_percpu_priv_s	*percpu_priv;
 	struct dpa_bp *dpa_bp;
-	/*
-	 * Store here the needed Tx headroom for convenience and speed
+	/* Store here the needed Tx headroom for convenience and speed
 	 * (even though it can be computed based on the fields of buf_layout)
 	 */
 	uint16_t tx_headroom;
@@ -485,7 +466,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev);
 struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 				   const struct qm_fd *fd);
-void __hot _dpa_process_parse_results(const t_FmPrsResult *parse_results,
+void __hot _dpa_process_parse_results(const fm_prs_result_t *parse_results,
 				      const struct qm_fd *fd,
 				      struct sk_buff *skb,
 				      int *use_gro);
@@ -495,8 +476,7 @@ void dpa_bp_add_8_bufs(const struct dpa_bp *dpa_bp, int cpu_id);
 int _dpa_bp_add_8_bufs(const struct dpa_bp *dpa_bp);
 #endif
 
-/*
- * Turn on HW checksum computation for this outgoing frame.
+/* Turn on HW checksum computation for this outgoing frame.
  * If the current protocol is not something we support in this regard
  * (or if the stack has already computed the SW checksum), we do nothing.
  *
@@ -511,8 +491,7 @@ int dpa_enable_tx_csum(struct dpa_priv_s *priv,
 
 static inline int dpaa_eth_napi_schedule(struct dpa_percpu_priv_s *percpu_priv)
 {
-	/*
-	 * In case of threaded ISR for RT enable kernel,
+	/* In case of threaded ISR for RT enable kernel,
 	 * in_irq() does not return appropriate value, so use
 	 * in_serving_softirq to distinguish softirq or irq context.
 	 */
@@ -601,7 +580,8 @@ static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
 
 #ifdef CONFIG_FSL_DPAA_TX_RECYCLE
 	/* Choose egress fq based on whether we want
-	 * to recycle the frame or not */
+	 * to recycle the frame or not
+	 */
 	if (fd->cmd & FM_FD_CMD_FCO)
 		egress_fq = priv->recycle_fqs[queue];
 	else
@@ -634,8 +614,7 @@ static inline int __hot dpa_xmit(struct dpa_priv_s *priv,
 
 #if defined CONFIG_FSL_DPAA_ETH_WQ_LEGACY
 #define DPA_NUM_WQS 8
-/*
- * Older WQ assignment: statically-defined FQIDs (such as PCDs) are assigned
+/* Older WQ assignment: statically-defined FQIDs (such as PCDs) are assigned
  * round-robin to all WQs available. Dynamically-allocated FQIDs go to WQ7.
  *
  * Not necessarily the best scheme, but worked fine so far, so we might want
@@ -646,8 +625,7 @@ static inline void _dpa_assign_wq(struct dpa_fq *fq)
 	fq->wq = fq->fqid ? fq->fqid % DPA_NUM_WQS : DPA_NUM_WQS - 1;
 }
 #elif defined CONFIG_FSL_DPAA_ETH_WQ_MULTI
-/*
- * Use multiple WQs for FQ assignment:
+/* Use multiple WQs for FQ assignment:
  *	- Tx Confirmation queues go to WQ1.
  *	- Rx Default, Tx and PCD queues go to WQ3 (no differentiation between
  *	  Rx and Tx traffic, or between Rx Default and Rx PCD frames).
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
index 55c3db7..c42cdb9 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_common.c
@@ -1501,7 +1501,7 @@ void count_ern(struct dpa_percpu_priv_s *percpu_priv,
 int dpa_enable_tx_csum(struct dpa_priv_s *priv,
 	struct sk_buff *skb, struct qm_fd *fd, char *parse_results)
 {
-	t_FmPrsResult *parse_result;
+	fm_prs_result_t *parse_result;
 	struct iphdr *iph;
 	struct ipv6hdr *ipv6h = NULL;
 	int l4_proto;
@@ -1518,7 +1518,7 @@ int dpa_enable_tx_csum(struct dpa_priv_s *priv,
 	/* Fill in some fields of the Parse Results array, so the FMan
 	 * can find them as if they came from the FMan Parser.
 	 */
-	parse_result = (t_FmPrsResult *)parse_results;
+	parse_result = (fm_prs_result_t *)parse_results;
 
 	/* If we're dealing with VLAN, get the real Ethernet type */
 	if (ethertype == ETH_P_8021Q) {
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c
index b3736cb..0e89aed 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_macless.c
@@ -378,7 +378,8 @@ static int __init __cold dpa_macless_load(void)
 {
 	int	 _errno;
 
-	printk(KERN_INFO KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
+	printk(KERN_INFO KBUILD_MODNAME ": "
+		DPA_DESCRIPTION " (" VERSION ")\n");
 
 	/* Initialize dpaa_eth mirror values */
 	dpa_rx_extra_headroom = fm_get_rx_extra_headroom();
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c
index 3bcb5b3..6ce1af5 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c
@@ -306,7 +306,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	dma_addr_t addr = qm_fd_addr(fd);
 	u32 fd_status = fd->status;
 	unsigned int skb_len;
-	t_FmPrsResult *parse_result;
+	fm_prs_result_t *parse_result;
 	int use_gro = net_dev->features & NETIF_F_GRO;
 
 	skbh = (struct sk_buff **)phys_to_virt(addr);
@@ -361,7 +361,7 @@ void __hot _dpa_rx(struct net_device *net_dev,
 	skb_len = skb->len;
 
 	/* Validate the skb csum and figure out whether GRO is appropriate */
-	parse_result = (t_FmPrsResult *)((u8 *)skbh + DPA_RX_PRIV_DATA_SIZE);
+	parse_result = (fm_prs_result_t *)((u8 *)skbh + DPA_RX_PRIV_DATA_SIZE);
 	_dpa_process_parse_results(parse_result, fd, skb, &use_gro);
 
 #ifdef CONFIG_FSL_DPAA_TS
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c
index 49636f4..adb1125 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_proxy.c
@@ -159,7 +159,8 @@ static int __init __cold dpa_proxy_load(void)
 {
 	int	 _errno;
 
-	printk(KERN_INFO KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
+	printk(KERN_INFO KBUILD_MODNAME ": "
+		DPA_DESCRIPTION " (" VERSION ")\n");
 
 	/* Initialize dpaa_eth mirror values */
 	dpa_rx_extra_headroom = fm_get_rx_extra_headroom();
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index aa6083e..cc76dda 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -98,8 +98,7 @@ int _dpa_bp_add_8_bufs(const struct dpa_bp *dpa_bp)
 	}
 
 release_bufs:
-	/*
-	 * Release the buffers. In case bman is busy, keep trying
+	/* Release the buffers. In case bman is busy, keep trying
 	 * until successful. bman_release() is guaranteed to succeed
 	 * in a reasonable amount of time
 	 */
@@ -113,8 +112,7 @@ bail_out:
 	WARN_ONCE(1, "Memory allocation failure on Rx\n");
 
 	bm_buffer_set64(&bmb[i], 0);
-	/*
-	 * Avoid releasing a completely null buffer; bman_release() requires
+	/* Avoid releasing a completely null buffer; bman_release() requires
 	 * at least one buffer.
 	 */
 	if (likely(i))
@@ -140,8 +138,7 @@ int dpa_bp_priv_seed(struct dpa_bp *dpa_bp)
 	for_each_online_cpu(i) {
 		int j;
 
-		/*
-		 * Although we access another CPU's counters here
+		/* Although we access another CPU's counters here
 		 * we do it at boot time so it is safe
 		 */
 		for (j = 0; j < dpa_bp->config_count; j += 8)
@@ -150,8 +147,7 @@ int dpa_bp_priv_seed(struct dpa_bp *dpa_bp)
 	return 0;
 }
 
-/*
- * Add buffers/(pages) for Rx processing whenever bpool count falls below
+/* Add buffers/(pages) for Rx processing whenever bpool count falls below
  * REFILL_THRESHOLD.
  */
 int dpaa_eth_refill_bpools(struct dpa_percpu_priv_s *percpu_priv)
@@ -211,8 +207,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 	nr_frags = skb_shinfo(skb)->nr_frags;
 
 	if (fd->format == qm_fd_sg) {
-		/*
-		 * The sgt buffer has been allocated with netdev_alloc_frag(),
+		/* The sgt buffer has been allocated with netdev_alloc_frag(),
 		 * it's from lowmem.
 		 */
 		sgt = phys_to_virt(addr + dpa_fd_offset(fd));
@@ -243,8 +238,7 @@ struct sk_buff *_dpa_cleanup_tx_fd(const struct dpa_priv_s *priv,
 					sgt[i].length, dma_dir);
 		}
 
-		/*
-		 * TODO: dpa_bp_recycle_frag() ?
+		/* TODO: dpa_bp_recycle_frag() ?
 		 * We could put these in the pool, since we allocated them
 		 * and we know they're not used by anyone else
 		 */
@@ -326,8 +320,7 @@ static bool dpa_buf_is_recyclable(struct sk_buff *skb,
 #endif /* CONFIG_FSL_DPAA_TS */
 
 
-/*
- * Build a linear skb around the received buffer.
+/* Build a linear skb around the received buffer.
  * We are guaranteed there is enough room at the end of the data buffer to
  * accomodate the shared info area of the skb.
  */
@@ -338,7 +331,7 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	ssize_t fd_off = dpa_fd_offset(fd);
 	void *vaddr;
 	struct dpa_bp *dpa_bp = priv->dpa_bp;
-	const t_FmPrsResult *parse_results;
+	const fm_prs_result_t *parse_results;
 	struct sk_buff *skb = NULL;
 
 	vaddr = phys_to_virt(addr);
@@ -368,7 +361,8 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 	skb_put(skb, dpa_fd_length(fd));
 
 	/* Peek at the parse results for csum validation */
-	parse_results = (const t_FmPrsResult *)(vaddr + DPA_RX_PRIV_DATA_SIZE);
+	parse_results = (const fm_prs_result_t *)(vaddr +
+				DPA_RX_PRIV_DATA_SIZE);
 	_dpa_process_parse_results(parse_results, fd, skb, use_gro);
 
 #ifdef CONFIG_FSL_DPAA_TS
@@ -380,8 +374,7 @@ static struct sk_buff *__hot contig_fd_to_skb(const struct dpa_priv_s *priv,
 }
 
 
-/*
- * Build an skb with the data of the first S/G entry in the linear portion and
+/* Build an skb with the data of the first S/G entry in the linear portion and
  * the rest of the frame as skb fragments.
  *
  * The page fragment holding the S/G Table is recycled here.
@@ -399,7 +392,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 	int frag_offset, frag_len;
 	int page_offset;
 	int i;
-	const t_FmPrsResult *parse_results;
+	const fm_prs_result_t *parse_results;
 	struct sk_buff *skb = NULL;
 	int *count_ptr;
 
@@ -455,7 +448,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 			 * Context in the buffer containing the sgt.
 			 * Inspect the parse results before anything else.
 			 */
-			parse_results = (const t_FmPrsResult *)(vaddr +
+			parse_results = (const fm_prs_result_t *)(vaddr +
 						DPA_RX_PRIV_DATA_SIZE);
 			_dpa_process_parse_results(parse_results, fd, skb,
 						   use_gro);
@@ -469,8 +462,7 @@ static struct sk_buff *__hot sg_fd_to_skb(const struct dpa_priv_s *priv,
 		} else {
 			dma_unmap_single(dpa_bp->dev, sg_addr, dpa_bp->size,
 				DMA_BIDIRECTIONAL);
-			/*
-			 * Not the first S/G entry; all data from buffer will
+			/* Not the first S/G entry; all data from buffer will
 			 * be added in an skb fragment; fragment index is offset
 			 * by one since first S/G entry was incorporated in the
 			 * linear part of the skb.
@@ -652,8 +644,7 @@ static int __hot skb_to_contig_fd(struct dpa_priv_s *priv,
 no_recycle:
 	*skbh = skb;
 
-	/*
-	 * Enable L3/L4 hardware checksum computation.
+	/* Enable L3/L4 hardware checksum computation.
 	 *
 	 * We must do this before dma_map_single(DMA_TO_DEVICE), because we may
 	 * need to write into the skb.
@@ -711,8 +702,7 @@ static int __hot skb_to_sg_fd(struct dpa_priv_s *priv,
 		return -ENOMEM;
 	}
 
-	/*
-	 * Enable L3/L4 hardware checksum computation.
+	/* Enable L3/L4 hardware checksum computation.
 	 *
 	 * We must do this before dma_map_single(DMA_TO_DEVICE), because we may
 	 * need to write into the skb.
@@ -827,8 +817,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
 #endif /* CONFIG_FSL_DPAA_TS */
 
-	/*
-	 * MAX_SKB_FRAGS is larger than our DPA_SGT_MAX_ENTRIES; make sure
+	/* MAX_SKB_FRAGS is larger than our DPA_SGT_MAX_ENTRIES; make sure
 	 * we don't feed FMan with more fragments than it supports.
 	 * Btw, we're using the first sgt entry to store the linear part of
 	 * the skb, so we're one extra frag short.
@@ -839,8 +828,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 		err = skb_to_sg_fd(priv, skb, &fd);
 		percpu_priv->tx_frag_skbuffs++;
 	} else {
-		/*
-		 * Make sure we have enough headroom to accomodate private
+		/* Make sure we have enough headroom to accomodate private
 		 * data, parse results, etc. Normally this shouldn't happen if
 		 * we're here via the standard kernel stack.
 		 */
@@ -857,8 +845,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 			skb = skb_new;
 		}
 
-		/*
-		 * We're going to store the skb backpointer at the beginning
+		/* We're going to store the skb backpointer at the beginning
 		 * of the data buffer, so we need a privately owned skb
 		 */
 
@@ -869,8 +856,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 			skb = nskb;
 			/* skb_copy() has now linearized the skbuff. */
 		} else if (unlikely(nonlinear)) {
-			/*
-			 * We are here because the egress skb contains
+			/* We are here because the egress skb contains
 			 * more fragments than we support. In this case,
 			 * we have no choice but to linearize it ourselves.
 			 */
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
index 0280088..c0dcee8 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_shared.c
@@ -454,7 +454,7 @@ int __hot dpa_shared_tx(struct sk_buff *skb, struct net_device *net_dev)
 	int queue_mapping;
 	int err;
 	void *dpa_bp_vaddr;
-	t_FmPrsResult parse_results;
+	fm_prs_result_t parse_results;
 
 	priv = netdev_priv(net_dev);
 	percpu_priv = per_cpu_ptr(priv->percpu_priv, smp_processor_id());
@@ -704,7 +704,8 @@ dpaa_eth_shared_probe(struct platform_device *_of_dev)
 
 	dpaa_eth_sysfs_init(&net_dev->dev);
 
-	printk(KERN_INFO "fsl_dpa_shared: Probed shared interface %s\n", net_dev->name);
+	printk(KERN_INFO "fsl_dpa_shared: Probed shared interface %s\n",
+			net_dev->name);
 
 	return 0;
 
@@ -757,7 +758,8 @@ static int __init __cold dpa_shared_load(void)
 {
 	int	 _errno;
 
-	printk(KERN_INFO KBUILD_MODNAME ": " DPA_DESCRIPTION " (" VERSION ")\n");
+	printk(KERN_INFO KBUILD_MODNAME ": "
+		DPA_DESCRIPTION " (" VERSION ")\n");
 
 	/* Initialize dpaa_eth mirror values */
 	dpa_rx_extra_headroom = fm_get_rx_extra_headroom();
diff --git a/drivers/net/ethernet/freescale/dpa/mac-api.c b/drivers/net/ethernet/freescale/dpa/mac-api.c
index 2ea6a72..328d55a 100644
--- a/drivers/net/ethernet/freescale/dpa/mac-api.c
+++ b/drivers/net/ethernet/freescale/dpa/mac-api.c
@@ -65,14 +65,12 @@ const size_t	 mac_sizeof_priv[] = {
 	[MEMAC] = sizeof(struct mac_priv_s)
 };
 
-static const e_EnetMode _100[] =
-{
+static const enet_mode_t _100[] = {
 	[PHY_INTERFACE_MODE_MII]	= e_ENET_MODE_MII_100,
 	[PHY_INTERFACE_MODE_RMII]	= e_ENET_MODE_RMII_100
 };
 
-static const e_EnetMode _1000[] =
-{
+static const enet_mode_t _1000[] = {
 	[PHY_INTERFACE_MODE_GMII]	= e_ENET_MODE_GMII_1000,
 	[PHY_INTERFACE_MODE_SGMII]	= e_ENET_MODE_SGMII_1000,
 	[PHY_INTERFACE_MODE_TBI]	= e_ENET_MODE_TBI_1000,
@@ -83,7 +81,7 @@ static const e_EnetMode _1000[] =
 	[PHY_INTERFACE_MODE_RTBI]	= e_ENET_MODE_RTBI_1000
 };
 
-static e_EnetMode __cold __attribute__((nonnull))
+static enet_mode_t __cold __attribute__((nonnull))
 macdev2enetinterface(const struct mac_device *mac_dev)
 {
 	switch (mac_dev->max_speed) {
@@ -98,7 +96,7 @@ macdev2enetinterface(const struct mac_device *mac_dev)
 	}
 }
 
-static void mac_exception(t_Handle _mac_dev, e_FmMacExceptions exception)
+static void mac_exception(handle_t _mac_dev, e_FmMacExceptions exception)
 {
 	struct mac_device	*mac_dev;
 
@@ -108,7 +106,8 @@ static void mac_exception(t_Handle _mac_dev, e_FmMacExceptions exception)
 		/* don't flag RX FIFO after the first */
 		fm_mac_set_exception(mac_dev->get_mac_handle(mac_dev),
 		    e_FM_MAC_EX_10G_RX_FIFO_OVFL, false);
-		printk(KERN_ERR "10G MAC got RX FIFO Error = %x\n", exception);
+		dev_err(mac_dev->dev, "10G MAC got RX FIFO Error = %x\n",
+				exception);
 	}
 
 	dev_dbg(mac_dev->dev, "%s:%s() -> %d\n", KBUILD_BASENAME".c", __func__,
@@ -130,7 +129,7 @@ static int __cold init(struct mac_device *mac_dev)
 	memcpy(&param.addr, mac_dev->addr, min(sizeof(param.addr),
 		sizeof(mac_dev->addr)));
 	param.macId		= mac_dev->cell_index;
-	param.h_Fm		= (t_Handle)mac_dev->fm;
+	param.h_Fm		= (handle_t)mac_dev->fm;
 	param.mdioIrq		= NO_IRQ;
 	param.f_Exception	= mac_exception;
 	param.f_Event		= mac_exception;
@@ -161,8 +160,7 @@ static int __cold init(struct mac_device *mac_dev)
 				mac_dev->half_duplex);
 		if (unlikely(_errno < 0))
 			goto _return_fm_mac_free;
-	}
-	else  {
+	} else {
 		_errno = fm_mac_config_reset_on_init(priv->fm_mac, true);
 		if (unlikely(_errno < 0))
 			goto _return_fm_mac_free;
@@ -221,7 +219,7 @@ static int __cold memac_init(struct mac_device *mac_dev)
 	param.enetMode	= macdev2enetinterface(mac_dev);
 	memcpy(&param.addr, mac_dev->addr, sizeof(mac_dev->addr));
 	param.macId		= mac_dev->cell_index;
-	param.h_Fm		= (t_Handle)mac_dev->fm;
+	param.h_Fm		= (handle_t)mac_dev->fm;
 	param.mdioIrq		= NO_IRQ;
 	param.f_Exception	= mac_exception;
 	param.f_Event		= mac_exception;
@@ -284,12 +282,12 @@ static int __cold stop(struct mac_device *mac_dev)
 
 static int __cold set_multi(struct net_device *net_dev)
 {
-	struct dpa_priv_s       *priv;
-	struct mac_device       *mac_dev;
-	struct mac_priv_s 	*mac_priv;
+	struct dpa_priv_s	*priv;
+	struct mac_device	*mac_dev;
+	struct mac_priv_s	*mac_priv;
 	struct mac_address	*old_addr, *tmp;
 	struct netdev_hw_addr	*ha;
-	int 			 _errno;
+	int			_errno;
 
 	priv = netdev_priv(net_dev);
 	mac_dev = priv->mac_dev;
@@ -446,9 +444,8 @@ static int __cold uninit(struct fm_mac_dev *fm_mac_dev)
 	_errno = fm_mac_disable(fm_mac_dev);
 	__errno = fm_mac_free(fm_mac_dev);
 
-	if (unlikely(__errno < 0)) {
+	if (unlikely(__errno < 0))
 		_errno = __errno;
-	}
 
 	return _errno;
 }
diff --git a/drivers/net/ethernet/freescale/dpa/mac.c b/drivers/net/ethernet/freescale/dpa/mac.c
index ed5d5fe..1782ab7 100644
--- a/drivers/net/ethernet/freescale/dpa/mac.c
+++ b/drivers/net/ethernet/freescale/dpa/mac.c
@@ -53,8 +53,7 @@
 	| SUPPORTED_Autoneg \
 	| SUPPORTED_MII)
 
-static const char phy_str[][11] =
-{
+static const char phy_str[][11] = {
 	[PHY_INTERFACE_MODE_MII]	= "mii",
 	[PHY_INTERFACE_MODE_GMII]	= "gmii",
 	[PHY_INTERFACE_MODE_SGMII]	= "sgmii",
@@ -79,8 +78,7 @@ static phy_interface_t __pure __attribute__((nonnull)) str2phy(const char *str)
 	return PHY_INTERFACE_MODE_MII;
 }
 
-static const uint16_t phy2speed[] =
-{
+static const uint16_t phy2speed[] = {
 	[PHY_INTERFACE_MODE_MII]	= SPEED_100,
 	[PHY_INTERFACE_MODE_GMII]	= SPEED_1000,
 	[PHY_INTERFACE_MODE_SGMII]	= SPEED_1000,
@@ -95,7 +93,8 @@ static const uint16_t phy2speed[] =
 };
 
 static struct mac_device * __cold
-alloc_macdev(struct device *dev, size_t sizeof_priv, void (*setup)(struct mac_device *mac_dev))
+alloc_macdev(struct device *dev, size_t sizeof_priv,
+		void (*setup)(struct mac_device *mac_dev))
 {
 	struct mac_device	*mac_dev;
 
@@ -144,16 +143,18 @@ static int __cold mac_probe(struct platform_device *_of_dev)
 	const char		*char_prop;
 	const phandle		*phandle_prop;
 	const uint32_t		*uint32_prop;
-        const struct of_device_id *match;
+	const struct of_device_id *match;
 
 	dev = &_of_dev->dev;
 	mac_node = dev->of_node;
 
-        match = of_match_device(mac_match, dev);
-        if (!match)
-                return -EINVAL;
+	match = of_match_device(mac_match, dev);
+	if (!match)
+		return -EINVAL;
 
-	for (i = 0; i < ARRAY_SIZE(mac_match) - 1 && match != mac_match + i; i++);
+	for (i = 0; i < ARRAY_SIZE(mac_match) - 1 && match != mac_match + i;
+			i++)
+		;
 	BUG_ON(i >= ARRAY_SIZE(mac_match) - 1);
 
 	mac_dev = alloc_macdev(dev, mac_sizeof_priv[i], mac_setup[i]);
@@ -218,15 +219,15 @@ static int __cold mac_probe(struct platform_device *_of_dev)
 	}
 
 	mac_dev->vaddr = devm_ioremap(dev, mac_dev->res->start,
-				      mac_dev->res->end + 1 - mac_dev->res->start);
+				      mac_dev->res->end + 1
+				      - mac_dev->res->start);
 	if (unlikely(mac_dev->vaddr == NULL)) {
 		dev_err(dev, "devm_ioremap() failed\n");
 		_errno = -EIO;
 		goto _return_dev_set_drvdata;
 	}
 
-	/*
-	 * XXX: Warning, future versions of Linux will most likely not even
+	/* XXX: Warning, future versions of Linux will most likely not even
 	 * call the driver code to allow us to override the TBIPA value,
 	 * we'll need to address this when we move to newer kernel rev
 	 */
@@ -417,8 +418,7 @@ static int __init __cold mac_load(void)
 
 	_errno = platform_driver_register(&mac_driver);
 	if (unlikely(_errno < 0)) {
-		pr_err(KBUILD_MODNAME ": %s:%hu:%s(): " \
-			"platform_driver_register() = %d\n",
+		pr_err(KBUILD_MODNAME ": %s:%hu:%s(): platform_driver_register() = %d\n",
 			   KBUILD_BASENAME".c", __LINE__, __func__, _errno);
 		goto _return;
 	}
diff --git a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
index 795f6b2..2933f75 100755
--- a/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
+++ b/drivers/net/ethernet/freescale/fman/inc/flib/fsl_fman.h
@@ -105,6 +105,10 @@ enum fman_dma_cache_option {
 	FMAN_DMA_STASH = 1         /**< Cacheable and Allocate (Stashing on) */
 };
 
+typedef struct t_FmPrsResult fm_prs_result_t;
+typedef enum e_EnetMode enet_mode_t;
+typedef t_Handle handle_t;
+
 /* sizes */
 #define CAPWAP_FRAG_EXTRA_SPACE                 32
 #define OFFSET_UNITS                            16
-- 
1.9.1

