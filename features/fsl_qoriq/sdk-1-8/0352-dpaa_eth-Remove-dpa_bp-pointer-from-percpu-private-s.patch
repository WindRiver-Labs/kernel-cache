From e373513e84895655261987ddec426a2e5f754051 Mon Sep 17 00:00:00 2001
From: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Date: Wed, 21 Aug 2013 15:52:22 +0300
Subject: [PATCH 352/987] dpaa_eth: Remove dpa_bp pointer from percpu private
 structure

[Original patch taken from QorIQ-SDK-V1.6-SOURCE-20140619-yocto.iso]

The reference to the buffer pool can be just as easily obtained from
the netdev private structure, so do that and reduce the size of the percpu
private struct.

Signed-off-by: Ioana Radulescu <ruxandra.radulescu@freescale.com>
Change-Id: I78aea782014b863994585beccac52567b242a72e
Reviewed-on: http://git.am.freescale.net:8181/4194
Tested-by: Review Code-CDREVIEW <CDREVIEW@freescale.com>
Reviewed-by: Bucur Madalin-Cristian-B32716 <madalin.bucur@freescale.com>
Reviewed-by: Rivera Jose-B46482 <German.Rivera@freescale.com>
---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.c        | 5 ++---
 drivers/net/ethernet/freescale/dpa/dpaa_eth.h        | 3 +--
 drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c | 3 +--
 drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c     | 7 +++----
 4 files changed, 7 insertions(+), 11 deletions(-)

diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
index 2981467..8e8bea2 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.c
@@ -335,7 +335,7 @@ priv_rx_error_dqrr(struct qman_portal		*portal,
 	if (dpaa_eth_napi_schedule(percpu_priv))
 		return qman_cb_dqrr_stop;
 
-	if (unlikely(dpaa_eth_refill_bpools(percpu_priv)))
+	if (unlikely(dpaa_eth_refill_bpools(priv->dpa_bp)))
 		/* Unable to refill the buffer pool due to insufficient
 		 * system memory. Just release the frame back into the pool,
 		 * otherwise we'll soon end up with an empty buffer pool.
@@ -371,7 +371,7 @@ priv_rx_default_dqrr(struct qman_portal		*portal,
 
 	/* Vale of plenty: make sure we didn't run out of buffers */
 
-	if (unlikely(dpaa_eth_refill_bpools(percpu_priv)))
+	if (unlikely(dpaa_eth_refill_bpools(priv->dpa_bp)))
 		/* Unable to refill the buffer pool due to insufficient
 		 * system memory. Just release the frame back into the pool,
 		 * otherwise we'll soon end up with an empty buffer pool.
@@ -820,7 +820,6 @@ dpaa_eth_priv_probe(struct platform_device *_of_dev)
 	for_each_online_cpu(i) {
 		percpu_priv = per_cpu_ptr(priv->percpu_priv, i);
 		memset(percpu_priv, 0, sizeof(*percpu_priv));
-		percpu_priv->dpa_bp = priv->dpa_bp;
 	}
 
 	err = dpa_private_netdev_init(dpa_node, net_dev);
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
index 344fa87..f33ff0a 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth.h
@@ -376,7 +376,6 @@ struct dpa_ern_cnt {
 
 struct dpa_percpu_priv_s {
 	struct net_device *net_dev;
-	struct dpa_bp *dpa_bp;
 	struct napi_struct napi;
 	u64 in_interrupt;
 	u64 tx_returned;
@@ -459,7 +458,7 @@ struct fm_port_fqs {
 
 /* functions with different implementation for SG and non-SG: */
 int dpa_bp_priv_seed(struct dpa_bp *dpa_bp);
-int dpaa_eth_refill_bpools(struct dpa_percpu_priv_s *percpu_priv);
+int dpaa_eth_refill_bpools(struct dpa_bp *dpa_bp);
 void __hot _dpa_rx(struct net_device *net_dev,
 		const struct dpa_priv_s *priv,
 		struct dpa_percpu_priv_s *percpu_priv,
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c
index 1d67edb..b4d26ce 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_non_sg.c
@@ -162,9 +162,8 @@ void dpa_bp_priv_non_sg_seed(struct dpa_bp *dpa_bp)
 /* Add buffers/(skbuffs) for Rx processing whenever bpool count falls below
  * REFILL_THRESHOLD.
  */
-int dpaa_eth_refill_bpools(struct dpa_percpu_priv_s *percpu_priv)
+int dpaa_eth_refill_bpools(struct dpa_bp* dpa_bp)
 {
-	const struct dpa_bp *dpa_bp = percpu_priv->dpa_bp;
 	int *countptr = __this_cpu_ptr(dpa_bp->percpu_count);
 	int count = *countptr;
 	/* this function is called in softirq context;
diff --git a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
index 5b9ed7d..eb300b4 100644
--- a/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
+++ b/drivers/net/ethernet/freescale/dpa/dpaa_eth_sg.c
@@ -150,10 +150,9 @@ int dpa_bp_priv_seed(struct dpa_bp *dpa_bp)
 /* Add buffers/(pages) for Rx processing whenever bpool count falls below
  * REFILL_THRESHOLD.
  */
-int dpaa_eth_refill_bpools(struct dpa_percpu_priv_s *percpu_priv)
+int dpaa_eth_refill_bpools(struct dpa_bp *dpa_bp)
 {
-	const struct dpa_bp *dpa_bp = percpu_priv->dpa_bp;
-	int *countptr = __this_cpu_ptr(percpu_priv->dpa_bp->percpu_count);
+	int *countptr = __this_cpu_ptr(dpa_bp->percpu_count);
 	int count = *countptr;
 	int new_bufs;
 
@@ -802,7 +801,7 @@ int __hot dpa_tx(struct sk_buff *skb, struct net_device *net_dev)
 	/* Non-migratable context, safe to use __this_cpu_ptr */
 	percpu_priv = __this_cpu_ptr(priv->percpu_priv);
 	percpu_stats = &percpu_priv->stats;
-	countptr = __this_cpu_ptr(percpu_priv->dpa_bp->percpu_count);
+	countptr = __this_cpu_ptr(priv->dpa_bp->percpu_count);
 
 	clear_fd(&fd);
 
-- 
1.9.1

